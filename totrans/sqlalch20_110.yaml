- en: SQLite
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SQLite
- en: 原文：[https://docs.sqlalchemy.org/en/20/dialects/sqlite.html](https://docs.sqlalchemy.org/en/20/dialects/sqlite.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://docs.sqlalchemy.org/en/20/dialects/sqlite.html](https://docs.sqlalchemy.org/en/20/dialects/sqlite.html)
- en: Support for the SQLite database.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 对 SQLite 数据库的支持。
- en: The following table summarizes current support levels for database release versions.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格总结了数据库发布版本的当前支持水平。
- en: '**Supported SQLite versions**'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '**支持的 SQLite 版本**'
- en: '| Support type | Versions |'
  id: totrans-5
  prefs: []
  type: TYPE_TB
  zh: '| 支持类型 | 版本 |'
- en: '| --- | --- |'
  id: totrans-6
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| [Fully tested in CI](index.html#term-Fully-tested-in-CI) | 3.36.0 |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '| [CI 中完全测试过](index.html#term-Fully-tested-in-CI) | 3.36.0 |'
- en: '| [Normal support](index.html#term-Normal-support) | 3.12+ |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '| [普通支持](index.html#term-Normal-support) | 3.12+ |'
- en: '| [Best effort](index.html#term-Best-effort) | 3.7.16+ |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '| [尽力而为](index.html#term-Best-effort) | 3.7.16+ |'
- en: DBAPI Support
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DBAPI 支持
- en: The following dialect/DBAPI options are available. Please refer to individual
    DBAPI sections for connect information.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 可用以下方言/DBAPI 选项。有关连接信息，请参阅各个 DBAPI 部分。
- en: '[pysqlite](#module-sqlalchemy.dialects.sqlite.pysqlite)'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[pysqlite](#module-sqlalchemy.dialects.sqlite.pysqlite)'
- en: '[aiosqlite](#module-sqlalchemy.dialects.sqlite.aiosqlite)'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[aiosqlite](#module-sqlalchemy.dialects.sqlite.aiosqlite)'
- en: '[pysqlcipher](#module-sqlalchemy.dialects.sqlite.pysqlcipher)'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[pysqlcipher](#module-sqlalchemy.dialects.sqlite.pysqlcipher)'
- en: '## Date and Time Types'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '## 日期和时间类型'
- en: SQLite does not have built-in DATE, TIME, or DATETIME types, and pysqlite does
    not provide out of the box functionality for translating values between Python
    datetime objects and a SQLite-supported format. SQLAlchemy’s own [`DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime
    "sqlalchemy.types.DateTime") and related types provide date formatting and parsing
    functionality when SQLite is used. The implementation classes are [`DATETIME`](#sqlalchemy.dialects.sqlite.DATETIME
    "sqlalchemy.dialects.sqlite.DATETIME"), [`DATE`](#sqlalchemy.dialects.sqlite.DATE
    "sqlalchemy.dialects.sqlite.DATE") and [`TIME`](#sqlalchemy.dialects.sqlite.TIME
    "sqlalchemy.dialects.sqlite.TIME"). These types represent dates and times as ISO
    formatted strings, which also nicely support ordering. There’s no reliance on
    typical “libc” internals for these functions so historical dates are fully supported.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 没有内置的 DATE、TIME 或 DATETIME 类型，而 pysqlite 也没有提供将值在 Python datetime 对象和
    SQLite 支持的格式之间转换的开箱即用功能。当使用 SQLite 时，SQLAlchemy 自己的 [`DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime
    "sqlalchemy.types.DateTime") 和相关类型提供日期格式化和解析功能。实现类是 [`DATETIME`](#sqlalchemy.dialects.sqlite.DATETIME
    "sqlalchemy.dialects.sqlite.DATETIME")、[`DATE`](#sqlalchemy.dialects.sqlite.DATE
    "sqlalchemy.dialects.sqlite.DATE") 和 [`TIME`](#sqlalchemy.dialects.sqlite.TIME
    "sqlalchemy.dialects.sqlite.TIME")。这些类型将日期和时间表示为 ISO 格式的字符串，也很好地支持排序。对于这些函数，不依赖于典型的“libc”内部，因此完全支持历史日期。
- en: Ensuring Text affinity
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 确保文本亲和性
- en: The DDL rendered for these types is the standard `DATE`, `TIME` and `DATETIME`
    indicators. However, custom storage formats can also be applied to these types.
    When the storage format is detected as containing no alpha characters, the DDL
    for these types is rendered as `DATE_CHAR`, `TIME_CHAR`, and `DATETIME_CHAR`,
    so that the column continues to have textual affinity.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型的 DDL 渲染是标准的 `DATE`、`TIME` 和 `DATETIME` 指示符。然而，这些类型也可以应用自定义存储格式。当检测到存储格式不包含字母字符时，这些类型的
    DDL 被渲染为 `DATE_CHAR`、`TIME_CHAR` 和 `DATETIME_CHAR`，以便列继续具有文本亲和性。
- en: See also
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Type Affinity](https://www.sqlite.org/datatype3.html#affinity) - in the SQLite
    documentation  ## SQLite Auto Incrementing Behavior'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '[类型亲和性](https://www.sqlite.org/datatype3.html#affinity) - SQLite 文档中的说明  ##
    SQLite 自增行为'
- en: 'Background on SQLite’s autoincrement is at: [https://sqlite.org/autoinc.html](https://sqlite.org/autoinc.html)'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 的自动增量背景资料位于：[https://sqlite.org/autoinc.html](https://sqlite.org/autoinc.html)
- en: 'Key concepts:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 关键概念：
- en: SQLite has an implicit “auto increment” feature that takes place for any non-composite
    primary-key column that is specifically created using “INTEGER PRIMARY KEY” for
    the type + primary key.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQLite 对于任何非复合主键列都有一个隐式的“自动增量”功能，只要使用“INTEGER PRIMARY KEY”类型 + 主键明确创建该列即可。
- en: SQLite also has an explicit “AUTOINCREMENT” keyword, that is **not** equivalent
    to the implicit autoincrement feature; this keyword is not recommended for general
    use. SQLAlchemy does not render this keyword unless a special SQLite-specific
    directive is used (see below). However, it still requires that the column’s type
    is named “INTEGER”.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQLite 还有一个显式的“AUTOINCREMENT”关键字，它与隐式自增功能**不**等同；不推荐一般使用此关键字。除非使用了特殊的 SQLite
    特定指令（见下文），否则 SQLAlchemy 不会渲染此关键字。但仍然要求列的类型命名为“INTEGER”。
- en: Using the AUTOINCREMENT Keyword
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 AUTOINCREMENT 关键字
- en: 'To specifically render the AUTOINCREMENT keyword on the primary key column
    when rendering DDL, add the flag `sqlite_autoincrement=True` to the Table construct:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 要在渲染 DDL 时特别呈现主键列上的 AUTOINCREMENT 关键字，将标志`sqlite_autoincrement=True`添加到 Table
    构造中：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Allowing autoincrement behavior SQLAlchemy types other than Integer/INTEGER
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 允许自动增量行为的 SQLAlchemy 类型不仅限于 Integer/INTEGER
- en: SQLite’s typing model is based on naming conventions. Among other things, this
    means that any type name which contains the substring `"INT"` will be determined
    to be of “integer affinity”. A type named `"BIGINT"`, `"SPECIAL_INT"` or even
    `"XYZINTQPR"`, will be considered by SQLite to be of “integer” affinity. However,
    **the SQLite autoincrement feature, whether implicitly or explicitly enabled,
    requires that the name of the column’s type is exactly the string “INTEGER”**.
    Therefore, if an application uses a type like [`BigInteger`](../core/type_basics.html#sqlalchemy.types.BigInteger
    "sqlalchemy.types.BigInteger") for a primary key, on SQLite this type will need
    to be rendered as the name `"INTEGER"` when emitting the initial `CREATE TABLE`
    statement in order for the autoincrement behavior to be available.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 的类型模型基于命名约定。除其他外，这意味着任何包含子字符串`"INT"`的类型名称将被确定为“整数亲和性”。一个名为`"BIGINT"`、`"SPECIAL_INT"`甚至`"XYZINTQPR"`的类型，SQLite
    都会认为是“整数”亲和性。然而，**SQLite 的自动增量功能，无论是隐式还是显式启用，都要求列类型的名称正好是字符串`"INTEGER"`**。因此，如果应用程序对主键使用类似[`BigInteger`](../core/type_basics.html#sqlalchemy.types.BigInteger
    "sqlalchemy.types.BigInteger")的类型，在 SQLite 中，当发出初始`CREATE TABLE`语句时，此类型需要呈现为名称`"INTEGER"`，以便使自动增量行为可用。
- en: 'One approach to achieve this is to use [`Integer`](../core/type_basics.html#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer") on SQLite only using [`TypeEngine.with_variant()`](../core/type_api.html#sqlalchemy.types.TypeEngine.with_variant
    "sqlalchemy.types.TypeEngine.with_variant"):'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 实现此目的的一种方法是仅在 SQLite 上使用[`Integer`](../core/type_basics.html#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer")，并使用[`TypeEngine.with_variant()`](../core/type_api.html#sqlalchemy.types.TypeEngine.with_variant
    "sqlalchemy.types.TypeEngine.with_variant")：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Another is to use a subclass of [`BigInteger`](../core/type_basics.html#sqlalchemy.types.BigInteger
    "sqlalchemy.types.BigInteger") that overrides its DDL name to be `INTEGER` when
    compiled against SQLite:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是使用[`BigInteger`](../core/type_basics.html#sqlalchemy.types.BigInteger
    "sqlalchemy.types.BigInteger")的子类，在针对 SQLite 编译时覆盖其 DDL 名称为`INTEGER`：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: See also
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`TypeEngine.with_variant()`](../core/type_api.html#sqlalchemy.types.TypeEngine.with_variant
    "sqlalchemy.types.TypeEngine.with_variant")'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '[`TypeEngine.with_variant()`](../core/type_api.html#sqlalchemy.types.TypeEngine.with_variant
    "sqlalchemy.types.TypeEngine.with_variant")'
- en: '[Custom SQL Constructs and Compilation Extension](../core/compiler.html)'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '[自定义 SQL 构造和编译扩展](../core/compiler.html)'
- en: '[Datatypes In SQLite Version 3](https://sqlite.org/datatype3.html)  ## Database
    Locking Behavior / Concurrency'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '[SQLite 版本 3 中的数据类型](https://sqlite.org/datatype3.html)  ## 数据库锁定行为 / 并发性'
- en: SQLite is not designed for a high level of write concurrency. The database itself,
    being a file, is locked completely during write operations within transactions,
    meaning exactly one “connection” (in reality a file handle) has exclusive access
    to the database during this period - all other “connections” will be blocked during
    this time.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 不适用于高并发写入。数据库本身作为文件，在事务中的写操作期间完全被锁定，这意味着在此期间仅有一个“连接”（实际上是一个文件句柄）对数据库具有独占访问权限
    - 在此期间所有其他“连接”将被阻塞。
- en: The Python DBAPI specification also calls for a connection model that is always
    in a transaction; there is no `connection.begin()` method, only `connection.commit()`
    and `connection.rollback()`, upon which a new transaction is to be begun immediately.
    This may seem to imply that the SQLite driver would in theory allow only a single
    filehandle on a particular database file at any time; however, there are several
    factors both within SQLite itself as well as within the pysqlite driver which
    loosen this restriction significantly.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Python DBAPI 规范还要求连接模型始终处于事务中；没有`connection.begin()`方法，只有`connection.commit()`和`connection.rollback()`，在其上立即开始新事务。这似乎意味着
    SQLite 驱动理论上只允许在任何时候对特定数据库文件进行单个文件句柄的操作；然而，SQLite 本身以及 pysqlite 驱动中有几个因素显著放宽了这一限制。
- en: However, no matter what locking modes are used, SQLite will still always lock
    the database file once a transaction is started and DML (e.g. INSERT, UPDATE,
    DELETE) has at least been emitted, and this will block other transactions at least
    at the point that they also attempt to emit DML. By default, the length of time
    on this block is very short before it times out with an error.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，无论使用何种锁定模式，一旦启动事务并且至少发出了 DML（例如 INSERT、UPDATE、DELETE），SQLite 将始终锁定数据库文件，并且这将至少在其他事务试图发出
    DML 时阻止其他事务。默认情况下，此阻塞的时间非常短，然后会超时并显示错误。
- en: This behavior becomes more critical when used in conjunction with the SQLAlchemy
    ORM. SQLAlchemy’s [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    object by default runs within a transaction, and with its autoflush model, may
    emit DML preceding any SELECT statement. This may lead to a SQLite database that
    locks more quickly than is expected. The locking mode of SQLite and the pysqlite
    driver can be manipulated to some degree, however it should be noted that achieving
    a high degree of write-concurrency with SQLite is a losing battle.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当与 SQLAlchemy ORM 结合使用时，此行为变得更加关键。SQLAlchemy 的 [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 对象默认在事务中运行，并且使用其自动刷新模式，可能会在任何 SELECT 语句之前发出 DML。这可能会导致
    SQLite 数据库比预期更快地锁定。可以在某种程度上操纵 SQLite 和 pysqlite 驱动程序的锁定模式，但应注意，要在 SQLite 中实现高度的写并发是一场失败的战斗。
- en: For more information on SQLite’s lack of write concurrency by design, please
    see [Situations Where Another RDBMS May Work Better - High Concurrency](https://www.sqlite.org/whentouse.html)
    near the bottom of the page.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 SQLite 按设计缺乏写并发的更多信息，请参阅页面底部的 [在其他关系数据库管理系统可能更适合的情况下 - 高并发](https://www.sqlite.org/whentouse.html)。
- en: 'The following subsections introduce areas that are impacted by SQLite’s file-based
    architecture and additionally will usually require workarounds to work when using
    the pysqlite driver.  ## Transaction Isolation Level / Autocommit'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 以下各小节介绍了受 SQLite 文件型架构影响的区域，并在使用 pysqlite 驱动程序时通常需要解决方法才能正常工作。## 事务隔离级别 / 自动提交
- en: SQLite supports “transaction isolation” in a non-standard way, along two axes.
    One is that of the [PRAGMA read_uncommitted](https://www.sqlite.org/pragma.html#pragma_read_uncommitted)
    instruction. This setting can essentially switch SQLite between its default mode
    of `SERIALIZABLE` isolation, and a “dirty read” isolation mode normally referred
    to as `READ UNCOMMITTED`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 以非标准方式支持“事务隔离”，沿着两个轴。一个是 [PRAGMA read_uncommitted](https://www.sqlite.org/pragma.html#pragma_read_uncommitted)
    指令。此设置可以在 SQLite 的默认模式 `SERIALIZABLE` 隔离和通常称为 `READ UNCOMMITTED` 的 “脏读” 隔离模式之间切换。
- en: SQLAlchemy ties into this PRAGMA statement using the [`create_engine.isolation_level`](../core/engines.html#sqlalchemy.create_engine.params.isolation_level
    "sqlalchemy.create_engine") parameter of [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine"). Valid values for this parameter when used with SQLite
    are `"SERIALIZABLE"` and `"READ UNCOMMITTED"` corresponding to a value of 0 and
    1, respectively. SQLite defaults to `SERIALIZABLE`, however its behavior is impacted
    by the pysqlite driver’s default behavior.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 使用 [`create_engine.isolation_level`](../core/engines.html#sqlalchemy.create_engine.params.isolation_level
    "sqlalchemy.create_engine") 参数的 PRAGMA 语句绑定到此。当与 SQLite 结合使用时，此参数的有效值是 `"SERIALIZABLE"`
    和 `"READ UNCOMMITTED"`，分别对应值 0 和 1。SQLite 默认为 `SERIALIZABLE`，但其行为受 pysqlite 驱动程序的默认行为影响。
- en: When using the pysqlite driver, the `"AUTOCOMMIT"` isolation level is also available,
    which will alter the pysqlite connection using the `.isolation_level` attribute
    on the DBAPI connection and set it to None for the duration of the setting.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 pysqlite 驱动程序时，还可以使用 `"AUTOCOMMIT"` 隔离级别，这将通过 DBAPI 连接上的 `.isolation_level`
    属性来更改 pysqlite 连接，并在设置的持续时间内将其设置为 None。
- en: 'New in version 1.3.16: added support for SQLite AUTOCOMMIT isolation level
    when using the pysqlite / sqlite3 SQLite driver.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 新版本 1.3.16 中：在使用 pysqlite / sqlite3 SQLite 驱动程序时添加了对 SQLite AUTOCOMMIT 隔离级别的支持。
- en: The other axis along which SQLite’s transactional locking is impacted is via
    the nature of the `BEGIN` statement used. The three varieties are “deferred”,
    “immediate”, and “exclusive”, as described at [BEGIN TRANSACTION](https://sqlite.org/lang_transaction.html).
    A straight `BEGIN` statement uses the “deferred” mode, where the database file
    is not locked until the first read or write operation, and read access remains
    open to other transactions until the first write operation. But again, it is critical
    to note that the pysqlite driver interferes with this behavior by *not even emitting
    BEGIN* until the first write operation.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 影响 SQLite 事务性锁定的另一个轴是使用的 `BEGIN` 语句的性质。三种变体是“deferred”、“immediate” 和 “exclusive”，如
    [BEGIN TRANSACTION](https://sqlite.org/lang_transaction.html) 中所述。直接的 `BEGIN`
    语句使用“deferred”模式，在第一次读取或写入操作之前不会锁定数据库文件，并且在第一次写入操作之前会保持对其他事务的读取访问打开。但是，关键要注意的是
    pysqlite 驱动程序通过*甚至不发出 BEGIN*来干扰此行为。
- en: Warning
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: SQLite’s transactional scope is impacted by unresolved issues in the pysqlite
    driver, which defers BEGIN statements to a greater degree than is often feasible.
    See the section [Serializable isolation / Savepoints / Transactional DDL](#pysqlite-serializable)
    or [Serializable isolation / Savepoints / Transactional DDL (asyncio version)](#aiosqlite-serializable)
    for techniques to work around this behavior.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 的事务范围受到 pysqlite 驱动程序中未解决的问题的影响，该驱动程序将 BEGIN 语句推迟到比通常更大的程度。请参阅 [Serializable
    isolation / Savepoints / Transactional DDL](#pysqlite-serializable) 或 [Serializable
    isolation / Savepoints / Transactional DDL (asyncio version)](#aiosqlite-serializable)
    部分，了解解决此行为的技术。
- en: See also
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[Setting Transaction Isolation Levels including DBAPI Autocommit](../core/connections.html#dbapi-autocommit)'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '[设置事务隔离级别，包括 DBAPI 自动提交](../core/connections.html#dbapi-autocommit)'
- en: INSERT/UPDATE/DELETE…RETURNING
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: INSERT/UPDATE/DELETE…RETURNING
- en: The SQLite dialect supports SQLite 3.35’s `INSERT|UPDATE|DELETE..RETURNING`
    syntax. `INSERT..RETURNING` may be used automatically in some cases in order to
    fetch newly generated identifiers in place of the traditional approach of using
    `cursor.lastrowid`, however `cursor.lastrowid` is currently still preferred for
    simple single-statement cases for its better performance.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 方言支持 SQLite 3.35 的 `INSERT|UPDATE|DELETE..RETURNING` 语法。在某些情况下，`INSERT..RETURNING`
    可以自动使用，以在生成新标识符时替代传统方法使用 `cursor.lastrowid`，但是在简单的单语句情况下，目前仍更倾向于使用 `cursor.lastrowid`，因为其性能更好。
- en: 'To specify an explicit `RETURNING` clause, use the `_UpdateBase.returning()`
    method on a per-statement basis:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要指定显式的 `RETURNING` 子句，请在每个语句基础上使用 `_UpdateBase.returning()` 方法：
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'New in version 2.0: Added support for SQLite RETURNING'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 版本 2.0 中的新功能：添加对 SQLite RETURNING 的支持
- en: SAVEPOINT Support
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SAVEPOINT 支持
- en: SQLite supports SAVEPOINTs, which only function once a transaction is begun.
    SQLAlchemy’s SAVEPOINT support is available using the [`Connection.begin_nested()`](../core/connections.html#sqlalchemy.engine.Connection.begin_nested
    "sqlalchemy.engine.Connection.begin_nested") method at the Core level, and [`Session.begin_nested()`](../orm/session_api.html#sqlalchemy.orm.Session.begin_nested
    "sqlalchemy.orm.Session.begin_nested") at the ORM level. However, SAVEPOINTs won’t
    work at all with pysqlite unless workarounds are taken.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 支持 SAVEPOINT，仅在事务开始后才起作用。SQLAlchemy 的 SAVEPOINT 支持可使用 Core 级别的 [`Connection.begin_nested()`](../core/connections.html#sqlalchemy.engine.Connection.begin_nested
    "sqlalchemy.engine.Connection.begin_nested") 方法和 ORM 级别的 [`Session.begin_nested()`](../orm/session_api.html#sqlalchemy.orm.Session.begin_nested
    "sqlalchemy.orm.Session.begin_nested") 方法。但是，除非采取解决方法，否则在 pysqlite 中根本无法使用 SAVEPOINT。
- en: Warning
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: SQLite’s SAVEPOINT feature is impacted by unresolved issues in the pysqlite
    and aiosqlite drivers, which defer BEGIN statements to a greater degree than is
    often feasible. See the sections [Serializable isolation / Savepoints / Transactional
    DDL](#pysqlite-serializable) and [Serializable isolation / Savepoints / Transactional
    DDL (asyncio version)](#aiosqlite-serializable) for techniques to work around
    this behavior.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 的 SAVEPOINT 功能受到 pysqlite 和 aiosqlite 驱动程序中未解决的问题的影响，这些驱动程序将 BEGIN 语句推迟到比通常更大的程度。请参阅
    [Serializable isolation / Savepoints / Transactional DDL](#pysqlite-serializable)
    和 [Serializable isolation / Savepoints / Transactional DDL (asyncio version)](#aiosqlite-serializable)
    部分，了解解决此行为的技术。
- en: Transactional DDL
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事务性 DDL
- en: The SQLite database supports transactional [DDL](../glossary.html#term-DDL)
    as well. In this case, the pysqlite driver is not only failing to start transactions,
    it also is ending any existing transaction when DDL is detected, so again, workarounds
    are required.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 数据库也支持事务性 [DDL](../glossary.html#term-DDL)。在这种情况下，pysqlite 驱动程序不仅未能启动事务，还在检测到
    DDL 时结束了任何现有事务，因此需要解决方法。
- en: Warning
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: SQLite’s transactional DDL is impacted by unresolved issues in the pysqlite
    driver, which fails to emit BEGIN and additionally forces a COMMIT to cancel any
    transaction when DDL is encountered. See the section [Serializable isolation /
    Savepoints / Transactional DDL](#pysqlite-serializable) for techniques to work
    around this behavior.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 的事务 DDL 受到 pysqlite 驱动程序中未解决的问题的影响，该驱动程序在遇到 DDL 时未发出 BEGIN 并且还强制执行 COMMIT
    以取消任何事务。请参阅 [Serializable isolation / Savepoints / Transactional DDL](#pysqlite-serializable)
    部分以了解解决此行为的技巧。
- en: '## Foreign Key Support'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '## 外键支持'
- en: SQLite supports FOREIGN KEY syntax when emitting CREATE statements for tables,
    however by default these constraints have no effect on the operation of the table.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 在发出 CREATE 语句创建表时支持 FOREIGN KEY 语法，但默认情况下这些约束对表的操作没有任何影响。
- en: 'Constraint checking on SQLite has three prerequisites:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SQLite 上进行约束检查有三个前提条件：
- en: At least version 3.6.19 of SQLite must be in use
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须使用至少版本 3.6.19 的 SQLite。
- en: The SQLite library must be compiled *without* the SQLITE_OMIT_FOREIGN_KEY or
    SQLITE_OMIT_TRIGGER symbols enabled.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQLite 库必须编译为 *不包含* SQLITE_OMIT_FOREIGN_KEY 或 SQLITE_OMIT_TRIGGER 符号的状态。
- en: The `PRAGMA foreign_keys = ON` statement must be emitted on all connections
    before use – including the initial call to [`MetaData.create_all()`](../core/metadata.html#sqlalchemy.schema.MetaData.create_all
    "sqlalchemy.schema.MetaData.create_all").
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须在所有连接上发出 `PRAGMA foreign_keys = ON` 语句，包括对 [`MetaData.create_all()`](../core/metadata.html#sqlalchemy.schema.MetaData.create_all
    "sqlalchemy.schema.MetaData.create_all") 的初始调用。
- en: 'SQLAlchemy allows for the `PRAGMA` statement to be emitted automatically for
    new connections through the usage of events:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 允许通过事件的使用自动发出 `PRAGMA` 语句以用于新连接：
- en: '[PRE4]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Warning
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: When SQLite foreign keys are enabled, it is **not possible** to emit CREATE
    or DROP statements for tables that contain mutually-dependent foreign key constraints;
    to emit the DDL for these tables requires that ALTER TABLE be used to create or
    drop these constraints separately, for which SQLite has no support.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当启用 SQLite 外键时，**不可能** 发出包含相互依赖外键约束的表的 CREATE 或 DROP 语句；要为这些表发出 DDL，需要使用 ALTER
    TABLE 分别创建或删除这些约束，而 SQLite 不支持此操作。
- en: See also
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[SQLite Foreign Key Support](https://www.sqlite.org/foreignkeys.html) - on
    the SQLite web site.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '[SQLite 外键支持](https://www.sqlite.org/foreignkeys.html) - SQLite 网站上的链接。'
- en: '[Events](../core/event.html) - SQLAlchemy event API.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '[Events](../core/event.html) - SQLAlchemy 事件 API。'
- en: '[Creating/Dropping Foreign Key Constraints via ALTER](../core/constraints.html#use-alter)
    - more information on SQLAlchemy’s facilities for handling'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '[通过 ALTER 创建/删除外键约束](../core/constraints.html#use-alter) - 关于 SQLAlchemy 处理的更多信息'
- en: 'mutually-dependent foreign key constraints.  ## ON CONFLICT support for constraints'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 相互依赖的外键约束。## 用于约束的 ON CONFLICT 支持
- en: See also
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: This section describes the [DDL](../glossary.html#term-DDL) version of “ON CONFLICT”
    for SQLite, which occurs within a CREATE TABLE statement. For “ON CONFLICT” as
    applied to an INSERT statement, see [INSERT…ON CONFLICT (Upsert)](#sqlite-on-conflict-insert).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 本节描述了 SQLite 中在 CREATE TABLE 语句内部发生的 “ON CONFLICT” 的 [DDL](../glossary.html#term-DDL)
    版本。有关作用于 INSERT 语句的 “ON CONFLICT”，请参阅 [INSERT…ON CONFLICT (Upsert)](#sqlite-on-conflict-insert)。
- en: SQLite supports a non-standard DDL clause known as ON CONFLICT which can be
    applied to primary key, unique, check, and not null constraints. In DDL, it is
    rendered either within the “CONSTRAINT” clause or within the column definition
    itself depending on the location of the target constraint. To render this clause
    within DDL, the extension parameter `sqlite_on_conflict` can be specified with
    a string conflict resolution algorithm within the [`PrimaryKeyConstraint`](../core/constraints.html#sqlalchemy.schema.PrimaryKeyConstraint
    "sqlalchemy.schema.PrimaryKeyConstraint"), [`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint"), [`CheckConstraint`](../core/constraints.html#sqlalchemy.schema.CheckConstraint
    "sqlalchemy.schema.CheckConstraint") objects. Within the [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") object, there are individual parameters `sqlite_on_conflict_not_null`,
    `sqlite_on_conflict_primary_key`, `sqlite_on_conflict_unique` which each correspond
    to the three types of relevant constraint types that can be indicated from a [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") object.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite支持一个名为ON CONFLICT的非标准DDL子句，可应用于主键、唯一、检查和非空约束。在DDL中，它要么在“CONSTRAINT”子句中呈现，要么在目标约束的位置取决于列定义本身。要在DDL中呈现此子句，可以使用扩展参数`sqlite_on_conflict`并在[`PrimaryKeyConstraint`](../core/constraints.html#sqlalchemy.schema.PrimaryKeyConstraint
    "sqlalchemy.schema.PrimaryKeyConstraint")、[`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint")、[`CheckConstraint`](../core/constraints.html#sqlalchemy.schema.CheckConstraint
    "sqlalchemy.schema.CheckConstraint")对象中指定字符串冲突解析算法。在[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")对象中，有单独的参数`sqlite_on_conflict_not_null`、`sqlite_on_conflict_primary_key`、`sqlite_on_conflict_unique`，它们分别对应于可以从[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")对象指示的三种相关约束类型。
- en: See also
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[ON CONFLICT](https://www.sqlite.org/lang_conflict.html) - in the SQLite documentation'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '[ON CONFLICT](https://www.sqlite.org/lang_conflict.html) - SQLite文档中的内容'
- en: New in version 1.3.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 版本1.3中的新功能。
- en: 'The `sqlite_on_conflict` parameters accept a string argument which is just
    the resolution name to be chosen, which on SQLite can be one of ROLLBACK, ABORT,
    FAIL, IGNORE, and REPLACE. For example, to add a UNIQUE constraint that specifies
    the IGNORE algorithm:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`sqlite_on_conflict`参数接受一个字符串参数，该参数只是要选择的解析名称，在SQLite中可以是ROLLBACK、ABORT、FAIL、IGNORE和REPLACE中的一个。例如，要添加指定IGNORE算法的唯一约束：'
- en: '[PRE5]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The above renders CREATE TABLE DDL as:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 以上呈现了CREATE TABLE DDL如下：
- en: '[PRE6]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'When using the [`Column.unique`](../core/metadata.html#sqlalchemy.schema.Column.params.unique
    "sqlalchemy.schema.Column") flag to add a UNIQUE constraint to a single column,
    the `sqlite_on_conflict_unique` parameter can be added to the [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") as well, which will be added to the UNIQUE constraint
    in the DDL:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用[`Column.unique`](../core/metadata.html#sqlalchemy.schema.Column.params.unique
    "sqlalchemy.schema.Column")标志将唯一约束添加到单个列时，也可以将`sqlite_on_conflict_unique`参数添加到[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")中，该参数将添加到DDL中的唯一约束中：
- en: '[PRE7]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'rendering:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染：
- en: '[PRE8]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To apply the FAIL algorithm for a NOT NULL constraint, `sqlite_on_conflict_not_null`
    is used:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 要应用FAIL算法以满足非空约束，使用`sqlite_on_conflict_not_null`：
- en: '[PRE9]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'this renders the column inline ON CONFLICT phrase:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这将呈现列内联的ON CONFLICT短语：
- en: '[PRE10]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Similarly, for an inline primary key, use `sqlite_on_conflict_primary_key`:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，对于内联主键，请使用`sqlite_on_conflict_primary_key`：
- en: '[PRE11]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'SQLAlchemy renders the PRIMARY KEY constraint separately, so the conflict resolution
    algorithm is applied to the constraint itself:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy单独呈现主键约束，因此冲突解析算法应用于约束本身：
- en: '[PRE12]  ## INSERT…ON CONFLICT (Upsert)'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE12]  ## INSERT…ON CONFLICT（Upsert）'
- en: See also
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: This section describes the [DML](../glossary.html#term-DML) version of “ON CONFLICT”
    for SQLite, which occurs within an INSERT statement. For “ON CONFLICT” as applied
    to a CREATE TABLE statement, see [ON CONFLICT support for constraints](#sqlite-on-conflict-ddl).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 本节描述了SQLite中“ON CONFLICT”的[DML](../glossary.html#term-DML)版本，它出现在INSERT语句中。有关应用于CREATE
    TABLE语句的“ON CONFLICT”，请参见[ON CONFLICT支持约束](#sqlite-on-conflict-ddl)。
- en: From version 3.24.0 onwards, SQLite supports “upserts” (update or insert) of
    rows into a table via the `ON CONFLICT` clause of the `INSERT` statement. A candidate
    row will only be inserted if that row does not violate any unique or primary key
    constraints. In the case of a unique constraint violation, a secondary action
    can occur which can be either “DO UPDATE”, indicating that the data in the target
    row should be updated, or “DO NOTHING”, which indicates to silently skip this
    row.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 从版本 3.24.0 开始，SQLite 支持通过 `INSERT` 语句的 `ON CONFLICT` 子句将行“upsert”（更新或插入）到表中。只有候选行不违反任何唯一约束或主键约束时，才会插入候选行。在唯一约束违反的情况下，可以发生二次操作，可以是“DO
    UPDATE”，表示目标行中的数据应该更新，也可以是“DO NOTHING”，表示要默默跳过此行。
- en: Conflicts are determined using columns that are part of existing unique constraints
    and indexes. These constraints are identified by stating the columns and conditions
    that comprise the indexes.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 冲突是使用现有唯一约束和索引的列确定的。这些约束通过说明组成索引的列和条件来识别。
- en: 'SQLAlchemy provides `ON CONFLICT` support via the SQLite-specific [`insert()`](#sqlalchemy.dialects.sqlite.insert
    "sqlalchemy.dialects.sqlite.insert") function, which provides the generative methods
    [`Insert.on_conflict_do_update()`](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update
    "sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update") and [`Insert.on_conflict_do_nothing()`](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_nothing
    "sqlalchemy.dialects.sqlite.Insert.on_conflict_do_nothing"):'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 通过 SQLite 特定的 [`insert()`](#sqlalchemy.dialects.sqlite.insert "sqlalchemy.dialects.sqlite.insert")
    函数提供了 `ON CONFLICT` 支持，该函数提供了生成方法 [`Insert.on_conflict_do_update()`](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update
    "sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update") 和 [`Insert.on_conflict_do_nothing()`](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_nothing
    "sqlalchemy.dialects.sqlite.Insert.on_conflict_do_nothing")：
- en: '[PRE13]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: New in version 1.4.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 版本 1.4 中的新功能。
- en: See also
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Upsert](https://sqlite.org/lang_UPSERT.html) - in the SQLite documentation.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '[Upsert](https://sqlite.org/lang_UPSERT.html) - SQLite 文档中的内容。'
- en: Specifying the Target
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 指定目标
- en: 'Both methods supply the “target” of the conflict using column inference:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法都使用列推断提供冲突的“目标”：
- en: The [`Insert.on_conflict_do_update.index_elements`](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update.params.index_elements
    "sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update") argument specifies
    a sequence containing string column names, [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects, and/or SQL expression elements, which would
    identify a unique index or unique constraint.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`Insert.on_conflict_do_update.index_elements`](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update.params.index_elements
    "sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update") 参数指定一个序列，其中包含字符串列名、[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") 对象和/或 SQL 表达式元素，用于标识唯一索引或唯一约束。'
- en: 'When using [`Insert.on_conflict_do_update.index_elements`](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update.params.index_elements
    "sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update") to infer an index,
    a partial index can be inferred by also specifying the [`Insert.on_conflict_do_update.index_where`](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update.params.index_where
    "sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update") parameter:'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用 [`Insert.on_conflict_do_update.index_elements`](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update.params.index_elements
    "sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update") 推断索引时，也可以通过指定 [`Insert.on_conflict_do_update.index_where`](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update.params.index_where
    "sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update") 参数来推断部分索引：
- en: '[PRE14]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The SET Clause
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SET 子句
- en: '`ON CONFLICT...DO UPDATE` is used to perform an update of the already existing
    row, using any combination of new values as well as values from the proposed insertion.
    These values are specified using the [`Insert.on_conflict_do_update.set_`](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update.params.set_
    "sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update") parameter. This parameter
    accepts a dictionary which consists of direct values for UPDATE:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`ON CONFLICT...DO UPDATE` 用于执行已存在行的更新操作，使用新值以及建议插入的值的任意组合。这些值使用 [`Insert.on_conflict_do_update.set_`](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update.params.set_
    "sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update") 参数指定。该参数接受一个字典，其中包含更新的直接值：'
- en: '[PRE15]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Warning
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: The [`Insert.on_conflict_do_update()`](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update
    "sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update") method does **not**
    take into account Python-side default UPDATE values or generation functions, e.g.
    those specified using [`Column.onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.onupdate
    "sqlalchemy.schema.Column"). These values will not be exercised for an ON CONFLICT
    style of UPDATE, unless they are manually specified in the [`Insert.on_conflict_do_update.set_`](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update.params.set_
    "sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update") dictionary.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Insert.on_conflict_do_update()`](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update
    "sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update") 方法**不会**考虑 Python 端的默认
    UPDATE 值或生成函数，例如使用 [`Column.onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.onupdate
    "sqlalchemy.schema.Column") 指定的值。这些值不会在 ON CONFLICT 类型的 UPDATE 中执行，除非它们在 [`Insert.on_conflict_do_update.set_`](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update.params.set_
    "sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update") 字典中手动指定。'
- en: Updating using the Excluded INSERT Values
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用排除的 INSERT 值进行更新
- en: 'In order to refer to the proposed insertion row, the special alias [`Insert.excluded`](#sqlalchemy.dialects.sqlite.Insert.excluded
    "sqlalchemy.dialects.sqlite.Insert.excluded") is available as an attribute on
    the [`Insert`](#sqlalchemy.dialects.sqlite.Insert "sqlalchemy.dialects.sqlite.Insert")
    object; this object creates an “excluded.” prefix on a column, that informs the
    DO UPDATE to update the row with the value that would have been inserted had the
    constraint not failed:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 要引用提议的插入行，[`Insert.excluded`](#sqlalchemy.dialects.sqlite.Insert.excluded "sqlalchemy.dialects.sqlite.Insert.excluded")
    这个特殊别名可作为 [`Insert`](#sqlalchemy.dialects.sqlite.Insert "sqlalchemy.dialects.sqlite.Insert")
    对象的属性使用；这个对象在列上创建一个“excluded.” 前缀，通知 DO UPDATE 使用将要插入的值来更新行，如果约束没有失败的话：
- en: '[PRE16]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Additional WHERE Criteria
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 额外的 WHERE 条件
- en: 'The [`Insert.on_conflict_do_update()`](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update
    "sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update") method also accepts
    a WHERE clause using the [`Insert.on_conflict_do_update.where`](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update.params.where
    "sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update") parameter, which will
    limit those rows which receive an UPDATE:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Insert.on_conflict_do_update()`](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update
    "sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update") 方法还接受使用 [`Insert.on_conflict_do_update.where`](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update.params.where
    "sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update") 参数的 WHERE 子句，这将限制接收
    UPDATE 的行：'
- en: '[PRE17]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Skipping Rows with DO NOTHING
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 DO NOTHING 跳过行
- en: '`ON CONFLICT` may be used to skip inserting a row entirely if any conflict
    with a unique constraint occurs; below this is illustrated using the [`Insert.on_conflict_do_nothing()`](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_nothing
    "sqlalchemy.dialects.sqlite.Insert.on_conflict_do_nothing") method:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`ON CONFLICT` 可用于完全跳过插入行，如果与唯一约束发生冲突；下面使用 [`Insert.on_conflict_do_nothing()`](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_nothing
    "sqlalchemy.dialects.sqlite.Insert.on_conflict_do_nothing") 方法进行说明：'
- en: '[PRE18]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If `DO NOTHING` is used without specifying any columns or constraint, it has
    the effect of skipping the INSERT for any unique violation which occurs:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用 `DO NOTHING` 而没有指定任何列或约束，它将跳过任何唯一性冲突导致的 INSERT：
- en: '[PRE19]  ## Type Reflection'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE19]  ## 类型反射'
- en: SQLite types are unlike those of most other database backends, in that the string
    name of the type usually does not correspond to a “type” in a one-to-one fashion.
    Instead, SQLite links per-column typing behavior to one of five so-called “type
    affinities” based on a string matching pattern for the type.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 类型与大多数其他数据库后端的类型不同，因为类型的字符串名称通常不是一对一对应的“类型”。相反，SQLite 将每列的类型行为链接到五种所谓的“类型亲和性”之一，基于类型的字符串匹配模式。
- en: SQLAlchemy’s reflection process, when inspecting types, uses a simple lookup
    table to link the keywords returned to provided SQLAlchemy types. This lookup
    table is present within the SQLite dialect as it is for all other dialects. However,
    the SQLite dialect has a different “fallback” routine for when a particular type
    name is not located in the lookup map; it instead implements the SQLite “type
    affinity” scheme located at [https://www.sqlite.org/datatype3.html](https://www.sqlite.org/datatype3.html)
    section 2.1.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 的反射过程，在检查类型时，使用一个简单的查找表将返回的关键字链接到提供的 SQLAlchemy 类型。这个查找表存在于 SQLite
    方言中，就像所有其他方言一样。然而，当特定类型名称未在查找映射中找到时，SQLite 方言有一个不同的“回退”程序；它实际上实现了位于 [https://www.sqlite.org/datatype3.html](https://www.sqlite.org/datatype3.html)
    第 2.1 节的 SQLite “类型亲和性”方案。
- en: 'The provided typemap will make direct associations from an exact string name
    match for the following types:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 提供的类型映射将直接从以下类型的精确字符串名称匹配中进行关联：
- en: '[`BIGINT`](../core/type_basics.html#sqlalchemy.types.BIGINT "sqlalchemy.types.BIGINT"),
    [`BLOB`](../core/type_basics.html#sqlalchemy.types.BLOB "sqlalchemy.types.BLOB"),
    [`BOOLEAN`](../core/type_basics.html#sqlalchemy.types.BOOLEAN "sqlalchemy.types.BOOLEAN"),
    [`BOOLEAN`](../core/type_basics.html#sqlalchemy.types.BOOLEAN "sqlalchemy.types.BOOLEAN"),
    [`CHAR`](../core/type_basics.html#sqlalchemy.types.CHAR "sqlalchemy.types.CHAR"),
    [`DATE`](../core/type_basics.html#sqlalchemy.types.DATE "sqlalchemy.types.DATE"),
    [`DATETIME`](../core/type_basics.html#sqlalchemy.types.DATETIME "sqlalchemy.types.DATETIME"),
    [`FLOAT`](../core/type_basics.html#sqlalchemy.types.FLOAT "sqlalchemy.types.FLOAT"),
    [`DECIMAL`](../core/type_basics.html#sqlalchemy.types.DECIMAL "sqlalchemy.types.DECIMAL"),
    [`FLOAT`](../core/type_basics.html#sqlalchemy.types.FLOAT "sqlalchemy.types.FLOAT"),
    [`INTEGER`](../core/type_basics.html#sqlalchemy.types.INTEGER "sqlalchemy.types.INTEGER"),
    [`INTEGER`](../core/type_basics.html#sqlalchemy.types.INTEGER "sqlalchemy.types.INTEGER"),
    [`NUMERIC`](../core/type_basics.html#sqlalchemy.types.NUMERIC "sqlalchemy.types.NUMERIC"),
    [`REAL`](../core/type_basics.html#sqlalchemy.types.REAL "sqlalchemy.types.REAL"),
    [`SMALLINT`](../core/type_basics.html#sqlalchemy.types.SMALLINT "sqlalchemy.types.SMALLINT"),
    [`TEXT`](../core/type_basics.html#sqlalchemy.types.TEXT "sqlalchemy.types.TEXT"),
    [`TIME`](../core/type_basics.html#sqlalchemy.types.TIME "sqlalchemy.types.TIME"),
    [`TIMESTAMP`](../core/type_basics.html#sqlalchemy.types.TIMESTAMP "sqlalchemy.types.TIMESTAMP"),
    [`VARCHAR`](../core/type_basics.html#sqlalchemy.types.VARCHAR "sqlalchemy.types.VARCHAR"),
    [`NVARCHAR`](../core/type_basics.html#sqlalchemy.types.NVARCHAR "sqlalchemy.types.NVARCHAR"),
    [`NCHAR`](../core/type_basics.html#sqlalchemy.types.NCHAR "sqlalchemy.types.NCHAR")'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果类型名称包含字符串`BLOB`，则返回[`BIGINT`](../core/type_basics.html#sqlalchemy.types.BIGINT
    "sqlalchemy.types.BIGINT")、[`BLOB`](../core/type_basics.html#sqlalchemy.types.BLOB
    "sqlalchemy.types.BLOB")、[`BOOLEAN`](../core/type_basics.html#sqlalchemy.types.BOOLEAN
    "sqlalchemy.types.BOOLEAN")、[`BOOLEAN`](../core/type_basics.html#sqlalchemy.types.BOOLEAN
    "sqlalchemy.types.BOOLEAN")、[`CHAR`](../core/type_basics.html#sqlalchemy.types.CHAR
    "sqlalchemy.types.CHAR")、[`DATE`](../core/type_basics.html#sqlalchemy.types.DATE
    "sqlalchemy.types.DATE")、[`DATETIME`](../core/type_basics.html#sqlalchemy.types.DATETIME
    "sqlalchemy.types.DATETIME")、[`FLOAT`](../core/type_basics.html#sqlalchemy.types.FLOAT
    "sqlalchemy.types.FLOAT")、[`DECIMAL`](../core/type_basics.html#sqlalchemy.types.DECIMAL
    "sqlalchemy.types.DECIMAL")、[`FLOAT`](../core/type_basics.html#sqlalchemy.types.FLOAT
    "sqlalchemy.types.FLOAT")、[`INTEGER`](../core/type_basics.html#sqlalchemy.types.INTEGER
    "sqlalchemy.types.INTEGER")、[`INTEGER`](../core/type_basics.html#sqlalchemy.types.INTEGER
    "sqlalchemy.types.INTEGER")、[`NUMERIC`](../core/type_basics.html#sqlalchemy.types.NUMERIC
    "sqlalchemy.types.NUMERIC")、[`REAL`](../core/type_basics.html#sqlalchemy.types.REAL
    "sqlalchemy.types.REAL")、[`SMALLINT`](../core/type_basics.html#sqlalchemy.types.SMALLINT
    "sqlalchemy.types.SMALLINT")、[`TEXT`](../core/type_basics.html#sqlalchemy.types.TEXT
    "sqlalchemy.types.TEXT")、[`TIME`](../core/type_basics.html#sqlalchemy.types.TIME
    "sqlalchemy.types.TIME")、[`TIMESTAMP`](../core/type_basics.html#sqlalchemy.types.TIMESTAMP
    "sqlalchemy.types.TIMESTAMP")、[`VARCHAR`](../core/type_basics.html#sqlalchemy.types.VARCHAR
    "sqlalchemy.types.VARCHAR")、[`NVARCHAR`](../core/type_basics.html#sqlalchemy.types.NVARCHAR
    "sqlalchemy.types.NVARCHAR")、[`NCHAR`](../core/type_basics.html#sqlalchemy.types.NCHAR
    "sqlalchemy.types.NCHAR")
- en: 'When a type name does not match one of the above types, the “type affinity”
    lookup is used instead:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当类型名称不匹配上述类型之一时，将使用“类型亲和性”查找代替：
- en: '[`INTEGER`](../core/type_basics.html#sqlalchemy.types.INTEGER "sqlalchemy.types.INTEGER")
    is returned if the type name includes the string `INT`'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果类型名称包含字符串`INT`，则返回[`INTEGER`](../core/type_basics.html#sqlalchemy.types.INTEGER
    "sqlalchemy.types.INTEGER")
- en: '[`TEXT`](../core/type_basics.html#sqlalchemy.types.TEXT "sqlalchemy.types.TEXT")
    is returned if the type name includes the string `CHAR`, `CLOB` or `TEXT`'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果类型名称包含字符串`CHAR`、`CLOB`或`TEXT`，则返回[`TEXT`](../core/type_basics.html#sqlalchemy.types.TEXT
    "sqlalchemy.types.TEXT")
- en: '[`NullType`](../core/type_api.html#sqlalchemy.types.NullType "sqlalchemy.types.NullType")
    is returned if the type name includes the string `BLOB`'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果类型名称包含字符串`BLOB`，则返回[`NullType`](../core/type_api.html#sqlalchemy.types.NullType
    "sqlalchemy.types.NullType")
- en: '[`REAL`](../core/type_basics.html#sqlalchemy.types.REAL "sqlalchemy.types.REAL")
    is returned if the type name includes the string `REAL`, `FLOA` or `DOUB`.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果类型名称包含字符串`REAL`、`FLOA`或`DOUB`，则返回[`REAL`](../core/type_basics.html#sqlalchemy.types.REAL
    "sqlalchemy.types.REAL")
- en: 'Otherwise, the [`NUMERIC`](../core/type_basics.html#sqlalchemy.types.NUMERIC
    "sqlalchemy.types.NUMERIC") type is used.  ## Partial Indexes'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，将使用[`NUMERIC`](../core/type_basics.html#sqlalchemy.types.NUMERIC "sqlalchemy.types.NUMERIC")类型。##
    部分索引
- en: 'A partial index, e.g. one which uses a WHERE clause, can be specified with
    the DDL system using the argument `sqlite_where`:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用DDL系统使用参数`sqlite_where`来指定部分索引，例如使用WHERE子句的索引：
- en: '[PRE20]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The index will be rendered at create time as:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 索引将在创建时呈现为：
- en: '[PRE21]  ## Dotted Column Names'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE21]  ## 点列名'
- en: Using table or column names that explicitly have periods in them is **not recommended**.
    While this is generally a bad idea for relational databases in general, as the
    dot is a syntactically significant character, the SQLite driver up until version
    **3.10.0** of SQLite has a bug which requires that SQLAlchemy filter out these
    dots in result sets.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 使用明确包含句点的表格或列名**不推荐**。虽然这通常对关系数据库来说是个坏主意，因为句点是一个语法上重要的字符，但直到SQLite版本**3.10.0**之前的SQLite驱动程序存在一个bug，需要SQLAlchemy在结果集中过滤掉这些句点。
- en: 'The bug, entirely outside of SQLAlchemy, can be illustrated thusly:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这个bug完全不是SQLAlchemy的问题，可以这样说明：
- en: '[PRE22]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The second assertion fails:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个断言失败：
- en: '[PRE23]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Where above, the driver incorrectly reports the names of the columns including
    the name of the table, which is entirely inconsistent vs. when the UNION is not
    present.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述情况下，驱动程序错误地报告包括表名在内的列名，这与没有UNION时完全不一致。
- en: 'SQLAlchemy relies upon column names being predictable in how they match to
    the original statement, so the SQLAlchemy dialect has no choice but to filter
    these out:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy依赖于列名在匹配原始语句时的可预测性，因此SQLAlchemy方言别无选择，只能过滤掉这些内容：
- en: '[PRE24]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Note that above, even though SQLAlchemy filters out the dots, *both names are
    still addressable*:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，即使SQLAlchemy过滤掉了句点，*这两个名称仍然可寻址*：
- en: '[PRE25]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Therefore, the workaround applied by SQLAlchemy only impacts [`CursorResult.keys()`](../core/connections.html#sqlalchemy.engine.CursorResult.keys
    "sqlalchemy.engine.CursorResult.keys") and `Row.keys()` in the public API. In
    the very specific case where an application is forced to use column names that
    contain dots, and the functionality of [`CursorResult.keys()`](../core/connections.html#sqlalchemy.engine.CursorResult.keys
    "sqlalchemy.engine.CursorResult.keys") and `Row.keys()` is required to return
    these dotted names unmodified, the `sqlite_raw_colnames` execution option may
    be provided, either on a per-[`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") basis:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，SQLAlchemy应用的解决方法仅影响公共API中的[`CursorResult.keys()`](../core/connections.html#sqlalchemy.engine.CursorResult.keys
    "sqlalchemy.engine.CursorResult.keys")和`Row.keys()`，在应用被迫使用包含句点的列名，并且需要[`CursorResult.keys()`](../core/connections.html#sqlalchemy.engine.CursorResult.keys
    "sqlalchemy.engine.CursorResult.keys")和`Row.keys()`返回这些带点的名称时，可以提供`sqlite_raw_colnames`执行选项，或者基于每个[`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")的基础上：
- en: '[PRE26]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'or on a per-[`Engine`](../core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    basis:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 或者基于每个[`Engine`](../core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")的基础上：
- en: '[PRE27]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: When using the per-[`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") execution option, note that **Core and ORM queries
    that use UNION may not function properly**.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用基于每个[`Engine`](../core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")的执行选项时，请注意**使用UNION的Core和ORM查询可能无法正常工作**。
- en: SQLite-specific table options
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 特定于SQLite的表选项
- en: 'One option for CREATE TABLE is supported directly by the SQLite dialect in
    conjunction with the [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    construct:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 一个CREATE TABLE的选项直接由SQLite方言支持，与[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")构造一起使用：
- en: '`WITHOUT ROWID`:'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WITHOUT ROWID`：'
- en: '[PRE28]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: See also
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[SQLite CREATE TABLE options](https://www.sqlite.org/lang_createtable.html)'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '[SQLite CREATE TABLE options](https://www.sqlite.org/lang_createtable.html)'
- en: '## Reflecting internal schema tables'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '## 反射内部模式表'
- en: Reflection methods that return lists of tables will omit so-called “SQLite internal
    schema object” names, which are considered by SQLite as any object name that is
    prefixed with `sqlite_`. An example of such an object is the `sqlite_sequence`
    table that’s generated when the `AUTOINCREMENT` column parameter is used. In order
    to return these objects, the parameter `sqlite_include_internal=True` may be passed
    to methods such as [`MetaData.reflect()`](../core/metadata.html#sqlalchemy.schema.MetaData.reflect
    "sqlalchemy.schema.MetaData.reflect") or [`Inspector.get_table_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_table_names
    "sqlalchemy.engine.reflection.Inspector.get_table_names").
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 返回表列表的反射方法将省略所谓的“SQLite内部模式对象”名称，这些名称被SQLite视为任何以`sqlite_`为前缀的对象名称。这种对象的一个例子是在使用`AUTOINCREMENT`列参数时生成的`sqlite_sequence`表。为了返回这些对象，可以将参数`sqlite_include_internal=True`传递给诸如[`MetaData.reflect()`](../core/metadata.html#sqlalchemy.schema.MetaData.reflect
    "sqlalchemy.schema.MetaData.reflect")或[`Inspector.get_table_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_table_names
    "sqlalchemy.engine.reflection.Inspector.get_table_names")等方法。
- en: 'New in version 2.0: Added the `sqlite_include_internal=True` parameter. Previously,
    these tables were not ignored by SQLAlchemy reflection methods.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 新增于版本 2.0：添加了 `sqlite_include_internal=True` 参数。以前，这些表不会被SQLAlchemy反射方法所忽略。
- en: Note
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 注
- en: The `sqlite_include_internal` parameter does not refer to the “system” tables
    that are present in schemas such as `sqlite_master`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`sqlite_include_internal` 参数不是指与 `sqlite_master` 等模式中存在的“系统”表相关的内容。'
- en: See also
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[SQLite Internal Schema Objects](https://www.sqlite.org/fileformat2.html#intschema)
    - in the SQLite documentation.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '[SQLite 内部模式对象](https://www.sqlite.org/fileformat2.html#intschema) - 在SQLite文档中。'
- en: SQLite Data Types
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SQLite 数据类型
- en: 'As with all SQLAlchemy dialects, all UPPERCASE types that are known to be valid
    with SQLite are importable from the top level dialect, whether they originate
    from [`sqlalchemy.types`](../core/type_basics.html#module-sqlalchemy.types "sqlalchemy.types")
    or from the local dialect:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有SQLAlchemy方言一样，所有已知与SQLite兼容的大写类型都可以从顶级方言导入，无论它们是来自 [`sqlalchemy.types`](../core/type_basics.html#module-sqlalchemy.types
    "sqlalchemy.types") 还是本地方言：
- en: '[PRE29]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '| Object Name | Description |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| 对象名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| [DATE](#sqlalchemy.dialects.sqlite.DATE) | Represent a Python date object
    in SQLite using a string. |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| [日期](#sqlalchemy.dialects.sqlite.DATE) | 使用字符串在SQLite中表示Python日期对象。 |'
- en: '| [DATETIME](#sqlalchemy.dialects.sqlite.DATETIME) | Represent a Python datetime
    object in SQLite using a string. |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| [日期时间](#sqlalchemy.dialects.sqlite.DATETIME) | 使用字符串在SQLite中表示Python日期时间对象。
    |'
- en: '| [JSON](#sqlalchemy.dialects.sqlite.JSON) | SQLite JSON type. |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| [JSON](#sqlalchemy.dialects.sqlite.JSON) | SQLite JSON 类型。 |'
- en: '| [TIME](#sqlalchemy.dialects.sqlite.TIME) | Represent a Python time object
    in SQLite using a string. |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| [时间](#sqlalchemy.dialects.sqlite.TIME) | 使用字符串在SQLite中表示Python时间对象。 |'
- en: '[PRE30]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Represent a Python datetime object in SQLite using a string.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 使用字符串在SQLite中表示Python日期时间对象。
- en: 'The default string storage format is:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的字符串存储格式为：
- en: '[PRE31]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'e.g.:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE32]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The incoming storage format is by default parsed using the Python `datetime.fromisoformat()`
    function.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，传入的存储格式将使用Python的 `datetime.fromisoformat()` 函数解析。
- en: 'Changed in version 2.0: `datetime.fromisoformat()` is used for default datetime
    string parsing.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 从版本 2.0开始更改：默认日期时间字符串解析使用 `datetime.fromisoformat()`。
- en: 'The storage format can be customized to some degree using the `storage_format`
    and `regexp` parameters, such as:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `storage_format` 和 `regexp` 参数在一定程度上定制存储格式，例如：
- en: '[PRE33]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Parameters:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '`storage_format` – format string which will be applied to the dict with keys
    year, month, day, hour, minute, second, and microsecond.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`storage_format` – 格式字符串，将应用于具有键年、月、日、小时、分钟、秒和微秒的字典。'
- en: '`regexp` – regular expression which will be applied to incoming result rows,
    replacing the use of `datetime.fromisoformat()` to parse incoming strings. If
    the regexp contains named groups, the resulting match dict is applied to the Python
    datetime() constructor as keyword arguments. Otherwise, if positional groups are
    used, the datetime() constructor is called with positional arguments via `*map(int,
    match_obj.groups(0))`.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`regexp` – 将应用于传入结果行的正则表达式，替换使用 `datetime.fromisoformat()` 解析传入字符串的方法。如果正则表达式包含命名组，则将生成的匹配字典作为关键字参数应用于Python的
    datetime() 构造函数。否则，如果使用了位置组，则通过 `*map(int, match_obj.groups(0))` 调用 datetime()
    构造函数以使用位置参数。'
- en: '**Class signature**'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '**类签名**'
- en: class [`sqlalchemy.dialects.sqlite.DATETIME`](#sqlalchemy.dialects.sqlite.DATETIME
    "sqlalchemy.dialects.sqlite.DATETIME") (`sqlalchemy.dialects.sqlite.base._DateTimeMixin`,
    [`sqlalchemy.types.DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime
    "sqlalchemy.types.DateTime"))
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 类[`sqlalchemy.dialects.sqlite.DATETIME`](#sqlalchemy.dialects.sqlite.DATETIME
    "sqlalchemy.dialects.sqlite.DATETIME")（`sqlalchemy.dialects.sqlite.base._DateTimeMixin`，[`sqlalchemy.types.DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime
    "sqlalchemy.types.DateTime"))
- en: '[PRE34]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Represent a Python date object in SQLite using a string.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 使用字符串在SQLite中表示Python日期对象。
- en: 'The default string storage format is:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的字符串存储格式为：
- en: '[PRE35]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'e.g.:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE36]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The incoming storage format is by default parsed using the Python `date.fromisoformat()`
    function.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，传入的存储格式将使用Python的 `date.fromisoformat()` 函数解析。
- en: 'Changed in version 2.0: `date.fromisoformat()` is used for default date string
    parsing.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 从版本 2.0开始更改：默认日期字符串解析使用 `date.fromisoformat()`。
- en: 'The storage format can be customized to some degree using the `storage_format`
    and `regexp` parameters, such as:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `storage_format` 和 `regexp` 参数在一定程度上定制存储格式，例如：
- en: '[PRE37]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Parameters:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '`storage_format` – format string which will be applied to the dict with keys
    year, month, and day.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`storage_format` – 格式字符串，将应用于具有键年、月和日的字典。'
- en: '`regexp` – regular expression which will be applied to incoming result rows,
    replacing the use of `date.fromisoformat()` to parse incoming strings. If the
    regexp contains named groups, the resulting match dict is applied to the Python
    date() constructor as keyword arguments. Otherwise, if positional groups are used,
    the date() constructor is called with positional arguments via `*map(int, match_obj.groups(0))`.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`regexp` – 将应用于传入结果行的正则表达式，以替换使用 `date.fromisoformat()` 来解析传入字符串。如果正则表达式包含命名组，则生成的匹配字典将作为关键字参数应用于
    Python 的 date() 构造函数。否则，如果使用位置组，则通过 `*map(int, match_obj.groups(0))` 调用 date()
    构造函数来传递位置参数。'
- en: '**Class signature**'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '**类签名**'
- en: class [`sqlalchemy.dialects.sqlite.DATE`](#sqlalchemy.dialects.sqlite.DATE "sqlalchemy.dialects.sqlite.DATE")
    (`sqlalchemy.dialects.sqlite.base._DateTimeMixin`, [`sqlalchemy.types.Date`](../core/type_basics.html#sqlalchemy.types.Date
    "sqlalchemy.types.Date"))
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: class [`sqlalchemy.dialects.sqlite.DATE`](#sqlalchemy.dialects.sqlite.DATE "sqlalchemy.dialects.sqlite.DATE")
    (`sqlalchemy.dialects.sqlite.base._DateTimeMixin`, [`sqlalchemy.types.Date`](../core/type_basics.html#sqlalchemy.types.Date
    "sqlalchemy.types.Date"))
- en: '[PRE38]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: SQLite JSON type.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite JSON 类型。
- en: SQLite supports JSON as of version 3.9 through its [JSON1](https://www.sqlite.org/json1.html)
    extension. Note that [JSON1](https://www.sqlite.org/json1.html) is a [loadable
    extension](https://www.sqlite.org/loadext.html) and as such may not be available,
    or may require run-time loading.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 从版本 3.9 开始支持 JSON，通过其 [JSON1](https://www.sqlite.org/json1.html) 扩展。请注意，[JSON1](https://www.sqlite.org/json1.html)
    是一个[可加载扩展](https://www.sqlite.org/loadext.html)，因此可能不可用，或者可能需要运行时加载。
- en: '[`JSON`](#sqlalchemy.dialects.sqlite.JSON "sqlalchemy.dialects.sqlite.JSON")
    is used automatically whenever the base [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON") datatype is used against a SQLite backend.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SQLite 后端中使用基本 [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON")
    数据类型时，[`JSON`](#sqlalchemy.dialects.sqlite.JSON "sqlalchemy.dialects.sqlite.JSON")
    会自动使用。
- en: See also
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON")
    - main documentation for the generic cross-platform JSON datatype.'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '[`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON")
    - 通用跨平台 JSON 数据类型的主文档。'
- en: The [`JSON`](#sqlalchemy.dialects.sqlite.JSON "sqlalchemy.dialects.sqlite.JSON")
    type supports persistence of JSON values as well as the core index operations
    provided by [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON")
    datatype, by adapting the operations to render the `JSON_EXTRACT` function wrapped
    in the `JSON_QUOTE` function at the database level. Extracted values are quoted
    in order to ensure that the results are always JSON string values.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '[`JSON`](#sqlalchemy.dialects.sqlite.JSON "sqlalchemy.dialects.sqlite.JSON")
    类型支持将 JSON 值持久化，以及通过在数据库级别包装 `JSON_EXTRACT` 函数并渲染为 `JSON_QUOTE` 函数来提供核心索引操作的 [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON") 数据类型，以适应这些操作。提取的值都被引用，以确保结果始终是 JSON 字符串值。'
- en: New in version 1.3.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 版本 1.3 中的新功能。
- en: '**Members**'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '**成员**'
- en: '[__init__()](#sqlalchemy.dialects.sqlite.JSON.__init__)'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '[__init__()](#sqlalchemy.dialects.sqlite.JSON.__init__)'
- en: '**Class signature**'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '**类签名**'
- en: class [`sqlalchemy.dialects.sqlite.JSON`](#sqlalchemy.dialects.sqlite.JSON "sqlalchemy.dialects.sqlite.JSON")
    ([`sqlalchemy.types.JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON"))
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: class [`sqlalchemy.dialects.sqlite.JSON`](#sqlalchemy.dialects.sqlite.JSON "sqlalchemy.dialects.sqlite.JSON")
    ([`sqlalchemy.types.JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON"))
- en: '[PRE39]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '*inherited from the* `sqlalchemy.types.JSON.__init__` *method of* [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON")'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '*继承自* [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON")
    的 `sqlalchemy.types.JSON.__init__` *方法*'
- en: Construct a [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON")
    type.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 构造一个 [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON")
    类型。
- en: 'Parameters:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**none_as_null=False** –'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '**none_as_null=False** –'
- en: 'if True, persist the value `None` as a SQL NULL value, not the JSON encoding
    of `null`. Note that when this flag is False, the [`null()`](../core/sqlelement.html#sqlalchemy.sql.expression.null
    "sqlalchemy.sql.expression.null") construct can still be used to persist a NULL
    value, which may be passed directly as a parameter value that is specially interpreted
    by the [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON")
    type as SQL NULL:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果为 True，则将值 `None` 持久化为 SQL NULL 值，而不是 `null` 的 JSON 编码。注意，当此标志为 False 时，仍然可以使用
    [`null()`](../core/sqlelement.html#sqlalchemy.sql.expression.null "sqlalchemy.sql.expression.null")
    构造来持久化 NULL 值，该值可以直接作为参数值传递，由 [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON") 类型特殊解释为 SQL NULL：
- en: '[PRE40]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Note
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '[`JSON.none_as_null`](../core/type_basics.html#sqlalchemy.types.JSON.params.none_as_null
    "sqlalchemy.types.JSON") does **not** apply to the values passed to [`Column.default`](../core/metadata.html#sqlalchemy.schema.Column.params.default
    "sqlalchemy.schema.Column") and [`Column.server_default`](../core/metadata.html#sqlalchemy.schema.Column.params.server_default
    "sqlalchemy.schema.Column"); a value of `None` passed for these parameters means
    “no default present”.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '[`JSON.none_as_null`](../core/type_basics.html#sqlalchemy.types.JSON.params.none_as_null
    "sqlalchemy.types.JSON") **不**适用于传递给 [`Column.default`](../core/metadata.html#sqlalchemy.schema.Column.params.default
    "sqlalchemy.schema.Column") 和 [`Column.server_default`](../core/metadata.html#sqlalchemy.schema.Column.params.server_default
    "sqlalchemy.schema.Column") 的值；这些参数的传递值为 `None` 意味着“没有默认值”。'
- en: Additionally, when used in SQL comparison expressions, the Python value `None`
    continues to refer to SQL null, and not JSON NULL. The [`JSON.none_as_null`](../core/type_basics.html#sqlalchemy.types.JSON.params.none_as_null
    "sqlalchemy.types.JSON") flag refers explicitly to the **persistence** of the
    value within an INSERT or UPDATE statement. The [`JSON.NULL`](../core/type_basics.html#sqlalchemy.types.JSON.NULL
    "sqlalchemy.types.JSON.NULL") value should be used for SQL expressions that wish
    to compare to JSON null.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在 SQL 比较表达式中使用时，Python 值 `None` 仍然表示 SQL 空值，而不是 JSON NULL。[`JSON.none_as_null`](../core/type_basics.html#sqlalchemy.types.JSON.params.none_as_null
    "sqlalchemy.types.JSON") 标志显式指定了值在 INSERT 或 UPDATE 语句中的**持久性**。应该使用 [`JSON.NULL`](../core/type_basics.html#sqlalchemy.types.JSON.NULL
    "sqlalchemy.types.JSON.NULL") 值来表示希望与 JSON 空值进行比较的 SQL 表达式。
- en: See also
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`JSON.NULL`](../core/type_basics.html#sqlalchemy.types.JSON.NULL "sqlalchemy.types.JSON.NULL")'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '[`JSON.NULL`](../core/type_basics.html#sqlalchemy.types.JSON.NULL "sqlalchemy.types.JSON.NULL")'
- en: '[PRE41]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Represent a Python time object in SQLite using a string.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 使用字符串在 SQLite 中表示 Python 时间对象。
- en: 'The default string storage format is:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 默认字符串存储格式为：
- en: '[PRE42]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'e.g.:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE43]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The incoming storage format is by default parsed using the Python `time.fromisoformat()`
    function.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，传入的存储格式使用 Python 的 `time.fromisoformat()` 函数解析。
- en: 'Changed in version 2.0: `time.fromisoformat()` is used for default time string
    parsing.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 自 2.0 版本更改：默认时间字符串解析现在使用 `time.fromisoformat()`。
- en: 'The storage format can be customized to some degree using the `storage_format`
    and `regexp` parameters, such as:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 存储格式可以在一定程度上使用 `storage_format` 和 `regexp` 参数进行自定义，例如：
- en: '[PRE44]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Parameters:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '`storage_format` – format string which will be applied to the dict with keys
    hour, minute, second, and microsecond.'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`storage_format` – 将应用于包含小时、分钟、秒和微秒键的字典的格式字符串。'
- en: '`regexp` – regular expression which will be applied to incoming result rows,
    replacing the use of `datetime.fromisoformat()` to parse incoming strings. If
    the regexp contains named groups, the resulting match dict is applied to the Python
    time() constructor as keyword arguments. Otherwise, if positional groups are used,
    the time() constructor is called with positional arguments via `*map(int, match_obj.groups(0))`.'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`regexp` – 将应用于传入结果行的正则表达式，取代使用 `datetime.fromisoformat()` 解析传入字符串。如果正则表达式包含命名组，则结果匹配字典将作为关键字参数应用于
    Python 的 time() 构造函数。否则，如果使用了位置组，则通过 `*map(int, match_obj.groups(0))` 将调用 time()
    构造函数以传递位置参数。'
- en: '**Class signature**'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '**类签名**'
- en: class [`sqlalchemy.dialects.sqlite.TIME`](#sqlalchemy.dialects.sqlite.TIME "sqlalchemy.dialects.sqlite.TIME")
    (`sqlalchemy.dialects.sqlite.base._DateTimeMixin`, [`sqlalchemy.types.Time`](../core/type_basics.html#sqlalchemy.types.Time
    "sqlalchemy.types.Time"))
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: class [`sqlalchemy.dialects.sqlite.TIME`](#sqlalchemy.dialects.sqlite.TIME "sqlalchemy.dialects.sqlite.TIME")
    (`sqlalchemy.dialects.sqlite.base._DateTimeMixin`, [`sqlalchemy.types.Time`](../core/type_basics.html#sqlalchemy.types.Time
    "sqlalchemy.types.Time"))
- en: SQLite DML Constructs
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SQLite DML Constructs
- en: '| Object Name | Description |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '| 对象名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| [insert](#sqlalchemy.dialects.sqlite.insert)(table) | Construct a sqlite-specific
    variant [`Insert`](#sqlalchemy.dialects.sqlite.Insert "sqlalchemy.dialects.sqlite.Insert")
    construct. |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '| [insert](#sqlalchemy.dialects.sqlite.insert)(table) | 构造一个特定于 SQLite 的变体
    [`Insert`](#sqlalchemy.dialects.sqlite.Insert "sqlalchemy.dialects.sqlite.Insert")
    构造。 |'
- en: '| [Insert](#sqlalchemy.dialects.sqlite.Insert) | SQLite-specific implementation
    of INSERT. |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| [Insert](#sqlalchemy.dialects.sqlite.Insert) | SQLite 的 INSERT 的特定实现。 |'
- en: '[PRE45]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Construct a sqlite-specific variant [`Insert`](#sqlalchemy.dialects.sqlite.Insert
    "sqlalchemy.dialects.sqlite.Insert") construct.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 构造一个特定于 SQLite 的变体 [`Insert`](#sqlalchemy.dialects.sqlite.Insert "sqlalchemy.dialects.sqlite.Insert")
    构造。
- en: The [`sqlalchemy.dialects.sqlite.insert()`](#sqlalchemy.dialects.sqlite.insert
    "sqlalchemy.dialects.sqlite.insert") function creates a [`sqlalchemy.dialects.sqlite.Insert`](#sqlalchemy.dialects.sqlite.Insert
    "sqlalchemy.dialects.sqlite.Insert"). This class is based on the dialect-agnostic
    [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert "sqlalchemy.sql.expression.Insert")
    construct which may be constructed using the [`insert()`](../core/dml.html#sqlalchemy.sql.expression.insert
    "sqlalchemy.sql.expression.insert") function in SQLAlchemy Core.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '[`sqlalchemy.dialects.sqlite.insert()`](#sqlalchemy.dialects.sqlite.insert
    "sqlalchemy.dialects.sqlite.insert") 函数创建 [`sqlalchemy.dialects.sqlite.Insert`](#sqlalchemy.dialects.sqlite.Insert
    "sqlalchemy.dialects.sqlite.Insert")。该类基于方言无关的 [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") 结构，可以使用 SQLAlchemy Core 中的 [`insert()`](../core/dml.html#sqlalchemy.sql.expression.insert
    "sqlalchemy.sql.expression.insert") 函数构造。'
- en: The [`Insert`](#sqlalchemy.dialects.sqlite.Insert "sqlalchemy.dialects.sqlite.Insert")
    construct includes additional methods [`Insert.on_conflict_do_update()`](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update
    "sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update"), [`Insert.on_conflict_do_nothing()`](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_nothing
    "sqlalchemy.dialects.sqlite.Insert.on_conflict_do_nothing").
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Insert`](#sqlalchemy.dialects.sqlite.Insert "sqlalchemy.dialects.sqlite.Insert")
    结构包括额外的方法 [`Insert.on_conflict_do_update()`](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update
    "sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update")、[`Insert.on_conflict_do_nothing()`](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_nothing
    "sqlalchemy.dialects.sqlite.Insert.on_conflict_do_nothing")。'
- en: '[PRE46]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: SQLite-specific implementation of INSERT.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 特定的 INSERT 实现。
- en: Adds methods for SQLite-specific syntaxes such as ON CONFLICT.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 添加了针对 SQLite 特定语法的方法，如 ON CONFLICT。
- en: The [`Insert`](#sqlalchemy.dialects.sqlite.Insert "sqlalchemy.dialects.sqlite.Insert")
    object is created using the [`sqlalchemy.dialects.sqlite.insert()`](#sqlalchemy.dialects.sqlite.insert
    "sqlalchemy.dialects.sqlite.insert") function.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Insert`](#sqlalchemy.dialects.sqlite.Insert "sqlalchemy.dialects.sqlite.Insert")
    对象是通过 [`sqlalchemy.dialects.sqlite.insert()`](#sqlalchemy.dialects.sqlite.insert
    "sqlalchemy.dialects.sqlite.insert") 函数创建的。'
- en: New in version 1.4.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在 1.4 版中新增。
- en: See also
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[INSERT…ON CONFLICT (Upsert)](#sqlite-on-conflict-insert)'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '[INSERT…ON CONFLICT（插入或替换）](#sqlite-on-conflict-insert)'
- en: '**Members**'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '**成员**'
- en: '[excluded](#sqlalchemy.dialects.sqlite.Insert.excluded), [inherit_cache](#sqlalchemy.dialects.sqlite.Insert.inherit_cache),
    [on_conflict_do_nothing()](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_nothing),
    [on_conflict_do_update()](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update)'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '[excluded](#sqlalchemy.dialects.sqlite.Insert.excluded)、[inherit_cache](#sqlalchemy.dialects.sqlite.Insert.inherit_cache)、[on_conflict_do_nothing()](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_nothing)、[on_conflict_do_update()](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update)'
- en: '**Class signature**'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '**类签名**'
- en: class [`sqlalchemy.dialects.sqlite.Insert`](#sqlalchemy.dialects.sqlite.Insert
    "sqlalchemy.dialects.sqlite.Insert") ([`sqlalchemy.sql.expression.Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert"))
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: class [`sqlalchemy.dialects.sqlite.Insert`](#sqlalchemy.dialects.sqlite.Insert
    "sqlalchemy.dialects.sqlite.Insert")（[`sqlalchemy.sql.expression.Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert")）
- en: '[PRE47]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Provide the `excluded` namespace for an ON CONFLICT statement
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 为 ON CONFLICT 语句提供 `excluded` 命名空间。
- en: SQLite’s ON CONFLICT clause allows reference to the row that would be inserted,
    known as `excluded`. This attribute provides all columns in this row to be referenceable.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 的 ON CONFLICT 子句允许引用将要插入的行，称为 `excluded`。此属性提供了对此行中的所有列的引用。
- en: Tip
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: The [`Insert.excluded`](#sqlalchemy.dialects.sqlite.Insert.excluded "sqlalchemy.dialects.sqlite.Insert.excluded")
    attribute is an instance of [`ColumnCollection`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnCollection
    "sqlalchemy.sql.expression.ColumnCollection"), which provides an interface the
    same as that of the [`Table.c`](../core/metadata.html#sqlalchemy.schema.Table.c
    "sqlalchemy.schema.Table.c") collection described at [Accessing Tables and Columns](../core/metadata.html#metadata-tables-and-columns).
    With this collection, ordinary names are accessible like attributes (e.g. `stmt.excluded.some_column`),
    but special names and dictionary method names should be accessed using indexed
    access, such as `stmt.excluded["column name"]` or `stmt.excluded["values"]`. See
    the docstring for [`ColumnCollection`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnCollection
    "sqlalchemy.sql.expression.ColumnCollection") for further examples.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Insert.excluded`](#sqlalchemy.dialects.sqlite.Insert.excluded "sqlalchemy.dialects.sqlite.Insert.excluded")
    属性是 [`ColumnCollection`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnCollection
    "sqlalchemy.sql.expression.ColumnCollection") 的一个实例，它提供与[访问表和列](../core/metadata.html#metadata-tables-and-columns)描述的
    [`Table.c`](../core/metadata.html#sqlalchemy.schema.Table.c "sqlalchemy.schema.Table.c")
    集合相同的接口。通过这个集合，普通名称可以像属性一样访问（例如 `stmt.excluded.some_column`），但特殊名称和字典方法名称应使用索引访问，例如
    `stmt.excluded["column name"]` 或 `stmt.excluded["values"]`。有关更多示例，请参阅 [`ColumnCollection`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnCollection
    "sqlalchemy.sql.expression.ColumnCollection") 的文档字符串。'
- en: '[PRE48]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Indicate if this [`HasCacheKey`](../core/foundation.html#sqlalchemy.sql.traversals.HasCacheKey
    "sqlalchemy.sql.traversals.HasCacheKey") instance should make use of the cache
    key generation scheme used by its immediate superclass.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 指示此 [`HasCacheKey`](../core/foundation.html#sqlalchemy.sql.traversals.HasCacheKey
    "sqlalchemy.sql.traversals.HasCacheKey") 实例是否应使用其直接超类使用的缓存密钥生成方案。
- en: The attribute defaults to `None`, which indicates that a construct has not yet
    taken into account whether or not its appropriate for it to participate in caching;
    this is functionally equivalent to setting the value to `False`, except that a
    warning is also emitted.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 此属性默认为 `None`，表示构造尚未考虑是否适合参与缓存；这在功能上相当于将值设置为 `False`，但还会发出警告。
- en: This flag can be set to `True` on a particular class, if the SQL that corresponds
    to the object does not change based on attributes which are local to this class,
    and not its superclass.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 如果与此类本地属性（而不是其超类）无关，则可以在特定类上设置此标志为 `True`，则与对象对应的 SQL 不会根据这个类的属性而改变。
- en: See also
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Enabling Caching Support for Custom Constructs](../core/compiler.html#compilerext-caching)
    - General guideslines for setting the [`HasCacheKey.inherit_cache`](../core/foundation.html#sqlalchemy.sql.traversals.HasCacheKey.inherit_cache
    "sqlalchemy.sql.traversals.HasCacheKey.inherit_cache") attribute for third-party
    or user defined SQL constructs.'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '[为自定义结构启用缓存支持](../core/compiler.html#compilerext-caching) - 设置[`HasCacheKey.inherit_cache`](../core/foundation.html#sqlalchemy.sql.traversals.HasCacheKey.inherit_cache
    "sqlalchemy.sql.traversals.HasCacheKey.inherit_cache") 属性的通用指南，用于第三方或用户定义的 SQL
    结构。'
- en: '[PRE49]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Specifies a DO NOTHING action for ON CONFLICT clause.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 指定了 ON CONFLICT 子句的 DO NOTHING 操作。
- en: 'Parameters:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '`index_elements` – A sequence consisting of string column names, [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects, or other column expression objects that will
    be used to infer a target index or unique constraint.'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`index_elements` – 由字符串列名、[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") 对象或其他列表达式对象组成的序列，将用于推断目标索引或唯一约束。'
- en: '`index_where` – Additional WHERE criterion that can be used to infer a conditional
    target index.'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`index_where` – 用于推断条件目标索引的额外 WHERE 条件。'
- en: '[PRE50]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Specifies a DO UPDATE SET action for ON CONFLICT clause.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 指定了 ON CONFLICT 子句的 DO UPDATE SET 操作。
- en: 'Parameters:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '`index_elements` – A sequence consisting of string column names, [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects, or other column expression objects that will
    be used to infer a target index or unique constraint.'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`index_elements` – 由字符串列名、[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") 对象或其他列表达式对象组成的序列，将用于推断目标索引或唯一约束。'
- en: '`index_where` – Additional WHERE criterion that can be used to infer a conditional
    target index.'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`index_where` – 用于推断条件目标索引的额外 WHERE 条件。'
- en: '`set_` –'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set_` –'
- en: A dictionary or other mapping object where the keys are either names of columns
    in the target table, or [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects or other ORM-mapped columns matching that
    of the target table, and expressions or literals as values, specifying the `SET`
    actions to take.
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一个字典或其他映射对象，其中键是目标表中的列名称，或者是 [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") 对象或其他 ORM 映射的列，匹配目标表的列，值是表达式或文字，指定要采取的 `SET` 操作。
- en: 'New in version 1.4: The [`Insert.on_conflict_do_update.set_`](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update.params.set_
    "sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update") parameter supports
    [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    objects from the target [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") as keys.'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从版本 1.4 开始：[`Insert.on_conflict_do_update.set_`](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update.params.set_
    "sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update") 参数支持目标 [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") 中的 [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") 对象作为键。
- en: Warning
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 警告
- en: This dictionary does **not** take into account Python-specified default UPDATE
    values or generation functions, e.g. those specified using [`Column.onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.onupdate
    "sqlalchemy.schema.Column"). These values will not be exercised for an ON CONFLICT
    style of UPDATE, unless they are manually specified in the [`Insert.on_conflict_do_update.set_`](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update.params.set_
    "sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update") dictionary.
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此字典**不**考虑 Python 指定的默认 UPDATE 值或生成函数，例如使用 [`Column.onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.onupdate
    "sqlalchemy.schema.Column") 指定的值。除非在 [`Insert.on_conflict_do_update.set_`](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update.params.set_
    "sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update") 字典中手动指定，否则这些值将不会用于
    ON CONFLICT 类型的 UPDATE。
- en: '`where` – Optional argument. If present, can be a literal SQL string or an
    acceptable expression for a `WHERE` clause that restricts the rows affected by
    `DO UPDATE SET`. Rows not meeting the `WHERE` condition will not be updated (effectively
    a `DO NOTHING` for those rows).'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`where` – 可选参数。如果存在，则可以是一个文字 SQL 字符串或一个可接受的 `WHERE` 子句表达式，用于限制受 `DO UPDATE
    SET` 影响的行。不满足 `WHERE` 条件的行将不会更新（对于这些行实际上是 `DO NOTHING`）。'
- en: '## Pysqlite'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '## Pysqlite'
- en: Support for the SQLite database via the pysqlite driver.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 pysqlite 驱动程序支持 SQLite 数据库。
- en: Note that `pysqlite` is the same driver as the `sqlite3` module included with
    the Python distribution.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`pysqlite` 与 Python 发行版中包含的 `sqlite3` 模块是相同的驱动程序。
- en: DBAPI
  id: totrans-303
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: DBAPI
- en: 'Documentation and download information (if applicable) for pysqlite is available
    at: [https://docs.python.org/library/sqlite3.html](https://docs.python.org/library/sqlite3.html)'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: pysqlite 的文档和下载信息（如果适用）可在此处找到：[https://docs.python.org/library/sqlite3.html](https://docs.python.org/library/sqlite3.html)
- en: Connecting
  id: totrans-305
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接
- en: 'Connect String:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 连接字符串：
- en: '[PRE51]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Driver
  id: totrans-308
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 驱动程序
- en: The `sqlite3` Python DBAPI is standard on all modern Python versions; for cPython
    and Pypy, no additional installation is necessary.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有现代 Python 版本上，`sqlite3` Python DBAPI 都是标准的；对于 cPython 和 Pypy，不需要额外安装。
- en: Connect Strings
  id: totrans-310
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接字符串
- en: 'The file specification for the SQLite database is taken as the “database” portion
    of the URL. Note that the format of a SQLAlchemy url is:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 数据库的文件规范被视为 URL 的 “数据库” 部分。请注意，SQLAlchemy URL 的格式为：
- en: '[PRE52]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'This means that the actual filename to be used starts with the characters to
    the **right** of the third slash. So connecting to a relative filepath looks like:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着要使用的实际文件名从第三个斜杠的**右边**开始。因此，连接到相对文件路径看起来像：
- en: '[PRE53]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'An absolute path, which is denoted by starting with a slash, means you need
    **four** slashes:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 绝对路径，以斜杠开头表示，意味着您需要**四个**斜杠：
- en: '[PRE54]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'To use a Windows path, regular drive specifications and backslashes can be
    used. Double backslashes are probably needed:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Windows 路径，可以使用常规的驱动器规范和反斜杠。可能需要双反斜杠：
- en: '[PRE55]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'To use sqlite `:memory:` database specify it as the filename using `sqlite://:memory:`.
    It’s also the default if no filepath is present, specifying only `sqlite://` and
    nothing else:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 sqlite `:memory:` 数据库，请将其指定为使用 `sqlite://:memory:` 的文件名。如果没有文件路径，指定只有 `sqlite://`
    而没有其他内容：
- en: '[PRE56]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '#### URI Connections'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '#### URI 连接'
- en: 'Modern versions of SQLite support an alternative system of connecting using
    a [driver level URI](https://www.sqlite.org/uri.html), which has the advantage
    that additional driver-level arguments can be passed including options such as
    “read only”. The Python sqlite3 driver supports this mode under modern Python
    3 versions. The SQLAlchemy pysqlite driver supports this mode of use by specifying
    “uri=true” in the URL query string. The SQLite-level “URI” is kept as the “database”
    portion of the SQLAlchemy url (that is, following a slash):'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 现代版本的SQLite支持使用[驱动级URI](https://www.sqlite.org/uri.html)进行连接的另一种系统，其优势在于可以传递附加的驱动级参数，包括诸如“只读”之类的选项。Python的sqlite3驱动在现代Python
    3版本下支持此模式。SQLAlchemy的pysqlite驱动通过在URL查询字符串中指定“uri=true”来支持此使用模式。SQLite级别的“URI”被保留为SQLAlchemy
    URL的“database”部分（即在斜杠后面）：
- en: '[PRE57]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Note
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The “uri=true” parameter must appear in the **query string** of the URL. It
    will not currently work as expected if it is only present in the [`create_engine.connect_args`](../core/engines.html#sqlalchemy.create_engine.params.connect_args
    "sqlalchemy.create_engine") parameter dictionary.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: “uri=true”参数必须出现在URL的**查询字符串**中。如果仅出现在[`create_engine.connect_args`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine")参数字典中，则目前不会按预期工作。
- en: 'The logic reconciles the simultaneous presence of SQLAlchemy’s query string
    and SQLite’s query string by separating out the parameters that belong to the
    Python sqlite3 driver vs. those that belong to the SQLite URI. This is achieved
    through the use of a fixed list of parameters known to be accepted by the Python
    side of the driver. For example, to include a URL that indicates the Python sqlite3
    “timeout” and “check_same_thread” parameters, along with the SQLite “mode” and
    “nolock” parameters, they can all be passed together on the query string:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 该逻辑通过分离属于Python sqlite3驱动程序和属于SQLite URI的参数来协调SQLAlchemy查询字符串和SQLite查询字符串的同时存在。这是通过使用已知被Python驱动程序的固定参数列表来实现的。例如，要包含指示Python
    sqlite3“timeout”和“check_same_thread”参数以及SQLite“mode”和“nolock”参数的URL，它们都可以一起传递到查询字符串中：
- en: '[PRE58]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Above, the pysqlite / sqlite3 DBAPI would be passed arguments as:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 如上，pysqlite / sqlite3 DBAPI将传递参数为：
- en: '[PRE59]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Regarding future parameters added to either the Python or native drivers. new
    parameter names added to the SQLite URI scheme should be automatically accommodated
    by this scheme. New parameter names added to the Python driver side can be accommodated
    by specifying them in the [`create_engine.connect_args`](../core/engines.html#sqlalchemy.create_engine.params.connect_args
    "sqlalchemy.create_engine") dictionary, until dialect support is added by SQLAlchemy.
    For the less likely case that the native SQLite driver adds a new parameter name
    that overlaps with one of the existing, known Python driver parameters (such as
    “timeout” perhaps), SQLAlchemy’s dialect would require adjustment for the URL
    scheme to continue to support this.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 关于将来添加到Python或本机驱动程序的参数。 SQLite URI方案中添加的新参数名称应该会自动适应此方案。可以通过在[`create_engine.connect_args`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine")字典中指定它们来适应Python驱动程序端添加的新参数名称，直到SQLAlchemy添加了方言支持为止。对于本机SQLite驱动程序添加的新参数名称与现有的已知Python驱动程序参数之一（例如“timeout”）重叠的不太可能的情况，SQLAlchemy的方言将需要调整URL方案以继续支持此参数。
- en: As is always the case for all SQLAlchemy dialects, the entire “URL” process
    can be bypassed in [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") through the use of the [`create_engine.creator`](../core/engines.html#sqlalchemy.create_engine.params.creator
    "sqlalchemy.create_engine") parameter which allows for a custom callable that
    creates a Python sqlite3 driver level connection directly.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有SQLAlchemy方言，可以通过[`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine")的[`create_engine.creator`](../core/engines.html#sqlalchemy.create_engine.params.creator
    "sqlalchemy.create_engine")参数绕过整个“URL”过程，该参数允许创建直接创建Python sqlite3驱动级连接的自定义可调用函数。
- en: New in version 1.3.9.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 新版本中新增。
- en: See also
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[Uniform Resource Identifiers](https://www.sqlite.org/uri.html) - in the SQLite
    documentation  ### Regular Expression Support'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '[统一资源标识符](https://www.sqlite.org/uri.html) - SQLite文档中的正则表达式支持  ### 正则表达式支持'
- en: New in version 1.4.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 新版本中新增。
- en: Support for the [`ColumnOperators.regexp_match()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.regexp_match
    "sqlalchemy.sql.expression.ColumnOperators.regexp_match") operator is provided
    using Python’s [re.search](https://docs.python.org/3/library/re.html#re.search)
    function. SQLite itself does not include a working regular expression operator;
    instead, it includes a non-implemented placeholder operator `REGEXP` that calls
    a user-defined function that must be provided.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Python 的 [re.search](https://docs.python.org/3/library/re.html#re.search)
    函数提供了对 [`ColumnOperators.regexp_match()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.regexp_match
    "sqlalchemy.sql.expression.ColumnOperators.regexp_match") 运算符的支持。SQLite 本身不包括可用的正则表达式运算符；相反，它包括一个未实现的占位符运算符
    `REGEXP`，调用必须提供的用户定义函数。
- en: 'SQLAlchemy’s implementation makes use of the pysqlite [create_function](https://docs.python.org/3/library/sqlite3.html#sqlite3.Connection.create_function)
    hook as follows:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 的实现使用 pysqlite 的 [create_function](https://docs.python.org/3/library/sqlite3.html#sqlite3.Connection.create_function)
    钩子，如下所示：
- en: '[PRE60]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: There is currently no support for regular expression flags as a separate argument,
    as these are not supported by SQLite’s REGEXP operator, however these may be included
    inline within the regular expression string. See [Python regular expressions](https://docs.python.org/3/library/re.html#re.search)
    for details.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 目前不支持将正则表达式标志作为单独参数，因为这些标志不受 SQLite 的 REGEXP 运算符支持，但可以在正则表达式字符串内联包含。详见[Python
    正则表达式](https://docs.python.org/3/library/re.html#re.search)。
- en: See also
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[Python regular expressions](https://docs.python.org/3/library/re.html#re.search):
    Documentation for Python’s regular expression syntax.'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '[Python 正则表达式](https://docs.python.org/3/library/re.html#re.search)：Python
    正则表达式语法的文档。'
- en: Compatibility with sqlite3 “native” date and datetime types
  id: totrans-342
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 与 sqlite3 “本地”日期和日期时间类型兼容
- en: The pysqlite driver includes the sqlite3.PARSE_DECLTYPES and sqlite3.PARSE_COLNAMES
    options, which have the effect of any column or expression explicitly cast as
    “date” or “timestamp” will be converted to a Python date or datetime object. The
    date and datetime types provided with the pysqlite dialect are not currently compatible
    with these options, since they render the ISO date/datetime including microseconds,
    which pysqlite’s driver does not. Additionally, SQLAlchemy does not at this time
    automatically render the “cast” syntax required for the freestanding functions
    “current_timestamp” and “current_date” to return datetime/date types natively.
    Unfortunately, pysqlite does not provide the standard DBAPI types in `cursor.description`,
    leaving SQLAlchemy with no way to detect these types on the fly without expensive
    per-row type checks.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: pysqlite 驱动程序包括 sqlite3.PARSE_DECLTYPES 和 sqlite3.PARSE_COLNAMES 选项，这些选项的效果是任何明确转换为“date”或“timestamp”的列或表达式将转换为
    Python 日期或日期时间对象。pysqlite 方言提供的日期和日期时间类型目前与这些选项不兼容，因为它们呈现 ISO 日期/日期时间，包括微秒，而 pysqlite
    的驱动程序不包括。此外，SQLAlchemy 目前不会自动呈现“cast”语法，以使自由函数“current_timestamp”和“current_date”返回原生的
    datetime/date 类型。不幸的是，pysqlite 不提供 `cursor.description` 中的标准 DBAPI 类型，使得 SQLAlchemy
    无法在不进行昂贵的每行类型检查的情况下动态检测这些类型。
- en: 'Keeping in mind that pysqlite’s parsing option is not recommended, nor should
    be necessary, for use with SQLAlchemy, usage of PARSE_DECLTYPES can be forced
    if one configures “native_datetime=True” on create_engine():'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，不推荐使用 pysqlite 的解析选项，也不应该使用 SQLAlchemy，如果配置了 "native_datetime=True" 在 create_engine()
    上，可以强制使用 PARSE_DECLTYPES。
- en: '[PRE61]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: With this flag enabled, the DATE and TIMESTAMP types (but note - not the DATETIME
    or TIME types…confused yet ?) will not perform any bind parameter or result processing.
    Execution of “func.current_date()” will return a string. “func.current_timestamp()”
    is registered as returning a DATETIME type in SQLAlchemy, so this function still
    receives SQLAlchemy-level result processing.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 启用此标志后，DATE 和 TIMESTAMP 类型（但请注意 - 不是 DATETIME 或 TIME 类型...还困惑吗？）将不执行任何绑定参数或结果处理。执行
    “func.current_date()” 将返回一个字符串。在 SQLAlchemy 中，“func.current_timestamp()” 被注册为返回
    DATETIME 类型，因此此函数仍接收 SQLAlchemy 级别的结果处理。
- en: '### Threading/Pooling Behavior'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '### 线程/池行为'
- en: The `sqlite3` DBAPI by default prohibits the use of a particular connection
    in a thread which is not the one in which it was created. As SQLite has matured,
    it’s behavior under multiple threads has improved, and even includes options for
    memory only databases to be used in multiple threads.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`sqlite3` DBAPI 禁止在创建它的线程之外的线程中使用特定连接。随着 SQLite 的成熟，它在多线程下的行为已经改进，甚至包括选项，使得内存数据库可以在多个线程中使用。
- en: The thread prohibition is known as “check same thread” and may be controlled
    using the `sqlite3` parameter `check_same_thread`, which will disable or enable
    this check. SQLAlchemy’s default behavior here is to set `check_same_thread` to
    `False` automatically whenever a file-based database is in use, to establish compatibility
    with the default pool class [`QueuePool`](../core/pooling.html#sqlalchemy.pool.QueuePool
    "sqlalchemy.pool.QueuePool").
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 线程禁止被称为“检查同一线程”，可以使用`sqlite3`参数`check_same_thread`进行控制，该参数将禁用或启用此检查。在使用基于文件的数据库时，SQLAlchemy
    的默认行为是自动将`check_same_thread`设置为`False`，以确立与默认池类[`QueuePool`](../core/pooling.html#sqlalchemy.pool.QueuePool
    "sqlalchemy.pool.QueuePool")的兼容性。
- en: 'The SQLAlchemy `pysqlite` DBAPI establishes the connection pool differently
    based on the kind of SQLite database that’s requested:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 的 `pysqlite` DBAPI 根据请求的 SQLite 数据库的类型以不同的方式建立连接池：
- en: When a `:memory:` SQLite database is specified, the dialect by default will
    use [`SingletonThreadPool`](../core/pooling.html#sqlalchemy.pool.SingletonThreadPool
    "sqlalchemy.pool.SingletonThreadPool"). This pool maintains a single connection
    per thread, so that all access to the engine within the current thread use the
    same `:memory:` database - other threads would access a different `:memory:` database.
    The `check_same_thread` parameter defaults to `True`.
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当指定`:memory:` SQLite 数据库时，默认情况下方言将使用[`SingletonThreadPool`](../core/pooling.html#sqlalchemy.pool.SingletonThreadPool
    "sqlalchemy.pool.SingletonThreadPool")。此池在每个线程中维护单个连接，因此当前线程内对引擎的所有访问都使用相同的`:memory:`数据库
    - 其他线程将访问不同的`:memory:`数据库。`check_same_thread`参数默认为`True`。
- en: When a file-based database is specified, the dialect will use [`QueuePool`](../core/pooling.html#sqlalchemy.pool.QueuePool
    "sqlalchemy.pool.QueuePool") as the source of connections. at the same time, the
    `check_same_thread` flag is set to False by default unless overridden.
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当指定基于文件的数据库时，方言将使用[`QueuePool`](../core/pooling.html#sqlalchemy.pool.QueuePool
    "sqlalchemy.pool.QueuePool")作为连接的源。同时，默认情况下将`check_same_thread`标志设置为`False`，除非被覆盖。
- en: 'Changed in version 2.0: SQLite file database engines now use [`QueuePool`](../core/pooling.html#sqlalchemy.pool.QueuePool
    "sqlalchemy.pool.QueuePool") by default. Previously, [`NullPool`](../core/pooling.html#sqlalchemy.pool.NullPool
    "sqlalchemy.pool.NullPool") were used. The [`NullPool`](../core/pooling.html#sqlalchemy.pool.NullPool
    "sqlalchemy.pool.NullPool") class may be used by specifying it via the [`create_engine.poolclass`](../core/engines.html#sqlalchemy.create_engine.params.poolclass
    "sqlalchemy.create_engine") parameter.'
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 自 2.0 版本更改：SQLite 文件数据库引擎现在默认使用[`QueuePool`](../core/pooling.html#sqlalchemy.pool.QueuePool
    "sqlalchemy.pool.QueuePool")。以前使用的是[`NullPool`](../core/pooling.html#sqlalchemy.pool.NullPool
    "sqlalchemy.pool.NullPool")。可以通过[`create_engine.poolclass`](../core/engines.html#sqlalchemy.create_engine.params.poolclass
    "sqlalchemy.create_engine")参数指定使用[`NullPool`](../core/pooling.html#sqlalchemy.pool.NullPool
    "sqlalchemy.pool.NullPool")类。
- en: Disabling Connection Pooling for File Databases
  id: totrans-354
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 禁用文件数据库的连接池
- en: 'Pooling may be disabled for a file based database by specifying the [`NullPool`](../core/pooling.html#sqlalchemy.pool.NullPool
    "sqlalchemy.pool.NullPool") implementation for the `poolclass()` parameter:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过为`poolclass()`参数指定[`NullPool`](../core/pooling.html#sqlalchemy.pool.NullPool
    "sqlalchemy.pool.NullPool")实现来禁用基于文件的数据库的连接池：
- en: '[PRE62]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: It’s been observed that the [`NullPool`](../core/pooling.html#sqlalchemy.pool.NullPool
    "sqlalchemy.pool.NullPool") implementation incurs an extremely small performance
    overhead for repeated checkouts due to the lack of connection re-use implemented
    by [`QueuePool`](../core/pooling.html#sqlalchemy.pool.QueuePool "sqlalchemy.pool.QueuePool").
    However, it still may be beneficial to use this class if the application is experiencing
    issues with files being locked.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用[`NullPool`](../core/pooling.html#sqlalchemy.pool.NullPool "sqlalchemy.pool.NullPool")实现时，由于[`QueuePool`](../core/pooling.html#sqlalchemy.pool.QueuePool
    "sqlalchemy.pool.QueuePool")未实现连接重用，因此对于重复检出，`NullPool`实现会产生极小的性能开销。然而，如果应用程序遇到文件被锁定的问题，仍然可能有利于使用此类。
- en: Using a Memory Database in Multiple Threads
  id: totrans-358
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在多个线程中使用内存数据库
- en: 'To use a `:memory:` database in a multithreaded scenario, the same connection
    object must be shared among threads, since the database exists only within the
    scope of that connection. The [`StaticPool`](../core/pooling.html#sqlalchemy.pool.StaticPool
    "sqlalchemy.pool.StaticPool") implementation will maintain a single connection
    globally, and the `check_same_thread` flag can be passed to Pysqlite as `False`:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 要在多线程场景中使用 `:memory:` 数据库，必须在线程之间共享同一个连接对象，因为数据库仅存在于该连接的范围内。 [`StaticPool`](../core/pooling.html#sqlalchemy.pool.StaticPool
    "sqlalchemy.pool.StaticPool") 实现将全局维护单个连接，并且可以将 `check_same_thread` 标志传递给 Pysqlite
    为 `False`。
- en: '[PRE63]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Note that using a `:memory:` database in multiple threads requires a recent
    version of SQLite.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，要在多个线程中使用 `:memory:` 数据库，需要使用最近版本的 SQLite。
- en: Using Temporary Tables with SQLite
  id: totrans-362
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 SQLite 临时表
- en: 'Due to the way SQLite deals with temporary tables, if you wish to use a temporary
    table in a file-based SQLite database across multiple checkouts from the connection
    pool, such as when using an ORM [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") where the temporary table should continue to remain
    after [`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") or [`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") is called, a pool which maintains a single
    connection must be used. Use [`SingletonThreadPool`](../core/pooling.html#sqlalchemy.pool.SingletonThreadPool
    "sqlalchemy.pool.SingletonThreadPool") if the scope is only needed within the
    current thread, or [`StaticPool`](../core/pooling.html#sqlalchemy.pool.StaticPool
    "sqlalchemy.pool.StaticPool") is scope is needed within multiple threads for this
    case:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 SQLite 处理临时表的方式，如果希望在基于文件的 SQLite 数据库中跨多个连接池检出使用临时表（例如在使用 ORM [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 时，临时表应在 [`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") 或 [`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") 调用后继续存在），则必须使用维护单个连接的池。如果范围仅在当前线程内，则使用 [`SingletonThreadPool`](../core/pooling.html#sqlalchemy.pool.SingletonThreadPool
    "sqlalchemy.pool.SingletonThreadPool")，如果此情况需要范围在多个线程内，则使用 [`StaticPool`](../core/pooling.html#sqlalchemy.pool.StaticPool
    "sqlalchemy.pool.StaticPool")：
- en: '[PRE64]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Note that [`SingletonThreadPool`](../core/pooling.html#sqlalchemy.pool.SingletonThreadPool
    "sqlalchemy.pool.SingletonThreadPool") should be configured for the number of
    threads that are to be used; beyond that number, connections will be closed out
    in a non deterministic way.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，[`SingletonThreadPool`](../core/pooling.html#sqlalchemy.pool.SingletonThreadPool
    "sqlalchemy.pool.SingletonThreadPool") 应配置为要使用的线程数；超出该数量的连接将以不确定的方式关闭。
- en: Dealing with Mixed String / Binary Columns
  id: totrans-366
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理混合字符串/二进制列
- en: The SQLite database is weakly typed, and as such it is possible when using binary
    values, which in Python are represented as `b'some string'`, that a particular
    SQLite database can have data values within different rows where some of them
    will be returned as a `b''` value by the Pysqlite driver, and others will be returned
    as Python strings, e.g. `''` values. This situation is not known to occur if the
    SQLAlchemy [`LargeBinary`](../core/type_basics.html#sqlalchemy.types.LargeBinary
    "sqlalchemy.types.LargeBinary") datatype is used consistently, however if a particular
    SQLite database has data that was inserted using the Pysqlite driver directly,
    or when using the SQLAlchemy [`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String") type which was later changed to [`LargeBinary`](../core/type_basics.html#sqlalchemy.types.LargeBinary
    "sqlalchemy.types.LargeBinary"), the table will not be consistently readable because
    SQLAlchemy’s [`LargeBinary`](../core/type_basics.html#sqlalchemy.types.LargeBinary
    "sqlalchemy.types.LargeBinary") datatype does not handle strings so it has no
    way of “encoding” a value that is in string format.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 数据库是弱类型的，因此当使用二进制值（在 Python 中表示为 `b'some string'`）时，可能发生以下情况，即特定的 SQLite
    数据库可以在不同行中返回数据值，其中某些值将由 Pysqlite 驱动程序返回为 `b''` 值，而其他值将作为 Python 字符串返回，例如 `''`
    值。如果始终一致使用 SQLAlchemy 的 [`LargeBinary`](../core/type_basics.html#sqlalchemy.types.LargeBinary
    "sqlalchemy.types.LargeBinary") 数据类型，则不知道是否会发生此情况；但是如果特定的 SQLite 数据库具有使用 Pysqlite
    驱动程序直接插入的数据，或者在使用后更改为 [`LargeBinary`](../core/type_basics.html#sqlalchemy.types.LargeBinary
    "sqlalchemy.types.LargeBinary") 的 SQLAlchemy [`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String") 类型时，该表将无法一致地读取，因为 SQLAlchemy 的 [`LargeBinary`](../core/type_basics.html#sqlalchemy.types.LargeBinary
    "sqlalchemy.types.LargeBinary") 数据类型不处理字符串，因此无法“编码”字符串格式的值。
- en: 'To deal with a SQLite table that has mixed string / binary data in the same
    column, use a custom type that will check each row individually:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 要处理具有相同列中的混合字符串/二进制数据的SQLite表，请使用一个将逐个检查每行的自定义类型：
- en: '[PRE65]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Then use the above `MixedBinary` datatype in the place where [`LargeBinary`](../core/type_basics.html#sqlalchemy.types.LargeBinary
    "sqlalchemy.types.LargeBinary") would normally be used.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在通常会使用[`LargeBinary`](../core/type_basics.html#sqlalchemy.types.LargeBinary
    "sqlalchemy.types.LargeBinary")的地方使用上述`MixedBinary`数据类型。
- en: '### Serializable isolation / Savepoints / Transactional DDL'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '### 可序列化隔离/保存点/事务DDL'
- en: In the section [Database Locking Behavior / Concurrency](#sqlite-concurrency),
    we refer to the pysqlite driver’s assortment of issues that prevent several features
    of SQLite from working correctly. The pysqlite DBAPI driver has several long-standing
    bugs which impact the correctness of its transactional behavior. In its default
    mode of operation, SQLite features such as SERIALIZABLE isolation, transactional
    DDL, and SAVEPOINT support are non-functional, and in order to use these features,
    workarounds must be taken.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 在[数据库锁定行为/并发性](#sqlite-concurrency)部分，我们提到pysqlite驱动程序的一系列问题，这些问题阻止SQLite的几个功能正常工作。
    pysqlite DBAPI驱动程序有几个长期存在的错误，影响其事务行为的正确性。在其默认操作模式下，SQLite的功能，如可序列化隔离、事务DDL和SAVEPOINT支持是不起作用的，为了使用这些功能，必须采取解决方法。
- en: The issue is essentially that the driver attempts to second-guess the user’s
    intent, failing to start transactions and sometimes ending them prematurely, in
    an effort to minimize the SQLite databases’s file locking behavior, even though
    SQLite itself uses “shared” locks for read-only activities.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 问题实质上是驱动程序试图猜测用户意图，未能启动事务，有时会过早结束事务，以减少SQLite数据库的文件锁定行为，尽管SQLite本身对只读活动使用“共享”锁。
- en: SQLAlchemy chooses to not alter this behavior by default, as it is the long-expected
    behavior of the pysqlite driver; if and when the pysqlite driver attempts to repair
    these issues, that will be more of a driver towards defaults for SQLAlchemy.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy选择默认情况下不更改此行为，因为这是pysqlite驱动程序的长期预期行为；如果pysqlite驱动程序尝试修复这些问��，那将更多地推动SQLAlchemy的默认值。
- en: 'The good news is that with a few events, we can implement transactional support
    fully, by disabling pysqlite’s feature entirely and emitting BEGIN ourselves.
    This is achieved using two event listeners:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，通过几个事件，我们可以完全实现事务支持，通过完全禁用pysqlite的功能并自己发出BEGIN。这是通过使用两个事件监听器实现的：
- en: '[PRE66]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Warning
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: When using the above recipe, it is advised to not use the [`Connection.execution_options.isolation_level`](../core/connections.html#sqlalchemy.engine.Connection.execution_options.params.isolation_level
    "sqlalchemy.engine.Connection.execution_options") setting on [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") and [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") with the SQLite driver, as this function necessarily
    will also alter the “.isolation_level” setting.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用上述配方时，建议不要在SQLite驱动程序上使用[`Connection.execution_options.isolation_level`](../core/connections.html#sqlalchemy.engine.Connection.execution_options.params.isolation_level
    "sqlalchemy.engine.Connection.execution_options")设置[`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")和[`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine")，因为此函数必然也会改变“.isolation_level”设置。
- en: Above, we intercept a new pysqlite connection and disable any transactional
    integration. Then, at the point at which SQLAlchemy knows that transaction scope
    is to begin, we emit `"BEGIN"` ourselves.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面，我们拦截一个新的pysqlite连接并禁用任何事务集成。然后，在SQLAlchemy知道事务范围将开始的时候，我们自己发出`"BEGIN"`。
- en: 'When we take control of `"BEGIN"`, we can also control directly SQLite’s locking
    modes, introduced at [BEGIN TRANSACTION](https://sqlite.org/lang_transaction.html),
    by adding the desired locking mode to our `"BEGIN"`:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们控制`"BEGIN"`时，我们还可以直接控制SQLite的锁定模式，通过将所需的锁定模式添加到我们的`"BEGIN"`中引入的[开始事务](https://sqlite.org/lang_transaction.html)：
- en: '[PRE67]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: See also
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[BEGIN TRANSACTION](https://sqlite.org/lang_transaction.html) - on the SQLite
    site'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '[开始事务](https://sqlite.org/lang_transaction.html) - 在SQLite网站上'
- en: '[sqlite3 SELECT does not BEGIN a transaction](https://bugs.python.org/issue9924)
    - on the Python bug tracker'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '[sqlite3 SELECT不会BEGIN事务](https://bugs.python.org/issue9924) - 在Python错误跟踪器上'
- en: '[sqlite3 module breaks transactions and potentially corrupts data](https://bugs.python.org/issue10740)
    - on the Python bug tracker  ### User-Defined Functions'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '[sqlite3模块中断事务并可能损坏数据](https://bugs.python.org/issue10740) - 在Python错误跟踪器上  ###
    用户定义的函数'
- en: pysqlite supports a [create_function()](https://docs.python.org/3/library/sqlite3.html#sqlite3.Connection.create_function)
    method that allows us to create our own user-defined functions (UDFs) in Python
    and use them directly in SQLite queries. These functions are registered with a
    specific DBAPI Connection.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: pysqlite 支持一个 [create_function()](https://docs.python.org/3/library/sqlite3.html#sqlite3.Connection.create_function)
    方法，允许我们在 Python 中创建自己的用户定义的函数 (UDFs)，并直接在 SQLite 查询中使用它们。这些函数已与特定的 DBAPI 连接注册。
- en: 'SQLAlchemy uses connection pooling with file-based SQLite databases, so we
    need to ensure that the UDF is attached to the connection when it is created.
    That is accomplished with an event listener:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 使用基于文件的 SQLite 数据库的连接池，因此我们需要确保在创建连接时将 UDF 附加到连接。这通过事件监听器实现：
- en: '[PRE68]  ## Aiosqlite'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE68]  ## Aiosqlite'
- en: Support for the SQLite database via the aiosqlite driver.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 aiosqlite 驱动程序支持 SQLite 数据库。
- en: DBAPI
  id: totrans-390
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: DBAPI
- en: 'Documentation and download information (if applicable) for aiosqlite is available
    at: [https://pypi.org/project/aiosqlite/](https://pypi.org/project/aiosqlite/)'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: aiosqlite 的文档和下载信息（如果适用）可在此处获得：[https://pypi.org/project/aiosqlite/](https://pypi.org/project/aiosqlite/)
- en: Connecting
  id: totrans-392
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接
- en: 'Connect String:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 连接字符串：
- en: '[PRE69]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The aiosqlite dialect provides support for the SQLAlchemy asyncio interface
    running on top of pysqlite.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: aiosqlite 方言提供了对运行在 pysqlite 之上的 SQLAlchemy asyncio 接口的支持。
- en: aiosqlite is a wrapper around pysqlite that uses a background thread for each
    connection. It does not actually use non-blocking IO, as SQLite databases are
    not socket-based. However it does provide a working asyncio interface that’s useful
    for testing and prototyping purposes.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: aiosqlite 是对 pysqlite 的封装，每个连接使用一个后台线程。它实际上不使用非阻塞 IO，因为 SQLite 数据库不是基于套接字的。但是它提供了一个可用于测试和原型设计的工作
    asyncio 接口。
- en: Using a special asyncio mediation layer, the aiosqlite dialect is usable as
    the backend for the [SQLAlchemy asyncio](../orm/extensions/asyncio.html) extension
    package.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 使用特殊的 asyncio 中介层，aiosqlite 方言可作为 [SQLAlchemy asyncio](../orm/extensions/asyncio.html)
    扩展包的后端使用。
- en: 'This dialect should normally be used only with the [`create_async_engine()`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.create_async_engine
    "sqlalchemy.ext.asyncio.create_async_engine") engine creation function:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 通常应使用 [`create_async_engine()`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.create_async_engine
    "sqlalchemy.ext.asyncio.create_async_engine") 引擎创建函数创建此方言：
- en: '[PRE70]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The URL passes through all arguments to the `pysqlite` driver, so all connection
    arguments are the same as they are for that of [Pysqlite](#pysqlite).
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: URL 通过所有参数传递给 `pysqlite` 驱动程序，因此所有连接参数与 [Pysqlite](#pysqlite) 的相同。
- en: '### User-Defined Functions'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '### 用户定义的函数'
- en: 'aiosqlite extends pysqlite to support async, so we can create our own user-defined
    functions (UDFs) in Python and use them directly in SQLite queries as described
    here: [User-Defined Functions](#pysqlite-udfs).  ### Serializable isolation /
    Savepoints / Transactional DDL (asyncio version)'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: aiosqlite 扩展了 pysqlite 以支持异步，因此我们可以在 Python 中创建自定义用户定义的函数 (UDFs)，并直接在 SQLite
    查询中使用它们，如此处所述：[用户定义的函数](#pysqlite-udfs)。### Serializable isolation / Savepoints
    / Transactional DDL (asyncio 版本)
- en: Similarly to pysqlite, aiosqlite does not support SAVEPOINT feature.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于 pysqlite，aiosqlite 不支持 SAVEPOINT 功能。
- en: 'The solution is similar to [Serializable isolation / Savepoints / Transactional
    DDL](#pysqlite-serializable). This is achieved by the event listeners in async:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案类似于 [Serializable isolation / Savepoints / Transactional DDL](#pysqlite-serializable)。这是通过
    async 中的事件监听器实现的：
- en: '[PRE71]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Warning
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: 'When using the above recipe, it is advised to not use the [`Connection.execution_options.isolation_level`](../core/connections.html#sqlalchemy.engine.Connection.execution_options.params.isolation_level
    "sqlalchemy.engine.Connection.execution_options") setting on [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") and [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") with the SQLite driver, as this function necessarily
    will also alter the “.isolation_level” setting.  ## Pysqlcipher'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用以上方案时，建议不要在 SQLite 驱动程序上使用 [`Connection.execution_options.isolation_level`](../core/connections.html#sqlalchemy.engine.Connection.execution_options.params.isolation_level
    "sqlalchemy.engine.Connection.execution_options") 设置 [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") 和 [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") ，因为该函数必然也会改变 “.isolation_level” 设置。## Pysqlcipher
- en: Support for the SQLite database via the pysqlcipher driver.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 pysqlcipher 驱动程序支持 SQLite 数据库。
- en: Dialect for support of DBAPIs that make use of the [SQLCipher](https://www.zetetic.net/sqlcipher)
    backend.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 为支持利用 [SQLCipher](https://www.zetetic.net/sqlcipher) 后端的 DBAPI 提供方言。
- en: Connecting
  id: totrans-410
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接中
- en: 'Connect String:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 连接字符串：
- en: '[PRE72]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Driver
  id: totrans-413
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 驱动程序
- en: 'Current dialect selection logic is:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的方言选择逻辑是：
- en: If the [`create_engine.module`](../core/engines.html#sqlalchemy.create_engine.params.module
    "sqlalchemy.create_engine") parameter supplies a DBAPI module, that module is
    used.
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 [`create_engine.module`](../core/engines.html#sqlalchemy.create_engine.params.module)
    参数提供了一个 DBAPI 模块，则使用该模块。
- en: Otherwise for Python 3, choose [https://pypi.org/project/sqlcipher3/](https://pypi.org/project/sqlcipher3/)
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则对于 Python 3，选择[https://pypi.org/project/sqlcipher3/](https://pypi.org/project/sqlcipher3/)
- en: If not available, fall back to [https://pypi.org/project/pysqlcipher3/](https://pypi.org/project/pysqlcipher3/)
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果不可用，回退到[https://pypi.org/project/pysqlcipher3/](https://pypi.org/project/pysqlcipher3/)
- en: For Python 2, [https://pypi.org/project/pysqlcipher/](https://pypi.org/project/pysqlcipher/)
    is used.
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 Python 2，使用[https://pypi.org/project/pysqlcipher/](https://pypi.org/project/pysqlcipher/)。
- en: Warning
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: 'The `pysqlcipher3` and `pysqlcipher` DBAPI drivers are no longer maintained;
    the `sqlcipher3` driver as of this writing appears to be current. For future compatibility,
    any pysqlcipher-compatible DBAPI may be used as follows:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 截止到目前为止，`pysqlcipher3` 和 `pysqlcipher` DBAPI 驱动程序不再维护；`sqlcipher3` 驱动程序似乎是当前的。为了未来的兼容性，可以使用任何兼容
    pysqlcipher 的 DBAPI 如下所示：
- en: '[PRE73]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: These drivers make use of the SQLCipher engine. This system essentially introduces
    new PRAGMA commands to SQLite which allows the setting of a passphrase and other
    encryption parameters, allowing the database file to be encrypted.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 这些驱动程序利用了 SQLCipher 引擎。该系统基本上引入了新的 PRAGMA 命令到 SQLite，这允许设置密码和其他加密参数，从而允许加密数据库文件。
- en: Connect Strings
  id: totrans-423
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接字符串
- en: 'The format of the connect string is in every way the same as that of the [`pysqlite`](#module-sqlalchemy.dialects.sqlite.pysqlite
    "sqlalchemy.dialects.sqlite.pysqlite") driver, except that the “password” field
    is now accepted, which should contain a passphrase:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 连接字符串的格式在每个方面与 [`pysqlite`](#module-sqlalchemy.dialects.sqlite.pysqlite) 驱动程序的格式相同，除了现在接受“密码”字段，该字段应包含一个密码：
- en: '[PRE74]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'For an absolute file path, two leading slashes should be used for the database
    name:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 对于绝对文件路径，应该使用两个前导斜杠作为数据库名：
- en: '[PRE75]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'A selection of additional encryption-related pragmas supported by SQLCipher
    as documented at [https://www.zetetic.net/sqlcipher/sqlcipher-api/](https://www.zetetic.net/sqlcipher/sqlcipher-api/)
    can be passed in the query string, and will result in that PRAGMA being called
    for each new connection. Currently, `cipher`, `kdf_iter` `cipher_page_size` and
    `cipher_use_hmac` are supported:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过查询字符串传递一系列由 SQLCipher 支持的附加加密相关的 PRAGMA，如 [https://www.zetetic.net/sqlcipher/sqlcipher-api/](https://www.zetetic.net/sqlcipher/sqlcipher-api/)
    中所述，并且将导致每个新连接调用该 PRAGMA。目前，支持 `cipher`、`kdf_iter`、`cipher_page_size` 和 `cipher_use_hmac`：
- en: '[PRE76]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Warning
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: Previous versions of sqlalchemy did not take into consideration the encryption-related
    pragmas passed in the url string, that were silently ignored. This may cause errors
    when opening files saved by a previous sqlalchemy version if the encryption options
    do not match.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 先前版本的 sqlalchemy 没有考虑到在 url 字符串中传递的与加密相关的 PRAGMA，这些 PRAGMA 被悄悄地忽略了。如果加密选项不匹配，这可能会导致打开由之前的
    sqlalchemy 版本保存的文件时出错。
- en: Pooling Behavior
  id: totrans-432
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 池行为
- en: The driver makes a change to the default pool behavior of pysqlite as described
    in [Threading/Pooling Behavior](#pysqlite-threading-pooling). The pysqlcipher
    driver has been observed to be significantly slower on connection than the pysqlite
    driver, most likely due to the encryption overhead, so the dialect here defaults
    to using the [`SingletonThreadPool`](../core/pooling.html#sqlalchemy.pool.SingletonThreadPool
    "sqlalchemy.pool.SingletonThreadPool") implementation, instead of the [`NullPool`](../core/pooling.html#sqlalchemy.pool.NullPool
    "sqlalchemy.pool.NullPool") pool used by pysqlite. As always, the pool implementation
    is entirely configurable using the [`create_engine.poolclass`](../core/engines.html#sqlalchemy.create_engine.params.poolclass
    "sqlalchemy.create_engine") parameter; the `StaticPool` may be more feasible for
    single-threaded use, or [`NullPool`](../core/pooling.html#sqlalchemy.pool.NullPool
    "sqlalchemy.pool.NullPool") may be used to prevent unencrypted connections from
    being held open for long periods of time, at the expense of slower startup time
    for new connections.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 驱动程序对pysqlite的默认池行为进行了更改，如[线程/池行为](#pysqlite-threading-pooling)中所述。观察到pysqlcipher驱动程序连接速度比pysqlite驱动程序慢得多，很可能是由于加密开销，因此该方言在这里默认使用[`SingletonThreadPool`](../core/pooling.html#sqlalchemy.pool.SingletonThreadPool
    "sqlalchemy.pool.SingletonThreadPool")实现，而不是pysqlite使用的[`NullPool`](../core/pooling.html#sqlalchemy.pool.NullPool
    "sqlalchemy.pool.NullPool")池。与往常一样，可以使用[`create_engine.poolclass`](../core/engines.html#sqlalchemy.create_engine.params.poolclass
    "sqlalchemy.create_engine")参数完全配置池实现；`StaticPool`可能更适合单线程使用，或者可以使用[`NullPool`](../core/pooling.html#sqlalchemy.pool.NullPool
    "sqlalchemy.pool.NullPool")来防止未加密的连接被长时间保持打开，但新连接的启动时间较慢。
- en: Support for the SQLite database.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 支持SQLite数据库。
- en: The following table summarizes current support levels for database release versions.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表总结了当前数据库发布版本的支持水平。
- en: '**Supported SQLite versions**'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: '**支持的SQLite版本**'
- en: '| Support type | Versions |'
  id: totrans-437
  prefs: []
  type: TYPE_TB
  zh: '| 支持类型 | 版本 |'
- en: '| --- | --- |'
  id: totrans-438
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| [Fully tested in CI](index.html#term-Fully-tested-in-CI) | 3.36.0 |'
  id: totrans-439
  prefs: []
  type: TYPE_TB
  zh: '| [在CI中完全测试](index.html#term-Fully-tested-in-CI) | 3.36.0 |'
- en: '| [Normal support](index.html#term-Normal-support) | 3.12+ |'
  id: totrans-440
  prefs: []
  type: TYPE_TB
  zh: '| [常规支持](index.html#term-Normal-support) | 3.12+ |'
- en: '| [Best effort](index.html#term-Best-effort) | 3.7.16+ |'
  id: totrans-441
  prefs: []
  type: TYPE_TB
  zh: '| [尽力而为](index.html#term-Best-effort) | 3.7.16+ |'
- en: DBAPI Support
  id: totrans-442
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DBAPI支持
- en: The following dialect/DBAPI options are available. Please refer to individual
    DBAPI sections for connect information.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 可用以下方言/DBAPI选项。请参考各个DBAPI部分以获取连接信息。
- en: '[pysqlite](#module-sqlalchemy.dialects.sqlite.pysqlite)'
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[pysqlite](#module-sqlalchemy.dialects.sqlite.pysqlite)'
- en: '[aiosqlite](#module-sqlalchemy.dialects.sqlite.aiosqlite)'
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[aiosqlite](#module-sqlalchemy.dialects.sqlite.aiosqlite)'
- en: '[pysqlcipher](#module-sqlalchemy.dialects.sqlite.pysqlcipher)'
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[pysqlcipher](#module-sqlalchemy.dialects.sqlite.pysqlcipher)'
- en: '## Date and Time Types'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: '## 日期和时间类型'
- en: SQLite does not have built-in DATE, TIME, or DATETIME types, and pysqlite does
    not provide out of the box functionality for translating values between Python
    datetime objects and a SQLite-supported format. SQLAlchemy’s own [`DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime
    "sqlalchemy.types.DateTime") and related types provide date formatting and parsing
    functionality when SQLite is used. The implementation classes are [`DATETIME`](#sqlalchemy.dialects.sqlite.DATETIME
    "sqlalchemy.dialects.sqlite.DATETIME"), [`DATE`](#sqlalchemy.dialects.sqlite.DATE
    "sqlalchemy.dialects.sqlite.DATE") and [`TIME`](#sqlalchemy.dialects.sqlite.TIME
    "sqlalchemy.dialects.sqlite.TIME"). These types represent dates and times as ISO
    formatted strings, which also nicely support ordering. There’s no reliance on
    typical “libc” internals for these functions so historical dates are fully supported.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite没有内置的DATE、TIME或DATETIME类型，而pysqlite也没有提供将值在Python datetime对象和SQLite支持的格式之间转换的开箱即用功能。当使用SQLite时，SQLAlchemy自己的[`DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime
    "sqlalchemy.types.DateTime")和相关类型提供日期格式化和解析功能。实现类是[`DATETIME`](#sqlalchemy.dialects.sqlite.DATETIME
    "sqlalchemy.dialects.sqlite.DATETIME")、[`DATE`](#sqlalchemy.dialects.sqlite.DATE
    "sqlalchemy.dialects.sqlite.DATE")和[`TIME`](#sqlalchemy.dialects.sqlite.TIME "sqlalchemy.dialects.sqlite.TIME")。这些类型将日期和时间表示为ISO格式的字符串，这也很好地支持排序。这些函数不依赖于典型的“libc”内部，因此完全支持历史日期。
- en: Ensuring Text affinity
  id: totrans-449
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 确保文本亲和性
- en: The DDL rendered for these types is the standard `DATE`, `TIME` and `DATETIME`
    indicators. However, custom storage formats can also be applied to these types.
    When the storage format is detected as containing no alpha characters, the DDL
    for these types is rendered as `DATE_CHAR`, `TIME_CHAR`, and `DATETIME_CHAR`,
    so that the column continues to have textual affinity.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型的DDL呈现是标准的 `DATE`、`TIME` 和 `DATETIME` 指示符。然而，这些类型也可以应用自定义的存储格式。当检测到存储格式不包含任何字母字符时，这些类型的DDL将呈现为
    `DATE_CHAR`、`TIME_CHAR` 和 `DATETIME_CHAR`，以便列继续具有文本亲和性。
- en: See also
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 参见
- en: '[Type Affinity](https://www.sqlite.org/datatype3.html#affinity) - in the SQLite
    documentation'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: '[类型亲和性](https://www.sqlite.org/datatype3.html#affinity) - SQLite 文档中的内容'
- en: Ensuring Text affinity
  id: totrans-453
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 确保文本亲和性
- en: The DDL rendered for these types is the standard `DATE`, `TIME` and `DATETIME`
    indicators. However, custom storage formats can also be applied to these types.
    When the storage format is detected as containing no alpha characters, the DDL
    for these types is rendered as `DATE_CHAR`, `TIME_CHAR`, and `DATETIME_CHAR`,
    so that the column continues to have textual affinity.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型的DDL呈现是标准的 `DATE`、`TIME` 和 `DATETIME` 指示符。然而，这些类型也可以应用自定义的存储格式。当检测到存储格式不包含任何字母字符时，这些类型的DDL将呈现为
    `DATE_CHAR`、`TIME_CHAR` 和 `DATETIME_CHAR`，以便列继续具有文本亲和性。
- en: See also
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 参见
- en: '[Type Affinity](https://www.sqlite.org/datatype3.html#affinity) - in the SQLite
    documentation'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: '[类型亲和性](https://www.sqlite.org/datatype3.html#affinity) - SQLite 文档中的内容'
- en: '## SQLite Auto Incrementing Behavior'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: '## SQLite 自动增量行为'
- en: 'Background on SQLite’s autoincrement is at: [https://sqlite.org/autoinc.html](https://sqlite.org/autoinc.html)'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 SQLite 的自动增量的背景信息请参阅：[https://sqlite.org/autoinc.html](https://sqlite.org/autoinc.html)
- en: 'Key concepts:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 关键概念：
- en: SQLite has an implicit “auto increment” feature that takes place for any non-composite
    primary-key column that is specifically created using “INTEGER PRIMARY KEY” for
    the type + primary key.
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQLite 具有隐式的“自动增量”功能，适用于任何使用“INTEGER PRIMARY KEY”来明确创建的非复合主键列。
- en: SQLite also has an explicit “AUTOINCREMENT” keyword, that is **not** equivalent
    to the implicit autoincrement feature; this keyword is not recommended for general
    use. SQLAlchemy does not render this keyword unless a special SQLite-specific
    directive is used (see below). However, it still requires that the column’s type
    is named “INTEGER”.
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQLite 还具有显式的 “AUTOINCREMENT” 关键字，这与隐式自动增量功能 **不** 等同；不建议一般使用这个关键字。SQLAlchemy
    不会呈现此关键字，除非使用特殊的特定于 SQLite 的指令（见下文）。但是，它仍然要求列的类型被命名为 “INTEGER”。
- en: Using the AUTOINCREMENT Keyword
  id: totrans-462
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 AUTOINCREMENT 关键字
- en: 'To specifically render the AUTOINCREMENT keyword on the primary key column
    when rendering DDL, add the flag `sqlite_autoincrement=True` to the Table construct:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 要在渲染 DDL 时在主键列上具体呈现 AUTOINCREMENT 关键字，请将 `sqlite_autoincrement=True` 标志添加到 Table
    构造函数中：
- en: '[PRE77]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Allowing autoincrement behavior SQLAlchemy types other than Integer/INTEGER
  id: totrans-465
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 允许除 Integer/INTEGER 之外的 SQLAlchemy 类型具有自动增量行为
- en: SQLite’s typing model is based on naming conventions. Among other things, this
    means that any type name which contains the substring `"INT"` will be determined
    to be of “integer affinity”. A type named `"BIGINT"`, `"SPECIAL_INT"` or even
    `"XYZINTQPR"`, will be considered by SQLite to be of “integer” affinity. However,
    **the SQLite autoincrement feature, whether implicitly or explicitly enabled,
    requires that the name of the column’s type is exactly the string “INTEGER”**.
    Therefore, if an application uses a type like [`BigInteger`](../core/type_basics.html#sqlalchemy.types.BigInteger
    "sqlalchemy.types.BigInteger") for a primary key, on SQLite this type will need
    to be rendered as the name `"INTEGER"` when emitting the initial `CREATE TABLE`
    statement in order for the autoincrement behavior to be available.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 的类型模型基于命名约定。这意味着包含子字符串 `"INT"` 的任何类型名称都将被确定为“整数亲和性”。一个名为 `"BIGINT"`、`"SPECIAL_INT"`
    或甚至 `"XYZINTQPR"` 的类型都将被 SQLite 视为“整数”亲和性。然而，**无论隐式还是显式启用了 SQLite 的自动增量功能，列类型的名称都必须正好是字符串
    “INTEGER”**。因此，如果应用程序使用 [`BigInteger`](../core/type_basics.html#sqlalchemy.types.BigInteger
    "sqlalchemy.types.BigInteger") 作为主键的类型，在 SQLite 上，当在发出初始的 `CREATE TABLE` 语句时，这个类型将需要被渲染为名称
    `"INTEGER"`，以便自动增量行为可用。
- en: 'One approach to achieve this is to use [`Integer`](../core/type_basics.html#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer") on SQLite only using [`TypeEngine.with_variant()`](../core/type_api.html#sqlalchemy.types.TypeEngine.with_variant
    "sqlalchemy.types.TypeEngine.with_variant"):'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: '实现此目标的一种方法是仅在 SQLite 上使用 [`TypeEngine.with_variant()`](../core/type_api.html#sqlalchemy.types.TypeEngine.with_variant
    "sqlalchemy.types.TypeEngine.with_variant") 使用 [`Integer`](../core/type_basics.html#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer"):'
- en: '[PRE78]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Another is to use a subclass of [`BigInteger`](../core/type_basics.html#sqlalchemy.types.BigInteger
    "sqlalchemy.types.BigInteger") that overrides its DDL name to be `INTEGER` when
    compiled against SQLite:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是使用 [`BigInteger`](../core/type_basics.html#sqlalchemy.types.BigInteger
    "sqlalchemy.types.BigInteger") 的子类，当编译针对 SQLite 时，重写其 DDL 名称为 `INTEGER`：
- en: '[PRE79]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: See also
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`TypeEngine.with_variant()`](../core/type_api.html#sqlalchemy.types.TypeEngine.with_variant
    "sqlalchemy.types.TypeEngine.with_variant")'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: '[`TypeEngine.with_variant()`](../core/type_api.html#sqlalchemy.types.TypeEngine.with_variant
    "sqlalchemy.types.TypeEngine.with_variant")'
- en: '[Custom SQL Constructs and Compilation Extension](../core/compiler.html)'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: '[自定义 SQL 构造和编译扩展](../core/compiler.html)'
- en: '[Datatypes In SQLite Version 3](https://sqlite.org/datatype3.html)'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: '[SQLite 版本 3 中的数据类型](https://sqlite.org/datatype3.html)'
- en: Using the AUTOINCREMENT Keyword
  id: totrans-475
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 AUTOINCREMENT 关键字
- en: 'To specifically render the AUTOINCREMENT keyword on the primary key column
    when rendering DDL, add the flag `sqlite_autoincrement=True` to the Table construct:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 要在渲染 DDL 时特别呈现主键列上的 AUTOINCREMENT 关键字，请向 Table 构造添加标志 `sqlite_autoincrement=True`：
- en: '[PRE80]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Allowing autoincrement behavior SQLAlchemy types other than Integer/INTEGER
  id: totrans-478
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 允许除 Integer/INTEGER 外的 SQLAlchemy 类型具有自增行为
- en: SQLite’s typing model is based on naming conventions. Among other things, this
    means that any type name which contains the substring `"INT"` will be determined
    to be of “integer affinity”. A type named `"BIGINT"`, `"SPECIAL_INT"` or even
    `"XYZINTQPR"`, will be considered by SQLite to be of “integer” affinity. However,
    **the SQLite autoincrement feature, whether implicitly or explicitly enabled,
    requires that the name of the column’s type is exactly the string “INTEGER”**.
    Therefore, if an application uses a type like [`BigInteger`](../core/type_basics.html#sqlalchemy.types.BigInteger
    "sqlalchemy.types.BigInteger") for a primary key, on SQLite this type will need
    to be rendered as the name `"INTEGER"` when emitting the initial `CREATE TABLE`
    statement in order for the autoincrement behavior to be available.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 的类型模型基于命名约定。除其他外，这意味着包含子字符串 `"INT"` 的任何类型名称都将被确定为“整数亲和性”。类型名称为 `"BIGINT"`、`"SPECIAL_INT"`
    甚至 `"XYZINTQPR"` 的类型，SQLite 都会将其视为“整数”亲和性。然而，**无论是隐式还是显式启用的 SQLite 自增特性，都要求列的类型名称正好是字符串“INTEGER”**。因此，如果应用程序使用类似
    [`BigInteger`](../core/type_basics.html#sqlalchemy.types.BigInteger "sqlalchemy.types.BigInteger")
    的类型作为主键，在 SQLite 上，此类型在发出初始的 `CREATE TABLE` 语句时需要呈现为名称 `"INTEGER"`，以便自增行为可用。
- en: 'One approach to achieve this is to use [`Integer`](../core/type_basics.html#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer") on SQLite only using [`TypeEngine.with_variant()`](../core/type_api.html#sqlalchemy.types.TypeEngine.with_variant
    "sqlalchemy.types.TypeEngine.with_variant"):'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: '实现此目标的一种方法是仅在 SQLite 上使用 [`TypeEngine.with_variant()`](../core/type_api.html#sqlalchemy.types.TypeEngine.with_variant
    "sqlalchemy.types.TypeEngine.with_variant") 使用 [`Integer`](../core/type_basics.html#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer"):'
- en: '[PRE81]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Another is to use a subclass of [`BigInteger`](../core/type_basics.html#sqlalchemy.types.BigInteger
    "sqlalchemy.types.BigInteger") that overrides its DDL name to be `INTEGER` when
    compiled against SQLite:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是使用 [`BigInteger`](../core/type_basics.html#sqlalchemy.types.BigInteger
    "sqlalchemy.types.BigInteger") 的子类，当编译针对 SQLite 时，重写其 DDL 名称为 `INTEGER`：
- en: '[PRE82]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: See also
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`TypeEngine.with_variant()`](../core/type_api.html#sqlalchemy.types.TypeEngine.with_variant
    "sqlalchemy.types.TypeEngine.with_variant")'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: '[`TypeEngine.with_variant()`](../core/type_api.html#sqlalchemy.types.TypeEngine.with_variant
    "sqlalchemy.types.TypeEngine.with_variant")'
- en: '[Custom SQL Constructs and Compilation Extension](../core/compiler.html)'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: '[自定义 SQL 构造和编译扩展](../core/compiler.html)'
- en: '[Datatypes In SQLite Version 3](https://sqlite.org/datatype3.html)'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: '[SQLite 版本 3 中的数据类型](https://sqlite.org/datatype3.html)'
- en: '## Database Locking Behavior / Concurrency'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: '## 数据库锁定行为 / 并发'
- en: SQLite is not designed for a high level of write concurrency. The database itself,
    being a file, is locked completely during write operations within transactions,
    meaning exactly one “connection” (in reality a file handle) has exclusive access
    to the database during this period - all other “connections” will be blocked during
    this time.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 并不适用于高度写并发性。数据库本身，作为一个文件，在事务内的写操作期间完全被锁定，这意味着在此期间仅有一个“连接”（实际上是一个文件句柄）对数据库具有独占访问权限
    - 在此期间所有其他“连接”都将被阻塞。
- en: The Python DBAPI specification also calls for a connection model that is always
    in a transaction; there is no `connection.begin()` method, only `connection.commit()`
    and `connection.rollback()`, upon which a new transaction is to be begun immediately.
    This may seem to imply that the SQLite driver would in theory allow only a single
    filehandle on a particular database file at any time; however, there are several
    factors both within SQLite itself as well as within the pysqlite driver which
    loosen this restriction significantly.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: Python DBAPI 规范还要求一个始终处于事务中的连接模型；没有 `connection.begin()` 方法，只有 `connection.commit()`
    和 `connection.rollback()`，在这之后立即开始一个新事务。这似乎暗示着 SQLite 驱动理论上只允许在任何时候对特定数据库文件进行单个文件句柄的访问；然而，SQLite
    本身以及 pysqlite 驱动程序中有几个因素大大放宽了这个限制。
- en: However, no matter what locking modes are used, SQLite will still always lock
    the database file once a transaction is started and DML (e.g. INSERT, UPDATE,
    DELETE) has at least been emitted, and this will block other transactions at least
    at the point that they also attempt to emit DML. By default, the length of time
    on this block is very short before it times out with an error.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，无论使用什么锁定模式，一旦启动事务并且已经发出了 DML（例如 INSERT、UPDATE、DELETE），SQLite 都会锁定数据库文件，这将至少在其他事务也试图发出
    DML 的时候阻塞其他事务。默认情况下，在此阻塞的时间长度非常短，超时后会出现错误。
- en: This behavior becomes more critical when used in conjunction with the SQLAlchemy
    ORM. SQLAlchemy’s [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    object by default runs within a transaction, and with its autoflush model, may
    emit DML preceding any SELECT statement. This may lead to a SQLite database that
    locks more quickly than is expected. The locking mode of SQLite and the pysqlite
    driver can be manipulated to some degree, however it should be noted that achieving
    a high degree of write-concurrency with SQLite is a losing battle.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 当与 SQLAlchemy ORM 结合使用时，这种行为变得更加关键。SQLAlchemy 的 [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 对象默认在事务内运行，并且使用其自动刷新模型，可能会在任何 SELECT 语句之前发出 DML。这可能导致
    SQLite 数据库比预期更快地锁定。SQLite 和 pysqlite 驱动程序的锁定模式可以在一定程度上被操纵，但应注意，要想在 SQLite 中实现高度的写并发性是一场失败的战斗。
- en: For more information on SQLite’s lack of write concurrency by design, please
    see [Situations Where Another RDBMS May Work Better - High Concurrency](https://www.sqlite.org/whentouse.html)
    near the bottom of the page.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 欲了解 SQLite 的设计缺乏写并发性的更多信息，请参阅[在哪些情况下另一个 RDBMS 可能更适合使用 - 高并发性](https://www.sqlite.org/whentouse.html)，页面底部。
- en: The following subsections introduce areas that are impacted by SQLite’s file-based
    architecture and additionally will usually require workarounds to work when using
    the pysqlite driver.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 以下子节介绍了受 SQLite 的基于文件的架构影响的领域，此外，通常在使用 pysqlite 驱动程序时需要一些解决方法。
- en: '## Transaction Isolation Level / Autocommit'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: '## 事务隔离级别 / 自动提交'
- en: SQLite supports “transaction isolation” in a non-standard way, along two axes.
    One is that of the [PRAGMA read_uncommitted](https://www.sqlite.org/pragma.html#pragma_read_uncommitted)
    instruction. This setting can essentially switch SQLite between its default mode
    of `SERIALIZABLE` isolation, and a “dirty read” isolation mode normally referred
    to as `READ UNCOMMITTED`.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 以一种非标准的方式支持“事务隔离”，沿着两个轴线。一个是[PRAGMA read_uncommitted](https://www.sqlite.org/pragma.html#pragma_read_uncommitted)
    指令。这个设置可以基本上在 SQLite 的默认模式 `SERIALIZABLE` 隔离和一个通常称为 `READ UNCOMMITTED` 的“脏读”隔离模式之间切换。
- en: SQLAlchemy ties into this PRAGMA statement using the [`create_engine.isolation_level`](../core/engines.html#sqlalchemy.create_engine.params.isolation_level
    "sqlalchemy.create_engine") parameter of [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine"). Valid values for this parameter when used with SQLite
    are `"SERIALIZABLE"` and `"READ UNCOMMITTED"` corresponding to a value of 0 and
    1, respectively. SQLite defaults to `SERIALIZABLE`, however its behavior is impacted
    by the pysqlite driver’s default behavior.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy使用[`create_engine.isolation_level`](../core/engines.html#sqlalchemy.create_engine.params.isolation_level
    "sqlalchemy.create_engine")参数来连接到此PRAGMA语句[`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine")。在与SQLite一起使用此参数的有效值是`"SERIALIZABLE"`和`"READ UNCOMMITTED"`，分别对应于0和1的值。SQLite默认为`SERIALIZABLE`，但其行为受到pysqlite驱动程序的默认行为的影响。
- en: When using the pysqlite driver, the `"AUTOCOMMIT"` isolation level is also available,
    which will alter the pysqlite connection using the `.isolation_level` attribute
    on the DBAPI connection and set it to None for the duration of the setting.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 使用pysqlite驱动程序时，还可以使用`"AUTOCOMMIT"`隔离级别，该级别将通过DBAPI连接的`.isolation_level`属性更改pysqlite连接，并将其设置为None以进行设置的持续时间。
- en: 'New in version 1.3.16: added support for SQLite AUTOCOMMIT isolation level
    when using the pysqlite / sqlite3 SQLite driver.'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 版本1.3.16中的新功能：在使用pysqlite/sqlite3 SQLite驱动程序时增加了对SQLite AUTOCOMMIT隔离级别的支持。
- en: The other axis along which SQLite’s transactional locking is impacted is via
    the nature of the `BEGIN` statement used. The three varieties are “deferred”,
    “immediate”, and “exclusive”, as described at [BEGIN TRANSACTION](https://sqlite.org/lang_transaction.html).
    A straight `BEGIN` statement uses the “deferred” mode, where the database file
    is not locked until the first read or write operation, and read access remains
    open to other transactions until the first write operation. But again, it is critical
    to note that the pysqlite driver interferes with this behavior by *not even emitting
    BEGIN* until the first write operation.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite的事务锁定受影响的另一个轴是通过使用的`BEGIN`语句的性质。这三种类型是“延迟”、“立即”和“独占”，如[开始事务](https://sqlite.org/lang_transaction.html)所述。直接的`BEGIN`语句使用“延迟”模式，在第一次读取或写入操作之前不锁定数据库文件，并且读取访问在第一次写入操作之前仍然对其他事务开放。但需要再次强调的是，pysqlite驱动器通过*甚至不发出BEGIN*直到第一次写入操作来干扰此行为。
- en: Warning
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: SQLite’s transactional scope is impacted by unresolved issues in the pysqlite
    driver, which defers BEGIN statements to a greater degree than is often feasible.
    See the section [Serializable isolation / Savepoints / Transactional DDL](#pysqlite-serializable)
    or [Serializable isolation / Savepoints / Transactional DDL (asyncio version)](#aiosqlite-serializable)
    for techniques to work around this behavior.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite的事务范围受到pysqlite驱动程序中未解决的问题的影响，该问题将BEGIN语句推迟到比通常可行的更大程度。有关解决此行为的技术，请参阅部分[可序列化隔离/保存点/事务DDL](#pysqlite-serializable)或[可序列化隔离/保存点/事务DDL（asyncio版本）](#aiosqlite-serializable)。
- en: See also
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅
- en: '[Setting Transaction Isolation Levels including DBAPI Autocommit](../core/connections.html#dbapi-autocommit)'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: '[设置事务隔离级别，包括DBAPI自动提交](../core/connections.html#dbapi-autocommit)'
- en: INSERT/UPDATE/DELETE…RETURNING
  id: totrans-505
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: INSERT/UPDATE/DELETE…RETURNING
- en: The SQLite dialect supports SQLite 3.35’s `INSERT|UPDATE|DELETE..RETURNING`
    syntax. `INSERT..RETURNING` may be used automatically in some cases in order to
    fetch newly generated identifiers in place of the traditional approach of using
    `cursor.lastrowid`, however `cursor.lastrowid` is currently still preferred for
    simple single-statement cases for its better performance.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite方言支持SQLite 3.35的`INSERT|UPDATE|DELETE..RETURNING`语法。在某些情况下，`INSERT..RETURNING`可能会自动使用，以获取新生成的标识符，而不是传统方法中使用`cursor.lastrowid`，但目前仍然推荐对于简单的单语句情况使用`cursor.lastrowid`，因为其性能更好。
- en: 'To specify an explicit `RETURNING` clause, use the `_UpdateBase.returning()`
    method on a per-statement basis:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 要指定显式的`RETURNING`子句，请在每个语句上使用`_UpdateBase.returning()`方法：
- en: '[PRE83]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'New in version 2.0: Added support for SQLite RETURNING'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 版本2.0中的新功能：增加了对SQLite RETURNING的支持
- en: SAVEPOINT Support
  id: totrans-510
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保存点支持
- en: SQLite supports SAVEPOINTs, which only function once a transaction is begun.
    SQLAlchemy’s SAVEPOINT support is available using the [`Connection.begin_nested()`](../core/connections.html#sqlalchemy.engine.Connection.begin_nested
    "sqlalchemy.engine.Connection.begin_nested") method at the Core level, and [`Session.begin_nested()`](../orm/session_api.html#sqlalchemy.orm.Session.begin_nested
    "sqlalchemy.orm.Session.begin_nested") at the ORM level. However, SAVEPOINTs won’t
    work at all with pysqlite unless workarounds are taken.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 支持 SAVEPOINT，仅在启动事务后才能运行。SQLAlchemy 的 SAVEPOINT 支持可在 Core 级别使用 [`Connection.begin_nested()`](../core/connections.html#sqlalchemy.engine.Connection.begin_nested
    "sqlalchemy.engine.Connection.begin_nested") 方法，在 ORM 级别使用 [`Session.begin_nested()`](../orm/session_api.html#sqlalchemy.orm.Session.begin_nested
    "sqlalchemy.orm.Session.begin_nested")。但是，除非采取解决方法，否则 SAVEPOINT 在 pysqlite 中将无法工作。
- en: Warning
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: SQLite’s SAVEPOINT feature is impacted by unresolved issues in the pysqlite
    and aiosqlite drivers, which defer BEGIN statements to a greater degree than is
    often feasible. See the sections [Serializable isolation / Savepoints / Transactional
    DDL](#pysqlite-serializable) and [Serializable isolation / Savepoints / Transactional
    DDL (asyncio version)](#aiosqlite-serializable) for techniques to work around
    this behavior.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: pysqlite 和 aiosqlite 驱动存在未解决的问题，这些问题将 BEGIN 语句推迟到一个更大程度上比通常可行的程度。有关绕过此行为的技术，请参见
    [Serializable isolation / Savepoints / Transactional DDL](#pysqlite-serializable)
    和 [Serializable isolation / Savepoints / Transactional DDL (asyncio version)](#aiosqlite-serializable)
    部分。
- en: Transactional DDL
  id: totrans-514
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事务性 DDL
- en: The SQLite database supports transactional [DDL](../glossary.html#term-DDL)
    as well. In this case, the pysqlite driver is not only failing to start transactions,
    it also is ending any existing transaction when DDL is detected, so again, workarounds
    are required.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 数据库还支持事务性 [DDL](../glossary.html#term-DDL)。在这种情况下，pysqlite 驱动不仅在检测到 DDL
    时无法启动事务，还会结束任何现有事务，因此需要采取解决方法。
- en: Warning
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: SQLite’s transactional DDL is impacted by unresolved issues in the pysqlite
    driver, which fails to emit BEGIN and additionally forces a COMMIT to cancel any
    transaction when DDL is encountered. See the section [Serializable isolation /
    Savepoints / Transactional DDL](#pysqlite-serializable) for techniques to work
    around this behavior.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: pysqlite 驱动中存在未解决的问题影响了 SQLite 的事务性 DDL，当遇到 DDL 时，该驱动器未发出 BEGIN 并且还强制执行 COMMIT
    来取消任何事务。有关绕过此行为的技术，请参见 [Serializable isolation / Savepoints / Transactional DDL](#pysqlite-serializable)
    部分。
- en: '## Foreign Key Support'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: '## 外键支持'
- en: SQLite supports FOREIGN KEY syntax when emitting CREATE statements for tables,
    however by default these constraints have no effect on the operation of the table.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 当发出用于表的 CREATE 语句时，SQLite 支持 FOREIGN KEY 语法，但是默认情况下，这些约束对表的操作没有任何影响。
- en: 'Constraint checking on SQLite has three prerequisites:'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SQLite 上进行约束检查有三个先决条件：
- en: At least version 3.6.19 of SQLite must be in use
  id: totrans-521
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须使用至少版本 3.6.19 的 SQLite
- en: The SQLite library must be compiled *without* the SQLITE_OMIT_FOREIGN_KEY or
    SQLITE_OMIT_TRIGGER symbols enabled.
  id: totrans-522
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须在编译 SQLite 库时 *没有* 启用 SQLITE_OMIT_FOREIGN_KEY 或 SQLITE_OMIT_TRIGGER 符号。
- en: The `PRAGMA foreign_keys = ON` statement must be emitted on all connections
    before use – including the initial call to [`MetaData.create_all()`](../core/metadata.html#sqlalchemy.schema.MetaData.create_all
    "sqlalchemy.schema.MetaData.create_all").
  id: totrans-523
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须在所有连接上发出 `PRAGMA foreign_keys = ON` 语句，包括对 [`MetaData.create_all()`](../core/metadata.html#sqlalchemy.schema.MetaData.create_all
    "sqlalchemy.schema.MetaData.create_all") 的初始调用。
- en: 'SQLAlchemy allows for the `PRAGMA` statement to be emitted automatically for
    new connections through the usage of events:'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 允许通过事件的使用自动发出 `PRAGMA` 语句以进行新连接：
- en: '[PRE84]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Warning
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: When SQLite foreign keys are enabled, it is **not possible** to emit CREATE
    or DROP statements for tables that contain mutually-dependent foreign key constraints;
    to emit the DDL for these tables requires that ALTER TABLE be used to create or
    drop these constraints separately, for which SQLite has no support.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 当启用 SQLite 外键时，**不可能**对包含相互依赖的外键约束的表发出 CREATE 或 DROP 语句；要发出这些表的 DDL，需要单独使用 ALTER
    TABLE 创建或删除这些约束，而 SQLite 不支持这一点。
- en: See also
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[SQLite Foreign Key Support](https://www.sqlite.org/foreignkeys.html) - on
    the SQLite web site.'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: '[SQLite 外键支持](https://www.sqlite.org/foreignkeys.html) - 在 SQLite 网站上。'
- en: '[Events](../core/event.html) - SQLAlchemy event API.'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: '[事件](../core/event.html) - SQLAlchemy 事件 API。'
- en: '[Creating/Dropping Foreign Key Constraints via ALTER](../core/constraints.html#use-alter)
    - more information on SQLAlchemy’s facilities for handling'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: '[通过 ALTER 创建/删除外键约束](../core/constraints.html#use-alter) - 有关 SQLAlchemy 处理的更多信息'
- en: mutually-dependent foreign key constraints.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 互相依赖的外键约束。
- en: '## ON CONFLICT support for constraints'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: '## 对约束的ON CONFLICT支持'
- en: See also
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: This section describes the [DDL](../glossary.html#term-DDL) version of “ON CONFLICT”
    for SQLite, which occurs within a CREATE TABLE statement. For “ON CONFLICT” as
    applied to an INSERT statement, see [INSERT…ON CONFLICT (Upsert)](#sqlite-on-conflict-insert).
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 本节描述了SQLite中“ON CONFLICT”的DDL版本，该版本出现在CREATE TABLE语句中。有关应用于INSERT语句的“ON CONFLICT”，请参见[INSERT…ON
    CONFLICT (Upsert)](#sqlite-on-conflict-insert)。
- en: SQLite supports a non-standard DDL clause known as ON CONFLICT which can be
    applied to primary key, unique, check, and not null constraints. In DDL, it is
    rendered either within the “CONSTRAINT” clause or within the column definition
    itself depending on the location of the target constraint. To render this clause
    within DDL, the extension parameter `sqlite_on_conflict` can be specified with
    a string conflict resolution algorithm within the [`PrimaryKeyConstraint`](../core/constraints.html#sqlalchemy.schema.PrimaryKeyConstraint
    "sqlalchemy.schema.PrimaryKeyConstraint"), [`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint"), [`CheckConstraint`](../core/constraints.html#sqlalchemy.schema.CheckConstraint
    "sqlalchemy.schema.CheckConstraint") objects. Within the [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") object, there are individual parameters `sqlite_on_conflict_not_null`,
    `sqlite_on_conflict_primary_key`, `sqlite_on_conflict_unique` which each correspond
    to the three types of relevant constraint types that can be indicated from a [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") object.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite支持一个名为ON CONFLICT的非标准DDL子句，可应用于主键、唯一、检查和非空约束。在DDL中，它要么在“CONSTRAINT”子句中呈现，要么在目标约束的位置取决于列定义本身。要在DDL中呈现此子句，可以在[`PrimaryKeyConstraint`](../core/constraints.html#sqlalchemy.schema.PrimaryKeyConstraint
    "sqlalchemy.schema.PrimaryKeyConstraint")、[`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint")、[`CheckConstraint`](../core/constraints.html#sqlalchemy.schema.CheckConstraint
    "sqlalchemy.schema.CheckConstraint")对象中指定扩展参数`sqlite_on_conflict`，并在[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")对象中，有单独的参数`sqlite_on_conflict_not_null`、`sqlite_on_conflict_primary_key`、`sqlite_on_conflict_unique`，分别对应于可以从[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")对象指示的三种相关约束类型。
- en: See also
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[ON CONFLICT](https://www.sqlite.org/lang_conflict.html) - in the SQLite documentation'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: '[冲突时执行](https://www.sqlite.org/lang_conflict.html) - 在SQLite文档中'
- en: New in version 1.3.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 版本1.3中的新功能。
- en: 'The `sqlite_on_conflict` parameters accept a string argument which is just
    the resolution name to be chosen, which on SQLite can be one of ROLLBACK, ABORT,
    FAIL, IGNORE, and REPLACE. For example, to add a UNIQUE constraint that specifies
    the IGNORE algorithm:'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: '`sqlite_on_conflict`参数接受一个字符串参数，该参数只是要选择的解决方案名称，在SQLite上可以是ROLLBACK、ABORT、FAIL、IGNORE和REPLACE中的一个。例如，要添加一个指定IGNORE算法的唯一约束：'
- en: '[PRE85]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'The above renders CREATE TABLE DDL as:'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 以上将CREATE TABLE DDL呈现为：
- en: '[PRE86]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'When using the [`Column.unique`](../core/metadata.html#sqlalchemy.schema.Column.params.unique
    "sqlalchemy.schema.Column") flag to add a UNIQUE constraint to a single column,
    the `sqlite_on_conflict_unique` parameter can be added to the [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") as well, which will be added to the UNIQUE constraint
    in the DDL:'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用[`Column.unique`](../core/metadata.html#sqlalchemy.schema.Column.params.unique
    "sqlalchemy.schema.Column")标志向单个列添加唯一约束时，也可以向[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")添加`sqlite_on_conflict_unique`参数，该参数将添加到DDL中的唯一约束中：
- en: '[PRE87]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'rendering:'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染：
- en: '[PRE88]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'To apply the FAIL algorithm for a NOT NULL constraint, `sqlite_on_conflict_not_null`
    is used:'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 要应用FAIL算法以满足NOT NULL约束，使用`sqlite_on_conflict_not_null`：
- en: '[PRE89]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'this renders the column inline ON CONFLICT phrase:'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使列内联ON CONFLICT短语：
- en: '[PRE90]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Similarly, for an inline primary key, use `sqlite_on_conflict_primary_key`:'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，对于内联主键，使用`sqlite_on_conflict_primary_key`：
- en: '[PRE91]'
  id: totrans-553
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'SQLAlchemy renders the PRIMARY KEY constraint separately, so the conflict resolution
    algorithm is applied to the constraint itself:'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy将主键约束单独呈现，因此冲突解决算法应用于约束本身：
- en: '[PRE92]'
  id: totrans-555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '## INSERT…ON CONFLICT (Upsert)'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: '## 插入…冲突时执行（Upsert）'
- en: See also
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: This section describes the [DML](../glossary.html#term-DML) version of “ON CONFLICT”
    for SQLite, which occurs within an INSERT statement. For “ON CONFLICT” as applied
    to a CREATE TABLE statement, see [ON CONFLICT support for constraints](#sqlite-on-conflict-ddl).
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 本节描述了 SQLite 的“ON CONFLICT”的 [DML](../glossary.html#term-DML) 版本，它发生在 INSERT
    语句中。有关应用于 CREATE TABLE 语句的“ON CONFLICT”，请参见[约束的 ON CONFLICT 支持](#sqlite-on-conflict-ddl)。
- en: From version 3.24.0 onwards, SQLite supports “upserts” (update or insert) of
    rows into a table via the `ON CONFLICT` clause of the `INSERT` statement. A candidate
    row will only be inserted if that row does not violate any unique or primary key
    constraints. In the case of a unique constraint violation, a secondary action
    can occur which can be either “DO UPDATE”, indicating that the data in the target
    row should be updated, or “DO NOTHING”, which indicates to silently skip this
    row.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 从版本 3.24.0 开始，SQLite 支持通过 `INSERT` 语句的 `ON CONFLICT` 子句进行行的“upserts”（更新或插入）到表中。仅当候选行不违反任何唯一或主键约束时才会插入该行。在唯一约束违反的情况下，可以发生次要操作，可以是“DO
    UPDATE”，表示应更新目标行中的数据，或者是“DO NOTHING”，表示默默地跳过此行。
- en: Conflicts are determined using columns that are part of existing unique constraints
    and indexes. These constraints are identified by stating the columns and conditions
    that comprise the indexes.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 冲突是使用现有唯一约束和索引的列确定的。这些约束通过说明组成索引的列和条件来确定。
- en: 'SQLAlchemy provides `ON CONFLICT` support via the SQLite-specific [`insert()`](#sqlalchemy.dialects.sqlite.insert
    "sqlalchemy.dialects.sqlite.insert") function, which provides the generative methods
    [`Insert.on_conflict_do_update()`](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update
    "sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update") and [`Insert.on_conflict_do_nothing()`](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_nothing
    "sqlalchemy.dialects.sqlite.Insert.on_conflict_do_nothing"):'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 通过 SQLite 特定的 [`insert()`](#sqlalchemy.dialects.sqlite.insert "sqlalchemy.dialects.sqlite.insert")
    函数提供 `ON CONFLICT` 支持，该函数提供生成方法 [`Insert.on_conflict_do_update()`](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update
    "sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update") 和 [`Insert.on_conflict_do_nothing()`](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_nothing
    "sqlalchemy.dialects.sqlite.Insert.on_conflict_do_nothing")：
- en: '[PRE93]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: New in version 1.4.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 新版本 1.4 中新增。
- en: See also
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Upsert](https://sqlite.org/lang_UPSERT.html) - in the SQLite documentation.'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: '[Upsert](https://sqlite.org/lang_UPSERT.html) - SQLite 文档中的内容。'
- en: Specifying the Target
  id: totrans-566
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 指定目标
- en: 'Both methods supply the “target” of the conflict using column inference:'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 两种方法都使用列推断冲突的“目标”：
- en: The [`Insert.on_conflict_do_update.index_elements`](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update.params.index_elements
    "sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update") argument specifies
    a sequence containing string column names, [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects, and/or SQL expression elements, which would
    identify a unique index or unique constraint.
  id: totrans-568
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`Insert.on_conflict_do_update.index_elements`](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update.params.index_elements
    "sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update") 参数指定包含字符串列名称、[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") 对象和/或 SQL 表达式元素的序列，这些元素将标识唯一索引或唯一约束。'
- en: 'When using [`Insert.on_conflict_do_update.index_elements`](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update.params.index_elements
    "sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update") to infer an index,
    a partial index can be inferred by also specifying the [`Insert.on_conflict_do_update.index_where`](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update.params.index_where
    "sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update") parameter:'
  id: totrans-569
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用 [`Insert.on_conflict_do_update.index_elements`](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update.params.index_elements
    "sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update") 来推断索引时，还可以通过指定 [`Insert.on_conflict_do_update.index_where`](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update.params.index_where
    "sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update") 参数推断出部分索引：
- en: '[PRE94]'
  id: totrans-570
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: The SET Clause
  id: totrans-571
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SET 子句
- en: '`ON CONFLICT...DO UPDATE` is used to perform an update of the already existing
    row, using any combination of new values as well as values from the proposed insertion.
    These values are specified using the [`Insert.on_conflict_do_update.set_`](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update.params.set_
    "sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update") parameter. This parameter
    accepts a dictionary which consists of direct values for UPDATE:'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `ON CONFLICT...DO UPDATE` 来执行已经存在行的更新，使用任何组合的新值以及来自所提议插入的值。这些值使用 [`Insert.on_conflict_do_update.set_`](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update.params.set_
    "sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update") 参数指定。该参数接受一个包含直接 UPDATE
    值的字典：
- en: '[PRE95]'
  id: totrans-573
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Warning
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: The [`Insert.on_conflict_do_update()`](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update
    "sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update") method does **not**
    take into account Python-side default UPDATE values or generation functions, e.g.
    those specified using [`Column.onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.onupdate
    "sqlalchemy.schema.Column"). These values will not be exercised for an ON CONFLICT
    style of UPDATE, unless they are manually specified in the [`Insert.on_conflict_do_update.set_`](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update.params.set_
    "sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update") dictionary.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Insert.on_conflict_do_update()`](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update
    "sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update") 方法 **不** 考虑 Python
    端的默认 UPDATE 值或生成函数，例如，使用 [`Column.onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.onupdate
    "sqlalchemy.schema.Column") 指定的那些。除非在 [`Insert.on_conflict_do_update.set_`](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update.params.set_
    "sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update") 字典中手动指定，否则这些值不会在 ON
    CONFLICT 类型的 UPDATE 中使用。'
- en: Updating using the Excluded INSERT Values
  id: totrans-576
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用被排除的 INSERT 值进行更新
- en: 'In order to refer to the proposed insertion row, the special alias [`Insert.excluded`](#sqlalchemy.dialects.sqlite.Insert.excluded
    "sqlalchemy.dialects.sqlite.Insert.excluded") is available as an attribute on
    the [`Insert`](#sqlalchemy.dialects.sqlite.Insert "sqlalchemy.dialects.sqlite.Insert")
    object; this object creates an “excluded.” prefix on a column, that informs the
    DO UPDATE to update the row with the value that would have been inserted had the
    constraint not failed:'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 为了引用所提议的插入行，特殊别名 [`Insert.excluded`](#sqlalchemy.dialects.sqlite.Insert.excluded
    "sqlalchemy.dialects.sqlite.Insert.excluded") 可以作为 [`Insert`](#sqlalchemy.dialects.sqlite.Insert
    "sqlalchemy.dialects.sqlite.Insert") 对象的属性使用；该对象在列上创建了一个 “excluded.” 前缀，它通知 DO
    UPDATE 使用将插入的值更新行，如果约束没有失败的话将会插入的值：
- en: '[PRE96]'
  id: totrans-578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Additional WHERE Criteria
  id: totrans-579
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 附加的 WHERE 条件
- en: 'The [`Insert.on_conflict_do_update()`](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update
    "sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update") method also accepts
    a WHERE clause using the [`Insert.on_conflict_do_update.where`](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update.params.where
    "sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update") parameter, which will
    limit those rows which receive an UPDATE:'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Insert.on_conflict_do_update()`](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update
    "sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update") 方法还接受使用 [`Insert.on_conflict_do_update.where`](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update.params.where
    "sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update") 参数的 WHERE 子句，这将限制接收
    UPDATE 的行：'
- en: '[PRE97]'
  id: totrans-581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Skipping Rows with DO NOTHING
  id: totrans-582
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 DO NOTHING 跳过行
- en: '`ON CONFLICT` may be used to skip inserting a row entirely if any conflict
    with a unique constraint occurs; below this is illustrated using the [`Insert.on_conflict_do_nothing()`](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_nothing
    "sqlalchemy.dialects.sqlite.Insert.on_conflict_do_nothing") method:'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: '`ON CONFLICT` 可以用来完全跳过插入行，如果任何与唯一约束发生冲突的话；下面通过使用 [`Insert.on_conflict_do_nothing()`](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_nothing
    "sqlalchemy.dialects.sqlite.Insert.on_conflict_do_nothing") 方法进行了说明：'
- en: '[PRE98]'
  id: totrans-584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'If `DO NOTHING` is used without specifying any columns or constraint, it has
    the effect of skipping the INSERT for any unique violation which occurs:'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用 `DO NOTHING` 而没有指定任何列或约束，则会跳过发生的任何唯一性冲突的 INSERT：
- en: '[PRE99]'
  id: totrans-586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Specifying the Target
  id: totrans-587
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 指定目标
- en: 'Both methods supply the “target” of the conflict using column inference:'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 两种方法都使用列推断提供冲突的 “目标”：
- en: The [`Insert.on_conflict_do_update.index_elements`](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update.params.index_elements
    "sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update") argument specifies
    a sequence containing string column names, [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects, and/or SQL expression elements, which would
    identify a unique index or unique constraint.
  id: totrans-589
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`Insert.on_conflict_do_update.index_elements`](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update.params.index_elements
    "sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update") 参数指定一个序列，包含字符串列名、[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") 对象和/或 SQL 表达式元素，用于标识唯一索引或唯一约束。'
- en: 'When using [`Insert.on_conflict_do_update.index_elements`](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update.params.index_elements
    "sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update") to infer an index,
    a partial index can be inferred by also specifying the [`Insert.on_conflict_do_update.index_where`](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update.params.index_where
    "sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update") parameter:'
  id: totrans-590
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用 [`Insert.on_conflict_do_update.index_elements`](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update.params.index_elements
    "sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update") 推断索引时，还可以通过指定 [`Insert.on_conflict_do_update.index_where`](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update.params.index_where
    "sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update") 参数来推断部分索引。
- en: '[PRE100]'
  id: totrans-591
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: The SET Clause
  id: totrans-592
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SET 子句
- en: '`ON CONFLICT...DO UPDATE` is used to perform an update of the already existing
    row, using any combination of new values as well as values from the proposed insertion.
    These values are specified using the [`Insert.on_conflict_do_update.set_`](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update.params.set_
    "sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update") parameter. This parameter
    accepts a dictionary which consists of direct values for UPDATE:'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: '`ON CONFLICT...DO UPDATE` 用于对已存在的行进行更新，可以使用新值与插入提议中的任意组合值。这些值使用 [`Insert.on_conflict_do_update.set_`](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update.params.set_
    "sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update") 参数指定。此参数接受一个字典，其中包含
    UPDATE 的直接值：'
- en: '[PRE101]'
  id: totrans-594
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: Warning
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: The [`Insert.on_conflict_do_update()`](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update
    "sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update") method does **not**
    take into account Python-side default UPDATE values or generation functions, e.g.
    those specified using [`Column.onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.onupdate
    "sqlalchemy.schema.Column"). These values will not be exercised for an ON CONFLICT
    style of UPDATE, unless they are manually specified in the [`Insert.on_conflict_do_update.set_`](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update.params.set_
    "sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update") dictionary.
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Insert.on_conflict_do_update()`](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update
    "sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update") 方法**不会**考虑 Python 端默认的
    UPDATE 值或生成函数，例如使用 [`Column.onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.onupdate
    "sqlalchemy.schema.Column") 指定的值。除非这些值在 [`Insert.on_conflict_do_update.set_`](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update.params.set_
    "sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update") 字典中手动指定，否则这些值不会用于 ON
    CONFLICT 类型的 UPDATE。'
- en: Updating using the Excluded INSERT Values
  id: totrans-597
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用插入的排除值进行更新
- en: 'In order to refer to the proposed insertion row, the special alias [`Insert.excluded`](#sqlalchemy.dialects.sqlite.Insert.excluded
    "sqlalchemy.dialects.sqlite.Insert.excluded") is available as an attribute on
    the [`Insert`](#sqlalchemy.dialects.sqlite.Insert "sqlalchemy.dialects.sqlite.Insert")
    object; this object creates an “excluded.” prefix on a column, that informs the
    DO UPDATE to update the row with the value that would have been inserted had the
    constraint not failed:'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 为了引用插入提议的行，特殊别名 [`Insert.excluded`](#sqlalchemy.dialects.sqlite.Insert.excluded
    "sqlalchemy.dialects.sqlite.Insert.excluded") 可作为 [`Insert`](#sqlalchemy.dialects.sqlite.Insert
    "sqlalchemy.dialects.sqlite.Insert") 对象的属性使用；此对象在列上创建一个“excluded.”前缀，该前缀告知 DO
    UPDATE 使用将在约束失败时插入的值更新行：
- en: '[PRE102]'
  id: totrans-599
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Additional WHERE Criteria
  id: totrans-600
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 附加的 WHERE 条件
- en: 'The [`Insert.on_conflict_do_update()`](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update
    "sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update") method also accepts
    a WHERE clause using the [`Insert.on_conflict_do_update.where`](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update.params.where
    "sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update") parameter, which will
    limit those rows which receive an UPDATE:'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Insert.on_conflict_do_update()`](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update
    "sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update") 方法还接受使用 [`Insert.on_conflict_do_update.where`](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update.params.where
    "sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update") 参数的 WHERE 子句，这将限制那些接收
    UPDATE 的行：'
- en: '[PRE103]'
  id: totrans-602
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: Skipping Rows with DO NOTHING
  id: totrans-603
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 DO NOTHING 跳过行
- en: '`ON CONFLICT` may be used to skip inserting a row entirely if any conflict
    with a unique constraint occurs; below this is illustrated using the [`Insert.on_conflict_do_nothing()`](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_nothing
    "sqlalchemy.dialects.sqlite.Insert.on_conflict_do_nothing") method:'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: '`ON CONFLICT` 可以用于完全跳过插入行，如果发生与唯一约束的冲突；以下是使用 [`Insert.on_conflict_do_nothing()`](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_nothing
    "sqlalchemy.dialects.sqlite.Insert.on_conflict_do_nothing") 方法进行说明：'
- en: '[PRE104]'
  id: totrans-605
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'If `DO NOTHING` is used without specifying any columns or constraint, it has
    the effect of skipping the INSERT for any unique violation which occurs:'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `DO NOTHING` 在不指定任何列或约束的情况下使用，则会跳过发生的任何唯一违规的 INSERT：
- en: '[PRE105]'
  id: totrans-607
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '## Type Reflection'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: '## 类型反射'
- en: SQLite types are unlike those of most other database backends, in that the string
    name of the type usually does not correspond to a “type” in a one-to-one fashion.
    Instead, SQLite links per-column typing behavior to one of five so-called “type
    affinities” based on a string matching pattern for the type.
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 类型与大多数其他数据库后端不同，在于类型的字符串名称通常不是一对一地对应于一个“类型”。相反，SQLite 将每列的类型行为链接到五种所谓的“类型亲和性”之一，基于类型的字符串匹配模式。
- en: SQLAlchemy’s reflection process, when inspecting types, uses a simple lookup
    table to link the keywords returned to provided SQLAlchemy types. This lookup
    table is present within the SQLite dialect as it is for all other dialects. However,
    the SQLite dialect has a different “fallback” routine for when a particular type
    name is not located in the lookup map; it instead implements the SQLite “type
    affinity” scheme located at [https://www.sqlite.org/datatype3.html](https://www.sqlite.org/datatype3.html)
    section 2.1.
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 当 SQLAlchemy 的反射过程检查类型时，它使用一个简单的查找表将返回的关键字链接到提供的 SQLAlchemy 类型。这个查找表存在于 SQLite
    方言中，就像存在于所有其他方言中一样。然而，当某个特定类型名称未在查找映射中找到时，SQLite 方言有一个不同的“回退”例程；它实现了位于 [https://www.sqlite.org/datatype3.html](https://www.sqlite.org/datatype3.html)
    第 2.1 节的 SQLite “类型亲和性”方案。
- en: 'The provided typemap will make direct associations from an exact string name
    match for the following types:'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 提供的类型映射将直接从以下类型的精确字符串名称匹配进行关联：
- en: '[`BIGINT`](../core/type_basics.html#sqlalchemy.types.BIGINT "sqlalchemy.types.BIGINT"),
    [`BLOB`](../core/type_basics.html#sqlalchemy.types.BLOB "sqlalchemy.types.BLOB"),
    [`BOOLEAN`](../core/type_basics.html#sqlalchemy.types.BOOLEAN "sqlalchemy.types.BOOLEAN"),
    [`BOOLEAN`](../core/type_basics.html#sqlalchemy.types.BOOLEAN "sqlalchemy.types.BOOLEAN"),
    [`CHAR`](../core/type_basics.html#sqlalchemy.types.CHAR "sqlalchemy.types.CHAR"),
    [`DATE`](../core/type_basics.html#sqlalchemy.types.DATE "sqlalchemy.types.DATE"),
    [`DATETIME`](../core/type_basics.html#sqlalchemy.types.DATETIME "sqlalchemy.types.DATETIME"),
    [`FLOAT`](../core/type_basics.html#sqlalchemy.types.FLOAT "sqlalchemy.types.FLOAT"),
    [`DECIMAL`](../core/type_basics.html#sqlalchemy.types.DECIMAL "sqlalchemy.types.DECIMAL"),
    [`FLOAT`](../core/type_basics.html#sqlalchemy.types.FLOAT "sqlalchemy.types.FLOAT"),
    [`INTEGER`](../core/type_basics.html#sqlalchemy.types.INTEGER "sqlalchemy.types.INTEGER"),
    [`INTEGER`](../core/type_basics.html#sqlalchemy.types.INTEGER "sqlalchemy.types.INTEGER"),
    [`NUMERIC`](../core/type_basics.html#sqlalchemy.types.NUMERIC "sqlalchemy.types.NUMERIC"),
    [`REAL`](../core/type_basics.html#sqlalchemy.types.REAL "sqlalchemy.types.REAL"),
    [`SMALLINT`](../core/type_basics.html#sqlalchemy.types.SMALLINT "sqlalchemy.types.SMALLINT"),
    [`TEXT`](../core/type_basics.html#sqlalchemy.types.TEXT "sqlalchemy.types.TEXT"),
    [`TIME`](../core/type_basics.html#sqlalchemy.types.TIME "sqlalchemy.types.TIME"),
    [`TIMESTAMP`](../core/type_basics.html#sqlalchemy.types.TIMESTAMP "sqlalchemy.types.TIMESTAMP"),
    [`VARCHAR`](../core/type_basics.html#sqlalchemy.types.VARCHAR "sqlalchemy.types.VARCHAR"),
    [`NVARCHAR`](../core/type_basics.html#sqlalchemy.types.NVARCHAR "sqlalchemy.types.NVARCHAR"),
    [`NCHAR`](../core/type_basics.html#sqlalchemy.types.NCHAR "sqlalchemy.types.NCHAR")'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: '[`BIGINT`](../core/type_basics.html#sqlalchemy.types.BIGINT "sqlalchemy.types.BIGINT")、[`BLOB`](../core/type_basics.html#sqlalchemy.types.BLOB
    "sqlalchemy.types.BLOB")、[`BOOLEAN`](../core/type_basics.html#sqlalchemy.types.BOOLEAN
    "sqlalchemy.types.BOOLEAN")、[`BOOLEAN`](../core/type_basics.html#sqlalchemy.types.BOOLEAN
    "sqlalchemy.types.BOOLEAN")、[`CHAR`](../core/type_basics.html#sqlalchemy.types.CHAR
    "sqlalchemy.types.CHAR")、[`DATE`](../core/type_basics.html#sqlalchemy.types.DATE
    "sqlalchemy.types.DATE")、[`DATETIME`](../core/type_basics.html#sqlalchemy.types.DATETIME
    "sqlalchemy.types.DATETIME")、[`FLOAT`](../core/type_basics.html#sqlalchemy.types.FLOAT
    "sqlalchemy.types.FLOAT")、[`DECIMAL`](../core/type_basics.html#sqlalchemy.types.DECIMAL
    "sqlalchemy.types.DECIMAL")、[`FLOAT`](../core/type_basics.html#sqlalchemy.types.FLOAT
    "sqlalchemy.types.FLOAT")、[`INTEGER`](../core/type_basics.html#sqlalchemy.types.INTEGER
    "sqlalchemy.types.INTEGER")、[`INTEGER`](../core/type_basics.html#sqlalchemy.types.INTEGER
    "sqlalchemy.types.INTEGER")、[`NUMERIC`](../core/type_basics.html#sqlalchemy.types.NUMERIC
    "sqlalchemy.types.NUMERIC")、[`REAL`](../core/type_basics.html#sqlalchemy.types.REAL
    "sqlalchemy.types.REAL")、[`SMALLINT`](../core/type_basics.html#sqlalchemy.types.SMALLINT
    "sqlalchemy.types.SMALLINT")、[`TEXT`](../core/type_basics.html#sqlalchemy.types.TEXT
    "sqlalchemy.types.TEXT")、[`TIME`](../core/type_basics.html#sqlalchemy.types.TIME
    "sqlalchemy.types.TIME")、[`TIMESTAMP`](../core/type_basics.html#sqlalchemy.types.TIMESTAMP
    "sqlalchemy.types.TIMESTAMP")、[`VARCHAR`](../core/type_basics.html#sqlalchemy.types.VARCHAR
    "sqlalchemy.types.VARCHAR")、[`NVARCHAR`](../core/type_basics.html#sqlalchemy.types.NVARCHAR
    "sqlalchemy.types.NVARCHAR")、[`NCHAR`](../core/type_basics.html#sqlalchemy.types.NCHAR
    "sqlalchemy.types.NCHAR")'
- en: 'When a type name does not match one of the above types, the “type affinity”
    lookup is used instead:'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 当类型名称与上述类型之一不匹配时，将使用“类型亲和性”查找：
- en: '[`INTEGER`](../core/type_basics.html#sqlalchemy.types.INTEGER "sqlalchemy.types.INTEGER")
    is returned if the type name includes the string `INT`'
  id: totrans-614
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果类型名称包含字符串`INT`，则返回[`INTEGER`](../core/type_basics.html#sqlalchemy.types.INTEGER
    "sqlalchemy.types.INTEGER")类型。
- en: '[`TEXT`](../core/type_basics.html#sqlalchemy.types.TEXT "sqlalchemy.types.TEXT")
    is returned if the type name includes the string `CHAR`, `CLOB` or `TEXT`'
  id: totrans-615
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果类型名称包含字符串`CHAR`、`CLOB`或`TEXT`，则返回[`TEXT`](../core/type_basics.html#sqlalchemy.types.TEXT
    "sqlalchemy.types.TEXT")类型。
- en: '[`NullType`](../core/type_api.html#sqlalchemy.types.NullType "sqlalchemy.types.NullType")
    is returned if the type name includes the string `BLOB`'
  id: totrans-616
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果类型名称包含字符串`BLOB`，则返回[`NullType`](../core/type_api.html#sqlalchemy.types.NullType
    "sqlalchemy.types.NullType")类型。
- en: '[`REAL`](../core/type_basics.html#sqlalchemy.types.REAL "sqlalchemy.types.REAL")
    is returned if the type name includes the string `REAL`, `FLOA` or `DOUB`.'
  id: totrans-617
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果类型名称包含字符串`REAL`、`FLOA`或`DOUB`，则返回[`REAL`](../core/type_basics.html#sqlalchemy.types.REAL
    "sqlalchemy.types.REAL")类型。
- en: Otherwise, the [`NUMERIC`](../core/type_basics.html#sqlalchemy.types.NUMERIC
    "sqlalchemy.types.NUMERIC") type is used.
  id: totrans-618
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，使用[`NUMERIC`](../core/type_basics.html#sqlalchemy.types.NUMERIC "sqlalchemy.types.NUMERIC")类型。
- en: '## Partial Indexes'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: '## 部分索引'
- en: 'A partial index, e.g. one which uses a WHERE clause, can be specified with
    the DDL system using the argument `sqlite_where`:'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用DDL系统指定带有WHERE子句的部分索引，例如使用参数`sqlite_where`：
- en: '[PRE106]'
  id: totrans-621
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'The index will be rendered at create time as:'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建时，索引将被渲染为：
- en: '[PRE107]'
  id: totrans-623
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '## Dotted Column Names'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: '## 点分列名'
- en: Using table or column names that explicitly have periods in them is **not recommended**.
    While this is generally a bad idea for relational databases in general, as the
    dot is a syntactically significant character, the SQLite driver up until version
    **3.10.0** of SQLite has a bug which requires that SQLAlchemy filter out these
    dots in result sets.
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 不推荐使用显式带有句点的表名或列名。虽然这对于关系数据库来说通常是个坏主意，因为句点是一个语法上重要的字符，但 SQLite 驱动在 SQLite 版本
    **3.10.0** 之前存在一个 bug，要求 SQLAlchemy 在结果集中滤掉这些句点。
- en: 'The bug, entirely outside of SQLAlchemy, can be illustrated thusly:'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 bug 完全不在 SQLAlchemy 的范围之内，可以用以下方式加以说明：
- en: '[PRE108]'
  id: totrans-627
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'The second assertion fails:'
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个断言失败：
- en: '[PRE109]'
  id: totrans-629
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: Where above, the driver incorrectly reports the names of the columns including
    the name of the table, which is entirely inconsistent vs. when the UNION is not
    present.
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述情况下，驱动程序错误地报告包括表名在内的列名，这与 UNION 不在时完全不一致。
- en: 'SQLAlchemy relies upon column names being predictable in how they match to
    the original statement, so the SQLAlchemy dialect has no choice but to filter
    these out:'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 依赖于列名在匹配原始语句时的可预测性，因此 SQLAlchemy 方言别无选择，只能将这些列名滤除：
- en: '[PRE110]'
  id: totrans-632
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Note that above, even though SQLAlchemy filters out the dots, *both names are
    still addressable*:'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尽管 SQLAlchemy 过滤掉了句点，*这两个名称仍然是可寻址的*：
- en: '[PRE111]'
  id: totrans-634
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Therefore, the workaround applied by SQLAlchemy only impacts [`CursorResult.keys()`](../core/connections.html#sqlalchemy.engine.CursorResult.keys
    "sqlalchemy.engine.CursorResult.keys") and `Row.keys()` in the public API. In
    the very specific case where an application is forced to use column names that
    contain dots, and the functionality of [`CursorResult.keys()`](../core/connections.html#sqlalchemy.engine.CursorResult.keys
    "sqlalchemy.engine.CursorResult.keys") and `Row.keys()` is required to return
    these dotted names unmodified, the `sqlite_raw_colnames` execution option may
    be provided, either on a per-[`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") basis:'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，SQLAlchemy 应用的解决方法只会影响公共 API 中的 [`CursorResult.keys()`](../core/connections.html#sqlalchemy.engine.CursorResult.keys
    "sqlalchemy.engine.CursorResult.keys") 和 `Row.keys()`。在强制使用包含句点的列名，并且需要 [`CursorResult.keys()`](../core/connections.html#sqlalchemy.engine.CursorResult.keys
    "sqlalchemy.engine.CursorResult.keys") 和 `Row.keys()` 返回这些带点的名称不经修改的非常特殊情况下，可以在每个
    [`Connection`](../core/connections.html#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    上提供 `sqlite_raw_colnames` 执行选项：
- en: '[PRE112]'
  id: totrans-636
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'or on a per-[`Engine`](../core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    basis:'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 或者在每个 [`Engine`](../core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    上：
- en: '[PRE113]'
  id: totrans-638
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: When using the per-[`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") execution option, note that **Core and ORM queries
    that use UNION may not function properly**.
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 使用每个 [`Engine`](../core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    的执行选项时，请注意**使用 UNION 的 Core 和 ORM 查询可能无法正常工作**。
- en: SQLite-specific table options
  id: totrans-640
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SQLite 特定的表选项
- en: 'One option for CREATE TABLE is supported directly by the SQLite dialect in
    conjunction with the [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    construct:'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: '`CREATE TABLE` 的一种选项直接由 SQLite 方言支持，与 [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") 结构配合使用：'
- en: '`WITHOUT ROWID`:'
  id: totrans-642
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WITHOUT ROWID`：'
- en: '[PRE114]'
  id: totrans-643
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: See also
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[SQLite CREATE TABLE options](https://www.sqlite.org/lang_createtable.html)'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: '[SQLite CREATE TABLE 选项](https://www.sqlite.org/lang_createtable.html)'
- en: '## Reflecting internal schema tables'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: '## 反映内部模式表'
- en: Reflection methods that return lists of tables will omit so-called “SQLite internal
    schema object” names, which are considered by SQLite as any object name that is
    prefixed with `sqlite_`. An example of such an object is the `sqlite_sequence`
    table that’s generated when the `AUTOINCREMENT` column parameter is used. In order
    to return these objects, the parameter `sqlite_include_internal=True` may be passed
    to methods such as [`MetaData.reflect()`](../core/metadata.html#sqlalchemy.schema.MetaData.reflect
    "sqlalchemy.schema.MetaData.reflect") or [`Inspector.get_table_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_table_names
    "sqlalchemy.engine.reflection.Inspector.get_table_names").
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 返回表列表的反射方法将省略所谓的“SQLite 内部模式对象”名称，这些对象被 SQLite 视为任何以 `sqlite_` 为前缀的对象名称。这种对象的示例是在使用
    `AUTOINCREMENT` 列参数时生成的 `sqlite_sequence` 表。为了返回这些对象，可以向诸如 [`MetaData.reflect()`](../core/metadata.html#sqlalchemy.schema.MetaData.reflect
    "sqlalchemy.schema.MetaData.reflect") 或 [`Inspector.get_table_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_table_names
    "sqlalchemy.engine.reflection.Inspector.get_table_names") 这样的方法传递参数 `sqlite_include_internal=True`。
- en: 'New in version 2.0: Added the `sqlite_include_internal=True` parameter. Previously,
    these tables were not ignored by SQLAlchemy reflection methods.'
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 新版本 2.0 中新增了 `sqlite_include_internal=True` 参数。以前，这些表不被 SQLAlchemy 反射方法忽略。
- en: Note
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `sqlite_include_internal` parameter does not refer to the “system” tables
    that are present in schemas such as `sqlite_master`.
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: '`sqlite_include_internal` 参数不引用存在于 `sqlite_master` 等模式中的 “系统” 表。'
- en: See also
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[SQLite Internal Schema Objects](https://www.sqlite.org/fileformat2.html#intschema)
    - in the SQLite documentation.'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: '[SQLite 内部模式对象](https://www.sqlite.org/fileformat2.html#intschema) - SQLite
    文档中。'
- en: SQLite Data Types
  id: totrans-653
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SQLite 数据类型
- en: 'As with all SQLAlchemy dialects, all UPPERCASE types that are known to be valid
    with SQLite are importable from the top level dialect, whether they originate
    from [`sqlalchemy.types`](../core/type_basics.html#module-sqlalchemy.types "sqlalchemy.types")
    or from the local dialect:'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有 SQLAlchemy 方言一样，已知与 SQLite 兼容的所有大写类型都可以从顶级方言导入，无论它们来自 [`sqlalchemy.types`](../core/type_basics.html#module-sqlalchemy.types
    "sqlalchemy.types") 还是来自本地方言：
- en: '[PRE115]'
  id: totrans-655
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '| Object Name | Description |'
  id: totrans-656
  prefs: []
  type: TYPE_TB
  zh: '| 对象名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-657
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| [DATE](#sqlalchemy.dialects.sqlite.DATE) | Represent a Python date object
    in SQLite using a string. |'
  id: totrans-658
  prefs: []
  type: TYPE_TB
  zh: '| [DATE](#sqlalchemy.dialects.sqlite.DATE) | 使用字符串在 SQLite 中表示 Python date
    对象。 |'
- en: '| [DATETIME](#sqlalchemy.dialects.sqlite.DATETIME) | Represent a Python datetime
    object in SQLite using a string. |'
  id: totrans-659
  prefs: []
  type: TYPE_TB
  zh: '| [DATETIME](#sqlalchemy.dialects.sqlite.DATETIME) | 使用字符串在 SQLite 中表示 Python
    datetime 对象。 |'
- en: '| [JSON](#sqlalchemy.dialects.sqlite.JSON) | SQLite JSON type. |'
  id: totrans-660
  prefs: []
  type: TYPE_TB
  zh: '| [JSON](#sqlalchemy.dialects.sqlite.JSON) | SQLite JSON 类型。 |'
- en: '| [TIME](#sqlalchemy.dialects.sqlite.TIME) | Represent a Python time object
    in SQLite using a string. |'
  id: totrans-661
  prefs: []
  type: TYPE_TB
  zh: '| [TIME](#sqlalchemy.dialects.sqlite.TIME) | 使用字符串在 SQLite 中表示 Python time
    对象。 |'
- en: '[PRE116]'
  id: totrans-662
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: Represent a Python datetime object in SQLite using a string.
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 使用字符串在 SQLite 中表示 Python datetime 对象。
- en: 'The default string storage format is:'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 默认字符串存储格式为：
- en: '[PRE117]'
  id: totrans-665
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'e.g.:'
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE118]'
  id: totrans-667
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: The incoming storage format is by default parsed using the Python `datetime.fromisoformat()`
    function.
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，输入的存储格式使用 Python `datetime.fromisoformat()` 函数进行解析。
- en: 'Changed in version 2.0: `datetime.fromisoformat()` is used for default datetime
    string parsing.'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 新版本 2.0 中已更改：默认日期时间字符串解析使用 `datetime.fromisoformat()`。
- en: 'The storage format can be customized to some degree using the `storage_format`
    and `regexp` parameters, such as:'
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `storage_format` 和 `regexp` 参数在一定程度上自定义存储格式，例如：
- en: '[PRE119]'
  id: totrans-671
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'Parameters:'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '`storage_format` – format string which will be applied to the dict with keys
    year, month, day, hour, minute, second, and microsecond.'
  id: totrans-673
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`storage_format` - 应用于带有年、月、日、小时、分钟、秒和微秒键的字典的格式字符串。'
- en: '`regexp` – regular expression which will be applied to incoming result rows,
    replacing the use of `datetime.fromisoformat()` to parse incoming strings. If
    the regexp contains named groups, the resulting match dict is applied to the Python
    datetime() constructor as keyword arguments. Otherwise, if positional groups are
    used, the datetime() constructor is called with positional arguments via `*map(int,
    match_obj.groups(0))`.'
  id: totrans-674
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`regexp` - 应用于输入结果行的正则表达式，用于替换使用 `datetime.fromisoformat()` 解析输入字符串。如果正则表达式包含命名组，则结果匹配字典将作为关键字参数应用于
    Python datetime() 构造函数。否则，如果使用位置组，则通过 `*map(int, match_obj.groups(0))` 调用 datetime()
    构造函数进行位置参数传递。'
- en: '**Class signature**'
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: '**类签名**'
- en: class [`sqlalchemy.dialects.sqlite.DATETIME`](#sqlalchemy.dialects.sqlite.DATETIME
    "sqlalchemy.dialects.sqlite.DATETIME") (`sqlalchemy.dialects.sqlite.base._DateTimeMixin`,
    [`sqlalchemy.types.DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime
    "sqlalchemy.types.DateTime"))
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 类 [`sqlalchemy.dialects.sqlite.DATETIME`](#sqlalchemy.dialects.sqlite.DATETIME
    "sqlalchemy.dialects.sqlite.DATETIME") (`sqlalchemy.dialects.sqlite.base._DateTimeMixin`,
    [`sqlalchemy.types.DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime
    "sqlalchemy.types.DateTime"))
- en: '[PRE120]'
  id: totrans-677
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: Represent a Python date object in SQLite using a string.
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 使用字符串在 SQLite 中表示 Python 日期对象。
- en: 'The default string storage format is:'
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 默认字符串存储格式为：
- en: '[PRE121]'
  id: totrans-680
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'e.g.:'
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE122]'
  id: totrans-682
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: The incoming storage format is by default parsed using the Python `date.fromisoformat()`
    function.
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，输入的存储格式使用 Python `date.fromisoformat()` 函数进行解析。
- en: 'Changed in version 2.0: `date.fromisoformat()` is used for default date string
    parsing.'
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 新版本 2.0 中已更改：默认日期字符串解析使用 `date.fromisoformat()`。
- en: 'The storage format can be customized to some degree using the `storage_format`
    and `regexp` parameters, such as:'
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `storage_format` 和 `regexp` 参数在一定程度上自定义存储格式，例如：
- en: '[PRE123]'
  id: totrans-686
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'Parameters:'
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '`storage_format` – format string which will be applied to the dict with keys
    year, month, and day.'
  id: totrans-688
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`storage_format` - 应用于带有年、月和日键的字典的格式字符串。'
- en: '`regexp` – regular expression which will be applied to incoming result rows,
    replacing the use of `date.fromisoformat()` to parse incoming strings. If the
    regexp contains named groups, the resulting match dict is applied to the Python
    date() constructor as keyword arguments. Otherwise, if positional groups are used,
    the date() constructor is called with positional arguments via `*map(int, match_obj.groups(0))`.'
  id: totrans-689
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`regexp` – 将应用于传入结果行的正则表达式，替换使用 `date.fromisoformat()` 来解析传入字符串。如果 regexp 包含命名组，则生成的匹配字典将作为关键字参数应用于
    Python date() 构造函数。否则，如果使用位置组，则通过 `*map(int, match_obj.groups(0))` 将调用 date()
    构造函数以位置参数形式。'
- en: '**Class signature**'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: '**类签名**'
- en: class [`sqlalchemy.dialects.sqlite.DATE`](#sqlalchemy.dialects.sqlite.DATE "sqlalchemy.dialects.sqlite.DATE")
    (`sqlalchemy.dialects.sqlite.base._DateTimeMixin`, [`sqlalchemy.types.Date`](../core/type_basics.html#sqlalchemy.types.Date
    "sqlalchemy.types.Date"))
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 类 [`sqlalchemy.dialects.sqlite.DATE`](#sqlalchemy.dialects.sqlite.DATE "sqlalchemy.dialects.sqlite.DATE")
    (`sqlalchemy.dialects.sqlite.base._DateTimeMixin`, [`sqlalchemy.types.Date`](../core/type_basics.html#sqlalchemy.types.Date
    "sqlalchemy.types.Date"))
- en: '[PRE124]'
  id: totrans-692
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: SQLite JSON type.
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite JSON 类型。
- en: SQLite supports JSON as of version 3.9 through its [JSON1](https://www.sqlite.org/json1.html)
    extension. Note that [JSON1](https://www.sqlite.org/json1.html) is a [loadable
    extension](https://www.sqlite.org/loadext.html) and as such may not be available,
    or may require run-time loading.
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 从版本 3.9 开始支持 JSON，通过其 [JSON1](https://www.sqlite.org/json1.html) 扩展。请注意，[JSON1](https://www.sqlite.org/json1.html)
    是一个[可加载扩展](https://www.sqlite.org/loadext.html)，因此可能不可用，或者可能需要运行时加载。
- en: '[`JSON`](#sqlalchemy.dialects.sqlite.JSON "sqlalchemy.dialects.sqlite.JSON")
    is used automatically whenever the base [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON") datatype is used against a SQLite backend.'
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 当基本 [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON")
    数据类型用于 SQLite 后端时，[`JSON`](#sqlalchemy.dialects.sqlite.JSON "sqlalchemy.dialects.sqlite.JSON")
    会自动使用。
- en: See also
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON")
    - main documentation for the generic cross-platform JSON datatype.'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: '[`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON")
    - 通用跨平台 JSON 数据类型的主要文档。'
- en: The [`JSON`](#sqlalchemy.dialects.sqlite.JSON "sqlalchemy.dialects.sqlite.JSON")
    type supports persistence of JSON values as well as the core index operations
    provided by [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON")
    datatype, by adapting the operations to render the `JSON_EXTRACT` function wrapped
    in the `JSON_QUOTE` function at the database level. Extracted values are quoted
    in order to ensure that the results are always JSON string values.
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: '[`JSON`](#sqlalchemy.dialects.sqlite.JSON "sqlalchemy.dialects.sqlite.JSON")
    类型支持将 JSON 值持久化，同时通过在数据库级别将 `JSON_EXTRACT` 函数包装在 `JSON_QUOTE` 函数中来提供 [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON") 数据类型提供的核心索引操作。提取的值被引用以确保结果始终为 JSON 字符串值。'
- en: New in version 1.3.
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 版本 1.3 中的新内容。
- en: '**Members**'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: '**成员**'
- en: '[__init__()](#sqlalchemy.dialects.sqlite.JSON.__init__)'
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: '[__init__()](#sqlalchemy.dialects.sqlite.JSON.__init__)'
- en: '**Class signature**'
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: '**类签名**'
- en: class [`sqlalchemy.dialects.sqlite.JSON`](#sqlalchemy.dialects.sqlite.JSON "sqlalchemy.dialects.sqlite.JSON")
    ([`sqlalchemy.types.JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON"))
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 类 [`sqlalchemy.dialects.sqlite.JSON`](#sqlalchemy.dialects.sqlite.JSON "sqlalchemy.dialects.sqlite.JSON")
    ([`sqlalchemy.types.JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON"))
- en: '[PRE125]'
  id: totrans-704
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '*inherited from the* `sqlalchemy.types.JSON.__init__` *method of* [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON")'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: '*继承自* [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON")
    的 `sqlalchemy.types.JSON.__init__` *方法*'
- en: Construct a [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON")
    type.
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 构造一个 [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON")
    类型。
- en: 'Parameters:'
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**none_as_null=False** –'
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: '**none_as_null=False** –'
- en: 'if True, persist the value `None` as a SQL NULL value, not the JSON encoding
    of `null`. Note that when this flag is False, the [`null()`](../core/sqlelement.html#sqlalchemy.sql.expression.null
    "sqlalchemy.sql.expression.null") construct can still be used to persist a NULL
    value, which may be passed directly as a parameter value that is specially interpreted
    by the [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON")
    type as SQL NULL:'
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 如果为 True，则将值 `None` 持久化为 SQL NULL 值，而不是 `null` 的 JSON 编码。请注意，当此标志为 False 时，仍然可以使用
    [`null()`](../core/sqlelement.html#sqlalchemy.sql.expression.null "sqlalchemy.sql.expression.null")
    构造来持久化 NULL 值，该构造可以直接作为参数值传递，由 [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON") 类型特殊解释为 SQL NULL：
- en: '[PRE126]'
  id: totrans-710
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: Note
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '[`JSON.none_as_null`](../core/type_basics.html#sqlalchemy.types.JSON.params.none_as_null
    "sqlalchemy.types.JSON") does **not** apply to the values passed to [`Column.default`](../core/metadata.html#sqlalchemy.schema.Column.params.default
    "sqlalchemy.schema.Column") and [`Column.server_default`](../core/metadata.html#sqlalchemy.schema.Column.params.server_default
    "sqlalchemy.schema.Column"); a value of `None` passed for these parameters means
    “no default present”.'
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: '[`JSON.none_as_null`](../core/type_basics.html#sqlalchemy.types.JSON.params.none_as_null
    "sqlalchemy.types.JSON") 不适用于传递给 [`Column.default`](../core/metadata.html#sqlalchemy.schema.Column.params.default
    "sqlalchemy.schema.Column") 和 [`Column.server_default`](../core/metadata.html#sqlalchemy.schema.Column.params.server_default
    "sqlalchemy.schema.Column") 的值；这些参数传递的`None`值表示“无默认值”。'
- en: Additionally, when used in SQL comparison expressions, the Python value `None`
    continues to refer to SQL null, and not JSON NULL. The [`JSON.none_as_null`](../core/type_basics.html#sqlalchemy.types.JSON.params.none_as_null
    "sqlalchemy.types.JSON") flag refers explicitly to the **persistence** of the
    value within an INSERT or UPDATE statement. The [`JSON.NULL`](../core/type_basics.html#sqlalchemy.types.JSON.NULL
    "sqlalchemy.types.JSON.NULL") value should be used for SQL expressions that wish
    to compare to JSON null.
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当在SQL比较表达式中使用时，Python值 `None` 仍然表示SQL null，而不是JSON NULL。 [`JSON.none_as_null`](../core/type_basics.html#sqlalchemy.types.JSON.params.none_as_null
    "sqlalchemy.types.JSON") 标志明确指的是值在INSERT或UPDATE语句中的**持久性**。应使用 [`JSON.NULL`](../core/type_basics.html#sqlalchemy.types.JSON.NULL
    "sqlalchemy.types.JSON.NULL") 值进行希望与JSON null进行比较的SQL表达式。
- en: See also
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`JSON.NULL`](../core/type_basics.html#sqlalchemy.types.JSON.NULL "sqlalchemy.types.JSON.NULL")'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: '[`JSON.NULL`](../core/type_basics.html#sqlalchemy.types.JSON.NULL "sqlalchemy.types.JSON.NULL")'
- en: '[PRE127]'
  id: totrans-716
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: Represent a Python time object in SQLite using a string.
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 以字符串形式在SQLite中表示Python时间对象。
- en: 'The default string storage format is:'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的字符串存储格式是：
- en: '[PRE128]'
  id: totrans-719
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'e.g.:'
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE129]'
  id: totrans-721
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: The incoming storage format is by default parsed using the Python `time.fromisoformat()`
    function.
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，传入的存储格式是使用Python `time.fromisoformat()`函数解析的。
- en: 'Changed in version 2.0: `time.fromisoformat()` is used for default time string
    parsing.'
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 在2.0版本中更改：默认时间字符串解析使用 `time.fromisoformat()`。
- en: 'The storage format can be customized to some degree using the `storage_format`
    and `regexp` parameters, such as:'
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 存储格式可以在一定程度上使用 `storage_format` 和 `regexp` 参数进行自定义，例如：
- en: '[PRE130]'
  id: totrans-725
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'Parameters:'
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '`storage_format` – format string which will be applied to the dict with keys
    hour, minute, second, and microsecond.'
  id: totrans-727
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`storage_format` – 将应用于带有小时、分钟、秒和微秒键的字典的格式字符串。'
- en: '`regexp` – regular expression which will be applied to incoming result rows,
    replacing the use of `datetime.fromisoformat()` to parse incoming strings. If
    the regexp contains named groups, the resulting match dict is applied to the Python
    time() constructor as keyword arguments. Otherwise, if positional groups are used,
    the time() constructor is called with positional arguments via `*map(int, match_obj.groups(0))`.'
  id: totrans-728
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`regexp` – 将应用于传入结果行的正则表达式，替换使用 `datetime.fromisoformat()` 解析传入字符串的用法。如果正则表达式包含命名分组，则生成的匹配字典将作为关键字参数应用于Python的
    `time()` 构造函数。否则，如果使用了位置分组，则通过 `*map(int, match_obj.groups(0))` 将调用时间()构造函数以位置参数的方式。'
- en: '**Class signature**'
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: '**类签名**'
- en: class [`sqlalchemy.dialects.sqlite.TIME`](#sqlalchemy.dialects.sqlite.TIME "sqlalchemy.dialects.sqlite.TIME")
    (`sqlalchemy.dialects.sqlite.base._DateTimeMixin`, [`sqlalchemy.types.Time`](../core/type_basics.html#sqlalchemy.types.Time
    "sqlalchemy.types.Time"))
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 类 [`sqlalchemy.dialects.sqlite.TIME`](#sqlalchemy.dialects.sqlite.TIME "sqlalchemy.dialects.sqlite.TIME")
    (`sqlalchemy.dialects.sqlite.base._DateTimeMixin`, [`sqlalchemy.types.Time`](../core/type_basics.html#sqlalchemy.types.Time
    "sqlalchemy.types.Time"))
- en: SQLite DML Constructs
  id: totrans-731
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SQLite DML Constructs
- en: '| Object Name | Description |'
  id: totrans-732
  prefs: []
  type: TYPE_TB
  zh: '| 对象名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-733
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| [insert](#sqlalchemy.dialects.sqlite.insert)(table) | Construct a sqlite-specific
    variant [`Insert`](#sqlalchemy.dialects.sqlite.Insert "sqlalchemy.dialects.sqlite.Insert")
    construct. |'
  id: totrans-734
  prefs: []
  type: TYPE_TB
  zh: '| [insert](#sqlalchemy.dialects.sqlite.insert)(table) | 构造SQLite特定的变体 [`Insert`](#sqlalchemy.dialects.sqlite.Insert
    "sqlalchemy.dialects.sqlite.Insert") 构造。 |'
- en: '| [Insert](#sqlalchemy.dialects.sqlite.Insert) | SQLite-specific implementation
    of INSERT. |'
  id: totrans-735
  prefs: []
  type: TYPE_TB
  zh: '| [Insert](#sqlalchemy.dialects.sqlite.Insert) | INSERT的SQLite特定实现。 |'
- en: '[PRE131]'
  id: totrans-736
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: Construct a sqlite-specific variant [`Insert`](#sqlalchemy.dialects.sqlite.Insert
    "sqlalchemy.dialects.sqlite.Insert") construct.
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 构造SQLite特定的变体 [`Insert`](#sqlalchemy.dialects.sqlite.Insert "sqlalchemy.dialects.sqlite.Insert")
    构造。
- en: The [`sqlalchemy.dialects.sqlite.insert()`](#sqlalchemy.dialects.sqlite.insert
    "sqlalchemy.dialects.sqlite.insert") function creates a [`sqlalchemy.dialects.sqlite.Insert`](#sqlalchemy.dialects.sqlite.Insert
    "sqlalchemy.dialects.sqlite.Insert"). This class is based on the dialect-agnostic
    [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert "sqlalchemy.sql.expression.Insert")
    construct which may be constructed using the [`insert()`](../core/dml.html#sqlalchemy.sql.expression.insert
    "sqlalchemy.sql.expression.insert") function in SQLAlchemy Core.
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: '[`sqlalchemy.dialects.sqlite.insert()`](#sqlalchemy.dialects.sqlite.insert
    "sqlalchemy.dialects.sqlite.insert") 函数创建一个 [`sqlalchemy.dialects.sqlite.Insert`](#sqlalchemy.dialects.sqlite.Insert
    "sqlalchemy.dialects.sqlite.Insert")。此类基于方言不可知的 [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") 构造，可以使用 SQLAlchemy Core 中的 [`insert()`](../core/dml.html#sqlalchemy.sql.expression.insert
    "sqlalchemy.sql.expression.insert") 函数构造。'
- en: The [`Insert`](#sqlalchemy.dialects.sqlite.Insert "sqlalchemy.dialects.sqlite.Insert")
    construct includes additional methods [`Insert.on_conflict_do_update()`](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update
    "sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update"), [`Insert.on_conflict_do_nothing()`](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_nothing
    "sqlalchemy.dialects.sqlite.Insert.on_conflict_do_nothing").
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Insert`](#sqlalchemy.dialects.sqlite.Insert "sqlalchemy.dialects.sqlite.Insert")
    构造包括其他方法 [`Insert.on_conflict_do_update()`](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update
    "sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update"), [`Insert.on_conflict_do_nothing()`](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_nothing
    "sqlalchemy.dialects.sqlite.Insert.on_conflict_do_nothing")。'
- en: '[PRE132]'
  id: totrans-740
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: SQLite-specific implementation of INSERT.
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 特定的 INSERT 实现。
- en: Adds methods for SQLite-specific syntaxes such as ON CONFLICT.
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: 添加了针对 SQLite 特定语法的方法，例如 ON CONFLICT。
- en: The [`Insert`](#sqlalchemy.dialects.sqlite.Insert "sqlalchemy.dialects.sqlite.Insert")
    object is created using the [`sqlalchemy.dialects.sqlite.insert()`](#sqlalchemy.dialects.sqlite.insert
    "sqlalchemy.dialects.sqlite.insert") function.
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 [`sqlalchemy.dialects.sqlite.insert()`](#sqlalchemy.dialects.sqlite.insert
    "sqlalchemy.dialects.sqlite.insert") 函数创建 [`Insert`](#sqlalchemy.dialects.sqlite.Insert
    "sqlalchemy.dialects.sqlite.Insert") 对象。
- en: New in version 1.4.
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 新版本 1.4 中新增。
- en: See also
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[INSERT…ON CONFLICT (Upsert)](#sqlite-on-conflict-insert)'
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: '[INSERT…ON CONFLICT (Upsert)](#sqlite-on-conflict-insert)'
- en: '**Members**'
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: '**成员**'
- en: '[excluded](#sqlalchemy.dialects.sqlite.Insert.excluded), [inherit_cache](#sqlalchemy.dialects.sqlite.Insert.inherit_cache),
    [on_conflict_do_nothing()](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_nothing),
    [on_conflict_do_update()](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update)'
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: '[excluded](#sqlalchemy.dialects.sqlite.Insert.excluded), [inherit_cache](#sqlalchemy.dialects.sqlite.Insert.inherit_cache),
    [on_conflict_do_nothing()](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_nothing),
    [on_conflict_do_update()](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update)'
- en: '**Class signature**'
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: '**类签名**'
- en: class [`sqlalchemy.dialects.sqlite.Insert`](#sqlalchemy.dialects.sqlite.Insert
    "sqlalchemy.dialects.sqlite.Insert") ([`sqlalchemy.sql.expression.Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert"))
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: 类 [`sqlalchemy.dialects.sqlite.Insert`](#sqlalchemy.dialects.sqlite.Insert "sqlalchemy.dialects.sqlite.Insert")
    ([`sqlalchemy.sql.expression.Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert"))
- en: '[PRE133]'
  id: totrans-751
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: Provide the `excluded` namespace for an ON CONFLICT statement
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 ON CONFLICT 语句提供了 `excluded` 命名空间
- en: SQLite’s ON CONFLICT clause allows reference to the row that would be inserted,
    known as `excluded`. This attribute provides all columns in this row to be referenceable.
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 的 ON CONFLICT 子句允许引用将要插入的行，称为 `excluded`。此属性提供了此行中的所有列以供引用。
- en: Tip
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: The [`Insert.excluded`](#sqlalchemy.dialects.sqlite.Insert.excluded "sqlalchemy.dialects.sqlite.Insert.excluded")
    attribute is an instance of [`ColumnCollection`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnCollection
    "sqlalchemy.sql.expression.ColumnCollection"), which provides an interface the
    same as that of the [`Table.c`](../core/metadata.html#sqlalchemy.schema.Table.c
    "sqlalchemy.schema.Table.c") collection described at [Accessing Tables and Columns](../core/metadata.html#metadata-tables-and-columns).
    With this collection, ordinary names are accessible like attributes (e.g. `stmt.excluded.some_column`),
    but special names and dictionary method names should be accessed using indexed
    access, such as `stmt.excluded["column name"]` or `stmt.excluded["values"]`. See
    the docstring for [`ColumnCollection`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnCollection
    "sqlalchemy.sql.expression.ColumnCollection") for further examples.
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Insert.excluded`](#sqlalchemy.dialects.sqlite.Insert.excluded "sqlalchemy.dialects.sqlite.Insert.excluded")
    属性是 [`ColumnCollection`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnCollection
    "sqlalchemy.sql.expression.ColumnCollection") 的一个实例，提供了与 [访问表和列](../core/metadata.html#metadata-tables-and-columns)
    中描述的 [`Table.c`](../core/metadata.html#sqlalchemy.schema.Table.c "sqlalchemy.schema.Table.c")
    集合相同的接口。通过该集合，普通名称可以像属性一样访问（例如 `stmt.excluded.some_column`），但特殊名称和字典方法名称应使用索引访问，例如
    `stmt.excluded["column name"]` 或 `stmt.excluded["values"]`。有关更多示例，请参阅 [`ColumnCollection`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnCollection
    "sqlalchemy.sql.expression.ColumnCollection") 的文档字符串。'
- en: '[PRE134]'
  id: totrans-756
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: Indicate if this [`HasCacheKey`](../core/foundation.html#sqlalchemy.sql.traversals.HasCacheKey
    "sqlalchemy.sql.traversals.HasCacheKey") instance should make use of the cache
    key generation scheme used by its immediate superclass.
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 指示此 [`HasCacheKey`](../core/foundation.html#sqlalchemy.sql.traversals.HasCacheKey
    "sqlalchemy.sql.traversals.HasCacheKey") 实例是否应使用其直接超类使用的缓存键生成方案。
- en: The attribute defaults to `None`, which indicates that a construct has not yet
    taken into account whether or not its appropriate for it to participate in caching;
    this is functionally equivalent to setting the value to `False`, except that a
    warning is also emitted.
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: 该属性默认为 `None`，表示结构尚未考虑是否适合参与缓存；这在功能上等同于将值设置为 `False`，除了还会发出警告。
- en: This flag can be set to `True` on a particular class, if the SQL that corresponds
    to the object does not change based on attributes which are local to this class,
    and not its superclass.
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: 如果与此类本地属性而不是其超类有关的属性不会改变与对象相对应的 SQL，则可以将此标志设置为 `True`。
- en: See also
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: See also
- en: '[Enabling Caching Support for Custom Constructs](../core/compiler.html#compilerext-caching)
    - General guideslines for setting the [`HasCacheKey.inherit_cache`](../core/foundation.html#sqlalchemy.sql.traversals.HasCacheKey.inherit_cache
    "sqlalchemy.sql.traversals.HasCacheKey.inherit_cache") attribute for third-party
    or user defined SQL constructs.'
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: '[为自定义结构启用缓存支持](../core/compiler.html#compilerext-caching) - 设置[`HasCacheKey.inherit_cache`](../core/foundation.html#sqlalchemy.sql.traversals.HasCacheKey.inherit_cache
    "sqlalchemy.sql.traversals.HasCacheKey.inherit_cache") 属性的一般指南，用于第三方或用户定义的 SQL
    构造。'
- en: '[PRE135]'
  id: totrans-762
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: Specifies a DO NOTHING action for ON CONFLICT clause.
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: 指定了 ON CONFLICT 子句的 DO NOTHING 操作。
- en: 'Parameters:'
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '`index_elements` – A sequence consisting of string column names, [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects, or other column expression objects that will
    be used to infer a target index or unique constraint.'
  id: totrans-765
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`index_elements` – 由字符串列名、[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") 对象或其他列表达式对象组成的序列，将用于推断目标索引或唯一约束。'
- en: '`index_where` – Additional WHERE criterion that can be used to infer a conditional
    target index.'
  id: totrans-766
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`index_where` – 可用于推断条件目标索引的附加 WHERE 准则。'
- en: '[PRE136]'
  id: totrans-767
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: Specifies a DO UPDATE SET action for ON CONFLICT clause.
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: 指定了 ON CONFLICT 子句的 DO UPDATE SET 操作。
- en: 'Parameters:'
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '`index_elements` – A sequence consisting of string column names, [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects, or other column expression objects that will
    be used to infer a target index or unique constraint.'
  id: totrans-770
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`index_elements` – 由字符串列名、[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") 对象或其他列表达式对象组成的序列，将用于推断目标索引或唯一约束。'
- en: '`index_where` – Additional WHERE criterion that can be used to infer a conditional
    target index.'
  id: totrans-771
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`index_where` – 可用于推断条件目标索引的附加 WHERE 准则。'
- en: '`set_` –'
  id: totrans-772
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`set_` –'
- en: A dictionary or other mapping object where the keys are either names of columns
    in the target table, or [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects or other ORM-mapped columns matching that
    of the target table, and expressions or literals as values, specifying the `SET`
    actions to take.
  id: totrans-773
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一个字典或其他映射对象，其中键可以是目标表中的列名，或者是 [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") 对象或其他 ORM 映射的列，与目标表匹配，以及表达式或字面值作为值，指定要执行的 `SET` 操作。
- en: 'New in version 1.4: The [`Insert.on_conflict_do_update.set_`](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update.params.set_
    "sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update") parameter supports
    [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    objects from the target [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") as keys.'
  id: totrans-774
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从版本 1.4 开始：[`Insert.on_conflict_do_update.set_`](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update.params.set_
    "sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update") 参数支持来自目标 [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") 的 [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") 对象作为键。
- en: Warning
  id: totrans-775
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 警告
- en: This dictionary does **not** take into account Python-specified default UPDATE
    values or generation functions, e.g. those specified using [`Column.onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.onupdate
    "sqlalchemy.schema.Column"). These values will not be exercised for an ON CONFLICT
    style of UPDATE, unless they are manually specified in the [`Insert.on_conflict_do_update.set_`](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update.params.set_
    "sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update") dictionary.
  id: totrans-776
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个字典**不**考虑 Python 指定的默认 UPDATE 值或生成函数，例如使用 [`Column.onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.onupdate
    "sqlalchemy.schema.Column") 指定的那些。这些值不会对 ON CONFLICT 风格的 UPDATE 生效，除非它们在 [`Insert.on_conflict_do_update.set_`](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update.params.set_
    "sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update") 字典中手动指定。
- en: '`where` – Optional argument. If present, can be a literal SQL string or an
    acceptable expression for a `WHERE` clause that restricts the rows affected by
    `DO UPDATE SET`. Rows not meeting the `WHERE` condition will not be updated (effectively
    a `DO NOTHING` for those rows).'
  id: totrans-777
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`where` – 可选参数。如果存在，则可以是一个 SQL 字符串字面量或 `WHERE` 子句的可接受表达式，该子句限制了由 `DO UPDATE
    SET` 受影响的行。不符合 `WHERE` 条件的行将不会更新（对于这些行实际上是 `DO NOTHING`）。'
- en: '## Pysqlite'
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: '## Pysqlite'
- en: Support for the SQLite database via the pysqlite driver.
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 pysqlite 驱动程序支持 SQLite 数据库。
- en: Note that `pysqlite` is the same driver as the `sqlite3` module included with
    the Python distribution.
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`pysqlite` 与 Python 发行版中包含的 `sqlite3` 模块是相同的驱动程序。
- en: DBAPI
  id: totrans-781
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: DBAPI
- en: 'Documentation and download information (if applicable) for pysqlite is available
    at: [https://docs.python.org/library/sqlite3.html](https://docs.python.org/library/sqlite3.html)'
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: pysqlite 的文档和下载信息（如果适用）可在此处获取：[https://docs.python.org/library/sqlite3.html](https://docs.python.org/library/sqlite3.html)
- en: Connecting
  id: totrans-783
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接
- en: 'Connect String:'
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: 连接字符串：
- en: '[PRE137]'
  id: totrans-785
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: Driver
  id: totrans-786
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 驱动程序
- en: The `sqlite3` Python DBAPI is standard on all modern Python versions; for cPython
    and Pypy, no additional installation is necessary.
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: '`sqlite3` Python DBAPI 是所有现代 Python 版本的标准；对于 cPython 和 Pypy，不需要额外安装。'
- en: Connect Strings
  id: totrans-788
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接字符串
- en: 'The file specification for the SQLite database is taken as the “database” portion
    of the URL. Note that the format of a SQLAlchemy url is:'
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 SQLite 数据库的文件规范被视为 URL 的“数据库”部分。请注意，SQLAlchemy URL 的格式是：
- en: '[PRE138]'
  id: totrans-790
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'This means that the actual filename to be used starts with the characters to
    the **right** of the third slash. So connecting to a relative filepath looks like:'
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: 文件名的实际使用要从第三个斜杠的**右边**开始的字符开始。因此，连接到相对文件路径看起来像是：
- en: '[PRE139]'
  id: totrans-792
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'An absolute path, which is denoted by starting with a slash, means you need
    **four** slashes:'
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: 绝对路径，以斜杠开头表示，意味着你需要**四个**斜杠：
- en: '[PRE140]'
  id: totrans-794
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'To use a Windows path, regular drive specifications and backslashes can be
    used. Double backslashes are probably needed:'
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Windows 路径，可以使用常规的驱动器规范和反斜杠。可能需要双反斜杠：
- en: '[PRE141]'
  id: totrans-796
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'To use sqlite `:memory:` database specify it as the filename using `sqlite://:memory:`.
    It’s also the default if no filepath is present, specifying only `sqlite://` and
    nothing else:'
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 sqlite `:memory:` 数据库，请将其指定为使用 `sqlite://:memory:` 的文件名。如果没有路径名，指定 `sqlite://`
    并什么都不写，也是默认情况：
- en: '[PRE142]'
  id: totrans-798
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '#### URI Connections'
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: '#### URI 连接'
- en: 'Modern versions of SQLite support an alternative system of connecting using
    a [driver level URI](https://www.sqlite.org/uri.html), which has the advantage
    that additional driver-level arguments can be passed including options such as
    “read only”. The Python sqlite3 driver supports this mode under modern Python
    3 versions. The SQLAlchemy pysqlite driver supports this mode of use by specifying
    “uri=true” in the URL query string. The SQLite-level “URI” is kept as the “database”
    portion of the SQLAlchemy url (that is, following a slash):'
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: 现代版本的SQLite支持使用[驱动程序级URI](https://www.sqlite.org/uri.html)进行连接的替代系统，其优势在于可以传递额外的驱动程序级参数，包括“只读”等选项。Python
    sqlite3驱动程序在现代Python 3版本下支持此模式。SQLAlchemy pysqlite驱动程序通过在URL查询字符串中指定“uri=true”来支持此使用模式。SQLite级别的“URI”保留为SQLAlchemy
    URL的“数据库”部分（即在斜杠后面）：
- en: '[PRE143]'
  id: totrans-801
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: Note
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The “uri=true” parameter must appear in the **query string** of the URL. It
    will not currently work as expected if it is only present in the [`create_engine.connect_args`](../core/engines.html#sqlalchemy.create_engine.params.connect_args
    "sqlalchemy.create_engine") parameter dictionary.
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: “uri=true”参数必须出现在URL的**查询字符串**中。如果它仅出现在[`create_engine.connect_args`](../core/engines.html#sqlalchemy.create_engine.params.connect_args
    "sqlalchemy.create_engine")参数字典中，则目前不会按预期工作。
- en: 'The logic reconciles the simultaneous presence of SQLAlchemy’s query string
    and SQLite’s query string by separating out the parameters that belong to the
    Python sqlite3 driver vs. those that belong to the SQLite URI. This is achieved
    through the use of a fixed list of parameters known to be accepted by the Python
    side of the driver. For example, to include a URL that indicates the Python sqlite3
    “timeout” and “check_same_thread” parameters, along with the SQLite “mode” and
    “nolock” parameters, they can all be passed together on the query string:'
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: 该逻辑通过分离属于Python sqlite3驱动程序的参数和属于SQLite URI的参数来协调SQLAlchemy的查询字符串和SQLite的查询字符串的同时存在。这是通过使用已知被Python驱动程序接受的一组固定参数来实现的。例如，要包含指示Python
    sqlite3“timeout”和“check_same_thread”参数以及SQLite“mode”和“nolock”参数的URL，它们可以一起传递在查询字符串中：
- en: '[PRE144]'
  id: totrans-805
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'Above, the pysqlite / sqlite3 DBAPI would be passed arguments as:'
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面，pysqlite / sqlite3 DBAPI将传递参数如下：
- en: '[PRE145]'
  id: totrans-807
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: Regarding future parameters added to either the Python or native drivers. new
    parameter names added to the SQLite URI scheme should be automatically accommodated
    by this scheme. New parameter names added to the Python driver side can be accommodated
    by specifying them in the [`create_engine.connect_args`](../core/engines.html#sqlalchemy.create_engine.params.connect_args
    "sqlalchemy.create_engine") dictionary, until dialect support is added by SQLAlchemy.
    For the less likely case that the native SQLite driver adds a new parameter name
    that overlaps with one of the existing, known Python driver parameters (such as
    “timeout” perhaps), SQLAlchemy’s dialect would require adjustment for the URL
    scheme to continue to support this.
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: 关于将来添加到Python或本机驱动程序的参数。应该自动适应此方案的SQLite URI方案中添加的新参数名称。添加到Python驱动程序端的新参数名称可以通过在[`create_engine.connect_args`](../core/engines.html#sqlalchemy.create_engine.params.connect_args
    "sqlalchemy.create_engine")字典中指定它们来适应，直到SQLAlchemy添加方言支持。对于较不可能的情况，即本机SQLite驱动程序添加了一个与现有已知Python驱动程序参数之一重叠的新参数名称（例如“timeout”），SQLAlchemy的方言将需要调整URL方案以继续支持这一点。
- en: As is always the case for all SQLAlchemy dialects, the entire “URL” process
    can be bypassed in [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") through the use of the [`create_engine.creator`](../core/engines.html#sqlalchemy.create_engine.params.creator
    "sqlalchemy.create_engine") parameter which allows for a custom callable that
    creates a Python sqlite3 driver level connection directly.
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有SQLAlchemy方言，始终可以通过使用[`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine")中的[`create_engine.creator`](../core/engines.html#sqlalchemy.create_engine.params.creator
    "sqlalchemy.create_engine")参数来绕过整个“URL”过程，该参数允许创建一个直接创建Python sqlite3驱动程序级连接的自定义可调用对象。
- en: New in version 1.3.9.
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: 版本1.3.9中的新功能。
- en: See also
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Uniform Resource Identifiers](https://www.sqlite.org/uri.html) - in the SQLite
    documentation  ### Regular Expression Support'
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: '[统一资源标识符](https://www.sqlite.org/uri.html) - SQLite文档中的内容  ### 正则表达式支持'
- en: New in version 1.4.
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: 版本1.4中的新功能。
- en: Support for the [`ColumnOperators.regexp_match()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.regexp_match
    "sqlalchemy.sql.expression.ColumnOperators.regexp_match") operator is provided
    using Python’s [re.search](https://docs.python.org/3/library/re.html#re.search)
    function. SQLite itself does not include a working regular expression operator;
    instead, it includes a non-implemented placeholder operator `REGEXP` that calls
    a user-defined function that must be provided.
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: 支持使用Python的[re.search](https://docs.python.org/3/library/re.html#re.search)函数提供[`ColumnOperators.regexp_match()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.regexp_match
    "sqlalchemy.sql.expression.ColumnOperators.regexp_match")操作符。SQLite本身不包括有效的正则表达式操作符；相反，它包括一个未实现的占位符操作符`REGEXP`，调用必须提供的用户定义函数。
- en: 'SQLAlchemy’s implementation makes use of the pysqlite [create_function](https://docs.python.org/3/library/sqlite3.html#sqlite3.Connection.create_function)
    hook as follows:'
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy的实现利用pysqlite的[create_function](https://docs.python.org/3/library/sqlite3.html#sqlite3.Connection.create_function)钩子如下：
- en: '[PRE146]'
  id: totrans-816
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: There is currently no support for regular expression flags as a separate argument,
    as these are not supported by SQLite’s REGEXP operator, however these may be included
    inline within the regular expression string. See [Python regular expressions](https://docs.python.org/3/library/re.html#re.search)
    for details.
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: 目前不支持将正则表达式标志作为单独参数，因为SQLite的REGEXP操作符不支持这些标志，但可以在正则表达式字符串内联包含这些标志。有关详细信息，请参阅[Python正则表达式](https://docs.python.org/3/library/re.html#re.search)。
- en: See also
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[Python regular expressions](https://docs.python.org/3/library/re.html#re.search):
    Documentation for Python’s regular expression syntax.'
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: '[Python正则表达式](https://docs.python.org/3/library/re.html#re.search)：Python正则表达式语法的文档。'
- en: Compatibility with sqlite3 “native” date and datetime types
  id: totrans-820
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 与sqlite3“本地”日期和日期时间类型兼容
- en: The pysqlite driver includes the sqlite3.PARSE_DECLTYPES and sqlite3.PARSE_COLNAMES
    options, which have the effect of any column or expression explicitly cast as
    “date” or “timestamp” will be converted to a Python date or datetime object. The
    date and datetime types provided with the pysqlite dialect are not currently compatible
    with these options, since they render the ISO date/datetime including microseconds,
    which pysqlite’s driver does not. Additionally, SQLAlchemy does not at this time
    automatically render the “cast” syntax required for the freestanding functions
    “current_timestamp” and “current_date” to return datetime/date types natively.
    Unfortunately, pysqlite does not provide the standard DBAPI types in `cursor.description`,
    leaving SQLAlchemy with no way to detect these types on the fly without expensive
    per-row type checks.
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: pysqlite驱动程序包括sqlite3.PARSE_DECLTYPES和sqlite3.PARSE_COLNAMES选项，其效果是任何显式转换为“date”或“timestamp”的列或表达式将转换为Python日期或日期时间对象。pysqlite方言提供的日期和日期时间类型目前与这些选项不兼容，因为它们呈现包括微秒的ISO日期/日期时间，而pysqlite的驱动程序不包括。此外，SQLAlchemy目前不会自动呈现“cast”语法，以便使独立函数“current_timestamp”和“current_date”返回本地的日期时间/日期类型。不幸的是，pysqlite不会在`cursor.description`中提供标准的DBAPI类型，使得SQLAlchemy无法在不进行昂贵的每行类型检查的情况下动态检测这些类型。
- en: 'Keeping in mind that pysqlite’s parsing option is not recommended, nor should
    be necessary, for use with SQLAlchemy, usage of PARSE_DECLTYPES can be forced
    if one configures “native_datetime=True” on create_engine():'
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，不建议使用pysqlite的解析选项，也不应该与SQLAlchemy一起使用，如果在create_engine()上配置“native_datetime=True”，则可以强制使用PARSE_DECLTYPES：
- en: '[PRE147]'
  id: totrans-823
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: With this flag enabled, the DATE and TIMESTAMP types (but note - not the DATETIME
    or TIME types…confused yet ?) will not perform any bind parameter or result processing.
    Execution of “func.current_date()” will return a string. “func.current_timestamp()”
    is registered as returning a DATETIME type in SQLAlchemy, so this function still
    receives SQLAlchemy-level result processing.
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: 启用此标志后，DATE和TIMESTAMP类型（但请注意 - 不包括DATETIME或TIME类型...搞糊涂了吗？）将不执行任何绑定参数或结果处理。执行“func.current_date()”将返回一个字符串。“func.current_timestamp()”在SQLAlchemy中注册为返回DATETIME类型，因此此函数仍然接收SQLAlchemy级别的结果处理。
- en: '### Threading/Pooling Behavior'
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: '### 线程/池行为'
- en: The `sqlite3` DBAPI by default prohibits the use of a particular connection
    in a thread which is not the one in which it was created. As SQLite has matured,
    it’s behavior under multiple threads has improved, and even includes options for
    memory only databases to be used in multiple threads.
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`sqlite3` DBAPI禁止在创建它的线程之外的线程中使用特定连接。随着SQLite的成熟，它在多线程下的行为已经改进，甚至包括选项，允许在多个线程中使用仅内存数据库。
- en: The thread prohibition is known as “check same thread” and may be controlled
    using the `sqlite3` parameter `check_same_thread`, which will disable or enable
    this check. SQLAlchemy’s default behavior here is to set `check_same_thread` to
    `False` automatically whenever a file-based database is in use, to establish compatibility
    with the default pool class [`QueuePool`](../core/pooling.html#sqlalchemy.pool.QueuePool
    "sqlalchemy.pool.QueuePool").
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: 线程禁止被称为“检查同一线程”，可以使用`sqlite3`参数`check_same_thread`来控制，该参数将禁用或启用此检查。 SQLAlchemy
    在这里的默认行为是，当使用基于文件的数据库时，自动将`check_same_thread`设置为`False`，以与默认的池类[`QueuePool`](../core/pooling.html#sqlalchemy.pool.QueuePool
    "sqlalchemy.pool.QueuePool")建立兼容性。
- en: 'The SQLAlchemy `pysqlite` DBAPI establishes the connection pool differently
    based on the kind of SQLite database that’s requested:'
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy的`pysqlite` DBAPI基于请求的SQLite数据库类型以不同的方式建立连接池：
- en: When a `:memory:` SQLite database is specified, the dialect by default will
    use [`SingletonThreadPool`](../core/pooling.html#sqlalchemy.pool.SingletonThreadPool
    "sqlalchemy.pool.SingletonThreadPool"). This pool maintains a single connection
    per thread, so that all access to the engine within the current thread use the
    same `:memory:` database - other threads would access a different `:memory:` database.
    The `check_same_thread` parameter defaults to `True`.
  id: totrans-829
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当指定了一个`:memory:`的 SQLite 数据库时，默认情况下方言将使用[`SingletonThreadPool`](../core/pooling.html#sqlalchemy.pool.SingletonThreadPool
    "sqlalchemy.pool.SingletonThreadPool")。该池每个线程维护一个单一连接，因此当前线程内对引擎的所有访问都使用相同的`:memory:`数据库，而其他线程将访问不同的`:memory:`数据库。`check_same_thread`参数的默认值为`True`。
- en: When a file-based database is specified, the dialect will use [`QueuePool`](../core/pooling.html#sqlalchemy.pool.QueuePool
    "sqlalchemy.pool.QueuePool") as the source of connections. at the same time, the
    `check_same_thread` flag is set to False by default unless overridden.
  id: totrans-830
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当指定文件型数据库时，方言将同时使用[`QueuePool`](../core/pooling.html#sqlalchemy.pool.QueuePool
    "sqlalchemy.pool.QueuePool")作为连接源。同时，默认情况下将`check_same_thread`标志设置为`False`，除非被覆盖。
- en: 'Changed in version 2.0: SQLite file database engines now use [`QueuePool`](../core/pooling.html#sqlalchemy.pool.QueuePool
    "sqlalchemy.pool.QueuePool") by default. Previously, [`NullPool`](../core/pooling.html#sqlalchemy.pool.NullPool
    "sqlalchemy.pool.NullPool") were used. The [`NullPool`](../core/pooling.html#sqlalchemy.pool.NullPool
    "sqlalchemy.pool.NullPool") class may be used by specifying it via the [`create_engine.poolclass`](../core/engines.html#sqlalchemy.create_engine.params.poolclass
    "sqlalchemy.create_engine") parameter.'
  id: totrans-831
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从版本 2.0 开始更改：SQLite 文件数据库引擎现在默认使用[`QueuePool`](../core/pooling.html#sqlalchemy.pool.QueuePool
    "sqlalchemy.pool.QueuePool")。先前使用的是[`NullPool`](../core/pooling.html#sqlalchemy.pool.NullPool
    "sqlalchemy.pool.NullPool")。可以通过在[`create_engine.poolclass`](../core/engines.html#sqlalchemy.create_engine.params.poolclass
    "sqlalchemy.create_engine")参数中指定[`NullPool`](../core/pooling.html#sqlalchemy.pool.NullPool
    "sqlalchemy.pool.NullPool")类来使用[`NullPool`](../core/pooling.html#sqlalchemy.pool.NullPool
    "sqlalchemy.pool.NullPool")类。
- en: Disabling Connection Pooling for File Databases
  id: totrans-832
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 为文件数据库禁用连接池
- en: 'Pooling may be disabled for a file based database by specifying the [`NullPool`](../core/pooling.html#sqlalchemy.pool.NullPool
    "sqlalchemy.pool.NullPool") implementation for the `poolclass()` parameter:'
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过为`poolclass()`参数指定[`NullPool`](../core/pooling.html#sqlalchemy.pool.NullPool
    "sqlalchemy.pool.NullPool")实现来禁用文件型数据库的连接池：
- en: '[PRE148]'
  id: totrans-834
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: It’s been observed that the [`NullPool`](../core/pooling.html#sqlalchemy.pool.NullPool
    "sqlalchemy.pool.NullPool") implementation incurs an extremely small performance
    overhead for repeated checkouts due to the lack of connection re-use implemented
    by [`QueuePool`](../core/pooling.html#sqlalchemy.pool.QueuePool "sqlalchemy.pool.QueuePool").
    However, it still may be beneficial to use this class if the application is experiencing
    issues with files being locked.
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: 已观察到由于[`QueuePool`](../core/pooling.html#sqlalchemy.pool.QueuePool "sqlalchemy.pool.QueuePool")没有连接重用，因此[`NullPool`](../core/pooling.html#sqlalchemy.pool.NullPool
    "sqlalchemy.pool.NullPool")实现在重复检出时产生极小的性能开销。然而，如果应用程序出现文件被锁定的问题，仍然可能有利于使用此类。
- en: Using a Memory Database in Multiple Threads
  id: totrans-836
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在多个线程中使用内存数据库
- en: 'To use a `:memory:` database in a multithreaded scenario, the same connection
    object must be shared among threads, since the database exists only within the
    scope of that connection. The [`StaticPool`](../core/pooling.html#sqlalchemy.pool.StaticPool
    "sqlalchemy.pool.StaticPool") implementation will maintain a single connection
    globally, and the `check_same_thread` flag can be passed to Pysqlite as `False`:'
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: 要在多线程情况下使用 `:memory:` 数据库，必须共享相同的连接对象，因为数据库仅存在于该连接的范围内。 [`StaticPool`](../core/pooling.html#sqlalchemy.pool.StaticPool
    "sqlalchemy.pool.StaticPool") 实现将在全局维护单个连接，并且可以将 `check_same_thread` 标志传递给 Pysqlite
    为 `False`：
- en: '[PRE149]'
  id: totrans-838
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: Note that using a `:memory:` database in multiple threads requires a recent
    version of SQLite.
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在多线程中使用 `:memory:` 数据库需要 SQLite 的最新版本。
- en: Using Temporary Tables with SQLite
  id: totrans-840
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用临时表与 SQLite
- en: 'Due to the way SQLite deals with temporary tables, if you wish to use a temporary
    table in a file-based SQLite database across multiple checkouts from the connection
    pool, such as when using an ORM [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") where the temporary table should continue to remain
    after [`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") or [`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") is called, a pool which maintains a single
    connection must be used. Use [`SingletonThreadPool`](../core/pooling.html#sqlalchemy.pool.SingletonThreadPool
    "sqlalchemy.pool.SingletonThreadPool") if the scope is only needed within the
    current thread, or [`StaticPool`](../core/pooling.html#sqlalchemy.pool.StaticPool
    "sqlalchemy.pool.StaticPool") is scope is needed within multiple threads for this
    case:'
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 SQLite 处理临时表的方式，如果希望在基于文件的 SQLite 数据库中跨多个连接池检出时使用临时表，例如在使用 ORM [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 时，临时表应在 [`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") 或 [`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") 调用后继续存在，必须使用维护单个连接的连接池。如果作用域仅在当前线程中需要，请使用 [`SingletonThreadPool`](../core/pooling.html#sqlalchemy.pool.SingletonThreadPool
    "sqlalchemy.pool.SingletonThreadPool")，或者如果需要在多个线程中使用，则使用 [`StaticPool`](../core/pooling.html#sqlalchemy.pool.StaticPool
    "sqlalchemy.pool.StaticPool")：
- en: '[PRE150]'
  id: totrans-842
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: Note that [`SingletonThreadPool`](../core/pooling.html#sqlalchemy.pool.SingletonThreadPool
    "sqlalchemy.pool.SingletonThreadPool") should be configured for the number of
    threads that are to be used; beyond that number, connections will be closed out
    in a non deterministic way.
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，[`SingletonThreadPool`](../core/pooling.html#sqlalchemy.pool.SingletonThreadPool
    "sqlalchemy.pool.SingletonThreadPool") 应配置为要使用的线程数；超出该数量时，连接将以不确定的方式关闭。
- en: Dealing with Mixed String / Binary Columns
  id: totrans-844
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理混合字符串 / 二进制列
- en: The SQLite database is weakly typed, and as such it is possible when using binary
    values, which in Python are represented as `b'some string'`, that a particular
    SQLite database can have data values within different rows where some of them
    will be returned as a `b''` value by the Pysqlite driver, and others will be returned
    as Python strings, e.g. `''` values. This situation is not known to occur if the
    SQLAlchemy [`LargeBinary`](../core/type_basics.html#sqlalchemy.types.LargeBinary
    "sqlalchemy.types.LargeBinary") datatype is used consistently, however if a particular
    SQLite database has data that was inserted using the Pysqlite driver directly,
    or when using the SQLAlchemy [`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String") type which was later changed to [`LargeBinary`](../core/type_basics.html#sqlalchemy.types.LargeBinary
    "sqlalchemy.types.LargeBinary"), the table will not be consistently readable because
    SQLAlchemy’s [`LargeBinary`](../core/type_basics.html#sqlalchemy.types.LargeBinary
    "sqlalchemy.types.LargeBinary") datatype does not handle strings so it has no
    way of “encoding” a value that is in string format.
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 数据库是弱类型的，因此在使用二进制值时（在 Python 中表示为 `b'some string'`），可能会出现特定的 SQLite 数据库，其中一些行的数据值将由
    Pysqlite 驱动程序返回为 `b''` 值，而其他行将作为 Python 字符串返回，例如 `''` 值。如果一致使用 SQLAlchemy [`LargeBinary`](../core/type_basics.html#sqlalchemy.types.LargeBinary
    "sqlalchemy.types.LargeBinary") 数据类型，则不会发生此情况，但是如果特定的 SQLite 数据库具有使用 Pysqlite
    驱动程序直接插入的数据，或者当使用 SQLAlchemy [`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String") 类型时后来更改为 [`LargeBinary`](../core/type_basics.html#sqlalchemy.types.LargeBinary
    "sqlalchemy.types.LargeBinary")，表将无法一致可读，因为 SQLAlchemy 的 [`LargeBinary`](../core/type_basics.html#sqlalchemy.types.LargeBinary
    "sqlalchemy.types.LargeBinary") 数据类型不处理字符串，因此无法对处于字符串格式的值进行“编码”。
- en: 'To deal with a SQLite table that has mixed string / binary data in the same
    column, use a custom type that will check each row individually:'
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: 要处理具有混合字符串/二进制数据的 SQLite 表中的情况，请使用一个自定义类型，将逐行检查每一行：
- en: '[PRE151]'
  id: totrans-847
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: Then use the above `MixedBinary` datatype in the place where [`LargeBinary`](../core/type_basics.html#sqlalchemy.types.LargeBinary
    "sqlalchemy.types.LargeBinary") would normally be used.
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在通常会使用 [`LargeBinary`](../core/type_basics.html#sqlalchemy.types.LargeBinary
    "sqlalchemy.types.LargeBinary") 的地方使用上述 `MixedBinary` 数据类型。
- en: '### Serializable isolation / Savepoints / Transactional DDL'
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: '### 可序列化隔离 / 保存点 / 事务 DDL'
- en: In the section [Database Locking Behavior / Concurrency](#sqlite-concurrency),
    we refer to the pysqlite driver’s assortment of issues that prevent several features
    of SQLite from working correctly. The pysqlite DBAPI driver has several long-standing
    bugs which impact the correctness of its transactional behavior. In its default
    mode of operation, SQLite features such as SERIALIZABLE isolation, transactional
    DDL, and SAVEPOINT support are non-functional, and in order to use these features,
    workarounds must be taken.
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [数据库锁定行为 / 并发性](#sqlite-concurrency) 部分中，我们提到 pysqlite 驱动程序的一系列问题，这些问题会导致
    SQLite 的几个功能无法正常工作。 pysqlite DBAPI 驱动程序有几个长期存在的错误，影响其事务行为的正确性。 在其默认操作模式下，SQLite
    的功能，如 SERIALIZABLE 隔离、事务 DDL 和 SAVEPOINT 支持是不起作用的，为了使用这些功能，必须采取解决方法。
- en: The issue is essentially that the driver attempts to second-guess the user’s
    intent, failing to start transactions and sometimes ending them prematurely, in
    an effort to minimize the SQLite databases’s file locking behavior, even though
    SQLite itself uses “shared” locks for read-only activities.
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: 问题本质上是驱动程序试图猜测用户的意图，未能启动事务，有时会过早结束事务，以减少 SQLite 数据库的文件锁定行为，尽管 SQLite 本身对只读活动使用“共享”锁。
- en: SQLAlchemy chooses to not alter this behavior by default, as it is the long-expected
    behavior of the pysqlite driver; if and when the pysqlite driver attempts to repair
    these issues, that will be more of a driver towards defaults for SQLAlchemy.
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 默认选择不更改此行为，因为这是 pysqlite 驱动程序长期期望的行为；如果 pysqlite 驱动程序尝试修复这些问题，那将更多地影响到
    SQLAlchemy 的默认设置。
- en: 'The good news is that with a few events, we can implement transactional support
    fully, by disabling pysqlite’s feature entirely and emitting BEGIN ourselves.
    This is achieved using two event listeners:'
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，通过几个事件，我们可以完全实现事务支持，通过完全禁用 pysqlite 的功能并自己发出 BEGIN 来实现。 这是通过使用两个事件监听器实现的：
- en: '[PRE152]'
  id: totrans-854
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: Warning
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: When using the above recipe, it is advised to not use the [`Connection.execution_options.isolation_level`](../core/connections.html#sqlalchemy.engine.Connection.execution_options.params.isolation_level
    "sqlalchemy.engine.Connection.execution_options") setting on [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") and [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") with the SQLite driver, as this function necessarily
    will also alter the “.isolation_level” setting.
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用上述方法时，建议不要在 SQLite 驱动程序上使用 [`Connection.execution_options.isolation_level`](../core/connections.html#sqlalchemy.engine.Connection.execution_options.params.isolation_level
    "sqlalchemy.engine.Connection.execution_options") 设置，因为这个函数必然也会改变“.isolation_level”设置。
- en: Above, we intercept a new pysqlite connection and disable any transactional
    integration. Then, at the point at which SQLAlchemy knows that transaction scope
    is to begin, we emit `"BEGIN"` ourselves.
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面，我们拦截一个新的 pysqlite 连接并禁用任何事务集成。然后，在 SQLAlchemy 知道事务范围即将开始的时候，我们自己发出 `"BEGIN"`。
- en: 'When we take control of `"BEGIN"`, we can also control directly SQLite’s locking
    modes, introduced at [BEGIN TRANSACTION](https://sqlite.org/lang_transaction.html),
    by adding the desired locking mode to our `"BEGIN"`:'
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们控制 `"BEGIN"` 时，我们也可以直接控制 SQLite 的锁定模式，通过在我们的 `"BEGIN"` 中添加所需的锁定模式：
- en: '[PRE153]'
  id: totrans-859
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: See also
  id: totrans-860
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[BEGIN TRANSACTION](https://sqlite.org/lang_transaction.html) - on the SQLite
    site'
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
  zh: '[BEGIN TRANSACTION](https://sqlite.org/lang_transaction.html) - 在 SQLite 网站上'
- en: '[sqlite3 SELECT does not BEGIN a transaction](https://bugs.python.org/issue9924)
    - on the Python bug tracker'
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
  zh: '[sqlite3 SELECT 不会开始事务](https://bugs.python.org/issue9924) - 在 Python 缺陷跟踪器上'
- en: '[sqlite3 module breaks transactions and potentially corrupts data](https://bugs.python.org/issue10740)
    - on the Python bug tracker  ### User-Defined Functions'
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: '[sqlite3 模块破坏事务并可能损坏数据](https://bugs.python.org/issue10740) - 在 Python 缺陷跟踪器上  ###
    用户定义函数'
- en: pysqlite supports a [create_function()](https://docs.python.org/3/library/sqlite3.html#sqlite3.Connection.create_function)
    method that allows us to create our own user-defined functions (UDFs) in Python
    and use them directly in SQLite queries. These functions are registered with a
    specific DBAPI Connection.
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
  zh: pysqlite支持一个[create_function()](https://docs.python.org/3/library/sqlite3.html#sqlite3.Connection.create_function)方法，允许我们在Python中创建自己的用户定义函数（UDF）并直接在SQLite查询中使用它们。这些函数与特定的DBAPI连接相关联。
- en: 'SQLAlchemy uses connection pooling with file-based SQLite databases, so we
    need to ensure that the UDF is attached to the connection when it is created.
    That is accomplished with an event listener:'
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy使用基于文件的SQLite数据库的连接池，因此我们需要确保在创建连接时将UDF附加到连接上。通过事件监听器实现：
- en: '[PRE154]'
  id: totrans-866
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: DBAPI
  id: totrans-867
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据库API
- en: 'Documentation and download information (if applicable) for pysqlite is available
    at: [https://docs.python.org/library/sqlite3.html](https://docs.python.org/library/sqlite3.html)'
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
  zh: pysqlite的文档和下载信息（如果适用）可在此处获取：[https://docs.python.org/library/sqlite3.html](https://docs.python.org/library/sqlite3.html)
- en: Connecting
  id: totrans-869
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接
- en: 'Connect String:'
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
  zh: 连接字符串：
- en: '[PRE155]'
  id: totrans-871
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: Driver
  id: totrans-872
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 驱动程序
- en: The `sqlite3` Python DBAPI is standard on all modern Python versions; for cPython
    and Pypy, no additional installation is necessary.
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有现代Python版本上，`sqlite3` Python数据库API是标准的；对于cPython和Pypy，不需要额外安装。
- en: Connect Strings
  id: totrans-874
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接字符串
- en: 'The file specification for the SQLite database is taken as the “database” portion
    of the URL. Note that the format of a SQLAlchemy url is:'
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite数据库的文件规范被视为URL的“数据库”部分。请注意，SQLAlchemy URL的格式是：
- en: '[PRE156]'
  id: totrans-876
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'This means that the actual filename to be used starts with the characters to
    the **right** of the third slash. So connecting to a relative filepath looks like:'
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着要使用的实际文件名从第三个斜杠的**右侧**字符开始。因此，连接到相对文件路径看起来像：
- en: '[PRE157]'
  id: totrans-878
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: 'An absolute path, which is denoted by starting with a slash, means you need
    **four** slashes:'
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
  zh: 绝对路径，以斜杠开头，意味着你需要**四个**斜杠：
- en: '[PRE158]'
  id: totrans-880
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'To use a Windows path, regular drive specifications and backslashes can be
    used. Double backslashes are probably needed:'
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Windows路径，可以使用常规的驱动器规范和反斜杠。可能需要双反斜杠：
- en: '[PRE159]'
  id: totrans-882
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'To use sqlite `:memory:` database specify it as the filename using `sqlite://:memory:`.
    It’s also the default if no filepath is present, specifying only `sqlite://` and
    nothing else:'
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用sqlite的`:memory:`数据库，请将其指定为文件名，使用`sqlite://:memory:`。如果没有文件路径，则它也是默认值，只需指定`sqlite://`而不加其他内容：
- en: '[PRE160]'
  id: totrans-884
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: '#### URI Connections'
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: '#### URI连接'
- en: 'Modern versions of SQLite support an alternative system of connecting using
    a [driver level URI](https://www.sqlite.org/uri.html), which has the advantage
    that additional driver-level arguments can be passed including options such as
    “read only”. The Python sqlite3 driver supports this mode under modern Python
    3 versions. The SQLAlchemy pysqlite driver supports this mode of use by specifying
    “uri=true” in the URL query string. The SQLite-level “URI” is kept as the “database”
    portion of the SQLAlchemy url (that is, following a slash):'
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
  zh: 现代版本的SQLite支持使用[驱动程序级URI](https://www.sqlite.org/uri.html)进行连接的替代系统，其优点是可以传递额外的驱动程序级参数，包括“只读”选项。
    Python sqlite3驱动程序在现代Python 3版本下支持此模式。 SQLAlchemy pysqlite驱动程序通过在URL查询字符串中指定“uri=true”来支持此使用模式。
    SQLite级别的“URI”保留为SQLAlchemy URL的“数据库”部分（即，跟在斜杠后面）：
- en: '[PRE161]'
  id: totrans-887
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: Note
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The “uri=true” parameter must appear in the **query string** of the URL. It
    will not currently work as expected if it is only present in the [`create_engine.connect_args`](../core/engines.html#sqlalchemy.create_engine.params.connect_args
    "sqlalchemy.create_engine") parameter dictionary.
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
  zh: “uri=true”参数必须出现在URL的**查询字符串**中。如果它只出现在[`create_engine.connect_args`](../core/engines.html#sqlalchemy.create_engine)参数字典中，则当前不会按预期工作。
- en: 'The logic reconciles the simultaneous presence of SQLAlchemy’s query string
    and SQLite’s query string by separating out the parameters that belong to the
    Python sqlite3 driver vs. those that belong to the SQLite URI. This is achieved
    through the use of a fixed list of parameters known to be accepted by the Python
    side of the driver. For example, to include a URL that indicates the Python sqlite3
    “timeout” and “check_same_thread” parameters, along with the SQLite “mode” and
    “nolock” parameters, they can all be passed together on the query string:'
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
  zh: 该逻辑通过分离属于Python sqlite3驱动程序与属于SQLite URI的参数，来调和SQLAlchemy查询字符串和SQLite查询字符串的同时出现。这通过使用一个已知被驱动程序的Python部分接受的固定参数列表来实现。例如，要包含指示Python
    sqlite3“timeout”和“check_same_thread”参数以及SQLite“mode”和“nolock”参数的URL，它们可以一起传递到查询字符串中：
- en: '[PRE162]'
  id: totrans-891
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: 'Above, the pysqlite / sqlite3 DBAPI would be passed arguments as:'
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: 上面，pysqlite / sqlite3 DBAPI 将被传递参数如下：
- en: '[PRE163]'
  id: totrans-893
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: Regarding future parameters added to either the Python or native drivers. new
    parameter names added to the SQLite URI scheme should be automatically accommodated
    by this scheme. New parameter names added to the Python driver side can be accommodated
    by specifying them in the [`create_engine.connect_args`](../core/engines.html#sqlalchemy.create_engine.params.connect_args
    "sqlalchemy.create_engine") dictionary, until dialect support is added by SQLAlchemy.
    For the less likely case that the native SQLite driver adds a new parameter name
    that overlaps with one of the existing, known Python driver parameters (such as
    “timeout” perhaps), SQLAlchemy’s dialect would require adjustment for the URL
    scheme to continue to support this.
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: 关于将来添加到Python或本机驱动程序的新参数。添加到SQLite URI方案的新参数名称应该自动适应此方案。添加到Python驱动程序端的新参数名称可以通过在[`create_engine.connect_args`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine")字典中指定它们来适应，直到SQLAlchemy添加了方言支持。对于本机SQLite驱动程序添加一个与现有已知Python驱动程序参数（例如“timeout”）重叠的新参数名称的可能性较小，SQLAlchemy的方言将需要调整URL方案以继续支持此参数。
- en: As is always the case for all SQLAlchemy dialects, the entire “URL” process
    can be bypassed in [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") through the use of the [`create_engine.creator`](../core/engines.html#sqlalchemy.create_engine.params.creator
    "sqlalchemy.create_engine") parameter which allows for a custom callable that
    creates a Python sqlite3 driver level connection directly.
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有SQLAlchemy方言，始终可以通过使用[`create_engine.creator`](../core/engines.html#sqlalchemy.create_engine.params.creator
    "sqlalchemy.create_engine")参数绕过整个“URL”过程，在[`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine")中直接通过使用一个自定义可调用对象来创建Python sqlite3驱动程序级别的连接。
- en: New in version 1.3.9.
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
  zh: 版本1.3.9中的新功能。
- en: See also
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[Uniform Resource Identifiers](https://www.sqlite.org/uri.html) - in the SQLite
    documentation  #### URI Connections'
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
  zh: '[统一资源标识符](https://www.sqlite.org/uri.html) - 在SQLite文档中  #### URI连接'
- en: 'Modern versions of SQLite support an alternative system of connecting using
    a [driver level URI](https://www.sqlite.org/uri.html), which has the advantage
    that additional driver-level arguments can be passed including options such as
    “read only”. The Python sqlite3 driver supports this mode under modern Python
    3 versions. The SQLAlchemy pysqlite driver supports this mode of use by specifying
    “uri=true” in the URL query string. The SQLite-level “URI” is kept as the “database”
    portion of the SQLAlchemy url (that is, following a slash):'
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
  zh: 现代版本的SQLite支持使用[驱动级URI](https://www.sqlite.org/uri.html)进行连接的替代系统，其优势在于可以传递额外的驱动级参数，包括“只读”等选项。Python
    sqlite3驱动程序在现代Python 3版本下支持此模式。SQLAlchemy pysqlite驱动程序通过在URL查询字符串中指定“uri=true”来支持此使用模式。SQLite级别的“URI”保留为SQLAlchemy
    URL的“database”部分（即，在斜杠后面）：
- en: '[PRE164]'
  id: totrans-900
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: Note
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The “uri=true” parameter must appear in the **query string** of the URL. It
    will not currently work as expected if it is only present in the [`create_engine.connect_args`](../core/engines.html#sqlalchemy.create_engine.params.connect_args
    "sqlalchemy.create_engine") parameter dictionary.
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
  zh: “uri=true” 参数必须出现在URL的**查询字符串**中。如果它只存在于[`create_engine.connect_args`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine")参数字典中，它目前不会按预期工作。
- en: 'The logic reconciles the simultaneous presence of SQLAlchemy’s query string
    and SQLite’s query string by separating out the parameters that belong to the
    Python sqlite3 driver vs. those that belong to the SQLite URI. This is achieved
    through the use of a fixed list of parameters known to be accepted by the Python
    side of the driver. For example, to include a URL that indicates the Python sqlite3
    “timeout” and “check_same_thread” parameters, along with the SQLite “mode” and
    “nolock” parameters, they can all be passed together on the query string:'
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑通过将属于Python sqlite3驱动程序的参数与属于SQLite URI的参数分开，来协调SQLAlchemy的查询字符串和SQLite的查询字符串的同时存在。这是通过使用已知被Python驱动程序接受的一组固定参数来实现的。例如，要包含指示Python
    sqlite3“timeout”和“check_same_thread”参数以及SQLite“mode”和“nolock”参数的URL，它们可以一起传递在查询字符串中：
- en: '[PRE165]'
  id: totrans-904
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: 'Above, the pysqlite / sqlite3 DBAPI would be passed arguments as:'
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
  zh: 上面，pysqlite / sqlite3 DBAPI 将被传递参数如下：
- en: '[PRE166]'
  id: totrans-906
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: Regarding future parameters added to either the Python or native drivers. new
    parameter names added to the SQLite URI scheme should be automatically accommodated
    by this scheme. New parameter names added to the Python driver side can be accommodated
    by specifying them in the [`create_engine.connect_args`](../core/engines.html#sqlalchemy.create_engine.params.connect_args
    "sqlalchemy.create_engine") dictionary, until dialect support is added by SQLAlchemy.
    For the less likely case that the native SQLite driver adds a new parameter name
    that overlaps with one of the existing, known Python driver parameters (such as
    “timeout” perhaps), SQLAlchemy’s dialect would require adjustment for the URL
    scheme to continue to support this.
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
  zh: 关于将来添加到 Python 或本机驱动程序的参数。新增加到 SQLite URI 方案的参数名应该由该方案自动适应。新增加到 Python 驱动程序端的参数名可以通过在
    [`create_engine.connect_args`](../core/engines.html#sqlalchemy.create_engine.params.connect_args
    "sqlalchemy.create_engine") 字典中指定它们来容纳，直到 SQLAlchemy 添加了方言支持。对于较不可能的情况，即本机 SQLite
    驱动程序添加了与现有已知 Python 驱动程序参数（例如“timeout”）重叠的新参数名，SQLAlchemy 的方言需要调整 URL 方案以继续支持此参数。
- en: As is always the case for all SQLAlchemy dialects, the entire “URL” process
    can be bypassed in [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") through the use of the [`create_engine.creator`](../core/engines.html#sqlalchemy.create_engine.params.creator
    "sqlalchemy.create_engine") parameter which allows for a custom callable that
    creates a Python sqlite3 driver level connection directly.
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: 与 SQLAlchemy 方言的所有情况一样，整个“URL”过程都可以通过 [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") 中的 [`create_engine.creator`](../core/engines.html#sqlalchemy.create_engine.params.creator
    "sqlalchemy.create_engine") 参数绕过，该参数允许自定义可调用项，直接创建 Python sqlite3 驱动程序级连接。
- en: New in version 1.3.9.
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
  zh: 1.3.9 版的新内容。
- en: See also
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Uniform Resource Identifiers](https://www.sqlite.org/uri.html) - in the SQLite
    documentation'
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
  zh: '[统一资源标识符](https://www.sqlite.org/uri.html) - SQLite 文档中'
- en: '### Regular Expression Support'
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
  zh: '### 正则表达式支持'
- en: New in version 1.4.
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
  zh: 1.4 版中的新内容。
- en: Support for the [`ColumnOperators.regexp_match()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.regexp_match
    "sqlalchemy.sql.expression.ColumnOperators.regexp_match") operator is provided
    using Python’s [re.search](https://docs.python.org/3/library/re.html#re.search)
    function. SQLite itself does not include a working regular expression operator;
    instead, it includes a non-implemented placeholder operator `REGEXP` that calls
    a user-defined function that must be provided.
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
  zh: 支持使用 Python 的 [re.search](https://docs.python.org/3/library/re.html#re.search)
    函数提供 [`ColumnOperators.regexp_match()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.regexp_match
    "sqlalchemy.sql.expression.ColumnOperators.regexp_match") 操作符。SQLite 本身不包括工作正则表达式运算符；相反，它包括一个未实现的占位符操作符
    `REGEXP`，该操作符调用必须提供的用户定义函数。
- en: 'SQLAlchemy’s implementation makes use of the pysqlite [create_function](https://docs.python.org/3/library/sqlite3.html#sqlite3.Connection.create_function)
    hook as follows:'
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 的实现使用 pysqlite [create_function](https://docs.python.org/3/library/sqlite3.html#sqlite3.Connection.create_function)
    钩子，如下所示：
- en: '[PRE167]'
  id: totrans-916
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: There is currently no support for regular expression flags as a separate argument,
    as these are not supported by SQLite’s REGEXP operator, however these may be included
    inline within the regular expression string. See [Python regular expressions](https://docs.python.org/3/library/re.html#re.search)
    for details.
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
  zh: 目前不支持将正则表达式标志作为单独参数，因为这些标志不受 SQLite 的 REGEXP 操作符支持，但可以内联在正则表达式字符串中。有关详情，请参阅
    [Python 正则表达式](https://docs.python.org/3/library/re.html#re.search)。
- en: See also
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Python regular expressions](https://docs.python.org/3/library/re.html#re.search):
    Documentation for Python’s regular expression syntax.'
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
  zh: '[Python 正则表达式](https://docs.python.org/3/library/re.html#re.search)：Python
    正则表达式语法的文档。'
- en: Compatibility with sqlite3 “native” date and datetime types
  id: totrans-920
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 兼容性与 sqlite3 的“本地”日期和日期时间类型
- en: The pysqlite driver includes the sqlite3.PARSE_DECLTYPES and sqlite3.PARSE_COLNAMES
    options, which have the effect of any column or expression explicitly cast as
    “date” or “timestamp” will be converted to a Python date or datetime object. The
    date and datetime types provided with the pysqlite dialect are not currently compatible
    with these options, since they render the ISO date/datetime including microseconds,
    which pysqlite’s driver does not. Additionally, SQLAlchemy does not at this time
    automatically render the “cast” syntax required for the freestanding functions
    “current_timestamp” and “current_date” to return datetime/date types natively.
    Unfortunately, pysqlite does not provide the standard DBAPI types in `cursor.description`,
    leaving SQLAlchemy with no way to detect these types on the fly without expensive
    per-row type checks.
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
  zh: pysqlite 驱动程序包括 sqlite3.PARSE_DECLTYPES 和 sqlite3.PARSE_COLNAMES 选项，其效果是任何明确转换为“date”或“timestamp”的列或表达式将被转换为Python的日期或日期时间对象。pysqlite
    方言提供的日期和日期时间类型目前与这些选项不兼容，因为它们呈现的ISO日期/日期时间包括微秒，而 pysqlite 的驱动程序没有。此外，SQLAlchemy
    目前不会自动渲染“cast”语法，该语法要求独立的函数“current_timestamp”和“current_date”以本地返回datetime/date类型。不幸的是，pysqlite
    不会在 `cursor.description` 中提供标准的DBAPI类型，因此SQLAlchemy无法在不执行昂贵的每行类型检查的情况下即时检测到这些类型。
- en: 'Keeping in mind that pysqlite’s parsing option is not recommended, nor should
    be necessary, for use with SQLAlchemy, usage of PARSE_DECLTYPES can be forced
    if one configures “native_datetime=True” on create_engine():'
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
  zh: 特别注意，pysqlite 的解析选项不建议使用，也不应该在与SQLAlchemy一起使用时需要使用，如果在 create_engine() 上配置了
    “native_datetime=True”，则可以强制使用 PARSE_DECLTYPES 选项：
- en: '[PRE168]'
  id: totrans-923
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: With this flag enabled, the DATE and TIMESTAMP types (but note - not the DATETIME
    or TIME types…confused yet ?) will not perform any bind parameter or result processing.
    Execution of “func.current_date()” will return a string. “func.current_timestamp()”
    is registered as returning a DATETIME type in SQLAlchemy, so this function still
    receives SQLAlchemy-level result processing.
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
  zh: 启用此标志后，DATE 和 TIMESTAMP 类型（但请注意 - 不是 DATETIME 或 TIME 类型…搞糊涂了吗？）将不执行任何绑定参数或结果处理。执行“func.current_date()”将返回一个字符串。“func.current_timestamp()”在SQLAlchemy中注册为返回DATETIME类型，因此此函数仍然接收SQLAlchemy级别的结果处理。
- en: '### Threading/Pooling Behavior'
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
  zh: '### 线程/池行为'
- en: The `sqlite3` DBAPI by default prohibits the use of a particular connection
    in a thread which is not the one in which it was created. As SQLite has matured,
    it’s behavior under multiple threads has improved, and even includes options for
    memory only databases to be used in multiple threads.
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`sqlite3` DBAPI 禁止在非创建它的线程中使用特定的连接。随着SQLite的成熟，它在多线程下的行为已经改进，甚至包括选项让内存数据库可以在多个线程中使用。
- en: The thread prohibition is known as “check same thread” and may be controlled
    using the `sqlite3` parameter `check_same_thread`, which will disable or enable
    this check. SQLAlchemy’s default behavior here is to set `check_same_thread` to
    `False` automatically whenever a file-based database is in use, to establish compatibility
    with the default pool class [`QueuePool`](../core/pooling.html#sqlalchemy.pool.QueuePool
    "sqlalchemy.pool.QueuePool").
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
  zh: 线程禁止被称为“检查同一线程”，可以使用 `sqlite3` 参数 `check_same_thread` 来控制，这将禁用或启用此检查。SQLAlchemy在这里的默认行为是，当使用基于文件的数据库时，自动将
    `check_same_thread` 设置为 `False`，以确保与默认的池类 [`QueuePool`](../core/pooling.html#sqlalchemy.pool.QueuePool
    "sqlalchemy.pool.QueuePool") 兼容。
- en: 'The SQLAlchemy `pysqlite` DBAPI establishes the connection pool differently
    based on the kind of SQLite database that’s requested:'
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy `pysqlite` DBAPI 根据所请求的SQLite数据库的类型不同而建立连接池：
- en: When a `:memory:` SQLite database is specified, the dialect by default will
    use [`SingletonThreadPool`](../core/pooling.html#sqlalchemy.pool.SingletonThreadPool
    "sqlalchemy.pool.SingletonThreadPool"). This pool maintains a single connection
    per thread, so that all access to the engine within the current thread use the
    same `:memory:` database - other threads would access a different `:memory:` database.
    The `check_same_thread` parameter defaults to `True`.
  id: totrans-929
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当指定了一个 `:memory:` 的SQLite数据库时，默认情况下方言会使用 [`SingletonThreadPool`](../core/pooling.html#sqlalchemy.pool.SingletonThreadPool
    "sqlalchemy.pool.SingletonThreadPool")。这个池每个线程维护一个连接，所以当前线程内的对引擎的所有访问都使用同一个 `:memory:`
    数据库 - 其他线程将访问一个不同的 `:memory:` 数据库。`check_same_thread` 参数默认为 `True`。
- en: When a file-based database is specified, the dialect will use [`QueuePool`](../core/pooling.html#sqlalchemy.pool.QueuePool
    "sqlalchemy.pool.QueuePool") as the source of connections. at the same time, the
    `check_same_thread` flag is set to False by default unless overridden.
  id: totrans-930
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当指定基于文件的数据库时，方言将使用[`QueuePool`](../core/pooling.html#sqlalchemy.pool.QueuePool
    "sqlalchemy.pool.QueuePool")作为连接的源。同时，默认情况下将`check_same_thread`标志设置为False，除非被覆盖。
- en: 'Changed in version 2.0: SQLite file database engines now use [`QueuePool`](../core/pooling.html#sqlalchemy.pool.QueuePool
    "sqlalchemy.pool.QueuePool") by default. Previously, [`NullPool`](../core/pooling.html#sqlalchemy.pool.NullPool
    "sqlalchemy.pool.NullPool") were used. The [`NullPool`](../core/pooling.html#sqlalchemy.pool.NullPool
    "sqlalchemy.pool.NullPool") class may be used by specifying it via the [`create_engine.poolclass`](../core/engines.html#sqlalchemy.create_engine.params.poolclass
    "sqlalchemy.create_engine") parameter.'
  id: totrans-931
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从版本2.0开始更改：SQLite文件数据库引擎现在默认使用[`QueuePool`](../core/pooling.html#sqlalchemy.pool.QueuePool
    "sqlalchemy.pool.QueuePool")。以前使用的是[`NullPool`](../core/pooling.html#sqlalchemy.pool.NullPool
    "sqlalchemy.pool.NullPool")。可以通过[`create_engine.poolclass`](../core/engines.html#sqlalchemy.create_engine.params.poolclass
    "sqlalchemy.create_engine")参数指定使用[`NullPool`](../core/pooling.html#sqlalchemy.pool.NullPool
    "sqlalchemy.pool.NullPool")类。
- en: Disabling Connection Pooling for File Databases
  id: totrans-932
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 禁用文件数据库的连接池
- en: 'Pooling may be disabled for a file based database by specifying the [`NullPool`](../core/pooling.html#sqlalchemy.pool.NullPool
    "sqlalchemy.pool.NullPool") implementation for the `poolclass()` parameter:'
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
  zh: 通过为`poolclass()`参数指定[`NullPool`](../core/pooling.html#sqlalchemy.pool.NullPool
    "sqlalchemy.pool.NullPool")实现，可以禁用基于文件的数据库的连接池：
- en: '[PRE169]'
  id: totrans-934
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: It’s been observed that the [`NullPool`](../core/pooling.html#sqlalchemy.pool.NullPool
    "sqlalchemy.pool.NullPool") implementation incurs an extremely small performance
    overhead for repeated checkouts due to the lack of connection re-use implemented
    by [`QueuePool`](../core/pooling.html#sqlalchemy.pool.QueuePool "sqlalchemy.pool.QueuePool").
    However, it still may be beneficial to use this class if the application is experiencing
    issues with files being locked.
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
  zh: 据观察，[`NullPool`](../core/pooling.html#sqlalchemy.pool.NullPool "sqlalchemy.pool.NullPool")实现由于[`QueuePool`](../core/pooling.html#sqlalchemy.pool.QueuePool
    "sqlalchemy.pool.QueuePool")实现的连接不重用而导致极小的性能开销。但是，如果应用程序遇到文件被锁定的问题，仍然可能有益于使用此类。
- en: Using a Memory Database in Multiple Threads
  id: totrans-936
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在多个线程中使用内存数据库
- en: 'To use a `:memory:` database in a multithreaded scenario, the same connection
    object must be shared among threads, since the database exists only within the
    scope of that connection. The [`StaticPool`](../core/pooling.html#sqlalchemy.pool.StaticPool
    "sqlalchemy.pool.StaticPool") implementation will maintain a single connection
    globally, and the `check_same_thread` flag can be passed to Pysqlite as `False`:'
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
  zh: 在多线程场景中使用`:memory:`数据库，必须共享相同的连接对象，因为数据库仅存在于该连接的范围内。[`StaticPool`](../core/pooling.html#sqlalchemy.pool.StaticPool
    "sqlalchemy.pool.StaticPool")实现将全局维护一个单一连接，并且`check_same_thread`标志可以传递给 Pysqlite
    作为 `False`：
- en: '[PRE170]'
  id: totrans-938
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: Note that using a `:memory:` database in multiple threads requires a recent
    version of SQLite.
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在多线程中使用`:memory:`数据库需要最新版本的SQLite。
- en: Using Temporary Tables with SQLite
  id: totrans-940
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用SQLite临时表
- en: 'Due to the way SQLite deals with temporary tables, if you wish to use a temporary
    table in a file-based SQLite database across multiple checkouts from the connection
    pool, such as when using an ORM [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") where the temporary table should continue to remain
    after [`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") or [`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") is called, a pool which maintains a single
    connection must be used. Use [`SingletonThreadPool`](../core/pooling.html#sqlalchemy.pool.SingletonThreadPool
    "sqlalchemy.pool.SingletonThreadPool") if the scope is only needed within the
    current thread, or [`StaticPool`](../core/pooling.html#sqlalchemy.pool.StaticPool
    "sqlalchemy.pool.StaticPool") is scope is needed within multiple threads for this
    case:'
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
  zh: 由于SQLite处理临时表的方式，如果希望在基于文件的SQLite数据库中跨多个连接池检出使用临时表，例如在使用ORM [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")时，临时表应在[`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit")或[`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback")之后继续保留，必须使用维护单个连接的池。如果范围仅在当前线程内使用，则使用[`SingletonThreadPool`](../core/pooling.html#sqlalchemy.pool.SingletonThreadPool
    "sqlalchemy.pool.SingletonThreadPool")，或者在此情况下需要在多个线程中使用范围，则使用[`StaticPool`](../core/pooling.html#sqlalchemy.pool.StaticPool
    "sqlalchemy.pool.StaticPool")：
- en: '[PRE171]'
  id: totrans-942
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: Note that [`SingletonThreadPool`](../core/pooling.html#sqlalchemy.pool.SingletonThreadPool
    "sqlalchemy.pool.SingletonThreadPool") should be configured for the number of
    threads that are to be used; beyond that number, connections will be closed out
    in a non deterministic way.
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，应该为[`SingletonThreadPool`](../core/pooling.html#sqlalchemy.pool.SingletonThreadPool
    "sqlalchemy.pool.SingletonThreadPool")配置要使用的线程数；超出该数量，连接将以不确定的方式关闭。
- en: Disabling Connection Pooling for File Databases
  id: totrans-944
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 禁用文件数据库的连接池
- en: 'Pooling may be disabled for a file based database by specifying the [`NullPool`](../core/pooling.html#sqlalchemy.pool.NullPool
    "sqlalchemy.pool.NullPool") implementation for the `poolclass()` parameter:'
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过为`poolclass()`参数指定[`NullPool`](../core/pooling.html#sqlalchemy.pool.NullPool
    "sqlalchemy.pool.NullPool")实现来禁用基于文件的数据库的池化：
- en: '[PRE172]'
  id: totrans-946
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: It’s been observed that the [`NullPool`](../core/pooling.html#sqlalchemy.pool.NullPool
    "sqlalchemy.pool.NullPool") implementation incurs an extremely small performance
    overhead for repeated checkouts due to the lack of connection re-use implemented
    by [`QueuePool`](../core/pooling.html#sqlalchemy.pool.QueuePool "sqlalchemy.pool.QueuePool").
    However, it still may be beneficial to use this class if the application is experiencing
    issues with files being locked.
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[`NullPool`](../core/pooling.html#sqlalchemy.pool.NullPool "sqlalchemy.pool.NullPool")实现观察到，由于[`QueuePool`](../core/pooling.html#sqlalchemy.pool.QueuePool
    "sqlalchemy.pool.QueuePool")没有实现连接重用，因此对于重复检出，它会产生极小的性能开销。然而，如果应用程序遇到文件被锁定的问题，仍然可能有利用这个类。
- en: Using a Memory Database in Multiple Threads
  id: totrans-948
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在多线程中使用内存数据库
- en: 'To use a `:memory:` database in a multithreaded scenario, the same connection
    object must be shared among threads, since the database exists only within the
    scope of that connection. The [`StaticPool`](../core/pooling.html#sqlalchemy.pool.StaticPool
    "sqlalchemy.pool.StaticPool") implementation will maintain a single connection
    globally, and the `check_same_thread` flag can be passed to Pysqlite as `False`:'
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
  zh: 在多线程方案中使用`:memory:`数据库，相同的连接对象必须在线程之间共享，因为数据库仅存在于该连接的范围内。[`StaticPool`](../core/pooling.html#sqlalchemy.pool.StaticPool
    "sqlalchemy.pool.StaticPool")实现将在全局维护一个单一连接，并且`check_same_thread`标志可以传递给Pysqlite，设置为`False`：
- en: '[PRE173]'
  id: totrans-950
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: Note that using a `:memory:` database in multiple threads requires a recent
    version of SQLite.
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在多个线程中使用`:memory:`数据库需要SQLite的最新版本。
- en: Using Temporary Tables with SQLite
  id: totrans-952
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用SQLite临时表
- en: 'Due to the way SQLite deals with temporary tables, if you wish to use a temporary
    table in a file-based SQLite database across multiple checkouts from the connection
    pool, such as when using an ORM [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") where the temporary table should continue to remain
    after [`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") or [`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") is called, a pool which maintains a single
    connection must be used. Use [`SingletonThreadPool`](../core/pooling.html#sqlalchemy.pool.SingletonThreadPool
    "sqlalchemy.pool.SingletonThreadPool") if the scope is only needed within the
    current thread, or [`StaticPool`](../core/pooling.html#sqlalchemy.pool.StaticPool
    "sqlalchemy.pool.StaticPool") is scope is needed within multiple threads for this
    case:'
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
  zh: 由于SQLite处理临时表的方式，如果希望在基于文件的SQLite数据库中跨多次从连接池检出时使用临时表，例如在使用ORM [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")时，在[`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit")或[`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback")之后，临时表应继续保持，必须使用维护单个连接的池。如果范围仅在当前线程内需要，则使用[`SingletonThreadPool`](../core/pooling.html#sqlalchemy.pool.SingletonThreadPool
    "sqlalchemy.pool.SingletonThreadPool")，如果在多个线程中需要范围，则使用[`StaticPool`](../core/pooling.html#sqlalchemy.pool.StaticPool
    "sqlalchemy.pool.StaticPool")用于此案例：
- en: '[PRE174]'
  id: totrans-954
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: Note that [`SingletonThreadPool`](../core/pooling.html#sqlalchemy.pool.SingletonThreadPool
    "sqlalchemy.pool.SingletonThreadPool") should be configured for the number of
    threads that are to be used; beyond that number, connections will be closed out
    in a non deterministic way.
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，[`SingletonThreadPool`](../core/pooling.html#sqlalchemy.pool.SingletonThreadPool
    "sqlalchemy.pool.SingletonThreadPool")应配置为要使用的线程数；超出该数字后，连接将以不确定的方式关闭。
- en: Dealing with Mixed String / Binary Columns
  id: totrans-956
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理混合字符串/二进制列
- en: The SQLite database is weakly typed, and as such it is possible when using binary
    values, which in Python are represented as `b'some string'`, that a particular
    SQLite database can have data values within different rows where some of them
    will be returned as a `b''` value by the Pysqlite driver, and others will be returned
    as Python strings, e.g. `''` values. This situation is not known to occur if the
    SQLAlchemy [`LargeBinary`](../core/type_basics.html#sqlalchemy.types.LargeBinary
    "sqlalchemy.types.LargeBinary") datatype is used consistently, however if a particular
    SQLite database has data that was inserted using the Pysqlite driver directly,
    or when using the SQLAlchemy [`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String") type which was later changed to [`LargeBinary`](../core/type_basics.html#sqlalchemy.types.LargeBinary
    "sqlalchemy.types.LargeBinary"), the table will not be consistently readable because
    SQLAlchemy’s [`LargeBinary`](../core/type_basics.html#sqlalchemy.types.LargeBinary
    "sqlalchemy.types.LargeBinary") datatype does not handle strings so it has no
    way of “encoding” a value that is in string format.
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite数据库是弱类型的，因此当使用二进制值时，可能出现一种情况，即在Python中表示为`b'some string'`的情况下，特定的SQLite数据库可能会在不同的行中具有不同的数据值，其中一些将被Pysqlite驱动器返回为`b''`值，而另一些将被返回为Python字符串，例如`''`值。如果一直使用SQLAlchemy的[`LargeBinary`](../core/type_basics.html#sqlalchemy.types.LargeBinary
    "sqlalchemy.types.LargeBinary")数据类型，则不会发生此情况，但是如果特定的SQLite数据库具有使用Pysqlite驱动器直接插入的数据，或者在使用后将其更改为[`LargeBinary`](../core/type_basics.html#sqlalchemy.types.LargeBinary
    "sqlalchemy.types.LargeBinary")的SQLAlchemy [`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String")类型时，表将无法一致地读取，因为SQLAlchemy的[`LargeBinary`](../core/type_basics.html#sqlalchemy.types.LargeBinary
    "sqlalchemy.types.LargeBinary")数据类型不处理字符串，因此无法“编码”字符串格式的值。
- en: 'To deal with a SQLite table that has mixed string / binary data in the same
    column, use a custom type that will check each row individually:'
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
  zh: 要处理具有相同列中的混合字符串/二进制数据的SQLite表，请使用自定义类型逐个检查每一行：
- en: '[PRE175]'
  id: totrans-959
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: Then use the above `MixedBinary` datatype in the place where [`LargeBinary`](../core/type_basics.html#sqlalchemy.types.LargeBinary
    "sqlalchemy.types.LargeBinary") would normally be used.
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在通常会使用[`LargeBinary`](../core/type_basics.html#sqlalchemy.types.LargeBinary
    "sqlalchemy.types.LargeBinary")的地方使用上述的`MixedBinary`数据类型。
- en: '### Serializable isolation / Savepoints / Transactional DDL'
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
  zh: '### 可序列化隔离/保存点/事务DDL'
- en: In the section [Database Locking Behavior / Concurrency](#sqlite-concurrency),
    we refer to the pysqlite driver’s assortment of issues that prevent several features
    of SQLite from working correctly. The pysqlite DBAPI driver has several long-standing
    bugs which impact the correctness of its transactional behavior. In its default
    mode of operation, SQLite features such as SERIALIZABLE isolation, transactional
    DDL, and SAVEPOINT support are non-functional, and in order to use these features,
    workarounds must be taken.
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [数据库锁定行为 / 并发性](#sqlite-concurrency) 部分中，我们提到了 pysqlite 驱动程序的各种问题，这些问题阻止了
    SQLite 的几个功能正常工作。pysqlite DBAPI 驱动程序有一些长期存在的错误，这些错误影响了其事务行为的正确性。在其默认操作模式下，SQLite
    功能（如 SERIALIZABLE 隔离、事务性 DDL 和 SAVEPOINT 支持）是不起作用的，为了使用这些功能，必须采取一些变通方法。
- en: The issue is essentially that the driver attempts to second-guess the user’s
    intent, failing to start transactions and sometimes ending them prematurely, in
    an effort to minimize the SQLite databases’s file locking behavior, even though
    SQLite itself uses “shared” locks for read-only activities.
  id: totrans-963
  prefs: []
  type: TYPE_NORMAL
  zh: 问题本质上是驱动程序试图猜测用户的意图，未能启动事务，并有时过早结束它们，以尽量减少 SQLite 数据库的文件锁定行为，尽管 SQLite 本身对只读活动使用“共享”锁。
- en: SQLAlchemy chooses to not alter this behavior by default, as it is the long-expected
    behavior of the pysqlite driver; if and when the pysqlite driver attempts to repair
    these issues, that will be more of a driver towards defaults for SQLAlchemy.
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 选择默认情况下不更改此行为，因为这是 pysqlite 驱动程序的长期期望行为；如果 pysqlite 驱动程序尝试修复这些问题，那将更多地驱动
    SQLAlchemy 的默认设置。
- en: 'The good news is that with a few events, we can implement transactional support
    fully, by disabling pysqlite’s feature entirely and emitting BEGIN ourselves.
    This is achieved using two event listeners:'
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，通过几个事件，我们可以完全实现事务支持，方法是完全禁用 pysqlite 的功能，并自行发出 BEGIN。这通过两个事件监听器实现：
- en: '[PRE176]'
  id: totrans-966
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: Warning
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: When using the above recipe, it is advised to not use the [`Connection.execution_options.isolation_level`](../core/connections.html#sqlalchemy.engine.Connection.execution_options.params.isolation_level
    "sqlalchemy.engine.Connection.execution_options") setting on [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") and [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") with the SQLite driver, as this function necessarily
    will also alter the “.isolation_level” setting.
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用上述方法时，建议不要在 SQLite 驱动程序上使用 [`Connection.execution_options.isolation_level`](../core/connections.html#sqlalchemy.engine.Connection.execution_options.params.isolation_level
    "sqlalchemy.engine.Connection.execution_options") 设置以及 [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine")，因为这个函数必然会改变“.isolation_level”设置。
- en: Above, we intercept a new pysqlite connection and disable any transactional
    integration. Then, at the point at which SQLAlchemy knows that transaction scope
    is to begin, we emit `"BEGIN"` ourselves.
  id: totrans-969
  prefs: []
  type: TYPE_NORMAL
  zh: 上面，我们拦截了一个新的 pysqlite 连接，并禁用了任何事务集成。然后，在 SQLAlchemy 知道事务范围即将开始的时候，我们自己发出了 `"BEGIN"`。
- en: 'When we take control of `"BEGIN"`, we can also control directly SQLite’s locking
    modes, introduced at [BEGIN TRANSACTION](https://sqlite.org/lang_transaction.html),
    by adding the desired locking mode to our `"BEGIN"`:'
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们控制 `"BEGIN"` 时，我们也可以直接控制 SQLite 的锁定模式，通过在我们的 `"BEGIN"` 中添加所需的锁定模式来引入 [BEGIN
    TRANSACTION](https://sqlite.org/lang_transaction.html) 中的锁定模式：
- en: '[PRE177]'
  id: totrans-971
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: See also
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[BEGIN TRANSACTION](https://sqlite.org/lang_transaction.html) - on the SQLite
    site'
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
  zh: '[BEGIN TRANSACTION](https://sqlite.org/lang_transaction.html) - SQLite 网站上的内容'
- en: '[sqlite3 SELECT does not BEGIN a transaction](https://bugs.python.org/issue9924)
    - on the Python bug tracker'
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
  zh: '[sqlite3 SELECT does not BEGIN a transaction](https://bugs.python.org/issue9924)
    - Python 缺陷跟踪器上的问题'
- en: '[sqlite3 module breaks transactions and potentially corrupts data](https://bugs.python.org/issue10740)
    - on the Python bug tracker'
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
  zh: '[sqlite3 模块破坏事务并可能损坏数据](https://bugs.python.org/issue10740) - Python 缺陷跟踪器上的问题'
- en: '### User-Defined Functions'
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
  zh: '### 用户定义的函数'
- en: pysqlite supports a [create_function()](https://docs.python.org/3/library/sqlite3.html#sqlite3.Connection.create_function)
    method that allows us to create our own user-defined functions (UDFs) in Python
    and use them directly in SQLite queries. These functions are registered with a
    specific DBAPI Connection.
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
  zh: pysqlite 支持一个 [create_function()](https://docs.python.org/3/library/sqlite3.html#sqlite3.Connection.create_function)
    方法，允许我们在 Python 中创建自己的用户定义函数（UDFs），并直接在 SQLite 查询中使用它们。这些函数与特定的 DBAPI 连接相关联。
- en: 'SQLAlchemy uses connection pooling with file-based SQLite databases, so we
    need to ensure that the UDF is attached to the connection when it is created.
    That is accomplished with an event listener:'
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 在基于文件的 SQLite 数据库中使用连接池，因此我们需要确保在创建连接时将 UDF 附加到连接上。这可以通过事件侦听器完成：
- en: '[PRE178]'
  id: totrans-979
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: '## Aiosqlite'
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
  zh: '## Aiosqlite'
- en: Support for the SQLite database via the aiosqlite driver.
  id: totrans-981
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 aiosqlite 驱动程序支持 SQLite 数据库。
- en: DBAPI
  id: totrans-982
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: DBAPI
- en: 'Documentation and download information (if applicable) for aiosqlite is available
    at: [https://pypi.org/project/aiosqlite/](https://pypi.org/project/aiosqlite/)'
  id: totrans-983
  prefs: []
  type: TYPE_NORMAL
  zh: 'aiosqlite 的文档和下载信息 (如果适用) 可在此处找到: [https://pypi.org/project/aiosqlite/](https://pypi.org/project/aiosqlite/)'
- en: Connecting
  id: totrans-984
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接
- en: 'Connect String:'
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
  zh: '连接字符串:'
- en: '[PRE179]'
  id: totrans-986
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: The aiosqlite dialect provides support for the SQLAlchemy asyncio interface
    running on top of pysqlite.
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
  zh: aiosqlite 方言提供了对在 pysqlite 上运行的 SQLAlchemy asyncio 接口的支持。
- en: aiosqlite is a wrapper around pysqlite that uses a background thread for each
    connection. It does not actually use non-blocking IO, as SQLite databases are
    not socket-based. However it does provide a working asyncio interface that’s useful
    for testing and prototyping purposes.
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
  zh: aiosqlite 是 pysqlite 的一个封装，它为每个连接使用一个后台线程。它实际上不使用非阻塞 IO，因为 SQLite 数据库不是基于套接字的。但是，它提供了一个有效的
    asyncio 接口，对于测试和原型设计非常有用。
- en: Using a special asyncio mediation layer, the aiosqlite dialect is usable as
    the backend for the [SQLAlchemy asyncio](../orm/extensions/asyncio.html) extension
    package.
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
  zh: 使用特殊的 asyncio 中介层，aiosqlite 方言可用作 [SQLAlchemy asyncio](../orm/extensions/asyncio.html)
    扩展包的后端。
- en: 'This dialect should normally be used only with the [`create_async_engine()`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.create_async_engine
    "sqlalchemy.ext.asyncio.create_async_engine") engine creation function:'
  id: totrans-990
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方言通常应该仅与 [`create_async_engine()`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.create_async_engine
    "sqlalchemy.ext.asyncio.create_async_engine") 引擎创建函数一起使用：
- en: '[PRE180]'
  id: totrans-991
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: The URL passes through all arguments to the `pysqlite` driver, so all connection
    arguments are the same as they are for that of [Pysqlite](#pysqlite).
  id: totrans-992
  prefs: []
  type: TYPE_NORMAL
  zh: URL 通过所有参数传递给 `pysqlite` 驱动程序，因此所有连接参数与 [Pysqlite](#pysqlite) 的参数相同。
- en: '### User-Defined Functions'
  id: totrans-993
  prefs: []
  type: TYPE_NORMAL
  zh: '### 用户定义函数'
- en: 'aiosqlite extends pysqlite to support async, so we can create our own user-defined
    functions (UDFs) in Python and use them directly in SQLite queries as described
    here: [User-Defined Functions](#pysqlite-udfs).  ### Serializable isolation /
    Savepoints / Transactional DDL (asyncio version)'
  id: totrans-994
  prefs: []
  type: TYPE_NORMAL
  zh: 'aiosqlite 扩展了 pysqlite 来支持异步，因此我们可以在 Python 中创建自己的用户定义函数 (UDFs)，并直接在 SQLite
    查询中使用它们，如此处所述: [用户定义函数](#pysqlite-udfs)。### 可串行化隔离/保存点/事务DDL (asyncio 版本)'
- en: Similarly to pysqlite, aiosqlite does not support SAVEPOINT feature.
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
  zh: 与 pysqlite 类似，aiosqlite 不支持 SAVEPOINT 功能。
- en: 'The solution is similar to [Serializable isolation / Savepoints / Transactional
    DDL](#pysqlite-serializable). This is achieved by the event listeners in async:'
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案类似于 [可串行化隔离/保存点/事务DDL](#pysqlite-serializable)。这通过 async 中的事件侦听器实现：
- en: '[PRE181]'
  id: totrans-997
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: Warning
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: When using the above recipe, it is advised to not use the [`Connection.execution_options.isolation_level`](../core/connections.html#sqlalchemy.engine.Connection.execution_options.params.isolation_level
    "sqlalchemy.engine.Connection.execution_options") setting on [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") and [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") with the SQLite driver, as this function necessarily
    will also alter the “.isolation_level” setting.
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上述方法时，建议不要在 SQLite 驱动程序上使用 [`Connection.execution_options.isolation_level`](../core/connections.html#sqlalchemy.engine.Connection.execution_options.params.isolation_level
    "sqlalchemy.engine.Connection.execution_options") 设置，以及不要在 [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") 和 [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") 上使用，因为这个函数必然也会改变“isolation_level”设置。
- en: DBAPI
  id: totrans-1000
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: DBAPI
- en: 'Documentation and download information (if applicable) for aiosqlite is available
    at: [https://pypi.org/project/aiosqlite/](https://pypi.org/project/aiosqlite/)'
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
  zh: 'aiosqlite 的文档和下载信息 (如果适用) 可在此处找到: [https://pypi.org/project/aiosqlite/](https://pypi.org/project/aiosqlite/)'
- en: Connecting
  id: totrans-1002
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接
- en: 'Connect String:'
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
  zh: '连接字符串:'
- en: '[PRE182]'
  id: totrans-1004
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: '### User-Defined Functions'
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
  zh: '### 用户定义函数'
- en: 'aiosqlite extends pysqlite to support async, so we can create our own user-defined
    functions (UDFs) in Python and use them directly in SQLite queries as described
    here: [User-Defined Functions](#pysqlite-udfs).'
  id: totrans-1006
  prefs: []
  type: TYPE_NORMAL
  zh: 'aiosqlite 扩展了 pysqlite 来支持异步，因此我们可以在 Python 中创建自己的用户定义函数 (UDFs)，并直接在 SQLite
    查询中使用它们，如此处所述: [用户定义函数](#pysqlite-udfs)。'
- en: '### Serializable isolation / Savepoints / Transactional DDL (asyncio version)'
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
  zh: '### Serializable isolation / Savepoints / Transactional DDL（asyncio 版本）'
- en: Similarly to pysqlite, aiosqlite does not support SAVEPOINT feature.
  id: totrans-1008
  prefs: []
  type: TYPE_NORMAL
  zh: 与 pysqlite 类似，aiosqlite 不支持 SAVEPOINT 功能。
- en: 'The solution is similar to [Serializable isolation / Savepoints / Transactional
    DDL](#pysqlite-serializable). This is achieved by the event listeners in async:'
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案类似于[Serializable isolation / Savepoints / Transactional DDL](#pysqlite-serializable)。这是通过异步事件监听器实现的：
- en: '[PRE183]'
  id: totrans-1010
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: Warning
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: When using the above recipe, it is advised to not use the [`Connection.execution_options.isolation_level`](../core/connections.html#sqlalchemy.engine.Connection.execution_options.params.isolation_level
    "sqlalchemy.engine.Connection.execution_options") setting on [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") and [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") with the SQLite driver, as this function necessarily
    will also alter the “.isolation_level” setting.
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用上述配方时，建议不要在SQLite驱动上使用[`Connection.execution_options.isolation_level`](../core/connections.html#sqlalchemy.engine.Connection.execution_options.params.isolation_level
    "sqlalchemy.engine.Connection.execution_options")设置，并且不要在[`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")和[`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine")中使用，因为这个函数必然会改变“.isolation_level”设置。
- en: '## Pysqlcipher'
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
  zh: '## Pysqlcipher'
- en: Support for the SQLite database via the pysqlcipher driver.
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 pysqlcipher 驱动支持 SQLite 数据库。
- en: Dialect for support of DBAPIs that make use of the [SQLCipher](https://www.zetetic.net/sqlcipher)
    backend.
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
  zh: 支持使用 [SQLCipher](https://www.zetetic.net/sqlcipher) 后端的 DBAPI 的方言。
- en: Connecting
  id: totrans-1016
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接
- en: 'Connect String:'
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
  zh: 连接字符串：
- en: '[PRE184]'
  id: totrans-1018
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: Driver
  id: totrans-1019
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 驱动程序
- en: 'Current dialect selection logic is:'
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的方言选择逻辑是：
- en: If the [`create_engine.module`](../core/engines.html#sqlalchemy.create_engine.params.module
    "sqlalchemy.create_engine") parameter supplies a DBAPI module, that module is
    used.
  id: totrans-1021
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果[`create_engine.module`](../core/engines.html#sqlalchemy.create_engine.params.module
    "sqlalchemy.create_engine")参数提供了一个 DBAPI 模块，则使用该模块。
- en: Otherwise for Python 3, choose [https://pypi.org/project/sqlcipher3/](https://pypi.org/project/sqlcipher3/)
  id: totrans-1022
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则对于 Python 3，选择 [https://pypi.org/project/sqlcipher3/](https://pypi.org/project/sqlcipher3/)
- en: If not available, fall back to [https://pypi.org/project/pysqlcipher3/](https://pypi.org/project/pysqlcipher3/)
  id: totrans-1023
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果不可用，则回退到 [https://pypi.org/project/pysqlcipher3/](https://pypi.org/project/pysqlcipher3/)
- en: For Python 2, [https://pypi.org/project/pysqlcipher/](https://pypi.org/project/pysqlcipher/)
    is used.
  id: totrans-1024
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 Python 2，使用 [https://pypi.org/project/pysqlcipher/](https://pypi.org/project/pysqlcipher/)。
- en: Warning
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: 'The `pysqlcipher3` and `pysqlcipher` DBAPI drivers are no longer maintained;
    the `sqlcipher3` driver as of this writing appears to be current. For future compatibility,
    any pysqlcipher-compatible DBAPI may be used as follows:'
  id: totrans-1026
  prefs: []
  type: TYPE_NORMAL
  zh: '`pysqlcipher3` 和 `pysqlcipher` DBAPI 驱动已不再维护；截至目前为止，`sqlcipher3` 驱动似乎是最新的。为了未来的兼容性，可以使用任何与
    pysqlcipher 兼容的 DBAPI，如下所示：'
- en: '[PRE185]'
  id: totrans-1027
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: These drivers make use of the SQLCipher engine. This system essentially introduces
    new PRAGMA commands to SQLite which allows the setting of a passphrase and other
    encryption parameters, allowing the database file to be encrypted.
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
  zh: 这些驱动程序使用了 SQLCipher 引擎。该系统基本上引入了新的 PRAGMA 命令到 SQLite，这些命令允许设置密码和其他加密参数，从而允许对数据库文件进行加密。
- en: Connect Strings
  id: totrans-1029
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接字符串
- en: 'The format of the connect string is in every way the same as that of the [`pysqlite`](#module-sqlalchemy.dialects.sqlite.pysqlite
    "sqlalchemy.dialects.sqlite.pysqlite") driver, except that the “password” field
    is now accepted, which should contain a passphrase:'
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
  zh: 连接字符串的格式在各方面与[`pysqlite`](#module-sqlalchemy.dialects.sqlite.pysqlite "sqlalchemy.dialects.sqlite.pysqlite")驱动程序完全相同，只是现在接受“password”字段，其中应包含一个密码：
- en: '[PRE186]'
  id: totrans-1031
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: 'For an absolute file path, two leading slashes should be used for the database
    name:'
  id: totrans-1032
  prefs: []
  type: TYPE_NORMAL
  zh: 对于绝对文件路径，数据库名称应使用两个前导斜杠：
- en: '[PRE187]'
  id: totrans-1033
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: 'A selection of additional encryption-related pragmas supported by SQLCipher
    as documented at [https://www.zetetic.net/sqlcipher/sqlcipher-api/](https://www.zetetic.net/sqlcipher/sqlcipher-api/)
    can be passed in the query string, and will result in that PRAGMA being called
    for each new connection. Currently, `cipher`, `kdf_iter` `cipher_page_size` and
    `cipher_use_hmac` are supported:'
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在查询字符串中传递由 SQLCipher 文档记录的一些额外的与加密相关的 PRAGMA，这将导致每个新连接调用该 PRAGMA。目前支持 `cipher`、`kdf_iter`、`cipher_page_size`
    和 `cipher_use_hmac`：
- en: '[PRE188]'
  id: totrans-1035
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: Warning
  id: totrans-1036
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: Previous versions of sqlalchemy did not take into consideration the encryption-related
    pragmas passed in the url string, that were silently ignored. This may cause errors
    when opening files saved by a previous sqlalchemy version if the encryption options
    do not match.
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
  zh: 先前版本的 sqlalchemy 没有考虑到 url 字符串中传递的与加密相关的 pragma，这些 pragma 被静默忽略。如果加密选项不匹配，这可能导致打开先前
    sqlalchemy 版本保存的文件时出错。
- en: Pooling Behavior
  id: totrans-1038
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 池行为
- en: The driver makes a change to the default pool behavior of pysqlite as described
    in [Threading/Pooling Behavior](#pysqlite-threading-pooling). The pysqlcipher
    driver has been observed to be significantly slower on connection than the pysqlite
    driver, most likely due to the encryption overhead, so the dialect here defaults
    to using the [`SingletonThreadPool`](../core/pooling.html#sqlalchemy.pool.SingletonThreadPool
    "sqlalchemy.pool.SingletonThreadPool") implementation, instead of the [`NullPool`](../core/pooling.html#sqlalchemy.pool.NullPool
    "sqlalchemy.pool.NullPool") pool used by pysqlite. As always, the pool implementation
    is entirely configurable using the [`create_engine.poolclass`](../core/engines.html#sqlalchemy.create_engine.params.poolclass
    "sqlalchemy.create_engine") parameter; the `StaticPool` may be more feasible for
    single-threaded use, or [`NullPool`](../core/pooling.html#sqlalchemy.pool.NullPool
    "sqlalchemy.pool.NullPool") may be used to prevent unencrypted connections from
    being held open for long periods of time, at the expense of slower startup time
    for new connections.
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
  zh: 该驱动对 pysqlite 的默认池行为进行了更改，如 [Threading/Pooling Behavior](#pysqlite-threading-pooling)
    所述。观察到 pysqlcipher 驱动在连接方面明显比 pysqlite 驱动慢得多，很可能是由于加密开销，因此此处的方言默认使用 [`SingletonThreadPool`](../core/pooling.html#sqlalchemy.pool.SingletonThreadPool
    "sqlalchemy.pool.SingletonThreadPool") 实现，而不是 pysqlite 使用的 [`NullPool`](../core/pooling.html#sqlalchemy.pool.NullPool
    "sqlalchemy.pool.NullPool") 池。与以往一样，池实现完全可通过 [`create_engine.poolclass`](../core/engines.html#sqlalchemy.create_engine.params.poolclass
    "sqlalchemy.create_engine") 参数进行配置；`StaticPool` 可能更适合单线程使用，或者可以使用 [`NullPool`](../core/pooling.html#sqlalchemy.pool.NullPool
    "sqlalchemy.pool.NullPool") 来防止未加密的连接被保持打开长时间，但新连接的启动时间会变慢。
- en: Connecting
  id: totrans-1040
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接
- en: 'Connect String:'
  id: totrans-1041
  prefs: []
  type: TYPE_NORMAL
  zh: 连接字符串：
- en: '[PRE189]'
  id: totrans-1042
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: Driver
  id: totrans-1043
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 驱动程序
- en: 'Current dialect selection logic is:'
  id: totrans-1044
  prefs: []
  type: TYPE_NORMAL
  zh: 当前方言选择逻辑为：
- en: If the [`create_engine.module`](../core/engines.html#sqlalchemy.create_engine.params.module
    "sqlalchemy.create_engine") parameter supplies a DBAPI module, that module is
    used.
  id: totrans-1045
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 [`create_engine.module`](../core/engines.html#sqlalchemy.create_engine.params.module
    "sqlalchemy.create_engine") 参数提供了一个 DBAPI 模块，则使用该模块。
- en: Otherwise for Python 3, choose [https://pypi.org/project/sqlcipher3/](https://pypi.org/project/sqlcipher3/)
  id: totrans-1046
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则对于 Python 3，选择 [https://pypi.org/project/sqlcipher3/](https://pypi.org/project/sqlcipher3/)
- en: If not available, fall back to [https://pypi.org/project/pysqlcipher3/](https://pypi.org/project/pysqlcipher3/)
  id: totrans-1047
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果不可用，则回退到 [https://pypi.org/project/pysqlcipher3/](https://pypi.org/project/pysqlcipher3/)
- en: For Python 2, [https://pypi.org/project/pysqlcipher/](https://pypi.org/project/pysqlcipher/)
    is used.
  id: totrans-1048
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 Python 2，使用 [https://pypi.org/project/pysqlcipher/](https://pypi.org/project/pysqlcipher/)。
- en: Warning
  id: totrans-1049
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: 'The `pysqlcipher3` and `pysqlcipher` DBAPI drivers are no longer maintained;
    the `sqlcipher3` driver as of this writing appears to be current. For future compatibility,
    any pysqlcipher-compatible DBAPI may be used as follows:'
  id: totrans-1050
  prefs: []
  type: TYPE_NORMAL
  zh: '`pysqlcipher3` 和 `pysqlcipher` DBAPI 驱动已经不再维护；截至目前，`sqlcipher3` 驱动似乎是最新的。为了未来的兼容性，可以使用任何与
    pysqlcipher 兼容的 DBAPI，如下所示：'
- en: '[PRE190]'
  id: totrans-1051
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: These drivers make use of the SQLCipher engine. This system essentially introduces
    new PRAGMA commands to SQLite which allows the setting of a passphrase and other
    encryption parameters, allowing the database file to be encrypted.
  id: totrans-1052
  prefs: []
  type: TYPE_NORMAL
  zh: 这些驱动程序使用了 SQLCipher 引擎。该系统基本上向 SQLite 引入了新的 PRAGMA 命令，允许设置密码短语和其他加密参数，从而使数据库文件被加密。
- en: Connect Strings
  id: totrans-1053
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接字符串
- en: 'The format of the connect string is in every way the same as that of the [`pysqlite`](#module-sqlalchemy.dialects.sqlite.pysqlite
    "sqlalchemy.dialects.sqlite.pysqlite") driver, except that the “password” field
    is now accepted, which should contain a passphrase:'
  id: totrans-1054
  prefs: []
  type: TYPE_NORMAL
  zh: 连接字符串的格式与[`pysqlite`](#module-sqlalchemy.dialects.sqlite.pysqlite "sqlalchemy.dialects.sqlite.pysqlite")驱动完全相同，只是现在接受了“password”字段，其中应该包含一个密码短语：
- en: '[PRE191]'
  id: totrans-1055
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: 'For an absolute file path, two leading slashes should be used for the database
    name:'
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
  zh: 对于绝对文件路径，应该在数据库名称前使用两个斜杠：
- en: '[PRE192]'
  id: totrans-1057
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: 'A selection of additional encryption-related pragmas supported by SQLCipher
    as documented at [https://www.zetetic.net/sqlcipher/sqlcipher-api/](https://www.zetetic.net/sqlcipher/sqlcipher-api/)
    can be passed in the query string, and will result in that PRAGMA being called
    for each new connection. Currently, `cipher`, `kdf_iter` `cipher_page_size` and
    `cipher_use_hmac` are supported:'
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在查询字符串中传递一组额外的与加密相关的 SQLCipher 所支持的 pragma，详见[https://www.zetetic.net/sqlcipher/sqlcipher-api/](https://www.zetetic.net/sqlcipher/sqlcipher-api/)，并且会导致每个新连接调用该
    PRAGMA。目前支持的有：`cipher`、`kdf_iter`、`cipher_page_size` 和 `cipher_use_hmac`。
- en: '[PRE193]'
  id: totrans-1059
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: Warning
  id: totrans-1060
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: Previous versions of sqlalchemy did not take into consideration the encryption-related
    pragmas passed in the url string, that were silently ignored. This may cause errors
    when opening files saved by a previous sqlalchemy version if the encryption options
    do not match.
  id: totrans-1061
  prefs: []
  type: TYPE_NORMAL
  zh: 先前版本的 SQLAlchemy 并未考虑传递在 URL 字符串中的与加密相关的 pragma，这些 pragma 被默默忽略。如果加密选项不匹配，这可能导致在打开之前由先前的
    SQLAlchemy 版本保存的文件时出现错误。
- en: Pooling Behavior
  id: totrans-1062
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 池行为
- en: The driver makes a change to the default pool behavior of pysqlite as described
    in [Threading/Pooling Behavior](#pysqlite-threading-pooling). The pysqlcipher
    driver has been observed to be significantly slower on connection than the pysqlite
    driver, most likely due to the encryption overhead, so the dialect here defaults
    to using the [`SingletonThreadPool`](../core/pooling.html#sqlalchemy.pool.SingletonThreadPool
    "sqlalchemy.pool.SingletonThreadPool") implementation, instead of the [`NullPool`](../core/pooling.html#sqlalchemy.pool.NullPool
    "sqlalchemy.pool.NullPool") pool used by pysqlite. As always, the pool implementation
    is entirely configurable using the [`create_engine.poolclass`](../core/engines.html#sqlalchemy.create_engine.params.poolclass
    "sqlalchemy.create_engine") parameter; the `StaticPool` may be more feasible for
    single-threaded use, or [`NullPool`](../core/pooling.html#sqlalchemy.pool.NullPool
    "sqlalchemy.pool.NullPool") may be used to prevent unencrypted connections from
    being held open for long periods of time, at the expense of slower startup time
    for new connections.
  id: totrans-1063
  prefs: []
  type: TYPE_NORMAL
  zh: 驱动程序对 pysqlite 的默认池行为进行了更改，详见[线程/池行为](#pysqlite-threading-pooling)。观察到 pysqlcipher
    驱动程序在连接时比 pysqlite 驱动程序慢得多，很可能是由于加密开销，因此这里的方言默认使用 [`SingletonThreadPool`](../core/pooling.html#sqlalchemy.pool.SingletonThreadPool
    "sqlalchemy.pool.SingletonThreadPool") 实现，而不是 pysqlite 使用的 [`NullPool`](../core/pooling.html#sqlalchemy.pool.NullPool
    "sqlalchemy.pool.NullPool") 池。与往常一样，池实现完全可配置，使用 [`create_engine.poolclass`](../core/engines.html#sqlalchemy.create_engine.params.poolclass
    "sqlalchemy.create_engine") 参数；`StaticPool` 可能更适合单线程使用，或者 [`NullPool`](../core/pooling.html#sqlalchemy.pool.NullPool
    "sqlalchemy.pool.NullPool") 可以用于防止未加密的连接长时间保持打开，但会牺牲新连接的启动速度。
