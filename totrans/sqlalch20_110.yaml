- en: SQLite
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.sqlalchemy.org/en/20/dialects/sqlite.html](https://docs.sqlalchemy.org/en/20/dialects/sqlite.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Support for the SQLite database.
  prefs: []
  type: TYPE_NORMAL
- en: The following table summarizes current support levels for database release versions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Supported SQLite versions**'
  prefs: []
  type: TYPE_NORMAL
- en: '| Support type | Versions |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| [Fully tested in CI](index.html#term-Fully-tested-in-CI) | 3.36.0 |'
  prefs: []
  type: TYPE_TB
- en: '| [Normal support](index.html#term-Normal-support) | 3.12+ |'
  prefs: []
  type: TYPE_TB
- en: '| [Best effort](index.html#term-Best-effort) | 3.7.16+ |'
  prefs: []
  type: TYPE_TB
- en: DBAPI Support
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following dialect/DBAPI options are available. Please refer to individual
    DBAPI sections for connect information.
  prefs: []
  type: TYPE_NORMAL
- en: '[pysqlite](#module-sqlalchemy.dialects.sqlite.pysqlite)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[aiosqlite](#module-sqlalchemy.dialects.sqlite.aiosqlite)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[pysqlcipher](#module-sqlalchemy.dialects.sqlite.pysqlcipher)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '## Date and Time Types'
  prefs: []
  type: TYPE_NORMAL
- en: SQLite does not have built-in DATE, TIME, or DATETIME types, and pysqlite does
    not provide out of the box functionality for translating values between Python
    datetime objects and a SQLite-supported format. SQLAlchemy’s own [`DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime
    "sqlalchemy.types.DateTime") and related types provide date formatting and parsing
    functionality when SQLite is used. The implementation classes are [`DATETIME`](#sqlalchemy.dialects.sqlite.DATETIME
    "sqlalchemy.dialects.sqlite.DATETIME"), [`DATE`](#sqlalchemy.dialects.sqlite.DATE
    "sqlalchemy.dialects.sqlite.DATE") and [`TIME`](#sqlalchemy.dialects.sqlite.TIME
    "sqlalchemy.dialects.sqlite.TIME"). These types represent dates and times as ISO
    formatted strings, which also nicely support ordering. There’s no reliance on
    typical “libc” internals for these functions so historical dates are fully supported.
  prefs: []
  type: TYPE_NORMAL
- en: Ensuring Text affinity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The DDL rendered for these types is the standard `DATE`, `TIME` and `DATETIME`
    indicators. However, custom storage formats can also be applied to these types.
    When the storage format is detected as containing no alpha characters, the DDL
    for these types is rendered as `DATE_CHAR`, `TIME_CHAR`, and `DATETIME_CHAR`,
    so that the column continues to have textual affinity.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Type Affinity](https://www.sqlite.org/datatype3.html#affinity) - in the SQLite
    documentation  ## SQLite Auto Incrementing Behavior'
  prefs: []
  type: TYPE_NORMAL
- en: 'Background on SQLite’s autoincrement is at: [https://sqlite.org/autoinc.html](https://sqlite.org/autoinc.html)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Key concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: SQLite has an implicit “auto increment” feature that takes place for any non-composite
    primary-key column that is specifically created using “INTEGER PRIMARY KEY” for
    the type + primary key.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SQLite also has an explicit “AUTOINCREMENT” keyword, that is **not** equivalent
    to the implicit autoincrement feature; this keyword is not recommended for general
    use. SQLAlchemy does not render this keyword unless a special SQLite-specific
    directive is used (see below). However, it still requires that the column’s type
    is named “INTEGER”.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the AUTOINCREMENT Keyword
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To specifically render the AUTOINCREMENT keyword on the primary key column
    when rendering DDL, add the flag `sqlite_autoincrement=True` to the Table construct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Allowing autoincrement behavior SQLAlchemy types other than Integer/INTEGER
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: SQLite’s typing model is based on naming conventions. Among other things, this
    means that any type name which contains the substring `"INT"` will be determined
    to be of “integer affinity”. A type named `"BIGINT"`, `"SPECIAL_INT"` or even
    `"XYZINTQPR"`, will be considered by SQLite to be of “integer” affinity. However,
    **the SQLite autoincrement feature, whether implicitly or explicitly enabled,
    requires that the name of the column’s type is exactly the string “INTEGER”**.
    Therefore, if an application uses a type like [`BigInteger`](../core/type_basics.html#sqlalchemy.types.BigInteger
    "sqlalchemy.types.BigInteger") for a primary key, on SQLite this type will need
    to be rendered as the name `"INTEGER"` when emitting the initial `CREATE TABLE`
    statement in order for the autoincrement behavior to be available.
  prefs: []
  type: TYPE_NORMAL
- en: 'One approach to achieve this is to use [`Integer`](../core/type_basics.html#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer") on SQLite only using [`TypeEngine.with_variant()`](../core/type_api.html#sqlalchemy.types.TypeEngine.with_variant
    "sqlalchemy.types.TypeEngine.with_variant"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Another is to use a subclass of [`BigInteger`](../core/type_basics.html#sqlalchemy.types.BigInteger
    "sqlalchemy.types.BigInteger") that overrides its DDL name to be `INTEGER` when
    compiled against SQLite:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`TypeEngine.with_variant()`](../core/type_api.html#sqlalchemy.types.TypeEngine.with_variant
    "sqlalchemy.types.TypeEngine.with_variant")'
  prefs: []
  type: TYPE_NORMAL
- en: '[Custom SQL Constructs and Compilation Extension](../core/compiler.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Datatypes In SQLite Version 3](https://sqlite.org/datatype3.html)  ## Database
    Locking Behavior / Concurrency'
  prefs: []
  type: TYPE_NORMAL
- en: SQLite is not designed for a high level of write concurrency. The database itself,
    being a file, is locked completely during write operations within transactions,
    meaning exactly one “connection” (in reality a file handle) has exclusive access
    to the database during this period - all other “connections” will be blocked during
    this time.
  prefs: []
  type: TYPE_NORMAL
- en: The Python DBAPI specification also calls for a connection model that is always
    in a transaction; there is no `connection.begin()` method, only `connection.commit()`
    and `connection.rollback()`, upon which a new transaction is to be begun immediately.
    This may seem to imply that the SQLite driver would in theory allow only a single
    filehandle on a particular database file at any time; however, there are several
    factors both within SQLite itself as well as within the pysqlite driver which
    loosen this restriction significantly.
  prefs: []
  type: TYPE_NORMAL
- en: However, no matter what locking modes are used, SQLite will still always lock
    the database file once a transaction is started and DML (e.g. INSERT, UPDATE,
    DELETE) has at least been emitted, and this will block other transactions at least
    at the point that they also attempt to emit DML. By default, the length of time
    on this block is very short before it times out with an error.
  prefs: []
  type: TYPE_NORMAL
- en: This behavior becomes more critical when used in conjunction with the SQLAlchemy
    ORM. SQLAlchemy’s [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    object by default runs within a transaction, and with its autoflush model, may
    emit DML preceding any SELECT statement. This may lead to a SQLite database that
    locks more quickly than is expected. The locking mode of SQLite and the pysqlite
    driver can be manipulated to some degree, however it should be noted that achieving
    a high degree of write-concurrency with SQLite is a losing battle.
  prefs: []
  type: TYPE_NORMAL
- en: For more information on SQLite’s lack of write concurrency by design, please
    see [Situations Where Another RDBMS May Work Better - High Concurrency](https://www.sqlite.org/whentouse.html)
    near the bottom of the page.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following subsections introduce areas that are impacted by SQLite’s file-based
    architecture and additionally will usually require workarounds to work when using
    the pysqlite driver.  ## Transaction Isolation Level / Autocommit'
  prefs: []
  type: TYPE_NORMAL
- en: SQLite supports “transaction isolation” in a non-standard way, along two axes.
    One is that of the [PRAGMA read_uncommitted](https://www.sqlite.org/pragma.html#pragma_read_uncommitted)
    instruction. This setting can essentially switch SQLite between its default mode
    of `SERIALIZABLE` isolation, and a “dirty read” isolation mode normally referred
    to as `READ UNCOMMITTED`.
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy ties into this PRAGMA statement using the [`create_engine.isolation_level`](../core/engines.html#sqlalchemy.create_engine.params.isolation_level
    "sqlalchemy.create_engine") parameter of [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine"). Valid values for this parameter when used with SQLite
    are `"SERIALIZABLE"` and `"READ UNCOMMITTED"` corresponding to a value of 0 and
    1, respectively. SQLite defaults to `SERIALIZABLE`, however its behavior is impacted
    by the pysqlite driver’s default behavior.
  prefs: []
  type: TYPE_NORMAL
- en: When using the pysqlite driver, the `"AUTOCOMMIT"` isolation level is also available,
    which will alter the pysqlite connection using the `.isolation_level` attribute
    on the DBAPI connection and set it to None for the duration of the setting.
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 1.3.16: added support for SQLite AUTOCOMMIT isolation level
    when using the pysqlite / sqlite3 SQLite driver.'
  prefs: []
  type: TYPE_NORMAL
- en: The other axis along which SQLite’s transactional locking is impacted is via
    the nature of the `BEGIN` statement used. The three varieties are “deferred”,
    “immediate”, and “exclusive”, as described at [BEGIN TRANSACTION](https://sqlite.org/lang_transaction.html).
    A straight `BEGIN` statement uses the “deferred” mode, where the database file
    is not locked until the first read or write operation, and read access remains
    open to other transactions until the first write operation. But again, it is critical
    to note that the pysqlite driver interferes with this behavior by *not even emitting
    BEGIN* until the first write operation.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: SQLite’s transactional scope is impacted by unresolved issues in the pysqlite
    driver, which defers BEGIN statements to a greater degree than is often feasible.
    See the section [Serializable isolation / Savepoints / Transactional DDL](#pysqlite-serializable)
    or [Serializable isolation / Savepoints / Transactional DDL (asyncio version)](#aiosqlite-serializable)
    for techniques to work around this behavior.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Setting Transaction Isolation Levels including DBAPI Autocommit](../core/connections.html#dbapi-autocommit)'
  prefs: []
  type: TYPE_NORMAL
- en: INSERT/UPDATE/DELETE…RETURNING
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The SQLite dialect supports SQLite 3.35’s `INSERT|UPDATE|DELETE..RETURNING`
    syntax. `INSERT..RETURNING` may be used automatically in some cases in order to
    fetch newly generated identifiers in place of the traditional approach of using
    `cursor.lastrowid`, however `cursor.lastrowid` is currently still preferred for
    simple single-statement cases for its better performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'To specify an explicit `RETURNING` clause, use the `_UpdateBase.returning()`
    method on a per-statement basis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'New in version 2.0: Added support for SQLite RETURNING'
  prefs: []
  type: TYPE_NORMAL
- en: SAVEPOINT Support
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SQLite supports SAVEPOINTs, which only function once a transaction is begun.
    SQLAlchemy’s SAVEPOINT support is available using the [`Connection.begin_nested()`](../core/connections.html#sqlalchemy.engine.Connection.begin_nested
    "sqlalchemy.engine.Connection.begin_nested") method at the Core level, and [`Session.begin_nested()`](../orm/session_api.html#sqlalchemy.orm.Session.begin_nested
    "sqlalchemy.orm.Session.begin_nested") at the ORM level. However, SAVEPOINTs won’t
    work at all with pysqlite unless workarounds are taken.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: SQLite’s SAVEPOINT feature is impacted by unresolved issues in the pysqlite
    and aiosqlite drivers, which defer BEGIN statements to a greater degree than is
    often feasible. See the sections [Serializable isolation / Savepoints / Transactional
    DDL](#pysqlite-serializable) and [Serializable isolation / Savepoints / Transactional
    DDL (asyncio version)](#aiosqlite-serializable) for techniques to work around
    this behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Transactional DDL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The SQLite database supports transactional [DDL](../glossary.html#term-DDL)
    as well. In this case, the pysqlite driver is not only failing to start transactions,
    it also is ending any existing transaction when DDL is detected, so again, workarounds
    are required.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: SQLite’s transactional DDL is impacted by unresolved issues in the pysqlite
    driver, which fails to emit BEGIN and additionally forces a COMMIT to cancel any
    transaction when DDL is encountered. See the section [Serializable isolation /
    Savepoints / Transactional DDL](#pysqlite-serializable) for techniques to work
    around this behavior.
  prefs: []
  type: TYPE_NORMAL
- en: '## Foreign Key Support'
  prefs: []
  type: TYPE_NORMAL
- en: SQLite supports FOREIGN KEY syntax when emitting CREATE statements for tables,
    however by default these constraints have no effect on the operation of the table.
  prefs: []
  type: TYPE_NORMAL
- en: 'Constraint checking on SQLite has three prerequisites:'
  prefs: []
  type: TYPE_NORMAL
- en: At least version 3.6.19 of SQLite must be in use
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The SQLite library must be compiled *without* the SQLITE_OMIT_FOREIGN_KEY or
    SQLITE_OMIT_TRIGGER symbols enabled.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `PRAGMA foreign_keys = ON` statement must be emitted on all connections
    before use – including the initial call to [`MetaData.create_all()`](../core/metadata.html#sqlalchemy.schema.MetaData.create_all
    "sqlalchemy.schema.MetaData.create_all").
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'SQLAlchemy allows for the `PRAGMA` statement to be emitted automatically for
    new connections through the usage of events:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: When SQLite foreign keys are enabled, it is **not possible** to emit CREATE
    or DROP statements for tables that contain mutually-dependent foreign key constraints;
    to emit the DDL for these tables requires that ALTER TABLE be used to create or
    drop these constraints separately, for which SQLite has no support.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[SQLite Foreign Key Support](https://www.sqlite.org/foreignkeys.html) - on
    the SQLite web site.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Events](../core/event.html) - SQLAlchemy event API.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Creating/Dropping Foreign Key Constraints via ALTER](../core/constraints.html#use-alter)
    - more information on SQLAlchemy’s facilities for handling'
  prefs: []
  type: TYPE_NORMAL
- en: 'mutually-dependent foreign key constraints.  ## ON CONFLICT support for constraints'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: This section describes the [DDL](../glossary.html#term-DDL) version of “ON CONFLICT”
    for SQLite, which occurs within a CREATE TABLE statement. For “ON CONFLICT” as
    applied to an INSERT statement, see [INSERT…ON CONFLICT (Upsert)](#sqlite-on-conflict-insert).
  prefs: []
  type: TYPE_NORMAL
- en: SQLite supports a non-standard DDL clause known as ON CONFLICT which can be
    applied to primary key, unique, check, and not null constraints. In DDL, it is
    rendered either within the “CONSTRAINT” clause or within the column definition
    itself depending on the location of the target constraint. To render this clause
    within DDL, the extension parameter `sqlite_on_conflict` can be specified with
    a string conflict resolution algorithm within the [`PrimaryKeyConstraint`](../core/constraints.html#sqlalchemy.schema.PrimaryKeyConstraint
    "sqlalchemy.schema.PrimaryKeyConstraint"), [`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint"), [`CheckConstraint`](../core/constraints.html#sqlalchemy.schema.CheckConstraint
    "sqlalchemy.schema.CheckConstraint") objects. Within the [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") object, there are individual parameters `sqlite_on_conflict_not_null`,
    `sqlite_on_conflict_primary_key`, `sqlite_on_conflict_unique` which each correspond
    to the three types of relevant constraint types that can be indicated from a [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") object.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[ON CONFLICT](https://www.sqlite.org/lang_conflict.html) - in the SQLite documentation'
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.3.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `sqlite_on_conflict` parameters accept a string argument which is just
    the resolution name to be chosen, which on SQLite can be one of ROLLBACK, ABORT,
    FAIL, IGNORE, and REPLACE. For example, to add a UNIQUE constraint that specifies
    the IGNORE algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The above renders CREATE TABLE DDL as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'When using the [`Column.unique`](../core/metadata.html#sqlalchemy.schema.Column.params.unique
    "sqlalchemy.schema.Column") flag to add a UNIQUE constraint to a single column,
    the `sqlite_on_conflict_unique` parameter can be added to the [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") as well, which will be added to the UNIQUE constraint
    in the DDL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'rendering:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'To apply the FAIL algorithm for a NOT NULL constraint, `sqlite_on_conflict_not_null`
    is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'this renders the column inline ON CONFLICT phrase:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, for an inline primary key, use `sqlite_on_conflict_primary_key`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'SQLAlchemy renders the PRIMARY KEY constraint separately, so the conflict resolution
    algorithm is applied to the constraint itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]  ## INSERT…ON CONFLICT (Upsert)'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: This section describes the [DML](../glossary.html#term-DML) version of “ON CONFLICT”
    for SQLite, which occurs within an INSERT statement. For “ON CONFLICT” as applied
    to a CREATE TABLE statement, see [ON CONFLICT support for constraints](#sqlite-on-conflict-ddl).
  prefs: []
  type: TYPE_NORMAL
- en: From version 3.24.0 onwards, SQLite supports “upserts” (update or insert) of
    rows into a table via the `ON CONFLICT` clause of the `INSERT` statement. A candidate
    row will only be inserted if that row does not violate any unique or primary key
    constraints. In the case of a unique constraint violation, a secondary action
    can occur which can be either “DO UPDATE”, indicating that the data in the target
    row should be updated, or “DO NOTHING”, which indicates to silently skip this
    row.
  prefs: []
  type: TYPE_NORMAL
- en: Conflicts are determined using columns that are part of existing unique constraints
    and indexes. These constraints are identified by stating the columns and conditions
    that comprise the indexes.
  prefs: []
  type: TYPE_NORMAL
- en: 'SQLAlchemy provides `ON CONFLICT` support via the SQLite-specific [`insert()`](#sqlalchemy.dialects.sqlite.insert
    "sqlalchemy.dialects.sqlite.insert") function, which provides the generative methods
    [`Insert.on_conflict_do_update()`](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update
    "sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update") and [`Insert.on_conflict_do_nothing()`](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_nothing
    "sqlalchemy.dialects.sqlite.Insert.on_conflict_do_nothing"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: New in version 1.4.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Upsert](https://sqlite.org/lang_UPSERT.html) - in the SQLite documentation.'
  prefs: []
  type: TYPE_NORMAL
- en: Specifying the Target
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Both methods supply the “target” of the conflict using column inference:'
  prefs: []
  type: TYPE_NORMAL
- en: The [`Insert.on_conflict_do_update.index_elements`](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update.params.index_elements
    "sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update") argument specifies
    a sequence containing string column names, [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects, and/or SQL expression elements, which would
    identify a unique index or unique constraint.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When using [`Insert.on_conflict_do_update.index_elements`](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update.params.index_elements
    "sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update") to infer an index,
    a partial index can be inferred by also specifying the [`Insert.on_conflict_do_update.index_where`](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update.params.index_where
    "sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update") parameter:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The SET Clause
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`ON CONFLICT...DO UPDATE` is used to perform an update of the already existing
    row, using any combination of new values as well as values from the proposed insertion.
    These values are specified using the [`Insert.on_conflict_do_update.set_`](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update.params.set_
    "sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update") parameter. This parameter
    accepts a dictionary which consists of direct values for UPDATE:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: The [`Insert.on_conflict_do_update()`](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update
    "sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update") method does **not**
    take into account Python-side default UPDATE values or generation functions, e.g.
    those specified using [`Column.onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.onupdate
    "sqlalchemy.schema.Column"). These values will not be exercised for an ON CONFLICT
    style of UPDATE, unless they are manually specified in the [`Insert.on_conflict_do_update.set_`](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update.params.set_
    "sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update") dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: Updating using the Excluded INSERT Values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In order to refer to the proposed insertion row, the special alias [`Insert.excluded`](#sqlalchemy.dialects.sqlite.Insert.excluded
    "sqlalchemy.dialects.sqlite.Insert.excluded") is available as an attribute on
    the [`Insert`](#sqlalchemy.dialects.sqlite.Insert "sqlalchemy.dialects.sqlite.Insert")
    object; this object creates an “excluded.” prefix on a column, that informs the
    DO UPDATE to update the row with the value that would have been inserted had the
    constraint not failed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Additional WHERE Criteria
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The [`Insert.on_conflict_do_update()`](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update
    "sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update") method also accepts
    a WHERE clause using the [`Insert.on_conflict_do_update.where`](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update.params.where
    "sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update") parameter, which will
    limit those rows which receive an UPDATE:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Skipping Rows with DO NOTHING
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`ON CONFLICT` may be used to skip inserting a row entirely if any conflict
    with a unique constraint occurs; below this is illustrated using the [`Insert.on_conflict_do_nothing()`](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_nothing
    "sqlalchemy.dialects.sqlite.Insert.on_conflict_do_nothing") method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'If `DO NOTHING` is used without specifying any columns or constraint, it has
    the effect of skipping the INSERT for any unique violation which occurs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]  ## Type Reflection'
  prefs: []
  type: TYPE_NORMAL
- en: SQLite types are unlike those of most other database backends, in that the string
    name of the type usually does not correspond to a “type” in a one-to-one fashion.
    Instead, SQLite links per-column typing behavior to one of five so-called “type
    affinities” based on a string matching pattern for the type.
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy’s reflection process, when inspecting types, uses a simple lookup
    table to link the keywords returned to provided SQLAlchemy types. This lookup
    table is present within the SQLite dialect as it is for all other dialects. However,
    the SQLite dialect has a different “fallback” routine for when a particular type
    name is not located in the lookup map; it instead implements the SQLite “type
    affinity” scheme located at [https://www.sqlite.org/datatype3.html](https://www.sqlite.org/datatype3.html)
    section 2.1.
  prefs: []
  type: TYPE_NORMAL
- en: 'The provided typemap will make direct associations from an exact string name
    match for the following types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`BIGINT`](../core/type_basics.html#sqlalchemy.types.BIGINT "sqlalchemy.types.BIGINT"),
    [`BLOB`](../core/type_basics.html#sqlalchemy.types.BLOB "sqlalchemy.types.BLOB"),
    [`BOOLEAN`](../core/type_basics.html#sqlalchemy.types.BOOLEAN "sqlalchemy.types.BOOLEAN"),
    [`BOOLEAN`](../core/type_basics.html#sqlalchemy.types.BOOLEAN "sqlalchemy.types.BOOLEAN"),
    [`CHAR`](../core/type_basics.html#sqlalchemy.types.CHAR "sqlalchemy.types.CHAR"),
    [`DATE`](../core/type_basics.html#sqlalchemy.types.DATE "sqlalchemy.types.DATE"),
    [`DATETIME`](../core/type_basics.html#sqlalchemy.types.DATETIME "sqlalchemy.types.DATETIME"),
    [`FLOAT`](../core/type_basics.html#sqlalchemy.types.FLOAT "sqlalchemy.types.FLOAT"),
    [`DECIMAL`](../core/type_basics.html#sqlalchemy.types.DECIMAL "sqlalchemy.types.DECIMAL"),
    [`FLOAT`](../core/type_basics.html#sqlalchemy.types.FLOAT "sqlalchemy.types.FLOAT"),
    [`INTEGER`](../core/type_basics.html#sqlalchemy.types.INTEGER "sqlalchemy.types.INTEGER"),
    [`INTEGER`](../core/type_basics.html#sqlalchemy.types.INTEGER "sqlalchemy.types.INTEGER"),
    [`NUMERIC`](../core/type_basics.html#sqlalchemy.types.NUMERIC "sqlalchemy.types.NUMERIC"),
    [`REAL`](../core/type_basics.html#sqlalchemy.types.REAL "sqlalchemy.types.REAL"),
    [`SMALLINT`](../core/type_basics.html#sqlalchemy.types.SMALLINT "sqlalchemy.types.SMALLINT"),
    [`TEXT`](../core/type_basics.html#sqlalchemy.types.TEXT "sqlalchemy.types.TEXT"),
    [`TIME`](../core/type_basics.html#sqlalchemy.types.TIME "sqlalchemy.types.TIME"),
    [`TIMESTAMP`](../core/type_basics.html#sqlalchemy.types.TIMESTAMP "sqlalchemy.types.TIMESTAMP"),
    [`VARCHAR`](../core/type_basics.html#sqlalchemy.types.VARCHAR "sqlalchemy.types.VARCHAR"),
    [`NVARCHAR`](../core/type_basics.html#sqlalchemy.types.NVARCHAR "sqlalchemy.types.NVARCHAR"),
    [`NCHAR`](../core/type_basics.html#sqlalchemy.types.NCHAR "sqlalchemy.types.NCHAR")'
  prefs: []
  type: TYPE_NORMAL
- en: 'When a type name does not match one of the above types, the “type affinity”
    lookup is used instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`INTEGER`](../core/type_basics.html#sqlalchemy.types.INTEGER "sqlalchemy.types.INTEGER")
    is returned if the type name includes the string `INT`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`TEXT`](../core/type_basics.html#sqlalchemy.types.TEXT "sqlalchemy.types.TEXT")
    is returned if the type name includes the string `CHAR`, `CLOB` or `TEXT`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`NullType`](../core/type_api.html#sqlalchemy.types.NullType "sqlalchemy.types.NullType")
    is returned if the type name includes the string `BLOB`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`REAL`](../core/type_basics.html#sqlalchemy.types.REAL "sqlalchemy.types.REAL")
    is returned if the type name includes the string `REAL`, `FLOA` or `DOUB`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Otherwise, the [`NUMERIC`](../core/type_basics.html#sqlalchemy.types.NUMERIC
    "sqlalchemy.types.NUMERIC") type is used.  ## Partial Indexes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A partial index, e.g. one which uses a WHERE clause, can be specified with
    the DDL system using the argument `sqlite_where`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The index will be rendered at create time as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]  ## Dotted Column Names'
  prefs: []
  type: TYPE_NORMAL
- en: Using table or column names that explicitly have periods in them is **not recommended**.
    While this is generally a bad idea for relational databases in general, as the
    dot is a syntactically significant character, the SQLite driver up until version
    **3.10.0** of SQLite has a bug which requires that SQLAlchemy filter out these
    dots in result sets.
  prefs: []
  type: TYPE_NORMAL
- en: 'The bug, entirely outside of SQLAlchemy, can be illustrated thusly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The second assertion fails:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Where above, the driver incorrectly reports the names of the columns including
    the name of the table, which is entirely inconsistent vs. when the UNION is not
    present.
  prefs: []
  type: TYPE_NORMAL
- en: 'SQLAlchemy relies upon column names being predictable in how they match to
    the original statement, so the SQLAlchemy dialect has no choice but to filter
    these out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that above, even though SQLAlchemy filters out the dots, *both names are
    still addressable*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Therefore, the workaround applied by SQLAlchemy only impacts [`CursorResult.keys()`](../core/connections.html#sqlalchemy.engine.CursorResult.keys
    "sqlalchemy.engine.CursorResult.keys") and `Row.keys()` in the public API. In
    the very specific case where an application is forced to use column names that
    contain dots, and the functionality of [`CursorResult.keys()`](../core/connections.html#sqlalchemy.engine.CursorResult.keys
    "sqlalchemy.engine.CursorResult.keys") and `Row.keys()` is required to return
    these dotted names unmodified, the `sqlite_raw_colnames` execution option may
    be provided, either on a per-[`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") basis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'or on a per-[`Engine`](../core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    basis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: When using the per-[`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") execution option, note that **Core and ORM queries
    that use UNION may not function properly**.
  prefs: []
  type: TYPE_NORMAL
- en: SQLite-specific table options
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One option for CREATE TABLE is supported directly by the SQLite dialect in
    conjunction with the [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    construct:'
  prefs: []
  type: TYPE_NORMAL
- en: '`WITHOUT ROWID`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[SQLite CREATE TABLE options](https://www.sqlite.org/lang_createtable.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '## Reflecting internal schema tables'
  prefs: []
  type: TYPE_NORMAL
- en: Reflection methods that return lists of tables will omit so-called “SQLite internal
    schema object” names, which are considered by SQLite as any object name that is
    prefixed with `sqlite_`. An example of such an object is the `sqlite_sequence`
    table that’s generated when the `AUTOINCREMENT` column parameter is used. In order
    to return these objects, the parameter `sqlite_include_internal=True` may be passed
    to methods such as [`MetaData.reflect()`](../core/metadata.html#sqlalchemy.schema.MetaData.reflect
    "sqlalchemy.schema.MetaData.reflect") or [`Inspector.get_table_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_table_names
    "sqlalchemy.engine.reflection.Inspector.get_table_names").
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 2.0: Added the `sqlite_include_internal=True` parameter. Previously,
    these tables were not ignored by SQLAlchemy reflection methods.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The `sqlite_include_internal` parameter does not refer to the “system” tables
    that are present in schemas such as `sqlite_master`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[SQLite Internal Schema Objects](https://www.sqlite.org/fileformat2.html#intschema)
    - in the SQLite documentation.'
  prefs: []
  type: TYPE_NORMAL
- en: SQLite Data Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As with all SQLAlchemy dialects, all UPPERCASE types that are known to be valid
    with SQLite are importable from the top level dialect, whether they originate
    from [`sqlalchemy.types`](../core/type_basics.html#module-sqlalchemy.types "sqlalchemy.types")
    or from the local dialect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '| Object Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| [DATE](#sqlalchemy.dialects.sqlite.DATE) | Represent a Python date object
    in SQLite using a string. |'
  prefs: []
  type: TYPE_TB
- en: '| [DATETIME](#sqlalchemy.dialects.sqlite.DATETIME) | Represent a Python datetime
    object in SQLite using a string. |'
  prefs: []
  type: TYPE_TB
- en: '| [JSON](#sqlalchemy.dialects.sqlite.JSON) | SQLite JSON type. |'
  prefs: []
  type: TYPE_TB
- en: '| [TIME](#sqlalchemy.dialects.sqlite.TIME) | Represent a Python time object
    in SQLite using a string. |'
  prefs: []
  type: TYPE_TB
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Represent a Python datetime object in SQLite using a string.
  prefs: []
  type: TYPE_NORMAL
- en: 'The default string storage format is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The incoming storage format is by default parsed using the Python `datetime.fromisoformat()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 2.0: `datetime.fromisoformat()` is used for default datetime
    string parsing.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The storage format can be customized to some degree using the `storage_format`
    and `regexp` parameters, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`storage_format` – format string which will be applied to the dict with keys
    year, month, day, hour, minute, second, and microsecond.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`regexp` – regular expression which will be applied to incoming result rows,
    replacing the use of `datetime.fromisoformat()` to parse incoming strings. If
    the regexp contains named groups, the resulting match dict is applied to the Python
    datetime() constructor as keyword arguments. Otherwise, if positional groups are
    used, the datetime() constructor is called with positional arguments via `*map(int,
    match_obj.groups(0))`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.sqlite.DATETIME`](#sqlalchemy.dialects.sqlite.DATETIME
    "sqlalchemy.dialects.sqlite.DATETIME") (`sqlalchemy.dialects.sqlite.base._DateTimeMixin`,
    [`sqlalchemy.types.DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime
    "sqlalchemy.types.DateTime"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Represent a Python date object in SQLite using a string.
  prefs: []
  type: TYPE_NORMAL
- en: 'The default string storage format is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The incoming storage format is by default parsed using the Python `date.fromisoformat()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 2.0: `date.fromisoformat()` is used for default date string
    parsing.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The storage format can be customized to some degree using the `storage_format`
    and `regexp` parameters, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`storage_format` – format string which will be applied to the dict with keys
    year, month, and day.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`regexp` – regular expression which will be applied to incoming result rows,
    replacing the use of `date.fromisoformat()` to parse incoming strings. If the
    regexp contains named groups, the resulting match dict is applied to the Python
    date() constructor as keyword arguments. Otherwise, if positional groups are used,
    the date() constructor is called with positional arguments via `*map(int, match_obj.groups(0))`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.sqlite.DATE`](#sqlalchemy.dialects.sqlite.DATE "sqlalchemy.dialects.sqlite.DATE")
    (`sqlalchemy.dialects.sqlite.base._DateTimeMixin`, [`sqlalchemy.types.Date`](../core/type_basics.html#sqlalchemy.types.Date
    "sqlalchemy.types.Date"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: SQLite JSON type.
  prefs: []
  type: TYPE_NORMAL
- en: SQLite supports JSON as of version 3.9 through its [JSON1](https://www.sqlite.org/json1.html)
    extension. Note that [JSON1](https://www.sqlite.org/json1.html) is a [loadable
    extension](https://www.sqlite.org/loadext.html) and as such may not be available,
    or may require run-time loading.
  prefs: []
  type: TYPE_NORMAL
- en: '[`JSON`](#sqlalchemy.dialects.sqlite.JSON "sqlalchemy.dialects.sqlite.JSON")
    is used automatically whenever the base [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON") datatype is used against a SQLite backend.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON")
    - main documentation for the generic cross-platform JSON datatype.'
  prefs: []
  type: TYPE_NORMAL
- en: The [`JSON`](#sqlalchemy.dialects.sqlite.JSON "sqlalchemy.dialects.sqlite.JSON")
    type supports persistence of JSON values as well as the core index operations
    provided by [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON")
    datatype, by adapting the operations to render the `JSON_EXTRACT` function wrapped
    in the `JSON_QUOTE` function at the database level. Extracted values are quoted
    in order to ensure that the results are always JSON string values.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.3.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.dialects.sqlite.JSON.__init__)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.sqlite.JSON`](#sqlalchemy.dialects.sqlite.JSON "sqlalchemy.dialects.sqlite.JSON")
    ([`sqlalchemy.types.JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `sqlalchemy.types.JSON.__init__` *method of* [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON")'
  prefs: []
  type: TYPE_NORMAL
- en: Construct a [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON")
    type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**none_as_null=False** –'
  prefs: []
  type: TYPE_NORMAL
- en: 'if True, persist the value `None` as a SQL NULL value, not the JSON encoding
    of `null`. Note that when this flag is False, the [`null()`](../core/sqlelement.html#sqlalchemy.sql.expression.null
    "sqlalchemy.sql.expression.null") construct can still be used to persist a NULL
    value, which may be passed directly as a parameter value that is specially interpreted
    by the [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON")
    type as SQL NULL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '[`JSON.none_as_null`](../core/type_basics.html#sqlalchemy.types.JSON.params.none_as_null
    "sqlalchemy.types.JSON") does **not** apply to the values passed to [`Column.default`](../core/metadata.html#sqlalchemy.schema.Column.params.default
    "sqlalchemy.schema.Column") and [`Column.server_default`](../core/metadata.html#sqlalchemy.schema.Column.params.server_default
    "sqlalchemy.schema.Column"); a value of `None` passed for these parameters means
    “no default present”.'
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, when used in SQL comparison expressions, the Python value `None`
    continues to refer to SQL null, and not JSON NULL. The [`JSON.none_as_null`](../core/type_basics.html#sqlalchemy.types.JSON.params.none_as_null
    "sqlalchemy.types.JSON") flag refers explicitly to the **persistence** of the
    value within an INSERT or UPDATE statement. The [`JSON.NULL`](../core/type_basics.html#sqlalchemy.types.JSON.NULL
    "sqlalchemy.types.JSON.NULL") value should be used for SQL expressions that wish
    to compare to JSON null.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`JSON.NULL`](../core/type_basics.html#sqlalchemy.types.JSON.NULL "sqlalchemy.types.JSON.NULL")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Represent a Python time object in SQLite using a string.
  prefs: []
  type: TYPE_NORMAL
- en: 'The default string storage format is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The incoming storage format is by default parsed using the Python `time.fromisoformat()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 2.0: `time.fromisoformat()` is used for default time string
    parsing.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The storage format can be customized to some degree using the `storage_format`
    and `regexp` parameters, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`storage_format` – format string which will be applied to the dict with keys
    hour, minute, second, and microsecond.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`regexp` – regular expression which will be applied to incoming result rows,
    replacing the use of `datetime.fromisoformat()` to parse incoming strings. If
    the regexp contains named groups, the resulting match dict is applied to the Python
    time() constructor as keyword arguments. Otherwise, if positional groups are used,
    the time() constructor is called with positional arguments via `*map(int, match_obj.groups(0))`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.sqlite.TIME`](#sqlalchemy.dialects.sqlite.TIME "sqlalchemy.dialects.sqlite.TIME")
    (`sqlalchemy.dialects.sqlite.base._DateTimeMixin`, [`sqlalchemy.types.Time`](../core/type_basics.html#sqlalchemy.types.Time
    "sqlalchemy.types.Time"))
  prefs: []
  type: TYPE_NORMAL
- en: SQLite DML Constructs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '| Object Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| [insert](#sqlalchemy.dialects.sqlite.insert)(table) | Construct a sqlite-specific
    variant [`Insert`](#sqlalchemy.dialects.sqlite.Insert "sqlalchemy.dialects.sqlite.Insert")
    construct. |'
  prefs: []
  type: TYPE_TB
- en: '| [Insert](#sqlalchemy.dialects.sqlite.Insert) | SQLite-specific implementation
    of INSERT. |'
  prefs: []
  type: TYPE_TB
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Construct a sqlite-specific variant [`Insert`](#sqlalchemy.dialects.sqlite.Insert
    "sqlalchemy.dialects.sqlite.Insert") construct.
  prefs: []
  type: TYPE_NORMAL
- en: The [`sqlalchemy.dialects.sqlite.insert()`](#sqlalchemy.dialects.sqlite.insert
    "sqlalchemy.dialects.sqlite.insert") function creates a [`sqlalchemy.dialects.sqlite.Insert`](#sqlalchemy.dialects.sqlite.Insert
    "sqlalchemy.dialects.sqlite.Insert"). This class is based on the dialect-agnostic
    [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert "sqlalchemy.sql.expression.Insert")
    construct which may be constructed using the [`insert()`](../core/dml.html#sqlalchemy.sql.expression.insert
    "sqlalchemy.sql.expression.insert") function in SQLAlchemy Core.
  prefs: []
  type: TYPE_NORMAL
- en: The [`Insert`](#sqlalchemy.dialects.sqlite.Insert "sqlalchemy.dialects.sqlite.Insert")
    construct includes additional methods [`Insert.on_conflict_do_update()`](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update
    "sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update"), [`Insert.on_conflict_do_nothing()`](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_nothing
    "sqlalchemy.dialects.sqlite.Insert.on_conflict_do_nothing").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: SQLite-specific implementation of INSERT.
  prefs: []
  type: TYPE_NORMAL
- en: Adds methods for SQLite-specific syntaxes such as ON CONFLICT.
  prefs: []
  type: TYPE_NORMAL
- en: The [`Insert`](#sqlalchemy.dialects.sqlite.Insert "sqlalchemy.dialects.sqlite.Insert")
    object is created using the [`sqlalchemy.dialects.sqlite.insert()`](#sqlalchemy.dialects.sqlite.insert
    "sqlalchemy.dialects.sqlite.insert") function.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.4.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[INSERT…ON CONFLICT (Upsert)](#sqlite-on-conflict-insert)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[excluded](#sqlalchemy.dialects.sqlite.Insert.excluded), [inherit_cache](#sqlalchemy.dialects.sqlite.Insert.inherit_cache),
    [on_conflict_do_nothing()](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_nothing),
    [on_conflict_do_update()](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.sqlite.Insert`](#sqlalchemy.dialects.sqlite.Insert
    "sqlalchemy.dialects.sqlite.Insert") ([`sqlalchemy.sql.expression.Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Provide the `excluded` namespace for an ON CONFLICT statement
  prefs: []
  type: TYPE_NORMAL
- en: SQLite’s ON CONFLICT clause allows reference to the row that would be inserted,
    known as `excluded`. This attribute provides all columns in this row to be referenceable.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: The [`Insert.excluded`](#sqlalchemy.dialects.sqlite.Insert.excluded "sqlalchemy.dialects.sqlite.Insert.excluded")
    attribute is an instance of [`ColumnCollection`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnCollection
    "sqlalchemy.sql.expression.ColumnCollection"), which provides an interface the
    same as that of the [`Table.c`](../core/metadata.html#sqlalchemy.schema.Table.c
    "sqlalchemy.schema.Table.c") collection described at [Accessing Tables and Columns](../core/metadata.html#metadata-tables-and-columns).
    With this collection, ordinary names are accessible like attributes (e.g. `stmt.excluded.some_column`),
    but special names and dictionary method names should be accessed using indexed
    access, such as `stmt.excluded["column name"]` or `stmt.excluded["values"]`. See
    the docstring for [`ColumnCollection`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnCollection
    "sqlalchemy.sql.expression.ColumnCollection") for further examples.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Indicate if this [`HasCacheKey`](../core/foundation.html#sqlalchemy.sql.traversals.HasCacheKey
    "sqlalchemy.sql.traversals.HasCacheKey") instance should make use of the cache
    key generation scheme used by its immediate superclass.
  prefs: []
  type: TYPE_NORMAL
- en: The attribute defaults to `None`, which indicates that a construct has not yet
    taken into account whether or not its appropriate for it to participate in caching;
    this is functionally equivalent to setting the value to `False`, except that a
    warning is also emitted.
  prefs: []
  type: TYPE_NORMAL
- en: This flag can be set to `True` on a particular class, if the SQL that corresponds
    to the object does not change based on attributes which are local to this class,
    and not its superclass.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Enabling Caching Support for Custom Constructs](../core/compiler.html#compilerext-caching)
    - General guideslines for setting the [`HasCacheKey.inherit_cache`](../core/foundation.html#sqlalchemy.sql.traversals.HasCacheKey.inherit_cache
    "sqlalchemy.sql.traversals.HasCacheKey.inherit_cache") attribute for third-party
    or user defined SQL constructs.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Specifies a DO NOTHING action for ON CONFLICT clause.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`index_elements` – A sequence consisting of string column names, [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects, or other column expression objects that will
    be used to infer a target index or unique constraint.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`index_where` – Additional WHERE criterion that can be used to infer a conditional
    target index.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Specifies a DO UPDATE SET action for ON CONFLICT clause.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`index_elements` – A sequence consisting of string column names, [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects, or other column expression objects that will
    be used to infer a target index or unique constraint.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`index_where` – Additional WHERE criterion that can be used to infer a conditional
    target index.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`set_` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A dictionary or other mapping object where the keys are either names of columns
    in the target table, or [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects or other ORM-mapped columns matching that
    of the target table, and expressions or literals as values, specifying the `SET`
    actions to take.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'New in version 1.4: The [`Insert.on_conflict_do_update.set_`](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update.params.set_
    "sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update") parameter supports
    [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    objects from the target [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") as keys.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This dictionary does **not** take into account Python-specified default UPDATE
    values or generation functions, e.g. those specified using [`Column.onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.onupdate
    "sqlalchemy.schema.Column"). These values will not be exercised for an ON CONFLICT
    style of UPDATE, unless they are manually specified in the [`Insert.on_conflict_do_update.set_`](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update.params.set_
    "sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update") dictionary.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`where` – Optional argument. If present, can be a literal SQL string or an
    acceptable expression for a `WHERE` clause that restricts the rows affected by
    `DO UPDATE SET`. Rows not meeting the `WHERE` condition will not be updated (effectively
    a `DO NOTHING` for those rows).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '## Pysqlite'
  prefs: []
  type: TYPE_NORMAL
- en: Support for the SQLite database via the pysqlite driver.
  prefs: []
  type: TYPE_NORMAL
- en: Note that `pysqlite` is the same driver as the `sqlite3` module included with
    the Python distribution.
  prefs: []
  type: TYPE_NORMAL
- en: DBAPI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Documentation and download information (if applicable) for pysqlite is available
    at: [https://docs.python.org/library/sqlite3.html](https://docs.python.org/library/sqlite3.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Connecting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Connect String:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Driver
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `sqlite3` Python DBAPI is standard on all modern Python versions; for cPython
    and Pypy, no additional installation is necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Connect Strings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The file specification for the SQLite database is taken as the “database” portion
    of the URL. Note that the format of a SQLAlchemy url is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that the actual filename to be used starts with the characters to
    the **right** of the third slash. So connecting to a relative filepath looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'An absolute path, which is denoted by starting with a slash, means you need
    **four** slashes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'To use a Windows path, regular drive specifications and backslashes can be
    used. Double backslashes are probably needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'To use sqlite `:memory:` database specify it as the filename using `sqlite://:memory:`.
    It’s also the default if no filepath is present, specifying only `sqlite://` and
    nothing else:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '#### URI Connections'
  prefs: []
  type: TYPE_NORMAL
- en: 'Modern versions of SQLite support an alternative system of connecting using
    a [driver level URI](https://www.sqlite.org/uri.html), which has the advantage
    that additional driver-level arguments can be passed including options such as
    “read only”. The Python sqlite3 driver supports this mode under modern Python
    3 versions. The SQLAlchemy pysqlite driver supports this mode of use by specifying
    “uri=true” in the URL query string. The SQLite-level “URI” is kept as the “database”
    portion of the SQLAlchemy url (that is, following a slash):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The “uri=true” parameter must appear in the **query string** of the URL. It
    will not currently work as expected if it is only present in the [`create_engine.connect_args`](../core/engines.html#sqlalchemy.create_engine.params.connect_args
    "sqlalchemy.create_engine") parameter dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: 'The logic reconciles the simultaneous presence of SQLAlchemy’s query string
    and SQLite’s query string by separating out the parameters that belong to the
    Python sqlite3 driver vs. those that belong to the SQLite URI. This is achieved
    through the use of a fixed list of parameters known to be accepted by the Python
    side of the driver. For example, to include a URL that indicates the Python sqlite3
    “timeout” and “check_same_thread” parameters, along with the SQLite “mode” and
    “nolock” parameters, they can all be passed together on the query string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Above, the pysqlite / sqlite3 DBAPI would be passed arguments as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Regarding future parameters added to either the Python or native drivers. new
    parameter names added to the SQLite URI scheme should be automatically accommodated
    by this scheme. New parameter names added to the Python driver side can be accommodated
    by specifying them in the [`create_engine.connect_args`](../core/engines.html#sqlalchemy.create_engine.params.connect_args
    "sqlalchemy.create_engine") dictionary, until dialect support is added by SQLAlchemy.
    For the less likely case that the native SQLite driver adds a new parameter name
    that overlaps with one of the existing, known Python driver parameters (such as
    “timeout” perhaps), SQLAlchemy’s dialect would require adjustment for the URL
    scheme to continue to support this.
  prefs: []
  type: TYPE_NORMAL
- en: As is always the case for all SQLAlchemy dialects, the entire “URL” process
    can be bypassed in [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") through the use of the [`create_engine.creator`](../core/engines.html#sqlalchemy.create_engine.params.creator
    "sqlalchemy.create_engine") parameter which allows for a custom callable that
    creates a Python sqlite3 driver level connection directly.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.3.9.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Uniform Resource Identifiers](https://www.sqlite.org/uri.html) - in the SQLite
    documentation  ### Regular Expression Support'
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.4.
  prefs: []
  type: TYPE_NORMAL
- en: Support for the [`ColumnOperators.regexp_match()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.regexp_match
    "sqlalchemy.sql.expression.ColumnOperators.regexp_match") operator is provided
    using Python’s [re.search](https://docs.python.org/3/library/re.html#re.search)
    function. SQLite itself does not include a working regular expression operator;
    instead, it includes a non-implemented placeholder operator `REGEXP` that calls
    a user-defined function that must be provided.
  prefs: []
  type: TYPE_NORMAL
- en: 'SQLAlchemy’s implementation makes use of the pysqlite [create_function](https://docs.python.org/3/library/sqlite3.html#sqlite3.Connection.create_function)
    hook as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: There is currently no support for regular expression flags as a separate argument,
    as these are not supported by SQLite’s REGEXP operator, however these may be included
    inline within the regular expression string. See [Python regular expressions](https://docs.python.org/3/library/re.html#re.search)
    for details.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Python regular expressions](https://docs.python.org/3/library/re.html#re.search):
    Documentation for Python’s regular expression syntax.'
  prefs: []
  type: TYPE_NORMAL
- en: Compatibility with sqlite3 “native” date and datetime types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The pysqlite driver includes the sqlite3.PARSE_DECLTYPES and sqlite3.PARSE_COLNAMES
    options, which have the effect of any column or expression explicitly cast as
    “date” or “timestamp” will be converted to a Python date or datetime object. The
    date and datetime types provided with the pysqlite dialect are not currently compatible
    with these options, since they render the ISO date/datetime including microseconds,
    which pysqlite’s driver does not. Additionally, SQLAlchemy does not at this time
    automatically render the “cast” syntax required for the freestanding functions
    “current_timestamp” and “current_date” to return datetime/date types natively.
    Unfortunately, pysqlite does not provide the standard DBAPI types in `cursor.description`,
    leaving SQLAlchemy with no way to detect these types on the fly without expensive
    per-row type checks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Keeping in mind that pysqlite’s parsing option is not recommended, nor should
    be necessary, for use with SQLAlchemy, usage of PARSE_DECLTYPES can be forced
    if one configures “native_datetime=True” on create_engine():'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: With this flag enabled, the DATE and TIMESTAMP types (but note - not the DATETIME
    or TIME types…confused yet ?) will not perform any bind parameter or result processing.
    Execution of “func.current_date()” will return a string. “func.current_timestamp()”
    is registered as returning a DATETIME type in SQLAlchemy, so this function still
    receives SQLAlchemy-level result processing.
  prefs: []
  type: TYPE_NORMAL
- en: '### Threading/Pooling Behavior'
  prefs: []
  type: TYPE_NORMAL
- en: The `sqlite3` DBAPI by default prohibits the use of a particular connection
    in a thread which is not the one in which it was created. As SQLite has matured,
    it’s behavior under multiple threads has improved, and even includes options for
    memory only databases to be used in multiple threads.
  prefs: []
  type: TYPE_NORMAL
- en: The thread prohibition is known as “check same thread” and may be controlled
    using the `sqlite3` parameter `check_same_thread`, which will disable or enable
    this check. SQLAlchemy’s default behavior here is to set `check_same_thread` to
    `False` automatically whenever a file-based database is in use, to establish compatibility
    with the default pool class [`QueuePool`](../core/pooling.html#sqlalchemy.pool.QueuePool
    "sqlalchemy.pool.QueuePool").
  prefs: []
  type: TYPE_NORMAL
- en: 'The SQLAlchemy `pysqlite` DBAPI establishes the connection pool differently
    based on the kind of SQLite database that’s requested:'
  prefs: []
  type: TYPE_NORMAL
- en: When a `:memory:` SQLite database is specified, the dialect by default will
    use [`SingletonThreadPool`](../core/pooling.html#sqlalchemy.pool.SingletonThreadPool
    "sqlalchemy.pool.SingletonThreadPool"). This pool maintains a single connection
    per thread, so that all access to the engine within the current thread use the
    same `:memory:` database - other threads would access a different `:memory:` database.
    The `check_same_thread` parameter defaults to `True`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a file-based database is specified, the dialect will use [`QueuePool`](../core/pooling.html#sqlalchemy.pool.QueuePool
    "sqlalchemy.pool.QueuePool") as the source of connections. at the same time, the
    `check_same_thread` flag is set to False by default unless overridden.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Changed in version 2.0: SQLite file database engines now use [`QueuePool`](../core/pooling.html#sqlalchemy.pool.QueuePool
    "sqlalchemy.pool.QueuePool") by default. Previously, [`NullPool`](../core/pooling.html#sqlalchemy.pool.NullPool
    "sqlalchemy.pool.NullPool") were used. The [`NullPool`](../core/pooling.html#sqlalchemy.pool.NullPool
    "sqlalchemy.pool.NullPool") class may be used by specifying it via the [`create_engine.poolclass`](../core/engines.html#sqlalchemy.create_engine.params.poolclass
    "sqlalchemy.create_engine") parameter.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Disabling Connection Pooling for File Databases
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Pooling may be disabled for a file based database by specifying the [`NullPool`](../core/pooling.html#sqlalchemy.pool.NullPool
    "sqlalchemy.pool.NullPool") implementation for the `poolclass()` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: It’s been observed that the [`NullPool`](../core/pooling.html#sqlalchemy.pool.NullPool
    "sqlalchemy.pool.NullPool") implementation incurs an extremely small performance
    overhead for repeated checkouts due to the lack of connection re-use implemented
    by [`QueuePool`](../core/pooling.html#sqlalchemy.pool.QueuePool "sqlalchemy.pool.QueuePool").
    However, it still may be beneficial to use this class if the application is experiencing
    issues with files being locked.
  prefs: []
  type: TYPE_NORMAL
- en: Using a Memory Database in Multiple Threads
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a `:memory:` database in a multithreaded scenario, the same connection
    object must be shared among threads, since the database exists only within the
    scope of that connection. The [`StaticPool`](../core/pooling.html#sqlalchemy.pool.StaticPool
    "sqlalchemy.pool.StaticPool") implementation will maintain a single connection
    globally, and the `check_same_thread` flag can be passed to Pysqlite as `False`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Note that using a `:memory:` database in multiple threads requires a recent
    version of SQLite.
  prefs: []
  type: TYPE_NORMAL
- en: Using Temporary Tables with SQLite
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Due to the way SQLite deals with temporary tables, if you wish to use a temporary
    table in a file-based SQLite database across multiple checkouts from the connection
    pool, such as when using an ORM [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") where the temporary table should continue to remain
    after [`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") or [`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") is called, a pool which maintains a single
    connection must be used. Use [`SingletonThreadPool`](../core/pooling.html#sqlalchemy.pool.SingletonThreadPool
    "sqlalchemy.pool.SingletonThreadPool") if the scope is only needed within the
    current thread, or [`StaticPool`](../core/pooling.html#sqlalchemy.pool.StaticPool
    "sqlalchemy.pool.StaticPool") is scope is needed within multiple threads for this
    case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Note that [`SingletonThreadPool`](../core/pooling.html#sqlalchemy.pool.SingletonThreadPool
    "sqlalchemy.pool.SingletonThreadPool") should be configured for the number of
    threads that are to be used; beyond that number, connections will be closed out
    in a non deterministic way.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with Mixed String / Binary Columns
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The SQLite database is weakly typed, and as such it is possible when using binary
    values, which in Python are represented as `b'some string'`, that a particular
    SQLite database can have data values within different rows where some of them
    will be returned as a `b''` value by the Pysqlite driver, and others will be returned
    as Python strings, e.g. `''` values. This situation is not known to occur if the
    SQLAlchemy [`LargeBinary`](../core/type_basics.html#sqlalchemy.types.LargeBinary
    "sqlalchemy.types.LargeBinary") datatype is used consistently, however if a particular
    SQLite database has data that was inserted using the Pysqlite driver directly,
    or when using the SQLAlchemy [`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String") type which was later changed to [`LargeBinary`](../core/type_basics.html#sqlalchemy.types.LargeBinary
    "sqlalchemy.types.LargeBinary"), the table will not be consistently readable because
    SQLAlchemy’s [`LargeBinary`](../core/type_basics.html#sqlalchemy.types.LargeBinary
    "sqlalchemy.types.LargeBinary") datatype does not handle strings so it has no
    way of “encoding” a value that is in string format.
  prefs: []
  type: TYPE_NORMAL
- en: 'To deal with a SQLite table that has mixed string / binary data in the same
    column, use a custom type that will check each row individually:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Then use the above `MixedBinary` datatype in the place where [`LargeBinary`](../core/type_basics.html#sqlalchemy.types.LargeBinary
    "sqlalchemy.types.LargeBinary") would normally be used.
  prefs: []
  type: TYPE_NORMAL
- en: '### Serializable isolation / Savepoints / Transactional DDL'
  prefs: []
  type: TYPE_NORMAL
- en: In the section [Database Locking Behavior / Concurrency](#sqlite-concurrency),
    we refer to the pysqlite driver’s assortment of issues that prevent several features
    of SQLite from working correctly. The pysqlite DBAPI driver has several long-standing
    bugs which impact the correctness of its transactional behavior. In its default
    mode of operation, SQLite features such as SERIALIZABLE isolation, transactional
    DDL, and SAVEPOINT support are non-functional, and in order to use these features,
    workarounds must be taken.
  prefs: []
  type: TYPE_NORMAL
- en: The issue is essentially that the driver attempts to second-guess the user’s
    intent, failing to start transactions and sometimes ending them prematurely, in
    an effort to minimize the SQLite databases’s file locking behavior, even though
    SQLite itself uses “shared” locks for read-only activities.
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy chooses to not alter this behavior by default, as it is the long-expected
    behavior of the pysqlite driver; if and when the pysqlite driver attempts to repair
    these issues, that will be more of a driver towards defaults for SQLAlchemy.
  prefs: []
  type: TYPE_NORMAL
- en: 'The good news is that with a few events, we can implement transactional support
    fully, by disabling pysqlite’s feature entirely and emitting BEGIN ourselves.
    This is achieved using two event listeners:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: When using the above recipe, it is advised to not use the [`Connection.execution_options.isolation_level`](../core/connections.html#sqlalchemy.engine.Connection.execution_options.params.isolation_level
    "sqlalchemy.engine.Connection.execution_options") setting on [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") and [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") with the SQLite driver, as this function necessarily
    will also alter the “.isolation_level” setting.
  prefs: []
  type: TYPE_NORMAL
- en: Above, we intercept a new pysqlite connection and disable any transactional
    integration. Then, at the point at which SQLAlchemy knows that transaction scope
    is to begin, we emit `"BEGIN"` ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we take control of `"BEGIN"`, we can also control directly SQLite’s locking
    modes, introduced at [BEGIN TRANSACTION](https://sqlite.org/lang_transaction.html),
    by adding the desired locking mode to our `"BEGIN"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[BEGIN TRANSACTION](https://sqlite.org/lang_transaction.html) - on the SQLite
    site'
  prefs: []
  type: TYPE_NORMAL
- en: '[sqlite3 SELECT does not BEGIN a transaction](https://bugs.python.org/issue9924)
    - on the Python bug tracker'
  prefs: []
  type: TYPE_NORMAL
- en: '[sqlite3 module breaks transactions and potentially corrupts data](https://bugs.python.org/issue10740)
    - on the Python bug tracker  ### User-Defined Functions'
  prefs: []
  type: TYPE_NORMAL
- en: pysqlite supports a [create_function()](https://docs.python.org/3/library/sqlite3.html#sqlite3.Connection.create_function)
    method that allows us to create our own user-defined functions (UDFs) in Python
    and use them directly in SQLite queries. These functions are registered with a
    specific DBAPI Connection.
  prefs: []
  type: TYPE_NORMAL
- en: 'SQLAlchemy uses connection pooling with file-based SQLite databases, so we
    need to ensure that the UDF is attached to the connection when it is created.
    That is accomplished with an event listener:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]  ## Aiosqlite'
  prefs: []
  type: TYPE_NORMAL
- en: Support for the SQLite database via the aiosqlite driver.
  prefs: []
  type: TYPE_NORMAL
- en: DBAPI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Documentation and download information (if applicable) for aiosqlite is available
    at: [https://pypi.org/project/aiosqlite/](https://pypi.org/project/aiosqlite/)'
  prefs: []
  type: TYPE_NORMAL
- en: Connecting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Connect String:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: The aiosqlite dialect provides support for the SQLAlchemy asyncio interface
    running on top of pysqlite.
  prefs: []
  type: TYPE_NORMAL
- en: aiosqlite is a wrapper around pysqlite that uses a background thread for each
    connection. It does not actually use non-blocking IO, as SQLite databases are
    not socket-based. However it does provide a working asyncio interface that’s useful
    for testing and prototyping purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Using a special asyncio mediation layer, the aiosqlite dialect is usable as
    the backend for the [SQLAlchemy asyncio](../orm/extensions/asyncio.html) extension
    package.
  prefs: []
  type: TYPE_NORMAL
- en: 'This dialect should normally be used only with the [`create_async_engine()`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.create_async_engine
    "sqlalchemy.ext.asyncio.create_async_engine") engine creation function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: The URL passes through all arguments to the `pysqlite` driver, so all connection
    arguments are the same as they are for that of [Pysqlite](#pysqlite).
  prefs: []
  type: TYPE_NORMAL
- en: '### User-Defined Functions'
  prefs: []
  type: TYPE_NORMAL
- en: 'aiosqlite extends pysqlite to support async, so we can create our own user-defined
    functions (UDFs) in Python and use them directly in SQLite queries as described
    here: [User-Defined Functions](#pysqlite-udfs).  ### Serializable isolation /
    Savepoints / Transactional DDL (asyncio version)'
  prefs: []
  type: TYPE_NORMAL
- en: Similarly to pysqlite, aiosqlite does not support SAVEPOINT feature.
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution is similar to [Serializable isolation / Savepoints / Transactional
    DDL](#pysqlite-serializable). This is achieved by the event listeners in async:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: 'When using the above recipe, it is advised to not use the [`Connection.execution_options.isolation_level`](../core/connections.html#sqlalchemy.engine.Connection.execution_options.params.isolation_level
    "sqlalchemy.engine.Connection.execution_options") setting on [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") and [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") with the SQLite driver, as this function necessarily
    will also alter the “.isolation_level” setting.  ## Pysqlcipher'
  prefs: []
  type: TYPE_NORMAL
- en: Support for the SQLite database via the pysqlcipher driver.
  prefs: []
  type: TYPE_NORMAL
- en: Dialect for support of DBAPIs that make use of the [SQLCipher](https://www.zetetic.net/sqlcipher)
    backend.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Connect String:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Driver
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Current dialect selection logic is:'
  prefs: []
  type: TYPE_NORMAL
- en: If the [`create_engine.module`](../core/engines.html#sqlalchemy.create_engine.params.module
    "sqlalchemy.create_engine") parameter supplies a DBAPI module, that module is
    used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Otherwise for Python 3, choose [https://pypi.org/project/sqlcipher3/](https://pypi.org/project/sqlcipher3/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If not available, fall back to [https://pypi.org/project/pysqlcipher3/](https://pypi.org/project/pysqlcipher3/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For Python 2, [https://pypi.org/project/pysqlcipher/](https://pypi.org/project/pysqlcipher/)
    is used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: 'The `pysqlcipher3` and `pysqlcipher` DBAPI drivers are no longer maintained;
    the `sqlcipher3` driver as of this writing appears to be current. For future compatibility,
    any pysqlcipher-compatible DBAPI may be used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: These drivers make use of the SQLCipher engine. This system essentially introduces
    new PRAGMA commands to SQLite which allows the setting of a passphrase and other
    encryption parameters, allowing the database file to be encrypted.
  prefs: []
  type: TYPE_NORMAL
- en: Connect Strings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The format of the connect string is in every way the same as that of the [`pysqlite`](#module-sqlalchemy.dialects.sqlite.pysqlite
    "sqlalchemy.dialects.sqlite.pysqlite") driver, except that the “password” field
    is now accepted, which should contain a passphrase:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'For an absolute file path, two leading slashes should be used for the database
    name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'A selection of additional encryption-related pragmas supported by SQLCipher
    as documented at [https://www.zetetic.net/sqlcipher/sqlcipher-api/](https://www.zetetic.net/sqlcipher/sqlcipher-api/)
    can be passed in the query string, and will result in that PRAGMA being called
    for each new connection. Currently, `cipher`, `kdf_iter` `cipher_page_size` and
    `cipher_use_hmac` are supported:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: Previous versions of sqlalchemy did not take into consideration the encryption-related
    pragmas passed in the url string, that were silently ignored. This may cause errors
    when opening files saved by a previous sqlalchemy version if the encryption options
    do not match.
  prefs: []
  type: TYPE_NORMAL
- en: Pooling Behavior
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The driver makes a change to the default pool behavior of pysqlite as described
    in [Threading/Pooling Behavior](#pysqlite-threading-pooling). The pysqlcipher
    driver has been observed to be significantly slower on connection than the pysqlite
    driver, most likely due to the encryption overhead, so the dialect here defaults
    to using the [`SingletonThreadPool`](../core/pooling.html#sqlalchemy.pool.SingletonThreadPool
    "sqlalchemy.pool.SingletonThreadPool") implementation, instead of the [`NullPool`](../core/pooling.html#sqlalchemy.pool.NullPool
    "sqlalchemy.pool.NullPool") pool used by pysqlite. As always, the pool implementation
    is entirely configurable using the [`create_engine.poolclass`](../core/engines.html#sqlalchemy.create_engine.params.poolclass
    "sqlalchemy.create_engine") parameter; the `StaticPool` may be more feasible for
    single-threaded use, or [`NullPool`](../core/pooling.html#sqlalchemy.pool.NullPool
    "sqlalchemy.pool.NullPool") may be used to prevent unencrypted connections from
    being held open for long periods of time, at the expense of slower startup time
    for new connections.
  prefs: []
  type: TYPE_NORMAL
- en: Support for the SQLite database.
  prefs: []
  type: TYPE_NORMAL
- en: The following table summarizes current support levels for database release versions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Supported SQLite versions**'
  prefs: []
  type: TYPE_NORMAL
- en: '| Support type | Versions |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| [Fully tested in CI](index.html#term-Fully-tested-in-CI) | 3.36.0 |'
  prefs: []
  type: TYPE_TB
- en: '| [Normal support](index.html#term-Normal-support) | 3.12+ |'
  prefs: []
  type: TYPE_TB
- en: '| [Best effort](index.html#term-Best-effort) | 3.7.16+ |'
  prefs: []
  type: TYPE_TB
- en: DBAPI Support
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following dialect/DBAPI options are available. Please refer to individual
    DBAPI sections for connect information.
  prefs: []
  type: TYPE_NORMAL
- en: '[pysqlite](#module-sqlalchemy.dialects.sqlite.pysqlite)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[aiosqlite](#module-sqlalchemy.dialects.sqlite.aiosqlite)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[pysqlcipher](#module-sqlalchemy.dialects.sqlite.pysqlcipher)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '## Date and Time Types'
  prefs: []
  type: TYPE_NORMAL
- en: SQLite does not have built-in DATE, TIME, or DATETIME types, and pysqlite does
    not provide out of the box functionality for translating values between Python
    datetime objects and a SQLite-supported format. SQLAlchemy’s own [`DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime
    "sqlalchemy.types.DateTime") and related types provide date formatting and parsing
    functionality when SQLite is used. The implementation classes are [`DATETIME`](#sqlalchemy.dialects.sqlite.DATETIME
    "sqlalchemy.dialects.sqlite.DATETIME"), [`DATE`](#sqlalchemy.dialects.sqlite.DATE
    "sqlalchemy.dialects.sqlite.DATE") and [`TIME`](#sqlalchemy.dialects.sqlite.TIME
    "sqlalchemy.dialects.sqlite.TIME"). These types represent dates and times as ISO
    formatted strings, which also nicely support ordering. There’s no reliance on
    typical “libc” internals for these functions so historical dates are fully supported.
  prefs: []
  type: TYPE_NORMAL
- en: Ensuring Text affinity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The DDL rendered for these types is the standard `DATE`, `TIME` and `DATETIME`
    indicators. However, custom storage formats can also be applied to these types.
    When the storage format is detected as containing no alpha characters, the DDL
    for these types is rendered as `DATE_CHAR`, `TIME_CHAR`, and `DATETIME_CHAR`,
    so that the column continues to have textual affinity.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Type Affinity](https://www.sqlite.org/datatype3.html#affinity) - in the SQLite
    documentation'
  prefs: []
  type: TYPE_NORMAL
- en: Ensuring Text affinity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The DDL rendered for these types is the standard `DATE`, `TIME` and `DATETIME`
    indicators. However, custom storage formats can also be applied to these types.
    When the storage format is detected as containing no alpha characters, the DDL
    for these types is rendered as `DATE_CHAR`, `TIME_CHAR`, and `DATETIME_CHAR`,
    so that the column continues to have textual affinity.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Type Affinity](https://www.sqlite.org/datatype3.html#affinity) - in the SQLite
    documentation'
  prefs: []
  type: TYPE_NORMAL
- en: '## SQLite Auto Incrementing Behavior'
  prefs: []
  type: TYPE_NORMAL
- en: 'Background on SQLite’s autoincrement is at: [https://sqlite.org/autoinc.html](https://sqlite.org/autoinc.html)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Key concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: SQLite has an implicit “auto increment” feature that takes place for any non-composite
    primary-key column that is specifically created using “INTEGER PRIMARY KEY” for
    the type + primary key.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SQLite also has an explicit “AUTOINCREMENT” keyword, that is **not** equivalent
    to the implicit autoincrement feature; this keyword is not recommended for general
    use. SQLAlchemy does not render this keyword unless a special SQLite-specific
    directive is used (see below). However, it still requires that the column’s type
    is named “INTEGER”.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the AUTOINCREMENT Keyword
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To specifically render the AUTOINCREMENT keyword on the primary key column
    when rendering DDL, add the flag `sqlite_autoincrement=True` to the Table construct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Allowing autoincrement behavior SQLAlchemy types other than Integer/INTEGER
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: SQLite’s typing model is based on naming conventions. Among other things, this
    means that any type name which contains the substring `"INT"` will be determined
    to be of “integer affinity”. A type named `"BIGINT"`, `"SPECIAL_INT"` or even
    `"XYZINTQPR"`, will be considered by SQLite to be of “integer” affinity. However,
    **the SQLite autoincrement feature, whether implicitly or explicitly enabled,
    requires that the name of the column’s type is exactly the string “INTEGER”**.
    Therefore, if an application uses a type like [`BigInteger`](../core/type_basics.html#sqlalchemy.types.BigInteger
    "sqlalchemy.types.BigInteger") for a primary key, on SQLite this type will need
    to be rendered as the name `"INTEGER"` when emitting the initial `CREATE TABLE`
    statement in order for the autoincrement behavior to be available.
  prefs: []
  type: TYPE_NORMAL
- en: 'One approach to achieve this is to use [`Integer`](../core/type_basics.html#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer") on SQLite only using [`TypeEngine.with_variant()`](../core/type_api.html#sqlalchemy.types.TypeEngine.with_variant
    "sqlalchemy.types.TypeEngine.with_variant"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Another is to use a subclass of [`BigInteger`](../core/type_basics.html#sqlalchemy.types.BigInteger
    "sqlalchemy.types.BigInteger") that overrides its DDL name to be `INTEGER` when
    compiled against SQLite:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`TypeEngine.with_variant()`](../core/type_api.html#sqlalchemy.types.TypeEngine.with_variant
    "sqlalchemy.types.TypeEngine.with_variant")'
  prefs: []
  type: TYPE_NORMAL
- en: '[Custom SQL Constructs and Compilation Extension](../core/compiler.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Datatypes In SQLite Version 3](https://sqlite.org/datatype3.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Using the AUTOINCREMENT Keyword
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To specifically render the AUTOINCREMENT keyword on the primary key column
    when rendering DDL, add the flag `sqlite_autoincrement=True` to the Table construct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Allowing autoincrement behavior SQLAlchemy types other than Integer/INTEGER
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: SQLite’s typing model is based on naming conventions. Among other things, this
    means that any type name which contains the substring `"INT"` will be determined
    to be of “integer affinity”. A type named `"BIGINT"`, `"SPECIAL_INT"` or even
    `"XYZINTQPR"`, will be considered by SQLite to be of “integer” affinity. However,
    **the SQLite autoincrement feature, whether implicitly or explicitly enabled,
    requires that the name of the column’s type is exactly the string “INTEGER”**.
    Therefore, if an application uses a type like [`BigInteger`](../core/type_basics.html#sqlalchemy.types.BigInteger
    "sqlalchemy.types.BigInteger") for a primary key, on SQLite this type will need
    to be rendered as the name `"INTEGER"` when emitting the initial `CREATE TABLE`
    statement in order for the autoincrement behavior to be available.
  prefs: []
  type: TYPE_NORMAL
- en: 'One approach to achieve this is to use [`Integer`](../core/type_basics.html#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer") on SQLite only using [`TypeEngine.with_variant()`](../core/type_api.html#sqlalchemy.types.TypeEngine.with_variant
    "sqlalchemy.types.TypeEngine.with_variant"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Another is to use a subclass of [`BigInteger`](../core/type_basics.html#sqlalchemy.types.BigInteger
    "sqlalchemy.types.BigInteger") that overrides its DDL name to be `INTEGER` when
    compiled against SQLite:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`TypeEngine.with_variant()`](../core/type_api.html#sqlalchemy.types.TypeEngine.with_variant
    "sqlalchemy.types.TypeEngine.with_variant")'
  prefs: []
  type: TYPE_NORMAL
- en: '[Custom SQL Constructs and Compilation Extension](../core/compiler.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Datatypes In SQLite Version 3](https://sqlite.org/datatype3.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '## Database Locking Behavior / Concurrency'
  prefs: []
  type: TYPE_NORMAL
- en: SQLite is not designed for a high level of write concurrency. The database itself,
    being a file, is locked completely during write operations within transactions,
    meaning exactly one “connection” (in reality a file handle) has exclusive access
    to the database during this period - all other “connections” will be blocked during
    this time.
  prefs: []
  type: TYPE_NORMAL
- en: The Python DBAPI specification also calls for a connection model that is always
    in a transaction; there is no `connection.begin()` method, only `connection.commit()`
    and `connection.rollback()`, upon which a new transaction is to be begun immediately.
    This may seem to imply that the SQLite driver would in theory allow only a single
    filehandle on a particular database file at any time; however, there are several
    factors both within SQLite itself as well as within the pysqlite driver which
    loosen this restriction significantly.
  prefs: []
  type: TYPE_NORMAL
- en: However, no matter what locking modes are used, SQLite will still always lock
    the database file once a transaction is started and DML (e.g. INSERT, UPDATE,
    DELETE) has at least been emitted, and this will block other transactions at least
    at the point that they also attempt to emit DML. By default, the length of time
    on this block is very short before it times out with an error.
  prefs: []
  type: TYPE_NORMAL
- en: This behavior becomes more critical when used in conjunction with the SQLAlchemy
    ORM. SQLAlchemy’s [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    object by default runs within a transaction, and with its autoflush model, may
    emit DML preceding any SELECT statement. This may lead to a SQLite database that
    locks more quickly than is expected. The locking mode of SQLite and the pysqlite
    driver can be manipulated to some degree, however it should be noted that achieving
    a high degree of write-concurrency with SQLite is a losing battle.
  prefs: []
  type: TYPE_NORMAL
- en: For more information on SQLite’s lack of write concurrency by design, please
    see [Situations Where Another RDBMS May Work Better - High Concurrency](https://www.sqlite.org/whentouse.html)
    near the bottom of the page.
  prefs: []
  type: TYPE_NORMAL
- en: The following subsections introduce areas that are impacted by SQLite’s file-based
    architecture and additionally will usually require workarounds to work when using
    the pysqlite driver.
  prefs: []
  type: TYPE_NORMAL
- en: '## Transaction Isolation Level / Autocommit'
  prefs: []
  type: TYPE_NORMAL
- en: SQLite supports “transaction isolation” in a non-standard way, along two axes.
    One is that of the [PRAGMA read_uncommitted](https://www.sqlite.org/pragma.html#pragma_read_uncommitted)
    instruction. This setting can essentially switch SQLite between its default mode
    of `SERIALIZABLE` isolation, and a “dirty read” isolation mode normally referred
    to as `READ UNCOMMITTED`.
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy ties into this PRAGMA statement using the [`create_engine.isolation_level`](../core/engines.html#sqlalchemy.create_engine.params.isolation_level
    "sqlalchemy.create_engine") parameter of [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine"). Valid values for this parameter when used with SQLite
    are `"SERIALIZABLE"` and `"READ UNCOMMITTED"` corresponding to a value of 0 and
    1, respectively. SQLite defaults to `SERIALIZABLE`, however its behavior is impacted
    by the pysqlite driver’s default behavior.
  prefs: []
  type: TYPE_NORMAL
- en: When using the pysqlite driver, the `"AUTOCOMMIT"` isolation level is also available,
    which will alter the pysqlite connection using the `.isolation_level` attribute
    on the DBAPI connection and set it to None for the duration of the setting.
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 1.3.16: added support for SQLite AUTOCOMMIT isolation level
    when using the pysqlite / sqlite3 SQLite driver.'
  prefs: []
  type: TYPE_NORMAL
- en: The other axis along which SQLite’s transactional locking is impacted is via
    the nature of the `BEGIN` statement used. The three varieties are “deferred”,
    “immediate”, and “exclusive”, as described at [BEGIN TRANSACTION](https://sqlite.org/lang_transaction.html).
    A straight `BEGIN` statement uses the “deferred” mode, where the database file
    is not locked until the first read or write operation, and read access remains
    open to other transactions until the first write operation. But again, it is critical
    to note that the pysqlite driver interferes with this behavior by *not even emitting
    BEGIN* until the first write operation.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: SQLite’s transactional scope is impacted by unresolved issues in the pysqlite
    driver, which defers BEGIN statements to a greater degree than is often feasible.
    See the section [Serializable isolation / Savepoints / Transactional DDL](#pysqlite-serializable)
    or [Serializable isolation / Savepoints / Transactional DDL (asyncio version)](#aiosqlite-serializable)
    for techniques to work around this behavior.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Setting Transaction Isolation Levels including DBAPI Autocommit](../core/connections.html#dbapi-autocommit)'
  prefs: []
  type: TYPE_NORMAL
- en: INSERT/UPDATE/DELETE…RETURNING
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The SQLite dialect supports SQLite 3.35’s `INSERT|UPDATE|DELETE..RETURNING`
    syntax. `INSERT..RETURNING` may be used automatically in some cases in order to
    fetch newly generated identifiers in place of the traditional approach of using
    `cursor.lastrowid`, however `cursor.lastrowid` is currently still preferred for
    simple single-statement cases for its better performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'To specify an explicit `RETURNING` clause, use the `_UpdateBase.returning()`
    method on a per-statement basis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'New in version 2.0: Added support for SQLite RETURNING'
  prefs: []
  type: TYPE_NORMAL
- en: SAVEPOINT Support
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SQLite supports SAVEPOINTs, which only function once a transaction is begun.
    SQLAlchemy’s SAVEPOINT support is available using the [`Connection.begin_nested()`](../core/connections.html#sqlalchemy.engine.Connection.begin_nested
    "sqlalchemy.engine.Connection.begin_nested") method at the Core level, and [`Session.begin_nested()`](../orm/session_api.html#sqlalchemy.orm.Session.begin_nested
    "sqlalchemy.orm.Session.begin_nested") at the ORM level. However, SAVEPOINTs won’t
    work at all with pysqlite unless workarounds are taken.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: SQLite’s SAVEPOINT feature is impacted by unresolved issues in the pysqlite
    and aiosqlite drivers, which defer BEGIN statements to a greater degree than is
    often feasible. See the sections [Serializable isolation / Savepoints / Transactional
    DDL](#pysqlite-serializable) and [Serializable isolation / Savepoints / Transactional
    DDL (asyncio version)](#aiosqlite-serializable) for techniques to work around
    this behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Transactional DDL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The SQLite database supports transactional [DDL](../glossary.html#term-DDL)
    as well. In this case, the pysqlite driver is not only failing to start transactions,
    it also is ending any existing transaction when DDL is detected, so again, workarounds
    are required.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: SQLite’s transactional DDL is impacted by unresolved issues in the pysqlite
    driver, which fails to emit BEGIN and additionally forces a COMMIT to cancel any
    transaction when DDL is encountered. See the section [Serializable isolation /
    Savepoints / Transactional DDL](#pysqlite-serializable) for techniques to work
    around this behavior.
  prefs: []
  type: TYPE_NORMAL
- en: '## Foreign Key Support'
  prefs: []
  type: TYPE_NORMAL
- en: SQLite supports FOREIGN KEY syntax when emitting CREATE statements for tables,
    however by default these constraints have no effect on the operation of the table.
  prefs: []
  type: TYPE_NORMAL
- en: 'Constraint checking on SQLite has three prerequisites:'
  prefs: []
  type: TYPE_NORMAL
- en: At least version 3.6.19 of SQLite must be in use
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The SQLite library must be compiled *without* the SQLITE_OMIT_FOREIGN_KEY or
    SQLITE_OMIT_TRIGGER symbols enabled.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `PRAGMA foreign_keys = ON` statement must be emitted on all connections
    before use – including the initial call to [`MetaData.create_all()`](../core/metadata.html#sqlalchemy.schema.MetaData.create_all
    "sqlalchemy.schema.MetaData.create_all").
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'SQLAlchemy allows for the `PRAGMA` statement to be emitted automatically for
    new connections through the usage of events:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: When SQLite foreign keys are enabled, it is **not possible** to emit CREATE
    or DROP statements for tables that contain mutually-dependent foreign key constraints;
    to emit the DDL for these tables requires that ALTER TABLE be used to create or
    drop these constraints separately, for which SQLite has no support.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[SQLite Foreign Key Support](https://www.sqlite.org/foreignkeys.html) - on
    the SQLite web site.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Events](../core/event.html) - SQLAlchemy event API.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Creating/Dropping Foreign Key Constraints via ALTER](../core/constraints.html#use-alter)
    - more information on SQLAlchemy’s facilities for handling'
  prefs: []
  type: TYPE_NORMAL
- en: mutually-dependent foreign key constraints.
  prefs: []
  type: TYPE_NORMAL
- en: '## ON CONFLICT support for constraints'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: This section describes the [DDL](../glossary.html#term-DDL) version of “ON CONFLICT”
    for SQLite, which occurs within a CREATE TABLE statement. For “ON CONFLICT” as
    applied to an INSERT statement, see [INSERT…ON CONFLICT (Upsert)](#sqlite-on-conflict-insert).
  prefs: []
  type: TYPE_NORMAL
- en: SQLite supports a non-standard DDL clause known as ON CONFLICT which can be
    applied to primary key, unique, check, and not null constraints. In DDL, it is
    rendered either within the “CONSTRAINT” clause or within the column definition
    itself depending on the location of the target constraint. To render this clause
    within DDL, the extension parameter `sqlite_on_conflict` can be specified with
    a string conflict resolution algorithm within the [`PrimaryKeyConstraint`](../core/constraints.html#sqlalchemy.schema.PrimaryKeyConstraint
    "sqlalchemy.schema.PrimaryKeyConstraint"), [`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint"), [`CheckConstraint`](../core/constraints.html#sqlalchemy.schema.CheckConstraint
    "sqlalchemy.schema.CheckConstraint") objects. Within the [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") object, there are individual parameters `sqlite_on_conflict_not_null`,
    `sqlite_on_conflict_primary_key`, `sqlite_on_conflict_unique` which each correspond
    to the three types of relevant constraint types that can be indicated from a [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") object.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[ON CONFLICT](https://www.sqlite.org/lang_conflict.html) - in the SQLite documentation'
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.3.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `sqlite_on_conflict` parameters accept a string argument which is just
    the resolution name to be chosen, which on SQLite can be one of ROLLBACK, ABORT,
    FAIL, IGNORE, and REPLACE. For example, to add a UNIQUE constraint that specifies
    the IGNORE algorithm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'The above renders CREATE TABLE DDL as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'When using the [`Column.unique`](../core/metadata.html#sqlalchemy.schema.Column.params.unique
    "sqlalchemy.schema.Column") flag to add a UNIQUE constraint to a single column,
    the `sqlite_on_conflict_unique` parameter can be added to the [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") as well, which will be added to the UNIQUE constraint
    in the DDL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'rendering:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'To apply the FAIL algorithm for a NOT NULL constraint, `sqlite_on_conflict_not_null`
    is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'this renders the column inline ON CONFLICT phrase:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, for an inline primary key, use `sqlite_on_conflict_primary_key`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'SQLAlchemy renders the PRIMARY KEY constraint separately, so the conflict resolution
    algorithm is applied to the constraint itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '## INSERT…ON CONFLICT (Upsert)'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: This section describes the [DML](../glossary.html#term-DML) version of “ON CONFLICT”
    for SQLite, which occurs within an INSERT statement. For “ON CONFLICT” as applied
    to a CREATE TABLE statement, see [ON CONFLICT support for constraints](#sqlite-on-conflict-ddl).
  prefs: []
  type: TYPE_NORMAL
- en: From version 3.24.0 onwards, SQLite supports “upserts” (update or insert) of
    rows into a table via the `ON CONFLICT` clause of the `INSERT` statement. A candidate
    row will only be inserted if that row does not violate any unique or primary key
    constraints. In the case of a unique constraint violation, a secondary action
    can occur which can be either “DO UPDATE”, indicating that the data in the target
    row should be updated, or “DO NOTHING”, which indicates to silently skip this
    row.
  prefs: []
  type: TYPE_NORMAL
- en: Conflicts are determined using columns that are part of existing unique constraints
    and indexes. These constraints are identified by stating the columns and conditions
    that comprise the indexes.
  prefs: []
  type: TYPE_NORMAL
- en: 'SQLAlchemy provides `ON CONFLICT` support via the SQLite-specific [`insert()`](#sqlalchemy.dialects.sqlite.insert
    "sqlalchemy.dialects.sqlite.insert") function, which provides the generative methods
    [`Insert.on_conflict_do_update()`](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update
    "sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update") and [`Insert.on_conflict_do_nothing()`](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_nothing
    "sqlalchemy.dialects.sqlite.Insert.on_conflict_do_nothing"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: New in version 1.4.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Upsert](https://sqlite.org/lang_UPSERT.html) - in the SQLite documentation.'
  prefs: []
  type: TYPE_NORMAL
- en: Specifying the Target
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Both methods supply the “target” of the conflict using column inference:'
  prefs: []
  type: TYPE_NORMAL
- en: The [`Insert.on_conflict_do_update.index_elements`](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update.params.index_elements
    "sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update") argument specifies
    a sequence containing string column names, [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects, and/or SQL expression elements, which would
    identify a unique index or unique constraint.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When using [`Insert.on_conflict_do_update.index_elements`](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update.params.index_elements
    "sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update") to infer an index,
    a partial index can be inferred by also specifying the [`Insert.on_conflict_do_update.index_where`](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update.params.index_where
    "sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update") parameter:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The SET Clause
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`ON CONFLICT...DO UPDATE` is used to perform an update of the already existing
    row, using any combination of new values as well as values from the proposed insertion.
    These values are specified using the [`Insert.on_conflict_do_update.set_`](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update.params.set_
    "sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update") parameter. This parameter
    accepts a dictionary which consists of direct values for UPDATE:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: The [`Insert.on_conflict_do_update()`](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update
    "sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update") method does **not**
    take into account Python-side default UPDATE values or generation functions, e.g.
    those specified using [`Column.onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.onupdate
    "sqlalchemy.schema.Column"). These values will not be exercised for an ON CONFLICT
    style of UPDATE, unless they are manually specified in the [`Insert.on_conflict_do_update.set_`](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update.params.set_
    "sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update") dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: Updating using the Excluded INSERT Values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In order to refer to the proposed insertion row, the special alias [`Insert.excluded`](#sqlalchemy.dialects.sqlite.Insert.excluded
    "sqlalchemy.dialects.sqlite.Insert.excluded") is available as an attribute on
    the [`Insert`](#sqlalchemy.dialects.sqlite.Insert "sqlalchemy.dialects.sqlite.Insert")
    object; this object creates an “excluded.” prefix on a column, that informs the
    DO UPDATE to update the row with the value that would have been inserted had the
    constraint not failed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: Additional WHERE Criteria
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The [`Insert.on_conflict_do_update()`](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update
    "sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update") method also accepts
    a WHERE clause using the [`Insert.on_conflict_do_update.where`](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update.params.where
    "sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update") parameter, which will
    limit those rows which receive an UPDATE:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: Skipping Rows with DO NOTHING
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`ON CONFLICT` may be used to skip inserting a row entirely if any conflict
    with a unique constraint occurs; below this is illustrated using the [`Insert.on_conflict_do_nothing()`](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_nothing
    "sqlalchemy.dialects.sqlite.Insert.on_conflict_do_nothing") method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'If `DO NOTHING` is used without specifying any columns or constraint, it has
    the effect of skipping the INSERT for any unique violation which occurs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: Specifying the Target
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Both methods supply the “target” of the conflict using column inference:'
  prefs: []
  type: TYPE_NORMAL
- en: The [`Insert.on_conflict_do_update.index_elements`](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update.params.index_elements
    "sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update") argument specifies
    a sequence containing string column names, [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects, and/or SQL expression elements, which would
    identify a unique index or unique constraint.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When using [`Insert.on_conflict_do_update.index_elements`](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update.params.index_elements
    "sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update") to infer an index,
    a partial index can be inferred by also specifying the [`Insert.on_conflict_do_update.index_where`](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update.params.index_where
    "sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update") parameter:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The SET Clause
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`ON CONFLICT...DO UPDATE` is used to perform an update of the already existing
    row, using any combination of new values as well as values from the proposed insertion.
    These values are specified using the [`Insert.on_conflict_do_update.set_`](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update.params.set_
    "sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update") parameter. This parameter
    accepts a dictionary which consists of direct values for UPDATE:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: The [`Insert.on_conflict_do_update()`](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update
    "sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update") method does **not**
    take into account Python-side default UPDATE values or generation functions, e.g.
    those specified using [`Column.onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.onupdate
    "sqlalchemy.schema.Column"). These values will not be exercised for an ON CONFLICT
    style of UPDATE, unless they are manually specified in the [`Insert.on_conflict_do_update.set_`](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update.params.set_
    "sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update") dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: Updating using the Excluded INSERT Values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In order to refer to the proposed insertion row, the special alias [`Insert.excluded`](#sqlalchemy.dialects.sqlite.Insert.excluded
    "sqlalchemy.dialects.sqlite.Insert.excluded") is available as an attribute on
    the [`Insert`](#sqlalchemy.dialects.sqlite.Insert "sqlalchemy.dialects.sqlite.Insert")
    object; this object creates an “excluded.” prefix on a column, that informs the
    DO UPDATE to update the row with the value that would have been inserted had the
    constraint not failed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: Additional WHERE Criteria
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The [`Insert.on_conflict_do_update()`](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update
    "sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update") method also accepts
    a WHERE clause using the [`Insert.on_conflict_do_update.where`](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update.params.where
    "sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update") parameter, which will
    limit those rows which receive an UPDATE:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: Skipping Rows with DO NOTHING
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`ON CONFLICT` may be used to skip inserting a row entirely if any conflict
    with a unique constraint occurs; below this is illustrated using the [`Insert.on_conflict_do_nothing()`](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_nothing
    "sqlalchemy.dialects.sqlite.Insert.on_conflict_do_nothing") method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'If `DO NOTHING` is used without specifying any columns or constraint, it has
    the effect of skipping the INSERT for any unique violation which occurs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '## Type Reflection'
  prefs: []
  type: TYPE_NORMAL
- en: SQLite types are unlike those of most other database backends, in that the string
    name of the type usually does not correspond to a “type” in a one-to-one fashion.
    Instead, SQLite links per-column typing behavior to one of five so-called “type
    affinities” based on a string matching pattern for the type.
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy’s reflection process, when inspecting types, uses a simple lookup
    table to link the keywords returned to provided SQLAlchemy types. This lookup
    table is present within the SQLite dialect as it is for all other dialects. However,
    the SQLite dialect has a different “fallback” routine for when a particular type
    name is not located in the lookup map; it instead implements the SQLite “type
    affinity” scheme located at [https://www.sqlite.org/datatype3.html](https://www.sqlite.org/datatype3.html)
    section 2.1.
  prefs: []
  type: TYPE_NORMAL
- en: 'The provided typemap will make direct associations from an exact string name
    match for the following types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`BIGINT`](../core/type_basics.html#sqlalchemy.types.BIGINT "sqlalchemy.types.BIGINT"),
    [`BLOB`](../core/type_basics.html#sqlalchemy.types.BLOB "sqlalchemy.types.BLOB"),
    [`BOOLEAN`](../core/type_basics.html#sqlalchemy.types.BOOLEAN "sqlalchemy.types.BOOLEAN"),
    [`BOOLEAN`](../core/type_basics.html#sqlalchemy.types.BOOLEAN "sqlalchemy.types.BOOLEAN"),
    [`CHAR`](../core/type_basics.html#sqlalchemy.types.CHAR "sqlalchemy.types.CHAR"),
    [`DATE`](../core/type_basics.html#sqlalchemy.types.DATE "sqlalchemy.types.DATE"),
    [`DATETIME`](../core/type_basics.html#sqlalchemy.types.DATETIME "sqlalchemy.types.DATETIME"),
    [`FLOAT`](../core/type_basics.html#sqlalchemy.types.FLOAT "sqlalchemy.types.FLOAT"),
    [`DECIMAL`](../core/type_basics.html#sqlalchemy.types.DECIMAL "sqlalchemy.types.DECIMAL"),
    [`FLOAT`](../core/type_basics.html#sqlalchemy.types.FLOAT "sqlalchemy.types.FLOAT"),
    [`INTEGER`](../core/type_basics.html#sqlalchemy.types.INTEGER "sqlalchemy.types.INTEGER"),
    [`INTEGER`](../core/type_basics.html#sqlalchemy.types.INTEGER "sqlalchemy.types.INTEGER"),
    [`NUMERIC`](../core/type_basics.html#sqlalchemy.types.NUMERIC "sqlalchemy.types.NUMERIC"),
    [`REAL`](../core/type_basics.html#sqlalchemy.types.REAL "sqlalchemy.types.REAL"),
    [`SMALLINT`](../core/type_basics.html#sqlalchemy.types.SMALLINT "sqlalchemy.types.SMALLINT"),
    [`TEXT`](../core/type_basics.html#sqlalchemy.types.TEXT "sqlalchemy.types.TEXT"),
    [`TIME`](../core/type_basics.html#sqlalchemy.types.TIME "sqlalchemy.types.TIME"),
    [`TIMESTAMP`](../core/type_basics.html#sqlalchemy.types.TIMESTAMP "sqlalchemy.types.TIMESTAMP"),
    [`VARCHAR`](../core/type_basics.html#sqlalchemy.types.VARCHAR "sqlalchemy.types.VARCHAR"),
    [`NVARCHAR`](../core/type_basics.html#sqlalchemy.types.NVARCHAR "sqlalchemy.types.NVARCHAR"),
    [`NCHAR`](../core/type_basics.html#sqlalchemy.types.NCHAR "sqlalchemy.types.NCHAR")'
  prefs: []
  type: TYPE_NORMAL
- en: 'When a type name does not match one of the above types, the “type affinity”
    lookup is used instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`INTEGER`](../core/type_basics.html#sqlalchemy.types.INTEGER "sqlalchemy.types.INTEGER")
    is returned if the type name includes the string `INT`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`TEXT`](../core/type_basics.html#sqlalchemy.types.TEXT "sqlalchemy.types.TEXT")
    is returned if the type name includes the string `CHAR`, `CLOB` or `TEXT`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`NullType`](../core/type_api.html#sqlalchemy.types.NullType "sqlalchemy.types.NullType")
    is returned if the type name includes the string `BLOB`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`REAL`](../core/type_basics.html#sqlalchemy.types.REAL "sqlalchemy.types.REAL")
    is returned if the type name includes the string `REAL`, `FLOA` or `DOUB`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Otherwise, the [`NUMERIC`](../core/type_basics.html#sqlalchemy.types.NUMERIC
    "sqlalchemy.types.NUMERIC") type is used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '## Partial Indexes'
  prefs: []
  type: TYPE_NORMAL
- en: 'A partial index, e.g. one which uses a WHERE clause, can be specified with
    the DDL system using the argument `sqlite_where`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'The index will be rendered at create time as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '## Dotted Column Names'
  prefs: []
  type: TYPE_NORMAL
- en: Using table or column names that explicitly have periods in them is **not recommended**.
    While this is generally a bad idea for relational databases in general, as the
    dot is a syntactically significant character, the SQLite driver up until version
    **3.10.0** of SQLite has a bug which requires that SQLAlchemy filter out these
    dots in result sets.
  prefs: []
  type: TYPE_NORMAL
- en: 'The bug, entirely outside of SQLAlchemy, can be illustrated thusly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'The second assertion fails:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: Where above, the driver incorrectly reports the names of the columns including
    the name of the table, which is entirely inconsistent vs. when the UNION is not
    present.
  prefs: []
  type: TYPE_NORMAL
- en: 'SQLAlchemy relies upon column names being predictable in how they match to
    the original statement, so the SQLAlchemy dialect has no choice but to filter
    these out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that above, even though SQLAlchemy filters out the dots, *both names are
    still addressable*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'Therefore, the workaround applied by SQLAlchemy only impacts [`CursorResult.keys()`](../core/connections.html#sqlalchemy.engine.CursorResult.keys
    "sqlalchemy.engine.CursorResult.keys") and `Row.keys()` in the public API. In
    the very specific case where an application is forced to use column names that
    contain dots, and the functionality of [`CursorResult.keys()`](../core/connections.html#sqlalchemy.engine.CursorResult.keys
    "sqlalchemy.engine.CursorResult.keys") and `Row.keys()` is required to return
    these dotted names unmodified, the `sqlite_raw_colnames` execution option may
    be provided, either on a per-[`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") basis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'or on a per-[`Engine`](../core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    basis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: When using the per-[`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") execution option, note that **Core and ORM queries
    that use UNION may not function properly**.
  prefs: []
  type: TYPE_NORMAL
- en: SQLite-specific table options
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One option for CREATE TABLE is supported directly by the SQLite dialect in
    conjunction with the [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    construct:'
  prefs: []
  type: TYPE_NORMAL
- en: '`WITHOUT ROWID`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[SQLite CREATE TABLE options](https://www.sqlite.org/lang_createtable.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '## Reflecting internal schema tables'
  prefs: []
  type: TYPE_NORMAL
- en: Reflection methods that return lists of tables will omit so-called “SQLite internal
    schema object” names, which are considered by SQLite as any object name that is
    prefixed with `sqlite_`. An example of such an object is the `sqlite_sequence`
    table that’s generated when the `AUTOINCREMENT` column parameter is used. In order
    to return these objects, the parameter `sqlite_include_internal=True` may be passed
    to methods such as [`MetaData.reflect()`](../core/metadata.html#sqlalchemy.schema.MetaData.reflect
    "sqlalchemy.schema.MetaData.reflect") or [`Inspector.get_table_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_table_names
    "sqlalchemy.engine.reflection.Inspector.get_table_names").
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 2.0: Added the `sqlite_include_internal=True` parameter. Previously,
    these tables were not ignored by SQLAlchemy reflection methods.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The `sqlite_include_internal` parameter does not refer to the “system” tables
    that are present in schemas such as `sqlite_master`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[SQLite Internal Schema Objects](https://www.sqlite.org/fileformat2.html#intschema)
    - in the SQLite documentation.'
  prefs: []
  type: TYPE_NORMAL
- en: SQLite Data Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As with all SQLAlchemy dialects, all UPPERCASE types that are known to be valid
    with SQLite are importable from the top level dialect, whether they originate
    from [`sqlalchemy.types`](../core/type_basics.html#module-sqlalchemy.types "sqlalchemy.types")
    or from the local dialect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: '| Object Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| [DATE](#sqlalchemy.dialects.sqlite.DATE) | Represent a Python date object
    in SQLite using a string. |'
  prefs: []
  type: TYPE_TB
- en: '| [DATETIME](#sqlalchemy.dialects.sqlite.DATETIME) | Represent a Python datetime
    object in SQLite using a string. |'
  prefs: []
  type: TYPE_TB
- en: '| [JSON](#sqlalchemy.dialects.sqlite.JSON) | SQLite JSON type. |'
  prefs: []
  type: TYPE_TB
- en: '| [TIME](#sqlalchemy.dialects.sqlite.TIME) | Represent a Python time object
    in SQLite using a string. |'
  prefs: []
  type: TYPE_TB
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: Represent a Python datetime object in SQLite using a string.
  prefs: []
  type: TYPE_NORMAL
- en: 'The default string storage format is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: The incoming storage format is by default parsed using the Python `datetime.fromisoformat()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 2.0: `datetime.fromisoformat()` is used for default datetime
    string parsing.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The storage format can be customized to some degree using the `storage_format`
    and `regexp` parameters, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`storage_format` – format string which will be applied to the dict with keys
    year, month, day, hour, minute, second, and microsecond.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`regexp` – regular expression which will be applied to incoming result rows,
    replacing the use of `datetime.fromisoformat()` to parse incoming strings. If
    the regexp contains named groups, the resulting match dict is applied to the Python
    datetime() constructor as keyword arguments. Otherwise, if positional groups are
    used, the datetime() constructor is called with positional arguments via `*map(int,
    match_obj.groups(0))`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.sqlite.DATETIME`](#sqlalchemy.dialects.sqlite.DATETIME
    "sqlalchemy.dialects.sqlite.DATETIME") (`sqlalchemy.dialects.sqlite.base._DateTimeMixin`,
    [`sqlalchemy.types.DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime
    "sqlalchemy.types.DateTime"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: Represent a Python date object in SQLite using a string.
  prefs: []
  type: TYPE_NORMAL
- en: 'The default string storage format is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: The incoming storage format is by default parsed using the Python `date.fromisoformat()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 2.0: `date.fromisoformat()` is used for default date string
    parsing.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The storage format can be customized to some degree using the `storage_format`
    and `regexp` parameters, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`storage_format` – format string which will be applied to the dict with keys
    year, month, and day.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`regexp` – regular expression which will be applied to incoming result rows,
    replacing the use of `date.fromisoformat()` to parse incoming strings. If the
    regexp contains named groups, the resulting match dict is applied to the Python
    date() constructor as keyword arguments. Otherwise, if positional groups are used,
    the date() constructor is called with positional arguments via `*map(int, match_obj.groups(0))`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.sqlite.DATE`](#sqlalchemy.dialects.sqlite.DATE "sqlalchemy.dialects.sqlite.DATE")
    (`sqlalchemy.dialects.sqlite.base._DateTimeMixin`, [`sqlalchemy.types.Date`](../core/type_basics.html#sqlalchemy.types.Date
    "sqlalchemy.types.Date"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: SQLite JSON type.
  prefs: []
  type: TYPE_NORMAL
- en: SQLite supports JSON as of version 3.9 through its [JSON1](https://www.sqlite.org/json1.html)
    extension. Note that [JSON1](https://www.sqlite.org/json1.html) is a [loadable
    extension](https://www.sqlite.org/loadext.html) and as such may not be available,
    or may require run-time loading.
  prefs: []
  type: TYPE_NORMAL
- en: '[`JSON`](#sqlalchemy.dialects.sqlite.JSON "sqlalchemy.dialects.sqlite.JSON")
    is used automatically whenever the base [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON") datatype is used against a SQLite backend.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON")
    - main documentation for the generic cross-platform JSON datatype.'
  prefs: []
  type: TYPE_NORMAL
- en: The [`JSON`](#sqlalchemy.dialects.sqlite.JSON "sqlalchemy.dialects.sqlite.JSON")
    type supports persistence of JSON values as well as the core index operations
    provided by [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON")
    datatype, by adapting the operations to render the `JSON_EXTRACT` function wrapped
    in the `JSON_QUOTE` function at the database level. Extracted values are quoted
    in order to ensure that the results are always JSON string values.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.3.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.dialects.sqlite.JSON.__init__)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.sqlite.JSON`](#sqlalchemy.dialects.sqlite.JSON "sqlalchemy.dialects.sqlite.JSON")
    ([`sqlalchemy.types.JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `sqlalchemy.types.JSON.__init__` *method of* [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON")'
  prefs: []
  type: TYPE_NORMAL
- en: Construct a [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON")
    type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**none_as_null=False** –'
  prefs: []
  type: TYPE_NORMAL
- en: 'if True, persist the value `None` as a SQL NULL value, not the JSON encoding
    of `null`. Note that when this flag is False, the [`null()`](../core/sqlelement.html#sqlalchemy.sql.expression.null
    "sqlalchemy.sql.expression.null") construct can still be used to persist a NULL
    value, which may be passed directly as a parameter value that is specially interpreted
    by the [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON")
    type as SQL NULL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '[`JSON.none_as_null`](../core/type_basics.html#sqlalchemy.types.JSON.params.none_as_null
    "sqlalchemy.types.JSON") does **not** apply to the values passed to [`Column.default`](../core/metadata.html#sqlalchemy.schema.Column.params.default
    "sqlalchemy.schema.Column") and [`Column.server_default`](../core/metadata.html#sqlalchemy.schema.Column.params.server_default
    "sqlalchemy.schema.Column"); a value of `None` passed for these parameters means
    “no default present”.'
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, when used in SQL comparison expressions, the Python value `None`
    continues to refer to SQL null, and not JSON NULL. The [`JSON.none_as_null`](../core/type_basics.html#sqlalchemy.types.JSON.params.none_as_null
    "sqlalchemy.types.JSON") flag refers explicitly to the **persistence** of the
    value within an INSERT or UPDATE statement. The [`JSON.NULL`](../core/type_basics.html#sqlalchemy.types.JSON.NULL
    "sqlalchemy.types.JSON.NULL") value should be used for SQL expressions that wish
    to compare to JSON null.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`JSON.NULL`](../core/type_basics.html#sqlalchemy.types.JSON.NULL "sqlalchemy.types.JSON.NULL")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: Represent a Python time object in SQLite using a string.
  prefs: []
  type: TYPE_NORMAL
- en: 'The default string storage format is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: The incoming storage format is by default parsed using the Python `time.fromisoformat()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 2.0: `time.fromisoformat()` is used for default time string
    parsing.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The storage format can be customized to some degree using the `storage_format`
    and `regexp` parameters, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`storage_format` – format string which will be applied to the dict with keys
    hour, minute, second, and microsecond.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`regexp` – regular expression which will be applied to incoming result rows,
    replacing the use of `datetime.fromisoformat()` to parse incoming strings. If
    the regexp contains named groups, the resulting match dict is applied to the Python
    time() constructor as keyword arguments. Otherwise, if positional groups are used,
    the time() constructor is called with positional arguments via `*map(int, match_obj.groups(0))`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.sqlite.TIME`](#sqlalchemy.dialects.sqlite.TIME "sqlalchemy.dialects.sqlite.TIME")
    (`sqlalchemy.dialects.sqlite.base._DateTimeMixin`, [`sqlalchemy.types.Time`](../core/type_basics.html#sqlalchemy.types.Time
    "sqlalchemy.types.Time"))
  prefs: []
  type: TYPE_NORMAL
- en: SQLite DML Constructs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '| Object Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| [insert](#sqlalchemy.dialects.sqlite.insert)(table) | Construct a sqlite-specific
    variant [`Insert`](#sqlalchemy.dialects.sqlite.Insert "sqlalchemy.dialects.sqlite.Insert")
    construct. |'
  prefs: []
  type: TYPE_TB
- en: '| [Insert](#sqlalchemy.dialects.sqlite.Insert) | SQLite-specific implementation
    of INSERT. |'
  prefs: []
  type: TYPE_TB
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: Construct a sqlite-specific variant [`Insert`](#sqlalchemy.dialects.sqlite.Insert
    "sqlalchemy.dialects.sqlite.Insert") construct.
  prefs: []
  type: TYPE_NORMAL
- en: The [`sqlalchemy.dialects.sqlite.insert()`](#sqlalchemy.dialects.sqlite.insert
    "sqlalchemy.dialects.sqlite.insert") function creates a [`sqlalchemy.dialects.sqlite.Insert`](#sqlalchemy.dialects.sqlite.Insert
    "sqlalchemy.dialects.sqlite.Insert"). This class is based on the dialect-agnostic
    [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert "sqlalchemy.sql.expression.Insert")
    construct which may be constructed using the [`insert()`](../core/dml.html#sqlalchemy.sql.expression.insert
    "sqlalchemy.sql.expression.insert") function in SQLAlchemy Core.
  prefs: []
  type: TYPE_NORMAL
- en: The [`Insert`](#sqlalchemy.dialects.sqlite.Insert "sqlalchemy.dialects.sqlite.Insert")
    construct includes additional methods [`Insert.on_conflict_do_update()`](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update
    "sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update"), [`Insert.on_conflict_do_nothing()`](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_nothing
    "sqlalchemy.dialects.sqlite.Insert.on_conflict_do_nothing").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: SQLite-specific implementation of INSERT.
  prefs: []
  type: TYPE_NORMAL
- en: Adds methods for SQLite-specific syntaxes such as ON CONFLICT.
  prefs: []
  type: TYPE_NORMAL
- en: The [`Insert`](#sqlalchemy.dialects.sqlite.Insert "sqlalchemy.dialects.sqlite.Insert")
    object is created using the [`sqlalchemy.dialects.sqlite.insert()`](#sqlalchemy.dialects.sqlite.insert
    "sqlalchemy.dialects.sqlite.insert") function.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.4.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[INSERT…ON CONFLICT (Upsert)](#sqlite-on-conflict-insert)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[excluded](#sqlalchemy.dialects.sqlite.Insert.excluded), [inherit_cache](#sqlalchemy.dialects.sqlite.Insert.inherit_cache),
    [on_conflict_do_nothing()](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_nothing),
    [on_conflict_do_update()](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.sqlite.Insert`](#sqlalchemy.dialects.sqlite.Insert
    "sqlalchemy.dialects.sqlite.Insert") ([`sqlalchemy.sql.expression.Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: Provide the `excluded` namespace for an ON CONFLICT statement
  prefs: []
  type: TYPE_NORMAL
- en: SQLite’s ON CONFLICT clause allows reference to the row that would be inserted,
    known as `excluded`. This attribute provides all columns in this row to be referenceable.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: The [`Insert.excluded`](#sqlalchemy.dialects.sqlite.Insert.excluded "sqlalchemy.dialects.sqlite.Insert.excluded")
    attribute is an instance of [`ColumnCollection`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnCollection
    "sqlalchemy.sql.expression.ColumnCollection"), which provides an interface the
    same as that of the [`Table.c`](../core/metadata.html#sqlalchemy.schema.Table.c
    "sqlalchemy.schema.Table.c") collection described at [Accessing Tables and Columns](../core/metadata.html#metadata-tables-and-columns).
    With this collection, ordinary names are accessible like attributes (e.g. `stmt.excluded.some_column`),
    but special names and dictionary method names should be accessed using indexed
    access, such as `stmt.excluded["column name"]` or `stmt.excluded["values"]`. See
    the docstring for [`ColumnCollection`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnCollection
    "sqlalchemy.sql.expression.ColumnCollection") for further examples.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: Indicate if this [`HasCacheKey`](../core/foundation.html#sqlalchemy.sql.traversals.HasCacheKey
    "sqlalchemy.sql.traversals.HasCacheKey") instance should make use of the cache
    key generation scheme used by its immediate superclass.
  prefs: []
  type: TYPE_NORMAL
- en: The attribute defaults to `None`, which indicates that a construct has not yet
    taken into account whether or not its appropriate for it to participate in caching;
    this is functionally equivalent to setting the value to `False`, except that a
    warning is also emitted.
  prefs: []
  type: TYPE_NORMAL
- en: This flag can be set to `True` on a particular class, if the SQL that corresponds
    to the object does not change based on attributes which are local to this class,
    and not its superclass.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Enabling Caching Support for Custom Constructs](../core/compiler.html#compilerext-caching)
    - General guideslines for setting the [`HasCacheKey.inherit_cache`](../core/foundation.html#sqlalchemy.sql.traversals.HasCacheKey.inherit_cache
    "sqlalchemy.sql.traversals.HasCacheKey.inherit_cache") attribute for third-party
    or user defined SQL constructs.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: Specifies a DO NOTHING action for ON CONFLICT clause.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`index_elements` – A sequence consisting of string column names, [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects, or other column expression objects that will
    be used to infer a target index or unique constraint.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`index_where` – Additional WHERE criterion that can be used to infer a conditional
    target index.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: Specifies a DO UPDATE SET action for ON CONFLICT clause.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`index_elements` – A sequence consisting of string column names, [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects, or other column expression objects that will
    be used to infer a target index or unique constraint.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`index_where` – Additional WHERE criterion that can be used to infer a conditional
    target index.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`set_` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A dictionary or other mapping object where the keys are either names of columns
    in the target table, or [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects or other ORM-mapped columns matching that
    of the target table, and expressions or literals as values, specifying the `SET`
    actions to take.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'New in version 1.4: The [`Insert.on_conflict_do_update.set_`](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update.params.set_
    "sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update") parameter supports
    [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    objects from the target [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") as keys.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This dictionary does **not** take into account Python-specified default UPDATE
    values or generation functions, e.g. those specified using [`Column.onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.onupdate
    "sqlalchemy.schema.Column"). These values will not be exercised for an ON CONFLICT
    style of UPDATE, unless they are manually specified in the [`Insert.on_conflict_do_update.set_`](#sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update.params.set_
    "sqlalchemy.dialects.sqlite.Insert.on_conflict_do_update") dictionary.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`where` – Optional argument. If present, can be a literal SQL string or an
    acceptable expression for a `WHERE` clause that restricts the rows affected by
    `DO UPDATE SET`. Rows not meeting the `WHERE` condition will not be updated (effectively
    a `DO NOTHING` for those rows).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '## Pysqlite'
  prefs: []
  type: TYPE_NORMAL
- en: Support for the SQLite database via the pysqlite driver.
  prefs: []
  type: TYPE_NORMAL
- en: Note that `pysqlite` is the same driver as the `sqlite3` module included with
    the Python distribution.
  prefs: []
  type: TYPE_NORMAL
- en: DBAPI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Documentation and download information (if applicable) for pysqlite is available
    at: [https://docs.python.org/library/sqlite3.html](https://docs.python.org/library/sqlite3.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Connecting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Connect String:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: Driver
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `sqlite3` Python DBAPI is standard on all modern Python versions; for cPython
    and Pypy, no additional installation is necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Connect Strings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The file specification for the SQLite database is taken as the “database” portion
    of the URL. Note that the format of a SQLAlchemy url is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that the actual filename to be used starts with the characters to
    the **right** of the third slash. So connecting to a relative filepath looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: 'An absolute path, which is denoted by starting with a slash, means you need
    **four** slashes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: 'To use a Windows path, regular drive specifications and backslashes can be
    used. Double backslashes are probably needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: 'To use sqlite `:memory:` database specify it as the filename using `sqlite://:memory:`.
    It’s also the default if no filepath is present, specifying only `sqlite://` and
    nothing else:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: '#### URI Connections'
  prefs: []
  type: TYPE_NORMAL
- en: 'Modern versions of SQLite support an alternative system of connecting using
    a [driver level URI](https://www.sqlite.org/uri.html), which has the advantage
    that additional driver-level arguments can be passed including options such as
    “read only”. The Python sqlite3 driver supports this mode under modern Python
    3 versions. The SQLAlchemy pysqlite driver supports this mode of use by specifying
    “uri=true” in the URL query string. The SQLite-level “URI” is kept as the “database”
    portion of the SQLAlchemy url (that is, following a slash):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The “uri=true” parameter must appear in the **query string** of the URL. It
    will not currently work as expected if it is only present in the [`create_engine.connect_args`](../core/engines.html#sqlalchemy.create_engine.params.connect_args
    "sqlalchemy.create_engine") parameter dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: 'The logic reconciles the simultaneous presence of SQLAlchemy’s query string
    and SQLite’s query string by separating out the parameters that belong to the
    Python sqlite3 driver vs. those that belong to the SQLite URI. This is achieved
    through the use of a fixed list of parameters known to be accepted by the Python
    side of the driver. For example, to include a URL that indicates the Python sqlite3
    “timeout” and “check_same_thread” parameters, along with the SQLite “mode” and
    “nolock” parameters, they can all be passed together on the query string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: 'Above, the pysqlite / sqlite3 DBAPI would be passed arguments as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: Regarding future parameters added to either the Python or native drivers. new
    parameter names added to the SQLite URI scheme should be automatically accommodated
    by this scheme. New parameter names added to the Python driver side can be accommodated
    by specifying them in the [`create_engine.connect_args`](../core/engines.html#sqlalchemy.create_engine.params.connect_args
    "sqlalchemy.create_engine") dictionary, until dialect support is added by SQLAlchemy.
    For the less likely case that the native SQLite driver adds a new parameter name
    that overlaps with one of the existing, known Python driver parameters (such as
    “timeout” perhaps), SQLAlchemy’s dialect would require adjustment for the URL
    scheme to continue to support this.
  prefs: []
  type: TYPE_NORMAL
- en: As is always the case for all SQLAlchemy dialects, the entire “URL” process
    can be bypassed in [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") through the use of the [`create_engine.creator`](../core/engines.html#sqlalchemy.create_engine.params.creator
    "sqlalchemy.create_engine") parameter which allows for a custom callable that
    creates a Python sqlite3 driver level connection directly.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.3.9.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Uniform Resource Identifiers](https://www.sqlite.org/uri.html) - in the SQLite
    documentation  ### Regular Expression Support'
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.4.
  prefs: []
  type: TYPE_NORMAL
- en: Support for the [`ColumnOperators.regexp_match()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.regexp_match
    "sqlalchemy.sql.expression.ColumnOperators.regexp_match") operator is provided
    using Python’s [re.search](https://docs.python.org/3/library/re.html#re.search)
    function. SQLite itself does not include a working regular expression operator;
    instead, it includes a non-implemented placeholder operator `REGEXP` that calls
    a user-defined function that must be provided.
  prefs: []
  type: TYPE_NORMAL
- en: 'SQLAlchemy’s implementation makes use of the pysqlite [create_function](https://docs.python.org/3/library/sqlite3.html#sqlite3.Connection.create_function)
    hook as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: There is currently no support for regular expression flags as a separate argument,
    as these are not supported by SQLite’s REGEXP operator, however these may be included
    inline within the regular expression string. See [Python regular expressions](https://docs.python.org/3/library/re.html#re.search)
    for details.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Python regular expressions](https://docs.python.org/3/library/re.html#re.search):
    Documentation for Python’s regular expression syntax.'
  prefs: []
  type: TYPE_NORMAL
- en: Compatibility with sqlite3 “native” date and datetime types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The pysqlite driver includes the sqlite3.PARSE_DECLTYPES and sqlite3.PARSE_COLNAMES
    options, which have the effect of any column or expression explicitly cast as
    “date” or “timestamp” will be converted to a Python date or datetime object. The
    date and datetime types provided with the pysqlite dialect are not currently compatible
    with these options, since they render the ISO date/datetime including microseconds,
    which pysqlite’s driver does not. Additionally, SQLAlchemy does not at this time
    automatically render the “cast” syntax required for the freestanding functions
    “current_timestamp” and “current_date” to return datetime/date types natively.
    Unfortunately, pysqlite does not provide the standard DBAPI types in `cursor.description`,
    leaving SQLAlchemy with no way to detect these types on the fly without expensive
    per-row type checks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Keeping in mind that pysqlite’s parsing option is not recommended, nor should
    be necessary, for use with SQLAlchemy, usage of PARSE_DECLTYPES can be forced
    if one configures “native_datetime=True” on create_engine():'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: With this flag enabled, the DATE and TIMESTAMP types (but note - not the DATETIME
    or TIME types…confused yet ?) will not perform any bind parameter or result processing.
    Execution of “func.current_date()” will return a string. “func.current_timestamp()”
    is registered as returning a DATETIME type in SQLAlchemy, so this function still
    receives SQLAlchemy-level result processing.
  prefs: []
  type: TYPE_NORMAL
- en: '### Threading/Pooling Behavior'
  prefs: []
  type: TYPE_NORMAL
- en: The `sqlite3` DBAPI by default prohibits the use of a particular connection
    in a thread which is not the one in which it was created. As SQLite has matured,
    it’s behavior under multiple threads has improved, and even includes options for
    memory only databases to be used in multiple threads.
  prefs: []
  type: TYPE_NORMAL
- en: The thread prohibition is known as “check same thread” and may be controlled
    using the `sqlite3` parameter `check_same_thread`, which will disable or enable
    this check. SQLAlchemy’s default behavior here is to set `check_same_thread` to
    `False` automatically whenever a file-based database is in use, to establish compatibility
    with the default pool class [`QueuePool`](../core/pooling.html#sqlalchemy.pool.QueuePool
    "sqlalchemy.pool.QueuePool").
  prefs: []
  type: TYPE_NORMAL
- en: 'The SQLAlchemy `pysqlite` DBAPI establishes the connection pool differently
    based on the kind of SQLite database that’s requested:'
  prefs: []
  type: TYPE_NORMAL
- en: When a `:memory:` SQLite database is specified, the dialect by default will
    use [`SingletonThreadPool`](../core/pooling.html#sqlalchemy.pool.SingletonThreadPool
    "sqlalchemy.pool.SingletonThreadPool"). This pool maintains a single connection
    per thread, so that all access to the engine within the current thread use the
    same `:memory:` database - other threads would access a different `:memory:` database.
    The `check_same_thread` parameter defaults to `True`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a file-based database is specified, the dialect will use [`QueuePool`](../core/pooling.html#sqlalchemy.pool.QueuePool
    "sqlalchemy.pool.QueuePool") as the source of connections. at the same time, the
    `check_same_thread` flag is set to False by default unless overridden.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Changed in version 2.0: SQLite file database engines now use [`QueuePool`](../core/pooling.html#sqlalchemy.pool.QueuePool
    "sqlalchemy.pool.QueuePool") by default. Previously, [`NullPool`](../core/pooling.html#sqlalchemy.pool.NullPool
    "sqlalchemy.pool.NullPool") were used. The [`NullPool`](../core/pooling.html#sqlalchemy.pool.NullPool
    "sqlalchemy.pool.NullPool") class may be used by specifying it via the [`create_engine.poolclass`](../core/engines.html#sqlalchemy.create_engine.params.poolclass
    "sqlalchemy.create_engine") parameter.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Disabling Connection Pooling for File Databases
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Pooling may be disabled for a file based database by specifying the [`NullPool`](../core/pooling.html#sqlalchemy.pool.NullPool
    "sqlalchemy.pool.NullPool") implementation for the `poolclass()` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: It’s been observed that the [`NullPool`](../core/pooling.html#sqlalchemy.pool.NullPool
    "sqlalchemy.pool.NullPool") implementation incurs an extremely small performance
    overhead for repeated checkouts due to the lack of connection re-use implemented
    by [`QueuePool`](../core/pooling.html#sqlalchemy.pool.QueuePool "sqlalchemy.pool.QueuePool").
    However, it still may be beneficial to use this class if the application is experiencing
    issues with files being locked.
  prefs: []
  type: TYPE_NORMAL
- en: Using a Memory Database in Multiple Threads
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a `:memory:` database in a multithreaded scenario, the same connection
    object must be shared among threads, since the database exists only within the
    scope of that connection. The [`StaticPool`](../core/pooling.html#sqlalchemy.pool.StaticPool
    "sqlalchemy.pool.StaticPool") implementation will maintain a single connection
    globally, and the `check_same_thread` flag can be passed to Pysqlite as `False`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: Note that using a `:memory:` database in multiple threads requires a recent
    version of SQLite.
  prefs: []
  type: TYPE_NORMAL
- en: Using Temporary Tables with SQLite
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Due to the way SQLite deals with temporary tables, if you wish to use a temporary
    table in a file-based SQLite database across multiple checkouts from the connection
    pool, such as when using an ORM [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") where the temporary table should continue to remain
    after [`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") or [`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") is called, a pool which maintains a single
    connection must be used. Use [`SingletonThreadPool`](../core/pooling.html#sqlalchemy.pool.SingletonThreadPool
    "sqlalchemy.pool.SingletonThreadPool") if the scope is only needed within the
    current thread, or [`StaticPool`](../core/pooling.html#sqlalchemy.pool.StaticPool
    "sqlalchemy.pool.StaticPool") is scope is needed within multiple threads for this
    case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: Note that [`SingletonThreadPool`](../core/pooling.html#sqlalchemy.pool.SingletonThreadPool
    "sqlalchemy.pool.SingletonThreadPool") should be configured for the number of
    threads that are to be used; beyond that number, connections will be closed out
    in a non deterministic way.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with Mixed String / Binary Columns
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The SQLite database is weakly typed, and as such it is possible when using binary
    values, which in Python are represented as `b'some string'`, that a particular
    SQLite database can have data values within different rows where some of them
    will be returned as a `b''` value by the Pysqlite driver, and others will be returned
    as Python strings, e.g. `''` values. This situation is not known to occur if the
    SQLAlchemy [`LargeBinary`](../core/type_basics.html#sqlalchemy.types.LargeBinary
    "sqlalchemy.types.LargeBinary") datatype is used consistently, however if a particular
    SQLite database has data that was inserted using the Pysqlite driver directly,
    or when using the SQLAlchemy [`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String") type which was later changed to [`LargeBinary`](../core/type_basics.html#sqlalchemy.types.LargeBinary
    "sqlalchemy.types.LargeBinary"), the table will not be consistently readable because
    SQLAlchemy’s [`LargeBinary`](../core/type_basics.html#sqlalchemy.types.LargeBinary
    "sqlalchemy.types.LargeBinary") datatype does not handle strings so it has no
    way of “encoding” a value that is in string format.
  prefs: []
  type: TYPE_NORMAL
- en: 'To deal with a SQLite table that has mixed string / binary data in the same
    column, use a custom type that will check each row individually:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: Then use the above `MixedBinary` datatype in the place where [`LargeBinary`](../core/type_basics.html#sqlalchemy.types.LargeBinary
    "sqlalchemy.types.LargeBinary") would normally be used.
  prefs: []
  type: TYPE_NORMAL
- en: '### Serializable isolation / Savepoints / Transactional DDL'
  prefs: []
  type: TYPE_NORMAL
- en: In the section [Database Locking Behavior / Concurrency](#sqlite-concurrency),
    we refer to the pysqlite driver’s assortment of issues that prevent several features
    of SQLite from working correctly. The pysqlite DBAPI driver has several long-standing
    bugs which impact the correctness of its transactional behavior. In its default
    mode of operation, SQLite features such as SERIALIZABLE isolation, transactional
    DDL, and SAVEPOINT support are non-functional, and in order to use these features,
    workarounds must be taken.
  prefs: []
  type: TYPE_NORMAL
- en: The issue is essentially that the driver attempts to second-guess the user’s
    intent, failing to start transactions and sometimes ending them prematurely, in
    an effort to minimize the SQLite databases’s file locking behavior, even though
    SQLite itself uses “shared” locks for read-only activities.
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy chooses to not alter this behavior by default, as it is the long-expected
    behavior of the pysqlite driver; if and when the pysqlite driver attempts to repair
    these issues, that will be more of a driver towards defaults for SQLAlchemy.
  prefs: []
  type: TYPE_NORMAL
- en: 'The good news is that with a few events, we can implement transactional support
    fully, by disabling pysqlite’s feature entirely and emitting BEGIN ourselves.
    This is achieved using two event listeners:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: When using the above recipe, it is advised to not use the [`Connection.execution_options.isolation_level`](../core/connections.html#sqlalchemy.engine.Connection.execution_options.params.isolation_level
    "sqlalchemy.engine.Connection.execution_options") setting on [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") and [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") with the SQLite driver, as this function necessarily
    will also alter the “.isolation_level” setting.
  prefs: []
  type: TYPE_NORMAL
- en: Above, we intercept a new pysqlite connection and disable any transactional
    integration. Then, at the point at which SQLAlchemy knows that transaction scope
    is to begin, we emit `"BEGIN"` ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we take control of `"BEGIN"`, we can also control directly SQLite’s locking
    modes, introduced at [BEGIN TRANSACTION](https://sqlite.org/lang_transaction.html),
    by adding the desired locking mode to our `"BEGIN"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[BEGIN TRANSACTION](https://sqlite.org/lang_transaction.html) - on the SQLite
    site'
  prefs: []
  type: TYPE_NORMAL
- en: '[sqlite3 SELECT does not BEGIN a transaction](https://bugs.python.org/issue9924)
    - on the Python bug tracker'
  prefs: []
  type: TYPE_NORMAL
- en: '[sqlite3 module breaks transactions and potentially corrupts data](https://bugs.python.org/issue10740)
    - on the Python bug tracker  ### User-Defined Functions'
  prefs: []
  type: TYPE_NORMAL
- en: pysqlite supports a [create_function()](https://docs.python.org/3/library/sqlite3.html#sqlite3.Connection.create_function)
    method that allows us to create our own user-defined functions (UDFs) in Python
    and use them directly in SQLite queries. These functions are registered with a
    specific DBAPI Connection.
  prefs: []
  type: TYPE_NORMAL
- en: 'SQLAlchemy uses connection pooling with file-based SQLite databases, so we
    need to ensure that the UDF is attached to the connection when it is created.
    That is accomplished with an event listener:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: DBAPI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Documentation and download information (if applicable) for pysqlite is available
    at: [https://docs.python.org/library/sqlite3.html](https://docs.python.org/library/sqlite3.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Connecting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Connect String:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: Driver
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `sqlite3` Python DBAPI is standard on all modern Python versions; for cPython
    and Pypy, no additional installation is necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Connect Strings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The file specification for the SQLite database is taken as the “database” portion
    of the URL. Note that the format of a SQLAlchemy url is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that the actual filename to be used starts with the characters to
    the **right** of the third slash. So connecting to a relative filepath looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: 'An absolute path, which is denoted by starting with a slash, means you need
    **four** slashes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: 'To use a Windows path, regular drive specifications and backslashes can be
    used. Double backslashes are probably needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: 'To use sqlite `:memory:` database specify it as the filename using `sqlite://:memory:`.
    It’s also the default if no filepath is present, specifying only `sqlite://` and
    nothing else:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: '#### URI Connections'
  prefs: []
  type: TYPE_NORMAL
- en: 'Modern versions of SQLite support an alternative system of connecting using
    a [driver level URI](https://www.sqlite.org/uri.html), which has the advantage
    that additional driver-level arguments can be passed including options such as
    “read only”. The Python sqlite3 driver supports this mode under modern Python
    3 versions. The SQLAlchemy pysqlite driver supports this mode of use by specifying
    “uri=true” in the URL query string. The SQLite-level “URI” is kept as the “database”
    portion of the SQLAlchemy url (that is, following a slash):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The “uri=true” parameter must appear in the **query string** of the URL. It
    will not currently work as expected if it is only present in the [`create_engine.connect_args`](../core/engines.html#sqlalchemy.create_engine.params.connect_args
    "sqlalchemy.create_engine") parameter dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: 'The logic reconciles the simultaneous presence of SQLAlchemy’s query string
    and SQLite’s query string by separating out the parameters that belong to the
    Python sqlite3 driver vs. those that belong to the SQLite URI. This is achieved
    through the use of a fixed list of parameters known to be accepted by the Python
    side of the driver. For example, to include a URL that indicates the Python sqlite3
    “timeout” and “check_same_thread” parameters, along with the SQLite “mode” and
    “nolock” parameters, they can all be passed together on the query string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: 'Above, the pysqlite / sqlite3 DBAPI would be passed arguments as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: Regarding future parameters added to either the Python or native drivers. new
    parameter names added to the SQLite URI scheme should be automatically accommodated
    by this scheme. New parameter names added to the Python driver side can be accommodated
    by specifying them in the [`create_engine.connect_args`](../core/engines.html#sqlalchemy.create_engine.params.connect_args
    "sqlalchemy.create_engine") dictionary, until dialect support is added by SQLAlchemy.
    For the less likely case that the native SQLite driver adds a new parameter name
    that overlaps with one of the existing, known Python driver parameters (such as
    “timeout” perhaps), SQLAlchemy’s dialect would require adjustment for the URL
    scheme to continue to support this.
  prefs: []
  type: TYPE_NORMAL
- en: As is always the case for all SQLAlchemy dialects, the entire “URL” process
    can be bypassed in [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") through the use of the [`create_engine.creator`](../core/engines.html#sqlalchemy.create_engine.params.creator
    "sqlalchemy.create_engine") parameter which allows for a custom callable that
    creates a Python sqlite3 driver level connection directly.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.3.9.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Uniform Resource Identifiers](https://www.sqlite.org/uri.html) - in the SQLite
    documentation  #### URI Connections'
  prefs: []
  type: TYPE_NORMAL
- en: 'Modern versions of SQLite support an alternative system of connecting using
    a [driver level URI](https://www.sqlite.org/uri.html), which has the advantage
    that additional driver-level arguments can be passed including options such as
    “read only”. The Python sqlite3 driver supports this mode under modern Python
    3 versions. The SQLAlchemy pysqlite driver supports this mode of use by specifying
    “uri=true” in the URL query string. The SQLite-level “URI” is kept as the “database”
    portion of the SQLAlchemy url (that is, following a slash):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The “uri=true” parameter must appear in the **query string** of the URL. It
    will not currently work as expected if it is only present in the [`create_engine.connect_args`](../core/engines.html#sqlalchemy.create_engine.params.connect_args
    "sqlalchemy.create_engine") parameter dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: 'The logic reconciles the simultaneous presence of SQLAlchemy’s query string
    and SQLite’s query string by separating out the parameters that belong to the
    Python sqlite3 driver vs. those that belong to the SQLite URI. This is achieved
    through the use of a fixed list of parameters known to be accepted by the Python
    side of the driver. For example, to include a URL that indicates the Python sqlite3
    “timeout” and “check_same_thread” parameters, along with the SQLite “mode” and
    “nolock” parameters, they can all be passed together on the query string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: 'Above, the pysqlite / sqlite3 DBAPI would be passed arguments as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: Regarding future parameters added to either the Python or native drivers. new
    parameter names added to the SQLite URI scheme should be automatically accommodated
    by this scheme. New parameter names added to the Python driver side can be accommodated
    by specifying them in the [`create_engine.connect_args`](../core/engines.html#sqlalchemy.create_engine.params.connect_args
    "sqlalchemy.create_engine") dictionary, until dialect support is added by SQLAlchemy.
    For the less likely case that the native SQLite driver adds a new parameter name
    that overlaps with one of the existing, known Python driver parameters (such as
    “timeout” perhaps), SQLAlchemy’s dialect would require adjustment for the URL
    scheme to continue to support this.
  prefs: []
  type: TYPE_NORMAL
- en: As is always the case for all SQLAlchemy dialects, the entire “URL” process
    can be bypassed in [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") through the use of the [`create_engine.creator`](../core/engines.html#sqlalchemy.create_engine.params.creator
    "sqlalchemy.create_engine") parameter which allows for a custom callable that
    creates a Python sqlite3 driver level connection directly.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.3.9.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Uniform Resource Identifiers](https://www.sqlite.org/uri.html) - in the SQLite
    documentation'
  prefs: []
  type: TYPE_NORMAL
- en: '### Regular Expression Support'
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.4.
  prefs: []
  type: TYPE_NORMAL
- en: Support for the [`ColumnOperators.regexp_match()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.regexp_match
    "sqlalchemy.sql.expression.ColumnOperators.regexp_match") operator is provided
    using Python’s [re.search](https://docs.python.org/3/library/re.html#re.search)
    function. SQLite itself does not include a working regular expression operator;
    instead, it includes a non-implemented placeholder operator `REGEXP` that calls
    a user-defined function that must be provided.
  prefs: []
  type: TYPE_NORMAL
- en: 'SQLAlchemy’s implementation makes use of the pysqlite [create_function](https://docs.python.org/3/library/sqlite3.html#sqlite3.Connection.create_function)
    hook as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: There is currently no support for regular expression flags as a separate argument,
    as these are not supported by SQLite’s REGEXP operator, however these may be included
    inline within the regular expression string. See [Python regular expressions](https://docs.python.org/3/library/re.html#re.search)
    for details.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Python regular expressions](https://docs.python.org/3/library/re.html#re.search):
    Documentation for Python’s regular expression syntax.'
  prefs: []
  type: TYPE_NORMAL
- en: Compatibility with sqlite3 “native” date and datetime types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The pysqlite driver includes the sqlite3.PARSE_DECLTYPES and sqlite3.PARSE_COLNAMES
    options, which have the effect of any column or expression explicitly cast as
    “date” or “timestamp” will be converted to a Python date or datetime object. The
    date and datetime types provided with the pysqlite dialect are not currently compatible
    with these options, since they render the ISO date/datetime including microseconds,
    which pysqlite’s driver does not. Additionally, SQLAlchemy does not at this time
    automatically render the “cast” syntax required for the freestanding functions
    “current_timestamp” and “current_date” to return datetime/date types natively.
    Unfortunately, pysqlite does not provide the standard DBAPI types in `cursor.description`,
    leaving SQLAlchemy with no way to detect these types on the fly without expensive
    per-row type checks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Keeping in mind that pysqlite’s parsing option is not recommended, nor should
    be necessary, for use with SQLAlchemy, usage of PARSE_DECLTYPES can be forced
    if one configures “native_datetime=True” on create_engine():'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: With this flag enabled, the DATE and TIMESTAMP types (but note - not the DATETIME
    or TIME types…confused yet ?) will not perform any bind parameter or result processing.
    Execution of “func.current_date()” will return a string. “func.current_timestamp()”
    is registered as returning a DATETIME type in SQLAlchemy, so this function still
    receives SQLAlchemy-level result processing.
  prefs: []
  type: TYPE_NORMAL
- en: '### Threading/Pooling Behavior'
  prefs: []
  type: TYPE_NORMAL
- en: The `sqlite3` DBAPI by default prohibits the use of a particular connection
    in a thread which is not the one in which it was created. As SQLite has matured,
    it’s behavior under multiple threads has improved, and even includes options for
    memory only databases to be used in multiple threads.
  prefs: []
  type: TYPE_NORMAL
- en: The thread prohibition is known as “check same thread” and may be controlled
    using the `sqlite3` parameter `check_same_thread`, which will disable or enable
    this check. SQLAlchemy’s default behavior here is to set `check_same_thread` to
    `False` automatically whenever a file-based database is in use, to establish compatibility
    with the default pool class [`QueuePool`](../core/pooling.html#sqlalchemy.pool.QueuePool
    "sqlalchemy.pool.QueuePool").
  prefs: []
  type: TYPE_NORMAL
- en: 'The SQLAlchemy `pysqlite` DBAPI establishes the connection pool differently
    based on the kind of SQLite database that’s requested:'
  prefs: []
  type: TYPE_NORMAL
- en: When a `:memory:` SQLite database is specified, the dialect by default will
    use [`SingletonThreadPool`](../core/pooling.html#sqlalchemy.pool.SingletonThreadPool
    "sqlalchemy.pool.SingletonThreadPool"). This pool maintains a single connection
    per thread, so that all access to the engine within the current thread use the
    same `:memory:` database - other threads would access a different `:memory:` database.
    The `check_same_thread` parameter defaults to `True`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a file-based database is specified, the dialect will use [`QueuePool`](../core/pooling.html#sqlalchemy.pool.QueuePool
    "sqlalchemy.pool.QueuePool") as the source of connections. at the same time, the
    `check_same_thread` flag is set to False by default unless overridden.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Changed in version 2.0: SQLite file database engines now use [`QueuePool`](../core/pooling.html#sqlalchemy.pool.QueuePool
    "sqlalchemy.pool.QueuePool") by default. Previously, [`NullPool`](../core/pooling.html#sqlalchemy.pool.NullPool
    "sqlalchemy.pool.NullPool") were used. The [`NullPool`](../core/pooling.html#sqlalchemy.pool.NullPool
    "sqlalchemy.pool.NullPool") class may be used by specifying it via the [`create_engine.poolclass`](../core/engines.html#sqlalchemy.create_engine.params.poolclass
    "sqlalchemy.create_engine") parameter.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Disabling Connection Pooling for File Databases
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Pooling may be disabled for a file based database by specifying the [`NullPool`](../core/pooling.html#sqlalchemy.pool.NullPool
    "sqlalchemy.pool.NullPool") implementation for the `poolclass()` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: It’s been observed that the [`NullPool`](../core/pooling.html#sqlalchemy.pool.NullPool
    "sqlalchemy.pool.NullPool") implementation incurs an extremely small performance
    overhead for repeated checkouts due to the lack of connection re-use implemented
    by [`QueuePool`](../core/pooling.html#sqlalchemy.pool.QueuePool "sqlalchemy.pool.QueuePool").
    However, it still may be beneficial to use this class if the application is experiencing
    issues with files being locked.
  prefs: []
  type: TYPE_NORMAL
- en: Using a Memory Database in Multiple Threads
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a `:memory:` database in a multithreaded scenario, the same connection
    object must be shared among threads, since the database exists only within the
    scope of that connection. The [`StaticPool`](../core/pooling.html#sqlalchemy.pool.StaticPool
    "sqlalchemy.pool.StaticPool") implementation will maintain a single connection
    globally, and the `check_same_thread` flag can be passed to Pysqlite as `False`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: Note that using a `:memory:` database in multiple threads requires a recent
    version of SQLite.
  prefs: []
  type: TYPE_NORMAL
- en: Using Temporary Tables with SQLite
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Due to the way SQLite deals with temporary tables, if you wish to use a temporary
    table in a file-based SQLite database across multiple checkouts from the connection
    pool, such as when using an ORM [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") where the temporary table should continue to remain
    after [`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") or [`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") is called, a pool which maintains a single
    connection must be used. Use [`SingletonThreadPool`](../core/pooling.html#sqlalchemy.pool.SingletonThreadPool
    "sqlalchemy.pool.SingletonThreadPool") if the scope is only needed within the
    current thread, or [`StaticPool`](../core/pooling.html#sqlalchemy.pool.StaticPool
    "sqlalchemy.pool.StaticPool") is scope is needed within multiple threads for this
    case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: Note that [`SingletonThreadPool`](../core/pooling.html#sqlalchemy.pool.SingletonThreadPool
    "sqlalchemy.pool.SingletonThreadPool") should be configured for the number of
    threads that are to be used; beyond that number, connections will be closed out
    in a non deterministic way.
  prefs: []
  type: TYPE_NORMAL
- en: Disabling Connection Pooling for File Databases
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Pooling may be disabled for a file based database by specifying the [`NullPool`](../core/pooling.html#sqlalchemy.pool.NullPool
    "sqlalchemy.pool.NullPool") implementation for the `poolclass()` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: It’s been observed that the [`NullPool`](../core/pooling.html#sqlalchemy.pool.NullPool
    "sqlalchemy.pool.NullPool") implementation incurs an extremely small performance
    overhead for repeated checkouts due to the lack of connection re-use implemented
    by [`QueuePool`](../core/pooling.html#sqlalchemy.pool.QueuePool "sqlalchemy.pool.QueuePool").
    However, it still may be beneficial to use this class if the application is experiencing
    issues with files being locked.
  prefs: []
  type: TYPE_NORMAL
- en: Using a Memory Database in Multiple Threads
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To use a `:memory:` database in a multithreaded scenario, the same connection
    object must be shared among threads, since the database exists only within the
    scope of that connection. The [`StaticPool`](../core/pooling.html#sqlalchemy.pool.StaticPool
    "sqlalchemy.pool.StaticPool") implementation will maintain a single connection
    globally, and the `check_same_thread` flag can be passed to Pysqlite as `False`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: Note that using a `:memory:` database in multiple threads requires a recent
    version of SQLite.
  prefs: []
  type: TYPE_NORMAL
- en: Using Temporary Tables with SQLite
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Due to the way SQLite deals with temporary tables, if you wish to use a temporary
    table in a file-based SQLite database across multiple checkouts from the connection
    pool, such as when using an ORM [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") where the temporary table should continue to remain
    after [`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") or [`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") is called, a pool which maintains a single
    connection must be used. Use [`SingletonThreadPool`](../core/pooling.html#sqlalchemy.pool.SingletonThreadPool
    "sqlalchemy.pool.SingletonThreadPool") if the scope is only needed within the
    current thread, or [`StaticPool`](../core/pooling.html#sqlalchemy.pool.StaticPool
    "sqlalchemy.pool.StaticPool") is scope is needed within multiple threads for this
    case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: Note that [`SingletonThreadPool`](../core/pooling.html#sqlalchemy.pool.SingletonThreadPool
    "sqlalchemy.pool.SingletonThreadPool") should be configured for the number of
    threads that are to be used; beyond that number, connections will be closed out
    in a non deterministic way.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with Mixed String / Binary Columns
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The SQLite database is weakly typed, and as such it is possible when using binary
    values, which in Python are represented as `b'some string'`, that a particular
    SQLite database can have data values within different rows where some of them
    will be returned as a `b''` value by the Pysqlite driver, and others will be returned
    as Python strings, e.g. `''` values. This situation is not known to occur if the
    SQLAlchemy [`LargeBinary`](../core/type_basics.html#sqlalchemy.types.LargeBinary
    "sqlalchemy.types.LargeBinary") datatype is used consistently, however if a particular
    SQLite database has data that was inserted using the Pysqlite driver directly,
    or when using the SQLAlchemy [`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String") type which was later changed to [`LargeBinary`](../core/type_basics.html#sqlalchemy.types.LargeBinary
    "sqlalchemy.types.LargeBinary"), the table will not be consistently readable because
    SQLAlchemy’s [`LargeBinary`](../core/type_basics.html#sqlalchemy.types.LargeBinary
    "sqlalchemy.types.LargeBinary") datatype does not handle strings so it has no
    way of “encoding” a value that is in string format.
  prefs: []
  type: TYPE_NORMAL
- en: 'To deal with a SQLite table that has mixed string / binary data in the same
    column, use a custom type that will check each row individually:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: Then use the above `MixedBinary` datatype in the place where [`LargeBinary`](../core/type_basics.html#sqlalchemy.types.LargeBinary
    "sqlalchemy.types.LargeBinary") would normally be used.
  prefs: []
  type: TYPE_NORMAL
- en: '### Serializable isolation / Savepoints / Transactional DDL'
  prefs: []
  type: TYPE_NORMAL
- en: In the section [Database Locking Behavior / Concurrency](#sqlite-concurrency),
    we refer to the pysqlite driver’s assortment of issues that prevent several features
    of SQLite from working correctly. The pysqlite DBAPI driver has several long-standing
    bugs which impact the correctness of its transactional behavior. In its default
    mode of operation, SQLite features such as SERIALIZABLE isolation, transactional
    DDL, and SAVEPOINT support are non-functional, and in order to use these features,
    workarounds must be taken.
  prefs: []
  type: TYPE_NORMAL
- en: The issue is essentially that the driver attempts to second-guess the user’s
    intent, failing to start transactions and sometimes ending them prematurely, in
    an effort to minimize the SQLite databases’s file locking behavior, even though
    SQLite itself uses “shared” locks for read-only activities.
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy chooses to not alter this behavior by default, as it is the long-expected
    behavior of the pysqlite driver; if and when the pysqlite driver attempts to repair
    these issues, that will be more of a driver towards defaults for SQLAlchemy.
  prefs: []
  type: TYPE_NORMAL
- en: 'The good news is that with a few events, we can implement transactional support
    fully, by disabling pysqlite’s feature entirely and emitting BEGIN ourselves.
    This is achieved using two event listeners:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: When using the above recipe, it is advised to not use the [`Connection.execution_options.isolation_level`](../core/connections.html#sqlalchemy.engine.Connection.execution_options.params.isolation_level
    "sqlalchemy.engine.Connection.execution_options") setting on [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") and [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") with the SQLite driver, as this function necessarily
    will also alter the “.isolation_level” setting.
  prefs: []
  type: TYPE_NORMAL
- en: Above, we intercept a new pysqlite connection and disable any transactional
    integration. Then, at the point at which SQLAlchemy knows that transaction scope
    is to begin, we emit `"BEGIN"` ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we take control of `"BEGIN"`, we can also control directly SQLite’s locking
    modes, introduced at [BEGIN TRANSACTION](https://sqlite.org/lang_transaction.html),
    by adding the desired locking mode to our `"BEGIN"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[BEGIN TRANSACTION](https://sqlite.org/lang_transaction.html) - on the SQLite
    site'
  prefs: []
  type: TYPE_NORMAL
- en: '[sqlite3 SELECT does not BEGIN a transaction](https://bugs.python.org/issue9924)
    - on the Python bug tracker'
  prefs: []
  type: TYPE_NORMAL
- en: '[sqlite3 module breaks transactions and potentially corrupts data](https://bugs.python.org/issue10740)
    - on the Python bug tracker'
  prefs: []
  type: TYPE_NORMAL
- en: '### User-Defined Functions'
  prefs: []
  type: TYPE_NORMAL
- en: pysqlite supports a [create_function()](https://docs.python.org/3/library/sqlite3.html#sqlite3.Connection.create_function)
    method that allows us to create our own user-defined functions (UDFs) in Python
    and use them directly in SQLite queries. These functions are registered with a
    specific DBAPI Connection.
  prefs: []
  type: TYPE_NORMAL
- en: 'SQLAlchemy uses connection pooling with file-based SQLite databases, so we
    need to ensure that the UDF is attached to the connection when it is created.
    That is accomplished with an event listener:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: '## Aiosqlite'
  prefs: []
  type: TYPE_NORMAL
- en: Support for the SQLite database via the aiosqlite driver.
  prefs: []
  type: TYPE_NORMAL
- en: DBAPI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Documentation and download information (if applicable) for aiosqlite is available
    at: [https://pypi.org/project/aiosqlite/](https://pypi.org/project/aiosqlite/)'
  prefs: []
  type: TYPE_NORMAL
- en: Connecting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Connect String:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: The aiosqlite dialect provides support for the SQLAlchemy asyncio interface
    running on top of pysqlite.
  prefs: []
  type: TYPE_NORMAL
- en: aiosqlite is a wrapper around pysqlite that uses a background thread for each
    connection. It does not actually use non-blocking IO, as SQLite databases are
    not socket-based. However it does provide a working asyncio interface that’s useful
    for testing and prototyping purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Using a special asyncio mediation layer, the aiosqlite dialect is usable as
    the backend for the [SQLAlchemy asyncio](../orm/extensions/asyncio.html) extension
    package.
  prefs: []
  type: TYPE_NORMAL
- en: 'This dialect should normally be used only with the [`create_async_engine()`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.create_async_engine
    "sqlalchemy.ext.asyncio.create_async_engine") engine creation function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: The URL passes through all arguments to the `pysqlite` driver, so all connection
    arguments are the same as they are for that of [Pysqlite](#pysqlite).
  prefs: []
  type: TYPE_NORMAL
- en: '### User-Defined Functions'
  prefs: []
  type: TYPE_NORMAL
- en: 'aiosqlite extends pysqlite to support async, so we can create our own user-defined
    functions (UDFs) in Python and use them directly in SQLite queries as described
    here: [User-Defined Functions](#pysqlite-udfs).  ### Serializable isolation /
    Savepoints / Transactional DDL (asyncio version)'
  prefs: []
  type: TYPE_NORMAL
- en: Similarly to pysqlite, aiosqlite does not support SAVEPOINT feature.
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution is similar to [Serializable isolation / Savepoints / Transactional
    DDL](#pysqlite-serializable). This is achieved by the event listeners in async:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: When using the above recipe, it is advised to not use the [`Connection.execution_options.isolation_level`](../core/connections.html#sqlalchemy.engine.Connection.execution_options.params.isolation_level
    "sqlalchemy.engine.Connection.execution_options") setting on [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") and [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") with the SQLite driver, as this function necessarily
    will also alter the “.isolation_level” setting.
  prefs: []
  type: TYPE_NORMAL
- en: DBAPI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Documentation and download information (if applicable) for aiosqlite is available
    at: [https://pypi.org/project/aiosqlite/](https://pypi.org/project/aiosqlite/)'
  prefs: []
  type: TYPE_NORMAL
- en: Connecting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Connect String:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: '### User-Defined Functions'
  prefs: []
  type: TYPE_NORMAL
- en: 'aiosqlite extends pysqlite to support async, so we can create our own user-defined
    functions (UDFs) in Python and use them directly in SQLite queries as described
    here: [User-Defined Functions](#pysqlite-udfs).'
  prefs: []
  type: TYPE_NORMAL
- en: '### Serializable isolation / Savepoints / Transactional DDL (asyncio version)'
  prefs: []
  type: TYPE_NORMAL
- en: Similarly to pysqlite, aiosqlite does not support SAVEPOINT feature.
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution is similar to [Serializable isolation / Savepoints / Transactional
    DDL](#pysqlite-serializable). This is achieved by the event listeners in async:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: When using the above recipe, it is advised to not use the [`Connection.execution_options.isolation_level`](../core/connections.html#sqlalchemy.engine.Connection.execution_options.params.isolation_level
    "sqlalchemy.engine.Connection.execution_options") setting on [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") and [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") with the SQLite driver, as this function necessarily
    will also alter the “.isolation_level” setting.
  prefs: []
  type: TYPE_NORMAL
- en: '## Pysqlcipher'
  prefs: []
  type: TYPE_NORMAL
- en: Support for the SQLite database via the pysqlcipher driver.
  prefs: []
  type: TYPE_NORMAL
- en: Dialect for support of DBAPIs that make use of the [SQLCipher](https://www.zetetic.net/sqlcipher)
    backend.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Connect String:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: Driver
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Current dialect selection logic is:'
  prefs: []
  type: TYPE_NORMAL
- en: If the [`create_engine.module`](../core/engines.html#sqlalchemy.create_engine.params.module
    "sqlalchemy.create_engine") parameter supplies a DBAPI module, that module is
    used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Otherwise for Python 3, choose [https://pypi.org/project/sqlcipher3/](https://pypi.org/project/sqlcipher3/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If not available, fall back to [https://pypi.org/project/pysqlcipher3/](https://pypi.org/project/pysqlcipher3/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For Python 2, [https://pypi.org/project/pysqlcipher/](https://pypi.org/project/pysqlcipher/)
    is used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: 'The `pysqlcipher3` and `pysqlcipher` DBAPI drivers are no longer maintained;
    the `sqlcipher3` driver as of this writing appears to be current. For future compatibility,
    any pysqlcipher-compatible DBAPI may be used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: These drivers make use of the SQLCipher engine. This system essentially introduces
    new PRAGMA commands to SQLite which allows the setting of a passphrase and other
    encryption parameters, allowing the database file to be encrypted.
  prefs: []
  type: TYPE_NORMAL
- en: Connect Strings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The format of the connect string is in every way the same as that of the [`pysqlite`](#module-sqlalchemy.dialects.sqlite.pysqlite
    "sqlalchemy.dialects.sqlite.pysqlite") driver, except that the “password” field
    is now accepted, which should contain a passphrase:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: 'For an absolute file path, two leading slashes should be used for the database
    name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: 'A selection of additional encryption-related pragmas supported by SQLCipher
    as documented at [https://www.zetetic.net/sqlcipher/sqlcipher-api/](https://www.zetetic.net/sqlcipher/sqlcipher-api/)
    can be passed in the query string, and will result in that PRAGMA being called
    for each new connection. Currently, `cipher`, `kdf_iter` `cipher_page_size` and
    `cipher_use_hmac` are supported:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: Previous versions of sqlalchemy did not take into consideration the encryption-related
    pragmas passed in the url string, that were silently ignored. This may cause errors
    when opening files saved by a previous sqlalchemy version if the encryption options
    do not match.
  prefs: []
  type: TYPE_NORMAL
- en: Pooling Behavior
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The driver makes a change to the default pool behavior of pysqlite as described
    in [Threading/Pooling Behavior](#pysqlite-threading-pooling). The pysqlcipher
    driver has been observed to be significantly slower on connection than the pysqlite
    driver, most likely due to the encryption overhead, so the dialect here defaults
    to using the [`SingletonThreadPool`](../core/pooling.html#sqlalchemy.pool.SingletonThreadPool
    "sqlalchemy.pool.SingletonThreadPool") implementation, instead of the [`NullPool`](../core/pooling.html#sqlalchemy.pool.NullPool
    "sqlalchemy.pool.NullPool") pool used by pysqlite. As always, the pool implementation
    is entirely configurable using the [`create_engine.poolclass`](../core/engines.html#sqlalchemy.create_engine.params.poolclass
    "sqlalchemy.create_engine") parameter; the `StaticPool` may be more feasible for
    single-threaded use, or [`NullPool`](../core/pooling.html#sqlalchemy.pool.NullPool
    "sqlalchemy.pool.NullPool") may be used to prevent unencrypted connections from
    being held open for long periods of time, at the expense of slower startup time
    for new connections.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Connect String:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: Driver
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Current dialect selection logic is:'
  prefs: []
  type: TYPE_NORMAL
- en: If the [`create_engine.module`](../core/engines.html#sqlalchemy.create_engine.params.module
    "sqlalchemy.create_engine") parameter supplies a DBAPI module, that module is
    used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Otherwise for Python 3, choose [https://pypi.org/project/sqlcipher3/](https://pypi.org/project/sqlcipher3/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If not available, fall back to [https://pypi.org/project/pysqlcipher3/](https://pypi.org/project/pysqlcipher3/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For Python 2, [https://pypi.org/project/pysqlcipher/](https://pypi.org/project/pysqlcipher/)
    is used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: 'The `pysqlcipher3` and `pysqlcipher` DBAPI drivers are no longer maintained;
    the `sqlcipher3` driver as of this writing appears to be current. For future compatibility,
    any pysqlcipher-compatible DBAPI may be used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: These drivers make use of the SQLCipher engine. This system essentially introduces
    new PRAGMA commands to SQLite which allows the setting of a passphrase and other
    encryption parameters, allowing the database file to be encrypted.
  prefs: []
  type: TYPE_NORMAL
- en: Connect Strings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The format of the connect string is in every way the same as that of the [`pysqlite`](#module-sqlalchemy.dialects.sqlite.pysqlite
    "sqlalchemy.dialects.sqlite.pysqlite") driver, except that the “password” field
    is now accepted, which should contain a passphrase:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: 'For an absolute file path, two leading slashes should be used for the database
    name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: 'A selection of additional encryption-related pragmas supported by SQLCipher
    as documented at [https://www.zetetic.net/sqlcipher/sqlcipher-api/](https://www.zetetic.net/sqlcipher/sqlcipher-api/)
    can be passed in the query string, and will result in that PRAGMA being called
    for each new connection. Currently, `cipher`, `kdf_iter` `cipher_page_size` and
    `cipher_use_hmac` are supported:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: Previous versions of sqlalchemy did not take into consideration the encryption-related
    pragmas passed in the url string, that were silently ignored. This may cause errors
    when opening files saved by a previous sqlalchemy version if the encryption options
    do not match.
  prefs: []
  type: TYPE_NORMAL
- en: Pooling Behavior
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The driver makes a change to the default pool behavior of pysqlite as described
    in [Threading/Pooling Behavior](#pysqlite-threading-pooling). The pysqlcipher
    driver has been observed to be significantly slower on connection than the pysqlite
    driver, most likely due to the encryption overhead, so the dialect here defaults
    to using the [`SingletonThreadPool`](../core/pooling.html#sqlalchemy.pool.SingletonThreadPool
    "sqlalchemy.pool.SingletonThreadPool") implementation, instead of the [`NullPool`](../core/pooling.html#sqlalchemy.pool.NullPool
    "sqlalchemy.pool.NullPool") pool used by pysqlite. As always, the pool implementation
    is entirely configurable using the [`create_engine.poolclass`](../core/engines.html#sqlalchemy.create_engine.params.poolclass
    "sqlalchemy.create_engine") parameter; the `StaticPool` may be more feasible for
    single-threaded use, or [`NullPool`](../core/pooling.html#sqlalchemy.pool.NullPool
    "sqlalchemy.pool.NullPool") may be used to prevent unencrypted connections from
    being held open for long periods of time, at the expense of slower startup time
    for new connections.
  prefs: []
  type: TYPE_NORMAL
