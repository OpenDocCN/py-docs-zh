["```py\nengine = create_engine(\"mysql+mysqldb://scott:tiger@localhost/test\")\n```", "```py\nfrom sqlalchemy import text\n\nwith engine.connect() as connection:\n    result = connection.execute(text(\"select username from users\"))\n    for row in result:\n        print(\"username:\", row.username)\n```", "```py\nwith engine.connect() as connection:\n    connection.execute(some_table.insert(), {\"x\": 7, \"y\": \"this is some data\"})\n    connection.execute(\n        some_other_table.insert(), {\"q\": 8, \"p\": \"this is some more data\"}\n    )\n\n    connection.commit()  # commit the transaction\n```", "```py\nwith engine.connect() as connection:\n    connection.execute(text(\"<some statement>\"))\n    connection.commit()  # commits \"some statement\"\n\n    # new transaction starts\n    connection.execute(text(\"<some other statement>\"))\n    connection.rollback()  # rolls back \"some other statement\"\n\n    # new transaction starts\n    connection.execute(text(\"<a third statement>\"))\n    connection.commit()  # commits \"a third statement\"\n```", "```py\nwith engine.connect() as connection:\n    with connection.begin():\n        connection.execute(some_table.insert(), {\"x\": 7, \"y\": \"this is some data\"})\n        connection.execute(\n            some_other_table.insert(), {\"q\": 8, \"p\": \"this is some more data\"}\n        )\n\n    # transaction is committed\n```", "```py\nwith engine.begin() as connection:\n    connection.execute(some_table.insert(), {\"x\": 7, \"y\": \"this is some data\"})\n    connection.execute(\n        some_other_table.insert(), {\"q\": 8, \"p\": \"this is some more data\"}\n    )\n\n# transaction is committed, and Connection is released to the connection\n# pool\n```", "```py\n>>> from sqlalchemy import create_engine\n>>> e = create_engine(\"sqlite://\", echo=True)\n>>> with e.begin() as conn:\n...     conn.commit()\n...     conn.begin()\n2021-11-08 09:49:07,517 INFO sqlalchemy.engine.Engine BEGIN (implicit)\n2021-11-08 09:49:07,517 INFO sqlalchemy.engine.Engine COMMIT\nTraceback (most recent call last):\n...\nsqlalchemy.exc.InvalidRequestError: Can't operate on closed transaction inside\ncontext manager.  Please complete the context manager before emitting\nfurther commands.\n```", "```py\nwith engine.connect() as connection:\n    with connection.begin():\n        # run statements in a \"begin once\" block\n        connection.execute(some_table.insert(), {\"x\": 7, \"y\": \"this is some data\"})\n\n    # transaction is committed\n\n    # run a new statement outside of a block. The connection\n    # autobegins\n    connection.execute(\n        some_other_table.insert(), {\"q\": 8, \"p\": \"this is some more data\"}\n    )\n\n    # commit explicitly\n    connection.commit()\n\n    # can use a \"begin once\" block here\n    with connection.begin():\n        # run more statements\n        connection.execute(...)\n```", "```py\n# possible values for Connection.execution_options(isolation_level=\"<value>\")\n\n\"AUTOCOMMIT\"\n\"READ COMMITTED\"\n\"READ UNCOMMITTED\"\n\"REPEATABLE READ\"\n\"SERIALIZABLE\"\n```", "```py\nwith engine.connect().execution_options(\n    isolation_level=\"REPEATABLE READ\"\n) as connection:\n    with connection.begin():\n        connection.execute(text(\"<statement>\"))\n```", "```py\nfrom sqlalchemy import create_engine\n\neng = create_engine(\n    \"postgresql://scott:tiger@localhost/test\", isolation_level=\"REPEATABLE READ\"\n)\n```", "```py\nfrom sqlalchemy import create_engine\n\neng = create_engine(\n    \"postgresql+psycopg2://scott:tiger@localhost/test\",\n    execution_options={\"isolation_level\": \"REPEATABLE READ\"},\n)\n```", "```py\nfrom sqlalchemy import create_engine\n\neng = create_engine(\"postgresql+psycopg2://scott:tiger@localhost/test\")\n\nautocommit_engine = eng.execution_options(isolation_level=\"AUTOCOMMIT\")\n```", "```py\nwith engine.connect() as connection:\n    connection.execution_options(isolation_level=\"AUTOCOMMIT\")\n    connection.execute(text(\"<statement>\"))\n    connection.execute(text(\"<statement>\"))\n```", "```py\nwith engine.connect() as connection:\n    connection = connection.execution_options(isolation_level=\"AUTOCOMMIT\")\n\n    # this begin() does not affect the DBAPI connection, isolation stays at AUTOCOMMIT\n    with connection.begin() as trans:\n        connection.execute(text(\"<statement>\"))\n        connection.execute(text(\"<statement>\"))\n```", "```py\nINFO sqlalchemy.engine.Engine BEGIN (implicit)\n...\nINFO sqlalchemy.engine.Engine COMMIT using DBAPI connection.commit(), DBAPI should ignore due to autocommit mode\n```", "```py\nwith engine.connect() as connection:\n    connection = connection.execution_options(isolation_level=\"AUTOCOMMIT\")\n\n    # \"transaction\" is autobegin (but has no effect due to autocommit)\n    connection.execute(text(\"<statement>\"))\n\n    # this will raise; \"transaction\" is already begun\n    with connection.begin() as trans:\n        connection.execute(text(\"<statement>\"))\n```", "```py\n# if we wanted to flip autocommit on and off on a single connection/\n# which... we usually don't.\n\nwith engine.connect() as connection:\n    connection.execution_options(isolation_level=\"AUTOCOMMIT\")\n\n    # run statement(s) in autocommit mode\n    connection.execute(text(\"<statement>\"))\n\n    # \"commit\" the autobegun \"transaction\"\n    connection.commit()\n\n    # switch to default isolation level\n    connection.execution_options(isolation_level=connection.default_isolation_level)\n\n    # use a begin block\n    with connection.begin() as trans:\n        connection.execute(text(\"<statement>\"))\n```", "```py\n# use an autocommit block\nwith engine.connect().execution_options(isolation_level=\"AUTOCOMMIT\") as connection:\n    # run statement in autocommit mode\n    connection.execute(text(\"<statement>\"))\n\n# use a regular block\nwith engine.begin() as connection:\n    connection.execute(text(\"<statement>\"))\n```", "```py\nwith engine.connect() as conn:\n    with conn.execution_options(yield_per=100).execute(\n        text(\"select * from table\")\n    ) as result:\n        for partition in result.partitions():\n            # partition is an iterable that will be at most 100 items\n            for row in partition:\n                print(f\"{row}\")\n```", "```py\nwith engine.connect() as conn:\n    with conn.execution_options(stream_results=True, max_row_buffer=100).execute(\n        text(\"select * from table\")\n    ) as result:\n        for row in result:\n            print(f\"{row}\")\n```", "```py\nuser_table = Table(\n    \"user\",\n    metadata_obj,\n    Column(\"id\", Integer, primary_key=True),\n    Column(\"name\", String(50)),\n)\n```", "```py\nconnection = engine.connect().execution_options(\n    schema_translate_map={None: \"user_schema_one\"}\n)\n\nresult = connection.execute(user_table.select())\n```", "```py\nSELECT  user_schema_one.user.id,  user_schema_one.user.name  FROM\nuser_schema_one.user\n```", "```py\nconnection = engine.connect().execution_options(\n    schema_translate_map={\n        None: \"user_schema_one\",  # no schema name -> \"user_schema_one\"\n        \"special\": \"special_schema\",  # schema=\"special\" becomes \"special_schema\"\n        \"public\": None,  # Table objects with schema=\"public\" will render with no schema\n    }\n)\n```", "```py\nschema_engine = engine.execution_options(schema_translate_map={...})\n\nsession = Session(schema_engine)\n\n...\n```", "```py\ndef run_my_statement(connection, parameter):\n    stmt = select(table)\n    stmt = stmt.where(table.c.col == parameter)\n    stmt = stmt.order_by(table.c.id)\n    return connection.execute(stmt)\n```", "```py\nengine = create_engine(\n    \"postgresql+psycopg2://scott:tiger@localhost/test\", query_cache_size=1200\n)\n```", "```py\nfrom sqlalchemy import Column\nfrom sqlalchemy import create_engine\nfrom sqlalchemy import ForeignKey\nfrom sqlalchemy import Integer\nfrom sqlalchemy import select\nfrom sqlalchemy import String\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import relationship\nfrom sqlalchemy.orm import Session\n\nBase = declarative_base()\n\nclass A(Base):\n    __tablename__ = \"a\"\n\n    id = Column(Integer, primary_key=True)\n    data = Column(String)\n    bs = relationship(\"B\")\n\nclass B(Base):\n    __tablename__ = \"b\"\n    id = Column(Integer, primary_key=True)\n    a_id = Column(ForeignKey(\"a.id\"))\n    data = Column(String)\n\ne = create_engine(\"sqlite://\", echo=True)\nBase.metadata.create_all(e)\n\ns = Session(e)\n\ns.add_all([A(bs=[B(), B(), B()]), A(bs=[B(), B(), B()]), A(bs=[B(), B(), B()])])\ns.commit()\n\nfor a_rec in s.scalars(select(A)):\n    print(a_rec.bs)\n```", "```py\nINFO sqlalchemy.engine.Engine PRAGMA temp.table_info(\"a\")\nINFO sqlalchemy.engine.Engine [raw sql] ()\nINFO sqlalchemy.engine.Engine PRAGMA main.table_info(\"b\")\nINFO sqlalchemy.engine.Engine [raw sql] ()\n```", "```py\nINFO  sqlalchemy.engine.Engine\nCREATE  TABLE  a  (\n  id  INTEGER  NOT  NULL,\n  data  VARCHAR,\n  PRIMARY  KEY  (id)\n)\n\nINFO  sqlalchemy.engine.Engine  [no  key  0.00007s]  ()\nINFO  sqlalchemy.engine.Engine\nCREATE  TABLE  b  (\n  id  INTEGER  NOT  NULL,\n  a_id  INTEGER,\n  data  VARCHAR,\n  PRIMARY  KEY  (id),\n  FOREIGN  KEY(a_id)  REFERENCES  a  (id)\n)\n\nINFO  sqlalchemy.engine.Engine  [no  key  0.00006s]  ()\n```", "```py\nINFO  sqlalchemy.engine.Engine  INSERT  INTO  a  (data)  VALUES  (?)\nINFO  sqlalchemy.engine.Engine  [generated  in  0.00011s]  (None,)\nINFO  sqlalchemy.engine.Engine  INSERT  INTO  a  (data)  VALUES  (?)\nINFO  sqlalchemy.engine.Engine  [cached  since  0.0003533s  ago]  (None,)\nINFO  sqlalchemy.engine.Engine  INSERT  INTO  a  (data)  VALUES  (?)\nINFO  sqlalchemy.engine.Engine  [cached  since  0.0005326s  ago]  (None,)\nINFO  sqlalchemy.engine.Engine  INSERT  INTO  b  (a_id,  data)  VALUES  (?,  ?)\nINFO  sqlalchemy.engine.Engine  [generated  in  0.00010s]  (1,  None)\nINFO  sqlalchemy.engine.Engine  INSERT  INTO  b  (a_id,  data)  VALUES  (?,  ?)\nINFO  sqlalchemy.engine.Engine  [cached  since  0.0003232s  ago]  (1,  None)\nINFO  sqlalchemy.engine.Engine  INSERT  INTO  b  (a_id,  data)  VALUES  (?,  ?)\nINFO  sqlalchemy.engine.Engine  [cached  since  0.0004887s  ago]  (1,  None)\n```", "```py\nINFO sqlalchemy.engine.Engine SELECT a.id AS a_id, a.data AS a_data\nFROM a\nINFO sqlalchemy.engine.Engine [generated in 0.00009s] ()\nINFO sqlalchemy.engine.Engine SELECT b.id AS b_id, b.a_id AS b_a_id, b.data AS b_data\nFROM b\nWHERE ? = b.a_id\nINFO sqlalchemy.engine.Engine [generated in 0.00010s] (1,)\nINFO sqlalchemy.engine.Engine SELECT b.id AS b_id, b.a_id AS b_a_id, b.data AS b_data\nFROM b\nWHERE ? = b.a_id\nINFO sqlalchemy.engine.Engine [cached since 0.0005922s ago] (2,)\nINFO sqlalchemy.engine.Engine SELECT b.id AS b_id, b.a_id AS b_a_id, b.data AS b_data\nFROM b\nWHERE ? = b.a_id\n```", "```py\nmy_cache = {}\nwith engine.connect().execution_options(compiled_cache=my_cache) as conn:\n    conn.execute(table.select())\n```", "```py\n# disable caching for this connection\nwith engine.connect().execution_options(compiled_cache=None) as conn:\n    conn.execute(table.select())\n```", "```py\nfrom sqlalchemy.engine.default import DefaultDialect\n\nclass MyDialect(DefaultDialect):\n    supports_statement_cache = True\n```", "```py\nclass MyDBAPIForMyDialect(MyDialect):\n    supports_statement_cache = True\n```", "```py\n# pre 1.4 style code\ndef limit_clause(self, select, **kw):\n    text = \"\"\n    if select._limit is not None:\n        text += \" \\n LIMIT %d\" % (select._limit,)\n    if select._offset is not None:\n        text += \" \\n OFFSET %d\" % (select._offset,)\n    return text\n```", "```py\n# 1.4 cache-compatible code\ndef limit_clause(self, select, **kw):\n    text = \"\"\n\n    limit_clause = select._limit_clause\n    offset_clause = select._offset_clause\n\n    if select._simple_int_clause(limit_clause):\n        text += \" \\n LIMIT %s\" % (\n            self.process(limit_clause.render_literal_execute(), **kw)\n        )\n    elif limit_clause is not None:\n        # assuming the DB doesn't support SQL expressions for LIMIT.\n        # Otherwise render here normally\n        raise exc.CompileError(\n            \"dialect 'mydialect' can only render simple integers for LIMIT\"\n        )\n    if select._simple_int_clause(offset_clause):\n        text += \" \\n OFFSET %s\" % (\n            self.process(offset_clause.render_literal_execute(), **kw)\n        )\n    elif offset_clause is not None:\n        # assuming the DB doesn't support SQL expressions for OFFSET.\n        # Otherwise render here normally\n        raise exc.CompileError(\n            \"dialect 'mydialect' can only render simple integers for OFFSET\"\n        )\n\n    return text\n```", "```py\nSELECT  x  FROM  y\nLIMIT  __[POSTCOMPILE_param_1]\nOFFSET  __[POSTCOMPILE_param_2]\n```", "```py\nfrom sqlalchemy import lambda_stmt\n\ndef run_my_statement(connection, parameter):\n    stmt = lambda_stmt(lambda: select(table))\n    stmt += lambda s: s.where(table.c.col == parameter)\n    stmt += lambda s: s.order_by(table.c.id)\n\n    return connection.execute(stmt)\n\nwith engine.connect() as conn:\n    result = run_my_statement(some_connection, \"some parameter\")\n```", "```py\n    def upd(id_, newname):\n        stmt = lambda_stmt(lambda: users.update())\n        stmt += lambda s: s.values(name=newname)\n        stmt += lambda s: s.where(users.c.id == id_)\n        return stmt\n\n    with engine.begin() as conn:\n        conn.execute(upd(7, \"foo\"))\n    ```", "```py\n    def select_user(session, name):\n        stmt = lambda_stmt(lambda: select(User))\n        stmt += lambda s: s.where(User.name == name)\n\n        row = session.execute(stmt).first()\n        return row\n    ```", "```py\n    >>> def my_stmt(x, y):\n    ...     stmt = lambda_stmt(lambda: select(func.max(x, y)))\n    ...     return stmt\n    >>> engine = create_engine(\"sqlite://\", echo=True)\n    >>> with engine.connect() as conn:\n    ...     print(conn.scalar(my_stmt(5, 10)))\n    ...     print(conn.scalar(my_stmt(12, 8)))\n    SELECT  max(?,  ?)  AS  max_1\n    [generated  in  0.00057s]  (5,  10)\n    10\n    SELECT  max(?,  ?)  AS  max_1\n    [cached  since  0.002059s  ago]  (12,  8)\n    12\n    ```", "```py\n    # **Don't** do this:\n\n    def my_stmt(parameter, thing=False):\n        stmt = lambda_stmt(lambda: select(table))\n        stmt += lambda s: (\n            s.where(table.c.x > parameter) if thing else s.where(table.c.y == parameter)\n        )\n        return stmt\n\n    # **Do** do this:\n\n    def my_stmt(parameter, thing=False):\n        stmt = lambda_stmt(lambda: select(table))\n        if thing:\n            stmt += lambda s: s.where(table.c.x > parameter)\n        else:\n            stmt += lambda s: s.where(table.c.y == parameter)\n        return stmt\n    ```", "```py\n    >>> def my_stmt(x, y):\n    ...     def get_x():\n    ...         return x\n    ...\n    ...     def get_y():\n    ...         return y\n    ...\n    ...     stmt = lambda_stmt(lambda: select(func.max(get_x(), get_y())))\n    ...     return stmt\n    >>> with engine.connect() as conn:\n    ...     print(conn.scalar(my_stmt(5, 10)))\n    Traceback (most recent call last):\n     # ...\n    sqlalchemy.exc.InvalidRequestError: Can't invoke Python callable get_x()\n    inside of lambda expression argument at\n    <code object <lambda> at 0x7fed15f350e0, file \"<stdin>\", line 6>;\n    lambda SQL constructs should not invoke functions from closure variables\n    to produce literal values since the lambda SQL system normally extracts\n    bound values without actually invoking the lambda or any functions within it.\n    ```", "```py\n    >>> def my_stmt(x, y):\n    ...     def get_x():\n    ...         return x\n    ...\n    ...     def get_y():\n    ...         return y\n    ...\n    ...     x_param, y_param = get_x(), get_y()\n    ...     stmt = lambda_stmt(lambda: select(func.max(x_param, y_param)))\n    ...     return stmt\n    ```", "```py\n    >>> class Foo:\n    ...     def __init__(self, x, y):\n    ...         self.x = x\n    ...         self.y = y\n    >>> def my_stmt(foo):\n    ...     stmt = lambda_stmt(lambda: select(func.max(foo.x, foo.y)))\n    ...     return stmt\n    >>> with engine.connect() as conn:\n    ...     print(conn.scalar(my_stmt(Foo(5, 10))))\n    Traceback (most recent call last):\n     # ...\n    sqlalchemy.exc.InvalidRequestError: Closure variable named 'foo' inside of\n    lambda callable <code object <lambda> at 0x7fed15f35450, file\n    \"<stdin>\", line 2> does not refer to a cacheable SQL element, and also\n    does not appear to be serving as a SQL literal bound value based on the\n    default SQL expression returned by the function.  This variable needs to\n    remain outside the scope of a SQL-generating lambda so that a proper cache\n    key may be generated from the lambda's state.  Evaluate this variable\n    outside of the lambda, set track_on=[<elements>] to explicitly select\n    closure elements to track, or set track_closure_variables=False to exclude\n    closure variables from being part of the cache key.\n    ```", "```py\n    >>> def my_stmt(foo):\n    ...     x_param, y_param = foo.x, foo.y\n    ...     stmt = lambda_stmt(lambda: select(func.max(x_param, y_param)))\n    ...     return stmt\n    ```", "```py\n    >>> def my_stmt(foo):\n    ...     stmt = lambda_stmt(\n    ...         lambda: select(func.max(foo.x, foo.y)), track_closure_variables=False\n    ...     )\n    ...     return stmt\n    ```", "```py\n    >>> def my_stmt(self, foo):\n    ...     stmt = lambda_stmt(\n    ...         lambda: select(*self.column_expressions), track_closure_variables=False\n    ...     )\n    ...     stmt = stmt.add_criteria(lambda: self.where_criteria, track_on=[self])\n    ...     return stmt\n    ```", "```py\n>>> from sqlalchemy import select, column\n>>> stmt = select(column(\"q\"))\n>>> cache_key = stmt._generate_cache_key()\n>>> print(cache_key)  # somewhat paraphrased\nCacheKey(key=(\n '0',\n <class 'sqlalchemy.sql.selectable.Select'>,\n '_raw_columns',\n (\n (\n '1',\n <class 'sqlalchemy.sql.elements.ColumnClause'>,\n 'name',\n 'q',\n 'type',\n (\n <class 'sqlalchemy.sql.sqltypes.NullType'>,\n ),\n ),\n ),\n # a few more elements are here, and many more for a more\n # complicated SELECT statement\n),)\n```", "```py\n>>> from sqlalchemy import lambda_stmt\n>>> stmt = lambda_stmt(lambda: select(column(\"q\")))\n>>> cache_key = stmt._generate_cache_key()\n>>> print(cache_key)\nCacheKey(key=(\n <code object <lambda> at 0x7fed1617c710, file \"<stdin>\", line 1>,\n <class 'sqlalchemy.sql.lambdas.StatementLambdaElement'>,\n),)\n```", "```py\n>>> def my_stmt(parameter):\n...     col = column(\"q\")\n...     stmt = lambda_stmt(lambda: select(col))\n...     stmt += lambda s: s.where(col == parameter)\n...     return stmt\n```", "```py\n>>> stmt = my_stmt(5)\n>>> key = stmt._generate_cache_key()\n>>> print(key)\nCacheKey(key=(\n <code object <lambda> at 0x7f07323c50e0, file \"<stdin>\", line 3>,\n (\n '0',\n <class 'sqlalchemy.sql.elements.ColumnClause'>,\n 'name',\n 'q',\n 'type',\n (\n <class 'sqlalchemy.sql.sqltypes.NullType'>,\n ),\n ),\n <code object <lambda> at 0x7f07323c5190, file \"<stdin>\", line 4>,\n <class 'sqlalchemy.sql.lambdas.LinkedLambdaElement'>,\n (\n '0',\n <class 'sqlalchemy.sql.elements.ColumnClause'>,\n 'name',\n 'q',\n 'type',\n (\n <class 'sqlalchemy.sql.sqltypes.NullType'>,\n ),\n ),\n (\n '0',\n <class 'sqlalchemy.sql.elements.ColumnClause'>,\n 'name',\n 'q',\n 'type',\n (\n <class 'sqlalchemy.sql.sqltypes.NullType'>,\n ),\n ),\n),)\n```", "```py\n>>> key.bindparams\n[BindParameter('%(139668884281280 parameter)s', 5, type_=Integer())]\n```", "```py\nengine = create_engine(\n    \"mariadb+mariadbconnector://scott:tiger@host/db\", use_insertmanyvalues=False\n)\n```", "```py\nt = Table(\n    \"t\",\n    metadata,\n    Column(\"id\", Integer, primary_key=True),\n    Column(\"x\", Integer),\n    implicit_returning=False,\n)\n```", "```py\nINSERT  INTO  a  (data,  x,  y)  VALUES  (%(data)s,  %(x)s,  %(y)s)  RETURNING  a.id\n```", "```py\nINSERT  INTO  a  (data,  x,  y)  VALUES\n  (%(data_0)s,  %(x_0)s,  %(y_0)s),\n  (%(data_1)s,  %(x_1)s,  %(y_1)s),\n  (%(data_2)s,  %(x_2)s,  %(y_2)s),\n  ...\n  (%(data_78)s,  %(x_78)s,  %(y_78)s)\nRETURNING  a.id\n```", "```py\nINSERT  INTO  a  (data,  x,  y)\nOUTPUT  inserted.id,  inserted.id  AS  id__1\nSELECT  p0,  p1,  p2  FROM  (VALUES\n  (?,  ?,  ?,  0),  (?,  ?,  ?,  1),  (?,  ?,  ?,  2),\n  ...\n  (?,  ?,  ?,  77)\n)  AS  imp_sen(p0,  p1,  p2,  sen_counter)  ORDER  BY  sen_counter\n```", "```py\nimport uuid\n\nfrom sqlalchemy import Column\nfrom sqlalchemy import FetchedValue\nfrom sqlalchemy import Integer\nfrom sqlalchemy import String\nfrom sqlalchemy import Table\nfrom sqlalchemy import Uuid\n\nmy_table = Table(\n    \"some_table\",\n    metadata,\n    # assume some arbitrary server-side function generates\n    # primary key values, so cannot be tracked by a bulk insert\n    Column(\"id\", String(50), server_default=FetchedValue(), primary_key=True),\n    Column(\"data\", String(50)),\n    Column(\n        \"uniqueid\",\n        Uuid(),\n        default=uuid.uuid4,\n        nullable=False,\n        unique=True,\n        insert_sentinel=True,\n    ),\n)\n```", "```py\nimport uuid\n\nfrom sqlalchemy.orm import DeclarativeBase\nfrom sqlalchemy.orm import Mapped\nfrom sqlalchemy.orm import mapped_column\n\nclass Base(DeclarativeBase):\n    pass\n\nclass MyClass(Base):\n    __tablename__ = \"my_table\"\n\n    id: Mapped[str] = mapped_column(primary_key=True, server_default=FetchedValue())\n    data: Mapped[str] = mapped_column(String(50))\n    uniqueid: Mapped[uuid.UUID] = mapped_column(\n        default=uuid.uuid4, unique=True, insert_sentinel=True\n    )\n```", "```py\nfrom sqlalchemy import Column\nfrom sqlalchemy import Integer\nfrom sqlalchemy import String\nfrom sqlalchemy import Table\nfrom sqlalchemy import Uuid\nfrom sqlalchemy import insert_sentinel\n\nTable(\n    \"some_table\",\n    metadata,\n    Column(\"id\", Integer, primary_key=True),\n    Column(\"data\", String(50)),\n    insert_sentinel(\"sentinel\"),\n)\n```", "```py\nfrom sqlalchemy.orm import declared_attr\nfrom sqlalchemy.orm import DeclarativeBase\nfrom sqlalchemy.orm import Mapped\nfrom sqlalchemy.orm import mapped_column\nfrom sqlalchemy.orm import orm_insert_sentinel\n\nclass Base(DeclarativeBase):\n    @declared_attr\n    def _sentinel(cls) -> Mapped[int]:\n        return orm_insert_sentinel()\n\nclass MyClass(Base):\n    __tablename__ = \"my_table\"\n\n    id: Mapped[str] = mapped_column(primary_key=True, server_default=FetchedValue())\n    data: Mapped[str] = mapped_column(String(50))\n\nclass MySubClass(MyClass):\n    __tablename__ = \"sub_table\"\n\n    id: Mapped[str] = mapped_column(ForeignKey(\"my_table.id\"), primary_key=True)\n\nclass MySingleInhClass(MyClass):\n    pass\n```", "```py\ne = create_engine(\"sqlite://\", insertmanyvalues_page_size=100)\n```", "```py\nwith e.begin() as conn:\n    result = conn.execute(\n        table.insert().returning(table.c.id),\n        parameterlist,\n        execution_options={\"insertmanyvalues_page_size\": 100},\n    )\n```", "```py\nstmt = (\n    table.insert()\n    .returning(table.c.id)\n    .execution_options(insertmanyvalues_page_size=100)\n)\nwith e.begin() as conn:\n    result = conn.execute(stmt, parameterlist)\n```", "```py\nINSERT INTO a (data, x, y) VALUES (?, ?, ?), ... 795 characters truncated ...  (?, ?, ?), (?, ?, ?) RETURNING id\n[generated in 0.00177s (insertmanyvalues) 1/10 (unordered)] ('d0', 0, 0, 'd1',  ...\nINSERT INTO a (data, x, y) VALUES (?, ?, ?), ... 795 characters truncated ...  (?, ?, ?), (?, ?, ?) RETURNING id\n[insertmanyvalues 2/10 (unordered)] ('d100', 100, 1000, 'd101', ...\n\n...\n\nINSERT INTO a (data, x, y) VALUES (?, ?, ?), ... 795 characters truncated ...  (?, ?, ?), (?, ?, ?) RETURNING id\n[insertmanyvalues 10/10 (unordered)] ('d900', 900, 9000, 'd901', ...\n```", "```py\n...\n\nINSERT INTO a (data, x, y) VALUES (?, ?, ?) RETURNING id\n[insertmanyvalues 67/78 (ordered; batch not supported)] ('d66', 66, 66)\nINSERT INTO a (data, x, y) VALUES (?, ?, ?) RETURNING id\n[insertmanyvalues 68/78 (ordered; batch not supported)] ('d67', 67, 67)\nINSERT INTO a (data, x, y) VALUES (?, ?, ?) RETURNING id\n[insertmanyvalues 69/78 (ordered; batch not supported)] ('d68', 68, 68)\nINSERT INTO a (data, x, y) VALUES (?, ?, ?) RETURNING id\n[insertmanyvalues 70/78 (ordered; batch not supported)] ('d69', 69, 69)\n\n...\n```", "```py\nwith engine.connect() as conn:\n    conn.exec_driver_sql(\"SET param='bar'\")\n```", "```py\nconnection = engine.connect()\ndbapi_conn = connection.connection\n```", "```py\ndbapi_conn = engine.raw_connection()\n```", "```py\ndbapi_conn.close()\n```", "```py\nconnection = engine.raw_connection()\ntry:\n    cursor_obj = connection.cursor()\n    cursor_obj.callproc(\"my_procedure\", [\"x\", \"y\", \"z\"])\n    results = list(cursor_obj.fetchall())\n    cursor_obj.close()\n    connection.commit()\nfinally:\n    connection.close()\n```", "```py\nconnection.execute(\"CALL my_procedure();\")\n```", "```py\nconnection = engine.raw_connection()\ntry:\n    cursor_obj = connection.cursor()\n    cursor_obj.execute(\"select * from table1; select * from table2\")\n    results_one = cursor_obj.fetchall()\n    cursor_obj.nextset()\n    results_two = cursor_obj.fetchall()\n    cursor_obj.close()\nfinally:\n    connection.close()\n```", "```py\n    [options.entry_points]\n    sqlalchemy.dialects  =\n      foodialect  =  foodialect.dialect:FooDialect\n    ```", "```py\n[options.entry_points]\nsqlalchemy.dialects\n  mysql.foodialect  =  foodialect.dialect:FooDialect\n```", "```py\nfrom sqlalchemy.dialects import registry\n\nregistry.register(\"mysql.foodialect\", \"myapp.dialect\", \"MyMySQLDialect\")\n```", "```py\nclass sqlalchemy.engine.Connection\n```", "```py\nmethod __init__(engine: Engine, connection: PoolProxiedConnection | None = None, _has_events: bool | None = None, _allow_revalidate: bool = True, _allow_autobegin: bool = True)\n```", "```py\nmethod begin() \u2192 RootTransaction\n```", "```py\nwith engine.connect() as conn:\n    with conn.begin() as trans:\n        conn.execute(table.insert(), {\"username\": \"sandy\"})\n```", "```py\nwith engine.connect() as conn:\n    with conn.begin():\n        conn.execute(...)\n        conn.execute(...)\n\n    with conn.begin():\n        conn.execute(...)\n        conn.execute(...)\n```", "```py\nwith engine.connect() as conn:\n    conn.execute(...)\n    conn.execute(...)\n    conn.commit()\n\n    conn.execute(...)\n    conn.execute(...)\n    conn.commit()\n```", "```py\nmethod begin_nested() \u2192 NestedTransaction\n```", "```py\nwith engine.begin() as connection:\n    with connection.begin_nested():\n        connection.execute(table.insert(), {\"username\": \"sandy\"})\n```", "```py\nfrom sqlalchemy import exc\n\nwith engine.begin() as connection:\n    trans = connection.begin_nested()\n    try:\n        connection.execute(table.insert(), {\"username\": \"sandy\"})\n        trans.commit()\n    except exc.IntegrityError:  # catch for duplicate username\n        trans.rollback()  # rollback to savepoint\n\n    # outer transaction continues\n    connection.execute( ... )\n```", "```py\nwith engine.connect() as connection:  # begin() wasn't called\n\n    with connection.begin_nested(): will auto-\"begin()\" first\n        connection.execute( ... )\n    # savepoint is released\n\n    connection.execute( ... )\n\n    # explicitly commit outer transaction\n    connection.commit()\n\n    # can continue working with connection here\n```", "```py\nmethod begin_twophase(xid: Any | None = None) \u2192 TwoPhaseTransaction\n```", "```py\nmethod close() \u2192 None\n```", "```py\nattribute closed\n```", "```py\nmethod commit() \u2192 None\n```", "```py\nattribute connection\n```", "```py\nattribute default_isolation_level\n```", "```py\nmethod detach() \u2192 None\n```", "```py\nwith engine.connect() as conn:\n    conn.detach()\n    conn.execute(text(\"SET search_path TO schema1, schema2\"))\n\n    # work with connection\n\n# connection is fully closed (since we used \"with:\", can\n# also call .close())\n```", "```py\nmethod exec_driver_sql(statement: str, parameters: _DBAPIAnyExecuteParams | None = None, execution_options: CoreExecuteOptionsParameter | None = None) \u2192 CursorResult[Any]\n```", "```py\nconn.exec_driver_sql(\n    \"INSERT INTO table (id, value) VALUES (%(id)s, %(value)s)\",\n    [{\"id\":1, \"value\":\"v1\"}, {\"id\":2, \"value\":\"v2\"}]\n)\n```", "```py\nconn.exec_driver_sql(\n    \"INSERT INTO table (id, value) VALUES (%(id)s, %(value)s)\",\n    dict(id=1, value=\"v1\")\n)\n```", "```py\nconn.exec_driver_sql(\n    \"INSERT INTO table (id, value) VALUES (?, ?)\",\n    (1, 'v1')\n)\n```", "```py\nmethod execute(statement: Executable, parameters: _CoreAnyExecuteParams | None = None, *, execution_options: CoreExecuteOptionsParameter | None = None) \u2192 CursorResult[Any]\n```", "```py\nmethod execution_options(**opt: Any) \u2192 Connection\n```", "```py\nmethod get_execution_options() \u2192 _ExecuteOptions\n```", "```py\nmethod get_isolation_level() \u2192 Literal['SERIALIZABLE', 'REPEATABLE READ', 'READ COMMITTED', 'READ UNCOMMITTED', 'AUTOCOMMIT']\n```", "```py\nmethod get_nested_transaction() \u2192 NestedTransaction | None\n```", "```py\nmethod get_transaction() \u2192 RootTransaction | None\n```", "```py\nmethod in_nested_transaction() \u2192 bool\n```", "```py\nmethod in_transaction() \u2192 bool\n```", "```py\nattribute info\n```", "```py\nmethod invalidate(exception: BaseException | None = None) \u2192 None\n```", "```py\nattribute invalidated\n```", "```py\nmethod rollback() \u2192 None\n```", "```py\nmethod scalar(statement: Executable, parameters: _CoreSingleExecuteParams | None = None, *, execution_options: CoreExecuteOptionsParameter | None = None) \u2192 Any\n```", "```py\nmethod scalars(statement: Executable, parameters: _CoreAnyExecuteParams | None = None, *, execution_options: CoreExecuteOptionsParameter | None = None) \u2192 ScalarResult[Any]\n```", "```py\nmethod schema_for_object(obj: HasSchemaAttr) \u2192 str | None\n```", "```py\nclass sqlalchemy.engine.CreateEnginePlugin\n```", "```py\nimport logging\n\nfrom sqlalchemy.engine import CreateEnginePlugin\nfrom sqlalchemy import event\n\nclass LogCursorEventsPlugin(CreateEnginePlugin):\n    def __init__(self, url, kwargs):\n        # consume the parameter \"log_cursor_logging_name\" from the\n        # URL query\n        logging_name = url.query.get(\"log_cursor_logging_name\", \"log_cursor\")\n\n        self.log = logging.getLogger(logging_name)\n\n    def update_url(self, url):\n        \"update the URL to one that no longer includes our parameters\"\n        return url.difference_update_query([\"log_cursor_logging_name\"])\n\n    def engine_created(self, engine):\n        \"attach an event listener after the new Engine is constructed\"\n        event.listen(engine, \"before_cursor_execute\", self._log_event)\n\n    def _log_event(\n        self,\n        conn,\n        cursor,\n        statement,\n        parameters,\n        context,\n        executemany):\n\n        self.log.info(\"Plugin logged cursor event: %s\", statement)\n```", "```py\nentry_points={\n    'sqlalchemy.plugins': [\n        'log_cursor_plugin = myapp.plugins:LogCursorEventsPlugin'\n    ]\n```", "```py\nfrom sqlalchemy import create_engine\n\nengine = create_engine(\n    \"mysql+pymysql://scott:tiger@localhost/test?\"\n    \"plugin=log_cursor_plugin&log_cursor_logging_name=mylogger\"\n)\n```", "```py\nengine = create_engine(\n  \"mysql+pymysql://scott:tiger@localhost/test?\"\n  \"plugin=plugin_one&plugin=plugin_twp&plugin=plugin_three\")\n```", "```py\nengine = create_engine(\n  \"mysql+pymysql://scott:tiger@localhost/test\",\n  plugins=[\"myplugin\"])\n```", "```py\nclass MyPlugin(CreateEnginePlugin):\n    def __init__(self, url, kwargs):\n        self.my_argument_one = url.query['my_argument_one']\n        self.my_argument_two = url.query['my_argument_two']\n        self.my_argument_three = kwargs.pop('my_argument_three', None)\n\n    def update_url(self, url):\n        return url.difference_update_query(\n            [\"my_argument_one\", \"my_argument_two\"]\n        )\n```", "```py\nfrom sqlalchemy import create_engine\n\nengine = create_engine(\n  \"mysql+pymysql://scott:tiger@localhost/test?\"\n  \"plugin=myplugin&my_argument_one=foo&my_argument_two=bar\",\n  my_argument_three='bat'\n)\n```", "```py\nclass MyPlugin(CreateEnginePlugin):\n    def __init__(self, url, kwargs):\n        if hasattr(CreateEnginePlugin, \"update_url\"):\n            # detect the 1.4 API\n            self.my_argument_one = url.query['my_argument_one']\n            self.my_argument_two = url.query['my_argument_two']\n        else:\n            # detect the 1.3 and earlier API - mutate the\n            # URL directly\n            self.my_argument_one = url.query.pop('my_argument_one')\n            self.my_argument_two = url.query.pop('my_argument_two')\n\n        self.my_argument_three = kwargs.pop('my_argument_three', None)\n\n    def update_url(self, url):\n        # this method is only called in the 1.4 version\n        return url.difference_update_query(\n            [\"my_argument_one\", \"my_argument_two\"]\n        )\n```", "```py\nmethod __init__(url: URL, kwargs: Dict[str, Any])\n```", "```py\nmethod engine_created(engine: Engine) \u2192 None\n```", "```py\nmethod handle_dialect_kwargs(dialect_cls: Type[Dialect], dialect_args: Dict[str, Any]) \u2192 None\n```", "```py\nmethod handle_pool_kwargs(pool_cls: Type[Pool], pool_args: Dict[str, Any]) \u2192 None\n```", "```py\nmethod update_url(url: URL) \u2192 URL\n```", "```py\nclass sqlalchemy.engine.Engine\n```", "```py\nmethod begin() \u2192 Iterator[Connection]\n```", "```py\nwith engine.begin() as conn:\n    conn.execute(\n        text(\"insert into table (x, y, z) values (1, 2, 3)\")\n    )\n    conn.execute(text(\"my_special_procedure(5)\"))\n```", "```py\nmethod clear_compiled_cache() \u2192 None\n```", "```py\nmethod connect() \u2192 Connection\n```", "```py\nwith engine.connect() as connection:\n    connection.execute(text(\"insert into table values ('foo')\"))\n    connection.commit()\n```", "```py\nmethod dispose(close: bool = True) \u2192 None\n```", "```py\nattribute driver\n```", "```py\nattribute engine\n```", "```py\nmethod execution_options(**opt: Any) \u2192 OptionEngine\n```", "```py\nfrom sqlalchemy import event\nfrom sqlalchemy.engine import Engine\n\nprimary_engine = create_engine(\"mysql+mysqldb://\")\nshard1 = primary_engine.execution_options(shard_id=\"shard1\")\nshard2 = primary_engine.execution_options(shard_id=\"shard2\")\n\nshards = {\"default\": \"base\", \"shard_1\": \"db1\", \"shard_2\": \"db2\"}\n\n@event.listens_for(Engine, \"before_cursor_execute\")\ndef _switch_shard(conn, cursor, stmt,\n        params, context, executemany):\n    shard_id = conn.get_execution_options().get('shard_id', \"default\")\n    current_shard = conn.info.get(\"current_shard\", None)\n\n    if current_shard != shard_id:\n        cursor.execute(\"use %s\" % shards[shard_id])\n        conn.info[\"current_shard\"] = shard_id\n```", "```py\nmethod get_execution_options() \u2192 _ExecuteOptions\n```", "```py\nattribute name\n```", "```py\nmethod raw_connection() \u2192 PoolProxiedConnection\n```", "```py\nmethod update_execution_options(**opt: Any) \u2192 None\n```", "```py\nclass sqlalchemy.engine.ExceptionContext\n```", "```py\nattribute chained_exception: BaseException | None\n```", "```py\nattribute connection: Connection | None\n```", "```py\nattribute cursor: DBAPICursor | None\n```", "```py\nattribute dialect: Dialect\n```", "```py\nattribute engine: Engine | None\n```", "```py\nattribute execution_context: ExecutionContext | None\n```", "```py\nattribute invalidate_pool_on_disconnect: bool\n```", "```py\nattribute is_disconnect: bool\n```", "```py\nattribute is_pre_ping: bool\n```", "```py\nattribute original_exception: BaseException\n```", "```py\nattribute parameters: _DBAPIAnyExecuteParams | None\n```", "```py\nattribute sqlalchemy_exception: StatementError | None\n```", "```py\nattribute statement: str | None\n```", "```py\nclass sqlalchemy.engine.NestedTransaction\n```", "```py\nmethod close() \u2192 None\n```", "```py\nmethod commit() \u2192 None\n```", "```py\nmethod rollback() \u2192 None\n```", "```py\nclass sqlalchemy.engine.RootTransaction\n```", "```py\nmethod close() \u2192 None\n```", "```py\nmethod commit() \u2192 None\n```", "```py\nmethod rollback() \u2192 None\n```", "```py\nclass sqlalchemy.engine.Transaction\n```", "```py\nfrom sqlalchemy import create_engine\nengine = create_engine(\"postgresql+psycopg2://scott:tiger@localhost/test\")\nconnection = engine.connect()\ntrans = connection.begin()\nconnection.execute(text(\"insert into x (a, b) values (1, 2)\"))\ntrans.commit()\n```", "```py\nwith connection.begin():\n    connection.execute(text(\"insert into x (a, b) values (1, 2)\"))\n```", "```py\nmethod close() \u2192 None\n```", "```py\nmethod commit() \u2192 None\n```", "```py\nmethod rollback() \u2192 None\n```", "```py\nclass sqlalchemy.engine.TwoPhaseTransaction\n```", "```py\nmethod close() \u2192 None\n```", "```py\nmethod commit() \u2192 None\n```", "```py\nmethod prepare() \u2192 None\n```", "```py\nmethod rollback() \u2192 None\n```", "```py\nclass sqlalchemy.engine.ChunkedIteratorResult\n```", "```py\nmethod yield_per(num: int) \u2192 Self\n```", "```py\nclass sqlalchemy.engine.CursorResult\n```", "```py\nmethod all() \u2192 Sequence[Row[_TP]]\n```", "```py\nmethod close() \u2192 Any\n```", "```py\nmethod columns(*col_expressions: _KeyIndexType) \u2192 Self\n```", "```py\nstatement = select(table.c.x, table.c.y, table.c.z)\nresult = connection.execute(statement)\n\nfor z, y in result.columns('z', 'y'):\n    # ...\n```", "```py\nfor z, y in result.columns(\n        statement.selected_columns.c.z,\n        statement.selected_columns.c.y\n):\n    # ...\n```", "```py\nmethod fetchall() \u2192 Sequence[Row[_TP]]\n```", "```py\nmethod fetchmany(size: int | None = None) \u2192 Sequence[Row[_TP]]\n```", "```py\nmethod fetchone() \u2192 Row[_TP] | None\n```", "```py\nmethod first() \u2192 Row[_TP] | None\n```", "```py\nmethod freeze() \u2192 FrozenResult[_TP]\n```", "```py\nattribute inserted_primary_key\n```", "```py\nattribute inserted_primary_key_rows\n```", "```py\nattribute is_insert\n```", "```py\nmethod keys() \u2192 RMKeyView\n```", "```py\nmethod last_inserted_params()\n```", "```py\nmethod last_updated_params()\n```", "```py\nmethod lastrow_has_defaults()\n```", "```py\nattribute lastrowid\n```", "```py\nmethod mappings() \u2192 MappingResult\n```", "```py\nmethod merge(*others: Result[Any]) \u2192 MergedResult[Any]\n```", "```py\nmethod one() \u2192 Row[_TP]\n```", "```py\nmethod one_or_none() \u2192 Row[_TP] | None\n```", "```py\nmethod partitions(size: int | None = None) \u2192 Iterator[Sequence[Row[_TP]]]\n```", "```py\nmethod postfetch_cols()\n```", "```py\nmethod prefetch_cols()\n```", "```py\nattribute returned_defaults\n```", "```py\nattribute returned_defaults_rows\n```", "```py\nattribute returns_rows\n```", "```py\nattribute rowcount\n```", "```py\nmethod scalar() \u2192 Any\n```", "```py\nmethod scalar_one() \u2192 Any\n```", "```py\nmethod scalar_one_or_none() \u2192 Any | None\n```", "```py\nmethod scalars(index: _KeyIndexType = 0) \u2192 ScalarResult[Any]\n```", "```py\n>>> result = conn.execute(text(\"select int_id from table\"))\n>>> result.scalars().all()\n[1, 2, 3]\n```", "```py\nmethod splice_horizontally(other)\n```", "```py\nr1 = connection.execute(\n    users.insert().returning(\n        users.c.user_name,\n        users.c.user_id,\n        sort_by_parameter_order=True\n    ),\n    user_values\n)\n\nr2 = connection.execute(\n    addresses.insert().returning(\n        addresses.c.address_id,\n        addresses.c.address,\n        addresses.c.user_id,\n        sort_by_parameter_order=True\n    ),\n    address_values\n)\n\nrows = r1.splice_horizontally(r2).all()\nassert (\n    rows ==\n    [\n        (\"john\", 1, 1, \"foo@bar.com\", 1),\n        (\"jack\", 2, 2, \"bar@bat.com\", 2),\n    ]\n)\n```", "```py\nmethod splice_vertically(other)\n```", "```py\nmethod supports_sane_multi_rowcount()\n```", "```py\nmethod supports_sane_rowcount()\n```", "```py\nattribute t\n```", "```py\nmethod tuples() \u2192 TupleResult[_TP]\n```", "```py\nmethod unique(strategy: Callable[[Any], Any] | None = None) \u2192 Self\n```", "```py\nmethod yield_per(num: int) \u2192 Self\n```", "```py\nclass sqlalchemy.engine.FilterResult\n```", "```py\nmethod close() \u2192 None\n```", "```py\nattribute closed\n```", "```py\nmethod yield_per(num: int) \u2192 Self\n```", "```py\nclass sqlalchemy.engine.FrozenResult\n```", "```py\nresult = connection.execute(query)\n\nfrozen = result.freeze()\n\nunfrozen_result_one = frozen()\n\nfor row in unfrozen_result_one:\n    print(row)\n\nunfrozen_result_two = frozen()\nrows = unfrozen_result_two.all()\n\n# ... etc\n```", "```py\nclass sqlalchemy.engine.IteratorResult\n```", "```py\nattribute closed\n```", "```py\nclass sqlalchemy.engine.MergedResult\n```", "```py\nclass sqlalchemy.engine.Result\n```", "```py\nmethod all() \u2192 Sequence[Row[_TP]]\n```", "```py\nmethod close() \u2192 None\n```", "```py\nattribute closed\n```", "```py\nmethod columns(*col_expressions: _KeyIndexType) \u2192 Self\n```", "```py\nstatement = select(table.c.x, table.c.y, table.c.z)\nresult = connection.execute(statement)\n\nfor z, y in result.columns('z', 'y'):\n    # ...\n```", "```py\nfor z, y in result.columns(\n        statement.selected_columns.c.z,\n        statement.selected_columns.c.y\n):\n    # ...\n```", "```py\nmethod fetchall() \u2192 Sequence[Row[_TP]]\n```", "```py\nmethod fetchmany(size: int | None = None) \u2192 Sequence[Row[_TP]]\n```", "```py\nmethod fetchone() \u2192 Row[_TP] | None\n```", "```py\nmethod first() \u2192 Row[_TP] | None\n```", "```py\nmethod freeze() \u2192 FrozenResult[_TP]\n```", "```py\nmethod keys() \u2192 RMKeyView\n```", "```py\nmethod mappings() \u2192 MappingResult\n```", "```py\nmethod merge(*others: Result[Any]) \u2192 MergedResult[_TP]\n```", "```py\nmethod one() \u2192 Row[_TP]\n```", "```py\nmethod one_or_none() \u2192 Row[_TP] | None\n```", "```py\nmethod partitions(size: int | None = None) \u2192 Iterator[Sequence[Row[_TP]]]\n```", "```py\nmethod scalar() \u2192 Any\n```", "```py\nmethod scalar_one() \u2192 Any\n```", "```py\nmethod scalar_one_or_none() \u2192 Any | None\n```", "```py\nmethod scalars(index: _KeyIndexType = 0) \u2192 ScalarResult[Any]\n```", "```py\n>>> result = conn.execute(text(\"select int_id from table\"))\n>>> result.scalars().all()\n[1, 2, 3]\n```", "```py\nattribute t\n```", "```py\nmethod tuples() \u2192 TupleResult[_TP]\n```", "```py\nmethod unique(strategy: Callable[[Any], Any] | None = None) \u2192 Self\n```", "```py\nmethod yield_per(num: int) \u2192 Self\n```", "```py\nclass sqlalchemy.engine.ScalarResult\n```", "```py\nmethod all() \u2192 Sequence[_R]\n```", "```py\nmethod close() \u2192 None\n```", "```py\nattribute closed\n```", "```py\nmethod fetchall() \u2192 Sequence[_R]\n```", "```py\nmethod fetchmany(size: int | None = None) \u2192 Sequence[_R]\n```", "```py\nmethod first() \u2192 _R | None\n```", "```py\nmethod one() \u2192 _R\n```", "```py\nmethod one_or_none() \u2192 _R | None\n```", "```py\nmethod partitions(size: int | None = None) \u2192 Iterator[Sequence[_R]]\n```", "```py\nmethod unique(strategy: Callable[[Any], Any] | None = None) \u2192 Self\n```", "```py\nmethod yield_per(num: int) \u2192 Self\n```", "```py\nclass sqlalchemy.engine.MappingResult\n```", "```py\nmethod all() \u2192 Sequence[RowMapping]\n```", "```py\nmethod close() \u2192 None\n```", "```py\nattribute closed\n```", "```py\nmethod columns(*col_expressions: _KeyIndexType) \u2192 Self\n```", "```py\nmethod fetchall() \u2192 Sequence[RowMapping]\n```", "```py\nmethod fetchmany(size: int | None = None) \u2192 Sequence[RowMapping]\n```", "```py\nmethod fetchone() \u2192 RowMapping | None\n```", "```py\nmethod first() \u2192 RowMapping | None\n```", "```py\nmethod keys() \u2192 RMKeyView\n```", "```py\nmethod one() \u2192 RowMapping\n```", "```py\nmethod one_or_none() \u2192 RowMapping | None\n```", "```py\nmethod partitions(size: int | None = None) \u2192 Iterator[Sequence[RowMapping]]\n```", "```py\nmethod unique(strategy: Callable[[Any], Any] | None = None) \u2192 Self\n```", "```py\nmethod yield_per(num: int) \u2192 Self\n```", "```py\nclass sqlalchemy.engine.Row\n```", "```py\nmethod _asdict() \u2192 Dict[str, Any]\n```", "```py\nattribute _fields\n```", "```py\nattribute _mapping\n```", "```py\nattribute _t\n```", "```py\nmethod _tuple() \u2192 _TP\n```", "```py\nattribute count\n```", "```py\nattribute index\n```", "```py\nattribute t\n```", "```py\nmethod tuple() \u2192 _TP\n```", "```py\nclass sqlalchemy.engine.RowMapping\n```", "```py\nfor row in result:\n    if 'a' in row._mapping:\n        print(\"Column 'a': %s\" % row._mapping['a'])\n\n    print(\"Column b: %s\" % row._mapping[table.c.b])\n```", "```py\nmethod items() \u2192 ROMappingItemsView\n```", "```py\nmethod keys() \u2192 RMKeyView\n```", "```py\nmethod values() \u2192 ROMappingKeysValuesView\n```", "```py\nclass sqlalchemy.engine.TupleResult\n```", "```py\nengine = create_engine(\"mysql+mysqldb://scott:tiger@localhost/test\")\n```", "```py\nfrom sqlalchemy import text\n\nwith engine.connect() as connection:\n    result = connection.execute(text(\"select username from users\"))\n    for row in result:\n        print(\"username:\", row.username)\n```", "```py\nwith engine.connect() as connection:\n    connection.execute(some_table.insert(), {\"x\": 7, \"y\": \"this is some data\"})\n    connection.execute(\n        some_other_table.insert(), {\"q\": 8, \"p\": \"this is some more data\"}\n    )\n\n    connection.commit()  # commit the transaction\n```", "```py\nwith engine.connect() as connection:\n    connection.execute(text(\"<some statement>\"))\n    connection.commit()  # commits \"some statement\"\n\n    # new transaction starts\n    connection.execute(text(\"<some other statement>\"))\n    connection.rollback()  # rolls back \"some other statement\"\n\n    # new transaction starts\n    connection.execute(text(\"<a third statement>\"))\n    connection.commit()  # commits \"a third statement\"\n```", "```py\nwith engine.connect() as connection:\n    with connection.begin():\n        connection.execute(some_table.insert(), {\"x\": 7, \"y\": \"this is some data\"})\n        connection.execute(\n            some_other_table.insert(), {\"q\": 8, \"p\": \"this is some more data\"}\n        )\n\n    # transaction is committed\n```", "```py\nwith engine.begin() as connection:\n    connection.execute(some_table.insert(), {\"x\": 7, \"y\": \"this is some data\"})\n    connection.execute(\n        some_other_table.insert(), {\"q\": 8, \"p\": \"this is some more data\"}\n    )\n\n# transaction is committed, and Connection is released to the connection\n# pool\n```", "```py\n>>> from sqlalchemy import create_engine\n>>> e = create_engine(\"sqlite://\", echo=True)\n>>> with e.begin() as conn:\n...     conn.commit()\n...     conn.begin()\n2021-11-08 09:49:07,517 INFO sqlalchemy.engine.Engine BEGIN (implicit)\n2021-11-08 09:49:07,517 INFO sqlalchemy.engine.Engine COMMIT\nTraceback (most recent call last):\n...\nsqlalchemy.exc.InvalidRequestError: Can't operate on closed transaction inside\ncontext manager.  Please complete the context manager before emitting\nfurther commands.\n```", "```py\nwith engine.connect() as connection:\n    with connection.begin():\n        # run statements in a \"begin once\" block\n        connection.execute(some_table.insert(), {\"x\": 7, \"y\": \"this is some data\"})\n\n    # transaction is committed\n\n    # run a new statement outside of a block. The connection\n    # autobegins\n    connection.execute(\n        some_other_table.insert(), {\"q\": 8, \"p\": \"this is some more data\"}\n    )\n\n    # commit explicitly\n    connection.commit()\n\n    # can use a \"begin once\" block here\n    with connection.begin():\n        # run more statements\n        connection.execute(...)\n```", "```py\nwith engine.connect() as connection:\n    connection.execute(some_table.insert(), {\"x\": 7, \"y\": \"this is some data\"})\n    connection.execute(\n        some_other_table.insert(), {\"q\": 8, \"p\": \"this is some more data\"}\n    )\n\n    connection.commit()  # commit the transaction\n```", "```py\nwith engine.connect() as connection:\n    connection.execute(text(\"<some statement>\"))\n    connection.commit()  # commits \"some statement\"\n\n    # new transaction starts\n    connection.execute(text(\"<some other statement>\"))\n    connection.rollback()  # rolls back \"some other statement\"\n\n    # new transaction starts\n    connection.execute(text(\"<a third statement>\"))\n    connection.commit()  # commits \"a third statement\"\n```", "```py\nwith engine.connect() as connection:\n    with connection.begin():\n        connection.execute(some_table.insert(), {\"x\": 7, \"y\": \"this is some data\"})\n        connection.execute(\n            some_other_table.insert(), {\"q\": 8, \"p\": \"this is some more data\"}\n        )\n\n    # transaction is committed\n```", "```py\nwith engine.begin() as connection:\n    connection.execute(some_table.insert(), {\"x\": 7, \"y\": \"this is some data\"})\n    connection.execute(\n        some_other_table.insert(), {\"q\": 8, \"p\": \"this is some more data\"}\n    )\n\n# transaction is committed, and Connection is released to the connection\n# pool\n```", "```py\n>>> from sqlalchemy import create_engine\n>>> e = create_engine(\"sqlite://\", echo=True)\n>>> with e.begin() as conn:\n...     conn.commit()\n...     conn.begin()\n2021-11-08 09:49:07,517 INFO sqlalchemy.engine.Engine BEGIN (implicit)\n2021-11-08 09:49:07,517 INFO sqlalchemy.engine.Engine COMMIT\nTraceback (most recent call last):\n...\nsqlalchemy.exc.InvalidRequestError: Can't operate on closed transaction inside\ncontext manager.  Please complete the context manager before emitting\nfurther commands.\n```", "```py\nwith engine.connect() as connection:\n    with connection.begin():\n        # run statements in a \"begin once\" block\n        connection.execute(some_table.insert(), {\"x\": 7, \"y\": \"this is some data\"})\n\n    # transaction is committed\n\n    # run a new statement outside of a block. The connection\n    # autobegins\n    connection.execute(\n        some_other_table.insert(), {\"q\": 8, \"p\": \"this is some more data\"}\n    )\n\n    # commit explicitly\n    connection.commit()\n\n    # can use a \"begin once\" block here\n    with connection.begin():\n        # run more statements\n        connection.execute(...)\n```", "```py\n# possible values for Connection.execution_options(isolation_level=\"<value>\")\n\n\"AUTOCOMMIT\"\n\"READ COMMITTED\"\n\"READ UNCOMMITTED\"\n\"REPEATABLE READ\"\n\"SERIALIZABLE\"\n```", "```py\nwith engine.connect().execution_options(\n    isolation_level=\"REPEATABLE READ\"\n) as connection:\n    with connection.begin():\n        connection.execute(text(\"<statement>\"))\n```", "```py\nfrom sqlalchemy import create_engine\n\neng = create_engine(\n    \"postgresql://scott:tiger@localhost/test\", isolation_level=\"REPEATABLE READ\"\n)\n```", "```py\nfrom sqlalchemy import create_engine\n\neng = create_engine(\n    \"postgresql+psycopg2://scott:tiger@localhost/test\",\n    execution_options={\"isolation_level\": \"REPEATABLE READ\"},\n)\n```", "```py\nfrom sqlalchemy import create_engine\n\neng = create_engine(\"postgresql+psycopg2://scott:tiger@localhost/test\")\n\nautocommit_engine = eng.execution_options(isolation_level=\"AUTOCOMMIT\")\n```", "```py\nwith engine.connect() as connection:\n    connection.execution_options(isolation_level=\"AUTOCOMMIT\")\n    connection.execute(text(\"<statement>\"))\n    connection.execute(text(\"<statement>\"))\n```", "```py\nwith engine.connect() as connection:\n    connection = connection.execution_options(isolation_level=\"AUTOCOMMIT\")\n\n    # this begin() does not affect the DBAPI connection, isolation stays at AUTOCOMMIT\n    with connection.begin() as trans:\n        connection.execute(text(\"<statement>\"))\n        connection.execute(text(\"<statement>\"))\n```", "```py\nINFO sqlalchemy.engine.Engine BEGIN (implicit)\n...\nINFO sqlalchemy.engine.Engine COMMIT using DBAPI connection.commit(), DBAPI should ignore due to autocommit mode\n```", "```py\nwith engine.connect() as connection:\n    connection = connection.execution_options(isolation_level=\"AUTOCOMMIT\")\n\n    # \"transaction\" is autobegin (but has no effect due to autocommit)\n    connection.execute(text(\"<statement>\"))\n\n    # this will raise; \"transaction\" is already begun\n    with connection.begin() as trans:\n        connection.execute(text(\"<statement>\"))\n```", "```py\n# if we wanted to flip autocommit on and off on a single connection/\n# which... we usually don't.\n\nwith engine.connect() as connection:\n    connection.execution_options(isolation_level=\"AUTOCOMMIT\")\n\n    # run statement(s) in autocommit mode\n    connection.execute(text(\"<statement>\"))\n\n    # \"commit\" the autobegun \"transaction\"\n    connection.commit()\n\n    # switch to default isolation level\n    connection.execution_options(isolation_level=connection.default_isolation_level)\n\n    # use a begin block\n    with connection.begin() as trans:\n        connection.execute(text(\"<statement>\"))\n```", "```py\n# use an autocommit block\nwith engine.connect().execution_options(isolation_level=\"AUTOCOMMIT\") as connection:\n    # run statement in autocommit mode\n    connection.execute(text(\"<statement>\"))\n\n# use a regular block\nwith engine.begin() as connection:\n    connection.execute(text(\"<statement>\"))\n```", "```py\n# possible values for Connection.execution_options(isolation_level=\"<value>\")\n\n\"AUTOCOMMIT\"\n\"READ COMMITTED\"\n\"READ UNCOMMITTED\"\n\"REPEATABLE READ\"\n\"SERIALIZABLE\"\n```", "```py\nwith engine.connect().execution_options(\n    isolation_level=\"REPEATABLE READ\"\n) as connection:\n    with connection.begin():\n        connection.execute(text(\"<statement>\"))\n```", "```py\nfrom sqlalchemy import create_engine\n\neng = create_engine(\n    \"postgresql://scott:tiger@localhost/test\", isolation_level=\"REPEATABLE READ\"\n)\n```", "```py\nfrom sqlalchemy import create_engine\n\neng = create_engine(\n    \"postgresql+psycopg2://scott:tiger@localhost/test\",\n    execution_options={\"isolation_level\": \"REPEATABLE READ\"},\n)\n```", "```py\nfrom sqlalchemy import create_engine\n\neng = create_engine(\"postgresql+psycopg2://scott:tiger@localhost/test\")\n\nautocommit_engine = eng.execution_options(isolation_level=\"AUTOCOMMIT\")\n```", "```py\nwith engine.connect() as connection:\n    connection.execution_options(isolation_level=\"AUTOCOMMIT\")\n    connection.execute(text(\"<statement>\"))\n    connection.execute(text(\"<statement>\"))\n```", "```py\nwith engine.connect() as connection:\n    connection = connection.execution_options(isolation_level=\"AUTOCOMMIT\")\n\n    # this begin() does not affect the DBAPI connection, isolation stays at AUTOCOMMIT\n    with connection.begin() as trans:\n        connection.execute(text(\"<statement>\"))\n        connection.execute(text(\"<statement>\"))\n```", "```py\nINFO sqlalchemy.engine.Engine BEGIN (implicit)\n...\nINFO sqlalchemy.engine.Engine COMMIT using DBAPI connection.commit(), DBAPI should ignore due to autocommit mode\n```", "```py\nwith engine.connect() as connection:\n    connection = connection.execution_options(isolation_level=\"AUTOCOMMIT\")\n\n    # \"transaction\" is autobegin (but has no effect due to autocommit)\n    connection.execute(text(\"<statement>\"))\n\n    # this will raise; \"transaction\" is already begun\n    with connection.begin() as trans:\n        connection.execute(text(\"<statement>\"))\n```", "```py\n# if we wanted to flip autocommit on and off on a single connection/\n# which... we usually don't.\n\nwith engine.connect() as connection:\n    connection.execution_options(isolation_level=\"AUTOCOMMIT\")\n\n    # run statement(s) in autocommit mode\n    connection.execute(text(\"<statement>\"))\n\n    # \"commit\" the autobegun \"transaction\"\n    connection.commit()\n\n    # switch to default isolation level\n    connection.execution_options(isolation_level=connection.default_isolation_level)\n\n    # use a begin block\n    with connection.begin() as trans:\n        connection.execute(text(\"<statement>\"))\n```", "```py\n# use an autocommit block\nwith engine.connect().execution_options(isolation_level=\"AUTOCOMMIT\") as connection:\n    # run statement in autocommit mode\n    connection.execute(text(\"<statement>\"))\n\n# use a regular block\nwith engine.begin() as connection:\n    connection.execute(text(\"<statement>\"))\n```", "```py\n# if we wanted to flip autocommit on and off on a single connection/\n# which... we usually don't.\n\nwith engine.connect() as connection:\n    connection.execution_options(isolation_level=\"AUTOCOMMIT\")\n\n    # run statement(s) in autocommit mode\n    connection.execute(text(\"<statement>\"))\n\n    # \"commit\" the autobegun \"transaction\"\n    connection.commit()\n\n    # switch to default isolation level\n    connection.execution_options(isolation_level=connection.default_isolation_level)\n\n    # use a begin block\n    with connection.begin() as trans:\n        connection.execute(text(\"<statement>\"))\n```", "```py\n# use an autocommit block\nwith engine.connect().execution_options(isolation_level=\"AUTOCOMMIT\") as connection:\n    # run statement in autocommit mode\n    connection.execute(text(\"<statement>\"))\n\n# use a regular block\nwith engine.begin() as connection:\n    connection.execute(text(\"<statement>\"))\n```", "```py\nwith engine.connect() as conn:\n    with conn.execution_options(yield_per=100).execute(\n        text(\"select * from table\")\n    ) as result:\n        for partition in result.partitions():\n            # partition is an iterable that will be at most 100 items\n            for row in partition:\n                print(f\"{row}\")\n```", "```py\nwith engine.connect() as conn:\n    with conn.execution_options(stream_results=True, max_row_buffer=100).execute(\n        text(\"select * from table\")\n    ) as result:\n        for row in result:\n            print(f\"{row}\")\n```", "```py\nwith engine.connect() as conn:\n    with conn.execution_options(yield_per=100).execute(\n        text(\"select * from table\")\n    ) as result:\n        for partition in result.partitions():\n            # partition is an iterable that will be at most 100 items\n            for row in partition:\n                print(f\"{row}\")\n```", "```py\nwith engine.connect() as conn:\n    with conn.execution_options(stream_results=True, max_row_buffer=100).execute(\n        text(\"select * from table\")\n    ) as result:\n        for row in result:\n            print(f\"{row}\")\n```", "```py\nuser_table = Table(\n    \"user\",\n    metadata_obj,\n    Column(\"id\", Integer, primary_key=True),\n    Column(\"name\", String(50)),\n)\n```", "```py\nconnection = engine.connect().execution_options(\n    schema_translate_map={None: \"user_schema_one\"}\n)\n\nresult = connection.execute(user_table.select())\n```", "```py\nSELECT  user_schema_one.user.id,  user_schema_one.user.name  FROM\nuser_schema_one.user\n```", "```py\nconnection = engine.connect().execution_options(\n    schema_translate_map={\n        None: \"user_schema_one\",  # no schema name -> \"user_schema_one\"\n        \"special\": \"special_schema\",  # schema=\"special\" becomes \"special_schema\"\n        \"public\": None,  # Table objects with schema=\"public\" will render with no schema\n    }\n)\n```", "```py\nschema_engine = engine.execution_options(schema_translate_map={...})\n\nsession = Session(schema_engine)\n\n...\n```", "```py\ndef run_my_statement(connection, parameter):\n    stmt = select(table)\n    stmt = stmt.where(table.c.col == parameter)\n    stmt = stmt.order_by(table.c.id)\n    return connection.execute(stmt)\n```", "```py\nengine = create_engine(\n    \"postgresql+psycopg2://scott:tiger@localhost/test\", query_cache_size=1200\n)\n```", "```py\nfrom sqlalchemy import Column\nfrom sqlalchemy import create_engine\nfrom sqlalchemy import ForeignKey\nfrom sqlalchemy import Integer\nfrom sqlalchemy import select\nfrom sqlalchemy import String\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import relationship\nfrom sqlalchemy.orm import Session\n\nBase = declarative_base()\n\nclass A(Base):\n    __tablename__ = \"a\"\n\n    id = Column(Integer, primary_key=True)\n    data = Column(String)\n    bs = relationship(\"B\")\n\nclass B(Base):\n    __tablename__ = \"b\"\n    id = Column(Integer, primary_key=True)\n    a_id = Column(ForeignKey(\"a.id\"))\n    data = Column(String)\n\ne = create_engine(\"sqlite://\", echo=True)\nBase.metadata.create_all(e)\n\ns = Session(e)\n\ns.add_all([A(bs=[B(), B(), B()]), A(bs=[B(), B(), B()]), A(bs=[B(), B(), B()])])\ns.commit()\n\nfor a_rec in s.scalars(select(A)):\n    print(a_rec.bs)\n```", "```py\nINFO sqlalchemy.engine.Engine PRAGMA temp.table_info(\"a\")\nINFO sqlalchemy.engine.Engine [raw sql] ()\nINFO sqlalchemy.engine.Engine PRAGMA main.table_info(\"b\")\nINFO sqlalchemy.engine.Engine [raw sql] ()\n```", "```py\nINFO  sqlalchemy.engine.Engine\nCREATE  TABLE  a  (\n  id  INTEGER  NOT  NULL,\n  data  VARCHAR,\n  PRIMARY  KEY  (id)\n)\n\nINFO  sqlalchemy.engine.Engine  [no  key  0.00007s]  ()\nINFO  sqlalchemy.engine.Engine\nCREATE  TABLE  b  (\n  id  INTEGER  NOT  NULL,\n  a_id  INTEGER,\n  data  VARCHAR,\n  PRIMARY  KEY  (id),\n  FOREIGN  KEY(a_id)  REFERENCES  a  (id)\n)\n\nINFO  sqlalchemy.engine.Engine  [no  key  0.00006s]  ()\n```", "```py\nINFO  sqlalchemy.engine.Engine  INSERT  INTO  a  (data)  VALUES  (?)\nINFO  sqlalchemy.engine.Engine  [generated  in  0.00011s]  (None,)\nINFO  sqlalchemy.engine.Engine  INSERT  INTO  a  (data)  VALUES  (?)\nINFO  sqlalchemy.engine.Engine  [cached  since  0.0003533s  ago]  (None,)\nINFO  sqlalchemy.engine.Engine  INSERT  INTO  a  (data)  VALUES  (?)\nINFO  sqlalchemy.engine.Engine  [cached  since  0.0005326s  ago]  (None,)\nINFO  sqlalchemy.engine.Engine  INSERT  INTO  b  (a_id,  data)  VALUES  (?,  ?)\nINFO  sqlalchemy.engine.Engine  [generated  in  0.00010s]  (1,  None)\nINFO  sqlalchemy.engine.Engine  INSERT  INTO  b  (a_id,  data)  VALUES  (?,  ?)\nINFO  sqlalchemy.engine.Engine  [cached  since  0.0003232s  ago]  (1,  None)\nINFO  sqlalchemy.engine.Engine  INSERT  INTO  b  (a_id,  data)  VALUES  (?,  ?)\nINFO  sqlalchemy.engine.Engine  [cached  since  0.0004887s  ago]  (1,  None)\n```", "```py\nINFO sqlalchemy.engine.Engine SELECT a.id AS a_id, a.data AS a_data\nFROM a\nINFO sqlalchemy.engine.Engine [generated in 0.00009s] ()\nINFO sqlalchemy.engine.Engine SELECT b.id AS b_id, b.a_id AS b_a_id, b.data AS b_data\nFROM b\nWHERE ? = b.a_id\nINFO sqlalchemy.engine.Engine [generated in 0.00010s] (1,)\nINFO sqlalchemy.engine.Engine SELECT b.id AS b_id, b.a_id AS b_a_id, b.data AS b_data\nFROM b\nWHERE ? = b.a_id\nINFO sqlalchemy.engine.Engine [cached since 0.0005922s ago] (2,)\nINFO sqlalchemy.engine.Engine SELECT b.id AS b_id, b.a_id AS b_a_id, b.data AS b_data\nFROM b\nWHERE ? = b.a_id\n```", "```py\nmy_cache = {}\nwith engine.connect().execution_options(compiled_cache=my_cache) as conn:\n    conn.execute(table.select())\n```", "```py\n# disable caching for this connection\nwith engine.connect().execution_options(compiled_cache=None) as conn:\n    conn.execute(table.select())\n```", "```py\nfrom sqlalchemy.engine.default import DefaultDialect\n\nclass MyDialect(DefaultDialect):\n    supports_statement_cache = True\n```", "```py\nclass MyDBAPIForMyDialect(MyDialect):\n    supports_statement_cache = True\n```", "```py\n# pre 1.4 style code\ndef limit_clause(self, select, **kw):\n    text = \"\"\n    if select._limit is not None:\n        text += \" \\n LIMIT %d\" % (select._limit,)\n    if select._offset is not None:\n        text += \" \\n OFFSET %d\" % (select._offset,)\n    return text\n```", "```py\n# 1.4 cache-compatible code\ndef limit_clause(self, select, **kw):\n    text = \"\"\n\n    limit_clause = select._limit_clause\n    offset_clause = select._offset_clause\n\n    if select._simple_int_clause(limit_clause):\n        text += \" \\n LIMIT %s\" % (\n            self.process(limit_clause.render_literal_execute(), **kw)\n        )\n    elif limit_clause is not None:\n        # assuming the DB doesn't support SQL expressions for LIMIT.\n        # Otherwise render here normally\n        raise exc.CompileError(\n            \"dialect 'mydialect' can only render simple integers for LIMIT\"\n        )\n    if select._simple_int_clause(offset_clause):\n        text += \" \\n OFFSET %s\" % (\n            self.process(offset_clause.render_literal_execute(), **kw)\n        )\n    elif offset_clause is not None:\n        # assuming the DB doesn't support SQL expressions for OFFSET.\n        # Otherwise render here normally\n        raise exc.CompileError(\n            \"dialect 'mydialect' can only render simple integers for OFFSET\"\n        )\n\n    return text\n```", "```py\nSELECT  x  FROM  y\nLIMIT  __[POSTCOMPILE_param_1]\nOFFSET  __[POSTCOMPILE_param_2]\n```", "```py\nfrom sqlalchemy import lambda_stmt\n\ndef run_my_statement(connection, parameter):\n    stmt = lambda_stmt(lambda: select(table))\n    stmt += lambda s: s.where(table.c.col == parameter)\n    stmt += lambda s: s.order_by(table.c.id)\n\n    return connection.execute(stmt)\n\nwith engine.connect() as conn:\n    result = run_my_statement(some_connection, \"some parameter\")\n```", "```py\n    def upd(id_, newname):\n        stmt = lambda_stmt(lambda: users.update())\n        stmt += lambda s: s.values(name=newname)\n        stmt += lambda s: s.where(users.c.id == id_)\n        return stmt\n\n    with engine.begin() as conn:\n        conn.execute(upd(7, \"foo\"))\n    ```", "```py\n    def select_user(session, name):\n        stmt = lambda_stmt(lambda: select(User))\n        stmt += lambda s: s.where(User.name == name)\n\n        row = session.execute(stmt).first()\n        return row\n    ```", "```py\n    >>> def my_stmt(x, y):\n    ...     stmt = lambda_stmt(lambda: select(func.max(x, y)))\n    ...     return stmt\n    >>> engine = create_engine(\"sqlite://\", echo=True)\n    >>> with engine.connect() as conn:\n    ...     print(conn.scalar(my_stmt(5, 10)))\n    ...     print(conn.scalar(my_stmt(12, 8)))\n    SELECT  max(?,  ?)  AS  max_1\n    [generated  in  0.00057s]  (5,  10)\n    10\n    SELECT  max(?,  ?)  AS  max_1\n    [cached  since  0.002059s  ago]  (12,  8)\n    12\n    ```", "```py\n    # **Don't** do this:\n\n    def my_stmt(parameter, thing=False):\n        stmt = lambda_stmt(lambda: select(table))\n        stmt += lambda s: (\n            s.where(table.c.x > parameter) if thing else s.where(table.c.y == parameter)\n        )\n        return stmt\n\n    # **Do** do this:\n\n    def my_stmt(parameter, thing=False):\n        stmt = lambda_stmt(lambda: select(table))\n        if thing:\n            stmt += lambda s: s.where(table.c.x > parameter)\n        else:\n            stmt += lambda s: s.where(table.c.y == parameter)\n        return stmt\n    ```", "```py\n    >>> def my_stmt(x, y):\n    ...     def get_x():\n    ...         return x\n    ...\n    ...     def get_y():\n    ...         return y\n    ...\n    ...     stmt = lambda_stmt(lambda: select(func.max(get_x(), get_y())))\n    ...     return stmt\n    >>> with engine.connect() as conn:\n    ...     print(conn.scalar(my_stmt(5, 10)))\n    Traceback (most recent call last):\n     # ...\n    sqlalchemy.exc.InvalidRequestError: Can't invoke Python callable get_x()\n    inside of lambda expression argument at\n    <code object <lambda> at 0x7fed15f350e0, file \"<stdin>\", line 6>;\n    lambda SQL constructs should not invoke functions from closure variables\n    to produce literal values since the lambda SQL system normally extracts\n    bound values without actually invoking the lambda or any functions within it.\n    ```", "```py\n    >>> def my_stmt(x, y):\n    ...     def get_x():\n    ...         return x\n    ...\n    ...     def get_y():\n    ...         return y\n    ...\n    ...     x_param, y_param = get_x(), get_y()\n    ...     stmt = lambda_stmt(lambda: select(func.max(x_param, y_param)))\n    ...     return stmt\n    ```", "```py\n    >>> class Foo:\n    ...     def __init__(self, x, y):\n    ...         self.x = x\n    ...         self.y = y\n    >>> def my_stmt(foo):\n    ...     stmt = lambda_stmt(lambda: select(func.max(foo.x, foo.y)))\n    ...     return stmt\n    >>> with engine.connect() as conn:\n    ...     print(conn.scalar(my_stmt(Foo(5, 10))))\n    Traceback (most recent call last):\n     # ...\n    sqlalchemy.exc.InvalidRequestError: Closure variable named 'foo' inside of\n    lambda callable <code object <lambda> at 0x7fed15f35450, file\n    \"<stdin>\", line 2> does not refer to a cacheable SQL element, and also\n    does not appear to be serving as a SQL literal bound value based on the\n    default SQL expression returned by the function.  This variable needs to\n    remain outside the scope of a SQL-generating lambda so that a proper cache\n    key may be generated from the lambda's state.  Evaluate this variable\n    outside of the lambda, set track_on=[<elements>] to explicitly select\n    closure elements to track, or set track_closure_variables=False to exclude\n    closure variables from being part of the cache key.\n    ```", "```py\n    >>> def my_stmt(foo):\n    ...     x_param, y_param = foo.x, foo.y\n    ...     stmt = lambda_stmt(lambda: select(func.max(x_param, y_param)))\n    ...     return stmt\n    ```", "```py\n    >>> def my_stmt(foo):\n    ...     stmt = lambda_stmt(\n    ...         lambda: select(func.max(foo.x, foo.y)), track_closure_variables=False\n    ...     )\n    ...     return stmt\n    ```", "```py\n    >>> def my_stmt(self, foo):\n    ...     stmt = lambda_stmt(\n    ...         lambda: select(*self.column_expressions), track_closure_variables=False\n    ...     )\n    ...     stmt = stmt.add_criteria(lambda: self.where_criteria, track_on=[self])\n    ...     return stmt\n    ```", "```py\n>>> from sqlalchemy import select, column\n>>> stmt = select(column(\"q\"))\n>>> cache_key = stmt._generate_cache_key()\n>>> print(cache_key)  # somewhat paraphrased\nCacheKey(key=(\n '0',\n <class 'sqlalchemy.sql.selectable.Select'>,\n '_raw_columns',\n (\n (\n '1',\n <class 'sqlalchemy.sql.elements.ColumnClause'>,\n 'name',\n 'q',\n 'type',\n (\n <class 'sqlalchemy.sql.sqltypes.NullType'>,\n ),\n ),\n ),\n # a few more elements are here, and many more for a more\n # complicated SELECT statement\n),)\n```", "```py\n>>> from sqlalchemy import lambda_stmt\n>>> stmt = lambda_stmt(lambda: select(column(\"q\")))\n>>> cache_key = stmt._generate_cache_key()\n>>> print(cache_key)\nCacheKey(key=(\n <code object <lambda> at 0x7fed1617c710, file \"<stdin>\", line 1>,\n <class 'sqlalchemy.sql.lambdas.StatementLambdaElement'>,\n),)\n```", "```py\n>>> def my_stmt(parameter):\n...     col = column(\"q\")\n...     stmt = lambda_stmt(lambda: select(col))\n...     stmt += lambda s: s.where(col == parameter)\n...     return stmt\n```", "```py\n>>> stmt = my_stmt(5)\n>>> key = stmt._generate_cache_key()\n>>> print(key)\nCacheKey(key=(\n <code object <lambda> at 0x7f07323c50e0, file \"<stdin>\", line 3>,\n (\n '0',\n <class 'sqlalchemy.sql.elements.ColumnClause'>,\n 'name',\n 'q',\n 'type',\n (\n <class 'sqlalchemy.sql.sqltypes.NullType'>,\n ),\n ),\n <code object <lambda> at 0x7f07323c5190, file \"<stdin>\", line 4>,\n <class 'sqlalchemy.sql.lambdas.LinkedLambdaElement'>,\n (\n '0',\n <class 'sqlalchemy.sql.elements.ColumnClause'>,\n 'name',\n 'q',\n 'type',\n (\n <class 'sqlalchemy.sql.sqltypes.NullType'>,\n ),\n ),\n (\n '0',\n <class 'sqlalchemy.sql.elements.ColumnClause'>,\n 'name',\n 'q',\n 'type',\n (\n <class 'sqlalchemy.sql.sqltypes.NullType'>,\n ),\n ),\n),)\n```", "```py\n>>> key.bindparams\n[BindParameter('%(139668884281280 parameter)s', 5, type_=Integer())]\n```", "```py\nengine = create_engine(\n    \"postgresql+psycopg2://scott:tiger@localhost/test\", query_cache_size=1200\n)\n```", "```py\nfrom sqlalchemy import Column\nfrom sqlalchemy import create_engine\nfrom sqlalchemy import ForeignKey\nfrom sqlalchemy import Integer\nfrom sqlalchemy import select\nfrom sqlalchemy import String\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import relationship\nfrom sqlalchemy.orm import Session\n\nBase = declarative_base()\n\nclass A(Base):\n    __tablename__ = \"a\"\n\n    id = Column(Integer, primary_key=True)\n    data = Column(String)\n    bs = relationship(\"B\")\n\nclass B(Base):\n    __tablename__ = \"b\"\n    id = Column(Integer, primary_key=True)\n    a_id = Column(ForeignKey(\"a.id\"))\n    data = Column(String)\n\ne = create_engine(\"sqlite://\", echo=True)\nBase.metadata.create_all(e)\n\ns = Session(e)\n\ns.add_all([A(bs=[B(), B(), B()]), A(bs=[B(), B(), B()]), A(bs=[B(), B(), B()])])\ns.commit()\n\nfor a_rec in s.scalars(select(A)):\n    print(a_rec.bs)\n```", "```py\nINFO sqlalchemy.engine.Engine PRAGMA temp.table_info(\"a\")\nINFO sqlalchemy.engine.Engine [raw sql] ()\nINFO sqlalchemy.engine.Engine PRAGMA main.table_info(\"b\")\nINFO sqlalchemy.engine.Engine [raw sql] ()\n```", "```py\nINFO  sqlalchemy.engine.Engine\nCREATE  TABLE  a  (\n  id  INTEGER  NOT  NULL,\n  data  VARCHAR,\n  PRIMARY  KEY  (id)\n)\n\nINFO  sqlalchemy.engine.Engine  [no  key  0.00007s]  ()\nINFO  sqlalchemy.engine.Engine\nCREATE  TABLE  b  (\n  id  INTEGER  NOT  NULL,\n  a_id  INTEGER,\n  data  VARCHAR,\n  PRIMARY  KEY  (id),\n  FOREIGN  KEY(a_id)  REFERENCES  a  (id)\n)\n\nINFO  sqlalchemy.engine.Engine  [no  key  0.00006s]  ()\n```", "```py\nINFO  sqlalchemy.engine.Engine  INSERT  INTO  a  (data)  VALUES  (?)\nINFO  sqlalchemy.engine.Engine  [generated  in  0.00011s]  (None,)\nINFO  sqlalchemy.engine.Engine  INSERT  INTO  a  (data)  VALUES  (?)\nINFO  sqlalchemy.engine.Engine  [cached  since  0.0003533s  ago]  (None,)\nINFO  sqlalchemy.engine.Engine  INSERT  INTO  a  (data)  VALUES  (?)\nINFO  sqlalchemy.engine.Engine  [cached  since  0.0005326s  ago]  (None,)\nINFO  sqlalchemy.engine.Engine  INSERT  INTO  b  (a_id,  data)  VALUES  (?,  ?)\nINFO  sqlalchemy.engine.Engine  [generated  in  0.00010s]  (1,  None)\nINFO  sqlalchemy.engine.Engine  INSERT  INTO  b  (a_id,  data)  VALUES  (?,  ?)\nINFO  sqlalchemy.engine.Engine  [cached  since  0.0003232s  ago]  (1,  None)\nINFO  sqlalchemy.engine.Engine  INSERT  INTO  b  (a_id,  data)  VALUES  (?,  ?)\nINFO  sqlalchemy.engine.Engine  [cached  since  0.0004887s  ago]  (1,  None)\n```", "```py\nINFO sqlalchemy.engine.Engine SELECT a.id AS a_id, a.data AS a_data\nFROM a\nINFO sqlalchemy.engine.Engine [generated in 0.00009s] ()\nINFO sqlalchemy.engine.Engine SELECT b.id AS b_id, b.a_id AS b_a_id, b.data AS b_data\nFROM b\nWHERE ? = b.a_id\nINFO sqlalchemy.engine.Engine [generated in 0.00010s] (1,)\nINFO sqlalchemy.engine.Engine SELECT b.id AS b_id, b.a_id AS b_a_id, b.data AS b_data\nFROM b\nWHERE ? = b.a_id\nINFO sqlalchemy.engine.Engine [cached since 0.0005922s ago] (2,)\nINFO sqlalchemy.engine.Engine SELECT b.id AS b_id, b.a_id AS b_a_id, b.data AS b_data\nFROM b\nWHERE ? = b.a_id\n```", "```py\nmy_cache = {}\nwith engine.connect().execution_options(compiled_cache=my_cache) as conn:\n    conn.execute(table.select())\n```", "```py\n# disable caching for this connection\nwith engine.connect().execution_options(compiled_cache=None) as conn:\n    conn.execute(table.select())\n```", "```py\nfrom sqlalchemy.engine.default import DefaultDialect\n\nclass MyDialect(DefaultDialect):\n    supports_statement_cache = True\n```", "```py\nclass MyDBAPIForMyDialect(MyDialect):\n    supports_statement_cache = True\n```", "```py\n# pre 1.4 style code\ndef limit_clause(self, select, **kw):\n    text = \"\"\n    if select._limit is not None:\n        text += \" \\n LIMIT %d\" % (select._limit,)\n    if select._offset is not None:\n        text += \" \\n OFFSET %d\" % (select._offset,)\n    return text\n```", "```py\n# 1.4 cache-compatible code\ndef limit_clause(self, select, **kw):\n    text = \"\"\n\n    limit_clause = select._limit_clause\n    offset_clause = select._offset_clause\n\n    if select._simple_int_clause(limit_clause):\n        text += \" \\n LIMIT %s\" % (\n            self.process(limit_clause.render_literal_execute(), **kw)\n        )\n    elif limit_clause is not None:\n        # assuming the DB doesn't support SQL expressions for LIMIT.\n        # Otherwise render here normally\n        raise exc.CompileError(\n            \"dialect 'mydialect' can only render simple integers for LIMIT\"\n        )\n    if select._simple_int_clause(offset_clause):\n        text += \" \\n OFFSET %s\" % (\n            self.process(offset_clause.render_literal_execute(), **kw)\n        )\n    elif offset_clause is not None:\n        # assuming the DB doesn't support SQL expressions for OFFSET.\n        # Otherwise render here normally\n        raise exc.CompileError(\n            \"dialect 'mydialect' can only render simple integers for OFFSET\"\n        )\n\n    return text\n```", "```py\nSELECT  x  FROM  y\nLIMIT  __[POSTCOMPILE_param_1]\nOFFSET  __[POSTCOMPILE_param_2]\n```", "```py\n# pre 1.4 style code\ndef limit_clause(self, select, **kw):\n    text = \"\"\n    if select._limit is not None:\n        text += \" \\n LIMIT %d\" % (select._limit,)\n    if select._offset is not None:\n        text += \" \\n OFFSET %d\" % (select._offset,)\n    return text\n```", "```py\n# 1.4 cache-compatible code\ndef limit_clause(self, select, **kw):\n    text = \"\"\n\n    limit_clause = select._limit_clause\n    offset_clause = select._offset_clause\n\n    if select._simple_int_clause(limit_clause):\n        text += \" \\n LIMIT %s\" % (\n            self.process(limit_clause.render_literal_execute(), **kw)\n        )\n    elif limit_clause is not None:\n        # assuming the DB doesn't support SQL expressions for LIMIT.\n        # Otherwise render here normally\n        raise exc.CompileError(\n            \"dialect 'mydialect' can only render simple integers for LIMIT\"\n        )\n    if select._simple_int_clause(offset_clause):\n        text += \" \\n OFFSET %s\" % (\n            self.process(offset_clause.render_literal_execute(), **kw)\n        )\n    elif offset_clause is not None:\n        # assuming the DB doesn't support SQL expressions for OFFSET.\n        # Otherwise render here normally\n        raise exc.CompileError(\n            \"dialect 'mydialect' can only render simple integers for OFFSET\"\n        )\n\n    return text\n```", "```py\nSELECT  x  FROM  y\nLIMIT  __[POSTCOMPILE_param_1]\nOFFSET  __[POSTCOMPILE_param_2]\n```", "```py\nfrom sqlalchemy import lambda_stmt\n\ndef run_my_statement(connection, parameter):\n    stmt = lambda_stmt(lambda: select(table))\n    stmt += lambda s: s.where(table.c.col == parameter)\n    stmt += lambda s: s.order_by(table.c.id)\n\n    return connection.execute(stmt)\n\nwith engine.connect() as conn:\n    result = run_my_statement(some_connection, \"some parameter\")\n```", "```py\n    def upd(id_, newname):\n        stmt = lambda_stmt(lambda: users.update())\n        stmt += lambda s: s.values(name=newname)\n        stmt += lambda s: s.where(users.c.id == id_)\n        return stmt\n\n    with engine.begin() as conn:\n        conn.execute(upd(7, \"foo\"))\n    ```", "```py\n    def select_user(session, name):\n        stmt = lambda_stmt(lambda: select(User))\n        stmt += lambda s: s.where(User.name == name)\n\n        row = session.execute(stmt).first()\n        return row\n    ```", "```py\n    >>> def my_stmt(x, y):\n    ...     stmt = lambda_stmt(lambda: select(func.max(x, y)))\n    ...     return stmt\n    >>> engine = create_engine(\"sqlite://\", echo=True)\n    >>> with engine.connect() as conn:\n    ...     print(conn.scalar(my_stmt(5, 10)))\n    ...     print(conn.scalar(my_stmt(12, 8)))\n    SELECT  max(?,  ?)  AS  max_1\n    [generated  in  0.00057s]  (5,  10)\n    10\n    SELECT  max(?,  ?)  AS  max_1\n    [cached  since  0.002059s  ago]  (12,  8)\n    12\n    ```", "```py\n    # **Don't** do this:\n\n    def my_stmt(parameter, thing=False):\n        stmt = lambda_stmt(lambda: select(table))\n        stmt += lambda s: (\n            s.where(table.c.x > parameter) if thing else s.where(table.c.y == parameter)\n        )\n        return stmt\n\n    # **Do** do this:\n\n    def my_stmt(parameter, thing=False):\n        stmt = lambda_stmt(lambda: select(table))\n        if thing:\n            stmt += lambda s: s.where(table.c.x > parameter)\n        else:\n            stmt += lambda s: s.where(table.c.y == parameter)\n        return stmt\n    ```", "```py\n    >>> def my_stmt(x, y):\n    ...     def get_x():\n    ...         return x\n    ...\n    ...     def get_y():\n    ...         return y\n    ...\n    ...     stmt = lambda_stmt(lambda: select(func.max(get_x(), get_y())))\n    ...     return stmt\n    >>> with engine.connect() as conn:\n    ...     print(conn.scalar(my_stmt(5, 10)))\n    Traceback (most recent call last):\n     # ...\n    sqlalchemy.exc.InvalidRequestError: Can't invoke Python callable get_x()\n    inside of lambda expression argument at\n    <code object <lambda> at 0x7fed15f350e0, file \"<stdin>\", line 6>;\n    lambda SQL constructs should not invoke functions from closure variables\n    to produce literal values since the lambda SQL system normally extracts\n    bound values without actually invoking the lambda or any functions within it.\n    ```", "```py\n    >>> def my_stmt(x, y):\n    ...     def get_x():\n    ...         return x\n    ...\n    ...     def get_y():\n    ...         return y\n    ...\n    ...     x_param, y_param = get_x(), get_y()\n    ...     stmt = lambda_stmt(lambda: select(func.max(x_param, y_param)))\n    ...     return stmt\n    ```", "```py\n    >>> class Foo:\n    ...     def __init__(self, x, y):\n    ...         self.x = x\n    ...         self.y = y\n    >>> def my_stmt(foo):\n    ...     stmt = lambda_stmt(lambda: select(func.max(foo.x, foo.y)))\n    ...     return stmt\n    >>> with engine.connect() as conn:\n    ...     print(conn.scalar(my_stmt(Foo(5, 10))))\n    Traceback (most recent call last):\n     # ...\n    sqlalchemy.exc.InvalidRequestError: Closure variable named 'foo' inside of\n    lambda callable <code object <lambda> at 0x7fed15f35450, file\n    \"<stdin>\", line 2> does not refer to a cacheable SQL element, and also\n    does not appear to be serving as a SQL literal bound value based on the\n    default SQL expression returned by the function.  This variable needs to\n    remain outside the scope of a SQL-generating lambda so that a proper cache\n    key may be generated from the lambda's state.  Evaluate this variable\n    outside of the lambda, set track_on=[<elements>] to explicitly select\n    closure elements to track, or set track_closure_variables=False to exclude\n    closure variables from being part of the cache key.\n    ```", "```py\n    >>> def my_stmt(foo):\n    ...     x_param, y_param = foo.x, foo.y\n    ...     stmt = lambda_stmt(lambda: select(func.max(x_param, y_param)))\n    ...     return stmt\n    ```", "```py\n    >>> def my_stmt(foo):\n    ...     stmt = lambda_stmt(\n    ...         lambda: select(func.max(foo.x, foo.y)), track_closure_variables=False\n    ...     )\n    ...     return stmt\n    ```", "```py\n    >>> def my_stmt(self, foo):\n    ...     stmt = lambda_stmt(\n    ...         lambda: select(*self.column_expressions), track_closure_variables=False\n    ...     )\n    ...     stmt = stmt.add_criteria(lambda: self.where_criteria, track_on=[self])\n    ...     return stmt\n    ```", "```py\n>>> from sqlalchemy import select, column\n>>> stmt = select(column(\"q\"))\n>>> cache_key = stmt._generate_cache_key()\n>>> print(cache_key)  # somewhat paraphrased\nCacheKey(key=(\n '0',\n <class 'sqlalchemy.sql.selectable.Select'>,\n '_raw_columns',\n (\n (\n '1',\n <class 'sqlalchemy.sql.elements.ColumnClause'>,\n 'name',\n 'q',\n 'type',\n (\n <class 'sqlalchemy.sql.sqltypes.NullType'>,\n ),\n ),\n ),\n # a few more elements are here, and many more for a more\n # complicated SELECT statement\n),)\n```", "```py\n>>> from sqlalchemy import lambda_stmt\n>>> stmt = lambda_stmt(lambda: select(column(\"q\")))\n>>> cache_key = stmt._generate_cache_key()\n>>> print(cache_key)\nCacheKey(key=(\n <code object <lambda> at 0x7fed1617c710, file \"<stdin>\", line 1>,\n <class 'sqlalchemy.sql.lambdas.StatementLambdaElement'>,\n),)\n```", "```py\n>>> def my_stmt(parameter):\n...     col = column(\"q\")\n...     stmt = lambda_stmt(lambda: select(col))\n...     stmt += lambda s: s.where(col == parameter)\n...     return stmt\n```", "```py\n>>> stmt = my_stmt(5)\n>>> key = stmt._generate_cache_key()\n>>> print(key)\nCacheKey(key=(\n <code object <lambda> at 0x7f07323c50e0, file \"<stdin>\", line 3>,\n (\n '0',\n <class 'sqlalchemy.sql.elements.ColumnClause'>,\n 'name',\n 'q',\n 'type',\n (\n <class 'sqlalchemy.sql.sqltypes.NullType'>,\n ),\n ),\n <code object <lambda> at 0x7f07323c5190, file \"<stdin>\", line 4>,\n <class 'sqlalchemy.sql.lambdas.LinkedLambdaElement'>,\n (\n '0',\n <class 'sqlalchemy.sql.elements.ColumnClause'>,\n 'name',\n 'q',\n 'type',\n (\n <class 'sqlalchemy.sql.sqltypes.NullType'>,\n ),\n ),\n (\n '0',\n <class 'sqlalchemy.sql.elements.ColumnClause'>,\n 'name',\n 'q',\n 'type',\n (\n <class 'sqlalchemy.sql.sqltypes.NullType'>,\n ),\n ),\n),)\n```", "```py\n>>> key.bindparams\n[BindParameter('%(139668884281280 parameter)s', 5, type_=Integer())]\n```", "```py\nfrom sqlalchemy import lambda_stmt\n\ndef run_my_statement(connection, parameter):\n    stmt = lambda_stmt(lambda: select(table))\n    stmt += lambda s: s.where(table.c.col == parameter)\n    stmt += lambda s: s.order_by(table.c.id)\n\n    return connection.execute(stmt)\n\nwith engine.connect() as conn:\n    result = run_my_statement(some_connection, \"some parameter\")\n```", "```py\n    def upd(id_, newname):\n        stmt = lambda_stmt(lambda: users.update())\n        stmt += lambda s: s.values(name=newname)\n        stmt += lambda s: s.where(users.c.id == id_)\n        return stmt\n\n    with engine.begin() as conn:\n        conn.execute(upd(7, \"foo\"))\n    ```", "```py\n    def select_user(session, name):\n        stmt = lambda_stmt(lambda: select(User))\n        stmt += lambda s: s.where(User.name == name)\n\n        row = session.execute(stmt).first()\n        return row\n    ```", "```py\n    >>> def my_stmt(x, y):\n    ...     stmt = lambda_stmt(lambda: select(func.max(x, y)))\n    ...     return stmt\n    >>> engine = create_engine(\"sqlite://\", echo=True)\n    >>> with engine.connect() as conn:\n    ...     print(conn.scalar(my_stmt(5, 10)))\n    ...     print(conn.scalar(my_stmt(12, 8)))\n    SELECT  max(?,  ?)  AS  max_1\n    [generated  in  0.00057s]  (5,  10)\n    10\n    SELECT  max(?,  ?)  AS  max_1\n    [cached  since  0.002059s  ago]  (12,  8)\n    12\n    ```", "```py\n    # **Don't** do this:\n\n    def my_stmt(parameter, thing=False):\n        stmt = lambda_stmt(lambda: select(table))\n        stmt += lambda s: (\n            s.where(table.c.x > parameter) if thing else s.where(table.c.y == parameter)\n        )\n        return stmt\n\n    # **Do** do this:\n\n    def my_stmt(parameter, thing=False):\n        stmt = lambda_stmt(lambda: select(table))\n        if thing:\n            stmt += lambda s: s.where(table.c.x > parameter)\n        else:\n            stmt += lambda s: s.where(table.c.y == parameter)\n        return stmt\n    ```", "```py\n    >>> def my_stmt(x, y):\n    ...     def get_x():\n    ...         return x\n    ...\n    ...     def get_y():\n    ...         return y\n    ...\n    ...     stmt = lambda_stmt(lambda: select(func.max(get_x(), get_y())))\n    ...     return stmt\n    >>> with engine.connect() as conn:\n    ...     print(conn.scalar(my_stmt(5, 10)))\n    Traceback (most recent call last):\n     # ...\n    sqlalchemy.exc.InvalidRequestError: Can't invoke Python callable get_x()\n    inside of lambda expression argument at\n    <code object <lambda> at 0x7fed15f350e0, file \"<stdin>\", line 6>;\n    lambda SQL constructs should not invoke functions from closure variables\n    to produce literal values since the lambda SQL system normally extracts\n    bound values without actually invoking the lambda or any functions within it.\n    ```", "```py\n    >>> def my_stmt(x, y):\n    ...     def get_x():\n    ...         return x\n    ...\n    ...     def get_y():\n    ...         return y\n    ...\n    ...     x_param, y_param = get_x(), get_y()\n    ...     stmt = lambda_stmt(lambda: select(func.max(x_param, y_param)))\n    ...     return stmt\n    ```", "```py\n    >>> class Foo:\n    ...     def __init__(self, x, y):\n    ...         self.x = x\n    ...         self.y = y\n    >>> def my_stmt(foo):\n    ...     stmt = lambda_stmt(lambda: select(func.max(foo.x, foo.y)))\n    ...     return stmt\n    >>> with engine.connect() as conn:\n    ...     print(conn.scalar(my_stmt(Foo(5, 10))))\n    Traceback (most recent call last):\n     # ...\n    sqlalchemy.exc.InvalidRequestError: Closure variable named 'foo' inside of\n    lambda callable <code object <lambda> at 0x7fed15f35450, file\n    \"<stdin>\", line 2> does not refer to a cacheable SQL element, and also\n    does not appear to be serving as a SQL literal bound value based on the\n    default SQL expression returned by the function.  This variable needs to\n    remain outside the scope of a SQL-generating lambda so that a proper cache\n    key may be generated from the lambda's state.  Evaluate this variable\n    outside of the lambda, set track_on=[<elements>] to explicitly select\n    closure elements to track, or set track_closure_variables=False to exclude\n    closure variables from being part of the cache key.\n    ```", "```py\n    >>> def my_stmt(foo):\n    ...     x_param, y_param = foo.x, foo.y\n    ...     stmt = lambda_stmt(lambda: select(func.max(x_param, y_param)))\n    ...     return stmt\n    ```", "```py\n    >>> def my_stmt(foo):\n    ...     stmt = lambda_stmt(\n    ...         lambda: select(func.max(foo.x, foo.y)), track_closure_variables=False\n    ...     )\n    ...     return stmt\n    ```", "```py\n    >>> def my_stmt(self, foo):\n    ...     stmt = lambda_stmt(\n    ...         lambda: select(*self.column_expressions), track_closure_variables=False\n    ...     )\n    ...     stmt = stmt.add_criteria(lambda: self.where_criteria, track_on=[self])\n    ...     return stmt\n    ```", "```py\n>>> from sqlalchemy import select, column\n>>> stmt = select(column(\"q\"))\n>>> cache_key = stmt._generate_cache_key()\n>>> print(cache_key)  # somewhat paraphrased\nCacheKey(key=(\n '0',\n <class 'sqlalchemy.sql.selectable.Select'>,\n '_raw_columns',\n (\n (\n '1',\n <class 'sqlalchemy.sql.elements.ColumnClause'>,\n 'name',\n 'q',\n 'type',\n (\n <class 'sqlalchemy.sql.sqltypes.NullType'>,\n ),\n ),\n ),\n # a few more elements are here, and many more for a more\n # complicated SELECT statement\n),)\n```", "```py\n>>> from sqlalchemy import lambda_stmt\n>>> stmt = lambda_stmt(lambda: select(column(\"q\")))\n>>> cache_key = stmt._generate_cache_key()\n>>> print(cache_key)\nCacheKey(key=(\n <code object <lambda> at 0x7fed1617c710, file \"<stdin>\", line 1>,\n <class 'sqlalchemy.sql.lambdas.StatementLambdaElement'>,\n),)\n```", "```py\n>>> def my_stmt(parameter):\n...     col = column(\"q\")\n...     stmt = lambda_stmt(lambda: select(col))\n...     stmt += lambda s: s.where(col == parameter)\n...     return stmt\n```", "```py\n>>> stmt = my_stmt(5)\n>>> key = stmt._generate_cache_key()\n>>> print(key)\nCacheKey(key=(\n <code object <lambda> at 0x7f07323c50e0, file \"<stdin>\", line 3>,\n (\n '0',\n <class 'sqlalchemy.sql.elements.ColumnClause'>,\n 'name',\n 'q',\n 'type',\n (\n <class 'sqlalchemy.sql.sqltypes.NullType'>,\n ),\n ),\n <code object <lambda> at 0x7f07323c5190, file \"<stdin>\", line 4>,\n <class 'sqlalchemy.sql.lambdas.LinkedLambdaElement'>,\n (\n '0',\n <class 'sqlalchemy.sql.elements.ColumnClause'>,\n 'name',\n 'q',\n 'type',\n (\n <class 'sqlalchemy.sql.sqltypes.NullType'>,\n ),\n ),\n (\n '0',\n <class 'sqlalchemy.sql.elements.ColumnClause'>,\n 'name',\n 'q',\n 'type',\n (\n <class 'sqlalchemy.sql.sqltypes.NullType'>,\n ),\n ),\n),)\n```", "```py\n>>> key.bindparams\n[BindParameter('%(139668884281280 parameter)s', 5, type_=Integer())]\n```", "```py\nengine = create_engine(\n    \"mariadb+mariadbconnector://scott:tiger@host/db\", use_insertmanyvalues=False\n)\n```", "```py\nt = Table(\n    \"t\",\n    metadata,\n    Column(\"id\", Integer, primary_key=True),\n    Column(\"x\", Integer),\n    implicit_returning=False,\n)\n```", "```py\nINSERT  INTO  a  (data,  x,  y)  VALUES  (%(data)s,  %(x)s,  %(y)s)  RETURNING  a.id\n```", "```py\nINSERT  INTO  a  (data,  x,  y)  VALUES\n  (%(data_0)s,  %(x_0)s,  %(y_0)s),\n  (%(data_1)s,  %(x_1)s,  %(y_1)s),\n  (%(data_2)s,  %(x_2)s,  %(y_2)s),\n  ...\n  (%(data_78)s,  %(x_78)s,  %(y_78)s)\nRETURNING  a.id\n```", "```py\nINSERT  INTO  a  (data,  x,  y)\nOUTPUT  inserted.id,  inserted.id  AS  id__1\nSELECT  p0,  p1,  p2  FROM  (VALUES\n  (?,  ?,  ?,  0),  (?,  ?,  ?,  1),  (?,  ?,  ?,  2),\n  ...\n  (?,  ?,  ?,  77)\n)  AS  imp_sen(p0,  p1,  p2,  sen_counter)  ORDER  BY  sen_counter\n```", "```py\nimport uuid\n\nfrom sqlalchemy import Column\nfrom sqlalchemy import FetchedValue\nfrom sqlalchemy import Integer\nfrom sqlalchemy import String\nfrom sqlalchemy import Table\nfrom sqlalchemy import Uuid\n\nmy_table = Table(\n    \"some_table\",\n    metadata,\n    # assume some arbitrary server-side function generates\n    # primary key values, so cannot be tracked by a bulk insert\n    Column(\"id\", String(50), server_default=FetchedValue(), primary_key=True),\n    Column(\"data\", String(50)),\n    Column(\n        \"uniqueid\",\n        Uuid(),\n        default=uuid.uuid4,\n        nullable=False,\n        unique=True,\n        insert_sentinel=True,\n    ),\n)\n```", "```py\nimport uuid\n\nfrom sqlalchemy.orm import DeclarativeBase\nfrom sqlalchemy.orm import Mapped\nfrom sqlalchemy.orm import mapped_column\n\nclass Base(DeclarativeBase):\n    pass\n\nclass MyClass(Base):\n    __tablename__ = \"my_table\"\n\n    id: Mapped[str] = mapped_column(primary_key=True, server_default=FetchedValue())\n    data: Mapped[str] = mapped_column(String(50))\n    uniqueid: Mapped[uuid.UUID] = mapped_column(\n        default=uuid.uuid4, unique=True, insert_sentinel=True\n    )\n```", "```py\nfrom sqlalchemy import Column\nfrom sqlalchemy import Integer\nfrom sqlalchemy import String\nfrom sqlalchemy import Table\nfrom sqlalchemy import Uuid\nfrom sqlalchemy import insert_sentinel\n\nTable(\n    \"some_table\",\n    metadata,\n    Column(\"id\", Integer, primary_key=True),\n    Column(\"data\", String(50)),\n    insert_sentinel(\"sentinel\"),\n)\n```", "```py\nfrom sqlalchemy.orm import declared_attr\nfrom sqlalchemy.orm import DeclarativeBase\nfrom sqlalchemy.orm import Mapped\nfrom sqlalchemy.orm import mapped_column\nfrom sqlalchemy.orm import orm_insert_sentinel\n\nclass Base(DeclarativeBase):\n    @declared_attr\n    def _sentinel(cls) -> Mapped[int]:\n        return orm_insert_sentinel()\n\nclass MyClass(Base):\n    __tablename__ = \"my_table\"\n\n    id: Mapped[str] = mapped_column(primary_key=True, server_default=FetchedValue())\n    data: Mapped[str] = mapped_column(String(50))\n\nclass MySubClass(MyClass):\n    __tablename__ = \"sub_table\"\n\n    id: Mapped[str] = mapped_column(ForeignKey(\"my_table.id\"), primary_key=True)\n\nclass MySingleInhClass(MyClass):\n    pass\n```", "```py\ne = create_engine(\"sqlite://\", insertmanyvalues_page_size=100)\n```", "```py\nwith e.begin() as conn:\n    result = conn.execute(\n        table.insert().returning(table.c.id),\n        parameterlist,\n        execution_options={\"insertmanyvalues_page_size\": 100},\n    )\n```", "```py\nstmt = (\n    table.insert()\n    .returning(table.c.id)\n    .execution_options(insertmanyvalues_page_size=100)\n)\nwith e.begin() as conn:\n    result = conn.execute(stmt, parameterlist)\n```", "```py\nINSERT INTO a (data, x, y) VALUES (?, ?, ?), ... 795 characters truncated ...  (?, ?, ?), (?, ?, ?) RETURNING id\n[generated in 0.00177s (insertmanyvalues) 1/10 (unordered)] ('d0', 0, 0, 'd1',  ...\nINSERT INTO a (data, x, y) VALUES (?, ?, ?), ... 795 characters truncated ...  (?, ?, ?), (?, ?, ?) RETURNING id\n[insertmanyvalues 2/10 (unordered)] ('d100', 100, 1000, 'd101', ...\n\n...\n\nINSERT INTO a (data, x, y) VALUES (?, ?, ?), ... 795 characters truncated ...  (?, ?, ?), (?, ?, ?) RETURNING id\n[insertmanyvalues 10/10 (unordered)] ('d900', 900, 9000, 'd901', ...\n```", "```py\n...\n\nINSERT INTO a (data, x, y) VALUES (?, ?, ?) RETURNING id\n[insertmanyvalues 67/78 (ordered; batch not supported)] ('d66', 66, 66)\nINSERT INTO a (data, x, y) VALUES (?, ?, ?) RETURNING id\n[insertmanyvalues 68/78 (ordered; batch not supported)] ('d67', 67, 67)\nINSERT INTO a (data, x, y) VALUES (?, ?, ?) RETURNING id\n[insertmanyvalues 69/78 (ordered; batch not supported)] ('d68', 68, 68)\nINSERT INTO a (data, x, y) VALUES (?, ?, ?) RETURNING id\n[insertmanyvalues 70/78 (ordered; batch not supported)] ('d69', 69, 69)\n\n...\n```", "```py\nengine = create_engine(\n    \"mariadb+mariadbconnector://scott:tiger@host/db\", use_insertmanyvalues=False\n)\n```", "```py\nt = Table(\n    \"t\",\n    metadata,\n    Column(\"id\", Integer, primary_key=True),\n    Column(\"x\", Integer),\n    implicit_returning=False,\n)\n```", "```py\nINSERT  INTO  a  (data,  x,  y)  VALUES  (%(data)s,  %(x)s,  %(y)s)  RETURNING  a.id\n```", "```py\nINSERT  INTO  a  (data,  x,  y)  VALUES\n  (%(data_0)s,  %(x_0)s,  %(y_0)s),\n  (%(data_1)s,  %(x_1)s,  %(y_1)s),\n  (%(data_2)s,  %(x_2)s,  %(y_2)s),\n  ...\n  (%(data_78)s,  %(x_78)s,  %(y_78)s)\nRETURNING  a.id\n```", "```py\nINSERT  INTO  a  (data,  x,  y)\nOUTPUT  inserted.id,  inserted.id  AS  id__1\nSELECT  p0,  p1,  p2  FROM  (VALUES\n  (?,  ?,  ?,  0),  (?,  ?,  ?,  1),  (?,  ?,  ?,  2),\n  ...\n  (?,  ?,  ?,  77)\n)  AS  imp_sen(p0,  p1,  p2,  sen_counter)  ORDER  BY  sen_counter\n```", "```py\nimport uuid\n\nfrom sqlalchemy import Column\nfrom sqlalchemy import FetchedValue\nfrom sqlalchemy import Integer\nfrom sqlalchemy import String\nfrom sqlalchemy import Table\nfrom sqlalchemy import Uuid\n\nmy_table = Table(\n    \"some_table\",\n    metadata,\n    # assume some arbitrary server-side function generates\n    # primary key values, so cannot be tracked by a bulk insert\n    Column(\"id\", String(50), server_default=FetchedValue(), primary_key=True),\n    Column(\"data\", String(50)),\n    Column(\n        \"uniqueid\",\n        Uuid(),\n        default=uuid.uuid4,\n        nullable=False,\n        unique=True,\n        insert_sentinel=True,\n    ),\n)\n```", "```py\nimport uuid\n\nfrom sqlalchemy.orm import DeclarativeBase\nfrom sqlalchemy.orm import Mapped\nfrom sqlalchemy.orm import mapped_column\n\nclass Base(DeclarativeBase):\n    pass\n\nclass MyClass(Base):\n    __tablename__ = \"my_table\"\n\n    id: Mapped[str] = mapped_column(primary_key=True, server_default=FetchedValue())\n    data: Mapped[str] = mapped_column(String(50))\n    uniqueid: Mapped[uuid.UUID] = mapped_column(\n        default=uuid.uuid4, unique=True, insert_sentinel=True\n    )\n```", "```py\nfrom sqlalchemy import Column\nfrom sqlalchemy import Integer\nfrom sqlalchemy import String\nfrom sqlalchemy import Table\nfrom sqlalchemy import Uuid\nfrom sqlalchemy import insert_sentinel\n\nTable(\n    \"some_table\",\n    metadata,\n    Column(\"id\", Integer, primary_key=True),\n    Column(\"data\", String(50)),\n    insert_sentinel(\"sentinel\"),\n)\n```", "```py\nfrom sqlalchemy.orm import declared_attr\nfrom sqlalchemy.orm import DeclarativeBase\nfrom sqlalchemy.orm import Mapped\nfrom sqlalchemy.orm import mapped_column\nfrom sqlalchemy.orm import orm_insert_sentinel\n\nclass Base(DeclarativeBase):\n    @declared_attr\n    def _sentinel(cls) -> Mapped[int]:\n        return orm_insert_sentinel()\n\nclass MyClass(Base):\n    __tablename__ = \"my_table\"\n\n    id: Mapped[str] = mapped_column(primary_key=True, server_default=FetchedValue())\n    data: Mapped[str] = mapped_column(String(50))\n\nclass MySubClass(MyClass):\n    __tablename__ = \"sub_table\"\n\n    id: Mapped[str] = mapped_column(ForeignKey(\"my_table.id\"), primary_key=True)\n\nclass MySingleInhClass(MyClass):\n    pass\n```", "```py\nimport uuid\n\nfrom sqlalchemy import Column\nfrom sqlalchemy import FetchedValue\nfrom sqlalchemy import Integer\nfrom sqlalchemy import String\nfrom sqlalchemy import Table\nfrom sqlalchemy import Uuid\n\nmy_table = Table(\n    \"some_table\",\n    metadata,\n    # assume some arbitrary server-side function generates\n    # primary key values, so cannot be tracked by a bulk insert\n    Column(\"id\", String(50), server_default=FetchedValue(), primary_key=True),\n    Column(\"data\", String(50)),\n    Column(\n        \"uniqueid\",\n        Uuid(),\n        default=uuid.uuid4,\n        nullable=False,\n        unique=True,\n        insert_sentinel=True,\n    ),\n)\n```", "```py\nimport uuid\n\nfrom sqlalchemy.orm import DeclarativeBase\nfrom sqlalchemy.orm import Mapped\nfrom sqlalchemy.orm import mapped_column\n\nclass Base(DeclarativeBase):\n    pass\n\nclass MyClass(Base):\n    __tablename__ = \"my_table\"\n\n    id: Mapped[str] = mapped_column(primary_key=True, server_default=FetchedValue())\n    data: Mapped[str] = mapped_column(String(50))\n    uniqueid: Mapped[uuid.UUID] = mapped_column(\n        default=uuid.uuid4, unique=True, insert_sentinel=True\n    )\n```", "```py\nfrom sqlalchemy import Column\nfrom sqlalchemy import Integer\nfrom sqlalchemy import String\nfrom sqlalchemy import Table\nfrom sqlalchemy import Uuid\nfrom sqlalchemy import insert_sentinel\n\nTable(\n    \"some_table\",\n    metadata,\n    Column(\"id\", Integer, primary_key=True),\n    Column(\"data\", String(50)),\n    insert_sentinel(\"sentinel\"),\n)\n```", "```py\nfrom sqlalchemy.orm import declared_attr\nfrom sqlalchemy.orm import DeclarativeBase\nfrom sqlalchemy.orm import Mapped\nfrom sqlalchemy.orm import mapped_column\nfrom sqlalchemy.orm import orm_insert_sentinel\n\nclass Base(DeclarativeBase):\n    @declared_attr\n    def _sentinel(cls) -> Mapped[int]:\n        return orm_insert_sentinel()\n\nclass MyClass(Base):\n    __tablename__ = \"my_table\"\n\n    id: Mapped[str] = mapped_column(primary_key=True, server_default=FetchedValue())\n    data: Mapped[str] = mapped_column(String(50))\n\nclass MySubClass(MyClass):\n    __tablename__ = \"sub_table\"\n\n    id: Mapped[str] = mapped_column(ForeignKey(\"my_table.id\"), primary_key=True)\n\nclass MySingleInhClass(MyClass):\n    pass\n```", "```py\ne = create_engine(\"sqlite://\", insertmanyvalues_page_size=100)\n```", "```py\nwith e.begin() as conn:\n    result = conn.execute(\n        table.insert().returning(table.c.id),\n        parameterlist,\n        execution_options={\"insertmanyvalues_page_size\": 100},\n    )\n```", "```py\nstmt = (\n    table.insert()\n    .returning(table.c.id)\n    .execution_options(insertmanyvalues_page_size=100)\n)\nwith e.begin() as conn:\n    result = conn.execute(stmt, parameterlist)\n```", "```py\nINSERT INTO a (data, x, y) VALUES (?, ?, ?), ... 795 characters truncated ...  (?, ?, ?), (?, ?, ?) RETURNING id\n[generated in 0.00177s (insertmanyvalues) 1/10 (unordered)] ('d0', 0, 0, 'd1',  ...\nINSERT INTO a (data, x, y) VALUES (?, ?, ?), ... 795 characters truncated ...  (?, ?, ?), (?, ?, ?) RETURNING id\n[insertmanyvalues 2/10 (unordered)] ('d100', 100, 1000, 'd101', ...\n\n...\n\nINSERT INTO a (data, x, y) VALUES (?, ?, ?), ... 795 characters truncated ...  (?, ?, ?), (?, ?, ?) RETURNING id\n[insertmanyvalues 10/10 (unordered)] ('d900', 900, 9000, 'd901', ...\n```", "```py\n...\n\nINSERT INTO a (data, x, y) VALUES (?, ?, ?) RETURNING id\n[insertmanyvalues 67/78 (ordered; batch not supported)] ('d66', 66, 66)\nINSERT INTO a (data, x, y) VALUES (?, ?, ?) RETURNING id\n[insertmanyvalues 68/78 (ordered; batch not supported)] ('d67', 67, 67)\nINSERT INTO a (data, x, y) VALUES (?, ?, ?) RETURNING id\n[insertmanyvalues 69/78 (ordered; batch not supported)] ('d68', 68, 68)\nINSERT INTO a (data, x, y) VALUES (?, ?, ?) RETURNING id\n[insertmanyvalues 70/78 (ordered; batch not supported)] ('d69', 69, 69)\n\n...\n```", "```py\nwith engine.connect() as conn:\n    conn.exec_driver_sql(\"SET param='bar'\")\n```", "```py\nconnection = engine.connect()\ndbapi_conn = connection.connection\n```", "```py\ndbapi_conn = engine.raw_connection()\n```", "```py\ndbapi_conn.close()\n```", "```py\nconnection = engine.raw_connection()\ntry:\n    cursor_obj = connection.cursor()\n    cursor_obj.callproc(\"my_procedure\", [\"x\", \"y\", \"z\"])\n    results = list(cursor_obj.fetchall())\n    cursor_obj.close()\n    connection.commit()\nfinally:\n    connection.close()\n```", "```py\nconnection.execute(\"CALL my_procedure();\")\n```", "```py\nconnection = engine.raw_connection()\ntry:\n    cursor_obj = connection.cursor()\n    cursor_obj.execute(\"select * from table1; select * from table2\")\n    results_one = cursor_obj.fetchall()\n    cursor_obj.nextset()\n    results_two = cursor_obj.fetchall()\n    cursor_obj.close()\nfinally:\n    connection.close()\n```", "```py\nwith engine.connect() as conn:\n    conn.exec_driver_sql(\"SET param='bar'\")\n```", "```py\nconnection = engine.connect()\ndbapi_conn = connection.connection\n```", "```py\ndbapi_conn = engine.raw_connection()\n```", "```py\ndbapi_conn.close()\n```", "```py\nconnection = engine.raw_connection()\ntry:\n    cursor_obj = connection.cursor()\n    cursor_obj.callproc(\"my_procedure\", [\"x\", \"y\", \"z\"])\n    results = list(cursor_obj.fetchall())\n    cursor_obj.close()\n    connection.commit()\nfinally:\n    connection.close()\n```", "```py\nconnection.execute(\"CALL my_procedure();\")\n```", "```py\nconnection = engine.raw_connection()\ntry:\n    cursor_obj = connection.cursor()\n    cursor_obj.execute(\"select * from table1; select * from table2\")\n    results_one = cursor_obj.fetchall()\n    cursor_obj.nextset()\n    results_two = cursor_obj.fetchall()\n    cursor_obj.close()\nfinally:\n    connection.close()\n```", "```py\n    [options.entry_points]\n    sqlalchemy.dialects  =\n      foodialect  =  foodialect.dialect:FooDialect\n    ```", "```py\n[options.entry_points]\nsqlalchemy.dialects\n  mysql.foodialect  =  foodialect.dialect:FooDialect\n```", "```py\nfrom sqlalchemy.dialects import registry\n\nregistry.register(\"mysql.foodialect\", \"myapp.dialect\", \"MyMySQLDialect\")\n```", "```py\nfrom sqlalchemy.dialects import registry\n\nregistry.register(\"mysql.foodialect\", \"myapp.dialect\", \"MyMySQLDialect\")\n```", "```py\nclass sqlalchemy.engine.Connection\n```", "```py\nmethod __init__(engine: Engine, connection: PoolProxiedConnection | None = None, _has_events: bool | None = None, _allow_revalidate: bool = True, _allow_autobegin: bool = True)\n```", "```py\nmethod begin() \u2192 RootTransaction\n```", "```py\nwith engine.connect() as conn:\n    with conn.begin() as trans:\n        conn.execute(table.insert(), {\"username\": \"sandy\"})\n```", "```py\nwith engine.connect() as conn:\n    with conn.begin():\n        conn.execute(...)\n        conn.execute(...)\n\n    with conn.begin():\n        conn.execute(...)\n        conn.execute(...)\n```", "```py\nwith engine.connect() as conn:\n    conn.execute(...)\n    conn.execute(...)\n    conn.commit()\n\n    conn.execute(...)\n    conn.execute(...)\n    conn.commit()\n```", "```py\nmethod begin_nested() \u2192 NestedTransaction\n```", "```py\nwith engine.begin() as connection:\n    with connection.begin_nested():\n        connection.execute(table.insert(), {\"username\": \"sandy\"})\n```", "```py\nfrom sqlalchemy import exc\n\nwith engine.begin() as connection:\n    trans = connection.begin_nested()\n    try:\n        connection.execute(table.insert(), {\"username\": \"sandy\"})\n        trans.commit()\n    except exc.IntegrityError:  # catch for duplicate username\n        trans.rollback()  # rollback to savepoint\n\n    # outer transaction continues\n    connection.execute( ... )\n```", "```py\nwith engine.connect() as connection:  # begin() wasn't called\n\n    with connection.begin_nested(): will auto-\"begin()\" first\n        connection.execute( ... )\n    # savepoint is released\n\n    connection.execute( ... )\n\n    # explicitly commit outer transaction\n    connection.commit()\n\n    # can continue working with connection here\n```", "```py\nmethod begin_twophase(xid: Any | None = None) \u2192 TwoPhaseTransaction\n```", "```py\nmethod close() \u2192 None\n```", "```py\nattribute closed\n```", "```py\nmethod commit() \u2192 None\n```", "```py\nattribute connection\n```", "```py\nattribute default_isolation_level\n```", "```py\nmethod detach() \u2192 None\n```", "```py\nwith engine.connect() as conn:\n    conn.detach()\n    conn.execute(text(\"SET search_path TO schema1, schema2\"))\n\n    # work with connection\n\n# connection is fully closed (since we used \"with:\", can\n# also call .close())\n```", "```py\nmethod exec_driver_sql(statement: str, parameters: _DBAPIAnyExecuteParams | None = None, execution_options: CoreExecuteOptionsParameter | None = None) \u2192 CursorResult[Any]\n```", "```py\nconn.exec_driver_sql(\n    \"INSERT INTO table (id, value) VALUES (%(id)s, %(value)s)\",\n    [{\"id\":1, \"value\":\"v1\"}, {\"id\":2, \"value\":\"v2\"}]\n)\n```", "```py\nconn.exec_driver_sql(\n    \"INSERT INTO table (id, value) VALUES (%(id)s, %(value)s)\",\n    dict(id=1, value=\"v1\")\n)\n```", "```py\nconn.exec_driver_sql(\n    \"INSERT INTO table (id, value) VALUES (?, ?)\",\n    (1, 'v1')\n)\n```", "```py\nmethod execute(statement: Executable, parameters: _CoreAnyExecuteParams | None = None, *, execution_options: CoreExecuteOptionsParameter | None = None) \u2192 CursorResult[Any]\n```", "```py\nmethod execution_options(**opt: Any) \u2192 Connection\n```", "```py\nmethod get_execution_options() \u2192 _ExecuteOptions\n```", "```py\nmethod get_isolation_level() \u2192 Literal['SERIALIZABLE', 'REPEATABLE READ', 'READ COMMITTED', 'READ UNCOMMITTED', 'AUTOCOMMIT']\n```", "```py\nmethod get_nested_transaction() \u2192 NestedTransaction | None\n```", "```py\nmethod get_transaction() \u2192 RootTransaction | None\n```", "```py\nmethod in_nested_transaction() \u2192 bool\n```", "```py\nmethod in_transaction() \u2192 bool\n```", "```py\nattribute info\n```", "```py\nmethod invalidate(exception: BaseException | None = None) \u2192 None\n```", "```py\nattribute invalidated\n```", "```py\nmethod rollback() \u2192 None\n```", "```py\nmethod scalar(statement: Executable, parameters: _CoreSingleExecuteParams | None = None, *, execution_options: CoreExecuteOptionsParameter | None = None) \u2192 Any\n```", "```py\nmethod scalars(statement: Executable, parameters: _CoreAnyExecuteParams | None = None, *, execution_options: CoreExecuteOptionsParameter | None = None) \u2192 ScalarResult[Any]\n```", "```py\nmethod schema_for_object(obj: HasSchemaAttr) \u2192 str | None\n```", "```py\nclass sqlalchemy.engine.CreateEnginePlugin\n```", "```py\nimport logging\n\nfrom sqlalchemy.engine import CreateEnginePlugin\nfrom sqlalchemy import event\n\nclass LogCursorEventsPlugin(CreateEnginePlugin):\n    def __init__(self, url, kwargs):\n        # consume the parameter \"log_cursor_logging_name\" from the\n        # URL query\n        logging_name = url.query.get(\"log_cursor_logging_name\", \"log_cursor\")\n\n        self.log = logging.getLogger(logging_name)\n\n    def update_url(self, url):\n        \"update the URL to one that no longer includes our parameters\"\n        return url.difference_update_query([\"log_cursor_logging_name\"])\n\n    def engine_created(self, engine):\n        \"attach an event listener after the new Engine is constructed\"\n        event.listen(engine, \"before_cursor_execute\", self._log_event)\n\n    def _log_event(\n        self,\n        conn,\n        cursor,\n        statement,\n        parameters,\n        context,\n        executemany):\n\n        self.log.info(\"Plugin logged cursor event: %s\", statement)\n```", "```py\nentry_points={\n    'sqlalchemy.plugins': [\n        'log_cursor_plugin = myapp.plugins:LogCursorEventsPlugin'\n    ]\n```", "```py\nfrom sqlalchemy import create_engine\n\nengine = create_engine(\n    \"mysql+pymysql://scott:tiger@localhost/test?\"\n    \"plugin=log_cursor_plugin&log_cursor_logging_name=mylogger\"\n)\n```", "```py\nengine = create_engine(\n  \"mysql+pymysql://scott:tiger@localhost/test?\"\n  \"plugin=plugin_one&plugin=plugin_twp&plugin=plugin_three\")\n```", "```py\nengine = create_engine(\n  \"mysql+pymysql://scott:tiger@localhost/test\",\n  plugins=[\"myplugin\"])\n```", "```py\nclass MyPlugin(CreateEnginePlugin):\n    def __init__(self, url, kwargs):\n        self.my_argument_one = url.query['my_argument_one']\n        self.my_argument_two = url.query['my_argument_two']\n        self.my_argument_three = kwargs.pop('my_argument_three', None)\n\n    def update_url(self, url):\n        return url.difference_update_query(\n            [\"my_argument_one\", \"my_argument_two\"]\n        )\n```", "```py\nfrom sqlalchemy import create_engine\n\nengine = create_engine(\n  \"mysql+pymysql://scott:tiger@localhost/test?\"\n  \"plugin=myplugin&my_argument_one=foo&my_argument_two=bar\",\n  my_argument_three='bat'\n)\n```", "```py\nclass MyPlugin(CreateEnginePlugin):\n    def __init__(self, url, kwargs):\n        if hasattr(CreateEnginePlugin, \"update_url\"):\n            # detect the 1.4 API\n            self.my_argument_one = url.query['my_argument_one']\n            self.my_argument_two = url.query['my_argument_two']\n        else:\n            # detect the 1.3 and earlier API - mutate the\n            # URL directly\n            self.my_argument_one = url.query.pop('my_argument_one')\n            self.my_argument_two = url.query.pop('my_argument_two')\n\n        self.my_argument_three = kwargs.pop('my_argument_three', None)\n\n    def update_url(self, url):\n        # this method is only called in the 1.4 version\n        return url.difference_update_query(\n            [\"my_argument_one\", \"my_argument_two\"]\n        )\n```", "```py\nmethod __init__(url: URL, kwargs: Dict[str, Any])\n```", "```py\nmethod engine_created(engine: Engine) \u2192 None\n```", "```py\nmethod handle_dialect_kwargs(dialect_cls: Type[Dialect], dialect_args: Dict[str, Any]) \u2192 None\n```", "```py\nmethod handle_pool_kwargs(pool_cls: Type[Pool], pool_args: Dict[str, Any]) \u2192 None\n```", "```py\nmethod update_url(url: URL) \u2192 URL\n```", "```py\nclass sqlalchemy.engine.Engine\n```", "```py\nmethod begin() \u2192 Iterator[Connection]\n```", "```py\nwith engine.begin() as conn:\n    conn.execute(\n        text(\"insert into table (x, y, z) values (1, 2, 3)\")\n    )\n    conn.execute(text(\"my_special_procedure(5)\"))\n```", "```py\nmethod clear_compiled_cache() \u2192 None\n```", "```py\nmethod connect() \u2192 Connection\n```", "```py\nwith engine.connect() as connection:\n    connection.execute(text(\"insert into table values ('foo')\"))\n    connection.commit()\n```", "```py\nmethod dispose(close: bool = True) \u2192 None\n```", "```py\nattribute driver\n```", "```py\nattribute engine\n```", "```py\nmethod execution_options(**opt: Any) \u2192 OptionEngine\n```", "```py\nfrom sqlalchemy import event\nfrom sqlalchemy.engine import Engine\n\nprimary_engine = create_engine(\"mysql+mysqldb://\")\nshard1 = primary_engine.execution_options(shard_id=\"shard1\")\nshard2 = primary_engine.execution_options(shard_id=\"shard2\")\n\nshards = {\"default\": \"base\", \"shard_1\": \"db1\", \"shard_2\": \"db2\"}\n\n@event.listens_for(Engine, \"before_cursor_execute\")\ndef _switch_shard(conn, cursor, stmt,\n        params, context, executemany):\n    shard_id = conn.get_execution_options().get('shard_id', \"default\")\n    current_shard = conn.info.get(\"current_shard\", None)\n\n    if current_shard != shard_id:\n        cursor.execute(\"use %s\" % shards[shard_id])\n        conn.info[\"current_shard\"] = shard_id\n```", "```py\nmethod get_execution_options() \u2192 _ExecuteOptions\n```", "```py\nattribute name\n```", "```py\nmethod raw_connection() \u2192 PoolProxiedConnection\n```", "```py\nmethod update_execution_options(**opt: Any) \u2192 None\n```", "```py\nclass sqlalchemy.engine.ExceptionContext\n```", "```py\nattribute chained_exception: BaseException | None\n```", "```py\nattribute connection: Connection | None\n```", "```py\nattribute cursor: DBAPICursor | None\n```", "```py\nattribute dialect: Dialect\n```", "```py\nattribute engine: Engine | None\n```", "```py\nattribute execution_context: ExecutionContext | None\n```", "```py\nattribute invalidate_pool_on_disconnect: bool\n```", "```py\nattribute is_disconnect: bool\n```", "```py\nattribute is_pre_ping: bool\n```", "```py\nattribute original_exception: BaseException\n```", "```py\nattribute parameters: _DBAPIAnyExecuteParams | None\n```", "```py\nattribute sqlalchemy_exception: StatementError | None\n```", "```py\nattribute statement: str | None\n```", "```py\nclass sqlalchemy.engine.NestedTransaction\n```", "```py\nmethod close() \u2192 None\n```", "```py\nmethod commit() \u2192 None\n```", "```py\nmethod rollback() \u2192 None\n```", "```py\nclass sqlalchemy.engine.RootTransaction\n```", "```py\nmethod close() \u2192 None\n```", "```py\nmethod commit() \u2192 None\n```", "```py\nmethod rollback() \u2192 None\n```", "```py\nclass sqlalchemy.engine.Transaction\n```", "```py\nfrom sqlalchemy import create_engine\nengine = create_engine(\"postgresql+psycopg2://scott:tiger@localhost/test\")\nconnection = engine.connect()\ntrans = connection.begin()\nconnection.execute(text(\"insert into x (a, b) values (1, 2)\"))\ntrans.commit()\n```", "```py\nwith connection.begin():\n    connection.execute(text(\"insert into x (a, b) values (1, 2)\"))\n```", "```py\nmethod close() \u2192 None\n```", "```py\nmethod commit() \u2192 None\n```", "```py\nmethod rollback() \u2192 None\n```", "```py\nclass sqlalchemy.engine.TwoPhaseTransaction\n```", "```py\nmethod close() \u2192 None\n```", "```py\nmethod commit() \u2192 None\n```", "```py\nmethod prepare() \u2192 None\n```", "```py\nmethod rollback() \u2192 None\n```", "```py\nclass sqlalchemy.engine.ChunkedIteratorResult\n```", "```py\nmethod yield_per(num: int) \u2192 Self\n```", "```py\nclass sqlalchemy.engine.CursorResult\n```", "```py\nmethod all() \u2192 Sequence[Row[_TP]]\n```", "```py\nmethod close() \u2192 Any\n```", "```py\nmethod columns(*col_expressions: _KeyIndexType) \u2192 Self\n```", "```py\nstatement = select(table.c.x, table.c.y, table.c.z)\nresult = connection.execute(statement)\n\nfor z, y in result.columns('z', 'y'):\n    # ...\n```", "```py\nfor z, y in result.columns(\n        statement.selected_columns.c.z,\n        statement.selected_columns.c.y\n):\n    # ...\n```", "```py\nmethod fetchall() \u2192 Sequence[Row[_TP]]\n```", "```py\nmethod fetchmany(size: int | None = None) \u2192 Sequence[Row[_TP]]\n```", "```py\nmethod fetchone() \u2192 Row[_TP] | None\n```", "```py\nmethod first() \u2192 Row[_TP] | None\n```", "```py\nmethod freeze() \u2192 FrozenResult[_TP]\n```", "```py\nattribute inserted_primary_key\n```", "```py\nattribute inserted_primary_key_rows\n```", "```py\nattribute is_insert\n```", "```py\nmethod keys() \u2192 RMKeyView\n```", "```py\nmethod last_inserted_params()\n```", "```py\nmethod last_updated_params()\n```", "```py\nmethod lastrow_has_defaults()\n```", "```py\nattribute lastrowid\n```", "```py\nmethod mappings() \u2192 MappingResult\n```", "```py\nmethod merge(*others: Result[Any]) \u2192 MergedResult[Any]\n```", "```py\nmethod one() \u2192 Row[_TP]\n```", "```py\nmethod one_or_none() \u2192 Row[_TP] | None\n```", "```py\nmethod partitions(size: int | None = None) \u2192 Iterator[Sequence[Row[_TP]]]\n```", "```py\nmethod postfetch_cols()\n```", "```py\nmethod prefetch_cols()\n```", "```py\nattribute returned_defaults\n```", "```py\nattribute returned_defaults_rows\n```", "```py\nattribute returns_rows\n```", "```py\nattribute rowcount\n```", "```py\nmethod scalar() \u2192 Any\n```", "```py\nmethod scalar_one() \u2192 Any\n```", "```py\nmethod scalar_one_or_none() \u2192 Any | None\n```", "```py\nmethod scalars(index: _KeyIndexType = 0) \u2192 ScalarResult[Any]\n```", "```py\n>>> result = conn.execute(text(\"select int_id from table\"))\n>>> result.scalars().all()\n[1, 2, 3]\n```", "```py\nmethod splice_horizontally(other)\n```", "```py\nr1 = connection.execute(\n    users.insert().returning(\n        users.c.user_name,\n        users.c.user_id,\n        sort_by_parameter_order=True\n    ),\n    user_values\n)\n\nr2 = connection.execute(\n    addresses.insert().returning(\n        addresses.c.address_id,\n        addresses.c.address,\n        addresses.c.user_id,\n        sort_by_parameter_order=True\n    ),\n    address_values\n)\n\nrows = r1.splice_horizontally(r2).all()\nassert (\n    rows ==\n    [\n        (\"john\", 1, 1, \"foo@bar.com\", 1),\n        (\"jack\", 2, 2, \"bar@bat.com\", 2),\n    ]\n)\n```", "```py\nmethod splice_vertically(other)\n```", "```py\nmethod supports_sane_multi_rowcount()\n```", "```py\nmethod supports_sane_rowcount()\n```", "```py\nattribute t\n```", "```py\nmethod tuples() \u2192 TupleResult[_TP]\n```", "```py\nmethod unique(strategy: Callable[[Any], Any] | None = None) \u2192 Self\n```", "```py\nmethod yield_per(num: int) \u2192 Self\n```", "```py\nclass sqlalchemy.engine.FilterResult\n```", "```py\nmethod close() \u2192 None\n```", "```py\nattribute closed\n```", "```py\nmethod yield_per(num: int) \u2192 Self\n```", "```py\nclass sqlalchemy.engine.FrozenResult\n```", "```py\nresult = connection.execute(query)\n\nfrozen = result.freeze()\n\nunfrozen_result_one = frozen()\n\nfor row in unfrozen_result_one:\n    print(row)\n\nunfrozen_result_two = frozen()\nrows = unfrozen_result_two.all()\n\n# ... etc\n```", "```py\nclass sqlalchemy.engine.IteratorResult\n```", "```py\nattribute closed\n```", "```py\nclass sqlalchemy.engine.MergedResult\n```", "```py\nclass sqlalchemy.engine.Result\n```", "```py\nmethod all() \u2192 Sequence[Row[_TP]]\n```", "```py\nmethod close() \u2192 None\n```", "```py\nattribute closed\n```", "```py\nmethod columns(*col_expressions: _KeyIndexType) \u2192 Self\n```", "```py\nstatement = select(table.c.x, table.c.y, table.c.z)\nresult = connection.execute(statement)\n\nfor z, y in result.columns('z', 'y'):\n    # ...\n```", "```py\nfor z, y in result.columns(\n        statement.selected_columns.c.z,\n        statement.selected_columns.c.y\n):\n    # ...\n```", "```py\nmethod fetchall() \u2192 Sequence[Row[_TP]]\n```", "```py\nmethod fetchmany(size: int | None = None) \u2192 Sequence[Row[_TP]]\n```", "```py\nmethod fetchone() \u2192 Row[_TP] | None\n```", "```py\nmethod first() \u2192 Row[_TP] | None\n```", "```py\nmethod freeze() \u2192 FrozenResult[_TP]\n```", "```py\nmethod keys() \u2192 RMKeyView\n```", "```py\nmethod mappings() \u2192 MappingResult\n```", "```py\nmethod merge(*others: Result[Any]) \u2192 MergedResult[_TP]\n```", "```py\nmethod one() \u2192 Row[_TP]\n```", "```py\nmethod one_or_none() \u2192 Row[_TP] | None\n```", "```py\nmethod partitions(size: int | None = None) \u2192 Iterator[Sequence[Row[_TP]]]\n```", "```py\nmethod scalar() \u2192 Any\n```", "```py\nmethod scalar_one() \u2192 Any\n```", "```py\nmethod scalar_one_or_none() \u2192 Any | None\n```", "```py\nmethod scalars(index: _KeyIndexType = 0) \u2192 ScalarResult[Any]\n```", "```py\n>>> result = conn.execute(text(\"select int_id from table\"))\n>>> result.scalars().all()\n[1, 2, 3]\n```", "```py\nattribute t\n```", "```py\nmethod tuples() \u2192 TupleResult[_TP]\n```", "```py\nmethod unique(strategy: Callable[[Any], Any] | None = None) \u2192 Self\n```", "```py\nmethod yield_per(num: int) \u2192 Self\n```", "```py\nclass sqlalchemy.engine.ScalarResult\n```", "```py\nmethod all() \u2192 Sequence[_R]\n```", "```py\nmethod close() \u2192 None\n```", "```py\nattribute closed\n```", "```py\nmethod fetchall() \u2192 Sequence[_R]\n```", "```py\nmethod fetchmany(size: int | None = None) \u2192 Sequence[_R]\n```", "```py\nmethod first() \u2192 _R | None\n```", "```py\nmethod one() \u2192 _R\n```", "```py\nmethod one_or_none() \u2192 _R | None\n```", "```py\nmethod partitions(size: int | None = None) \u2192 Iterator[Sequence[_R]]\n```", "```py\nmethod unique(strategy: Callable[[Any], Any] | None = None) \u2192 Self\n```", "```py\nmethod yield_per(num: int) \u2192 Self\n```", "```py\nclass sqlalchemy.engine.MappingResult\n```", "```py\nmethod all() \u2192 Sequence[RowMapping]\n```", "```py\nmethod close() \u2192 None\n```", "```py\nattribute closed\n```", "```py\nmethod columns(*col_expressions: _KeyIndexType) \u2192 Self\n```", "```py\nmethod fetchall() \u2192 Sequence[RowMapping]\n```", "```py\nmethod fetchmany(size: int | None = None) \u2192 Sequence[RowMapping]\n```", "```py\nmethod fetchone() \u2192 RowMapping | None\n```", "```py\nmethod first() \u2192 RowMapping | None\n```", "```py\nmethod keys() \u2192 RMKeyView\n```", "```py\nmethod one() \u2192 RowMapping\n```", "```py\nmethod one_or_none() \u2192 RowMapping | None\n```", "```py\nmethod partitions(size: int | None = None) \u2192 Iterator[Sequence[RowMapping]]\n```", "```py\nmethod unique(strategy: Callable[[Any], Any] | None = None) \u2192 Self\n```", "```py\nmethod yield_per(num: int) \u2192 Self\n```", "```py\nclass sqlalchemy.engine.Row\n```", "```py\nmethod _asdict() \u2192 Dict[str, Any]\n```", "```py\nattribute _fields\n```", "```py\nattribute _mapping\n```", "```py\nattribute _t\n```", "```py\nmethod _tuple() \u2192 _TP\n```", "```py\nattribute count\n```", "```py\nattribute index\n```", "```py\nattribute t\n```", "```py\nmethod tuple() \u2192 _TP\n```", "```py\nclass sqlalchemy.engine.RowMapping\n```", "```py\nfor row in result:\n    if 'a' in row._mapping:\n        print(\"Column 'a': %s\" % row._mapping['a'])\n\n    print(\"Column b: %s\" % row._mapping[table.c.b])\n```", "```py\nmethod items() \u2192 ROMappingItemsView\n```", "```py\nmethod keys() \u2192 RMKeyView\n```", "```py\nmethod values() \u2192 ROMappingKeysValuesView\n```", "```py\nclass sqlalchemy.engine.TupleResult\n```"]