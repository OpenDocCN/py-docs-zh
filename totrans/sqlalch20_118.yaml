- en: ORM Configuration
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ORM 配置
- en: 原文：[https://docs.sqlalchemy.org/en/20/faq/ormconfiguration.html](https://docs.sqlalchemy.org/en/20/faq/ormconfiguration.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://docs.sqlalchemy.org/en/20/faq/ormconfiguration.html](https://docs.sqlalchemy.org/en/20/faq/ormconfiguration.html)
- en: '[How do I map a table that has no primary key?](#how-do-i-map-a-table-that-has-no-primary-key)'
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[如何映射没有主键的表？](#how-do-i-map-a-table-that-has-no-primary-key)'
- en: '[How do I configure a Column that is a Python reserved word or similar?](#how-do-i-configure-a-column-that-is-a-python-reserved-word-or-similar)'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[如何配置一个与 Python 保留字或类似的列？](#how-do-i-configure-a-column-that-is-a-python-reserved-word-or-similar)'
- en: '[How do I get a list of all columns, relationships, mapped attributes, etc.
    given a mapped class?](#how-do-i-get-a-list-of-all-columns-relationships-mapped-attributes-etc-given-a-mapped-class)'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[如何在给定映射类的情况下获取所有列、关系、映射属性等的列表？](#how-do-i-get-a-list-of-all-columns-relationships-mapped-attributes-etc-given-a-mapped-class)'
- en: '[I’m getting a warning or error about “Implicitly combining column X under
    attribute Y”](#i-m-getting-a-warning-or-error-about-implicitly-combining-column-x-under-attribute-y)'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[我收到关于“在属性 Y 下隐式组合列 X”的警告或错误](#i-m-getting-a-warning-or-error-about-implicitly-combining-column-x-under-attribute-y)'
- en: '[I’m using Declarative and setting primaryjoin/secondaryjoin using an `and_()`
    or `or_()`, and I am getting an error message about foreign keys.](#i-m-using-declarative-and-setting-primaryjoin-secondaryjoin-using-an-and-or-or-and-i-am-getting-an-error-message-about-foreign-keys)'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[我正在使用声明式并使用 `and_()` 或 `or_()` 设置 primaryjoin/secondaryjoin，但我收到了关于外键的错误消息。](#i-m-using-declarative-and-setting-primaryjoin-secondaryjoin-using-an-and-or-or-and-i-am-getting-an-error-message-about-foreign-keys)'
- en: '[Why is `ORDER BY` recommended with `LIMIT` (especially with `subqueryload()`)?](#why-is-order-by-recommended-with-limit-especially-with-subqueryload)'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[为什么推荐在 `LIMIT` 中使用 `ORDER BY`（特别是在 `subqueryload()` 中）？](#why-is-order-by-recommended-with-limit-especially-with-subqueryload)'
- en: '## How do I map a table that has no primary key?'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '## 如何映射没有主键的表？'
- en: The SQLAlchemy ORM, in order to map to a particular table, needs there to be
    at least one column denoted as a primary key column; multiple-column, i.e. composite,
    primary keys are of course entirely feasible as well. These columns do **not**
    need to be actually known to the database as primary key columns, though it’s
    a good idea that they are. It’s only necessary that the columns *behave* as a
    primary key does, e.g. as a unique and not nullable identifier for a row.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了映射到特定表，SQLAlchemy ORM 需要至少有一个列被标记为主键列；当然，多列，即复合主键，也是完全可行的。这些列不需要实际被数据库知道为主键列，尽管最好是这样。只需要这些列
    *行为* 象主键一样，例如，作为行的唯一且非空的标识符。
- en: Most ORMs require that objects have some kind of primary key defined because
    the object in memory must correspond to a uniquely identifiable row in the database
    table; at the very least, this allows the object can be targeted for UPDATE and
    DELETE statements which will affect only that object’s row and no other. However,
    the importance of the primary key goes far beyond that. In SQLAlchemy, all ORM-mapped
    objects are at all times linked uniquely within a [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") to their specific database row using a pattern called
    the [identity map](../glossary.html#term-identity-map), a pattern that’s central
    to the unit of work system employed by SQLAlchemy, and is also key to the most
    common (and not-so-common) patterns of ORM usage.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 ORM 都要求对象有某种形式的主键定义，因为内存中的对象必须对应于数据库表中的唯一可识别行；至少，这允许对象可以被定位用于仅影响该对象行而不影响其他行的
    UPDATE 和 DELETE 语句。然而，主键的重要性远不止于此。在 SQLAlchemy 中，所有 ORM 映射的对象始终使用称为 [身份映射](../glossary.html#term-identity-map)
    的模式与它们的特定数据库行唯一链接在一起，这是 SQLAlchemy 使用的工作单元系统的核心模式，也是最常见的（和不那么常见的） ORM 使用模式的关键。
- en: Note
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It’s important to note that we’re only talking about the SQLAlchemy ORM; an
    application which builds on Core and deals only with [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects, [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") constructs and the like, **does not** need
    any primary key to be present on or associated with a table in any way (though
    again, in SQL, all tables should really have some kind of primary key, lest you
    need to actually update or delete specific rows).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，我们只讨论 SQLAlchemy ORM；一个基于 Core 构建并且只处理 [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") 对象、[`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") 构造等的应用程序 **不需要** 在任何方式上存在或关联表上有任何主键（尽管再次强调，在
    SQL 中，所有表应该真的有某种主键，以免您实际上需要更新或删除特定行）。
- en: 'In almost all cases, a table does have a so-called [candidate key](../glossary.html#term-candidate-key),
    which is a column or series of columns that uniquely identify a row. If a table
    truly doesn’t have this, and has actual fully duplicate rows, the table is not
    corresponding to [first normal form](https://en.wikipedia.org/wiki/First_normal_form)
    and cannot be mapped. Otherwise, whatever columns comprise the best candidate
    key can be applied directly to the mapper:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在几乎所有情况下，表确实有所谓的 [候选键](../glossary.html#term-candidate-key)，它是一列或一系列列，可以唯一标识一行。如果一张表真的没有这个，而且有实际完全重复的行，那么该表就不符合
    [第一范式](https://en.wikipedia.org/wiki/First_normal_form)，也不能被映射。否则，组成最佳候选键的任何列都可以直接应用到映射器上：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Better yet is when using fully declared table metadata, use the `primary_key=True`
    flag on those columns:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用完全声明的表元数据时，最好在这些列上使用 `primary_key=True` 标志：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'All tables in a relational database should have primary keys. Even a many-to-many
    association table - the primary key would be the composite of the two association
    columns:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 关系数据库中的所有表都应该有主键。即使是多对多关联表 - 主键将是两个关联列的组合：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: How do I configure a Column that is a Python reserved word or similar?
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何配置一个 Python 保留字或类似的 Column？
- en: Column-based attributes can be given any name desired in the mapping. See [Naming
    Declarative Mapped Columns Explicitly](../orm/declarative_tables.html#mapper-column-distinct-names).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 基于列的属性可以在映射中被赋予任何所需的名称。请参阅[明确命名声明式映射的列](../orm/declarative_tables.html#mapper-column-distinct-names)。
- en: How do I get a list of all columns, relationships, mapped attributes, etc. given
    a mapped class?
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何在给定一个映射类的情况下获取所有列、关系、映射属性等列表？
- en: This information is all available from the [`Mapper`](../orm/mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper") object.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些信息都可以从 [`Mapper`](../orm/mapping_api.html#sqlalchemy.orm.Mapper "sqlalchemy.orm.Mapper")
    对象中获得。
- en: 'To get at the [`Mapper`](../orm/mapping_api.html#sqlalchemy.orm.Mapper "sqlalchemy.orm.Mapper")
    for a particular mapped class, call the [`inspect()`](../core/inspection.html#sqlalchemy.inspect
    "sqlalchemy.inspect") function on it:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取特定映射类的 [`Mapper`](../orm/mapping_api.html#sqlalchemy.orm.Mapper "sqlalchemy.orm.Mapper")，请对其调用
    [`inspect()`](../core/inspection.html#sqlalchemy.inspect "sqlalchemy.inspect")
    函数：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'From there, all information about the class can be accessed through properties
    such as:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 从那里，关于类的所有信息都可以通过属性访问，例如：
- en: '[`Mapper.attrs`](../orm/mapping_api.html#sqlalchemy.orm.Mapper.attrs "sqlalchemy.orm.Mapper.attrs")
    - a namespace of all mapped attributes. The attributes themselves are instances
    of [`MapperProperty`](../orm/internals.html#sqlalchemy.orm.MapperProperty "sqlalchemy.orm.MapperProperty"),
    which contain additional attributes that can lead to the mapped SQL expression
    or column, if applicable.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`Mapper.attrs`](../orm/mapping_api.html#sqlalchemy.orm.Mapper.attrs "sqlalchemy.orm.Mapper.attrs")
    - 所有映射属性的命名空间。属性本身是 [`MapperProperty`](../orm/internals.html#sqlalchemy.orm.MapperProperty
    "sqlalchemy.orm.MapperProperty") 的实例，如果适用的话，它们包含可以导致映射的 SQL 表达式或列的其他属性。'
- en: '[`Mapper.column_attrs`](../orm/mapping_api.html#sqlalchemy.orm.Mapper.column_attrs
    "sqlalchemy.orm.Mapper.column_attrs") - the mapped attribute namespace limited
    to column and SQL expression attributes. You might want to use [`Mapper.columns`](../orm/mapping_api.html#sqlalchemy.orm.Mapper.columns
    "sqlalchemy.orm.Mapper.columns") to get at the [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects directly.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`Mapper.column_attrs`](../orm/mapping_api.html#sqlalchemy.orm.Mapper.column_attrs
    "sqlalchemy.orm.Mapper.column_attrs") - 限于列和 SQL 表达式属性的映射属性命名空间。您可能想直接使用 [`Mapper.columns`](../orm/mapping_api.html#sqlalchemy.orm.Mapper.columns
    "sqlalchemy.orm.Mapper.columns") 来获取 [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") 对象。'
- en: '[`Mapper.relationships`](../orm/mapping_api.html#sqlalchemy.orm.Mapper.relationships
    "sqlalchemy.orm.Mapper.relationships") - namespace of all [`RelationshipProperty`](../orm/internals.html#sqlalchemy.orm.RelationshipProperty
    "sqlalchemy.orm.RelationshipProperty") attributes.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`Mapper.relationships`](../orm/mapping_api.html#sqlalchemy.orm.Mapper.relationships
    "sqlalchemy.orm.Mapper.relationships") - 所有[`RelationshipProperty`](../orm/internals.html#sqlalchemy.orm.RelationshipProperty
    "sqlalchemy.orm.RelationshipProperty")属性的命名空间。'
- en: '[`Mapper.all_orm_descriptors`](../orm/mapping_api.html#sqlalchemy.orm.Mapper.all_orm_descriptors
    "sqlalchemy.orm.Mapper.all_orm_descriptors") - namespace of all mapped attributes,
    plus user-defined attributes defined using systems such as [`hybrid_property`](../orm/extensions/hybrid.html#sqlalchemy.ext.hybrid.hybrid_property
    "sqlalchemy.ext.hybrid.hybrid_property"), [`AssociationProxy`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy
    "sqlalchemy.ext.associationproxy.AssociationProxy") and others.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`Mapper.all_orm_descriptors`](../orm/mapping_api.html#sqlalchemy.orm.Mapper.all_orm_descriptors
    "sqlalchemy.orm.Mapper.all_orm_descriptors") - 所有映射属性的命名空间，以及使用[`hybrid_property`](../orm/extensions/hybrid.html#sqlalchemy.ext.hybrid.hybrid_property
    "sqlalchemy.ext.hybrid.hybrid_property")、[`AssociationProxy`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy
    "sqlalchemy.ext.associationproxy.AssociationProxy")等系统定义的用户定义属性。'
- en: '[`Mapper.columns`](../orm/mapping_api.html#sqlalchemy.orm.Mapper.columns "sqlalchemy.orm.Mapper.columns")
    - A namespace of [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    objects and other named SQL expressions associated with the mapping.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`Mapper.columns`](../orm/mapping_api.html#sqlalchemy.orm.Mapper.columns "sqlalchemy.orm.Mapper.columns")
    - [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")对象和与映射相关的其他命名
    SQL 表达式的命名空间。'
- en: '[`Mapper.mapped_table`](../orm/mapping_api.html#sqlalchemy.orm.Mapper.mapped_table
    "sqlalchemy.orm.Mapper.mapped_table") - The [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") or other selectable to which this mapper is mapped.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`Mapper.mapped_table`](../orm/mapping_api.html#sqlalchemy.orm.Mapper.mapped_table
    "sqlalchemy.orm.Mapper.mapped_table") - 该映射器所映射到的[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")或其他可选择的对象。'
- en: '[`Mapper.local_table`](../orm/mapping_api.html#sqlalchemy.orm.Mapper.local_table
    "sqlalchemy.orm.Mapper.local_table") - The [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") that is “local” to this mapper; this differs from [`Mapper.mapped_table`](../orm/mapping_api.html#sqlalchemy.orm.Mapper.mapped_table
    "sqlalchemy.orm.Mapper.mapped_table") in the case of a mapper mapped using inheritance
    to a composed selectable.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`Mapper.local_table`](../orm/mapping_api.html#sqlalchemy.orm.Mapper.local_table
    "sqlalchemy.orm.Mapper.local_table") - 此映射器“本地”的[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")；这在将映射器映射到组合可选择项的情况下与[`Mapper.mapped_table`](../orm/mapping_api.html#sqlalchemy.orm.Mapper.mapped_table
    "sqlalchemy.orm.Mapper.mapped_table")不同。'
- en: '## I’m getting a warning or error about “Implicitly combining column X under
    attribute Y”'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '## 我收到关于“隐式将列 X 组合到属性 Y 下”的警告或错误'
- en: This condition refers to when a mapping contains two columns that are being
    mapped under the same attribute name due to their name, but there’s no indication
    that this is intentional. A mapped class needs to have explicit names for every
    attribute that is to store an independent value; when two columns have the same
    name and aren’t disambiguated, they fall under the same attribute and the effect
    is that the value from one column is **copied** into the other, based on which
    column was assigned to the attribute first.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 此条件指的是当映射包含两列，这两列由于名称而被映射到同一属性名下，但没有表明这是有意的。映射的类需要为每个要存储独立值的属性明确指定名称；当两列具有相同的名称并且没有消歧时，它们就属于同一属性，其效果是将一列的值**复制**到另一列，根据哪一列首先分配给属性。
- en: This behavior is often desirable and is allowed without warning in the case
    where the two columns are linked together via a foreign key relationship within
    an inheritance mapping. When the warning or exception occurs, the issue can be
    resolved by either assigning the columns to differently-named attributes, or if
    combining them together is desired, by using [`column_property()`](../orm/mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property") to make this explicit.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为通常是可取的，在继承映射中通过外键关系将两列链接在一起时是允许的，而不会发出警告。当出现警告或异常时，可以通过将列分配给名称不同的属性来解决问题，或者如果希望将它们组合在一起，则使用[`column_property()`](../orm/mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property")使其明确。
- en: 'Given the example as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 给出如下示例：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As of SQLAlchemy version 0.9.5, the above condition is detected, and will warn
    that the `id` column of `A` and `B` is being combined under the same-named attribute
    `id`, which above is a serious issue since it means that a `B` object’s primary
    key will always mirror that of its `A`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 自SQLAlchemy版本0.9.5起，将检测到上述条件，并将警告说`A`和`B`的`id`列正在组合为同名属性`id`，这是一个严重的问题，因为这意味着`B`对象的主键将始终与其`A`的主键相同。
- en: 'A mapping which resolves this is as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 解决此问题的映射如下：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Suppose we did want `A.id` and `B.id` to be mirrors of each other, despite
    the fact that `B.a_id` is where `A.id` is related. We could combine them together
    using [`column_property()`](../orm/mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property"):'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们确实希望`A.id`和`B.id`互为镜像，尽管`B.a_id`是`A.id`相关的地方。我们可以使用[`column_property()`](../orm/mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property")将它们组合在一起：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: I’m using Declarative and setting primaryjoin/secondaryjoin using an `and_()`
    or `or_()`, and I am getting an error message about foreign keys.
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我正在使用声明式语法，并使用`and_()`或`or_()`设置`primaryjoin/secondaryjoin`，但是我收到了关于外键的错误消息。
- en: 'Are you doing this?:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你这样做了吗？：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'That’s an `and_()` of two string expressions, which SQLAlchemy cannot apply
    any mapping towards. Declarative allows [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") arguments to be specified as strings, which are
    converted into expression objects using `eval()`. But this doesn’t occur inside
    of an `and_()` expression - it’s a special operation declarative applies only
    to the *entirety* of what’s passed to primaryjoin or other arguments as a string:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 那是两个字符串表达式的`and_()`，而SQLAlchemy不能对其应用任何映射。声明式允许将[`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")参数指定为字符串，这些字符串将使用`eval()`转换为表达式对象。但这不会发生在`and_()`表达式内部
    - 这是声明式仅对作为字符串传递给`primaryjoin`或其他参数的*整体*应用的特殊操作：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Or if the objects you need are already available, skip the strings:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果您需要的对象已经可用，请跳过字符串：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The same idea applies to all the other arguments, such as `foreign_keys`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的想法也适用于所有其他参数，比如`foreign_keys`：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '## Why is `ORDER BY` recommended with `LIMIT` (especially with `subqueryload()`)?'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '## 为什么推荐使用`ORDER BY`与`LIMIT`（特别是与`subqueryload()`一起）？'
- en: When ORDER BY is not used for a SELECT statement that returns rows, the relational
    database is free to returned matched rows in any arbitrary order. While this ordering
    very often corresponds to the natural order of rows within a table, this is not
    the case for all databases and all queries. The consequence of this is that any
    query that limits rows using `LIMIT` or `OFFSET`, or which merely selects the
    first row of the result, discarding the rest, will not be deterministic in terms
    of what result row is returned, assuming there’s more than one row that matches
    the query’s criteria.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当SELECT语句返回行时未使用ORDER BY时，关系数据库可以以任意顺序返回匹配的行。虽然这种排序很常见，对应于表中行的自然顺序，但并不是所有数据库和所有查询都是如此。这样做的结果是，任何使用`LIMIT`或`OFFSET`限制行，或者仅选择结果的第一行，而放弃其余部分的查询，在返回结果行时不是确定性的，假设有多个行匹配查询的条件。
- en: While we may not notice this for simple queries on databases that usually returns
    rows in their natural order, it becomes more of an issue if we also use [`subqueryload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.subqueryload
    "sqlalchemy.orm.subqueryload") to load related collections, and we may not be
    loading the collections as intended.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们可能不会注意到这一点，因为对于通常以其自然顺序返回行的数据库上的简单查询，它更多地成为问题，如果我们还使用[`subqueryload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.subqueryload
    "sqlalchemy.orm.subqueryload")来加载相关集合，并且我们可能无法按预期加载集合。
- en: 'SQLAlchemy implements [`subqueryload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.subqueryload
    "sqlalchemy.orm.subqueryload") by issuing a separate query, the results of which
    are matched up to the results from the first query. We see two queries emitted
    like this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy通过发出单独的查询来实现[`subqueryload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.subqueryload
    "sqlalchemy.orm.subqueryload")，其结果与第一个查询的结果匹配。我们会看到像这样发出两个查询：
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The second query embeds the first query as a source of rows. When the inner
    query uses `OFFSET` and/or `LIMIT` without ordering, the two queries may not see
    the same results:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个查询将第一个查询嵌入为行的来源。当内部查询使用`OFFSET`和/或`LIMIT`而没有排序时，这两个查询可能不会看到相同的结果：
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Depending on database specifics, there is a chance we may get a result like
    the following for the two queries:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 根据数据库的具体情况，我们可能会得到如下两个查询的结果：
- en: '[PRE13]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Above, we receive two `addresses` rows for `user.id` of 2, and none for 1\.
    We’ve wasted two rows and failed to actually load the collection. This is an insidious
    error because without looking at the SQL and the results, the ORM will not show
    that there’s any issue; if we access the `addresses` for the `User` we have, it
    will emit a lazy load for the collection and we won’t see that anything actually
    went wrong.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，我们为`user.id`为2的用户接收到了两行`addresses`，而对于id为1的用户却没有。我们浪费了两行，并且未能实际加载集合。这是一个隐匿的错误，因为不查看
    SQL 和结果，ORM 将不会显示任何问题；如果我们访问已有的`User`的`addresses`，它会对集合进行惰性加载，我们将看不到任何实际错误发生。
- en: 'The solution to this problem is to always specify a deterministic sort order,
    so that the main query always returns the same set of rows. This generally means
    that you should [`Select.order_by()`](../core/selectable.html#sqlalchemy.sql.expression.Select.order_by
    "sqlalchemy.sql.expression.Select.order_by") on a unique column on the table.
    The primary key is a good choice for this:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 解决此问题的方法是始终指定确定性排序顺序，以便主查询始终返回相同的行集。这通常意味着您应该在表的唯一列上进行 [`Select.order_by()`](../core/selectable.html#sqlalchemy.sql.expression.Select.order_by
    "sqlalchemy.sql.expression.Select.order_by") 排序。主键是一个不错的选择：
- en: '[PRE14]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note that the [`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload") eager loader strategy does not suffer from the same
    problem because only one query is ever issued, so the load query cannot be different
    from the main query. Similarly, the [`selectinload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.selectinload
    "sqlalchemy.orm.selectinload") eager loader strategy also does not have this issue
    as it links its collection loads directly to primary key values just loaded.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，[`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload") 这种预加载策略不会遇到相同的问题，因为只会发出一个查询，所以加载查询不会与主查询不同。同样，[`selectinload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.selectinload
    "sqlalchemy.orm.selectinload") 这种预加载策略也不会有此问题，因为它将其集合加载直接链接到刚刚加载的主键值。
- en: See also
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Subquery Eager Loading](../orm/queryguide/relationships.html#subquery-eager-loading)  ##
    How do I map a table that has no primary key?'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '[子查询预加载](../orm/queryguide/relationships.html#subquery-eager-loading)  ## 我如何映射一个没有主键的表？'
- en: The SQLAlchemy ORM, in order to map to a particular table, needs there to be
    at least one column denoted as a primary key column; multiple-column, i.e. composite,
    primary keys are of course entirely feasible as well. These columns do **not**
    need to be actually known to the database as primary key columns, though it’s
    a good idea that they are. It’s only necessary that the columns *behave* as a
    primary key does, e.g. as a unique and not nullable identifier for a row.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy ORM 为了映射到特定表，需要至少有一个列被指定为主键列；多列，即复合主键，当然也是完全可行的。这些列**不**需要实际上被数据库知道为主键列，尽管它们是主键列是个好主意。只需要这些列表现出主键的行为即可，例如作为行的唯一标识符和不可为空的标识符。
- en: Most ORMs require that objects have some kind of primary key defined because
    the object in memory must correspond to a uniquely identifiable row in the database
    table; at the very least, this allows the object can be targeted for UPDATE and
    DELETE statements which will affect only that object’s row and no other. However,
    the importance of the primary key goes far beyond that. In SQLAlchemy, all ORM-mapped
    objects are at all times linked uniquely within a [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") to their specific database row using a pattern called
    the [identity map](../glossary.html#term-identity-map), a pattern that’s central
    to the unit of work system employed by SQLAlchemy, and is also key to the most
    common (and not-so-common) patterns of ORM usage.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 ORM 要求对象定义某种主键，因为内存中的对象必须对应于数据库表中的唯一可识别行；至少，这允许对象可以成为 UPDATE 和 DELETE 语句的目标，这些语句将仅影响该对象的行，而不会影响其他行。但是，主键的重要性远不止于此。在
    SQLAlchemy 中，所有 ORM 映射的对象始终通过称为[标识映射](../glossary.html#term-identity-map)的模式与其特定数据库行唯一链接到一个
    [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    中，该模式是 SQLAlchemy 使用的工作单元系统的核心，并且也是最常见（以及不那么常见）的 ORM 使用模式的关键。
- en: Note
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It’s important to note that we’re only talking about the SQLAlchemy ORM; an
    application which builds on Core and deals only with [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects, [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") constructs and the like, **does not** need
    any primary key to be present on or associated with a table in any way (though
    again, in SQL, all tables should really have some kind of primary key, lest you
    need to actually update or delete specific rows).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，我们只谈论SQLAlchemy ORM；一个建立在Core之上、仅处理[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")对象、[`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select")构造等的应用程序，**不需要**在任何方式上要求主键存在于或与表相关联（尽管在SQL中，所有表实际上都应该具有某种主键，否则你可能需要实际更新或删除特定行）。
- en: 'In almost all cases, a table does have a so-called [candidate key](../glossary.html#term-candidate-key),
    which is a column or series of columns that uniquely identify a row. If a table
    truly doesn’t have this, and has actual fully duplicate rows, the table is not
    corresponding to [first normal form](https://en.wikipedia.org/wiki/First_normal_form)
    and cannot be mapped. Otherwise, whatever columns comprise the best candidate
    key can be applied directly to the mapper:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎在所有情况下，表都具有所谓的 [候选键](../glossary.html#term-candidate-key)，这是一列或一系列列，唯一标识一行。如果表确实没有这个，且具有实际完全重复的行，则该表不符合[第一范式](https://en.wikipedia.org/wiki/First_normal_form)，无法进行映射。否则，组成最佳候选键的任何列都可以直接应用于映射器：
- en: '[PRE15]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Better yet is when using fully declared table metadata, use the `primary_key=True`
    flag on those columns:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用完全声明的表元数据时，最好在这些列上使用`primary_key=True`标志：
- en: '[PRE16]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'All tables in a relational database should have primary keys. Even a many-to-many
    association table - the primary key would be the composite of the two association
    columns:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 关系数据库中的所有表都应该有主键。即使是多对多的关联表 - 主键也将是两个关联列的组合：
- en: '[PRE17]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: How do I configure a Column that is a Python reserved word or similar?
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何配置一个是Python保留字或类似的列？
- en: Column-based attributes can be given any name desired in the mapping. See [Naming
    Declarative Mapped Columns Explicitly](../orm/declarative_tables.html#mapper-column-distinct-names).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在映射中，基于列的属性可以赋予任何所需的名称。参见[显式命名声明式映射的列](../orm/declarative_tables.html#mapper-column-distinct-names)。
- en: How do I get a list of all columns, relationships, mapped attributes, etc. given
    a mapped class?
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何获取给定映射类的所有列、关系、映射属性等列表？
- en: This information is all available from the [`Mapper`](../orm/mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper") object.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些信息都可以从[`Mapper`](../orm/mapping_api.html#sqlalchemy.orm.Mapper "sqlalchemy.orm.Mapper")对象中获取。
- en: 'To get at the [`Mapper`](../orm/mapping_api.html#sqlalchemy.orm.Mapper "sqlalchemy.orm.Mapper")
    for a particular mapped class, call the [`inspect()`](../core/inspection.html#sqlalchemy.inspect
    "sqlalchemy.inspect") function on it:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取特定映射类的[`Mapper`](../orm/mapping_api.html#sqlalchemy.orm.Mapper "sqlalchemy.orm.Mapper")，请在其上调用[`inspect()`](../core/inspection.html#sqlalchemy.inspect
    "sqlalchemy.inspect")函数：
- en: '[PRE18]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'From there, all information about the class can be accessed through properties
    such as:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 从那里，可以通过诸如以下属性之类的属性访问有关类的所有信息：
- en: '[`Mapper.attrs`](../orm/mapping_api.html#sqlalchemy.orm.Mapper.attrs "sqlalchemy.orm.Mapper.attrs")
    - a namespace of all mapped attributes. The attributes themselves are instances
    of [`MapperProperty`](../orm/internals.html#sqlalchemy.orm.MapperProperty "sqlalchemy.orm.MapperProperty"),
    which contain additional attributes that can lead to the mapped SQL expression
    or column, if applicable.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`Mapper.attrs`](../orm/mapping_api.html#sqlalchemy.orm.Mapper.attrs "sqlalchemy.orm.Mapper.attrs")
    - 所有映射属性的命名空间。这些属性本身是[`MapperProperty`](../orm/internals.html#sqlalchemy.orm.MapperProperty
    "sqlalchemy.orm.MapperProperty")的实例，其中包含了可导致映射的SQL表达式或列的其他属性（如果适用）。'
- en: '[`Mapper.column_attrs`](../orm/mapping_api.html#sqlalchemy.orm.Mapper.column_attrs
    "sqlalchemy.orm.Mapper.column_attrs") - the mapped attribute namespace limited
    to column and SQL expression attributes. You might want to use [`Mapper.columns`](../orm/mapping_api.html#sqlalchemy.orm.Mapper.columns
    "sqlalchemy.orm.Mapper.columns") to get at the [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects directly.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`Mapper.column_attrs`](../orm/mapping_api.html#sqlalchemy.orm.Mapper.column_attrs
    "sqlalchemy.orm.Mapper.column_attrs") - 仅限于列和SQL表达式属性的映射属性命名空间。你可能想使用[`Mapper.columns`](../orm/mapping_api.html#sqlalchemy.orm.Mapper.columns
    "sqlalchemy.orm.Mapper.columns")直接获取 [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")对象。'
- en: '[`Mapper.relationships`](../orm/mapping_api.html#sqlalchemy.orm.Mapper.relationships
    "sqlalchemy.orm.Mapper.relationships") - namespace of all [`RelationshipProperty`](../orm/internals.html#sqlalchemy.orm.RelationshipProperty
    "sqlalchemy.orm.RelationshipProperty") attributes.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`Mapper.relationships`](../orm/mapping_api.html#sqlalchemy.orm.Mapper.relationships
    "sqlalchemy.orm.Mapper.relationships") - 所有 [`RelationshipProperty`](../orm/internals.html#sqlalchemy.orm.RelationshipProperty
    "sqlalchemy.orm.RelationshipProperty") 属性的命名空间。'
- en: '[`Mapper.all_orm_descriptors`](../orm/mapping_api.html#sqlalchemy.orm.Mapper.all_orm_descriptors
    "sqlalchemy.orm.Mapper.all_orm_descriptors") - namespace of all mapped attributes,
    plus user-defined attributes defined using systems such as [`hybrid_property`](../orm/extensions/hybrid.html#sqlalchemy.ext.hybrid.hybrid_property
    "sqlalchemy.ext.hybrid.hybrid_property"), [`AssociationProxy`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy
    "sqlalchemy.ext.associationproxy.AssociationProxy") and others.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`Mapper.all_orm_descriptors`](../orm/mapping_api.html#sqlalchemy.orm.Mapper.all_orm_descriptors
    "sqlalchemy.orm.Mapper.all_orm_descriptors") - 所有映射属性的命名空间，以及使用诸如 [`hybrid_property`](../orm/extensions/hybrid.html#sqlalchemy.ext.hybrid.hybrid_property
    "sqlalchemy.ext.hybrid.hybrid_property")、[`AssociationProxy`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy
    "sqlalchemy.ext.associationproxy.AssociationProxy") 等系统定义的用户定义属性等。'
- en: '[`Mapper.columns`](../orm/mapping_api.html#sqlalchemy.orm.Mapper.columns "sqlalchemy.orm.Mapper.columns")
    - A namespace of [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    objects and other named SQL expressions associated with the mapping.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`Mapper.columns`](../orm/mapping_api.html#sqlalchemy.orm.Mapper.columns "sqlalchemy.orm.Mapper.columns")
    - 与映射相关联的 [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    对象和其他命名 SQL 表达式的命名空间。'
- en: '[`Mapper.mapped_table`](../orm/mapping_api.html#sqlalchemy.orm.Mapper.mapped_table
    "sqlalchemy.orm.Mapper.mapped_table") - The [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") or other selectable to which this mapper is mapped.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`Mapper.mapped_table`](../orm/mapping_api.html#sqlalchemy.orm.Mapper.mapped_table
    "sqlalchemy.orm.Mapper.mapped_table") - 此映射器映射到的 [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") 或其他可选择的对象。'
- en: '[`Mapper.local_table`](../orm/mapping_api.html#sqlalchemy.orm.Mapper.local_table
    "sqlalchemy.orm.Mapper.local_table") - The [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") that is “local” to this mapper; this differs from [`Mapper.mapped_table`](../orm/mapping_api.html#sqlalchemy.orm.Mapper.mapped_table
    "sqlalchemy.orm.Mapper.mapped_table") in the case of a mapper mapped using inheritance
    to a composed selectable.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`Mapper.local_table`](../orm/mapping_api.html#sqlalchemy.orm.Mapper.local_table
    "sqlalchemy.orm.Mapper.local_table") - 此映射器“本地”的 [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")；在映射器使用继承映射到组合选择时，这与 [`Mapper.mapped_table`](../orm/mapping_api.html#sqlalchemy.orm.Mapper.mapped_table
    "sqlalchemy.orm.Mapper.mapped_table") 不同。'
- en: '## I’m getting a warning or error about “Implicitly combining column X under
    attribute Y”'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '## 我收到了一个关于“隐式组合列 X 在属性 Y 下”的警告或错误'
- en: This condition refers to when a mapping contains two columns that are being
    mapped under the same attribute name due to their name, but there’s no indication
    that this is intentional. A mapped class needs to have explicit names for every
    attribute that is to store an independent value; when two columns have the same
    name and aren’t disambiguated, they fall under the same attribute and the effect
    is that the value from one column is **copied** into the other, based on which
    column was assigned to the attribute first.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况指的是映射包含两个列，这两个列由于它们的名称而被映射到同一属性名称下，但没有迹象表明这是有意的。映射类需要为每个要存储独立值的属性指定明确的名称；当两个列具有相同的名称并且没有消歧义时，它们就会落入同一个属性下，效果是从一个列中的值被**复制**到另一个列中，取决于哪个列首先分配给属性。
- en: This behavior is often desirable and is allowed without warning in the case
    where the two columns are linked together via a foreign key relationship within
    an inheritance mapping. When the warning or exception occurs, the issue can be
    resolved by either assigning the columns to differently-named attributes, or if
    combining them together is desired, by using [`column_property()`](../orm/mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property") to make this explicit.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为通常是可取的，在继承映射内部通过外键关系链接两个列时，无需警告即可允许。当出现警告或异常时，可以通过将列分配给不同命名的属性来解决问题，或者如果希望将它们组合在一起，则可以使用[`column_property()`](../orm/mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property")来明确表示这一点。
- en: 'Given the example as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 给出如下示例：
- en: '[PRE19]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: As of SQLAlchemy version 0.9.5, the above condition is detected, and will warn
    that the `id` column of `A` and `B` is being combined under the same-named attribute
    `id`, which above is a serious issue since it means that a `B` object’s primary
    key will always mirror that of its `A`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 截至SQLAlchemy版本0.9.5，检测到上述条件，并将警告`A`和`B`的`id`列正在合并到同名属性`id`下，上面是一个严重问题，因为这意味着`B`对象的主键将始终反映其`A`的主键。
- en: 'A mapping which resolves this is as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 解决此问题的映射如下：
- en: '[PRE20]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Suppose we did want `A.id` and `B.id` to be mirrors of each other, despite
    the fact that `B.a_id` is where `A.id` is related. We could combine them together
    using [`column_property()`](../orm/mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property"):'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们确实希望`A.id`和`B.id`彼此镜像，尽管`B.a_id`是`A.id`相关的地方。我们可以使用[`column_property()`](../orm/mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property")将它们合并在一起：
- en: '[PRE21]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: I’m using Declarative and setting primaryjoin/secondaryjoin using an `and_()`
    or `or_()`, and I am getting an error message about foreign keys.
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我正在使用声明式并使用`and_()`或`or_()`设置primaryjoin/secondaryjoin，并且收到有关外键的错误消息。
- en: 'Are you doing this?:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '您是这样做的吗？:'
- en: '[PRE22]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'That’s an `and_()` of two string expressions, which SQLAlchemy cannot apply
    any mapping towards. Declarative allows [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") arguments to be specified as strings, which are
    converted into expression objects using `eval()`. But this doesn’t occur inside
    of an `and_()` expression - it’s a special operation declarative applies only
    to the *entirety* of what’s passed to primaryjoin or other arguments as a string:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这是两个字符串表达式的`and_()`，SQLAlchemy无法对其应用任何映射。声明式允许将[`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")参数指定为字符串，并使用`eval()`将其转换为表达式对象。但这不会发生在`and_()`表达式内部
    - 它是声明式仅适用于作为字符串传递给primaryjoin或其他参数的整体的特殊操作：
- en: '[PRE23]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Or if the objects you need are already available, skip the strings:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 或者如果您需要的对象已经可用，请跳过字符串：
- en: '[PRE24]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The same idea applies to all the other arguments, such as `foreign_keys`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的想法适用于所有其他参数，例如`foreign_keys`：
- en: '[PRE25]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '## Why is `ORDER BY` recommended with `LIMIT` (especially with `subqueryload()`)?'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '## 为什么推荐在`LIMIT`中使用`ORDER BY`（特别是在`subqueryload()`中）？'
- en: When ORDER BY is not used for a SELECT statement that returns rows, the relational
    database is free to returned matched rows in any arbitrary order. While this ordering
    very often corresponds to the natural order of rows within a table, this is not
    the case for all databases and all queries. The consequence of this is that any
    query that limits rows using `LIMIT` or `OFFSET`, or which merely selects the
    first row of the result, discarding the rest, will not be deterministic in terms
    of what result row is returned, assuming there’s more than one row that matches
    the query’s criteria.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当没有为返回行的SELECT语句使用ORDER BY时，关系数据库可以以任意的顺序返回匹配的行。虽然这种排序往往对应于表内行的自然顺序，但并非所有数据库和所有查询都是如此。这样做的结果是，任何使用`LIMIT`或`OFFSET`限制行数的查询，或者仅选择结果的第一行，丢弃其余行的查询，在返回哪个结果行时不是确定性的，假设查询的条件有多个匹配行。
- en: While we may not notice this for simple queries on databases that usually returns
    rows in their natural order, it becomes more of an issue if we also use [`subqueryload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.subqueryload
    "sqlalchemy.orm.subqueryload") to load related collections, and we may not be
    loading the collections as intended.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们可能在通常按照它们的自然顺序返回行的数据库上的简单查询中没有注意到这一点，但如果我们还使用[`subqueryload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.subqueryload
    "sqlalchemy.orm.subqueryload")来加载相关集合，这就更成为一个问题，我们可能不会按预期加载集合。
- en: 'SQLAlchemy implements [`subqueryload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.subqueryload
    "sqlalchemy.orm.subqueryload") by issuing a separate query, the results of which
    are matched up to the results from the first query. We see two queries emitted
    like this:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy通过发出单独的查询来实现[`subqueryload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.subqueryload
    "sqlalchemy.orm.subqueryload")，其结果与第一个查询的结果匹配。我们看到像这样发出的两个查询：
- en: '[PRE26]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The second query embeds the first query as a source of rows. When the inner
    query uses `OFFSET` and/or `LIMIT` without ordering, the two queries may not see
    the same results:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个查询将第一个查询嵌入为行的源。当内部查询使用`OFFSET`和/或`LIMIT`而没有排序时，这两个查询可能不会看到相同的结果：
- en: '[PRE27]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Depending on database specifics, there is a chance we may get a result like
    the following for the two queries:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 根据数据库的具体情况，我们可能会得到以下两个查询的结果：
- en: '[PRE28]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Above, we receive two `addresses` rows for `user.id` of 2, and none for 1\.
    We’ve wasted two rows and failed to actually load the collection. This is an insidious
    error because without looking at the SQL and the results, the ORM will not show
    that there’s any issue; if we access the `addresses` for the `User` we have, it
    will emit a lazy load for the collection and we won’t see that anything actually
    went wrong.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所述，我们对于`user.id`为2的两个`addresses`行，却没有对于1的。我们浪费了两行，并且未能实际加载集合。这是一个潜在的错误，因为如果不查看
    SQL 和结果，ORM 将不会显示任何问题；如果我们访问我们拥有的`User`的`addresses`，它将对集合进行惰性加载，并且我们将看不到任何实际出错的情况。
- en: 'The solution to this problem is to always specify a deterministic sort order,
    so that the main query always returns the same set of rows. This generally means
    that you should [`Select.order_by()`](../core/selectable.html#sqlalchemy.sql.expression.Select.order_by
    "sqlalchemy.sql.expression.Select.order_by") on a unique column on the table.
    The primary key is a good choice for this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的方法是始终指定确定性的排序顺序，以便主查询始终返回相同的行集合。这通常意味着你应该在表上的一个唯一列上使用[`Select.order_by()`](../core/selectable.html#sqlalchemy.sql.expression.Select.order_by
    "sqlalchemy.sql.expression.Select.order_by")。主键是一个不错的选择：
- en: '[PRE29]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Note that the [`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload") eager loader strategy does not suffer from the same
    problem because only one query is ever issued, so the load query cannot be different
    from the main query. Similarly, the [`selectinload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.selectinload
    "sqlalchemy.orm.selectinload") eager loader strategy also does not have this issue
    as it links its collection loads directly to primary key values just loaded.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，[`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload") 急加载策略不会遭受相同的问题，因为只发出一次查询，因此加载查询不能与主查询不同。类似地，[`selectinload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.selectinload
    "sqlalchemy.orm.selectinload") 急加载策略也不会有此问题，因为它将其集合加载直接链接到刚刚加载的主键值。
- en: See also
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Subquery Eager Loading](../orm/queryguide/relationships.html#subquery-eager-loading)'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '[子查询的急加载](../orm/queryguide/relationships.html#subquery-eager-loading)'
