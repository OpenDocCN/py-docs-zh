["```py\nclass sqlalchemy.event.base.Events\n```", "```py\nattribute dispatch: _Dispatch[_ET] = <sqlalchemy.event.base.EventsDispatch object>\n```", "```py\nclass sqlalchemy.events.PoolEvents\n```", "```py\nfrom sqlalchemy import event\n\ndef my_on_checkout(dbapi_conn, connection_rec, connection_proxy):\n    \"handle an on checkout event\"\n\nevent.listen(Pool, 'checkout', my_on_checkout)\n```", "```py\nengine = create_engine(\"postgresql+psycopg2://scott:tiger@localhost/test\")\n\n# will associate with engine.pool\nevent.listen(engine, 'checkout', my_on_checkout)\n```", "```py\nmethod checkin(dbapi_connection: DBAPIConnection | None, connection_record: ConnectionPoolEntry) \u2192 None\n```", "```py\nfrom sqlalchemy import event\n\n@event.listens_for(SomeEngineOrPool, 'checkin')\ndef receive_checkin(dbapi_connection, connection_record):\n    \"listen for the 'checkin' event\"\n\n    # ... (event handling logic) ...\n```", "```py\nmethod checkout(dbapi_connection: DBAPIConnection, connection_record: ConnectionPoolEntry, connection_proxy: PoolProxiedConnection) \u2192 None\n```", "```py\nfrom sqlalchemy import event\n\n@event.listens_for(SomeEngineOrPool, 'checkout')\ndef receive_checkout(dbapi_connection, connection_record, connection_proxy):\n    \"listen for the 'checkout' event\"\n\n    # ... (event handling logic) ...\n```", "```py\nmethod close(dbapi_connection: DBAPIConnection, connection_record: ConnectionPoolEntry) \u2192 None\n```", "```py\nfrom sqlalchemy import event\n\n@event.listens_for(SomeEngineOrPool, 'close')\ndef receive_close(dbapi_connection, connection_record):\n    \"listen for the 'close' event\"\n\n    # ... (event handling logic) ...\n```", "```py\nmethod close_detached(dbapi_connection: DBAPIConnection) \u2192 None\n```", "```py\nfrom sqlalchemy import event\n\n@event.listens_for(SomeEngineOrPool, 'close_detached')\ndef receive_close_detached(dbapi_connection):\n    \"listen for the 'close_detached' event\"\n\n    # ... (event handling logic) ...\n```", "```py\nmethod connect(dbapi_connection: DBAPIConnection, connection_record: ConnectionPoolEntry) \u2192 None\n```", "```py\nfrom sqlalchemy import event\n\n@event.listens_for(SomeEngineOrPool, 'connect')\ndef receive_connect(dbapi_connection, connection_record):\n    \"listen for the 'connect' event\"\n\n    # ... (event handling logic) ...\n```", "```py\nmethod detach(dbapi_connection: DBAPIConnection, connection_record: ConnectionPoolEntry) \u2192 None\n```", "```py\nfrom sqlalchemy import event\n\n@event.listens_for(SomeEngineOrPool, 'detach')\ndef receive_detach(dbapi_connection, connection_record):\n    \"listen for the 'detach' event\"\n\n    # ... (event handling logic) ...\n```", "```py\nattribute dispatch: _Dispatch[_ET] = <sqlalchemy.event.base.PoolEventsDispatch object>\n```", "```py\nmethod first_connect(dbapi_connection: DBAPIConnection, connection_record: ConnectionPoolEntry) \u2192 None\n```", "```py\nfrom sqlalchemy import event\n\n@event.listens_for(SomeEngineOrPool, 'first_connect')\ndef receive_first_connect(dbapi_connection, connection_record):\n    \"listen for the 'first_connect' event\"\n\n    # ... (event handling logic) ...\n```", "```py\nmethod invalidate(dbapi_connection: DBAPIConnection, connection_record: ConnectionPoolEntry, exception: BaseException | None) \u2192 None\n```", "```py\nfrom sqlalchemy import event\n\n@event.listens_for(SomeEngineOrPool, 'invalidate')\ndef receive_invalidate(dbapi_connection, connection_record, exception):\n    \"listen for the 'invalidate' event\"\n\n    # ... (event handling logic) ...\n```", "```py\nmethod reset(dbapi_connection: DBAPIConnection, connection_record: ConnectionPoolEntry, reset_state: PoolResetState) \u2192 None\n```", "```py\nfrom sqlalchemy import event\n\n@event.listens_for(SomeEngineOrPool, 'reset')\ndef receive_reset(dbapi_connection, connection_record, reset_state):\n    \"listen for the 'reset' event\"\n\n    # ... (event handling logic) ...\n\n# DEPRECATED calling style (pre-2.0, will be removed in a future release)\n@event.listens_for(SomeEngineOrPool, 'reset')\ndef receive_reset(dbapi_connection, connection_record):\n    \"listen for the 'reset' event\"\n\n    # ... (event handling logic) ...\n```", "```py\nmethod soft_invalidate(dbapi_connection: DBAPIConnection, connection_record: ConnectionPoolEntry, exception: BaseException | None) \u2192 None\n```", "```py\nfrom sqlalchemy import event\n\n@event.listens_for(SomeEngineOrPool, 'soft_invalidate')\ndef receive_soft_invalidate(dbapi_connection, connection_record, exception):\n    \"listen for the 'soft_invalidate' event\"\n\n    # ... (event handling logic) ...\n```", "```py\nclass sqlalchemy.events.PoolResetState\n```", "```py\nattribute asyncio_safe: bool\n```", "```py\nattribute terminate_only: bool\n```", "```py\nattribute transaction_was_reset: bool\n```", "```py\nclass sqlalchemy.events.ConnectionEvents\n```", "```py\nfrom sqlalchemy import event, create_engine\n\ndef before_cursor_execute(conn, cursor, statement, parameters, context,\n                                                executemany):\n    log.info(\"Received statement: %s\", statement)\n\nengine = create_engine('postgresql+psycopg2://scott:tiger@localhost/test')\nevent.listen(engine, \"before_cursor_execute\", before_cursor_execute)\n```", "```py\nwith engine.begin() as conn:\n    @event.listens_for(conn, 'before_cursor_execute')\n    def before_cursor_execute(conn, cursor, statement, parameters,\n                                    context, executemany):\n        log.info(\"Received statement: %s\", statement)\n```", "```py\nfrom sqlalchemy.engine import Engine\nfrom sqlalchemy import event\n\n@event.listens_for(Engine, \"before_cursor_execute\", retval=True)\ndef comment_sql_calls(conn, cursor, statement, parameters,\n                                    context, executemany):\n    statement = statement + \" -- some comment\"\n    return statement, parameters\n```", "```py\nmethod after_cursor_execute(conn: Connection, cursor: DBAPICursor, statement: str, parameters: _DBAPIAnyExecuteParams, context: ExecutionContext | None, executemany: bool) \u2192 None\n```", "```py\nfrom sqlalchemy import event\n\n@event.listens_for(SomeEngine, 'after_cursor_execute')\ndef receive_after_cursor_execute(conn, cursor, statement, parameters, context, executemany):\n    \"listen for the 'after_cursor_execute' event\"\n\n    # ... (event handling logic) ...\n```", "```py\nmethod after_execute(conn: Connection, clauseelement: Executable, multiparams: _CoreMultiExecuteParams, params: _CoreSingleExecuteParams, execution_options: _ExecuteOptions, result: Result[Any]) \u2192 None\n```", "```py\nfrom sqlalchemy import event\n\n@event.listens_for(SomeEngine, 'after_execute')\ndef receive_after_execute(conn, clauseelement, multiparams, params, execution_options, result):\n    \"listen for the 'after_execute' event\"\n\n    # ... (event handling logic) ...\n\n# DEPRECATED calling style (pre-1.4, will be removed in a future release)\n@event.listens_for(SomeEngine, 'after_execute')\ndef receive_after_execute(conn, clauseelement, multiparams, params, result):\n    \"listen for the 'after_execute' event\"\n\n    # ... (event handling logic) ...\n```", "```py\nmethod before_cursor_execute(conn: Connection, cursor: DBAPICursor, statement: str, parameters: _DBAPIAnyExecuteParams, context: ExecutionContext | None, executemany: bool) \u2192 Tuple[str, _DBAPIAnyExecuteParams] | None\n```", "```py\nfrom sqlalchemy import event\n\n@event.listens_for(SomeEngine, 'before_cursor_execute')\ndef receive_before_cursor_execute(conn, cursor, statement, parameters, context, executemany):\n    \"listen for the 'before_cursor_execute' event\"\n\n    # ... (event handling logic) ...\n```", "```py\n@event.listens_for(Engine, \"before_cursor_execute\", retval=True)\ndef before_cursor_execute(conn, cursor, statement,\n                parameters, context, executemany):\n    # do something with statement, parameters\n    return statement, parameters\n```", "```py\nmethod before_execute(conn: Connection, clauseelement: Executable, multiparams: _CoreMultiExecuteParams, params: _CoreSingleExecuteParams, execution_options: _ExecuteOptions) \u2192 Tuple[Executable, _CoreMultiExecuteParams, _CoreSingleExecuteParams] | None\n```", "```py\nfrom sqlalchemy import event\n\n@event.listens_for(SomeEngine, 'before_execute')\ndef receive_before_execute(conn, clauseelement, multiparams, params, execution_options):\n    \"listen for the 'before_execute' event\"\n\n    # ... (event handling logic) ...\n\n# DEPRECATED calling style (pre-1.4, will be removed in a future release)\n@event.listens_for(SomeEngine, 'before_execute')\ndef receive_before_execute(conn, clauseelement, multiparams, params):\n    \"listen for the 'before_execute' event\"\n\n    # ... (event handling logic) ...\n```", "```py\n@event.listens_for(Engine, \"before_execute\", retval=True)\ndef before_execute(conn, clauseelement, multiparams, params):\n    # do something with clauseelement, multiparams, params\n    return clauseelement, multiparams, params\n```", "```py\nmethod begin(conn: Connection) \u2192 None\n```", "```py\nfrom sqlalchemy import event\n\n@event.listens_for(SomeEngine, 'begin')\ndef receive_begin(conn):\n    \"listen for the 'begin' event\"\n\n    # ... (event handling logic) ...\n```", "```py\nmethod begin_twophase(conn: Connection, xid: Any) \u2192 None\n```", "```py\nfrom sqlalchemy import event\n\n@event.listens_for(SomeEngine, 'begin_twophase')\ndef receive_begin_twophase(conn, xid):\n    \"listen for the 'begin_twophase' event\"\n\n    # ... (event handling logic) ...\n```", "```py\nmethod commit(conn: Connection) \u2192 None\n```", "```py\nfrom sqlalchemy import event\n\n@event.listens_for(SomeEngine, 'commit')\ndef receive_commit(conn):\n    \"listen for the 'commit' event\"\n\n    # ... (event handling logic) ...\n```", "```py\nmethod commit_twophase(conn: Connection, xid: Any, is_prepared: bool) \u2192 None\n```", "```py\nfrom sqlalchemy import event\n\n@event.listens_for(SomeEngine, 'commit_twophase')\ndef receive_commit_twophase(conn, xid, is_prepared):\n    \"listen for the 'commit_twophase' event\"\n\n    # ... (event handling logic) ...\n```", "```py\nattribute dispatch: _Dispatch[_ET] = <sqlalchemy.event.base.ConnectionEventsDispatch object>\n```", "```py\nmethod engine_connect(conn: Connection) \u2192 None\n```", "```py\nfrom sqlalchemy import event\n\n@event.listens_for(SomeEngine, 'engine_connect')\ndef receive_engine_connect(conn):\n    \"listen for the 'engine_connect' event\"\n\n    # ... (event handling logic) ...\n\n# DEPRECATED calling style (pre-2.0, will be removed in a future release)\n@event.listens_for(SomeEngine, 'engine_connect')\ndef receive_engine_connect(conn, branch):\n    \"listen for the 'engine_connect' event\"\n\n    # ... (event handling logic) ...\n```", "```py\nmethod engine_disposed(engine: Engine) \u2192 None\n```", "```py\nfrom sqlalchemy import event\n\n@event.listens_for(SomeEngine, 'engine_disposed')\ndef receive_engine_disposed(engine):\n    \"listen for the 'engine_disposed' event\"\n\n    # ... (event handling logic) ...\n```", "```py\nmethod prepare_twophase(conn: Connection, xid: Any) \u2192 None\n```", "```py\nfrom sqlalchemy import event\n\n@event.listens_for(SomeEngine, 'prepare_twophase')\ndef receive_prepare_twophase(conn, xid):\n    \"listen for the 'prepare_twophase' event\"\n\n    # ... (event handling logic) ...\n```", "```py\nmethod release_savepoint(conn: Connection, name: str, context: None) \u2192 None\n```", "```py\nfrom sqlalchemy import event\n\n@event.listens_for(SomeEngine, 'release_savepoint')\ndef receive_release_savepoint(conn, name, context):\n    \"listen for the 'release_savepoint' event\"\n\n    # ... (event handling logic) ...\n```", "```py\nmethod rollback(conn: Connection) \u2192 None\n```", "```py\nfrom sqlalchemy import event\n\n@event.listens_for(SomeEngine, 'rollback')\ndef receive_rollback(conn):\n    \"listen for the 'rollback' event\"\n\n    # ... (event handling logic) ...\n```", "```py\nmethod rollback_savepoint(conn: Connection, name: str, context: None) \u2192 None\n```", "```py\nfrom sqlalchemy import event\n\n@event.listens_for(SomeEngine, 'rollback_savepoint')\ndef receive_rollback_savepoint(conn, name, context):\n    \"listen for the 'rollback_savepoint' event\"\n\n    # ... (event handling logic) ...\n```", "```py\nmethod rollback_twophase(conn: Connection, xid: Any, is_prepared: bool) \u2192 None\n```", "```py\nfrom sqlalchemy import event\n\n@event.listens_for(SomeEngine, 'rollback_twophase')\ndef receive_rollback_twophase(conn, xid, is_prepared):\n    \"listen for the 'rollback_twophase' event\"\n\n    # ... (event handling logic) ...\n```", "```py\nmethod savepoint(conn: Connection, name: str) \u2192 None\n```", "```py\nfrom sqlalchemy import event\n\n@event.listens_for(SomeEngine, 'savepoint')\ndef receive_savepoint(conn, name):\n    \"listen for the 'savepoint' event\"\n\n    # ... (event handling logic) ...\n```", "```py\nmethod set_connection_execution_options(conn: Connection, opts: Dict[str, Any]) \u2192 None\n```", "```py\nfrom sqlalchemy import event\n\n@event.listens_for(SomeEngine, 'set_connection_execution_options')\ndef receive_set_connection_execution_options(conn, opts):\n    \"listen for the 'set_connection_execution_options' event\"\n\n    # ... (event handling logic) ...\n```", "```py\nmethod set_engine_execution_options(engine: Engine, opts: Dict[str, Any]) \u2192 None\n```", "```py\nfrom sqlalchemy import event\n\n@event.listens_for(SomeEngine, 'set_engine_execution_options')\ndef receive_set_engine_execution_options(engine, opts):\n    \"listen for the 'set_engine_execution_options' event\"\n\n    # ... (event handling logic) ...\n```", "```py\nclass sqlalchemy.events.DialectEvents\n```", "```py\nattribute dispatch: _Dispatch[_ET] = <sqlalchemy.event.base.DialectEventsDispatch object>\n```", "```py\nmethod do_connect(dialect: Dialect, conn_rec: ConnectionPoolEntry, cargs: Tuple[Any, ...], cparams: Dict[str, Any]) \u2192 DBAPIConnection | None\n```", "```py\nfrom sqlalchemy import event\n\n@event.listens_for(SomeEngine, 'do_connect')\ndef receive_do_connect(dialect, conn_rec, cargs, cparams):\n    \"listen for the 'do_connect' event\"\n\n    # ... (event handling logic) ...\n```", "```py\ne = create_engine(\"postgresql+psycopg2://user@host/dbname\")\n\n@event.listens_for(e, 'do_connect')\ndef receive_do_connect(dialect, conn_rec, cargs, cparams):\n    cparams[\"password\"] = \"some_password\"\n```", "```py\ne = create_engine(\"postgresql+psycopg2://user@host/dbname\")\n\n@event.listens_for(e, 'do_connect')\ndef receive_do_connect(dialect, conn_rec, cargs, cparams):\n    return psycopg2.connect(*cargs, **cparams)\n```", "```py\nmethod do_execute(cursor: DBAPICursor, statement: str, parameters: _DBAPISingleExecuteParams, context: ExecutionContext) \u2192 Literal[True] | None\n```", "```py\nfrom sqlalchemy import event\n\n@event.listens_for(SomeEngine, 'do_execute')\ndef receive_do_execute(cursor, statement, parameters, context):\n    \"listen for the 'do_execute' event\"\n\n    # ... (event handling logic) ...\n```", "```py\nmethod do_execute_no_params(cursor: DBAPICursor, statement: str, context: ExecutionContext) \u2192 Literal[True] | None\n```", "```py\nfrom sqlalchemy import event\n\n@event.listens_for(SomeEngine, 'do_execute_no_params')\ndef receive_do_execute_no_params(cursor, statement, context):\n    \"listen for the 'do_execute_no_params' event\"\n\n    # ... (event handling logic) ...\n```", "```py\nmethod do_executemany(cursor: DBAPICursor, statement: str, parameters: _DBAPIMultiExecuteParams, context: ExecutionContext) \u2192 Literal[True] | None\n```", "```py\nfrom sqlalchemy import event\n\n@event.listens_for(SomeEngine, 'do_executemany')\ndef receive_do_executemany(cursor, statement, parameters, context):\n    \"listen for the 'do_executemany' event\"\n\n    # ... (event handling logic) ...\n```", "```py\nmethod do_setinputsizes(inputsizes: Dict[BindParameter[Any], Any], cursor: DBAPICursor, statement: str, parameters: _DBAPIAnyExecuteParams, context: ExecutionContext) \u2192 None\n```", "```py\nfrom sqlalchemy import event\n\n@event.listens_for(SomeEngine, 'do_setinputsizes')\ndef receive_do_setinputsizes(inputsizes, cursor, statement, parameters, context):\n    \"listen for the 'do_setinputsizes' event\"\n\n    # ... (event handling logic) ...\n```", "```py\ncreate_engine(\"mssql+pyodbc://...\", use_setinputsizes=True)\n```", "```py\nmethod handle_error(exception_context: ExceptionContext) \u2192 BaseException | None\n```", "```py\nfrom sqlalchemy import event\n\n@event.listens_for(SomeEngine, 'handle_error')\ndef receive_handle_error(exception_context):\n    \"listen for the 'handle_error' event\"\n\n    # ... (event handling logic) ...\n```", "```py\n@event.listens_for(Engine, \"handle_error\")\ndef handle_exception(context):\n    if isinstance(context.original_exception,\n        psycopg2.OperationalError) and \\\n        \"failed\" in str(context.original_exception):\n        raise MySpecialException(\"failed operation\")\n```", "```py\n@event.listens_for(Engine, \"handle_error\", retval=True)\ndef handle_exception(context):\n    if context.chained_exception is not None and \\\n        \"special\" in context.chained_exception.message:\n        return MySpecialException(\"failed\",\n            cause=context.chained_exception)\n```", "```py\nclass sqlalchemy.events.DDLEvents\n```", "```py\nfrom sqlalchemy import create_engine\nfrom sqlalchemy import event\nfrom sqlalchemy import Table, Column, Metadata, Integer\n\nm = MetaData()\nsome_table = Table('some_table', m, Column('data', Integer))\n\n@event.listens_for(some_table, \"after_create\")\ndef after_create(target, connection, **kw):\n    connection.execute(text(\n        \"ALTER TABLE %s SET name=foo_%s\" % (target.name, target.name)\n    ))\n\nsome_engine = create_engine(\"postgresql://scott:tiger@host/test\")\n\n# will emit \"CREATE TABLE some_table\" as well as the above\n# \"ALTER TABLE\" statement afterwards\nm.create_all(some_engine)\n```", "```py\nfrom sqlalchemy import DDL\nevent.listen(\n    some_table,\n    \"after_create\",\n    DDL(\"ALTER TABLE %(table)s SET name=foo_%(table)s\")\n)\n```", "```py\nfrom sqlalchemy import DDL\n\nmetadata = MetaData()\nsome_table = Table(\"some_table\", metadata, Column(\"data\", Integer))\n\nevent.listen(\n    some_table,\n    \"after_create\",\n    DDL(\"ALTER TABLE %(table)s SET name=foo_%(table)s\"),\n    propagate=True\n)\n\nnew_metadata = MetaData()\nnew_table = some_table.to_metadata(new_metadata)\n```", "```py\nmethod after_create(target: SchemaEventTarget, connection: Connection, **kw: Any) \u2192 None\n```", "```py\nfrom sqlalchemy import event\n\n@event.listens_for(SomeSchemaClassOrObject, 'after_create')\ndef receive_after_create(target, connection, **kw):\n    \"listen for the 'after_create' event\"\n\n    # ... (event handling logic) ...\n```", "```py\nmethod after_drop(target: SchemaEventTarget, connection: Connection, **kw: Any) \u2192 None\n```", "```py\nfrom sqlalchemy import event\n\n@event.listens_for(SomeSchemaClassOrObject, 'after_drop')\ndef receive_after_drop(target, connection, **kw):\n    \"listen for the 'after_drop' event\"\n\n    # ... (event handling logic) ...\n```", "```py\nmethod after_parent_attach(target: SchemaEventTarget, parent: SchemaItem) \u2192 None\n```", "```py\nfrom sqlalchemy import event\n\n@event.listens_for(SomeSchemaClassOrObject, 'after_parent_attach')\ndef receive_after_parent_attach(target, parent):\n    \"listen for the 'after_parent_attach' event\"\n\n    # ... (event handling logic) ...\n```", "```py\nmethod before_create(target: SchemaEventTarget, connection: Connection, **kw: Any) \u2192 None\n```", "```py\nfrom sqlalchemy import event\n\n@event.listens_for(SomeSchemaClassOrObject, 'before_create')\ndef receive_before_create(target, connection, **kw):\n    \"listen for the 'before_create' event\"\n\n    # ... (event handling logic) ...\n```", "```py\nmethod before_drop(target: SchemaEventTarget, connection: Connection, **kw: Any) \u2192 None\n```", "```py\nfrom sqlalchemy import event\n\n@event.listens_for(SomeSchemaClassOrObject, 'before_drop')\ndef receive_before_drop(target, connection, **kw):\n    \"listen for the 'before_drop' event\"\n\n    # ... (event handling logic) ...\n```", "```py\nmethod before_parent_attach(target: SchemaEventTarget, parent: SchemaItem) \u2192 None\n```", "```py\nfrom sqlalchemy import event\n\n@event.listens_for(SomeSchemaClassOrObject, 'before_parent_attach')\ndef receive_before_parent_attach(target, parent):\n    \"listen for the 'before_parent_attach' event\"\n\n    # ... (event handling logic) ...\n```", "```py\nmethod column_reflect(inspector: Inspector, table: Table, column_info: ReflectedColumn) \u2192 None\n```", "```py\nfrom sqlalchemy import event\n\n@event.listens_for(SomeSchemaClassOrObject, 'column_reflect')\ndef receive_column_reflect(inspector, table, column_info):\n    \"listen for the 'column_reflect' event\"\n\n    # ... (event handling logic) ...\n```", "```py\nmetadata = MetaData()\n\n@event.listens_for(metadata, 'column_reflect')\ndef receive_column_reflect(inspector, table, column_info):\n    # receives for all Table objects that are reflected\n    # under this MetaData\n\n# will use the above event hook\nmy_table = Table(\"my_table\", metadata, autoload_with=some_engine)\n```", "```py\nfrom sqlalchemy import Table\n\n@event.listens_for(Table, 'column_reflect')\ndef receive_column_reflect(inspector, table, column_info):\n    # receives for all Table objects that are reflected\n```", "```py\nt1 = Table(\n    \"my_table\",\n    autoload_with=some_engine,\n    listeners=[\n        ('column_reflect', receive_column_reflect)\n    ]\n)\n```", "```py\nattribute dispatch: _Dispatch[_ET] = <sqlalchemy.event.base.DDLEventsDispatch object>\n```", "```py\nclass sqlalchemy.events.SchemaEventTarget\n```", "```py\nclass sqlalchemy.events.PoolEvents\n```", "```py\nfrom sqlalchemy import event\n\ndef my_on_checkout(dbapi_conn, connection_rec, connection_proxy):\n    \"handle an on checkout event\"\n\nevent.listen(Pool, 'checkout', my_on_checkout)\n```", "```py\nengine = create_engine(\"postgresql+psycopg2://scott:tiger@localhost/test\")\n\n# will associate with engine.pool\nevent.listen(engine, 'checkout', my_on_checkout)\n```", "```py\nmethod checkin(dbapi_connection: DBAPIConnection | None, connection_record: ConnectionPoolEntry) \u2192 None\n```", "```py\nfrom sqlalchemy import event\n\n@event.listens_for(SomeEngineOrPool, 'checkin')\ndef receive_checkin(dbapi_connection, connection_record):\n    \"listen for the 'checkin' event\"\n\n    # ... (event handling logic) ...\n```", "```py\nmethod checkout(dbapi_connection: DBAPIConnection, connection_record: ConnectionPoolEntry, connection_proxy: PoolProxiedConnection) \u2192 None\n```", "```py\nfrom sqlalchemy import event\n\n@event.listens_for(SomeEngineOrPool, 'checkout')\ndef receive_checkout(dbapi_connection, connection_record, connection_proxy):\n    \"listen for the 'checkout' event\"\n\n    # ... (event handling logic) ...\n```", "```py\nmethod close(dbapi_connection: DBAPIConnection, connection_record: ConnectionPoolEntry) \u2192 None\n```", "```py\nfrom sqlalchemy import event\n\n@event.listens_for(SomeEngineOrPool, 'close')\ndef receive_close(dbapi_connection, connection_record):\n    \"listen for the 'close' event\"\n\n    # ... (event handling logic) ...\n```", "```py\nmethod close_detached(dbapi_connection: DBAPIConnection) \u2192 None\n```", "```py\nfrom sqlalchemy import event\n\n@event.listens_for(SomeEngineOrPool, 'close_detached')\ndef receive_close_detached(dbapi_connection):\n    \"listen for the 'close_detached' event\"\n\n    # ... (event handling logic) ...\n```", "```py\nmethod connect(dbapi_connection: DBAPIConnection, connection_record: ConnectionPoolEntry) \u2192 None\n```", "```py\nfrom sqlalchemy import event\n\n@event.listens_for(SomeEngineOrPool, 'connect')\ndef receive_connect(dbapi_connection, connection_record):\n    \"listen for the 'connect' event\"\n\n    # ... (event handling logic) ...\n```", "```py\nmethod detach(dbapi_connection: DBAPIConnection, connection_record: ConnectionPoolEntry) \u2192 None\n```", "```py\nfrom sqlalchemy import event\n\n@event.listens_for(SomeEngineOrPool, 'detach')\ndef receive_detach(dbapi_connection, connection_record):\n    \"listen for the 'detach' event\"\n\n    # ... (event handling logic) ...\n```", "```py\nattribute dispatch: _Dispatch[_ET] = <sqlalchemy.event.base.PoolEventsDispatch object>\n```", "```py\nmethod first_connect(dbapi_connection: DBAPIConnection, connection_record: ConnectionPoolEntry) \u2192 None\n```", "```py\nfrom sqlalchemy import event\n\n@event.listens_for(SomeEngineOrPool, 'first_connect')\ndef receive_first_connect(dbapi_connection, connection_record):\n    \"listen for the 'first_connect' event\"\n\n    # ... (event handling logic) ...\n```", "```py\nmethod invalidate(dbapi_connection: DBAPIConnection, connection_record: ConnectionPoolEntry, exception: BaseException | None) \u2192 None\n```", "```py\nfrom sqlalchemy import event\n\n@event.listens_for(SomeEngineOrPool, 'invalidate')\ndef receive_invalidate(dbapi_connection, connection_record, exception):\n    \"listen for the 'invalidate' event\"\n\n    # ... (event handling logic) ...\n```", "```py\nmethod reset(dbapi_connection: DBAPIConnection, connection_record: ConnectionPoolEntry, reset_state: PoolResetState) \u2192 None\n```", "```py\nfrom sqlalchemy import event\n\n@event.listens_for(SomeEngineOrPool, 'reset')\ndef receive_reset(dbapi_connection, connection_record, reset_state):\n    \"listen for the 'reset' event\"\n\n    # ... (event handling logic) ...\n\n# DEPRECATED calling style (pre-2.0, will be removed in a future release)\n@event.listens_for(SomeEngineOrPool, 'reset')\ndef receive_reset(dbapi_connection, connection_record):\n    \"listen for the 'reset' event\"\n\n    # ... (event handling logic) ...\n```", "```py\nmethod soft_invalidate(dbapi_connection: DBAPIConnection, connection_record: ConnectionPoolEntry, exception: BaseException | None) \u2192 None\n```", "```py\nfrom sqlalchemy import event\n\n@event.listens_for(SomeEngineOrPool, 'soft_invalidate')\ndef receive_soft_invalidate(dbapi_connection, connection_record, exception):\n    \"listen for the 'soft_invalidate' event\"\n\n    # ... (event handling logic) ...\n```", "```py\nclass sqlalchemy.events.PoolResetState\n```", "```py\nattribute asyncio_safe: bool\n```", "```py\nattribute terminate_only: bool\n```", "```py\nattribute transaction_was_reset: bool\n```", "```py\nclass sqlalchemy.events.ConnectionEvents\n```", "```py\nfrom sqlalchemy import event, create_engine\n\ndef before_cursor_execute(conn, cursor, statement, parameters, context,\n                                                executemany):\n    log.info(\"Received statement: %s\", statement)\n\nengine = create_engine('postgresql+psycopg2://scott:tiger@localhost/test')\nevent.listen(engine, \"before_cursor_execute\", before_cursor_execute)\n```", "```py\nwith engine.begin() as conn:\n    @event.listens_for(conn, 'before_cursor_execute')\n    def before_cursor_execute(conn, cursor, statement, parameters,\n                                    context, executemany):\n        log.info(\"Received statement: %s\", statement)\n```", "```py\nfrom sqlalchemy.engine import Engine\nfrom sqlalchemy import event\n\n@event.listens_for(Engine, \"before_cursor_execute\", retval=True)\ndef comment_sql_calls(conn, cursor, statement, parameters,\n                                    context, executemany):\n    statement = statement + \" -- some comment\"\n    return statement, parameters\n```", "```py\nmethod after_cursor_execute(conn: Connection, cursor: DBAPICursor, statement: str, parameters: _DBAPIAnyExecuteParams, context: ExecutionContext | None, executemany: bool) \u2192 None\n```", "```py\nfrom sqlalchemy import event\n\n@event.listens_for(SomeEngine, 'after_cursor_execute')\ndef receive_after_cursor_execute(conn, cursor, statement, parameters, context, executemany):\n    \"listen for the 'after_cursor_execute' event\"\n\n    # ... (event handling logic) ...\n```", "```py\nmethod after_execute(conn: Connection, clauseelement: Executable, multiparams: _CoreMultiExecuteParams, params: _CoreSingleExecuteParams, execution_options: _ExecuteOptions, result: Result[Any]) \u2192 None\n```", "```py\nfrom sqlalchemy import event\n\n@event.listens_for(SomeEngine, 'after_execute')\ndef receive_after_execute(conn, clauseelement, multiparams, params, execution_options, result):\n    \"listen for the 'after_execute' event\"\n\n    # ... (event handling logic) ...\n\n# DEPRECATED calling style (pre-1.4, will be removed in a future release)\n@event.listens_for(SomeEngine, 'after_execute')\ndef receive_after_execute(conn, clauseelement, multiparams, params, result):\n    \"listen for the 'after_execute' event\"\n\n    # ... (event handling logic) ...\n```", "```py\nmethod before_cursor_execute(conn: Connection, cursor: DBAPICursor, statement: str, parameters: _DBAPIAnyExecuteParams, context: ExecutionContext | None, executemany: bool) \u2192 Tuple[str, _DBAPIAnyExecuteParams] | None\n```", "```py\nfrom sqlalchemy import event\n\n@event.listens_for(SomeEngine, 'before_cursor_execute')\ndef receive_before_cursor_execute(conn, cursor, statement, parameters, context, executemany):\n    \"listen for the 'before_cursor_execute' event\"\n\n    # ... (event handling logic) ...\n```", "```py\n@event.listens_for(Engine, \"before_cursor_execute\", retval=True)\ndef before_cursor_execute(conn, cursor, statement,\n                parameters, context, executemany):\n    # do something with statement, parameters\n    return statement, parameters\n```", "```py\nmethod before_execute(conn: Connection, clauseelement: Executable, multiparams: _CoreMultiExecuteParams, params: _CoreSingleExecuteParams, execution_options: _ExecuteOptions) \u2192 Tuple[Executable, _CoreMultiExecuteParams, _CoreSingleExecuteParams] | None\n```", "```py\nfrom sqlalchemy import event\n\n@event.listens_for(SomeEngine, 'before_execute')\ndef receive_before_execute(conn, clauseelement, multiparams, params, execution_options):\n    \"listen for the 'before_execute' event\"\n\n    # ... (event handling logic) ...\n\n# DEPRECATED calling style (pre-1.4, will be removed in a future release)\n@event.listens_for(SomeEngine, 'before_execute')\ndef receive_before_execute(conn, clauseelement, multiparams, params):\n    \"listen for the 'before_execute' event\"\n\n    # ... (event handling logic) ...\n```", "```py\n@event.listens_for(Engine, \"before_execute\", retval=True)\ndef before_execute(conn, clauseelement, multiparams, params):\n    # do something with clauseelement, multiparams, params\n    return clauseelement, multiparams, params\n```", "```py\nmethod begin(conn: Connection) \u2192 None\n```", "```py\nfrom sqlalchemy import event\n\n@event.listens_for(SomeEngine, 'begin')\ndef receive_begin(conn):\n    \"listen for the 'begin' event\"\n\n    # ... (event handling logic) ...\n```", "```py\nmethod begin_twophase(conn: Connection, xid: Any) \u2192 None\n```", "```py\nfrom sqlalchemy import event\n\n@event.listens_for(SomeEngine, 'begin_twophase')\ndef receive_begin_twophase(conn, xid):\n    \"listen for the 'begin_twophase' event\"\n\n    # ... (event handling logic) ...\n```", "```py\nmethod commit(conn: Connection) \u2192 None\n```", "```py\nfrom sqlalchemy import event\n\n@event.listens_for(SomeEngine, 'commit')\ndef receive_commit(conn):\n    \"listen for the 'commit' event\"\n\n    # ... (event handling logic) ...\n```", "```py\nmethod commit_twophase(conn: Connection, xid: Any, is_prepared: bool) \u2192 None\n```", "```py\nfrom sqlalchemy import event\n\n@event.listens_for(SomeEngine, 'commit_twophase')\ndef receive_commit_twophase(conn, xid, is_prepared):\n    \"listen for the 'commit_twophase' event\"\n\n    # ... (event handling logic) ...\n```", "```py\nattribute dispatch: _Dispatch[_ET] = <sqlalchemy.event.base.ConnectionEventsDispatch object>\n```", "```py\nmethod engine_connect(conn: Connection) \u2192 None\n```", "```py\nfrom sqlalchemy import event\n\n@event.listens_for(SomeEngine, 'engine_connect')\ndef receive_engine_connect(conn):\n    \"listen for the 'engine_connect' event\"\n\n    # ... (event handling logic) ...\n\n# DEPRECATED calling style (pre-2.0, will be removed in a future release)\n@event.listens_for(SomeEngine, 'engine_connect')\ndef receive_engine_connect(conn, branch):\n    \"listen for the 'engine_connect' event\"\n\n    # ... (event handling logic) ...\n```", "```py\nmethod engine_disposed(engine: Engine) \u2192 None\n```", "```py\nfrom sqlalchemy import event\n\n@event.listens_for(SomeEngine, 'engine_disposed')\ndef receive_engine_disposed(engine):\n    \"listen for the 'engine_disposed' event\"\n\n    # ... (event handling logic) ...\n```", "```py\nmethod prepare_twophase(conn: Connection, xid: Any) \u2192 None\n```", "```py\nfrom sqlalchemy import event\n\n@event.listens_for(SomeEngine, 'prepare_twophase')\ndef receive_prepare_twophase(conn, xid):\n    \"listen for the 'prepare_twophase' event\"\n\n    # ... (event handling logic) ...\n```", "```py\nmethod release_savepoint(conn: Connection, name: str, context: None) \u2192 None\n```", "```py\nfrom sqlalchemy import event\n\n@event.listens_for(SomeEngine, 'release_savepoint')\ndef receive_release_savepoint(conn, name, context):\n    \"listen for the 'release_savepoint' event\"\n\n    # ... (event handling logic) ...\n```", "```py\nmethod rollback(conn: Connection) \u2192 None\n```", "```py\nfrom sqlalchemy import event\n\n@event.listens_for(SomeEngine, 'rollback')\ndef receive_rollback(conn):\n    \"listen for the 'rollback' event\"\n\n    # ... (event handling logic) ...\n```", "```py\nmethod rollback_savepoint(conn: Connection, name: str, context: None) \u2192 None\n```", "```py\nfrom sqlalchemy import event\n\n@event.listens_for(SomeEngine, 'rollback_savepoint')\ndef receive_rollback_savepoint(conn, name, context):\n    \"listen for the 'rollback_savepoint' event\"\n\n    # ... (event handling logic) ...\n```", "```py\nmethod rollback_twophase(conn: Connection, xid: Any, is_prepared: bool) \u2192 None\n```", "```py\nfrom sqlalchemy import event\n\n@event.listens_for(SomeEngine, 'rollback_twophase')\ndef receive_rollback_twophase(conn, xid, is_prepared):\n    \"listen for the 'rollback_twophase' event\"\n\n    # ... (event handling logic) ...\n```", "```py\nmethod savepoint(conn: Connection, name: str) \u2192 None\n```", "```py\nfrom sqlalchemy import event\n\n@event.listens_for(SomeEngine, 'savepoint')\ndef receive_savepoint(conn, name):\n    \"listen for the 'savepoint' event\"\n\n    # ... (event handling logic) ...\n```", "```py\nmethod set_connection_execution_options(conn: Connection, opts: Dict[str, Any]) \u2192 None\n```", "```py\nfrom sqlalchemy import event\n\n@event.listens_for(SomeEngine, 'set_connection_execution_options')\ndef receive_set_connection_execution_options(conn, opts):\n    \"listen for the 'set_connection_execution_options' event\"\n\n    # ... (event handling logic) ...\n```", "```py\nmethod set_engine_execution_options(engine: Engine, opts: Dict[str, Any]) \u2192 None\n```", "```py\nfrom sqlalchemy import event\n\n@event.listens_for(SomeEngine, 'set_engine_execution_options')\ndef receive_set_engine_execution_options(engine, opts):\n    \"listen for the 'set_engine_execution_options' event\"\n\n    # ... (event handling logic) ...\n```", "```py\nclass sqlalchemy.events.DialectEvents\n```", "```py\nattribute dispatch: _Dispatch[_ET] = <sqlalchemy.event.base.DialectEventsDispatch object>\n```", "```py\nmethod do_connect(dialect: Dialect, conn_rec: ConnectionPoolEntry, cargs: Tuple[Any, ...], cparams: Dict[str, Any]) \u2192 DBAPIConnection | None\n```", "```py\nfrom sqlalchemy import event\n\n@event.listens_for(SomeEngine, 'do_connect')\ndef receive_do_connect(dialect, conn_rec, cargs, cparams):\n    \"listen for the 'do_connect' event\"\n\n    # ... (event handling logic) ...\n```", "```py\ne = create_engine(\"postgresql+psycopg2://user@host/dbname\")\n\n@event.listens_for(e, 'do_connect')\ndef receive_do_connect(dialect, conn_rec, cargs, cparams):\n    cparams[\"password\"] = \"some_password\"\n```", "```py\ne = create_engine(\"postgresql+psycopg2://user@host/dbname\")\n\n@event.listens_for(e, 'do_connect')\ndef receive_do_connect(dialect, conn_rec, cargs, cparams):\n    return psycopg2.connect(*cargs, **cparams)\n```", "```py\nmethod do_execute(cursor: DBAPICursor, statement: str, parameters: _DBAPISingleExecuteParams, context: ExecutionContext) \u2192 Literal[True] | None\n```", "```py\nfrom sqlalchemy import event\n\n@event.listens_for(SomeEngine, 'do_execute')\ndef receive_do_execute(cursor, statement, parameters, context):\n    \"listen for the 'do_execute' event\"\n\n    # ... (event handling logic) ...\n```", "```py\nmethod do_execute_no_params(cursor: DBAPICursor, statement: str, context: ExecutionContext) \u2192 Literal[True] | None\n```", "```py\nfrom sqlalchemy import event\n\n@event.listens_for(SomeEngine, 'do_execute_no_params')\ndef receive_do_execute_no_params(cursor, statement, context):\n    \"listen for the 'do_execute_no_params' event\"\n\n    # ... (event handling logic) ...\n```", "```py\nmethod do_executemany(cursor: DBAPICursor, statement: str, parameters: _DBAPIMultiExecuteParams, context: ExecutionContext) \u2192 Literal[True] | None\n```", "```py\nfrom sqlalchemy import event\n\n@event.listens_for(SomeEngine, 'do_executemany')\ndef receive_do_executemany(cursor, statement, parameters, context):\n    \"listen for the 'do_executemany' event\"\n\n    # ... (event handling logic) ...\n```", "```py\nmethod do_setinputsizes(inputsizes: Dict[BindParameter[Any], Any], cursor: DBAPICursor, statement: str, parameters: _DBAPIAnyExecuteParams, context: ExecutionContext) \u2192 None\n```", "```py\nfrom sqlalchemy import event\n\n@event.listens_for(SomeEngine, 'do_setinputsizes')\ndef receive_do_setinputsizes(inputsizes, cursor, statement, parameters, context):\n    \"listen for the 'do_setinputsizes' event\"\n\n    # ... (event handling logic) ...\n```", "```py\ncreate_engine(\"mssql+pyodbc://...\", use_setinputsizes=True)\n```", "```py\nmethod handle_error(exception_context: ExceptionContext) \u2192 BaseException | None\n```", "```py\nfrom sqlalchemy import event\n\n@event.listens_for(SomeEngine, 'handle_error')\ndef receive_handle_error(exception_context):\n    \"listen for the 'handle_error' event\"\n\n    # ... (event handling logic) ...\n```", "```py\n@event.listens_for(Engine, \"handle_error\")\ndef handle_exception(context):\n    if isinstance(context.original_exception,\n        psycopg2.OperationalError) and \\\n        \"failed\" in str(context.original_exception):\n        raise MySpecialException(\"failed operation\")\n```", "```py\n@event.listens_for(Engine, \"handle_error\", retval=True)\ndef handle_exception(context):\n    if context.chained_exception is not None and \\\n        \"special\" in context.chained_exception.message:\n        return MySpecialException(\"failed\",\n            cause=context.chained_exception)\n```", "```py\nclass sqlalchemy.events.DDLEvents\n```", "```py\nfrom sqlalchemy import create_engine\nfrom sqlalchemy import event\nfrom sqlalchemy import Table, Column, Metadata, Integer\n\nm = MetaData()\nsome_table = Table('some_table', m, Column('data', Integer))\n\n@event.listens_for(some_table, \"after_create\")\ndef after_create(target, connection, **kw):\n    connection.execute(text(\n        \"ALTER TABLE %s SET name=foo_%s\" % (target.name, target.name)\n    ))\n\nsome_engine = create_engine(\"postgresql://scott:tiger@host/test\")\n\n# will emit \"CREATE TABLE some_table\" as well as the above\n# \"ALTER TABLE\" statement afterwards\nm.create_all(some_engine)\n```", "```py\nfrom sqlalchemy import DDL\nevent.listen(\n    some_table,\n    \"after_create\",\n    DDL(\"ALTER TABLE %(table)s SET name=foo_%(table)s\")\n)\n```", "```py\nfrom sqlalchemy import DDL\n\nmetadata = MetaData()\nsome_table = Table(\"some_table\", metadata, Column(\"data\", Integer))\n\nevent.listen(\n    some_table,\n    \"after_create\",\n    DDL(\"ALTER TABLE %(table)s SET name=foo_%(table)s\"),\n    propagate=True\n)\n\nnew_metadata = MetaData()\nnew_table = some_table.to_metadata(new_metadata)\n```", "```py\nmethod after_create(target: SchemaEventTarget, connection: Connection, **kw: Any) \u2192 None\n```", "```py\nfrom sqlalchemy import event\n\n@event.listens_for(SomeSchemaClassOrObject, 'after_create')\ndef receive_after_create(target, connection, **kw):\n    \"listen for the 'after_create' event\"\n\n    # ... (event handling logic) ...\n```", "```py\nmethod after_drop(target: SchemaEventTarget, connection: Connection, **kw: Any) \u2192 None\n```", "```py\nfrom sqlalchemy import event\n\n@event.listens_for(SomeSchemaClassOrObject, 'after_drop')\ndef receive_after_drop(target, connection, **kw):\n    \"listen for the 'after_drop' event\"\n\n    # ... (event handling logic) ...\n```", "```py\nmethod after_parent_attach(target: SchemaEventTarget, parent: SchemaItem) \u2192 None\n```", "```py\nfrom sqlalchemy import event\n\n@event.listens_for(SomeSchemaClassOrObject, 'after_parent_attach')\ndef receive_after_parent_attach(target, parent):\n    \"listen for the 'after_parent_attach' event\"\n\n    # ... (event handling logic) ...\n```", "```py\nmethod before_create(target: SchemaEventTarget, connection: Connection, **kw: Any) \u2192 None\n```", "```py\nfrom sqlalchemy import event\n\n@event.listens_for(SomeSchemaClassOrObject, 'before_create')\ndef receive_before_create(target, connection, **kw):\n    \"listen for the 'before_create' event\"\n\n    # ... (event handling logic) ...\n```", "```py\nmethod before_drop(target: SchemaEventTarget, connection: Connection, **kw: Any) \u2192 None\n```", "```py\nfrom sqlalchemy import event\n\n@event.listens_for(SomeSchemaClassOrObject, 'before_drop')\ndef receive_before_drop(target, connection, **kw):\n    \"listen for the 'before_drop' event\"\n\n    # ... (event handling logic) ...\n```", "```py\nmethod before_parent_attach(target: SchemaEventTarget, parent: SchemaItem) \u2192 None\n```", "```py\nfrom sqlalchemy import event\n\n@event.listens_for(SomeSchemaClassOrObject, 'before_parent_attach')\ndef receive_before_parent_attach(target, parent):\n    \"listen for the 'before_parent_attach' event\"\n\n    # ... (event handling logic) ...\n```", "```py\nmethod column_reflect(inspector: Inspector, table: Table, column_info: ReflectedColumn) \u2192 None\n```", "```py\nfrom sqlalchemy import event\n\n@event.listens_for(SomeSchemaClassOrObject, 'column_reflect')\ndef receive_column_reflect(inspector, table, column_info):\n    \"listen for the 'column_reflect' event\"\n\n    # ... (event handling logic) ...\n```", "```py\nmetadata = MetaData()\n\n@event.listens_for(metadata, 'column_reflect')\ndef receive_column_reflect(inspector, table, column_info):\n    # receives for all Table objects that are reflected\n    # under this MetaData\n\n# will use the above event hook\nmy_table = Table(\"my_table\", metadata, autoload_with=some_engine)\n```", "```py\nfrom sqlalchemy import Table\n\n@event.listens_for(Table, 'column_reflect')\ndef receive_column_reflect(inspector, table, column_info):\n    # receives for all Table objects that are reflected\n```", "```py\nt1 = Table(\n    \"my_table\",\n    autoload_with=some_engine,\n    listeners=[\n        ('column_reflect', receive_column_reflect)\n    ]\n)\n```", "```py\nattribute dispatch: _Dispatch[_ET] = <sqlalchemy.event.base.DDLEventsDispatch object>\n```", "```py\nclass sqlalchemy.events.SchemaEventTarget\n```"]