- en: Device Memory Profiling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[`jax.readthedocs.io/en/latest/device_memory_profiling.html`](https://jax.readthedocs.io/en/latest/device_memory_profiling.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'May 2023 update: we recommend using Tensorboard profiling for device memory
    analysis. After taking a profile, open the `memory_viewer` tab of the Tensorboard
    profiler for more detailed and understandable device memory usage.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The JAX Device Memory Profiler allows us to explore how and why JAX programs
    are using GPU or TPU memory. For example, it can be used to:'
  prefs: []
  type: TYPE_NORMAL
- en: Figure out which arrays and executables are in GPU memory at a given time, or
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Track down memory leaks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The JAX device memory profiler emits output that can be interpreted using pprof
    ([google/pprof](https://github.com/google/pprof)). Start by installing `pprof`,
    by following its [installation instructions](https://github.com/google/pprof#building-pprof).
    At the time of writing, installing `pprof` requires first installing [Go](https://golang.org/)
    of version 1.16+, [Graphviz](http://www.graphviz.org/), and then running
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: which installs `pprof` as `$GOPATH/bin/pprof`, where `GOPATH` defaults to `~/go`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The version of `pprof` from [google/pprof](https://github.com/google/pprof)
    is not the same as the older tool of the same name distributed as part of the
    `gperftools` package. The `gperftools` version of `pprof` will not work with JAX.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding how a JAX program is using GPU or TPU memory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A common use of the device memory profiler is to figure out why a JAX program
    is using a large amount of GPU or TPU memory, for example if trying to debug an
    out-of-memory problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'To capture a device memory profile to disk, use `jax.profiler.save_device_memory_profile()`.
    For example, consider the following Python program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: If we first run the program above and then execute
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '`pprof` opens a web browser containing the following visualization of the device
    memory profile in callgraph format:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Device memory profiling example](img/3866a83aa3ccf48282b5c1c8b894115a.png)'
  prefs: []
  type: TYPE_IMG
- en: The callgraph is a visualization of the Python stack at the point the allocation
    of each live buffer was made. For example, in this specific case, the visualization
    shows that `func2` and its callees were responsible for allocating 76.30MB, of
    which 38.15MB was allocated inside the call from `func1` to `func2`. For more
    information about how to interpret callgraph visualizations, see the [pprof documentation](https://github.com/google/pprof/blob/master/doc/README.md#interpreting-the-callgraph).
  prefs: []
  type: TYPE_NORMAL
- en: Functions compiled with `jax.jit()` are opaque to the device memory profiler.
    That is, any memory allocated inside a `jit`-compiled function will be attributed
    to the function as a whole.
  prefs: []
  type: TYPE_NORMAL
- en: In the example, the call to `block_until_ready()` is to ensure that `func2`
    completes before the device memory profile is collected. See Asynchronous dispatch
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging memory leaks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can also use the JAX device memory profiler to track down memory leaks by
    using `pprof` to visualize the change in memory usage between two device memory
    profiles taken at different times. For example, consider the following program
    which accumulates JAX arrays into a constantly-growing Python list.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'If we simply visualize the device memory profile at the end of execution (`memory9.prof`),
    it may not be obvious that each iteration of the loop in `anotherfunc` accumulates
    more device memory allocations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '![Device memory profile at end of execution](img/ff218217e3f7353d34fdece0bedc0800.png)'
  prefs: []
  type: TYPE_IMG
- en: The large but fixed allocation inside `afunction` dominates the profile but
    does not grow over time.
  prefs: []
  type: TYPE_NORMAL
- en: 'By using `pprof`’s [`--diff_base` feature](https://github.com/google/pprof/blob/master/doc/README.md#comparing-profiles)
    to visualize the change in memory usage across loop iterations, we can identify
    why the memory usage of the program increases over time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '![Device memory profile at end of execution](img/9d4eb42f4ab4cb41e8c6abfa6858c107.png)'
  prefs: []
  type: TYPE_IMG
- en: The visualization shows that the memory growth can be attributed to the call
    to `normal` inside `anotherfunc`.
  prefs: []
  type: TYPE_NORMAL
