- en: jax.experimental.jet module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[`jax.readthedocs.io/en/latest/jax.experimental.jet.html`](https://jax.readthedocs.io/en/latest/jax.experimental.jet.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Jet is an experimental module for higher-order automatic differentiation that
    does not rely on repeated first-order automatic differentiation.
  prefs: []
  type: TYPE_NORMAL
- en: How? Through the propagation of truncated Taylor polynomials. Consider a function
    \(f = g \circ h\), some point \(x\) and some offset \(v\). First-order automatic
    differentiation (such as `jax.jvp()`) computes the pair \((f(x), \partial f(x)[v])\)
    from the pair \((h(x), \partial h(x)[v])\).
  prefs: []
  type: TYPE_NORMAL
- en: '`jet()` implements the higher-order analogue: Given the tuple'
  prefs: []
  type: TYPE_NORMAL
- en: \[(h_0, ... h_K) := (h(x), \partial h(x)[v], \partial² h(x)[v, v], ..., \partial^K
    h(x)[v,...,v]),\]
  prefs: []
  type: TYPE_NORMAL
- en: which represents a \(K\)-th order Taylor approximation of \(h\) at \(x\), `jet()`
    returns a \(K\)-th order Taylor approximation of \(f\) at \(x\),
  prefs: []
  type: TYPE_NORMAL
- en: \[(f_0, ..., f_K) := (f(x), \partial f(x)[v], \partial² f(x)[v, v], ..., \partial^K
    f(x)[v,...,v]).\]
  prefs: []
  type: TYPE_NORMAL
- en: More specifically, `jet()` computes
  prefs: []
  type: TYPE_NORMAL
- en: \[f_0, (f_1, . . . , f_K) = \texttt{jet} (f, h_0, (h_1, . . . , h_K))\]
  prefs: []
  type: TYPE_NORMAL
- en: and can thus be used for high-order automatic differentiation of \(f\). Details
    are explained in [these notes](https://github.com/google/jax/files/6717197/jet.pdf).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Help improve `jet()` by contributing [outstanding primitive rules](https://github.com/google/jax/issues/2431).
  prefs: []
  type: TYPE_NORMAL
- en: API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Taylor-mode higher-order automatic differentiation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**fun** – Function to be differentiated. Its arguments should be arrays, scalars,
    or standard Python containers of arrays or scalars. It should return an array,
    scalar, or standard Python container of arrays or scalars.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**primals** – The primal values at which the Taylor approximation of `fun`
    should be evaluated. Should be either a tuple or a list of arguments, and its
    length should be equal to the number of positional parameters of `fun`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**series** – Higher order Taylor-series-coefficients. Together, primals and
    series make up a truncated Taylor polynomial. Should be either a tuple or a list
    of tuples or lists, and its length dictates the degree of the truncated Taylor
    polynomial.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: A `(primals_out, series_out)` pair, where `primals_out` is `fun(*primals)`,
    and together, `primals_out` and `series_out` are a truncated Taylor polynomial
    of \(f(h(\cdot))\). The `primals_out` value has the same Python tree structure
    as `primals`, and the `series_out` value the same Python tree structure as `series`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Consider the function \(h(z) = z³\), \(x = 0.5\), and the first few Taylor coefficients
    \(h_0=x³\), \(h_1=3x²\), and \(h_2=6x\). Let \(f(y) = \sin(y)\).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '`jet()` returns the Taylor coefficients of \(f(h(z)) = \sin(z³)\) according
    to Faà di Bruno’s formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
