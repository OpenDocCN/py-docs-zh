- en: What’s New in SQLAlchemy 1.4?
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SQLAlchemy 1.4有什么新特性？
- en: 原文：[https://docs.sqlalchemy.org/en/20/changelog/migration_14.html](https://docs.sqlalchemy.org/en/20/changelog/migration_14.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://docs.sqlalchemy.org/en/20/changelog/migration_14.html](https://docs.sqlalchemy.org/en/20/changelog/migration_14.html)
- en: About this Document
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 关于本文档
- en: This document describes changes between SQLAlchemy version 1.3 and SQLAlchemy
    version 1.4.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本文描述了SQLAlchemy版本1.3和SQLAlchemy版本1.4之间的变化。
- en: Version 1.4 is taking on a different focus than other SQLAlchemy releases in
    that it is in many ways attempting to serve as a potential migration point for
    a more dramatic series of API changes currently planned for release 2.0 of SQLAlchemy.
    The focus of SQLAlchemy 2.0 is a modernized and slimmed down API that removes
    lots of usage patterns that have long been discouraged, as well as mainstreams
    the best ideas in SQLAlchemy as first class API features, with the goal being
    that there is much less ambiguity in how the API is to be used, as well as that
    a series of implicit behaviors and rarely-used API flags that complicate the internals
    and hinder performance will be removed.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 版本1.4的重点与其他SQLAlchemy版本不同，它在很多方面试图作为潜在的迁移点，用于当前计划发布的SQLAlchemy 2.0中更为重大的一系列API更改。SQLAlchemy
    2.0的重点是现代化和精简的API，删除了长期以来被不鼓励的许多使用模式，并将SQLAlchemy中的最佳思想作为一流API功能，目标是API的使用方式更加明确，以及删除一系列隐式行为和很少使用的API标志，这些都会使内部复杂化并阻碍性能。
- en: For the current status of SQLAlchemy 2.0, see [SQLAlchemy 2.0 - Major Migration
    Guide](migration_20.html).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 有关SQLAlchemy 2.0的当前状态，请参阅[SQLAlchemy 2.0 - 主要迁移指南](migration_20.html)。
- en: Major API changes and features - General
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主要API更改和功能 - 通用
- en: '### Python 3.6 is the minimum Python 3 version; Python 2.7 still supported'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '### Python 3.6是最低要求的Python 3版本；仍支持Python 2.7'
- en: 'As Python 3.5 reached EOL in September of 2020, SQLAlchemy 1.4 now places version
    3.6 as the minimum Python 3 version. Python 2.7 is still supported, however the
    SQLAlchemy 1.4 series will be the last series to support Python 2.  ### ORM Query
    is internally unified with select, update, delete; 2.0 style execution available'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Python 3.5在2020年9月已达到生命周期终点，因此SQLAlchemy 1.4现在将版本3.6作为最低要求的Python 3版本。Python
    2.7仍然受支持，但是SQLAlchemy 1.4系列将是最后一个支持Python 2的系列。### ORM查询在内部与select、update、delete统一；2.0风格的执行可用
- en: The biggest conceptual change to SQLAlchemy for version 2.0 and essentially
    in 1.4 as well is that the great separation between the [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") construct in Core and the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object in the ORM has been removed, as well as between
    the [`Query.update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.update
    "sqlalchemy.orm.Query.update") and [`Query.delete()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.delete
    "sqlalchemy.orm.Query.delete") methods in how they relate to [`Update`](../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update") and [`Delete`](../core/dml.html#sqlalchemy.sql.expression.Delete
    "sqlalchemy.sql.expression.Delete").
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 对于SQLAlchemy 2.0和本质上也是1.4版本的最大概念变化是，在Core中的[`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select")构造和ORM中的[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")对象之间的巨大分离已被移除，以及在它们与[`Update`](../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update")和[`Delete`](../core/dml.html#sqlalchemy.sql.expression.Delete
    "sqlalchemy.sql.expression.Delete")之间的[`Query.update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.update
    "sqlalchemy.orm.Query.update")和[`Query.delete()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.delete
    "sqlalchemy.orm.Query.delete")方法之间的分离。
- en: With regards to [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") and [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query"), these two objects have for many versions had similar,
    largely overlapping APIs and even some ability to change between one and the other,
    while remaining very different in their usage patterns and behaviors. The historical
    background for this was that the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object was introduced to overcome shortcomings in the
    [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select "sqlalchemy.sql.expression.Select")
    object which used to be at the core of how ORM objects were queried, except that
    they had to be queried in terms of [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") metadata only. However [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") had only a simplistic interface for loading objects, and
    only over the course of many major releases did it eventually gain most of the
    flexibility of the [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") object, which then led to the ongoing awkwardness
    that these two objects became highly similar yet still largely incompatible with
    each other.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 关于[`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select "sqlalchemy.sql.expression.Select")和[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")，这两个对象在许多版本中具有类似的、大部分重叠的API，甚至有一些能够在两者之间切换的能力，但在使用模式和行为上仍然有很大的不同。这一历史背景是，[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")对象是为了克服[`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select")对象的缺点而引入的，后者曾经是ORM对象查询的核心，只是它们必须以[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")元数据的形式进行查询。然而，[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")只有一个简单的接口来加载对象，只有在许多主要版本的发布过程中，它最终才获得了大部分[`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select")对象的灵活性，这导致这两个对象变得非常相似，但仍然在很大程度上不兼容。
- en: 'In version 1.4, all Core and ORM SELECT statements are rendered from a [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") object directly; when the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object is used, at statement invocation time it copies
    its state to a [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") which is then invoked internally using [2.0
    style](../glossary.html#term-2.0-style) execution. Going forward, the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object will become legacy only, and applications will
    be encouraged to move to [2.0 style](../glossary.html#term-2.0-style) execution
    which allows Core constructs to be used freely against ORM entities:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在版本1.4中，所有核心和ORM SELECT语句都直接从[`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select")对象呈现；当使用[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")对象时，在语句调用时，它会将其状态复制到一个[`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select")对象中，然后使用[2.0风格](../glossary.html#term-2.0-style)执行。未来，[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")对象将仅成为传统，应用程序将被鼓励转向[2.0风格](../glossary.html#term-2.0-style)执行，允许核心构造自由地针对ORM实体使用：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Things to note about the above example:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 以上示例的注意事项：
- en: The [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    and [`sessionmaker`](../orm/session_api.html#sqlalchemy.orm.sessionmaker "sqlalchemy.orm.sessionmaker")
    objects now feature full context manager (i.e. the `with:` statement) capability;
    see the revised documentation at [Opening and Closing a Session](../orm/session_basics.html#session-getting)
    for an example.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")和[`sessionmaker`](../orm/session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker")对象现在具有完整的上下文管理器（即`with:`语句）功能；请参阅[打开和关闭会话](../orm/session_basics.html#session-getting)的修订文档以获取示例。'
- en: Within the 1.4 series, all [2.0 style](../glossary.html#term-2.0-style) ORM
    invocation uses a [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    that includes the [`Session.future`](../orm/session_api.html#sqlalchemy.orm.Session.params.future
    "sqlalchemy.orm.Session") flag set to `True`; this flag indicates the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") should have 2.0-style behaviors, which include that
    ORM queries can be invoked from [`execute`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") as well as some changes in transactional features.
    In version 2.0 this flag will always be `True`.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在1.4系列中，所有[2.0风格](../glossary.html#term-2.0-style)的ORM调用都使用一个包含[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")的对象，其中包括设置为`True`的[`Session.future`](../orm/session_api.html#sqlalchemy.orm.Session.params.future
    "sqlalchemy.orm.Session")标志；这个标志表示[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")应该具有2.0风格的行为，其中包括ORM查询可以从[`execute`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute")中调用，以及一些事务特性的变化。在2.0版本中，这个标志将始终为`True`。
- en: The [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select")
    construct no longer needs brackets around the columns clause; see [select(), case()
    now accept positional expressions](#change-5284) for background on this improvement.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`select()`](../core/selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select")构造不再需要在列子句周围加括号；有关此改进的背景，请参阅[select(),
    case()现在接受位置表达式](#change-5284)。'
- en: The [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select")
    / [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select "sqlalchemy.sql.expression.Select")
    object has a [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") method that acts like that of the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") and even accommodates an ORM relationship attribute (without
    breaking the separation between Core and ORM!) - see [select().join() and outerjoin()
    add JOIN criteria to the current query, rather than creating a subquery](#change-select-join)
    for background on this.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`select()`](../core/selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select")
    / [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select "sqlalchemy.sql.expression.Select")对象具有一个[`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join")方法，其行为类似于[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")的方法，甚至可以容纳ORM关系属性（而不会破坏Core和ORM之间的分离！）- 有关此内容，请参阅[select().join()和outerjoin()向当前查询添加JOIN条件，而不是创建子查询](#change-select-join)。'
- en: Statements that work with ORM entities and are expected to return ORM results
    are invoked using [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute"). See [Querying](../orm/session_basics.html#session-querying-20)
    for a primer. See also the following note at [ORM Session.execute() uses “future”
    style Result sets in all cases](#change-session-execute-result).
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与ORM实体一起工作并预计返回ORM结果的语句是使用[`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute")来调用的。查看[查询](../orm/session_basics.html#session-querying-20)以获取入门指南。另请参阅[ORM
    Session.execute()在所有情况下使用“future”风格结果集](#change-session-execute-result)中的以下注意事项。
- en: a [`Result`](../core/connections.html#sqlalchemy.engine.Result "sqlalchemy.engine.Result")
    object is returned, rather than a plain list, which itself is a much more sophisticated
    version of the previous `ResultProxy` object; this object is now used both for
    Core and ORM results. See [New Result object](#change-result-14-core), [RowProxy
    is no longer a “proxy”; is now called Row and behaves like an enhanced named tuple](#change-4710-core),
    and [The “KeyedTuple” object returned by Query is replaced by Row](#change-4710-orm)
    for information on this.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回一个[`Result`](../core/connections.html#sqlalchemy.engine.Result "sqlalchemy.engine.Result")对象，而不是一个普通列表，这本身是以前`ResultProxy`对象的一个更复杂的版本；这个对象现在用于Core和ORM结果。有关此信息，请参阅[新的Result对象](#change-result-14-core)，[RowProxy不再是“代理”；现在称为Row，并且行为类似于增强的命名元组](#change-4710-core)，以及[Query返回的“KeyedTuple”对象被Row替换](#change-4710-orm)。
- en: Throughout SQLAlchemy’s documentation, there will be many references to [1.x
    style](../glossary.html#term-1.x-style) and [2.0 style](../glossary.html#term-2.0-style)
    execution. This is to distinguish between the two querying styles and to attempt
    to forwards-document the new calling style going forward. In SQLAlchemy 2.0, while
    the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    object may remain as a legacy construct, it will no longer be featured in most
    documentation.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个 SQLAlchemy 的文档中，将会有许多关于 [1.x 风格](../glossary.html#term-1.x-style) 和 [2.0
    风格](../glossary.html#term-2.0-style) 执行的引用。这是为了区分这两种查询风格，并尝试在前进过程中向前文档化新的调用风格。在
    SQLAlchemy 2.0 中，虽然 [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") 对象可能仍然保留为遗留构造，但它将不再在大多数文档中显示。
- en: 'Similar adjustments have been made to “bulk updates and deletes” such that
    Core [`update()`](../core/dml.html#sqlalchemy.sql.expression.update "sqlalchemy.sql.expression.update")
    and [`delete()`](../core/dml.html#sqlalchemy.sql.expression.delete "sqlalchemy.sql.expression.delete")
    can be used for bulk operations. A bulk update like the following:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 类似的调整已经针对“批量更新和删除”进行了，以便 Core 的 [`update()`](../core/dml.html#sqlalchemy.sql.expression.update
    "sqlalchemy.sql.expression.update") 和 [`delete()`](../core/dml.html#sqlalchemy.sql.expression.delete
    "sqlalchemy.sql.expression.delete") 可用于批量操作。如下所示的批量更新：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'can now be achieved in [2.0 style](../glossary.html#term-2.0-style) (and indeed
    the above runs internally in this way) as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 可以以 [2.0 风格](../glossary.html#term-2.0-style)（事实上，上述代码在内部以此方式运行）实现如下：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note the use of the [`Executable.execution_options()`](../core/selectable.html#sqlalchemy.sql.expression.Executable.execution_options
    "sqlalchemy.sql.expression.Executable.execution_options") method to pass ORM-related
    options. The use of “execution options” is now much more prevalent within both
    Core and ORM, and many ORM-related methods from [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") are now implemented as execution options (see [`Query.execution_options()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.execution_options
    "sqlalchemy.orm.Query.execution_options") for some examples).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意使用 [`Executable.execution_options()`](../core/selectable.html#sqlalchemy.sql.expression.Executable.execution_options
    "sqlalchemy.sql.expression.Executable.execution_options") 方法传递 ORM 相关选项。现在“执行选项”的使用在
    Core 和 ORM 中更为普遍，并且许多来自 [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") 的 ORM 相关方法现在被实现为执行选项（请参阅 [`Query.execution_options()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.execution_options
    "sqlalchemy.orm.Query.execution_options") 查看一些示例）。
- en: See also
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[SQLAlchemy 2.0 - Major Migration Guide](migration_20.html)'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '[SQLAlchemy 2.0 - 主要迁移指南](migration_20.html)'
- en: '[#5159](https://www.sqlalchemy.org/trac/ticket/5159)  ### ORM `Session.execute()`
    uses “future” style `Result` sets in all cases'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '[#5159](https://www.sqlalchemy.org/trac/ticket/5159)  ### ORM `Session.execute()`
    在所有情况下都使用“future”风格的 `Result` 集'
- en: 'As noted in [RowProxy is no longer a “proxy”; is now called Row and behaves
    like an enhanced named tuple](#change-4710-core), the [`Result`](../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") and [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") objects now feature “named tuple” behavior, when used
    with an [`Engine`](../core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    that includes the [`create_engine.future`](../core/engines.html#sqlalchemy.create_engine.params.future
    "sqlalchemy.create_engine") parameter set to `True`. These “named tuple” rows
    in particular include a behavioral change which is that Python containment expressions
    using `in`, such as:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [RowProxy 现在不再是“代理”；现在被称为 Row 并且像增强型命名元组一样行为](#change-4710-core) 所述，当与一个包含
    [`create_engine.future`](../core/engines.html#sqlalchemy.create_engine.params.future
    "sqlalchemy.create_engine") 参数设置为 `True` 的 [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") 一起使用时，[`Result`](../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") 和 [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") 对象现在具有“命名元组”行为。这些“命名元组”行特别包括一种行为变化，即使用 `in` 的 Python
    包含表达式，如下所示：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The above containment test will use **value containment**, not **key containment**;
    the `row` would need to have a **value** of “name” to return `True`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 上述包含测试将使用 **值包含**，而不是 **键包含**；`row` 需要具有“name”的 **value** 才能返回 `True`。
- en: Under SQLAlchemy 1.4, when [`create_engine.future`](../core/engines.html#sqlalchemy.create_engine.params.future
    "sqlalchemy.create_engine") parameter set to `False`, legacy-style `LegacyRow`
    objects are returned which feature the partial-named-tuple behavior of prior SQLAlchemy
    versions, where containment checks continue to use key containment; `"name" in
    row` would return True if the row had a **column** named “name”, rather than a
    value.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在SQLAlchemy 1.4版本下，当[`create_engine.future`](../core/engines.html#sqlalchemy.create_engine.params.future
    "sqlalchemy.create_engine")参数设置为`False`时，将返回遗留风格的`LegacyRow`对象，其具有之前SQLAlchemy版本的部分命名元组行为，其中包含性检查仍然使用键包含；如果行中有名为“name”的**列**，则`"name"
    in row`将返回True，而不是一个值。
- en: When using [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute"), full named-tuple style is enabled **unconditionally**,
    meaning `"name" in row` will use **value containment** as the test, and **not**
    key containment. This is to accommodate that [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") now returns a [`Result`](../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") that also accommodates for ORM results, where even
    legacy ORM result rows such as those returned by [`Query.all()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.all
    "sqlalchemy.orm.Query.all") use value containment.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用[`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute")时，完整的命名元组样式被**无条件**启用，意味着`"name" in row`将使用**值包含**作为测试，而**不是**键包含。这是为了适应[`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute")现在返回一个[`Result`](../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result")，该结果还适应ORM结果，即使是由[`Query.all()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.all
    "sqlalchemy.orm.Query.all")返回的遗留ORM结果行也使用值包含。
- en: 'This is a behavioral change from SQLAlchemy 1.3 to 1.4\. To continue receiving
    key-containment collections, use the [`Result.mappings()`](../core/connections.html#sqlalchemy.engine.Result.mappings
    "sqlalchemy.engine.Result.mappings") method to receive a [`MappingResult`](../core/connections.html#sqlalchemy.engine.MappingResult
    "sqlalchemy.engine.MappingResult") that returns rows as dictionaries:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这是从SQLAlchemy 1.3到1.4的行为变化。要继续接收键包含集合，请使用[`Result.mappings()`](../core/connections.html#sqlalchemy.engine.Result.mappings
    "sqlalchemy.engine.Result.mappings")方法接收返回行的[`MappingResult`](../core/connections.html#sqlalchemy.engine.MappingResult
    "sqlalchemy.engine.MappingResult")作为字典：
- en: '[PRE4]  ### Transparent SQL Compilation Caching added to All DQL, DML Statements
    in Core, ORM'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE4]  ### 透明SQL编译缓存添加到Core，ORM中的所有DQL，DML语句'
- en: One of the most broadly encompassing changes to ever land in a single SQLAlchemy
    version, a many-month reorganization and refactoring of all querying systems from
    the base of Core all the way through ORM now allows the majority of Python computation
    involved producing SQL strings and related statement metadata from a user-constructed
    statement to be cached in memory, such that subsequent invocations of an identical
    statement construct will use 35-60% fewer CPU resources.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这是单个SQLAlchemy版本中最广泛的变化之一，经过数月的重新组织和重构，从Core的基础到ORM，现在允许大多数涉及从用户构造的语句生成SQL字符串和相关语句元数据的Python计算被缓存在内存中，因此对于相同的语句构造的后续调用将使用35-60%更少的CPU资源。
- en: This caching goes beyond the construction of the SQL string to also include
    the construction of result fetching structures that link the SQL construct to
    the result set, and in the ORM it includes the accommodation of ORM-enabled attribute
    loaders, relationship eager loaders and other options, and object construction
    routines that must be built up each time an ORM query seeks to run and construct
    ORM objects from result sets.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 此缓存不仅限于构造SQL字符串，还包括构造将SQL结构链接到结果集的结果获取结构，而在ORM中，它还包括适应ORM启用的属性加载程序、关系急加载程序和其他选项，以及每次ORM查询试图运行并从结果集构造ORM对象时必须构建的对象构造例程。
- en: 'To introduce the general idea of the feature, given code from the [Performance](../orm/examples.html#examples-performance)
    suite as follows, which will invoke a very simple query “n” times, for a default
    value of n=10000\. The query returns only a single row, as the overhead we are
    looking to decrease is that of **many small queries**. The optimization is not
    as significant for queries that return many rows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了介绍该功能的一般概念，给出来自[Performance](../orm/examples.html#examples-performance)套件的代码如下，它将调用一个非常简单的查询“n”次，默认值为n=10000。查询仅返回一行，因为我们要减少的开销是**许多小查询**的开销。对于返回许多行的查询，优化并不那么显著：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This example in the 1.3 release of SQLAlchemy on a Dell XPS13 running Linux
    completes as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行Linux的Dell XPS13上的SQLAlchemy 1.3版本中，此示例完成如下：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In 1.4, the code above without modification completes:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在1.4版本中，上述代码无需修改即可完成：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This first test indicates that regular ORM queries when using caching can run
    over many iterations in the range of **30% faster**.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这个第一个测试表明，当使用缓存时，常规ORM查询在许多迭代中可以运行得**快30%**。
- en: A second variant of the feature is the optional use of Python lambdas to defer
    the construction of the query itself. This is a more sophisticated variant of
    the approach used by the “Baked Query” extension, which was introduced in version
    1.0.0\. The “lambda” feature may be used in a style very similar to that of baked
    queries, except that it is available in an ad-hoc way for any SQL construct. It
    additionally includes the ability to scan each invocation of the lambda for bound
    literal values that change on every invocation, as well as changes to other constructs,
    such as querying from a different entity or column each time, while still not
    having to run the actual code each time.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 该功能的第二个变体是可选使用Python lambda来延迟查询本身的构建。这是“Baked Query”扩展所使用的方法的更复杂变体，该扩展是在1.0.0版本中引入的。
    “lambda”功能可以以与烘焙查询非常相似的方式使用，只是它以一种临时方式适用于任何SQL构造。它还包括扫描每次调用lambda以查找在每次调用时更改的绑定文字值的能力，以及对其他构造的更改，例如每次查询来自不同实体或列，同时仍然无需每次运行实际代码。
- en: 'Using this API looks as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个API如下所示：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The code above completes:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码完成：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This test indicates that using the newer “select()” style of ORM querying, in
    conjunction with a full “baked” style invocation that caches the entire construction,
    can run over many iterations in the range of **60% faster** and grants performance
    about the same as the baked query system which is now superseded by the native
    caching system.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试表明，使用较新的“select()”风格的ORM查询，结合完整的“baked”风格调用，可以在许多迭代中运行得**快60%**，并且提供与现在被本地缓存系统取代的烘焙查询系统大致相同的性能。
- en: The new system makes use of the existing [`Connection.execution_options.compiled_cache`](../core/connections.html#sqlalchemy.engine.Connection.execution_options.params.compiled_cache
    "sqlalchemy.engine.Connection.execution_options") execution option and also adds
    a cache to the [`Engine`](../core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    directly, which is configured using the [`Engine.query_cache_size`](../core/connections.html#sqlalchemy.engine.Engine.params.query_cache_size
    "sqlalchemy.engine.Engine") parameter.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 新系统利用现有的[`Connection.execution_options.compiled_cache`](../core/connections.html#sqlalchemy.engine.Connection.execution_options.params.compiled_cache
    "sqlalchemy.engine.Connection.execution_options")执行选项，并直接向[`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine")添加了一个缓存，该缓存使用[`Engine.query_cache_size`](../core/connections.html#sqlalchemy.engine.Engine.params.query_cache_size
    "sqlalchemy.engine.Engine")参数进行配置。
- en: A significant portion of API and behavioral changes throughout 1.4 were driven
    in order to support this new feature.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 1.4版本中的API和行为变化的重要部分是为了支持这一新功能。
- en: See also
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[SQL Compilation Caching](../core/connections.html#sql-caching)'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '[SQL编译缓存](../core/connections.html#sql-caching)'
- en: '[#4639](https://www.sqlalchemy.org/trac/ticket/4639) [#5380](https://www.sqlalchemy.org/trac/ticket/5380)
    [#4645](https://www.sqlalchemy.org/trac/ticket/4645) [#4808](https://www.sqlalchemy.org/trac/ticket/4808)
    [#5004](https://www.sqlalchemy.org/trac/ticket/5004)  ### Declarative is now integrated
    into the ORM with new features'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4639](https://www.sqlalchemy.org/trac/ticket/4639) [#5380](https://www.sqlalchemy.org/trac/ticket/5380)
    [#4645](https://www.sqlalchemy.org/trac/ticket/4645) [#4808](https://www.sqlalchemy.org/trac/ticket/4808)
    [#5004](https://www.sqlalchemy.org/trac/ticket/5004)  ### 声明式现在已经与新功能整合到ORM中'
- en: After ten years or so of popularity, the `sqlalchemy.ext.declarative` package
    is now integrated into the `sqlalchemy.orm` namespace, with the exception of the
    declarative “extension” classes which remain as Declarative extensions.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 大约十年后，`sqlalchemy.ext.declarative`包现在已经整合到`sqlalchemy.orm`命名空间中，除了保留为声明式扩展的声明式“extension”类。
- en: 'The new classes added to `sqlalchemy.orm` include:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 新添加到`sqlalchemy.orm`的类包括：
- en: '[`registry`](../orm/mapping_api.html#sqlalchemy.orm.registry "sqlalchemy.orm.registry")
    - a new class that supersedes the role of the “declarative base” class, serving
    as a registry of mapped classes which can be referenced via string name within
    [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")
    calls and is agnostic of the style in which any particular class was mapped.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`registry`](../orm/mapping_api.html#sqlalchemy.orm.registry "sqlalchemy.orm.registry")
    - 一个新类，取代了“declarative base”类的角色，作为映射类的注册表，可以通过字符串名称在[`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")调用中引用，并且不受任何特定类映射样式的限制。'
- en: '[`declarative_base()`](../orm/mapping_api.html#sqlalchemy.orm.declarative_base
    "sqlalchemy.orm.declarative_base") - this is the same declarative base class that
    has been in use throughout the span of the declarative system, except it now references
    a [`registry`](../orm/mapping_api.html#sqlalchemy.orm.registry "sqlalchemy.orm.registry")
    object internally and is implemented by the [`registry.generate_base()`](../orm/mapping_api.html#sqlalchemy.orm.registry.generate_base
    "sqlalchemy.orm.registry.generate_base") method which can be invoked from a [`registry`](../orm/mapping_api.html#sqlalchemy.orm.registry
    "sqlalchemy.orm.registry") directly. The [`declarative_base()`](../orm/mapping_api.html#sqlalchemy.orm.declarative_base
    "sqlalchemy.orm.declarative_base") function creates this registry automatically
    so there is no impact on existing code. The `sqlalchemy.ext.declarative.declarative_base`
    name is still present, emitting a 2.0 deprecation warning when [2.0 deprecations
    mode](#deprecation-20-mode) is enabled.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`declarative_base()`](../orm/mapping_api.html#sqlalchemy.orm.declarative_base
    "sqlalchemy.orm.declarative_base") - 这是在声明系统跨度期间一直在使用的相同声明基类，只是现在在内部引用了一个[`registry`](../orm/mapping_api.html#sqlalchemy.orm.registry
    "sqlalchemy.orm.registry")对象，并由[`registry.generate_base()`](../orm/mapping_api.html#sqlalchemy.orm.registry.generate_base
    "sqlalchemy.orm.registry.generate_base")方法实现，可以直接从[`registry`](../orm/mapping_api.html#sqlalchemy.orm.registry
    "sqlalchemy.orm.registry")调用。[`declarative_base()`](../orm/mapping_api.html#sqlalchemy.orm.declarative_base
    "sqlalchemy.orm.declarative_base")函数会自动创建此注册表，因此对现有代码没有影响。当启用[2.0 deprecations
    mode](#deprecation-20-mode)时，`sqlalchemy.ext.declarative.declarative_base`名称仍然存在，发出2.0弃用警告。'
- en: '[`declared_attr()`](../orm/mapping_api.html#sqlalchemy.orm.declared_attr "sqlalchemy.orm.declared_attr")
    - the same “declared attr” function call now part of `sqlalchemy.orm`. The `sqlalchemy.ext.declarative.declared_attr`
    name is still present, emitting a 2.0 deprecation warning when [2.0 deprecations
    mode](#deprecation-20-mode) is enabled.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`declared_attr()`](../orm/mapping_api.html#sqlalchemy.orm.declared_attr "sqlalchemy.orm.declared_attr")
    - 同样是“declared attr”函数调用现在成为`sqlalchemy.orm`的一部分。当启用[2.0 deprecations mode](#deprecation-20-mode)时，`sqlalchemy.ext.declarative.declared_attr`名称仍然存在，发出2.0弃用警告。'
- en: Other names moved into `sqlalchemy.orm` include [`has_inherited_table()`](../orm/mapping_api.html#sqlalchemy.orm.has_inherited_table
    "sqlalchemy.orm.has_inherited_table"), [`synonym_for()`](../orm/mapping_api.html#sqlalchemy.orm.synonym_for
    "sqlalchemy.orm.synonym_for"), `DeclarativeMeta`, [`as_declarative()`](../orm/mapping_api.html#sqlalchemy.orm.as_declarative
    "sqlalchemy.orm.as_declarative").
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他名称移至`sqlalchemy.orm`，包括[`has_inherited_table()`](../orm/mapping_api.html#sqlalchemy.orm.has_inherited_table
    "sqlalchemy.orm.has_inherited_table")，[`synonym_for()`](../orm/mapping_api.html#sqlalchemy.orm.synonym_for
    "sqlalchemy.orm.synonym_for")，`DeclarativeMeta`，[`as_declarative()`](../orm/mapping_api.html#sqlalchemy.orm.as_declarative
    "sqlalchemy.orm.as_declarative")。
- en: In addition, The `instrument_declarative()` function is deprecated, superseded
    by [`registry.map_declaratively()`](../orm/mapping_api.html#sqlalchemy.orm.registry.map_declaratively
    "sqlalchemy.orm.registry.map_declaratively"). The [`ConcreteBase`](../orm/extensions/declarative/index.html#sqlalchemy.ext.declarative.ConcreteBase
    "sqlalchemy.ext.declarative.ConcreteBase"), [`AbstractConcreteBase`](../orm/extensions/declarative/index.html#sqlalchemy.ext.declarative.AbstractConcreteBase
    "sqlalchemy.ext.declarative.AbstractConcreteBase"), and [`DeferredReflection`](../orm/extensions/declarative/index.html#sqlalchemy.ext.declarative.DeferredReflection
    "sqlalchemy.ext.declarative.DeferredReflection") classes remain as extensions
    in the [Declarative Extensions](../orm/extensions/declarative/index.html) package.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，`instrument_declarative()`函数已被弃用，被[`registry.map_declaratively()`](../orm/mapping_api.html#sqlalchemy.orm.registry.map_declaratively
    "sqlalchemy.orm.registry.map_declaratively")取代。[`ConcreteBase`](../orm/extensions/declarative/index.html#sqlalchemy.ext.declarative.ConcreteBase
    "sqlalchemy.ext.declarative.ConcreteBase")、[`AbstractConcreteBase`](../orm/extensions/declarative/index.html#sqlalchemy.ext.declarative.AbstractConcreteBase
    "sqlalchemy.ext.declarative.AbstractConcreteBase")和[`DeferredReflection`](../orm/extensions/declarative/index.html#sqlalchemy.ext.declarative.DeferredReflection
    "sqlalchemy.ext.declarative.DeferredReflection")类仍然作为[声明性扩展](../orm/extensions/declarative/index.html)包中的扩展。
- en: 'Mapping styles have now been organized such that they all extend from the [`registry`](../orm/mapping_api.html#sqlalchemy.orm.registry
    "sqlalchemy.orm.registry") object, and fall into these categories:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 映射样式现在已经组织起来，它们都从[`registry`](../orm/mapping_api.html#sqlalchemy.orm.registry
    "sqlalchemy.orm.registry")对象扩展，并分为以下几类：
- en: '[Declarative Mapping](../orm/mapping_styles.html#orm-declarative-mapping)'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[声明性映射](../orm/mapping_styles.html#orm-declarative-mapping)'
- en: Using [`declarative_base()`](../orm/mapping_api.html#sqlalchemy.orm.declarative_base
    "sqlalchemy.orm.declarative_base") Base class w/ metaclass
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用[`declarative_base()`](../orm/mapping_api.html#sqlalchemy.orm.declarative_base
    "sqlalchemy.orm.declarative_base")基类与元类
- en: '[Declarative Table with mapped_column()](../orm/declarative_tables.html#orm-declarative-table)'
  id: totrans-66
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[具有mapped_column()的声明性表](../orm/declarative_tables.html#orm-declarative-table)'
- en: '[Imperative Table (a.k.a. “hybrid table”)](../orm/declarative_tables.html#orm-imperative-table-configuration)'
  id: totrans-67
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[命令式表（又名“混合表”）](../orm/declarative_tables.html#orm-imperative-table-configuration)'
- en: Using [`registry.mapped()`](../orm/mapping_api.html#sqlalchemy.orm.registry.mapped
    "sqlalchemy.orm.registry.mapped") Declarative Decorator
  id: totrans-68
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用[`registry.mapped()`](../orm/mapping_api.html#sqlalchemy.orm.registry.mapped
    "sqlalchemy.orm.registry.mapped")声明性装饰器
- en: Declarative Table
  id: totrans-69
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明性表
- en: Imperative Table (Hybrid)
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令式表（混合）
- en: '[Applying ORM Mappings to an existing dataclass (legacy dataclass use)](../orm/dataclasses.html#orm-declarative-dataclasses)'
  id: totrans-71
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[将ORM映射应用于现有数据类（传统数据类用法）](../orm/dataclasses.html#orm-declarative-dataclasses)'
- en: '[Imperative (a.k.a. “classical” mapping)](../orm/mapping_styles.html#orm-imperative-mapping)'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[命令式（又名“经典”映射）](../orm/mapping_styles.html#orm-imperative-mapping)'
- en: Using [`registry.map_imperatively()`](../orm/mapping_api.html#sqlalchemy.orm.registry.map_imperatively
    "sqlalchemy.orm.registry.map_imperatively")
  id: totrans-73
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用[`registry.map_imperatively()`](../orm/mapping_api.html#sqlalchemy.orm.registry.map_imperatively
    "sqlalchemy.orm.registry.map_imperatively")
- en: '[Mapping pre-existing dataclasses using Imperative Mapping](../orm/dataclasses.html#orm-imperative-dataclasses)'
  id: totrans-74
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用命令式映射映射预先存在的数据类](../orm/dataclasses.html#orm-imperative-dataclasses)'
- en: The existing classical mapping function `sqlalchemy.orm.mapper()` remains, however
    it is deprecated to call upon `sqlalchemy.orm.mapper()` directly; the new [`registry.map_imperatively()`](../orm/mapping_api.html#sqlalchemy.orm.registry.map_imperatively
    "sqlalchemy.orm.registry.map_imperatively") method now routes the request through
    the [`sqlalchemy.orm.registry()`](../orm/mapping_api.html#sqlalchemy.orm.registry
    "sqlalchemy.orm.registry") so that it integrates with other declarative mappings
    unambiguously.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现有的经典映射函数`sqlalchemy.orm.mapper()`仍然存在，但不建议直接调用`sqlalchemy.orm.mapper()`；新的[`registry.map_imperatively()`](../orm/mapping_api.html#sqlalchemy.orm.registry.map_imperatively
    "sqlalchemy.orm.registry.map_imperatively")方法现在通过[`sqlalchemy.orm.registry()`](../orm/mapping_api.html#sqlalchemy.orm.registry
    "sqlalchemy.orm.registry")路由请求，以便与其他声明性映射明确集成。
- en: The new approach interoperates with 3rd party class instrumentation systems
    which necessarily must take place on the class before the mapping process does,
    allowing declarative mapping to work via a decorator instead of a declarative
    base so that packages like [dataclasses](https://docs.python.org/3/library/dataclasses.html)
    and [attrs](https://pypi.org/project/attrs/) can be used with declarative mappings,
    in addition to working with classical mappings.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这种新方法与第三方类仪器系统相互操作，这些系统必须在映射过程之前对类进行必要的操作，允许声明性映射通过装饰器而不是声明性基础工作，以便像[dataclasses](https://docs.python.org/3/library/dataclasses.html)和[attrs](https://pypi.org/project/attrs/)这样的包可以与声明性映射一起使用，除了与经典映射一起使用。
- en: Declarative documentation has now been fully integrated into the ORM mapper
    configuration documentation and includes examples for all styles of mappings organized
    into one place. See the section [ORM Mapped Class Overview](../orm/mapping_styles.html)
    for the start of the newly reorganized documentation.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 声明文档现在已完全集成到ORM映射器配置文档中，并包括对所有样式映射的示例，组织到一个地方。请参阅[ORM映射类概述](../orm/mapping_styles.html)部分，开始新的重新组织的文档。
- en: See also
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[ORM Mapped Class Overview](../orm/mapping_styles.html)'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '[ORM映射类概述](../orm/mapping_styles.html)'
- en: '[Python Dataclasses, attrs Supported w/ Declarative, Imperative Mappings](#change-5027)'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '[Python Dataclasses、attrs支持声明性、命令式映射](#change-5027)'
- en: '[#5508](https://www.sqlalchemy.org/trac/ticket/5508)  ### Python Dataclasses,
    attrs Supported w/ Declarative, Imperative Mappings'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '[#5508](https://www.sqlalchemy.org/trac/ticket/5508)  ### 使用Python Dataclasses、attrs支持声明性、命令式映射'
- en: Along with the new declarative decorator styles introduced in [Declarative is
    now integrated into the ORM with new features](#change-5508), the [`Mapper`](../orm/mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper") is now explicitly aware of the Python `dataclasses` module
    and will recognize attributes that are configured in this way, and proceed to
    map them without skipping them as was the case previously. In the case of the
    `attrs` module, `attrs` already removes its own attributes from the class so was
    already compatible with SQLAlchemy classical mappings. With the addition of the
    [`registry.mapped()`](../orm/mapping_api.html#sqlalchemy.orm.registry.mapped "sqlalchemy.orm.registry.mapped")
    decorator, both attribute systems can now interoperate with Declarative mappings
    as well.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 随着[声明性现在已经与新特性集成到ORM中](../orm/mapping_api.html#sqlalchemy.orm.Mapper "sqlalchemy.orm.Mapper")的新装饰器样式，[`Mapper`](../orm/mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper")现在明确地了解Python的`dataclasses`模块，并将识别配置为此方式的属性，并继续映射它们，而不是像以前那样跳过它们。对于`attrs`模块，`attrs`已经从类中删除了自己的属性，因此已经与SQLAlchemy的经典映射兼容。通过添加[`registry.mapped()`](../orm/mapping_api.html#sqlalchemy.orm.registry.mapped
    "sqlalchemy.orm.registry.mapped")装饰器，两种属性系统现在也可以与声明性映射互操作。
- en: See also
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Applying ORM Mappings to an existing dataclass (legacy dataclass use)](../orm/dataclasses.html#orm-declarative-dataclasses)'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '[将ORM映射应用于现有的数据类（传统数据类使用）](../orm/dataclasses.html#orm-declarative-dataclasses)'
- en: '[Mapping pre-existing dataclasses using Imperative Mapping](../orm/dataclasses.html#orm-imperative-dataclasses)'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用命令式映射映射预先存在的数据类](../orm/dataclasses.html#orm-imperative-dataclasses)'
- en: '[#5027](https://www.sqlalchemy.org/trac/ticket/5027)  ### Asynchronous IO Support
    for Core and ORM'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '[#5027](https://www.sqlalchemy.org/trac/ticket/5027)  ### 核心和ORM的异步IO支持'
- en: SQLAlchemy now supports Python `asyncio`-compatible database drivers using an
    all-new asyncio front-end interface to [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") for Core usage as well as [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") for ORM use, using the [`AsyncConnection`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncConnection
    "sqlalchemy.ext.asyncio.AsyncConnection") and [`AsyncSession`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession
    "sqlalchemy.ext.asyncio.AsyncSession") objects.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy现在支持使用全新的异步IO前端接口来使用Python `asyncio`兼容的数据库驱动程序，用于Core使用的[`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")以及用于ORM使用的[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")，使用[`AsyncConnection`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncConnection
    "sqlalchemy.ext.asyncio.AsyncConnection")和[`AsyncSession`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession
    "sqlalchemy.ext.asyncio.AsyncSession")对象。
- en: Note
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The new asyncio feature should be considered **alpha level** for the initial
    releases of SQLAlchemy 1.4\. This is super new stuff that uses some previously
    unfamiliar programming techniques.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 asyncio 功能应该被视为**alpha 级别**，适用于 SQLAlchemy 1.4 的初始版本。这是一些使用了一些以前不熟悉的编程技术的全新东西。
- en: The initial database API supported is the [asyncpg](../dialects/postgresql.html#dialect-postgresql-asyncpg)
    asyncio driver for PostgreSQL.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 初始支持的数据库 API 是[asyncpg](../dialects/postgresql.html#dialect-postgresql-asyncpg)用于
    PostgreSQL 的 asyncio 驱动程序。
- en: The internal features of SQLAlchemy are fully integrated by making use of the
    [greenlet](https://greenlet.readthedocs.io/en/latest/) library in order to adapt
    the flow of execution within SQLAlchemy’s internals to propagate asyncio `await`
    keywords outwards from the database driver to the end-user API, which features
    `async` methods. Using this approach, the asyncpg driver is fully operational
    within SQLAlchemy’s own test suite and features compatibility with most psycopg2
    features. The approach was vetted and improved upon by developers of the greenlet
    project for which SQLAlchemy is appreciative.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 的内部功能完全集成了[greenlet](https://greenlet.readthedocs.io/en/latest/)库，以便调整执行流程，从数据库驱动程序向最终用户
    API 传播 asyncio `await` 关键字，该 API 具有 `async` 方法。使用这种方法，asyncpg 驱动程序在 SQLAlchemy
    的测试套件中完全可用，并且与大多数 psycopg2 功能兼容。这种方法经过了 greenlet 项目的开发人员的审查和改进，对此 SQLAlchemy 表示感激。
- en: The user facing `async` API itself is focused around IO-oriented methods such
    as [`AsyncEngine.connect()`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncEngine.connect
    "sqlalchemy.ext.asyncio.AsyncEngine.connect") and [`AsyncConnection.execute()`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncConnection.execute
    "sqlalchemy.ext.asyncio.AsyncConnection.execute"). The new Core constructs strictly
    support [2.0 style](../glossary.html#term-2.0-style) usage only; which means all
    statements must be invoked given a connection object, in this case [`AsyncConnection`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncConnection
    "sqlalchemy.ext.asyncio.AsyncConnection").
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 用户面向的 `async` API 本身侧重于 IO 导向的方法，如[`AsyncEngine.connect()`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncEngine.connect
    "sqlalchemy.ext.asyncio.AsyncEngine.connect")和[`AsyncConnection.execute()`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncConnection.execute
    "sqlalchemy.ext.asyncio.AsyncConnection.execute")。新的 Core 结构严格支持[2.0 风格](../glossary.html#term-2.0-style)的使用方式；这意味着所有语句必须在给定连接对象的情况下调用，即[`AsyncConnection`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncConnection
    "sqlalchemy.ext.asyncio.AsyncConnection")。
- en: Within the ORM, [2.0 style](../glossary.html#term-2.0-style) query execution
    is supported, using [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") constructs in conjunction with [`AsyncSession.execute()`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession.execute
    "sqlalchemy.ext.asyncio.AsyncSession.execute"); the legacy [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object itself is not supported by the [`AsyncSession`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession
    "sqlalchemy.ext.asyncio.AsyncSession") class.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ORM 中，支持[2.0 风格](../glossary.html#term-2.0-style)的查询执行，使用[`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select")结构与[`AsyncSession.execute()`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession.execute
    "sqlalchemy.ext.asyncio.AsyncSession.execute")结合使用；传统的[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")对象本身不受[`AsyncSession`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession
    "sqlalchemy.ext.asyncio.AsyncSession")类支持。
- en: ORM features such as lazy loading of related attributes as well as unexpiry
    of expired attributes are by definition disallowed in the traditional asyncio
    programming model, as they indicate IO operations that would run implicitly within
    the scope of a Python `getattr()` operation. To overcome this, the **traditional**
    asyncio application should make judicious use of [eager loading](../orm/queryguide/relationships.html)
    techniques as well as forego the use of features such as [expire on commit](../orm/session_basics.html#session-committing)
    so that such loads are not needed.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: ORM 功能，如延迟加载相关属性以及过期属性的取消，根据定义在传统的 asyncio 编程模型中是不允许的，因为它们表示会在 Python `getattr()`
    操作的范围内隐式运行的 IO 操作。为了克服这一点，**传统**的 asyncio 应用程序应该巧妙地利用[eager loading](../orm/queryguide/relationships.html)技术，并放弃使用诸如[expire
    on commit](../orm/session_basics.html#session-committing)之类的功能，以便不需要这样的加载。
- en: For the asyncio application developer who **chooses to break** with tradition,
    the new API provides a **strictly optional feature** such that applications that
    wish to make use of such ORM features can opt to organize database-related code
    into functions which can then be run within greenlets using the [`AsyncSession.run_sync()`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession.run_sync
    "sqlalchemy.ext.asyncio.AsyncSession.run_sync") method. See the `greenlet_orm.py`
    example at [Asyncio Integration](../orm/examples.html#examples-asyncio) for a
    demonstration.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 对于选择与传统**决裂**的 asyncio 应用程序开发人员，新的 API 提供了一个**严格可选的功能**，使希望利用此类 ORM 功能的应用程序可以选择将与数据库相关的代码组织成函数，然后使用
    [`AsyncSession.run_sync()`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession.run_sync
    "sqlalchemy.ext.asyncio.AsyncSession.run_sync") 方法在 greenlets 中运行。查看 [Asyncio
    Integration](../orm/examples.html#examples-asyncio) 中的 `greenlet_orm.py` 示例以进行演示。
- en: Support for asynchronous cursors is also provided using new methods [`AsyncConnection.stream()`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncConnection.stream
    "sqlalchemy.ext.asyncio.AsyncConnection.stream") and [`AsyncSession.stream()`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession.stream
    "sqlalchemy.ext.asyncio.AsyncSession.stream"), which support a new [`AsyncResult`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncResult
    "sqlalchemy.ext.asyncio.AsyncResult") object that itself provides awaitable versions
    of common methods like [`AsyncResult.all()`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncResult.all
    "sqlalchemy.ext.asyncio.AsyncResult.all") and [`AsyncResult.fetchmany()`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncResult.fetchmany
    "sqlalchemy.ext.asyncio.AsyncResult.fetchmany"). Both Core and ORM are integrated
    with the feature which corresponds to the use of “server side cursors” in traditional
    SQLAlchemy.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 还提供了对异步游标的支持，使用新方法 [`AsyncConnection.stream()`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncConnection.stream
    "sqlalchemy.ext.asyncio.AsyncConnection.stream") 和 [`AsyncSession.stream()`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession.stream
    "sqlalchemy.ext.asyncio.AsyncSession.stream")，支持一个新的 [`AsyncResult`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncResult
    "sqlalchemy.ext.asyncio.AsyncResult") 对象，该对象本身提供了常见方法的可等待版本，如 [`AsyncResult.all()`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncResult.all
    "sqlalchemy.ext.asyncio.AsyncResult.all") 和 [`AsyncResult.fetchmany()`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncResult.fetchmany
    "sqlalchemy.ext.asyncio.AsyncResult.fetchmany")。核心和 ORM 都与传统 SQLAlchemy 中“服务器端游标”的使用对应的功能集成在一起。
- en: See also
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Asynchronous I/O (asyncio)](../orm/extensions/asyncio.html)'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '[异步 I/O（asyncio）](../orm/extensions/asyncio.html)'
- en: '[Asyncio Integration](../orm/examples.html#examples-asyncio)'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '[Asyncio Integration](../orm/examples.html#examples-asyncio)'
- en: '[#3414](https://www.sqlalchemy.org/trac/ticket/3414)  ### Many Core and ORM
    statement objects now perform much of their construction and validation in the
    compile phase'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3414](https://www.sqlalchemy.org/trac/ticket/3414)  ### 许多核心和 ORM 语句对象现在在编译阶段执行大部分构建和验证操作'
- en: A major initiative in the 1.4 series is to approach the model of both Core SQL
    statements as well as the ORM Query to allow for an efficient, cacheable model
    of statement creation and compilation, where the compilation step would be cached,
    based on a cache key generated by the created statement object, which itself is
    newly created for each use. Towards this goal, much of the Python computation
    which occurs within the construction of statements, particularly that of the ORM
    [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    as well as the [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") construct when used to invoke ORM queries,
    is being moved to occur within the compilation phase of the statement which only
    occurs after the statement has been invoked, and only if the statement’s compiled
    form was not yet cached.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 1.4 系列中的一个重要举措是接近核心 SQL 语句和 ORM 查询的模型，以实现高效、可缓存的语句创建和编译模型，其中编译步骤将被缓存，基于创建的语句对象生成的缓存键，该对象本身为每次使用新创建。为实现这一目标，特别是在构建语句时发生的大部分
    Python 计算，特别是 ORM [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") 和 [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") 构造在用于调用 ORM 查询时，正在移动到语句的编译阶段中，该阶段仅在调用语句后发生，且仅在语句的编译形式尚未被缓存时才会发生。
- en: From an end-user perspective, this means that some of the error messages which
    can arise based on arguments passed to the object will no longer be raised immediately,
    and instead will occur only when the statement is invoked for the first time.
    These conditions are always structural and not data driven, so there is no risk
    of such a condition being missed due to a cached statement.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 从最终用户的角度来看，这意味着基于传递给对象的参数可能引发的某些错误消息将不再立即引发，而是仅在首次调用语句时发生。这些条件始终是结构性的，而不是数据驱动的，因此不会因为缓存语句而错过这种条件。
- en: 'Error conditions which fall under this category include:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 属于此类别的错误条件包括：
- en: when a `_selectable.CompoundSelect` is constructed (e.g. a UNION, EXCEPT, etc.)
    and the SELECT statements passed do not have the same number of columns, a [`CompileError`](../core/exceptions.html#sqlalchemy.exc.CompileError
    "sqlalchemy.exc.CompileError") is now raised to this effect; previously, an [`ArgumentError`](../core/exceptions.html#sqlalchemy.exc.ArgumentError
    "sqlalchemy.exc.ArgumentError") would be raised immediately upon statement construction.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当构造`_selectable.CompoundSelect`（例如UNION，EXCEPT等）并且传递的SELECT语句列数不同时，现在会引发[`CompileError`](../core/exceptions.html#sqlalchemy.exc.CompileError
    "sqlalchemy.exc.CompileError")；以前，在语句构造时会立即引发[`ArgumentError`](../core/exceptions.html#sqlalchemy.exc.ArgumentError
    "sqlalchemy.exc.ArgumentError")。
- en: Various error conditions which may arise when calling upon [`Query.join()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join") will be evaluated at statement compilation time rather
    than when the method is first called.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用[`Query.join()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.join "sqlalchemy.orm.Query.join")时可能出现的各种错误条件将在语句编译时进行评估，而不是在首次调用方法时。
- en: 'Other things that may change involve the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object directly:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 可能发生变化的其他事情涉及直接操作[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")对象：
- en: Behaviors may be slightly different when calling upon the [`Query.statement`](../orm/queryguide/query.html#sqlalchemy.orm.Query.statement
    "sqlalchemy.orm.Query.statement") accessor. The [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") object returned is now a direct copy of the
    same state that was present in the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query"), without any ORM-specific compilation being performed
    (which means it’s dramatically faster). However, the [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") will not have the same internal state as it
    had in 1.3, including things like the FROM clauses being explicitly spelled out
    if they were not explicitly stated in the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query"). This means code that relies upon manipulating this [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") statement such as calling methods like [`Select.with_only_columns()`](../core/selectable.html#sqlalchemy.sql.expression.Select.with_only_columns
    "sqlalchemy.sql.expression.Select.with_only_columns") may need to accommodate
    for the FROM clause.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用[`Query.statement`](../orm/queryguide/query.html#sqlalchemy.orm.Query.statement
    "sqlalchemy.orm.Query.statement")访问器时行为可能略有不同。返回的[`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select")对象现在是与[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")中存在的相同状态的直接副本，而不执行任何ORM特定的编译（这意味着速度大大提高）。但是，该[`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select")将不具有与1.3版本中相同的内部状态，包括如果在[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")中未明确声明，则明确拼写出FROM子句。这意味着依赖于操作此[`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select")语句的代码，例如调用[`Select.with_only_columns()`](../core/selectable.html#sqlalchemy.sql.expression.Select.with_only_columns
    "sqlalchemy.sql.expression.Select.with_only_columns")方法，可能需要适应FROM子句。
- en: See also
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[Transparent SQL Compilation Caching added to All DQL, DML Statements in Core,
    ORM](#change-4639)  ### Repaired internal importing conventions such that code
    linters may work correctly'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '[透明SQL编译缓存添加到Core，ORM中的所有DQL，DML语句](#change-4639)  ### 修复了内部导入约定，使代码检查工具可以正常工作'
- en: 'SQLAlchemy has for a long time used a parameter-injecting decorator to help
    resolve mutually-dependent module imports, like this:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy长期以来一直使用参数注入装饰器来帮助解决相互依赖的模块导入，就像这样：
- en: '[PRE10]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Where the above function would be rewritten to no longer have the `dml` parameter
    on the outside. This would confuse code-linting tools into seeing a missing parameter
    to functions. A new approach has been implemented internally such that the function’s
    signature is no longer modified and the module object is procured inside the function
    instead.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 上述函数将被重写，不再在外部具有`dml`参数。这会让代码检查工具看到函数缺少参数而感到困惑。已经内部实现了一种新方法，使函数的签名不再被修改，而是在函数内部获取模块对象。
- en: '[#4656](https://www.sqlalchemy.org/trac/ticket/4656)'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4656](https://www.sqlalchemy.org/trac/ticket/4656)'
- en: '[#4689](https://www.sqlalchemy.org/trac/ticket/4689)  ### Support for SQL Regular
    Expression operators'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4689](https://www.sqlalchemy.org/trac/ticket/4689)  ### 支持 SQL 正则表达式操作符'
- en: A long awaited feature to add rudimentary support for database regular expression
    operators, to complement the [`ColumnOperators.like()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.like
    "sqlalchemy.sql.expression.ColumnOperators.like") and [`ColumnOperators.match()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.match
    "sqlalchemy.sql.expression.ColumnOperators.match") suites of operations. The new
    features include [`ColumnOperators.regexp_match()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.regexp_match
    "sqlalchemy.sql.expression.ColumnOperators.regexp_match") implementing a regular
    expression match like function, and [`ColumnOperators.regexp_replace()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.regexp_replace
    "sqlalchemy.sql.expression.ColumnOperators.regexp_replace") implementing a regular
    expression string replace function.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 期待已久的功能是为数据库正则表达式操作符添加基本支持，以补充[`ColumnOperators.like()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.like
    "sqlalchemy.sql.expression.ColumnOperators.like")和[`ColumnOperators.match()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.match
    "sqlalchemy.sql.expression.ColumnOperators.match")操作套件。新功能包括[`ColumnOperators.regexp_match()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.regexp_match
    "sqlalchemy.sql.expression.ColumnOperators.regexp_match")实现了类似正则表达式匹配的功能，以及[`ColumnOperators.regexp_replace()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.regexp_replace
    "sqlalchemy.sql.expression.ColumnOperators.regexp_replace")实现了正则表达式字符串替换功能。
- en: Supported backends include SQLite, PostgreSQL, MySQL / MariaDB, and Oracle.
    The SQLite backend only supports “regexp_match” but not “regexp_replace”.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 支持的后端包括 SQLite、PostgreSQL、MySQL / MariaDB 和 Oracle。SQLite 后端仅支持“regexp_match”而不支持“regexp_replace”。
- en: The regular expression syntaxes and flags are **not backend agnostic**. A future
    feature will allow multiple regular expression syntaxes to be specified at once
    to switch between different backends on the fly.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式语法和标志**不是通用于所有后端**。未来的功能将允许一次指定多个正则表达式语法，以便在不同后端之间动态切换。
- en: For SQLite, Python’s `re.search()` function with no additional arguments is
    established as the implementation.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 SQLite，Python的`re.search()`函数没有额外的参数被确定为实现。
- en: See also
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`ColumnOperators.regexp_match()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.regexp_match
    "sqlalchemy.sql.expression.ColumnOperators.regexp_match")'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '[`ColumnOperators.regexp_match()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.regexp_match
    "sqlalchemy.sql.expression.ColumnOperators.regexp_match")'
- en: '[`ColumnOperators.regexp_replace()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.regexp_replace
    "sqlalchemy.sql.expression.ColumnOperators.regexp_replace")'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '[`ColumnOperators.regexp_replace()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.regexp_replace
    "sqlalchemy.sql.expression.ColumnOperators.regexp_replace")'
- en: '[Regular Expression Support](../dialects/sqlite.html#pysqlite-regexp) - SQLite
    implementation notes'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '[正则表达式支持](../dialects/sqlite.html#pysqlite-regexp) - SQLite 实现注意事项'
- en: '[#1390](https://www.sqlalchemy.org/trac/ticket/1390)  ### SQLAlchemy 2.0 Deprecations
    Mode'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '[#1390](https://www.sqlalchemy.org/trac/ticket/1390)  ### SQLAlchemy 2.0 弃用模式'
- en: One of the primary goals of the 1.4 release is to provide a “transitional” release
    so that applications may migrate to SQLAlchemy 2.0 gradually. Towards this end,
    a primary feature in release 1.4 is “2.0 deprecations mode”, which is a series
    of deprecation warnings that emit against every detectable API pattern which will
    work differently in version 2.0\. The warnings all make use of the `RemovedIn20Warning`
    class. As these warnings affect foundational patterns including the [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") and [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") constructs, even simple applications can generate
    a lot of warnings until appropriate API changes are made. The warning mode is
    therefore turned off by default until the developer enables the environment variable
    `SQLALCHEMY_WARN_20=1`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 1.4 版本的主要目标之一是提供一个“过渡”版本，以便应用程序可以逐渐迁移到 SQLAlchemy 2.0。为此，1.4 版本的一个主要特性是“2.0
    弃用模式”，这是一系列针对每个可检测到的 API 模式发出的弃用警告，在 2.0 版本中将以不同方式工作。所有警告都使用`RemovedIn20Warning`类。由于这些警告影响到包括[`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") 和[`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") 构造在内的基础模式，即使是简单的应用程序也可能生成大量警告，直到适当的 API 更改完成。因此，警告模式默认关闭，直到开发人员启用环境变量`SQLALCHEMY_WARN_20=1`。
- en: For a full walkthrough of using 2.0 Deprecations mode, see [Migration to 2.0
    Step Two - Turn on RemovedIn20Warnings](migration_20.html#migration-20-deprecations-mode).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 要全面了解如何使用 2.0 弃用模式，请参阅[迁移到 2.0 步骤二 - 打开 RemovedIn20Warnings](migration_20.html#migration-20-deprecations-mode)。
- en: See also
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[SQLAlchemy 2.0 - Major Migration Guide](migration_20.html)'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '[SQLAlchemy 2.0 - 主要迁移指南](migration_20.html)'
- en: '[Migration to 2.0 Step Two - Turn on RemovedIn20Warnings](migration_20.html#migration-20-deprecations-mode)'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '[迁移到 2.0 步骤二 - 打开 RemovedIn20Warnings](migration_20.html#migration-20-deprecations-mode)'
- en: API and Behavioral Changes - Core
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: API 和行为变化 - 核心
- en: '### A SELECT statement is no longer implicitly considered to be a FROM clause'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '### SELECT 语句不再隐式地被视为 FROM 子句'
- en: This change is one of the larger conceptual changes in SQLAlchemy in many years,
    however it is hoped that the end user impact is relatively small, as the change
    more closely matches what databases like MySQL and PostgreSQL require in any case.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这个变化是多年来 SQLAlchemy 中较大的概念性变化之一，但希望最终用户的影响相对较小，因为这个变化更符合像 MySQL 和 PostgreSQL
    这样的数据库实际需要。
- en: The most immediate noticeable impact is that a [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") can no longer be embedded inside of another
    [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select")
    directly, without explicitly turning the inner [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") into a subquery first. This is historically
    performed by using the [`SelectBase.alias()`](../core/selectable.html#sqlalchemy.sql.expression.SelectBase.alias
    "sqlalchemy.sql.expression.SelectBase.alias") method, which remains, however is
    more explicitly suited by using a new method [`SelectBase.subquery()`](../core/selectable.html#sqlalchemy.sql.expression.SelectBase.subquery
    "sqlalchemy.sql.expression.SelectBase.subquery"); both methods do the same thing.
    The object returned is now [`Subquery`](../core/selectable.html#sqlalchemy.sql.expression.Subquery
    "sqlalchemy.sql.expression.Subquery"), which is very similar to the [`Alias`](../core/selectable.html#sqlalchemy.sql.expression.Alias
    "sqlalchemy.sql.expression.Alias") object and shares a common base [`AliasedReturnsRows`](../core/selectable.html#sqlalchemy.sql.expression.AliasedReturnsRows
    "sqlalchemy.sql.expression.AliasedReturnsRows").
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 最直接显著的影响是，一个[`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") 现在不能直接嵌套在另一个[`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") 中，而需要显式地先将内部的[`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") 转换为子查询。这在历史上是通过使用[`SelectBase.alias()`](../core/selectable.html#sqlalchemy.sql.expression.SelectBase.alias
    "sqlalchemy.sql.expression.SelectBase.alias") 方法来实现的，该方法仍然存在，但更适合使用一个新方法[`SelectBase.subquery()`](../core/selectable.html#sqlalchemy.sql.expression.SelectBase.subquery
    "sqlalchemy.sql.expression.SelectBase.subquery")；两种方法都是做同样的事情。现在返回的对象是[`Subquery`](../core/selectable.html#sqlalchemy.sql.expression.Subquery
    "sqlalchemy.sql.expression.Subquery")，它与[`Alias`](../core/selectable.html#sqlalchemy.sql.expression.Alias
    "sqlalchemy.sql.expression.Alias")对象非常相似，并共享一个共同的基类[`AliasedReturnsRows`](../core/selectable.html#sqlalchemy.sql.expression.AliasedReturnsRows
    "sqlalchemy.sql.expression.AliasedReturnsRows")。
- en: 'That is, this will now raise:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，现在会引发：
- en: '[PRE11]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Raising:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 引发：
- en: '[PRE12]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The correct calling form is instead (noting also that [brackets are no longer
    required for select()](#change-5284)):'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 正确的调用形式应该是（还要注意[select()不再需要括号](#change-5284)）：
- en: '[PRE13]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Noting above that the [`SelectBase.subquery()`](../core/selectable.html#sqlalchemy.sql.expression.SelectBase.subquery
    "sqlalchemy.sql.expression.SelectBase.subquery") method is essentially equivalent
    to using the [`SelectBase.alias()`](../core/selectable.html#sqlalchemy.sql.expression.SelectBase.alias
    "sqlalchemy.sql.expression.SelectBase.alias") method.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 注意[`SelectBase.subquery()`](../core/selectable.html#sqlalchemy.sql.expression.SelectBase.subquery
    "sqlalchemy.sql.expression.SelectBase.subquery")方法本质上等同于使用[`SelectBase.alias()`](../core/selectable.html#sqlalchemy.sql.expression.SelectBase.alias
    "sqlalchemy.sql.expression.SelectBase.alias")方法。
- en: 'The rationale for this change is based on the following:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这一变化的理由如下：
- en: In order to support the unification of [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") with [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query"), the [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") object needs to have [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") and [`Select.outerjoin()`](../core/selectable.html#sqlalchemy.sql.expression.Select.outerjoin
    "sqlalchemy.sql.expression.Select.outerjoin") methods that actually add JOIN criteria
    to the existing FROM clause, as is what users have always expected it to do in
    any case. The previous behavior, having to align with what a [`FromClause`](../core/selectable.html#sqlalchemy.sql.expression.FromClause
    "sqlalchemy.sql.expression.FromClause") would do, was that it would generate an
    unnamed subquery and then JOIN to it, which was a completely useless feature that
    only confused those users unfortunate enough to try this. This change is discussed
    at [select().join() and outerjoin() add JOIN criteria to the current query, rather
    than creating a subquery](#change-select-join).
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了支持[`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select "sqlalchemy.sql.expression.Select")与[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")的统一，[`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select")对象需要具有实际添加JOIN条件到现有FROM子句的[`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join")和[`Select.outerjoin()`](../core/selectable.html#sqlalchemy.sql.expression.Select.outerjoin
    "sqlalchemy.sql.expression.Select.outerjoin")方法，这正是用户一直期望它做的事情。先前的行为是，必须与[`FromClause`](../core/selectable.html#sqlalchemy.sql.expression.FromClause
    "sqlalchemy.sql.expression.FromClause")一致，它会生成一个无名子查询，然后JOIN到它，这是一个完全没有用的功能，只会让那些不幸尝试的用户感到困惑。这一变化在[select().join()
    and outerjoin() add JOIN criteria to the current query, rather than creating a
    subquery](#change-select-join)中讨论。
- en: 'The behavior of including a SELECT in the FROM clause of another SELECT without
    first creating an alias or subquery would be that it creates an unnamed subquery.
    While standard SQL does support this syntax, in practice it is rejected by most
    databases. For example, both the MySQL and PostgreSQL outright reject the usage
    of unnamed subqueries:'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在另一个SELECT的FROM子句中包含SELECT而不先创建别名或子查询的行为将创建一个无名子查询。虽然标准SQL确实支持这种语法，但实际上大多数数据库都会拒绝它。例如，MySQL和PostgreSQL都明确拒绝使用无名子查询：
- en: '[PRE14]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'A database like SQLite accepts them, however it is still often the case that
    the names produced from such a subquery are too ambiguous to be useful:'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 像SQLite这样的数据库接受它们，但通常情况下，从这样的子查询产生的名称太模糊，无法使用：
- en: '[PRE15]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As [`SelectBase`](../core/selectable.html#sqlalchemy.sql.expression.SelectBase
    "sqlalchemy.sql.expression.SelectBase") objects are no longer [`FromClause`](../core/selectable.html#sqlalchemy.sql.expression.FromClause
    "sqlalchemy.sql.expression.FromClause") objects, attributes like the `.c` attribute
    as well as methods like `.select()` is now deprecated, as they imply implicit
    production of a subquery. The `.join()` and `.outerjoin()` methods are now [repurposed
    to append JOIN criteria to the existing query](#change-select-join) in a similar
    way as that of [`Query.join()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join"), which is what users have always expected these methods
    to do in any case.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 由于[`SelectBase`](../core/selectable.html#sqlalchemy.sql.expression.SelectBase
    "sqlalchemy.sql.expression.SelectBase")对象不再是[`FromClause`](../core/selectable.html#sqlalchemy.sql.expression.FromClause
    "sqlalchemy.sql.expression.FromClause")对象，因此像`.c`属性和`.select()`方法这样的属性现在已被弃用，因为它们暗示着隐式生成子查询。`.join()`和`.outerjoin()`方法现在被重新用于在现有查询中添加JOIN条件，类似于[`Query.join()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join")的方式，这正是用户一直期望这些方法做的事情。
- en: 'In place of the `.c` attribute, a new attribute [`SelectBase.selected_columns`](../core/selectable.html#sqlalchemy.sql.expression.SelectBase.selected_columns
    "sqlalchemy.sql.expression.SelectBase.selected_columns") is added. This attribute
    resolves to a column collection that is what most people hope that `.c` does (but
    does not), which is to reference the columns that are in the columns clause of
    the SELECT statement. A common beginner mistake is code such as the following:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在`.c`属性的位置，添加了一个新属性[`SelectBase.selected_columns`](../core/selectable.html#sqlalchemy.sql.expression.SelectBase.selected_columns
    "sqlalchemy.sql.expression.SelectBase.selected_columns")。这个属性解析为一个列集合，大多数人希望`.c`做的事情（但实际上不是），即引用SELECT语句的列子句中的列。一个常见的初学者错误是以下代码：
- en: '[PRE16]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The above code appears intuitive and that it would generate “SELECT * FROM users
    WHERE name=’foo’”, however veteran SQLAlchemy users will recognize that it in
    fact generates a useless subquery resembling “SELECT * FROM (SELECT * FROM users)
    WHERE name=’foo’”.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码看起来很直观，似乎会生成“SELECT * FROM users WHERE name=’foo’”，然而，经验丰富的SQLAlchemy用户会意识到，实际上它生成了一个无用的子查询，类似于“SELECT
    * FROM (SELECT * FROM users) WHERE name=’foo’”。
- en: 'The new [`SelectBase.selected_columns`](../core/selectable.html#sqlalchemy.sql.expression.SelectBase.selected_columns
    "sqlalchemy.sql.expression.SelectBase.selected_columns") attribute however **does**
    suit the use case above, as in a case like the above it links directly to the
    columns present in the `users.c` collection:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，新的[`SelectBase.selected_columns`](../core/selectable.html#sqlalchemy.sql.expression.SelectBase.selected_columns
    "sqlalchemy.sql.expression.SelectBase.selected_columns")属性确实适用于上述用例，因为在上述情况下，它直接链接到`users.c`集合中存在的列：
- en: '[PRE17]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[#4617](https://www.sqlalchemy.org/trac/ticket/4617)  ### select().join() and
    outerjoin() add JOIN criteria to the current query, rather than creating a subquery'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4617](https://www.sqlalchemy.org/trac/ticket/4617)  ### select().join()和outerjoin()将JOIN条件添加到当前查询，而不是创建子查询'
- en: Towards the goal of unifying [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") and [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select"), particularly for [2.0 style](../glossary.html#term-2.0-style)
    use of [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select "sqlalchemy.sql.expression.Select"),
    it was critical that there be a working [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") method that behaves like the [`Query.join()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join") method, adding additional entries to the FROM clause
    of the existing SELECT and then returning the new [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") object for further modification, instead of
    wrapping the object inside of an unnamed subquery and returning a JOIN from that
    subquery, a behavior that has always been virtually useless and completely misleading
    to users.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现[2.0风格](../glossary.html#term-2.0-style)对[`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select")的使用，特别是统一[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")和[`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select")的目标，关键是有一个工作的[`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join")方法，其行为类似于[`Query.join()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join")方法，向现有SELECT的FROM子句添加额外条目，然后返回新的[`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select")对象以进行进一步修改，而不是将对象包装在未命名的子查询中并从该子查询返回JOIN，这种行为对用户来说一直是几乎无用和完全误导的。
- en: To allow this to be the case, [A SELECT statement is no longer implicitly considered
    to be a FROM clause](#change-4617) was first implemented which splits off [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") from having to be a [`FromClause`](../core/selectable.html#sqlalchemy.sql.expression.FromClause
    "sqlalchemy.sql.expression.FromClause"); this removed the requirement that [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") would need to return a [`Join`](../core/selectable.html#sqlalchemy.sql.expression.Join
    "sqlalchemy.sql.expression.Join") object rather than a new version of that [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") object that includes a new JOIN in its FROM
    clause.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，[不再将SELECT语句隐式视为FROM子句](#change-4617)首先实现了这一点，将[`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select")从必须是[`FromClause`](../core/selectable.html#sqlalchemy.sql.expression.FromClause
    "sqlalchemy.sql.expression.FromClause")中分离出来；这消除了[`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join")需要返回一个[`Join`](../core/selectable.html#sqlalchemy.sql.expression.Join
    "sqlalchemy.sql.expression.Join")对象而不是包含新JOIN的FROM子句的新版本[`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select")对象的要求。
- en: From that point on, as the [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") and [`Select.outerjoin()`](../core/selectable.html#sqlalchemy.sql.expression.Select.outerjoin
    "sqlalchemy.sql.expression.Select.outerjoin") did have an existing behavior, the
    original plan was that these methods would be deprecated, and the new “useful”
    version of the methods would be available on an alternate, “future” [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") object available as a separate import.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 从那时起，由于[`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join")和[`Select.outerjoin()`](../core/selectable.html#sqlalchemy.sql.expression.Select.outerjoin
    "sqlalchemy.sql.expression.Select.outerjoin")具有现有行为，最初的计划是这些方法将被弃用，并且这些方法的新“有用”版本将在一个备用的“未来”[`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select")对象上作为单独的导入可用。
- en: However, after some time working with this particular codebase, it was decided
    that having two different kinds of [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") objects floating around, each with 95% the
    same behavior except for some subtle difference in how some of the methods behave
    was going to be more misleading and inconvenient than simply making a hard change
    in how these two methods behave, given that the existing behavior of [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") and [`Select.outerjoin()`](../core/selectable.html#sqlalchemy.sql.expression.Select.outerjoin
    "sqlalchemy.sql.expression.Select.outerjoin") is essentially never used and only
    causes confusion.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在与这个特定代码库一段时间后，决定有两种不同类型的[`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select")对象漂浮在周围，每个对象的行为几乎相同，只是某些方法的行为略有不同，这将比简单地改变这两种方法的行为更具误导性和不便，因为[`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") 和 [`Select.outerjoin()`](../core/selectable.html#sqlalchemy.sql.expression.Select.outerjoin
    "sqlalchemy.sql.expression.Select.outerjoin") 的现有行为基本上从未被使用，只会引起混乱。
- en: So it was decided, given how very useless the current behavior is, and how extremely
    useful and important and useful the new behavior would be, to make a **hard behavioral
    change** in this one area, rather than waiting another year and having a more
    awkward API in the interim. SQLAlchemy developers do not take it lightly to make
    a completely breaking change like this, however this is a very special case and
    it is extremely unlikely that the previous implementation of these methods was
    being used; as noted in [A SELECT statement is no longer implicitly considered
    to be a FROM clause](#change-4617), major databases such as MySQL and PostgreSQL
    don’t allow for unnamed subqueries in any case and from a syntactical point of
    view it’s nearly impossible for a JOIN from an unnamed subquery to be useful since
    it’s very difficult to refer to the columns within it unambiguously.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，决定在这个领域做出**严格的行为改变**，而不是等待另一年并在此期间拥有更尴尬的 API，考虑到当前行为是多么无用，新行为将会是多么极其有用和重要。SQLAlchemy
    开发人员并不轻易做出像这样完全破坏性的改变，然而这是一个非常特殊的情况，以前的这些方法实现几乎不太可能被使用；正如在 [SELECT 语句不再隐式视为 FROM
    子句](#change-4617) 中所指出的，主要数据库如 MySQL 和 PostgreSQL 在任何情况下都不允许未命名的子查询，并且从语法角度来看，从未命名的子查询进行
    JOIN 几乎是不可能有用的，因为很难明确地引用其中的列。
- en: 'With the new implementation, [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") and [`Select.outerjoin()`](../core/selectable.html#sqlalchemy.sql.expression.Select.outerjoin
    "sqlalchemy.sql.expression.Select.outerjoin") now behave very similarly to that
    of [`Query.join()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.join "sqlalchemy.orm.Query.join"),
    adding JOIN criteria to the existing statement by matching to the left entity:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 使用新的实现方式，[`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") 和 [`Select.outerjoin()`](../core/selectable.html#sqlalchemy.sql.expression.Select.outerjoin
    "sqlalchemy.sql.expression.Select.outerjoin") 现在的行为与 [`Query.join()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join") 非常相似，通过匹配左实体来向现有语句添加 JOIN 条件：
- en: '[PRE18]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'producing:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 产生：
- en: '[PRE19]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As is the case for [`Join`](../core/selectable.html#sqlalchemy.sql.expression.Join
    "sqlalchemy.sql.expression.Join"), the ON clause is automatically determined if
    feasible:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 与 [`Join`](../core/selectable.html#sqlalchemy.sql.expression.Join "sqlalchemy.sql.expression.Join")
    一样，如果可行，ON 子句将自动确定：
- en: '[PRE20]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'When ORM entities are used in the statement, this is essentially how ORM queries
    are built up using [2.0 style](../glossary.html#term-2.0-style) invocation. ORM
    entities will assign a “plugin” to the statement internally such that ORM-related
    compilation rules will take place when the statement is compiled into a SQL string.
    More directly, the [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") method can accommodate ORM relationships,
    without breaking the hard separation between Core and ORM internals:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当在语句中使用 ORM 实体时，这基本上是使用 [2.0 风格](../glossary.html#term-2.0-style) 调用构建 ORM 查询的方式。ORM
    实体将在语句内部分配一个“插件”，以便在将语句编译成 SQL 字符串时发生 ORM 相关的编译规则。更直接地说，[`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") 方法可以适应 ORM 关系，而不会破坏 Core 和 ORM 内部之间的严格分离：
- en: '[PRE21]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Another new method [`Select.join_from()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join_from
    "sqlalchemy.sql.expression.Select.join_from") is also added, which allows easier
    specification of the left and right side of a join at once:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个新方法[`Select.join_from()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join_from
    "sqlalchemy.sql.expression.Select.join_from")也被添加，它允许更容易地一次性指定连接的左侧和右侧：
- en: '[PRE22]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'producing:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 产生：
- en: '[PRE23]  ### The URL object is now immutable'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE23]  ### URL 对象现在是不可变的'
- en: The [`URL`](../core/engines.html#sqlalchemy.engine.URL "sqlalchemy.engine.URL")
    object has been formalized such that it now presents itself as a `namedtuple`
    with a fixed number of fields that are immutable. In addition, the dictionary
    represented by the [`URL.query`](../core/engines.html#sqlalchemy.engine.URL.query
    "sqlalchemy.engine.URL.query") attribute is also an immutable mapping. Mutation
    of the [`URL`](../core/engines.html#sqlalchemy.engine.URL "sqlalchemy.engine.URL")
    object was not a formally supported or documented use case which led to some open-ended
    use cases that made it very difficult to intercept incorrect usages, most commonly
    mutation of the [`URL.query`](../core/engines.html#sqlalchemy.engine.URL.query
    "sqlalchemy.engine.URL.query") dictionary to include non-string elements. It also
    led to all the common problems of allowing mutability in a fundamental data object,
    namely unwanted mutations elsewhere leaking into code that didn’t expect the URL
    to change. Finally, the namedtuple design is inspired by that of Python’s `urllib.parse.urlparse()`
    which returns the parsed object as a named tuple.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '[`URL`](../core/engines.html#sqlalchemy.engine.URL "sqlalchemy.engine.URL")对象已经被正式规范化，现在它呈现为一个带有固定数量字段的不可变的`namedtuple`。此外，由[`URL.query`](../core/engines.html#sqlalchemy.engine.URL.query
    "sqlalchemy.engine.URL.query")属性表示的字典也是一个不可变映射。变异[`URL`](../core/engines.html#sqlalchemy.engine.URL
    "sqlalchemy.engine.URL")对象不是一个正式支持或记录的用例，这导致了一些开放式用例，使得很难拦截不正确的用法，最常见的是变异[`URL.query`](../core/engines.html#sqlalchemy.engine.URL.query
    "sqlalchemy.engine.URL.query")字典以包含非字符串元素。它还导致了在一个基本数据对象中允许可变性的所有常见问题，即不希望的变异泄漏到未预期
    URL 会发生变化的代码中。最后，`namedtuple` 的设计灵感来自 Python 的`urllib.parse.urlparse()`，它将解析后的对象作为一个命名元组返回。'
- en: The decision to change the API outright is based on a calculus weighing the
    infeasibility of a deprecation path (which would involve changing the [`URL.query`](../core/engines.html#sqlalchemy.engine.URL.query
    "sqlalchemy.engine.URL.query") dictionary to be a special dictionary that emits
    deprecation warnings when any kind of standard library mutation methods are invoked,
    in addition that when the dictionary would hold any kind of list of elements,
    the list would also have to emit deprecation warnings on mutation) against the
    unlikely use case of projects already mutating [`URL`](../core/engines.html#sqlalchemy.engine.URL
    "sqlalchemy.engine.URL") objects in the first place, as well as that small changes
    such as that of [#5341](https://www.sqlalchemy.org/trac/ticket/5341) were creating
    backwards-incompatibility in any case. The primary case for mutation of a [`URL`](../core/engines.html#sqlalchemy.engine.URL
    "sqlalchemy.engine.URL") object is that of parsing plugin arguments within the
    [`CreateEnginePlugin`](../core/connections.html#sqlalchemy.engine.CreateEnginePlugin
    "sqlalchemy.engine.CreateEnginePlugin") extension point, itself a fairly recent
    addition that based on Github code search is in use by two repositories, neither
    of which are actually mutating the URL object.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 决定彻底更改 API 的基础是根据一个计算，权衡了无法实现逐步废弃路径（这将涉及更改[`URL.query`](../core/engines.html#sqlalchemy.engine.URL.query
    "sqlalchemy.engine.URL.query")字典为一个特殊字典，当调用任何标准库变异方法时会发出废弃警告，此外，当字典保存任何元素列表时，列表也必须在变异时发出废弃警告）与项目已经在第一次变异[`URL`](../core/engines.html#sqlalchemy.engine.URL
    "sqlalchemy.engine.URL")对象的不太可能使用案例相比，以及像[#5341](https://www.sqlalchemy.org/trac/ticket/5341)这样的小变化在任何情况下都会造成向后不兼容性。对于变异[`URL`](../core/engines.html#sqlalchemy.engine.URL
    "sqlalchemy.engine.URL")对象的主要案例是在[`CreateEnginePlugin`](../core/connections.html#sqlalchemy.engine.CreateEnginePlugin
    "sqlalchemy.engine.CreateEnginePlugin")扩展点内解析插件参数，这本身是一个相当新的添加，根据 Github 代码搜索的结果，有两个仓库在使用，但实际上都没有变异
    URL 对象。
- en: 'The [`URL`](../core/engines.html#sqlalchemy.engine.URL "sqlalchemy.engine.URL")
    object now provides a rich interface inspecting and generating new [`URL`](../core/engines.html#sqlalchemy.engine.URL
    "sqlalchemy.engine.URL") objects. The existing mechanism to create a [`URL`](../core/engines.html#sqlalchemy.engine.URL
    "sqlalchemy.engine.URL") object, the [`make_url()`](../core/engines.html#sqlalchemy.engine.make_url
    "sqlalchemy.engine.make_url") function, remains unchanged:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '[`URL`](../core/engines.html#sqlalchemy.engine.URL "sqlalchemy.engine.URL")对象现在提供了检查和生成新的[`URL`](../core/engines.html#sqlalchemy.engine.URL
    "sqlalchemy.engine.URL")对象的丰富接口。创建[`URL`](../core/engines.html#sqlalchemy.engine.URL
    "sqlalchemy.engine.URL")对象的现有机制，即[`make_url()`](../core/engines.html#sqlalchemy.engine.make_url
    "sqlalchemy.engine.make_url")函数，保持不变：'
- en: '[PRE24]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'For programmatic construction, code that may have been using the [`URL`](../core/engines.html#sqlalchemy.engine.URL
    "sqlalchemy.engine.URL") constructor or `__init__` method directly will receive
    a deprecation warning if arguments are passed as keyword arguments and not an
    exact 7-tuple. The keyword-style constructor is now available via the [`URL.create()`](../core/engines.html#sqlalchemy.engine.URL.create
    "sqlalchemy.engine.URL.create") method:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 对于编程构造，如果代码可能直接使用[`URL`](../core/engines.html#sqlalchemy.engine.URL "sqlalchemy.engine.URL")构造函数或`__init__`方法，如果参数作为关键字参数而不是精确的7元组传递，将收到弃用警告。现在可以通过[`URL.create()`](../core/engines.html#sqlalchemy.engine.URL.create
    "sqlalchemy.engine.URL.create")方法使用关键字样式的构造函数：
- en: '[PRE25]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Fields can be altered typically using the [`URL.set()`](../core/engines.html#sqlalchemy.engine.URL.set
    "sqlalchemy.engine.URL.set") method, which returns a new [`URL`](../core/engines.html#sqlalchemy.engine.URL
    "sqlalchemy.engine.URL") object with changes applied:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 通常可以使用[`URL.set()`](../core/engines.html#sqlalchemy.engine.URL.set "sqlalchemy.engine.URL.set")方法更改字段，该方法返回一个应用更改后的新[`URL`](../core/engines.html#sqlalchemy.engine.URL
    "sqlalchemy.engine.URL")对象：
- en: '[PRE26]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'To alter the contents of the [`URL.query`](../core/engines.html#sqlalchemy.engine.URL.query
    "sqlalchemy.engine.URL.query") dictionary, methods such as [`URL.update_query_dict()`](../core/engines.html#sqlalchemy.engine.URL.update_query_dict
    "sqlalchemy.engine.URL.update_query_dict") may be used:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改[`URL.query`](../core/engines.html#sqlalchemy.engine.URL.query "sqlalchemy.engine.URL.query")字典的内容，可以使用诸如[`URL.update_query_dict()`](../core/engines.html#sqlalchemy.engine.URL.update_query_dict
    "sqlalchemy.engine.URL.update_query_dict")之类的方法：
- en: '[PRE27]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'To upgrade code that is mutating these fields directly, a **backwards and forwards
    compatible approach** is to use a duck-typing, as in the following style:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 要升级直接突变这些字段的代码，一个**向后和向前兼容的方法**是使用鸭子类型，如下所示：
- en: '[PRE28]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The query string retains its existing format as a dictionary of strings to
    strings, using sequences of strings to represent multiple parameters. For example:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 查询字符串保留其现有格式，作为字符串到字符串的字典，使用字符串序列表示多个参数。例如：
- en: '[PRE29]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'To work with the contents of the [`URL.query`](../core/engines.html#sqlalchemy.engine.URL.query
    "sqlalchemy.engine.URL.query") attribute such that all values are normalized into
    sequences, use the [`URL.normalized_query`](../core/engines.html#sqlalchemy.engine.URL.normalized_query
    "sqlalchemy.engine.URL.normalized_query") attribute:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 要处理[`URL.query`](../core/engines.html#sqlalchemy.engine.URL.query "sqlalchemy.engine.URL.query")属性的内容，使所有值都归一化为序列，请使用[`URL.normalized_query`](../core/engines.html#sqlalchemy.engine.URL.normalized_query
    "sqlalchemy.engine.URL.normalized_query")属性：
- en: '[PRE30]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The query string can be appended to via methods such as [`URL.update_query_dict()`](../core/engines.html#sqlalchemy.engine.URL.update_query_dict
    "sqlalchemy.engine.URL.update_query_dict"), [`URL.update_query_pairs()`](../core/engines.html#sqlalchemy.engine.URL.update_query_pairs
    "sqlalchemy.engine.URL.update_query_pairs"), [`URL.update_query_string()`](../core/engines.html#sqlalchemy.engine.URL.update_query_string
    "sqlalchemy.engine.URL.update_query_string"):'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 查询字符串可以通过[`URL.update_query_dict()`](../core/engines.html#sqlalchemy.engine.URL.update_query_dict
    "sqlalchemy.engine.URL.update_query_dict")、[`URL.update_query_pairs()`](../core/engines.html#sqlalchemy.engine.URL.update_query_pairs
    "sqlalchemy.engine.URL.update_query_pairs")、[`URL.update_query_string()`](../core/engines.html#sqlalchemy.engine.URL.update_query_string
    "sqlalchemy.engine.URL.update_query_string")等方法进行追加：
- en: '[PRE31]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: See also
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`URL`](../core/engines.html#sqlalchemy.engine.URL "sqlalchemy.engine.URL")'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '[`URL`](../core/engines.html#sqlalchemy.engine.URL "sqlalchemy.engine.URL")'
- en: Changes to CreateEnginePlugin
  id: totrans-190
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 对CreateEnginePlugin的更改
- en: 'The [`CreateEnginePlugin`](../core/connections.html#sqlalchemy.engine.CreateEnginePlugin
    "sqlalchemy.engine.CreateEnginePlugin") is also impacted by this change, as the
    documentation for custom plugins indicated that the `dict.pop()` method should
    be used to remove consumed arguments from the URL object. This should now be achieved
    using the [`CreateEnginePlugin.update_url()`](../core/connections.html#sqlalchemy.engine.CreateEnginePlugin.update_url
    "sqlalchemy.engine.CreateEnginePlugin.update_url") method. A backwards compatible
    approach would look like:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '[`CreateEnginePlugin`](../core/connections.html#sqlalchemy.engine.CreateEnginePlugin
    "sqlalchemy.engine.CreateEnginePlugin") 也受到这一变化的影响，因为自定义插件的文档指出应该使用`dict.pop()`方法从URL对象中删除已使用的参数。现在应该使用[`CreateEnginePlugin.update_url()`](../core/connections.html#sqlalchemy.engine.CreateEnginePlugin.update_url
    "sqlalchemy.engine.CreateEnginePlugin.update_url") 方法来实现。向后兼容的方法如下：'
- en: '[PRE32]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: See the docstring at [`CreateEnginePlugin`](../core/connections.html#sqlalchemy.engine.CreateEnginePlugin
    "sqlalchemy.engine.CreateEnginePlugin") for complete details on how this class
    is used.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 查看[`CreateEnginePlugin`](../core/connections.html#sqlalchemy.engine.CreateEnginePlugin
    "sqlalchemy.engine.CreateEnginePlugin")的文档字符串，了解如何使用该类的完整详细信息。
- en: '[#5526](https://www.sqlalchemy.org/trac/ticket/5526)  ### select(), case()
    now accept positional expressions'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '[#5526](https://www.sqlalchemy.org/trac/ticket/5526)  ### select(), case()
    现在接受位置表达式'
- en: 'As it may be seen elsewhere in this document, the [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") construct will now accept “columns clause”
    arguments positionally, rather than requiring they be passed as a list:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本文档中的其他地方所示，[`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") 构造现在将接受“columns clause”参数作为位置参数，而不需要将它们作为列表传递：
- en: '[PRE33]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: When sending the arguments positionally, no other keyword arguments are permitted.
    In SQLAlchemy 2.0, the above calling style will be the only calling style supported.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在将参数作为位置参数发送时，不允许其他关键字参数。在SQLAlchemy 2.0中，上述调用风格将是唯一支持的调用风格。
- en: 'For the duration of 1.4, the previous calling style will still continue to
    function, which passes the list of columns or other expressions as a list:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在1.4版本期间，先前的调用风格仍将继续运行，将列或其他表达式的列表作为列表传递：
- en: '[PRE34]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The above legacy calling style also accepts the old keyword arguments that
    have since been removed from most narrative documentation. The existence of these
    keyword arguments is why the columns clause was passed as a list in the first
    place:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 上述传统调用风格还接受自那时起已从大多数叙述文档中删除的旧关键字参数。这些关键字参数的存在是为什么首先将columns clause作为列表传递的原因：
- en: '[PRE35]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The detection between the two styles is based on whether or not the first positional
    argument is a list. There are unfortunately still likely some usages that look
    like the following, where the keyword for the “whereclause” is omitted:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 两种风格之间的区别在于第一个位置参数是否为列表。不幸的是，仍然可能存在一些使用情况看起来像以下这样，其中“whereclause”的关键字被省略：
- en: '[PRE36]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: As part of this change, the [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") construct also gains the 2.0-style “future”
    API which includes an updated [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") method as well as methods like [`Select.filter_by()`](../core/selectable.html#sqlalchemy.sql.expression.Select.filter_by
    "sqlalchemy.sql.expression.Select.filter_by") and [`Select.join_from()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join_from
    "sqlalchemy.sql.expression.Select.join_from").
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 作为这一变化的一部分，[`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") 构造还获得了2.0风格的“future” API，其中包括更新的[`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join")方法以及诸如[`Select.filter_by()`](../core/selectable.html#sqlalchemy.sql.expression.Select.filter_by
    "sqlalchemy.sql.expression.Select.filter_by")和[`Select.join_from()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join_from
    "sqlalchemy.sql.expression.Select.join_from")等方法。
- en: 'In a related change, the [`case()`](../core/sqlelement.html#sqlalchemy.sql.expression.case
    "sqlalchemy.sql.expression.case") construct has also been modified to accept its
    list of WHEN clauses positionally, with a similar deprecation track for the old
    calling style:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在相关更改中，[`case()`](../core/sqlelement.html#sqlalchemy.sql.expression.case "sqlalchemy.sql.expression.case")
    构造也已经修改为接受其WHEN子句的列表作为位置参数，旧调用风格也有类似的弃用轨迹：
- en: '[PRE37]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The convention for SQLAlchemy constructs accepting `*args` vs. a list of values,
    as is the latter case for a construct like [`ColumnOperators.in_()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.in_
    "sqlalchemy.sql.expression.ColumnOperators.in_"), is that **positional arguments
    are used for structural specification, lists are used for data specification**.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 对于SQLAlchemy构造函数接受`*args`与接受值列表的约定，例如[`ColumnOperators.in_()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.in_
    "sqlalchemy.sql.expression.ColumnOperators.in_")这样的构造函数，**位置参数用于结构规范，列表用于数据规范**。
- en: See also
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[select() no longer accepts varied constructor arguments, columns are passed
    positionally](migration_20.html#migration-20-5284)'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '[select()不再接受各种构造函数参数，列按位置传递](migration_20.html#migration-20-5284)'
- en: '[select() construct created in “legacy” mode; keyword arguments, etc.](../errors.html#error-c9ae)'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '[在“遗留”模式中创建的select()构造函数；关键字参数等。](../errors.html#error-c9ae)'
- en: '[#5284](https://www.sqlalchemy.org/trac/ticket/5284)  ### All IN expressions
    render parameters for each value in the list on the fly (e.g. expanding parameters)'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '[#5284](https://www.sqlalchemy.org/trac/ticket/5284)  ### 所有IN表达式都会动态生成列表中每个值的参数（例如，扩展参数）'
- en: The “expanding IN” feature, first introduced in [Late-expanded IN parameter
    sets allow IN expressions with cached statements](migration_12.html#change-3953),
    has matured enough such that it is clearly superior to the previous method of
    rendering IN expressions. As the approach was improved to handle empty lists of
    values, it is now the only means that Core / ORM will use to render lists of IN
    parameters.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: “扩展IN”功能首次在 [晚扩展的IN参数集允许带有缓存语句的IN表达式](migration_12.html#change-3953) 中引入，已经成熟到足以清楚地优于以前的渲染IN表达式的方法。随着该方法被改进以处理空值列表，它现在是Core
    / ORM用于渲染IN参数列表的唯一手段。
- en: The previous approach which has been present in SQLAlchemy since its first release
    was that when a list of values were passed to the [`ColumnOperators.in_()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.in_
    "sqlalchemy.sql.expression.ColumnOperators.in_") method, the list would be expanded
    into a series of individual [`BindParameter`](../core/sqlelement.html#sqlalchemy.sql.expression.BindParameter
    "sqlalchemy.sql.expression.BindParameter") objects at statement construction time.
    This suffered from the limitation that it was not possible to vary the parameter
    list at statement execution time based on the parameter dictionary, which meant
    that string SQL statements could not be cached independently of their parameters,
    nor could the parameter dictionary be fully used for statements that included
    IN expressions generally.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy自首次发布以来一直存在的先前方法是，当将值列表传递给[`ColumnOperators.in_()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.in_
    "sqlalchemy.sql.expression.ColumnOperators.in_")方法时，该列表将在语句构造时扩展为一系列单独的[`BindParameter`](../core/sqlelement.html#sqlalchemy.sql.expression.BindParameter
    "sqlalchemy.sql.expression.BindParameter")对象。这种方法的局限性在于无法根据参数字典在语句执行时变化参数列表，这意味着无法独立缓存字符串SQL语句及其参数，也不能完全使用参数字典来处理通常包含IN表达式的语句。
- en: In order to service the “baked query” feature described at [Baked Queries](../orm/extensions/baked.html),
    a cacheable version of IN was needed, which is what brought about the “expanding
    IN” feature. In contrast to the existing behavior whereby the parameter list is
    expanded at statement construction time into individual [`BindParameter`](../core/sqlelement.html#sqlalchemy.sql.expression.BindParameter
    "sqlalchemy.sql.expression.BindParameter") objects, the feature instead uses a
    single [`BindParameter`](../core/sqlelement.html#sqlalchemy.sql.expression.BindParameter
    "sqlalchemy.sql.expression.BindParameter") that stores the list of values at once;
    when the statement is executed by the [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine"), it is “expanded” on the fly into individual bound
    parameter positions based on the parameters passed to the call to [`Connection.execute()`](../core/connections.html#sqlalchemy.engine.Connection.execute
    "sqlalchemy.engine.Connection.execute"), and the existing SQL string which may
    have been retrieved from a previous execution is modified using a regular expression
    to suit the current parameter set. This allows for the same [`Compiled`](../core/internals.html#sqlalchemy.engine.Compiled
    "sqlalchemy.engine.Compiled") object, which stores the rendered string statement,
    to be invoked multiple times against different parameter sets that modify the
    list contents passed to IN expressions, while still maintaining the behavior of
    individual scalar parameters being passed to the DBAPI. While some DBAPIs do support
    this functionality directly, it is not generally available; the “expanding IN”
    feature now supports the behavior consistently for all backends.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 为了服务于[Baked Queries](../orm/extensions/baked.html)描述的“烘焙查询”功能，需要一个可缓存版本的IN，这就引入了“扩展IN”功能。与现有行为相反，现有行为是在语句构造时将参数列表展开为单独的[`BindParameter`](../core/sqlelement.html#sqlalchemy.sql.expression.BindParameter
    "sqlalchemy.sql.expression.BindParameter")对象，该功能使用一个存储一次性值列表的[`BindParameter`](../core/sqlelement.html#sqlalchemy.sql.expression.BindParameter
    "sqlalchemy.sql.expression.BindParameter")；当由[`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine")执行语句时，它会根据传递给[`Connection.execute()`](../core/connections.html#sqlalchemy.engine.Connection.execute
    "sqlalchemy.engine.Connection.execute")调用的参数，并根据以前执行时可能已经检索到的现有SQL字符串，使用正则表达式对其进行修改，以适应当前参数集。这允许相同的[`Compiled`](../core/internals.html#sqlalchemy.engine.Compiled
    "sqlalchemy.engine.Compiled")对象，该对象存储渲染的字符串语句，根据修改IN表达式的传递给多次调用的参数集，同时仍然保持将单个标量参数传递给DBAPI的行为。虽然某些DBAPI直接支持此功能，但通常不可用；“扩展IN”功能现在为所有后端一致地支持行为。
- en: 'As a major focus of 1.4 is to allow for true statement caching in Core and
    ORM without the awkwardness of the “baked” system, and since the “expanding IN”
    feature represents a simpler approach to building expressions in any case, it’s
    now invoked automatically whenever a list of values is passed to an IN expression:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 1.4的主要重点是在Core和ORM中允许真正的语句缓存，而不需要“烘焙”系统的笨拙性，而且由于“扩展IN”功能代表了构建表达式的更简单方法，所以现在在传递值列表给IN表达式时自动调用它：
- en: '[PRE38]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The pre-execution string representation is:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 预执行字符串表示如下：
- en: '[PRE39]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'To render the values directly, use `literal_binds` as was the case previously:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 要直接渲染值，请像以前一样使用`literal_binds`：
- en: '[PRE40]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'A new flag, “render_postcompile”, is added as a helper to allow the current
    bound value to be rendered as it would be passed to the database:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 添加了一个新标志，“render_postcompile”，作为帮助器，允许将当前绑定的值渲染为将要传递给数据库的样子：
- en: '[PRE41]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Engine logging output shows the ultimate rendered statement as well:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 引擎日志输出还显示了最终的渲染语句：
- en: '[PRE42]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: As part of this change, the behavior of “empty IN” expressions, where the list
    parameter is empty, is now standardized on use of the IN operator against a so-called
    “empty set”. As there is no standard SQL syntax for empty sets, a SELECT that
    returns no rows is used, tailored in specific ways for each backend so that the
    database treats it as an empty set; this feature was first introduced in version
    1.3 and is described at [Expanding IN feature now supports empty lists](migration_13.html#change-4271).
    The [`create_engine.empty_in_strategy`](../core/engines.html#sqlalchemy.create_engine.params.empty_in_strategy
    "sqlalchemy.create_engine") parameter, introduced in version 1.2 as a means for
    migrating for how this case was treated for the previous IN system, is now deprecated
    and this flag no longer has an effect; as described in [The IN / NOT IN operator’s
    empty collection behavior is now configurable; default expression simplified](migration_12.html#change-3907),
    this flag allowed a dialect to switch between the original system of comparing
    a column against itself, which turned out to be a huge performance issue, and
    a newer system of comparing “1 != 1” in order to produce a “false” expression.
    The 1.3 introduced behavior which now takes place in all cases is more correct
    than both approaches as the IN operator is still used, and does not have the performance
    issue of the original system.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 作为这一变化的一部分，“空 IN”表达式的行为，其中列表参数为空，现在已经标准化为使用 IN 运算符针对所谓的“空集合”。由于没有空集合的标准 SQL
    语法，因此使用返回零行的 SELECT，针对每个后端进行特定方式的定制，以便数据库将其视为空集合；此功能首次在版本 1.3 中引入，并在 [扩展 IN 功能现在支持空列表](migration_13.html#change-4271)
    中进行了描述。在版本 1.2 中引入的 [`create_engine.empty_in_strategy`](../core/engines.html#sqlalchemy.create_engine.params.empty_in_strategy
    "sqlalchemy.create_engine") 参数，作为迁移以前 IN 系统处理方式的手段，现已被弃用，此标志不再起作用；如 [IN / NOT
    IN 运算符的空集合行为现在可配置；默认表达式简化](migration_12.html#change-3907) 中所述，此标志允许方言在原始系统比较列与自身的情况下切换，这种情况被证明是一个巨大的性能问题，以及比较“1
    != 1” 以产生“false”表达式的新系统。1.3 引入的行为现在在所有情况下都更为正确，比两种方法都更为正确，因为仍然使用 IN 运算符，并且不具有原始系统的性能问题。
- en: In addition, the “expanding” parameter system has been generalized so that it
    also services other dialect-specific use cases where a parameter cannot be accommodated
    by the DBAPI or backing database; see [New “post compile” bound parameters used
    for LIMIT/OFFSET in Oracle, SQL Server](#change-4808) for details.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，“扩展”参数系统已经泛化，以便还可以服务于其他特定于方言的用例，其中参数无法被 DBAPI 或后端数据库容纳；有关详细信息，请参见 [Oracle、SQL
    Server 中用于 LIMIT/OFFSET 的新“编译后”绑定参数](#change-4808)。
- en: See also
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[New “post compile” bound parameters used for LIMIT/OFFSET in Oracle, SQL Server](#change-4808)'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '[Oracle、SQL Server 中用于 LIMIT/OFFSET 的新“编译后”绑定参数](#change-4808)'
- en: '[Expanding IN feature now supports empty lists](migration_13.html#change-4271)'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '[扩展 IN 功能现在支持空列表](migration_13.html#change-4271)'
- en: '[`BindParameter`](../core/sqlelement.html#sqlalchemy.sql.expression.BindParameter
    "sqlalchemy.sql.expression.BindParameter")'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '[`BindParameter`](../core/sqlelement.html#sqlalchemy.sql.expression.BindParameter
    "sqlalchemy.sql.expression.BindParameter")'
- en: '[#4645](https://www.sqlalchemy.org/trac/ticket/4645)  ### Built-in FROM linting
    will warn for any potential cartesian products in a SELECT statement'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4645](https://www.sqlalchemy.org/trac/ticket/4645)  ### 内置 FROM 代码检查将警告任何
    SELECT 语句中可能存在的笛卡尔积。'
- en: As the Core expression language as well as the ORM are built on an “implicit
    FROMs” model where a particular FROM clause is automatically added if any part
    of the query refers to it, a common issue is the case where a SELECT statement,
    either a top level statement or an embedded subquery, contains FROM elements that
    are not joined to the rest of the FROM elements in the query, causing what’s referred
    to as a “cartesian product” in the result set, i.e. every possible combination
    of rows from each FROM element not otherwise joined. In relational databases,
    this is nearly always an undesirable outcome as it produces an enormous result
    set full of duplicated, uncorrelated data.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 由于核心表达语言以及 ORM 建立在“隐式 FROMs”模型上，如果查询的任何部分引用了特定的 FROM 子句，那么该子句会自动添加，一个常见问题是 SELECT
    语句的情况，无论是顶层语句还是嵌套子查询，包含了未与查询中的其他 FROM 元素连接的 FROM 元素，导致结果集中出现所谓的“笛卡尔积”，即每个未连接的
    FROM 元素之间的所有可能行的组合。在关系数据库中，这几乎总是一个不良结果，因为它会产生一个充满重复、不相关数据的巨大结果集。
- en: 'SQLAlchemy, for all of its great features, is particularly prone to this sort
    of issue happening as a SELECT statement will have elements added to its FROM
    clause automatically from any table seen in the other clauses. A typical scenario
    looks like the following, where two tables are JOINed together, however an additional
    entry in the WHERE clause that perhaps inadvertently does not line up with these
    two tables will create an additional FROM entry:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy，尽管具有许多出色的功能，但特别容易出现这种问题，因为SELECT语句会自动从其他子句中看到的任何表中添加元素到其FROM子句中。一个典型的情况如下，其中两个表被JOIN在一起，然而在WHERE子句中可能无意中与这两个表不匹配的额外条目将创建一个额外的FROM条目：
- en: '[PRE43]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The above query selects from a JOIN of `User` and `address_alias`, the latter
    of which is an alias of the `Address` entity. However, the `Address` entity is
    used within the WHERE clause directly, so the above would result in the SQL:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的查询从`User`和`address_alias`的JOIN中选择，后者是`Address`实体的别名。然而，`Address`实体在WHERE子句中直接使用，因此上述将导致SQL：
- en: '[PRE44]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In the above SQL, we can see what SQLAlchemy developers term “the dreaded comma”,
    as we see “FROM addresses, users JOIN addresses” in the FROM clause which is the
    classic sign of a cartesian product; where a query is making use of JOIN in order
    to join FROM clauses together, however because one of them is not joined, it uses
    a comma. The above query will return a full set of rows that join the “user” and
    “addresses” table together on the “id / user_id” column, and will then apply all
    those rows into a cartesian product against every row in the “addresses” table
    directly. That is, if there are ten user rows and 100 rows in addresses, the above
    query will return its expected result rows, likely to be 100 as all address rows
    would be selected, multiplied by 100 again, so that the total result size would
    be 10000 rows.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的SQL中，我们可以看到SQLAlchemy开发人员所谓的“可怕的逗号”，因为我们在FROM子句中看到“FROM addresses, users
    JOIN addresses”，这是笛卡尔积的经典迹象；查询正在使用JOIN来将FROM子句连接在一起，但是因为其中一个没有连接，它使用了逗号。上面的查询将返回一个完整的行集，将“user”和“addresses”表在“id
    / user_id”列上连接在一起，然后将所有这些行直接应用到“addresses”表中的每一行的笛卡尔积中。也就是说，如果有十个用户行和100个地址行，则上面的查询将返回其预期的结果行，可能为100，因为所有地址行都将被选择，再乘以100，因此总结果大小将为10000行。
- en: The “table1, table2 JOIN table3” pattern is one that also occurs quite frequently
    within the SQLAlchemy ORM due to either subtle mis-application of ORM features
    particularly those related to joined eager loading or joined table inheritance,
    as well as a result of SQLAlchemy ORM bugs within those same systems. Similar
    issues apply to SELECT statements that use “implicit joins”, where the JOIN keyword
    is not used and instead each FROM element is linked with another one via the WHERE
    clause.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: “table1, table2 JOIN table3”模式在SQLAlchemy ORM中也经常出现，这要归因于ORM功能的微妙错误应用，特别是与连接式急加载或连接式表继承相关的功能，以及由于SQLAlchemy
    ORM中的错误而导致的问题。类似的问题也适用于使用“隐式连接”的SELECT语句，其中不使用JOIN关键字，而是通过WHERE子句将每个FROM元素与另一个元素链接起来。
- en: For some years there has been a recipe on the Wiki that applies a graph algorithm
    to a [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select")
    construct at query execution time and inspects the structure of the query for
    these un-linked FROM clauses, parsing through the WHERE clause and all JOIN clauses
    to determine how FROM elements are linked together and ensuring that all the FROM
    elements are connected in a single graph. This recipe has now been adapted to
    be part of the [`SQLCompiler`](../core/internals.html#sqlalchemy.sql.compiler.SQLCompiler
    "sqlalchemy.sql.compiler.SQLCompiler") itself where it now optionally emits a
    warning for a statement if this condition is detected. The warning is enabled
    using the [`create_engine.enable_from_linting`](../core/engines.html#sqlalchemy.create_engine.params.enable_from_linting
    "sqlalchemy.create_engine") flag and is enabled by default. The computational
    overhead of the linter is very low, and additionally it only occurs during statement
    compilation which means for a cached SQL statement it only occurs once.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，维基上有一篇关于应用图算法到查询执行时的[`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select")构造的配方，并检查查询的结构以寻找这些未链接的FROM子句，解析WHERE子句和所有JOIN子句以确定FROM元素如何相互连接，并确保所有FROM元素在单个图中连接。这个配方现已被调整为成为[`SQLCompiler`](../core/internals.html#sqlalchemy.sql.compiler.SQLCompiler
    "sqlalchemy.sql.compiler.SQLCompiler")的一部分，现在如果检测到此条件，它现在可选择发出警告。该警告使用[`create_engine.enable_from_linting`](../core/engines.html#sqlalchemy.create_engine.params.enable_from_linting
    "sqlalchemy.create_engine")标志启用，并且默认启用。linter的计算开销非常低，而且它只发生在语句编译期间，这意味着对于缓存的SQL语句，它只会发生一次。
- en: 'Using this feature, our ORM query above will emit a warning:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此功能，我们上面的ORM查询将发出警告：
- en: '[PRE45]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The linter feature accommodates not just for tables linked together through
    the JOIN clauses but also through the WHERE clause Above, we can add a WHERE clause
    to link the new `Address` entity with the previous `address_alias` entity and
    that will remove the warning:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: linter功能不仅适用于通过JOIN子句连接在一起的表，还适用于通过WHERE子句如上，我们可以添加一个WHERE子句来将新的`Address`实体与之前的`address_alias`实体链接起来，这将消除警告：
- en: '[PRE46]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The cartesian product warning considers **any** kind of link between two FROM
    clauses to be a resolution, even if the end result set is still wasteful, as the
    linter is intended only to detect the common case of a FROM clause that is completely
    unexpected. If the FROM clause is referred to explicitly elsewhere and linked
    to the other FROMs, no warning is emitted:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 笛卡尔积警告认为两个FROM子句之间的**任何**链接都是一个解决方案，即使最终结果集仍然是低效的，因为linter仅用于检测完全意外的FROM子句的常见情况。如果FROM子句在其他地方被明确引用并链接到其他FROM子句，则不会发出警告：
- en: '[PRE47]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Full cartesian products are also allowed if they are explicitly stated; if
    we wanted for example the cartesian product of `User` and `Address`, we can JOIN
    on [`true()`](../core/sqlelement.html#sqlalchemy.sql.expression.true "sqlalchemy.sql.expression.true")
    so that every row will match with every other; the following query will return
    all rows and produce no warnings:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的笛卡尔积也是允许的，如果明确说明；例如，如果我们想要`User`和`Address`的笛卡尔积，我们可以在[`true()`](../core/sqlelement.html#sqlalchemy.sql.expression.true
    "sqlalchemy.sql.expression.true")上进行JOIN，以便每一行都与其他每一行匹配；以下查询将返回所有行并且不会产生警告：
- en: '[PRE48]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The warning is only generated by default when the statement is compiled by
    the [`Connection`](../core/connections.html#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    for execution; calling the [`ClauseElement.compile()`](../core/foundation.html#sqlalchemy.sql.expression.ClauseElement.compile
    "sqlalchemy.sql.expression.ClauseElement.compile") method will not emit a warning
    unless the linting flag is supplied:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，只有在语句由[`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")编译执行时才会生成警告；调用[`ClauseElement.compile()`](../core/foundation.html#sqlalchemy.sql.expression.ClauseElement.compile
    "sqlalchemy.sql.expression.ClauseElement.compile")方法不会发出警告，除非提供了 linting 标志：
- en: '[PRE49]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[#4737](https://www.sqlalchemy.org/trac/ticket/4737)  ### New Result object'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4737](https://www.sqlalchemy.org/trac/ticket/4737)  ### 新 Result 对象'
- en: A major goal of SQLAlchemy 2.0 is to unify how “results” are handled between
    the ORM and Core. Towards this goal, version 1.4 introduces new versions of both
    the `ResultProxy` and `RowProxy` objects that have been part of SQLAlchemy since
    the beginning.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 2.0 的一个主要目标是统一ORM和Core之间如何处理“结果”的方式。为实现这一目标，版本1.4引入了自SQLAlchemy开始就存在的`ResultProxy`和`RowProxy`对象的新版本。
- en: The new objects are documented at [`Result`](../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") and [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row"), and are used not only for Core result sets but for [2.0
    style](../glossary.html#term-2.0-style) results within the ORM as well.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 新对象的文档位于[`Result`](../core/connections.html#sqlalchemy.engine.Result "sqlalchemy.engine.Result")和[`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row")，不仅用于核心结果集，还用于ORM中的[2.0风格](../glossary.html#term-2.0-style)结果。
- en: 'This result object is fully compatible with `ResultProxy` and includes many
    new features, that are now applied to both Core and ORM results equally, including
    methods such as:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 此结果对象与`ResultProxy`完全兼容，并包括许多新功能，现在对核心和ORM结果均应用，包括诸如：
- en: '[`Result.one()`](../core/connections.html#sqlalchemy.engine.Result.one "sqlalchemy.engine.Result.one")
    - returns exactly a single row, or raises:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Result.one()`](../core/connections.html#sqlalchemy.engine.Result.one "sqlalchemy.engine.Result.one")
    - 返回确切的单行，或引发异常：'
- en: '[PRE50]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[`Result.one_or_none()`](../core/connections.html#sqlalchemy.engine.Result.one_or_none
    "sqlalchemy.engine.Result.one_or_none") - same, but also returns None for no rows'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Result.one_or_none()`](../core/connections.html#sqlalchemy.engine.Result.one_or_none
    "sqlalchemy.engine.Result.one_or_none") - 相同，但对于没有行也返回None'
- en: '[`Result.all()`](../core/connections.html#sqlalchemy.engine.Result.all "sqlalchemy.engine.Result.all")
    - returns all rows'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Result.all()`](../core/connections.html#sqlalchemy.engine.Result.all "sqlalchemy.engine.Result.all")
    - 返回所有行'
- en: '[`Result.partitions()`](../core/connections.html#sqlalchemy.engine.Result.partitions
    "sqlalchemy.engine.Result.partitions") - fetches rows in chunks:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Result.partitions()`](../core/connections.html#sqlalchemy.engine.Result.partitions
    "sqlalchemy.engine.Result.partitions") - 按块获取行：'
- en: '[PRE51]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[`Result.columns()`](../core/connections.html#sqlalchemy.engine.Result.columns
    "sqlalchemy.engine.Result.columns") - allows slicing and reorganizing of rows:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Result.columns()`](../core/connections.html#sqlalchemy.engine.Result.columns
    "sqlalchemy.engine.Result.columns") - 允许对行进行切片和重新组织：'
- en: '[PRE52]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[`Result.scalars()`](../core/connections.html#sqlalchemy.engine.Result.scalars
    "sqlalchemy.engine.Result.scalars") - returns lists of scalar objects, from the
    first column by default but can also be selected:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Result.scalars()`](../core/connections.html#sqlalchemy.engine.Result.scalars
    "sqlalchemy.engine.Result.scalars") - 返回标量对象的列表，默认从第一列开始，但也可以选择：'
- en: '[PRE53]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[`Result.mappings()`](../core/connections.html#sqlalchemy.engine.Result.mappings
    "sqlalchemy.engine.Result.mappings") - instead of named-tuple rows, returns dictionaries:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Result.mappings()`](../core/connections.html#sqlalchemy.engine.Result.mappings
    "sqlalchemy.engine.Result.mappings") - 而不是命名元组行，返回字典：'
- en: '[PRE54]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: When using Core, the object returned by [`Connection.execute()`](../core/connections.html#sqlalchemy.engine.Connection.execute
    "sqlalchemy.engine.Connection.execute") is an instance of [`CursorResult`](../core/connections.html#sqlalchemy.engine.CursorResult
    "sqlalchemy.engine.CursorResult"), which continues to feature the same API features
    as `ResultProxy` regarding inserted primary keys, defaults, rowcounts, etc. For
    ORM, a [`Result`](../core/connections.html#sqlalchemy.engine.Result "sqlalchemy.engine.Result")
    subclass will be returned that performs translation of Core rows into ORM rows,
    and then allows all the same operations to take place.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用核心时，由[`Connection.execute()`](../core/connections.html#sqlalchemy.engine.Connection.execute
    "sqlalchemy.engine.Connection.execute")返回的对象是[`CursorResult`](../core/connections.html#sqlalchemy.engine.CursorResult
    "sqlalchemy.engine.CursorResult")的实例，其继续具有与`ResultProxy`相同的API功能，关于插入的主键、默认值、行数等。对于ORM，将返回[`Result`](../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result")的子类，执行核心行到ORM行的转换，然后允许进行所有相同的操作。
- en: See also
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[ORM Query Unified with Core Select](migration_20.html#migration-20-unify-select)
    - in the 2.0 migration documentation'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '[ORM查询与核心选择统一](migration_20.html#migration-20-unify-select) - 在2.0迁移文档中'
- en: '[#5087](https://www.sqlalchemy.org/trac/ticket/5087)'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '[#5087](https://www.sqlalchemy.org/trac/ticket/5087)'
- en: '[#4395](https://www.sqlalchemy.org/trac/ticket/4395)'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4395](https://www.sqlalchemy.org/trac/ticket/4395)'
- en: '[#4959](https://www.sqlalchemy.org/trac/ticket/4959)  ### RowProxy is no longer
    a “proxy”; is now called Row and behaves like an enhanced named tuple'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4959](https://www.sqlalchemy.org/trac/ticket/4959)  ### RowProxy不再是“代理”；现在称为Row，并且行为类似于增强的命名元组'
- en: The `RowProxy` class, which represents individual database result rows in a
    Core result set, is now called [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") and is no longer a “proxy” object; what this means is
    that when the [`Row`](../core/connections.html#sqlalchemy.engine.Row "sqlalchemy.engine.Row")
    object is returned, the row is a simple tuple that contains the data in its final
    form, already having been processed by result-row handling functions associated
    with datatypes (examples include turning a date string from the database into
    a `datetime` object, a JSON string into a Python `json.loads()` result, etc.).
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '`RowProxy` 类，代表 Core 结果集中的单个数据库结果行，现在被称为 [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row")，不再是一个“代理”对象；这意味着当返回 [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") 对象时，该行是一个简单的元组，其中包含数据的最终形式，已经通过与数据类型相关的结果行处理函数处理过（例如将数据库中的日期字符串转换为
    `datetime` 对象，将 JSON 字符串转换为 Python 的 `json.loads()` 结果等）。'
- en: The immediate rationale for this is so that the row can act more like a Python
    named tuple, rather than a mapping, where the values in the tuple are the subject
    of the `__contains__` operator on the tuple, rather than the keys. With [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") acting like a named tuple, it is then suitable for use
    as as replacement for the ORM’s `KeyedTuple` object, leading to an eventual API
    where both the ORM and Core deliver result sets that behave identically. Unification
    of major patterns within ORM and Core is a major goal of SQLAlchemy 2.0, and release
    1.4 aims to have most or all of the underlying architectural patterns in place
    in order to support this process. The note in [The “KeyedTuple” object returned
    by Query is replaced by Row](#change-4710-orm) describes the ORM’s use of the
    [`Row`](../core/connections.html#sqlalchemy.engine.Row "sqlalchemy.engine.Row")
    class.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的直接理由是为了使该行更像一个 Python 命名元组，而不是一个映射，其中元组中的值是元组上的 `__contains__` 运算符的主题，而不是键。由于
    [`Row`](../core/connections.html#sqlalchemy.engine.Row "sqlalchemy.engine.Row")
    表现得像一个命名元组，因此它适合用作 ORM 的 `KeyedTuple` 对象的替代，从而导致最终的 API 中，ORM 和 Core 提供的结果集行为相同。统一
    ORM 和 Core 中的主要模式是 SQLAlchemy 2.0 的主要目标，而发布 1.4 旨在具有大多数或所有底层架构模式，以支持这一过程。[Query
    返回的“KeyedTuple”对象被 Row 替换](#change-4710-orm) 中的注释描述了 ORM 对 [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") 类的使用。
- en: For release 1.4, the [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") class provides an additional subclass `LegacyRow`, which
    is used by Core and provides a backwards-compatible version of `RowProxy` while
    emitting deprecation warnings for those API features and behaviors that will be
    moved. ORM [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    now makes use of [`Row`](../core/connections.html#sqlalchemy.engine.Row "sqlalchemy.engine.Row")
    directly as a replacement for `KeyedTuple`.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 对于发布 1.4 版本，[`Row`](../core/connections.html#sqlalchemy.engine.Row "sqlalchemy.engine.Row")
    类提供了一个额外的子类 `LegacyRow`，它被 Core 使用，并提供了 `RowProxy` 的向后兼容版本，同时对那些将被移动的 API 功能和行为发出弃用警告。ORM
    [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    现在直接使用 [`Row`](../core/connections.html#sqlalchemy.engine.Row "sqlalchemy.engine.Row")
    作为 `KeyedTuple` 的替代品。
- en: The `LegacyRow` class is a transitional class where the `__contains__` method
    is still testing against the keys, not the values, while emitting a deprecation
    warning when the operation succeeds. Additionally, all the other mapping-like
    methods on the previous `RowProxy` are deprecated, including `LegacyRow.keys()`,
    `LegacyRow.items()`, etc. For mapping-like behaviors from a [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") object, including support for these methods as well as
    a key-oriented `__contains__` operator, the API going forward will be to first
    access a special attribute [`Row._mapping`](../core/connections.html#sqlalchemy.engine.Row._mapping
    "sqlalchemy.engine.Row._mapping"), which will then provide a complete mapping
    interface to the row, rather than a tuple interface.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '`LegacyRow` 类是一个过渡类，其中 `__contains__` 方法仍然针对键进行测试，而不是值，当操作成功时会发出弃用警告。此外，先前
    `RowProxy` 上的所有其他类似映射的方法也已弃用，包括 `LegacyRow.keys()`、`LegacyRow.items()` 等。对于从 [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") 对象获得类似映射的行为，包括支持这些方法以及面向键的 `__contains__` 运算符，未来的 API
    将是首先访问一个特殊属性 [`Row._mapping`](../core/connections.html#sqlalchemy.engine.Row._mapping
    "sqlalchemy.engine.Row._mapping")，然后该属性将为该行提供完整的映射接口，而不是元组接口。'
- en: 'Rationale: To behave more like a named tuple rather than a mapping'
  id: totrans-276
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 理念：表现得更像一个命名元组而不是映射
- en: 'The difference between a named tuple and a mapping as far as boolean operators
    can be summarized. Given a “named tuple” in pseudo code as:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 命名元组和映射之间在布尔运算方面的区别可以总结如下。给定伪代码中的“命名元组”为：
- en: '[PRE55]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The biggest cross-incompatible difference is the behavior of `__contains__`:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 最大的不兼容差异是`__contains__`的行为：
- en: '[PRE56]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'In 1.4, when a `LegacyRow` is returned by a Core result set, the above `"id"
    in row` comparison will continue to succeed, however a deprecation warning will
    be emitted. To use the “in” operator as a mapping, use the [`Row._mapping`](../core/connections.html#sqlalchemy.engine.Row._mapping
    "sqlalchemy.engine.Row._mapping") attribute:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在1.4版本中，当核心结果集返回一个`LegacyRow`时，上述`"id" in row`比较将继续成功，但会发出弃用警告。要将“in”运算符用作映射，请使用[`Row._mapping`](../core/connections.html#sqlalchemy.engine.Row._mapping
    "sqlalchemy.engine.Row._mapping")属性：
- en: '[PRE57]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'SQLAlchemy 2.0’s result object will feature a `.mappings()` modifier so that
    these mappings can be received directly:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 2.0的结果对象将具有`.mappings()`修饰符，以便可以直接接收这些映射：
- en: '[PRE58]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Proxying behavior goes away, was also unnecessary in modern usage
  id: totrans-285
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 代理行为消失，对于现代用法也是不必要的
- en: 'The refactor of [`Row`](../core/connections.html#sqlalchemy.engine.Row "sqlalchemy.engine.Row")
    to behave like a tuple requires that all data values be fully available up front.
    This is an internal behavior change from that of `RowProxy`, where result-row
    processing functions would be invoked at the point of accessing an element of
    the row, instead of when the row was first fetched. This means for example when
    retrieving a datetime value from SQLite, the data for the row as present in the
    `RowProxy` object would previously have looked like:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 对`Row`的重构使其行为类似于元组，需要所有数据值一开始就完全可用。这是与`RowProxy`的内部行为变化不同，`RowProxy`中的结果行处理函数将在访问行的元素时被调用，而不是在首次获取行时被调用。这意味着例如从SQLite检索日期时间值时，以前在`RowProxy`对象中的行数据看起来像是：
- en: '[PRE59]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'and then upon access via `__getitem__`, the `datetime.strptime()` function
    would be used on the fly to convert the above string date into a `datetime` object.
    With the new architecture, the `datetime()` object is present in the tuple when
    it is returned, the `datetime.strptime()` function having been called just once
    up front:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 然后通过`__getitem__`访问时，`datetime.strptime()`函数将即时用于将上述字符串日期转换为`datetime`对象。通过新架构，当元组返回时，`datetime()`对象已经存在于其中，`datetime.strptime()`函数只被提前调用了一次：
- en: '[PRE60]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The `RowProxy` and [`Row`](../core/connections.html#sqlalchemy.engine.Row "sqlalchemy.engine.Row")
    objects in SQLAlchemy are where the majority of SQLAlchemy’s C extension code
    takes place. This code has been highly refactored to provide the new behavior
    in an efficient manner, and overall performance has been improved as the design
    of [`Row`](../core/connections.html#sqlalchemy.engine.Row "sqlalchemy.engine.Row")
    is now considerably simpler.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy中的`RowProxy`和[`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row")对象是大部分SQLAlchemy的C扩展代码发生的地方。这些代码已经经过高度重构，以有效地提供新的行为，并且整体性能已经得到改善，因为[`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row")的设计现在相当简单。
- en: The rationale behind the previous behavior assumed a usage model where a result
    row might have dozens or hundreds of columns present, where most of those columns
    would not be accessed, and for which a majority of those columns would require
    some result-value processing function. By invoking the processing function only
    when needed, the goal was that lots of result processing functions would not be
    necessary, thus increasing performance.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 之前行为背后的理念假设了一个结果行可能有几十甚至几百列存在的使用模型，其中大多数列不会被访问，并且其中大多数列需要一些结果值处理函数。通过仅在需要时调用处理函数，目标是不需要大量的结果处理函数，从而提高性能。
- en: 'There are many reasons why the above assumptions do not hold:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多原因导致上述假设不成立：
- en: the vast majority of row-processing functions called were to Unicode decode
    a bytestring into a Python Unicode string under Python 2\. This was right as Python
    Unicode was beginning to see use and before Python 3 existed. Once Python 3 was
    introduced, within a few years, all Python DBAPIs took on the proper role of supporting
    the delivering of Python Unicode objects directly, under both Python 2 and Python
    3, as an option in the former case and as the only way forward in the latter case.
    Eventually, in most cases it became the default for Python 2 as well. SQLAlchemy’s
    Python 2 support still enables explicit string-to-Unicode conversion for some
    DBAPIs such as cx_Oracle, however it is now performed at the DBAPI level rather
    than as a standard SQLAlchemy result row processing function.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用绝大多数行处理函数是为了将字节字符串解码为 Python Unicode 字符串，在 Python 2 下。这是因为 Python Unicode
    开始被使用并且在 Python 3 存在之前。一旦引入了 Python 3，在几年内，所有 Python DBAPIs 都开始正确地支持直接传递 Python
    Unicode 对象，在 Python 2 和 Python 3 下都是如此，在前一种情况下是作为选项，在后一种情况下是唯一的前进方式。最终，在大多数情况下，它也成为了
    Python 2 的默认选项。SQLAlchemy 的 Python 2 支持仍然支持一些 DBAPIs，比如 cx_Oracle，但现在是在 DBAPI
    级别执行而不是作为标准 SQLAlchemy 结果行处理函数。
- en: The above string conversion, when it is used, was made to be extremely performant
    via the C extensions, so much so that even in 1.4, SQLAlchemy’s byte-to-Unicode
    codec hook is plugged into cx_Oracle where it has been observed to be more performant
    than cx_Oracle’s own hook; this meant that the overhead for converting all strings
    in a row was not as significant as it originally was in any case.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上述字符串转换，在使用时，通过 C 扩展被制作得非常高效，以至于即使在 1.4 版中，SQLAlchemy 的字节到 Unicode 编解码挂钩被插入到
    cx_Oracle 中，观察到它比 cx_Oracle 自己的挂钩更高效；这意味着在任何情况下将所有字符串转换为行的开销都不像最初那样显着。
- en: Row processing functions are not used in most other cases; the exceptions are
    SQLite’s datetime support, JSON support for some backends, some numeric handlers
    such as string to `Decimal`. In the case of `Decimal`, Python 3 also standardized
    on the highly performant `cdecimal` implementation, which is not the case in Python
    2 which continues to use the much less performant pure Python version.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在大多数其他情况下不使用行处理函数；例外情况包括 SQLite 的日期时间支持，某些后端的 JSON 支持，一些数字处理程序例如字符串到 `Decimal`
    的转换。在 `Decimal` 的情况下，Python 3 也标准化了高性能的 `cdecimal` 实现，而在 Python 2 中则继续使用性能远远不及的纯
    Python 版本。
- en: Fetching full rows where only a few columns are needed is not common within
    real-world use cases In the early days of SQLAlchemy, database code from other
    languages of the form “row = fetch(‘SELECT * FROM table’)” was common; using SQLAlchemy’s
    expression language however, code observed in the wild typically makes use of
    the specific columns needed.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在实际使用案例中，很少会出现只需要少数列的情况在 SQLAlchemy 的早期，来自其他语言的数据库代码形式“row = fetch(‘SELECT *
    FROM table’)”很常见；然而，观察到的野外代码通常使用了需要的特定列的表达式语言。
- en: See also
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[The “KeyedTuple” object returned by Query is replaced by Row](#change-4710-orm)'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '[查询返回的“KeyedTuple”对象已被“Row”替换](#change-4710-orm)'
- en: '[ORM Session.execute() uses “future” style Result sets in all cases](#change-session-execute-result)'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '[ORM 会话.execute() 在所有情况下都使用“future”风格的结果集](#change-session-execute-result)'
- en: '[#4710](https://www.sqlalchemy.org/trac/ticket/4710)  ### SELECT objects and
    derived FROM clauses allow for duplicate columns and column labels'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4710](https://www.sqlalchemy.org/trac/ticket/4710)  ### SELECT 对象和衍生的 FROM
    子句允许重复的列和列标签'
- en: 'This change allows that the [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") construct now allows for duplicate column
    labels as well as duplicate column objects themselves, so that result tuples are
    organized and ordered in the identical way in that the columns were selected.
    The ORM [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    already works this way, so this change allows for greater cross-compatibility
    between the two, which is a key goal of the 2.0 transition:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 此更改允许 [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") 构造现在允许重复的列标签以及重复的列对象本身，以便结果元组以相同的方式组织和排序，即所选列的方式。ORM
    [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    已经按照这种方式工作，因此此更改允许更大的跨兼容性，这是 2.0 过渡的一个关键目标：
- en: '[PRE61]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'To support this change, the [`ColumnCollection`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnCollection
    "sqlalchemy.sql.expression.ColumnCollection") used by [`SelectBase`](../core/selectable.html#sqlalchemy.sql.expression.SelectBase
    "sqlalchemy.sql.expression.SelectBase") as well as for derived FROM clauses such
    as subqueries also support duplicate columns; this includes the new [`SelectBase.selected_columns`](../core/selectable.html#sqlalchemy.sql.expression.SelectBase.selected_columns
    "sqlalchemy.sql.expression.SelectBase.selected_columns") attribute, the deprecated
    `SelectBase.c` attribute, as well as the [`FromClause.c`](../core/selectable.html#sqlalchemy.sql.expression.FromClause.c
    "sqlalchemy.sql.expression.FromClause.c") attribute seen on constructs such as
    [`Subquery`](../core/selectable.html#sqlalchemy.sql.expression.Subquery "sqlalchemy.sql.expression.Subquery")
    and [`Alias`](../core/selectable.html#sqlalchemy.sql.expression.Alias "sqlalchemy.sql.expression.Alias"):'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持这一变化，[`SelectBase`](../core/selectable.html#sqlalchemy.sql.expression.SelectBase
    "sqlalchemy.sql.expression.SelectBase")使用的[`ColumnCollection`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnCollection
    "sqlalchemy.sql.expression.ColumnCollection")以及用于派生FROM子句的列集合，如子查询，也支持重复列；这包括新的[`SelectBase.selected_columns`](../core/selectable.html#sqlalchemy.sql.expression.SelectBase.selected_columns
    "sqlalchemy.sql.expression.SelectBase.selected_columns")属性，已弃用的`SelectBase.c`属性，以及在诸如[`Subquery`](../core/selectable.html#sqlalchemy.sql.expression.Subquery
    "sqlalchemy.sql.expression.Subquery")和[`Alias`](../core/selectable.html#sqlalchemy.sql.expression.Alias
    "sqlalchemy.sql.expression.Alias")等构造中看到的[`FromClause.c`](../core/selectable.html#sqlalchemy.sql.expression.FromClause.c
    "sqlalchemy.sql.expression.FromClause.c")属性：
- en: '[PRE62]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[`ColumnCollection`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnCollection
    "sqlalchemy.sql.expression.ColumnCollection") also allows access by integer index
    to support when the string “key” is ambiguous:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '[`ColumnCollection`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnCollection
    "sqlalchemy.sql.expression.ColumnCollection")还允许通过整数索引访问，以支持当字符串“键”不明确时：'
- en: '[PRE63]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: To suit the use of [`ColumnCollection`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnCollection
    "sqlalchemy.sql.expression.ColumnCollection") in objects such as [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") and [`PrimaryKeyConstraint`](../core/constraints.html#sqlalchemy.schema.PrimaryKeyConstraint
    "sqlalchemy.schema.PrimaryKeyConstraint"), the old “deduplicating” behavior which
    is more critical for these objects is preserved in a new class `DedupeColumnCollection`.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 为了适应[`ColumnCollection`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnCollection
    "sqlalchemy.sql.expression.ColumnCollection")在诸如[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")和[`PrimaryKeyConstraint`](../core/constraints.html#sqlalchemy.schema.PrimaryKeyConstraint
    "sqlalchemy.schema.PrimaryKeyConstraint")等对象中的使用，保留了旧的“去重”行为，这对于这些对象更为关键，它被保存在一个新的类`DedupeColumnCollection`中。
- en: 'The change includes that the familiar warning `"Column %r on table %r being
    replaced by %r, which has the same key.  Consider use_labels for select() statements."`
    is **removed**; the `Select.apply_labels()` is still available and is still used
    by the ORM for all SELECT operations, however it does not imply deduplication
    of column objects, although it does imply deduplication of implicitly generated
    labels:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 此更改包括删除了熟悉的警告`"Column %r on table %r being replaced by %r, which has the same
    key.  Consider use_labels for select() statements."`；`Select.apply_labels()`仍然可用，并且仍然被ORM用于所有SELECT操作，但它不意味着列对象的去重，尽管它意味着隐式生成的标签的去重：
- en: '[PRE64]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Finally, the change makes it easier to create UNION and other `_selectable.CompoundSelect`
    objects, by ensuring that the number and position of columns in a SELECT statement
    mirrors what was given, in a use case such as:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，该更改使得更容易创建UNION和其他`_selectable.CompoundSelect`对象，通过确保SELECT语句中的列数和位置与给定的相同，例如：
- en: '[PRE65]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[#4753](https://www.sqlalchemy.org/trac/ticket/4753)  ### Improved column labeling
    for simple column expressions using CAST or similar'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4753](https://www.sqlalchemy.org/trac/ticket/4753)  ### 改进了使用CAST或类似方法对简单列表达式进行列标记'
- en: 'A user pointed out that the PostgreSQL database has a convenient behavior when
    using functions like CAST against a named column, in that the result column name
    is named the same as the inner expression:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 有用户指出，当针对命名列使用类似CAST的函数时，PostgreSQL数据库具有方便的行为，即结果列名与内部表达式相同：
- en: '[PRE66]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'This allows one to apply CAST to table columns while not losing the column
    name (above using the name `"data"`) in the result row. Compare to databases such
    as MySQL/MariaDB, as well as most others, where the column name is taken from
    the full SQL expression and is not very portable:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得可以对表列应用CAST而不会在结果行中丢失列名（上述使用名称`"data"`）。与MySQL/MariaDB等数据库��比，以及大多数其他数据库，其中列名取自完整的SQL表达式，不太具有可移植性：
- en: '[PRE67]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'In SQLAlchemy Core expressions, we never deal with a raw generated name like
    the above, as SQLAlchemy applies auto-labeling to expressions like these, which
    are up until now always a so-called “anonymous” expression:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SQLAlchemy Core 表达式中，我们从不处理像上面那样的原始生成名称，因为 SQLAlchemy 对这些表达式应用自动标记，这些表达式直到现在都是所谓的
    “匿名” 表达式：
- en: '[PRE68]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'These anonymous expressions were necessary as SQLAlchemy’s `ResultProxy` made
    heavy use of result column names in order to match up datatypes, such as the [`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String") datatype which used to have result-row-processing behavior,
    to the correct column, so most importantly the names had to be both easy to determine
    in a database-agnostic manner as well as unique in all cases. In SQLAlchemy 1.0
    as part of [#918](https://www.sqlalchemy.org/trac/ticket/918), this reliance on
    named columns in result rows (specifically the `cursor.description` element of
    the PEP-249 cursor) was scaled back to not be necessary for most Core SELECT constructs;
    in release 1.4, the system overall is becoming more comfortable with SELECT statements
    that have duplicate column or label names such as in [SELECT objects and derived
    FROM clauses allow for duplicate columns and column labels](#change-4753). So
    we now emulate PostgreSQL’s reasonable behavior for simple modifications to a
    single column, most prominently with CAST:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 这些匿名表达式是必需的，因为 SQLAlchemy 的 `ResultProxy` 大量使用结果列名称来匹配数据类型，例如 [`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String") 数据类型曾经具有结果行处理行为，以正确的列匹配起来，因此最重要的是这些名称必须易于以数据库无关的方式确定，并且在所有情况下都是唯一的。在
    SQLAlchemy 1.0 中作为 [#918](https://www.sqlalchemy.org/trac/ticket/918) 的一部分，对于大多数核心
    SELECT 构造，不再需要在结果行中使用命名列（特别是 PEP-249 游标的 `cursor.description` 元素），在 1.4 版本中，系统总体上变得更加适应具有重复列或标签名称的
    SELECT 语句，例如在 [SELECT 对象和派生 FROM 子句允许重复列和列标签](#change-4753) 中。所以我们现在模仿 PostgreSQL
    对单个列的简单修改的合理行为，尤其是与 CAST 相关的行为：
- en: '[PRE69]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'For CAST against expressions that don’t have a name, the previous logic is
    used to generate the usual “anonymous” labels:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 对于没有名称的表达式，使用先前的逻辑来生成通常的“匿名”标签：
- en: '[PRE70]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'A [`cast()`](../core/sqlelement.html#sqlalchemy.sql.expression.cast "sqlalchemy.sql.expression.cast")
    against a [`Label`](../core/sqlelement.html#sqlalchemy.sql.expression.Label "sqlalchemy.sql.expression.Label"),
    despite having to omit the label expression as these don’t render inside of a
    CAST, will nonetheless make use of the given name:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 [`Label`](../core/sqlelement.html#sqlalchemy.sql.expression.Label "sqlalchemy.sql.expression.Label")
    的 [`cast()`](../core/sqlelement.html#sqlalchemy.sql.expression.cast "sqlalchemy.sql.expression.cast")，尽管必须省略标签表达式，因为这些表达式不会在
    CAST 内部呈现，但仍然会使用给定的名称：
- en: '[PRE71]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'And of course as was always the case, [`Label`](../core/sqlelement.html#sqlalchemy.sql.expression.Label
    "sqlalchemy.sql.expression.Label") can be applied to the expression on the outside
    to apply an “AS <name>” label directly:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，一直以来都是这样，[`Label`](../core/sqlelement.html#sqlalchemy.sql.expression.Label
    "sqlalchemy.sql.expression.Label") 可以应用于外部的表达式，直接应用 “AS <name>” 标签：
- en: '[PRE72]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[#4449](https://www.sqlalchemy.org/trac/ticket/4449)  ### New “post compile”
    bound parameters used for LIMIT/OFFSET in Oracle, SQL Server'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4449](https://www.sqlalchemy.org/trac/ticket/4449)  ### 新的用于 LIMIT/OFFSET
    的 “后编译” 绑定参数在 Oracle、SQL Server 中使用'
- en: A major goal of the 1.4 series is to establish that all Core SQL constructs
    are completely cacheable, meaning that a particular [`Compiled`](../core/internals.html#sqlalchemy.engine.Compiled
    "sqlalchemy.engine.Compiled") structure will produce an identical SQL string regardless
    of any SQL parameters used with it, which notably includes those used to specify
    the LIMIT and OFFSET values, typically used for pagination and “top N” style results.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 1.4 系列的一个主要目标是确保所有核心 SQL 构造都是完全可缓存的，这意味着特定的 [`Compiled`](../core/internals.html#sqlalchemy.engine.Compiled
    "sqlalchemy.engine.Compiled") 结构将产生相同的 SQL 字符串，而不管使用它的任何 SQL 参数，其中特别包括用于指定 LIMIT
    和 OFFSET 值的参数，通常用于分页和 “top N” 类型的结果。
- en: 'While SQLAlchemy has used bound parameters for LIMIT/OFFSET schemes for many
    years, a few outliers remained where such parameters were not allowed, including
    a SQL Server “TOP N” statement, such as:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 SQLAlchemy 多年来一直使用绑定参数进行 LIMIT/OFFSET 方案，但仍然存在一些离群值，其中不允许使用这些参数，包括 SQL Server
    的 “TOP N” 语句，例如：
- en: '[PRE73]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'as well as with Oracle, where the FIRST_ROWS() hint (which SQLAlchemy will
    use if the `optimize_limits=True` parameter is passed to [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") with an Oracle URL) does not allow them, but also
    that using bound parameters with ROWNUM comparisons has been reported as producing
    slower query plans:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 以及在 Oracle 中，如果向 [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") 传递了 `optimize_limits=True` 参数，SQLAlchemy 将使用 FIRST_ROWS()
    提示，这不允许它们，但也有报道称使用绑定参数与 ROWNUM 比较会产生较慢的查询计划：
- en: '[PRE74]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'In order to allow for all statements to be unconditionally cacheable at the
    compilation level, a new form of bound parameter called a “post compile” parameter
    has been added, which makes use of the same mechanism as that of “expanding IN
    parameters”. This is a [`bindparam()`](../core/sqlelement.html#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam") that behaves identically to any other bound
    parameter except that parameter value will be rendered literally into the SQL
    string before sending it to the DBAPI `cursor.execute()` method. The new parameter
    is used internally by the SQL Server and Oracle dialects, so that the drivers
    receive the literal rendered value but the rest of SQLAlchemy can still consider
    this as a bound parameter. The above two statements when stringified using `str(statement.compile(dialect=<dialect>))`
    now look like:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让所有语句在编译级别无条件可缓存，添加了一种新形式的绑定参数，称为“后编译”参数，它利用了与“扩展 IN 参数”相同的机制。这是一个 [`bindparam()`](../core/sqlelement.html#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam")，其行为与任何其他绑定参数完全相同，只是参数值在发送到 DBAPI `cursor.execute()`
    方法之前会被直接渲染到 SQL 字符串中。新参数在 SQL Server 和 Oracle 方言内部使用，以便驱动程序接收到直接渲染的值，但 SQLAlchemy
    的其余部分仍然可以将其视为绑定参数。使用 `str(statement.compile(dialect=<dialect>))` 对上述两个语句进行字符串化后现在看起来像：
- en: '[PRE75]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'and:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 和：
- en: '[PRE76]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: The `[POSTCOMPILE_<param>]` format is also what is seen when an “expanding IN”
    is used.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用“扩展 IN”时，也会看到 `[POSTCOMPILE_<param>]` 格式。
- en: 'When viewing the SQL logging output, the final form of the statement will be
    seen:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 查看 SQL 日志输出时，将看到语句的最终形式：
- en: '[PRE77]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: The “post compile parameter” feature is exposed as public API through the [`bindparam.literal_execute`](../core/sqlelement.html#sqlalchemy.sql.expression.bindparam.params.literal_execute
    "sqlalchemy.sql.expression.bindparam") parameter, however is currently not intended
    for general use. The literal values are rendered using the [`TypeEngine.literal_processor()`](../core/type_api.html#sqlalchemy.types.TypeEngine.literal_processor
    "sqlalchemy.types.TypeEngine.literal_processor") of the underlying datatype, which
    in SQLAlchemy has **extremely limited** scope, supporting only integers and simple
    string values.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: “后编译参数”功能通过 [`bindparam.literal_execute`](../core/sqlelement.html#sqlalchemy.sql.expression.bindparam.params.literal_execute
    "sqlalchemy.sql.expression.bindparam") 参数作为公共 API 公开，但目前不打算供一般使用。字面值是使用底层数据类型的
    [`TypeEngine.literal_processor()`](../core/type_api.html#sqlalchemy.types.TypeEngine.literal_processor
    "sqlalchemy.types.TypeEngine.literal_processor") 渲染的，在 SQLAlchemy 中具有**极其有限**的范围，仅支持整数和简单字符串值。
- en: '[#4808](https://www.sqlalchemy.org/trac/ticket/4808)  ### Connection-level
    transactions can now be inactive based on subtransaction'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4808](https://www.sqlalchemy.org/trac/ticket/4808)  ### 基于子事务，现在可以根据连接级事务是否处于非活动状态'
- en: A [`Connection`](../core/connections.html#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    now includes the behavior where a [`Transaction`](../core/connections.html#sqlalchemy.engine.Transaction
    "sqlalchemy.engine.Transaction") can be made inactive due to a rollback on an
    inner transaction, however the [`Transaction`](../core/connections.html#sqlalchemy.engine.Transaction
    "sqlalchemy.engine.Transaction") will not clear until it is itself rolled back.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，[`Connection`](../core/connections.html#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    包括了一个行为，即由于内部事务的回滚，[`Transaction`](../core/connections.html#sqlalchemy.engine.Transaction
    "sqlalchemy.engine.Transaction") 可以变为非活动状态，但是 [`Transaction`](../core/connections.html#sqlalchemy.engine.Transaction
    "sqlalchemy.engine.Transaction") 在自身被回滚之前不会清除。
- en: This is essentially a new error condition which will disallow statement executions
    to proceed on a [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") if an inner “sub” transaction has been rolled
    back. The behavior works very similarly to that of the ORM [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), where if an outer transaction has been begun, it needs
    to be rolled back to clear the invalid transaction; this behavior is described
    in [“This Session’s transaction has been rolled back due to a previous exception
    during flush.” (or similar)](../faq/sessions.html#faq-session-rollback).
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 这本质上是一种新的错误条件，如果内部“子”事务已回滚，则不允许在 [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") 上继续执行语句。该行为与 ORM [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 的行为非常相似，如果已启动外部事务，则需要回滚以清除无效事务；此行为在 [“由于刷新期间的前一个异常，此会话的事务已回滚。”（或类似内容）](../faq/sessions.html#faq-session-rollback)
    中有描述。
- en: While the [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") has had a less strict behavioral pattern than
    the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session"),
    this change was made as it helps to identify when a subtransaction has rolled
    back the DBAPI transaction, however the external code isn’t aware of this and
    attempts to continue proceeding, which in fact runs operations on a new transaction.
    The “test harness” pattern described at [Joining a Session into an External Transaction
    (such as for test suites)](../orm/session_transaction.html#session-external-transaction)
    is the common place for this to occur.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 [`Connection`](../core/connections.html#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    的行为模式比 [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    更宽松，但由于它有助于确定子事务何时回滚了 DBAPI 事务，但外部代码并不知道此事并尝试继续进行，实际上是在新事务上运行操作，因此进行了更改。在 [将会话加入外部事务（例如用于测试套件）](../orm/session_transaction.html#session-external-transaction)
    中描述的“测试套件”模式是这种情况的普遍发生地点。
- en: The “subtransaction” feature of Core and ORM is itself deprecated and will no
    longer be present in version 2.0\. As a result, this new error condition is itself
    temporary as it will no longer apply once subtransactions are removed.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: Core 和 ORM 的“子事务”功能本身已被弃用，并且在 2.0 版本中将不再存在。因此，这种新的错误条件本身是临时的，因为一旦删除子事务，它就不再适用。
- en: In order to work with the 2.0 style behavior that does not include subtransactions,
    use the [`create_engine.future`](../core/engines.html#sqlalchemy.create_engine.params.future
    "sqlalchemy.create_engine") parameter on [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine").
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用不包括子事务的 2.0 样式行为，请在 [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") 上使用 [`create_engine.future`](../core/engines.html#sqlalchemy.create_engine.params.future
    "sqlalchemy.create_engine") 参数。
- en: 'The error message is described in the errors page at [This connection is on
    an inactive transaction. Please rollback() fully before proceeding](../errors.html#error-8s2a).  ###
    Enum and Boolean datatypes no longer default to “create constraint”'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 错误消息在错误页面中描述为 [此连接处于非活动事务中。 请在继续之前完全回滚（）](../errors.html#error-8s2a)。### 枚举和布尔数据类型不再默认为“创建约束”
- en: The [`Enum.create_constraint`](../core/type_basics.html#sqlalchemy.types.Enum.params.create_constraint
    "sqlalchemy.types.Enum") and [`Boolean.create_constraint`](../core/type_basics.html#sqlalchemy.types.Boolean.params.create_constraint
    "sqlalchemy.types.Boolean") parameters now default to False, indicating when a
    so-called “non-native” version of these two datatypes is created, a CHECK constraint
    will **not** be generated by default. These CHECK constraints present schema-management
    maintenance complexities that should be opted in to, rather than being turned
    on by default.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Enum.create_constraint`](../core/type_basics.html#sqlalchemy.types.Enum.params.create_constraint
    "sqlalchemy.types.Enum") 和 [`Boolean.create_constraint`](../core/type_basics.html#sqlalchemy.types.Boolean.params.create_constraint
    "sqlalchemy.types.Boolean") 参数现在默认为 False，表示当创建这两种数据类型的所谓“非本机”版本时，默认不会生成 CHECK
    约束。这些 CHECK 约束提出了应该选择的模式管理维护复杂性，而不是默认打开。'
- en: 'To ensure that a CREATE CONSTRAINT is emitted for these types, set these flags
    to `True`:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 要确保为这些类型发出 CREATE CONSTRAINT，请将这些标志设置为`True`：
- en: '[PRE78]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[#5367](https://www.sqlalchemy.org/trac/ticket/5367)'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '[#5367](https://www.sqlalchemy.org/trac/ticket/5367)'
- en: New Features - ORM
  id: totrans-352
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 新功能 - ORM
- en: '### Raiseload for Columns'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '### 列的 Raiseload'
- en: 'The “raiseload” feature, which raises [`InvalidRequestError`](../core/exceptions.html#sqlalchemy.exc.InvalidRequestError
    "sqlalchemy.exc.InvalidRequestError") when an unloaded attribute is accessed,
    is now available for column-oriented attributes using the [`defer.raiseload`](../orm/queryguide/columns.html#sqlalchemy.orm.defer.params.raiseload
    "sqlalchemy.orm.defer") parameter of [`defer()`](../orm/queryguide/columns.html#sqlalchemy.orm.defer
    "sqlalchemy.orm.defer"). This works in the same manner as that of the [`raiseload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.raiseload
    "sqlalchemy.orm.raiseload") option used by relationship loading:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: “raiseload”功能会在访问未加载属性时引发[`InvalidRequestError`](../core/exceptions.html#sqlalchemy.exc.InvalidRequestError
    "sqlalchemy.exc.InvalidRequestError")，现在可以通过[`defer.raiseload`](../orm/queryguide/columns.html#sqlalchemy.orm.defer.params.raiseload
    "sqlalchemy.orm.defer")参数来为基于列的属性提供支持。这与关系加载中使用的[`raiseload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.raiseload
    "sqlalchemy.orm.raiseload")选项的工作方式相同：
- en: '[PRE79]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'To configure column-level raiseload on a mapping, the [`deferred.raiseload`](../orm/queryguide/columns.html#sqlalchemy.orm.deferred.params.raiseload
    "sqlalchemy.orm.deferred") parameter of [`deferred()`](../orm/queryguide/columns.html#sqlalchemy.orm.deferred
    "sqlalchemy.orm.deferred") may be used. The [`undefer()`](../orm/queryguide/columns.html#sqlalchemy.orm.undefer
    "sqlalchemy.orm.undefer") option may then be used at query time to eagerly load
    the attribute:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 要在映射上配置列级raiseload，可以使用[`deferred.raiseload`](../orm/queryguide/columns.html#sqlalchemy.orm.deferred.params.raiseload
    "sqlalchemy.orm.deferred")参数来为[`deferred()`](../orm/queryguide/columns.html#sqlalchemy.orm.deferred
    "sqlalchemy.orm.deferred")。然后可以在查询时使用[`undefer()`](../orm/queryguide/columns.html#sqlalchemy.orm.undefer
    "sqlalchemy.orm.undefer")选项来急切加载属性：
- en: '[PRE80]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'It was originally considered that the existing [`raiseload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.raiseload
    "sqlalchemy.orm.raiseload") option that works for [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") attributes be expanded to also support column-oriented
    attributes. However, this would break the “wildcard” behavior of [`raiseload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.raiseload
    "sqlalchemy.orm.raiseload"), which is documented as allowing one to prevent all
    relationships from loading:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 最初考虑扩展现有的为[`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")属性工作的[`raiseload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.raiseload
    "sqlalchemy.orm.raiseload")选项，以支持基于列的属性。然而，这将破坏[`raiseload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.raiseload
    "sqlalchemy.orm.raiseload")的“通配符”行为，该行为被记录为允许阻止所有关系加载：
- en: '[PRE81]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Above, if we had expanded [`raiseload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.raiseload
    "sqlalchemy.orm.raiseload") to accommodate for columns as well, the wildcard would
    also prevent columns from loading and thus be a backwards incompatible change;
    additionally, it’s not clear if [`raiseload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.raiseload
    "sqlalchemy.orm.raiseload") covered both column expressions and relationships,
    how one would achieve the effect above of only blocking relationship loads, without
    new API being added. So to keep things simple, the option for columns remains
    on [`defer()`](../orm/queryguide/columns.html#sqlalchemy.orm.defer "sqlalchemy.orm.defer"):'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们扩展了[`raiseload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.raiseload
    "sqlalchemy.orm.raiseload")以适应列，通配符也将阻止列加载，从而导致向后不兼容的更改；此外，不清楚[`raiseload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.raiseload
    "sqlalchemy.orm.raiseload")是否同时涵盖列表达式和关系，如何实现上述仅阻止关系加载的效果，而不添加新的API。因此，为了保持简单，列的选项仍然在[`defer()`](../orm/queryguide/columns.html#sqlalchemy.orm.defer
    "sqlalchemy.orm.defer")上：
- en: '[`raiseload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.raiseload
    "sqlalchemy.orm.raiseload") - query option to raise for relationship loads'
  id: totrans-361
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[`raiseload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.raiseload
    "sqlalchemy.orm.raiseload") - 查询选项，用于关系加载时引发异常'
- en: ''
  id: totrans-362
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[`defer.raiseload`](../orm/queryguide/columns.html#sqlalchemy.orm.defer.params.raiseload
    "sqlalchemy.orm.defer") - query option to raise for column expression loads'
  id: totrans-363
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[`defer.raiseload`](../orm/queryguide/columns.html#sqlalchemy.orm.defer.params.raiseload
    "sqlalchemy.orm.defer") - 查询选项，用于列表达式加载时引发异常'
- en: As part of this change, the behavior of “deferred” in conjunction with attribute
    expiration has changed. Previously, when an object would be marked as expired,
    and then unexpired via the access of one of the expired attributes, attributes
    which were mapped as “deferred” at the mapper level would also load. This has
    been changed such that an attribute that is deferred in the mapping will never
    “unexpire”, it only loads when accessed as part of the deferral loader.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 作为此更改的一部分，“deferred”与属性过期的行为已更改。以前，当对象被标记为过期，然后通过访问其中一个过期属性来取消过期时，映射为“deferred”的属性也会加载。现在已更改为映射中延迟的属性永远不会“取消过期”，只有在作为延迟加载器的一部分访问时才会加载。
- en: An attribute that is not mapped as “deferred”, however was deferred at query
    time via the [`defer()`](../orm/queryguide/columns.html#sqlalchemy.orm.defer "sqlalchemy.orm.defer")
    option, will be reset when the object or attribute is expired; that is, the deferred
    option is removed. This is the same behavior as was present previously.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 一个未映射为“deferred”的属性，但在查询时通过[`defer()`](../orm/queryguide/columns.html#sqlalchemy.orm.defer
    "sqlalchemy.orm.defer")选项延迟，当对象或属性过期时将被重置；也就是说，延迟选项被移除。这与以前的行为相同。
- en: See also
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Using raiseload to prevent deferred column loads](../orm/queryguide/columns.html#orm-queryguide-deferred-raiseload)'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用 raiseload 防止延迟列加载](../orm/queryguide/columns.html#orm-queryguide-deferred-raiseload)'
- en: '[#4826](https://www.sqlalchemy.org/trac/ticket/4826)  ### ORM Batch inserts
    with psycopg2 now batch statements with RETURNING in most cases'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4826](https://www.sqlalchemy.org/trac/ticket/4826)  ### ORM Batch inserts
    with psycopg2 now batch statements with RETURNING in most cases'
- en: The change in [psycopg2 dialect features “execute_values” with RETURNING for
    INSERT statements by default](#change-5401) adds support for “executemany” + “RETURNING”
    at the same time in Core, which is now enabled for the psycopg2 dialect by default
    using the psycopg2 `execute_values()` extension. The ORM flush process now makes
    use of this feature such that the retrieval of newly generated primary key values
    and server defaults can be achieved while not losing the performance benefits
    of being able to batch INSERT statements together. Additionally, psycopg2’s `execute_values()`
    extension itself provides a five-fold performance improvement over psycopg2’s
    default “executemany” implementation, by rewriting an INSERT statement to include
    many “VALUES” expressions all in one statement rather than invoking the same statement
    repeatedly, as psycopg2 lacks the ability to PREPARE the statement ahead of time
    as would normally be expected for this approach to be performant.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '[psycopg2 方言特性“execute_values”现在默认为 INSERT 语句添加 RETURNING](#change-5401)，在
    Core 中同时支持“executemany” + “RETURNING”，现在默认情况下使用 psycopg2 的 `execute_values()`
    扩展为 psycopg2 方言启用。ORM 刷新过程现在利用此功能，以便在不丢失能够将 INSERT 语句批处理在一起的性能优势的同时实现新生成的主键值和服务器默认值的检索。此外，psycopg2
    的 `execute_values()` 扩展本身通过将一个 INSERT 语句重写为包含许多“VALUES”表达式的单个语句而不是重复调用相同语句，提供了五倍的性能改进，因为
    psycopg2 缺乏预先准备语句的能力，这通常是为了使这种方法具有高性能而预期的。'
- en: 'SQLAlchemy includes a [performance suite](../orm/examples.html#examples-performance)
    within its examples, where we can compare the times generated for the “batch_inserts”
    runner against 1.3 and 1.4, revealing a 3x-5x speedup for most flavors of batch
    insert:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 在其示例中包含一个[性能套件](../orm/examples.html#examples-performance)，我们可以比较“batch_inserts”运行程序在
    1.3 和 1.4 中生成的时间，显示大多数批量插入的速度提升了 3 倍至 5 倍：
- en: '[PRE82]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Note that the `execute_values()` extension modifies the INSERT statement in
    the psycopg2 layer, **after** it’s been logged by SQLAlchemy. So with SQL logging,
    one will see the parameter sets batched together, but the joining of multiple
    “values” will not be visible on the application side:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`execute_values()` 扩展会修改在 psycopg2 层中由 SQLAlchemy 记录的 INSERT 语句**之后**。因此，在
    SQL 记录中，可以看到参数集被批处理在一起，但多个“values”的连接在应用程序端不可见：
- en: '[PRE83]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'The ultimate INSERT statement can be seen by enabling statement logging on
    the PostgreSQL side:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过在 PostgreSQL 端启用语句记录来查看最终的 INSERT 语句：
- en: '[PRE84]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: The feature batches rows into groups of 1000 by default which can be affected
    using the `executemany_values_page_size` argument documented at [Psycopg2 Fast
    Execution Helpers](../dialects/postgresql.html#psycopg2-executemany-mode).
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 该功能默认将行分组为每组 1000 行，可以使用文档中记录的 `executemany_values_page_size` 参数来影响。
- en: '[#5263](https://www.sqlalchemy.org/trac/ticket/5263)  ### ORM Bulk Update and
    Delete use RETURNING for “fetch” strategy when available'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '[#5263](https://www.sqlalchemy.org/trac/ticket/5263)  ### ORM批量更新和删除在可用时使用RETURNING作为“fetch”策略'
- en: 'An ORM bulk update or delete that uses the “fetch” strategy:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 使用“fetch”策略的ORM批量更新或删除：
- en: '[PRE85]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Will now use RETURNING if the backend database supports it; this currently
    includes PostgreSQL and SQL Server (the Oracle dialect does not support RETURNING
    of multiple rows):'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果后端数据库支持，将使用RETURNING；目前包括PostgreSQL和SQL Server（Oracle方言不支持返回多行）：
- en: '[PRE86]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'For backends that do not support RETURNING of multiple rows, the previous approach
    of emitting SELECT for the primary keys beforehand is still used:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不支持返回多行的后端，仍然使用先前的方法在事先发出主键的SELECT：
- en: '[PRE87]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: One of the intricate challenges of this change is to support cases such as the
    horizontal sharding extension, where a single bulk update or delete may be multiplexed
    among backends some of which support RETURNING and some don’t. The new 1.4 execution
    architecture supports this case so that the “fetch” strategy can be left intact
    with a graceful degrade to using a SELECT, rather than having to add a new “returning”
    strategy that would not be backend-agnostic.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 这种变化的一个复杂挑战之一是支持水平分片扩展等情况，其中单个批量更新或删除可能在一些支持RETURNING的后端之间复用，而另一些则不支持。新的1.4执行架构支持这种情况，以便“fetch”策略可以保持不变，优雅地降级到使用SELECT，而不是必须添加一个不具备后端通用性的新“returning”策略。
- en: As part of this change, the “fetch” strategy is also made much more efficient
    in that it will no longer expire the objects located which match the rows, for
    Python expressions used in the SET clause which can be evaluated in Python; these
    are instead assigned directly onto the object in the same way as the “evaluate”
    strategy. Only for SQL expressions that can’t be evaluated does it fall back to
    expiring the attributes. The “evaluate” strategy has also been enhanced to fall
    back to “expire” for a value that cannot be evaluated.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 作为这一变化的一部分，“fetch”策略也变得更加高效，它不再使与匹配行对应的对象过期，对于可以在Python中求值的用于SET子句的Python表达式；相反，这些直接分配到对象上，就像“evaluate”策略一样。只有对于无法求值的SQL表达式，它才会退回到使属性过期。对于无法求值的值，“evaluate”策略也已经增强为退回到“expire”。
- en: Behavioral Changes - ORM
  id: totrans-386
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 行为变化 - ORM
- en: '### The “KeyedTuple” object returned by Query is replaced by Row'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '### 由Query返回的“KeyedTuple”对象被Row取代'
- en: As discussed at [RowProxy is no longer a “proxy”; is now called Row and behaves
    like an enhanced named tuple](#change-4710-core), the Core `RowProxy` object is
    now replaced by a class called [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row"). The base [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") object now behaves more fully like a named tuple, and
    as such it is now used as the basis for tuple-like results returned by the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object, rather than the previous “KeyedTuple” class.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 如在[RowProxy is no longer a “proxy”; is now called Row and behaves like an enhanced
    named tuple](#change-4710-core)中所讨论的，核心`RowProxy`对象现在被一个名为[`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row")的类所取代。基本的[`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row")对象现在更像一个命名元组，因此现在被用作由[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")对象返回的类似元组的结果的基础，而不是以前的“KeyedTuple”类。
- en: The rationale is so that by SQLAlchemy 2.0, both Core and ORM SELECT statements
    will return result rows using the same [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") object which behaves like a named tuple. Dictionary-like
    functionality is available from [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") via the [`Row._mapping`](../core/connections.html#sqlalchemy.engine.Row._mapping
    "sqlalchemy.engine.Row._mapping") attribute. In the interim, Core result sets
    will make use of a [`Row`](../core/connections.html#sqlalchemy.engine.Row "sqlalchemy.engine.Row")
    subclass `LegacyRow` which maintains the previous dict/tuple hybrid behavior for
    backwards compatibility while the [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") class will be used directly for ORM tuple results returned
    by the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    object.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 其原因是到SQLAlchemy 2.0，Core和ORM SELECT语句将使用与命名元组相似的相同[`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row")对象返回结果行。从[`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row")中可以通过[`Row._mapping`](../core/connections.html#sqlalchemy.engine.Row._mapping
    "sqlalchemy.engine.Row._mapping")属性获取类似字典的功能。在此期间，Core结果集将使用维护先前字典/元组混合行为的[`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row")子类`LegacyRow`以确保向后兼容性，而[`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row")类将直接用于[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")对象返回的ORM元组结果。
- en: 'Effort has been made to get most of the featureset of [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") to be available within the ORM, meaning that access by
    string name as well as entity / column should work:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让[`Row`](../core/connections.html#sqlalchemy.engine.Row "sqlalchemy.engine.Row")的大多数功能在ORM中可用，已经付出了努力，这意味着可以通过字符串名称以及实体/列来访问：
- en: '[PRE88]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: See also
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 另见
- en: '[RowProxy is no longer a “proxy”; is now called Row and behaves like an enhanced
    named tuple](#change-4710-core)'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '[RowProxy不再是“代理”；现在称为Row，并且行为类似于增强的命名元组](#change-4710-core)'
- en: '[#4710](https://www.sqlalchemy.org/trac/ticket/4710).  ### Session features
    new “autobegin” behavior'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4710](https://www.sqlalchemy.org/trac/ticket/4710).  ### 会话功能的新“autobegin”行为'
- en: Previously, the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    in its default mode of `autocommit=False` would internally begin a [`SessionTransaction`](../orm/session_api.html#sqlalchemy.orm.SessionTransaction
    "sqlalchemy.orm.SessionTransaction") object immediately on construction, and additionally
    would create a new one after each call to [`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") or [`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit").
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，在默认模式为`autocommit=False`的情况下，[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")会在构造时立即内部开始一个[`SessionTransaction`](../orm/session_api.html#sqlalchemy.orm.SessionTransaction
    "sqlalchemy.orm.SessionTransaction")对象，并且在每次调用[`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback")或[`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit")后会创建一个新的。
- en: The new behavior is that this [`SessionTransaction`](../orm/session_api.html#sqlalchemy.orm.SessionTransaction
    "sqlalchemy.orm.SessionTransaction") object is now created on demand only, when
    methods such as [`Session.add()`](../orm/session_api.html#sqlalchemy.orm.Session.add
    "sqlalchemy.orm.Session.add") or [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") are called. However it is also now possible
    to call [`Session.begin()`](../orm/session_api.html#sqlalchemy.orm.Session.begin
    "sqlalchemy.orm.Session.begin") explicitly in order to begin the transaction,
    even in `autocommit=False` mode, thus matching the behavior of the future-style
    `_base.Connection`.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 新行为是这个[`SessionTransaction`](../orm/session_api.html#sqlalchemy.orm.SessionTransaction
    "sqlalchemy.orm.SessionTransaction")对象现在只在需要时创建，当调用`Session.add()`或`Session.execute()`等方法时。但现在也可以显式调用[`Session.begin()`](../orm/session_api.html#sqlalchemy.orm.Session.begin
    "sqlalchemy.orm.Session.begin")来开始事务，即使在`autocommit=False`模式下，这与未来风格的`_base.Connection`的行为相匹配。
- en: 'The behavioral changes this indicates are:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明的行为变化是：
- en: The [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    can now be in the state where no transaction is begun, even in `autocommit=False`
    mode. Previously, this state was only available in “autocommit” mode.
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    现在可以处于没有启动事务的状态，即使在 `autocommit=False` 模式下也是如此。以前，这种状态只在“自动提交”模式下可用。'
- en: Within this state, the [`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") and [`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") methods are no-ops. Code that relies upon these
    methods to expire all objects should make explicit use of either [`Session.begin()`](../orm/session_api.html#sqlalchemy.orm.Session.begin
    "sqlalchemy.orm.Session.begin") or [`Session.expire_all()`](../orm/session_api.html#sqlalchemy.orm.Session.expire_all
    "sqlalchemy.orm.Session.expire_all") to suit their use case.
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这种状态下，[`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") 和 [`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") 方法都不起作用。依赖这些方法来使所有对象过期的代码应明确使用 [`Session.begin()`](../orm/session_api.html#sqlalchemy.orm.Session.begin
    "sqlalchemy.orm.Session.begin") 或 [`Session.expire_all()`](../orm/session_api.html#sqlalchemy.orm.Session.expire_all
    "sqlalchemy.orm.Session.expire_all") 来适应其用例。
- en: The [`SessionEvents.after_transaction_create()`](../orm/events.html#sqlalchemy.orm.SessionEvents.after_transaction_create
    "sqlalchemy.orm.SessionEvents.after_transaction_create") event hook is not emitted
    immediately when the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is created, or after a [`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") or [`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") completes.
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当 [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    被创建时，或者在 [`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") 或 [`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") 完成后，[`SessionEvents.after_transaction_create()`](../orm/events.html#sqlalchemy.orm.SessionEvents.after_transaction_create
    "sqlalchemy.orm.SessionEvents.after_transaction_create") 事件钩子不会立即被触发。
- en: The [`Session.close()`](../orm/session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") method also does not imply implicit begin of a
    new [`SessionTransaction`](../orm/session_api.html#sqlalchemy.orm.SessionTransaction
    "sqlalchemy.orm.SessionTransaction").
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`Session.close()`](../orm/session_api.html#sqlalchemy.orm.Session.close "sqlalchemy.orm.Session.close")
    方法也不意味着隐式开始一个新的 [`SessionTransaction`](../orm/session_api.html#sqlalchemy.orm.SessionTransaction
    "sqlalchemy.orm.SessionTransaction")。'
- en: See also
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Auto Begin](../orm/session_basics.html#session-autobegin)'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '[自动开始](../orm/session_basics.html#session-autobegin)'
- en: Rationale
  id: totrans-404
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 理由
- en: The [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    object’s default behavior of `autocommit=False` historically has meant that there
    is always a [`SessionTransaction`](../orm/session_api.html#sqlalchemy.orm.SessionTransaction
    "sqlalchemy.orm.SessionTransaction") object in play, associated with the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") via the `Session.transaction` attribute. When the given
    [`SessionTransaction`](../orm/session_api.html#sqlalchemy.orm.SessionTransaction
    "sqlalchemy.orm.SessionTransaction") was complete, due to a commit, rollback,
    or close, it was immediately replaced with a new one. The [`SessionTransaction`](../orm/session_api.html#sqlalchemy.orm.SessionTransaction
    "sqlalchemy.orm.SessionTransaction") by itself does not imply the usage of any
    connection-oriented resources, so this long-standing behavior has a particular
    elegance to it in that the state of `Session.transaction` is always predictable
    as non-None.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    对象的默认行为 `autocommit=False` 历来意味着始终有一个与 [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 相关的 [`SessionTransaction`](../orm/session_api.html#sqlalchemy.orm.SessionTransaction
    "sqlalchemy.orm.SessionTransaction") 对象，通过 `Session.transaction` 属性关联。当给定的 [`SessionTransaction`](../orm/session_api.html#sqlalchemy.orm.SessionTransaction
    "sqlalchemy.orm.SessionTransaction") 完成时，由于提交、回滚或关闭，它会立即被新的替换。[`SessionTransaction`](../orm/session_api.html#sqlalchemy.orm.SessionTransaction
    "sqlalchemy.orm.SessionTransaction") 本身并不意味着使用任何连接相关资源，因此这种长期存在的行为具有特定的优雅之处，即
    `Session.transaction` 的状态始终可预测为非 None。'
- en: However, as part of the initiative in [#5056](https://www.sqlalchemy.org/trac/ticket/5056)
    to greatly reduce reference cycles, this assumption means that calling upon [`Session.close()`](../orm/session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") results in a [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") object that still has reference cycles and is more expensive
    to clean up, not to mention that there is a small overhead in constructing the
    [`SessionTransaction`](../orm/session_api.html#sqlalchemy.orm.SessionTransaction
    "sqlalchemy.orm.SessionTransaction") object, which meant that there would be unnecessary
    overhead created for a [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") that for example invoked [`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") and then [`Session.close()`](../orm/session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close").
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，作为大大减少引用循环的[#5056](https://www.sqlalchemy.org/trac/ticket/5056)倡议的一部分，这种假设意味着调用[`Session.close()`](../orm/session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close")会导致一个仍然存在引用循环且更难清理的[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")对象，更不用说构造[`SessionTransaction`](../orm/session_api.html#sqlalchemy.orm.SessionTransaction
    "sqlalchemy.orm.SessionTransaction")对象的一点小开销了，这意味着会为一个例如调用了[`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit")然后再调用[`Session.close()`](../orm/session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close")的[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")创建不必要的开销。
- en: As such, it was decided that [`Session.close()`](../orm/session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") should leave the internal state of `self.transaction`,
    now referred to internally as `self._transaction`, as None, and that a new [`SessionTransaction`](../orm/session_api.html#sqlalchemy.orm.SessionTransaction
    "sqlalchemy.orm.SessionTransaction") should only be created when needed. For consistency
    and code coverage, this behavior was also expanded to include all the points at
    which “autobegin” is expected, not just when [`Session.close()`](../orm/session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") were called.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，决定[`Session.close()`](../orm/session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close")在内部状态`self.transaction`，现在内部称为`self._transaction`，留为空，并且只在需要时创建一个新的[`SessionTransaction`](../orm/session_api.html#sqlalchemy.orm.SessionTransaction
    "sqlalchemy.orm.SessionTransaction")。为了一致性和代码覆盖率，此行为还扩展到了所有期望“autobegin”的点，不仅仅是在调用[`Session.close()`](../orm/session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close")时。
- en: In particular, this causes a behavioral change for applications which subscribe
    to the [`SessionEvents.after_transaction_create()`](../orm/events.html#sqlalchemy.orm.SessionEvents.after_transaction_create
    "sqlalchemy.orm.SessionEvents.after_transaction_create") event hook; previously,
    this event would be emitted when the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") were first constructed, as well as for most actions
    that closed the previous transaction and would emit [`SessionEvents.after_transaction_end()`](../orm/events.html#sqlalchemy.orm.SessionEvents.after_transaction_end
    "sqlalchemy.orm.SessionEvents.after_transaction_end"). The new behavior is that
    [`SessionEvents.after_transaction_create()`](../orm/events.html#sqlalchemy.orm.SessionEvents.after_transaction_create
    "sqlalchemy.orm.SessionEvents.after_transaction_create") is emitted on demand,
    when the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    has not yet created a new [`SessionTransaction`](../orm/session_api.html#sqlalchemy.orm.SessionTransaction
    "sqlalchemy.orm.SessionTransaction") object and mapped objects are associated
    with the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    through methods like [`Session.add()`](../orm/session_api.html#sqlalchemy.orm.Session.add
    "sqlalchemy.orm.Session.add") and [`Session.delete()`](../orm/session_api.html#sqlalchemy.orm.Session.delete
    "sqlalchemy.orm.Session.delete"), when the `Session.transaction` attribute is
    called upon, when the [`Session.flush()`](../orm/session_api.html#sqlalchemy.orm.Session.flush
    "sqlalchemy.orm.Session.flush") method has tasks to complete, etc.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，这对于订阅[`SessionEvents.after_transaction_create()`](../orm/events.html#sqlalchemy.orm.SessionEvents.after_transaction_create
    "sqlalchemy.orm.SessionEvents.after_transaction_create")事件钩子的应用程序造成了行为上的改变；之前，当构造[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")时，此事件会被触发，以及对关闭上一个事务的大多数操作，并且会触发[`SessionEvents.after_transaction_end()`](../orm/events.html#sqlalchemy.orm.SessionEvents.after_transaction_end
    "sqlalchemy.orm.SessionEvents.after_transaction_end")。新的行为是，当[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")尚未创建新的[`SessionTransaction`](../orm/session_api.html#sqlalchemy.orm.SessionTransaction
    "sqlalchemy.orm.SessionTransaction")对象且映射对象通过诸如[`Session.add()`](../orm/session_api.html#sqlalchemy.orm.Session.add
    "sqlalchemy.orm.Session.add")和[`Session.delete()`](../orm/session_api.html#sqlalchemy.orm.Session.delete
    "sqlalchemy.orm.Session.delete")等方法与[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")关联时，当调用`Session.transaction`属性时，当[`Session.flush()`](../orm/session_api.html#sqlalchemy.orm.Session.flush
    "sqlalchemy.orm.Session.flush")方法有任务需要完成等情况下，将会按需触发[`SessionEvents.after_transaction_create()`](../orm/events.html#sqlalchemy.orm.SessionEvents.after_transaction_create
    "sqlalchemy.orm.SessionEvents.after_transaction_create")。
- en: In addition, code which relies upon the [`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") or [`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") method to unconditionally expire all objects
    can no longer do so. Code which needs to expire all objects when no change that
    has occurred should be calling [`Session.expire_all()`](../orm/session_api.html#sqlalchemy.orm.Session.expire_all
    "sqlalchemy.orm.Session.expire_all") for this case.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，依赖于[`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit")或[`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback")方法无条件使所有对象过期的代码不能再这样做了。当没有发生变化时需要使所有对象过期的代码应该针对此情况调用[`Session.expire_all()`](../orm/session_api.html#sqlalchemy.orm.Session.expire_all
    "sqlalchemy.orm.Session.expire_all")。
- en: Besides the change in when the [`SessionEvents.after_transaction_create()`](../orm/events.html#sqlalchemy.orm.SessionEvents.after_transaction_create
    "sqlalchemy.orm.SessionEvents.after_transaction_create") event is emitted as well
    as the no-op nature of [`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") or [`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback"), the change should have no other user-visible
    impact on the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    object’s behavior; the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") will continue to have the behavior that it remains usable
    for new operations after [`Session.close()`](../orm/session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") is called, and the sequencing of how the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") interacts with the [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") and the database itself should also remain unaffected,
    since these operations were already operating in an on-demand fashion.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 除了更改[`SessionEvents.after_transaction_create()`](../orm/events.html#sqlalchemy.orm.SessionEvents.after_transaction_create
    "sqlalchemy.orm.SessionEvents.after_transaction_create")事件发出的时间以及[`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit")或[`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback")的无操作性质外，此更改不应对[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")对象的行为产生其他用户可见的影响；[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")在调用[`Session.close()`](../orm/session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close")后仍然保持可用于新操作的行为，并且[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")与[`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine")和数据库本身的交互顺序也应保持不受影响，因为这些操作已经以按需方式运行。
- en: '[#5074](https://www.sqlalchemy.org/trac/ticket/5074)  ### Viewonly relationships
    don’t synchronize backrefs'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '[#5074](https://www.sqlalchemy.org/trac/ticket/5074)  ### 只读视图关系不同步回引'
- en: In [#5149](https://www.sqlalchemy.org/trac/ticket/5149) in 1.3.14, SQLAlchemy
    began emitting a warning when the [`relationship.backref`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.backref
    "sqlalchemy.orm.relationship") or [`relationship.back_populates`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.back_populates
    "sqlalchemy.orm.relationship") keywords would be used at the same time as the
    [`relationship.viewonly`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.viewonly
    "sqlalchemy.orm.relationship") flag on the target relationship. This was because
    a “viewonly” relationship does not actually persist changes made to it, which
    could cause some misleading behaviors to occur. However, in [#5237](https://www.sqlalchemy.org/trac/ticket/5237),
    we sought to refine this behavior as there are legitimate use cases to have backrefs
    set up on viewonly relationships, including that back populates attributes are
    used in some cases by the relationship lazy loaders to determine that an additional
    eager load in the other direction is not necessary, as well as that back populates
    can be used for mapper introspection and that [`backref()`](../orm/relationship_api.html#sqlalchemy.orm.backref
    "sqlalchemy.orm.backref") can be a convenient way to set up bi-directional relationships.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 在1.3.14中的[#5149](https://www.sqlalchemy.org/trac/ticket/5149)中，SQLAlchemy开始在目标关系上同时使用[`relationship.backref`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.backref
    "sqlalchemy.orm.relationship")或[`relationship.back_populates`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.back_populates
    "sqlalchemy.orm.relationship")关键字时发出警告，同时使用[`relationship.viewonly`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.viewonly
    "sqlalchemy.orm.relationship")标志。这是因为“只读”关系实际上不会保存对其所做的更改，这可能导致一些误导行为发生。然而，在[#5237](https://www.sqlalchemy.org/trac/ticket/5237)中，我们试图优化这种行为，因为在只读关系上设置回引是有合法用例的，包括回填属性有时由关系懒加载器用于确定在另一个方向上不需要额外的急加载，以及回填可以用于映射器内省和[`backref()`](../orm/relationship_api.html#sqlalchemy.orm.backref
    "sqlalchemy.orm.backref")可以是设置双向关系的便捷方式。
- en: 'The solution then was to make the “mutation” that occurs from a backref an
    optional thing, using the [`relationship.sync_backref`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.sync_backref
    "sqlalchemy.orm.relationship") flag. In 1.4 the value of [`relationship.sync_backref`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.sync_backref
    "sqlalchemy.orm.relationship") defaults to False for a relationship target that
    also sets [`relationship.viewonly`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.viewonly
    "sqlalchemy.orm.relationship"). This indicates that any changes made to a relationship
    with viewonly will not impact the state of the other side or of the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") in any way:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 那时的解决方案是使从反向引用发生的“变化”成为可选的事情，使用 [`relationship.sync_backref`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.sync_backref
    "sqlalchemy.orm.relationship") 标志。在 1.4 版本中，对于也设置了 [`relationship.viewonly`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.viewonly
    "sqlalchemy.orm.relationship") 的关系目标，默认情况下 [`relationship.sync_backref`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.sync_backref
    "sqlalchemy.orm.relationship") 的值为 False。这表示对具有 viewonly 的关系所做的任何更改都不会以任何方式影响另一侧或
    [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    的状态：
- en: '[PRE89]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Above, the `a1` object will **not** be added to the `u1.addresses` collection,
    nor will the `a1` object be added to the session. Previously, both of these things
    would be true. The warning that [`relationship.sync_backref`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.sync_backref
    "sqlalchemy.orm.relationship") should be set to `False` when [`relationship.viewonly`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.viewonly
    "sqlalchemy.orm.relationship") is `False` is no longer emitted as this is now
    the default behavior.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 上面，`a1` 对象将**不会**被添加到 `u1.addresses` 集合中，也不会将 `a1` 对象添加到会话中。之前，这两件事情都是正确的。当
    [`relationship.viewonly`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.viewonly
    "sqlalchemy.orm.relationship") 为 `False` 时，不再发出需要将 [`relationship.sync_backref`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.sync_backref
    "sqlalchemy.orm.relationship") 设置为 `False` 的警告，因为这现在是默认行为。
- en: '[#5237](https://www.sqlalchemy.org/trac/ticket/5237)  ### cascade_backrefs
    behavior deprecated for removal in 2.0'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '[#5237](https://www.sqlalchemy.org/trac/ticket/5237)  ### 在 2.0 版本中将删除对 cascade_backrefs
    行为的弃用'
- en: 'SQLAlchemy has long had a behavior of cascading objects into the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") based on backref assignment. Given `User` below already
    in a [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session"),
    assigning it to the `Address.user` attribute of an `Address` object, assuming
    a bidirectional relationship is set up, would mean that the `Address` also gets
    put into the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    at that point:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 长期以来一直有一个根据反向引用赋值将对象级联到 [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 的行为。给定下面已经在 [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 中的 `User`，将其分配给 `Address` 对象的 `Address.user` 属性，假设已经建立了双向关系，这意味着在那一点上
    `Address` 也会被放入 [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    中：
- en: '[PRE90]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: The above behavior was an unintended side effect of backref behavior, in that
    since `a1.user` implies `u1.addresses.append(a1)`, `a1` would get cascaded into
    the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session").
    This remains the default behavior throughout 1.4\. At some point, a new flag [`relationship.cascade_backrefs`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.cascade_backrefs
    "sqlalchemy.orm.relationship") was added to disable to above behavior, along with
    [`backref.cascade_backrefs`](../orm/relationship_api.html#sqlalchemy.orm.backref.params.cascade_backrefs
    "sqlalchemy.orm.backref") to set this when the relationship is specified by `relationship.backref`,
    as it can be surprising and also gets in the way of some operations where the
    object would be placed in the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") too early and get prematurely flushed.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 上述行为是backref行为的意外副作用，因为由于`a1.user`意味着`u1.addresses.append(a1)`，`a1`会被级联到[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")中。这在1.4版本中仍然是默认行为。在某个时候，添加了一个新标志[`relationship.cascade_backrefs`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.cascade_backrefs
    "sqlalchemy.orm.relationship")来禁用上述行为，以及[`backref.cascade_backrefs`](../orm/relationship_api.html#sqlalchemy.orm.backref.params.cascade_backrefs
    "sqlalchemy.orm.backref")来在通过`relationship.backref`指定关系时设置此行为，因为这可能会令人惊讶，也会妨碍一些操作，其中对象会过早地放入[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")中并提前刷新。
- en: 'In 2.0, the default behavior will be that “cascade_backrefs” is False, and
    additionally there will be no “True” behavior as this is not generally a desirable
    behavior. When 2.0 deprecation warnings are enabled, a warning will be emitted
    when a “backref cascade” actually takes place. To get the new behavior, either
    set [`relationship.cascade_backrefs`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.cascade_backrefs
    "sqlalchemy.orm.relationship") and [`backref.cascade_backrefs`](../orm/relationship_api.html#sqlalchemy.orm.backref.params.cascade_backrefs
    "sqlalchemy.orm.backref") to `False` on any target relationships, as is already
    supported in 1.3 and earlier, or alternatively make use of the [`Session.future`](../orm/session_api.html#sqlalchemy.orm.Session.params.future
    "sqlalchemy.orm.Session") flag to [2.0-style](../glossary.html#term-1) mode:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 在2.0版本中，默认行为将是“cascade_backrefs”为False，并且此外不会有“True”行为，因为这通常不是一种理想的行为。当启用2.0版本的弃用警告时，当“backref级联”实际发生时，将发出警告。要获得新行为，要么在任何目标关系上将[`relationship.cascade_backrefs`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.cascade_backrefs
    "sqlalchemy.orm.relationship")和[`backref.cascade_backrefs`](../orm/relationship_api.html#sqlalchemy.orm.backref.params.cascade_backrefs
    "sqlalchemy.orm.backref")设置为`False`，就像在1.3版本和更早版本中已经支持的那样，要么使用[`Session.future`](../orm/session_api.html#sqlalchemy.orm.Session.params.future
    "sqlalchemy.orm.Session")标志进入[2.0风格](../glossary.html#term-1)模式：
- en: '[PRE91]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[#5150](https://www.sqlalchemy.org/trac/ticket/5150)  ### Eager loaders emit
    during unexpire operations'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '[#5150](https://www.sqlalchemy.org/trac/ticket/5150)  ### Eager loaders emit
    during unexpire operations'
- en: 'A long sought behavior was that when an expired object is accessed, configured
    eager loaders will run in order to eagerly load relationships on the expired object
    when the object is refreshed or otherwise unexpired. This behavior has now been
    added, so that joinedloaders will add inline JOINs as usual, and selectin/subquery
    loaders will run an “immediateload” operation for a given relationship, when an
    expired object is unexpired or an object is refreshed:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 长期以来一直期望的行为是，当访问一个过期对象时，配置的急切加载器将运行，以便在对象被刷新或以其他方式取消过期时急切加载过期对象上的关系。现在已经添加了这种行为，因此joinedloaders将像往常一样添加内联JOIN，而selectin/subquery
    loaders将在对象被取消过期或对象被刷新时为给定关系运行“immediateload”操作：
- en: '[PRE92]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Above, the `A` object was loaded with a `joinedload()` option associated with
    it in order to eagerly load the `bs` collection. After the `session.commit()`,
    the state of the object is expired. Upon accessing the `.data` column attribute,
    the object is refreshed and this will now include the joinedload operation as
    well:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 上面，`A`对象使用了一个`joinedload()`选项来关联它，以便急切加载`bs`集合。在`session.commit()`之后，对象的状态被标记为过期。在访问`.data`列属性时，对象将被刷新，现在这将包括joinedload操作：
- en: '[PRE93]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: The behavior applies both to loader strategies applied to the [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") directly, as well as with options used with [`Query.options()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.options
    "sqlalchemy.orm.Query.options"), provided that the object was originally loaded
    by that query.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 该行为适用于直接应用于[`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")的加载策略，以及与[`Query.options()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.options
    "sqlalchemy.orm.Query.options")一起使用的选项，前提是对象最初是由该查询加载的。
- en: 'For the “secondary” eager loaders “selectinload” and “subqueryload”, the SQL
    strategy for these loaders is not necessary in order to eagerly load attributes
    on a single object; so they will instead invoke the “immediateload” strategy in
    a refresh scenario, which resembles the query emitted by “lazyload”, emitted as
    an additional query:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 对于“secondary”急切加载器“selectinload”和“subqueryload”，这些加载器的SQL策略并不是为了在单个对象上急切加载属性而必要；因此，在刷新场景中，它们将调用“immediateload”策略，这类似于由“lazyload”发出的查询，作为额外的查询发出：
- en: '[PRE94]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Note that a loader option does not apply to an object that was introduced into
    the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    in a different way. That is, if the `a1` object were just persisted in this [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), or was loaded with a different query before the eager
    option had been applied, then the object doesn’t have an eager load option associated
    with it. This is not a new concept, however users who are looking for the eagerload
    on refresh behavior may find this to be more noticeable.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，加载器选项不适用于以不同方式引入到[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")中的对象。也就是说，如果`a1`对象只是在这个[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")中持久化，或者在急切选项应用之前用不同的查询加载了该对象，则该对象不具有与之关联的急切加载选项。这并不是一个新概念，但是寻找刷新行为上的eagerload的用户可能会发现这更加明显。
- en: '[#1763](https://www.sqlalchemy.org/trac/ticket/1763)  ### Column loaders such
    as `deferred()`, `with_expression()` only take effect when indicated on the outermost,
    full entity query'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: '[#1763](https://www.sqlalchemy.org/trac/ticket/1763)  ### 列加载器，如`deferred()`，`with_expression()`，仅在最外层的完整实体查询中指示时才生效'
- en: Note
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This change note was not present in earlier versions of this document, however
    is relevant for all SQLAlchemy 1.4 versions.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 这个变更说明在本文档的早期版本中不存在，但对于所有SQLAlchemy 1.4版本都是相关的。
- en: 'A behavior that was never supported in 1.3 and previous versions yet nonetheless
    would have a particular effect was to repurpose column loader options such as
    [`defer()`](../orm/queryguide/columns.html#sqlalchemy.orm.defer "sqlalchemy.orm.defer")
    and [`with_expression()`](../orm/queryguide/columns.html#sqlalchemy.orm.with_expression
    "sqlalchemy.orm.with_expression") in subqueries in order to control which SQL
    expressions would be in the columns clause of each subquery. A typical example
    would be to construct UNION queries, such as:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 1.3版本及之前版本从未支持的行为，但仍然会产生特定效果，是重新利用列加载器选项，如[`defer()`](../orm/queryguide/columns.html#sqlalchemy.orm.defer
    "sqlalchemy.orm.defer")和[`with_expression()`](../orm/queryguide/columns.html#sqlalchemy.orm.with_expression
    "sqlalchemy.orm.with_expression") 在子查询中，以控制每个子查询的列子句中的SQL表达式。一个典型的例子是构建UNION查询，例如：
- en: '[PRE95]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'In version 1.3, the [`with_expression()`](../orm/queryguide/columns.html#sqlalchemy.orm.with_expression
    "sqlalchemy.orm.with_expression") option would take effect for each element of
    the UNION, such as:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 在1.3版本中，[`with_expression()`](../orm/queryguide/columns.html#sqlalchemy.orm.with_expression
    "sqlalchemy.orm.with_expression")选项会对UNION的每个元素生效，例如：
- en: '[PRE96]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'SQLAlchemy 1.4’s notion of loader options has been made more strict, and as
    such are applied to the **outermost part of the query only**, which is the SELECT
    that is intended to populate the actual ORM entities to be returned; the query
    above in 1.4 will produce:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 1.4对加载器选项的概念变得更加严格，因此仅应用于**查询的最外层部分**，即用于填充实际要返回的ORM实体的SELECT；在1.4中上面的查询将产生：
- en: '[PRE97]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: that is, the options for the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") were taken from the first element of the UNION, since
    all loader options are only to be at the topmost level. The option from the second
    query was ignored.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")的选项是从UNION的第一个元素中获取的，因为所有加载器选项只能在最顶层。第二个查询的选项被忽略了。
- en: Rationale
  id: totrans-441
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 理由
- en: This behavior now more closely matches that of other kinds of loader options
    such as relationship loader options like [`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload") in all SQLAlchemy versions, 1.3 and earlier included,
    which in a UNION situation were already copied out to the top most level of the
    query, and only taken from the first element of the UNION, discarding any options
    on other parts of the query.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 此行为现在更加接近于其他种类的加载选项，如在所有SQLAlchemy版本中，1.3及更早版本已经复制到查询的最顶层的关系加载器选项，如 [`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload")，在UNION情况下已经复制到了查询的顶层，并且只从UNION的第一个元素中取出选项，丢弃查询的其他部分上的任何选项。
- en: This implicit copying and selective ignoring of options, demonstrated above
    as being fairly arbitrary, is a legacy behavior that’s only part of [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query"), and is a particular example of where [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") and its means of applying [`Query.union_all()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.union_all
    "sqlalchemy.orm.Query.union_all") falls short, as it’s ambiguous how to turn a
    single SELECT into a UNION of itself and another query and how loader options
    should be applied to that new statement.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 上面展示的隐式复制和选择性忽略选项的行为，是一种遗留行为，仅限于 [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") 的一部分，是一个特殊的例子，说明了 [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") 及其应用 [`Query.union_all()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.union_all
    "sqlalchemy.orm.Query.union_all") 的方式存在不足之处，因为不清楚如何将单个 SELECT 转换为自身和另一个查询的 UNION，并且不清楚如何将加载选项应用于该新语句。
- en: 'SQLAlchemy 1.4’s behavior can be demonstrated as generally superior to that
    of 1.3 for a more common case of using [`defer()`](../orm/queryguide/columns.html#sqlalchemy.orm.defer
    "sqlalchemy.orm.defer"). The following query:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 1.4的行为可展示为通常优于1.3版本的情况，用于更常见情况的使用 [`defer()`](../orm/queryguide/columns.html#sqlalchemy.orm.defer
    "sqlalchemy.orm.defer")。以下查询：
- en: '[PRE98]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'In 1.3 would awkwardly add NULL to the inner queries and then SELECT it:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 在1.3版本中会笨拙地向内部查询添加NULL，然后选择它：
- en: '[PRE99]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: If all queries didn’t have the identical options set up, the above scenario
    would raise an error due to not being able to form a proper UNION.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有查询没有设置相同的选项，上述情况将由于无法形成正确的 UNION 而引发错误。
- en: 'Whereas in 1.4, the option is applied only at the top layer, omitting the fetch
    for `User.name`, and this complexity is avoided:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 而在1.4中，该选项仅应用于顶层，省略了对 `User.name` 的获取，并且避免了这种复杂性：
- en: '[PRE100]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: Correct Approach
  id: totrans-451
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 正确的方法
- en: 'Using [2.0-style](../glossary.html#term-1) querying, no warning is emitted
    at the moment, however the nested [`with_expression()`](../orm/queryguide/columns.html#sqlalchemy.orm.with_expression
    "sqlalchemy.orm.with_expression") options are consistently ignored as they don’t
    apply to an entity being loaded, and are not implicitly copied anywhere. The query
    below produces no output for the [`with_expression()`](../orm/queryguide/columns.html#sqlalchemy.orm.with_expression
    "sqlalchemy.orm.with_expression") calls:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 [2.0风格](../glossary.html#term-1) 查询时，目前不会发出警告，然而嵌套的 [`with_expression()`](../orm/queryguide/columns.html#sqlalchemy.orm.with_expression
    "sqlalchemy.orm.with_expression") 选项一直被忽略，因为它们不适用于正在加载的实体，并且不会被隐式复制到任何地方。下面的查询对
    [`with_expression()`](../orm/queryguide/columns.html#sqlalchemy.orm.with_expression
    "sqlalchemy.orm.with_expression") 调用不产生任何输出：
- en: '[PRE101]'
  id: totrans-453
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'producing the SQL:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 生成SQL：
- en: '[PRE102]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'To correctly apply [`with_expression()`](../orm/queryguide/columns.html#sqlalchemy.orm.with_expression
    "sqlalchemy.orm.with_expression") to the `User` entity, it should be applied to
    the outermost level of the query, using an ordinary SQL expression inside the
    columns clause of each SELECT:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 要正确应用 [`with_expression()`](../orm/queryguide/columns.html#sqlalchemy.orm.with_expression
    "sqlalchemy.orm.with_expression") 到 `User` 实体，应该将其应用于查询的最外层，使用每个 SELECT 的列子句中的普通
    SQL 表达式：
- en: '[PRE103]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Which will produce the expected SQL:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 将产生预期的 SQL：
- en: '[PRE104]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'The `User` objects themselves will include this expression in their contents
    underneath `User.expr`.  ### Accessing an uninitialized collection attribute on
    a transient object no longer mutates __dict__'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: '`User` 对象本身将在其内容中包含此表达式，在 `User.expr` 下面。### 在临时对象上访问未初始化的集合属性不再改变 __dict__'
- en: 'It has always been SQLAlchemy’s behavior that accessing mapped attributes on
    a newly created object returns an implicitly generated value, rather than raising
    `AttributeError`, such as `None` for scalar attributes or `[]` for a list-holding
    relationship:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy一直以来的行为是，在新创建的对象上访问映射属性会返回一个隐式生成的值，而不是引发`AttributeError`，例如对于标量属性是`None`，对于保存列表的关系是`[]`：
- en: '[PRE105]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'The rationale for the above behavior was originally to make ORM objects easier
    to work with. Since an ORM object represents an empty row when first created without
    any state, it is intuitive that its un-accessed attributes would resolve to `None`
    (or SQL NULL) for scalars and to empty collections for relationships. In particular,
    it makes possible an extremely common pattern of being able to mutate the new
    collection without manually creating and assigning an empty collection first:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 上述行为的原因最初是为了使ORM对象更易于使用。由于ORM对象在刚创建时代表一个空行而没有任何状态，因此直观地认为其未访问的属性会解析为标量的`None`（或SQL
    NULL），对于关系则是空集合。特别是，这使得一种极其常见的模式成为可能，即能够在不手动创建和分配空集合的情况下改变新集合：
- en: '[PRE106]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Up until version 1.0 of SQLAlchemy, the behavior of this initialization system
    for both scalar attributes as well as collections would be that the `None` or
    empty collection would be *populated* into the object’s state, e.g. `__dict__`.
    This meant that the following two operations were equivalent:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 直到SQLAlchemy的1.0版本，这种初始化系统对标量属性和集合的行为都是将`None`或空集合*填充*到对象的状态中，例如`__dict__`。这意味着以下两个操作是等效的：
- en: '[PRE107]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Where above, both `u1` and `u2` would have the value `None` populated in the
    value of the `name` attribute. Since this is a SQL NULL, the ORM would skip including
    these values within an INSERT so that SQL-level defaults take place, if any, else
    the value defaults to NULL on the database side.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述情况下，`u1`和`u2`都会在`name`属性的值中填充`None`。由于这是一个SQL NULL，ORM会跳过将这些值包含在INSERT中，以便SQL级别的默认值生效，否则值会默认为数据库端的NULL。
- en: In version 1.0 as part of [Changes to attribute events and other operations
    regarding attributes that have no pre-existing value](migration_10.html#migration-3061),
    this behavior was refined so that the `None` value was no longer populated into
    `__dict__`, only returned. Besides removing the mutating side effect of a getter
    operation, this change also made it possible to set columns that did have server
    defaults to the value NULL by actually assigning `None`, which was now distinguished
    from just reading it.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 作为[关于没有预先存在值的属性的属性事件和其他操作的更改](migration_10.html#migration-3061)的一部分，在1.0版本中，这种行为被调整，以便`None`值不再填充到`__dict__`中，只是返回。除了消除getter操作的变异副作用外，这种变化还使得可以通过实际分配`None`来将具有服务器默认值的列设置为NULL，现在可以区分出只是读取它。
- en: 'The change however did not accommodate for collections, where returning an
    empty collection that is not assigned meant that this mutable collection would
    be different each time and also would not be able to correctly accommodate for
    mutating operations (e.g. append, add, etc.) called upon it. While the behavior
    continued to generally not get in anyone’s way, an edge case was eventually identified
    in [#4519](https://www.sqlalchemy.org/trac/ticket/4519) where this empty collection
    could be harmful, which is when the object is merged into a session:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种变化并没有考虑到集合，其中返回一个未分配的空集合意味着这个可变集合每次都会不同，并且也无法正确地适应变异操作（例如追加、添加等）。虽然这种行为通常不会妨碍任何人，但最终在[#4519](https://www.sqlalchemy.org/trac/ticket/4519)中识别出了一个边缘情况，即当对象合并到会话中时，这个空集合可能会有害：
- en: '[PRE108]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: Above, the `.addresses` collection on `merged1` will contain all the `Address()`
    objects that were already in the database. `merged2` will not; because it has
    an empty list implicitly assigned, the `.addresses` collection will be erased.
    This is an example of where this mutating side effect can actually mutate the
    database itself.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述情况下，`merged1`上的`.addresses`集合将包含已经存在于数据库中的所有`Address()`对象。而`merged2`不会；因为它有一个隐式分配的空列表，`.addresses`集合将被擦除。这是一个例子，说明这种变异的副作用实际上可以改变数据库本身。
- en: While it was considered that perhaps the attribute system should begin using
    strict “plain Python” behavior, raising `AttributeError` in all cases for non-existent
    attributes on non-persistent objects and requiring that all collections be explicitly
    assigned, such a change would likely be too extreme for the vast number of applications
    that have relied upon this behavior for many years, leading to a complex rollout
    / backwards compatibility problem as well as the likelihood that workarounds to
    restore the old behavior would become prevalent, thus rendering the whole change
    ineffective in any case.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然曾考虑过属性系统是否应该开始使用严格的“纯Python”行为，在所有情况下对非存在属性的非持久对象引发`AttributeError`，并要求所有集合都明确分配，但这样的改变可能对多年来依赖于这种行为的大量应用程序来说过于极端，导致复杂的发布/向后兼容性问题，以及恢复旧行为的解决方法可能会变得普遍，从而使整个改变在任何情况下都变得无效。
- en: 'The change then is to keep the default producing behavior, but to finally make
    the non-mutating behavior of scalars a reality for collections as well, via the
    addition of additional mechanics in the collection system. When accessing the
    empty attribute, the new collection is created and associated with the state,
    however is not added to `__dict__` until it is actually mutated:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 然后的改变是保持默认的生成行为，但最终使标量的非变异行为对集合也成为现实，通过在集合系统中添加额外的机制。当访问空属性时，新的集合被创建并与状态关联，但直到实际变异才添加到`__dict__`中：
- en: '[PRE109]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'When the list is changed, then it becomes part of the tracked changes to be
    persisted to the database:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 当列表被更改时，它就成为要持久化到数据库的跟踪更改的一部分：
- en: '[PRE110]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'This change is expected to have *nearly* no impact on existing applications
    in any way, except that it has been observed that some applications may be relying
    upon the implicit assignment of this collection, such as to assert that the object
    contains certain values based on its `__dict__`:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 这个改变预计对现有应用程序几乎没有任何影响，除了观察到一些应用程序可能依赖于对该集合的隐式分配，例如根据其`__dict__`中的某些值来断言对象包含某些值：
- en: '[PRE111]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'or to ensure that the collection won’t require a lazy load to proceed, the
    (admittedly awkward) code below will now also fail:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 或者确保集合不需要延迟加载才能继续进行，下面（尽管有些尴尬）的代码现在也会失败：
- en: '[PRE112]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Applications that rely upon the implicit mutating behavior of collections will
    need to be changed so that they assign the desired collection explicitly:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖于集合的隐式变异行为的应用程序需要更改，以便明确地分配所需的集合：
- en: '[PRE113]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[#4519](https://www.sqlalchemy.org/trac/ticket/4519)  ### The “New instance
    conflicts with existing identity” error is now a warning'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4519](https://www.sqlalchemy.org/trac/ticket/4519)  ### “新实例与现有标识冲突”错误现在是一个警告'
- en: 'SQLAlchemy has always had logic to detect when an object in the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") to be inserted has the same primary key as an object
    that is already present:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy一直有逻辑来检测当一个要插入到[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")中的对象具有与已经存在的对象相同的主键时：
- en: '[PRE114]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'The change is that the [`FlushError`](../orm/exceptions.html#sqlalchemy.orm.exc.FlushError
    "sqlalchemy.orm.exc.FlushError") is altered to be only a warning:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 改变是[`FlushError`](../orm/exceptions.html#sqlalchemy.orm.exc.FlushError "sqlalchemy.orm.exc.FlushError")被修改为仅仅是一个警告：
- en: '[PRE115]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Subsequent to that, the condition will attempt to insert the row into the database
    which will emit [`IntegrityError`](../core/exceptions.html#sqlalchemy.exc.IntegrityError
    "sqlalchemy.exc.IntegrityError"), which is the same error that would be raised
    if the primary key identity was not already present in the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"):'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 随后，条件将尝试将行插入到数据库中，这将引发[`IntegrityError`](../core/exceptions.html#sqlalchemy.exc.IntegrityError
    "sqlalchemy.exc.IntegrityError")，这是与[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")中已存在的主键标识不同的错误：
- en: '[PRE116]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'The rationale is to allow code that is using [`IntegrityError`](../core/exceptions.html#sqlalchemy.exc.IntegrityError
    "sqlalchemy.exc.IntegrityError") to catch duplicates to function regardless of
    the existing state of the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), as is often done using savepoints:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的理由是允许使用[`IntegrityError`](../core/exceptions.html#sqlalchemy.exc.IntegrityError
    "sqlalchemy.exc.IntegrityError")来捕获重复项的代码能够正常运行，而不受[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")的现有状态的影响，通常使用保存点来实现：
- en: '[PRE117]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: The above logic was not fully feasible earlier, as in the case that the `Product`
    object with the existing identity were already in the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), the code would also have to catch [`FlushError`](../orm/exceptions.html#sqlalchemy.orm.exc.FlushError
    "sqlalchemy.orm.exc.FlushError"), which additionally is not filtered for the specific
    condition of integrity issues. With the change, the above block behaves consistently
    with the exception of the warning also being emitted.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 早期上述逻辑并不完全可行，因为如果具有现有标识的 `Product` 对象已经在 [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 中，代码还必须捕获 [`FlushError`](../orm/exceptions.html#sqlalchemy.orm.exc.FlushError
    "sqlalchemy.orm.exc.FlushError")，此外，该错误还未针对完整性问题的特定条件进行过滤。通过更改，上述块的行为与发出警告的异常一致。
- en: Since the logic in question deals with the primary key, all databases emit an
    integrity error in the case of primary key conflicts on INSERT. The case where
    an error would not be raised, that would have earlier, is the extremely unusual
    scenario of a mapping that defines a primary key on the mapped selectable that
    is more restrictive than what is actually configured in the database schema, such
    as when mapping to joins of tables or when defining additional columns as part
    of a composite primary key that is not actually constrained in the database schema.
    However, these situations also work more consistently in that the INSERT would
    theoretically proceed whether or not the existing identity were still in the database.
    The warning can also be configured to raise an exception using the Python warnings
    filter.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 由于涉及的逻辑处理主键，所有数据库在插入时出现主键冲突时都会发出完整性错误。不会引发错误的情况是极不寻常的，即定义了一个在映射的可选择项上定义了比实际配置的数据库模式更严格的主键的映射，例如在表的连接或在定义附加列作为复合主键的一部分时，这些列实际上在数据库模式中没有约束。然而，这些情况也更一致地工作，即使现有的标识仍然存在于数据库中，插入理论上也会继续进行。警告也可以使用
    Python 警告过滤器配置为引发异常。
- en: '[#4662](https://www.sqlalchemy.org/trac/ticket/4662)  ### Persistence-related
    cascade operations disallowed with viewonly=True'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4662](https://www.sqlalchemy.org/trac/ticket/4662)  ### 持久性相关的级联操作在 viewonly=True
    时不允许'
- en: When a [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") is set as `viewonly=True` using the [`relationship.viewonly`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.viewonly
    "sqlalchemy.orm.relationship") flag, it indicates this relationship should only
    be used to load data from the database, and should not be mutated or involved
    in a persistence operation. In order to ensure this contract works successfully,
    the relationship can no longer specify [`relationship.cascade`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.cascade
    "sqlalchemy.orm.relationship") settings that make no sense in terms of “viewonly”.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 [`relationship.viewonly`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.viewonly
    "sqlalchemy.orm.relationship") 标志将 [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") 设置为 `viewonly=True` 时，表示此关系仅应用于从数据库加载数据，不应进行变异或涉及持久性操作。为确保此约定成功运行，关系不再能指定在“仅查看”方面毫无意义的
    [`relationship.cascade`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.cascade
    "sqlalchemy.orm.relationship") 设置。
- en: 'The primary targets here are the “delete, delete-orphan” cascades, which through
    1.3 continued to impact persistence even if viewonly were True, which is a bug;
    even if viewonly were True, an object would still cascade these two operations
    onto the related object if the parent were deleted or the object were detached.
    Rather than modify the cascade operations to check for viewonly, the configuration
    of both of these together is simply disallowed:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的主要目标是“删除，删除孤儿”级联，即使 viewonly 为 True，通过 1.3 仍会影响持久性，这是一个错误；即使 viewonly 为 True，如果删除父对象或分离对象，对象仍会级联这两个操作到相关对象。而不是修改级联操作以检查
    viewonly，这两者的配置简单地被禁止：
- en: '[PRE118]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'The above will raise:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 上述将引发：
- en: '[PRE119]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: Applications that have this issue should be emitting a warning as of SQLAlchemy
    1.3.12, and for the above error the solution is to remove the cascade settings
    for a viewonly relationship.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序存在此问题的情况下，从 SQLAlchemy 1.3.12 开始应发出警告，对于上述错误，解决方法是移除仅用于查看的关系的级联设置。
- en: '[#4993](https://www.sqlalchemy.org/trac/ticket/4993) [#4994](https://www.sqlalchemy.org/trac/ticket/4994)  ###
    Stricter behavior when querying inheritance mappings using custom queries'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4993](https://www.sqlalchemy.org/trac/ticket/4993) [#4994](https://www.sqlalchemy.org/trac/ticket/4994)  ###
    使用自定义查询查询继承映射时更严格的行为'
- en: This change applies to the scenario where a joined- or single- table inheritance
    subclass entity is being queried, given a completed SELECT subquery to select
    from. If the given subquery returns rows that do not correspond to the requested
    polymorphic identity or identities, an error is raised. Previously, this condition
    would pass silently under joined table inheritance, returning an invalid subclass,
    and under single table inheritance, the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") would be adding additional criteria against the subquery
    to limit the results which could inappropriately interfere with the intent of
    the query.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 这个更改适用于查询已完成的SELECT子查询以选择的情况下，一个连接或单个表继承子类实体。如果给定的子查询返回的行不对应于请求的多态标识或标识，将引发错误。以前，在连接表继承下，这种情况会悄悄通过，返回一个无效的子类，而在单表继承下，[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")会添加额外的条件来限制结果，这可能会不恰当地干扰查询的意图。
- en: 'Given the example mapping of `Employee`, `Engineer(Employee)`, `Manager(Employee)`,
    in the 1.3 series if we were to emit the following query against a joined inheritance
    mapping:'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于`Employee`，`Engineer(Employee)`，`Manager(Employee)`的示例映射，在1.3系列中，如果我们针对连接继承映射发出以下查询：
- en: '[PRE120]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'The subquery selects both the `Engineer` and the `Manager` rows, and even though
    the outer query is against `Manager`, we get a non `Manager` object back:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 子查询同时选择`Engineer`和`Manager`行，即使外部查询针对`Manager`，我们也会得到一个非`Manager`对象：
- en: '[PRE121]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'The new behavior is that this condition raises an error:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 新的行为是这种情况引发错误：
- en: '[PRE122]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: The above error only raises if the primary key columns of that entity are non-NULL.
    If there’s no primary key for a given entity in a row, no attempt to construct
    an entity is made.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 仅当该实体的主键列为非NULL时，才会引发上述错误。如果一行中没有给定实体的主键，则不会尝试构造实体。
- en: 'In the case of single inheritance mapping, the change in behavior is slightly
    more involved; if `Engineer` and `Manager` above are mapped with single table
    inheritance, in 1.3 the following query would be emitted and only a `Manager`
    object is returned:'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 在单一继承映射的情况下，行为的变化稍微更为复杂；如果上述的`Engineer`和`Manager`被映射为单表继承，在1.3中将发出以下查询，并且只返回一个`Manager`对象：
- en: '[PRE123]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'The [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    added the “single table inheritance” criteria to the subquery, editorializing
    on the intent that was originally set up by it. This behavior was added in version
    1.0 in [#3891](https://www.sqlalchemy.org/trac/ticket/3891), and creates a behavioral
    inconsistency between “joined” and “single” table inheritance, and additionally
    modifies the intent of the given query, which may intend to return additional
    rows where the columns that correspond to the inheriting entity are NULL, which
    is a valid use case. The behavior is now equivalent to that of joined table inheritance,
    where it is assumed that the subquery returns the correct rows and an error is
    raised if an unexpected polymorphic identity is encountered:'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")向子查询添加了“单表继承”条件，对最初设置的意图进行了评论。这种行为是在版本1.0中添加的，在[#3891](https://www.sqlalchemy.org/trac/ticket/3891)中，它在“连接”和“单”表继承之间创建了行为不一致，并且还修改了给定查询的意图，可能意图返回额外的行，其中对应于继承实体的列为NULL，这是一个有效的用例。现在的行为等同于连接表继承的行为，其中假定子查询返回正确的行，如果遇到意外的多态标识，则会引发错误：'
- en: '[PRE124]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'The correct adjustment to the situation as presented above which worked on
    1.3 is to adjust the given subquery to correctly filter the rows based on the
    discriminator column:'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 对于上述情况的正确调整，在1.3上运行的是调整给定子查询以根据鉴别器列正确过滤行：
- en: '[PRE125]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[#5122](https://www.sqlalchemy.org/trac/ticket/5122)'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: '[#5122](https://www.sqlalchemy.org/trac/ticket/5122)'
- en: Dialect Changes
  id: totrans-518
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方言更改
- en: pg8000 minimum version is 1.16.6, supports Python 3 only
  id: totrans-519
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: pg8000的最低版本是1.16.6，仅支持Python 3
- en: Support for the pg8000 dialect has been dramatically improved, with help from
    the project’s maintainer.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 对pg8000方言的支持得到了显着改进，得益于项目的维护者。
- en: Due to API changes, the pg8000 dialect now requires version 1.16.6 or greater.
    The pg8000 series has dropped Python 2 support as of the 1.13 series. Python 2
    users who require pg8000 should ensure their requirements are pinned at `SQLAlchemy<1.4`.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 API 变化，pg8000 方言现在需要版本 1.16.6 或更高版本。自 1.13 系列起，pg8000 系列已不再支持 Python 2。需要
    pg8000 的 Python 2 用户应确保其要求固定在 `SQLAlchemy<1.4`。
- en: '[#5451](https://www.sqlalchemy.org/trac/ticket/5451)'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: '[#5451](https://www.sqlalchemy.org/trac/ticket/5451)'
- en: psycopg2 version 2.7 or higher is required for the PostgreSQL psycopg2 dialect
  id: totrans-523
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PostgreSQL psycopg2 方言需要版本 2.7 或更高版本的 psycopg2。
- en: The psycopg2 dialect relies upon many features of psycopg2 released in the past
    few years. To simplify the dialect, version 2.7, released in March, 2017 is now
    the minimum version required.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: psycopg2 方言依赖于过去几年中发布的许多 psycopg2 特性。为了简化方言，现在最低所需版本是 2017 年 3 月发布的版本 2.7。
- en: '### psycopg2 dialect no longer has limitations regarding bound parameter names'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: '### psycopg2 方言不再限制绑定参数名称'
- en: SQLAlchemy 1.3 was not able to accommodate bound parameter names that included
    percent signs or parenthesis under the psycopg2 dialect. This in turn meant that
    column names which included these characters were also problematic as INSERT and
    other DML statements would generate parameter names that matched that of the column,
    which would then cause failures. The workaround was to make use of the [`Column.key`](../core/metadata.html#sqlalchemy.schema.Column.params.key
    "sqlalchemy.schema.Column") parameter so that an alternate name that would be
    used to generate the parameter, or otherwise the parameter style of the dialect
    had to be changed at the [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") level. As of SQLAlchemy 1.4.0beta3 all naming limitations
    have been removed and parameters are fully escaped in all scenarios, so these
    workarounds are no longer necessary.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 1.3 无法适应在 psycopg2 方言下包含百分号或括号的绑定参数名称。这反过来意味着包含这些字符的列名也是有问题的，因为 INSERT
    和其他 DML 语句将生成与该列匹配的参数名称，这将导致失败。解决方法是利用 [`Column.key`](../core/metadata.html#sqlalchemy.schema.Column.params.key
    "sqlalchemy.schema.Column") 参数，以便生成参数的备用名称，或者在 [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") 级别更改方言的参数样式。从 SQLAlchemy 1.4.0beta3 开始，所有命名限制都已移除，并且在所有情况下参数都被完全转义，因此这些解决方法不再需要。
- en: '[#5941](https://www.sqlalchemy.org/trac/ticket/5941)'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: '[#5941](https://www.sqlalchemy.org/trac/ticket/5941)'
- en: '[#5653](https://www.sqlalchemy.org/trac/ticket/5653)  ### psycopg2 dialect
    features “execute_values” with RETURNING for INSERT statements by default'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: '[#5653](https://www.sqlalchemy.org/trac/ticket/5653)  ### psycopg2 方言默认使用“execute_values”来进行
    INSERT 语句的 RETURNING 操作'
- en: The first half of a significant performance enhancement for PostgreSQL when
    using both Core and ORM, the psycopg2 dialect now uses `psycopg2.extras.execute_values()`
    by default for compiled INSERT statements and also implements RETURNING support
    in this mode. The other half of this change is [ORM Batch inserts with psycopg2
    now batch statements with RETURNING in most cases](#change-5263) which allows
    the ORM to take advantage of RETURNING with executemany (i.e. batching of INSERT
    statements) so that ORM bulk inserts with psycopg2 are up to 400% faster depending
    on specifics.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 Core 和 ORM 时，对于 PostgreSQL 的重大性能增强的前半部分，psycopg2 方言现在默认使用 `psycopg2.extras.execute_values()`
    来编译 INSERT 语句，并在此模式下实现了 RETURNING 支持。这个变化的另一半是 [ORM 批量插入现在在大多数情况下使用 RETURNING
    的批量语句](#change-5263)，它允许 ORM 利用 executemany（即批量 INSERT 语句的批处理）从而使得使用 psycopg2
    的 ORM 批量插入速度提高了 400% 取决于具体情况。
- en: This extension method allows many rows to be INSERTed within a single statement,
    using an extended VALUES clause for the statement. While SQLAlchemy’s [`insert()`](../core/dml.html#sqlalchemy.sql.expression.insert
    "sqlalchemy.sql.expression.insert") construct already supports this syntax via
    the [`Insert.values()`](../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") method, the extension method allows
    the construction of the VALUES clause to occur dynamically when the statement
    is executed as an “executemany” execution, which is what occurs when one passes
    a list of parameter dictionaries to [`Connection.execute()`](../core/connections.html#sqlalchemy.engine.Connection.execute
    "sqlalchemy.engine.Connection.execute"). It also occurs beyond the cache boundary
    so that the INSERT statement may be cached before the VALUES are rendered.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 此扩展方法允许在单个语句中插入多行，使用语句的扩展 VALUES 子句。虽然 SQLAlchemy 的 [`insert()`](../core/dml.html#sqlalchemy.sql.expression.insert
    "sqlalchemy.sql.expression.insert") 构造已经通过 [`Insert.values()`](../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") 方法支持此语法，但是扩展方法允许在执行语句时动态构建 VALUES 子句，当语句执行为“executemany”执行时，即当将参数字典列表传递给
    [`Connection.execute()`](../core/connections.html#sqlalchemy.engine.Connection.execute
    "sqlalchemy.engine.Connection.execute") 时会发生这种情况。它还发生在缓存边界之外，因此在渲染 VALUES 之前可以缓存
    INSERT 语句。
- en: 'A quick test of the `execute_values()` approach using the `bulk_inserts.py`
    script in the [Performance](../orm/examples.html#examples-performance) example
    suite reveals an approximate **fivefold performance increase**:'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [Performance](../orm/examples.html#examples-performance) 示例套件中使用 `bulk_inserts.py`
    脚本进行 `execute_values()` 方法的快速测试显示了约**五倍的性能提升**：
- en: '[PRE127]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: Support for the “batch” extension was added in version 1.2 in [Support for Batch
    Mode / Fast Execution Helpers](migration_12.html#change-4109), and enhanced to
    include support for the `execute_values` extension in 1.3 in [#4623](https://www.sqlalchemy.org/trac/ticket/4623).
    In 1.4 the `execute_values` extension is now being turned on by default for INSERT
    statements; the “batch” extension for UPDATE and DELETE remains off by default.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 在版本 1.2 中添加了对“批处理”扩展的支持 [Support for Batch Mode / Fast Execution Helpers](migration_12.html#change-4109)，并在版本
    1.3 中增强了对 `execute_values` 扩展的支持 [#4623](https://www.sqlalchemy.org/trac/ticket/4623)。在版本
    1.4 中，对于 INSERT 语句现在默认打开了 `execute_values` 扩展；UPDATE 和 DELETE 的“批处理”扩展仍然默认关闭。
- en: In addition, the `execute_values` extension function supports returning the
    rows that are generated by RETURNING as an aggregated list. The psycopg2 dialect
    will now retrieve this list if the given [`insert()`](../core/dml.html#sqlalchemy.sql.expression.insert
    "sqlalchemy.sql.expression.insert") construct requests returning via the [`Insert.returning()`](../core/dml.html#sqlalchemy.sql.expression.Insert.returning
    "sqlalchemy.sql.expression.Insert.returning") method or similar methods intended
    to return generated defaults; the rows are then installed in the result so that
    they are retrieved as though they came from the cursor directly. This allows tools
    like the ORM to use batched inserts in all cases, which is expected to provide
    a dramatic performance improvement.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: '`execute_values` 扩展函数还支持将由 RETURNING 生成的行作为聚合列表返回。如果给定的 [`insert()`](../core/dml.html#sqlalchemy.sql.expression.insert
    "sqlalchemy.sql.expression.insert") 构造请求返回通过 [`Insert.returning()`](../core/dml.html#sqlalchemy.sql.expression.Insert.returning
    "sqlalchemy.sql.expression.Insert.returning") 方法或类似用于返回生成的默认值的方法生成的行，那么 psycopg2
    方言现在将检索此列表；然后将行安装在结果中，以便像直接来自游标一样检索它们。这使得像 ORM 这样的工具在所有情况下都可以使用批量插入，预计将提供显著的性能改进。'
- en: 'The `executemany_mode` feature of the psycopg2 dialect has been revised with
    the following changes:'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: psycopg2 方言的 `executemany_mode` 功能已经进行了以下更改：
- en: A new mode `"values_only"` is added. This mode uses the very performant `psycopg2.extras.execute_values()`
    extension method for compiled INSERT statements run with executemany(), but does
    not use `execute_batch()` for UPDATE and DELETE statements. This new mode is now
    the default setting for the psycopg2 dialect.
  id: totrans-536
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加了一个新模式 `"values_only"`。此模式使用非常高效的 `psycopg2.extras.execute_values()` 扩展方法来运行编译的
    INSERT 语句，但不使用 `execute_batch()` 来运行 UPDATE 和 DELETE 语句。此新模式现在是 psycopg2 方言的默认设置。
- en: The existing `"values"` mode is now named `"values_plus_batch"`. This mode will
    use `execute_values` for INSERT statements and `execute_batch` for UPDATE and
    DELETE statements. The mode is not enabled by default because it disables the
    proper functioning of `cursor.rowcount` with UPDATE and DELETE statements executed
    with `executemany()`.
  id: totrans-537
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现有的 `"values"` 模式现已更名为 `"values_plus_batch"`。此模式将对 INSERT 语句使用 `execute_values`，并对
    UPDATE 和 DELETE 语句使用 `execute_batch`。该模式默认未启用，因为它会导致使用 `executemany()` 执行的 UPDATE
    和 DELETE 语句的 `cursor.rowcount` 的正常功能受到影响。
- en: RETURNING support is enabled for `"values_only"` and `"values"` for INSERT statements.
    The psycopg2 dialect will receive the rows back from psycopg2 using the fetch=True
    flag and install them into the result set as though they came directly from the
    cursor (which they ultimately did, however psycopg2’s extension function has aggregated
    multiple batches into one list).
  id: totrans-538
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 INSERT 语句，启用了 RETURNING 支持，针对 `"values_only"` 和 `"values"`。Psycopg2 方言将使用
    fetch=True 标志从 psycopg2 中接收行，并将它们安装到结果集中，就好像它们直接来自游标一样（实际上，它们确实是，不过 psycopg2 的扩展函数已将多个批次聚合为一个列表）。
- en: The default “page_size” setting for `execute_values` has been increased from
    100 to 1000\. The default remains at 100 for the `execute_batch` function. These
    parameters may both be modified as was the case before.
  id: totrans-539
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`execute_values` 的默认 “page_size” 设置已从 100 增加到 1000。对于 `execute_batch` 函数，默认值仍为
    100。这些参数可以像以前一样进行修改。'
- en: The `use_batch_mode` flag that was part of the 1.2 version of the feature is
    removed; the behavior remains controllable via the `executemany_mode` flag added
    in 1.3.
  id: totrans-540
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 版本 1.2 中的 `use_batch_mode` 标志已移除；行为仍可通过版本 1.3 中添加的 `executemany_mode` 标志进行控制。
- en: The Core engine and dialect has been enhanced to support executemany plus returning
    mode, currently only available with psycopg2, by providing new [`CursorResult.inserted_primary_key_rows`](../core/connections.html#sqlalchemy.engine.CursorResult.inserted_primary_key_rows
    "sqlalchemy.engine.CursorResult.inserted_primary_key_rows") and `CursorResult.returned_default_rows`
    accessors.
  id: totrans-541
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 核心引擎和方言已增强以支持 executemany 加返回模式，目前仅适用于 psycopg2，通过提供新的 [`CursorResult.inserted_primary_key_rows`](../core/connections.html#sqlalchemy.engine.CursorResult.inserted_primary_key_rows
    "sqlalchemy.engine.CursorResult.inserted_primary_key_rows") 和 `CursorResult.returned_default_rows`
    访问器。
- en: See also
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Psycopg2 Fast Execution Helpers](../dialects/postgresql.html#psycopg2-executemany-mode)'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: '[Psycopg2 快速执行助手](../dialects/postgresql.html#psycopg2-executemany-mode)'
- en: '[#5401](https://www.sqlalchemy.org/trac/ticket/5401)  ### Removed “join rewriting”
    logic from SQLite dialect; updated imports'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: '[#5401](https://www.sqlalchemy.org/trac/ticket/5401) ### 从 SQLite 方言中删除了 “连接重写”
    逻辑；更新了导入'
- en: Dropped support for right-nested join rewriting to support old SQLite versions
    prior to 3.7.16, released in 2013\. It is not expected that any modern Python
    versions rely upon this limitation.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 放弃对右嵌套连接重写的支持，以支持 2013 年发布的旧 SQLite 版本 3.7.16 之前的版本。不期望任何现代 Python 版本依赖于此限制。
- en: The behavior was first introduced in 0.9 and was part of the larger change of
    allowing for right nested joins as described at [Many JOIN and LEFT OUTER JOIN
    expressions will no longer be wrapped in (SELECT * FROM ..) AS ANON_1](migration_09.html#feature-joins-09).
    However the SQLite workaround produced many regressions in the 2013-2014 period
    due to its complexity. In 2016, the dialect was modified so that the join rewriting
    logic would only occur for SQLite versions prior to 3.7.16 after bisection was
    used to identify where SQLite fixed its support for this construct, and no further
    issues were reported against the behavior (even though some bugs were found internally).
    It is now anticipated that there are little to no Python builds for Python 2.7
    or 3.5 and above (the supported Python versions) which would include a SQLite
    version prior to 3.7.17, and the behavior is only necessary only in more complex
    ORM joining scenarios. A warning is now emitted if the installed SQLite version
    is older than 3.7.16.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 该行为首次引入于版本 0.9，并作为允许右嵌套连接的较大更改的一部分，如 [Many JOIN and LEFT OUTER JOIN expressions
    will no longer be wrapped in (SELECT * FROM ..) AS ANON_1](migration_09.html#feature-joins-09)
    中所述。然而，由于其复杂性，SQLite 的解决方法在 2013-2014 年期间产生了许多回归。2016 年，方言被修改，使连接重写逻辑仅在 SQLite
    版本低于 3.7.16 时发生，使用二分法确定了 SQLite 修复了此结构支持的位置之后，并且未报告进一步的问题（尽管在内部发现了一些错误）。现在预计，几乎没有
    Python 2.7 或 3.5 及以上版本（支持的 Python 版本）的构建包含低于 3.7.17 的 SQLite 版本，并且该行为仅在更复杂的 ORM
    连接方案中才是必需的。如果安装的 SQLite 版本旧于 3.7.16，则现在会发出警告。
- en: In related changes, the module imports for SQLite no longer attempt to import
    the “pysqlite2” driver on Python 3 as this driver does not exist on Python 3;
    a very old warning for old pysqlite2 versions is also dropped.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 在相关更改中，SQLite的模块导入不再尝试在Python 3上导入“pysqlite2”驱动程序，因为此驱动程序在Python 3上不存在；对于旧的pysqlite2版本的非常古老警告也被删除。
- en: '[#4895](https://www.sqlalchemy.org/trac/ticket/4895)  ### Added Sequence support
    for MariaDB 10.3'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4895](https://www.sqlalchemy.org/trac/ticket/4895)  ### 为MariaDB 10.3添加了序列支持'
- en: The MariaDB database as of 10.3 supports sequences. SQLAlchemy’s MySQL dialect
    now implements support for the [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence") object against this database, meaning “CREATE SEQUENCE”
    DDL will be emitted for a [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence") that is present in a [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") or [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") collection in the same way as it works for backends
    such as PostgreSQL, Oracle, when the dialect’s server version check has confirmed
    the database is MariaDB 10.3 or greater. Additionally, the [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence") will act as a column default and primary key generation
    object when used in these ways.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 截至MariaDB 10.3，MariaDB数据库支持序列。SQLAlchemy的MySQL方言现在实现了对此数据库的[`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence")对象的支持，这意味着对于在相同方式下的[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")或[`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData")集合中存在的[`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence")，将发出“CREATE SEQUENCE” DDL。就像对于后端如PostgreSQL、Oracle一样，当方言的服务器版本检查确认数据库是MariaDB
    10.3或更高版本时。此外，当以这些方式使用时，[`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence")将作为列默认值和主键生成对象。
- en: 'Since this change will impact the assumptions both for DDL as well as the behavior
    of INSERT statements for an application that is currently deployed against MariaDB
    10.3 which also happens to make explicit use the [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence") construct within its table definitions, it is important
    to note that [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence "sqlalchemy.schema.Sequence")
    supports a flag [`Sequence.optional`](../core/defaults.html#sqlalchemy.schema.Sequence.params.optional
    "sqlalchemy.schema.Sequence") which is used to limit the scenarios in which the
    [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence "sqlalchemy.schema.Sequence")
    to take effect. When “optional” is used on a [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence") that is present in the integer primary key column
    of a table:'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 由于此更改将影响DDL和INSERT语句的假设，对于当前部署在MariaDB 10.3上的应用程序，该应用程序还明确使用其表定义中的[`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence")构造，重要的是要注意[`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence")支持一个标志[`Sequence.optional`](../core/defaults.html#sqlalchemy.schema.Sequence.params.optional
    "sqlalchemy.schema.Sequence")，用于限制[`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence")生效的情况。当在表的整数主键列上使用“optional”时，[`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence")上的“optional”将生效：
- en: '[PRE128]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: The above [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence "sqlalchemy.schema.Sequence")
    is only used for DDL and INSERT statements if the target database does not support
    any other means of generating integer primary key values for the column. That
    is, the Oracle database above would use the sequence, however the PostgreSQL and
    MariaDB 10.3 databases would not. This may be important for an existing application
    that is upgrading to SQLAlchemy 1.4 which may not have emitted DDL for this [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence") against its backing database, as an INSERT statement
    will fail if it seeks to use a sequence that was not created.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 上述[`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence "sqlalchemy.schema.Sequence")仅在目标数据库不支持任何其他生成整数主键值的方式时用于DDL和INSERT语句。也就是说，上述Oracle数据库将使用序列，但是PostgreSQL和MariaDB
    10.3数据库将不会。对于将升级到SQLAlchemy 1.4的现有应用程序可能很重要，因为如果试图使用未创建的序列，则INSERT语句将失败。
- en: See also
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Defining Sequences](../core/defaults.html#defaults-sequences)'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: '[定义序列](../core/defaults.html#defaults-sequences)'
- en: '[#4976](https://www.sqlalchemy.org/trac/ticket/4976)  ### Added Sequence support
    distinct from IDENTITY to SQL Server'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4976](https://www.sqlalchemy.org/trac/ticket/4976)  ### 添加了与 SQL Server 不同的序列支持'
- en: The [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence "sqlalchemy.schema.Sequence")
    construct is now fully functional with Microsoft SQL Server. When applied to a
    [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column"),
    the DDL for the table will no longer include IDENTITY keywords and instead will
    rely upon “CREATE SEQUENCE” to ensure a sequence is present which will then be
    used for INSERT statements on the table.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence "sqlalchemy.schema.Sequence")
    构造现在与 Microsoft SQL Server 完全兼容。当应用于 [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") 时，表的 DDL 将不再包含 IDENTITY 关键字，而是依赖于“CREATE SEQUENCE”以确保序列存在，然后将用于表上的
    INSERT 语句。'
- en: The [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence "sqlalchemy.schema.Sequence")
    prior to version 1.3 was used to control parameters for the IDENTITY column in
    SQL Server; this usage emitted deprecation warnings throughout 1.3 and is now
    removed in 1.4\. For control of parameters for an IDENTITY column, the `mssql_identity_start`
    and `mssql_identity_increment` parameters should be used; see the MSSQL dialect
    documentation linked below.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 在版本 1.3 之前，[`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence "sqlalchemy.schema.Sequence")
    用于控制 SQL Server 中的 IDENTITY 列的参数；这种用法在 1.3 版本中发出了弃用警告，并在 1.4 版本中现已移除。对于控制 IDENTITY
    列的参数，应使用 `mssql_identity_start` 和 `mssql_identity_increment` 参数；请参阅下面链接的 MSSQL
    方言文档。
- en: See also
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Auto Increment Behavior / IDENTITY Columns](../dialects/mssql.html#mssql-identity)'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: '[自增行为 / IDENTITY 列](../dialects/mssql.html#mssql-identity)'
- en: '[#4235](https://www.sqlalchemy.org/trac/ticket/4235)'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4235](https://www.sqlalchemy.org/trac/ticket/4235)'
- en: '[#4633](https://www.sqlalchemy.org/trac/ticket/4633)'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4633](https://www.sqlalchemy.org/trac/ticket/4633)'
- en: Major API changes and features - General
  id: totrans-562
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主要的 API 更改和特性 - 通用
- en: '### Python 3.6 is the minimum Python 3 version; Python 2.7 still supported'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: '### Python 3.6 是最低 Python 3 版本；仍支持 Python 2.7'
- en: 'As Python 3.5 reached EOL in September of 2020, SQLAlchemy 1.4 now places version
    3.6 as the minimum Python 3 version. Python 2.7 is still supported, however the
    SQLAlchemy 1.4 series will be the last series to support Python 2.  ### ORM Query
    is internally unified with select, update, delete; 2.0 style execution available'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: '由于 Python 3.5 在 2020 年 9 月到达 EOL，SQLAlchemy 1.4 现在将版本 3.6 作为最低 Python 3 版本。仍支持
    Python 2.7，但是 SQLAlchemy 1.4 系列将是最后一个支持 Python 2 的系列。  ### ORM 查询在内部与选择、更新、删除统一；2.0
    风格的执行可用'
- en: The biggest conceptual change to SQLAlchemy for version 2.0 and essentially
    in 1.4 as well is that the great separation between the [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") construct in Core and the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object in the ORM has been removed, as well as between
    the [`Query.update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.update
    "sqlalchemy.orm.Query.update") and [`Query.delete()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.delete
    "sqlalchemy.orm.Query.delete") methods in how they relate to [`Update`](../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update") and [`Delete`](../core/dml.html#sqlalchemy.sql.expression.Delete
    "sqlalchemy.sql.expression.Delete").
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 SQLAlchemy 版本 2.0 和本质上的 1.4 来说，最大的概念性改变是核心中的 [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") 构造和 ORM 中的 [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") 对象之间的巨大分离已被移除，以及在它们之间的 [`Query.update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.update
    "sqlalchemy.orm.Query.update") 和 [`Query.delete()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.delete
    "sqlalchemy.orm.Query.delete") 方法与 [`Update`](../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update") 和 [`Delete`](../core/dml.html#sqlalchemy.sql.expression.Delete
    "sqlalchemy.sql.expression.Delete") 的关系。
- en: With regards to [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") and [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query"), these two objects have for many versions had similar,
    largely overlapping APIs and even some ability to change between one and the other,
    while remaining very different in their usage patterns and behaviors. The historical
    background for this was that the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object was introduced to overcome shortcomings in the
    [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select "sqlalchemy.sql.expression.Select")
    object which used to be at the core of how ORM objects were queried, except that
    they had to be queried in terms of [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") metadata only. However [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") had only a simplistic interface for loading objects, and
    only over the course of many major releases did it eventually gain most of the
    flexibility of the [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") object, which then led to the ongoing awkwardness
    that these two objects became highly similar yet still largely incompatible with
    each other.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 关于[`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select "sqlalchemy.sql.expression.Select")和[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")，这两个对象在许多版本中具有类似的、大部分重叠的API，甚至有一些能够在两者之间切换的能力，但在使用模式和行为上仍然有很大的不同。这一历史背景是，[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")对象是为了克服[`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select")对象的缺点而引入的，后者曾经是ORM对象查询的核心，只是它们必须以[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")元数据的形式进行查询。然而，[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")只有一个简单的接口来加载对象，只有在许多主要版本的发布过程中，它最终才获得了大部分[`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select")对象的灵活性，这导致这两个对象变得非常相似，但仍然在很大程度上不兼容。
- en: 'In version 1.4, all Core and ORM SELECT statements are rendered from a [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") object directly; when the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object is used, at statement invocation time it copies
    its state to a [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") which is then invoked internally using [2.0
    style](../glossary.html#term-2.0-style) execution. Going forward, the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object will become legacy only, and applications will
    be encouraged to move to [2.0 style](../glossary.html#term-2.0-style) execution
    which allows Core constructs to be used freely against ORM entities:'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 在版本1.4中，所有核心和ORM SELECT语句都直接从[`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select")对象呈现；当使用[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")对象时，在语句调用时，它会将其状态复制到一个[`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select")对象中，然后使用[2.0风格](../glossary.html#term-2.0-style)执行。未来，[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")对象将仅成为传统，应用程序将被鼓励转向[2.0风格](../glossary.html#term-2.0-style)执行，允许核心构造自由地针对ORM实体使用：
- en: '[PRE129]'
  id: totrans-568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'Things to note about the above example:'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 以上示例的注意事项：
- en: The [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    and [`sessionmaker`](../orm/session_api.html#sqlalchemy.orm.sessionmaker "sqlalchemy.orm.sessionmaker")
    objects now feature full context manager (i.e. the `with:` statement) capability;
    see the revised documentation at [Opening and Closing a Session](../orm/session_basics.html#session-getting)
    for an example.
  id: totrans-570
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")和[`sessionmaker`](../orm/session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker")对象现在具有完整的上下文管理器（即`with:`语句）功能；请参阅[打开和关闭会话](../orm/session_basics.html#session-getting)的修订文档以获取示例。'
- en: Within the 1.4 series, all [2.0 style](../glossary.html#term-2.0-style) ORM
    invocation uses a [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    that includes the [`Session.future`](../orm/session_api.html#sqlalchemy.orm.Session.params.future
    "sqlalchemy.orm.Session") flag set to `True`; this flag indicates the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") should have 2.0-style behaviors, which include that
    ORM queries can be invoked from [`execute`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") as well as some changes in transactional features.
    In version 2.0 this flag will always be `True`.
  id: totrans-571
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 1.4 系列中，所有 [2.0 风格](../glossary.html#term-2.0-style) 的 ORM 调用都使用一个包含 [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 的 [`Session.future`](../orm/session_api.html#sqlalchemy.orm.Session.params.future
    "sqlalchemy.orm.Session") 标志设置为 `True` 的标志；此标志表示 [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 应具有 2.0 风格的行为，其中包括可以从 [`execute`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") 调用 ORM 查询以及一些事务特性的更改。在 2.0 版本中，此标志将始终为 `True`。
- en: The [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select")
    construct no longer needs brackets around the columns clause; see [select(), case()
    now accept positional expressions](#change-5284) for background on this improvement.
  id: totrans-572
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`select()`](../core/selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select")
    构造不再需要在列子句周围加括号；有关此改进，请参见 [select(), case() 现在接受位置表达式](#change-5284)。'
- en: The [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select")
    / [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select "sqlalchemy.sql.expression.Select")
    object has a [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") method that acts like that of the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") and even accommodates an ORM relationship attribute (without
    breaking the separation between Core and ORM!) - see [select().join() and outerjoin()
    add JOIN criteria to the current query, rather than creating a subquery](#change-select-join)
    for background on this.
  id: totrans-573
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`select()`](../core/selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select")
    / [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select "sqlalchemy.sql.expression.Select")
    对象具有一个 [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") 方法，其行为类似于 [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")，甚至可以容纳 ORM 关系属性（而不会破坏 Core 和 ORM 之间的分离！）- 有关此内容，请参见 [select().join()
    和 outerjoin() 将 JOIN 条件添加到当前查询，而不是创建子查询](#change-select-join)。'
- en: Statements that work with ORM entities and are expected to return ORM results
    are invoked using [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute"). See [Querying](../orm/session_basics.html#session-querying-20)
    for a primer. See also the following note at [ORM Session.execute() uses “future”
    style Result sets in all cases](#change-session-execute-result).
  id: totrans-574
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 ORM 实体一起工作并且预计返回 ORM 结果的语句是使用 [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") 调用的。请参见 [Querying](../orm/session_basics.html#session-querying-20)
    以获取入门指南。另请参阅 [ORM Session.execute() 在所有情况下使用“future”风格结果集](#change-session-execute-result)
    中的以下注意事项。
- en: a [`Result`](../core/connections.html#sqlalchemy.engine.Result "sqlalchemy.engine.Result")
    object is returned, rather than a plain list, which itself is a much more sophisticated
    version of the previous `ResultProxy` object; this object is now used both for
    Core and ORM results. See [New Result object](#change-result-14-core), [RowProxy
    is no longer a “proxy”; is now called Row and behaves like an enhanced named tuple](#change-4710-core),
    and [The “KeyedTuple” object returned by Query is replaced by Row](#change-4710-orm)
    for information on this.
  id: totrans-575
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回一个 [`Result`](../core/connections.html#sqlalchemy.engine.Result "sqlalchemy.engine.Result")
    对象，而不是一个普通列表，这本身是以前的 `ResultProxy` 对象的一个更复杂的版本；此对象现在用于 Core 和 ORM 结果。有关此信息，请参见
    [New Result object](#change-result-14-core)，[RowProxy 不再是“代理”；现在称为 Row 并且行为类似于增强的命名元组](#change-4710-core)，以及
    [Query 返回的“KeyedTuple”对象被 Row 替换](#change-4710-orm)。
- en: Throughout SQLAlchemy’s documentation, there will be many references to [1.x
    style](../glossary.html#term-1.x-style) and [2.0 style](../glossary.html#term-2.0-style)
    execution. This is to distinguish between the two querying styles and to attempt
    to forwards-document the new calling style going forward. In SQLAlchemy 2.0, while
    the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    object may remain as a legacy construct, it will no longer be featured in most
    documentation.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 在SQLAlchemy的文档中，将会有许多关于[1.x风格](../glossary.html#term-1.x-style)和[2.0风格](../glossary.html#term-2.0-style)执行的引用。这是为了区分两种查询风格，并尝试向前记录新的调用风格。在SQLAlchemy
    2.0中，虽然[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")对象可能仍然作为传统构造保留，但在大多数文档中将不再出现。
- en: 'Similar adjustments have been made to “bulk updates and deletes” such that
    Core [`update()`](../core/dml.html#sqlalchemy.sql.expression.update "sqlalchemy.sql.expression.update")
    and [`delete()`](../core/dml.html#sqlalchemy.sql.expression.delete "sqlalchemy.sql.expression.delete")
    can be used for bulk operations. A bulk update like the following:'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 对“批量更新和删除”进行了类似的调整，以便核心[`update()`](../core/dml.html#sqlalchemy.sql.expression.update
    "sqlalchemy.sql.expression.update")和[`delete()`](../core/dml.html#sqlalchemy.sql.expression.delete
    "sqlalchemy.sql.expression.delete")可用于批量操作。像下面这样的批量更新：
- en: '[PRE130]'
  id: totrans-578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'can now be achieved in [2.0 style](../glossary.html#term-2.0-style) (and indeed
    the above runs internally in this way) as follows:'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以通过[2.0风格](../glossary.html#term-2.0-style)来实现（实际上上述内容在内部以这种方式运行）如下所示：
- en: '[PRE131]'
  id: totrans-580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: Note the use of the [`Executable.execution_options()`](../core/selectable.html#sqlalchemy.sql.expression.Executable.execution_options
    "sqlalchemy.sql.expression.Executable.execution_options") method to pass ORM-related
    options. The use of “execution options” is now much more prevalent within both
    Core and ORM, and many ORM-related methods from [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") are now implemented as execution options (see [`Query.execution_options()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.execution_options
    "sqlalchemy.orm.Query.execution_options") for some examples).
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意使用[`Executable.execution_options()`](../core/selectable.html#sqlalchemy.sql.expression.Executable.execution_options
    "sqlalchemy.sql.expression.Executable.execution_options")方法传递ORM相关选项。现在“执行选项”的使用在核心和ORM中更加普遍，许多来自[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")的ORM相关方法现在被实现为执行选项（查看[`Query.execution_options()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.execution_options
    "sqlalchemy.orm.Query.execution_options")以获取一些示例）。
- en: See also
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[SQLAlchemy 2.0 - Major Migration Guide](migration_20.html)'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: '[SQLAlchemy 2.0 - 主要迁移指南](migration_20.html)'
- en: '[#5159](https://www.sqlalchemy.org/trac/ticket/5159)  ### ORM `Session.execute()`
    uses “future” style `Result` sets in all cases'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: '[#5159](https://www.sqlalchemy.org/trac/ticket/5159)  ### ORM `Session.execute()`
    在所有情况下都使用“future”风格的`Result`集'
- en: 'As noted in [RowProxy is no longer a “proxy”; is now called Row and behaves
    like an enhanced named tuple](#change-4710-core), the [`Result`](../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") and [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") objects now feature “named tuple” behavior, when used
    with an [`Engine`](../core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    that includes the [`create_engine.future`](../core/engines.html#sqlalchemy.create_engine.params.future
    "sqlalchemy.create_engine") parameter set to `True`. These “named tuple” rows
    in particular include a behavioral change which is that Python containment expressions
    using `in`, such as:'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 如[RowProxy不再是“代理”；现在称为Row并且行为类似增强的命名元组](#change-4710-core)中所述，当与设置为`True`的[`create_engine.future`](../core/engines.html#sqlalchemy.create_engine.params.future
    "sqlalchemy.create_engine")参数的[`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine")一起使用时，[`Result`](../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result")和[`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row")对象现在具有“命名元组”行为。这些特定的“命名元组”行现在包括一项行为变更，即Python包含表达式使用`in`，例如：
- en: '[PRE132]'
  id: totrans-586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: The above containment test will use **value containment**, not **key containment**;
    the `row` would need to have a **value** of “name” to return `True`.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 上述包含测试将使用**值包含**，而不是**键包含**；`row`需要具有“name”的**值**才能返回`True`。
- en: Under SQLAlchemy 1.4, when [`create_engine.future`](../core/engines.html#sqlalchemy.create_engine.params.future
    "sqlalchemy.create_engine") parameter set to `False`, legacy-style `LegacyRow`
    objects are returned which feature the partial-named-tuple behavior of prior SQLAlchemy
    versions, where containment checks continue to use key containment; `"name" in
    row` would return True if the row had a **column** named “name”, rather than a
    value.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 在SQLAlchemy 1.4中，当[`create_engine.future`](../core/engines.html#sqlalchemy.create_engine.params.future
    "sqlalchemy.create_engine")参数设置为`False`时，将返回传统风格的`LegacyRow`对象，其具有之前SQLAlchemy版本的部分命名元组行为，其中包含性检查继续使用键包含；如果行中有名为“name”的**列**，则`"name"
    in row`将返回True，而不是一个值。
- en: When using [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute"), full named-tuple style is enabled **unconditionally**,
    meaning `"name" in row` will use **value containment** as the test, and **not**
    key containment. This is to accommodate that [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") now returns a [`Result`](../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") that also accommodates for ORM results, where even
    legacy ORM result rows such as those returned by [`Query.all()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.all
    "sqlalchemy.orm.Query.all") use value containment.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用[`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute")时，完整的命名元组样式被**无条件地**启用，这意味着`"name" in row`将使用**值包含**作为测试，而**不是**键包含。这是为了适应[`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute")现在返回一个[`Result`](../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result")，该结果还适应ORM结果，其中甚至像由[`Query.all()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.all
    "sqlalchemy.orm.Query.all")返回的传统ORM结果行也使用值包含。
- en: 'This is a behavioral change from SQLAlchemy 1.3 to 1.4\. To continue receiving
    key-containment collections, use the [`Result.mappings()`](../core/connections.html#sqlalchemy.engine.Result.mappings
    "sqlalchemy.engine.Result.mappings") method to receive a [`MappingResult`](../core/connections.html#sqlalchemy.engine.MappingResult
    "sqlalchemy.engine.MappingResult") that returns rows as dictionaries:'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 这是从SQLAlchemy 1.3到1.4的行为变更。要继续接收键包含集合，请使用[`Result.mappings()`](../core/connections.html#sqlalchemy.engine.Result.mappings
    "sqlalchemy.engine.Result.mappings")方法接收返回行为字典的[`MappingResult`](../core/connections.html#sqlalchemy.engine.MappingResult
    "sqlalchemy.engine.MappingResult")：
- en: '[PRE133]  ### Transparent SQL Compilation Caching added to All DQL, DML Statements
    in Core, ORM'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE133]  ### 透明SQL编译缓存添加到Core、ORM中的所有DQL、DML语句'
- en: One of the most broadly encompassing changes to ever land in a single SQLAlchemy
    version, a many-month reorganization and refactoring of all querying systems from
    the base of Core all the way through ORM now allows the majority of Python computation
    involved producing SQL strings and related statement metadata from a user-constructed
    statement to be cached in memory, such that subsequent invocations of an identical
    statement construct will use 35-60% fewer CPU resources.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 这是单个SQLAlchemy版本中最广泛涵盖的更改之一，经过数月的重新组织和重构，从Core的基础到ORM，现在允许大多数涉及从用户构造的语句生成SQL字符串和相关语句元数据的Python计算被缓存在内存中，因此对于相同的语句构造的后续调用将使用35-60%更少的CPU资源。
- en: This caching goes beyond the construction of the SQL string to also include
    the construction of result fetching structures that link the SQL construct to
    the result set, and in the ORM it includes the accommodation of ORM-enabled attribute
    loaders, relationship eager loaders and other options, and object construction
    routines that must be built up each time an ORM query seeks to run and construct
    ORM objects from result sets.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 这种缓存不仅限于构建SQL字符串，还包括构建将SQL结构链接到结果集的结果获取结构，以及在ORM中包括适应ORM启用的属性加载器、关系急加载器和其他选项，以及每次ORM查询试图运行并从结果集构建ORM对象时必须构建的对象构造例程。
- en: 'To introduce the general idea of the feature, given code from the [Performance](../orm/examples.html#examples-performance)
    suite as follows, which will invoke a very simple query “n” times, for a default
    value of n=10000\. The query returns only a single row, as the overhead we are
    looking to decrease is that of **many small queries**. The optimization is not
    as significant for queries that return many rows:'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 为了介绍该功能的一般思想，给出了来自[性能](../orm/examples.html#examples-performance)套件的代码，将调用一个非常简单的查询“n”次，其中n的默认值为10000。查询仅返回一行，因为我们要减少的开销是**许多小查询**的开销。对于返回许多行的查询，优化并不那么显著：
- en: '[PRE134]'
  id: totrans-595
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'This example in the 1.3 release of SQLAlchemy on a Dell XPS13 running Linux
    completes as follows:'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Dell XPS13 运行 Linux 的 SQLAlchemy 1.3 版本中，此示例完成如下：
- en: '[PRE135]'
  id: totrans-597
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'In 1.4, the code above without modification completes:'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 在 1.4 版本中，上述代码不经修改即可完成：
- en: '[PRE136]'
  id: totrans-599
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: This first test indicates that regular ORM queries when using caching can run
    over many iterations in the range of **30% faster**.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 这个第一个测试表明，当使用缓存时，常规的 ORM 查询可以在很多次迭代中以**30% 更快**的速度运行。
- en: A second variant of the feature is the optional use of Python lambdas to defer
    the construction of the query itself. This is a more sophisticated variant of
    the approach used by the “Baked Query” extension, which was introduced in version
    1.0.0\. The “lambda” feature may be used in a style very similar to that of baked
    queries, except that it is available in an ad-hoc way for any SQL construct. It
    additionally includes the ability to scan each invocation of the lambda for bound
    literal values that change on every invocation, as well as changes to other constructs,
    such as querying from a different entity or column each time, while still not
    having to run the actual code each time.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 功能的第二个变体是可选使用 Python lambdas 来延迟查询本身的构建。这是一种更复杂的方法变体，类似于版本 1.0.0 中引入的“烘焙查询”扩展。
    “lambda” 功能可以以非常类似于烘焙查询的方式使用，除了它可以以临时方式用于任何 SQL 结构之外。它还包括扫描每次 lambda 调用的功能，以查找每次调用都会更改的绑定文字值，以及对其他结构的更改，例如每次查询不同的实体或列，同时仍然不必每次都运行实际代码。
- en: 'Using this API looks as follows:'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此 API 如下所示：
- en: '[PRE137]'
  id: totrans-603
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'The code above completes:'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码完成：
- en: '[PRE138]'
  id: totrans-605
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: This test indicates that using the newer “select()” style of ORM querying, in
    conjunction with a full “baked” style invocation that caches the entire construction,
    can run over many iterations in the range of **60% faster** and grants performance
    about the same as the baked query system which is now superseded by the native
    caching system.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 此测试表明，使用较新的“select()”风格的 ORM 查询，与完全“烘焙”样式调用结合使用，后者缓存了整个构建过程，可以在很多次迭代中以**60%
    更快**的速度运行，并且性能与被本地缓存系统取代的烘焙查询系统相当。
- en: The new system makes use of the existing [`Connection.execution_options.compiled_cache`](../core/connections.html#sqlalchemy.engine.Connection.execution_options.params.compiled_cache
    "sqlalchemy.engine.Connection.execution_options") execution option and also adds
    a cache to the [`Engine`](../core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    directly, which is configured using the [`Engine.query_cache_size`](../core/connections.html#sqlalchemy.engine.Engine.params.query_cache_size
    "sqlalchemy.engine.Engine") parameter.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 新系统利用现有的 [`Connection.execution_options.compiled_cache`](../core/connections.html#sqlalchemy.engine.Connection.execution_options.params.compiled_cache
    "sqlalchemy.engine.Connection.execution_options") 执行选项，并直接向 [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") 添加缓存，该缓存使用 [`Engine.query_cache_size`](../core/connections.html#sqlalchemy.engine.Engine.params.query_cache_size
    "sqlalchemy.engine.Engine") 参数进行配置。
- en: A significant portion of API and behavioral changes throughout 1.4 were driven
    in order to support this new feature.
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: API 和行为变化的重大部分是为了支持这一新功能而进行的。
- en: See also
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[SQL Compilation Caching](../core/connections.html#sql-caching)'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: '[SQL 编译缓存](../core/connections.html#sql-caching)'
- en: '[#4639](https://www.sqlalchemy.org/trac/ticket/4639) [#5380](https://www.sqlalchemy.org/trac/ticket/5380)
    [#4645](https://www.sqlalchemy.org/trac/ticket/4645) [#4808](https://www.sqlalchemy.org/trac/ticket/4808)
    [#5004](https://www.sqlalchemy.org/trac/ticket/5004)  ### Declarative is now integrated
    into the ORM with new features'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4639](https://www.sqlalchemy.org/trac/ticket/4639) [#5380](https://www.sqlalchemy.org/trac/ticket/5380)
    [#4645](https://www.sqlalchemy.org/trac/ticket/4645) [#4808](https://www.sqlalchemy.org/trac/ticket/4808)
    [#5004](https://www.sqlalchemy.org/trac/ticket/5004)  ### 声明式现在与 ORM 集成，并带有新功能'
- en: After ten years or so of popularity, the `sqlalchemy.ext.declarative` package
    is now integrated into the `sqlalchemy.orm` namespace, with the exception of the
    declarative “extension” classes which remain as Declarative extensions.
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 大约十年左右的时间后，`sqlalchemy.ext.declarative` 包现在已集成到 `sqlalchemy.orm` 命名空间中，除了声明式“扩展”类仍然保持为声明式扩展之外。
- en: 'The new classes added to `sqlalchemy.orm` include:'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: '`sqlalchemy.orm` 中新增的新类包括：'
- en: '[`registry`](../orm/mapping_api.html#sqlalchemy.orm.registry "sqlalchemy.orm.registry")
    - a new class that supersedes the role of the “declarative base” class, serving
    as a registry of mapped classes which can be referenced via string name within
    [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")
    calls and is agnostic of the style in which any particular class was mapped.'
  id: totrans-614
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`registry`](../orm/mapping_api.html#sqlalchemy.orm.registry "sqlalchemy.orm.registry")
    - 一个新的类，取代了“声明基类”的角色，作为映射类的注册表，可以通过字符串名称在[`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")调用中引用，并且不受任何特定类被映射的风格的影响。'
- en: '[`declarative_base()`](../orm/mapping_api.html#sqlalchemy.orm.declarative_base
    "sqlalchemy.orm.declarative_base") - this is the same declarative base class that
    has been in use throughout the span of the declarative system, except it now references
    a [`registry`](../orm/mapping_api.html#sqlalchemy.orm.registry "sqlalchemy.orm.registry")
    object internally and is implemented by the [`registry.generate_base()`](../orm/mapping_api.html#sqlalchemy.orm.registry.generate_base
    "sqlalchemy.orm.registry.generate_base") method which can be invoked from a [`registry`](../orm/mapping_api.html#sqlalchemy.orm.registry
    "sqlalchemy.orm.registry") directly. The [`declarative_base()`](../orm/mapping_api.html#sqlalchemy.orm.declarative_base
    "sqlalchemy.orm.declarative_base") function creates this registry automatically
    so there is no impact on existing code. The `sqlalchemy.ext.declarative.declarative_base`
    name is still present, emitting a 2.0 deprecation warning when [2.0 deprecations
    mode](#deprecation-20-mode) is enabled.'
  id: totrans-615
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`declarative_base()`](../orm/mapping_api.html#sqlalchemy.orm.declarative_base
    "sqlalchemy.orm.declarative_base") - 这是在声明系统中一直在使用的相同声明基类，只是现在在内部引用了一个[`registry`](../orm/mapping_api.html#sqlalchemy.orm.registry
    "sqlalchemy.orm.registry")对象，并由[`registry.generate_base()`](../orm/mapping_api.html#sqlalchemy.orm.registry.generate_base
    "sqlalchemy.orm.registry.generate_base")方法实现，可以直接从[`registry`](../orm/mapping_api.html#sqlalchemy.orm.registry
    "sqlalchemy.orm.registry")中调用。[`declarative_base()`](../orm/mapping_api.html#sqlalchemy.orm.declarative_base
    "sqlalchemy.orm.declarative_base")函数会自动生成这个注册表，因此不会影响现有代码。`sqlalchemy.ext.declarative.declarative_base`名称仍然存在，在启用[2.0弃用模式](#deprecation-20-mode)时会发出2.0弃用警告。'
- en: '[`declared_attr()`](../orm/mapping_api.html#sqlalchemy.orm.declared_attr "sqlalchemy.orm.declared_attr")
    - the same “declared attr” function call now part of `sqlalchemy.orm`. The `sqlalchemy.ext.declarative.declared_attr`
    name is still present, emitting a 2.0 deprecation warning when [2.0 deprecations
    mode](#deprecation-20-mode) is enabled.'
  id: totrans-616
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`declared_attr()`](../orm/mapping_api.html#sqlalchemy.orm.declared_attr "sqlalchemy.orm.declared_attr")
    - 现在是`sqlalchemy.orm`的一部分的相同“声明属性”函数调用。`sqlalchemy.ext.declarative.declared_attr`名称仍然存在，在启用[2.0弃用模式](#deprecation-20-mode)时会发出2.0弃用警告。'
- en: Other names moved into `sqlalchemy.orm` include [`has_inherited_table()`](../orm/mapping_api.html#sqlalchemy.orm.has_inherited_table
    "sqlalchemy.orm.has_inherited_table"), [`synonym_for()`](../orm/mapping_api.html#sqlalchemy.orm.synonym_for
    "sqlalchemy.orm.synonym_for"), `DeclarativeMeta`, [`as_declarative()`](../orm/mapping_api.html#sqlalchemy.orm.as_declarative
    "sqlalchemy.orm.as_declarative").
  id: totrans-617
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他移入`sqlalchemy.orm`的名称包括[`has_inherited_table()`](../orm/mapping_api.html#sqlalchemy.orm.has_inherited_table
    "sqlalchemy.orm.has_inherited_table")，[`synonym_for()`](../orm/mapping_api.html#sqlalchemy.orm.synonym_for
    "sqlalchemy.orm.synonym_for")，`DeclarativeMeta`，[`as_declarative()`](../orm/mapping_api.html#sqlalchemy.orm.as_declarative
    "sqlalchemy.orm.as_declarative")。
- en: In addition, The `instrument_declarative()` function is deprecated, superseded
    by [`registry.map_declaratively()`](../orm/mapping_api.html#sqlalchemy.orm.registry.map_declaratively
    "sqlalchemy.orm.registry.map_declaratively"). The [`ConcreteBase`](../orm/extensions/declarative/index.html#sqlalchemy.ext.declarative.ConcreteBase
    "sqlalchemy.ext.declarative.ConcreteBase"), [`AbstractConcreteBase`](../orm/extensions/declarative/index.html#sqlalchemy.ext.declarative.AbstractConcreteBase
    "sqlalchemy.ext.declarative.AbstractConcreteBase"), and [`DeferredReflection`](../orm/extensions/declarative/index.html#sqlalchemy.ext.declarative.DeferredReflection
    "sqlalchemy.ext.declarative.DeferredReflection") classes remain as extensions
    in the [Declarative Extensions](../orm/extensions/declarative/index.html) package.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，`instrument_declarative()`函数已被弃用，被[`registry.map_declaratively()`](../orm/mapping_api.html#sqlalchemy.orm.registry.map_declaratively
    "sqlalchemy.orm.registry.map_declaratively")取代。[`ConcreteBase`](../orm/extensions/declarative/index.html#sqlalchemy.ext.declarative.ConcreteBase
    "sqlalchemy.ext.declarative.ConcreteBase")、[`AbstractConcreteBase`](../orm/extensions/declarative/index.html#sqlalchemy.ext.declarative.AbstractConcreteBase
    "sqlalchemy.ext.declarative.AbstractConcreteBase")和[`DeferredReflection`](../orm/extensions/declarative/index.html#sqlalchemy.ext.declarative.DeferredReflection
    "sqlalchemy.ext.declarative.DeferredReflection")类仍然作为[声明性扩展](../orm/extensions/declarative/index.html)包中的扩展。
- en: 'Mapping styles have now been organized such that they all extend from the [`registry`](../orm/mapping_api.html#sqlalchemy.orm.registry
    "sqlalchemy.orm.registry") object, and fall into these categories:'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 映射样式现在已经组织起来，它们都从[`registry`](../orm/mapping_api.html#sqlalchemy.orm.registry
    "sqlalchemy.orm.registry")对象扩展，并分为以下类别：
- en: '[Declarative Mapping](../orm/mapping_styles.html#orm-declarative-mapping)'
  id: totrans-620
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[声明性映射](../orm/mapping_styles.html#orm-declarative-mapping)'
- en: Using [`declarative_base()`](../orm/mapping_api.html#sqlalchemy.orm.declarative_base
    "sqlalchemy.orm.declarative_base") Base class w/ metaclass
  id: totrans-621
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用[`declarative_base()`](../orm/mapping_api.html#sqlalchemy.orm.declarative_base
    "sqlalchemy.orm.declarative_base") 带有元类的基类
- en: '[Declarative Table with mapped_column()](../orm/declarative_tables.html#orm-declarative-table)'
  id: totrans-622
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用`mapped_column()`的声明性表](../orm/declarative_tables.html#orm-declarative-table)'
- en: '[Imperative Table (a.k.a. “hybrid table”)](../orm/declarative_tables.html#orm-imperative-table-configuration)'
  id: totrans-623
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[命令式表（又名“混合表”）](../orm/declarative_tables.html#orm-imperative-table-configuration)'
- en: Using [`registry.mapped()`](../orm/mapping_api.html#sqlalchemy.orm.registry.mapped
    "sqlalchemy.orm.registry.mapped") Declarative Decorator
  id: totrans-624
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用[`registry.mapped()`](../orm/mapping_api.html#sqlalchemy.orm.registry.mapped
    "sqlalchemy.orm.registry.mapped") 声明性装饰器
- en: Declarative Table
  id: totrans-625
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明性表
- en: Imperative Table (Hybrid)
  id: totrans-626
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令式表（混合）
- en: '[Applying ORM Mappings to an existing dataclass (legacy dataclass use)](../orm/dataclasses.html#orm-declarative-dataclasses)'
  id: totrans-627
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[将ORM映射应用于现有数据类（传统数据类用法）](../orm/dataclasses.html#orm-declarative-dataclasses)'
- en: '[Imperative (a.k.a. “classical” mapping)](../orm/mapping_styles.html#orm-imperative-mapping)'
  id: totrans-628
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[命令式（又名“经典”映射）](../orm/mapping_styles.html#orm-imperative-mapping)'
- en: Using [`registry.map_imperatively()`](../orm/mapping_api.html#sqlalchemy.orm.registry.map_imperatively
    "sqlalchemy.orm.registry.map_imperatively")
  id: totrans-629
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用[`registry.map_imperatively()`](../orm/mapping_api.html#sqlalchemy.orm.registry.map_imperatively
    "sqlalchemy.orm.registry.map_imperatively")
- en: '[Mapping pre-existing dataclasses using Imperative Mapping](../orm/dataclasses.html#orm-imperative-dataclasses)'
  id: totrans-630
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用命令式映射映射预先存在的数据类](../orm/dataclasses.html#orm-imperative-dataclasses)'
- en: The existing classical mapping function `sqlalchemy.orm.mapper()` remains, however
    it is deprecated to call upon `sqlalchemy.orm.mapper()` directly; the new [`registry.map_imperatively()`](../orm/mapping_api.html#sqlalchemy.orm.registry.map_imperatively
    "sqlalchemy.orm.registry.map_imperatively") method now routes the request through
    the [`sqlalchemy.orm.registry()`](../orm/mapping_api.html#sqlalchemy.orm.registry
    "sqlalchemy.orm.registry") so that it integrates with other declarative mappings
    unambiguously.
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 现有的经典映射函数`sqlalchemy.orm.mapper()`仍然存在，但直接调用`sqlalchemy.orm.mapper()`已被弃用；新的[`registry.map_imperatively()`](../orm/mapping_api.html#sqlalchemy.orm.registry.map_imperatively
    "sqlalchemy.orm.registry.map_imperatively")方法现在通过[`sqlalchemy.orm.registry()`](../orm/mapping_api.html#sqlalchemy.orm.registry
    "sqlalchemy.orm.registry")路由请求，以便与其他声明性映射明确集成。
- en: The new approach interoperates with 3rd party class instrumentation systems
    which necessarily must take place on the class before the mapping process does,
    allowing declarative mapping to work via a decorator instead of a declarative
    base so that packages like [dataclasses](https://docs.python.org/3/library/dataclasses.html)
    and [attrs](https://pypi.org/project/attrs/) can be used with declarative mappings,
    in addition to working with classical mappings.
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 新方法与第三方类仪器系统互操作，这些系统必须在映射过程之前对类进行操作，允许声明性映射通过装饰器而不是声明性基类工作，以便像[dataclasses](https://docs.python.org/3/library/dataclasses.html)和[attrs](https://pypi.org/project/attrs/)这样的包可以与声明性映射一起使用，除了与经典映射一起使用。
- en: Declarative documentation has now been fully integrated into the ORM mapper
    configuration documentation and includes examples for all styles of mappings organized
    into one place. See the section [ORM Mapped Class Overview](../orm/mapping_styles.html)
    for the start of the newly reorganized documentation.
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 声明性文档现已完全整合到ORM映射器配置文档中，并包括所有样式的映射示例，组织在一个地方。请查看新组织文档的开始部分[ORM映射类概述](../orm/mapping_styles.html)。
- en: See also
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[ORM Mapped Class Overview](../orm/mapping_styles.html)'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: '[ORM映射类概述](../orm/mapping_styles.html)'
- en: '[Python Dataclasses, attrs Supported w/ Declarative, Imperative Mappings](#change-5027)'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: '[Python Dataclasses, attrs支持声明性，命令式映射](#change-5027)'
- en: '[#5508](https://www.sqlalchemy.org/trac/ticket/5508)  ### Python Dataclasses,
    attrs Supported w/ Declarative, Imperative Mappings'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: '[#5508](https://www.sqlalchemy.org/trac/ticket/5508)  ### Python Dataclasses,
    attrs支持声明性，命令式映射'
- en: Along with the new declarative decorator styles introduced in [Declarative is
    now integrated into the ORM with new features](#change-5508), the [`Mapper`](../orm/mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper") is now explicitly aware of the Python `dataclasses` module
    and will recognize attributes that are configured in this way, and proceed to
    map them without skipping them as was the case previously. In the case of the
    `attrs` module, `attrs` already removes its own attributes from the class so was
    already compatible with SQLAlchemy classical mappings. With the addition of the
    [`registry.mapped()`](../orm/mapping_api.html#sqlalchemy.orm.registry.mapped "sqlalchemy.orm.registry.mapped")
    decorator, both attribute systems can now interoperate with Declarative mappings
    as well.
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在[声明性现在与新功能整合到ORM中](#change-5508)中引入的新声明性装饰器样式外，[`Mapper`](../orm/mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper")现在明确意识到Python的`dataclasses`模块，并将识别以这种方式配置的属性，并继续映射它们，而不像以前那样跳过它们。对于`attrs`模块，`attrs`已经从类中删除了自己的属性，因此已经与SQLAlchemy经典映射兼容。通过添加[`registry.mapped()`](../orm/mapping_api.html#sqlalchemy.orm.registry.mapped
    "sqlalchemy.orm.registry.mapped")装饰器，两个属性系统现在可以与声明性映射互操作。
- en: See also
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Applying ORM Mappings to an existing dataclass (legacy dataclass use)](../orm/dataclasses.html#orm-declarative-dataclasses)'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: '[将ORM映射应用于现有数据类（传统数据类用法）](../orm/dataclasses.html#orm-declarative-dataclasses)'
- en: '[Mapping pre-existing dataclasses using Imperative Mapping](../orm/dataclasses.html#orm-imperative-dataclasses)'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用命令式映射映射预先存在的数据类](../orm/dataclasses.html#orm-imperative-dataclasses)'
- en: '[#5027](https://www.sqlalchemy.org/trac/ticket/5027)  ### Asynchronous IO Support
    for Core and ORM'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: '[#5027](https://www.sqlalchemy.org/trac/ticket/5027)  ### Core和ORM的异步IO支持'
- en: SQLAlchemy now supports Python `asyncio`-compatible database drivers using an
    all-new asyncio front-end interface to [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") for Core usage as well as [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") for ORM use, using the [`AsyncConnection`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncConnection
    "sqlalchemy.ext.asyncio.AsyncConnection") and [`AsyncSession`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession
    "sqlalchemy.ext.asyncio.AsyncSession") objects.
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy现在支持使用全新的`asyncio`前端接口来支持Python的数据库驱动程序，用于[`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")的Core使用以及用于ORM使用的[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")，使用[`AsyncConnection`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncConnection
    "sqlalchemy.ext.asyncio.AsyncConnection")和[`AsyncSession`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession
    "sqlalchemy.ext.asyncio.AsyncSession")对象。
- en: Note
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The new asyncio feature should be considered **alpha level** for the initial
    releases of SQLAlchemy 1.4\. This is super new stuff that uses some previously
    unfamiliar programming techniques.
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 初始的SQLAlchemy 1.4版本应该考虑新的asyncio功能是**alpha级别**的。这是一种全新的东西，使用了一些以前不熟悉的编程技术。
- en: The initial database API supported is the [asyncpg](../dialects/postgresql.html#dialect-postgresql-asyncpg)
    asyncio driver for PostgreSQL.
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 初始支持的数据库API是用于PostgreSQL的[asyncpg](../dialects/postgresql.html#dialect-postgresql-asyncpg)
    asyncio驱动程序。
- en: The internal features of SQLAlchemy are fully integrated by making use of the
    [greenlet](https://greenlet.readthedocs.io/en/latest/) library in order to adapt
    the flow of execution within SQLAlchemy’s internals to propagate asyncio `await`
    keywords outwards from the database driver to the end-user API, which features
    `async` methods. Using this approach, the asyncpg driver is fully operational
    within SQLAlchemy’s own test suite and features compatibility with most psycopg2
    features. The approach was vetted and improved upon by developers of the greenlet
    project for which SQLAlchemy is appreciative.
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy的内部特性完全集成了[greenlet](https://greenlet.readthedocs.io/en/latest/)库，以便将SQLAlchemy内部的执行流程适应于将asyncio的`await`关键字从数据库驱动器传播到端用户API，该API具有`async`方法。使用这种方法，asyncpg驱动程序在SQLAlchemy自己的测试套件中完全可操作，并与大多数psycopg2特性兼容。这种方法经过了greenlet项目的开发人员的审查和改进，对此SQLAlchemy表示感激。
- en: The user facing `async` API itself is focused around IO-oriented methods such
    as [`AsyncEngine.connect()`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncEngine.connect
    "sqlalchemy.ext.asyncio.AsyncEngine.connect") and [`AsyncConnection.execute()`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncConnection.execute
    "sqlalchemy.ext.asyncio.AsyncConnection.execute"). The new Core constructs strictly
    support [2.0 style](../glossary.html#term-2.0-style) usage only; which means all
    statements must be invoked given a connection object, in this case [`AsyncConnection`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncConnection
    "sqlalchemy.ext.asyncio.AsyncConnection").
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 用户接口的`async` API本身集中于像[`AsyncEngine.connect()`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncEngine.connect
    "sqlalchemy.ext.asyncio.AsyncEngine.connect")和[`AsyncConnection.execute()`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncConnection.execute
    "sqlalchemy.ext.asyncio.AsyncConnection.execute")这样的IO导向方法。新的Core构造严格支持[2.0样式](../glossary.html#term-2.0-style)的使用方式；这意味着所有语句必须在给定连接对象的情况下调用，即在这种情况下为[`AsyncConnection`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncConnection
    "sqlalchemy.ext.asyncio.AsyncConnection")。
- en: Within the ORM, [2.0 style](../glossary.html#term-2.0-style) query execution
    is supported, using [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") constructs in conjunction with [`AsyncSession.execute()`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession.execute
    "sqlalchemy.ext.asyncio.AsyncSession.execute"); the legacy [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object itself is not supported by the [`AsyncSession`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession
    "sqlalchemy.ext.asyncio.AsyncSession") class.
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 在ORM中，支持[2.0样式](../glossary.html#term-2.0-style)的查询执行，使用[`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select")构造与[`AsyncSession.execute()`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession.execute
    "sqlalchemy.ext.asyncio.AsyncSession.execute")结合；传统的[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")对象本身不受[`AsyncSession`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession
    "sqlalchemy.ext.asyncio.AsyncSession")类支持。
- en: ORM features such as lazy loading of related attributes as well as unexpiry
    of expired attributes are by definition disallowed in the traditional asyncio
    programming model, as they indicate IO operations that would run implicitly within
    the scope of a Python `getattr()` operation. To overcome this, the **traditional**
    asyncio application should make judicious use of [eager loading](../orm/queryguide/relationships.html)
    techniques as well as forego the use of features such as [expire on commit](../orm/session_basics.html#session-committing)
    so that such loads are not needed.
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: ORM功能，如延迟加载相关属性以及过期属性的非过期化，在传统的asyncio编程模型中是被禁止的，因为它们表示将隐式运行的IO操作在Python的`getattr()`操作的范围内。为了克服这一问题，**传统**
    asyncio应用程序应该适度利用[eager loading](../orm/queryguide/relationships.html)技术，并放弃使用诸如[expire
    on commit](../orm/session_basics.html#session-committing)之类的特性，以便不需要这些加载。
- en: For the asyncio application developer who **chooses to break** with tradition,
    the new API provides a **strictly optional feature** such that applications that
    wish to make use of such ORM features can opt to organize database-related code
    into functions which can then be run within greenlets using the [`AsyncSession.run_sync()`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession.run_sync
    "sqlalchemy.ext.asyncio.AsyncSession.run_sync") method. See the `greenlet_orm.py`
    example at [Asyncio Integration](../orm/examples.html#examples-asyncio) for a
    demonstration.
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 对于选择与传统**决裂**的 asyncio 应用程序开发人员，新的 API 提供了一个**严格可选的功能**，使希望利用此类 ORM 功能的应用程序可以选择将与数据库相关的代码组织到函数中，然后使用
    [`AsyncSession.run_sync()`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession.run_sync
    "sqlalchemy.ext.asyncio.AsyncSession.run_sync") 方法在 greenlets 中运行。请参阅 [Asyncio
    Integration](../orm/examples.html#examples-asyncio) 中的 `greenlet_orm.py` 示例以进行演示。
- en: Support for asynchronous cursors is also provided using new methods [`AsyncConnection.stream()`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncConnection.stream
    "sqlalchemy.ext.asyncio.AsyncConnection.stream") and [`AsyncSession.stream()`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession.stream
    "sqlalchemy.ext.asyncio.AsyncSession.stream"), which support a new [`AsyncResult`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncResult
    "sqlalchemy.ext.asyncio.AsyncResult") object that itself provides awaitable versions
    of common methods like [`AsyncResult.all()`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncResult.all
    "sqlalchemy.ext.asyncio.AsyncResult.all") and [`AsyncResult.fetchmany()`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncResult.fetchmany
    "sqlalchemy.ext.asyncio.AsyncResult.fetchmany"). Both Core and ORM are integrated
    with the feature which corresponds to the use of “server side cursors” in traditional
    SQLAlchemy.
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 还提供了对异步游标的支持，使用新方法 [`AsyncConnection.stream()`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncConnection.stream
    "sqlalchemy.ext.asyncio.AsyncConnection.stream") 和 [`AsyncSession.stream()`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession.stream
    "sqlalchemy.ext.asyncio.AsyncSession.stream")，支持一个新的 [`AsyncResult`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncResult
    "sqlalchemy.ext.asyncio.AsyncResult") 对象，该对象本身提供了常见方法的可等待版本，如 [`AsyncResult.all()`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncResult.all
    "sqlalchemy.ext.asyncio.AsyncResult.all") 和 [`AsyncResult.fetchmany()`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncResult.fetchmany
    "sqlalchemy.ext.asyncio.AsyncResult.fetchmany")。核心和 ORM 都与传统 SQLAlchemy 中使用“服务器端游标”的功能集成。
- en: See also
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[Asynchronous I/O (asyncio)](../orm/extensions/asyncio.html)'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: '[异步 I/O (asyncio)](../orm/extensions/asyncio.html)'
- en: '[Asyncio Integration](../orm/examples.html#examples-asyncio)'
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: '[Asyncio Integration](../orm/examples.html#examples-asyncio)'
- en: '[#3414](https://www.sqlalchemy.org/trac/ticket/3414)  ### Many Core and ORM
    statement objects now perform much of their construction and validation in the
    compile phase'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3414](https://www.sqlalchemy.org/trac/ticket/3414)  ### 许多核心和 ORM 语句对象现在在编译阶段执行大部分构建和验证工作'
- en: A major initiative in the 1.4 series is to approach the model of both Core SQL
    statements as well as the ORM Query to allow for an efficient, cacheable model
    of statement creation and compilation, where the compilation step would be cached,
    based on a cache key generated by the created statement object, which itself is
    newly created for each use. Towards this goal, much of the Python computation
    which occurs within the construction of statements, particularly that of the ORM
    [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    as well as the [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") construct when used to invoke ORM queries,
    is being moved to occur within the compilation phase of the statement which only
    occurs after the statement has been invoked, and only if the statement’s compiled
    form was not yet cached.
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 1.4 系列的一个重要举措是接近核心 SQL 语句和 ORM 查询的模型，以实现高效、可缓存的语句创建和编译模型，其中编译步骤将被缓存，基于创建的语句对象生成的缓存键，该对象本身是为每次使用新创建的。为实现这一目标，特别是在构建语句时发生的大部分
    Python 计算，特别是 ORM [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") 和 [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") 构造在用于调用 ORM 查询时，正在移至语句的编译阶段，该阶段仅在调用语句后发生，并且仅在语句的编译形式尚未被缓存时才会发生。
- en: From an end-user perspective, this means that some of the error messages which
    can arise based on arguments passed to the object will no longer be raised immediately,
    and instead will occur only when the statement is invoked for the first time.
    These conditions are always structural and not data driven, so there is no risk
    of such a condition being missed due to a cached statement.
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 从最终用户的角度来看，这意味着基于传递给对象的参数可能引发的某些错误消息将不再立即引发，而是仅在首次调用语句时发生。这些条件始终是结构性的，而不是数据驱动的，因此不会由于缓存语句而错过此类条件的风险。
- en: 'Error conditions which fall under this category include:'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 属于此类别的错误条件包括：
- en: when a `_selectable.CompoundSelect` is constructed (e.g. a UNION, EXCEPT, etc.)
    and the SELECT statements passed do not have the same number of columns, a [`CompileError`](../core/exceptions.html#sqlalchemy.exc.CompileError
    "sqlalchemy.exc.CompileError") is now raised to this effect; previously, an [`ArgumentError`](../core/exceptions.html#sqlalchemy.exc.ArgumentError
    "sqlalchemy.exc.ArgumentError") would be raised immediately upon statement construction.
  id: totrans-660
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当构造`_selectable.CompoundSelect`（例如UNION，EXCEPT等）并且传递的SELECT语句列数不同时，现在会引发[`CompileError`](../core/exceptions.html#sqlalchemy.exc.CompileError
    "sqlalchemy.exc.CompileError")；以前，在语句构造时会立即引发[`ArgumentError`](../core/exceptions.html#sqlalchemy.exc.ArgumentError
    "sqlalchemy.exc.ArgumentError")。
- en: Various error conditions which may arise when calling upon [`Query.join()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join") will be evaluated at statement compilation time rather
    than when the method is first called.
  id: totrans-661
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当调用[`Query.join()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.join "sqlalchemy.orm.Query.join")时可能出现的各种错误条件将在语句编译时进行评估，而不是在首次调用方法时。
- en: 'Other things that may change involve the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object directly:'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会发生变化的其他事情涉及直接[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")对象：
- en: Behaviors may be slightly different when calling upon the [`Query.statement`](../orm/queryguide/query.html#sqlalchemy.orm.Query.statement
    "sqlalchemy.orm.Query.statement") accessor. The [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") object returned is now a direct copy of the
    same state that was present in the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query"), without any ORM-specific compilation being performed
    (which means it’s dramatically faster). However, the [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") will not have the same internal state as it
    had in 1.3, including things like the FROM clauses being explicitly spelled out
    if they were not explicitly stated in the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query"). This means code that relies upon manipulating this [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") statement such as calling methods like [`Select.with_only_columns()`](../core/selectable.html#sqlalchemy.sql.expression.Select.with_only_columns
    "sqlalchemy.sql.expression.Select.with_only_columns") may need to accommodate
    for the FROM clause.
  id: totrans-663
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当调用[`Query.statement`](../orm/queryguide/query.html#sqlalchemy.orm.Query.statement
    "sqlalchemy.orm.Query.statement")访问器时，行为可能会有所不同。返回的[`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select")对象现在是与[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")中存在的相同状态的直接副本，而不执行任何ORM特定的编译（这意味着速度大大提高）。然而，[`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select")将不会像1.3中那样具有相同的内部状态，包括如果在[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")中没有明确声明，则明确拼写出FROM子句等内容。这意味着依赖于操作此[`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select")语句的代码，例如调用[`Select.with_only_columns()`](../core/selectable.html#sqlalchemy.sql.expression.Select.with_only_columns
    "sqlalchemy.sql.expression.Select.with_only_columns")等方法，可能需要适应FROM子句。
- en: See also
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Transparent SQL Compilation Caching added to All DQL, DML Statements in Core,
    ORM](#change-4639)  ### Repaired internal importing conventions such that code
    linters may work correctly'
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: '[透明SQL编译缓存添加到Core，ORM中的所有DQL，DML语句](#change-4639)  ### 修复了内部导入约定，使代码检查工具可以正常工作'
- en: 'SQLAlchemy has for a long time used a parameter-injecting decorator to help
    resolve mutually-dependent module imports, like this:'
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy长期以来一直使用参数注入装饰器来帮助解决相互依赖的模块导入，就像这样：
- en: '[PRE139]'
  id: totrans-667
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: Where the above function would be rewritten to no longer have the `dml` parameter
    on the outside. This would confuse code-linting tools into seeing a missing parameter
    to functions. A new approach has been implemented internally such that the function’s
    signature is no longer modified and the module object is procured inside the function
    instead.
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 上述函数将被重写，不再在外部具有`dml`参数。这会让代码检查工具看到函数缺少参数而感到困惑。已经内部实现了一种新方法，使函数签名不再被修改，模块对象在函数内部获取。
- en: '[#4656](https://www.sqlalchemy.org/trac/ticket/4656)'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4656](https://www.sqlalchemy.org/trac/ticket/4656)'
- en: '[#4689](https://www.sqlalchemy.org/trac/ticket/4689)  ### Support for SQL Regular
    Expression operators'
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4689](https://www.sqlalchemy.org/trac/ticket/4689)  ### 支持SQL正则表达式操作符'
- en: A long awaited feature to add rudimentary support for database regular expression
    operators, to complement the [`ColumnOperators.like()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.like
    "sqlalchemy.sql.expression.ColumnOperators.like") and [`ColumnOperators.match()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.match
    "sqlalchemy.sql.expression.ColumnOperators.match") suites of operations. The new
    features include [`ColumnOperators.regexp_match()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.regexp_match
    "sqlalchemy.sql.expression.ColumnOperators.regexp_match") implementing a regular
    expression match like function, and [`ColumnOperators.regexp_replace()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.regexp_replace
    "sqlalchemy.sql.expression.ColumnOperators.regexp_replace") implementing a regular
    expression string replace function.
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 期待已久的功能，为数据库正则表达式操作符提供了基本支持，以补充[`ColumnOperators.like()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.like
    "sqlalchemy.sql.expression.ColumnOperators.like")和[`ColumnOperators.match()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.match
    "sqlalchemy.sql.expression.ColumnOperators.match")操作套件。新功能包括实现类似正则表达式匹配的[`ColumnOperators.regexp_match()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.regexp_match
    "sqlalchemy.sql.expression.ColumnOperators.regexp_match")函数，以及实现正则表达式字符串替换的[`ColumnOperators.regexp_replace()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.regexp_replace
    "sqlalchemy.sql.expression.ColumnOperators.regexp_replace")函数。
- en: Supported backends include SQLite, PostgreSQL, MySQL / MariaDB, and Oracle.
    The SQLite backend only supports “regexp_match” but not “regexp_replace”.
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 支持的后端包括SQLite、PostgreSQL、MySQL / MariaDB和Oracle。SQLite后端仅支持“regexp_match”而不支持“regexp_replace”。
- en: The regular expression syntaxes and flags are **not backend agnostic**. A future
    feature will allow multiple regular expression syntaxes to be specified at once
    to switch between different backends on the fly.
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式语法和标志**不是通用于所有后端**。未来的功能将允许一次指定多个正则表达式语法，以便在不同后端之间动态切换。
- en: For SQLite, Python’s `re.search()` function with no additional arguments is
    established as the implementation.
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 对于SQLite，Python的`re.search()`函数已被确定为实现，无需额外参数。
- en: See also
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`ColumnOperators.regexp_match()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.regexp_match
    "sqlalchemy.sql.expression.ColumnOperators.regexp_match")'
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: '[`ColumnOperators.regexp_match()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.regexp_match
    "sqlalchemy.sql.expression.ColumnOperators.regexp_match")'
- en: '[`ColumnOperators.regexp_replace()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.regexp_replace
    "sqlalchemy.sql.expression.ColumnOperators.regexp_replace")'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: '[`ColumnOperators.regexp_replace()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.regexp_replace
    "sqlalchemy.sql.expression.ColumnOperators.regexp_replace")'
- en: '[Regular Expression Support](../dialects/sqlite.html#pysqlite-regexp) - SQLite
    implementation notes'
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: '[正则表达式支持](../dialects/sqlite.html#pysqlite-regexp) - SQLite实现注意事项'
- en: '[#1390](https://www.sqlalchemy.org/trac/ticket/1390)  ### SQLAlchemy 2.0 Deprecations
    Mode'
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: '[#1390](https://www.sqlalchemy.org/trac/ticket/1390)  ### SQLAlchemy 2.0 弃用模式'
- en: One of the primary goals of the 1.4 release is to provide a “transitional” release
    so that applications may migrate to SQLAlchemy 2.0 gradually. Towards this end,
    a primary feature in release 1.4 is “2.0 deprecations mode”, which is a series
    of deprecation warnings that emit against every detectable API pattern which will
    work differently in version 2.0\. The warnings all make use of the `RemovedIn20Warning`
    class. As these warnings affect foundational patterns including the [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") and [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") constructs, even simple applications can generate
    a lot of warnings until appropriate API changes are made. The warning mode is
    therefore turned off by default until the developer enables the environment variable
    `SQLALCHEMY_WARN_20=1`.
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 1.4版本的主要目标之一是提供一个“过渡”版本，以便应用程序可以逐渐迁移到SQLAlchemy 2.0。为此，1.4版本的一个主要特性是“2.0弃用模式”，这是一系列针对每个可检测到的API模式发出的弃用警告，在版本2.0中将以不同方式工作。所有警告都使用`RemovedIn20Warning`类。由于这些警告影响包括[`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select")和[`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine")构造在内的基础模式，即使是简单的应用程序也可能生成大量警告，直到适当的API更改完成。因此，默认情况下警告模式是关闭的，直到开发人员启用环境变量`SQLALCHEMY_WARN_20=1`。
- en: For a full walkthrough of using 2.0 Deprecations mode, see [Migration to 2.0
    Step Two - Turn on RemovedIn20Warnings](migration_20.html#migration-20-deprecations-mode).
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何完整使用2.0弃用模式，请参阅[迁移到2.0第二步 - 打开RemovedIn20Warnings](migration_20.html#migration-20-deprecations-mode)。
- en: See also
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[SQLAlchemy 2.0 - Major Migration Guide](migration_20.html)'
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: '[SQLAlchemy 2.0 - 主要迁移指南](migration_20.html)'
- en: '[Migration to 2.0 Step Two - Turn on RemovedIn20Warnings](migration_20.html#migration-20-deprecations-mode)  ###
    Python 3.6 is the minimum Python 3 version; Python 2.7 still supported'
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: '[迁移到2.0第二步 - 打开RemovedIn20Warnings](migration_20.html#migration-20-deprecations-mode)  ###
    Python 3.6是最低Python 3版本；Python 2.7仍受支持'
- en: As Python 3.5 reached EOL in September of 2020, SQLAlchemy 1.4 now places version
    3.6 as the minimum Python 3 version. Python 2.7 is still supported, however the
    SQLAlchemy 1.4 series will be the last series to support Python 2.
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Python 3.5在2020年9月已达到生命周期终点，SQLAlchemy 1.4现在将版本3.6作为最低Python 3版本。Python 2.7仍然受支持，但SQLAlchemy
    1.4系列将是最后一个支持Python 2的系列。
- en: '### ORM Query is internally unified with select, update, delete; 2.0 style
    execution available'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: '### ORM查询在内部与select、update、delete统一；2.0风格的执行可用'
- en: The biggest conceptual change to SQLAlchemy for version 2.0 and essentially
    in 1.4 as well is that the great separation between the [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") construct in Core and the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object in the ORM has been removed, as well as between
    the [`Query.update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.update
    "sqlalchemy.orm.Query.update") and [`Query.delete()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.delete
    "sqlalchemy.orm.Query.delete") methods in how they relate to [`Update`](../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update") and [`Delete`](../core/dml.html#sqlalchemy.sql.expression.Delete
    "sqlalchemy.sql.expression.Delete").
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: 对于版本2.0的SQLAlchemy最大的概念性变化，实际上也是在1.4版本中，是Core中的[`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select")构造和ORM中的[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")对象之间的巨大分离已被移除，以及[`Query.update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.update
    "sqlalchemy.orm.Query.update")和[`Query.delete()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.delete
    "sqlalchemy.orm.Query.delete")方法与[`Update`](../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update")和[`Delete`](../core/dml.html#sqlalchemy.sql.expression.Delete
    "sqlalchemy.sql.expression.Delete")的关系。
- en: With regards to [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") and [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query"), these two objects have for many versions had similar,
    largely overlapping APIs and even some ability to change between one and the other,
    while remaining very different in their usage patterns and behaviors. The historical
    background for this was that the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object was introduced to overcome shortcomings in the
    [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select "sqlalchemy.sql.expression.Select")
    object which used to be at the core of how ORM objects were queried, except that
    they had to be queried in terms of [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") metadata only. However [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") had only a simplistic interface for loading objects, and
    only over the course of many major releases did it eventually gain most of the
    flexibility of the [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") object, which then led to the ongoing awkwardness
    that these two objects became highly similar yet still largely incompatible with
    each other.
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 关于[`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select "sqlalchemy.sql.expression.Select")和[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")，这两个对象在许多版本中具有类似的、大部分重叠的API，甚至可以在两者之间切换，但在使用模式和行为上仍然有很大的不同。这背后的历史背景是，[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")对象是为了克服[`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select")对象的缺点而引入的，后者曾经是ORM对象查询的核心，但只能根据[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")元数据进行查询。然而，[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")只有一个简单的接口来加载对象，直到经过多个重大版本的发布，它最终才获得了大部分[`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select")对象的灵活性，这导致这两个对象变得非常相似，但仍然在很大程度上不兼容。
- en: 'In version 1.4, all Core and ORM SELECT statements are rendered from a [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") object directly; when the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object is used, at statement invocation time it copies
    its state to a [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") which is then invoked internally using [2.0
    style](../glossary.html#term-2.0-style) execution. Going forward, the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object will become legacy only, and applications will
    be encouraged to move to [2.0 style](../glossary.html#term-2.0-style) execution
    which allows Core constructs to be used freely against ORM entities:'
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 在1.4版本中，所有Core和ORM SELECT语句都直接从[`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select")对象渲染；当使用[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")对象时，在语句调用时，它会将其状态复制到一个[`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select")对象中，然后使用[2.0风格](../glossary.html#term-2.0-style)执行内部调用。未来，[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")对象将仅作为传统遗留，应用程序将被鼓励转向[2.0风格](../glossary.html#term-2.0-style)执行，允许Core构造自由地针对ORM实体使用：
- en: '[PRE140]'
  id: totrans-690
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'Things to note about the above example:'
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 关于上面的示例需要注意的事项：
- en: The [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    and [`sessionmaker`](../orm/session_api.html#sqlalchemy.orm.sessionmaker "sqlalchemy.orm.sessionmaker")
    objects now feature full context manager (i.e. the `with:` statement) capability;
    see the revised documentation at [Opening and Closing a Session](../orm/session_basics.html#session-getting)
    for an example.
  id: totrans-692
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")和[`sessionmaker`](../orm/session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker")对象现在具有完整的上下文管理器（即`with:`语句）功能；请参阅[打开和关闭会话](../orm/session_basics.html#session-getting)的修订文档以获取示例。'
- en: Within the 1.4 series, all [2.0 style](../glossary.html#term-2.0-style) ORM
    invocation uses a [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    that includes the [`Session.future`](../orm/session_api.html#sqlalchemy.orm.Session.params.future
    "sqlalchemy.orm.Session") flag set to `True`; this flag indicates the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") should have 2.0-style behaviors, which include that
    ORM queries can be invoked from [`execute`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") as well as some changes in transactional features.
    In version 2.0 this flag will always be `True`.
  id: totrans-693
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在1.4系列中，所有[2.0风格](../glossary.html#term-2.0-style)的ORM调用都使用了一个包含[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")的标志设置为`True`的标志；这个标志表示[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")应该具有2.0风格的行为，其中包括ORM查询可以从[`execute`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute")中调用，以及一些事务特性的变化。在2.0版本中，这个标志将始终为`True`。
- en: The [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select")
    construct no longer needs brackets around the columns clause; see [select(), case()
    now accept positional expressions](#change-5284) for background on this improvement.
  id: totrans-694
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`select()`](../core/selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select")构造不再需要在列子句周围加括号；请参考[select(),
    case()现在接受位置表达式](#change-5284)以了解此改进的背景。'
- en: The [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select")
    / [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select "sqlalchemy.sql.expression.Select")
    object has a [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") method that acts like that of the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") and even accommodates an ORM relationship attribute (without
    breaking the separation between Core and ORM!) - see [select().join() and outerjoin()
    add JOIN criteria to the current query, rather than creating a subquery](#change-select-join)
    for background on this.
  id: totrans-695
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`select()`](../core/selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select")
    / [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select "sqlalchemy.sql.expression.Select")对象具有一个[`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join")方法，其行为类似于[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")的方法，甚至可以容纳ORM关系属性（而不会破坏Core和ORM之间的分离！）- 请参考[select().join()和outerjoin()向当前查询添加JOIN条件，而不是创建子查询](#change-select-join)以了解此背景。'
- en: Statements that work with ORM entities and are expected to return ORM results
    are invoked using [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute"). See [Querying](../orm/session_basics.html#session-querying-20)
    for a primer. See also the following note at [ORM Session.execute() uses “future”
    style Result sets in all cases](#change-session-execute-result).
  id: totrans-696
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与ORM实体一起工作并预计返回ORM结果的语句是使用[`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute")来调用的。查看[查询](../orm/session_basics.html#session-querying-20)以获取入门指南。另请参阅[ORM
    Session.execute()在所有情况下使用“future”风格结果集](#change-session-execute-result)中的以下注意事项。
- en: a [`Result`](../core/connections.html#sqlalchemy.engine.Result "sqlalchemy.engine.Result")
    object is returned, rather than a plain list, which itself is a much more sophisticated
    version of the previous `ResultProxy` object; this object is now used both for
    Core and ORM results. See [New Result object](#change-result-14-core), [RowProxy
    is no longer a “proxy”; is now called Row and behaves like an enhanced named tuple](#change-4710-core),
    and [The “KeyedTuple” object returned by Query is replaced by Row](#change-4710-orm)
    for information on this.
  id: totrans-697
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回一个[`Result`](../core/connections.html#sqlalchemy.engine.Result "sqlalchemy.engine.Result")对象，而不是一个普通列表，这本身是以前`ResultProxy`对象的一个更复杂的版本；这个对象现在被用于Core和ORM结果。查看[新的Result对象](#change-result-14-core)，[RowProxy不再是一个“代理”；现在被称为Row并且行为类似于增强的命名元组](#change-4710-core)，以及[Query返回的“KeyedTuple”对象被Row替换](#change-4710-orm)以获取更多信息。
- en: Throughout SQLAlchemy’s documentation, there will be many references to [1.x
    style](../glossary.html#term-1.x-style) and [2.0 style](../glossary.html#term-2.0-style)
    execution. This is to distinguish between the two querying styles and to attempt
    to forwards-document the new calling style going forward. In SQLAlchemy 2.0, while
    the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    object may remain as a legacy construct, it will no longer be featured in most
    documentation.
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: 在SQLAlchemy的文档中，将会有许多关于[1.x 风格](../glossary.html#term-1.x-style)和[2.0 风格](../glossary.html#term-2.0-style)执行的引用。这是为了区分两种查询风格，并尝试向前文档化新的调用风格。在SQLAlchemy
    2.0中，虽然[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")对象可能仍然是一个遗留构造，但它将不再在大多数文档中出现。
- en: 'Similar adjustments have been made to “bulk updates and deletes” such that
    Core [`update()`](../core/dml.html#sqlalchemy.sql.expression.update "sqlalchemy.sql.expression.update")
    and [`delete()`](../core/dml.html#sqlalchemy.sql.expression.delete "sqlalchemy.sql.expression.delete")
    can be used for bulk operations. A bulk update like the following:'
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 对“批量更新和删除”进行了类似的调整，以便Core [`update()`](../core/dml.html#sqlalchemy.sql.expression.update
    "sqlalchemy.sql.expression.update")和[`delete()`](../core/dml.html#sqlalchemy.sql.expression.delete
    "sqlalchemy.sql.expression.delete")可以用于批量操作。类似以下的批量更新：
- en: '[PRE141]'
  id: totrans-700
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'can now be achieved in [2.0 style](../glossary.html#term-2.0-style) (and indeed
    the above runs internally in this way) as follows:'
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以以[2.0 风格](../glossary.html#term-2.0-style)实现（实际上上述在内部以这种方式运行）如下：
- en: '[PRE142]'
  id: totrans-702
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: Note the use of the [`Executable.execution_options()`](../core/selectable.html#sqlalchemy.sql.expression.Executable.execution_options
    "sqlalchemy.sql.expression.Executable.execution_options") method to pass ORM-related
    options. The use of “execution options” is now much more prevalent within both
    Core and ORM, and many ORM-related methods from [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") are now implemented as execution options (see [`Query.execution_options()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.execution_options
    "sqlalchemy.orm.Query.execution_options") for some examples).
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意使用[`Executable.execution_options()`](../core/selectable.html#sqlalchemy.sql.expression.Executable.execution_options
    "sqlalchemy.sql.expression.Executable.execution_options")方法传递ORM相关选项。现在“执行选项”的使用在Core和ORM中更加普遍，许多来自[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")的ORM相关方法现在被实现为执行选项（查看[`Query.execution_options()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.execution_options
    "sqlalchemy.orm.Query.execution_options")以获取一些示例）。
- en: See also
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[SQLAlchemy 2.0 - Major Migration Guide](migration_20.html)'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: '[SQLAlchemy 2.0 - 主要迁移指南](migration_20.html)'
- en: '[#5159](https://www.sqlalchemy.org/trac/ticket/5159)'
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: '[#5159](https://www.sqlalchemy.org/trac/ticket/5159)'
- en: '### ORM `Session.execute()` uses “future” style `Result` sets in all cases'
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: '### ORM `Session.execute()`在所有情况下都使用“future”风格的`Result`集'
- en: 'As noted in [RowProxy is no longer a “proxy”; is now called Row and behaves
    like an enhanced named tuple](#change-4710-core), the [`Result`](../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") and [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") objects now feature “named tuple” behavior, when used
    with an [`Engine`](../core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    that includes the [`create_engine.future`](../core/engines.html#sqlalchemy.create_engine.params.future
    "sqlalchemy.create_engine") parameter set to `True`. These “named tuple” rows
    in particular include a behavioral change which is that Python containment expressions
    using `in`, such as:'
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 如在[RowProxy不再是“代理”；现在称为Row并且行为类似增强命名元组](#change-4710-core)中所述，当与设置了[`create_engine.future`](../core/engines.html#sqlalchemy.create_engine.params.future
    "sqlalchemy.create_engine")参数为`True`的[`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine")一起使用时，[`Result`](../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result")和[`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row")对象现在具有“命名元组”行为。特别是这些“命名元组”行现在包括一个行为变化，即使用`in`的Python包含表达式，例如：
- en: '[PRE143]'
  id: totrans-709
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: The above containment test will use **value containment**, not **key containment**;
    the `row` would need to have a **value** of “name” to return `True`.
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 上述包含测试将使用**值包含**，而不是**键包含**；`row`需要具有“name”的**值**才能返回`True`。
- en: Under SQLAlchemy 1.4, when [`create_engine.future`](../core/engines.html#sqlalchemy.create_engine.params.future
    "sqlalchemy.create_engine") parameter set to `False`, legacy-style `LegacyRow`
    objects are returned which feature the partial-named-tuple behavior of prior SQLAlchemy
    versions, where containment checks continue to use key containment; `"name" in
    row` would return True if the row had a **column** named “name”, rather than a
    value.
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 在SQLAlchemy 1.4版本中，当[`create_engine.future`](../core/engines.html#sqlalchemy.create_engine.params.future
    "sqlalchemy.create_engine")参数设置为`False`时，将返回传统风格的`LegacyRow`对象，其具有之前SQLAlchemy版本的部分命名元组行为，其中包含检查仍然使用键包含性；如果行中有名为“name”的**列**，则`"name"
    in row`将返回True，而不是值。
- en: When using [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute"), full named-tuple style is enabled **unconditionally**,
    meaning `"name" in row` will use **value containment** as the test, and **not**
    key containment. This is to accommodate that [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") now returns a [`Result`](../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") that also accommodates for ORM results, where even
    legacy ORM result rows such as those returned by [`Query.all()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.all
    "sqlalchemy.orm.Query.all") use value containment.
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用[`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute")时，完整的命名元组样式被**无条件地**启用，这意味着`"name" in row`将使用**值包含性**作为测试，而**不是**键包含性。这是为了适应[`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute")现在返回一个[`Result`](../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result")，该结果还适用于ORM结果，即使是由[`Query.all()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.all
    "sqlalchemy.orm.Query.all")返回的传统ORM结果行也使用值包含性。
- en: 'This is a behavioral change from SQLAlchemy 1.3 to 1.4\. To continue receiving
    key-containment collections, use the [`Result.mappings()`](../core/connections.html#sqlalchemy.engine.Result.mappings
    "sqlalchemy.engine.Result.mappings") method to receive a [`MappingResult`](../core/connections.html#sqlalchemy.engine.MappingResult
    "sqlalchemy.engine.MappingResult") that returns rows as dictionaries:'
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 这是从SQLAlchemy 1.3到1.4的行为变化。要继续接收键包含集合，请使用[`Result.mappings()`](../core/connections.html#sqlalchemy.engine.Result.mappings
    "sqlalchemy.engine.Result.mappings")方法来接收返回行为字典的[`MappingResult`](../core/connections.html#sqlalchemy.engine.MappingResult
    "sqlalchemy.engine.MappingResult")：
- en: '[PRE144]'
  id: totrans-714
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '### Transparent SQL Compilation Caching added to All DQL, DML Statements in
    Core, ORM'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: '### 透明SQL编译缓存添加到Core、ORM中的所有DQL、DML语句'
- en: One of the most broadly encompassing changes to ever land in a single SQLAlchemy
    version, a many-month reorganization and refactoring of all querying systems from
    the base of Core all the way through ORM now allows the majority of Python computation
    involved producing SQL strings and related statement metadata from a user-constructed
    statement to be cached in memory, such that subsequent invocations of an identical
    statement construct will use 35-60% fewer CPU resources.
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 这是SQLAlchemy版本中最广泛的变化之一，经过数月的重新组织和重构，从Core的基础一直到ORM，现在允许大部分涉及从用户构建的语句生成SQL字符串和相关语句元数据的Python计算在内存中被缓存，因此对于相同的语句构造的后续调用将使用35-60%更少的CPU资源。
- en: This caching goes beyond the construction of the SQL string to also include
    the construction of result fetching structures that link the SQL construct to
    the result set, and in the ORM it includes the accommodation of ORM-enabled attribute
    loaders, relationship eager loaders and other options, and object construction
    routines that must be built up each time an ORM query seeks to run and construct
    ORM objects from result sets.
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 这种缓存不仅限于构建SQL字符串，还包括构建将SQL构造与结果集链接起来的结果获取结构，在ORM中还包括适应ORM启用的属性加载器、关系急加载器和其他选项，以及每次ORM查询试图运行并从结果集构建ORM对象时必须构建的对象构造例程。
- en: 'To introduce the general idea of the feature, given code from the [Performance](../orm/examples.html#examples-performance)
    suite as follows, which will invoke a very simple query “n” times, for a default
    value of n=10000\. The query returns only a single row, as the overhead we are
    looking to decrease is that of **many small queries**. The optimization is not
    as significant for queries that return many rows:'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 为了介绍该功能的一般概念，给出来自[性能](../orm/examples.html#examples-performance)套件的代码如下，它将调用一个非常简单的查询“n”次，n的默认值为10000。该查询仅返回一行，因为我们希望减少的开销是**许多小查询**的开销。对于返回许多行的查询，优化并不那么显著：
- en: '[PRE145]'
  id: totrans-719
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'This example in the 1.3 release of SQLAlchemy on a Dell XPS13 running Linux
    completes as follows:'
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行Linux的Dell XPS13上的SQLAlchemy 1.3版本中，此示例完成如下：
- en: '[PRE146]'
  id: totrans-721
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'In 1.4, the code above without modification completes:'
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 在1.4中，上面的代码没有修改完成了：
- en: '[PRE147]'
  id: totrans-723
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: This first test indicates that regular ORM queries when using caching can run
    over many iterations in the range of **30% faster**.
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 这个第一个测试表明，在使用缓存时，常规的ORM查询可以在许多迭代中运行速度快**30%**。
- en: A second variant of the feature is the optional use of Python lambdas to defer
    the construction of the query itself. This is a more sophisticated variant of
    the approach used by the “Baked Query” extension, which was introduced in version
    1.0.0\. The “lambda” feature may be used in a style very similar to that of baked
    queries, except that it is available in an ad-hoc way for any SQL construct. It
    additionally includes the ability to scan each invocation of the lambda for bound
    literal values that change on every invocation, as well as changes to other constructs,
    such as querying from a different entity or column each time, while still not
    having to run the actual code each time.
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: 该功能的第二个变体是可选使用Python lambda来推迟查询本身的构建。这是“Baked Query”扩展所使用的方法的更复杂变体，该扩展是在1.0.0版本中引入的。
    “lambda”功能可以以与烘焙查询非常相似的方式使用，只是它以一种临时方式可用于任何SQL构造。它还包括扫描每次调用lambda以查找在每次调用时更改的绑定文字值的能力，以及对其他构造的更改，例如每次查询来自不同实体或列，同时仍然不必每次运行实际代码。
- en: 'Using this API looks as follows:'
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个API看起来如下：
- en: '[PRE148]'
  id: totrans-727
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'The code above completes:'
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码完成了：
- en: '[PRE149]'
  id: totrans-729
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: This test indicates that using the newer “select()” style of ORM querying, in
    conjunction with a full “baked” style invocation that caches the entire construction,
    can run over many iterations in the range of **60% faster** and grants performance
    about the same as the baked query system which is now superseded by the native
    caching system.
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试表明，使用较新的“select()”风格的ORM查询，结合完全“烘焙”风格的调用，可以在许多迭代中运行速度快**60%**，并且性能与现在被本地缓存系统取代的烘焙查询系统大致相同。
- en: The new system makes use of the existing [`Connection.execution_options.compiled_cache`](../core/connections.html#sqlalchemy.engine.Connection.execution_options.params.compiled_cache
    "sqlalchemy.engine.Connection.execution_options") execution option and also adds
    a cache to the [`Engine`](../core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    directly, which is configured using the [`Engine.query_cache_size`](../core/connections.html#sqlalchemy.engine.Engine.params.query_cache_size
    "sqlalchemy.engine.Engine") parameter.
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: 新系统利用现有的[`Connection.execution_options.compiled_cache`](../core/connections.html#sqlalchemy.engine.Connection.execution_options.params.compiled_cache
    "sqlalchemy.engine.Connection.execution_options")执行选项，并直接向[`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine")添加缓存，该缓存使用[`Engine.query_cache_size`](../core/connections.html#sqlalchemy.engine.Engine.params.query_cache_size
    "sqlalchemy.engine.Engine")参数进行配置。
- en: A significant portion of API and behavioral changes throughout 1.4 were driven
    in order to support this new feature.
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 1.4版本中的API和行为变化的一个重要部分是为了支持这一新功能。
- en: See also
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[SQL Compilation Caching](../core/connections.html#sql-caching)'
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: '[SQL编译缓存](../core/connections.html#sql-caching)'
- en: '[#4639](https://www.sqlalchemy.org/trac/ticket/4639) [#5380](https://www.sqlalchemy.org/trac/ticket/5380)
    [#4645](https://www.sqlalchemy.org/trac/ticket/4645) [#4808](https://www.sqlalchemy.org/trac/ticket/4808)
    [#5004](https://www.sqlalchemy.org/trac/ticket/5004)'
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4639](https://www.sqlalchemy.org/trac/ticket/4639) [#5380](https://www.sqlalchemy.org/trac/ticket/5380)
    [#4645](https://www.sqlalchemy.org/trac/ticket/4645) [#4808](https://www.sqlalchemy.org/trac/ticket/4808)
    [#5004](https://www.sqlalchemy.org/trac/ticket/5004)'
- en: '### Declarative is now integrated into the ORM with new features'
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: '### 声明式现在已经与ORM集成，并具有新功能'
- en: After ten years or so of popularity, the `sqlalchemy.ext.declarative` package
    is now integrated into the `sqlalchemy.orm` namespace, with the exception of the
    declarative “extension” classes which remain as Declarative extensions.
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 大约十年后，`sqlalchemy.ext.declarative`包现在已经集成到`sqlalchemy.orm`命名空间中，除了保留为声明式扩展的声明式“extension”类。
- en: 'The new classes added to `sqlalchemy.orm` include:'
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: 添加到`sqlalchemy.orm`的新类包括：
- en: '[`registry`](../orm/mapping_api.html#sqlalchemy.orm.registry "sqlalchemy.orm.registry")
    - a new class that supersedes the role of the “declarative base” class, serving
    as a registry of mapped classes which can be referenced via string name within
    [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")
    calls and is agnostic of the style in which any particular class was mapped.'
  id: totrans-739
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`registry`](../orm/mapping_api.html#sqlalchemy.orm.registry "sqlalchemy.orm.registry")
    - 一个新的类，取代了“声明基类”的角色，作为映射类的注册表，可以通过字符串名称在[`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")调用中引用，并且不受任何特定类被映射的风格的影响。'
- en: '[`declarative_base()`](../orm/mapping_api.html#sqlalchemy.orm.declarative_base
    "sqlalchemy.orm.declarative_base") - this is the same declarative base class that
    has been in use throughout the span of the declarative system, except it now references
    a [`registry`](../orm/mapping_api.html#sqlalchemy.orm.registry "sqlalchemy.orm.registry")
    object internally and is implemented by the [`registry.generate_base()`](../orm/mapping_api.html#sqlalchemy.orm.registry.generate_base
    "sqlalchemy.orm.registry.generate_base") method which can be invoked from a [`registry`](../orm/mapping_api.html#sqlalchemy.orm.registry
    "sqlalchemy.orm.registry") directly. The [`declarative_base()`](../orm/mapping_api.html#sqlalchemy.orm.declarative_base
    "sqlalchemy.orm.declarative_base") function creates this registry automatically
    so there is no impact on existing code. The `sqlalchemy.ext.declarative.declarative_base`
    name is still present, emitting a 2.0 deprecation warning when [2.0 deprecations
    mode](#deprecation-20-mode) is enabled.'
  id: totrans-740
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`declarative_base()`](../orm/mapping_api.html#sqlalchemy.orm.declarative_base
    "sqlalchemy.orm.declarative_base") - 这是在声明系统中一直在使用的相同声明基类，只是现在在内部引用了一个[`registry`](../orm/mapping_api.html#sqlalchemy.orm.registry
    "sqlalchemy.orm.registry")对象，并由[`registry.generate_base()`](../orm/mapping_api.html#sqlalchemy.orm.registry.generate_base
    "sqlalchemy.orm.registry.generate_base")方法实现，可以直接从[`registry`](../orm/mapping_api.html#sqlalchemy.orm.registry
    "sqlalchemy.orm.registry")调用。[`declarative_base()`](../orm/mapping_api.html#sqlalchemy.orm.declarative_base
    "sqlalchemy.orm.declarative_base")函数会自动生成这个注册表，因此不会影响现有代码。`sqlalchemy.ext.declarative.declarative_base`名称仍然存在，在启用[2.0弃用模式](#deprecation-20-mode)时会发出2.0弃用警告。'
- en: '[`declared_attr()`](../orm/mapping_api.html#sqlalchemy.orm.declared_attr "sqlalchemy.orm.declared_attr")
    - the same “declared attr” function call now part of `sqlalchemy.orm`. The `sqlalchemy.ext.declarative.declared_attr`
    name is still present, emitting a 2.0 deprecation warning when [2.0 deprecations
    mode](#deprecation-20-mode) is enabled.'
  id: totrans-741
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`declared_attr()`](../orm/mapping_api.html#sqlalchemy.orm.declared_attr "sqlalchemy.orm.declared_attr")
    - 现在是`sqlalchemy.orm`的一部分的相同“声明属性”函数调用。`sqlalchemy.ext.declarative.declared_attr`名称仍然存在，在启用[2.0弃用模式](#deprecation-20-mode)时会发出2.0弃用警告。'
- en: Other names moved into `sqlalchemy.orm` include [`has_inherited_table()`](../orm/mapping_api.html#sqlalchemy.orm.has_inherited_table
    "sqlalchemy.orm.has_inherited_table"), [`synonym_for()`](../orm/mapping_api.html#sqlalchemy.orm.synonym_for
    "sqlalchemy.orm.synonym_for"), `DeclarativeMeta`, [`as_declarative()`](../orm/mapping_api.html#sqlalchemy.orm.as_declarative
    "sqlalchemy.orm.as_declarative").
  id: totrans-742
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他移至`sqlalchemy.orm`的名称包括[`has_inherited_table()`](../orm/mapping_api.html#sqlalchemy.orm.has_inherited_table
    "sqlalchemy.orm.has_inherited_table")，[`synonym_for()`](../orm/mapping_api.html#sqlalchemy.orm.synonym_for
    "sqlalchemy.orm.synonym_for")，`DeclarativeMeta`，[`as_declarative()`](../orm/mapping_api.html#sqlalchemy.orm.as_declarative
    "sqlalchemy.orm.as_declarative")。
- en: In addition, The `instrument_declarative()` function is deprecated, superseded
    by [`registry.map_declaratively()`](../orm/mapping_api.html#sqlalchemy.orm.registry.map_declaratively
    "sqlalchemy.orm.registry.map_declaratively"). The [`ConcreteBase`](../orm/extensions/declarative/index.html#sqlalchemy.ext.declarative.ConcreteBase
    "sqlalchemy.ext.declarative.ConcreteBase"), [`AbstractConcreteBase`](../orm/extensions/declarative/index.html#sqlalchemy.ext.declarative.AbstractConcreteBase
    "sqlalchemy.ext.declarative.AbstractConcreteBase"), and [`DeferredReflection`](../orm/extensions/declarative/index.html#sqlalchemy.ext.declarative.DeferredReflection
    "sqlalchemy.ext.declarative.DeferredReflection") classes remain as extensions
    in the [Declarative Extensions](../orm/extensions/declarative/index.html) package.
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，`instrument_declarative()`函数已被弃用，被[`registry.map_declaratively()`](../orm/mapping_api.html#sqlalchemy.orm.registry.map_declaratively
    "sqlalchemy.orm.registry.map_declaratively")取代。[`ConcreteBase`](../orm/extensions/declarative/index.html#sqlalchemy.ext.declarative.ConcreteBase
    "sqlalchemy.ext.declarative.ConcreteBase")、[`AbstractConcreteBase`](../orm/extensions/declarative/index.html#sqlalchemy.ext.declarative.AbstractConcreteBase
    "sqlalchemy.ext.declarative.AbstractConcreteBase")和[`DeferredReflection`](../orm/extensions/declarative/index.html#sqlalchemy.ext.declarative.DeferredReflection
    "sqlalchemy.ext.declarative.DeferredReflection")类仍然作为[声明式扩展](../orm/extensions/declarative/index.html)包中的扩展。
- en: 'Mapping styles have now been organized such that they all extend from the [`registry`](../orm/mapping_api.html#sqlalchemy.orm.registry
    "sqlalchemy.orm.registry") object, and fall into these categories:'
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 映射样式现在已经组织起来，它们都从[`registry`](../orm/mapping_api.html#sqlalchemy.orm.registry
    "sqlalchemy.orm.registry")对象扩展，并分为以下类别：
- en: '[Declarative Mapping](../orm/mapping_styles.html#orm-declarative-mapping)'
  id: totrans-745
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[声明式映射](../orm/mapping_styles.html#orm-declarative-mapping)'
- en: Using [`declarative_base()`](../orm/mapping_api.html#sqlalchemy.orm.declarative_base
    "sqlalchemy.orm.declarative_base") Base class w/ metaclass
  id: totrans-746
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用[`declarative_base()`](../orm/mapping_api.html#sqlalchemy.orm.declarative_base
    "sqlalchemy.orm.declarative_base")基类与元类
- en: '[Declarative Table with mapped_column()](../orm/declarative_tables.html#orm-declarative-table)'
  id: totrans-747
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[具有mapped_column()的声明式表](../orm/declarative_tables.html#orm-declarative-table)'
- en: '[Imperative Table (a.k.a. “hybrid table”)](../orm/declarative_tables.html#orm-imperative-table-configuration)'
  id: totrans-748
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[命令式表（又称“混合表”）](../orm/declarative_tables.html#orm-imperative-table-configuration)'
- en: Using [`registry.mapped()`](../orm/mapping_api.html#sqlalchemy.orm.registry.mapped
    "sqlalchemy.orm.registry.mapped") Declarative Decorator
  id: totrans-749
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用[`registry.mapped()`](../orm/mapping_api.html#sqlalchemy.orm.registry.mapped
    "sqlalchemy.orm.registry.mapped")声明式装饰器
- en: Declarative Table
  id: totrans-750
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明式表
- en: Imperative Table (Hybrid)
  id: totrans-751
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令式表（混合）
- en: '[Applying ORM Mappings to an existing dataclass (legacy dataclass use)](../orm/dataclasses.html#orm-declarative-dataclasses)'
  id: totrans-752
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[将ORM映射应用于现有数据类（传统数据类用法）](../orm/dataclasses.html#orm-declarative-dataclasses)'
- en: '[Imperative (a.k.a. “classical” mapping)](../orm/mapping_styles.html#orm-imperative-mapping)'
  id: totrans-753
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[命令式（又称“经典”映射）](../orm/mapping_styles.html#orm-imperative-mapping)'
- en: Using [`registry.map_imperatively()`](../orm/mapping_api.html#sqlalchemy.orm.registry.map_imperatively
    "sqlalchemy.orm.registry.map_imperatively")
  id: totrans-754
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用[`registry.map_imperatively()`](../orm/mapping_api.html#sqlalchemy.orm.registry.map_imperatively
    "sqlalchemy.orm.registry.map_imperatively")
- en: '[Mapping pre-existing dataclasses using Imperative Mapping](../orm/dataclasses.html#orm-imperative-dataclasses)'
  id: totrans-755
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用命令式映射映射预先存在的数据类](../orm/dataclasses.html#orm-imperative-dataclasses)'
- en: The existing classical mapping function `sqlalchemy.orm.mapper()` remains, however
    it is deprecated to call upon `sqlalchemy.orm.mapper()` directly; the new [`registry.map_imperatively()`](../orm/mapping_api.html#sqlalchemy.orm.registry.map_imperatively
    "sqlalchemy.orm.registry.map_imperatively") method now routes the request through
    the [`sqlalchemy.orm.registry()`](../orm/mapping_api.html#sqlalchemy.orm.registry
    "sqlalchemy.orm.registry") so that it integrates with other declarative mappings
    unambiguously.
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 现有的经典映射函数`sqlalchemy.orm.mapper()`仍然存在，但不建议直接调用`sqlalchemy.orm.mapper()`；新的[`registry.map_imperatively()`](../orm/mapping_api.html#sqlalchemy.orm.registry.map_imperatively
    "sqlalchemy.orm.registry.map_imperatively")方法现在通过[`sqlalchemy.orm.registry()`](../orm/mapping_api.html#sqlalchemy.orm.registry
    "sqlalchemy.orm.registry")路由请求，以便与其他声明式映射无歧义地集成。
- en: The new approach interoperates with 3rd party class instrumentation systems
    which necessarily must take place on the class before the mapping process does,
    allowing declarative mapping to work via a decorator instead of a declarative
    base so that packages like [dataclasses](https://docs.python.org/3/library/dataclasses.html)
    and [attrs](https://pypi.org/project/attrs/) can be used with declarative mappings,
    in addition to working with classical mappings.
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 新方法与第三方类仪器系统互操作，这些系统必须在映射过程之前对类进行操作，允许通过装饰器而不是声明性基类工作的声明性映射，以便像 [dataclasses](https://docs.python.org/3/library/dataclasses.html)
    和 [attrs](https://pypi.org/project/attrs/) 这样的包可以与声明性映射一起使用，除了与经典映射一起使用。
- en: Declarative documentation has now been fully integrated into the ORM mapper
    configuration documentation and includes examples for all styles of mappings organized
    into one place. See the section [ORM Mapped Class Overview](../orm/mapping_styles.html)
    for the start of the newly reorganized documentation.
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: 声明式文档现已完全整合到 ORM 映射器配置文档中，并包括所有样式映射的示例，组织在一个地方。请查看重新组织文档的开始部分 [ORM 映射类概述](../orm/mapping_styles.html)。
- en: See also
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[ORM Mapped Class Overview](../orm/mapping_styles.html)'
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: '[ORM 映射类概述](../orm/mapping_styles.html)'
- en: '[Python Dataclasses, attrs Supported w/ Declarative, Imperative Mappings](#change-5027)'
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: '[Python Dataclasses, attrs 支持声明式、命令式映射](#change-5027)'
- en: '[#5508](https://www.sqlalchemy.org/trac/ticket/5508)'
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: '[#5508](https://www.sqlalchemy.org/trac/ticket/5508)'
- en: '### Python Dataclasses, attrs Supported w/ Declarative, Imperative Mappings'
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: '### Python Dataclasses, attrs 支持声明式、命令式映射'
- en: Along with the new declarative decorator styles introduced in [Declarative is
    now integrated into the ORM with new features](#change-5508), the [`Mapper`](../orm/mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper") is now explicitly aware of the Python `dataclasses` module
    and will recognize attributes that are configured in this way, and proceed to
    map them without skipping them as was the case previously. In the case of the
    `attrs` module, `attrs` already removes its own attributes from the class so was
    already compatible with SQLAlchemy classical mappings. With the addition of the
    [`registry.mapped()`](../orm/mapping_api.html#sqlalchemy.orm.registry.mapped "sqlalchemy.orm.registry.mapped")
    decorator, both attribute systems can now interoperate with Declarative mappings
    as well.
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在 [声明式现在与新功能一起集成到 ORM 中](#change-5508) 中引入的新声明式装饰器样式外，[`Mapper`](../orm/mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper") 现在明确了解 Python `dataclasses` 模块，并将识别以这种方式配置的属性，并继续映射它们，而不像以前那样跳过它们。对于
    `attrs` 模块，`attrs` 已经从类中删除了自己的属性，因此已经与 SQLAlchemy 经典映射兼容。通过 [`registry.mapped()`](../orm/mapping_api.html#sqlalchemy.orm.registry.mapped
    "sqlalchemy.orm.registry.mapped") 装饰器的添加，两个属性系统现在也可以与声明性映射互操作。
- en: See also
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Applying ORM Mappings to an existing dataclass (legacy dataclass use)](../orm/dataclasses.html#orm-declarative-dataclasses)'
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: '[将 ORM 映射应用于现有数据类（传统数据类用法）](../orm/dataclasses.html#orm-declarative-dataclasses)'
- en: '[Mapping pre-existing dataclasses using Imperative Mapping](../orm/dataclasses.html#orm-imperative-dataclasses)'
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用命令式映射映射预先存在的数据类](../orm/dataclasses.html#orm-imperative-dataclasses)'
- en: '[#5027](https://www.sqlalchemy.org/trac/ticket/5027)'
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: '[#5027](https://www.sqlalchemy.org/trac/ticket/5027)'
- en: '### Asynchronous IO Support for Core and ORM'
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: '### Core 和 ORM 的异步 IO 支持'
- en: SQLAlchemy now supports Python `asyncio`-compatible database drivers using an
    all-new asyncio front-end interface to [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") for Core usage as well as [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") for ORM use, using the [`AsyncConnection`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncConnection
    "sqlalchemy.ext.asyncio.AsyncConnection") and [`AsyncSession`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession
    "sqlalchemy.ext.asyncio.AsyncSession") objects.
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 现在支持使用全新的 asyncio 前端接口来支持 Python `asyncio` 兼容的数据库驱动程序，用于 Core 使用的
    [`Connection`](../core/connections.html#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    和用于 ORM 使用的 [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")，使用
    [`AsyncConnection`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncConnection
    "sqlalchemy.ext.asyncio.AsyncConnection") 和 [`AsyncSession`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession
    "sqlalchemy.ext.asyncio.AsyncSession") 对象。
- en: Note
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The new asyncio feature should be considered **alpha level** for the initial
    releases of SQLAlchemy 1.4\. This is super new stuff that uses some previously
    unfamiliar programming techniques.
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 asyncio 功能在 SQLAlchemy 1.4 的初始版本中应被视为**alpha级别**。这是一些以前不熟悉的编程技术的全新内容。
- en: The initial database API supported is the [asyncpg](../dialects/postgresql.html#dialect-postgresql-asyncpg)
    asyncio driver for PostgreSQL.
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: 初始数据库 API 支持的是 [asyncpg](../dialects/postgresql.html#dialect-postgresql-asyncpg)
    PostgreSQL 的 asyncio 驱动程序。
- en: The internal features of SQLAlchemy are fully integrated by making use of the
    [greenlet](https://greenlet.readthedocs.io/en/latest/) library in order to adapt
    the flow of execution within SQLAlchemy’s internals to propagate asyncio `await`
    keywords outwards from the database driver to the end-user API, which features
    `async` methods. Using this approach, the asyncpg driver is fully operational
    within SQLAlchemy’s own test suite and features compatibility with most psycopg2
    features. The approach was vetted and improved upon by developers of the greenlet
    project for which SQLAlchemy is appreciative.
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 的内部特性完全集成，通过使用 [greenlet](https://greenlet.readthedocs.io/en/latest/)
    库来调整在 SQLAlchemy 内部的执行流程，以将 asyncio 的 `await` 关键字从数据库驱动程序传播到最终用户 API，该 API 具有
    `async` 方法。使用这种方法，asyncpg 驱动程序在 SQLAlchemy 自己的测试套件中完全可操作，并与大多数 psycopg2 特性兼容。这种方法经过了
    greenlet 项目的开发人员的审查和改进，对此 SQLAlchemy 表示感谢。
- en: The user facing `async` API itself is focused around IO-oriented methods such
    as [`AsyncEngine.connect()`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncEngine.connect
    "sqlalchemy.ext.asyncio.AsyncEngine.connect") and [`AsyncConnection.execute()`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncConnection.execute
    "sqlalchemy.ext.asyncio.AsyncConnection.execute"). The new Core constructs strictly
    support [2.0 style](../glossary.html#term-2.0-style) usage only; which means all
    statements must be invoked given a connection object, in this case [`AsyncConnection`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncConnection
    "sqlalchemy.ext.asyncio.AsyncConnection").
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: 用户面向的 `async` API 本身主要围绕 IO 导向的方法，如 [`AsyncEngine.connect()`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncEngine.connect
    "sqlalchemy.ext.asyncio.AsyncEngine.connect") 和 [`AsyncConnection.execute()`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncConnection.execute
    "sqlalchemy.ext.asyncio.AsyncConnection.execute")。新的 Core 结构严格只支持 [2.0 风格](../glossary.html#term-2.0-style)
    的用法；这意味着所有语句必须在给定连接对象的情况下调用，本例中为 [`AsyncConnection`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncConnection
    "sqlalchemy.ext.asyncio.AsyncConnection")。
- en: Within the ORM, [2.0 style](../glossary.html#term-2.0-style) query execution
    is supported, using [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") constructs in conjunction with [`AsyncSession.execute()`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession.execute
    "sqlalchemy.ext.asyncio.AsyncSession.execute"); the legacy [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object itself is not supported by the [`AsyncSession`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession
    "sqlalchemy.ext.asyncio.AsyncSession") class.
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ORM 中，支持 [2.0 风格](../glossary.html#term-2.0-style) 的查询执行，使用 [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") 结构与 [`AsyncSession.execute()`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession.execute
    "sqlalchemy.ext.asyncio.AsyncSession.execute") 结合使用；传统的 [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") 对象本身不受 [`AsyncSession`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession
    "sqlalchemy.ext.asyncio.AsyncSession") 类支持。
- en: ORM features such as lazy loading of related attributes as well as unexpiry
    of expired attributes are by definition disallowed in the traditional asyncio
    programming model, as they indicate IO operations that would run implicitly within
    the scope of a Python `getattr()` operation. To overcome this, the **traditional**
    asyncio application should make judicious use of [eager loading](../orm/queryguide/relationships.html)
    techniques as well as forego the use of features such as [expire on commit](../orm/session_basics.html#session-committing)
    so that such loads are not needed.
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的 asyncio 编程模型不允许诸如延迟加载相关属性以及过期属性的非 ORM 特性，因为它们表示 IO 操作，这些操作会在 Python 的 `getattr()`
    操作的范围内隐式运行。为了克服这一点，**传统** asyncio 应用程序应该审慎使用 [急加载](../orm/queryguide/relationships.html)
    技术，并放弃使用诸如 [提交时过期](../orm/session_basics.html#session-committing) 等特性，以避免需要这样的加载。
- en: For the asyncio application developer who **chooses to break** with tradition,
    the new API provides a **strictly optional feature** such that applications that
    wish to make use of such ORM features can opt to organize database-related code
    into functions which can then be run within greenlets using the [`AsyncSession.run_sync()`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession.run_sync
    "sqlalchemy.ext.asyncio.AsyncSession.run_sync") method. See the `greenlet_orm.py`
    example at [Asyncio Integration](../orm/examples.html#examples-asyncio) for a
    demonstration.
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: 对于选择**打破**传统的 asyncio 应用程序开发人员，新的 API 提供了一个**严格可选的功能**，使希望使用此类 ORM 功能的应用程序可以选择将与数据库相关的代码组织到函数中，然后可以使用[`AsyncSession.run_sync()`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession.run_sync
    "sqlalchemy.ext.asyncio.AsyncSession.run_sync")方法在 greenlets 中运行。请参阅[Asyncio 集成](../orm/examples.html#examples-asyncio)中的`greenlet_orm.py`示例进行演示。
- en: Support for asynchronous cursors is also provided using new methods [`AsyncConnection.stream()`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncConnection.stream
    "sqlalchemy.ext.asyncio.AsyncConnection.stream") and [`AsyncSession.stream()`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession.stream
    "sqlalchemy.ext.asyncio.AsyncSession.stream"), which support a new [`AsyncResult`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncResult
    "sqlalchemy.ext.asyncio.AsyncResult") object that itself provides awaitable versions
    of common methods like [`AsyncResult.all()`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncResult.all
    "sqlalchemy.ext.asyncio.AsyncResult.all") and [`AsyncResult.fetchmany()`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncResult.fetchmany
    "sqlalchemy.ext.asyncio.AsyncResult.fetchmany"). Both Core and ORM are integrated
    with the feature which corresponds to the use of “server side cursors” in traditional
    SQLAlchemy.
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: 支持异步游标的方法也提供了新的方法[`AsyncConnection.stream()`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncConnection.stream
    "sqlalchemy.ext.asyncio.AsyncConnection.stream")和[`AsyncSession.stream()`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession.stream
    "sqlalchemy.ext.asyncio.AsyncSession.stream")，支持一个新的[`AsyncResult`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncResult
    "sqlalchemy.ext.asyncio.AsyncResult")对象，该对象本身提供了常见方法的可等待版本，如[`AsyncResult.all()`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncResult.all
    "sqlalchemy.ext.asyncio.AsyncResult.all")和[`AsyncResult.fetchmany()`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncResult.fetchmany
    "sqlalchemy.ext.asyncio.AsyncResult.fetchmany")。Core 和 ORM 都与这一特性集成，对应于传统 SQLAlchemy
    中“服务器端游标”的使用。
- en: See also
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Asynchronous I/O (asyncio)](../orm/extensions/asyncio.html)'
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: '[异步 I/O（asyncio）](../orm/extensions/asyncio.html)'
- en: '[Asyncio Integration](../orm/examples.html#examples-asyncio)'
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: '[Asyncio 集成](../orm/examples.html#examples-asyncio)'
- en: '[#3414](https://www.sqlalchemy.org/trac/ticket/3414)'
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3414](https://www.sqlalchemy.org/trac/ticket/3414)'
- en: '### Many Core and ORM statement objects now perform much of their construction
    and validation in the compile phase'
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: '### 许多 Core 和 ORM 语句对象现在在编译阶段执行大部分构建和验证工作'
- en: A major initiative in the 1.4 series is to approach the model of both Core SQL
    statements as well as the ORM Query to allow for an efficient, cacheable model
    of statement creation and compilation, where the compilation step would be cached,
    based on a cache key generated by the created statement object, which itself is
    newly created for each use. Towards this goal, much of the Python computation
    which occurs within the construction of statements, particularly that of the ORM
    [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    as well as the [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") construct when used to invoke ORM queries,
    is being moved to occur within the compilation phase of the statement which only
    occurs after the statement has been invoked, and only if the statement’s compiled
    form was not yet cached.
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 1.4 系列中的一个重要举措是处理 Core SQL 语句以及 ORM 查询的模型，以允许有效的、可缓存的语句创建和编译模型，其中编译步骤将被缓存，基于由创建的语句对象生成的缓存键，该对象本身为每次使用新创建。为实现这一目标，构建语句中发生的大部分
    Python 计算，特别是 ORM [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")以及在调用 ORM 查询时使用的[`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") 构造时的计算，正在被移至语句的编译阶段，该阶段仅在语句被调用后发生，并且仅在语句的编译形式尚未被缓存时才会发生。
- en: From an end-user perspective, this means that some of the error messages which
    can arise based on arguments passed to the object will no longer be raised immediately,
    and instead will occur only when the statement is invoked for the first time.
    These conditions are always structural and not data driven, so there is no risk
    of such a condition being missed due to a cached statement.
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: 从最终用户的角度来看，这意味着基于传递给对象的参数可能引发的某些错误消息将不再立即引发，而是仅在首次调用语句时发生。这些条件始终是结构性的，而不是数据驱动的，因此不会因为缓存语句而错过这种条件。
- en: 'Error conditions which fall under this category include:'
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: 属于此类别的错误条件包括：
- en: when a `_selectable.CompoundSelect` is constructed (e.g. a UNION, EXCEPT, etc.)
    and the SELECT statements passed do not have the same number of columns, a [`CompileError`](../core/exceptions.html#sqlalchemy.exc.CompileError
    "sqlalchemy.exc.CompileError") is now raised to this effect; previously, an [`ArgumentError`](../core/exceptions.html#sqlalchemy.exc.ArgumentError
    "sqlalchemy.exc.ArgumentError") would be raised immediately upon statement construction.
  id: totrans-788
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当构建`_selectable.CompoundSelect`（例如 UNION、EXCEPT 等）时，传递的 SELECT 语句列数不相同时，现在会引发[`CompileError`](../core/exceptions.html#sqlalchemy.exc.CompileError
    "sqlalchemy.exc.CompileError")；之前，在语句构建时会立即引发[`ArgumentError`](../core/exceptions.html#sqlalchemy.exc.ArgumentError
    "sqlalchemy.exc.ArgumentError")。
- en: Various error conditions which may arise when calling upon [`Query.join()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join") will be evaluated at statement compilation time rather
    than when the method is first called.
  id: totrans-789
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在调用[`Query.join()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.join "sqlalchemy.orm.Query.join")时可能出现的各种错误条件将在语句编译时进行评估，而不是在首次调用方法时。
- en: 'Other things that may change involve the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object directly:'
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: 其他可能发生变化的事情涉及直接的[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")对象：
- en: Behaviors may be slightly different when calling upon the [`Query.statement`](../orm/queryguide/query.html#sqlalchemy.orm.Query.statement
    "sqlalchemy.orm.Query.statement") accessor. The [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") object returned is now a direct copy of the
    same state that was present in the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query"), without any ORM-specific compilation being performed
    (which means it’s dramatically faster). However, the [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") will not have the same internal state as it
    had in 1.3, including things like the FROM clauses being explicitly spelled out
    if they were not explicitly stated in the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query"). This means code that relies upon manipulating this [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") statement such as calling methods like [`Select.with_only_columns()`](../core/selectable.html#sqlalchemy.sql.expression.Select.with_only_columns
    "sqlalchemy.sql.expression.Select.with_only_columns") may need to accommodate
    for the FROM clause.
  id: totrans-791
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在调用[`Query.statement`](../orm/queryguide/query.html#sqlalchemy.orm.Query.statement
    "sqlalchemy.orm.Query.statement")访问器时，行为可能会有所不同。现在返回的[`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select")对象是与[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")中存在的相同状态的直接副本，而不执行任何 ORM 特定的编译（这意味着速度大大提高）。但是，[`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select")将不具有与 1.3 版本中相同的内部状态，包括如果在[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")中未明确声明，则明确拼写出 FROM 子句。这意味着依赖于操作此[`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select")语句的代码，例如调用[`Select.with_only_columns()`](../core/selectable.html#sqlalchemy.sql.expression.Select.with_only_columns
    "sqlalchemy.sql.expression.Select.with_only_columns")等方法可能需要适应 FROM 子句。
- en: See also
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Transparent SQL Compilation Caching added to All DQL, DML Statements in Core,
    ORM](#change-4639)'
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: '[透明 SQL 编译缓存添加到 Core、ORM 中的所有 DQL、DML 语句](#change-4639)'
- en: '### Repaired internal importing conventions such that code linters may work
    correctly'
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: '### 修复了内部导入约定，使代码检查工具可以正常工作'
- en: 'SQLAlchemy has for a long time used a parameter-injecting decorator to help
    resolve mutually-dependent module imports, like this:'
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 长期以来一直使用参数注入装饰器来帮助解决相互依赖的模块导入，就像这样：
- en: '[PRE150]'
  id: totrans-796
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: Where the above function would be rewritten to no longer have the `dml` parameter
    on the outside. This would confuse code-linting tools into seeing a missing parameter
    to functions. A new approach has been implemented internally such that the function’s
    signature is no longer modified and the module object is procured inside the function
    instead.
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: 上述函数将被重写，不再在外部具有 `dml` 参数。这会让代码检测工具看到函数缺少参数而感到困惑。内部已经实现了一种新方法，使函数签名不再被修改，而是在函数内部获取模块对象。
- en: '[#4656](https://www.sqlalchemy.org/trac/ticket/4656)'
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4656](https://www.sqlalchemy.org/trac/ticket/4656)'
- en: '[#4689](https://www.sqlalchemy.org/trac/ticket/4689)'
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4689](https://www.sqlalchemy.org/trac/ticket/4689)'
- en: '### Support for SQL Regular Expression operators'
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: '### 支持 SQL 正则表达式运算符'
- en: A long awaited feature to add rudimentary support for database regular expression
    operators, to complement the [`ColumnOperators.like()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.like
    "sqlalchemy.sql.expression.ColumnOperators.like") and [`ColumnOperators.match()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.match
    "sqlalchemy.sql.expression.ColumnOperators.match") suites of operations. The new
    features include [`ColumnOperators.regexp_match()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.regexp_match
    "sqlalchemy.sql.expression.ColumnOperators.regexp_match") implementing a regular
    expression match like function, and [`ColumnOperators.regexp_replace()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.regexp_replace
    "sqlalchemy.sql.expression.ColumnOperators.regexp_replace") implementing a regular
    expression string replace function.
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: 期待已久的功能是为数据库正则表达式运算符添加基本支持，以补充 [`ColumnOperators.like()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.like
    "sqlalchemy.sql.expression.ColumnOperators.like") 和 [`ColumnOperators.match()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.match
    "sqlalchemy.sql.expression.ColumnOperators.match") 套件的操作。新功能包括 [`ColumnOperators.regexp_match()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.regexp_match
    "sqlalchemy.sql.expression.ColumnOperators.regexp_match") 实现了类似的正则表达式匹配函数，以及 [`ColumnOperators.regexp_replace()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.regexp_replace
    "sqlalchemy.sql.expression.ColumnOperators.regexp_replace") 实现了正则表达式字符串替换函数。
- en: Supported backends include SQLite, PostgreSQL, MySQL / MariaDB, and Oracle.
    The SQLite backend only supports “regexp_match” but not “regexp_replace”.
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: 支持的后端包括 SQLite、PostgreSQL、MySQL / MariaDB 和 Oracle。SQLite 后端仅支持“regexp_match”而不支持“regexp_replace”。
- en: The regular expression syntaxes and flags are **not backend agnostic**. A future
    feature will allow multiple regular expression syntaxes to be specified at once
    to switch between different backends on the fly.
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: 正则表达式语法和标志**不是通用于所有后端**的。未来的功能将允许一次指定多个正则表达式语法，以便在不同后端之间动态切换。
- en: For SQLite, Python’s `re.search()` function with no additional arguments is
    established as the implementation.
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 SQLite，Python 的 `re.search()` 函数在没有额外参数的情况下被确定为实现。
- en: See also
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`ColumnOperators.regexp_match()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.regexp_match
    "sqlalchemy.sql.expression.ColumnOperators.regexp_match")'
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: '[`ColumnOperators.regexp_match()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.regexp_match
    "sqlalchemy.sql.expression.ColumnOperators.regexp_match")'
- en: '[`ColumnOperators.regexp_replace()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.regexp_replace
    "sqlalchemy.sql.expression.ColumnOperators.regexp_replace")'
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: '[`ColumnOperators.regexp_replace()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.regexp_replace
    "sqlalchemy.sql.expression.ColumnOperators.regexp_replace")'
- en: '[Regular Expression Support](../dialects/sqlite.html#pysqlite-regexp) - SQLite
    implementation notes'
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: '[正则表达式支持](../dialects/sqlite.html#pysqlite-regexp) - SQLite 实现说明'
- en: '[#1390](https://www.sqlalchemy.org/trac/ticket/1390)'
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: '[#1390](https://www.sqlalchemy.org/trac/ticket/1390)'
- en: '### SQLAlchemy 2.0 Deprecations Mode'
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: '### SQLAlchemy 2.0 弃用模式'
- en: One of the primary goals of the 1.4 release is to provide a “transitional” release
    so that applications may migrate to SQLAlchemy 2.0 gradually. Towards this end,
    a primary feature in release 1.4 is “2.0 deprecations mode”, which is a series
    of deprecation warnings that emit against every detectable API pattern which will
    work differently in version 2.0\. The warnings all make use of the `RemovedIn20Warning`
    class. As these warnings affect foundational patterns including the [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") and [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") constructs, even simple applications can generate
    a lot of warnings until appropriate API changes are made. The warning mode is
    therefore turned off by default until the developer enables the environment variable
    `SQLALCHEMY_WARN_20=1`.
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: 1.4 版本的主要目标之一是提供一个“过渡”版本，以便应用程序可以逐渐迁移到 SQLAlchemy 2.0。为此，1.4 版本的一个主要特性是“2.0
    弃用模式”，它是一系列弃用警告，针对每个在 2.0 版本中会有不同工作方式的可检测 API 模式发出。所有警告都使用`RemovedIn20Warning`类。由于这些警告影响到基础模式，包括[`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select")和[`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine")构造，即使是简单的应用程序也可能生成大量警告，直到适当的 API 更改完成。因此，默认情况下警告模式被关闭，直到开发人员启用环境变量`SQLALCHEMY_WARN_20=1`。
- en: For a full walkthrough of using 2.0 Deprecations mode, see [Migration to 2.0
    Step Two - Turn on RemovedIn20Warnings](migration_20.html#migration-20-deprecations-mode).
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何使用 2.0 弃用模式的完整步骤，请参阅 [迁移至 2.0 第二步 - 打开 RemovedIn20Warnings](migration_20.html#migration-20-deprecations-mode)。
- en: See also
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[SQLAlchemy 2.0 - Major Migration Guide](migration_20.html)'
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: '[SQLAlchemy 2.0 - 主要迁移指南](migration_20.html)'
- en: '[Migration to 2.0 Step Two - Turn on RemovedIn20Warnings](migration_20.html#migration-20-deprecations-mode)'
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: '[迁移至 2.0 第二步 - 打开 RemovedIn20Warnings](migration_20.html#migration-20-deprecations-mode)'
- en: API and Behavioral Changes - Core
  id: totrans-816
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: API 和行为变化 - 核心
- en: '### A SELECT statement is no longer implicitly considered to be a FROM clause'
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: '### SELECT 语句不再隐式地被视为 FROM 子句'
- en: This change is one of the larger conceptual changes in SQLAlchemy in many years,
    however it is hoped that the end user impact is relatively small, as the change
    more closely matches what databases like MySQL and PostgreSQL require in any case.
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: 这个变化是多年来 SQLAlchemy 中的一个较大的概念性变化之一，但希望最终用户的影响相对较小，因为这个变化更符合像 MySQL 和 PostgreSQL
    这样的数据库在任何情况下所需的情况。
- en: The most immediate noticeable impact is that a [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") can no longer be embedded inside of another
    [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select")
    directly, without explicitly turning the inner [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") into a subquery first. This is historically
    performed by using the [`SelectBase.alias()`](../core/selectable.html#sqlalchemy.sql.expression.SelectBase.alias
    "sqlalchemy.sql.expression.SelectBase.alias") method, which remains, however is
    more explicitly suited by using a new method [`SelectBase.subquery()`](../core/selectable.html#sqlalchemy.sql.expression.SelectBase.subquery
    "sqlalchemy.sql.expression.SelectBase.subquery"); both methods do the same thing.
    The object returned is now [`Subquery`](../core/selectable.html#sqlalchemy.sql.expression.Subquery
    "sqlalchemy.sql.expression.Subquery"), which is very similar to the [`Alias`](../core/selectable.html#sqlalchemy.sql.expression.Alias
    "sqlalchemy.sql.expression.Alias") object and shares a common base [`AliasedReturnsRows`](../core/selectable.html#sqlalchemy.sql.expression.AliasedReturnsRows
    "sqlalchemy.sql.expression.AliasedReturnsRows").
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: 最直接显着的影响是，一个[`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select")现在不能直接嵌套在另一个[`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select")中，而不明确地先将内部[`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select")转换为子查询。这在历史上是通过使用[`SelectBase.alias()`](../core/selectable.html#sqlalchemy.sql.expression.SelectBase.alias
    "sqlalchemy.sql.expression.SelectBase.alias")方法来执行的，但现在更明确地适合使用新方法[`SelectBase.subquery()`](../core/selectable.html#sqlalchemy.sql.expression.SelectBase.subquery
    "sqlalchemy.sql.expression.SelectBase.subquery")；这两种方法都是做同样的事情。现在返回的对象是[`Subquery`](../core/selectable.html#sqlalchemy.sql.expression.Subquery
    "sqlalchemy.sql.expression.Subquery")，它与[`Alias`](../core/selectable.html#sqlalchemy.sql.expression.Alias
    "sqlalchemy.sql.expression.Alias")对象非常相似，并共享一个公共基类[`AliasedReturnsRows`](../core/selectable.html#sqlalchemy.sql.expression.AliasedReturnsRows
    "sqlalchemy.sql.expression.AliasedReturnsRows")。
- en: 'That is, this will now raise:'
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，现在会引发以下错误：
- en: '[PRE151]'
  id: totrans-821
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'Raising:'
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: 引发：
- en: '[PRE152]'
  id: totrans-823
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'The correct calling form is instead (noting also that [brackets are no longer
    required for select()](#change-5284)):'
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: 正确的调用形式应该是（同时注意到 [不再需要为 select() 使用括号](#change-5284)）：
- en: '[PRE153]'
  id: totrans-825
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: Noting above that the [`SelectBase.subquery()`](../core/selectable.html#sqlalchemy.sql.expression.SelectBase.subquery
    "sqlalchemy.sql.expression.SelectBase.subquery") method is essentially equivalent
    to using the [`SelectBase.alias()`](../core/selectable.html#sqlalchemy.sql.expression.SelectBase.alias
    "sqlalchemy.sql.expression.SelectBase.alias") method.
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到上面提到的 [`SelectBase.subquery()`](../core/selectable.html#sqlalchemy.sql.expression.SelectBase.subquery
    "sqlalchemy.sql.expression.SelectBase.subquery") 方法本质上等同于使用 [`SelectBase.alias()`](../core/selectable.html#sqlalchemy.sql.expression.SelectBase.alias
    "sqlalchemy.sql.expression.SelectBase.alias") 方法。
- en: 'The rationale for this change is based on the following:'
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: 这种更改的基本原理是：
- en: In order to support the unification of [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") with [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query"), the [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") object needs to have [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") and [`Select.outerjoin()`](../core/selectable.html#sqlalchemy.sql.expression.Select.outerjoin
    "sqlalchemy.sql.expression.Select.outerjoin") methods that actually add JOIN criteria
    to the existing FROM clause, as is what users have always expected it to do in
    any case. The previous behavior, having to align with what a [`FromClause`](../core/selectable.html#sqlalchemy.sql.expression.FromClause
    "sqlalchemy.sql.expression.FromClause") would do, was that it would generate an
    unnamed subquery and then JOIN to it, which was a completely useless feature that
    only confused those users unfortunate enough to try this. This change is discussed
    at [select().join() and outerjoin() add JOIN criteria to the current query, rather
    than creating a subquery](#change-select-join).
  id: totrans-828
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了支持将 [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select "sqlalchemy.sql.expression.Select")
    与 [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    统一起来，[`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select "sqlalchemy.sql.expression.Select")
    对象需要具有实际将 JOIN 条件添加到现有 FROM 子句的 [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") 和 [`Select.outerjoin()`](../core/selectable.html#sqlalchemy.sql.expression.Select.outerjoin
    "sqlalchemy.sql.expression.Select.outerjoin") 方法，正如用户一直期望它所做的那样。之前的行为是，必须与 [`FromClause`](../core/selectable.html#sqlalchemy.sql.expression.FromClause
    "sqlalchemy.sql.expression.FromClause") 的行为相一致，它会生成一个未命名的子查询，然后再与之 JOIN，这是一个完全无用的功能，只会混淆那些不幸尝试此操作的用户。这一变更在
    [select().join() 和 outerjoin() 将 JOIN 条件添加到当前查询，而不是创建子查询](#change-select-join)
    中进行了讨论。
- en: 'The behavior of including a SELECT in the FROM clause of another SELECT without
    first creating an alias or subquery would be that it creates an unnamed subquery.
    While standard SQL does support this syntax, in practice it is rejected by most
    databases. For example, both the MySQL and PostgreSQL outright reject the usage
    of unnamed subqueries:'
  id: totrans-829
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将一个 SELECT 包含在另一个 SELECT 的 FROM 子句中，而不先创建别名或子查询的行为会导致创建一个未命名的子查询。虽然标准 SQL 支持此语法，但实际上大多数数据库都会拒绝它。例如，MySQL
    和 PostgreSQL 都直接拒绝使用未命名的子查询：
- en: '[PRE154]'
  id: totrans-830
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE154]'
- en: 'A database like SQLite accepts them, however it is still often the case that
    the names produced from such a subquery are too ambiguous to be useful:'
  id: totrans-831
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: SQLite 这样的数据库接受它们，但通常情况下，从这样的子查询中生成的名称太模糊而无法使用：
- en: '[PRE155]'
  id: totrans-832
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE155]'
- en: As [`SelectBase`](../core/selectable.html#sqlalchemy.sql.expression.SelectBase
    "sqlalchemy.sql.expression.SelectBase") objects are no longer [`FromClause`](../core/selectable.html#sqlalchemy.sql.expression.FromClause
    "sqlalchemy.sql.expression.FromClause") objects, attributes like the `.c` attribute
    as well as methods like `.select()` is now deprecated, as they imply implicit
    production of a subquery. The `.join()` and `.outerjoin()` methods are now [repurposed
    to append JOIN criteria to the existing query](#change-select-join) in a similar
    way as that of [`Query.join()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join"), which is what users have always expected these methods
    to do in any case.
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 [`SelectBase`](../core/selectable.html#sqlalchemy.sql.expression.SelectBase
    "sqlalchemy.sql.expression.SelectBase") 对象不再是 [`FromClause`](../core/selectable.html#sqlalchemy.sql.expression.FromClause
    "sqlalchemy.sql.expression.FromClause") 对象，因此像 `.c` 属性以及 `.select()` 这样的方法现在已经被弃用，因为它们意味着隐式生成子查询。`.join()`
    和 `.outerjoin()` 方法现在被重新用于在现有查询中附加 JOIN 条件，方式与 [`Query.join()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join") 类似，这正是用户一直期望这些方法做的事情。
- en: 'In place of the `.c` attribute, a new attribute [`SelectBase.selected_columns`](../core/selectable.html#sqlalchemy.sql.expression.SelectBase.selected_columns
    "sqlalchemy.sql.expression.SelectBase.selected_columns") is added. This attribute
    resolves to a column collection that is what most people hope that `.c` does (but
    does not), which is to reference the columns that are in the columns clause of
    the SELECT statement. A common beginner mistake is code such as the following:'
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: 新的属性 [`SelectBase.selected_columns`](../core/selectable.html#sqlalchemy.sql.expression.SelectBase.selected_columns
    "sqlalchemy.sql.expression.SelectBase.selected_columns") 替代了 `.c` 属性。该属性解析为一个列集合，大多数人希望
    `.c` 能做到的事情（但实际上不行），即引用 SELECT 语句中列子句中的列。一个常见的初学者错误是以下代码：
- en: '[PRE156]'
  id: totrans-835
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: The above code appears intuitive and that it would generate “SELECT * FROM users
    WHERE name=’foo’”, however veteran SQLAlchemy users will recognize that it in
    fact generates a useless subquery resembling “SELECT * FROM (SELECT * FROM users)
    WHERE name=’foo’”.
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码看起来直观，会生成“SELECT * FROM users WHERE name='foo'”，但是经验丰富的 SQLAlchemy 用户会认识到，它实际上生成了一个无用的子查询，类似于“SELECT
    * FROM (SELECT * FROM users) WHERE name='foo'”。
- en: 'The new [`SelectBase.selected_columns`](../core/selectable.html#sqlalchemy.sql.expression.SelectBase.selected_columns
    "sqlalchemy.sql.expression.SelectBase.selected_columns") attribute however **does**
    suit the use case above, as in a case like the above it links directly to the
    columns present in the `users.c` collection:'
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: 但新的 [`SelectBase.selected_columns`](../core/selectable.html#sqlalchemy.sql.expression.SelectBase.selected_columns
    "sqlalchemy.sql.expression.SelectBase.selected_columns") 属性确实适用于上述用例，因为在上述情况下，它直接链接到
    `users.c` 集合中存在的列：
- en: '[PRE157]'
  id: totrans-838
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '[#4617](https://www.sqlalchemy.org/trac/ticket/4617)  ### select().join() and
    outerjoin() add JOIN criteria to the current query, rather than creating a subquery'
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4617](https://www.sqlalchemy.org/trac/ticket/4617)  ### select().join() 和
    outerjoin() 将 JOIN 条件添加到当前查询，而不是创建子查询'
- en: Towards the goal of unifying [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") and [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select"), particularly for [2.0 style](../glossary.html#term-2.0-style)
    use of [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select "sqlalchemy.sql.expression.Select"),
    it was critical that there be a working [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") method that behaves like the [`Query.join()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join") method, adding additional entries to the FROM clause
    of the existing SELECT and then returning the new [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") object for further modification, instead of
    wrapping the object inside of an unnamed subquery and returning a JOIN from that
    subquery, a behavior that has always been virtually useless and completely misleading
    to users.
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现统一[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")和[`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select")的目标，特别是对于[2.0风格](../glossary.html#term-2.0-style)使用[`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select")，至关重要的是有一个工作的[`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join")方法，其行为类似于[`Query.join()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join")方法，向现有SELECT的FROM子句添加额外条目，然后返回新的[`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select")对象以进行进一步修改，而不是将对象包装在一个无名子查询中并从该子查询返回JOIN，这种行为对用户来说一直是几乎无用和完全误导的。
- en: To allow this to be the case, [A SELECT statement is no longer implicitly considered
    to be a FROM clause](#change-4617) was first implemented which splits off [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") from having to be a [`FromClause`](../core/selectable.html#sqlalchemy.sql.expression.FromClause
    "sqlalchemy.sql.expression.FromClause"); this removed the requirement that [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") would need to return a [`Join`](../core/selectable.html#sqlalchemy.sql.expression.Join
    "sqlalchemy.sql.expression.Join") object rather than a new version of that [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") object that includes a new JOIN in its FROM
    clause.
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，首先实现了[A SELECT statement is no longer implicitly considered to be a
    FROM clause](#change-4617)，这将[`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select")从必须是[`FromClause`](../core/selectable.html#sqlalchemy.sql.expression.FromClause
    "sqlalchemy.sql.expression.FromClause")中分离出来；这消除了[`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join")需要返回一个[`Join`](../core/selectable.html#sqlalchemy.sql.expression.Join
    "sqlalchemy.sql.expression.Join")对象而不是包含新JOIN的新版本的[`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select")对象的要求。
- en: From that point on, as the [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") and [`Select.outerjoin()`](../core/selectable.html#sqlalchemy.sql.expression.Select.outerjoin
    "sqlalchemy.sql.expression.Select.outerjoin") did have an existing behavior, the
    original plan was that these methods would be deprecated, and the new “useful”
    version of the methods would be available on an alternate, “future” [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") object available as a separate import.
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: 从那时起，由于[`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join")和[`Select.outerjoin()`](../core/selectable.html#sqlalchemy.sql.expression.Select.outerjoin
    "sqlalchemy.sql.expression.Select.outerjoin")已经存在行为，最初的计划是这些方法将被弃用，并且新的“有用”版本的方法将在一个备用的“未来”[`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select")对象上可用，作为一个单独的导入。
- en: However, after some time working with this particular codebase, it was decided
    that having two different kinds of [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") objects floating around, each with 95% the
    same behavior except for some subtle difference in how some of the methods behave
    was going to be more misleading and inconvenient than simply making a hard change
    in how these two methods behave, given that the existing behavior of [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") and [`Select.outerjoin()`](../core/selectable.html#sqlalchemy.sql.expression.Select.outerjoin
    "sqlalchemy.sql.expression.Select.outerjoin") is essentially never used and only
    causes confusion.
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，经过一段时间与这个特定代码库一起工作后，决定让两种不同类型的[`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select")对象漂浮，每个对象的行为几乎相同，只是一些方法的行为略有不同，这将比简单地改变这两种方法的行为更具误导性和不便，因为[`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join")和[`Select.outerjoin()`](../core/selectable.html#sqlalchemy.sql.expression.Select.outerjoin
    "sqlalchemy.sql.expression.Select.outerjoin")的现有行为几乎从不被使用，只会造成混乱。
- en: So it was decided, given how very useless the current behavior is, and how extremely
    useful and important and useful the new behavior would be, to make a **hard behavioral
    change** in this one area, rather than waiting another year and having a more
    awkward API in the interim. SQLAlchemy developers do not take it lightly to make
    a completely breaking change like this, however this is a very special case and
    it is extremely unlikely that the previous implementation of these methods was
    being used; as noted in [A SELECT statement is no longer implicitly considered
    to be a FROM clause](#change-4617), major databases such as MySQL and PostgreSQL
    don’t allow for unnamed subqueries in any case and from a syntactical point of
    view it’s nearly impossible for a JOIN from an unnamed subquery to be useful since
    it’s very difficult to refer to the columns within it unambiguously.
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: 因为当前行为非常无用，而新行为将非常有用和重要，因此决定在这一领域做出**严格的行为更改**，而不是等待另一年并在此期间拥有更加尴尬的API。 SQLAlchemy开发人员并不轻易进行完全破坏性的更改，然而这是一个非常特殊的情况，以前几乎不太可能使用这些方法的实现；正如在[A
    SELECT statement is no longer implicitly considered to be a FROM clause](#change-4617)中所指出的，主要数据库如MySQL和PostgreSQL在任何情况下都不允许未命名的子查询，并且从语法角度来看，从未命名的子查询进行JOIN几乎不可能是有用的，因为在其中明确引用列非常困难。
- en: 'With the new implementation, [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") and [`Select.outerjoin()`](../core/selectable.html#sqlalchemy.sql.expression.Select.outerjoin
    "sqlalchemy.sql.expression.Select.outerjoin") now behave very similarly to that
    of [`Query.join()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.join "sqlalchemy.orm.Query.join"),
    adding JOIN criteria to the existing statement by matching to the left entity:'
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: 使用新实现，[`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join")和[`Select.outerjoin()`](../core/selectable.html#sqlalchemy.sql.expression.Select.outerjoin
    "sqlalchemy.sql.expression.Select.outerjoin")现在行为与[`Query.join()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join")非常相似，通过与左实体匹配添加JOIN条件到现有语句中：
- en: '[PRE158]'
  id: totrans-846
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'producing:'
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: 产生：
- en: '[PRE159]'
  id: totrans-848
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'As is the case for [`Join`](../core/selectable.html#sqlalchemy.sql.expression.Join
    "sqlalchemy.sql.expression.Join"), the ON clause is automatically determined if
    feasible:'
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: 与[`Join`](../core/selectable.html#sqlalchemy.sql.expression.Join "sqlalchemy.sql.expression.Join")一样，如果可行，ON子句将自动确定：
- en: '[PRE160]'
  id: totrans-850
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'When ORM entities are used in the statement, this is essentially how ORM queries
    are built up using [2.0 style](../glossary.html#term-2.0-style) invocation. ORM
    entities will assign a “plugin” to the statement internally such that ORM-related
    compilation rules will take place when the statement is compiled into a SQL string.
    More directly, the [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") method can accommodate ORM relationships,
    without breaking the hard separation between Core and ORM internals:'
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: 当在语句中使用ORM实体时，这基本上是使用[2.0风格](../glossary.html#term-2.0-style)调用构建ORM查询的方式。 ORM实体将在语句内部分配一个“插件”，以便在将语句编译为SQL字符串时将发生与ORM相关的编译规则。
    更直接地说，[`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join")方法可以适应ORM关系，而不会破坏Core和ORM内部之间的严格分离：
- en: '[PRE161]'
  id: totrans-852
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: 'Another new method [`Select.join_from()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join_from
    "sqlalchemy.sql.expression.Select.join_from") is also added, which allows easier
    specification of the left and right side of a join at once:'
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个新方法 [`Select.join_from()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join_from
    "sqlalchemy.sql.expression.Select.join_from") 也被添加，它允许更容易地一次性指定连接的左侧和右侧：
- en: '[PRE162]'
  id: totrans-854
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: 'producing:'
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: 产生：
- en: '[PRE163]  ### The URL object is now immutable'
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE163]  ### URL 对象现在是不可变的'
- en: The [`URL`](../core/engines.html#sqlalchemy.engine.URL "sqlalchemy.engine.URL")
    object has been formalized such that it now presents itself as a `namedtuple`
    with a fixed number of fields that are immutable. In addition, the dictionary
    represented by the [`URL.query`](../core/engines.html#sqlalchemy.engine.URL.query
    "sqlalchemy.engine.URL.query") attribute is also an immutable mapping. Mutation
    of the [`URL`](../core/engines.html#sqlalchemy.engine.URL "sqlalchemy.engine.URL")
    object was not a formally supported or documented use case which led to some open-ended
    use cases that made it very difficult to intercept incorrect usages, most commonly
    mutation of the [`URL.query`](../core/engines.html#sqlalchemy.engine.URL.query
    "sqlalchemy.engine.URL.query") dictionary to include non-string elements. It also
    led to all the common problems of allowing mutability in a fundamental data object,
    namely unwanted mutations elsewhere leaking into code that didn’t expect the URL
    to change. Finally, the namedtuple design is inspired by that of Python’s `urllib.parse.urlparse()`
    which returns the parsed object as a named tuple.
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: '[`URL`](../core/engines.html#sqlalchemy.engine.URL "sqlalchemy.engine.URL")
    对象已经被正式规范化，现在它呈现为一个具有固定字段数量的不可变的 `namedtuple`。此外，由 [`URL.query`](../core/engines.html#sqlalchemy.engine.URL.query
    "sqlalchemy.engine.URL.query") 属性表示的字典也是一个不可变的映射。对 [`URL`](../core/engines.html#sqlalchemy.engine.URL
    "sqlalchemy.engine.URL") 对象的修改并不是一个正式支持或记录的用例，这导致了一些开放式用例，使得很难拦截不正确的用法，最常见的是修改
    [`URL.query`](../core/engines.html#sqlalchemy.engine.URL.query "sqlalchemy.engine.URL.query")
    字典以包含非字符串元素。这也导致了在一个基本数据对象中允许可变性的所有常见问题，即不希望的变化泄漏到不希望 URL 改变的代码中。最后，`namedtuple`
    的设计灵感来自 Python 的 `urllib.parse.urlparse()`，它将解析后的对象作为一个命名元组返回。'
- en: The decision to change the API outright is based on a calculus weighing the
    infeasibility of a deprecation path (which would involve changing the [`URL.query`](../core/engines.html#sqlalchemy.engine.URL.query
    "sqlalchemy.engine.URL.query") dictionary to be a special dictionary that emits
    deprecation warnings when any kind of standard library mutation methods are invoked,
    in addition that when the dictionary would hold any kind of list of elements,
    the list would also have to emit deprecation warnings on mutation) against the
    unlikely use case of projects already mutating [`URL`](../core/engines.html#sqlalchemy.engine.URL
    "sqlalchemy.engine.URL") objects in the first place, as well as that small changes
    such as that of [#5341](https://www.sqlalchemy.org/trac/ticket/5341) were creating
    backwards-incompatibility in any case. The primary case for mutation of a [`URL`](../core/engines.html#sqlalchemy.engine.URL
    "sqlalchemy.engine.URL") object is that of parsing plugin arguments within the
    [`CreateEnginePlugin`](../core/connections.html#sqlalchemy.engine.CreateEnginePlugin
    "sqlalchemy.engine.CreateEnginePlugin") extension point, itself a fairly recent
    addition that based on Github code search is in use by two repositories, neither
    of which are actually mutating the URL object.
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: 直接更改 API 的决定是基于权衡不可能的弃用路径（这将涉及将 [`URL.query`](../core/engines.html#sqlalchemy.engine.URL.query
    "sqlalchemy.engine.URL.query") 字典更改为一个特殊字典，当调用任何标准库变异方法时会发出弃用警告，此外，当字典保存任何类型的元素列表时，列表也必须在变异时发出弃用警告）与项目已经在第一次变异
    [`URL`](../core/engines.html#sqlalchemy.engine.URL "sqlalchemy.engine.URL") 对象的不太可能用例之间的比较，以及像
    [#5341](https://www.sqlalchemy.org/trac/ticket/5341) 这样的小改变在任何情况下都会造成向后不兼容性。对
    [`URL`](../core/engines.html#sqlalchemy.engine.URL "sqlalchemy.engine.URL") 对象进行变异的主要用例是在
    [`CreateEnginePlugin`](../core/connections.html#sqlalchemy.engine.CreateEnginePlugin
    "sqlalchemy.engine.CreateEnginePlugin") 扩展点内解析插件参数，这本身是一个相当新的添加，根据 Github 代码搜索的结果，有两个仓库在使用它，但都没有实际变异
    URL 对象。
- en: 'The [`URL`](../core/engines.html#sqlalchemy.engine.URL "sqlalchemy.engine.URL")
    object now provides a rich interface inspecting and generating new [`URL`](../core/engines.html#sqlalchemy.engine.URL
    "sqlalchemy.engine.URL") objects. The existing mechanism to create a [`URL`](../core/engines.html#sqlalchemy.engine.URL
    "sqlalchemy.engine.URL") object, the [`make_url()`](../core/engines.html#sqlalchemy.engine.make_url
    "sqlalchemy.engine.make_url") function, remains unchanged:'
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: '[`URL`](../core/engines.html#sqlalchemy.engine.URL "sqlalchemy.engine.URL")对象现在提供了一个丰富的接口来检查和生成新的[`URL`](../core/engines.html#sqlalchemy.engine.URL
    "sqlalchemy.engine.URL")对象。用于创建[`URL`](../core/engines.html#sqlalchemy.engine.URL
    "sqlalchemy.engine.URL")对象的现有机制，即[`make_url()`](../core/engines.html#sqlalchemy.engine.make_url
    "sqlalchemy.engine.make_url")函数，保持不变：'
- en: '[PRE164]'
  id: totrans-860
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: 'For programmatic construction, code that may have been using the [`URL`](../core/engines.html#sqlalchemy.engine.URL
    "sqlalchemy.engine.URL") constructor or `__init__` method directly will receive
    a deprecation warning if arguments are passed as keyword arguments and not an
    exact 7-tuple. The keyword-style constructor is now available via the [`URL.create()`](../core/engines.html#sqlalchemy.engine.URL.create
    "sqlalchemy.engine.URL.create") method:'
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
  zh: 对于以编程方式构建的代码，如果参数作为关键字参数传递而不是精确的7元组，则可能已经使用[`URL`](../core/engines.html#sqlalchemy.engine.URL
    "sqlalchemy.engine.URL")构造函数或`__init__`方法的代码将收到弃用警告。现在可以通过[`URL.create()`](../core/engines.html#sqlalchemy.engine.URL.create
    "sqlalchemy.engine.URL.create")方法使用关键字样式的构造函数：
- en: '[PRE165]'
  id: totrans-862
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: 'Fields can be altered typically using the [`URL.set()`](../core/engines.html#sqlalchemy.engine.URL.set
    "sqlalchemy.engine.URL.set") method, which returns a new [`URL`](../core/engines.html#sqlalchemy.engine.URL
    "sqlalchemy.engine.URL") object with changes applied:'
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: 通常可以使用[`URL.set()`](../core/engines.html#sqlalchemy.engine.URL.set "sqlalchemy.engine.URL.set")方法更改字段，该方法返回一个应用更改的新[`URL`](../core/engines.html#sqlalchemy.engine.URL
    "sqlalchemy.engine.URL")对象：
- en: '[PRE166]'
  id: totrans-864
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: 'To alter the contents of the [`URL.query`](../core/engines.html#sqlalchemy.engine.URL.query
    "sqlalchemy.engine.URL.query") dictionary, methods such as [`URL.update_query_dict()`](../core/engines.html#sqlalchemy.engine.URL.update_query_dict
    "sqlalchemy.engine.URL.update_query_dict") may be used:'
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改[`URL.query`](../core/engines.html#sqlalchemy.engine.URL.query "sqlalchemy.engine.URL.query")字典的内容，可以使用[`URL.update_query_dict()`](../core/engines.html#sqlalchemy.engine.URL.update_query_dict
    "sqlalchemy.engine.URL.update_query_dict")等方法：
- en: '[PRE167]'
  id: totrans-866
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: 'To upgrade code that is mutating these fields directly, a **backwards and forwards
    compatible approach** is to use a duck-typing, as in the following style:'
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: 要升级直接更改这些字段的代码，一个**向后和向前兼容的方法**是使用鸭子类型，如以下样式：
- en: '[PRE168]'
  id: totrans-868
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: 'The query string retains its existing format as a dictionary of strings to
    strings, using sequences of strings to represent multiple parameters. For example:'
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: 查询字符串保留其现有格式，作为字符串到字符串的字典，使用字符串序列表示多个参数。例如：
- en: '[PRE169]'
  id: totrans-870
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: 'To work with the contents of the [`URL.query`](../core/engines.html#sqlalchemy.engine.URL.query
    "sqlalchemy.engine.URL.query") attribute such that all values are normalized into
    sequences, use the [`URL.normalized_query`](../core/engines.html#sqlalchemy.engine.URL.normalized_query
    "sqlalchemy.engine.URL.normalized_query") attribute:'
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
  zh: 要处理[`URL.query`](../core/engines.html#sqlalchemy.engine.URL.query "sqlalchemy.engine.URL.query")属性的内容，使所有值规范化为序列，可以使用[`URL.normalized_query`](../core/engines.html#sqlalchemy.engine.URL.normalized_query
    "sqlalchemy.engine.URL.normalized_query")属性：
- en: '[PRE170]'
  id: totrans-872
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: 'The query string can be appended to via methods such as [`URL.update_query_dict()`](../core/engines.html#sqlalchemy.engine.URL.update_query_dict
    "sqlalchemy.engine.URL.update_query_dict"), [`URL.update_query_pairs()`](../core/engines.html#sqlalchemy.engine.URL.update_query_pairs
    "sqlalchemy.engine.URL.update_query_pairs"), [`URL.update_query_string()`](../core/engines.html#sqlalchemy.engine.URL.update_query_string
    "sqlalchemy.engine.URL.update_query_string"):'
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
  zh: 查询字符串可以通过[`URL.update_query_dict()`](../core/engines.html#sqlalchemy.engine.URL.update_query_dict
    "sqlalchemy.engine.URL.update_query_dict")、[`URL.update_query_pairs()`](../core/engines.html#sqlalchemy.engine.URL.update_query_pairs
    "sqlalchemy.engine.URL.update_query_pairs")、[`URL.update_query_string()`](../core/engines.html#sqlalchemy.engine.URL.update_query_string
    "sqlalchemy.engine.URL.update_query_string")等方法追加：
- en: '[PRE171]'
  id: totrans-874
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: See also
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`URL`](../core/engines.html#sqlalchemy.engine.URL "sqlalchemy.engine.URL")'
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: '[`URL`](../core/engines.html#sqlalchemy.engine.URL "sqlalchemy.engine.URL")'
- en: Changes to CreateEnginePlugin
  id: totrans-877
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 更改CreateEnginePlugin
- en: 'The [`CreateEnginePlugin`](../core/connections.html#sqlalchemy.engine.CreateEnginePlugin
    "sqlalchemy.engine.CreateEnginePlugin") is also impacted by this change, as the
    documentation for custom plugins indicated that the `dict.pop()` method should
    be used to remove consumed arguments from the URL object. This should now be achieved
    using the [`CreateEnginePlugin.update_url()`](../core/connections.html#sqlalchemy.engine.CreateEnginePlugin.update_url
    "sqlalchemy.engine.CreateEnginePlugin.update_url") method. A backwards compatible
    approach would look like:'
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
  zh: '[`CreateEnginePlugin`](../core/connections.html#sqlalchemy.engine.CreateEnginePlugin
    "sqlalchemy.engine.CreateEnginePlugin") 也受到了这一更改的影响，因为自定义插件的文档指出应该使用 `dict.pop()`
    方法从 URL 对象中删除已使用的参数。现在应该使用 [`CreateEnginePlugin.update_url()`](../core/connections.html#sqlalchemy.engine.CreateEnginePlugin.update_url
    "sqlalchemy.engine.CreateEnginePlugin.update_url") 方法来实现。向后兼容的方法如下所示：'
- en: '[PRE172]'
  id: totrans-879
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: See the docstring at [`CreateEnginePlugin`](../core/connections.html#sqlalchemy.engine.CreateEnginePlugin
    "sqlalchemy.engine.CreateEnginePlugin") for complete details on how this class
    is used.
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
  zh: 有关此类的完整详细信息，请参阅[`CreateEnginePlugin`](../core/connections.html#sqlalchemy.engine.CreateEnginePlugin
    "sqlalchemy.engine.CreateEnginePlugin")中的文档字符串，了解此类的使用方法。
- en: '[#5526](https://www.sqlalchemy.org/trac/ticket/5526)  ### select(), case()
    now accept positional expressions'
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: '[#5526](https://www.sqlalchemy.org/trac/ticket/5526)  ### select(), case()
    现在接受位置表达式'
- en: 'As it may be seen elsewhere in this document, the [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") construct will now accept “columns clause”
    arguments positionally, rather than requiring they be passed as a list:'
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
  zh: 正如本文档中的其他地方所见，[`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") 构造现在将按位置接受“列子句”参数，而不需要将它们作为列表传递：
- en: '[PRE173]'
  id: totrans-883
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: When sending the arguments positionally, no other keyword arguments are permitted.
    In SQLAlchemy 2.0, the above calling style will be the only calling style supported.
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: 在按位置发送参数时，不允许使用其他关键字参数。在 SQLAlchemy 2.0 中，上述调用风格将是唯一支持的调用风格。
- en: 'For the duration of 1.4, the previous calling style will still continue to
    function, which passes the list of columns or other expressions as a list:'
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: 在 1.4 版本期间，先前的调用风格仍将继续运行，该调用风格将列或其他表达式的列表作为列表传递：
- en: '[PRE174]'
  id: totrans-886
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: 'The above legacy calling style also accepts the old keyword arguments that
    have since been removed from most narrative documentation. The existence of these
    keyword arguments is why the columns clause was passed as a list in the first
    place:'
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: 上述的旧调用风格也接受了从大多数叙述性文档中删除的旧关键字参数。正是这些关键字参数的存在导致了首次传递列子句作为列表的原因：
- en: '[PRE175]'
  id: totrans-888
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: 'The detection between the two styles is based on whether or not the first positional
    argument is a list. There are unfortunately still likely some usages that look
    like the following, where the keyword for the “whereclause” is omitted:'
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
  zh: 两种风格之间的区别是第一个位置参数是否为列表。不幸的是，仍然可能存在一些看起来像下面的用法，其中“whereclause”的关键字被省略了：
- en: '[PRE176]'
  id: totrans-890
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: As part of this change, the [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") construct also gains the 2.0-style “future”
    API which includes an updated [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") method as well as methods like [`Select.filter_by()`](../core/selectable.html#sqlalchemy.sql.expression.Select.filter_by
    "sqlalchemy.sql.expression.Select.filter_by") and [`Select.join_from()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join_from
    "sqlalchemy.sql.expression.Select.join_from").
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: 作为此更改的一部分，[`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") 构造还获得了 2.0 风格的“未来” API，其中包括更新的 [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") 方法以及像 [`Select.filter_by()`](../core/selectable.html#sqlalchemy.sql.expression.Select.filter_by
    "sqlalchemy.sql.expression.Select.filter_by") 和 [`Select.join_from()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join_from
    "sqlalchemy.sql.expression.Select.join_from") 这样的方法。
- en: 'In a related change, the [`case()`](../core/sqlelement.html#sqlalchemy.sql.expression.case
    "sqlalchemy.sql.expression.case") construct has also been modified to accept its
    list of WHEN clauses positionally, with a similar deprecation track for the old
    calling style:'
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: 在相关更改中，[`case()`](../core/sqlelement.html#sqlalchemy.sql.expression.case "sqlalchemy.sql.expression.case")
    构造也已经修改为按位置接受其 WHEN 子句列表，旧的调用风格也有类似的弃用跟踪：
- en: '[PRE177]'
  id: totrans-893
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: The convention for SQLAlchemy constructs accepting `*args` vs. a list of values,
    as is the latter case for a construct like [`ColumnOperators.in_()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.in_
    "sqlalchemy.sql.expression.ColumnOperators.in_"), is that **positional arguments
    are used for structural specification, lists are used for data specification**.
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: 对于接受`*args`与值列表的SQLAlchemy构造的约定，就像[`ColumnOperators.in_()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.in_
    "sqlalchemy.sql.expression.ColumnOperators.in_")这样的构造中的后者情况一样，**位置参数用于结构规范，列表用于数据规范**。
- en: See also
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[select() no longer accepts varied constructor arguments, columns are passed
    positionally](migration_20.html#migration-20-5284)'
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
  zh: '[select() 不再接受不同的构造参数，列按位置传递](migration_20.html#migration-20-5284)'
- en: '[select() construct created in “legacy” mode; keyword arguments, etc.](../errors.html#error-c9ae)'
  id: totrans-897
  prefs: []
  type: TYPE_NORMAL
  zh: '[select() 构造以“legacy”模式创建；关键字参数等](../errors.html#error-c9ae)'
- en: '[#5284](https://www.sqlalchemy.org/trac/ticket/5284)  ### All IN expressions
    render parameters for each value in the list on the fly (e.g. expanding parameters)'
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
  zh: '[#5284](https://www.sqlalchemy.org/trac/ticket/5284)  ### 所有IN表达式会动态为列表中的每个值渲染参数（例如，扩展参数）'
- en: The “expanding IN” feature, first introduced in [Late-expanded IN parameter
    sets allow IN expressions with cached statements](migration_12.html#change-3953),
    has matured enough such that it is clearly superior to the previous method of
    rendering IN expressions. As the approach was improved to handle empty lists of
    values, it is now the only means that Core / ORM will use to render lists of IN
    parameters.
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
  zh: 首次引入的“扩展IN”功能，见[延迟扩展的IN参数集允许具有缓存语句的IN表达式](migration_12.html#change-3953)，已经足够成熟，明显优于以前的渲染IN表达式的方法。随着这种方法的改进以处理空值列表，它现在是Core
    / ORM渲染IN参数列表的唯一方法。
- en: The previous approach which has been present in SQLAlchemy since its first release
    was that when a list of values were passed to the [`ColumnOperators.in_()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.in_
    "sqlalchemy.sql.expression.ColumnOperators.in_") method, the list would be expanded
    into a series of individual [`BindParameter`](../core/sqlelement.html#sqlalchemy.sql.expression.BindParameter
    "sqlalchemy.sql.expression.BindParameter") objects at statement construction time.
    This suffered from the limitation that it was not possible to vary the parameter
    list at statement execution time based on the parameter dictionary, which meant
    that string SQL statements could not be cached independently of their parameters,
    nor could the parameter dictionary be fully used for statements that included
    IN expressions generally.
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy自首次发布以来一直存在的先前方法是，当一系列值传递给[`ColumnOperators.in_()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.in_
    "sqlalchemy.sql.expression.ColumnOperators.in_")方法时，在语句构造时，列表将被扩展为一系列单独的[`BindParameter`](../core/sqlelement.html#sqlalchemy.sql.expression.BindParameter
    "sqlalchemy.sql.expression.BindParameter")对象。这受到的限制是，在语句执行时无法根据参数字典变化参数列表，这意味着无法独立缓存字符串SQL语句及其参数，也无法完全用于包含IN表达式的语句。
- en: In order to service the “baked query” feature described at [Baked Queries](../orm/extensions/baked.html),
    a cacheable version of IN was needed, which is what brought about the “expanding
    IN” feature. In contrast to the existing behavior whereby the parameter list is
    expanded at statement construction time into individual [`BindParameter`](../core/sqlelement.html#sqlalchemy.sql.expression.BindParameter
    "sqlalchemy.sql.expression.BindParameter") objects, the feature instead uses a
    single [`BindParameter`](../core/sqlelement.html#sqlalchemy.sql.expression.BindParameter
    "sqlalchemy.sql.expression.BindParameter") that stores the list of values at once;
    when the statement is executed by the [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine"), it is “expanded” on the fly into individual bound
    parameter positions based on the parameters passed to the call to [`Connection.execute()`](../core/connections.html#sqlalchemy.engine.Connection.execute
    "sqlalchemy.engine.Connection.execute"), and the existing SQL string which may
    have been retrieved from a previous execution is modified using a regular expression
    to suit the current parameter set. This allows for the same [`Compiled`](../core/internals.html#sqlalchemy.engine.Compiled
    "sqlalchemy.engine.Compiled") object, which stores the rendered string statement,
    to be invoked multiple times against different parameter sets that modify the
    list contents passed to IN expressions, while still maintaining the behavior of
    individual scalar parameters being passed to the DBAPI. While some DBAPIs do support
    this functionality directly, it is not generally available; the “expanding IN”
    feature now supports the behavior consistently for all backends.
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持[Baked Queries](../orm/extensions/baked.html)中描述的“烘焙查询”功能，需要一个可缓存版本的IN，这就带来了“扩展IN”功能。与现有行为相反，在语句构造时将参数列表展开为单独的[`BindParameter`](../core/sqlelement.html#sqlalchemy.sql.expression.BindParameter
    "sqlalchemy.sql.expression.BindParameter")对象，该功能使用一个存储值列表的单个[`BindParameter`](../core/sqlelement.html#sqlalchemy.sql.expression.BindParameter
    "sqlalchemy.sql.expression.BindParameter")；当语句由[`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine")执行时，它会根据传递给[`Connection.execute()`](../core/connections.html#sqlalchemy.engine.Connection.execute
    "sqlalchemy.engine.Connection.execute")调用的参数，在执行过程中动态将其“展开”为基于参数传递的单个绑定参数位置，并且已从先前执行中检索到的现有SQL字符串将使用正则表达式进行修改，以适应当前参数集。这允许相同的[`Compiled`](../core/internals.html#sqlalchemy.engine.Compiled
    "sqlalchemy.engine.Compiled")对象，存储渲染的字符串语句，针对修改传递给IN表达式的列表内容的不同参数集多次调用，同时仍保持将单个标量参数传递给DBAPI的行为。虽然一些DBAPI直接支持此功能，但通常不可用；“扩展IN”功能现在为所有后端一致支持此行为。
- en: 'As a major focus of 1.4 is to allow for true statement caching in Core and
    ORM without the awkwardness of the “baked” system, and since the “expanding IN”
    feature represents a simpler approach to building expressions in any case, it’s
    now invoked automatically whenever a list of values is passed to an IN expression:'
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
  zh: 1.4的一个主要重点是在Core和ORM中允许真正的语句缓存，而不需要“烘焙”系统的尴尬，而且由于“扩展IN”功能代表了一种更简单的构建表达式的方法，因此当传递值列表给IN表达式时，它现在会自动调用：
- en: '[PRE178]'
  id: totrans-903
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: 'The pre-execution string representation is:'
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
  zh: 预执行字符串表示为：
- en: '[PRE179]'
  id: totrans-905
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: 'To render the values directly, use `literal_binds` as was the case previously:'
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
  zh: 要直接渲染值，请像以前一样使用`literal_binds`：
- en: '[PRE180]'
  id: totrans-907
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: 'A new flag, “render_postcompile”, is added as a helper to allow the current
    bound value to be rendered as it would be passed to the database:'
  id: totrans-908
  prefs: []
  type: TYPE_NORMAL
  zh: 新增了一个名为“render_postcompile”的标志，作为一个辅助工具，允许当前绑定的值被渲染，就像传递给数据库一样：
- en: '[PRE181]'
  id: totrans-909
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: 'Engine logging output shows the ultimate rendered statement as well:'
  id: totrans-910
  prefs: []
  type: TYPE_NORMAL
  zh: 引擎日志输出也显示了最终渲染的语句：
- en: '[PRE182]'
  id: totrans-911
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: As part of this change, the behavior of “empty IN” expressions, where the list
    parameter is empty, is now standardized on use of the IN operator against a so-called
    “empty set”. As there is no standard SQL syntax for empty sets, a SELECT that
    returns no rows is used, tailored in specific ways for each backend so that the
    database treats it as an empty set; this feature was first introduced in version
    1.3 and is described at [Expanding IN feature now supports empty lists](migration_13.html#change-4271).
    The [`create_engine.empty_in_strategy`](../core/engines.html#sqlalchemy.create_engine.params.empty_in_strategy
    "sqlalchemy.create_engine") parameter, introduced in version 1.2 as a means for
    migrating for how this case was treated for the previous IN system, is now deprecated
    and this flag no longer has an effect; as described in [The IN / NOT IN operator’s
    empty collection behavior is now configurable; default expression simplified](migration_12.html#change-3907),
    this flag allowed a dialect to switch between the original system of comparing
    a column against itself, which turned out to be a huge performance issue, and
    a newer system of comparing “1 != 1” in order to produce a “false” expression.
    The 1.3 introduced behavior which now takes place in all cases is more correct
    than both approaches as the IN operator is still used, and does not have the performance
    issue of the original system.
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
  zh: 作为这一变化的一部分，“空 IN”表达式的行为，其中列表参数为空，现在标准化为使用针对所谓“空集”的 IN 运算符。由于没有标准的空集 SQL 语法，因此使用返回零行的
    SELECT，针对每个后端以特定方式定制，以便数据库将其视为空集；此功能首次在版本 1.3 中引入，并在[扩展 IN 功能现在支持空列表](migration_13.html#change-4271)中描述。在版本
    1.2 中引入的[`create_engine.empty_in_strategy`](../core/engines.html#sqlalchemy.create_engine.params.empty_in_strategy
    "sqlalchemy.create_engine")参数，作为迁移以前 IN 系统处理方式的手段，现已弃用，此标志不再起作用；如[IN / NOT IN
    运算符的空集合行为现在可配置；默认表达式简化](migration_12.html#change-3907)中所述，此标志允许方言在原始系统比较列与自身的情况下切换，这种情况被证明是一个巨大的性能问题，以及比较“1
    != 1” 以生成“false” 表达式的新系统。1.3 引入的行为现在在所有情况下都更加正确，因为仍然使用 IN 运算符，并且不具有原始系统的性能问题。
- en: In addition, the “expanding” parameter system has been generalized so that it
    also services other dialect-specific use cases where a parameter cannot be accommodated
    by the DBAPI or backing database; see [New “post compile” bound parameters used
    for LIMIT/OFFSET in Oracle, SQL Server](#change-4808) for details.
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，“扩展”参数系统已经泛化，以便为其他特定方言的用例提供服务，其中参数无法由DBAPI或后端数据库容纳；详细信息请参见[在 Oracle、SQL Server
    中用于 LIMIT/OFFSET 的新“编译后”绑定参数](#change-4808)。
- en: See also
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[New “post compile” bound parameters used for LIMIT/OFFSET in Oracle, SQL Server](#change-4808)'
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
  zh: '[在 Oracle、SQL Server 中用于 LIMIT/OFFSET 的新“编译后”绑定参数](#change-4808)'
- en: '[Expanding IN feature now supports empty lists](migration_13.html#change-4271)'
  id: totrans-916
  prefs: []
  type: TYPE_NORMAL
  zh: '[扩展 IN 功能现在支持空列表](migration_13.html#change-4271)'
- en: '[`BindParameter`](../core/sqlelement.html#sqlalchemy.sql.expression.BindParameter
    "sqlalchemy.sql.expression.BindParameter")'
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
  zh: '[`BindParameter`](../core/sqlelement.html#sqlalchemy.sql.expression.BindParameter
    "sqlalchemy.sql.expression.BindParameter")'
- en: '[#4645](https://www.sqlalchemy.org/trac/ticket/4645)  ### Built-in FROM linting
    will warn for any potential cartesian products in a SELECT statement'
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4645](https://www.sqlalchemy.org/trac/ticket/4645)  ### 内置的 FROM linting
    将警告任何 SELECT 语句中潜在的笛卡尔积'
- en: As the Core expression language as well as the ORM are built on an “implicit
    FROMs” model where a particular FROM clause is automatically added if any part
    of the query refers to it, a common issue is the case where a SELECT statement,
    either a top level statement or an embedded subquery, contains FROM elements that
    are not joined to the rest of the FROM elements in the query, causing what’s referred
    to as a “cartesian product” in the result set, i.e. every possible combination
    of rows from each FROM element not otherwise joined. In relational databases,
    this is nearly always an undesirable outcome as it produces an enormous result
    set full of duplicated, uncorrelated data.
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
  zh: 由于核心表达式语言以及 ORM 建立在“隐式 FROMs”模型上，如果查询的任何部分引用了它，那么特定的 FROM 子句将自动添加，一个常见问题是 SELECT
    语句，无论是顶级语句还是嵌套子查询，包含了未与查询中的其他 FROM 元素连接的 FROM 元素，导致结果集中出现所谓的“笛卡尔积”，即每个未连接的 FROM
    元素之间的所有可能组合的行。在关系数据库中，这几乎总是一个不希望的结果，因为它会产生一个充满重复、不相关数据的巨大结果集。
- en: 'SQLAlchemy, for all of its great features, is particularly prone to this sort
    of issue happening as a SELECT statement will have elements added to its FROM
    clause automatically from any table seen in the other clauses. A typical scenario
    looks like the following, where two tables are JOINed together, however an additional
    entry in the WHERE clause that perhaps inadvertently does not line up with these
    two tables will create an additional FROM entry:'
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管SQLAlchemy具有许多出色的功能，但特别容易发生这种问题，因为SELECT语句将自动从其他子句中看到的任何表添加到其FROM子句中。典型情况如下，其中两个表被JOIN在一起，但是WHERE子句中可能无意中与这两个表不匹配的额外条目将创建一个额外的FROM条目：
- en: '[PRE183]'
  id: totrans-921
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: 'The above query selects from a JOIN of `User` and `address_alias`, the latter
    of which is an alias of the `Address` entity. However, the `Address` entity is
    used within the WHERE clause directly, so the above would result in the SQL:'
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
  zh: 上述查询从`User`和`address_alias`的JOIN中进行选择，后者是`Address`实体的别名。然而，在WHERE子句中直接使用了`Address`实体，因此上述查询将导致以下SQL：
- en: '[PRE184]'
  id: totrans-923
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: In the above SQL, we can see what SQLAlchemy developers term “the dreaded comma”,
    as we see “FROM addresses, users JOIN addresses” in the FROM clause which is the
    classic sign of a cartesian product; where a query is making use of JOIN in order
    to join FROM clauses together, however because one of them is not joined, it uses
    a comma. The above query will return a full set of rows that join the “user” and
    “addresses” table together on the “id / user_id” column, and will then apply all
    those rows into a cartesian product against every row in the “addresses” table
    directly. That is, if there are ten user rows and 100 rows in addresses, the above
    query will return its expected result rows, likely to be 100 as all address rows
    would be selected, multiplied by 100 again, so that the total result size would
    be 10000 rows.
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述SQL中，我们可以看到SQLAlchemy开发人员所称的“可怕逗号”，因为我们在FROM子句中看到了“FROM addresses, users
    JOIN addresses”，这是笛卡尔积的经典迹象；查询正在使用JOIN来将FROM子句连接在一起，但是因为其中一个没有连接，所以使用了逗号。上述查询将返回一个完整的行集，将“user”和“addresses”表在“id
    / user_id”列上连接在一起，然后将所有这些行直接应用于“addresses”表中的每一行的笛卡尔积。也就是说，如果有十个用户行和100个地址行，上述查询将返回其预期的结果行，可能是100，因为所有地址行都将被选择，再乘以100，因此总结果大小将为10000行。
- en: The “table1, table2 JOIN table3” pattern is one that also occurs quite frequently
    within the SQLAlchemy ORM due to either subtle mis-application of ORM features
    particularly those related to joined eager loading or joined table inheritance,
    as well as a result of SQLAlchemy ORM bugs within those same systems. Similar
    issues apply to SELECT statements that use “implicit joins”, where the JOIN keyword
    is not used and instead each FROM element is linked with another one via the WHERE
    clause.
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
  zh: “table1, table2 JOIN table3”模式在SQLAlchemy ORM中也经常出现，这是由于ORM功能的微妙错误应用，特别是与连接式急加载或连接式表继承相关的功能，以及SQLAlchemy
    ORM系统中的错误造成的。类似的问题也适用于使用“隐式连接”的SELECT语句，其中不使用JOIN关键字，而是通过WHERE子句将每个FROM元素与另一个元素链接起来。
- en: For some years there has been a recipe on the Wiki that applies a graph algorithm
    to a [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select")
    construct at query execution time and inspects the structure of the query for
    these un-linked FROM clauses, parsing through the WHERE clause and all JOIN clauses
    to determine how FROM elements are linked together and ensuring that all the FROM
    elements are connected in a single graph. This recipe has now been adapted to
    be part of the [`SQLCompiler`](../core/internals.html#sqlalchemy.sql.compiler.SQLCompiler
    "sqlalchemy.sql.compiler.SQLCompiler") itself where it now optionally emits a
    warning for a statement if this condition is detected. The warning is enabled
    using the [`create_engine.enable_from_linting`](../core/engines.html#sqlalchemy.create_engine.params.enable_from_linting
    "sqlalchemy.create_engine") flag and is enabled by default. The computational
    overhead of the linter is very low, and additionally it only occurs during statement
    compilation which means for a cached SQL statement it only occurs once.
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，Wiki上有一个配方，它在查询执行时将图算法应用于[`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select")构造，并检查查询的结构以查找这些未链接的FROM子句，通过WHERE子句和所有JOIN子句解析以确定FROM元素如何链接在一起，并确保所有FROM元素在单个图中连接在一起。这个配方现在已经被调整为成为[`SQLCompiler`](../core/internals.html#sqlalchemy.sql.compiler.SQLCompiler
    "sqlalchemy.sql.compiler.SQLCompiler")的一部分，现在如果检测到这种条件，它现在可以选择性地为语句发出警告。使用[`create_engine.enable_from_linting`](../core/engines.html#sqlalchemy.create_engine.params.enable_from_linting
    "sqlalchemy.create_engine")标志启用警告，默认情况下启用。linter的计算开销非常低，而且它只在语句编译期间发生，这意味着对于缓存的SQL语句，它只会发生一次。
- en: 'Using this feature, our ORM query above will emit a warning:'
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此功能，我们上面的ORM查询将发出警告：
- en: '[PRE185]'
  id: totrans-928
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: 'The linter feature accommodates not just for tables linked together through
    the JOIN clauses but also through the WHERE clause Above, we can add a WHERE clause
    to link the new `Address` entity with the previous `address_alias` entity and
    that will remove the warning:'
  id: totrans-929
  prefs: []
  type: TYPE_NORMAL
  zh: linter功能不仅适用于通过JOIN子句链接在一起的表，还适用于通过WHERE子句链接在一起的表。上面，我们可以添加一个WHERE子句，将新的`Address`实体与先前的`address_alias`实体链接起来，这将消除警告：
- en: '[PRE186]'
  id: totrans-930
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: 'The cartesian product warning considers **any** kind of link between two FROM
    clauses to be a resolution, even if the end result set is still wasteful, as the
    linter is intended only to detect the common case of a FROM clause that is completely
    unexpected. If the FROM clause is referred to explicitly elsewhere and linked
    to the other FROMs, no warning is emitted:'
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
  zh: 笛卡尔积警告考虑**任何**两个FROM子句之间的任何链接都是一个解析，即使最终结果集仍然是低效的，因为linter仅旨在检测完全意外的FROM子句的常见情况。如果FROM子句在其他地方明确引用并链接到其他FROM子句，则不会发出警告：
- en: '[PRE187]'
  id: totrans-932
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: 'Full cartesian products are also allowed if they are explicitly stated; if
    we wanted for example the cartesian product of `User` and `Address`, we can JOIN
    on [`true()`](../core/sqlelement.html#sqlalchemy.sql.expression.true "sqlalchemy.sql.expression.true")
    so that every row will match with every other; the following query will return
    all rows and produce no warnings:'
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
  zh: 如果明确声明，也允许完整的笛卡尔积；例如，如果我们想要`User`和`Address`的笛卡尔积，我们可以在[`true()`](../core/sqlelement.html#sqlalchemy.sql.expression.true
    "sqlalchemy.sql.expression.true")上进行JOIN，以便每一行都与其他每一行匹配；以下查询将返回所有行并不会产生警告：
- en: '[PRE188]'
  id: totrans-934
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: 'The warning is only generated by default when the statement is compiled by
    the [`Connection`](../core/connections.html#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    for execution; calling the [`ClauseElement.compile()`](../core/foundation.html#sqlalchemy.sql.expression.ClauseElement.compile
    "sqlalchemy.sql.expression.ClauseElement.compile") method will not emit a warning
    unless the linting flag is supplied:'
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，只有当语句由[`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")编译以执行时才会生成警告；调用[`ClauseElement.compile()`](../core/foundation.html#sqlalchemy.sql.expression.ClauseElement.compile
    "sqlalchemy.sql.expression.ClauseElement.compile")方法不会发出警告，除非提供了linting标志：
- en: '[PRE189]'
  id: totrans-936
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: '[#4737](https://www.sqlalchemy.org/trac/ticket/4737)  ### New Result object'
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4737](https://www.sqlalchemy.org/trac/ticket/4737)  ### 新的Result对象'
- en: A major goal of SQLAlchemy 2.0 is to unify how “results” are handled between
    the ORM and Core. Towards this goal, version 1.4 introduces new versions of both
    the `ResultProxy` and `RowProxy` objects that have been part of SQLAlchemy since
    the beginning.
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 2.0的一个主要目标是统一ORM和Core之间如何处理“结果”。为实现这一目标，版本1.4引入了自SQLAlchemy成立以来一直存在的`ResultProxy`和`RowProxy`对象的新版本。
- en: The new objects are documented at [`Result`](../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") and [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row"), and are used not only for Core result sets but for [2.0
    style](../glossary.html#term-2.0-style) results within the ORM as well.
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
  zh: 这些新对象在 [`Result`](../core/connections.html#sqlalchemy.engine.Result "sqlalchemy.engine.Result")
    和 [`Row`](../core/connections.html#sqlalchemy.engine.Row "sqlalchemy.engine.Row")
    中有文档记录，并且不仅用于 Core 结果集，还用于 ORM 中的 [2.0 风格](../glossary.html#term-2.0-style) 结果。
- en: 'This result object is fully compatible with `ResultProxy` and includes many
    new features, that are now applied to both Core and ORM results equally, including
    methods such as:'
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
  zh: 这个结果对象与 `ResultProxy` 完全兼容，并包括许多新功能，现在这些功能同样适用于 Core 和 ORM 结果，包括方法：
- en: '[`Result.one()`](../core/connections.html#sqlalchemy.engine.Result.one "sqlalchemy.engine.Result.one")
    - returns exactly a single row, or raises:'
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Result.one()`](../core/connections.html#sqlalchemy.engine.Result.one "sqlalchemy.engine.Result.one")
    - 返回确切的单行，否则引发异常：'
- en: '[PRE190]'
  id: totrans-942
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: '[`Result.one_or_none()`](../core/connections.html#sqlalchemy.engine.Result.one_or_none
    "sqlalchemy.engine.Result.one_or_none") - same, but also returns None for no rows'
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Result.one_or_none()`](../core/connections.html#sqlalchemy.engine.Result.one_or_none
    "sqlalchemy.engine.Result.one_or_none") - 相同，但对于没有行的情况也返回 None'
- en: '[`Result.all()`](../core/connections.html#sqlalchemy.engine.Result.all "sqlalchemy.engine.Result.all")
    - returns all rows'
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Result.all()`](../core/connections.html#sqlalchemy.engine.Result.all "sqlalchemy.engine.Result.all")
    - 返回所有行'
- en: '[`Result.partitions()`](../core/connections.html#sqlalchemy.engine.Result.partitions
    "sqlalchemy.engine.Result.partitions") - fetches rows in chunks:'
  id: totrans-945
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Result.partitions()`](../core/connections.html#sqlalchemy.engine.Result.partitions
    "sqlalchemy.engine.Result.partitions") - 按块获取行：'
- en: '[PRE191]'
  id: totrans-946
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: '[`Result.columns()`](../core/connections.html#sqlalchemy.engine.Result.columns
    "sqlalchemy.engine.Result.columns") - allows slicing and reorganizing of rows:'
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Result.columns()`](../core/connections.html#sqlalchemy.engine.Result.columns
    "sqlalchemy.engine.Result.columns") - 允许对行进行切片和重新组织：'
- en: '[PRE192]'
  id: totrans-948
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: '[`Result.scalars()`](../core/connections.html#sqlalchemy.engine.Result.scalars
    "sqlalchemy.engine.Result.scalars") - returns lists of scalar objects, from the
    first column by default but can also be selected:'
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Result.scalars()`](../core/connections.html#sqlalchemy.engine.Result.scalars
    "sqlalchemy.engine.Result.scalars") - 返回标量对象的列表，默认情况下是从第一列开始，但也可以选择其他列：'
- en: '[PRE193]'
  id: totrans-950
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: '[`Result.mappings()`](../core/connections.html#sqlalchemy.engine.Result.mappings
    "sqlalchemy.engine.Result.mappings") - instead of named-tuple rows, returns dictionaries:'
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Result.mappings()`](../core/connections.html#sqlalchemy.engine.Result.mappings
    "sqlalchemy.engine.Result.mappings") - 返回字典而不是命名元组行：'
- en: '[PRE194]'
  id: totrans-952
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: When using Core, the object returned by [`Connection.execute()`](../core/connections.html#sqlalchemy.engine.Connection.execute
    "sqlalchemy.engine.Connection.execute") is an instance of [`CursorResult`](../core/connections.html#sqlalchemy.engine.CursorResult
    "sqlalchemy.engine.CursorResult"), which continues to feature the same API features
    as `ResultProxy` regarding inserted primary keys, defaults, rowcounts, etc. For
    ORM, a [`Result`](../core/connections.html#sqlalchemy.engine.Result "sqlalchemy.engine.Result")
    subclass will be returned that performs translation of Core rows into ORM rows,
    and then allows all the same operations to take place.
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 Core 时，[`Connection.execute()`](../core/connections.html#sqlalchemy.engine.Connection.execute
    "sqlalchemy.engine.Connection.execute") 返回的对象是 [`CursorResult`](../core/connections.html#sqlalchemy.engine.CursorResult
    "sqlalchemy.engine.CursorResult") 的一个实例，它继续具有与 `ResultProxy` 相同的 API 功能，包括插入的主键、默认值、行数等。对于
    ORM，将返回一个 [`Result`](../core/connections.html#sqlalchemy.engine.Result "sqlalchemy.engine.Result")
    的子类，它执行将 Core 行转换为 ORM 行的操作，然后允许进行所有相同的操作。
- en: See also
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[ORM Query Unified with Core Select](migration_20.html#migration-20-unify-select)
    - in the 2.0 migration documentation'
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
  zh: '[ORM 查询与 Core Select 统一](migration_20.html#migration-20-unify-select) - 在 2.0
    迁移文档中'
- en: '[#5087](https://www.sqlalchemy.org/trac/ticket/5087)'
  id: totrans-956
  prefs: []
  type: TYPE_NORMAL
  zh: '[#5087](https://www.sqlalchemy.org/trac/ticket/5087)'
- en: '[#4395](https://www.sqlalchemy.org/trac/ticket/4395)'
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4395](https://www.sqlalchemy.org/trac/ticket/4395)'
- en: '[#4959](https://www.sqlalchemy.org/trac/ticket/4959)  ### RowProxy is no longer
    a “proxy”; is now called Row and behaves like an enhanced named tuple'
  id: totrans-958
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4959](https://www.sqlalchemy.org/trac/ticket/4959)  ### RowProxy 不再是“代理”；现在称为
    Row，并且像增强型命名元组一样运行'
- en: The `RowProxy` class, which represents individual database result rows in a
    Core result set, is now called [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") and is no longer a “proxy” object; what this means is
    that when the [`Row`](../core/connections.html#sqlalchemy.engine.Row "sqlalchemy.engine.Row")
    object is returned, the row is a simple tuple that contains the data in its final
    form, already having been processed by result-row handling functions associated
    with datatypes (examples include turning a date string from the database into
    a `datetime` object, a JSON string into a Python `json.loads()` result, etc.).
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
  zh: '`RowProxy`类，代表Core结果集中的单个数据库结果行，现在被称为[`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row")，不再是一个“代理”对象；这意味着当返回[`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row")对象时，该行是一个简单的元组，其中包含数据的最终形式，已经通过与数据类型相关的结果行处理函数处理过（例如将数据库中的日期字符串转换为`datetime`对象，将JSON字符串转换为Python的`json.loads()`结果等）。'
- en: The immediate rationale for this is so that the row can act more like a Python
    named tuple, rather than a mapping, where the values in the tuple are the subject
    of the `__contains__` operator on the tuple, rather than the keys. With [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") acting like a named tuple, it is then suitable for use
    as as replacement for the ORM’s `KeyedTuple` object, leading to an eventual API
    where both the ORM and Core deliver result sets that behave identically. Unification
    of major patterns within ORM and Core is a major goal of SQLAlchemy 2.0, and release
    1.4 aims to have most or all of the underlying architectural patterns in place
    in order to support this process. The note in [The “KeyedTuple” object returned
    by Query is replaced by Row](#change-4710-orm) describes the ORM’s use of the
    [`Row`](../core/connections.html#sqlalchemy.engine.Row "sqlalchemy.engine.Row")
    class.
  id: totrans-960
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的直接原因是为了使行更像Python的命名元组，而不是映射，元组中的值是元组上的`__contains__`运算符的主题，而不是键。当[`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row")像命名元组一样工作时，它就适合用作ORM的`KeyedTuple`对象的替代品，从而导致最终API中ORM和Core提供的结果集行为相同。统一ORM和Core中的主要模式是SQLAlchemy
    2.0的主要目标，版本1.4旨在在支持此过程的基础架构模式中放置大多数或所有的基础架构模式。[Query返回的“KeyedTuple”对象被Row替换](#change-4710-orm)中的注释描述了ORM对[`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row")类的使用。
- en: For release 1.4, the [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") class provides an additional subclass `LegacyRow`, which
    is used by Core and provides a backwards-compatible version of `RowProxy` while
    emitting deprecation warnings for those API features and behaviors that will be
    moved. ORM [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    now makes use of [`Row`](../core/connections.html#sqlalchemy.engine.Row "sqlalchemy.engine.Row")
    directly as a replacement for `KeyedTuple`.
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
  zh: 对于版本1.4，[`Row`](../core/connections.html#sqlalchemy.engine.Row "sqlalchemy.engine.Row")类提供了一个额外的子类`LegacyRow`，它被Core使用，并提供了`RowProxy`的向后兼容版本，同时对那些将被移动的API功能和行为发出弃用警告。ORM
    [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")现在直接使用[`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row")作为`KeyedTuple`的替代品。
- en: The `LegacyRow` class is a transitional class where the `__contains__` method
    is still testing against the keys, not the values, while emitting a deprecation
    warning when the operation succeeds. Additionally, all the other mapping-like
    methods on the previous `RowProxy` are deprecated, including `LegacyRow.keys()`,
    `LegacyRow.items()`, etc. For mapping-like behaviors from a [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") object, including support for these methods as well as
    a key-oriented `__contains__` operator, the API going forward will be to first
    access a special attribute [`Row._mapping`](../core/connections.html#sqlalchemy.engine.Row._mapping
    "sqlalchemy.engine.Row._mapping"), which will then provide a complete mapping
    interface to the row, rather than a tuple interface.
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
  zh: '`LegacyRow`类是一个过渡类，其中`__contains__`方法仍然针对键进行测试，而不是值，当操作成功时发出弃用警告。此外，先前的`RowProxy`上的所有其他类似映射的方法也已弃用，包括`LegacyRow.keys()`，`LegacyRow.items()`等。对于从[`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row")对象获得类似映射的行为，包括支持这些方法以及面向键的`__contains__`运算符，未来的API将首先访问一个特殊属性[`Row._mapping`](../core/connections.html#sqlalchemy.engine.Row._mapping
    "sqlalchemy.engine.Row._mapping")，然后提供完整的映射接口给行，而不是元组接口。'
- en: 'Rationale: To behave more like a named tuple rather than a mapping'
  id: totrans-963
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 理由：为了更像一个命名元组而不是一个映射
- en: 'The difference between a named tuple and a mapping as far as boolean operators
    can be summarized. Given a “named tuple” in pseudo code as:'
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
  zh: 就布尔运算符而言，命名元组和映射之间的差异可以总结为：给定伪代码中的“命名元组”：
- en: '[PRE195]'
  id: totrans-965
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: 'The biggest cross-incompatible difference is the behavior of `__contains__`:'
  id: totrans-966
  prefs: []
  type: TYPE_NORMAL
  zh: 最大的跨不兼容差异是 `__contains__` 的行为：
- en: '[PRE196]'
  id: totrans-967
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: 'In 1.4, when a `LegacyRow` is returned by a Core result set, the above `"id"
    in row` comparison will continue to succeed, however a deprecation warning will
    be emitted. To use the “in” operator as a mapping, use the [`Row._mapping`](../core/connections.html#sqlalchemy.engine.Row._mapping
    "sqlalchemy.engine.Row._mapping") attribute:'
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
  zh: 在 1.4 中，当核心结果集返回一个 `LegacyRow` 时，上述 `"id" in row` 比较将继续成功，但是会发出弃用警告。要将“in”运算符用作映射，请使用
    [`Row._mapping`](../core/connections.html#sqlalchemy.engine.Row._mapping "sqlalchemy.engine.Row._mapping")
    属性：
- en: '[PRE197]'
  id: totrans-969
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: 'SQLAlchemy 2.0’s result object will feature a `.mappings()` modifier so that
    these mappings can be received directly:'
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 2.0 的结果对象将具有 `.mappings()` 修改器，以便可以直接接收这些映射：
- en: '[PRE198]'
  id: totrans-971
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: Proxying behavior goes away, was also unnecessary in modern usage
  id: totrans-972
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 代理行为消失了，在现代用法中也是不必要的
- en: 'The refactor of [`Row`](../core/connections.html#sqlalchemy.engine.Row "sqlalchemy.engine.Row")
    to behave like a tuple requires that all data values be fully available up front.
    This is an internal behavior change from that of `RowProxy`, where result-row
    processing functions would be invoked at the point of accessing an element of
    the row, instead of when the row was first fetched. This means for example when
    retrieving a datetime value from SQLite, the data for the row as present in the
    `RowProxy` object would previously have looked like:'
  id: totrans-973
  prefs: []
  type: TYPE_NORMAL
  zh: 将 [`Row`](../core/connections.html#sqlalchemy.engine.Row "sqlalchemy.engine.Row")
    重构为行为类似于元组需要所有数据值一开始就完全可用。这是从 `RowProxy` 的内部行为更改而来，其中结果行处理函数将在访问行元素时调用，而不是在首次提取行时调用。这意味着例如从
    SQLite 检索 datetime 值时，`RowProxy` 对象中的行数据先前看起来是这样的：
- en: '[PRE199]'
  id: totrans-974
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: 'and then upon access via `__getitem__`, the `datetime.strptime()` function
    would be used on the fly to convert the above string date into a `datetime` object.
    With the new architecture, the `datetime()` object is present in the tuple when
    it is returned, the `datetime.strptime()` function having been called just once
    up front:'
  id: totrans-975
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在通过 `__getitem__` 访问时，`datetime.strptime()` 函数将在使用时动态将上述字符串日期转换为 `datetime`
    对象。有了新的架构，`datetime()` 对象在返回元组时就已经存在，`datetime.strptime()` 函数只需在一开始调用一次：
- en: '[PRE200]'
  id: totrans-976
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: The `RowProxy` and [`Row`](../core/connections.html#sqlalchemy.engine.Row "sqlalchemy.engine.Row")
    objects in SQLAlchemy are where the majority of SQLAlchemy’s C extension code
    takes place. This code has been highly refactored to provide the new behavior
    in an efficient manner, and overall performance has been improved as the design
    of [`Row`](../core/connections.html#sqlalchemy.engine.Row "sqlalchemy.engine.Row")
    is now considerably simpler.
  id: totrans-977
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 中的 `RowProxy` 和 [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") 对象是 SQLAlchemy 大部分 C 扩展代码的位置。该代码已经进行了大量重构，以高效的方式提供新行为，并且整体性能已经得到了提高，因为
    [`Row`](../core/connections.html#sqlalchemy.engine.Row "sqlalchemy.engine.Row")
    的设计现在相对简单。
- en: The rationale behind the previous behavior assumed a usage model where a result
    row might have dozens or hundreds of columns present, where most of those columns
    would not be accessed, and for which a majority of those columns would require
    some result-value processing function. By invoking the processing function only
    when needed, the goal was that lots of result processing functions would not be
    necessary, thus increasing performance.
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
  zh: 先前行为的基本原理假设一个使用模型，其中一个结果行可能具有几十或几百列，其中大多数列不会被访问，并且其中大多数列需要一些结果值处理函数。通过仅在需要时调用处理函数，目标是不需要大量的结果处理函数，从而增加性能。
- en: 'There are many reasons why the above assumptions do not hold:'
  id: totrans-979
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多原因说明上述假设不成立：
- en: the vast majority of row-processing functions called were to Unicode decode
    a bytestring into a Python Unicode string under Python 2\. This was right as Python
    Unicode was beginning to see use and before Python 3 existed. Once Python 3 was
    introduced, within a few years, all Python DBAPIs took on the proper role of supporting
    the delivering of Python Unicode objects directly, under both Python 2 and Python
    3, as an option in the former case and as the only way forward in the latter case.
    Eventually, in most cases it became the default for Python 2 as well. SQLAlchemy’s
    Python 2 support still enables explicit string-to-Unicode conversion for some
    DBAPIs such as cx_Oracle, however it is now performed at the DBAPI level rather
    than as a standard SQLAlchemy result row processing function.
  id: totrans-980
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 大多数调用的行处理函数是将字节串解码为Python Unicode字符串，这是在Python 2下开始使用Python Unicode并在Python
    3出现之前的情况。一旦引入了Python 3，在几年内，所有Python DBAPI都承担了支持直接传递Python Unicode对象的正确角色，在Python
    2和Python 3下，前者是一个选项，后者是唯一的前进方式。最终，在大多数情况下，它也成为Python 2的默认选项。SQLAlchemy的Python
    2支持仍然允许为一些DBAPI（如cx_Oracle）执行显式的字符串到Unicode转换，但现在是在DBAPI级别执行，而不是作为标准的SQLAlchemy结果行处理函数。
- en: The above string conversion, when it is used, was made to be extremely performant
    via the C extensions, so much so that even in 1.4, SQLAlchemy’s byte-to-Unicode
    codec hook is plugged into cx_Oracle where it has been observed to be more performant
    than cx_Oracle’s own hook; this meant that the overhead for converting all strings
    in a row was not as significant as it originally was in any case.
  id: totrans-981
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上述字符串转换在使用时通过C扩展被设计得非常高效，以至于即使在1.4版本中，SQLAlchemy的字节到Unicode编解码器挂接到了cx_Oracle中，据观察，它比cx_Oracle自己的挂接更高效；这意味着在任何情况下，将所有字符串转换为Unicode字符串的开销不再像最初那样显著。
- en: Row processing functions are not used in most other cases; the exceptions are
    SQLite’s datetime support, JSON support for some backends, some numeric handlers
    such as string to `Decimal`. In the case of `Decimal`, Python 3 also standardized
    on the highly performant `cdecimal` implementation, which is not the case in Python
    2 which continues to use the much less performant pure Python version.
  id: totrans-982
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 大多数情况下不使用行处理函数；例外情况包括SQLite的日期时间支持，某些后端的JSON支持，一些数值处理程序，如字符串转换为`Decimal`。在`Decimal`的情况下，Python
    3也标准化了高性能的`cdecimal`实现，而在Python 2中并非如此，Python 2仍然使用性能较低的纯Python版本。
- en: Fetching full rows where only a few columns are needed is not common within
    real-world use cases In the early days of SQLAlchemy, database code from other
    languages of the form “row = fetch(‘SELECT * FROM table’)” was common; using SQLAlchemy’s
    expression language however, code observed in the wild typically makes use of
    the specific columns needed.
  id: totrans-983
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在实际用例中，很少有需要获取完整行而只需要少数列的情况。在SQLAlchemy的早期，来自其他语言的数据库代码形式“row = fetch(‘SELECT
    * FROM table’)”很常见；然而，使用SQLAlchemy的表达式语言，实际观察到的代码通常使用所需的特定列。
- en: See also
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[The “KeyedTuple” object returned by Query is replaced by Row](#change-4710-orm)'
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
  zh: '[Query返回的“KeyedTuple”对象被Row替换](#change-4710-orm)'
- en: '[ORM Session.execute() uses “future” style Result sets in all cases](#change-session-execute-result)'
  id: totrans-986
  prefs: []
  type: TYPE_NORMAL
  zh: '[ORM Session.execute() uses “future” style Result sets in all cases](#change-session-execute-result)'
- en: '[#4710](https://www.sqlalchemy.org/trac/ticket/4710)  ### SELECT objects and
    derived FROM clauses allow for duplicate columns and column labels'
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4710](https://www.sqlalchemy.org/trac/ticket/4710)  ### SELECT对象和派生的FROM子句允许重复列和列标签'
- en: 'This change allows that the [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") construct now allows for duplicate column
    labels as well as duplicate column objects themselves, so that result tuples are
    organized and ordered in the identical way in that the columns were selected.
    The ORM [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    already works this way, so this change allows for greater cross-compatibility
    between the two, which is a key goal of the 2.0 transition:'
  id: totrans-988
  prefs: []
  type: TYPE_NORMAL
  zh: 此更改允许[`select()`](../core/selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select")构造现在允许重复的列标签以及重复的列对象本身，以便结果元组以与选择列相同的方式组织和排序。ORM
    [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")已经按照这种方式工作，因此这个更改允许两者之间更大的交叉兼容性，这是2.0过渡的一个关键目标：
- en: '[PRE201]'
  id: totrans-989
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: 'To support this change, the [`ColumnCollection`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnCollection
    "sqlalchemy.sql.expression.ColumnCollection") used by [`SelectBase`](../core/selectable.html#sqlalchemy.sql.expression.SelectBase
    "sqlalchemy.sql.expression.SelectBase") as well as for derived FROM clauses such
    as subqueries also support duplicate columns; this includes the new [`SelectBase.selected_columns`](../core/selectable.html#sqlalchemy.sql.expression.SelectBase.selected_columns
    "sqlalchemy.sql.expression.SelectBase.selected_columns") attribute, the deprecated
    `SelectBase.c` attribute, as well as the [`FromClause.c`](../core/selectable.html#sqlalchemy.sql.expression.FromClause.c
    "sqlalchemy.sql.expression.FromClause.c") attribute seen on constructs such as
    [`Subquery`](../core/selectable.html#sqlalchemy.sql.expression.Subquery "sqlalchemy.sql.expression.Subquery")
    and [`Alias`](../core/selectable.html#sqlalchemy.sql.expression.Alias "sqlalchemy.sql.expression.Alias"):'
  id: totrans-990
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持这一变化，[`SelectBase`](../core/selectable.html#sqlalchemy.sql.expression.SelectBase
    "sqlalchemy.sql.expression.SelectBase")使用的[`ColumnCollection`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnCollection
    "sqlalchemy.sql.expression.ColumnCollection")以及派生的FROM子句（如子查询）也支持重复列；这包括新的[`SelectBase.selected_columns`](../core/selectable.html#sqlalchemy.sql.expression.SelectBase.selected_columns
    "sqlalchemy.sql.expression.SelectBase.selected_columns")属性，已弃用的`SelectBase.c`属性，以及在诸如[`Subquery`](../core/selectable.html#sqlalchemy.sql.expression.Subquery
    "sqlalchemy.sql.expression.Subquery")和[`Alias`](../core/selectable.html#sqlalchemy.sql.expression.Alias
    "sqlalchemy.sql.expression.Alias")等构造中看到的[`FromClause.c`](../core/selectable.html#sqlalchemy.sql.expression.FromClause.c
    "sqlalchemy.sql.expression.FromClause.c")属性：
- en: '[PRE202]'
  id: totrans-991
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: '[`ColumnCollection`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnCollection
    "sqlalchemy.sql.expression.ColumnCollection") also allows access by integer index
    to support when the string “key” is ambiguous:'
  id: totrans-992
  prefs: []
  type: TYPE_NORMAL
  zh: '[`ColumnCollection`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnCollection
    "sqlalchemy.sql.expression.ColumnCollection")还允许通过整数索引访问，以支持当字符串“键”不明确时：'
- en: '[PRE203]'
  id: totrans-993
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: To suit the use of [`ColumnCollection`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnCollection
    "sqlalchemy.sql.expression.ColumnCollection") in objects such as [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") and [`PrimaryKeyConstraint`](../core/constraints.html#sqlalchemy.schema.PrimaryKeyConstraint
    "sqlalchemy.schema.PrimaryKeyConstraint"), the old “deduplicating” behavior which
    is more critical for these objects is preserved in a new class `DedupeColumnCollection`.
  id: totrans-994
  prefs: []
  type: TYPE_NORMAL
  zh: 为了适应[`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")和[`PrimaryKeyConstraint`](../core/constraints.html#sqlalchemy.schema.PrimaryKeyConstraint
    "sqlalchemy.schema.PrimaryKeyConstraint")等对象中对[`ColumnCollection`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnCollection
    "sqlalchemy.sql.expression.ColumnCollection")的使用，保留了更适用于这些对象的旧的“去重”行为，这一行为在新的`DedupeColumnCollection`类中得以保留。
- en: 'The change includes that the familiar warning `"Column %r on table %r being
    replaced by %r, which has the same key.  Consider use_labels for select() statements."`
    is **removed**; the `Select.apply_labels()` is still available and is still used
    by the ORM for all SELECT operations, however it does not imply deduplication
    of column objects, although it does imply deduplication of implicitly generated
    labels:'
  id: totrans-995
  prefs: []
  type: TYPE_NORMAL
  zh: 这一变化包括移除了熟悉的警告`“表%r上的列%r被%r替换，具有相同的键。考虑为select()语句使用use_labels。”`；`Select.apply_labels()`仍然可用，并且仍然被ORM用于所有SELECT操作，但它不意味着对列对象进行去重，尽管它确实意味着对隐式生成的标签进行去重：
- en: '[PRE204]'
  id: totrans-996
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: 'Finally, the change makes it easier to create UNION and other `_selectable.CompoundSelect`
    objects, by ensuring that the number and position of columns in a SELECT statement
    mirrors what was given, in a use case such as:'
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这一变化使得更容易创建UNION和其他`_selectable.CompoundSelect`对象，通过确保SELECT语句中的列数和位置与给定的相符，例如：
- en: '[PRE205]'
  id: totrans-998
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: '[#4753](https://www.sqlalchemy.org/trac/ticket/4753)  ### Improved column labeling
    for simple column expressions using CAST or similar'
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4753](https://www.sqlalchemy.org/trac/ticket/4753)  ### 使用CAST或类似方法改进简单列表达式的列标签'
- en: 'A user pointed out that the PostgreSQL database has a convenient behavior when
    using functions like CAST against a named column, in that the result column name
    is named the same as the inner expression:'
  id: totrans-1000
  prefs: []
  type: TYPE_NORMAL
  zh: 一位用户指出，PostgreSQL数据库在使用诸如CAST之类的函数针对命名列时具有方便的行为，即结果列名与内部表达式同名：
- en: '[PRE206]'
  id: totrans-1001
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: 'This allows one to apply CAST to table columns while not losing the column
    name (above using the name `"data"`) in the result row. Compare to databases such
    as MySQL/MariaDB, as well as most others, where the column name is taken from
    the full SQL expression and is not very portable:'
  id: totrans-1002
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得可以对表列应用CAST而不会丢失结果行中的列名（上面使用名称`“data”`）。与MySQL/MariaDB等大多数其他数据库不同，这些数据库的列名取自完整的SQL表达式，不太具有可移植性：
- en: '[PRE207]'
  id: totrans-1003
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: 'In SQLAlchemy Core expressions, we never deal with a raw generated name like
    the above, as SQLAlchemy applies auto-labeling to expressions like these, which
    are up until now always a so-called “anonymous” expression:'
  id: totrans-1004
  prefs: []
  type: TYPE_NORMAL
  zh: 在SQLAlchemy Core表达式中，我们从不处理像上面那样的原始生成名称，因为SQLAlchemy对这些表达式应用自动标记，这些表达式直到现在始终是所谓的“匿名”表达式：
- en: '[PRE208]'
  id: totrans-1005
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: 'These anonymous expressions were necessary as SQLAlchemy’s `ResultProxy` made
    heavy use of result column names in order to match up datatypes, such as the [`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String") datatype which used to have result-row-processing behavior,
    to the correct column, so most importantly the names had to be both easy to determine
    in a database-agnostic manner as well as unique in all cases. In SQLAlchemy 1.0
    as part of [#918](https://www.sqlalchemy.org/trac/ticket/918), this reliance on
    named columns in result rows (specifically the `cursor.description` element of
    the PEP-249 cursor) was scaled back to not be necessary for most Core SELECT constructs;
    in release 1.4, the system overall is becoming more comfortable with SELECT statements
    that have duplicate column or label names such as in [SELECT objects and derived
    FROM clauses allow for duplicate columns and column labels](#change-4753). So
    we now emulate PostgreSQL’s reasonable behavior for simple modifications to a
    single column, most prominently with CAST:'
  id: totrans-1006
  prefs: []
  type: TYPE_NORMAL
  zh: 这些匿名表达式是必要的，因为SQLAlchemy的`ResultProxy`大量使用结果列名称来匹配数据类型，例如[`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String")数据类型曾经具有结果行处理行为，以正确匹配列，因此最重要的是这些名称必须易于以与数据库无关的方式确定，并且在所有情况下都是唯一的。在SQLAlchemy
    1.0中作为[#918](https://www.sqlalchemy.org/trac/ticket/918)的一部分，对于大多数Core SELECT构造，不再需要依赖结果行中的命名列（特别是PEP-249游标的`cursor.description`元素）；在1.4版本中，整个系统对于具有重复列或标签名称的SELECT语句变得更加舒适，例如在[SELECT对象和派生FROM子句允许重复列和列标签](#change-4753)中。因此，我们现在模拟PostgreSQL对于对单个列进行简单修改的合理行为，最显著的是使用CAST：
- en: '[PRE209]'
  id: totrans-1007
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: 'For CAST against expressions that don’t have a name, the previous logic is
    used to generate the usual “anonymous” labels:'
  id: totrans-1008
  prefs: []
  type: TYPE_NORMAL
  zh: 对于没有名称的表达式进行CAST，先前的逻辑用于生成通常的“匿名”标签：
- en: '[PRE210]'
  id: totrans-1009
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: 'A [`cast()`](../core/sqlelement.html#sqlalchemy.sql.expression.cast "sqlalchemy.sql.expression.cast")
    against a [`Label`](../core/sqlelement.html#sqlalchemy.sql.expression.Label "sqlalchemy.sql.expression.Label"),
    despite having to omit the label expression as these don’t render inside of a
    CAST, will nonetheless make use of the given name:'
  id: totrans-1010
  prefs: []
  type: TYPE_NORMAL
  zh: 对于针对[`Label`](../core/sqlelement.html#sqlalchemy.sql.expression.Label "sqlalchemy.sql.expression.Label")的[`cast()`](../core/sqlelement.html#sqlalchemy.sql.expression.cast
    "sqlalchemy.sql.expression.cast")，尽管必须省略标签表达式，因为这些表达式不会在CAST内部呈现，但仍将使用给定的名称：
- en: '[PRE211]'
  id: totrans-1011
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: 'And of course as was always the case, [`Label`](../core/sqlelement.html#sqlalchemy.sql.expression.Label
    "sqlalchemy.sql.expression.Label") can be applied to the expression on the outside
    to apply an “AS <name>” label directly:'
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，正如往常一样，[`Label`](../core/sqlelement.html#sqlalchemy.sql.expression.Label
    "sqlalchemy.sql.expression.Label") 可以应用于外部表达式，直接应用“AS <name>”标签：
- en: '[PRE212]'
  id: totrans-1013
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: '[#4449](https://www.sqlalchemy.org/trac/ticket/4449)  ### New “post compile”
    bound parameters used for LIMIT/OFFSET in Oracle, SQL Server'
  id: totrans-1014
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4449](https://www.sqlalchemy.org/trac/ticket/4449)  ### 用于Oracle、SQL Server中LIMIT/OFFSET的新“编译后”绑定参数'
- en: A major goal of the 1.4 series is to establish that all Core SQL constructs
    are completely cacheable, meaning that a particular [`Compiled`](../core/internals.html#sqlalchemy.engine.Compiled
    "sqlalchemy.engine.Compiled") structure will produce an identical SQL string regardless
    of any SQL parameters used with it, which notably includes those used to specify
    the LIMIT and OFFSET values, typically used for pagination and “top N” style results.
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
  zh: 1.4系列的一个主要目标是确保所有Core SQL构造完全可缓存，这意味着特定的[`Compiled`](../core/internals.html#sqlalchemy.engine.Compiled
    "sqlalchemy.engine.Compiled")结构将生成相同的SQL字符串，而不管与之一起使用的任何SQL参数，其中特别包括用于指定LIMIT和OFFSET值的参数，通常用于分页和“top
    N”样式的结果。
- en: 'While SQLAlchemy has used bound parameters for LIMIT/OFFSET schemes for many
    years, a few outliers remained where such parameters were not allowed, including
    a SQL Server “TOP N” statement, such as:'
  id: totrans-1016
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然SQLAlchemy多年来一直使用绑定参数来实现LIMIT/OFFSET方案，但仍有一些特例，其中不允许使用这些参数，包括SQL Server的“TOP
    N”语句，例如：
- en: '[PRE213]'
  id: totrans-1017
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: 'as well as with Oracle, where the FIRST_ROWS() hint (which SQLAlchemy will
    use if the `optimize_limits=True` parameter is passed to [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") with an Oracle URL) does not allow them, but also
    that using bound parameters with ROWNUM comparisons has been reported as producing
    slower query plans:'
  id: totrans-1018
  prefs: []
  type: TYPE_NORMAL
  zh: 以及在Oracle中，如果向[`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine")传递了`optimize_limits=True`参数并使用Oracle URL，那么FIRST_ROWS()提示（SQLAlchemy将使用该提示）将不允许它们，但是使用绑定参数与ROWNUM比较已被报告为产生较慢的查询计划：
- en: '[PRE214]'
  id: totrans-1019
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: 'In order to allow for all statements to be unconditionally cacheable at the
    compilation level, a new form of bound parameter called a “post compile” parameter
    has been added, which makes use of the same mechanism as that of “expanding IN
    parameters”. This is a [`bindparam()`](../core/sqlelement.html#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam") that behaves identically to any other bound
    parameter except that parameter value will be rendered literally into the SQL
    string before sending it to the DBAPI `cursor.execute()` method. The new parameter
    is used internally by the SQL Server and Oracle dialects, so that the drivers
    receive the literal rendered value but the rest of SQLAlchemy can still consider
    this as a bound parameter. The above two statements when stringified using `str(statement.compile(dialect=<dialect>))`
    now look like:'
  id: totrans-1020
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使所有语句在编译级别无条件可缓存，添加了一种新形式的绑定参数，称为“后编译”参数，它利用了与“扩展IN参数”相同的机制。这是一个[`bindparam()`](../core/sqlelement.html#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam")，其行为与任何其他绑定参数完全相同，只是参数值将在发送到DBAPI `cursor.execute()`方法之前被直接呈现到SQL字符串中。新参数在SQL
    Server和Oracle方言内部使用，以便驱动程序接收到字面呈现的值，但SQLAlchemy的其余部分仍然可以将其视为绑定参数。现在，使用`str(statement.compile(dialect=<dialect>))`将上述两个语句字符串化后看起来如下：
- en: '[PRE215]'
  id: totrans-1021
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: 'and:'
  id: totrans-1022
  prefs: []
  type: TYPE_NORMAL
  zh: 和：
- en: '[PRE216]'
  id: totrans-1023
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: The `[POSTCOMPILE_<param>]` format is also what is seen when an “expanding IN”
    is used.
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用“扩展IN”时，也会看到`[POSTCOMPILE_<param>]`格式。
- en: 'When viewing the SQL logging output, the final form of the statement will be
    seen:'
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
  zh: 查看SQL日志输出时，将看到语句的最终形式：
- en: '[PRE217]'
  id: totrans-1026
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: The “post compile parameter” feature is exposed as public API through the [`bindparam.literal_execute`](../core/sqlelement.html#sqlalchemy.sql.expression.bindparam.params.literal_execute
    "sqlalchemy.sql.expression.bindparam") parameter, however is currently not intended
    for general use. The literal values are rendered using the [`TypeEngine.literal_processor()`](../core/type_api.html#sqlalchemy.types.TypeEngine.literal_processor
    "sqlalchemy.types.TypeEngine.literal_processor") of the underlying datatype, which
    in SQLAlchemy has **extremely limited** scope, supporting only integers and simple
    string values.
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
  zh: “后编译参数”功能通过[`bindparam.literal_execute`](../core/sqlelement.html#sqlalchemy.sql.expression.bindparam.params.literal_execute
    "sqlalchemy.sql.expression.bindparam")参数作为公共API公开，但目前不打算供一般使用。在SQLAlchemy中，字面值使用底层数据类型的[`TypeEngine.literal_processor()`](../core/type_api.html#sqlalchemy.types.TypeEngine.literal_processor
    "sqlalchemy.types.TypeEngine.literal_processor")进行呈现，其范围**极其有限**，仅支持整数和简单字符串值。
- en: '[#4808](https://www.sqlalchemy.org/trac/ticket/4808)  ### Connection-level
    transactions can now be inactive based on subtransaction'
  id: totrans-1028
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4808](https://www.sqlalchemy.org/trac/ticket/4808)  ### 连接级事务现在可以基于子事务处于非活动状态'
- en: A [`Connection`](../core/connections.html#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    now includes the behavior where a [`Transaction`](../core/connections.html#sqlalchemy.engine.Transaction
    "sqlalchemy.engine.Transaction") can be made inactive due to a rollback on an
    inner transaction, however the [`Transaction`](../core/connections.html#sqlalchemy.engine.Transaction
    "sqlalchemy.engine.Transaction") will not clear until it is itself rolled back.
  id: totrans-1029
  prefs: []
  type: TYPE_NORMAL
  zh: 一个[`Connection`](../core/connections.html#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")现在包括了一个行为，即由于内部事务的回滚而使得[`Transaction`](../core/connections.html#sqlalchemy.engine.Transaction
    "sqlalchemy.engine.Transaction")变为非活动状态，但是[`Transaction`](../core/connections.html#sqlalchemy.engine.Transaction
    "sqlalchemy.engine.Transaction")直到自身被回滚之前都不会清除。
- en: This is essentially a new error condition which will disallow statement executions
    to proceed on a [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") if an inner “sub” transaction has been rolled
    back. The behavior works very similarly to that of the ORM [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), where if an outer transaction has been begun, it needs
    to be rolled back to clear the invalid transaction; this behavior is described
    in [“This Session’s transaction has been rolled back due to a previous exception
    during flush.” (or similar)](../faq/sessions.html#faq-session-rollback).
  id: totrans-1030
  prefs: []
  type: TYPE_NORMAL
  zh: 这本质上是一个新的错误条件，如果内部“子”事务已被回滚，则将禁止语句执行继续在[`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")上进行。该行为与ORM [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")的行为非常相似，如果已开始外部事务，则需要将其回滚以清除无效事务；此行为在[“由于刷新期间的先前异常，此会话的事务已被回滚。”（或类似）](../faq/sessions.html#faq-session-rollback)中有描述。
- en: While the [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") has had a less strict behavioral pattern than
    the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session"),
    this change was made as it helps to identify when a subtransaction has rolled
    back the DBAPI transaction, however the external code isn’t aware of this and
    attempts to continue proceeding, which in fact runs operations on a new transaction.
    The “test harness” pattern described at [Joining a Session into an External Transaction
    (such as for test suites)](../orm/session_transaction.html#session-external-transaction)
    is the common place for this to occur.
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然[`Connection`](../core/connections.html#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")的行为模式比[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")更宽松，但由于它有助于识别子事务已回滚DBAPI事务，但外部代码不知道这一点并尝试继续进行，实际上在新事务上运行操作，因此进行了此更改。在[将会话加入外部事务（例如用于测试套件）](../orm/session_transaction.html#session-external-transaction)中描述的“测试工具”模式是发生这种情况的常见地方。
- en: The “subtransaction” feature of Core and ORM is itself deprecated and will no
    longer be present in version 2.0\. As a result, this new error condition is itself
    temporary as it will no longer apply once subtransactions are removed.
  id: totrans-1032
  prefs: []
  type: TYPE_NORMAL
  zh: Core和ORM的“子事务”功能本身已被弃用，并将不再出现在2.0版本中。因此，这种新的错误条件本身是临时的，一旦子事务被移除，它将不再适用。
- en: In order to work with the 2.0 style behavior that does not include subtransactions,
    use the [`create_engine.future`](../core/engines.html#sqlalchemy.create_engine.params.future
    "sqlalchemy.create_engine") parameter on [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine").
  id: totrans-1033
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与不包括子事务的2.0风格行为一起工作，请在[`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine")上使用[`create_engine.future`](../core/engines.html#sqlalchemy.create_engine.params.future
    "sqlalchemy.create_engine")参数。
- en: 'The error message is described in the errors page at [This connection is on
    an inactive transaction. Please rollback() fully before proceeding](../errors.html#error-8s2a).  ###
    Enum and Boolean datatypes no longer default to “create constraint”'
  id: totrans-1034
  prefs: []
  type: TYPE_NORMAL
  zh: '错误消息在错误页面中描述为[此连接处于非活动事务状态。请在继续之前完全回滚()](../errors.html#error-8s2a)。  ### 枚举和布尔数据类型不再默认为“创建约束”'
- en: The [`Enum.create_constraint`](../core/type_basics.html#sqlalchemy.types.Enum.params.create_constraint
    "sqlalchemy.types.Enum") and [`Boolean.create_constraint`](../core/type_basics.html#sqlalchemy.types.Boolean.params.create_constraint
    "sqlalchemy.types.Boolean") parameters now default to False, indicating when a
    so-called “non-native” version of these two datatypes is created, a CHECK constraint
    will **not** be generated by default. These CHECK constraints present schema-management
    maintenance complexities that should be opted in to, rather than being turned
    on by default.
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Enum.create_constraint`](../core/type_basics.html#sqlalchemy.types.Enum.params.create_constraint
    "sqlalchemy.types.Enum")和[`Boolean.create_constraint`](../core/type_basics.html#sqlalchemy.types.Boolean.params.create_constraint
    "sqlalchemy.types.Boolean")参数现在默认为False，表示当创建这两种数据类型的所谓“非本地”版本时，默认情况下不会生成CHECK约束。这些CHECK约束会带来应该选择的模式管理维护复杂性，而不是默认打开。'
- en: 'To ensure that a CREATE CONSTRAINT is emitted for these types, set these flags
    to `True`:'
  id: totrans-1036
  prefs: []
  type: TYPE_NORMAL
  zh: 要确保为这些类型发出CREATE CONSTRAINT，请将这些标志设置为`True`：
- en: '[PRE218]'
  id: totrans-1037
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: '[#5367](https://www.sqlalchemy.org/trac/ticket/5367)  ### A SELECT statement
    is no longer implicitly considered to be a FROM clause'
  id: totrans-1038
  prefs: []
  type: TYPE_NORMAL
  zh: '[#5367](https://www.sqlalchemy.org/trac/ticket/5367)  ### SELECT语句不再被隐式视为FROM子句'
- en: This change is one of the larger conceptual changes in SQLAlchemy in many years,
    however it is hoped that the end user impact is relatively small, as the change
    more closely matches what databases like MySQL and PostgreSQL require in any case.
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
  zh: 这个变化是 SQLAlchemy 多年来的一个较大的概念性变化之一，但希望最终用户的影响相对较小，因为这个变化更接近于 MySQL 和 PostgreSQL
    等数据库所要求的情况。
- en: The most immediate noticeable impact is that a [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") can no longer be embedded inside of another
    [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select")
    directly, without explicitly turning the inner [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") into a subquery first. This is historically
    performed by using the [`SelectBase.alias()`](../core/selectable.html#sqlalchemy.sql.expression.SelectBase.alias
    "sqlalchemy.sql.expression.SelectBase.alias") method, which remains, however is
    more explicitly suited by using a new method [`SelectBase.subquery()`](../core/selectable.html#sqlalchemy.sql.expression.SelectBase.subquery
    "sqlalchemy.sql.expression.SelectBase.subquery"); both methods do the same thing.
    The object returned is now [`Subquery`](../core/selectable.html#sqlalchemy.sql.expression.Subquery
    "sqlalchemy.sql.expression.Subquery"), which is very similar to the [`Alias`](../core/selectable.html#sqlalchemy.sql.expression.Alias
    "sqlalchemy.sql.expression.Alias") object and shares a common base [`AliasedReturnsRows`](../core/selectable.html#sqlalchemy.sql.expression.AliasedReturnsRows
    "sqlalchemy.sql.expression.AliasedReturnsRows").
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
  zh: 最直观的显著影响是，一个 [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") 不能再直接嵌套在另一个 [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") 中，而不是先将内部的 [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") 明确地转换为子查询。这在历史上是通过使用 [`SelectBase.alias()`](../core/selectable.html#sqlalchemy.sql.expression.SelectBase.alias
    "sqlalchemy.sql.expression.SelectBase.alias") 方法来实现的，但更明确地使用新方法 [`SelectBase.subquery()`](../core/selectable.html#sqlalchemy.sql.expression.SelectBase.subquery
    "sqlalchemy.sql.expression.SelectBase.subquery") 更适合；这两种方法做的事情是一样的。现在返回的对象是 [`Subquery`](../core/selectable.html#sqlalchemy.sql.expression.Subquery
    "sqlalchemy.sql.expression.Subquery")，它与 [`Alias`](../core/selectable.html#sqlalchemy.sql.expression.Alias
    "sqlalchemy.sql.expression.Alias") 对象非常相似，并共享一个公共基类 [`AliasedReturnsRows`](../core/selectable.html#sqlalchemy.sql.expression.AliasedReturnsRows
    "sqlalchemy.sql.expression.AliasedReturnsRows")。
- en: 'That is, this will now raise:'
  id: totrans-1041
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，现在会引发：
- en: '[PRE219]'
  id: totrans-1042
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: 'Raising:'
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
  zh: 提出：
- en: '[PRE220]'
  id: totrans-1044
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: 'The correct calling form is instead (noting also that [brackets are no longer
    required for select()](#change-5284)):'
  id: totrans-1045
  prefs: []
  type: TYPE_NORMAL
  zh: 正确的调用形式应为（同时注意[不再需要对 select() 使用括号](#change-5284)）：
- en: '[PRE221]'
  id: totrans-1046
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: Noting above that the [`SelectBase.subquery()`](../core/selectable.html#sqlalchemy.sql.expression.SelectBase.subquery
    "sqlalchemy.sql.expression.SelectBase.subquery") method is essentially equivalent
    to using the [`SelectBase.alias()`](../core/selectable.html#sqlalchemy.sql.expression.SelectBase.alias
    "sqlalchemy.sql.expression.SelectBase.alias") method.
  id: totrans-1047
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到上面的 [`SelectBase.subquery()`](../core/selectable.html#sqlalchemy.sql.expression.SelectBase.subquery
    "sqlalchemy.sql.expression.SelectBase.subquery") 方法本质上等同于使用 [`SelectBase.alias()`](../core/selectable.html#sqlalchemy.sql.expression.SelectBase.alias
    "sqlalchemy.sql.expression.SelectBase.alias") 方法。
- en: 'The rationale for this change is based on the following:'
  id: totrans-1048
  prefs: []
  type: TYPE_NORMAL
  zh: 这种变更的原理如下：
- en: In order to support the unification of [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") with [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query"), the [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") object needs to have [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") and [`Select.outerjoin()`](../core/selectable.html#sqlalchemy.sql.expression.Select.outerjoin
    "sqlalchemy.sql.expression.Select.outerjoin") methods that actually add JOIN criteria
    to the existing FROM clause, as is what users have always expected it to do in
    any case. The previous behavior, having to align with what a [`FromClause`](../core/selectable.html#sqlalchemy.sql.expression.FromClause
    "sqlalchemy.sql.expression.FromClause") would do, was that it would generate an
    unnamed subquery and then JOIN to it, which was a completely useless feature that
    only confused those users unfortunate enough to try this. This change is discussed
    at [select().join() and outerjoin() add JOIN criteria to the current query, rather
    than creating a subquery](#change-select-join).
  id: totrans-1049
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了支持将[`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select "sqlalchemy.sql.expression.Select")与[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")统一起来，[`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select")对象需要具有实际添加JOIN条件到现有FROM子句的[`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join")和[`Select.outerjoin()`](../core/selectable.html#sqlalchemy.sql.expression.Select.outerjoin
    "sqlalchemy.sql.expression.Select.outerjoin")方法，正如用户一直期望它们做的那样。先前的行为，需要与[`FromClause`](../core/selectable.html#sqlalchemy.sql.expression.FromClause
    "sqlalchemy.sql.expression.FromClause")一致，即生成一个无名称的子查询，然后JOIN到它，这是一个完全没有用的功能，只会让那些不幸尝试的用户感到困惑。这一变化在[select().join()
    and outerjoin() add JOIN criteria to the current query, rather than creating a
    subquery](#change-select-join)中讨论。
- en: 'The behavior of including a SELECT in the FROM clause of another SELECT without
    first creating an alias or subquery would be that it creates an unnamed subquery.
    While standard SQL does support this syntax, in practice it is rejected by most
    databases. For example, both the MySQL and PostgreSQL outright reject the usage
    of unnamed subqueries:'
  id: totrans-1050
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在另一个SELECT的FROM子句中包含一个SELECT的行为，而不先创建别名或子查询，会导致创建一个无名称的子查询。虽然标准SQL支持这种语法，但实际上大多数数据库都会拒绝。例如，MySQL和PostgreSQL都明确拒绝使用无名称子查询：
- en: '[PRE222]'
  id: totrans-1051
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE222]'
- en: 'A database like SQLite accepts them, however it is still often the case that
    the names produced from such a subquery are too ambiguous to be useful:'
  id: totrans-1052
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 像SQLite这样的数据库接受它们，但通常情况下，从这样的子查询中产生的名称太模糊，无法使用：
- en: '[PRE223]'
  id: totrans-1053
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE223]'
- en: As [`SelectBase`](../core/selectable.html#sqlalchemy.sql.expression.SelectBase
    "sqlalchemy.sql.expression.SelectBase") objects are no longer [`FromClause`](../core/selectable.html#sqlalchemy.sql.expression.FromClause
    "sqlalchemy.sql.expression.FromClause") objects, attributes like the `.c` attribute
    as well as methods like `.select()` is now deprecated, as they imply implicit
    production of a subquery. The `.join()` and `.outerjoin()` methods are now [repurposed
    to append JOIN criteria to the existing query](#change-select-join) in a similar
    way as that of [`Query.join()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join"), which is what users have always expected these methods
    to do in any case.
  id: totrans-1054
  prefs: []
  type: TYPE_NORMAL
  zh: 由于[`SelectBase`](../core/selectable.html#sqlalchemy.sql.expression.SelectBase
    "sqlalchemy.sql.expression.SelectBase")对象不再是[`FromClause`](../core/selectable.html#sqlalchemy.sql.expression.FromClause
    "sqlalchemy.sql.expression.FromClause")对象，因此像`.c`属性以及`.select()`等方法现在已被弃用，因为它们暗示隐式生成子查询。`.join()`和`.outerjoin()`方法现在被重新用于在现有查询中追加JOIN条件，类似于[`Query.join()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join")的方式，这正是用户一直期望这些方法做的事情。
- en: 'In place of the `.c` attribute, a new attribute [`SelectBase.selected_columns`](../core/selectable.html#sqlalchemy.sql.expression.SelectBase.selected_columns
    "sqlalchemy.sql.expression.SelectBase.selected_columns") is added. This attribute
    resolves to a column collection that is what most people hope that `.c` does (but
    does not), which is to reference the columns that are in the columns clause of
    the SELECT statement. A common beginner mistake is code such as the following:'
  id: totrans-1055
  prefs: []
  type: TYPE_NORMAL
  zh: 在`.c`属性的位置，新增了一个属性[`SelectBase.selected_columns`](../core/selectable.html#sqlalchemy.sql.expression.SelectBase.selected_columns
    "sqlalchemy.sql.expression.SelectBase.selected_columns")。这个属性解析为一个列集合，大多数人希望`.c`能够做到的（但实际上不能），即引用SELECT语句中列子句中的列。一个常见的初学者错误是以下代码：
- en: '[PRE224]'
  id: totrans-1056
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: The above code appears intuitive and that it would generate “SELECT * FROM users
    WHERE name=’foo’”, however veteran SQLAlchemy users will recognize that it in
    fact generates a useless subquery resembling “SELECT * FROM (SELECT * FROM users)
    WHERE name=’foo’”.
  id: totrans-1057
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码看起来直观，似乎会生成“SELECT * FROM users WHERE name=’foo’”，然而，经验丰富的SQLAlchemy用户会意识到，实际上它生成了一个无用的子查询，类似于“SELECT
    * FROM (SELECT * FROM users) WHERE name=’foo’”。
- en: 'The new [`SelectBase.selected_columns`](../core/selectable.html#sqlalchemy.sql.expression.SelectBase.selected_columns
    "sqlalchemy.sql.expression.SelectBase.selected_columns") attribute however **does**
    suit the use case above, as in a case like the above it links directly to the
    columns present in the `users.c` collection:'
  id: totrans-1058
  prefs: []
  type: TYPE_NORMAL
  zh: 新的[`SelectBase.selected_columns`](../core/selectable.html#sqlalchemy.sql.expression.SelectBase.selected_columns
    "sqlalchemy.sql.expression.SelectBase.selected_columns")属性确实**适用于**上述用例，因为在上述情况下，它直接链接到`users.c`集合中存在的列：
- en: '[PRE225]'
  id: totrans-1059
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: '[#4617](https://www.sqlalchemy.org/trac/ticket/4617)'
  id: totrans-1060
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4617](https://www.sqlalchemy.org/trac/ticket/4617)'
- en: '### select().join() and outerjoin() add JOIN criteria to the current query,
    rather than creating a subquery'
  id: totrans-1061
  prefs: []
  type: TYPE_NORMAL
  zh: '### select().join()和outerjoin()将JOIN条件添加到当前查询，而不是创建子查询'
- en: Towards the goal of unifying [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") and [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select"), particularly for [2.0 style](../glossary.html#term-2.0-style)
    use of [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select "sqlalchemy.sql.expression.Select"),
    it was critical that there be a working [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") method that behaves like the [`Query.join()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join") method, adding additional entries to the FROM clause
    of the existing SELECT and then returning the new [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") object for further modification, instead of
    wrapping the object inside of an unnamed subquery and returning a JOIN from that
    subquery, a behavior that has always been virtually useless and completely misleading
    to users.
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现统一[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")和[`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select")的目标，特别是对于[2.0风格](../glossary.html#term-2.0-style)使用[`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select")，至关重要的是有一个工作的[`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join")方法，其行为类似于[`Query.join()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join")方法，向现有SELECT的FROM子句添加额外条目，然后返回新的[`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select")对象以进行进一步修改，而不是将对象包装在一个无名子查询中，并从该子查询返回JOIN，这种行为对用户来说一直是几乎无用和完全误导的。
- en: To allow this to be the case, [A SELECT statement is no longer implicitly considered
    to be a FROM clause](#change-4617) was first implemented which splits off [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") from having to be a [`FromClause`](../core/selectable.html#sqlalchemy.sql.expression.FromClause
    "sqlalchemy.sql.expression.FromClause"); this removed the requirement that [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") would need to return a [`Join`](../core/selectable.html#sqlalchemy.sql.expression.Join
    "sqlalchemy.sql.expression.Join") object rather than a new version of that [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") object that includes a new JOIN in its FROM
    clause.
  id: totrans-1063
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这成为可能，首先实现了[A SELECT statement is no longer implicitly considered to be a
    FROM clause](#change-4617)，这将[`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select")从必须是[`FromClause`](../core/selectable.html#sqlalchemy.sql.expression.FromClause
    "sqlalchemy.sql.expression.FromClause")的要求中分离出来；这消除了[`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join")需要返回一个[`Join`](../core/selectable.html#sqlalchemy.sql.expression.Join
    "sqlalchemy.sql.expression.Join")对象而不是包含新JOIN的FROM子句的新版本[`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select")对象的要求。
- en: From that point on, as the [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") and [`Select.outerjoin()`](../core/selectable.html#sqlalchemy.sql.expression.Select.outerjoin
    "sqlalchemy.sql.expression.Select.outerjoin") did have an existing behavior, the
    original plan was that these methods would be deprecated, and the new “useful”
    version of the methods would be available on an alternate, “future” [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") object available as a separate import.
  id: totrans-1064
  prefs: []
  type: TYPE_NORMAL
  zh: 从那时起，由于 [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") 和 [`Select.outerjoin()`](../core/selectable.html#sqlalchemy.sql.expression.Select.outerjoin
    "sqlalchemy.sql.expression.Select.outerjoin") 有着现有的行为，最初的计划是这些方法将被弃用，而新的“有用”版本的方法将在一个备用的“未来”
    [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select "sqlalchemy.sql.expression.Select")
    对象上作为一个单独的导入可用。
- en: However, after some time working with this particular codebase, it was decided
    that having two different kinds of [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") objects floating around, each with 95% the
    same behavior except for some subtle difference in how some of the methods behave
    was going to be more misleading and inconvenient than simply making a hard change
    in how these two methods behave, given that the existing behavior of [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") and [`Select.outerjoin()`](../core/selectable.html#sqlalchemy.sql.expression.Select.outerjoin
    "sqlalchemy.sql.expression.Select.outerjoin") is essentially never used and only
    causes confusion.
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，经过一段时间的与这个特定的代码库一起工作后，决定有两种不同类型的 [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") 对象在周围漂浮，每个对象的行为都相似，除了某些细微的方法行为上的差异，这比起简单地对这两种方法的行为进行硬性更改更加误导和不便，因为
    [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") 和 [`Select.outerjoin()`](../core/selectable.html#sqlalchemy.sql.expression.Select.outerjoin
    "sqlalchemy.sql.expression.Select.outerjoin") 的现有行为基本上是不会被使用的，只会造成混淆。
- en: So it was decided, given how very useless the current behavior is, and how extremely
    useful and important and useful the new behavior would be, to make a **hard behavioral
    change** in this one area, rather than waiting another year and having a more
    awkward API in the interim. SQLAlchemy developers do not take it lightly to make
    a completely breaking change like this, however this is a very special case and
    it is extremely unlikely that the previous implementation of these methods was
    being used; as noted in [A SELECT statement is no longer implicitly considered
    to be a FROM clause](#change-4617), major databases such as MySQL and PostgreSQL
    don’t allow for unnamed subqueries in any case and from a syntactical point of
    view it’s nearly impossible for a JOIN from an unnamed subquery to be useful since
    it’s very difficult to refer to the columns within it unambiguously.
  id: totrans-1066
  prefs: []
  type: TYPE_NORMAL
  zh: 所以决定在这一个领域做出一个**硬性行为更改**，而不是等待另一年并在此期间产生更加尴尬的 API。SQLAlchemy 开发人员不轻易做出像这样完全破坏性的更改，然而这是一个非常特殊的情况，以前的这些方法的实现几乎肯定不会被使用；如
    [A SELECT statement is no longer implicitly considered to be a FROM clause](#change-4617)
    中所述，主要数据库如 MySQL 和 PostgreSQL 在任何情况下都不允许未命名的子查询，从语法上来说，从未命名的子查询中进行 JOIN 几乎是不可能有用的，因为在其中明确引用列非常困难。
- en: 'With the new implementation, [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") and [`Select.outerjoin()`](../core/selectable.html#sqlalchemy.sql.expression.Select.outerjoin
    "sqlalchemy.sql.expression.Select.outerjoin") now behave very similarly to that
    of [`Query.join()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.join "sqlalchemy.orm.Query.join"),
    adding JOIN criteria to the existing statement by matching to the left entity:'
  id: totrans-1067
  prefs: []
  type: TYPE_NORMAL
  zh: 有了新的实现，[`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") 和 [`Select.outerjoin()`](../core/selectable.html#sqlalchemy.sql.expression.Select.outerjoin
    "sqlalchemy.sql.expression.Select.outerjoin") 现在的行为与 [`Query.join()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join") 非常相似，通过将 JOIN 条件与左实体进行匹配，将 JOIN 条件添加到现有语句中：
- en: '[PRE226]'
  id: totrans-1068
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: 'producing:'
  id: totrans-1069
  prefs: []
  type: TYPE_NORMAL
  zh: 产生的结果是：
- en: '[PRE227]'
  id: totrans-1070
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: 'As is the case for [`Join`](../core/selectable.html#sqlalchemy.sql.expression.Join
    "sqlalchemy.sql.expression.Join"), the ON clause is automatically determined if
    feasible:'
  id: totrans-1071
  prefs: []
  type: TYPE_NORMAL
  zh: 就像[`Join`](../core/selectable.html#sqlalchemy.sql.expression.Join "sqlalchemy.sql.expression.Join")一样，如果可行的话，ON
    子句会被自动确定：
- en: '[PRE228]'
  id: totrans-1072
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: 'When ORM entities are used in the statement, this is essentially how ORM queries
    are built up using [2.0 style](../glossary.html#term-2.0-style) invocation. ORM
    entities will assign a “plugin” to the statement internally such that ORM-related
    compilation rules will take place when the statement is compiled into a SQL string.
    More directly, the [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") method can accommodate ORM relationships,
    without breaking the hard separation between Core and ORM internals:'
  id: totrans-1073
  prefs: []
  type: TYPE_NORMAL
  zh: 当在语句中使用 ORM 实体时，这基本上是使用 [2.0 风格](../glossary.html#term-2.0-style) 调用来构建 ORM
    查询的方式。ORM 实体将在语句内部分配一个“插件”，这样当语句被编译成 SQL 字符串时，与 ORM 相关的编译规则将会发生作用。更直接地说，[`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") 方法可以适应 ORM 关系，而不会破坏核心和 ORM 内部之间的严格分隔：
- en: '[PRE229]'
  id: totrans-1074
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: 'Another new method [`Select.join_from()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join_from
    "sqlalchemy.sql.expression.Select.join_from") is also added, which allows easier
    specification of the left and right side of a join at once:'
  id: totrans-1075
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，还添加了另一个新方法 [`Select.join_from()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join_from
    "sqlalchemy.sql.expression.Select.join_from")，它允许一次更轻松地指定连接的左侧和右侧：
- en: '[PRE230]'
  id: totrans-1076
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: 'producing:'
  id: totrans-1077
  prefs: []
  type: TYPE_NORMAL
  zh: 生成：
- en: '[PRE231]'
  id: totrans-1078
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: '### The URL object is now immutable'
  id: totrans-1079
  prefs: []
  type: TYPE_NORMAL
  zh: '### URL 对象现在是不可变的'
- en: The [`URL`](../core/engines.html#sqlalchemy.engine.URL "sqlalchemy.engine.URL")
    object has been formalized such that it now presents itself as a `namedtuple`
    with a fixed number of fields that are immutable. In addition, the dictionary
    represented by the [`URL.query`](../core/engines.html#sqlalchemy.engine.URL.query
    "sqlalchemy.engine.URL.query") attribute is also an immutable mapping. Mutation
    of the [`URL`](../core/engines.html#sqlalchemy.engine.URL "sqlalchemy.engine.URL")
    object was not a formally supported or documented use case which led to some open-ended
    use cases that made it very difficult to intercept incorrect usages, most commonly
    mutation of the [`URL.query`](../core/engines.html#sqlalchemy.engine.URL.query
    "sqlalchemy.engine.URL.query") dictionary to include non-string elements. It also
    led to all the common problems of allowing mutability in a fundamental data object,
    namely unwanted mutations elsewhere leaking into code that didn’t expect the URL
    to change. Finally, the namedtuple design is inspired by that of Python’s `urllib.parse.urlparse()`
    which returns the parsed object as a named tuple.
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
  zh: '[`URL`](../core/engines.html#sqlalchemy.engine.URL "sqlalchemy.engine.URL")
    对象已经被规范化，现在它呈现为一个具有固定数量字段的`namedtuple`，这些字段是不可变的。此外，由 [`URL.query`](../core/engines.html#sqlalchemy.engine.URL.query
    "sqlalchemy.engine.URL.query") 属性表示的字典也是一个不可变映射。对 [`URL`](../core/engines.html#sqlalchemy.engine.URL
    "sqlalchemy.engine.URL") 对象的修改不是正式支持或记录的用例，这导致了一些开放性用例，使得很难拦截不正确的用法，最常见的是修改 [`URL.query`](../core/engines.html#sqlalchemy.engine.URL.query
    "sqlalchemy.engine.URL.query") 字典以包含非字符串元素。这也导致了允许在基本数据对象中进行可变性的所有常见问题，即不期望 URL
    改变的代码中泄露了不需要的变异。最后，`namedtuple` 的设计受到了 Python 的 `urllib.parse.urlparse()` 的启发，它将解析后的对象返回为命名元组。'
- en: The decision to change the API outright is based on a calculus weighing the
    infeasibility of a deprecation path (which would involve changing the [`URL.query`](../core/engines.html#sqlalchemy.engine.URL.query
    "sqlalchemy.engine.URL.query") dictionary to be a special dictionary that emits
    deprecation warnings when any kind of standard library mutation methods are invoked,
    in addition that when the dictionary would hold any kind of list of elements,
    the list would also have to emit deprecation warnings on mutation) against the
    unlikely use case of projects already mutating [`URL`](../core/engines.html#sqlalchemy.engine.URL
    "sqlalchemy.engine.URL") objects in the first place, as well as that small changes
    such as that of [#5341](https://www.sqlalchemy.org/trac/ticket/5341) were creating
    backwards-incompatibility in any case. The primary case for mutation of a [`URL`](../core/engines.html#sqlalchemy.engine.URL
    "sqlalchemy.engine.URL") object is that of parsing plugin arguments within the
    [`CreateEnginePlugin`](../core/connections.html#sqlalchemy.engine.CreateEnginePlugin
    "sqlalchemy.engine.CreateEnginePlugin") extension point, itself a fairly recent
    addition that based on Github code search is in use by two repositories, neither
    of which are actually mutating the URL object.
  id: totrans-1081
  prefs: []
  type: TYPE_NORMAL
  zh: 直接更改API的决定基于对废弃路径的不可行性的权衡（这将涉及将[`URL.query`](../core/engines.html#sqlalchemy.engine.URL.query
    "sqlalchemy.engine.URL.query")字典更改为一个特殊字典，当调用任何标准库变异方法时会发出废弃警告，此外，当字典将保存任何元素列表时，列表也将在变异时发出废弃警告），而不是项目已经在第一次更改[`URL`](../core/engines.html#sqlalchemy.engine.URL
    "sqlalchemy.engine.URL")对象的不太可能使用情况，以及像[#5341](https://www.sqlalchemy.org/trac/ticket/5341)这样的小变化在任何情况下都会造成向后不兼容性。对于更改[`URL`](../core/engines.html#sqlalchemy.engine.URL
    "sqlalchemy.engine.URL")对象的主要情况是在[`CreateEnginePlugin`](../core/connections.html#sqlalchemy.engine.CreateEnginePlugin
    "sqlalchemy.engine.CreateEnginePlugin")扩展点内解析插件参数，这本身是一个相当新的添加，根据Github代码搜索的结果，有两个仓库在使用，但实际上都没有更改URL对象。
- en: 'The [`URL`](../core/engines.html#sqlalchemy.engine.URL "sqlalchemy.engine.URL")
    object now provides a rich interface inspecting and generating new [`URL`](../core/engines.html#sqlalchemy.engine.URL
    "sqlalchemy.engine.URL") objects. The existing mechanism to create a [`URL`](../core/engines.html#sqlalchemy.engine.URL
    "sqlalchemy.engine.URL") object, the [`make_url()`](../core/engines.html#sqlalchemy.engine.make_url
    "sqlalchemy.engine.make_url") function, remains unchanged:'
  id: totrans-1082
  prefs: []
  type: TYPE_NORMAL
  zh: '[`URL`](../core/engines.html#sqlalchemy.engine.URL "sqlalchemy.engine.URL")对象现在提供了一个丰富的接口来检查和生成新的[`URL`](../core/engines.html#sqlalchemy.engine.URL
    "sqlalchemy.engine.URL")对象。创建[`URL`](../core/engines.html#sqlalchemy.engine.URL
    "sqlalchemy.engine.URL")对象的现有机制，即[`make_url()`](../core/engines.html#sqlalchemy.engine.make_url
    "sqlalchemy.engine.make_url")函数，保持不变：'
- en: '[PRE232]'
  id: totrans-1083
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: 'For programmatic construction, code that may have been using the [`URL`](../core/engines.html#sqlalchemy.engine.URL
    "sqlalchemy.engine.URL") constructor or `__init__` method directly will receive
    a deprecation warning if arguments are passed as keyword arguments and not an
    exact 7-tuple. The keyword-style constructor is now available via the [`URL.create()`](../core/engines.html#sqlalchemy.engine.URL.create
    "sqlalchemy.engine.URL.create") method:'
  id: totrans-1084
  prefs: []
  type: TYPE_NORMAL
  zh: 对于以编程方式构建的代码，如果参数作为关键字参数传递而不是精确的7元组，则可能一直在使用[`URL`](../core/engines.html#sqlalchemy.engine.URL
    "sqlalchemy.engine.URL")构造函数或`__init__`方法的代码将收到废弃警告。现在可以通过[`URL.create()`](../core/engines.html#sqlalchemy.engine.URL.create
    "sqlalchemy.engine.URL.create")方法使用关键字样式的构造函数：
- en: '[PRE233]'
  id: totrans-1085
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: 'Fields can be altered typically using the [`URL.set()`](../core/engines.html#sqlalchemy.engine.URL.set
    "sqlalchemy.engine.URL.set") method, which returns a new [`URL`](../core/engines.html#sqlalchemy.engine.URL
    "sqlalchemy.engine.URL") object with changes applied:'
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[`URL.set()`](../core/engines.html#sqlalchemy.engine.URL.set "sqlalchemy.engine.URL.set")方法通常可以修改字段，该方法返回一个应用更改的新[`URL`](../core/engines.html#sqlalchemy.engine.URL
    "sqlalchemy.engine.URL")对象：
- en: '[PRE234]'
  id: totrans-1087
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: 'To alter the contents of the [`URL.query`](../core/engines.html#sqlalchemy.engine.URL.query
    "sqlalchemy.engine.URL.query") dictionary, methods such as [`URL.update_query_dict()`](../core/engines.html#sqlalchemy.engine.URL.update_query_dict
    "sqlalchemy.engine.URL.update_query_dict") may be used:'
  id: totrans-1088
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改[`URL.query`](../core/engines.html#sqlalchemy.engine.URL.query "sqlalchemy.engine.URL.query")字典的内容，可以使用[`URL.update_query_dict()`](../core/engines.html#sqlalchemy.engine.URL.update_query_dict
    "sqlalchemy.engine.URL.update_query_dict")等方法：
- en: '[PRE235]'
  id: totrans-1089
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: 'To upgrade code that is mutating these fields directly, a **backwards and forwards
    compatible approach** is to use a duck-typing, as in the following style:'
  id: totrans-1090
  prefs: []
  type: TYPE_NORMAL
  zh: 要升级直接更改这些字段的代码，一个**向后和向前兼容的方法**是使用鸭子类型，如以下样式：
- en: '[PRE236]'
  id: totrans-1091
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: 'The query string retains its existing format as a dictionary of strings to
    strings, using sequences of strings to represent multiple parameters. For example:'
  id: totrans-1092
  prefs: []
  type: TYPE_NORMAL
  zh: 查询字符串保留其现有格式，作为字符串到字符串的字典，使用字符串序列表示多个参数。例如：
- en: '[PRE237]'
  id: totrans-1093
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: 'To work with the contents of the [`URL.query`](../core/engines.html#sqlalchemy.engine.URL.query
    "sqlalchemy.engine.URL.query") attribute such that all values are normalized into
    sequences, use the [`URL.normalized_query`](../core/engines.html#sqlalchemy.engine.URL.normalized_query
    "sqlalchemy.engine.URL.normalized_query") attribute:'
  id: totrans-1094
  prefs: []
  type: TYPE_NORMAL
  zh: 要处理[`URL.query`](../core/engines.html#sqlalchemy.engine.URL.query "sqlalchemy.engine.URL.query")属性的内容，使所有值规范化为序列，请使用[`URL.normalized_query`](../core/engines.html#sqlalchemy.engine.URL.normalized_query
    "sqlalchemy.engine.URL.normalized_query")属性：
- en: '[PRE238]'
  id: totrans-1095
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: 'The query string can be appended to via methods such as [`URL.update_query_dict()`](../core/engines.html#sqlalchemy.engine.URL.update_query_dict
    "sqlalchemy.engine.URL.update_query_dict"), [`URL.update_query_pairs()`](../core/engines.html#sqlalchemy.engine.URL.update_query_pairs
    "sqlalchemy.engine.URL.update_query_pairs"), [`URL.update_query_string()`](../core/engines.html#sqlalchemy.engine.URL.update_query_string
    "sqlalchemy.engine.URL.update_query_string"):'
  id: totrans-1096
  prefs: []
  type: TYPE_NORMAL
  zh: 查询字符串可以通过诸如[`URL.update_query_dict()`](../core/engines.html#sqlalchemy.engine.URL.update_query_dict
    "sqlalchemy.engine.URL.update_query_dict")，[`URL.update_query_pairs()`](../core/engines.html#sqlalchemy.engine.URL.update_query_pairs
    "sqlalchemy.engine.URL.update_query_pairs")，[`URL.update_query_string()`](../core/engines.html#sqlalchemy.engine.URL.update_query_string
    "sqlalchemy.engine.URL.update_query_string")等方法进行追加：
- en: '[PRE239]'
  id: totrans-1097
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: See also
  id: totrans-1098
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`URL`](../core/engines.html#sqlalchemy.engine.URL "sqlalchemy.engine.URL")'
  id: totrans-1099
  prefs: []
  type: TYPE_NORMAL
  zh: '[`URL`](../core/engines.html#sqlalchemy.engine.URL "sqlalchemy.engine.URL")'
- en: Changes to CreateEnginePlugin
  id: totrans-1100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 对CreateEnginePlugin的更改
- en: 'The [`CreateEnginePlugin`](../core/connections.html#sqlalchemy.engine.CreateEnginePlugin
    "sqlalchemy.engine.CreateEnginePlugin") is also impacted by this change, as the
    documentation for custom plugins indicated that the `dict.pop()` method should
    be used to remove consumed arguments from the URL object. This should now be achieved
    using the [`CreateEnginePlugin.update_url()`](../core/connections.html#sqlalchemy.engine.CreateEnginePlugin.update_url
    "sqlalchemy.engine.CreateEnginePlugin.update_url") method. A backwards compatible
    approach would look like:'
  id: totrans-1101
  prefs: []
  type: TYPE_NORMAL
  zh: 此更改还会影响[`CreateEnginePlugin`](../core/connections.html#sqlalchemy.engine.CreateEnginePlugin
    "sqlalchemy.engine.CreateEnginePlugin")，因为自定义插件的文档指出应使用`dict.pop()`方法从URL对象中删除已使用的参数。现在应该使用[`CreateEnginePlugin.update_url()`](../core/connections.html#sqlalchemy.engine.CreateEnginePlugin.update_url
    "sqlalchemy.engine.CreateEnginePlugin.update_url")方法来实现。向后兼容的方法如下：
- en: '[PRE240]'
  id: totrans-1102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: See the docstring at [`CreateEnginePlugin`](../core/connections.html#sqlalchemy.engine.CreateEnginePlugin
    "sqlalchemy.engine.CreateEnginePlugin") for complete details on how this class
    is used.
  id: totrans-1103
  prefs: []
  type: TYPE_NORMAL
  zh: 查看[`CreateEnginePlugin`](../core/connections.html#sqlalchemy.engine.CreateEnginePlugin
    "sqlalchemy.engine.CreateEnginePlugin")处的文档字符串，了解此类的完整使用详情。
- en: '[#5526](https://www.sqlalchemy.org/trac/ticket/5526)'
  id: totrans-1104
  prefs: []
  type: TYPE_NORMAL
  zh: '[#5526](https://www.sqlalchemy.org/trac/ticket/5526)'
- en: Changes to CreateEnginePlugin
  id: totrans-1105
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 对CreateEnginePlugin的更改
- en: 'The [`CreateEnginePlugin`](../core/connections.html#sqlalchemy.engine.CreateEnginePlugin
    "sqlalchemy.engine.CreateEnginePlugin") is also impacted by this change, as the
    documentation for custom plugins indicated that the `dict.pop()` method should
    be used to remove consumed arguments from the URL object. This should now be achieved
    using the [`CreateEnginePlugin.update_url()`](../core/connections.html#sqlalchemy.engine.CreateEnginePlugin.update_url
    "sqlalchemy.engine.CreateEnginePlugin.update_url") method. A backwards compatible
    approach would look like:'
  id: totrans-1106
  prefs: []
  type: TYPE_NORMAL
  zh: 此更改还会影响[`CreateEnginePlugin`](../core/connections.html#sqlalchemy.engine.CreateEnginePlugin
    "sqlalchemy.engine.CreateEnginePlugin")，因为自定义插件的文档指出应使用`dict.pop()`方法从URL对象中删除已使用的参数。现在应该使用[`CreateEnginePlugin.update_url()`](../core/connections.html#sqlalchemy.engine.CreateEnginePlugin.update_url
    "sqlalchemy.engine.CreateEnginePlugin.update_url")方法来实现。向后兼容的方法如下：
- en: '[PRE241]'
  id: totrans-1107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: See the docstring at [`CreateEnginePlugin`](../core/connections.html#sqlalchemy.engine.CreateEnginePlugin
    "sqlalchemy.engine.CreateEnginePlugin") for complete details on how this class
    is used.
  id: totrans-1108
  prefs: []
  type: TYPE_NORMAL
  zh: 查看[`CreateEnginePlugin`](../core/connections.html#sqlalchemy.engine.CreateEnginePlugin
    "sqlalchemy.engine.CreateEnginePlugin")处的文档字符串，了解此类的完整使用详情。
- en: '[#5526](https://www.sqlalchemy.org/trac/ticket/5526)'
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
  zh: '[#5526](https://www.sqlalchemy.org/trac/ticket/5526)'
- en: '### select(), case() now accept positional expressions'
  id: totrans-1110
  prefs: []
  type: TYPE_NORMAL
  zh: '### select()，case()现在接受位置表达式'
- en: 'As it may be seen elsewhere in this document, the [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") construct will now accept “columns clause”
    arguments positionally, rather than requiring they be passed as a list:'
  id: totrans-1111
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在本文档的其他地方可能看到的那样，[`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") 构造现在将按位置接受“列子句”参数，而不需要将它们作为列表传递：
- en: '[PRE242]'
  id: totrans-1112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: When sending the arguments positionally, no other keyword arguments are permitted.
    In SQLAlchemy 2.0, the above calling style will be the only calling style supported.
  id: totrans-1113
  prefs: []
  type: TYPE_NORMAL
  zh: 在按位置发送参数时，不允许其他关键字参数。在 SQLAlchemy 2.0 中，上述调用风格将是唯一支持的调用风格。
- en: 'For the duration of 1.4, the previous calling style will still continue to
    function, which passes the list of columns or other expressions as a list:'
  id: totrans-1114
  prefs: []
  type: TYPE_NORMAL
  zh: 在 1.4 版本期间，先前的调用风格仍将继续运行，将列或其他表达式的列表作为列表传递：
- en: '[PRE243]'
  id: totrans-1115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: 'The above legacy calling style also accepts the old keyword arguments that
    have since been removed from most narrative documentation. The existence of these
    keyword arguments is why the columns clause was passed as a list in the first
    place:'
  id: totrans-1116
  prefs: []
  type: TYPE_NORMAL
  zh: 上述传统调用风格还接受了自那时起已从大多数叙述文档中删除的旧关键字参数。这些关键字参数的存在是为什么列子句首先作为列表传递的原因：
- en: '[PRE244]'
  id: totrans-1117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE244]'
- en: 'The detection between the two styles is based on whether or not the first positional
    argument is a list. There are unfortunately still likely some usages that look
    like the following, where the keyword for the “whereclause” is omitted:'
  id: totrans-1118
  prefs: []
  type: TYPE_NORMAL
  zh: 两种风格之间的区别是第一个位置参数是否为列表。不幸的是，仍然可能有一些使用看起来像以下内容的用法，其中“whereclause”的关键字被省略：
- en: '[PRE245]'
  id: totrans-1119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE245]'
- en: As part of this change, the [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") construct also gains the 2.0-style “future”
    API which includes an updated [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") method as well as methods like [`Select.filter_by()`](../core/selectable.html#sqlalchemy.sql.expression.Select.filter_by
    "sqlalchemy.sql.expression.Select.filter_by") and [`Select.join_from()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join_from
    "sqlalchemy.sql.expression.Select.join_from").
  id: totrans-1120
  prefs: []
  type: TYPE_NORMAL
  zh: 作为这一更改的一部分，[`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") 构造还获得了 2.0 风格的“未来” API，其中包括更新的 [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") 方法以及诸如 [`Select.filter_by()`](../core/selectable.html#sqlalchemy.sql.expression.Select.filter_by
    "sqlalchemy.sql.expression.Select.filter_by") 和 [`Select.join_from()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join_from
    "sqlalchemy.sql.expression.Select.join_from") 等方法。
- en: 'In a related change, the [`case()`](../core/sqlelement.html#sqlalchemy.sql.expression.case
    "sqlalchemy.sql.expression.case") construct has also been modified to accept its
    list of WHEN clauses positionally, with a similar deprecation track for the old
    calling style:'
  id: totrans-1121
  prefs: []
  type: TYPE_NORMAL
  zh: 在相关更改中，[`case()`](../core/sqlelement.html#sqlalchemy.sql.expression.case "sqlalchemy.sql.expression.case")
    构造也已经修改为按位置接受其 WHEN 子句列表，对于旧的调用风格也有类似的弃用跟踪：
- en: '[PRE246]'
  id: totrans-1122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE246]'
- en: The convention for SQLAlchemy constructs accepting `*args` vs. a list of values,
    as is the latter case for a construct like [`ColumnOperators.in_()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.in_
    "sqlalchemy.sql.expression.ColumnOperators.in_"), is that **positional arguments
    are used for structural specification, lists are used for data specification**.
  id: totrans-1123
  prefs: []
  type: TYPE_NORMAL
  zh: 对于接受`*args`与值列表的 SQLAlchemy 构造的约定，就像[`ColumnOperators.in_()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.in_
    "sqlalchemy.sql.expression.ColumnOperators.in_")这样的构造中的后者情况一样，**位置参数用于结构规范，列表用于数据规范**。
- en: See also
  id: totrans-1124
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[select() no longer accepts varied constructor arguments, columns are passed
    positionally](migration_20.html#migration-20-5284)'
  id: totrans-1125
  prefs: []
  type: TYPE_NORMAL
  zh: '[select() 不再接受不同的构造参数，列是按位置传递的](migration_20.html#migration-20-5284)'
- en: '[select() construct created in “legacy” mode; keyword arguments, etc.](../errors.html#error-c9ae)'
  id: totrans-1126
  prefs: []
  type: TYPE_NORMAL
  zh: '[在“传统”模式下创建的 select() 构造；关键字参数等](../errors.html#error-c9ae)'
- en: '[#5284](https://www.sqlalchemy.org/trac/ticket/5284)'
  id: totrans-1127
  prefs: []
  type: TYPE_NORMAL
  zh: '[#5284](https://www.sqlalchemy.org/trac/ticket/5284)'
- en: '### All IN expressions render parameters for each value in the list on the
    fly (e.g. expanding parameters)'
  id: totrans-1128
  prefs: []
  type: TYPE_NORMAL
  zh: '### 所有 IN 表达式都会即时为列表中的每个值呈现参数（例如，扩展参数）'
- en: The “expanding IN” feature, first introduced in [Late-expanded IN parameter
    sets allow IN expressions with cached statements](migration_12.html#change-3953),
    has matured enough such that it is clearly superior to the previous method of
    rendering IN expressions. As the approach was improved to handle empty lists of
    values, it is now the only means that Core / ORM will use to render lists of IN
    parameters.
  id: totrans-1129
  prefs: []
  type: TYPE_NORMAL
  zh: 首次引入的“扩展 IN”功能已经足够成熟，以至于它显然优于以前的 IN 表达式渲染方法。随着该方法被改进以处理空值列表，它现在是 Core / ORM
    渲染 IN 参数列表的唯一方法。
- en: The previous approach which has been present in SQLAlchemy since its first release
    was that when a list of values were passed to the [`ColumnOperators.in_()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.in_
    "sqlalchemy.sql.expression.ColumnOperators.in_") method, the list would be expanded
    into a series of individual [`BindParameter`](../core/sqlelement.html#sqlalchemy.sql.expression.BindParameter
    "sqlalchemy.sql.expression.BindParameter") objects at statement construction time.
    This suffered from the limitation that it was not possible to vary the parameter
    list at statement execution time based on the parameter dictionary, which meant
    that string SQL statements could not be cached independently of their parameters,
    nor could the parameter dictionary be fully used for statements that included
    IN expressions generally.
  id: totrans-1130
  prefs: []
  type: TYPE_NORMAL
  zh: 之前在 SQLAlchemy 中一直存在的方法是，在[`ColumnOperators.in_()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.in_
    "sqlalchemy.sql.expression.ColumnOperators.in_")方法中传递值列表时，列表会在语句构建时扩展为一系列单独的[`BindParameter`](../core/sqlelement.html#sqlalchemy.sql.expression.BindParameter
    "sqlalchemy.sql.expression.BindParameter")对象。这种方法的局限性在于，无法根据参数字典在语句执行时变化参数列表，这意味着字符串
    SQL 语句不能独立于其参数缓存，并且参数字典不能完全用于包含 IN 表达式的语句。
- en: In order to service the “baked query” feature described at [Baked Queries](../orm/extensions/baked.html),
    a cacheable version of IN was needed, which is what brought about the “expanding
    IN” feature. In contrast to the existing behavior whereby the parameter list is
    expanded at statement construction time into individual [`BindParameter`](../core/sqlelement.html#sqlalchemy.sql.expression.BindParameter
    "sqlalchemy.sql.expression.BindParameter") objects, the feature instead uses a
    single [`BindParameter`](../core/sqlelement.html#sqlalchemy.sql.expression.BindParameter
    "sqlalchemy.sql.expression.BindParameter") that stores the list of values at once;
    when the statement is executed by the [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine"), it is “expanded” on the fly into individual bound
    parameter positions based on the parameters passed to the call to [`Connection.execute()`](../core/connections.html#sqlalchemy.engine.Connection.execute
    "sqlalchemy.engine.Connection.execute"), and the existing SQL string which may
    have been retrieved from a previous execution is modified using a regular expression
    to suit the current parameter set. This allows for the same [`Compiled`](../core/internals.html#sqlalchemy.engine.Compiled
    "sqlalchemy.engine.Compiled") object, which stores the rendered string statement,
    to be invoked multiple times against different parameter sets that modify the
    list contents passed to IN expressions, while still maintaining the behavior of
    individual scalar parameters being passed to the DBAPI. While some DBAPIs do support
    this functionality directly, it is not generally available; the “expanding IN”
    feature now supports the behavior consistently for all backends.
  id: totrans-1131
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持[Baked Queries](../orm/extensions/baked.html)中描述的“烘焙查询”功能，需要一个可缓存版本的 IN，这就引入了“扩展
    IN”功能。与现有行为相比，在语句构造时将参数列表展开为单独的[`BindParameter`](../core/sqlelement.html#sqlalchemy.sql.expression.BindParameter
    "sqlalchemy.sql.expression.BindParameter")对象，该功能使用一个存储所有值列表的单个[`BindParameter`](../core/sqlelement.html#sqlalchemy.sql.expression.BindParameter
    "sqlalchemy.sql.expression.BindParameter")；当由[`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine")执行语句时，它会根据传递给[`Connection.execute()`](../core/connections.html#sqlalchemy.engine.Connection.execute
    "sqlalchemy.engine.Connection.execute")调用的参数，在执行过程中动态将其“展开”为基于当前参数集合的单个绑定参数位置，并且可能已从先前执行中检索到的现有
    SQL 字符串会使用正则表达式修改以适应当前参数集合。这允许相同的[`Compiled`](../core/internals.html#sqlalchemy.engine.Compiled
    "sqlalchemy.engine.Compiled")对象，存储呈现的字符串语句，多次针对修改 IN 表达式传递的不同参数集合调用，同时仍保持将单个标量参数传递给
    DBAPI 的行为。虽然一些 DBAPI 直接支持此功能，但通常不可用；“扩展 IN”功能现在为所有后端一致支持此行为。
- en: 'As a major focus of 1.4 is to allow for true statement caching in Core and
    ORM without the awkwardness of the “baked” system, and since the “expanding IN”
    feature represents a simpler approach to building expressions in any case, it’s
    now invoked automatically whenever a list of values is passed to an IN expression:'
  id: totrans-1132
  prefs: []
  type: TYPE_NORMAL
  zh: 1.4 版的一个主要重点是在 Core 和 ORM 中实现真正的语句缓存，而不需要“烘焙”系统的尴尬，由于“扩展 IN”功能代表了构建表达式的更简单方法，因此现在在将值列表传递给
    IN 表达式时会自动调用它：
- en: '[PRE247]'
  id: totrans-1133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE247]'
- en: 'The pre-execution string representation is:'
  id: totrans-1134
  prefs: []
  type: TYPE_NORMAL
  zh: 预执行字符串表示为：
- en: '[PRE248]'
  id: totrans-1135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE248]'
- en: 'To render the values directly, use `literal_binds` as was the case previously:'
  id: totrans-1136
  prefs: []
  type: TYPE_NORMAL
  zh: 要直接呈现值，请像以前一样使用`literal_binds`：
- en: '[PRE249]'
  id: totrans-1137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE249]'
- en: 'A new flag, “render_postcompile”, is added as a helper to allow the current
    bound value to be rendered as it would be passed to the database:'
  id: totrans-1138
  prefs: []
  type: TYPE_NORMAL
  zh: 添加了一个新标志“render_postcompile”作为辅助工具，允许当前绑定值被呈现为传递给数据库的形式：
- en: '[PRE250]'
  id: totrans-1139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE250]'
- en: 'Engine logging output shows the ultimate rendered statement as well:'
  id: totrans-1140
  prefs: []
  type: TYPE_NORMAL
  zh: 引擎日志输出显示最终呈现的语句如下：
- en: '[PRE251]'
  id: totrans-1141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE251]'
- en: As part of this change, the behavior of “empty IN” expressions, where the list
    parameter is empty, is now standardized on use of the IN operator against a so-called
    “empty set”. As there is no standard SQL syntax for empty sets, a SELECT that
    returns no rows is used, tailored in specific ways for each backend so that the
    database treats it as an empty set; this feature was first introduced in version
    1.3 and is described at [Expanding IN feature now supports empty lists](migration_13.html#change-4271).
    The [`create_engine.empty_in_strategy`](../core/engines.html#sqlalchemy.create_engine.params.empty_in_strategy
    "sqlalchemy.create_engine") parameter, introduced in version 1.2 as a means for
    migrating for how this case was treated for the previous IN system, is now deprecated
    and this flag no longer has an effect; as described in [The IN / NOT IN operator’s
    empty collection behavior is now configurable; default expression simplified](migration_12.html#change-3907),
    this flag allowed a dialect to switch between the original system of comparing
    a column against itself, which turned out to be a huge performance issue, and
    a newer system of comparing “1 != 1” in order to produce a “false” expression.
    The 1.3 introduced behavior which now takes place in all cases is more correct
    than both approaches as the IN operator is still used, and does not have the performance
    issue of the original system.
  id: totrans-1142
  prefs: []
  type: TYPE_NORMAL
  zh: 作为这一变化的一部分，“空 IN”表达式的行为，其中列表参数为空，现在标准化为使用针对所谓“空集”的 IN 运算符。由于没有标准的空集 SQL 语法，使用返回零行的
    SELECT，针对每个后端进行特定方式的定制，以便数据库将其视为空集；此功能首次在版本 1.3 中引入，并在 [扩展 IN 功能现在支持空列表](migration_13.html#change-4271)
    中描述。在版本 1.2 中引入的 [`create_engine.empty_in_strategy`](../core/engines.html#sqlalchemy.create_engine.params.empty_in_strategy
    "sqlalchemy.create_engine") 参数，作为迁移以前 IN 系统处理方式的手段，现已被弃用，此标志不再起作用；如 [IN / NOT
    IN 运算符的空集合行为现在可配置；默认表达式简化](migration_12.html#change-3907) 中所述，此标志允许方言在原始系统比较列与自身，这证明是一个巨大的性能问题，以及新系统比较“1
    != 1” 以产生“false”表达式之间切换。1.3 引入的行为现在在所有情况下都更为正确，因为仍然使用 IN 运算符，并且不具有原始系统的性能问题。
- en: In addition, the “expanding” parameter system has been generalized so that it
    also services other dialect-specific use cases where a parameter cannot be accommodated
    by the DBAPI or backing database; see [New “post compile” bound parameters used
    for LIMIT/OFFSET in Oracle, SQL Server](#change-4808) for details.
  id: totrans-1143
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，“扩展”参数系统已经泛化，以便还服务于其他特定方言的用例，其中参数无法被 DBAPI 或后端数据库容纳；有关详细信息，请参阅 [Oracle、SQL
    Server 中用于 LIMIT/OFFSET 的新“编译后”绑定参数](#change-4808)。
- en: See also
  id: totrans-1144
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[New “post compile” bound parameters used for LIMIT/OFFSET in Oracle, SQL Server](#change-4808)'
  id: totrans-1145
  prefs: []
  type: TYPE_NORMAL
  zh: '[Oracle、SQL Server 中用于 LIMIT/OFFSET 的新“编译后”绑定参数](#change-4808)'
- en: '[Expanding IN feature now supports empty lists](migration_13.html#change-4271)'
  id: totrans-1146
  prefs: []
  type: TYPE_NORMAL
  zh: '[扩展 IN 功能现在支持空列表](migration_13.html#change-4271)'
- en: '[`BindParameter`](../core/sqlelement.html#sqlalchemy.sql.expression.BindParameter
    "sqlalchemy.sql.expression.BindParameter")'
  id: totrans-1147
  prefs: []
  type: TYPE_NORMAL
  zh: '[`BindParameter`](../core/sqlelement.html#sqlalchemy.sql.expression.BindParameter
    "sqlalchemy.sql.expression.BindParameter")'
- en: '[#4645](https://www.sqlalchemy.org/trac/ticket/4645)'
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4645](https://www.sqlalchemy.org/trac/ticket/4645)'
- en: '### Built-in FROM linting will warn for any potential cartesian products in
    a SELECT statement'
  id: totrans-1149
  prefs: []
  type: TYPE_NORMAL
  zh: '### 内置 FROM 代码检查将警告任何 SELECT 语句中潜在的笛卡尔积'
- en: As the Core expression language as well as the ORM are built on an “implicit
    FROMs” model where a particular FROM clause is automatically added if any part
    of the query refers to it, a common issue is the case where a SELECT statement,
    either a top level statement or an embedded subquery, contains FROM elements that
    are not joined to the rest of the FROM elements in the query, causing what’s referred
    to as a “cartesian product” in the result set, i.e. every possible combination
    of rows from each FROM element not otherwise joined. In relational databases,
    this is nearly always an undesirable outcome as it produces an enormous result
    set full of duplicated, uncorrelated data.
  id: totrans-1150
  prefs: []
  type: TYPE_NORMAL
  zh: 由于核心表达语言以及 ORM 建立在“隐式 FROMs”模型上，如果查询的任何部分引用了特定的 FROM 子句，那么该子句将自动添加，一个常见问题是 SELECT
    语句的情况，无论是顶层语句还是嵌入的子查询，包含了未与查询中的其他 FROM 元素连接的 FROM 元素，导致结果集中出现所谓的“笛卡尔积”，即每个未连接的
    FROM 元素之间的所有可能组合的行。在关系数据库中，这几乎总是一个不良结果，因为它会产生一个充满重复、不相关数据的巨大结果集。
- en: 'SQLAlchemy, for all of its great features, is particularly prone to this sort
    of issue happening as a SELECT statement will have elements added to its FROM
    clause automatically from any table seen in the other clauses. A typical scenario
    looks like the following, where two tables are JOINed together, however an additional
    entry in the WHERE clause that perhaps inadvertently does not line up with these
    two tables will create an additional FROM entry:'
  id: totrans-1151
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy，尽管具有许多出色的功能，但特别容易发生这种问题，因为SELECT语句将自动从其他子句中看到的任何表添加到其FROM子句中。典型情况如下，其中两个表被JOIN在一起，然而WHERE子句中可能无意中与这两个表不匹配的额外条目将创建一个额外的FROM条目：
- en: '[PRE252]'
  id: totrans-1152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE252]'
- en: 'The above query selects from a JOIN of `User` and `address_alias`, the latter
    of which is an alias of the `Address` entity. However, the `Address` entity is
    used within the WHERE clause directly, so the above would result in the SQL:'
  id: totrans-1153
  prefs: []
  type: TYPE_NORMAL
  zh: 上述查询从`User`和`address_alias`的JOIN中选择，后者是`Address`实体的别名。然而，`Address`实体直接在WHERE子句中使用，因此上述查询将导致以下SQL：
- en: '[PRE253]'
  id: totrans-1154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE253]'
- en: In the above SQL, we can see what SQLAlchemy developers term “the dreaded comma”,
    as we see “FROM addresses, users JOIN addresses” in the FROM clause which is the
    classic sign of a cartesian product; where a query is making use of JOIN in order
    to join FROM clauses together, however because one of them is not joined, it uses
    a comma. The above query will return a full set of rows that join the “user” and
    “addresses” table together on the “id / user_id” column, and will then apply all
    those rows into a cartesian product against every row in the “addresses” table
    directly. That is, if there are ten user rows and 100 rows in addresses, the above
    query will return its expected result rows, likely to be 100 as all address rows
    would be selected, multiplied by 100 again, so that the total result size would
    be 10000 rows.
  id: totrans-1155
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述SQL中，我们可以看到SQLAlchemy开发人员所称的“可怕的逗号”，因为我们在FROM子句中看到“FROM addresses, users
    JOIN addresses”，这是笛卡尔积的典型迹象；查询正在使用JOIN来将FROM子句连接在一起，但是因为其中一个没有连接，它使用了逗号。上述查询将返回一个完整的行集，将“user”和“addresses”表在“id
    / user_id”列上连接在一起，然后将所有这些行直接应用于“addresses”表中的每一行的笛卡尔积。也就是说，如果有十个用户行和100个地址行，上述查询将返回其预期的结果行，可能为100，因为所有地址行都将被选择，再乘以100，因此总结果大小将为10000行。
- en: The “table1, table2 JOIN table3” pattern is one that also occurs quite frequently
    within the SQLAlchemy ORM due to either subtle mis-application of ORM features
    particularly those related to joined eager loading or joined table inheritance,
    as well as a result of SQLAlchemy ORM bugs within those same systems. Similar
    issues apply to SELECT statements that use “implicit joins”, where the JOIN keyword
    is not used and instead each FROM element is linked with another one via the WHERE
    clause.
  id: totrans-1156
  prefs: []
  type: TYPE_NORMAL
  zh: “table1, table2 JOIN table3”模式在SQLAlchemy ORM中也经常出现，这要归因于对ORM功能的微妙错误应用，特别是与连接式急加载或连接式表继承相关的功能，以及由于这些系统中的SQLAlchemy
    ORM错误而导致的结果。类似的问题也适用于使用“隐式连接”的SELECT语句，其中不使用JOIN关键字，而是通过WHERE子句将每个FROM元素与另一个元素链接起来。
- en: For some years there has been a recipe on the Wiki that applies a graph algorithm
    to a [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select")
    construct at query execution time and inspects the structure of the query for
    these un-linked FROM clauses, parsing through the WHERE clause and all JOIN clauses
    to determine how FROM elements are linked together and ensuring that all the FROM
    elements are connected in a single graph. This recipe has now been adapted to
    be part of the [`SQLCompiler`](../core/internals.html#sqlalchemy.sql.compiler.SQLCompiler
    "sqlalchemy.sql.compiler.SQLCompiler") itself where it now optionally emits a
    warning for a statement if this condition is detected. The warning is enabled
    using the [`create_engine.enable_from_linting`](../core/engines.html#sqlalchemy.create_engine.params.enable_from_linting
    "sqlalchemy.create_engine") flag and is enabled by default. The computational
    overhead of the linter is very low, and additionally it only occurs during statement
    compilation which means for a cached SQL statement it only occurs once.
  id: totrans-1157
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，Wiki 上有一个配方应用图算法于查询执行时间的 [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") 构造，并检查查询的结构以寻找这些未连接的 FROM 子句，通过 WHERE 子句和所有
    JOIN 子句解析来确定 FROM 元素如何连接在一起，并确保所有 FROM 元素在单个图中连接在一起。现在，这个配方已经被改编为 [`SQLCompiler`](../core/internals.html#sqlalchemy.sql.compiler.SQLCompiler
    "sqlalchemy.sql.compiler.SQLCompiler") 的一部分，它现在可以选择性地为语句发出警告，如果检测到这种条件。通过使用 [`create_engine.enable_from_linting`](../core/engines.html#sqlalchemy.create_engine.params.enable_from_linting
    "sqlalchemy.create_engine") 标志启用警告，默认情况下启用警告。检查程序的计算开销非常低，而且它只在语句编译期间发生，这意味着对于缓存的
    SQL 语句，它只发生一次。
- en: 'Using this feature, our ORM query above will emit a warning:'
  id: totrans-1158
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此功能，我们上面的 ORM 查询将发出警告：
- en: '[PRE254]'
  id: totrans-1159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE254]'
- en: 'The linter feature accommodates not just for tables linked together through
    the JOIN clauses but also through the WHERE clause Above, we can add a WHERE clause
    to link the new `Address` entity with the previous `address_alias` entity and
    that will remove the warning:'
  id: totrans-1160
  prefs: []
  type: TYPE_NORMAL
  zh: 检查程序功能不仅适用于通过 JOIN 子句连接在一起的表，还适用于通过 WHERE 子句上述，我们可以添加一个 WHERE 子句来将新的 `Address`
    实体与以前的 `address_alias` 实体链接起来，这将消除警告：
- en: '[PRE255]'
  id: totrans-1161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE255]'
- en: 'The cartesian product warning considers **any** kind of link between two FROM
    clauses to be a resolution, even if the end result set is still wasteful, as the
    linter is intended only to detect the common case of a FROM clause that is completely
    unexpected. If the FROM clause is referred to explicitly elsewhere and linked
    to the other FROMs, no warning is emitted:'
  id: totrans-1162
  prefs: []
  type: TYPE_NORMAL
  zh: 笛卡尔积警告将 **任何** 类型的两个 FROM 子句之间的任何链接都视为解析，即使最终结果集仍然是浪费的，因为检查程序旨在仅检测完全意外的 FROM
    子句的常见情况。如果 FROM 子句在其他地方明确引用并链接到其他 FROM，就不会发出警告：
- en: '[PRE256]'
  id: totrans-1163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE256]'
- en: 'Full cartesian products are also allowed if they are explicitly stated; if
    we wanted for example the cartesian product of `User` and `Address`, we can JOIN
    on [`true()`](../core/sqlelement.html#sqlalchemy.sql.expression.true "sqlalchemy.sql.expression.true")
    so that every row will match with every other; the following query will return
    all rows and produce no warnings:'
  id: totrans-1164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果明确指定，也可以允许完全的笛卡尔积；例如，如果我们想要 `User` 和 `Address` 的笛卡尔积，我们可以在 [`true()`](../core/sqlelement.html#sqlalchemy.sql.expression.true
    "sqlalchemy.sql.expression.true") 上进行 JOIN，以便每一行都与其他行匹配；以下查询将返回所有行并且不会产生警告：
- en: '[PRE257]'
  id: totrans-1165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE257]'
- en: 'The warning is only generated by default when the statement is compiled by
    the [`Connection`](../core/connections.html#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    for execution; calling the [`ClauseElement.compile()`](../core/foundation.html#sqlalchemy.sql.expression.ClauseElement.compile
    "sqlalchemy.sql.expression.ClauseElement.compile") method will not emit a warning
    unless the linting flag is supplied:'
  id: totrans-1166
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，只有当语句由 [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") 编译执行时才会生成警告；调用 [`ClauseElement.compile()`](../core/foundation.html#sqlalchemy.sql.expression.ClauseElement.compile
    "sqlalchemy.sql.expression.ClauseElement.compile") 方法不会发出警告，除非提供了检查标志：
- en: '[PRE258]'
  id: totrans-1167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE258]'
- en: '[#4737](https://www.sqlalchemy.org/trac/ticket/4737)'
  id: totrans-1168
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4737](https://www.sqlalchemy.org/trac/ticket/4737)'
- en: '### New Result object'
  id: totrans-1169
  prefs: []
  type: TYPE_NORMAL
  zh: '### 新的 Result 对象'
- en: A major goal of SQLAlchemy 2.0 is to unify how “results” are handled between
    the ORM and Core. Towards this goal, version 1.4 introduces new versions of both
    the `ResultProxy` and `RowProxy` objects that have been part of SQLAlchemy since
    the beginning.
  id: totrans-1170
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 2.0 的一个主要目标是统一 ORM 和 Core 之间如何处理 “结果”。为实现此目标，版本 1.4 引入了自从 SQLAlchemy
    开始就存在的 `ResultProxy` 和 `RowProxy` 对象的新版本。
- en: The new objects are documented at [`Result`](../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") and [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row"), and are used not only for Core result sets but for [2.0
    style](../glossary.html#term-2.0-style) results within the ORM as well.
  id: totrans-1171
  prefs: []
  type: TYPE_NORMAL
  zh: 新对象在[`Result`](../core/connections.html#sqlalchemy.engine.Result "sqlalchemy.engine.Result")和[`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row")中有文档记录，并且不仅用于核心结果集，还用于ORM中的[2.0风格](../glossary.html#term-2.0-style)结果。
- en: 'This result object is fully compatible with `ResultProxy` and includes many
    new features, that are now applied to both Core and ORM results equally, including
    methods such as:'
  id: totrans-1172
  prefs: []
  type: TYPE_NORMAL
  zh: 此结果对象与`ResultProxy`完全兼容，并包含许多新功能，现在同样适用于核心和ORM结果，包括方法如：
- en: '[`Result.one()`](../core/connections.html#sqlalchemy.engine.Result.one "sqlalchemy.engine.Result.one")
    - returns exactly a single row, or raises:'
  id: totrans-1173
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Result.one()`](../core/connections.html#sqlalchemy.engine.Result.one "sqlalchemy.engine.Result.one")
    - 返回确切的单行，或引发异常：'
- en: '[PRE259]'
  id: totrans-1174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE259]'
- en: '[`Result.one_or_none()`](../core/connections.html#sqlalchemy.engine.Result.one_or_none
    "sqlalchemy.engine.Result.one_or_none") - same, but also returns None for no rows'
  id: totrans-1175
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Result.one_or_none()`](../core/connections.html#sqlalchemy.engine.Result.one_or_none
    "sqlalchemy.engine.Result.one_or_none") - 相同，但对于没有行的情况也返回None'
- en: '[`Result.all()`](../core/connections.html#sqlalchemy.engine.Result.all "sqlalchemy.engine.Result.all")
    - returns all rows'
  id: totrans-1176
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Result.all()`](../core/connections.html#sqlalchemy.engine.Result.all "sqlalchemy.engine.Result.all")
    - 返回所有行'
- en: '[`Result.partitions()`](../core/connections.html#sqlalchemy.engine.Result.partitions
    "sqlalchemy.engine.Result.partitions") - fetches rows in chunks:'
  id: totrans-1177
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Result.partitions()`](../core/connections.html#sqlalchemy.engine.Result.partitions
    "sqlalchemy.engine.Result.partitions") - 按块获取行：'
- en: '[PRE260]'
  id: totrans-1178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE260]'
- en: '[`Result.columns()`](../core/connections.html#sqlalchemy.engine.Result.columns
    "sqlalchemy.engine.Result.columns") - allows slicing and reorganizing of rows:'
  id: totrans-1179
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Result.columns()`](../core/connections.html#sqlalchemy.engine.Result.columns
    "sqlalchemy.engine.Result.columns") - 允许对行进行切片和重新组织：'
- en: '[PRE261]'
  id: totrans-1180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE261]'
- en: '[`Result.scalars()`](../core/connections.html#sqlalchemy.engine.Result.scalars
    "sqlalchemy.engine.Result.scalars") - returns lists of scalar objects, from the
    first column by default but can also be selected:'
  id: totrans-1181
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Result.scalars()`](../core/connections.html#sqlalchemy.engine.Result.scalars
    "sqlalchemy.engine.Result.scalars") - 返回标量对象的列表，默认情况下从第一列开始，但也可以选择：'
- en: '[PRE262]'
  id: totrans-1182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE262]'
- en: '[`Result.mappings()`](../core/connections.html#sqlalchemy.engine.Result.mappings
    "sqlalchemy.engine.Result.mappings") - instead of named-tuple rows, returns dictionaries:'
  id: totrans-1183
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Result.mappings()`](../core/connections.html#sqlalchemy.engine.Result.mappings
    "sqlalchemy.engine.Result.mappings") - 返回字典而不是命名元组行：'
- en: '[PRE263]'
  id: totrans-1184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE263]'
- en: When using Core, the object returned by [`Connection.execute()`](../core/connections.html#sqlalchemy.engine.Connection.execute
    "sqlalchemy.engine.Connection.execute") is an instance of [`CursorResult`](../core/connections.html#sqlalchemy.engine.CursorResult
    "sqlalchemy.engine.CursorResult"), which continues to feature the same API features
    as `ResultProxy` regarding inserted primary keys, defaults, rowcounts, etc. For
    ORM, a [`Result`](../core/connections.html#sqlalchemy.engine.Result "sqlalchemy.engine.Result")
    subclass will be returned that performs translation of Core rows into ORM rows,
    and then allows all the same operations to take place.
  id: totrans-1185
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用核心时，由[`Connection.execute()`](../core/connections.html#sqlalchemy.engine.Connection.execute
    "sqlalchemy.engine.Connection.execute")返回的对象是[`CursorResult`](../core/connections.html#sqlalchemy.engine.CursorResult
    "sqlalchemy.engine.CursorResult")的一个实例，它继续具有与`ResultProxy`相同的API功能，关于插入的主键、默认值、行数等。对于ORM，将返回一个执行将核心行转换为ORM行的[`Result`](../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result")子类，然后允许进行所有相同的操作。
- en: See also
  id: totrans-1186
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[ORM Query Unified with Core Select](migration_20.html#migration-20-unify-select)
    - in the 2.0 migration documentation'
  id: totrans-1187
  prefs: []
  type: TYPE_NORMAL
  zh: '[ORM 查询与核心选择统一](migration_20.html#migration-20-unify-select) - 在2.0迁移文档中'
- en: '[#5087](https://www.sqlalchemy.org/trac/ticket/5087)'
  id: totrans-1188
  prefs: []
  type: TYPE_NORMAL
  zh: '[#5087](https://www.sqlalchemy.org/trac/ticket/5087)'
- en: '[#4395](https://www.sqlalchemy.org/trac/ticket/4395)'
  id: totrans-1189
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4395](https://www.sqlalchemy.org/trac/ticket/4395)'
- en: '[#4959](https://www.sqlalchemy.org/trac/ticket/4959)'
  id: totrans-1190
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4959](https://www.sqlalchemy.org/trac/ticket/4959)'
- en: '### RowProxy is no longer a “proxy”; is now called Row and behaves like an
    enhanced named tuple'
  id: totrans-1191
  prefs: []
  type: TYPE_NORMAL
  zh: '### RowProxy不再是“代理”；现在称为Row，并且行为类似于增强的命名元组'
- en: The `RowProxy` class, which represents individual database result rows in a
    Core result set, is now called [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") and is no longer a “proxy” object; what this means is
    that when the [`Row`](../core/connections.html#sqlalchemy.engine.Row "sqlalchemy.engine.Row")
    object is returned, the row is a simple tuple that contains the data in its final
    form, already having been processed by result-row handling functions associated
    with datatypes (examples include turning a date string from the database into
    a `datetime` object, a JSON string into a Python `json.loads()` result, etc.).
  id: totrans-1192
  prefs: []
  type: TYPE_NORMAL
  zh: '`RowProxy`类，表示Core结果集中的单个数据库结果行，现在称为[`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row")，不再是“代理”对象；这意味着当返回[`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row")对象时，行是一个简单的元组，其中包含数据的最终形式，已经通过与数据类型相关联的结果行处理函数处理过（示例包括将数据库中的日期字符串转换为`datetime`对象、将JSON字符串转换为Python的`json.loads()`结果等）。'
- en: The immediate rationale for this is so that the row can act more like a Python
    named tuple, rather than a mapping, where the values in the tuple are the subject
    of the `__contains__` operator on the tuple, rather than the keys. With [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") acting like a named tuple, it is then suitable for use
    as as replacement for the ORM’s `KeyedTuple` object, leading to an eventual API
    where both the ORM and Core deliver result sets that behave identically. Unification
    of major patterns within ORM and Core is a major goal of SQLAlchemy 2.0, and release
    1.4 aims to have most or all of the underlying architectural patterns in place
    in order to support this process. The note in [The “KeyedTuple” object returned
    by Query is replaced by Row](#change-4710-orm) describes the ORM’s use of the
    [`Row`](../core/connections.html#sqlalchemy.engine.Row "sqlalchemy.engine.Row")
    class.
  id: totrans-1193
  prefs: []
  type: TYPE_NORMAL
  zh: 该操作的直接理由是，使行更像Python中的命名元组，而不是映射，其中元组中的值是元组上的`__contains__`运算符的主题，而不是键。使用[`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row")作为命名元组，然后适用于替换ORM的`KeyedTuple`对象，从而导致最终的API，其中ORM和Core提供的结果集行为相同。统一ORM和Core中的主要模式是SQLAlchemy
    2.0的主要目标，而1.4版本旨在具有大部分或全部基础架构模式，以支持此过程。 [查询返回的“KeyedTuple”对象由Row替换](#change-4710-orm)中的说明描述了ORM对[`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row")类的使用。
- en: For release 1.4, the [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") class provides an additional subclass `LegacyRow`, which
    is used by Core and provides a backwards-compatible version of `RowProxy` while
    emitting deprecation warnings for those API features and behaviors that will be
    moved. ORM [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    now makes use of [`Row`](../core/connections.html#sqlalchemy.engine.Row "sqlalchemy.engine.Row")
    directly as a replacement for `KeyedTuple`.
  id: totrans-1194
  prefs: []
  type: TYPE_NORMAL
  zh: 对于1.4版本，[`Row`](../core/connections.html#sqlalchemy.engine.Row "sqlalchemy.engine.Row")类提供了一个额外的子类`LegacyRow`，它由Core使用，并提供了`RowProxy`的向后兼容版本，同时对那些将被移动的API功能和行为发出弃用警告。ORM
    [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")现在直接使用[`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row")作为`KeyedTuple`的替代品。
- en: The `LegacyRow` class is a transitional class where the `__contains__` method
    is still testing against the keys, not the values, while emitting a deprecation
    warning when the operation succeeds. Additionally, all the other mapping-like
    methods on the previous `RowProxy` are deprecated, including `LegacyRow.keys()`,
    `LegacyRow.items()`, etc. For mapping-like behaviors from a [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") object, including support for these methods as well as
    a key-oriented `__contains__` operator, the API going forward will be to first
    access a special attribute [`Row._mapping`](../core/connections.html#sqlalchemy.engine.Row._mapping
    "sqlalchemy.engine.Row._mapping"), which will then provide a complete mapping
    interface to the row, rather than a tuple interface.
  id: totrans-1195
  prefs: []
  type: TYPE_NORMAL
  zh: '`LegacyRow`类是一个过渡类，其中`__contains__`方法仍然针对键而不是值进行测试，当操作成功时发出弃用警告。此外，以前的`RowProxy`上的所有其他类似映射的方法也已弃用，包括`LegacyRow.keys()`、`LegacyRow.items()`等。为了从[`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row")对象获取类似映射的行为，包括对这些方法的支持以及面向键的`__contains__`操作，未来的API将首先访问特殊属性[`Row._mapping`](../core/connections.html#sqlalchemy.engine.Row._mapping
    "sqlalchemy.engine.Row._mapping")，然后提供完整的映射接口以访问行，而不是元组接口。'
- en: 'Rationale: To behave more like a named tuple rather than a mapping'
  id: totrans-1196
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 理念：表现得更像一个命名元组而不是一个映射
- en: 'The difference between a named tuple and a mapping as far as boolean operators
    can be summarized. Given a “named tuple” in pseudo code as:'
  id: totrans-1197
  prefs: []
  type: TYPE_NORMAL
  zh: 就布尔运算符而言，命名元组和映射之间的区别可以总结如下。假设伪代码中有一个“命名元组”：
- en: '[PRE264]'
  id: totrans-1198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE264]'
- en: 'The biggest cross-incompatible difference is the behavior of `__contains__`:'
  id: totrans-1199
  prefs: []
  type: TYPE_NORMAL
  zh: 最大的不兼容差异是`__contains__`的行为：
- en: '[PRE265]'
  id: totrans-1200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE265]'
- en: 'In 1.4, when a `LegacyRow` is returned by a Core result set, the above `"id"
    in row` comparison will continue to succeed, however a deprecation warning will
    be emitted. To use the “in” operator as a mapping, use the [`Row._mapping`](../core/connections.html#sqlalchemy.engine.Row._mapping
    "sqlalchemy.engine.Row._mapping") attribute:'
  id: totrans-1201
  prefs: []
  type: TYPE_NORMAL
  zh: 在1.4版本中，当核心结果集返回一个`LegacyRow`时，上述`"id" in row`比较将继续成功，但会发出弃用警告。要将“in”运算符用作映射，请使用[`Row._mapping`](../core/connections.html#sqlalchemy.engine.Row._mapping
    "sqlalchemy.engine.Row._mapping")属性：
- en: '[PRE266]'
  id: totrans-1202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE266]'
- en: 'SQLAlchemy 2.0’s result object will feature a `.mappings()` modifier so that
    these mappings can be received directly:'
  id: totrans-1203
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 2.0的结果对象将具有`.mappings()`修饰符，以便可以直接接收这些映射：
- en: '[PRE267]'
  id: totrans-1204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE267]'
- en: Proxying behavior goes away, was also unnecessary in modern usage
  id: totrans-1205
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 代理行为消失，也在现代用法中是不必要的
- en: 'The refactor of [`Row`](../core/connections.html#sqlalchemy.engine.Row "sqlalchemy.engine.Row")
    to behave like a tuple requires that all data values be fully available up front.
    This is an internal behavior change from that of `RowProxy`, where result-row
    processing functions would be invoked at the point of accessing an element of
    the row, instead of when the row was first fetched. This means for example when
    retrieving a datetime value from SQLite, the data for the row as present in the
    `RowProxy` object would previously have looked like:'
  id: totrans-1206
  prefs: []
  type: TYPE_NORMAL
  zh: 将[`Row`](../core/connections.html#sqlalchemy.engine.Row "sqlalchemy.engine.Row")重构为像元组一样的行需要所有数据值一开始就完全可用。这是从`RowProxy`的内部行为变化，其中结果行处理函数将在访问行的元素时调用，而不是在首次获取行时调用。这意味着例如从SQLite检索日期时间值时，以前在`RowProxy`对象中的行数据看起来像：
- en: '[PRE268]'
  id: totrans-1207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE268]'
- en: 'and then upon access via `__getitem__`, the `datetime.strptime()` function
    would be used on the fly to convert the above string date into a `datetime` object.
    With the new architecture, the `datetime()` object is present in the tuple when
    it is returned, the `datetime.strptime()` function having been called just once
    up front:'
  id: totrans-1208
  prefs: []
  type: TYPE_NORMAL
  zh: 然后通过`__getitem__`访问时，将实时使用`datetime.strptime()`函数将上述字符串日期转换为`datetime`对象。通过新的架构，当返回元组时，`datetime()`对象已经存在于其中，`datetime.strptime()`函数只被调用了一次：
- en: '[PRE269]'
  id: totrans-1209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE269]'
- en: The `RowProxy` and [`Row`](../core/connections.html#sqlalchemy.engine.Row "sqlalchemy.engine.Row")
    objects in SQLAlchemy are where the majority of SQLAlchemy’s C extension code
    takes place. This code has been highly refactored to provide the new behavior
    in an efficient manner, and overall performance has been improved as the design
    of [`Row`](../core/connections.html#sqlalchemy.engine.Row "sqlalchemy.engine.Row")
    is now considerably simpler.
  id: totrans-1210
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy中的`RowProxy`和[`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row")对象是大部分SQLAlchemy C扩展代码的位置。这段代码已经进行了高度重构，以有效地提供新的行为，并且由于[`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row")的设计现在相当简单，因此整体性能得到了改善。
- en: The rationale behind the previous behavior assumed a usage model where a result
    row might have dozens or hundreds of columns present, where most of those columns
    would not be accessed, and for which a majority of those columns would require
    some result-value processing function. By invoking the processing function only
    when needed, the goal was that lots of result processing functions would not be
    necessary, thus increasing performance.
  id: totrans-1211
  prefs: []
  type: TYPE_NORMAL
  zh: 之前行为背后的理念假定了一个使用模型，其中一个结果行可能有几十个或几百个列，其中大多数列不会被访问，并且其中大多数列需要一些结果值处理函数。通过仅在需要时调用处理函数，目标是不需要大量的结果处理函数，从而提高性能。
- en: 'There are many reasons why the above assumptions do not hold:'
  id: totrans-1212
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多原因导致上述假设不成立：
- en: the vast majority of row-processing functions called were to Unicode decode
    a bytestring into a Python Unicode string under Python 2\. This was right as Python
    Unicode was beginning to see use and before Python 3 existed. Once Python 3 was
    introduced, within a few years, all Python DBAPIs took on the proper role of supporting
    the delivering of Python Unicode objects directly, under both Python 2 and Python
    3, as an option in the former case and as the only way forward in the latter case.
    Eventually, in most cases it became the default for Python 2 as well. SQLAlchemy’s
    Python 2 support still enables explicit string-to-Unicode conversion for some
    DBAPIs such as cx_Oracle, however it is now performed at the DBAPI level rather
    than as a standard SQLAlchemy result row processing function.
  id: totrans-1213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用的绝大多数行处理函数是将字节串解码为 Python Unicode 字符串在 Python 2 下。这是因为 Python Unicode 开始被使用，而
    Python 3 之前存在。一旦引入了 Python 3，在几年内，所有 Python DBAPI 都承担了支持直接传递 Python Unicode 对象的正确角色，在
    Python 2 和 Python 3 下，前者是一个选项，在后者是唯一的前进方式。最终，在大多数情况下，它也成为了 Python 2 的默认值。SQLAlchemy
    的 Python 2 支持仍然允许对一些 DBAPI（如 cx_Oracle）进行显式的字符串转换为 Unicode，但现在是在 DBAPI 级别执行，而不是作为标准的
    SQLAlchemy 结果行处理函数。
- en: The above string conversion, when it is used, was made to be extremely performant
    via the C extensions, so much so that even in 1.4, SQLAlchemy’s byte-to-Unicode
    codec hook is plugged into cx_Oracle where it has been observed to be more performant
    than cx_Oracle’s own hook; this meant that the overhead for converting all strings
    in a row was not as significant as it originally was in any case.
  id: totrans-1214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上述字符串转换在使用时通过 C 扩展被设计得非常高效，以至于即使在 1.4 版本中，SQLAlchemy 的字节到 Unicode 编解码钩子被插入到
    cx_Oracle 中，据观察，它比 cx_Oracle 自己的钩子更高效；这意味着在任何情况下，转换所有���符串的开销不再像最初那样显著。
- en: Row processing functions are not used in most other cases; the exceptions are
    SQLite’s datetime support, JSON support for some backends, some numeric handlers
    such as string to `Decimal`. In the case of `Decimal`, Python 3 also standardized
    on the highly performant `cdecimal` implementation, which is not the case in Python
    2 which continues to use the much less performant pure Python version.
  id: totrans-1215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 行处理函数在大多数其他情况下不被使用；例外情况包括 SQLite 的日期时间支持，一些后端的 JSON 支持，一些数值处理程序，如字符串到`Decimal`。在`Decimal`的情况下，Python
    3 也标准化了高性能的`cdecimal`实现，而在 Python 2 中则继续使用性能较低的纯 Python 版本。
- en: Fetching full rows where only a few columns are needed is not common within
    real-world use cases In the early days of SQLAlchemy, database code from other
    languages of the form “row = fetch(‘SELECT * FROM table’)” was common; using SQLAlchemy’s
    expression language however, code observed in the wild typically makes use of
    the specific columns needed.
  id: totrans-1216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在真实世界的用例中，很少有需要获取完整行而只需要几列的情况。在 SQLAlchemy 的早期，来自其他语言的数据库代码形式“row = fetch(‘SELECT
    * FROM table’)”很常见；然而，使用 SQLAlchemy 的表达式语言，实际观察到的代码通常只使用所需的特定列。
- en: See also
  id: totrans-1217
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[The “KeyedTuple” object returned by Query is replaced by Row](#change-4710-orm)'
  id: totrans-1218
  prefs: []
  type: TYPE_NORMAL
  zh: '[Query 返回的“KeyedTuple”对象被 Row 替换](#change-4710-orm)'
- en: '[ORM Session.execute() uses “future” style Result sets in all cases](#change-session-execute-result)'
  id: totrans-1219
  prefs: []
  type: TYPE_NORMAL
  zh: '[ORM Session.execute() 在所有情况下使用“future”风格的结果集](#change-session-execute-result)'
- en: '[#4710](https://www.sqlalchemy.org/trac/ticket/4710)'
  id: totrans-1220
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4710](https://www.sqlalchemy.org/trac/ticket/4710)'
- en: 'Rationale: To behave more like a named tuple rather than a mapping'
  id: totrans-1221
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 理由：为了更像一个命名元组而不是一个映射
- en: 'The difference between a named tuple and a mapping as far as boolean operators
    can be summarized. Given a “named tuple” in pseudo code as:'
  id: totrans-1222
  prefs: []
  type: TYPE_NORMAL
  zh: 命名元组和映射之间在布尔运算方面的区别可以总结如下。给定一个伪代码中的“命名元组”：
- en: '[PRE270]'
  id: totrans-1223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE270]'
- en: 'The biggest cross-incompatible difference is the behavior of `__contains__`:'
  id: totrans-1224
  prefs: []
  type: TYPE_NORMAL
  zh: 最大的跨不兼容差异是`__contains__`的行为：
- en: '[PRE271]'
  id: totrans-1225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE271]'
- en: 'In 1.4, when a `LegacyRow` is returned by a Core result set, the above `"id"
    in row` comparison will continue to succeed, however a deprecation warning will
    be emitted. To use the “in” operator as a mapping, use the [`Row._mapping`](../core/connections.html#sqlalchemy.engine.Row._mapping
    "sqlalchemy.engine.Row._mapping") attribute:'
  id: totrans-1226
  prefs: []
  type: TYPE_NORMAL
  zh: 在 1.4 版本中，当核心结果集返回一个`LegacyRow`时，上述的`"id" in row`比较仍然会成功，但会发出一个弃用警告。要将“in”运算符用作映射，请使用[`Row._mapping`](../core/connections.html#sqlalchemy.engine.Row._mapping
    "sqlalchemy.engine.Row._mapping")属性：
- en: '[PRE272]'
  id: totrans-1227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE272]'
- en: 'SQLAlchemy 2.0’s result object will feature a `.mappings()` modifier so that
    these mappings can be received directly:'
  id: totrans-1228
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 2.0 的结果对象将具有`.mappings()`修饰符，以便可以直接接收这些映射：
- en: '[PRE273]'
  id: totrans-1229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE273]'
- en: Proxying behavior goes away, was also unnecessary in modern usage
  id: totrans-1230
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 代理行为消失，对于现代用法也是不必要的
- en: 'The refactor of [`Row`](../core/connections.html#sqlalchemy.engine.Row "sqlalchemy.engine.Row")
    to behave like a tuple requires that all data values be fully available up front.
    This is an internal behavior change from that of `RowProxy`, where result-row
    processing functions would be invoked at the point of accessing an element of
    the row, instead of when the row was first fetched. This means for example when
    retrieving a datetime value from SQLite, the data for the row as present in the
    `RowProxy` object would previously have looked like:'
  id: totrans-1231
  prefs: []
  type: TYPE_NORMAL
  zh: 对[`Row`](../core/connections.html#sqlalchemy.engine.Row "sqlalchemy.engine.Row")进行重构，使其像元组一样行为需要所有数据值在一开始就完全可用。这是与`RowProxy`的内部行为变化相对应的，其中结果行处理函数会在访问行的元素时被调用，而不是在首次获取行时。这意味着例如从SQLite检索datetime值时，`RowProxy`对象中的数据以前看起来是这样的：
- en: '[PRE274]'
  id: totrans-1232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE274]'
- en: 'and then upon access via `__getitem__`, the `datetime.strptime()` function
    would be used on the fly to convert the above string date into a `datetime` object.
    With the new architecture, the `datetime()` object is present in the tuple when
    it is returned, the `datetime.strptime()` function having been called just once
    up front:'
  id: totrans-1233
  prefs: []
  type: TYPE_NORMAL
  zh: 然后通过`__getitem__`访问时，将动态使用`datetime.strptime()`函数将上述字符串日期转换为`datetime`对象。通过新的架构，当元组返回时，`datetime()`对象已经存在于其中，`datetime.strptime()`函数仅在一开始被调用了一次：
- en: '[PRE275]'
  id: totrans-1234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE275]'
- en: The `RowProxy` and [`Row`](../core/connections.html#sqlalchemy.engine.Row "sqlalchemy.engine.Row")
    objects in SQLAlchemy are where the majority of SQLAlchemy’s C extension code
    takes place. This code has been highly refactored to provide the new behavior
    in an efficient manner, and overall performance has been improved as the design
    of [`Row`](../core/connections.html#sqlalchemy.engine.Row "sqlalchemy.engine.Row")
    is now considerably simpler.
  id: totrans-1235
  prefs: []
  type: TYPE_NORMAL
  zh: 在SQLAlchemy中，`RowProxy`和[`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row")对象是大部分SQLAlchemy C扩展代码的主要位置。此代码已进行了大量重构，以有效地提供新的行为，并且由于[`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row")的设计现在明显更简单，因此总体性能已得到提高。
- en: The rationale behind the previous behavior assumed a usage model where a result
    row might have dozens or hundreds of columns present, where most of those columns
    would not be accessed, and for which a majority of those columns would require
    some result-value processing function. By invoking the processing function only
    when needed, the goal was that lots of result processing functions would not be
    necessary, thus increasing performance.
  id: totrans-1236
  prefs: []
  type: TYPE_NORMAL
  zh: 先前行为的背后逻辑假定了一个使用模型，在这个模型中，结果行可能会有几十个甚至几百个列存在，其中大多数列不会被访问，并且其中大多数列需要某种结果值处理函数。通过仅在需要时调用处理函数，目标是不需要太多的结果处理函数，从而提高性能。
- en: 'There are many reasons why the above assumptions do not hold:'
  id: totrans-1237
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多原因导致上述假设不成立：
- en: the vast majority of row-processing functions called were to Unicode decode
    a bytestring into a Python Unicode string under Python 2\. This was right as Python
    Unicode was beginning to see use and before Python 3 existed. Once Python 3 was
    introduced, within a few years, all Python DBAPIs took on the proper role of supporting
    the delivering of Python Unicode objects directly, under both Python 2 and Python
    3, as an option in the former case and as the only way forward in the latter case.
    Eventually, in most cases it became the default for Python 2 as well. SQLAlchemy’s
    Python 2 support still enables explicit string-to-Unicode conversion for some
    DBAPIs such as cx_Oracle, however it is now performed at the DBAPI level rather
    than as a standard SQLAlchemy result row processing function.
  id: totrans-1238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用的绝大多数行处理函数是将字节字符串解码为Python Unicode字符串。这是在Python Unicode开始使用并且Python 3存在之前的情况。一旦Python
    3被引入，几年后，所有Python DBAPI都承担起直接支持交付Python Unicode对象的正确角色，在Python 2和Python 3下，前者是一个选项，而后者则是唯一的前进方式。最终，在大多数情况下，它也成为了Python
    2的默认选项。SQLAlchemy的Python 2支持仍然可以为某些DBAPI（如cx_Oracle）执行显式的字符串到Unicode转换，但现在是在DBAPI级别执行，而不是作为标准的SQLAlchemy结果行处理函数。
- en: The above string conversion, when it is used, was made to be extremely performant
    via the C extensions, so much so that even in 1.4, SQLAlchemy’s byte-to-Unicode
    codec hook is plugged into cx_Oracle where it has been observed to be more performant
    than cx_Oracle’s own hook; this meant that the overhead for converting all strings
    in a row was not as significant as it originally was in any case.
  id: totrans-1239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上述字符串转换在使用时，通过C扩展实现了极高的性能，以至于甚至在1.4版本中，SQLAlchemy的字节到Unicode编解码器钩子被插入了cx_Oracle中，在这种情况下，它被观察到比cx_Oracle自己的钩子更具性能；这意味着在任何情况下，转换行中的所有字符串的开销都不像最初那样显著。
- en: Row processing functions are not used in most other cases; the exceptions are
    SQLite’s datetime support, JSON support for some backends, some numeric handlers
    such as string to `Decimal`. In the case of `Decimal`, Python 3 also standardized
    on the highly performant `cdecimal` implementation, which is not the case in Python
    2 which continues to use the much less performant pure Python version.
  id: totrans-1240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 大多数情况下不使用行处理函数；例外情况包括SQLite的日期时间支持，一些后端的JSON支持，一些数值处理程序，如字符串转换为`Decimal`。在`Decimal`的情况下，Python
    3还规范化了高性能的`cdecimal`实现，而在Python 2中并非如此，它继续使用性能远低于`cdecimal`的纯Python版本。
- en: Fetching full rows where only a few columns are needed is not common within
    real-world use cases In the early days of SQLAlchemy, database code from other
    languages of the form “row = fetch(‘SELECT * FROM table’)” was common; using SQLAlchemy’s
    expression language however, code observed in the wild typically makes use of
    the specific columns needed.
  id: totrans-1241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在真实世界的使用案例中，很少会出现仅需要几列的完整行抓取。在SQLAlchemy的早期，来自其他语言的数据库代码形式“row = fetch(‘SELECT
    * FROM table’)”很常见；然而，使用SQLAlchemy的表达式语言，观察到的实际代码通常只使用所需的特定列。
- en: See also
  id: totrans-1242
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[The “KeyedTuple” object returned by Query is replaced by Row](#change-4710-orm)'
  id: totrans-1243
  prefs: []
  type: TYPE_NORMAL
  zh: '[查询返回的“KeyedTuple”对象被“Row”替换](#change-4710-orm)'
- en: '[ORM Session.execute() uses “future” style Result sets in all cases](#change-session-execute-result)'
  id: totrans-1244
  prefs: []
  type: TYPE_NORMAL
  zh: '[ORM Session.execute() 在所有情况下使用“future”风格的结果集](#change-session-execute-result)'
- en: '[#4710](https://www.sqlalchemy.org/trac/ticket/4710)'
  id: totrans-1245
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4710](https://www.sqlalchemy.org/trac/ticket/4710)'
- en: '### SELECT objects and derived FROM clauses allow for duplicate columns and
    column labels'
  id: totrans-1246
  prefs: []
  type: TYPE_NORMAL
  zh: '### SELECT对象和派生的FROM子句允许重复的列和列标签'
- en: 'This change allows that the [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") construct now allows for duplicate column
    labels as well as duplicate column objects themselves, so that result tuples are
    organized and ordered in the identical way in that the columns were selected.
    The ORM [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    already works this way, so this change allows for greater cross-compatibility
    between the two, which is a key goal of the 2.0 transition:'
  id: totrans-1247
  prefs: []
  type: TYPE_NORMAL
  zh: 此更改允许[`select()`](../core/selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select")构造现在允许重复的列标签以及重复的列对象本身，以便结果元组按照选择列的相同方式组织和排序。ORM
    [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")已经以这种方式工作，因此此更改允许更大程度上的跨两者的兼容性，这是2.0转换的关键目标之一：
- en: '[PRE276]'
  id: totrans-1248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE276]'
- en: 'To support this change, the [`ColumnCollection`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnCollection
    "sqlalchemy.sql.expression.ColumnCollection") used by [`SelectBase`](../core/selectable.html#sqlalchemy.sql.expression.SelectBase
    "sqlalchemy.sql.expression.SelectBase") as well as for derived FROM clauses such
    as subqueries also support duplicate columns; this includes the new [`SelectBase.selected_columns`](../core/selectable.html#sqlalchemy.sql.expression.SelectBase.selected_columns
    "sqlalchemy.sql.expression.SelectBase.selected_columns") attribute, the deprecated
    `SelectBase.c` attribute, as well as the [`FromClause.c`](../core/selectable.html#sqlalchemy.sql.expression.FromClause.c
    "sqlalchemy.sql.expression.FromClause.c") attribute seen on constructs such as
    [`Subquery`](../core/selectable.html#sqlalchemy.sql.expression.Subquery "sqlalchemy.sql.expression.Subquery")
    and [`Alias`](../core/selectable.html#sqlalchemy.sql.expression.Alias "sqlalchemy.sql.expression.Alias"):'
  id: totrans-1249
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持这一更改，[`ColumnCollection`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnCollection
    "sqlalchemy.sql.expression.ColumnCollection") 由 [`SelectBase`](../core/selectable.html#sqlalchemy.sql.expression.SelectBase
    "sqlalchemy.sql.expression.SelectBase") 使用，以及用于派生 FROM 子句的情况，例如子查询，也支持重复列；这包括新的
    [`SelectBase.selected_columns`](../core/selectable.html#sqlalchemy.sql.expression.SelectBase.selected_columns
    "sqlalchemy.sql.expression.SelectBase.selected_columns") 属性，已弃用的 `SelectBase.c`
    属性，以及在构造中看到的 [`FromClause.c`](../core/selectable.html#sqlalchemy.sql.expression.FromClause.c
    "sqlalchemy.sql.expression.FromClause.c") 属性，例如 [`Subquery`](../core/selectable.html#sqlalchemy.sql.expression.Subquery
    "sqlalchemy.sql.expression.Subquery") 和 [`Alias`](../core/selectable.html#sqlalchemy.sql.expression.Alias
    "sqlalchemy.sql.expression.Alias")：
- en: '[PRE277]'
  id: totrans-1250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE277]'
- en: '[`ColumnCollection`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnCollection
    "sqlalchemy.sql.expression.ColumnCollection") also allows access by integer index
    to support when the string “key” is ambiguous:'
  id: totrans-1251
  prefs: []
  type: TYPE_NORMAL
  zh: '[`ColumnCollection`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnCollection
    "sqlalchemy.sql.expression.ColumnCollection") 还允许通过整数索引访问，以支持字符串 “key” 不明确时的情况：'
- en: '[PRE278]'
  id: totrans-1252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE278]'
- en: To suit the use of [`ColumnCollection`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnCollection
    "sqlalchemy.sql.expression.ColumnCollection") in objects such as [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") and [`PrimaryKeyConstraint`](../core/constraints.html#sqlalchemy.schema.PrimaryKeyConstraint
    "sqlalchemy.schema.PrimaryKeyConstraint"), the old “deduplicating” behavior which
    is more critical for these objects is preserved in a new class `DedupeColumnCollection`.
  id: totrans-1253
  prefs: []
  type: TYPE_NORMAL
  zh: 为了适应 [`ColumnCollection`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnCollection
    "sqlalchemy.sql.expression.ColumnCollection") 在对象（例如 [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") 和 [`PrimaryKeyConstraint`](../core/constraints.html#sqlalchemy.schema.PrimaryKeyConstraint
    "sqlalchemy.schema.PrimaryKeyConstraint")）中的使用，保留了更适用于这些对象的旧的 “去重” 行为，并将其放在一个新的类
    `DedupeColumnCollection` 中。
- en: 'The change includes that the familiar warning `"Column %r on table %r being
    replaced by %r, which has the same key.  Consider use_labels for select() statements."`
    is **removed**; the `Select.apply_labels()` is still available and is still used
    by the ORM for all SELECT operations, however it does not imply deduplication
    of column objects, although it does imply deduplication of implicitly generated
    labels:'
  id: totrans-1254
  prefs: []
  type: TYPE_NORMAL
  zh: 此更改包括将熟悉的警告 `"Column %r on table %r being replaced by %r, which has the same
    key.  Consider use_labels for select() statements."` **删除**；`Select.apply_labels()`
    仍然可用，并且仍然由 ORM 用于所有 SELECT 操作，但它并不意味着列对象的重复，尽管它暗示了隐式生成的标签的重复：
- en: '[PRE279]'
  id: totrans-1255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE279]'
- en: 'Finally, the change makes it easier to create UNION and other `_selectable.CompoundSelect`
    objects, by ensuring that the number and position of columns in a SELECT statement
    mirrors what was given, in a use case such as:'
  id: totrans-1256
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这个改变使得创建 UNION 和其他 `_selectable.CompoundSelect` 对象变得更加容易，通过确保 SELECT 语句中的列的数量和位置与所给定的相同，例如在以下用例中：
- en: '[PRE280]'
  id: totrans-1257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE280]'
- en: '[#4753](https://www.sqlalchemy.org/trac/ticket/4753)'
  id: totrans-1258
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4753](https://www.sqlalchemy.org/trac/ticket/4753)'
- en: '### Improved column labeling for simple column expressions using CAST or similar'
  id: totrans-1259
  prefs: []
  type: TYPE_NORMAL
  zh: '### 使用 CAST 或类似方法改进简单列表达式的列标签'
- en: 'A user pointed out that the PostgreSQL database has a convenient behavior when
    using functions like CAST against a named column, in that the result column name
    is named the same as the inner expression:'
  id: totrans-1260
  prefs: []
  type: TYPE_NORMAL
  zh: 有用户指出，PostgreSQL 数据库在使用 CAST 等函数对命名列进行操作时具有方便的行为，因为结果列名与内部表达式相同：
- en: '[PRE281]'
  id: totrans-1261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE281]'
- en: 'This allows one to apply CAST to table columns while not losing the column
    name (above using the name `"data"`) in the result row. Compare to databases such
    as MySQL/MariaDB, as well as most others, where the column name is taken from
    the full SQL expression and is not very portable:'
  id: totrans-1262
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许将 CAST 应用于表列，同时不丢失结果行中列名（上述使用名称 `"data"`）。与 MySQL/MariaDB 等大多数数据库相比，此处的列名取自完整的
    SQL 表达式，而且不太可移植：
- en: '[PRE282]'
  id: totrans-1263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE282]'
- en: 'In SQLAlchemy Core expressions, we never deal with a raw generated name like
    the above, as SQLAlchemy applies auto-labeling to expressions like these, which
    are up until now always a so-called “anonymous” expression:'
  id: totrans-1264
  prefs: []
  type: TYPE_NORMAL
  zh: 在SQLAlchemy Core表达式中，我们从不处理像上面那样的原始生成名称，因为SQLAlchemy对这些表达式应用自动标记，直到现在始终是所谓的“匿名”表达式：
- en: '[PRE283]'
  id: totrans-1265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE283]'
- en: 'These anonymous expressions were necessary as SQLAlchemy’s `ResultProxy` made
    heavy use of result column names in order to match up datatypes, such as the [`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String") datatype which used to have result-row-processing behavior,
    to the correct column, so most importantly the names had to be both easy to determine
    in a database-agnostic manner as well as unique in all cases. In SQLAlchemy 1.0
    as part of [#918](https://www.sqlalchemy.org/trac/ticket/918), this reliance on
    named columns in result rows (specifically the `cursor.description` element of
    the PEP-249 cursor) was scaled back to not be necessary for most Core SELECT constructs;
    in release 1.4, the system overall is becoming more comfortable with SELECT statements
    that have duplicate column or label names such as in [SELECT objects and derived
    FROM clauses allow for duplicate columns and column labels](#change-4753). So
    we now emulate PostgreSQL’s reasonable behavior for simple modifications to a
    single column, most prominently with CAST:'
  id: totrans-1266
  prefs: []
  type: TYPE_NORMAL
  zh: 这些匿名表达式是必需的，因为SQLAlchemy的`ResultProxy`大量使用结果列名称来匹配数据类型，例如[`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String")数据类型曾经具有结果行处理行为，以正确匹配列，因此最重要的是名称必须易于以与数据库无关的方式确定，并且在所有情况下都是唯一的。在SQLAlchemy
    1.0中作为[#918](https://www.sqlalchemy.org/trac/ticket/918)的一部分，对于大多数Core SELECT构造，不再需要依赖结果行中的命名列（特别是PEP-249游标的`cursor.description`元素）；在1.4版本中，整个系统对于具有重复列或标签名称的SELECT语句变得更加舒适，例如在[SELECT对象和派生FROM子句允许重复列和列标签](#change-4753)中。因此，我们现在模拟PostgreSQL对于对单个列进行简单修改的合理行为，最显著的是使用CAST：
- en: '[PRE284]'
  id: totrans-1267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE284]'
- en: 'For CAST against expressions that don’t have a name, the previous logic is
    used to generate the usual “anonymous” labels:'
  id: totrans-1268
  prefs: []
  type: TYPE_NORMAL
  zh: 对于没有名称的表达式，CAST使用先前的逻辑生成通常的“匿名”标签：
- en: '[PRE285]'
  id: totrans-1269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE285]'
- en: 'A [`cast()`](../core/sqlelement.html#sqlalchemy.sql.expression.cast "sqlalchemy.sql.expression.cast")
    against a [`Label`](../core/sqlelement.html#sqlalchemy.sql.expression.Label "sqlalchemy.sql.expression.Label"),
    despite having to omit the label expression as these don’t render inside of a
    CAST, will nonetheless make use of the given name:'
  id: totrans-1270
  prefs: []
  type: TYPE_NORMAL
  zh: 对于[`Label`](../core/sqlelement.html#sqlalchemy.sql.expression.Label "sqlalchemy.sql.expression.Label")的[`cast()`](../core/sqlelement.html#sqlalchemy.sql.expression.cast
    "sqlalchemy.sql.expression.cast")，尽管必须省略标签表达式，因为这些在CAST内部不会呈现，但仍将使用给定的名称：
- en: '[PRE286]'
  id: totrans-1271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE286]'
- en: 'And of course as was always the case, [`Label`](../core/sqlelement.html#sqlalchemy.sql.expression.Label
    "sqlalchemy.sql.expression.Label") can be applied to the expression on the outside
    to apply an “AS <name>” label directly:'
  id: totrans-1272
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，一直以来，[`Label`](../core/sqlelement.html#sqlalchemy.sql.expression.Label "sqlalchemy.sql.expression.Label")可以应用于表达式的外部，直接应用“AS
    <name>”标签：
- en: '[PRE287]'
  id: totrans-1273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE287]'
- en: '[#4449](https://www.sqlalchemy.org/trac/ticket/4449)'
  id: totrans-1274
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4449](https://www.sqlalchemy.org/trac/ticket/4449)'
- en: '### New “post compile” bound parameters used for LIMIT/OFFSET in Oracle, SQL
    Server'
  id: totrans-1275
  prefs: []
  type: TYPE_NORMAL
  zh: '### 用于Oracle、SQL Server中LIMIT/OFFSET的新“后编译”绑定参数'
- en: A major goal of the 1.4 series is to establish that all Core SQL constructs
    are completely cacheable, meaning that a particular [`Compiled`](../core/internals.html#sqlalchemy.engine.Compiled
    "sqlalchemy.engine.Compiled") structure will produce an identical SQL string regardless
    of any SQL parameters used with it, which notably includes those used to specify
    the LIMIT and OFFSET values, typically used for pagination and “top N” style results.
  id: totrans-1276
  prefs: []
  type: TYPE_NORMAL
  zh: 1.4系列的一个主要目标是确保所有Core SQL构造都是完全可缓存的，这意味着特定的[`Compiled`](../core/internals.html#sqlalchemy.engine.Compiled
    "sqlalchemy.engine.Compiled")结构将生成相同的SQL字符串，而不管与之一起使用的任何SQL参数，其中特别包括用于指定LIMIT和OFFSET值的参数，通常用于分页和“top
    N”样式的结果。
- en: 'While SQLAlchemy has used bound parameters for LIMIT/OFFSET schemes for many
    years, a few outliers remained where such parameters were not allowed, including
    a SQL Server “TOP N” statement, such as:'
  id: totrans-1277
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然SQLAlchemy多年来一直使用绑定参数来处理LIMIT/OFFSET方案，但仍然存在一些离群值，其中不允许使用这些参数，包括SQL Server的“TOP
    N”语句，例如：
- en: '[PRE288]'
  id: totrans-1278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE288]'
- en: 'as well as with Oracle, where the FIRST_ROWS() hint (which SQLAlchemy will
    use if the `optimize_limits=True` parameter is passed to [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") with an Oracle URL) does not allow them, but also
    that using bound parameters with ROWNUM comparisons has been reported as producing
    slower query plans:'
  id: totrans-1279
  prefs: []
  type: TYPE_NORMAL
  zh: 以及在 Oracle 中，如果将 `optimize_limits=True` 参数传递给 [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") 时，SQLAlchemy 将使用 FIRST_ROWS() 提示，不允许它们，但还有一种使用带有 ROWNUM
    比较的绑定参数被报告为生成较慢的查询计划：
- en: '[PRE289]'
  id: totrans-1280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE289]'
- en: 'In order to allow for all statements to be unconditionally cacheable at the
    compilation level, a new form of bound parameter called a “post compile” parameter
    has been added, which makes use of the same mechanism as that of “expanding IN
    parameters”. This is a [`bindparam()`](../core/sqlelement.html#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam") that behaves identically to any other bound
    parameter except that parameter value will be rendered literally into the SQL
    string before sending it to the DBAPI `cursor.execute()` method. The new parameter
    is used internally by the SQL Server and Oracle dialects, so that the drivers
    receive the literal rendered value but the rest of SQLAlchemy can still consider
    this as a bound parameter. The above two statements when stringified using `str(statement.compile(dialect=<dialect>))`
    now look like:'
  id: totrans-1281
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使所有语句在编译级别无条件可缓存，添加了一种新形式的绑定参数，称为“后编译”参数，它使用与“扩展 IN 参数”相同的机制。这是一个[`bindparam()`](../core/sqlelement.html#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam")，其行为与任何其他绑定参数完全相同，只是参数值在发送到 DBAPI `cursor.execute()`
    方法之前会被字面渲染到 SQL 字符串中。新参数在 SQL Server 和 Oracle 方言内部使用，以便驱动程序接收字面渲染值，但 SQLAlchemy
    的其余部分仍然可以将其视为绑定参数。现在，使用 `str(statement.compile(dialect=<dialect>))` 将上述两个语句字符串化后，看起来如下：
- en: '[PRE290]'
  id: totrans-1282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE290]'
- en: 'and:'
  id: totrans-1283
  prefs: []
  type: TYPE_NORMAL
  zh: 和：
- en: '[PRE291]'
  id: totrans-1284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE291]'
- en: The `[POSTCOMPILE_<param>]` format is also what is seen when an “expanding IN”
    is used.
  id: totrans-1285
  prefs: []
  type: TYPE_NORMAL
  zh: '`[POSTCOMPILE_<param>]` 格式也是在使用“扩展 IN”时所见的格式。'
- en: 'When viewing the SQL logging output, the final form of the statement will be
    seen:'
  id: totrans-1286
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看 SQL 记录输出时，将看到语句的最终形式：
- en: '[PRE292]'
  id: totrans-1287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE292]'
- en: The “post compile parameter” feature is exposed as public API through the [`bindparam.literal_execute`](../core/sqlelement.html#sqlalchemy.sql.expression.bindparam.params.literal_execute
    "sqlalchemy.sql.expression.bindparam") parameter, however is currently not intended
    for general use. The literal values are rendered using the [`TypeEngine.literal_processor()`](../core/type_api.html#sqlalchemy.types.TypeEngine.literal_processor
    "sqlalchemy.types.TypeEngine.literal_processor") of the underlying datatype, which
    in SQLAlchemy has **extremely limited** scope, supporting only integers and simple
    string values.
  id: totrans-1288
  prefs: []
  type: TYPE_NORMAL
  zh: “后编译参数”功能通过[`bindparam.literal_execute`](../core/sqlelement.html#sqlalchemy.sql.expression.bindparam.params.literal_execute
    "sqlalchemy.sql.expression.bindparam")参数作为公共 API 公开，但目前不打算供一般使用。字面值是使用底层数据类型的[`TypeEngine.literal_processor()`](../core/type_api.html#sqlalchemy.types.TypeEngine.literal_processor
    "sqlalchemy.types.TypeEngine.literal_processor")渲染的，在 SQLAlchemy 中的范围**极其有限**，仅支持整数和简单字符串值。
- en: '[#4808](https://www.sqlalchemy.org/trac/ticket/4808)'
  id: totrans-1289
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4808](https://www.sqlalchemy.org/trac/ticket/4808)'
- en: '### Connection-level transactions can now be inactive based on subtransaction'
  id: totrans-1290
  prefs: []
  type: TYPE_NORMAL
  zh: '### 基于子事务，现在可以使连接级事务不活动'
- en: A [`Connection`](../core/connections.html#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    now includes the behavior where a [`Transaction`](../core/connections.html#sqlalchemy.engine.Transaction
    "sqlalchemy.engine.Transaction") can be made inactive due to a rollback on an
    inner transaction, however the [`Transaction`](../core/connections.html#sqlalchemy.engine.Transaction
    "sqlalchemy.engine.Transaction") will not clear until it is itself rolled back.
  id: totrans-1291
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，[`Connection`](../core/connections.html#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    包括了一个行为，即由于内部事务的回滚，[`Transaction`](../core/connections.html#sqlalchemy.engine.Transaction
    "sqlalchemy.engine.Transaction") 可以变为不活动，但是直到它自己被回滚之前，[`Transaction`](../core/connections.html#sqlalchemy.engine.Transaction
    "sqlalchemy.engine.Transaction") 不会清除。
- en: This is essentially a new error condition which will disallow statement executions
    to proceed on a [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") if an inner “sub” transaction has been rolled
    back. The behavior works very similarly to that of the ORM [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), where if an outer transaction has been begun, it needs
    to be rolled back to clear the invalid transaction; this behavior is described
    in [“This Session’s transaction has been rolled back due to a previous exception
    during flush.” (or similar)](../faq/sessions.html#faq-session-rollback).
  id: totrans-1292
  prefs: []
  type: TYPE_NORMAL
  zh: 这本质上是一个新的错误条件，如果内部“子”事务已被回滚，则会禁止在[`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")上继续执行语句。该行为与ORM [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")的行为非常相似，如果已开始外部事务，则需要将其回滚以清除无效事务；此行为在[“由于刷新期间的先前异常，此会话的事务已被回滚。”（或类似）](../faq/sessions.html#faq-session-rollback)中有描述。
- en: While the [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") has had a less strict behavioral pattern than
    the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session"),
    this change was made as it helps to identify when a subtransaction has rolled
    back the DBAPI transaction, however the external code isn’t aware of this and
    attempts to continue proceeding, which in fact runs operations on a new transaction.
    The “test harness” pattern described at [Joining a Session into an External Transaction
    (such as for test suites)](../orm/session_transaction.html#session-external-transaction)
    is the common place for this to occur.
  id: totrans-1293
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然[`Connection`](../core/connections.html#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")的行为模式比[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")更宽松，但由于它有助于识别子事务已回滚DBAPI事务，但外部代码并不知晓并尝试继续进行，实际上在新事务上运行操作，因此进行了此更改。在[将会话加入外部事务（例如用于测试套件）](../orm/session_transaction.html#session-external-transaction)中描述的“测试工具”模式是发生这种情况的常见地方。
- en: The “subtransaction” feature of Core and ORM is itself deprecated and will no
    longer be present in version 2.0\. As a result, this new error condition is itself
    temporary as it will no longer apply once subtransactions are removed.
  id: totrans-1294
  prefs: []
  type: TYPE_NORMAL
  zh: Core和ORM的“子事务”功能本身已被弃用，并将不再出现在2.0版本中。因此，这种新的错误条件本身是临时的，一旦子事务被移除，它将不再适用。
- en: In order to work with the 2.0 style behavior that does not include subtransactions,
    use the [`create_engine.future`](../core/engines.html#sqlalchemy.create_engine.params.future
    "sqlalchemy.create_engine") parameter on [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine").
  id: totrans-1295
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用不包括子事务的2.0风格行为，可以在[`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine")上使用[`create_engine.future`](../core/engines.html#sqlalchemy.create_engine.params.future
    "sqlalchemy.create_engine")参数。
- en: The error message is described in the errors page at [This connection is on
    an inactive transaction. Please rollback() fully before proceeding](../errors.html#error-8s2a).
  id: totrans-1296
  prefs: []
  type: TYPE_NORMAL
  zh: 错误消息在错误页面中描述为[此连接处于非活动事务状态。请在继续之前完全回滚()](../errors.html#error-8s2a)。
- en: '### Enum and Boolean datatypes no longer default to “create constraint”'
  id: totrans-1297
  prefs: []
  type: TYPE_NORMAL
  zh: '### 枚举和布尔数据类型不再默认为“创建约束”'
- en: The [`Enum.create_constraint`](../core/type_basics.html#sqlalchemy.types.Enum.params.create_constraint
    "sqlalchemy.types.Enum") and [`Boolean.create_constraint`](../core/type_basics.html#sqlalchemy.types.Boolean.params.create_constraint
    "sqlalchemy.types.Boolean") parameters now default to False, indicating when a
    so-called “non-native” version of these two datatypes is created, a CHECK constraint
    will **not** be generated by default. These CHECK constraints present schema-management
    maintenance complexities that should be opted in to, rather than being turned
    on by default.
  id: totrans-1298
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Enum.create_constraint`](../core/type_basics.html#sqlalchemy.types.Enum.params.create_constraint
    "sqlalchemy.types.Enum")和[`Boolean.create_constraint`](../core/type_basics.html#sqlalchemy.types.Boolean.params.create_constraint
    "sqlalchemy.types.Boolean")参数现在默认为False，表示当创建这两种数据类型的所谓“非本地”版本时，默认情况下不会生成CHECK约束。这些CHECK约束会带来应该选择的模式管理维护复杂性，而不是默认打开。'
- en: 'To ensure that a CREATE CONSTRAINT is emitted for these types, set these flags
    to `True`:'
  id: totrans-1299
  prefs: []
  type: TYPE_NORMAL
  zh: 要确保为这些类型发出CREATE CONSTRAINT，请将这些标志设置为`True`：
- en: '[PRE293]'
  id: totrans-1300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE293]'
- en: '[#5367](https://www.sqlalchemy.org/trac/ticket/5367)'
  id: totrans-1301
  prefs: []
  type: TYPE_NORMAL
  zh: '[#5367](https://www.sqlalchemy.org/trac/ticket/5367)'
- en: New Features - ORM
  id: totrans-1302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 新功能 - ORM
- en: '### Raiseload for Columns'
  id: totrans-1303
  prefs: []
  type: TYPE_NORMAL
  zh: '### 为列提升加载'
- en: 'The “raiseload” feature, which raises [`InvalidRequestError`](../core/exceptions.html#sqlalchemy.exc.InvalidRequestError
    "sqlalchemy.exc.InvalidRequestError") when an unloaded attribute is accessed,
    is now available for column-oriented attributes using the [`defer.raiseload`](../orm/queryguide/columns.html#sqlalchemy.orm.defer.params.raiseload
    "sqlalchemy.orm.defer") parameter of [`defer()`](../orm/queryguide/columns.html#sqlalchemy.orm.defer
    "sqlalchemy.orm.defer"). This works in the same manner as that of the [`raiseload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.raiseload
    "sqlalchemy.orm.raiseload") option used by relationship loading:'
  id: totrans-1304
  prefs: []
  type: TYPE_NORMAL
  zh: “raiseload”功能现在可用于使用[`defer.raiseload`](../orm/queryguide/columns.html#sqlalchemy.orm.defer.params.raiseload
    "sqlalchemy.orm.defer")参数的[`defer()`](../orm/queryguide/columns.html#sqlalchemy.orm.defer
    "sqlalchemy.orm.defer")的基于列的属性，当访问未加载的属性时引发[`InvalidRequestError`](../core/exceptions.html#sqlalchemy.exc.InvalidRequestError
    "sqlalchemy.exc.InvalidRequestError")。这与关系加载使用的[`raiseload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.raiseload
    "sqlalchemy.orm.raiseload")选项的工作方式相同：
- en: '[PRE294]'
  id: totrans-1305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE294]'
- en: 'To configure column-level raiseload on a mapping, the [`deferred.raiseload`](../orm/queryguide/columns.html#sqlalchemy.orm.deferred.params.raiseload
    "sqlalchemy.orm.deferred") parameter of [`deferred()`](../orm/queryguide/columns.html#sqlalchemy.orm.deferred
    "sqlalchemy.orm.deferred") may be used. The [`undefer()`](../orm/queryguide/columns.html#sqlalchemy.orm.undefer
    "sqlalchemy.orm.undefer") option may then be used at query time to eagerly load
    the attribute:'
  id: totrans-1306
  prefs: []
  type: TYPE_NORMAL
  zh: 要在映射上配置列级raiseload，可以使用[`deferred.raiseload`](../orm/queryguide/columns.html#sqlalchemy.orm.deferred.params.raiseload
    "sqlalchemy.orm.deferred")参数的[`deferred()`](../orm/queryguide/columns.html#sqlalchemy.orm.deferred
    "sqlalchemy.orm.deferred")。然后可以在查询时使用[`undefer()`](../orm/queryguide/columns.html#sqlalchemy.orm.undefer
    "sqlalchemy.orm.undefer")选项来急切加载属性：
- en: '[PRE295]'
  id: totrans-1307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE295]'
- en: 'It was originally considered that the existing [`raiseload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.raiseload
    "sqlalchemy.orm.raiseload") option that works for [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") attributes be expanded to also support column-oriented
    attributes. However, this would break the “wildcard” behavior of [`raiseload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.raiseload
    "sqlalchemy.orm.raiseload"), which is documented as allowing one to prevent all
    relationships from loading:'
  id: totrans-1308
  prefs: []
  type: TYPE_NORMAL
  zh: 最初认为现有的[`raiseload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.raiseload
    "sqlalchemy.orm.raiseload")选项适用于[`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")属性，应扩展以支持基于列的属性。然而，这将破坏[`raiseload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.raiseload
    "sqlalchemy.orm.raiseload")的“通配符”行为，该行为被记录为允许阻止所有关系加载：
- en: '[PRE296]'
  id: totrans-1309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE296]'
- en: 'Above, if we had expanded [`raiseload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.raiseload
    "sqlalchemy.orm.raiseload") to accommodate for columns as well, the wildcard would
    also prevent columns from loading and thus be a backwards incompatible change;
    additionally, it’s not clear if [`raiseload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.raiseload
    "sqlalchemy.orm.raiseload") covered both column expressions and relationships,
    how one would achieve the effect above of only blocking relationship loads, without
    new API being added. So to keep things simple, the option for columns remains
    on [`defer()`](../orm/queryguide/columns.html#sqlalchemy.orm.defer "sqlalchemy.orm.defer"):'
  id: totrans-1310
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们扩展了[`raiseload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.raiseload
    "sqlalchemy.orm.raiseload")以适应列，通配符也将阻止列加载，从而导致向后不兼容的更改；此外，不清楚[`raiseload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.raiseload
    "sqlalchemy.orm.raiseload")是否同时涵盖列表达式和关系，如何实现上述仅阻止关系加载的效果，而不添加新的API。因此，为了保持简单，列的选项仍然在[`defer()`](../orm/queryguide/columns.html#sqlalchemy.orm.defer
    "sqlalchemy.orm.defer")上：
- en: '[`raiseload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.raiseload
    "sqlalchemy.orm.raiseload") - query option to raise for relationship loads'
  id: totrans-1311
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[`raiseload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.raiseload
    "sqlalchemy.orm.raiseload") - 查询选项，用于关系加载时引发异常'
- en: ''
  id: totrans-1312
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[`defer.raiseload`](../orm/queryguide/columns.html#sqlalchemy.orm.defer.params.raiseload
    "sqlalchemy.orm.defer") - query option to raise for column expression loads'
  id: totrans-1313
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[`defer.raiseload`](../orm/queryguide/columns.html#sqlalchemy.orm.defer.params.raiseload
    "sqlalchemy.orm.defer") - 查询选项，用于列表达式加载时引发异常'
- en: As part of this change, the behavior of “deferred” in conjunction with attribute
    expiration has changed. Previously, when an object would be marked as expired,
    and then unexpired via the access of one of the expired attributes, attributes
    which were mapped as “deferred” at the mapper level would also load. This has
    been changed such that an attribute that is deferred in the mapping will never
    “unexpire”, it only loads when accessed as part of the deferral loader.
  id: totrans-1314
  prefs: []
  type: TYPE_NORMAL
  zh: 作为这一变化的一部分，“deferred”与属性过期的行为已经改变。以前，当对象被标记为过期，然后通过访问其中一个过期属性来取消过期时，映射为“deferred”的属性也会加载。现在已更改为映射中延迟的属性永远不会“过期”，只有在作为延迟加载器的一部分访问时才会加载。
- en: An attribute that is not mapped as “deferred”, however was deferred at query
    time via the [`defer()`](../orm/queryguide/columns.html#sqlalchemy.orm.defer "sqlalchemy.orm.defer")
    option, will be reset when the object or attribute is expired; that is, the deferred
    option is removed. This is the same behavior as was present previously.
  id: totrans-1315
  prefs: []
  type: TYPE_NORMAL
  zh: 一个未映射为“deferred”的属性，但在查询时通过[`defer()`](../orm/queryguide/columns.html#sqlalchemy.orm.defer
    "sqlalchemy.orm.defer")选项进行了延迟，当对象或属性过期时将被重置；也就是说，延迟选项被移除。这与以前的行为相同。
- en: See also
  id: totrans-1316
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Using raiseload to prevent deferred column loads](../orm/queryguide/columns.html#orm-queryguide-deferred-raiseload)'
  id: totrans-1317
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用raiseload来防止延迟列加载](../orm/queryguide/columns.html#orm-queryguide-deferred-raiseload)'
- en: '[#4826](https://www.sqlalchemy.org/trac/ticket/4826)  ### ORM Batch inserts
    with psycopg2 now batch statements with RETURNING in most cases'
  id: totrans-1318
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4826](https://www.sqlalchemy.org/trac/ticket/4826)  ### 使用psycopg2进行ORM批量插入现在在大多数情况下批量处理带有RETURNING的语句'
- en: The change in [psycopg2 dialect features “execute_values” with RETURNING for
    INSERT statements by default](#change-5401) adds support for “executemany” + “RETURNING”
    at the same time in Core, which is now enabled for the psycopg2 dialect by default
    using the psycopg2 `execute_values()` extension. The ORM flush process now makes
    use of this feature such that the retrieval of newly generated primary key values
    and server defaults can be achieved while not losing the performance benefits
    of being able to batch INSERT statements together. Additionally, psycopg2’s `execute_values()`
    extension itself provides a five-fold performance improvement over psycopg2’s
    default “executemany” implementation, by rewriting an INSERT statement to include
    many “VALUES” expressions all in one statement rather than invoking the same statement
    repeatedly, as psycopg2 lacks the ability to PREPARE the statement ahead of time
    as would normally be expected for this approach to be performant.
  id: totrans-1319
  prefs: []
  type: TYPE_NORMAL
  zh: '[psycopg2方言特性的变化“默认情况下为INSERT语句添加RETURNING”](#change-5401)在Core中添加了对“executemany”
    + “RETURNING”同时支持的功能，现在默认情况下通过psycopg2的`execute_values()`扩展为psycopg2方言启用。ORM刷新过程现在利用此功能，以便在不丢失能够将INSERT语句批量处理在一起的性能优势的同时，实现新生成的主键值和服务器默认值的检索。此外，psycopg2的`execute_values()`扩展本身通过将一个INSERT语句重写为包含许多“VALUES”表达式的单个语句，而不是重复调用相同的语句，提供了五倍的性能改进，因为psycopg2缺乏预先准备语句的能力，这通常被期望为这种方法提供性能。'
- en: 'SQLAlchemy includes a [performance suite](../orm/examples.html#examples-performance)
    within its examples, where we can compare the times generated for the “batch_inserts”
    runner against 1.3 and 1.4, revealing a 3x-5x speedup for most flavors of batch
    insert:'
  id: totrans-1320
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy在其示例中包含一个[性能套件](../orm/examples.html#examples-performance)，在这里我们可以比较“batch_inserts”运行程序在1.3和1.4版本中生成的时间，显示大多数批量插入的速度提升了3倍至5倍：
- en: '[PRE297]'
  id: totrans-1321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE297]'
- en: 'Note that the `execute_values()` extension modifies the INSERT statement in
    the psycopg2 layer, **after** it’s been logged by SQLAlchemy. So with SQL logging,
    one will see the parameter sets batched together, but the joining of multiple
    “values” will not be visible on the application side:'
  id: totrans-1322
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`execute_values()`扩展会在SQLAlchemy记录后修改psycopg2层的INSERT语句。因此，在SQL记录中，可以看到参数集被批处理在一起，但多个“values”的连接在应用程序端不可见：
- en: '[PRE298]'
  id: totrans-1323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE298]'
- en: 'The ultimate INSERT statement can be seen by enabling statement logging on
    the PostgreSQL side:'
  id: totrans-1324
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过在PostgreSQL端启用语句记录来查看最终的INSERT语句：
- en: '[PRE299]'
  id: totrans-1325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE299]'
- en: The feature batches rows into groups of 1000 by default which can be affected
    using the `executemany_values_page_size` argument documented at [Psycopg2 Fast
    Execution Helpers](../dialects/postgresql.html#psycopg2-executemany-mode).
  id: totrans-1326
  prefs: []
  type: TYPE_NORMAL
  zh: 该功能默认将行分组为1000个一组，可以使用文档中记录的`executemany_values_page_size`参数来影响：
- en: '[#5263](https://www.sqlalchemy.org/trac/ticket/5263)  ### ORM Bulk Update and
    Delete use RETURNING for “fetch” strategy when available'
  id: totrans-1327
  prefs: []
  type: TYPE_NORMAL
  zh: '[#5263](https://www.sqlalchemy.org/trac/ticket/5263)  ### ORM批量更新和删除在可用时使用RETURNING进行“fetch”策略'
- en: 'An ORM bulk update or delete that uses the “fetch” strategy:'
  id: totrans-1328
  prefs: []
  type: TYPE_NORMAL
  zh: 使用“fetch”策略的ORM批量更新或删除：
- en: '[PRE300]'
  id: totrans-1329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE300]'
- en: 'Will now use RETURNING if the backend database supports it; this currently
    includes PostgreSQL and SQL Server (the Oracle dialect does not support RETURNING
    of multiple rows):'
  id: totrans-1330
  prefs: []
  type: TYPE_NORMAL
  zh: 如果后端数据库支持，现在将使用RETURNING；目前包括PostgreSQL和SQL Server（Oracle方言不支持返回多行）：
- en: '[PRE301]'
  id: totrans-1331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE301]'
- en: 'For backends that do not support RETURNING of multiple rows, the previous approach
    of emitting SELECT for the primary keys beforehand is still used:'
  id: totrans-1332
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不支持返回多行的后端，仍然使用先前的方法在主键之前发出SELECT：
- en: '[PRE302]'
  id: totrans-1333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE302]'
- en: One of the intricate challenges of this change is to support cases such as the
    horizontal sharding extension, where a single bulk update or delete may be multiplexed
    among backends some of which support RETURNING and some don’t. The new 1.4 execution
    architecture supports this case so that the “fetch” strategy can be left intact
    with a graceful degrade to using a SELECT, rather than having to add a new “returning”
    strategy that would not be backend-agnostic.
  id: totrans-1334
  prefs: []
  type: TYPE_NORMAL
  zh: 这一变化的一个复杂挑战之一是支持诸如水平分片扩展之类的情况，其中单个批量更新或删除可能在一些支持RETURNING的后端之间多路复用，而另一些则不支持。新的1.4执行架构支持这种情况，以便“fetch”策略可以保持不变，优雅地降级到使用SELECT，而不是必须添加一个新的不具备后端通用性的“returning”策略。
- en: 'As part of this change, the “fetch” strategy is also made much more efficient
    in that it will no longer expire the objects located which match the rows, for
    Python expressions used in the SET clause which can be evaluated in Python; these
    are instead assigned directly onto the object in the same way as the “evaluate”
    strategy. Only for SQL expressions that can’t be evaluated does it fall back to
    expiring the attributes. The “evaluate” strategy has also been enhanced to fall
    back to “expire” for a value that cannot be evaluated.  ### Raiseload for Columns'
  id: totrans-1335
  prefs: []
  type: TYPE_NORMAL
  zh: '作为这一变化的一部分，“fetch”策略也变得更加高效，不再使匹配行的对象过期，对于可以在Python中评估的SET子句中使用的Python表达式；这些直接分配到对象上，方式与“evaluate”策略相同。只有对于无法评估的SQL表达式，它才会退回到使属性过期。对于无法评估的值，“evaluate”策略也已增强为退回到“expire”。  ###
    列的Raiseload'
- en: 'The “raiseload” feature, which raises [`InvalidRequestError`](../core/exceptions.html#sqlalchemy.exc.InvalidRequestError
    "sqlalchemy.exc.InvalidRequestError") when an unloaded attribute is accessed,
    is now available for column-oriented attributes using the [`defer.raiseload`](../orm/queryguide/columns.html#sqlalchemy.orm.defer.params.raiseload
    "sqlalchemy.orm.defer") parameter of [`defer()`](../orm/queryguide/columns.html#sqlalchemy.orm.defer
    "sqlalchemy.orm.defer"). This works in the same manner as that of the [`raiseload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.raiseload
    "sqlalchemy.orm.raiseload") option used by relationship loading:'
  id: totrans-1336
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用[`defer.raiseload`](../orm/queryguide/columns.html#sqlalchemy.orm.defer.params.raiseload
    "sqlalchemy.orm.defer")参数的[`defer()`](../orm/queryguide/columns.html#sqlalchemy.orm.defer
    "sqlalchemy.orm.defer")，可以为基于列的属性提供“raiseload”功能，当访问未加载的属性时引发[`InvalidRequestError`](../core/exceptions.html#sqlalchemy.exc.InvalidRequestError
    "sqlalchemy.exc.InvalidRequestError")，这与关系加载使用的[`raiseload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.raiseload
    "sqlalchemy.orm.raiseload")选项的方式相同：
- en: '[PRE303]'
  id: totrans-1337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE303]'
- en: 'To configure column-level raiseload on a mapping, the [`deferred.raiseload`](../orm/queryguide/columns.html#sqlalchemy.orm.deferred.params.raiseload
    "sqlalchemy.orm.deferred") parameter of [`deferred()`](../orm/queryguide/columns.html#sqlalchemy.orm.deferred
    "sqlalchemy.orm.deferred") may be used. The [`undefer()`](../orm/queryguide/columns.html#sqlalchemy.orm.undefer
    "sqlalchemy.orm.undefer") option may then be used at query time to eagerly load
    the attribute:'
  id: totrans-1338
  prefs: []
  type: TYPE_NORMAL
  zh: 要在映射上配置列级raiseload，可以使用[`deferred.raiseload`](../orm/queryguide/columns.html#sqlalchemy.orm.deferred.params.raiseload
    "sqlalchemy.orm.deferred")参数的[`deferred()`](../orm/queryguide/columns.html#sqlalchemy.orm.deferred
    "sqlalchemy.orm.deferred")。然后可以在查询时使用[`undefer()`](../orm/queryguide/columns.html#sqlalchemy.orm.undefer
    "sqlalchemy.orm.undefer")选项来急切加载属性：
- en: '[PRE304]'
  id: totrans-1339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE304]'
- en: 'It was originally considered that the existing [`raiseload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.raiseload
    "sqlalchemy.orm.raiseload") option that works for [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") attributes be expanded to also support column-oriented
    attributes. However, this would break the “wildcard” behavior of [`raiseload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.raiseload
    "sqlalchemy.orm.raiseload"), which is documented as allowing one to prevent all
    relationships from loading:'
  id: totrans-1340
  prefs: []
  type: TYPE_NORMAL
  zh: 最初考虑扩展现有的[`raiseload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.raiseload
    "sqlalchemy.orm.raiseload")选项，以支持面向列的属性。然而，这将破坏[`raiseload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.raiseload
    "sqlalchemy.orm.raiseload")的“通配符”行为，该行为被记录为允许阻止所有关系加载：
- en: '[PRE305]'
  id: totrans-1341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE305]'
- en: 'Above, if we had expanded [`raiseload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.raiseload
    "sqlalchemy.orm.raiseload") to accommodate for columns as well, the wildcard would
    also prevent columns from loading and thus be a backwards incompatible change;
    additionally, it’s not clear if [`raiseload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.raiseload
    "sqlalchemy.orm.raiseload") covered both column expressions and relationships,
    how one would achieve the effect above of only blocking relationship loads, without
    new API being added. So to keep things simple, the option for columns remains
    on [`defer()`](../orm/queryguide/columns.html#sqlalchemy.orm.defer "sqlalchemy.orm.defer"):'
  id: totrans-1342
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们扩展了[`raiseload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.raiseload
    "sqlalchemy.orm.raiseload")以适应列，通配符也将阻止列的加载，因此这将是一个不兼容的更改；此外，不清楚[`raiseload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.raiseload
    "sqlalchemy.orm.raiseload")是否同时涵盖列表达式和关系，如何实现上述仅阻止关系加载的效果，而不添加新的API。因此，为了保持简单，列的选项仍然在[`defer()`](../orm/queryguide/columns.html#sqlalchemy.orm.defer
    "sqlalchemy.orm.defer")上：
- en: '[`raiseload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.raiseload
    "sqlalchemy.orm.raiseload") - query option to raise for relationship loads'
  id: totrans-1343
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[`raiseload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.raiseload
    "sqlalchemy.orm.raiseload") - 查询选项，用于为关系加载时引发异常'
- en: ''
  id: totrans-1344
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[`defer.raiseload`](../orm/queryguide/columns.html#sqlalchemy.orm.defer.params.raiseload
    "sqlalchemy.orm.defer") - query option to raise for column expression loads'
  id: totrans-1345
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[`defer.raiseload`](../orm/queryguide/columns.html#sqlalchemy.orm.defer.params.raiseload
    "sqlalchemy.orm.defer") - 查询选项，用于为列表达式加载时引发异常'
- en: As part of this change, the behavior of “deferred” in conjunction with attribute
    expiration has changed. Previously, when an object would be marked as expired,
    and then unexpired via the access of one of the expired attributes, attributes
    which were mapped as “deferred” at the mapper level would also load. This has
    been changed such that an attribute that is deferred in the mapping will never
    “unexpire”, it only loads when accessed as part of the deferral loader.
  id: totrans-1346
  prefs: []
  type: TYPE_NORMAL
  zh: 作为这一变化的一部分，“延迟”与属性过期的行为已经改变。以前，当对象被标记为过期，然后通过访问其中一个过期属性来取消过期时，映射为“deferred”的属性也会加载。现在已经更改为映射为延迟的属性永远不会“取消过期”，它只会在作为延迟加载器的一部分访问时加载。
- en: An attribute that is not mapped as “deferred”, however was deferred at query
    time via the [`defer()`](../orm/queryguide/columns.html#sqlalchemy.orm.defer "sqlalchemy.orm.defer")
    option, will be reset when the object or attribute is expired; that is, the deferred
    option is removed. This is the same behavior as was present previously.
  id: totrans-1347
  prefs: []
  type: TYPE_NORMAL
  zh: 一个未映射为“deferred”的属性，但在查询时通过[`defer()`](../orm/queryguide/columns.html#sqlalchemy.orm.defer
    "sqlalchemy.orm.defer")选项进行了延迟，当对象或属性过期时将被重置；也就是说，延迟选项被移除。这与以前的行为相同。
- en: See also
  id: totrans-1348
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[Using raiseload to prevent deferred column loads](../orm/queryguide/columns.html#orm-queryguide-deferred-raiseload)'
  id: totrans-1349
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用raiseload阻止延迟列加载](../orm/queryguide/columns.html#orm-queryguide-deferred-raiseload)'
- en: '[#4826](https://www.sqlalchemy.org/trac/ticket/4826)'
  id: totrans-1350
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4826](https://www.sqlalchemy.org/trac/ticket/4826)'
- en: '### ORM Batch inserts with psycopg2 now batch statements with RETURNING in
    most cases'
  id: totrans-1351
  prefs: []
  type: TYPE_NORMAL
  zh: '### 使用psycopg2进行ORM批量插入现在在大多数情况下批量执行带有RETURNING的语句'
- en: The change in [psycopg2 dialect features “execute_values” with RETURNING for
    INSERT statements by default](#change-5401) adds support for “executemany” + “RETURNING”
    at the same time in Core, which is now enabled for the psycopg2 dialect by default
    using the psycopg2 `execute_values()` extension. The ORM flush process now makes
    use of this feature such that the retrieval of newly generated primary key values
    and server defaults can be achieved while not losing the performance benefits
    of being able to batch INSERT statements together. Additionally, psycopg2’s `execute_values()`
    extension itself provides a five-fold performance improvement over psycopg2’s
    default “executemany” implementation, by rewriting an INSERT statement to include
    many “VALUES” expressions all in one statement rather than invoking the same statement
    repeatedly, as psycopg2 lacks the ability to PREPARE the statement ahead of time
    as would normally be expected for this approach to be performant.
  id: totrans-1352
  prefs: []
  type: TYPE_NORMAL
  zh: '[psycopg2方言特性“execute_values”默认使用RETURNING进行INSERT语句的更改](#change-5401)在Core中添加了对“executemany”
    + “RETURNING”同时支持的功能，现在默认情况下为psycopg2方言启用了使用psycopg2的`execute_values()`扩展。ORM刷新过程现在利用了这一特性，以便在不失去能够批量将INSERT语句一起执行的性能优势的同时，实现新生成的主键值和服务器默认值的检索。此外，psycopg2的`execute_values()`扩展本身比psycopg2的默认“executemany”实现提供了五倍的性能改进，通过将INSERT语句重写为在一个语句中包含多个“VALUES”表达式，而不是重复调用相同的语句，因为psycopg2缺乏预先准备语句的能力，这通常被期望为这种方法提供性能。'
- en: 'SQLAlchemy includes a [performance suite](../orm/examples.html#examples-performance)
    within its examples, where we can compare the times generated for the “batch_inserts”
    runner against 1.3 and 1.4, revealing a 3x-5x speedup for most flavors of batch
    insert:'
  id: totrans-1353
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy在其示例中包含了一个[性能套件](../orm/examples.html#examples-performance)，在这里我们可以将“batch_inserts”运行程序生成的时间与1.3和1.4进行比较，对大多数批量插入的变体显示出3倍至5倍的加速：
- en: '[PRE306]'
  id: totrans-1354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE306]'
- en: 'Note that the `execute_values()` extension modifies the INSERT statement in
    the psycopg2 layer, **after** it’s been logged by SQLAlchemy. So with SQL logging,
    one will see the parameter sets batched together, but the joining of multiple
    “values” will not be visible on the application side:'
  id: totrans-1355
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`execute_values()`扩展会修改SQLAlchemy记录的psycopg2层中的INSERT语句**之后**。因此，在SQL记录中，可以看到参数集被批量处理在一起，但多个“values”的连接在应用程序端不可见：
- en: '[PRE307]'
  id: totrans-1356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE307]'
- en: 'The ultimate INSERT statement can be seen by enabling statement logging on
    the PostgreSQL side:'
  id: totrans-1357
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过在PostgreSQL端启用语句记录来查看最终的INSERT语句：
- en: '[PRE308]'
  id: totrans-1358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE308]'
- en: The feature batches rows into groups of 1000 by default which can be affected
    using the `executemany_values_page_size` argument documented at [Psycopg2 Fast
    Execution Helpers](../dialects/postgresql.html#psycopg2-executemany-mode).
  id: totrans-1359
  prefs: []
  type: TYPE_NORMAL
  zh: 该功能默认将行分组为每组1000行，可以使用`executemany_values_page_size`参数进行影响，该参数在[Psycopg2快速执行助手](../dialects/postgresql.html#psycopg2-executemany-mode)中有文档记录。
- en: '[#5263](https://www.sqlalchemy.org/trac/ticket/5263)'
  id: totrans-1360
  prefs: []
  type: TYPE_NORMAL
  zh: '[#5263](https://www.sqlalchemy.org/trac/ticket/5263)'
- en: '### ORM Bulk Update and Delete use RETURNING for “fetch” strategy when available'
  id: totrans-1361
  prefs: []
  type: TYPE_NORMAL
  zh: '### ORM批量更新和删除在可用时使用RETURNING进行“fetch”策略'
- en: 'An ORM bulk update or delete that uses the “fetch” strategy:'
  id: totrans-1362
  prefs: []
  type: TYPE_NORMAL
  zh: 使用“fetch”策略的ORM批量更新或删除：
- en: '[PRE309]'
  id: totrans-1363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE309]'
- en: 'Will now use RETURNING if the backend database supports it; this currently
    includes PostgreSQL and SQL Server (the Oracle dialect does not support RETURNING
    of multiple rows):'
  id: totrans-1364
  prefs: []
  type: TYPE_NORMAL
  zh: 如果后端数据库支持，现在将使用RETURNING；目前包括PostgreSQL和SQL Server（Oracle方言不支持多行RETURNING）：
- en: '[PRE310]'
  id: totrans-1365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE310]'
- en: 'For backends that do not support RETURNING of multiple rows, the previous approach
    of emitting SELECT for the primary keys beforehand is still used:'
  id: totrans-1366
  prefs: []
  type: TYPE_NORMAL
  zh: 对于不支持多行RETURNING的后端，仍然使用之前的在主键之前发出SELECT的方法：
- en: '[PRE311]'
  id: totrans-1367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE311]'
- en: One of the intricate challenges of this change is to support cases such as the
    horizontal sharding extension, where a single bulk update or delete may be multiplexed
    among backends some of which support RETURNING and some don’t. The new 1.4 execution
    architecture supports this case so that the “fetch” strategy can be left intact
    with a graceful degrade to using a SELECT, rather than having to add a new “returning”
    strategy that would not be backend-agnostic.
  id: totrans-1368
  prefs: []
  type: TYPE_NORMAL
  zh: 这一变化的一个复杂挑战之一是支持水平分片扩展等情况，其中单个批量更新或删除可能在一些支持RETURNING的后端中进行多路复用，而一些不支持。新的1.4执行架构支持这种情况，以便“fetch”策略可以保持完整，优雅地降级到使用SELECT，而不是必须添加一个新的不具备后端通用性的“returning”策略。
- en: As part of this change, the “fetch” strategy is also made much more efficient
    in that it will no longer expire the objects located which match the rows, for
    Python expressions used in the SET clause which can be evaluated in Python; these
    are instead assigned directly onto the object in the same way as the “evaluate”
    strategy. Only for SQL expressions that can’t be evaluated does it fall back to
    expiring the attributes. The “evaluate” strategy has also been enhanced to fall
    back to “expire” for a value that cannot be evaluated.
  id: totrans-1369
  prefs: []
  type: TYPE_NORMAL
  zh: 作为这一变化的一部分，“fetch”策略也变得更加高效，不再使匹配行的对象过期，对于在SET子句中使用的可以在Python中评估的Python表达式；这些表达式会直接分配到对象上，就像“evaluate”策略一样。
    只有对于无法评估的SQL表达式，才会退回到使属性过期。 “evaluate”策略也已经增强，对于无法评估的值会退回到“expire”。
- en: Behavioral Changes - ORM
  id: totrans-1370
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 行为变化 - ORM
- en: '### The “KeyedTuple” object returned by Query is replaced by Row'
  id: totrans-1371
  prefs: []
  type: TYPE_NORMAL
  zh: '### 查询返回的“KeyedTuple”对象已被`Row`替换'
- en: As discussed at [RowProxy is no longer a “proxy”; is now called Row and behaves
    like an enhanced named tuple](#change-4710-core), the Core `RowProxy` object is
    now replaced by a class called [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row"). The base [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") object now behaves more fully like a named tuple, and
    as such it is now used as the basis for tuple-like results returned by the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object, rather than the previous “KeyedTuple” class.
  id: totrans-1372
  prefs: []
  type: TYPE_NORMAL
  zh: 如在[RowProxy不再是“代理”；现在称为Row并且行为类似于增强的命名元组](#change-4710-core)中讨论的，Core的`RowProxy`对象现在被一个名为[`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row")的类替换。 基本的[`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row")对象现在更像一个命名元组，因此现在用作由[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")对象返回的类似元组的结果的基础，而不是以前的“KeyedTuple”类。
- en: The rationale is so that by SQLAlchemy 2.0, both Core and ORM SELECT statements
    will return result rows using the same [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") object which behaves like a named tuple. Dictionary-like
    functionality is available from [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") via the [`Row._mapping`](../core/connections.html#sqlalchemy.engine.Row._mapping
    "sqlalchemy.engine.Row._mapping") attribute. In the interim, Core result sets
    will make use of a [`Row`](../core/connections.html#sqlalchemy.engine.Row "sqlalchemy.engine.Row")
    subclass `LegacyRow` which maintains the previous dict/tuple hybrid behavior for
    backwards compatibility while the [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") class will be used directly for ORM tuple results returned
    by the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    object.
  id: totrans-1373
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的理由是，到达SQLAlchemy 2.0，Core和ORM SELECT语句将使用行为类似于命名元组的相同[`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row")对象返回结果行。 通过[`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row")的[`Row._mapping`](../core/connections.html#sqlalchemy.engine.Row._mapping
    "sqlalchemy.engine.Row._mapping")属性可以获得类似字典的功能。 在此期间，Core结果集将使用一个[`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row")子类`LegacyRow`，该子类保留了以前的字典/元组混合行为，以确保向后兼容性，而[`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row")类将直接用于由[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")对象返回的ORM元组结果。
- en: 'Effort has been made to get most of the featureset of [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") to be available within the ORM, meaning that access by
    string name as well as entity / column should work:'
  id: totrans-1374
  prefs: []
  type: TYPE_NORMAL
  zh: 已经努力使得[`Row`](../core/connections.html#sqlalchemy.engine.Row "sqlalchemy.engine.Row")的大部分功能集在ORM中可用，这意味着可以通过字符串名称以及实体/列进行访问：
- en: '[PRE312]'
  id: totrans-1375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE312]'
- en: See also
  id: totrans-1376
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[RowProxy is no longer a “proxy”; is now called Row and behaves like an enhanced
    named tuple](#change-4710-core)'
  id: totrans-1377
  prefs: []
  type: TYPE_NORMAL
  zh: '[RowProxy不再是“代理”；现在称为Row，并且行为类似于增强的命名元组](#change-4710-core)'
- en: '[#4710](https://www.sqlalchemy.org/trac/ticket/4710).  ### Session features
    new “autobegin” behavior'
  id: totrans-1378
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4710](https://www.sqlalchemy.org/trac/ticket/4710).  ### 会话功能新的“autobegin”行为'
- en: Previously, the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    in its default mode of `autocommit=False` would internally begin a [`SessionTransaction`](../orm/session_api.html#sqlalchemy.orm.SessionTransaction
    "sqlalchemy.orm.SessionTransaction") object immediately on construction, and additionally
    would create a new one after each call to [`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") or [`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit").
  id: totrans-1379
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，在其默认模式 `autocommit=False` 下，[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 在构造时会立即开始一个 [`SessionTransaction`](../orm/session_api.html#sqlalchemy.orm.SessionTransaction
    "sqlalchemy.orm.SessionTransaction") 对象，并且在每次调用 [`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") 或 [`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") 后还会创建一个新的对象。
- en: The new behavior is that this [`SessionTransaction`](../orm/session_api.html#sqlalchemy.orm.SessionTransaction
    "sqlalchemy.orm.SessionTransaction") object is now created on demand only, when
    methods such as [`Session.add()`](../orm/session_api.html#sqlalchemy.orm.Session.add
    "sqlalchemy.orm.Session.add") or [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") are called. However it is also now possible
    to call [`Session.begin()`](../orm/session_api.html#sqlalchemy.orm.Session.begin
    "sqlalchemy.orm.Session.begin") explicitly in order to begin the transaction,
    even in `autocommit=False` mode, thus matching the behavior of the future-style
    `_base.Connection`.
  id: totrans-1380
  prefs: []
  type: TYPE_NORMAL
  zh: 新行为是，这个 [`SessionTransaction`](../orm/session_api.html#sqlalchemy.orm.SessionTransaction
    "sqlalchemy.orm.SessionTransaction") 对象现在只在需要时才创建，当调用 [`Session.add()`](../orm/session_api.html#sqlalchemy.orm.Session.add
    "sqlalchemy.orm.Session.add") 或 [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") 等方法时。但现在也可以显式调用 [`Session.begin()`](../orm/session_api.html#sqlalchemy.orm.Session.begin
    "sqlalchemy.orm.Session.begin") 来开始事务，即使在 `autocommit=False` 模式下，从而与未来风格的 `_base.Connection`
    的行为相匹配。
- en: 'The behavioral changes this indicates are:'
  id: totrans-1381
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明的行为变化是：
- en: The [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    can now be in the state where no transaction is begun, even in `autocommit=False`
    mode. Previously, this state was only available in “autocommit” mode.
  id: totrans-1382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，即使在 `autocommit=False` 模式下，[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 也可以处于未开始事务的状态。以前，这种状态仅在“自动提交”模式下可用。
- en: Within this state, the [`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") and [`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") methods are no-ops. Code that relies upon these
    methods to expire all objects should make explicit use of either [`Session.begin()`](../orm/session_api.html#sqlalchemy.orm.Session.begin
    "sqlalchemy.orm.Session.begin") or [`Session.expire_all()`](../orm/session_api.html#sqlalchemy.orm.Session.expire_all
    "sqlalchemy.orm.Session.expire_all") to suit their use case.
  id: totrans-1383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这种状态下，[`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") 和 [`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") 方法不起作用。依赖这些方法来使所有对象过期的代码应明确使用 [`Session.begin()`](../orm/session_api.html#sqlalchemy.orm.Session.begin
    "sqlalchemy.orm.Session.begin") 或 [`Session.expire_all()`](../orm/session_api.html#sqlalchemy.orm.Session.expire_all
    "sqlalchemy.orm.Session.expire_all") 来适应其用例。
- en: The [`SessionEvents.after_transaction_create()`](../orm/events.html#sqlalchemy.orm.SessionEvents.after_transaction_create
    "sqlalchemy.orm.SessionEvents.after_transaction_create") event hook is not emitted
    immediately when the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is created, or after a [`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") or [`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") completes.
  id: totrans-1384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当 [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    创建时，或在 [`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") 或 [`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") 完成后，不会立即触发 [`SessionEvents.after_transaction_create()`](../orm/events.html#sqlalchemy.orm.SessionEvents.after_transaction_create
    "sqlalchemy.orm.SessionEvents.after_transaction_create") 事件钩子。
- en: The [`Session.close()`](../orm/session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") method also does not imply implicit begin of a
    new [`SessionTransaction`](../orm/session_api.html#sqlalchemy.orm.SessionTransaction
    "sqlalchemy.orm.SessionTransaction").
  id: totrans-1385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`Session.close()`](../orm/session_api.html#sqlalchemy.orm.Session.close "sqlalchemy.orm.Session.close")方法也不意味着隐式开始新的[`SessionTransaction`](../orm/session_api.html#sqlalchemy.orm.SessionTransaction
    "sqlalchemy.orm.SessionTransaction")。'
- en: See also
  id: totrans-1386
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Auto Begin](../orm/session_basics.html#session-autobegin)'
  id: totrans-1387
  prefs: []
  type: TYPE_NORMAL
  zh: '[自动开始](../orm/session_basics.html#session-autobegin)'
- en: Rationale
  id: totrans-1388
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 理由
- en: The [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    object’s default behavior of `autocommit=False` historically has meant that there
    is always a [`SessionTransaction`](../orm/session_api.html#sqlalchemy.orm.SessionTransaction
    "sqlalchemy.orm.SessionTransaction") object in play, associated with the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") via the `Session.transaction` attribute. When the given
    [`SessionTransaction`](../orm/session_api.html#sqlalchemy.orm.SessionTransaction
    "sqlalchemy.orm.SessionTransaction") was complete, due to a commit, rollback,
    or close, it was immediately replaced with a new one. The [`SessionTransaction`](../orm/session_api.html#sqlalchemy.orm.SessionTransaction
    "sqlalchemy.orm.SessionTransaction") by itself does not imply the usage of any
    connection-oriented resources, so this long-standing behavior has a particular
    elegance to it in that the state of `Session.transaction` is always predictable
    as non-None.
  id: totrans-1389
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    对象的默认行为`autocommit=False`在历史上意味着始终存在一个与[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")相关联的[`SessionTransaction`](../orm/session_api.html#sqlalchemy.orm.SessionTransaction
    "sqlalchemy.orm.SessionTransaction")对象，通过`Session.transaction`属性关联。当给定的[`SessionTransaction`](../orm/session_api.html#sqlalchemy.orm.SessionTransaction
    "sqlalchemy.orm.SessionTransaction")完成时，由于提交、回滚或关闭，它会立即被新的替代。[`SessionTransaction`](../orm/session_api.html#sqlalchemy.orm.SessionTransaction
    "sqlalchemy.orm.SessionTransaction")本身并不意味着使用任何连接相关资源，因此这种长期存在的行为具有特定的优雅之处，即`Session.transaction`的状态始终可预测为非None。'
- en: However, as part of the initiative in [#5056](https://www.sqlalchemy.org/trac/ticket/5056)
    to greatly reduce reference cycles, this assumption means that calling upon [`Session.close()`](../orm/session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") results in a [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") object that still has reference cycles and is more expensive
    to clean up, not to mention that there is a small overhead in constructing the
    [`SessionTransaction`](../orm/session_api.html#sqlalchemy.orm.SessionTransaction
    "sqlalchemy.orm.SessionTransaction") object, which meant that there would be unnecessary
    overhead created for a [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") that for example invoked [`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") and then [`Session.close()`](../orm/session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close").
  id: totrans-1390
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，作为[#5056](https://www.sqlalchemy.org/trac/ticket/5056)倡议的一部分，大大减少引用循环，这一假设意味着调用[`Session.close()`](../orm/session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close")会导致一个仍然存在引用循环且更昂贵的[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")对象需要清理，更不用说构造[`SessionTransaction`](../orm/session_api.html#sqlalchemy.orm.SessionTransaction
    "sqlalchemy.orm.SessionTransaction")对象的一点开销，这意味着对于例如调用[`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit")然后[`Session.close()`](../orm/session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close")的[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")会创建不必要的开销。
- en: As such, it was decided that [`Session.close()`](../orm/session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") should leave the internal state of `self.transaction`,
    now referred to internally as `self._transaction`, as None, and that a new [`SessionTransaction`](../orm/session_api.html#sqlalchemy.orm.SessionTransaction
    "sqlalchemy.orm.SessionTransaction") should only be created when needed. For consistency
    and code coverage, this behavior was also expanded to include all the points at
    which “autobegin” is expected, not just when [`Session.close()`](../orm/session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") were called.
  id: totrans-1391
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，决定[`Session.close()`](../orm/session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close")应该将`self.transaction`的内部状态，现在在内部称为`self._transaction`，保留为None，并且只有在需要时才会创建新的[`SessionTransaction`](../orm/session_api.html#sqlalchemy.orm.SessionTransaction
    "sqlalchemy.orm.SessionTransaction")。为了一致性和代码覆盖率，此行为还扩展到了所有“自动开始”预期的点，而不仅仅是在调用[`Session.close()`](../orm/session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close")时。
- en: In particular, this causes a behavioral change for applications which subscribe
    to the [`SessionEvents.after_transaction_create()`](../orm/events.html#sqlalchemy.orm.SessionEvents.after_transaction_create
    "sqlalchemy.orm.SessionEvents.after_transaction_create") event hook; previously,
    this event would be emitted when the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") were first constructed, as well as for most actions
    that closed the previous transaction and would emit [`SessionEvents.after_transaction_end()`](../orm/events.html#sqlalchemy.orm.SessionEvents.after_transaction_end
    "sqlalchemy.orm.SessionEvents.after_transaction_end"). The new behavior is that
    [`SessionEvents.after_transaction_create()`](../orm/events.html#sqlalchemy.orm.SessionEvents.after_transaction_create
    "sqlalchemy.orm.SessionEvents.after_transaction_create") is emitted on demand,
    when the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    has not yet created a new [`SessionTransaction`](../orm/session_api.html#sqlalchemy.orm.SessionTransaction
    "sqlalchemy.orm.SessionTransaction") object and mapped objects are associated
    with the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    through methods like [`Session.add()`](../orm/session_api.html#sqlalchemy.orm.Session.add
    "sqlalchemy.orm.Session.add") and [`Session.delete()`](../orm/session_api.html#sqlalchemy.orm.Session.delete
    "sqlalchemy.orm.Session.delete"), when the `Session.transaction` attribute is
    called upon, when the [`Session.flush()`](../orm/session_api.html#sqlalchemy.orm.Session.flush
    "sqlalchemy.orm.Session.flush") method has tasks to complete, etc.
  id: totrans-1392
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，这对订阅[`SessionEvents.after_transaction_create()`](../orm/events.html#sqlalchemy.orm.SessionEvents.after_transaction_create
    "sqlalchemy.orm.SessionEvents.after_transaction_create")事件钩子的应用程序造成了行为上的变化；以前，当首次构建[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")时，此事件将被触发，以及对关闭先前事务的大多数操作，并将触发[`SessionEvents.after_transaction_end()`](../orm/events.html#sqlalchemy.orm.SessionEvents.after_transaction_end
    "sqlalchemy.orm.SessionEvents.after_transaction_end")。新行为是，当[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")尚未创建新的[`SessionTransaction`](../orm/session_api.html#sqlalchemy.orm.SessionTransaction
    "sqlalchemy.orm.SessionTransaction")对象并且映射对象通过[`Session.add()`](../orm/session_api.html#sqlalchemy.orm.Session.add
    "sqlalchemy.orm.Session.add")和[`Session.delete()`](../orm/session_api.html#sqlalchemy.orm.Session.delete
    "sqlalchemy.orm.Session.delete")等方法与[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")关联时，当调用`Session.transaction`属性时，当[`Session.flush()`](../orm/session_api.html#sqlalchemy.orm.Session.flush
    "sqlalchemy.orm.Session.flush")方法有任务要完成时等，[`SessionEvents.after_transaction_create()`](../orm/events.html#sqlalchemy.orm.SessionEvents.after_transaction_create
    "sqlalchemy.orm.SessionEvents.after_transaction_create")会按需触发。
- en: In addition, code which relies upon the [`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") or [`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") method to unconditionally expire all objects
    can no longer do so. Code which needs to expire all objects when no change that
    has occurred should be calling [`Session.expire_all()`](../orm/session_api.html#sqlalchemy.orm.Session.expire_all
    "sqlalchemy.orm.Session.expire_all") for this case.
  id: totrans-1393
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，依赖于[`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit")或[`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback")方法无条件使所有对象过期的代码将不再能够这样做。当没有发生任何更改时需要使所有对象过期的代码应该针对此情况调用[`Session.expire_all()`](../orm/session_api.html#sqlalchemy.orm.Session.expire_all
    "sqlalchemy.orm.Session.expire_all")。
- en: Besides the change in when the [`SessionEvents.after_transaction_create()`](../orm/events.html#sqlalchemy.orm.SessionEvents.after_transaction_create
    "sqlalchemy.orm.SessionEvents.after_transaction_create") event is emitted as well
    as the no-op nature of [`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") or [`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback"), the change should have no other user-visible
    impact on the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    object’s behavior; the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") will continue to have the behavior that it remains usable
    for new operations after [`Session.close()`](../orm/session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") is called, and the sequencing of how the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") interacts with the [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") and the database itself should also remain unaffected,
    since these operations were already operating in an on-demand fashion.
  id: totrans-1394
  prefs: []
  type: TYPE_NORMAL
  zh: 除了更改[`SessionEvents.after_transaction_create()`](../orm/events.html#sqlalchemy.orm.SessionEvents.after_transaction_create
    "sqlalchemy.orm.SessionEvents.after_transaction_create")事件发出的时间以及[`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit")或[`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback")的无操作性质外，此更改不应对[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")对象的行为产生其他用户可见的影响；[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")在调用[`Session.close()`](../orm/session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close")后仍然保持可用于新操作的行为，并且[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")与[`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine")和数据库本身的交互顺序也应保持不受影响，因为这些操作已经以按需方式运行。
- en: '[#5074](https://www.sqlalchemy.org/trac/ticket/5074)  ### Viewonly relationships
    don’t synchronize backrefs'
  id: totrans-1395
  prefs: []
  type: TYPE_NORMAL
  zh: '[#5074](https://www.sqlalchemy.org/trac/ticket/5074)  ### 只读视图关系不同步回引'
- en: In [#5149](https://www.sqlalchemy.org/trac/ticket/5149) in 1.3.14, SQLAlchemy
    began emitting a warning when the [`relationship.backref`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.backref
    "sqlalchemy.orm.relationship") or [`relationship.back_populates`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.back_populates
    "sqlalchemy.orm.relationship") keywords would be used at the same time as the
    [`relationship.viewonly`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.viewonly
    "sqlalchemy.orm.relationship") flag on the target relationship. This was because
    a “viewonly” relationship does not actually persist changes made to it, which
    could cause some misleading behaviors to occur. However, in [#5237](https://www.sqlalchemy.org/trac/ticket/5237),
    we sought to refine this behavior as there are legitimate use cases to have backrefs
    set up on viewonly relationships, including that back populates attributes are
    used in some cases by the relationship lazy loaders to determine that an additional
    eager load in the other direction is not necessary, as well as that back populates
    can be used for mapper introspection and that [`backref()`](../orm/relationship_api.html#sqlalchemy.orm.backref
    "sqlalchemy.orm.backref") can be a convenient way to set up bi-directional relationships.
  id: totrans-1396
  prefs: []
  type: TYPE_NORMAL
  zh: 在1.3.14中的[#5149](https://www.sqlalchemy.org/trac/ticket/5149)中，SQLAlchemy开始在目标关系上同时使用[`relationship.backref`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.backref
    "sqlalchemy.orm.relationship")或[`relationship.back_populates`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.back_populates
    "sqlalchemy.orm.relationship")关键字时发出警告，同时使用[`relationship.viewonly`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.viewonly
    "sqlalchemy.orm.relationship")标志。这是因为“只读”关系实际上不会保存对其所做的更改，这可能导致一些误导行为发生。然而，在[#5237](https://www.sqlalchemy.org/trac/ticket/5237)中，我们试图优化这种行为，因为在只读关系上设置回引是有合法用例的，包括回填属性有时由关系懒加载器用于确定在另一个方向上不需要额外的急加载，以及回填可以用于映射器内省和[`backref()`](../orm/relationship_api.html#sqlalchemy.orm.backref
    "sqlalchemy.orm.backref")可以是设置双向关系的便捷方式。
- en: 'The solution then was to make the “mutation” that occurs from a backref an
    optional thing, using the [`relationship.sync_backref`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.sync_backref
    "sqlalchemy.orm.relationship") flag. In 1.4 the value of [`relationship.sync_backref`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.sync_backref
    "sqlalchemy.orm.relationship") defaults to False for a relationship target that
    also sets [`relationship.viewonly`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.viewonly
    "sqlalchemy.orm.relationship"). This indicates that any changes made to a relationship
    with viewonly will not impact the state of the other side or of the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") in any way:'
  id: totrans-1397
  prefs: []
  type: TYPE_NORMAL
  zh: 当时的解决方案是使从反向引用发生的“变化”成为可选的事情，使用 [`relationship.sync_backref`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.sync_backref
    "sqlalchemy.orm.relationship") 标志。在 1.4 版本中，对于也设置了 [`relationship.viewonly`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.viewonly
    "sqlalchemy.orm.relationship") 的关系目标，默认情况下 [`relationship.sync_backref`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.sync_backref
    "sqlalchemy.orm.relationship") 的值为 False。这表明对于具有 viewonly 的关系所做的任何更改都不会影响另一侧或
    [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    的状态：
- en: '[PRE313]'
  id: totrans-1398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE313]'
- en: Above, the `a1` object will **not** be added to the `u1.addresses` collection,
    nor will the `a1` object be added to the session. Previously, both of these things
    would be true. The warning that [`relationship.sync_backref`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.sync_backref
    "sqlalchemy.orm.relationship") should be set to `False` when [`relationship.viewonly`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.viewonly
    "sqlalchemy.orm.relationship") is `False` is no longer emitted as this is now
    the default behavior.
  id: totrans-1399
  prefs: []
  type: TYPE_NORMAL
  zh: 上面，`a1` 对象将**不会**被添加到 `u1.addresses` 集合中，也不会将 `a1` 对象添加到会话中。之前，这两件事情都是正确的。当
    [`relationship.viewonly`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.viewonly
    "sqlalchemy.orm.relationship") 为 `False` 时，不再发出应将 [`relationship.sync_backref`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.sync_backref
    "sqlalchemy.orm.relationship") 设置为 `False` 的警告，因为这现在是默认行为。
- en: '[#5237](https://www.sqlalchemy.org/trac/ticket/5237)  ### cascade_backrefs
    behavior deprecated for removal in 2.0'
  id: totrans-1400
  prefs: []
  type: TYPE_NORMAL
  zh: '[#5237](https://www.sqlalchemy.org/trac/ticket/5237)  ### 在 2.0 版本中将删除的 cascade_backrefs
    行为'
- en: 'SQLAlchemy has long had a behavior of cascading objects into the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") based on backref assignment. Given `User` below already
    in a [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session"),
    assigning it to the `Address.user` attribute of an `Address` object, assuming
    a bidirectional relationship is set up, would mean that the `Address` also gets
    put into the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    at that point:'
  id: totrans-1401
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 长期以来一直有一个根据反向引用分配将对象级联到 [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 的行为。假设 `User` 已经在 [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 中，将其分配给 `Address` 对象的 `Address.user` 属性，假设已经建立了双向关系，这意味着此时
    `Address` 也会被放入 [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    中：
- en: '[PRE314]'
  id: totrans-1402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE314]'
- en: The above behavior was an unintended side effect of backref behavior, in that
    since `a1.user` implies `u1.addresses.append(a1)`, `a1` would get cascaded into
    the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session").
    This remains the default behavior throughout 1.4\. At some point, a new flag [`relationship.cascade_backrefs`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.cascade_backrefs
    "sqlalchemy.orm.relationship") was added to disable to above behavior, along with
    [`backref.cascade_backrefs`](../orm/relationship_api.html#sqlalchemy.orm.backref.params.cascade_backrefs
    "sqlalchemy.orm.backref") to set this when the relationship is specified by `relationship.backref`,
    as it can be surprising and also gets in the way of some operations where the
    object would be placed in the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") too early and get prematurely flushed.
  id: totrans-1403
  prefs: []
  type: TYPE_NORMAL
  zh: 上述行为是反向引用行为的意外副作用，因为由于 `a1.user` 暗示着 `u1.addresses.append(a1)`，所以 `a1` 将被级联到
    [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    中。这仍然是整个 1.4 版本的默认行为。在某些时候，新增了一个标志 [`relationship.cascade_backrefs`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.cascade_backrefs
    "sqlalchemy.orm.relationship") 来禁用上述行为，以及 [`backref.cascade_backrefs`](../orm/relationship_api.html#sqlalchemy.orm.backref.params.cascade_backrefs
    "sqlalchemy.orm.backref") 来设置此标志，当关系由 `relationship.backref` 指定时，因为这可能会令人惊讶，并且还会妨碍某些操作，其中对象会过早地放入
    [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    中并过早地刷新。
- en: 'In 2.0, the default behavior will be that “cascade_backrefs” is False, and
    additionally there will be no “True” behavior as this is not generally a desirable
    behavior. When 2.0 deprecation warnings are enabled, a warning will be emitted
    when a “backref cascade” actually takes place. To get the new behavior, either
    set [`relationship.cascade_backrefs`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.cascade_backrefs
    "sqlalchemy.orm.relationship") and [`backref.cascade_backrefs`](../orm/relationship_api.html#sqlalchemy.orm.backref.params.cascade_backrefs
    "sqlalchemy.orm.backref") to `False` on any target relationships, as is already
    supported in 1.3 and earlier, or alternatively make use of the [`Session.future`](../orm/session_api.html#sqlalchemy.orm.Session.params.future
    "sqlalchemy.orm.Session") flag to [2.0-style](../glossary.html#term-1) mode:'
  id: totrans-1404
  prefs: []
  type: TYPE_NORMAL
  zh: 在 2.0 版本中，默认行为将是“cascade_backrefs”为 False，另外也不会有“True”行为，因为这通常不是一种理想的行为。当启用
    2.0 版本的弃用警告时，当“反向引用级联”实际发生时，将发出警告。要获取新行为，可以在任何目标关系上将 [`relationship.cascade_backrefs`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.cascade_backrefs
    "sqlalchemy.orm.relationship") 和 [`backref.cascade_backrefs`](../orm/relationship_api.html#sqlalchemy.orm.backref.params.cascade_backrefs
    "sqlalchemy.orm.backref") 设置为 `False`，就像在 1.3 版本和更早版本中已经支持的那样，或者可以使用 [`Session.future`](../orm/session_api.html#sqlalchemy.orm.Session.params.future
    "sqlalchemy.orm.Session") 标志进入 [2.0 样式](../glossary.html#term-1) 模式：
- en: '[PRE315]'
  id: totrans-1405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE315]'
- en: '[#5150](https://www.sqlalchemy.org/trac/ticket/5150)  ### Eager loaders emit
    during unexpire operations'
  id: totrans-1406
  prefs: []
  type: TYPE_NORMAL
  zh: '[#5150](https://www.sqlalchemy.org/trac/ticket/5150)  ### 急切加载器在取消过期操作期间发出'
- en: 'A long sought behavior was that when an expired object is accessed, configured
    eager loaders will run in order to eagerly load relationships on the expired object
    when the object is refreshed or otherwise unexpired. This behavior has now been
    added, so that joinedloaders will add inline JOINs as usual, and selectin/subquery
    loaders will run an “immediateload” operation for a given relationship, when an
    expired object is unexpired or an object is refreshed:'
  id: totrans-1407
  prefs: []
  type: TYPE_NORMAL
  zh: 长期以来，人们一直期待的行为是，当访问过期对象时，配置的急切加载器将运行，以便在刷新或其他情况下未过期时急切加载过期对象上的关系。现已添加了此行为，以便
    joinedloaders 将像往常一样添加内联 JOIN，并且当未过期对象被刷新或对象被刷新时，selectin/subquery 加载器将为给定关系运行“immediateload”操作：
- en: '[PRE316]'
  id: totrans-1408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE316]'
- en: 'Above, the `A` object was loaded with a `joinedload()` option associated with
    it in order to eagerly load the `bs` collection. After the `session.commit()`,
    the state of the object is expired. Upon accessing the `.data` column attribute,
    the object is refreshed and this will now include the joinedload operation as
    well:'
  id: totrans-1409
  prefs: []
  type: TYPE_NORMAL
  zh: 上述 `A` 对象是使用与其关联的 `joinedload()` 选项加载的，以便急切加载 `bs` 集合。在 `session.commit()` 后，对象的状态已过期。在访问
    `.data` 列属性时，对象将被刷新，现在这将包括 joinedload 操作：
- en: '[PRE317]'
  id: totrans-1410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE317]'
- en: The behavior applies both to loader strategies applied to the [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") directly, as well as with options used with [`Query.options()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.options
    "sqlalchemy.orm.Query.options"), provided that the object was originally loaded
    by that query.
  id: totrans-1411
  prefs: []
  type: TYPE_NORMAL
  zh: 该行为适用于直接应用于[`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")的加载策略，以及与[`Query.options()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.options
    "sqlalchemy.orm.Query.options")一起使用的选项，前提是对象最初是由该查询加载的。
- en: 'For the “secondary” eager loaders “selectinload” and “subqueryload”, the SQL
    strategy for these loaders is not necessary in order to eagerly load attributes
    on a single object; so they will instead invoke the “immediateload” strategy in
    a refresh scenario, which resembles the query emitted by “lazyload”, emitted as
    an additional query:'
  id: totrans-1412
  prefs: []
  type: TYPE_NORMAL
  zh: 对于“次要”急加载器“selectinload”和“subqueryload”，这些加载器的SQL策略在单个对象上急加载属性时并不是必要的；因此，在刷新场景中，它们将调用“immediateload”策略，类似于“lazyload”发出的查询，作为额外的查询：
- en: '[PRE318]'
  id: totrans-1413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE318]'
- en: Note that a loader option does not apply to an object that was introduced into
    the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    in a different way. That is, if the `a1` object were just persisted in this [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), or was loaded with a different query before the eager
    option had been applied, then the object doesn’t have an eager load option associated
    with it. This is not a new concept, however users who are looking for the eagerload
    on refresh behavior may find this to be more noticeable.
  id: totrans-1414
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，加载器选项不适用于以不同方式引入到[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")中的对象。也就是说，如果`a1`对象只是在此[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")中持久化，或者在应用急加载选项之前使用不同的查询加载了该对象，则该对象不具有与之关联的急加载选项。这并不是一个新概念，但是寻找刷新行为上的急加载的用户可能会发现这更加明显。
- en: '[#1763](https://www.sqlalchemy.org/trac/ticket/1763)  ### Column loaders such
    as `deferred()`, `with_expression()` only take effect when indicated on the outermost,
    full entity query'
  id: totrans-1415
  prefs: []
  type: TYPE_NORMAL
  zh: '[#1763](https://www.sqlalchemy.org/trac/ticket/1763)  ### 列加载器如`deferred()`、`with_expression()`仅在外部、完整实体查询中指示时才生效'
- en: Note
  id: totrans-1416
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This change note was not present in earlier versions of this document, however
    is relevant for all SQLAlchemy 1.4 versions.
  id: totrans-1417
  prefs: []
  type: TYPE_NORMAL
  zh: 本更改说明在本文档的早期版本中不存在，但对于所有SQLAlchemy 1.4版本都是相关的。
- en: 'A behavior that was never supported in 1.3 and previous versions yet nonetheless
    would have a particular effect was to repurpose column loader options such as
    [`defer()`](../orm/queryguide/columns.html#sqlalchemy.orm.defer "sqlalchemy.orm.defer")
    and [`with_expression()`](../orm/queryguide/columns.html#sqlalchemy.orm.with_expression
    "sqlalchemy.orm.with_expression") in subqueries in order to control which SQL
    expressions would be in the columns clause of each subquery. A typical example
    would be to construct UNION queries, such as:'
  id: totrans-1418
  prefs: []
  type: TYPE_NORMAL
  zh: 1.3版本和之前版本从未支持的行为，但仍然会产生特定效果，即重新利用列加载器选项，如[`defer()`](../orm/queryguide/columns.html#sqlalchemy.orm.defer
    "sqlalchemy.orm.defer")和[`with_expression()`](../orm/queryguide/columns.html#sqlalchemy.orm.with_expression
    "sqlalchemy.orm.with_expression")在子查询中，以控制每个子查询的列子句中的SQL表达式。一个典型的例子是构造UNION查询，例如：
- en: '[PRE319]'
  id: totrans-1419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE319]'
- en: 'In version 1.3, the [`with_expression()`](../orm/queryguide/columns.html#sqlalchemy.orm.with_expression
    "sqlalchemy.orm.with_expression") option would take effect for each element of
    the UNION, such as:'
  id: totrans-1420
  prefs: []
  type: TYPE_NORMAL
  zh: 在1.3版本中，[`with_expression()`](../orm/queryguide/columns.html#sqlalchemy.orm.with_expression
    "sqlalchemy.orm.with_expression")选项会对UNION的每个元素生效，例如：
- en: '[PRE320]'
  id: totrans-1421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE320]'
- en: 'SQLAlchemy 1.4’s notion of loader options has been made more strict, and as
    such are applied to the **outermost part of the query only**, which is the SELECT
    that is intended to populate the actual ORM entities to be returned; the query
    above in 1.4 will produce:'
  id: totrans-1422
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 1.4对加载器选项的概念变得更加严格，因此仅应用于查询的**最外层部分**，即用于填充实际要返回的ORM实体的SELECT；在1.4中，上述查询将产生：
- en: '[PRE321]'
  id: totrans-1423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE321]'
- en: that is, the options for the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") were taken from the first element of the UNION, since
    all loader options are only to be at the topmost level. The option from the second
    query was ignored.
  id: totrans-1424
  prefs: []
  type: TYPE_NORMAL
  zh: 即，[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")的选项是从UNION的第一个元素中获取的，因为所有加载器选项只能在最顶层。第二个查询的选项被忽略了。
- en: Rationale
  id: totrans-1425
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 理由
- en: This behavior now more closely matches that of other kinds of loader options
    such as relationship loader options like [`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload") in all SQLAlchemy versions, 1.3 and earlier included,
    which in a UNION situation were already copied out to the top most level of the
    query, and only taken from the first element of the UNION, discarding any options
    on other parts of the query.
  id: totrans-1426
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为现在更加接近于其他种类的加载器选项，例如所有SQLAlchemy版本中的关系加载器选项，如[`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload")，其中在UNION情况下已经复制到查询的最顶层，并且仅从UNION的第一个元素中获取，舍弃查询的其他部分的任何选项。
- en: This implicit copying and selective ignoring of options, demonstrated above
    as being fairly arbitrary, is a legacy behavior that’s only part of [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query"), and is a particular example of where [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") and its means of applying [`Query.union_all()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.union_all
    "sqlalchemy.orm.Query.union_all") falls short, as it’s ambiguous how to turn a
    single SELECT into a UNION of itself and another query and how loader options
    should be applied to that new statement.
  id: totrans-1427
  prefs: []
  type: TYPE_NORMAL
  zh: 这种隐式复制和选择性忽略选项的行为，如上所示，是相当任意的，是[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")的遗留行为，也是[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")以及其应用[`Query.union_all()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.union_all
    "sqlalchemy.orm.Query.union_all")方式存在不足的一个特定示例，因为如何将单个SELECT转换为其自身和另一个查询的UNION以及如何应用加载器选项到新语句上都是模糊的。
- en: 'SQLAlchemy 1.4’s behavior can be demonstrated as generally superior to that
    of 1.3 for a more common case of using [`defer()`](../orm/queryguide/columns.html#sqlalchemy.orm.defer
    "sqlalchemy.orm.defer"). The following query:'
  id: totrans-1428
  prefs: []
  type: TYPE_NORMAL
  zh: 对于使用[`defer()`](../orm/queryguide/columns.html#sqlalchemy.orm.defer "sqlalchemy.orm.defer")的更常见情况，可以演示SQLAlchemy
    1.4的行为通常优于1.3。以下查询：
- en: '[PRE322]'
  id: totrans-1429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE322]'
- en: 'In 1.3 would awkwardly add NULL to the inner queries and then SELECT it:'
  id: totrans-1430
  prefs: []
  type: TYPE_NORMAL
  zh: 在1.3中，会笨拙地向内部查询添加NULL，然后选择它：
- en: '[PRE323]'
  id: totrans-1431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE323]'
- en: If all queries didn’t have the identical options set up, the above scenario
    would raise an error due to not being able to form a proper UNION.
  id: totrans-1432
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有查询都没有设置相同的选项，上述场景将由于无法形成正确的UNION而引发错误。
- en: 'Whereas in 1.4, the option is applied only at the top layer, omitting the fetch
    for `User.name`, and this complexity is avoided:'
  id: totrans-1433
  prefs: []
  type: TYPE_NORMAL
  zh: 而在1.4中，该选项仅应用于顶层，省略了对`User.name`的提取，并且避免了这种复杂性：
- en: '[PRE324]'
  id: totrans-1434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE324]'
- en: Correct Approach
  id: totrans-1435
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 正确的方法
- en: 'Using [2.0-style](../glossary.html#term-1) querying, no warning is emitted
    at the moment, however the nested [`with_expression()`](../orm/queryguide/columns.html#sqlalchemy.orm.with_expression
    "sqlalchemy.orm.with_expression") options are consistently ignored as they don’t
    apply to an entity being loaded, and are not implicitly copied anywhere. The query
    below produces no output for the [`with_expression()`](../orm/queryguide/columns.html#sqlalchemy.orm.with_expression
    "sqlalchemy.orm.with_expression") calls:'
  id: totrans-1436
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[2.0-style](../glossary.html#term-1)查询时，目前不会发出警告，但是嵌套的[`with_expression()`](../orm/queryguide/columns.html#sqlalchemy.orm.with_expression
    "sqlalchemy.orm.with_expression")选项一致被忽略，因为它们不适用于正在加载的实体，并且不会被隐式复制到任何地方。以下查询不会为[`with_expression()`](../orm/queryguide/columns.html#sqlalchemy.orm.with_expression
    "sqlalchemy.orm.with_expression")调用产生输出：
- en: '[PRE325]'
  id: totrans-1437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE325]'
- en: 'producing the SQL:'
  id: totrans-1438
  prefs: []
  type: TYPE_NORMAL
  zh: 产生SQL：
- en: '[PRE326]'
  id: totrans-1439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE326]'
- en: 'To correctly apply [`with_expression()`](../orm/queryguide/columns.html#sqlalchemy.orm.with_expression
    "sqlalchemy.orm.with_expression") to the `User` entity, it should be applied to
    the outermost level of the query, using an ordinary SQL expression inside the
    columns clause of each SELECT:'
  id: totrans-1440
  prefs: []
  type: TYPE_NORMAL
  zh: 要将[`with_expression()`](../orm/queryguide/columns.html#sqlalchemy.orm.with_expression
    "sqlalchemy.orm.with_expression")正确应用于`User`实体，应将其应用于查询的最外层级，使用每个SELECT的列子句中的普通SQL表达式：
- en: '[PRE327]'
  id: totrans-1441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE327]'
- en: 'Which will produce the expected SQL:'
  id: totrans-1442
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生预期的SQL：
- en: '[PRE328]'
  id: totrans-1443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE328]'
- en: 'The `User` objects themselves will include this expression in their contents
    underneath `User.expr`.  ### Accessing an uninitialized collection attribute on
    a transient object no longer mutates __dict__'
  id: totrans-1444
  prefs: []
  type: TYPE_NORMAL
  zh: '`User`对象本身将在其内容中包含此表达式，在`User.expr`下方。'
- en: 'It has always been SQLAlchemy’s behavior that accessing mapped attributes on
    a newly created object returns an implicitly generated value, rather than raising
    `AttributeError`, such as `None` for scalar attributes or `[]` for a list-holding
    relationship:'
  id: totrans-1445
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy一直以来的行为是，在新创建的对象上访问映射属性会返回一个隐式生成的值，而不是引发`AttributeError`，例如标量属性为`None`或列表关系为`[]`：
- en: '[PRE329]'
  id: totrans-1446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE329]'
- en: 'The rationale for the above behavior was originally to make ORM objects easier
    to work with. Since an ORM object represents an empty row when first created without
    any state, it is intuitive that its un-accessed attributes would resolve to `None`
    (or SQL NULL) for scalars and to empty collections for relationships. In particular,
    it makes possible an extremely common pattern of being able to mutate the new
    collection without manually creating and assigning an empty collection first:'
  id: totrans-1447
  prefs: []
  type: TYPE_NORMAL
  zh: 上述行为的理由最初是为了使ORM对象更易于使用。由于ORM对象在首次创建时代表一个空行而没有任何状态，因此直观地认为其未访问的属性会解析为标量的`None`（或SQL
    NULL），对于关系则解析为空集合。特别是，这使得一种极其常见的模式成为可能，即能够在不手动创建和分配空集合的情况下改变新集合：
- en: '[PRE330]'
  id: totrans-1448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE330]'
- en: 'Up until version 1.0 of SQLAlchemy, the behavior of this initialization system
    for both scalar attributes as well as collections would be that the `None` or
    empty collection would be *populated* into the object’s state, e.g. `__dict__`.
    This meant that the following two operations were equivalent:'
  id: totrans-1449
  prefs: []
  type: TYPE_NORMAL
  zh: 直到SQLAlchemy的1.0版本，对于标量属性以及集合的初始化系统的行为是，`None`或空集合会被*填充*到对象的状态中，例如`__dict__`。这意味着以下两个操作是等效的：
- en: '[PRE331]'
  id: totrans-1450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE331]'
- en: Where above, both `u1` and `u2` would have the value `None` populated in the
    value of the `name` attribute. Since this is a SQL NULL, the ORM would skip including
    these values within an INSERT so that SQL-level defaults take place, if any, else
    the value defaults to NULL on the database side.
  id: totrans-1451
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述情况下，`u1`和`u2`都会在`name`属性的值中填充`None`。由于这是一个SQL NULL，ORM会跳过将这些值包含在INSERT中，以便SQL级别的默认值生效，如果有的话，否则该值默认为数据库端的NULL。
- en: In version 1.0 as part of [Changes to attribute events and other operations
    regarding attributes that have no pre-existing value](migration_10.html#migration-3061),
    this behavior was refined so that the `None` value was no longer populated into
    `__dict__`, only returned. Besides removing the mutating side effect of a getter
    operation, this change also made it possible to set columns that did have server
    defaults to the value NULL by actually assigning `None`, which was now distinguished
    from just reading it.
  id: totrans-1452
  prefs: []
  type: TYPE_NORMAL
  zh: 在1.0版本中作为[关于没有预先存在值的属性的属性事件和其他操作的更改](migration_10.html#migration-3061)的一部分，这种行为被改进，以便`None`值不再填充到`__dict__`中，只是返回。除了消除getter操作的变异副作用外，这种改变还使得可以通过实际分配`None`来将具有服务器默认值的列设置为NULL值，这现在与仅仅读取它有所区别。
- en: 'The change however did not accommodate for collections, where returning an
    empty collection that is not assigned meant that this mutable collection would
    be different each time and also would not be able to correctly accommodate for
    mutating operations (e.g. append, add, etc.) called upon it. While the behavior
    continued to generally not get in anyone’s way, an edge case was eventually identified
    in [#4519](https://www.sqlalchemy.org/trac/ticket/4519) where this empty collection
    could be harmful, which is when the object is merged into a session:'
  id: totrans-1453
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种变化并没有考虑到集合，其中返回一个未分配的空集合意味着这个可变集合每次都会不同，并且也无法正确地适应变异操作（例如追加，添加等）调用它。虽然这种行为通常不会妨碍任何人，但最终在[#4519](https://www.sqlalchemy.org/trac/ticket/4519)中识别出了一个边缘情况，其中这个空集合可能是有害的，即当对象合并到会话中时：
- en: '[PRE332]'
  id: totrans-1454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE332]'
- en: Above, the `.addresses` collection on `merged1` will contain all the `Address()`
    objects that were already in the database. `merged2` will not; because it has
    an empty list implicitly assigned, the `.addresses` collection will be erased.
    This is an example of where this mutating side effect can actually mutate the
    database itself.
  id: totrans-1455
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述情况下，`merged1`上的`.addresses`集合将包含已经在数据库中的所有`Address()`对象。`merged2`不会；因为它有一个隐式分配的空列表，`.addresses`集合将被擦除。这是一个例子，说明这种变异副作用实际上可以改变数据库本身。
- en: While it was considered that perhaps the attribute system should begin using
    strict “plain Python” behavior, raising `AttributeError` in all cases for non-existent
    attributes on non-persistent objects and requiring that all collections be explicitly
    assigned, such a change would likely be too extreme for the vast number of applications
    that have relied upon this behavior for many years, leading to a complex rollout
    / backwards compatibility problem as well as the likelihood that workarounds to
    restore the old behavior would become prevalent, thus rendering the whole change
    ineffective in any case.
  id: totrans-1456
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然考虑过属性系统是否应开始使用严格的“纯Python”行为，在所有情况下为非存在属性的非持久对象引发`AttributeError`，并要求所有集合都必须显式分配，但这样的更改可能对多年来依赖此行为的大量应用程序来说过于极端，导致复杂的发布/向后兼容性问题，以及恢复旧行为的解决方法可能会变得普遍，从而使整个更改在任何情况下都变得无效。
- en: 'The change then is to keep the default producing behavior, but to finally make
    the non-mutating behavior of scalars a reality for collections as well, via the
    addition of additional mechanics in the collection system. When accessing the
    empty attribute, the new collection is created and associated with the state,
    however is not added to `__dict__` until it is actually mutated:'
  id: totrans-1457
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，更改是保持默认的生成行为，但最终使标量的非变异行为对集合也成为现实，通过在集合系统中添加额外的机制。访问空属性时，将创建新集合并与状态关联，但直到实际发生变异才添加到`__dict__`中：
- en: '[PRE333]'
  id: totrans-1458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE333]'
- en: 'When the list is changed, then it becomes part of the tracked changes to be
    persisted to the database:'
  id: totrans-1459
  prefs: []
  type: TYPE_NORMAL
  zh: 当列表发生更改时，它将成为要持久化到数据库的已跟踪更改的一部分：
- en: '[PRE334]'
  id: totrans-1460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE334]'
- en: 'This change is expected to have *nearly* no impact on existing applications
    in any way, except that it has been observed that some applications may be relying
    upon the implicit assignment of this collection, such as to assert that the object
    contains certain values based on its `__dict__`:'
  id: totrans-1461
  prefs: []
  type: TYPE_NORMAL
  zh: 预计这种更改几乎不会对现有应用程序产生任何影响，除了观察到一些应用程序可能依赖于对该集合的隐式分配，例如根据其`__dict__`断定对象包含某些值：
- en: '[PRE335]'
  id: totrans-1462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE335]'
- en: 'or to ensure that the collection won’t require a lazy load to proceed, the
    (admittedly awkward) code below will now also fail:'
  id: totrans-1463
  prefs: []
  type: TYPE_NORMAL
  zh: 或者确保集合不需要进行延迟加载以继续进行，下面（尽管有些笨拙）的代码现在也会失败：
- en: '[PRE336]'
  id: totrans-1464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE336]'
- en: 'Applications that rely upon the implicit mutating behavior of collections will
    need to be changed so that they assign the desired collection explicitly:'
  id: totrans-1465
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖于集合的隐式变异行为的应用程序将需要更改，以便显式分配所需的集合：
- en: '[PRE337]'
  id: totrans-1466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE337]'
- en: '[#4519](https://www.sqlalchemy.org/trac/ticket/4519)  ### The “New instance
    conflicts with existing identity” error is now a warning'
  id: totrans-1467
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4519](https://www.sqlalchemy.org/trac/ticket/4519)  ### “新实例与现有标识冲突”错误现在是一个警告'
- en: 'SQLAlchemy has always had logic to detect when an object in the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") to be inserted has the same primary key as an object
    that is already present:'
  id: totrans-1468
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy一直具有逻辑来检测要插入的[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")中的对象是否具有与已存在对象相同的主键：
- en: '[PRE338]'
  id: totrans-1469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE338]'
- en: 'The change is that the [`FlushError`](../orm/exceptions.html#sqlalchemy.orm.exc.FlushError
    "sqlalchemy.orm.exc.FlushError") is altered to be only a warning:'
  id: totrans-1470
  prefs: []
  type: TYPE_NORMAL
  zh: 更改是将[`FlushError`](../orm/exceptions.html#sqlalchemy.orm.exc.FlushError "sqlalchemy.orm.exc.FlushError")更改为仅作为警告：
- en: '[PRE339]'
  id: totrans-1471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE339]'
- en: 'Subsequent to that, the condition will attempt to insert the row into the database
    which will emit [`IntegrityError`](../core/exceptions.html#sqlalchemy.exc.IntegrityError
    "sqlalchemy.exc.IntegrityError"), which is the same error that would be raised
    if the primary key identity was not already present in the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"):'
  id: totrans-1472
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，该条件将尝试将行插入数据库，这将引发[`IntegrityError`](../core/exceptions.html#sqlalchemy.exc.IntegrityError
    "sqlalchemy.exc.IntegrityError")，这是与[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")中尚不存在主键标识时引发的相同错误：
- en: '[PRE340]'
  id: totrans-1473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE340]'
- en: 'The rationale is to allow code that is using [`IntegrityError`](../core/exceptions.html#sqlalchemy.exc.IntegrityError
    "sqlalchemy.exc.IntegrityError") to catch duplicates to function regardless of
    the existing state of the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), as is often done using savepoints:'
  id: totrans-1474
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许使用[`IntegrityError`](../core/exceptions.html#sqlalchemy.exc.IntegrityError
    "sqlalchemy.exc.IntegrityError")的代码捕获重复项而无需考虑[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")的现有状态，通常使用保存点来实现：
- en: '[PRE341]'
  id: totrans-1475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE341]'
- en: The above logic was not fully feasible earlier, as in the case that the `Product`
    object with the existing identity were already in the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), the code would also have to catch [`FlushError`](../orm/exceptions.html#sqlalchemy.orm.exc.FlushError
    "sqlalchemy.orm.exc.FlushError"), which additionally is not filtered for the specific
    condition of integrity issues. With the change, the above block behaves consistently
    with the exception of the warning also being emitted.
  id: totrans-1476
  prefs: []
  type: TYPE_NORMAL
  zh: 以前的逻辑并不完全可行，因为如果具有现有标识的`Product`对象已经在[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")中，代码还必须捕获[`FlushError`](../orm/exceptions.html#sqlalchemy.orm.exc.FlushError
    "sqlalchemy.orm.exc.FlushError")，此外，该错误也没有针对完整性问题的特定条件进行过滤。通过更改，上述块的行为与发出警告的异常一致。
- en: Since the logic in question deals with the primary key, all databases emit an
    integrity error in the case of primary key conflicts on INSERT. The case where
    an error would not be raised, that would have earlier, is the extremely unusual
    scenario of a mapping that defines a primary key on the mapped selectable that
    is more restrictive than what is actually configured in the database schema, such
    as when mapping to joins of tables or when defining additional columns as part
    of a composite primary key that is not actually constrained in the database schema.
    However, these situations also work more consistently in that the INSERT would
    theoretically proceed whether or not the existing identity were still in the database.
    The warning can also be configured to raise an exception using the Python warnings
    filter.
  id: totrans-1477
  prefs: []
  type: TYPE_NORMAL
  zh: 由于涉及主键的逻辑，所有数据库在插入时发生主键冲突时都会发出完整性错误。不会引发错误的情况是极为罕见的，即定义了一个在映射的可选择项上定义了一个比实际配置的数据库模式更严格的主键的映射，例如在映射到表的连接或在定义附加列作为复合主键的一部分时，这些列实际上在数据库模式中没有约束。然而，这些情况也更一致地工作，即使现有标识仍然存在于数据库中，插入理论上也会继续进行。警告也可以使用Python警告过滤器配置为引发异常。
- en: '[#4662](https://www.sqlalchemy.org/trac/ticket/4662)  ### Persistence-related
    cascade operations disallowed with viewonly=True'
  id: totrans-1478
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4662](https://www.sqlalchemy.org/trac/ticket/4662)  ### 持久性相关级联操作不允许与viewonly=True '
- en: When a [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") is set as `viewonly=True` using the [`relationship.viewonly`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.viewonly
    "sqlalchemy.orm.relationship") flag, it indicates this relationship should only
    be used to load data from the database, and should not be mutated or involved
    in a persistence operation. In order to ensure this contract works successfully,
    the relationship can no longer specify [`relationship.cascade`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.cascade
    "sqlalchemy.orm.relationship") settings that make no sense in terms of “viewonly”.
  id: totrans-1479
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用[`relationship.viewonly`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.viewonly
    "sqlalchemy.orm.relationship")标志将[`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")设置为`viewonly=True`时，表示此关系仅用于从数据库加载数据，不应进行变异或参与持久化操作。为了确保此约定成功运行，关系不能再指定在“viewonly”方面毫无意义的[`relationship.cascade`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.cascade
    "sqlalchemy.orm.relationship")设置。
- en: 'The primary targets here are the “delete, delete-orphan” cascades, which through
    1.3 continued to impact persistence even if viewonly were True, which is a bug;
    even if viewonly were True, an object would still cascade these two operations
    onto the related object if the parent were deleted or the object were detached.
    Rather than modify the cascade operations to check for viewonly, the configuration
    of both of these together is simply disallowed:'
  id: totrans-1480
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的主要目标是“delete, delete-orphan”级联，即使`viewonly`为True，通过1.3仍会影响持久性，这是一个错误；即使`viewonly`为True，如果删除父对象或分离对象，对象仍会级联这两个操作到相关对象。而不是修改级联操作以检查`viewonly`，这两者的配置被简单地禁止在一起：
- en: '[PRE342]'
  id: totrans-1481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE342]'
- en: 'The above will raise:'
  id: totrans-1482
  prefs: []
  type: TYPE_NORMAL
  zh: 上述将引发：
- en: '[PRE343]'
  id: totrans-1483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE343]'
- en: Applications that have this issue should be emitting a warning as of SQLAlchemy
    1.3.12, and for the above error the solution is to remove the cascade settings
    for a viewonly relationship.
  id: totrans-1484
  prefs: []
  type: TYPE_NORMAL
  zh: 从SQLAlchemy 1.3.12开始，存在此问题的应用程序应发出警告，对于上述错误，解决方案是删除视图关系的级联设置。
- en: '[#4993](https://www.sqlalchemy.org/trac/ticket/4993) [#4994](https://www.sqlalchemy.org/trac/ticket/4994)  ###
    Stricter behavior when querying inheritance mappings using custom queries'
  id: totrans-1485
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4993](https://www.sqlalchemy.org/trac/ticket/4993) [#4994](https://www.sqlalchemy.org/trac/ticket/4994)  ###
    使用自定义查询查询继承映射时更严格的行为'
- en: This change applies to the scenario where a joined- or single- table inheritance
    subclass entity is being queried, given a completed SELECT subquery to select
    from. If the given subquery returns rows that do not correspond to the requested
    polymorphic identity or identities, an error is raised. Previously, this condition
    would pass silently under joined table inheritance, returning an invalid subclass,
    and under single table inheritance, the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") would be adding additional criteria against the subquery
    to limit the results which could inappropriately interfere with the intent of
    the query.
  id: totrans-1486
  prefs: []
  type: TYPE_NORMAL
  zh: 此更改适用于查询已完成的SELECT子查询以选择的连接或单表继承子类实体的情况。如果给定的子查询返回的行不对应于请求的多态标识或标识，则会引发错误。在以前的情况下，这种条件在连接表继承下会悄悄通过，返回一个无效的子类，在单表继承下，[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")会添加额外的条件来限制结果，这可能会不当地干扰查询的意图。
- en: 'Given the example mapping of `Employee`, `Engineer(Employee)`, `Manager(Employee)`,
    in the 1.3 series if we were to emit the following query against a joined inheritance
    mapping:'
  id: totrans-1487
  prefs: []
  type: TYPE_NORMAL
  zh: 给定`Employee`，`Engineer(Employee)`，`Manager(Employee)`的映射示例，在1.3系列中，如果我们针对连接继承映射发出以下查询：
- en: '[PRE344]'
  id: totrans-1488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE344]'
- en: 'The subquery selects both the `Engineer` and the `Manager` rows, and even though
    the outer query is against `Manager`, we get a non `Manager` object back:'
  id: totrans-1489
  prefs: []
  type: TYPE_NORMAL
  zh: 子查询选择了`Engineer`和`Manager`行，即使外部查询针对`Manager`，我们也会得到一个非`Manager`对象：
- en: '[PRE345]'
  id: totrans-1490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE345]'
- en: 'The new behavior is that this condition raises an error:'
  id: totrans-1491
  prefs: []
  type: TYPE_NORMAL
  zh: 新的行为是这种情况会引发错误：
- en: '[PRE346]'
  id: totrans-1492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE346]'
- en: The above error only raises if the primary key columns of that entity are non-NULL.
    If there’s no primary key for a given entity in a row, no attempt to construct
    an entity is made.
  id: totrans-1493
  prefs: []
  type: TYPE_NORMAL
  zh: 仅当该实体的主键列为非NULL时，才会引发上述错误。如果一行中没有给定实体的主键，则不会尝试构造实体。
- en: 'In the case of single inheritance mapping, the change in behavior is slightly
    more involved; if `Engineer` and `Manager` above are mapped with single table
    inheritance, in 1.3 the following query would be emitted and only a `Manager`
    object is returned:'
  id: totrans-1494
  prefs: []
  type: TYPE_NORMAL
  zh: 在单继承映射的情况下，行为的变化稍微更加复杂；如果上面的`Engineer`和`Manager`被映射为单表继承，那么在1.3版本中将会发出以下查询，并且只返回一个`Manager`对象：
- en: '[PRE347]'
  id: totrans-1495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE347]'
- en: 'The [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    added the “single table inheritance” criteria to the subquery, editorializing
    on the intent that was originally set up by it. This behavior was added in version
    1.0 in [#3891](https://www.sqlalchemy.org/trac/ticket/3891), and creates a behavioral
    inconsistency between “joined” and “single” table inheritance, and additionally
    modifies the intent of the given query, which may intend to return additional
    rows where the columns that correspond to the inheriting entity are NULL, which
    is a valid use case. The behavior is now equivalent to that of joined table inheritance,
    where it is assumed that the subquery returns the correct rows and an error is
    raised if an unexpected polymorphic identity is encountered:'
  id: totrans-1496
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")向子查询添加了“单表继承”条件，对其最初设置的意图进行了评论。这种行为是在1.0版本中添加的[#3891](https://www.sqlalchemy.org/trac/ticket/3891)，在“连接”和“单”表继承之间创建了行为不一致，并且修改了给定查询的意图，可能意图返回额外的行，其中对应于继承实体的列为NULL，这是一个有效的用例。现在的行为等同于连接表继承的行为，假定子查询返回正确的行，如果遇到意外的多态标识，则会引发错误：'
- en: '[PRE348]'
  id: totrans-1497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE348]'
- en: 'The correct adjustment to the situation as presented above which worked on
    1.3 is to adjust the given subquery to correctly filter the rows based on the
    discriminator column:'
  id: totrans-1498
  prefs: []
  type: TYPE_NORMAL
  zh: 对于上述情况的正确调整是在1.3上运行的，调整给定的子查询以根据鉴别器列正确过滤行：
- en: '[PRE349]'
  id: totrans-1499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE349]'
- en: '[PRE350]'
  id: totrans-1500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE350]'
- en: '[#5122](https://www.sqlalchemy.org/trac/ticket/5122)  ### The “KeyedTuple”
    object returned by Query is replaced by Row'
  id: totrans-1501
  prefs: []
  type: TYPE_NORMAL
  zh: '[#5122](https://www.sqlalchemy.org/trac/ticket/5122)  ### 查询返回的“KeyedTuple”对象被“Row”替换'
- en: As discussed at [RowProxy is no longer a “proxy”; is now called Row and behaves
    like an enhanced named tuple](#change-4710-core), the Core `RowProxy` object is
    now replaced by a class called [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row"). The base [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") object now behaves more fully like a named tuple, and
    as such it is now used as the basis for tuple-like results returned by the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object, rather than the previous “KeyedTuple” class.
  id: totrans-1502
  prefs: []
  type: TYPE_NORMAL
  zh: 如在[RowProxy 不再是“代理”；现在被称为 Row，并且表现得像一个增强的命名元组](#change-4710-core)中所讨论的，Core
    `RowProxy` 对象现在被一个名为[`Row`](../core/connections.html#sqlalchemy.engine.Row "sqlalchemy.engine.Row")的类所取代。基本的[`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row")对象现在更像一个命名元组，因此它现在被用作由[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")对象返回的类似元组的结果的基础，而不是以前的“KeyedTuple”类。
- en: The rationale is so that by SQLAlchemy 2.0, both Core and ORM SELECT statements
    will return result rows using the same [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") object which behaves like a named tuple. Dictionary-like
    functionality is available from [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") via the [`Row._mapping`](../core/connections.html#sqlalchemy.engine.Row._mapping
    "sqlalchemy.engine.Row._mapping") attribute. In the interim, Core result sets
    will make use of a [`Row`](../core/connections.html#sqlalchemy.engine.Row "sqlalchemy.engine.Row")
    subclass `LegacyRow` which maintains the previous dict/tuple hybrid behavior for
    backwards compatibility while the [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") class will be used directly for ORM tuple results returned
    by the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    object.
  id: totrans-1503
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的理由是到 SQLAlchemy 2.0，Core 和 ORM SELECT 语句将使用行为类似命名元组的相同[`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row")对象返回结果行。通过[`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row")的[`Row._mapping`](../core/connections.html#sqlalchemy.engine.Row._mapping
    "sqlalchemy.engine.Row._mapping")属性可以获得类似字典的功能。在此期间，Core 结果集将使用一个[`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row")子类 `LegacyRow`，它保持了以前的字典/元组混合行为以实现向后兼容性，而[`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row")类将直接用于由[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")对象返回的 ORM 元组结果。
- en: 'Effort has been made to get most of the featureset of [`Row`](../core/connections.html#sqlalchemy.engine.Row
    "sqlalchemy.engine.Row") to be available within the ORM, meaning that access by
    string name as well as entity / column should work:'
  id: totrans-1504
  prefs: []
  type: TYPE_NORMAL
  zh: 已经努力使[`Row`](../core/connections.html#sqlalchemy.engine.Row "sqlalchemy.engine.Row")的大部分功能集在
    ORM 中可用，这意味着可以通过字符串名称以及实体/列进行访问：
- en: '[PRE351]'
  id: totrans-1505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE351]'
- en: See also
  id: totrans-1506
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[RowProxy is no longer a “proxy”; is now called Row and behaves like an enhanced
    named tuple](#change-4710-core)'
  id: totrans-1507
  prefs: []
  type: TYPE_NORMAL
  zh: '[RowProxy 不再是“代理”；现在被称为 Row，并且表现得像一个增强的命名元组](#change-4710-core)'
- en: '[#4710](https://www.sqlalchemy.org/trac/ticket/4710).'
  id: totrans-1508
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4710](https://www.sqlalchemy.org/trac/ticket/4710).'
- en: '### Session features new “autobegin” behavior'
  id: totrans-1509
  prefs: []
  type: TYPE_NORMAL
  zh: '### Session 新的“autobegin”行为特性'
- en: Previously, the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    in its default mode of `autocommit=False` would internally begin a [`SessionTransaction`](../orm/session_api.html#sqlalchemy.orm.SessionTransaction
    "sqlalchemy.orm.SessionTransaction") object immediately on construction, and additionally
    would create a new one after each call to [`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") or [`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit").
  id: totrans-1510
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，在其默认模式`autocommit=False`下，[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")会在构造时立即内部开始一个[`SessionTransaction`](../orm/session_api.html#sqlalchemy.orm.SessionTransaction
    "sqlalchemy.orm.SessionTransaction")对象，并且在每次调用[`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback")或[`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit")后还会创建一个新的对象。
- en: The new behavior is that this [`SessionTransaction`](../orm/session_api.html#sqlalchemy.orm.SessionTransaction
    "sqlalchemy.orm.SessionTransaction") object is now created on demand only, when
    methods such as [`Session.add()`](../orm/session_api.html#sqlalchemy.orm.Session.add
    "sqlalchemy.orm.Session.add") or [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") are called. However it is also now possible
    to call [`Session.begin()`](../orm/session_api.html#sqlalchemy.orm.Session.begin
    "sqlalchemy.orm.Session.begin") explicitly in order to begin the transaction,
    even in `autocommit=False` mode, thus matching the behavior of the future-style
    `_base.Connection`.
  id: totrans-1511
  prefs: []
  type: TYPE_NORMAL
  zh: 新的行为是，只有在调用诸如[`Session.add()`](../orm/session_api.html#sqlalchemy.orm.Session.add
    "sqlalchemy.orm.Session.add")或[`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute")等方法时，才会按需创建此[`SessionTransaction`](../orm/session_api.html#sqlalchemy.orm.SessionTransaction
    "sqlalchemy.orm.SessionTransaction")对象。然而，现在也可以显式调用[`Session.begin()`](../orm/session_api.html#sqlalchemy.orm.Session.begin
    "sqlalchemy.orm.Session.begin")来开始事务，即使在`autocommit=False`模式下，从而与未来风格的`_base.Connection`的行为相匹配。
- en: 'The behavioral changes this indicates are:'
  id: totrans-1512
  prefs: []
  type: TYPE_NORMAL
  zh: 这些变化所指示的行为变化是：
- en: The [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    can now be in the state where no transaction is begun, even in `autocommit=False`
    mode. Previously, this state was only available in “autocommit” mode.
  id: totrans-1513
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，[`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")可以处于未开始任何事务的状态，即使在`autocommit=False`模式下。以前，这种状态仅在“自动提交”模式下可用。
- en: Within this state, the [`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") and [`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") methods are no-ops. Code that relies upon these
    methods to expire all objects should make explicit use of either [`Session.begin()`](../orm/session_api.html#sqlalchemy.orm.Session.begin
    "sqlalchemy.orm.Session.begin") or [`Session.expire_all()`](../orm/session_api.html#sqlalchemy.orm.Session.expire_all
    "sqlalchemy.orm.Session.expire_all") to suit their use case.
  id: totrans-1514
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在这种状态下，[`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit")和[`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback")方法是无操作的。依赖这些方法使所有对象过期的代码应明确使用[`Session.begin()`](../orm/session_api.html#sqlalchemy.orm.Session.begin
    "sqlalchemy.orm.Session.begin")或[`Session.expire_all()`](../orm/session_api.html#sqlalchemy.orm.Session.expire_all
    "sqlalchemy.orm.Session.expire_all")来适应其用例。
- en: The [`SessionEvents.after_transaction_create()`](../orm/events.html#sqlalchemy.orm.SessionEvents.after_transaction_create
    "sqlalchemy.orm.SessionEvents.after_transaction_create") event hook is not emitted
    immediately when the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is created, or after a [`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") or [`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") completes.
  id: totrans-1515
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当[`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")被创建时，或在[`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback")或[`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit")完成后，[`SessionEvents.after_transaction_create()`](../orm/events.html#sqlalchemy.orm.SessionEvents.after_transaction_create
    "sqlalchemy.orm.SessionEvents.after_transaction_create")事件钩子不会立即触发。
- en: The [`Session.close()`](../orm/session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") method also does not imply implicit begin of a
    new [`SessionTransaction`](../orm/session_api.html#sqlalchemy.orm.SessionTransaction
    "sqlalchemy.orm.SessionTransaction").
  id: totrans-1516
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`Session.close()`](../orm/session_api.html#sqlalchemy.orm.Session.close "sqlalchemy.orm.Session.close")方法也不意味着隐式开始新的[`SessionTransaction`](../orm/session_api.html#sqlalchemy.orm.SessionTransaction
    "sqlalchemy.orm.SessionTransaction")。'
- en: See also
  id: totrans-1517
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Auto Begin](../orm/session_basics.html#session-autobegin)'
  id: totrans-1518
  prefs: []
  type: TYPE_NORMAL
  zh: '[自动开始](../orm/session_basics.html#session-autobegin)'
- en: Rationale
  id: totrans-1519
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 理由
- en: The [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    object’s default behavior of `autocommit=False` historically has meant that there
    is always a [`SessionTransaction`](../orm/session_api.html#sqlalchemy.orm.SessionTransaction
    "sqlalchemy.orm.SessionTransaction") object in play, associated with the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") via the `Session.transaction` attribute. When the given
    [`SessionTransaction`](../orm/session_api.html#sqlalchemy.orm.SessionTransaction
    "sqlalchemy.orm.SessionTransaction") was complete, due to a commit, rollback,
    or close, it was immediately replaced with a new one. The [`SessionTransaction`](../orm/session_api.html#sqlalchemy.orm.SessionTransaction
    "sqlalchemy.orm.SessionTransaction") by itself does not imply the usage of any
    connection-oriented resources, so this long-standing behavior has a particular
    elegance to it in that the state of `Session.transaction` is always predictable
    as non-None.
  id: totrans-1520
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")对象的默认行为`autocommit=False`历史上意味着始终有一个与[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")相关联的[`SessionTransaction`](../orm/session_api.html#sqlalchemy.orm.SessionTransaction
    "sqlalchemy.orm.SessionTransaction")对象，通过`Session.transaction`属性关联。当给定的[`SessionTransaction`](../orm/session_api.html#sqlalchemy.orm.SessionTransaction
    "sqlalchemy.orm.SessionTransaction")完成时，由于提交、回滚或关闭，它会立即被新的替换。[`SessionTransaction`](../orm/session_api.html#sqlalchemy.orm.SessionTransaction
    "sqlalchemy.orm.SessionTransaction")本身并不意味着使用任何连接相关资源，因此这种长期存在的行为具有特定的优雅之处，即`Session.transaction`的状态始终可预测为非None。'
- en: However, as part of the initiative in [#5056](https://www.sqlalchemy.org/trac/ticket/5056)
    to greatly reduce reference cycles, this assumption means that calling upon [`Session.close()`](../orm/session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") results in a [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") object that still has reference cycles and is more expensive
    to clean up, not to mention that there is a small overhead in constructing the
    [`SessionTransaction`](../orm/session_api.html#sqlalchemy.orm.SessionTransaction
    "sqlalchemy.orm.SessionTransaction") object, which meant that there would be unnecessary
    overhead created for a [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") that for example invoked [`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") and then [`Session.close()`](../orm/session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close").
  id: totrans-1521
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，作为减少引用循环的倡议的一部分[#5056](https://www.sqlalchemy.org/trac/ticket/5056)，这意味着调用[`Session.close()`](../orm/session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close")会导致一个仍然存在引用循环且更昂贵的[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")对象，清理起来更加费力，更不用说构造[`SessionTransaction`](../orm/session_api.html#sqlalchemy.orm.SessionTransaction
    "sqlalchemy.orm.SessionTransaction")对象时会有一些额外开销，这意味着对于一个例如调用了[`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit")然后又调用[`Session.close()`](../orm/session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close")的[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")会产生不必要的开销。
- en: As such, it was decided that [`Session.close()`](../orm/session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") should leave the internal state of `self.transaction`,
    now referred to internally as `self._transaction`, as None, and that a new [`SessionTransaction`](../orm/session_api.html#sqlalchemy.orm.SessionTransaction
    "sqlalchemy.orm.SessionTransaction") should only be created when needed. For consistency
    and code coverage, this behavior was also expanded to include all the points at
    which “autobegin” is expected, not just when [`Session.close()`](../orm/session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") were called.
  id: totrans-1522
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，决定[`Session.close()`](../orm/session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close")应该将`self.transaction`的内部状态，现在在内部称为`self._transaction`，保留为None，并且只有在需要时才创建新的[`SessionTransaction`](../orm/session_api.html#sqlalchemy.orm.SessionTransaction
    "sqlalchemy.orm.SessionTransaction")。为了保持一致性和代码覆盖率，这种行为也扩展到了所有“autobegin”预期的点，而不仅仅是调用[`Session.close()`](../orm/session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close")时。
- en: In particular, this causes a behavioral change for applications which subscribe
    to the [`SessionEvents.after_transaction_create()`](../orm/events.html#sqlalchemy.orm.SessionEvents.after_transaction_create
    "sqlalchemy.orm.SessionEvents.after_transaction_create") event hook; previously,
    this event would be emitted when the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") were first constructed, as well as for most actions
    that closed the previous transaction and would emit [`SessionEvents.after_transaction_end()`](../orm/events.html#sqlalchemy.orm.SessionEvents.after_transaction_end
    "sqlalchemy.orm.SessionEvents.after_transaction_end"). The new behavior is that
    [`SessionEvents.after_transaction_create()`](../orm/events.html#sqlalchemy.orm.SessionEvents.after_transaction_create
    "sqlalchemy.orm.SessionEvents.after_transaction_create") is emitted on demand,
    when the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    has not yet created a new [`SessionTransaction`](../orm/session_api.html#sqlalchemy.orm.SessionTransaction
    "sqlalchemy.orm.SessionTransaction") object and mapped objects are associated
    with the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    through methods like [`Session.add()`](../orm/session_api.html#sqlalchemy.orm.Session.add
    "sqlalchemy.orm.Session.add") and [`Session.delete()`](../orm/session_api.html#sqlalchemy.orm.Session.delete
    "sqlalchemy.orm.Session.delete"), when the `Session.transaction` attribute is
    called upon, when the [`Session.flush()`](../orm/session_api.html#sqlalchemy.orm.Session.flush
    "sqlalchemy.orm.Session.flush") method has tasks to complete, etc.
  id: totrans-1523
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，这对订阅[`SessionEvents.after_transaction_create()`](../orm/events.html#sqlalchemy.orm.SessionEvents.after_transaction_create
    "sqlalchemy.orm.SessionEvents.after_transaction_create")事件钩子的应用程序造成了行为上的改变；以前，当首次构建[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")时，此事件将被触发，以及对关闭先前事务的大多数操作，并将触发[`SessionEvents.after_transaction_end()`](../orm/events.html#sqlalchemy.orm.SessionEvents.after_transaction_end
    "sqlalchemy.orm.SessionEvents.after_transaction_end")。新行为是，当[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")尚未创建新的[`SessionTransaction`](../orm/session_api.html#sqlalchemy.orm.SessionTransaction
    "sqlalchemy.orm.SessionTransaction")对象并且映射对象通过[`Session.add()`](../orm/session_api.html#sqlalchemy.orm.Session.add
    "sqlalchemy.orm.Session.add")和[`Session.delete()`](../orm/session_api.html#sqlalchemy.orm.Session.delete
    "sqlalchemy.orm.Session.delete")等方法与[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")关联时，当调用`Session.transaction`属性时，当[`Session.flush()`](../orm/session_api.html#sqlalchemy.orm.Session.flush
    "sqlalchemy.orm.Session.flush")方法有任务要完成时等，[`SessionEvents.after_transaction_create()`](../orm/events.html#sqlalchemy.orm.SessionEvents.after_transaction_create
    "sqlalchemy.orm.SessionEvents.after_transaction_create")会按需触发。
- en: In addition, code which relies upon the [`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") or [`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") method to unconditionally expire all objects
    can no longer do so. Code which needs to expire all objects when no change that
    has occurred should be calling [`Session.expire_all()`](../orm/session_api.html#sqlalchemy.orm.Session.expire_all
    "sqlalchemy.orm.Session.expire_all") for this case.
  id: totrans-1524
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，依赖于[`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit")或[`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback")方法无条件使所有对象过期的代码将不再能够这样做。当没有发生任何更改时需要使所有对象过期的代码应该在这种情况下调用[`Session.expire_all()`](../orm/session_api.html#sqlalchemy.orm.Session.expire_all
    "sqlalchemy.orm.Session.expire_all")。
- en: Besides the change in when the [`SessionEvents.after_transaction_create()`](../orm/events.html#sqlalchemy.orm.SessionEvents.after_transaction_create
    "sqlalchemy.orm.SessionEvents.after_transaction_create") event is emitted as well
    as the no-op nature of [`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") or [`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback"), the change should have no other user-visible
    impact on the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    object’s behavior; the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") will continue to have the behavior that it remains usable
    for new operations after [`Session.close()`](../orm/session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") is called, and the sequencing of how the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") interacts with the [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") and the database itself should also remain unaffected,
    since these operations were already operating in an on-demand fashion.
  id: totrans-1525
  prefs: []
  type: TYPE_NORMAL
  zh: 除了[`SessionEvents.after_transaction_create()`](../orm/events.html#sqlalchemy.orm.SessionEvents.after_transaction_create
    "sqlalchemy.orm.SessionEvents.after_transaction_create")事件发出的时间变化以及[`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit")或[`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback")的无操作性质之外，这种变化对[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")对象的行为应该没有其他用户可见的影响；[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")在调用[`Session.close()`](../orm/session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close")后仍然保持可用于新操作的行为，并且[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")与[`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine")以及数据库本身的交互顺序也应该保持不受影响，因为这些操作已经以按需方式运行。
- en: '[#5074](https://www.sqlalchemy.org/trac/ticket/5074)'
  id: totrans-1526
  prefs: []
  type: TYPE_NORMAL
  zh: '[#5074](https://www.sqlalchemy.org/trac/ticket/5074)'
- en: Rationale
  id: totrans-1527
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 理由
- en: The [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    object’s default behavior of `autocommit=False` historically has meant that there
    is always a [`SessionTransaction`](../orm/session_api.html#sqlalchemy.orm.SessionTransaction
    "sqlalchemy.orm.SessionTransaction") object in play, associated with the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") via the `Session.transaction` attribute. When the given
    [`SessionTransaction`](../orm/session_api.html#sqlalchemy.orm.SessionTransaction
    "sqlalchemy.orm.SessionTransaction") was complete, due to a commit, rollback,
    or close, it was immediately replaced with a new one. The [`SessionTransaction`](../orm/session_api.html#sqlalchemy.orm.SessionTransaction
    "sqlalchemy.orm.SessionTransaction") by itself does not imply the usage of any
    connection-oriented resources, so this long-standing behavior has a particular
    elegance to it in that the state of `Session.transaction` is always predictable
    as non-None.
  id: totrans-1528
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    对象的默认行为`autocommit=False`在历史上意味着始终存在一个与[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")相关联的[`SessionTransaction`](../orm/session_api.html#sqlalchemy.orm.SessionTransaction
    "sqlalchemy.orm.SessionTransaction")对象，通过`Session.transaction`属性关联。当给定的[`SessionTransaction`](../orm/session_api.html#sqlalchemy.orm.SessionTransaction
    "sqlalchemy.orm.SessionTransaction")完成时，由于提交、回滚或关闭，它会立即被新的替代。[`SessionTransaction`](../orm/session_api.html#sqlalchemy.orm.SessionTransaction
    "sqlalchemy.orm.SessionTransaction")本身并不意味着使用任何连接相关资源，因此这种长期存在的行为具有特定的优雅之处，即`Session.transaction`的状态始终可预测为非None。'
- en: However, as part of the initiative in [#5056](https://www.sqlalchemy.org/trac/ticket/5056)
    to greatly reduce reference cycles, this assumption means that calling upon [`Session.close()`](../orm/session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") results in a [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") object that still has reference cycles and is more expensive
    to clean up, not to mention that there is a small overhead in constructing the
    [`SessionTransaction`](../orm/session_api.html#sqlalchemy.orm.SessionTransaction
    "sqlalchemy.orm.SessionTransaction") object, which meant that there would be unnecessary
    overhead created for a [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") that for example invoked [`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") and then [`Session.close()`](../orm/session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close").
  id: totrans-1529
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，作为在[#5056](https://www.sqlalchemy.org/trac/ticket/5056)中极大减少引用循环的倡议的一部分，这意味着调用[`Session.close()`](../orm/session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close")会导致一个仍然存在引用循环且更昂贵清理的[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")对象，更不用说构造[`SessionTransaction`](../orm/session_api.html#sqlalchemy.orm.SessionTransaction
    "sqlalchemy.orm.SessionTransaction")对象时会有一些小的开销，这意味着对于一个例如调用了[`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit")然后调用[`Session.close()`](../orm/session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close")的[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")会产生不必要的开销。
- en: As such, it was decided that [`Session.close()`](../orm/session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") should leave the internal state of `self.transaction`,
    now referred to internally as `self._transaction`, as None, and that a new [`SessionTransaction`](../orm/session_api.html#sqlalchemy.orm.SessionTransaction
    "sqlalchemy.orm.SessionTransaction") should only be created when needed. For consistency
    and code coverage, this behavior was also expanded to include all the points at
    which “autobegin” is expected, not just when [`Session.close()`](../orm/session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") were called.
  id: totrans-1530
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，决定让[`Session.close()`](../orm/session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close")将`self.transaction`的内部状态，现在在内部称为`self._transaction`，保留为None，并且只在需要时创建一个新的[`SessionTransaction`](../orm/session_api.html#sqlalchemy.orm.SessionTransaction
    "sqlalchemy.orm.SessionTransaction")。为了一致性和代码覆盖率，这种行为也扩展到所有“自动开始”预期的点，不仅仅是在调用[`Session.close()`](../orm/session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close")时。
- en: In particular, this causes a behavioral change for applications which subscribe
    to the [`SessionEvents.after_transaction_create()`](../orm/events.html#sqlalchemy.orm.SessionEvents.after_transaction_create
    "sqlalchemy.orm.SessionEvents.after_transaction_create") event hook; previously,
    this event would be emitted when the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") were first constructed, as well as for most actions
    that closed the previous transaction and would emit [`SessionEvents.after_transaction_end()`](../orm/events.html#sqlalchemy.orm.SessionEvents.after_transaction_end
    "sqlalchemy.orm.SessionEvents.after_transaction_end"). The new behavior is that
    [`SessionEvents.after_transaction_create()`](../orm/events.html#sqlalchemy.orm.SessionEvents.after_transaction_create
    "sqlalchemy.orm.SessionEvents.after_transaction_create") is emitted on demand,
    when the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    has not yet created a new [`SessionTransaction`](../orm/session_api.html#sqlalchemy.orm.SessionTransaction
    "sqlalchemy.orm.SessionTransaction") object and mapped objects are associated
    with the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    through methods like [`Session.add()`](../orm/session_api.html#sqlalchemy.orm.Session.add
    "sqlalchemy.orm.Session.add") and [`Session.delete()`](../orm/session_api.html#sqlalchemy.orm.Session.delete
    "sqlalchemy.orm.Session.delete"), when the `Session.transaction` attribute is
    called upon, when the [`Session.flush()`](../orm/session_api.html#sqlalchemy.orm.Session.flush
    "sqlalchemy.orm.Session.flush") method has tasks to complete, etc.
  id: totrans-1531
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，这会对订阅 [`SessionEvents.after_transaction_create()`](../orm/events.html#sqlalchemy.orm.SessionEvents.after_transaction_create
    "sqlalchemy.orm.SessionEvents.after_transaction_create") 事件钩子的应用程序造成行为上的改变；以前，此事件将在首次构造
    [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    时被触发，以及对关闭上一个事务的大多数动作进行操作，并会发出 [`SessionEvents.after_transaction_end()`](../orm/events.html#sqlalchemy.orm.SessionEvents.after_transaction_end
    "sqlalchemy.orm.SessionEvents.after_transaction_end")。新行为是，当 [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 尚未创建新的 [`SessionTransaction`](../orm/session_api.html#sqlalchemy.orm.SessionTransaction
    "sqlalchemy.orm.SessionTransaction") 对象，并且映射对象通过 [`Session.add()`](../orm/session_api.html#sqlalchemy.orm.Session.add
    "sqlalchemy.orm.Session.add") 和 [`Session.delete()`](../orm/session_api.html#sqlalchemy.orm.Session.delete
    "sqlalchemy.orm.Session.delete") 等方法与 [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 关联时，以及调用 `Session.transaction` 属性时，当 [`Session.flush()`](../orm/session_api.html#sqlalchemy.orm.Session.flush
    "sqlalchemy.orm.Session.flush") 方法有任务需要完成等情况下，将按需触发 [`SessionEvents.after_transaction_create()`](../orm/events.html#sqlalchemy.orm.SessionEvents.after_transaction_create
    "sqlalchemy.orm.SessionEvents.after_transaction_create")。
- en: In addition, code which relies upon the [`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") or [`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") method to unconditionally expire all objects
    can no longer do so. Code which needs to expire all objects when no change that
    has occurred should be calling [`Session.expire_all()`](../orm/session_api.html#sqlalchemy.orm.Session.expire_all
    "sqlalchemy.orm.Session.expire_all") for this case.
  id: totrans-1532
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，依赖于[`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") 或 [`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") 方法来无条件使所有对象过期的代码将不再能够这样做。当没有发生变化时需要使所有对象过期的代码应该调用[`Session.expire_all()`](../orm/session_api.html#sqlalchemy.orm.Session.expire_all
    "sqlalchemy.orm.Session.expire_all")。
- en: Besides the change in when the [`SessionEvents.after_transaction_create()`](../orm/events.html#sqlalchemy.orm.SessionEvents.after_transaction_create
    "sqlalchemy.orm.SessionEvents.after_transaction_create") event is emitted as well
    as the no-op nature of [`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") or [`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback"), the change should have no other user-visible
    impact on the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    object’s behavior; the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") will continue to have the behavior that it remains usable
    for new operations after [`Session.close()`](../orm/session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") is called, and the sequencing of how the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") interacts with the [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") and the database itself should also remain unaffected,
    since these operations were already operating in an on-demand fashion.
  id: totrans-1533
  prefs: []
  type: TYPE_NORMAL
  zh: 除了[`SessionEvents.after_transaction_create()`](../orm/events.html#sqlalchemy.orm.SessionEvents.after_transaction_create
    "sqlalchemy.orm.SessionEvents.after_transaction_create")事件的触发时间发生变化以及[`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit")或[`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback")的无操作性质外，这一变化不应对[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")对象的行为产生其他用户可见的影响；[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")在调用[`Session.close()`](../orm/session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close")后仍然保持可用于新操作的行为，并且[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")与[`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine")以及数据库本身的交互顺序也应保持不受影响，因为这些操作已经以按需方式运行。
- en: '[#5074](https://www.sqlalchemy.org/trac/ticket/5074)'
  id: totrans-1534
  prefs: []
  type: TYPE_NORMAL
  zh: '[#5074](https://www.sqlalchemy.org/trac/ticket/5074)'
- en: '### Viewonly relationships don’t synchronize backrefs'
  id: totrans-1535
  prefs: []
  type: TYPE_NORMAL
  zh: '### 只读视图关系不同步反向引用'
- en: In [#5149](https://www.sqlalchemy.org/trac/ticket/5149) in 1.3.14, SQLAlchemy
    began emitting a warning when the [`relationship.backref`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.backref
    "sqlalchemy.orm.relationship") or [`relationship.back_populates`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.back_populates
    "sqlalchemy.orm.relationship") keywords would be used at the same time as the
    [`relationship.viewonly`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.viewonly
    "sqlalchemy.orm.relationship") flag on the target relationship. This was because
    a “viewonly” relationship does not actually persist changes made to it, which
    could cause some misleading behaviors to occur. However, in [#5237](https://www.sqlalchemy.org/trac/ticket/5237),
    we sought to refine this behavior as there are legitimate use cases to have backrefs
    set up on viewonly relationships, including that back populates attributes are
    used in some cases by the relationship lazy loaders to determine that an additional
    eager load in the other direction is not necessary, as well as that back populates
    can be used for mapper introspection and that [`backref()`](../orm/relationship_api.html#sqlalchemy.orm.backref
    "sqlalchemy.orm.backref") can be a convenient way to set up bi-directional relationships.
  id: totrans-1536
  prefs: []
  type: TYPE_NORMAL
  zh: 在1.3.14中的[#5149](https://www.sqlalchemy.org/trac/ticket/5149)中，SQLAlchemy开始在目标关系上同时使用[`relationship.backref`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.backref
    "sqlalchemy.orm.relationship")或[`relationship.back_populates`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.back_populates
    "sqlalchemy.orm.relationship")关键字时发出警告，与[`relationship.viewonly`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.viewonly
    "sqlalchemy.orm.relationship")标志一起使用。这是因为“只读”关系实际上不会持久保存对其所做的更改，这可能导致一些误导性行为发生。然而，在[#5237](https://www.sqlalchemy.org/trac/ticket/5237)中，我们试图优化这种行为，因为在只读关系上设置反向引用是有合法用例的，包括反向填充属性有时被关系懒加载器用来确定在另一个方向上不需要额外的急加载，以及反向填充可以用于映射器内省，[`backref()`](../orm/relationship_api.html#sqlalchemy.orm.backref
    "sqlalchemy.orm.backref")也可以是设置双向关系的便捷方式。
- en: 'The solution then was to make the “mutation” that occurs from a backref an
    optional thing, using the [`relationship.sync_backref`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.sync_backref
    "sqlalchemy.orm.relationship") flag. In 1.4 the value of [`relationship.sync_backref`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.sync_backref
    "sqlalchemy.orm.relationship") defaults to False for a relationship target that
    also sets [`relationship.viewonly`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.viewonly
    "sqlalchemy.orm.relationship"). This indicates that any changes made to a relationship
    with viewonly will not impact the state of the other side or of the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") in any way:'
  id: totrans-1537
  prefs: []
  type: TYPE_NORMAL
  zh: 那时的解决方案是使从反向引用发生的“变化”成为可选的事情，使用[`relationship.sync_backref`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.sync_backref
    "sqlalchemy.orm.relationship")标志。在1.4中，对于还设置了[`relationship.viewonly`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.viewonly
    "sqlalchemy.orm.relationship")的关系目标，默认情况下[`relationship.sync_backref`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.sync_backref
    "sqlalchemy.orm.relationship")的值为False。这表示对于具有viewonly的关系所做的任何更改都不会影响另一侧或[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")的状态：
- en: '[PRE352]'
  id: totrans-1538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE352]'
- en: Above, the `a1` object will **not** be added to the `u1.addresses` collection,
    nor will the `a1` object be added to the session. Previously, both of these things
    would be true. The warning that [`relationship.sync_backref`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.sync_backref
    "sqlalchemy.orm.relationship") should be set to `False` when [`relationship.viewonly`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.viewonly
    "sqlalchemy.orm.relationship") is `False` is no longer emitted as this is now
    the default behavior.
  id: totrans-1539
  prefs: []
  type: TYPE_NORMAL
  zh: 上面，`a1`对象**不会**被添加到`u1.addresses`集合中，也不会将`a1`对象添加到会话中。以前，这两件事情都是正确的。当[`relationship.viewonly`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.viewonly
    "sqlalchemy.orm.relationship")为`False`时，不再发出警告，即[`relationship.sync_backref`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.sync_backref
    "sqlalchemy.orm.relationship")应设置为`False`，因为这现在是默认行为。
- en: '[#5237](https://www.sqlalchemy.org/trac/ticket/5237)'
  id: totrans-1540
  prefs: []
  type: TYPE_NORMAL
  zh: '[#5237](https://www.sqlalchemy.org/trac/ticket/5237)'
- en: '### cascade_backrefs behavior deprecated for removal in 2.0'
  id: totrans-1541
  prefs: []
  type: TYPE_NORMAL
  zh: '### 在2.0版本中将删除cascade_backrefs行为'
- en: 'SQLAlchemy has long had a behavior of cascading objects into the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") based on backref assignment. Given `User` below already
    in a [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session"),
    assigning it to the `Address.user` attribute of an `Address` object, assuming
    a bidirectional relationship is set up, would mean that the `Address` also gets
    put into the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    at that point:'
  id: totrans-1542
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy长期以来一直有一个行为，根据反向引用赋值将对象级联到[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")中。给定下面的`User`已经在[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")中，将其分配给`Address`对象的`Address.user`属性，假设已建立双向关系，这意味着在那一点上`Address`也会被放入[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")中：
- en: '[PRE353]'
  id: totrans-1543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE353]'
- en: The above behavior was an unintended side effect of backref behavior, in that
    since `a1.user` implies `u1.addresses.append(a1)`, `a1` would get cascaded into
    the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session").
    This remains the default behavior throughout 1.4\. At some point, a new flag [`relationship.cascade_backrefs`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.cascade_backrefs
    "sqlalchemy.orm.relationship") was added to disable to above behavior, along with
    [`backref.cascade_backrefs`](../orm/relationship_api.html#sqlalchemy.orm.backref.params.cascade_backrefs
    "sqlalchemy.orm.backref") to set this when the relationship is specified by `relationship.backref`,
    as it can be surprising and also gets in the way of some operations where the
    object would be placed in the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") too early and get prematurely flushed.
  id: totrans-1544
  prefs: []
  type: TYPE_NORMAL
  zh: 上述行为是反向引用行为的一个意外副作用，因为`a1.user`意味着`u1.addresses.append(a1)`，`a1`会被级联到[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")中。这在1.4版本中仍然是默认行为。在某个时候，添加了一个新标志[`relationship.cascade_backrefs`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.cascade_backrefs
    "sqlalchemy.orm.relationship")来禁用上述行为，以及[`backref.cascade_backrefs`](../orm/relationship_api.html#sqlalchemy.orm.backref.params.cascade_backrefs
    "sqlalchemy.orm.backref")来在通过`relationship.backref`指定关系时设置此行为，因为这可能会令人惊讶，也会妨碍一些操作，其中对象会过早地放置在[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")中并提前刷新。
- en: 'In 2.0, the default behavior will be that “cascade_backrefs” is False, and
    additionally there will be no “True” behavior as this is not generally a desirable
    behavior. When 2.0 deprecation warnings are enabled, a warning will be emitted
    when a “backref cascade” actually takes place. To get the new behavior, either
    set [`relationship.cascade_backrefs`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.cascade_backrefs
    "sqlalchemy.orm.relationship") and [`backref.cascade_backrefs`](../orm/relationship_api.html#sqlalchemy.orm.backref.params.cascade_backrefs
    "sqlalchemy.orm.backref") to `False` on any target relationships, as is already
    supported in 1.3 and earlier, or alternatively make use of the [`Session.future`](../orm/session_api.html#sqlalchemy.orm.Session.params.future
    "sqlalchemy.orm.Session") flag to [2.0-style](../glossary.html#term-1) mode:'
  id: totrans-1545
  prefs: []
  type: TYPE_NORMAL
  zh: 在2.0版本中，默认行为将是“cascade_backrefs”为False，并且另外不会有“True”行为，因为这通常不是一种理想的行为。当启用2.0版本的弃用警告时，当“backref
    cascade”实际发生时将发出警告。要获得新行为，可以在任何目标关系上将[`relationship.cascade_backrefs`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.cascade_backrefs
    "sqlalchemy.orm.relationship")和[`backref.cascade_backrefs`](../orm/relationship_api.html#sqlalchemy.orm.backref.params.cascade_backrefs
    "sqlalchemy.orm.backref")设置为`False`，就像在1.3版本和更早版本中已经支持的那样，或者使用[`Session.future`](../orm/session_api.html#sqlalchemy.orm.Session.params.future
    "sqlalchemy.orm.Session")标志进入[2.0风格](../glossary.html#term-1)模式：
- en: '[PRE354]'
  id: totrans-1546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE354]'
- en: '[#5150](https://www.sqlalchemy.org/trac/ticket/5150)'
  id: totrans-1547
  prefs: []
  type: TYPE_NORMAL
  zh: '[#5150](https://www.sqlalchemy.org/trac/ticket/5150)'
- en: '### Eager loaders emit during unexpire operations'
  id: totrans-1548
  prefs: []
  type: TYPE_NORMAL
  zh: '### 在取消过期操作期间急切加载器发出'
- en: 'A long sought behavior was that when an expired object is accessed, configured
    eager loaders will run in order to eagerly load relationships on the expired object
    when the object is refreshed or otherwise unexpired. This behavior has now been
    added, so that joinedloaders will add inline JOINs as usual, and selectin/subquery
    loaders will run an “immediateload” operation for a given relationship, when an
    expired object is unexpired or an object is refreshed:'
  id: totrans-1549
  prefs: []
  type: TYPE_NORMAL
  zh: 长期以来一直寻求的行为是，当访问一个过期对象时，配置的急切加载器将运行，以便在对象被刷新或其他情况下取消过期时急切加载过期对象上的关系。现在已经添加了这种行为，因此joinedloaders将像往常一样添加内联JOIN，而selectin/subquery
    loaders将在过期对象被取消过期或对象被刷新时运行“immediateload”操作：
- en: '[PRE355]'
  id: totrans-1550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE355]'
- en: 'Above, the `A` object was loaded with a `joinedload()` option associated with
    it in order to eagerly load the `bs` collection. After the `session.commit()`,
    the state of the object is expired. Upon accessing the `.data` column attribute,
    the object is refreshed and this will now include the joinedload operation as
    well:'
  id: totrans-1551
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，`A`对象使用了`joinedload()`选项加载，以便急切加载`bs`集合。在`session.commit()`后，对象的状态会过期。访问`.data`列属性时，对象会被刷新，现在这将包括joinedload操作：
- en: '[PRE356]'
  id: totrans-1552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE356]'
- en: The behavior applies both to loader strategies applied to the [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") directly, as well as with options used with [`Query.options()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.options
    "sqlalchemy.orm.Query.options"), provided that the object was originally loaded
    by that query.
  id: totrans-1553
  prefs: []
  type: TYPE_NORMAL
  zh: 该行为适用于直接应用于[`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")的加载策略，以及与[`Query.options()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.options
    "sqlalchemy.orm.Query.options")一起使用的选项，前提是对象最初是由该查询��载的。
- en: 'For the “secondary” eager loaders “selectinload” and “subqueryload”, the SQL
    strategy for these loaders is not necessary in order to eagerly load attributes
    on a single object; so they will instead invoke the “immediateload” strategy in
    a refresh scenario, which resembles the query emitted by “lazyload”, emitted as
    an additional query:'
  id: totrans-1554
  prefs: []
  type: TYPE_NORMAL
  zh: 对于“secondary”急加载器“selectinload”和“subqueryload”，这些加载器的 SQL 策略并不是必要的，以便在单个对象上急加载属性；因此它们将在刷新场景中调用“immediateload”策略，这类似于“lazyload”发出的查询，作为额外的查询：
- en: '[PRE357]'
  id: totrans-1555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE357]'
- en: Note that a loader option does not apply to an object that was introduced into
    the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    in a different way. That is, if the `a1` object were just persisted in this [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), or was loaded with a different query before the eager
    option had been applied, then the object doesn’t have an eager load option associated
    with it. This is not a new concept, however users who are looking for the eagerload
    on refresh behavior may find this to be more noticeable.
  id: totrans-1556
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，加载器选项不适用于以不同方式引入到[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")中的对象。也就是说，如果`a1`对象只是在这个[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")中被持久化，或者在应用急加载选项之前用不同的查询加载了该对象，那么该对象就没有与之关联的急加载选项。这并不是一个新概念，但是寻找刷新行为上的急加载的用户可能会发现这更加明显。
- en: '[#1763](https://www.sqlalchemy.org/trac/ticket/1763)'
  id: totrans-1557
  prefs: []
  type: TYPE_NORMAL
  zh: '[#1763](https://www.sqlalchemy.org/trac/ticket/1763)'
- en: '### Column loaders such as `deferred()`, `with_expression()` only take effect
    when indicated on the outermost, full entity query'
  id: totrans-1558
  prefs: []
  type: TYPE_NORMAL
  zh: '### 列加载器如`deferred()`、`with_expression()` 只在最外层、完整的实体查询中指定时才生效'
- en: Note
  id: totrans-1559
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This change note was not present in earlier versions of this document, however
    is relevant for all SQLAlchemy 1.4 versions.
  id: totrans-1560
  prefs: []
  type: TYPE_NORMAL
  zh: 这个变更说明在此文档的早期版本中并不存在，但对于所有 SQLAlchemy 1.4 版本都是相关的。
- en: 'A behavior that was never supported in 1.3 and previous versions yet nonetheless
    would have a particular effect was to repurpose column loader options such as
    [`defer()`](../orm/queryguide/columns.html#sqlalchemy.orm.defer "sqlalchemy.orm.defer")
    and [`with_expression()`](../orm/queryguide/columns.html#sqlalchemy.orm.with_expression
    "sqlalchemy.orm.with_expression") in subqueries in order to control which SQL
    expressions would be in the columns clause of each subquery. A typical example
    would be to construct UNION queries, such as:'
  id: totrans-1561
  prefs: []
  type: TYPE_NORMAL
  zh: 一个在 1.3 版本和之前版本中从未支持过的行为，但仍然会产生特定效果的是重新利用列加载器选项，比如[`defer()`](../orm/queryguide/columns.html#sqlalchemy.orm.defer
    "sqlalchemy.orm.defer")和[`with_expression()`](../orm/queryguide/columns.html#sqlalchemy.orm.with_expression
    "sqlalchemy.orm.with_expression") 在子查询中，以控制哪些 SQL 表达式将出现在每个子查询的列子句中。一个典型的例子是构造
    UNION 查询，例如：
- en: '[PRE358]'
  id: totrans-1562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE358]'
- en: 'In version 1.3, the [`with_expression()`](../orm/queryguide/columns.html#sqlalchemy.orm.with_expression
    "sqlalchemy.orm.with_expression") option would take effect for each element of
    the UNION, such as:'
  id: totrans-1563
  prefs: []
  type: TYPE_NORMAL
  zh: 在 1.3 版本中，[`with_expression()`](../orm/queryguide/columns.html#sqlalchemy.orm.with_expression
    "sqlalchemy.orm.with_expression") 选项会对 UNION 的每个元素生效，例如：
- en: '[PRE359]'
  id: totrans-1564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE359]'
- en: 'SQLAlchemy 1.4’s notion of loader options has been made more strict, and as
    such are applied to the **outermost part of the query only**, which is the SELECT
    that is intended to populate the actual ORM entities to be returned; the query
    above in 1.4 will produce:'
  id: totrans-1565
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 1.4 对加载器选项的概念变得更加严格，因此仅应用于**查询的最外层部分**，即用于填充实际要返回的 ORM 实体的 SELECT；在
    1.4 中上述查询将产生：
- en: '[PRE360]'
  id: totrans-1566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE360]'
- en: that is, the options for the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") were taken from the first element of the UNION, since
    all loader options are only to be at the topmost level. The option from the second
    query was ignored.
  id: totrans-1567
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    的选项是从 UNION 的第一个元素中获取的，因为所有加载器选项只能在最顶层。第二个查询的选项被忽略。
- en: Rationale
  id: totrans-1568
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 理由
- en: This behavior now more closely matches that of other kinds of loader options
    such as relationship loader options like [`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload") in all SQLAlchemy versions, 1.3 and earlier included,
    which in a UNION situation were already copied out to the top most level of the
    query, and only taken from the first element of the UNION, discarding any options
    on other parts of the query.
  id: totrans-1569
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为现在更接近于其他类型的加载器选项，比如在所有 SQLAlchemy 版本中，1.3 版本及更早版本中的关系加载器选项[`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload")，在 UNION 情况下已经被复制到查询的最顶层，并且仅从 UNION 的第一个元素中获取，丢弃查询其他部分的任何选项。
- en: This implicit copying and selective ignoring of options, demonstrated above
    as being fairly arbitrary, is a legacy behavior that’s only part of [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query"), and is a particular example of where [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") and its means of applying [`Query.union_all()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.union_all
    "sqlalchemy.orm.Query.union_all") falls short, as it’s ambiguous how to turn a
    single SELECT into a UNION of itself and another query and how loader options
    should be applied to that new statement.
  id: totrans-1570
  prefs: []
  type: TYPE_NORMAL
  zh: 上面演示的这种隐式复制和选择性忽略选项的行为，是一个仅在[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")中存在的遗留行为，也是一个特定的例子，说明了[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")及其应用[`Query.union_all()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.union_all
    "sqlalchemy.orm.Query.union_all")的方式存在缺陷，因为如何将单个 SELECT 转换为自身和另一个查询的 UNION 以及如何应用加载器选项到该新语句是模棱两可的。
- en: 'SQLAlchemy 1.4’s behavior can be demonstrated as generally superior to that
    of 1.3 for a more common case of using [`defer()`](../orm/queryguide/columns.html#sqlalchemy.orm.defer
    "sqlalchemy.orm.defer"). The following query:'
  id: totrans-1571
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 1.4 的行为可以被证明在更常见的使用[`defer()`](../orm/queryguide/columns.html#sqlalchemy.orm.defer
    "sqlalchemy.orm.defer")的情况下，比 1.3 更为优越。以下查询：
- en: '[PRE361]'
  id: totrans-1572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE361]'
- en: 'In 1.3 would awkwardly add NULL to the inner queries and then SELECT it:'
  id: totrans-1573
  prefs: []
  type: TYPE_NORMAL
  zh: 在 1.3 版本中会尴尬地向内部查询中添加 NULL，然后再 SELECT 它：
- en: '[PRE362]'
  id: totrans-1574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE362]'
- en: If all queries didn’t have the identical options set up, the above scenario
    would raise an error due to not being able to form a proper UNION.
  id: totrans-1575
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有查询没有设置相同的选项，上述情况将由于无法形成正确的 UNION 而引发错误。
- en: 'Whereas in 1.4, the option is applied only at the top layer, omitting the fetch
    for `User.name`, and this complexity is avoided:'
  id: totrans-1576
  prefs: []
  type: TYPE_NORMAL
  zh: 而在 1.4 版本中，该选项仅应用于顶层，省略了对 `User.name` 的提取，避免了这种复杂性：
- en: '[PRE363]'
  id: totrans-1577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE363]'
- en: Correct Approach
  id: totrans-1578
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 正确的方法
- en: 'Using [2.0-style](../glossary.html#term-1) querying, no warning is emitted
    at the moment, however the nested [`with_expression()`](../orm/queryguide/columns.html#sqlalchemy.orm.with_expression
    "sqlalchemy.orm.with_expression") options are consistently ignored as they don’t
    apply to an entity being loaded, and are not implicitly copied anywhere. The query
    below produces no output for the [`with_expression()`](../orm/queryguide/columns.html#sqlalchemy.orm.with_expression
    "sqlalchemy.orm.with_expression") calls:'
  id: totrans-1579
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[2.0 风格](../glossary.html#term-1)查询，目前不会发出警告，但是嵌套的[`with_expression()`](../orm/queryguide/columns.html#sqlalchemy.orm.with_expression
    "sqlalchemy.orm.with_expression")选项始终被忽略，因为它们不适用于正在加载的实体，并且不会被隐式复制到任何地方。下面的查询对[`with_expression()`](../orm/queryguide/columns.html#sqlalchemy.orm.with_expression
    "sqlalchemy.orm.with_expression")调用不会产生任何输出：
- en: '[PRE364]'
  id: totrans-1580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE364]'
- en: 'producing the SQL:'
  id: totrans-1581
  prefs: []
  type: TYPE_NORMAL
  zh: 生成 SQL：
- en: '[PRE365]'
  id: totrans-1582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE365]'
- en: 'To correctly apply [`with_expression()`](../orm/queryguide/columns.html#sqlalchemy.orm.with_expression
    "sqlalchemy.orm.with_expression") to the `User` entity, it should be applied to
    the outermost level of the query, using an ordinary SQL expression inside the
    columns clause of each SELECT:'
  id: totrans-1583
  prefs: []
  type: TYPE_NORMAL
  zh: 要正确应用[`with_expression()`](../orm/queryguide/columns.html#sqlalchemy.orm.with_expression
    "sqlalchemy.orm.with_expression")到 `User` 实体，应该将其应用于查询的最外层，使用普通的 SQL 表达式在每个 SELECT
    的列子句中：
- en: '[PRE366]'
  id: totrans-1584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE366]'
- en: 'Which will produce the expected SQL:'
  id: totrans-1585
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生预期的 SQL：
- en: '[PRE367]'
  id: totrans-1586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE367]'
- en: The `User` objects themselves will include this expression in their contents
    underneath `User.expr`.
  id: totrans-1587
  prefs: []
  type: TYPE_NORMAL
  zh: '`User` 对象本身将在 `User.expr` 下的内容中包含此表达式。'
- en: Rationale
  id: totrans-1588
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 理由
- en: This behavior now more closely matches that of other kinds of loader options
    such as relationship loader options like [`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload") in all SQLAlchemy versions, 1.3 and earlier included,
    which in a UNION situation were already copied out to the top most level of the
    query, and only taken from the first element of the UNION, discarding any options
    on other parts of the query.
  id: totrans-1589
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为现在更接近于其他种类的加载器选项，比如关系加载器选项，比如[`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload")在所有SQLAlchemy版本中，包括1.3和更早的版本，这在UNION情况下已经复制到查询的最顶层，并且只从UNION的第一个元素中获取，丢弃查询其他部分的任何选项。
- en: This implicit copying and selective ignoring of options, demonstrated above
    as being fairly arbitrary, is a legacy behavior that’s only part of [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query"), and is a particular example of where [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") and its means of applying [`Query.union_all()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.union_all
    "sqlalchemy.orm.Query.union_all") falls short, as it’s ambiguous how to turn a
    single SELECT into a UNION of itself and another query and how loader options
    should be applied to that new statement.
  id: totrans-1590
  prefs: []
  type: TYPE_NORMAL
  zh: 上面演示的这种隐式复制和选择性忽略选项的行为是一种遗留行为，仅属于[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")的一部分，并且是一个特殊的例子，展示了[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")及其应用[`Query.union_all()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.union_all
    "sqlalchemy.orm.Query.union_all")的方式存在缺陷，因为不清楚如何将单个SELECT转换为自身和另一个查询的UNION，以及如何应用加载器选项到新语句。
- en: 'SQLAlchemy 1.4’s behavior can be demonstrated as generally superior to that
    of 1.3 for a more common case of using [`defer()`](../orm/queryguide/columns.html#sqlalchemy.orm.defer
    "sqlalchemy.orm.defer"). The following query:'
  id: totrans-1591
  prefs: []
  type: TYPE_NORMAL
  zh: 对于更常见的情况，使用[`defer()`](../orm/queryguide/columns.html#sqlalchemy.orm.defer "sqlalchemy.orm.defer")，演示了SQLAlchemy
    1.4的行为通常优于1.3。以下查询：
- en: '[PRE368]'
  id: totrans-1592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE368]'
- en: 'In 1.3 would awkwardly add NULL to the inner queries and then SELECT it:'
  id: totrans-1593
  prefs: []
  type: TYPE_NORMAL
  zh: 在1.3中会尴尬地向内部查询添加NULL，然后SELECT它：
- en: '[PRE369]'
  id: totrans-1594
  prefs: []
  type: TYPE_PRE
  zh: '[PRE369]'
- en: If all queries didn’t have the identical options set up, the above scenario
    would raise an error due to not being able to form a proper UNION.
  id: totrans-1595
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有查询没有设置相同的选项，上述情况将由于无法形成正确的UNION而引发错误。
- en: 'Whereas in 1.4, the option is applied only at the top layer, omitting the fetch
    for `User.name`, and this complexity is avoided:'
  id: totrans-1596
  prefs: []
  type: TYPE_NORMAL
  zh: 而在1.4中，该选项仅应用于顶层，省略了对`User.name`的提取，避免了这种复杂性：
- en: '[PRE370]'
  id: totrans-1597
  prefs: []
  type: TYPE_PRE
  zh: '[PRE370]'
- en: Correct Approach
  id: totrans-1598
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 正确的方法
- en: 'Using [2.0-style](../glossary.html#term-1) querying, no warning is emitted
    at the moment, however the nested [`with_expression()`](../orm/queryguide/columns.html#sqlalchemy.orm.with_expression
    "sqlalchemy.orm.with_expression") options are consistently ignored as they don’t
    apply to an entity being loaded, and are not implicitly copied anywhere. The query
    below produces no output for the [`with_expression()`](../orm/queryguide/columns.html#sqlalchemy.orm.with_expression
    "sqlalchemy.orm.with_expression") calls:'
  id: totrans-1599
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[2.0风格](../glossary.html#term-1)查询，目前不会发出警告，但是嵌套的[`with_expression()`](../orm/queryguide/columns.html#sqlalchemy.orm.with_expression
    "sqlalchemy.orm.with_expression")选项始终被忽略，因为它们不适用于正在加载的实体，并且不会被隐式复制到任何地方。下面的查询对[`with_expression()`](../orm/queryguide/columns.html#sqlalchemy.orm.with_expression
    "sqlalchemy.orm.with_expression")调用不会产生任何输出：
- en: '[PRE371]'
  id: totrans-1600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE371]'
- en: 'producing the SQL:'
  id: totrans-1601
  prefs: []
  type: TYPE_NORMAL
  zh: 生成SQL：
- en: '[PRE372]'
  id: totrans-1602
  prefs: []
  type: TYPE_PRE
  zh: '[PRE372]'
- en: 'To correctly apply [`with_expression()`](../orm/queryguide/columns.html#sqlalchemy.orm.with_expression
    "sqlalchemy.orm.with_expression") to the `User` entity, it should be applied to
    the outermost level of the query, using an ordinary SQL expression inside the
    columns clause of each SELECT:'
  id: totrans-1603
  prefs: []
  type: TYPE_NORMAL
  zh: 要正确应用[`with_expression()`](../orm/queryguide/columns.html#sqlalchemy.orm.with_expression
    "sqlalchemy.orm.with_expression")到`User`实体，应该应用到查询的最外层，使用普通的SQL表达式放在每个SELECT的columns子句中：
- en: '[PRE373]'
  id: totrans-1604
  prefs: []
  type: TYPE_PRE
  zh: '[PRE373]'
- en: 'Which will produce the expected SQL:'
  id: totrans-1605
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生预期的SQL：
- en: '[PRE374]'
  id: totrans-1606
  prefs: []
  type: TYPE_PRE
  zh: '[PRE374]'
- en: The `User` objects themselves will include this expression in their contents
    underneath `User.expr`.
  id: totrans-1607
  prefs: []
  type: TYPE_NORMAL
  zh: '`User`对象本身将包含这个表达式在它们的内容中`User.expr`下面。'
- en: '### Accessing an uninitialized collection attribute on a transient object no
    longer mutates __dict__'
  id: totrans-1608
  prefs: []
  type: TYPE_NORMAL
  zh: '### 在瞬态对象上访问未初始化的集合属性不再改变__dict__'
- en: 'It has always been SQLAlchemy’s behavior that accessing mapped attributes on
    a newly created object returns an implicitly generated value, rather than raising
    `AttributeError`, such as `None` for scalar attributes or `[]` for a list-holding
    relationship:'
  id: totrans-1609
  prefs: []
  type: TYPE_NORMAL
  zh: 对于新创建的对象访问映射属性始终返回隐式生成的值，而不是引发`AttributeError`，例如标量属性返回`None`或列表关系返回`[]`：
- en: '[PRE375]'
  id: totrans-1610
  prefs: []
  type: TYPE_PRE
  zh: '[PRE375]'
- en: 'The rationale for the above behavior was originally to make ORM objects easier
    to work with. Since an ORM object represents an empty row when first created without
    any state, it is intuitive that its un-accessed attributes would resolve to `None`
    (or SQL NULL) for scalars and to empty collections for relationships. In particular,
    it makes possible an extremely common pattern of being able to mutate the new
    collection without manually creating and assigning an empty collection first:'
  id: totrans-1611
  prefs: []
  type: TYPE_NORMAL
  zh: 以上行为的理由最初是为了使ORM对象更易于使用。由于ORM对象在首次创建时表示一个空行而没有任何状态，因此直观地，其未访问的属性应该解析为标量的`None`（或SQL
    NULL），并对关系解析为空集合。特别是，这使得一种极其常见的模式成为可能，即能够在不手动创建和分配空集合的情况下对新集合进行变异：
- en: '[PRE376]'
  id: totrans-1612
  prefs: []
  type: TYPE_PRE
  zh: '[PRE376]'
- en: 'Up until version 1.0 of SQLAlchemy, the behavior of this initialization system
    for both scalar attributes as well as collections would be that the `None` or
    empty collection would be *populated* into the object’s state, e.g. `__dict__`.
    This meant that the following two operations were equivalent:'
  id: totrans-1613
  prefs: []
  type: TYPE_NORMAL
  zh: 直到SQLAlchemy的1.0版本，这种初始化系统对标量属性以及集合的行为都是将`None`或空集合*填充*到对象的状态中，例如`__dict__`。这意味着以下两个操作是等效的：
- en: '[PRE377]'
  id: totrans-1614
  prefs: []
  type: TYPE_PRE
  zh: '[PRE377]'
- en: Where above, both `u1` and `u2` would have the value `None` populated in the
    value of the `name` attribute. Since this is a SQL NULL, the ORM would skip including
    these values within an INSERT so that SQL-level defaults take place, if any, else
    the value defaults to NULL on the database side.
  id: totrans-1615
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述情况下，`u1`和`u2`的`name`属性的值都将填充为`None`。由于这是一个SQL NULL，ORM将跳过将这些值包含在INSERT中，以便发生SQL级别的默认值，如果有的话，否则值将在数据库端默认为NULL。
- en: In version 1.0 as part of [Changes to attribute events and other operations
    regarding attributes that have no pre-existing value](migration_10.html#migration-3061),
    this behavior was refined so that the `None` value was no longer populated into
    `__dict__`, only returned. Besides removing the mutating side effect of a getter
    operation, this change also made it possible to set columns that did have server
    defaults to the value NULL by actually assigning `None`, which was now distinguished
    from just reading it.
  id: totrans-1616
  prefs: []
  type: TYPE_NORMAL
  zh: 在版本1.0中作为[关于没有预先存在值的属性的属性事件和其他操作的更改](migration_10.html#migration-3061)的一部分，这种行为被调整，以便`None`值不再填充到`__dict__`中，只是返回。除了消除获取器操作的变异副作用外，这种变化还使得可以将具有服务器默认值的列设置为NULL值，方法是实际分配`None`，这现在与仅仅读取它有所区别。
- en: 'The change however did not accommodate for collections, where returning an
    empty collection that is not assigned meant that this mutable collection would
    be different each time and also would not be able to correctly accommodate for
    mutating operations (e.g. append, add, etc.) called upon it. While the behavior
    continued to generally not get in anyone’s way, an edge case was eventually identified
    in [#4519](https://www.sqlalchemy.org/trac/ticket/4519) where this empty collection
    could be harmful, which is when the object is merged into a session:'
  id: totrans-1617
  prefs: []
  type: TYPE_NORMAL
  zh: 但是这种变化并没有考虑到集合，其中返回一个未分配的空集合意味着这个可变集合每次都会不同，也无法正确地适应对其进行的变异操作（例如追加、添加等）。虽然这种行为通常不会影响任何人，但最终在[#4519](https://www.sqlalchemy.org/trac/ticket/4519)中识别出了一个边缘情况，即当对象合并到会话中时，这个空集合可能会有害：
- en: '[PRE378]'
  id: totrans-1618
  prefs: []
  type: TYPE_PRE
  zh: '[PRE378]'
- en: Above, the `.addresses` collection on `merged1` will contain all the `Address()`
    objects that were already in the database. `merged2` will not; because it has
    an empty list implicitly assigned, the `.addresses` collection will be erased.
    This is an example of where this mutating side effect can actually mutate the
    database itself.
  id: totrans-1619
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述情况下，`merged1`上的`.addresses`集合将包含数据库中已经存在的所有`Address()`对象。`merged2`不会；因为它有一个隐式分配的空列表，`.addresses`集合将被擦除。这是一个实际上可以改变数据库本身的变异副作用的示例。
- en: While it was considered that perhaps the attribute system should begin using
    strict “plain Python” behavior, raising `AttributeError` in all cases for non-existent
    attributes on non-persistent objects and requiring that all collections be explicitly
    assigned, such a change would likely be too extreme for the vast number of applications
    that have relied upon this behavior for many years, leading to a complex rollout
    / backwards compatibility problem as well as the likelihood that workarounds to
    restore the old behavior would become prevalent, thus rendering the whole change
    ineffective in any case.
  id: totrans-1620
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然考虑过属性系统是否应开始使用严格的“纯Python”行为，在所有情况下对非存在属性的非持久对象引发`AttributeError`，并要求所有集合都必须显式分配，但这样的改变可能对多年来依赖于这种行为的大量应用程序来说过于极端，导致复杂的发布/向后兼容性问题，以及恢复旧行为的解决方法可能会变得普遍，从而使整个改变失效。
- en: 'The change then is to keep the default producing behavior, but to finally make
    the non-mutating behavior of scalars a reality for collections as well, via the
    addition of additional mechanics in the collection system. When accessing the
    empty attribute, the new collection is created and associated with the state,
    however is not added to `__dict__` until it is actually mutated:'
  id: totrans-1621
  prefs: []
  type: TYPE_NORMAL
  zh: 改变的是保持默认的生成行为，但最终使标量的非变异行为对集合也成为现实，通过在集合系统中添加额外的机制。当访问空属性时，新集合将被创建并与状态关联，但直到实际发生变异才会被添加到`__dict__`中：
- en: '[PRE379]'
  id: totrans-1622
  prefs: []
  type: TYPE_PRE
  zh: '[PRE379]'
- en: 'When the list is changed, then it becomes part of the tracked changes to be
    persisted to the database:'
  id: totrans-1623
  prefs: []
  type: TYPE_NORMAL
  zh: 当列表发生变化时，它将成为要持久化到数据库的跟踪更改的一部分：
- en: '[PRE380]'
  id: totrans-1624
  prefs: []
  type: TYPE_PRE
  zh: '[PRE380]'
- en: 'This change is expected to have *nearly* no impact on existing applications
    in any way, except that it has been observed that some applications may be relying
    upon the implicit assignment of this collection, such as to assert that the object
    contains certain values based on its `__dict__`:'
  id: totrans-1625
  prefs: []
  type: TYPE_NORMAL
  zh: 这种改变预计对现有应用程序几乎没有任何影响，除了观察到一些应用程序可能依赖于对该集合的隐式赋值，例如根据其`__dict__`来断定对象包含某些值：
- en: '[PRE381]'
  id: totrans-1626
  prefs: []
  type: TYPE_PRE
  zh: '[PRE381]'
- en: 'or to ensure that the collection won’t require a lazy load to proceed, the
    (admittedly awkward) code below will now also fail:'
  id: totrans-1627
  prefs: []
  type: TYPE_NORMAL
  zh: 或确保集合不需要延迟加载才能继续，现在下面这段（尽管有些尴尬）代码也将失败：
- en: '[PRE382]'
  id: totrans-1628
  prefs: []
  type: TYPE_PRE
  zh: '[PRE382]'
- en: 'Applications that rely upon the implicit mutating behavior of collections will
    need to be changed so that they assign the desired collection explicitly:'
  id: totrans-1629
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖于集合的隐式变异行为的应用程序需要更改，以便显式地分配所需的集合：
- en: '[PRE383]'
  id: totrans-1630
  prefs: []
  type: TYPE_PRE
  zh: '[PRE383]'
- en: '[#4519](https://www.sqlalchemy.org/trac/ticket/4519)'
  id: totrans-1631
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4519](https://www.sqlalchemy.org/trac/ticket/4519)'
- en: '### The “New instance conflicts with existing identity” error is now a warning'
  id: totrans-1632
  prefs: []
  type: TYPE_NORMAL
  zh: '### “新实例与现有标识冲突”错误现在是一个警告'
- en: 'SQLAlchemy has always had logic to detect when an object in the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") to be inserted has the same primary key as an object
    that is already present:'
  id: totrans-1633
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy一直有逻辑来检测要插入[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")中的对象是否具有与已经存在的对象相同的主键：
- en: '[PRE384]'
  id: totrans-1634
  prefs: []
  type: TYPE_PRE
  zh: '[PRE384]'
- en: 'The change is that the [`FlushError`](../orm/exceptions.html#sqlalchemy.orm.exc.FlushError
    "sqlalchemy.orm.exc.FlushError") is altered to be only a warning:'
  id: totrans-1635
  prefs: []
  type: TYPE_NORMAL
  zh: 改变是[`FlushError`](../orm/exceptions.html#sqlalchemy.orm.exc.FlushError "sqlalchemy.orm.exc.FlushError")被修改为仅作为警告：
- en: '[PRE385]'
  id: totrans-1636
  prefs: []
  type: TYPE_PRE
  zh: '[PRE385]'
- en: 'Subsequent to that, the condition will attempt to insert the row into the database
    which will emit [`IntegrityError`](../core/exceptions.html#sqlalchemy.exc.IntegrityError
    "sqlalchemy.exc.IntegrityError"), which is the same error that would be raised
    if the primary key identity was not already present in the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"):'
  id: totrans-1637
  prefs: []
  type: TYPE_NORMAL
  zh: 随后，该条件将尝试将行插入数据库，这将引发[`IntegrityError`](../core/exceptions.html#sqlalchemy.exc.IntegrityError
    "sqlalchemy.exc.IntegrityError")，这是如果主键标识在[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")中尚不存在时将引发的相同错误：
- en: '[PRE386]'
  id: totrans-1638
  prefs: []
  type: TYPE_PRE
  zh: '[PRE386]'
- en: 'The rationale is to allow code that is using [`IntegrityError`](../core/exceptions.html#sqlalchemy.exc.IntegrityError
    "sqlalchemy.exc.IntegrityError") to catch duplicates to function regardless of
    the existing state of the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), as is often done using savepoints:'
  id: totrans-1639
  prefs: []
  type: TYPE_NORMAL
  zh: 其理念是允许使用[`IntegrityError`](../core/exceptions.html#sqlalchemy.exc.IntegrityError
    "sqlalchemy.exc.IntegrityError")来捕获重复项的代码能够正常运行，而不受[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")的现有状态的影响，通常使用保存点来实现：
- en: '[PRE387]'
  id: totrans-1640
  prefs: []
  type: TYPE_PRE
  zh: '[PRE387]'
- en: The above logic was not fully feasible earlier, as in the case that the `Product`
    object with the existing identity were already in the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), the code would also have to catch [`FlushError`](../orm/exceptions.html#sqlalchemy.orm.exc.FlushError
    "sqlalchemy.orm.exc.FlushError"), which additionally is not filtered for the specific
    condition of integrity issues. With the change, the above block behaves consistently
    with the exception of the warning also being emitted.
  id: totrans-1641
  prefs: []
  type: TYPE_NORMAL
  zh: 上述逻辑在早期并不完全可行，因为在`Session`中已经存在具有现有标识的`Product`对象的情况下，代码还必须捕获[`FlushError`](../orm/exceptions.html#sqlalchemy.orm.exc.FlushError
    "sqlalchemy.orm.exc.FlushError")，而这种情况又没有针对完整性问题的特定条件进行过滤。通过这次更改，上述代码块的行为与警告也会被发出的例外情况一致。
- en: Since the logic in question deals with the primary key, all databases emit an
    integrity error in the case of primary key conflicts on INSERT. The case where
    an error would not be raised, that would have earlier, is the extremely unusual
    scenario of a mapping that defines a primary key on the mapped selectable that
    is more restrictive than what is actually configured in the database schema, such
    as when mapping to joins of tables or when defining additional columns as part
    of a composite primary key that is not actually constrained in the database schema.
    However, these situations also work more consistently in that the INSERT would
    theoretically proceed whether or not the existing identity were still in the database.
    The warning can also be configured to raise an exception using the Python warnings
    filter.
  id: totrans-1642
  prefs: []
  type: TYPE_NORMAL
  zh: 由于涉及主键的逻辑会导致所有数据库在插入时出现主键冲突时发出完整性错误。不会引发错误的情况是极为罕见的，即在映射定义了比实际配置在数据库模式中更严格的主键的情况下，例如在映射到表的连接或在定义附加列作为复合主键的一部分时，这些列实际上在数据库模式中并没有约束。然而，这些情况也更一致地工作，即使现有标识仍然存在于数据库中，插入理论上也会继续进行。警告也可以通过Python警告过滤器配置为引发异常。
- en: '[#4662](https://www.sqlalchemy.org/trac/ticket/4662)'
  id: totrans-1643
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4662](https://www.sqlalchemy.org/trac/ticket/4662)'
- en: '### Persistence-related cascade operations disallowed with viewonly=True'
  id: totrans-1644
  prefs: []
  type: TYPE_NORMAL
  zh: '### 持久化相关级联操作在viewonly=True时不允许'
- en: When a [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") is set as `viewonly=True` using the [`relationship.viewonly`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.viewonly
    "sqlalchemy.orm.relationship") flag, it indicates this relationship should only
    be used to load data from the database, and should not be mutated or involved
    in a persistence operation. In order to ensure this contract works successfully,
    the relationship can no longer specify [`relationship.cascade`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.cascade
    "sqlalchemy.orm.relationship") settings that make no sense in terms of “viewonly”.
  id: totrans-1645
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用[`relationship.viewonly`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.viewonly
    "sqlalchemy.orm.relationship")标志将[`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")设置为`viewonly=True`时，表示此关系应仅用于从数据库加载数据，并且不应进行变异或参与持久化操作。为了确保此契约成功运行，关系不能再指定在“viewonly”方面毫无意义的[`relationship.cascade`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.cascade
    "sqlalchemy.orm.relationship")设置。
- en: 'The primary targets here are the “delete, delete-orphan” cascades, which through
    1.3 continued to impact persistence even if viewonly were True, which is a bug;
    even if viewonly were True, an object would still cascade these two operations
    onto the related object if the parent were deleted or the object were detached.
    Rather than modify the cascade operations to check for viewonly, the configuration
    of both of these together is simply disallowed:'
  id: totrans-1646
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的主要目标是“delete, delete-orphan”级联，即使viewonly为True，通过1.3仍会影响持久性，这是一个错误；即使viewonly为True，如果父对象被删除或对象被分离，对象仍会将这两个操作级联到相关对象。而不是修改级联操作以检查viewonly，这两者的配置被简单地禁止在一起：
- en: '[PRE388]'
  id: totrans-1647
  prefs: []
  type: TYPE_PRE
  zh: '[PRE388]'
- en: 'The above will raise:'
  id: totrans-1648
  prefs: []
  type: TYPE_NORMAL
  zh: 上述将引发：
- en: '[PRE389]'
  id: totrans-1649
  prefs: []
  type: TYPE_PRE
  zh: '[PRE389]'
- en: Applications that have this issue should be emitting a warning as of SQLAlchemy
    1.3.12, and for the above error the solution is to remove the cascade settings
    for a viewonly relationship.
  id: totrans-1650
  prefs: []
  type: TYPE_NORMAL
  zh: 作为SQLAlchemy 1.3.12的一部分，存在此问题的应用程序应该发出警告，对于上述错误，解决方案是删除视图关系的级联设置。
- en: '[#4993](https://www.sqlalchemy.org/trac/ticket/4993) [#4994](https://www.sqlalchemy.org/trac/ticket/4994)'
  id: totrans-1651
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4993](https://www.sqlalchemy.org/trac/ticket/4993) [#4994](https://www.sqlalchemy.org/trac/ticket/4994)'
- en: '### Stricter behavior when querying inheritance mappings using custom queries'
  id: totrans-1652
  prefs: []
  type: TYPE_NORMAL
  zh: '### 使用自定义查询查询继承映射时更严格的行为'
- en: This change applies to the scenario where a joined- or single- table inheritance
    subclass entity is being queried, given a completed SELECT subquery to select
    from. If the given subquery returns rows that do not correspond to the requested
    polymorphic identity or identities, an error is raised. Previously, this condition
    would pass silently under joined table inheritance, returning an invalid subclass,
    and under single table inheritance, the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") would be adding additional criteria against the subquery
    to limit the results which could inappropriately interfere with the intent of
    the query.
  id: totrans-1653
  prefs: []
  type: TYPE_NORMAL
  zh: 此更改适用于查询已完成的SELECT子查询以选择的连接或单表继承子类实体的情况。如果给定的子查询返回与请求的多态标识或标识不对应的行，则会引发错误。以前，在连接表继承下，此条件会悄悄通过，返回一个无效的子类，并且在单表继承下，[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")会添加额外的条件来限制结果，这可能会不当地干扰查询的意图。
- en: 'Given the example mapping of `Employee`, `Engineer(Employee)`, `Manager(Employee)`,
    in the 1.3 series if we were to emit the following query against a joined inheritance
    mapping:'
  id: totrans-1654
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于`Employee`，`Engineer(Employee)`，`Manager(Employee)`的示例映射，在1.3系列中，如果我们针对连接继承映射发出以下查询：
- en: '[PRE390]'
  id: totrans-1655
  prefs: []
  type: TYPE_PRE
  zh: '[PRE390]'
- en: 'The subquery selects both the `Engineer` and the `Manager` rows, and even though
    the outer query is against `Manager`, we get a non `Manager` object back:'
  id: totrans-1656
  prefs: []
  type: TYPE_NORMAL
  zh: 子查询选择了`Engineer`和`Manager`行，即使外部查询针对`Manager`，我们也会得到一个非`Manager`对象：
- en: '[PRE391]'
  id: totrans-1657
  prefs: []
  type: TYPE_PRE
  zh: '[PRE391]'
- en: 'The new behavior is that this condition raises an error:'
  id: totrans-1658
  prefs: []
  type: TYPE_NORMAL
  zh: 新行为是这种情况会引发错误：
- en: '[PRE392]'
  id: totrans-1659
  prefs: []
  type: TYPE_PRE
  zh: '[PRE392]'
- en: The above error only raises if the primary key columns of that entity are non-NULL.
    If there’s no primary key for a given entity in a row, no attempt to construct
    an entity is made.
  id: totrans-1660
  prefs: []
  type: TYPE_NORMAL
  zh: 仅当该实体的主键列为非NULL时才会引发上述错误。如果行中没有给定实体的主键，则不会尝试构造实体。
- en: 'In the case of single inheritance mapping, the change in behavior is slightly
    more involved; if `Engineer` and `Manager` above are mapped with single table
    inheritance, in 1.3 the following query would be emitted and only a `Manager`
    object is returned:'
  id: totrans-1661
  prefs: []
  type: TYPE_NORMAL
  zh: 在单继承映射的情况下，行为的变化稍微更为复杂；如果上述的`Engineer`和`Manager`被映射为单表继承，在1.3中，将发出以下查询，并且只返回一个`Manager`对象：
- en: '[PRE393]'
  id: totrans-1662
  prefs: []
  type: TYPE_PRE
  zh: '[PRE393]'
- en: 'The [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    added the “single table inheritance” criteria to the subquery, editorializing
    on the intent that was originally set up by it. This behavior was added in version
    1.0 in [#3891](https://www.sqlalchemy.org/trac/ticket/3891), and creates a behavioral
    inconsistency between “joined” and “single” table inheritance, and additionally
    modifies the intent of the given query, which may intend to return additional
    rows where the columns that correspond to the inheriting entity are NULL, which
    is a valid use case. The behavior is now equivalent to that of joined table inheritance,
    where it is assumed that the subquery returns the correct rows and an error is
    raised if an unexpected polymorphic identity is encountered:'
  id: totrans-1663
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")向子查询添加了“单表继承”条件，对最初设置的意图进行了评论。此行为是在版本1.0中添加的[#3891](https://www.sqlalchemy.org/trac/ticket/3891)，并在“连接”和“单”表继承之间创建了行为不一致，并且修改了给定查询的意图，可能意图返回列对应于继承实体的空值的其他行，这是一个有效的用例。该行为现在等同于连接表继承的行为，其中假定子查询返回正确的行，如果遇到意外的多态标识，则会引发错误：'
- en: '[PRE394]'
  id: totrans-1664
  prefs: []
  type: TYPE_PRE
  zh: '[PRE394]'
- en: 'The correct adjustment to the situation as presented above which worked on
    1.3 is to adjust the given subquery to correctly filter the rows based on the
    discriminator column:'
  id: totrans-1665
  prefs: []
  type: TYPE_NORMAL
  zh: 如上所述的情况下的正确调整是调整给定的子查询，以正确根据鉴别器列过滤行：
- en: '[PRE395]'
  id: totrans-1666
  prefs: []
  type: TYPE_PRE
  zh: '[PRE395]'
- en: '[PRE396]'
  id: totrans-1667
  prefs: []
  type: TYPE_PRE
  zh: '[PRE396]'
- en: '[#5122](https://www.sqlalchemy.org/trac/ticket/5122)'
  id: totrans-1668
  prefs: []
  type: TYPE_NORMAL
  zh: '[#5122](https://www.sqlalchemy.org/trac/ticket/5122)'
- en: Dialect Changes
  id: totrans-1669
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方言更改
- en: pg8000 minimum version is 1.16.6, supports Python 3 only
  id: totrans-1670
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: pg8000的最低版本为1.16.6，仅支持Python 3
- en: Support for the pg8000 dialect has been dramatically improved, with help from
    the project’s maintainer.
  id: totrans-1671
  prefs: []
  type: TYPE_NORMAL
  zh: 支持pg8000方言已经得到显着改进，得益于该项目的维护者。
- en: Due to API changes, the pg8000 dialect now requires version 1.16.6 or greater.
    The pg8000 series has dropped Python 2 support as of the 1.13 series. Python 2
    users who require pg8000 should ensure their requirements are pinned at `SQLAlchemy<1.4`.
  id: totrans-1672
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 API 更改，pg8000 方言现在需要版本 1.16.6 或更高版本。从 1.13 系列开始，pg8000 系列已经放弃了 Python 2 支持。需要
    pg8000 的 Python 2 用户应确保他们的要求被固定在 `SQLAlchemy<1.4`。
- en: '[#5451](https://www.sqlalchemy.org/trac/ticket/5451)'
  id: totrans-1673
  prefs: []
  type: TYPE_NORMAL
  zh: '[#5451](https://www.sqlalchemy.org/trac/ticket/5451)'
- en: psycopg2 version 2.7 or higher is required for the PostgreSQL psycopg2 dialect
  id: totrans-1674
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PostgreSQL psycopg2 方言需要 psycopg2 版本 2.7 或更高版本。
- en: The psycopg2 dialect relies upon many features of psycopg2 released in the past
    few years. To simplify the dialect, version 2.7, released in March, 2017 is now
    the minimum version required.
  id: totrans-1675
  prefs: []
  type: TYPE_NORMAL
  zh: psycopg2 方言依赖于过去几年中发布的许多 psycopg2 特性。为了简化方言，现在要求的最低版本是 2017 年 3 月发布的版本 2.7。
- en: '### psycopg2 dialect no longer has limitations regarding bound parameter names'
  id: totrans-1676
  prefs: []
  type: TYPE_NORMAL
  zh: '### psycopg2 方言不再对绑定参数名称有限制'
- en: SQLAlchemy 1.3 was not able to accommodate bound parameter names that included
    percent signs or parenthesis under the psycopg2 dialect. This in turn meant that
    column names which included these characters were also problematic as INSERT and
    other DML statements would generate parameter names that matched that of the column,
    which would then cause failures. The workaround was to make use of the [`Column.key`](../core/metadata.html#sqlalchemy.schema.Column.params.key
    "sqlalchemy.schema.Column") parameter so that an alternate name that would be
    used to generate the parameter, or otherwise the parameter style of the dialect
    had to be changed at the [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") level. As of SQLAlchemy 1.4.0beta3 all naming limitations
    have been removed and parameters are fully escaped in all scenarios, so these
    workarounds are no longer necessary.
  id: totrans-1677
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 1.3 无法适应在 psycopg2 方言下包含百分号或括号的绑定参数名称。这反过来意味着包含这些字符的列名也有问题，因为 INSERT
    和其他 DML 语句会生成与列名匹配的参数名称，这将导致失败。解决方法是利用 [`Column.key`](../core/metadata.html#sqlalchemy.schema.Column.params.key
    "sqlalchemy.schema.Column") 参数，以便生成用于生成参数的替代名称，或者必须在 [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") 级别更改方言的参数样式。从 SQLAlchemy 1.4.0beta3 开始，所有命名限制都已被移除，并且在所有情况下参数都被完全转义，因此这些解决方法不再必要。
- en: '[#5941](https://www.sqlalchemy.org/trac/ticket/5941)'
  id: totrans-1678
  prefs: []
  type: TYPE_NORMAL
  zh: '[#5941](https://www.sqlalchemy.org/trac/ticket/5941)'
- en: '[#5653](https://www.sqlalchemy.org/trac/ticket/5653)  ### psycopg2 dialect
    features “execute_values” with RETURNING for INSERT statements by default'
  id: totrans-1679
  prefs: []
  type: TYPE_NORMAL
  zh: '[#5653](https://www.sqlalchemy.org/trac/ticket/5653)  ### psycopg2 方言默认使用“execute_values”和
    RETURNING 来进行 INSERT 语句'
- en: The first half of a significant performance enhancement for PostgreSQL when
    using both Core and ORM, the psycopg2 dialect now uses `psycopg2.extras.execute_values()`
    by default for compiled INSERT statements and also implements RETURNING support
    in this mode. The other half of this change is [ORM Batch inserts with psycopg2
    now batch statements with RETURNING in most cases](#change-5263) which allows
    the ORM to take advantage of RETURNING with executemany (i.e. batching of INSERT
    statements) so that ORM bulk inserts with psycopg2 are up to 400% faster depending
    on specifics.
  id: totrans-1680
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Core 和 ORM 时，PostgreSQL 的一个重要性能增强的前半部分，psycopg2 方言现在默认使用 `psycopg2.extras.execute_values()`
    来编译 INSERT 语句，并在此模式下实现了 RETURNING 支持。这一变化的另一半是 [ORM 批量插入现在在大多数情况下使用带有 RETURNING
    的 psycopg2 批量语句](#change-5263)，这使得 ORM 能够利用 executemany（即批量插入语句）的 RETURNING，因此使用
    psycopg2 进行的 ORM 批量插入速度提高了 400%，具体取决于具体情况。
- en: This extension method allows many rows to be INSERTed within a single statement,
    using an extended VALUES clause for the statement. While SQLAlchemy’s [`insert()`](../core/dml.html#sqlalchemy.sql.expression.insert
    "sqlalchemy.sql.expression.insert") construct already supports this syntax via
    the [`Insert.values()`](../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") method, the extension method allows
    the construction of the VALUES clause to occur dynamically when the statement
    is executed as an “executemany” execution, which is what occurs when one passes
    a list of parameter dictionaries to [`Connection.execute()`](../core/connections.html#sqlalchemy.engine.Connection.execute
    "sqlalchemy.engine.Connection.execute"). It also occurs beyond the cache boundary
    so that the INSERT statement may be cached before the VALUES are rendered.
  id: totrans-1681
  prefs: []
  type: TYPE_NORMAL
  zh: 此扩展方法允许在单个语句中插入多行，使用语句的扩展VALUES子句。虽然SQLAlchemy的[`insert()`](../core/dml.html#sqlalchemy.sql.expression.insert
    "sqlalchemy.sql.expression.insert")构造已经通过[`Insert.values()`](../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values")方法支持此语法，但扩展方法允许在执行语句时动态构建VALUES子句，这是当将参数字典列表传递给[`Connection.execute()`](../core/connections.html#sqlalchemy.engine.Connection.execute
    "sqlalchemy.engine.Connection.execute")时发生的“executemany”执行。它还发生在缓存边界之外，以便在渲染VALUES之前可以缓存INSERT语句。
- en: 'A quick test of the `execute_values()` approach using the `bulk_inserts.py`
    script in the [Performance](../orm/examples.html#examples-performance) example
    suite reveals an approximate **fivefold performance increase**:'
  id: totrans-1682
  prefs: []
  type: TYPE_NORMAL
  zh: 在[性能](../orm/examples.html#examples-performance)示例套件中使用`bulk_inserts.py`脚本快速测试`execute_values()`方法，显示出约**五倍的性能提升**：
- en: '[PRE397]'
  id: totrans-1683
  prefs: []
  type: TYPE_PRE
  zh: '[PRE397]'
- en: Support for the “batch” extension was added in version 1.2 in [Support for Batch
    Mode / Fast Execution Helpers](migration_12.html#change-4109), and enhanced to
    include support for the `execute_values` extension in 1.3 in [#4623](https://www.sqlalchemy.org/trac/ticket/4623).
    In 1.4 the `execute_values` extension is now being turned on by default for INSERT
    statements; the “batch” extension for UPDATE and DELETE remains off by default.
  id: totrans-1684
  prefs: []
  type: TYPE_NORMAL
  zh: “batch”扩展的支持是在版本1.2中添加的，在[支持批处理模式/快速执行助手](migration_12.html#change-4109)，并在1.3中增强以支持`execute_values`扩展在[#4623](https://www.sqlalchemy.org/trac/ticket/4623)中。在1.4中，`execute_values`扩展现在默认为INSERT语句打开；UPDATE和DELETE的“batch”扩展默认关闭。
- en: In addition, the `execute_values` extension function supports returning the
    rows that are generated by RETURNING as an aggregated list. The psycopg2 dialect
    will now retrieve this list if the given [`insert()`](../core/dml.html#sqlalchemy.sql.expression.insert
    "sqlalchemy.sql.expression.insert") construct requests returning via the [`Insert.returning()`](../core/dml.html#sqlalchemy.sql.expression.Insert.returning
    "sqlalchemy.sql.expression.Insert.returning") method or similar methods intended
    to return generated defaults; the rows are then installed in the result so that
    they are retrieved as though they came from the cursor directly. This allows tools
    like the ORM to use batched inserts in all cases, which is expected to provide
    a dramatic performance improvement.
  id: totrans-1685
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`execute_values`扩展函数支持将由RETURNING生成的行作为聚合列表返回。如果给定的[`insert()`](../core/dml.html#sqlalchemy.sql.expression.insert
    "sqlalchemy.sql.expression.insert")构造请求通过[`Insert.returning()`](../core/dml.html#sqlalchemy.sql.expression.Insert.returning
    "sqlalchemy.sql.expression.Insert.returning")方法或类似用于返回生成默认值的方法来返回，psycopg2方言现在将检索此列表；然后将这些行安装在结果中，以便它们被检索为直接来自游标。这允许ORM等工具在所有情况下使用批量插入，预计将提供显著的性能改进。
- en: 'The `executemany_mode` feature of the psycopg2 dialect has been revised with
    the following changes:'
  id: totrans-1686
  prefs: []
  type: TYPE_NORMAL
  zh: psycopg2方言的`executemany_mode`功能已经进行了以下更改：
- en: A new mode `"values_only"` is added. This mode uses the very performant `psycopg2.extras.execute_values()`
    extension method for compiled INSERT statements run with executemany(), but does
    not use `execute_batch()` for UPDATE and DELETE statements. This new mode is now
    the default setting for the psycopg2 dialect.
  id: totrans-1687
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加了一个新模式`"values_only"`。此模式使用非常高效的`psycopg2.extras.execute_values()`扩展方法来运行使用executemany()的编译INSERT语句，但不使用`execute_batch()`来运行UPDATE和DELETE语句。这种新模式现在是psycopg2方言的默认设置。
- en: The existing `"values"` mode is now named `"values_plus_batch"`. This mode will
    use `execute_values` for INSERT statements and `execute_batch` for UPDATE and
    DELETE statements. The mode is not enabled by default because it disables the
    proper functioning of `cursor.rowcount` with UPDATE and DELETE statements executed
    with `executemany()`.
  id: totrans-1688
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现有的“values”模式现在被命名为“values_plus_batch”。此模式将使用`execute_values`进行INSERT语句，使用`execute_batch`进行UPDATE和DELETE语句。该模式默认未启用，因为它会禁用使用`executemany()`执行UPDATE和DELETE语句时的`cursor.rowcount`的正确功能。
- en: RETURNING support is enabled for `"values_only"` and `"values"` for INSERT statements.
    The psycopg2 dialect will receive the rows back from psycopg2 using the fetch=True
    flag and install them into the result set as though they came directly from the
    cursor (which they ultimately did, however psycopg2’s extension function has aggregated
    multiple batches into one list).
  id: totrans-1689
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于INSERT语句，启用了“values_only”和“values”的RETURNING支持。psycopg2方言将使用fetch=True标志从psycopg2接收行，并将它们安装到结果集中，就好像它们直接来自游标（尽管最终确实是这样，但是psycopg2的扩展函数已经将多个批次聚合成一个列表）。
- en: The default “page_size” setting for `execute_values` has been increased from
    100 to 1000\. The default remains at 100 for the `execute_batch` function. These
    parameters may both be modified as was the case before.
  id: totrans-1690
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`execute_values`的默认“page_size”设置从100增加到1000。`execute_batch`函数的默认值仍为100。这些参数可以像以前一样进行修改。'
- en: The `use_batch_mode` flag that was part of the 1.2 version of the feature is
    removed; the behavior remains controllable via the `executemany_mode` flag added
    in 1.3.
  id: totrans-1691
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1.2版本功能中的`use_batch_mode`标志已被移除；行为仍可通过1.3中添加的`executemany_mode`标志进行控制。
- en: The Core engine and dialect has been enhanced to support executemany plus returning
    mode, currently only available with psycopg2, by providing new [`CursorResult.inserted_primary_key_rows`](../core/connections.html#sqlalchemy.engine.CursorResult.inserted_primary_key_rows
    "sqlalchemy.engine.CursorResult.inserted_primary_key_rows") and `CursorResult.returned_default_rows`
    accessors.
  id: totrans-1692
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 核心引擎和方言已经增强，以支持`executemany`加上返回模式，目前仅适用于psycopg2，通过提供新的[`CursorResult.inserted_primary_key_rows`](../core/connections.html#sqlalchemy.engine.CursorResult.inserted_primary_key_rows
    "sqlalchemy.engine.CursorResult.inserted_primary_key_rows")和`CursorResult.returned_default_rows`访问器。
- en: See also
  id: totrans-1693
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[Psycopg2 Fast Execution Helpers](../dialects/postgresql.html#psycopg2-executemany-mode)'
  id: totrans-1694
  prefs: []
  type: TYPE_NORMAL
  zh: '[Psycopg2快速执行助手](../dialects/postgresql.html#psycopg2-executemany-mode)'
- en: '[#5401](https://www.sqlalchemy.org/trac/ticket/5401)  ### Removed “join rewriting”
    logic from SQLite dialect; updated imports'
  id: totrans-1695
  prefs: []
  type: TYPE_NORMAL
  zh: '[#5401](https://www.sqlalchemy.org/trac/ticket/5401)  ### 从SQLite方言中删除了“连接重写”逻辑；更新了导入'
- en: Dropped support for right-nested join rewriting to support old SQLite versions
    prior to 3.7.16, released in 2013\. It is not expected that any modern Python
    versions rely upon this limitation.
  id: totrans-1696
  prefs: []
  type: TYPE_NORMAL
  zh: 放弃了支持右嵌套连接重写，以支持2013年发布的旧SQLite版本低于3.7.16。不希望任何现代Python版本依赖于此限制。
- en: The behavior was first introduced in 0.9 and was part of the larger change of
    allowing for right nested joins as described at [Many JOIN and LEFT OUTER JOIN
    expressions will no longer be wrapped in (SELECT * FROM ..) AS ANON_1](migration_09.html#feature-joins-09).
    However the SQLite workaround produced many regressions in the 2013-2014 period
    due to its complexity. In 2016, the dialect was modified so that the join rewriting
    logic would only occur for SQLite versions prior to 3.7.16 after bisection was
    used to identify where SQLite fixed its support for this construct, and no further
    issues were reported against the behavior (even though some bugs were found internally).
    It is now anticipated that there are little to no Python builds for Python 2.7
    or 3.5 and above (the supported Python versions) which would include a SQLite
    version prior to 3.7.17, and the behavior is only necessary only in more complex
    ORM joining scenarios. A warning is now emitted if the installed SQLite version
    is older than 3.7.16.
  id: totrans-1697
  prefs: []
  type: TYPE_NORMAL
  zh: 该行为首次在0.9版本中引入，并作为更大变化的一部分，允许右嵌套连接，如[migration_09.html#feature-joins-09](https://www.sqlalchemy.org/trac/ticket/5401)所述。然而，由于其复杂性，SQLite的解决方法在2013-2014年间产生了许多回归问题。2016年，方言被修改，以便连接重写逻辑仅在SQLite版本低于3.7.16时发生，通过二分法确定SQLite修复了对此结构的支持的位置，并且没有进一步的问题报告该行为（尽管在内部发现了一些错误）。现在预计，几乎没有Python
    2.7或3.5及以上版本（支持的Python版本）的构建包含SQLite版本低于3.7.17，该行为仅在更复杂的ORM连接场景中才是必要的。如果安装的SQLite版本旧于3.7.16，则现在会发出警告。
- en: In related changes, the module imports for SQLite no longer attempt to import
    the “pysqlite2” driver on Python 3 as this driver does not exist on Python 3;
    a very old warning for old pysqlite2 versions is also dropped.
  id: totrans-1698
  prefs: []
  type: TYPE_NORMAL
  zh: 在相关更改中，SQLite的模块导入不再尝试在Python 3上导入“pysqlite2”驱动程序，因为该驱动程序在Python 3上不存在；对于旧的pysqlite2版本的非常古老的警告也被删除。
- en: '[#4895](https://www.sqlalchemy.org/trac/ticket/4895)  ### Added Sequence support
    for MariaDB 10.3'
  id: totrans-1699
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4895](https://www.sqlalchemy.org/trac/ticket/4895)  ### 为MariaDB 10.3添加了序列支持'
- en: The MariaDB database as of 10.3 supports sequences. SQLAlchemy’s MySQL dialect
    now implements support for the [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence") object against this database, meaning “CREATE SEQUENCE”
    DDL will be emitted for a [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence") that is present in a [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") or [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") collection in the same way as it works for backends
    such as PostgreSQL, Oracle, when the dialect’s server version check has confirmed
    the database is MariaDB 10.3 or greater. Additionally, the [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence") will act as a column default and primary key generation
    object when used in these ways.
  id: totrans-1700
  prefs: []
  type: TYPE_NORMAL
  zh: MariaDB数据库截至10.3版本支持序列。SQLAlchemy的MySQL方言现在在该数据库上实现了对[`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence")对象的支持，这意味着对于在相同方式下的[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")或[`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData")集合中存在的[`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence")将发出“CREATE SEQUENCE” DDL，就像对于后端如PostgreSQL、Oracle等一样，当方言的服务器版本检查确认数据库是MariaDB
    10.3或更高版本时。此外，当以这些方式使用时，[`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence")将作为列默认值和主键生成对象。
- en: 'Since this change will impact the assumptions both for DDL as well as the behavior
    of INSERT statements for an application that is currently deployed against MariaDB
    10.3 which also happens to make explicit use the [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence") construct within its table definitions, it is important
    to note that [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence "sqlalchemy.schema.Sequence")
    supports a flag [`Sequence.optional`](../core/defaults.html#sqlalchemy.schema.Sequence.params.optional
    "sqlalchemy.schema.Sequence") which is used to limit the scenarios in which the
    [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence "sqlalchemy.schema.Sequence")
    to take effect. When “optional” is used on a [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence") that is present in the integer primary key column
    of a table:'
  id: totrans-1701
  prefs: []
  type: TYPE_NORMAL
  zh: 由于此更改将影响当前部署在MariaDB 10.3上的应用程序的DDL和INSERT语句的行为假设，同时也会显式使用[`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence")构造在其表定义中，因此重要的是要注意[`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence")支持一个标志[`Sequence.optional`](../core/defaults.html#sqlalchemy.schema.Sequence.params.optional
    "sqlalchemy.schema.Sequence")，用于限制[`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence")生效的情况。当在表的整数主键列中使用“optional”时，[`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence")：
- en: '[PRE398]'
  id: totrans-1702
  prefs: []
  type: TYPE_PRE
  zh: '[PRE398]'
- en: The above [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence "sqlalchemy.schema.Sequence")
    is only used for DDL and INSERT statements if the target database does not support
    any other means of generating integer primary key values for the column. That
    is, the Oracle database above would use the sequence, however the PostgreSQL and
    MariaDB 10.3 databases would not. This may be important for an existing application
    that is upgrading to SQLAlchemy 1.4 which may not have emitted DDL for this [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence") against its backing database, as an INSERT statement
    will fail if it seeks to use a sequence that was not created.
  id: totrans-1703
  prefs: []
  type: TYPE_NORMAL
  zh: 上述[`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence "sqlalchemy.schema.Sequence")仅在目标数据库不支持其他生成整数主键值的方式时用于DDL和INSERT语句。也就是说，上述Oracle数据库将使用该序列，但PostgreSQL和MariaDB
    10.3数据库不会。对于正在升级到SQLAlchemy 1.4的现有应用程序而言，这可能很重要，因为如果尝试使用未创建的序列进行INSERT语句，则会失败。
- en: See also
  id: totrans-1704
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Defining Sequences](../core/defaults.html#defaults-sequences)'
  id: totrans-1705
  prefs: []
  type: TYPE_NORMAL
  zh: '[定义序列](../core/defaults.html#defaults-sequences)'
- en: '[#4976](https://www.sqlalchemy.org/trac/ticket/4976)  ### Added Sequence support
    distinct from IDENTITY to SQL Server'
  id: totrans-1706
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4976](https://www.sqlalchemy.org/trac/ticket/4976)  ### 添加了对SQL Server的与IDENTITY不同的Sequence支持'
- en: The [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence "sqlalchemy.schema.Sequence")
    construct is now fully functional with Microsoft SQL Server. When applied to a
    [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column"),
    the DDL for the table will no longer include IDENTITY keywords and instead will
    rely upon “CREATE SEQUENCE” to ensure a sequence is present which will then be
    used for INSERT statements on the table.
  id: totrans-1707
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence "sqlalchemy.schema.Sequence")构造现在与Microsoft
    SQL Server完全兼容。当应用于[`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")时，表的DDL将不再包含IDENTITY关键字，而是依赖于“CREATE
    SEQUENCE”来确保存在一个序列，然后将用于表上的INSERT语句。'
- en: The [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence "sqlalchemy.schema.Sequence")
    prior to version 1.3 was used to control parameters for the IDENTITY column in
    SQL Server; this usage emitted deprecation warnings throughout 1.3 and is now
    removed in 1.4\. For control of parameters for an IDENTITY column, the `mssql_identity_start`
    and `mssql_identity_increment` parameters should be used; see the MSSQL dialect
    documentation linked below.
  id: totrans-1708
  prefs: []
  type: TYPE_NORMAL
  zh: 在版本1.3之前，[`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence "sqlalchemy.schema.Sequence")用于控制SQL
    Server中IDENTITY列的参数；这种用法在1.3期间发出了弃用警告，并在1.4中被移除。要控制IDENTITY列的参数，应使用`mssql_identity_start`和`mssql_identity_increment`参数；请参阅下面链接的MSSQL方言文档。
- en: See also
  id: totrans-1709
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[Auto Increment Behavior / IDENTITY Columns](../dialects/mssql.html#mssql-identity)'
  id: totrans-1710
  prefs: []
  type: TYPE_NORMAL
  zh: '[自增行为/IDENTITY列](../dialects/mssql.html#mssql-identity)'
- en: '[#4235](https://www.sqlalchemy.org/trac/ticket/4235)'
  id: totrans-1711
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4235](https://www.sqlalchemy.org/trac/ticket/4235)'
- en: '[#4633](https://www.sqlalchemy.org/trac/ticket/4633)'
  id: totrans-1712
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4633](https://www.sqlalchemy.org/trac/ticket/4633)'
- en: pg8000 minimum version is 1.16.6, supports Python 3 only
  id: totrans-1713
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: pg8000的最低版本为1.16.6，仅支持Python 3
- en: Support for the pg8000 dialect has been dramatically improved, with help from
    the project’s maintainer.
  id: totrans-1714
  prefs: []
  type: TYPE_NORMAL
  zh: pg8000方言的支持得到了显著改善，得益于项目的维护者的帮助。
- en: Due to API changes, the pg8000 dialect now requires version 1.16.6 or greater.
    The pg8000 series has dropped Python 2 support as of the 1.13 series. Python 2
    users who require pg8000 should ensure their requirements are pinned at `SQLAlchemy<1.4`.
  id: totrans-1715
  prefs: []
  type: TYPE_NORMAL
  zh: 由于API更改，pg8000方言现在要求版本为1.16.6或更高。从1.13系列开始，pg8000系列已经放弃了对Python 2的支持。需要pg8000的Python
    2用户应确保他们的要求被固定在`SQLAlchemy<1.4`。
- en: '[#5451](https://www.sqlalchemy.org/trac/ticket/5451)'
  id: totrans-1716
  prefs: []
  type: TYPE_NORMAL
  zh: '[#5451](https://www.sqlalchemy.org/trac/ticket/5451)'
- en: psycopg2 version 2.7 or higher is required for the PostgreSQL psycopg2 dialect
  id: totrans-1717
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 要求使用版本为2.7或更高的psycopg2以支持PostgreSQL psycopg2方言
- en: The psycopg2 dialect relies upon many features of psycopg2 released in the past
    few years. To simplify the dialect, version 2.7, released in March, 2017 is now
    the minimum version required.
  id: totrans-1718
  prefs: []
  type: TYPE_NORMAL
  zh: psycopg2方言依赖于过去几年中发布的许多psycopg2功能。为了简化方言，现在要求的最低版本是2017年3月发布的版本2.7。
- en: '### psycopg2 dialect no longer has limitations regarding bound parameter names'
  id: totrans-1719
  prefs: []
  type: TYPE_NORMAL
  zh: '### psycopg2方言不再对绑定参数名称有限制'
- en: SQLAlchemy 1.3 was not able to accommodate bound parameter names that included
    percent signs or parenthesis under the psycopg2 dialect. This in turn meant that
    column names which included these characters were also problematic as INSERT and
    other DML statements would generate parameter names that matched that of the column,
    which would then cause failures. The workaround was to make use of the [`Column.key`](../core/metadata.html#sqlalchemy.schema.Column.params.key
    "sqlalchemy.schema.Column") parameter so that an alternate name that would be
    used to generate the parameter, or otherwise the parameter style of the dialect
    had to be changed at the [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") level. As of SQLAlchemy 1.4.0beta3 all naming limitations
    have been removed and parameters are fully escaped in all scenarios, so these
    workarounds are no longer necessary.
  id: totrans-1720
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 1.3无法容纳包含百分号或括号的绑定参数名称，这意味着包含这些字符的列名也会有问题，因为INSERT和其他DML语句会生成与列名匹配的参数名称，这将导致失败。解决方法是利用[`Column.key`](../core/metadata.html#sqlalchemy.schema.Column.params.key
    "sqlalchemy.schema.Column")参数，以便使用替代名称来生成参数，或者在[`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine")级别更改方言的参数样式。从SQLAlchemy 1.4.0beta3开始，所有命名限制都已被移除，并且在所有情况下参数都被完全转义，因此这些解决方法不再必要。
- en: '[#5941](https://www.sqlalchemy.org/trac/ticket/5941)'
  id: totrans-1721
  prefs: []
  type: TYPE_NORMAL
  zh: '[#5941](https://www.sqlalchemy.org/trac/ticket/5941)'
- en: '[#5653](https://www.sqlalchemy.org/trac/ticket/5653)'
  id: totrans-1722
  prefs: []
  type: TYPE_NORMAL
  zh: '[#5653](https://www.sqlalchemy.org/trac/ticket/5653)'
- en: '### psycopg2 dialect features “execute_values” with RETURNING for INSERT statements
    by default'
  id: totrans-1723
  prefs: []
  type: TYPE_NORMAL
  zh: '### psycopg2方言默认使用“execute_values”与RETURNING来处理INSERT语句'
- en: The first half of a significant performance enhancement for PostgreSQL when
    using both Core and ORM, the psycopg2 dialect now uses `psycopg2.extras.execute_values()`
    by default for compiled INSERT statements and also implements RETURNING support
    in this mode. The other half of this change is [ORM Batch inserts with psycopg2
    now batch statements with RETURNING in most cases](#change-5263) which allows
    the ORM to take advantage of RETURNING with executemany (i.e. batching of INSERT
    statements) so that ORM bulk inserts with psycopg2 are up to 400% faster depending
    on specifics.
  id: totrans-1724
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Core和ORM时，PostgreSQL的一个重要性能增强的前半部分，psycopg2方言现在默认使用`psycopg2.extras.execute_values()`来编译INSERT语句，并且还在此模式下实现了RETURNING支持。这一变化的另一半是[ORM
    Batch inserts with psycopg2 now batch statements with RETURNING in most cases](#change-5263)，这允许ORM利用RETURNING与executemany（即批量插入INSERT语句）以便ORM批量插入与psycopg2在具体情况下快400%。
- en: This extension method allows many rows to be INSERTed within a single statement,
    using an extended VALUES clause for the statement. While SQLAlchemy’s [`insert()`](../core/dml.html#sqlalchemy.sql.expression.insert
    "sqlalchemy.sql.expression.insert") construct already supports this syntax via
    the [`Insert.values()`](../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") method, the extension method allows
    the construction of the VALUES clause to occur dynamically when the statement
    is executed as an “executemany” execution, which is what occurs when one passes
    a list of parameter dictionaries to [`Connection.execute()`](../core/connections.html#sqlalchemy.engine.Connection.execute
    "sqlalchemy.engine.Connection.execute"). It also occurs beyond the cache boundary
    so that the INSERT statement may be cached before the VALUES are rendered.
  id: totrans-1725
  prefs: []
  type: TYPE_NORMAL
  zh: 这个扩展方法允许在单个语句中插入多行，使用扩展的VALUES子句。虽然SQLAlchemy的[`insert()`](../core/dml.html#sqlalchemy.sql.expression.insert
    "sqlalchemy.sql.expression.insert")构造已经通过[`Insert.values()`](../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values")方法支持这种语法，但是扩展方法允许在执行语句时动态构建VALUES子句，这是在通过将参数字典列表传递给[`Connection.execute()`](../core/connections.html#sqlalchemy.engine.Connection.execute
    "sqlalchemy.engine.Connection.execute")时发生的“executemany”执行。它还发生在缓存边界之外，以便在渲染VALUES之前可以缓存INSERT语句。
- en: 'A quick test of the `execute_values()` approach using the `bulk_inserts.py`
    script in the [Performance](../orm/examples.html#examples-performance) example
    suite reveals an approximate **fivefold performance increase**:'
  id: totrans-1726
  prefs: []
  type: TYPE_NORMAL
  zh: 在[Performance](../orm/examples.html#examples-performance)示例套件中使用`bulk_inserts.py`脚本快速测试`execute_values()`方法，发现大约**五倍的性能提升**：
- en: '[PRE399]'
  id: totrans-1727
  prefs: []
  type: TYPE_PRE
  zh: '[PRE399]'
- en: Support for the “batch” extension was added in version 1.2 in [Support for Batch
    Mode / Fast Execution Helpers](migration_12.html#change-4109), and enhanced to
    include support for the `execute_values` extension in 1.3 in [#4623](https://www.sqlalchemy.org/trac/ticket/4623).
    In 1.4 the `execute_values` extension is now being turned on by default for INSERT
    statements; the “batch” extension for UPDATE and DELETE remains off by default.
  id: totrans-1728
  prefs: []
  type: TYPE_NORMAL
  zh: 在版本1.2中添加了对“batch”扩展的支持[Support for Batch Mode / Fast Execution Helpers](migration_12.html#change-4109)，并在1.3中增强以包括对`execute_values`扩展的支持[#4623](https://www.sqlalchemy.org/trac/ticket/4623)。在1.4中，`execute_values`扩展现在默认为INSERT语句打开；UPDATE和DELETE的“batch”扩展默认关闭。
- en: In addition, the `execute_values` extension function supports returning the
    rows that are generated by RETURNING as an aggregated list. The psycopg2 dialect
    will now retrieve this list if the given [`insert()`](../core/dml.html#sqlalchemy.sql.expression.insert
    "sqlalchemy.sql.expression.insert") construct requests returning via the [`Insert.returning()`](../core/dml.html#sqlalchemy.sql.expression.Insert.returning
    "sqlalchemy.sql.expression.Insert.returning") method or similar methods intended
    to return generated defaults; the rows are then installed in the result so that
    they are retrieved as though they came from the cursor directly. This allows tools
    like the ORM to use batched inserts in all cases, which is expected to provide
    a dramatic performance improvement.
  id: totrans-1729
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`execute_values`扩展函数支持将由`RETURNING`生成的行作为聚合列表返回。如果给定的[`insert()`](../core/dml.html#sqlalchemy.sql.expression.insert
    "sqlalchemy.sql.expression.insert")构造请求通过[`Insert.returning()`](../core/dml.html#sqlalchemy.sql.expression.Insert.returning
    "sqlalchemy.sql.expression.Insert.returning")方法或类似方法返回生成的默认值，则`psycopg2`方言现在将检索此列表；然后将这些行安装在结果中，以便像直接来自游标一样检索它们。这允许ORM等工具在所有情况下使用批量插入，预计将提供显著的性能改进。
- en: 'The `executemany_mode` feature of the psycopg2 dialect has been revised with
    the following changes:'
  id: totrans-1730
  prefs: []
  type: TYPE_NORMAL
  zh: '`psycopg2`方言的`executemany_mode`功能已经进行了以下更改：'
- en: A new mode `"values_only"` is added. This mode uses the very performant `psycopg2.extras.execute_values()`
    extension method for compiled INSERT statements run with executemany(), but does
    not use `execute_batch()` for UPDATE and DELETE statements. This new mode is now
    the default setting for the psycopg2 dialect.
  id: totrans-1731
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加了一个新模式`"values_only"`。此模式使用非常高效的`psycopg2.extras.execute_values()`扩展方法来运行使用`executemany()`的编译INSERT语句，但不使用`execute_batch()`来运行UPDATE和DELETE语句。这个新模式现在是`psycopg2`方言的默认设置。
- en: The existing `"values"` mode is now named `"values_plus_batch"`. This mode will
    use `execute_values` for INSERT statements and `execute_batch` for UPDATE and
    DELETE statements. The mode is not enabled by default because it disables the
    proper functioning of `cursor.rowcount` with UPDATE and DELETE statements executed
    with `executemany()`.
  id: totrans-1732
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现有的`"values"`模式现在被命名为`"values_plus_batch"`。此模式将使用`execute_values`进行INSERT语句，使用`execute_batch`进行UPDATE和DELETE语句。该模式默认情况下未启用，因为它会禁用使用`executemany()`执行UPDATE和DELETE语句时的`cursor.rowcount`的正确功能。
- en: RETURNING support is enabled for `"values_only"` and `"values"` for INSERT statements.
    The psycopg2 dialect will receive the rows back from psycopg2 using the fetch=True
    flag and install them into the result set as though they came directly from the
    cursor (which they ultimately did, however psycopg2’s extension function has aggregated
    multiple batches into one list).
  id: totrans-1733
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于INSERT语句，`"values_only"`和`"values"`启用了RETURNING支持。`psycopg2`方言将使用`fetch=True`标志从`psycopg2`接收行，并将它们安装到结果集中，就好像它们直接来自游标一样（尽管它们最终确实来自游标，但`psycopg2`的扩展函数已将多个批次聚合成一个列表）。
- en: The default “page_size” setting for `execute_values` has been increased from
    100 to 1000\. The default remains at 100 for the `execute_batch` function. These
    parameters may both be modified as was the case before.
  id: totrans-1734
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`execute_values`的默认“page_size”设置已从100增加到1000。`execute_batch`函数的默认值仍为100。这些参数可以像以前一样进行修改。'
- en: The `use_batch_mode` flag that was part of the 1.2 version of the feature is
    removed; the behavior remains controllable via the `executemany_mode` flag added
    in 1.3.
  id: totrans-1735
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1.2版本功能的`use_batch_mode`标志已被移除；行为仍可通过1.3版本中添加的`executemany_mode`标志进行控制。
- en: The Core engine and dialect has been enhanced to support executemany plus returning
    mode, currently only available with psycopg2, by providing new [`CursorResult.inserted_primary_key_rows`](../core/connections.html#sqlalchemy.engine.CursorResult.inserted_primary_key_rows
    "sqlalchemy.engine.CursorResult.inserted_primary_key_rows") and `CursorResult.returned_default_rows`
    accessors.
  id: totrans-1736
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 核心引擎和方言已经增强以支持`executemany`加返回模式，目前仅适用于`psycopg2`，通过提供新的[`CursorResult.inserted_primary_key_rows`](../core/connections.html#sqlalchemy.engine.CursorResult.inserted_primary_key_rows
    "sqlalchemy.engine.CursorResult.inserted_primary_key_rows")和`CursorResult.returned_default_rows`访问器。
- en: See also
  id: totrans-1737
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[Psycopg2 Fast Execution Helpers](../dialects/postgresql.html#psycopg2-executemany-mode)'
  id: totrans-1738
  prefs: []
  type: TYPE_NORMAL
  zh: '[Psycopg2 快速执行助手](../dialects/postgresql.html#psycopg2-executemany-mode)'
- en: '[#5401](https://www.sqlalchemy.org/trac/ticket/5401)'
  id: totrans-1739
  prefs: []
  type: TYPE_NORMAL
  zh: '[#5401](https://www.sqlalchemy.org/trac/ticket/5401)'
- en: '### Removed “join rewriting” logic from SQLite dialect; updated imports'
  id: totrans-1740
  prefs: []
  type: TYPE_NORMAL
  zh: '### 从SQLite方言中删除了“join rewriting”逻辑；更新了导入'
- en: Dropped support for right-nested join rewriting to support old SQLite versions
    prior to 3.7.16, released in 2013\. It is not expected that any modern Python
    versions rely upon this limitation.
  id: totrans-1741
  prefs: []
  type: TYPE_NORMAL
  zh: 放弃了支持右嵌套连接重写以支持2013年发布的旧SQLite版本3.7.16之前的版本。不希望任何现代Python版本依赖于此限制。
- en: The behavior was first introduced in 0.9 and was part of the larger change of
    allowing for right nested joins as described at [Many JOIN and LEFT OUTER JOIN
    expressions will no longer be wrapped in (SELECT * FROM ..) AS ANON_1](migration_09.html#feature-joins-09).
    However the SQLite workaround produced many regressions in the 2013-2014 period
    due to its complexity. In 2016, the dialect was modified so that the join rewriting
    logic would only occur for SQLite versions prior to 3.7.16 after bisection was
    used to identify where SQLite fixed its support for this construct, and no further
    issues were reported against the behavior (even though some bugs were found internally).
    It is now anticipated that there are little to no Python builds for Python 2.7
    or 3.5 and above (the supported Python versions) which would include a SQLite
    version prior to 3.7.17, and the behavior is only necessary only in more complex
    ORM joining scenarios. A warning is now emitted if the installed SQLite version
    is older than 3.7.16.
  id: totrans-1742
  prefs: []
  type: TYPE_NORMAL
  zh: 该行为首次在0.9版本中引入，并作为允许右嵌套连接的较大更改的一部分，如[许多JOIN和LEFT OUTER JOIN表达式将不再包装在(SELECT
    * FROM ..) AS ANON_1中](migration_09.html#feature-joins-09)所述。然而，由于其复杂性，SQLite的解决方法在2013-2014年期间产生了许多回归。2016年，方言被修改，以便仅在SQLite版本低于3.7.16的情况下进行连接重写逻辑，通过二分法确定SQLite修复了对此构造的支持的位置，并且没有进一步的问题报告该行为（尽管在内部发现了一些错误）。现在预计，几乎没有Python
    2.7或3.5及以上版本（支持的Python版本）的构建会包含SQLite版本低于3.7.17，该行为仅在更复杂的ORM连接场景中才是必要的。如果安装的SQLite版本旧于3.7.16，则现在会发出警告。
- en: In related changes, the module imports for SQLite no longer attempt to import
    the “pysqlite2” driver on Python 3 as this driver does not exist on Python 3;
    a very old warning for old pysqlite2 versions is also dropped.
  id: totrans-1743
  prefs: []
  type: TYPE_NORMAL
  zh: 在相关更改中，SQLite的模块导入不再尝试在Python 3上导入“pysqlite2”驱动程序，因为该驱动程序在Python 3上不存在；对于旧的pysqlite2版本的非常古老警告也被删除。
- en: '[#4895](https://www.sqlalchemy.org/trac/ticket/4895)'
  id: totrans-1744
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4895](https://www.sqlalchemy.org/trac/ticket/4895)'
- en: '### Added Sequence support for MariaDB 10.3'
  id: totrans-1745
  prefs: []
  type: TYPE_NORMAL
  zh: '### 为MariaDB 10.3添加了Sequence支持'
- en: The MariaDB database as of 10.3 supports sequences. SQLAlchemy’s MySQL dialect
    now implements support for the [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence") object against this database, meaning “CREATE SEQUENCE”
    DDL will be emitted for a [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence") that is present in a [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") or [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") collection in the same way as it works for backends
    such as PostgreSQL, Oracle, when the dialect’s server version check has confirmed
    the database is MariaDB 10.3 or greater. Additionally, the [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence") will act as a column default and primary key generation
    object when used in these ways.
  id: totrans-1746
  prefs: []
  type: TYPE_NORMAL
  zh: 截至10.3版本，MariaDB数据库支持序列。SQLAlchemy的MySQL方言现在实现了对该数据库的[`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence")对象的支持，这意味着当方言的服务器版本检查确认数据库是MariaDB 10.3或更高版本时，将为[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")或[`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData")集合中存在的[`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence")发出“CREATE SEQUENCE” DDL，就像对于后端如PostgreSQL、Oracle等一样。此外，当以这些方式使用时，[`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence")将作为列默认值和主键生成对象。
- en: 'Since this change will impact the assumptions both for DDL as well as the behavior
    of INSERT statements for an application that is currently deployed against MariaDB
    10.3 which also happens to make explicit use the [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence") construct within its table definitions, it is important
    to note that [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence "sqlalchemy.schema.Sequence")
    supports a flag [`Sequence.optional`](../core/defaults.html#sqlalchemy.schema.Sequence.params.optional
    "sqlalchemy.schema.Sequence") which is used to limit the scenarios in which the
    [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence "sqlalchemy.schema.Sequence")
    to take effect. When “optional” is used on a [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence") that is present in the integer primary key column
    of a table:'
  id: totrans-1747
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这一变化将影响DDL的假设以及针对MariaDB 10.3的当前部署应用程序的INSERT语句的行为，该应用程序也恰好在其表定义中明确使用[`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence")构造，因此重要的是要注意[`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence")支持一个标志[`Sequence.optional`](../core/defaults.html#sqlalchemy.schema.Sequence.params.optional
    "sqlalchemy.schema.Sequence")，用于限制[`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence")生效的情况。当在表的整数主键列上使用“optional”时：
- en: '[PRE400]'
  id: totrans-1748
  prefs: []
  type: TYPE_PRE
  zh: '[PRE400]'
- en: The above [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence "sqlalchemy.schema.Sequence")
    is only used for DDL and INSERT statements if the target database does not support
    any other means of generating integer primary key values for the column. That
    is, the Oracle database above would use the sequence, however the PostgreSQL and
    MariaDB 10.3 databases would not. This may be important for an existing application
    that is upgrading to SQLAlchemy 1.4 which may not have emitted DDL for this [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence") against its backing database, as an INSERT statement
    will fail if it seeks to use a sequence that was not created.
  id: totrans-1749
  prefs: []
  type: TYPE_NORMAL
  zh: 上述[`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence "sqlalchemy.schema.Sequence")仅在目标数据库不支持其他生成整数主键值的方式时用于DDL和INSERT语句。也就是说，上述Oracle数据库将使用该序列，但PostgreSQL和MariaDB
    10.3数据库不会。这对于正在升级到SQLAlchemy 1.4的现有应用程序可能很重要，因为如果插入语句试图使用未创建的序列，则会失败。
- en: See also
  id: totrans-1750
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[Defining Sequences](../core/defaults.html#defaults-sequences)'
  id: totrans-1751
  prefs: []
  type: TYPE_NORMAL
  zh: '[定义序列](../core/defaults.html#defaults-sequences)'
- en: '[#4976](https://www.sqlalchemy.org/trac/ticket/4976)'
  id: totrans-1752
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4976](https://www.sqlalchemy.org/trac/ticket/4976)'
- en: '### Added Sequence support distinct from IDENTITY to SQL Server'
  id: totrans-1753
  prefs: []
  type: TYPE_NORMAL
  zh: '### 添加了对SQL Server的与IDENTITY不同的Sequence支持'
- en: The [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence "sqlalchemy.schema.Sequence")
    construct is now fully functional with Microsoft SQL Server. When applied to a
    [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column"),
    the DDL for the table will no longer include IDENTITY keywords and instead will
    rely upon “CREATE SEQUENCE” to ensure a sequence is present which will then be
    used for INSERT statements on the table.
  id: totrans-1754
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence "sqlalchemy.schema.Sequence")构造现在已经完全与Microsoft
    SQL Server兼容。当应用于[`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")时，表的DDL将不再包含IDENTITY关键字，而是依赖于“CREATE
    SEQUENCE”来确保存在一个序列，然后将用于表的INSERT语句。'
- en: The [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence "sqlalchemy.schema.Sequence")
    prior to version 1.3 was used to control parameters for the IDENTITY column in
    SQL Server; this usage emitted deprecation warnings throughout 1.3 and is now
    removed in 1.4\. For control of parameters for an IDENTITY column, the `mssql_identity_start`
    and `mssql_identity_increment` parameters should be used; see the MSSQL dialect
    documentation linked below.
  id: totrans-1755
  prefs: []
  type: TYPE_NORMAL
  zh: 在版本1.3之前，[`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence "sqlalchemy.schema.Sequence")用于控制SQL
    Server中的IDENTITY列的参数；这种用法在1.3中发出了弃用警告，并在1.4中已被移除。对于控制IDENTITY列的参数，应使用`mssql_identity_start`和`mssql_identity_increment`参数；请参阅下面链接的MSSQL方言文档。
- en: See also
  id: totrans-1756
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[Auto Increment Behavior / IDENTITY Columns](../dialects/mssql.html#mssql-identity)'
  id: totrans-1757
  prefs: []
  type: TYPE_NORMAL
  zh: '[自增行为 / IDENTITY 列](../dialects/mssql.html#mssql-identity)'
- en: '[#4235](https://www.sqlalchemy.org/trac/ticket/4235)'
  id: totrans-1758
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4235](https://www.sqlalchemy.org/trac/ticket/4235)'
- en: '[#4633](https://www.sqlalchemy.org/trac/ticket/4633)'
  id: totrans-1759
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4633](https://www.sqlalchemy.org/trac/ticket/4633)'
