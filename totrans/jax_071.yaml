- en: Design of Type Promotion Semantics for JAX
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JAX类型提升的设计
- en: 原文：[`jax.readthedocs.io/en/latest/jep/9407-type-promotion.html`](https://jax.readthedocs.io/en/latest/jep/9407-type-promotion.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[`jax.readthedocs.io/en/latest/jep/9407-type-promotion.html`](https://jax.readthedocs.io/en/latest/jep/9407-type-promotion.html)
- en: '![Open in Colab](https://colab.research.google.com/github/google/jax/blob/main/docs/jep/9407-type-promotion.ipynb)
    ![Open in Kaggle](https://kaggle.com/kernels/welcome?src=https://github.com/google/jax/blob/main/docs/jep/9407-type-promotion.ipynb)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![在Colab中打开](https://colab.research.google.com/github/google/jax/blob/main/docs/jep/9407-type-promotion.ipynb)
    ![在Kaggle中打开](https://kaggle.com/kernels/welcome?src=https://github.com/google/jax/blob/main/docs/jep/9407-type-promotion.ipynb)'
- en: '*Jake VanderPlas, December 2021*'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*Jake VanderPlas, December 2021*'
- en: One of the challenges faced in the design of any numerical computing library
    is the choice of how to handle operations between values of different types. This
    document outlines the thought process behind the promotion semantics used by JAX,
    summarized in [JAX Type Promotion Semantics](https://jax.readthedocs.io/en/latest/type_promotion.html).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 任何数值计算库设计中面临的挑战之一是如何处理不同类型值之间的操作选择。本文概述了JAX使用的提升语义背后的思维过程，总结在[JAX类型提升语义](https://jax.readthedocs.io/en/latest/type_promotion.html)中。
- en: Goals of JAX Type Promotion
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JAX类型提升的目标
- en: 'JAX’s numerical computing API is modeled after that of NumPy, with a few enhancements
    including the ability to target accelerators like GPU and TPU. This makes adoption
    of NumPy’s type promotion system disadvantageous for JAX users: NumPy’s type promotion
    rules heavily favor 64-bit outputs, which is problematic for computation on accelerators.
    Devices such as GPUs and TPUs often pay a significant performance penalty to use
    64-bit floating point types, and in some cases do not support native 64-bit floating
    point types at all.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: JAX的数值计算API是模仿NumPy的，但增加了一些功能，包括能够针对GPU和TPU等加速器进行优化。这使得采用NumPy的类型提升系统对JAX用户不利：NumPy的类型提升规则严重偏向于64位输出，这对于加速器上的计算是有问题的。像GPU和TPU这样的设备通常需要付出显著的性能代价来使用64位浮点类型，并且在某些情况下根本不支持本地64位浮点类型。
- en: 'A simple example of this problematic type promotion semantics can be seen in
    binary operations between 32-bit integers and floats:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这种问题类型提升语义的简单例子可以在32位整数和浮点数之间的二进制操作中看到：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: NumPy’s tendency to produce 64-bit values is a [long-standing issue](https://github.com/numpy/numpy/issues/6860)
    with using NumPy’s API for accelerator computations, for which there isn’t yet
    a good solution. For this reason, JAX has sought to re-think NumPy-style type
    promotion with accelerators in mind.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy倾向于生成64位值是使用NumPy API进行加速计算的一个[长期问题](https://github.com/numpy/numpy/issues/6860)，目前还没有一个很好的解决方案。因此，JAX已经开始重新思考以加速器为目标的NumPy风格类型提升。
- en: 'Stepping Back: Tables and Lattices'
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回顾：表格和格子
- en: 'Before we dive into the details, let’s take a moment to step back and think
    about *how* to think about the problem of type promotion. Consider arithmetic
    operations between built-in numerical types in Python, namely those of type `int`,
    `float`, and `complex`. With a few lines of code we can generate the type promotion
    table used by Python for addition between values of these types:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入细节之前，让我们花点时间退后一步，思考*如何*思考类型提升问题。考虑Python内置数值类型（即`int`、`float`和`complex`）之间的算术操作，我们可以用几行代码生成Python用于这些类型值加法的类型提升表：
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '|  | int | float | complex |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '|  | int | float | complex |'
- en: '| --- | --- | --- | --- |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| int | int | float | complex |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| int | int | float | complex |'
- en: '| float | float | float | complex |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| float | float | float | complex |'
- en: '| complex | complex | complex | complex |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| complex | complex | complex | complex |'
- en: 'This table enumerates Python’s numerical type promotion behavior, but it turns
    out there is a complementary representation that is much more compact: a [Lattice](https://en.wikipedia.org/wiki/Lattice_(order))
    representation, where the [supremum](https://en.wikipedia.org/wiki/Infimum_and_supremum)
    between any two nodes is the type that they promote to. The lattice representation
    of Python’s promotion table is much simpler:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这张表详细列出了Python的数值类型提升行为，但事实证明有一种更为简洁的补充表示：[格](https://en.wikipedia.org/wiki/Lattice_(order))表示法，其中任意两个节点之间的[上确界](https://en.wikipedia.org/wiki/Infimum_and_supremum)是它们提升到的类型。Python提升表的格表示法要简单得多：
- en: <details class="hide above-input"><summary aria-label="Toggle hidden content">Show
    code cell source Hide code cell source</summary>
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: <details class="hide above-input"><summary aria-label="Toggle hidden content">显示代码单元格源代码
    隐藏代码单元格源代码</summary>
- en: '[PRE3]</details> ![../_images/818a3cf499d15c3be1d4c116db142da0418c174873f21e1ffcde679c6058f918.png](img/1adb771731c921aaf44122c0c8a2c96f.png)'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE3]</details> ![../_images/818a3cf499d15c3be1d4c116db142da0418c174873f21e1ffcde679c6058f918.png](img/1adb771731c921aaf44122c0c8a2c96f.png)'
- en: This lattice is a compact encoding of the information in the promotion table
    above. You can find the result of a type promotion for two inputs by tracing the
    graph to the first common child of the two nodes (including the nodes themselves);
    mathematically, this common child is known as the *supremum*, or *least upper
    bound*, or *join* of the pair on the lattice; here we will refer to this operation
    as the **join**.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这个格是促进表中信息的紧凑编码。您可以通过跟踪到两个节点的第一个共同子节点（包括节点本身）找到两个输入的类型提升的结果；在数学上，这个共同子节点被称为对格上的*上确界*，或*最小上界*，或*结合*的操作；这里我们将这个操作称为**结合**。
- en: 'Conceptually, an arrow means that *implicit type promotion is allowed* between
    the source and the destination: for example, implicit promotion from integer to
    float is allowed, but implicit promotion from float to integer is not.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 概念上，箭头表示允许在源和目标之间进行*隐式类型提升*：例如，允许从整数到浮点数的隐式提升，但不允许从浮点数到整数的隐式提升。
- en: 'Keep in mind that in general not every directed acyclic graph (DAG) will satisfy
    the properties of a lattice. A lattice requires the existence of a unique least
    upper bound for every pair of nodes; so, for example the following two DAGs are
    not lattices:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，通常并非每个有向无环图（DAG）都满足格的性质。格要求每对节点之间存在唯一的最小上界；例如，以下两个DAG不是格：
- en: <details class="hide above-input"><summary aria-label="Toggle hidden content">Show
    code cell source Hide code cell source</summary>
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: <details class="hide above-input"><summary aria-label="Toggle hidden content">显示代码单元格源码
    隐藏代码单元格源码</summary>
- en: '[PRE4]</details> ![../_images/a0acbd07f9486d95c10a36c11301d528fb7e65d671d622226151c431b3e36c62.png](img/5a266a4810ed90d79776de9034ad3c61.png)'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE4]</details> ![../_images/a0acbd07f9486d95c10a36c11301d528fb7e65d671d622226151c431b3e36c62.png](img/5a266a4810ed90d79776de9034ad3c61.png)'
- en: 'The left DAG is not a lattice because there exists no upper bound for nodes
    `B` and `C`; the right DAG fails on two counts: first, there exists no upper bound
    for nodes `C` and `D`, and for nodes `A` and `B` the least upper bound cannot
    be *uniquely* determined: both `C` and `D` are candidates, but they are unorderable.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 左边的DAG不是格，因为节点`B`和`C`没有上界；右边的DAG有两个问题：首先，节点`C`和`D`没有上界，其次，节点`A`和`B`的最小上界无法*唯一*确定：`C`和`D`都是候选项，但它们是不可排序的。
- en: Properties of a Type Promotion Lattice
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类型提升格的属性
- en: 'Specifying type promotions in terms of a lattice ensures a number of useful
    properties. Denoting the join on the lattice with the \(\vee\) operator, we have:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在格中指定类型提升确保了许多有用的属性。用\(\vee\)运算符表示格中的结合，我们有：
- en: '**Existence:** A lattice by definition requires that a unique lattice join
    exists for every pair of elements: \(\forall (a, b): \exists !(a \vee b)\)'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**存在性：** 格的定义要求每对元素都存在唯一的格结合：\(\forall (a, b): \exists !(a \vee b)\)'
- en: '**Commutativity:** The lattice join is commutative: \(\forall (a, b): a\vee
    b = b \vee a\).'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**交换律：** 格的结合运算是交换的：\(\forall (a, b): a\vee b = b \vee a\).'
- en: '**Associativity:** The lattice join is associative: \(\forall (a, b, c): a
    \vee (b \vee c) = (a \vee b) \vee c\).'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**结合律：** 格的结合运算是结合的：\(\forall (a, b, c): a \vee (b \vee c) = (a \vee b) \vee
    c\).'
- en: 'On the other hand, these properties imply restrictions on the type promotion
    systems they can represent; in particular **not every type promotion table can
    be represented by a lattice**. A ready example of this is NumPy’s full type promotion
    table; this can be shown quickly by counterexample: here are three scalar types
    whose promotion behavior in NumPy is non-associative:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，这些属性意味着它们对能够表示的类型提升系统有所限制；特别是**并非每个类型提升表都可以用格表示**。NumPy的完整类型提升表就是一个快速反例：这里有三种标量类型，它们在NumPy中的提升行为是非结合的。
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Such a result may come as a surprise to users: we generally expect mathematical
    expressions to map to mathematical concepts, so, for example, `a + b + c` should
    be equivalent to `c + b + a`; `x * (y + z)` should be equivalent to `x * y + x
    * z`. If type promotion is non-associative or non-commutative, these properties
    no longer apply.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的结果可能会让用户感到惊讶：我们通常期望数学表达式映射到数学概念，所以，例如，`a + b + c`应等同于`c + b + a`；`x * (y
    + z)`应等同于`x * y + x * z`。如果类型提升不是结合的或不是交换的，这些属性将不再适用。
- en: 'Further, a lattice-based type promotion system is simpler to conceptualize
    and understand when compared to a table-based system. For example, JAX recognizes
    18 distinct types: a promotion lattice consisting of 18 nodes and sparse, well-motivated
    connections between them is far easier to hold in one’s mind than a table of 324
    entries.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，基于格子的类型提升系统与基于表的系统相比，在概念上更简单和更易理解。例如，JAX识别18种不同的类型：一个包含18个节点和之间稀疏、有充分动机的连接的提升格子，比324个条目的表在脑中更容易维持。
- en: For this reason, we opt to use a lattice-based type promotion system for JAX.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们选择为JAX使用基于格子的类型提升系统。
- en: Type Promotion within Categories
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类别内的类型提升
- en: 'Numerical computing libraries generally provide more than just `int`, `float`,
    and `complex`; within each of these categories there are a variety of possible
    precisions, denoted by the number of bits used in the numerical representation.
    The categories we will consider here are:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 数值计算库通常提供不仅仅是`int`、`float`和`complex`，在每个类别中，都有各种可能的精度，由数值表示中使用的位数表示。我们在这里考虑的类别是：
- en: '*unsigned integers* which include `uint8`, `uint16`, `uint32` & `uint64` (we’ll
    use `u8`, `u16`, `u32`, `u64` for short)'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*无符号整数*，包括`uint8`、`uint16`、`uint32`和`uint64`（我们简称为`u8`、`u16`、`u32`、`u64`）'
- en: '*signed integers* which include `int8`, `int16`, `int32` & `int64` (we’ll use
    `i8`, `i16`, `i32`, `i64` for short)'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*有符号整数*，包括`int8`、`int16`、`int32`和`int64`（我们简称为`i8`、`i16`、`i32`、`i64`）'
- en: '*floating point*, which include `float16`, `float32` & `float64` (we’ll use
    `f16`, `f32`, `f64` for short)'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*浮点数*，包括`float16`、`float32`和`float64`（我们简称为`f16`、`f32`、`f64`）'
- en: '*complex floating point*, which include `complex64` & `complex128` (we’ll use
    `c64`, `c128` for short)'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*复数浮点数*，包括`complex64`和`complex128`（我们简称为`c64`、`c128`）'
- en: 'Numpy’s type promotion semantics **within** each of these four categories is
    relatively straightforward: the ordered hierarchy of types translates directly
    to four separate lattices representing in-category type promotion rules:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Numpy在每个这四个类别内的类型提升语义相对来说是相对简单的：类型的有序层次结构直接转换为四个分离的格子，表示类内类型提升规则：
- en: <details class="hide above-input"><summary aria-label="Toggle hidden content">Show
    code cell source Hide code cell source</summary>
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: <details class="hide above-input"><summary aria-label="Toggle hidden content">显示代码单元源代码
    隐藏代码单元源代码</summary>
- en: '[PRE7]</details> ![../_images/2d8495bcb006c34b42eeb4f3e0c6530fdef0bd7364c56184993925f0cf157abc.png](img/3704ee4a86ce603a27b8fdb41d064d81.png)'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE7]</details> ![../_images/2d8495bcb006c34b42eeb4f3e0c6530fdef0bd7364c56184993925f0cf157abc.png](img/3704ee4a86ce603a27b8fdb41d064d81.png)'
- en: 'In terms of promotion of values to 64-bit that JAX seeks to avoid, these same-kind
    promotion semantics within each type category are unproblematic: the only way
    to produce a 64-bit output is to have a 64-bit input.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 关于JAX避免的值提升为64位，这些同类别的提升语义在每种类型类别内部是没有问题的：产生64位输出的唯一方式是有一个64位输入。
- en: Enter Python Scalars
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 输入Python标量
- en: Let’s now think about where Python scalars fit into the mix.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们考虑Python标量如何融入其中。
- en: 'In NumPy, promotion behavior differs depending on whether the inputs are arrays
    or scalars. For example, when operating on two scalars, normal promotion rules
    apply:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在NumPy中，提升行为取决于输入是数组还是标量。例如，在操作两个标量时，适用正常的提升规则：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here the Python value `1` is treated as an `int64`, and straightforward within-category
    rules lead to an `int64` result.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，Python值`1`被视为`int64`，并且简单的类内规则导致`int64`结果。
- en: 'In operations between Python scalars and NumPy arrays, however, scalars defer
    to the dtype of the array. For example:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在Python标量和NumPy数组之间的操作中，标量会延续到数组的dtype。例如：
- en: '[PRE10]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here the bit width of the `int64` scalar is ignored, deferring to the bit width
    of the array.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 忽略`int64`标量的位宽度，而是延续数组的位宽度。
- en: 'There is another detail here: when NumPy type promotion involves a scalar,
    the output dtype is value-dependent: if the Python scalar is too large for the
    given dtype, it is promoted to a compatible type:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一个细节：当NumPy类型提升涉及标量时，输出的dtype取决于值：如果Python标量过大，超出了给定dtype的范围，则被提升为兼容的类型：
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: For the purposes of JAX, **value-dependent promotion is a non-starter** because
    of the nature of JIT compilation and other transformations, which act on abstract
    representations of data without reference to their value.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 出于JAX的目的，**依赖值的提升是不可行的**，因为JIT编译和其他转换的性质使其作用于数据的抽象表示，而不参考其值。
- en: 'Ignoring value-dependent effects, the signed integer branch of NumPy’s type
    promotion can be represented in the following lattice, where we’ll use `*` to
    mark scalar dtypes:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 忽略依赖值的影响，NumPy 类型提升的有符号整数分支可以在以下格点中表示，我们将使用 `*` 标记标量数据类型：
- en: <details class="hide above-input"><summary aria-label="Toggle hidden content">Show
    code cell source Hide code cell source</summary>
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: <details class="hide above-input"><summary aria-label="Toggle hidden content">显示代码单元格来源
    隐藏代码单元格来源</summary>
- en: '[PRE14]</details> ![../_images/7e8c3295e403209560d8e142c5c830d79456a4e6d207dd1a7e4d15b55c56006b.png](img/e129510e5b34d2fc6197a149b22de27c.png)'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE14]</details> ![../_images/7e8c3295e403209560d8e142c5c830d79456a4e6d207dd1a7e4d15b55c56006b.png](img/e129510e5b34d2fc6197a149b22de27c.png)'
- en: A similar pattern holds within the `uint`, `float`, and `complex` lattices.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `uint`、`float` 和 `complex` 格点内，类似的模式也成立。
- en: 'For the sake of simplicity, let’s collapse each category of scalar types into
    a single node, denoted by `u*`, `i*`, `f*`, and `c*` respectively. Our set of
    in-category lattices can now be represented like this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，让我们将每个标量类型的类别折叠为单个节点，分别表示为 `u*`、`i*`、`f*` 和 `c*`。我们的类别内格点集现在可以这样表示：
- en: <details class="hide above-input"><summary aria-label="Toggle hidden content">Show
    code cell source Hide code cell source</summary>
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: <details class="hide above-input"><summary aria-label="Toggle hidden content">显示代码单元格来源
    隐藏代码单元格来源</summary>
- en: '[PRE15]</details> ![../_images/0fbe0c20cd350821e64f3742aa7864ec729565572b136950042095881672fdb9.png](img/f1e06280fcda633736c3159251434cfc.png)'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE15]</details> ![../_images/0fbe0c20cd350821e64f3742aa7864ec729565572b136950042095881672fdb9.png](img/f1e06280fcda633736c3159251434cfc.png)'
- en: 'In some senses, putting scalars at the left is a strange choice: the scalar
    types may contain values of any width, but when interacting with an array of a
    given type, the promotion result defers to the array type. The benefit of this
    is that when you perform an operation like `x + 2` for an array `x`, the type
    of `x` will carry to the result no matter its width:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 从某种意义上说，将标量放在左边是一个奇怪的选择：标量类型可能包含任何宽度的值，但与给定类型的数组交互时，提升的结果将延续到数组类型。这样做的好处在于，当您对数组
    `x` 执行像 `x + 2` 这样的操作时，`x` 的类型将传递到结果中，无论其宽度如何：
- en: '[PRE16]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This behavior gives motivation to our `*` notation for scalar values: the `*`
    is reminiscent of a wildcard that can take on any desired value.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为为标量值的 `*` 符号赋予了动机：`*` 符号类似于一个通配符，可以取任意所需的值。
- en: 'The benefit of these semantics is that you can readily express sequences of
    operations with clean Python code, without having to explicitly cast scalars to
    the appropriate type. Imagine if rather than writing this:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这种语义的好处在于，您可以用清晰的 Python 代码轻松表达操作序列，而无需显式地将标量强制转换为适当的类型。想象一下，如果不是写成这样：
- en: '[PRE17]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'you had to write this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 您不得不写成这样：
- en: '[PRE18]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Although it is explicit, numerical code would become tedious to read or write.
    With the scalar promotion semantics described above, given an array `x` of type
    `int32`, the types in the second statement are implicit within the first.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它很明确，数值代码会变得阅读或编写起来非常繁琐。使用上述标量提升语义，给定类型为 `int32` 的数组 `x`，第二个语句中的类型在第一个语句中是隐含的。
- en: Combining Lattices
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 合并格点
- en: 'Recall that we began our discussion by introducing the lattice representing
    type promotion within Python: `int -> float -> complex`. Let’s rewrite this as
    `i* -> f* -> c*`, and let’s further allow `i*` to subsume `u*` (after all, there
    is no unsigned integer scalar type in Python).'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 请回想，我们开始讨论 Python 内部类型提升的格点图：`int -> float -> complex`。让我们将其重写为 `i* -> f* ->
    c*`，并允许 `i*` 吸收 `u*`（毕竟，在 Python 中没有无符号整数标量类型）。
- en: 'Putting these all together, we get the following partial lattice representing
    type promotion between Python scalars and numpy arrays:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有内容整合在一起，我们得到以下部分格点图，表示 Python 标量和 numpy 数组之间的类型提升：
- en: <details class="hide above-input"><summary aria-label="Toggle hidden content">Show
    code cell source Hide code cell source</summary>
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: <details class="hide above-input"><summary aria-label="Toggle hidden content">显示代码单元格来源
    隐藏代码单元格来源</summary>
- en: '[PRE19]</details> ![../_images/796586be87180b0de3171d39763f2d33a80a641b72d82c00f0c0e352f754f201.png](img/dd4a0cdc7416bcb8469bfa5424566191.png)'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE19]</details> ![../_images/796586be87180b0de3171d39763f2d33a80a641b72d82c00f0c0e352f754f201.png](img/dd4a0cdc7416bcb8469bfa5424566191.png)'
- en: 'Notice that this is not (yet) a true lattice: there are many pairs of nodes
    for which a join does not exist. However, we can think of this as a *partial*
    lattice, in which some pairs of nodes do not have a defined promotion behavior,
    and the defined portion of this partial lattice does correctly describe NumPy’s
    array promotion behavior (leaving aside value-dependent semantics mentioned above).'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这还不是一个真正的格：存在许多节点对，它们之间没有联接。然而，我们可以将其视为一个*部分*格，在这种格中，某些节点对没有定义的推广行为，而此部分格的定义部分确实正确描述了
    NumPy 的数组推广行为（不考虑上述值依赖语义）。
- en: 'This sets up a nice framework by which we can think about filling-out these
    undefined promotion rules, by adding connections on this graph. But which connections
    to add? Broadly speaking, we want any additional connections to satisfy a few
    properties:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们提供了一个很好的框架，可以用来思考如何填补这些未定义的推广规则，方法是在这个图上添加连接。但是应该添加哪些连接呢？总体来说，我们希望任何额外的连接都满足几个属性：
- en: 'Promotion should satisfy the commutative and associative properties: in other
    words, the graph should remain a (partial) lattice.'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 推广应满足交换和结合性质：换句话说，图应保持（部分）格的形式。
- en: 'Promotion should never allow for dropping entire components of data: for example,
    we should never promote `complex` to `float`, as it would discard any imaginary
    parts.'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 推广不应允许丢弃数据的整个组成部分：例如，我们不应将`complex`推广为`float`，因为这会丢弃任何虚部。
- en: Promotion should never lead to an unhandled overflow. For example, the maximum
    possible `uint32` is twice as large as the maximum possible `int32`, so we should
    not implicitly promote `uint32` to `int32`.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 推广不应导致未处理的溢出。例如，最大可能的`uint32`是最大可能的`int32`的两倍，因此我们不应隐式地将`uint32`提升为`int32`。
- en: 'Wherever possible, promotion should avoid loss of precision. For example, an
    `int64` value may have 64 bits of mantissa, so promoting `int64` to `float64`
    represents a possible loss of precision. However, the maximum representable float64
    is larger than the maximum representable int64, so in this case criterion #3 is
    still satisfied.'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '在可能的情况下，推广应避免精度损失。例如，一个`int64`值可能有64位的尾数，因此将`int64`提升为`float64`可能会导致精度损失。然而，最大可表示的float64大于最大可表示的int64，因此在这种情况下仍满足标准
    #3。'
- en: Wherever possible, binary promotion should avoid resulting in types that are
    wider than the inputs. This is to ensure that JAX’s implicit promotions remain
    friendly to accelerator-based workflows, in which users often want to restrict
    types to 32-bit (or in some cases 16-bit) values.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在可能的情况下，二进制推广应避免导致比输入更宽的类型。这是为了确保 JAX 的隐式推广对加速器工作流友好，其中用户通常希望将类型限制为32位（或在某些情况下是16位）值。
- en: Each new connection on the lattice introduces some level of convenience to the
    user (a new set of types that can interact without explicit casting), but the
    convenience may become too costly if any of the above criteria are violated. Developing
    a full promotion lattice involves striking a balance between this convenience
    and this cost.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 格上的每一个新连接都为用户引入了一定程度的便利性（一组新的可以在没有显式转换的情况下相互作用的类型），但是如果以上任何标准被违反，这种便利性可能会变得代价高昂。发展一个完整的推广格涉及在便利性和成本之间达到平衡。
- en: 'Mixed Promotion: Float and Complex'
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 混合推广：浮点数和复数
- en: Let’s begin with what is perhaps the easiest case, that of promotion between
    float and complex values.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从可能是最简单的情况开始，即在浮点数和复数值之间的推广。
- en: 'Complex numbers are made up of pairs of floating point numbers, and so we have
    a natural path of promotion between them: cast float to complex while maintaining
    the width of the real part. In terms of our partial lattice representation, it
    would look like this:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 复数由一对浮点数组成，因此在它们之间存在一种自然的推广路径：将浮点数转换为复数，同时保持实部的宽度。在我们的部分格表示中，它看起来像这样：
- en: <details class="hide above-input"><summary aria-label="Toggle hidden content">Show
    code cell source Hide code cell source</summary>
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: <details class="hide above-input"><summary aria-label="Toggle hidden content">显示代码单元格源码
    隐藏代码单元格源码</summary>
- en: '[PRE20]</details> ![../_images/bf87909b2344aed80590d1c6d91585a02b25898ac217526cb49948d91205318f.png](img/5d610fde93b793459425e06d94094f8f.png)'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE20]</details> ![../_images/bf87909b2344aed80590d1c6d91585a02b25898ac217526cb49948d91205318f.png](img/5d610fde93b793459425e06d94094f8f.png)'
- en: This turns out to represent exactly the semantics used by Numpy in mixed float/complex
    type promotion.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这恰好代表了 Numpy 在混合浮点/复数类型推广中使用的语义。
- en: 'Mixed Promotion: Signed & Unsigned Integers'
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 混合推广：有符号和无符号整数
- en: 'For the next case, let’s consider something a bit more difficult: promotion
    between signed and unsigned integers. For example, when promoting `uint8` to a
    signed integer, how many bits do we need?'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的情况，让我们考虑一些更困难的情况：有符号和无符号整数之间的提升。例如，当将`uint8`提升为有符号整数时，我们需要多少位？
- en: 'At first glance, you might think it natural to promote `uint8` to `int8`; but
    the largest `uint8` numbers are not representable in `int8`. For this reason,
    it makes more sense to promote unsigned integers to integers with twice the number
    of bits; this promotion behavior can be represented by adding the following connections
    to the promotion lattice:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，您可能会认为将`uint8`提升为`int8`是很自然的；但最大的`uint8`数字在`int8`中是不能表示的。因此，将无符号整数提升为比特数加倍的整数更有意义；这种提升行为可以通过将以下连接添加到提升格中来表示：
- en: <details class="hide above-input"><summary aria-label="Toggle hidden content">Show
    code cell source Hide code cell source</summary>
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: <details class="hide above-input"><summary aria-label="Toggle hidden content">显示代码单元格源代码
    隐藏代码单元格源代码</summary>
- en: '[PRE21]</details> ![../_images/3be7e17889458ac823bb5dacf31525c0d96578c6854962f45dcc60ec987a30bd.png](img/1a7d3b78b45858ca77d9810e77d053b9.png)'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE21]</details> ![../_images/3be7e17889458ac823bb5dacf31525c0d96578c6854962f45dcc60ec987a30bd.png](img/1a7d3b78b45858ca77d9810e77d053b9.png)'
- en: Again, the connections added here are precisely the promotion semantics implemented
    by Numpy for mixed-integer promotion.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，这里添加的连接正是NumPy用于混合整数提升的提升语义实现。
- en: How to handle `uint64`?
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何处理`uint64`？
- en: 'The approach to mixed signed/unsigned integer promotion leaves out one type:
    `uint64`. Following the pattern above, the output of a mixed-integer operation
    involving `uint64` should result in `int128`, but this is not a standard available
    dtype.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 混合有符号/无符号整数提升的方法中缺少一种类型：`uint64`。按照上述模式，涉及`uint64`的混合整数操作的输出应该是`int128`，但这不是标准可用的数据类型。
- en: 'Numpy’s choice here is to promote to `float64`:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy在这里的选择是提升为`float64`：
- en: '[PRE22]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'However, this may be a surprising convention: it’s the only case in which promotion
    of integer types does not result in an integer. For now, we will leave `uint64`
    promotion undefined, and return to it later.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这可能是一个令人惊讶的约定：这是唯一一种整数类型提升不会产生整数的情况。目前，我们将保持`uint64`提升的未定义状态，并稍后再回到这个问题。
- en: 'Mixed Promotion: Integer and Floating'
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 整数和浮点混合提升
- en: 'When promoting integers to floating point, we might start with the same thought
    process as mixed promotion between signed and unsigned integers. A 16-bit signed
    or unsigned integer cannot be represented at full precision by a 16-bit float,
    which has only 10 bits of mantissa. Therefore, it might make sense to promote
    integers to floats represented by twice the number of bits:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当将整数提升为浮点数时，我们可能会从与有符号和无符号整数之间的混合提升相同的思路开始。16位有符号或无符号整数无法被只有10位尾数的16位浮点数以全精度表示。因此，将整数提升为比特数加倍的浮点数可能是有道理的：
- en: <details class="hide above-input"><summary aria-label="Toggle hidden content">Show
    code cell source Hide code cell source</summary>
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: <details class="hide above-input"><summary aria-label="Toggle hidden content">显示代码单元格源代码
    隐藏代码单元格源代码</summary>
- en: '[PRE24]</details> ![../_images/8b3247e8189fbfad46a7e5583b636866fc45576e07c9bfd904457926306299d1.png](img/830c2790dfd6b146ef474a036558f81e.png)'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE24]</details> ![../_images/8b3247e8189fbfad46a7e5583b636866fc45576e07c9bfd904457926306299d1.png](img/830c2790dfd6b146ef474a036558f81e.png)'
- en: 'This is effectively what Numpy type promotion does, but in doing so it breaks
    the lattice property of the graph: for example, the pair *{i8, u8}* no longer
    has a unique least upper bound: the possibilities are *i16* and *f16*, which are
    unorderable on the graph. This turns out to be the source of NumPy’s non-associative
    type promotion highlighted above.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上是NumPy类型提升所做的事情，但在这样做时它破坏了图的格性质：例如，对于*{i8, u8}*对，不再有唯一的最小上界：可能性有*i16*和*f16*，这在图上是不可排序的。这事实上是NumPy非可结合类型提升的根源。
- en: Can we come up with a modification of NumPy’s promotion rules, such that it
    will satisfy the lattice property, while also giving sensible results for mixed
    type promotion? There are a few approaches we could take here.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能否提出NumPy提升规则的修改，以便满足格性质，并为混合类型提升提供明智的结果？我们在这里可以采取几种方法。
- en: 'Option 0: Leave integer/floating mixed precision undefined'
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选项 0：将整数/浮点混合精度未定义
- en: To make behavior utterly predictable (at some cost to user convenience), a defensible
    choice would be to leave as undefined any mixed integer/float promotion beyond
    Python scalars, stopping with the partial lattice from the previous section. The
    downside would be the requirement for users to explicitly type-cast when operating
    between integer and floating-point quantities.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使行为完全可预测（虽然会损失用户方便性），一个可以辩护的选择是在Python标量之外将任何混合整数/浮点数提升保留为未定义状态，停留在前一节的部分格子结构。缺点是用户在操作整数和浮点数数量之间时需要显式类型转换。
- en: 'Option 1: Avoiding All Precision Loss'
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选项1：避免所有精度损失
- en: 'If our focus is on avoiding precision loss at all costs, we can restore the
    lattice property by promoting unsigned integers to float via their existing signed
    integer paths:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的重点是以任何代价避免精度损失，我们可以通过其现有的有符号整数路径将无符号整数提升为浮点数来恢复格子属性：
- en: <details class="hide above-input"><summary aria-label="Toggle hidden content">Show
    code cell source Hide code cell source</summary>
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: <details class="hide above-input"><summary aria-label="Toggle hidden content">显示代码单元格源代码
    隐藏代码单元格源代码</summary>
- en: '[PRE25]</details> ![../_images/1eda89d008a8c6dadf926229bf9f2245722006c5bc1c42961c555a2595c95117.png](img/c062177f41f5c0a66d94848e91df12e8.png)'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE25]</details> ![../_images/1eda89d008a8c6dadf926229bf9f2245722006c5bc1c42961c555a2595c95117.png](img/c062177f41f5c0a66d94848e91df12e8.png)'
- en: A disadvantage of this approach is that it still leaves `int64` and `uint64`
    promotion undefined, because there is no standard floating point type with enough
    bits of mantissa to represent their full range of values. We could relax the precision
    constraint and complete the lattice by drawing connections from `i64->f64` and
    `u64->f64`, but those links would run counter to the motivation for this promotion
    scheme.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的一个缺点是它仍然使得`int64`和`uint64`的提升未定义，因为没有标准的浮点类型具有足够的尾数位来表示它们的完整值范围。我们可以放宽精度约束并通过从`i64->f64`和`u64->f64`的连接来完成格子，但这些连接会违反这种提升方案的动机。
- en: A second disadvantage is that this lattice makes it difficult to find a sensible
    place to insert `bfloat16` (see below) while maintaining the lattice property.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个缺点是这种格子结构使得很难找到一个合理的位置来插入`bfloat16`（见下文），同时保持格子属性。
- en: A third disadvantage of this approach, more important for JAX’s accelerator
    backends, is that some operations result in types that are much wider than necessary;
    for example mixed operations between `uint16` and `float16` would promote all
    the way to `float64`, which is not ideal.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 对于JAX加速器后端来说，这种方法的第三个缺点更为重要，即某些操作会导致比必要宽得多的类型；例如，`uint16` 和 `float16` 之间的混合操作会提升到`float64`，这并不理想。
- en: 'Option 2: Avoid most wider-than-necessary promotions'
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选项2：避免大部分比必要更宽的提升
- en: 'To address the unnecessary promotions to wider types, we could accept the possibility
    of some precision loss in integer/float promotion, promoting signed integers to
    floats of the same width:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决更广泛类型的不必要提升，我们可以接受整数/浮点数提升可能会导致一些精度损失的可能性，将有符号整数提升为相同宽度的浮点数：
- en: <details class="hide above-input"><summary aria-label="Toggle hidden content">Show
    code cell source Hide code cell source</summary>
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: <details class="hide above-input"><summary aria-label="Toggle hidden content">显示代码单元格源代码
    隐藏代码单元格源代码</summary>
- en: '[PRE26]</details> ![../_images/f41cee38a476bf636be901e7f64a5dc3687002f9d12532ab706b9077d602b175.png](img/053dcc1c67022eff2e093d2a9e6989ce.png)'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE26]</details> ![../_images/f41cee38a476bf636be901e7f64a5dc3687002f9d12532ab706b9077d602b175.png](img/053dcc1c67022eff2e093d2a9e6989ce.png)'
- en: 'While this does allow for precision-losing promotions between integers and
    floats, these promotions will not mis-represent the *magnitude* of the result:
    though the floating point mantissa is not wide enough to represent all values,
    the exponent is wide enough to approximate them.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这确实允许在整数和浮点数之间进行精度损失的提升，但这些提升不会误代表结果的*幅度*：虽然浮点数的尾数不足以表示所有值，但指数足以近似它们。
- en: This approach also allows a natural promotion path from `int64` to `float64`,
    though `uint64` remains unpromotable in this scheme. That said, a connection from
    `u64` to `f64` could be justified more readily here than before.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法还允许从`int64`自然提升到`float64`，尽管在此方案中`uint64`仍然无法提升。也就是说，在这里更容易地可以通过其现有的有符号整数路径连接从`u64`到`f64`。
- en: This promotion scheme still results in some wider than necessary promotion paths;
    for example operations between `float32` and `uint32` result in `float64`. Additionally,
    this lattice makes it difficult to find a sensible place to insert `bfloat16`
    (see below) while maintaining the lattice property.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这种提升方案仍然会导致一些比必要更宽的提升路径；例如 `float32` 和 `uint32` 之间的操作将导致 `float64`。此外，这个格子使得很难找到一个合理的地方插入
    `bfloat16`（见下文），同时保持格子属性。
- en: 'Option 3: Avoid all wider-than-necessary promotions'
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选项 3：避免所有比必要更宽的提升
- en: 'We can avoid *all* non-ideal 64-bit promotions if we’re willing to fundamentally
    change our thinking around integer and float promotions. Just as scalars always
    defer to the widths of array types, we can make integers always defer to the width
    of float types:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们愿意从根本上改变我们对整数和浮点提升的思维方式，我们可以避免 *所有* 非理想的 64 位提升：就像标量总是遵循数组类型的宽度一样，我们可以使整数总是遵循浮点类型的宽度：
- en: <details class="hide above-input"><summary aria-label="Toggle hidden content">Show
    code cell source Hide code cell source</summary>
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: <details class="hide above-input"><summary aria-label="Toggle hidden content">显示代码单元源代码
    隐藏代码单元源代码</summary>
- en: '[PRE27]</details> ![../_images/d3f5e5be4354238a60698cb4f228d4e1f75a665577343c36b2c1ade1207783a0.png](img/bf94c44dddef5be193e1a2aa9a9bf685.png)'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE27]</details> ![../_images/d3f5e5be4354238a60698cb4f228d4e1f75a665577343c36b2c1ade1207783a0.png](img/bf94c44dddef5be193e1a2aa9a9bf685.png)'
- en: 'This involves a small sleight of hand: previously we had used `f*` to refer
    to a scalar type. In this lattice, `f*` might be applied to the array output of
    a mixed computation. Instead of thinking of `f*` as a scalar, we could think of
    it as a special kind of `float` value with distinct promotion rules: in JAX we
    refer to this as a *weak float*; see below.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这涉及一种小的手法：之前我们使用 `f*` 表示标量类型。在这个格中，`f*` 可能被应用于混合计算的数组输出。我们不再将 `f*` 视为标量，而是可以将其视为一种具有不同提升规则的特殊类型
    `float` 值：在 JAX 中我们称之为 *弱浮点数*；详见下文。
- en: 'The advantage of this approach is that, outside unsigned ints, it avoids *all*
    wider-than-necessary promotions: you can never get an f64 output without a 64-bit
    input, and you can never get an f32 output without a 32-bit input: this results
    in convenient semantics for working on accelerators while avoiding inadvertent
    64-bit values.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的优势在于，除了无符号整数外，它避免了 *所有* 比必要更宽的提升：你永远不会得到没有 64 位输入的 f64 输出，也永远不会得到没有 32
    位输入的 f32 输出：这对于在加速器上工作时提供了方便的语义，同时避免了无意间生成 64 位值。
- en: This feature of giving primacy to floating point types resembles the type promotion
    behavior of PyTorch. This lattice also happens to generate a promotion table that
    very closely resembles JAX’s original *ad hoc* type promotion scheme, which was
    not based on a lattice but had the property of giving primacy to floating point
    types.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这种优先考虑浮点类型的特性类似于 PyTorch 的类型提升行为。这个格子也碰巧生成了一个非常接近 JAX 原始 *临时* 类型提升方案的提升表，该方案不是基于格子的，但具有优先考虑浮点类型的特性。
- en: 'This lattice additionally offers a natural location to insert `bfloat16`, without
    the need to impose an ordering between `bf16` and `f16`:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这个格子还提供了一个自然的位置来插入 `bfloat16`，而无需在 `bf16` 和 `f16` 之间施加排序：
- en: <details class="hide above-input"><summary aria-label="Toggle hidden content">Show
    code cell source Hide code cell source</summary>
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: <details class="hide above-input"><summary aria-label="Toggle hidden content">显示代码单元源代码
    隐藏代码单元源代码</summary>
- en: '[PRE28]</details> ![../_images/aa73688b580b02776fce218d6efe58792ae3b0976160a4b0c130b797780578af.png](img/774df410c611ee33896b0d5d7ef34e35.png)'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE28]</details> ![../_images/aa73688b580b02776fce218d6efe58792ae3b0976160a4b0c130b797780578af.png](img/774df410c611ee33896b0d5d7ef34e35.png)'
- en: 'This is important because `f16` and `bf16` are not comparable because they
    utilize their bits differently: `bf16` represents a larger range at lower precision,
    while `f16` represents a smaller range at higher precision.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这一点很重要，因为 `f16` 和 `bf16` 不可比较，它们利用其位的方式不同：`bf16` 以较低精度表示更大的范围，而 `f16` 则以较高精度表示更小的范围。
- en: 'However, these advantages comes with a few tradeoffs:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这些优势也伴随着一些权衡：
- en: 'mixed float/integer promotion is very prone to precision loss: for example,
    `int64` (with a maximum value of \(9.2 \times 10^{18}\)) can be promoted to `float16`
    (with a maximum value of \(6.5 \times 10⁴\)), meaning most representable values
    will become `inf`.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 混合浮点数/整数提升非常容易产生精度损失：例如，`int64`（最大值为 \(9.2 \times 10^{18}\)）可以提升为 `float16`（最大值为
    \(6.5 \times 10⁴\)），这意味着大多数可表示的值将变为 `inf`。
- en: as mentioned above, `f*` can no longer be thought of as a “scalar type”, but
    as a different flavor of float64\. In JAX’s parlance, this is referred to as a
    [*weak type*](https://jax.readthedocs.io/en/latest/type_promotion.html#weakly-typed-values-in-jax),
    in that it is represented as 64-bit, but only weakly holds to this bit width in
    promotion with other values.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如上所述，`f*`不再被视为“标量类型”，而是被视为float64的不同风味。在JAX术语中，这被称为[*弱类型*](https://jax.readthedocs.io/en/latest/type_promotion.html#weakly-typed-values-in-jax)，即它表示为64位，但在与其他值推广时只弱化到此位宽度。
- en: Note that also, this approach still leaves the `uint64` promotion question unanswered,
    although it is perhaps reasonable to close the lattice by connecting `u64` to
    `f*`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 还请注意，这种方法仍然未解决`uint64`提升问题，尽管将`u64`连接到`f*`可能是合理的。
- en: Type Promotion in JAX
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JAX中的类型提升
- en: 'In designing the type promotion semantics of JAX, we kept in mind many of these
    ideas, and leaned heavily on a few things:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计JAX的类型提升语义时，我们牢记了许多这些想法，并且在几个方面倾向于：
- en: 'We chose to constrain JAX’s type promotion semantics to graphs that satisfy
    the lattice property: this is to ensure associativity and commutativity, but also
    to allow the semantics to be compactly described in a DAG, rather than requiring
    a large table.'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们选择将JAX的类型提升语义约束为满足格属性的图形：这是为了确保结合律和交换律，但也为了允许语义被简洁地描述为DAG，而不需要一个大表格。
- en: We leaned toward semantics that avoid inadvertent promotion to wider types,
    particularly when it comes to float values, in order to benefit computation on
    accelerators.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在计算加速器上获益时，我们倾向于避免意外推广到更宽的类型，特别是在涉及浮点值时。
- en: We were fine accepting potential loss of precision (but not loss of magnitude)
    in mixed type promotion if it were required to maintain (1) and (2)
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果需要为了保持（1）和（2），我们可以接受在混合类型提升中潜在的精度损失（但不是幅度损失）。
- en: 'With this in mind, JAX has adopted Option 3\. Or rather, a slightly modified
    version of Option 3 that draws the connection between `u64` and `f*`, in order
    to create a true lattice. Rearranging the nodes for clarity, JAX’s type promotion
    lattice then looks like this:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，JAX采用了选项3。或者更确切地说，选项3的一个稍微修改的版本，以建立`u64`与`f*`之间的连接，以创建真正的格。为了清晰起见重新排列节点，JAX的类型提升格看起来像这样：
- en: <details class="hide above-input"><summary aria-label="Toggle hidden content">Show
    code cell source Hide code cell source</summary>
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: <details class="hide above-input"><summary aria-label="Toggle hidden content">显示代码单元格源码
    隐藏代码单元格源码</summary>
- en: '[PRE29]</details> ![../_images/d261add493a579484d9772634ce146f1240af3966d0845839c354417a3de2e53.png](img/e2f9680e0c4d097070698630af5edf61.png)'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE29]</details> ![../_images/d261add493a579484d9772634ce146f1240af3966d0845839c354417a3de2e53.png](img/e2f9680e0c4d097070698630af5edf61.png)'
- en: The behavior resulting from this choice is summarized in [JAX Type Promotion
    Semantics](https://jax.readthedocs.io/en/latest/type_promotion.html). Notably,
    aside from the inclusion of larger unsigned types (`u16`, `u32`, `u64`) and some
    details about the behavior of scalar/weak types (`i*`, `f*`, `c*`), this type
    promotion scheme turns out to be very close to that chosen by PyTorch.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 从这种选择产生的行为总结在[JAX类型提升语义](https://jax.readthedocs.io/en/latest/type_promotion.html)中。特别地，除了包括更大的无符号类型（`u16`、`u32`、`u64`）和一些关于标量/弱类型（`i*`、`f*`、`c*`）行为的细节外，这种类型提升方案与PyTorch选择的非常接近。
- en: For those interested, the appendix below prints the full promotion tables used
    by NumPy, Tensorflow, PyTorch, and JAX.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 对于有兴趣的人，附录下面打印了NumPy、Tensorflow、PyTorch和JAX使用的完整推广表。
- en: 'Appendix: Example Type Promotion Tables'
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 附录：示例类型提升表
- en: The following are some examples of implicit type promotion tables implemented
    by various Python array computing libraries.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是各种Python数组计算库实现的隐式类型提升表的一些示例。
- en: NumPy Type Promotion
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: NumPy类型提升
- en: Note that NumPy does not include the `bfloat16` dtype, and that the table below
    ignores value-dependent effects.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，NumPy不包括`bfloat16` dtype，并且下表忽略了依赖值影响。
- en: <details class="hide above-input"><summary aria-label="Toggle hidden content">Show
    code cell source Hide code cell source</summary>
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: <details class="hide above-input"><summary aria-label="Toggle hidden content">显示代码单元格源码
    隐藏代码单元格源码</summary>
- en: '[PRE30]</details>'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE30]</details>'
- en: '|  | b | u8 | u16 | u32 | u64 | i8 | i16 | i32 | i64 | bf16 | f16 | f32 | f64
    | c64 | c128 | i* | f* | c* |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '|  | b | u8 | u16 | u32 | u64 | i8 | i16 | i32 | i64 | bf16 | f16 | f32 | f64
    | c64 | c128 | i* | f* | c* |'
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | ---
    | --- | --- | --- | --- | --- | --- |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | ---
    | --- | --- | --- | --- | --- | --- |'
- en: '| b | b | u8 | u16 | u32 | u64 | i8 | i16 | i32 | i64 | - | f16 | f32 | f64
    | c64 | c128 | i64 | f64 | c128 |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| b | b | u8 | u16 | u32 | u64 | i8 | i16 | i32 | i64 | - | f16 | f32 | f64
    | c64 | c128 | i64 | f64 | c128 |'
- en: '| u8 | u8 | u8 | u16 | u32 | u64 | i16 | i16 | i32 | i64 | - | f16 | f32 |
    f64 | c64 | c128 | u8 | f64 | c128 |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| u8 | u8 | u8 | u16 | u32 | u64 | i16 | i16 | i32 | i64 | - | f16 | f32 |
    f64 | c64 | c128 | u8 | f64 | c128 |'
- en: '| u16 | u16 | u16 | u16 | u32 | u64 | i32 | i32 | i32 | i64 | - | f32 | f32
    | f64 | c64 | c128 | u16 | f64 | c128 |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| u16 | u16 | u16 | u16 | u32 | u64 | i32 | i32 | i32 | i64 | - | f32 | f32
    | f64 | c64 | c128 | u16 | f64 | c128 |'
- en: '| u32 | u32 | u32 | u32 | u32 | u64 | i64 | i64 | i64 | i64 | - | f64 | f64
    | f64 | c128 | c128 | u32 | f64 | c128 |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| u32 | u32 | u32 | u32 | u32 | u64 | i64 | i64 | i64 | i64 | - | f64 | f64
    | f64 | c128 | c128 | u32 | f64 | c128 |'
- en: '| u64 | u64 | u64 | u64 | u64 | u64 | f64 | f64 | f64 | f64 | - | f64 | f64
    | f64 | c128 | c128 | u64 | f64 | c128 |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| u64 | u64 | u64 | u64 | u64 | u64 | f64 | f64 | f64 | f64 | - | f64 | f64
    | f64 | c128 | c128 | u64 | f64 | c128 |'
- en: '| i8 | i8 | i16 | i32 | i64 | f64 | i8 | i16 | i32 | i64 | - | f16 | f32 |
    f64 | c64 | c128 | i8 | f64 | c128 |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| i8 | i8 | i16 | i32 | i64 | f64 | i8 | i16 | i32 | i64 | - | f16 | f32 |
    f64 | c64 | c128 | i8 | f64 | c128 |'
- en: '| i16 | i16 | i16 | i32 | i64 | f64 | i16 | i16 | i32 | i64 | - | f32 | f32
    | f64 | c64 | c128 | i16 | f64 | c128 |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| i16 | i16 | i16 | i32 | i64 | f64 | i16 | i16 | i32 | i64 | - | f32 | f32
    | f64 | c64 | c128 | i16 | f64 | c128 |'
- en: '| i32 | i32 | i32 | i32 | i64 | f64 | i32 | i32 | i32 | i64 | - | f64 | f64
    | f64 | c128 | c128 | i32 | f64 | c128 |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| i32 | i32 | i32 | i32 | i64 | f64 | i32 | i32 | i32 | i64 | - | f64 | f64
    | f64 | c128 | c128 | i32 | f64 | c128 |'
- en: '| i64 | i64 | i64 | i64 | i64 | f64 | i64 | i64 | i64 | i64 | - | f64 | f64
    | f64 | c128 | c128 | i64 | f64 | c128 |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| i64 | i64 | i64 | i64 | i64 | f64 | i64 | i64 | i64 | i64 | - | f64 | f64
    | f64 | c128 | c128 | i64 | f64 | c128 |'
- en: '| bf16 | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | -
    | - |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| bf16 | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | -
    | - |'
- en: '| f16 | f16 | f16 | f32 | f64 | f64 | f16 | f32 | f64 | f64 | - | f16 | f32
    | f64 | c64 | c128 | f16 | f16 | c64 |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| f16 | f16 | f16 | f32 | f64 | f64 | f16 | f32 | f64 | f64 | - | f16 | f32
    | f64 | c64 | c128 | f16 | f16 | c64 |'
- en: '| f32 | f32 | f32 | f32 | f64 | f64 | f32 | f32 | f64 | f64 | - | f32 | f32
    | f64 | c64 | c128 | f32 | f32 | c64 |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| f32 | f32 | f32 | f32 | f64 | f64 | f32 | f32 | f64 | f64 | - | f32 | f32
    | f64 | c64 | c128 | f32 | f32 | c64 |'
- en: '| f64 | f64 | f64 | f64 | f64 | f64 | f64 | f64 | f64 | f64 | - | f64 | f64
    | f64 | c128 | c128 | f64 | f64 | c128 |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| f64 | f64 | f64 | f64 | f64 | f64 | f64 | f64 | f64 | f64 | - | f64 | f64
    | f64 | c128 | c128 | f64 | f64 | c128 |'
- en: '| c64 | c64 | c64 | c64 | c128 | c128 | c64 | c64 | c128 | c128 | - | c64 |
    c64 | c128 | c64 | c128 | c64 | c64 | c64 |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| c64 | c64 | c64 | c64 | c128 | c128 | c64 | c64 | c128 | c128 | - | c64 |
    c64 | c128 | c64 | c128 | c64 | c64 | c64 |'
- en: '| c128 | c128 | c128 | c128 | c128 | c128 | c128 | c128 | c128 | c128 | - |
    c128 | c128 | c128 | c128 | c128 | c128 | c128 | c128 |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| c128 | c128 | c128 | c128 | c128 | c128 | c128 | c128 | c128 | c128 | - |
    c128 | c128 | c128 | c128 | c128 | c128 | c128 | c128 |'
- en: '| i* | i64 | u8 | u16 | u32 | u64 | i8 | i16 | i32 | i64 | - | f16 | f32 |
    f64 | c64 | c128 | i64 | f64 | c128 |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| i* | i64 | u8 | u16 | u32 | u64 | i8 | i16 | i32 | i64 | - | f16 | f32 |
    f64 | c64 | c128 | i64 | f64 | c128 |'
- en: '| f* | f64 | f64 | f64 | f64 | f64 | f64 | f64 | f64 | f64 | - | f16 | f32
    | f64 | c64 | c128 | f64 | f64 | c128 |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| f* | f64 | f64 | f64 | f64 | f64 | f64 | f64 | f64 | f64 | - | f16 | f32
    | f64 | c64 | c128 | f64 | f64 | c128 |'
- en: '| c* | c128 | c128 | c128 | c128 | c128 | c128 | c128 | c128 | c128 | - | c64
    | c64 | c128 | c64 | c128 | c128 | c128 | c128 |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| c* | c128 | c128 | c128 | c128 | c128 | c128 | c128 | c128 | c128 | - | c64
    | c64 | c128 | c64 | c128 | c128 | c128 | c128 |'
- en: Tensorflow Type Promotion
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: TensorFlow 类型提升
- en: Tensorflow avoids defining implicit type promotion, except for Python scalars
    in limited cases. The table is asymmetric because in `tf.add(x, y)`, the type
    of `y` must be coercible to the type of `x`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: TensorFlow 避免定义隐式类型提升，除了在有限的情况下，对 Python 标量进行操作。该表格是不对称的，因为在 `tf.add(x, y)`
    中，`y` 的类型必须可以强制转换为 `x` 的类型。
- en: <details class="hide above-input"><summary aria-label="Toggle hidden content">Show
    code cell source Hide code cell source</summary>
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: <details class="hide above-input"><summary aria-label="Toggle hidden content">显示代码单元格来源
    隐藏代码单元格来源</summary>
- en: '[PRE31]</details>'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE31]</details>'
- en: '|  | b | u8 | u16 | u32 | u64 | i8 | i16 | i32 | i64 | bf16 | f16 | f32 | f64
    | c64 | c128 | i* | f* | c* |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '|  | b | u8 | u16 | u32 | u64 | i8 | i16 | i32 | i64 | bf16 | f16 | f32 | f64
    | c64 | c128 | i* | f* | c* |'
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | ---
    | --- | --- | --- | --- | --- | --- |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | ---
    | --- | --- | --- | --- | --- | --- |'
- en: '| b | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | -
    |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| b | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | -
    |'
- en: '| u8 | - | u8 | - | - | - | - | - | - | - | - | - | - | - | - | - | u8 | -
    | - |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| u8 | - | u8 | - | - | - | - | - | - | - | - | - | - | - | - | - | u8 | -
    | - |'
- en: '| u16 | - | - | u16 | - | - | - | - | - | - | - | - | - | - | - | - | u16 |
    - | - |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| u16 | - | - | u16 | - | - | - | - | - | - | - | - | - | - | - | - | u16 |
    - | - |'
- en: '| u32 | - | - | - | u32 | - | - | - | - | - | - | - | - | - | - | - | u32 |
    - | - |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| u32 | - | - | - | u32 | - | - | - | - | - | - | - | - | - | - | - | u32 |
    - | - |'
- en: '| u64 | - | - | - | - | u64 | - | - | - | - | - | - | - | - | - | - | u64 |
    - | - |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| u64 | - | - | - | - | u64 | - | - | - | - | - | - | - | - | - | - | u64 |
    - | - |'
- en: '| i8 | - | - | - | - | - | i8 | - | - | - | - | - | - | - | - | - | i8 | -
    | - |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| i8 | - | - | - | - | - | i8 | - | - | - | - | - | - | - | - | - | i8 | -
    | - |'
- en: '| i16 | - | - | - | - | - | - | i16 | - | - | - | - | - | - | - | - | i16 |
    - | - |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| i16 | - | - | - | - | - | - | i16 | - | - | - | - | - | - | - | - | i16 |
    - | - |'
- en: '| i32 | - | - | - | - | - | - | - | i32 | - | - | - | - | - | - | - | i32 |
    - | - |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| i32 | - | - | - | - | - | - | - | i32 | - | - | - | - | - | - | - | i32 |
    - | - |'
- en: '| i64 | - | - | - | - | - | - | - | - | i64 | - | - | - | - | - | - | i64 |
    - | - |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| i64 | - | - | - | - | - | - | - | - | i64 | - | - | - | - | - | - | i64 |
    - | - |'
- en: '| bf16 | - | - | - | - | - | - | - | - | - | bf16 | - | - | - | - | - | bf16
    | bf16 | - |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| bf16 | - | - | - | - | - | - | - | - | - | bf16 | - | - | - | - | - | bf16
    | bf16 | - |'
- en: '| f16 | - | - | - | - | - | - | - | - | - | - | f16 | - | - | - | - | f16 |
    f16 | - |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| f16 | - | - | - | - | - | - | - | - | - | - | f16 | - | - | - | - | f16 |
    f16 | - |'
- en: '| f32 | - | - | - | - | - | - | - | - | - | - | - | f32 | - | - | - | f32 |
    f32 | - |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| f32 | - | - | - | - | - | - | - | - | - | - | - | f32 | - | - | - | f32 |
    f32 | - |'
- en: '| f64 | - | - | - | - | - | - | - | - | - | - | - | - | f64 | - | - | f64 |
    f64 | - |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| f64 | - | - | - | - | - | - | - | - | - | - | - | - | f64 | - | - | f64 |
    f64 | - |'
- en: '| c64 | - | - | - | - | - | - | - | - | - | - | - | - | - | c64 | - | c64 |
    c64 | c64 |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| c64 | - | - | - | - | - | - | - | - | - | - | - | - | - | c64 | - | c64 |
    c64 | c64 |'
- en: '| c128 | - | - | - | - | - | - | - | - | - | - | - | - | - | - | c128 | c128
    | c128 | c128 |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| c128 | - | - | - | - | - | - | - | - | - | - | - | - | - | c128 | c128 |
    c128 | c128 |'
- en: '| i* | - | - | - | - | - | - | - | i32 | - | - | - | - | - | - | - | i32 |
    - | - |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| i* | - | - | - | - | - | - | - | i32 | - | - | - | - | - | - | - | i32 |
    - | - |'
- en: '| f* | - | - | - | - | - | - | - | - | - | - | - | f32 | - | - | - | f32 |
    f32 | - |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| f* | - | - | - | - | - | - | - | - | - | - | - | f32 | - | - | - | f32 |
    f32 | - |'
- en: '| c* | - | - | - | - | - | - | - | - | - | - | - | - | - | - | c128 | c128
    | c128 | c128 |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| c* | - | - | - | - | - | - | - | - | - | - | - | - | - | - | c128 | c128
    | c128 | c128 |'
- en: PyTorch Type Promotion
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PyTorch 类型提升
- en: Notice that torch does not include unsigned integer types larger than `uint8`.
    Aside from this and some details about promotion with scalar/weak types, the table
    is close to that used by `jax.numpy`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，torch 不包括大于 `uint8` 的无符号整数类型。除此之外，有关标量/弱类型提升的一些细节，表格接近于 `jax.numpy` 的用法。
- en: <details class="hide above-input"><summary aria-label="Toggle hidden content">Show
    code cell source Hide code cell source</summary>
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: <details class="hide above-input"><summary aria-label="Toggle hidden content">显示代码单元源代码
    隐藏代码单元源代码</summary>
- en: '[PRE32]</details>'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE32]</details>'
- en: '|  | b | u8 | u16 | u32 | u64 | i8 | i16 | i32 | i64 | bf16 | f16 | f32 | f64
    | c64 | c128 | i* | f* | c* |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '|  | b | u8 | u16 | u32 | u64 | i8 | i16 | i32 | i64 | bf16 | f16 | f32 | f64
    | c64 | c128 | i* | f* | c* |'
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | ---
    | --- | --- | --- | --- | --- | --- |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | ---
    | --- | --- | --- | --- | --- | --- |'
- en: '| b | b | u8 | - | - | - | i8 | i16 | i32 | i64 | bf16 | f16 | f32 | f64 |
    c64 | c128 | i64 | f32 | c64 |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| b | b | u8 | - | - | - | i8 | i16 | i32 | i64 | bf16 | f16 | f32 | f64 |
    c64 | c128 | i64 | f32 | c64 |'
- en: '| u8 | u8 | u8 | - | - | - | i16 | i16 | i32 | i64 | bf16 | f16 | f32 | f64
    | c64 | c128 | u8 | f32 | c64 |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| u8 | u8 | u8 | - | - | - | i16 | i16 | i32 | i64 | bf16 | f16 | f32 | f64
    | c64 | c128 | u8 | f32 | c64 |'
- en: '| u16 | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - |
    - |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| u16 | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - |
    - |'
- en: '| u32 | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - |
    - |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| u32 | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - |
    - |'
- en: '| u64 | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - |
    - |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| u64 | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - |
    - |'
- en: '| i8 | i8 | i16 | - | - | - | i8 | i16 | i32 | i64 | bf16 | f16 | f32 | f64
    | c64 | c128 | i8 | f32 | c64 |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| i8 | i8 | i16 | - | - | - | i8 | i16 | i32 | i64 | bf16 | f16 | f32 | f64
    | c64 | c128 | i8 | f32 | c64 |'
- en: '| i16 | i16 | i16 | - | - | - | i16 | i16 | i32 | i64 | bf16 | f16 | f32 |
    f64 | c64 | c128 | i16 | f32 | c64 |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| i16 | i16 | i16 | - | - | - | i16 | i16 | i32 | i64 | bf16 | f16 | f32 |
    f64 | c64 | c128 | i16 | f32 | c64 |'
- en: '| i32 | i32 | i32 | - | - | - | i32 | i32 | i32 | i64 | bf16 | f16 | f32 |
    f64 | c64 | c128 | i32 | f32 | c64 |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| i32 | i32 | i32 | - | - | - | i32 | i32 | i32 | i64 | bf16 | f16 | f32 |
    f64 | c64 | c128 | i32 | f32 | c64 |'
- en: '| i64 | i64 | i64 | - | - | - | i64 | i64 | i64 | i64 | bf16 | f16 | f32 |
    f64 | c64 | c128 | i64 | f32 | c64 |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| i64 | i64 | i64 | - | - | - | i64 | i64 | i64 | i64 | bf16 | f16 | f32 |
    f64 | c64 | c128 | i64 | f32 | c64 |'
- en: '| bf16 | bf16 | bf16 | - | - | - | bf16 | bf16 | bf16 | bf16 | bf16 | f32 |
    f32 | f64 | c64 | c128 | bf16 | bf16 | c64 |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| bf16 | bf16 | bf16 | - | - | - | bf16 | bf16 | bf16 | bf16 | bf16 | f32 |
    f32 | f64 | c64 | c128 | bf16 | bf16 | c64 |'
- en: '| f16 | f16 | f16 | - | - | - | f16 | f16 | f16 | f16 | f32 | f16 | f32 | f64
    | c64 | c128 | f16 | f16 | c64 |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| f16 | f16 | f16 | - | - | - | f16 | f16 | f16 | f16 | f32 | f16 | f32 | f64
    | c64 | c128 | f16 | f16 | c64 |'
- en: '| f32 | f32 | f32 | - | - | - | f32 | f32 | f32 | f32 | f32 | f32 | f32 | f64
    | c64 | c128 | f32 | f32 | c64 |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| f32 | f32 | f32 | - | - | - | f32 | f32 | f32 | f32 | f32 | f32 | f32 | f64
    | c64 | c128 | f32 | f32 | c64 |'
- en: '| f64 | f64 | f64 | - | - | - | f64 | f64 | f64 | f64 | f64 | f64 | f64 | f64
    | c128 | c128 | f64 | f64 | c128 |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| f64 | f64 | f64 | - | - | - | f64 | f64 | f64 | f64 | f64 | f64 | f64 | f64
    | c128 | c128 | f64 | f64 | c128 |'
- en: '| c64 | c64 | c64 | - | - | - | c64 | c64 | c64 | c64 | c64 | c64 | c64 | c128
    | c64 | c128 | c64 | c64 | c64 |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| c64 | c64 | c64 | - | - | - | c64 | c64 | c64 | c64 | c64 | c64 | c64 | c128
    | c64 | c128 | c64 | c64 | c64 |'
- en: '| c128 | c128 | c128 | - | - | - | c128 | c128 | c128 | c128 | c128 | c128
    | c128 | c128 | c128 | c128 | c128 | c128 | c128 |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| c128 | c128 | c128 | - | - | - | c128 | c128 | c128 | c128 | c128 | c128
    | c128 | c128 | c128 | c128 | c128 | c128 | c128 |'
- en: '| i* | i64 | u8 | - | - | - | i8 | i16 | i32 | i64 | bf16 | f16 | f32 | f64
    | c64 | c128 | i64 | f32 | c64 |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| i* | i64 | u8 | - | - | - | i8 | i16 | i32 | i64 | bf16 | f16 | f32 | f64
    | c64 | c128 | i64 | f32 | c64 |'
- en: '| f* | f32 | f32 | - | - | - | f32 | f32 | f32 | f32 | bf16 | f16 | f32 | f64
    | c64 | c128 | f32 | f64 | c64 |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| f* | f32 | f32 | - | - | - | f32 | f32 | f32 | f32 | bf16 | f16 | f32 | f64
    | c64 | c128 | f32 | f64 | c64 |'
- en: '| c* | c64 | c64 | - | - | - | c64 | c64 | c64 | c64 | c64 | c64 | c64 | c128
    | c64 | c128 | c64 | c64 | c128 |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| c* | c64 | c64 | - | - | - | c64 | c64 | c64 | c64 | c64 | c64 | c64 | c128
    | c64 | c128 | c64 | c64 | c128 |'
- en: 'JAX Type Promotion: `jax.numpy`'
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'JAX Type Promotion: `jax.numpy`'
- en: '`jax.numpy` follows type promotion rules laid out at https://jax.readthedocs.io/en/latest/type_promotion.html.
    Here we use `i*`, `f*`, `c*` to indicate both Python scalars and weakly-typed
    arrays.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`jax.numpy` follows type promotion rules laid out at https://jax.readthedocs.io/en/latest/type_promotion.html.
    Here we use `i*`, `f*`, `c*` to indicate both Python scalars and weakly-typed
    arrays.'
- en: <details class="hide above-input"><summary aria-label="Toggle hidden content">Show
    code cell source Hide code cell source</summary>
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: <details class="hide above-input"><summary aria-label="Toggle hidden content">显示代码单元格源码
    隐藏代码单元格源码</summary>
- en: '[PRE33]</details>'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE33]</details>'
- en: '|  | b | u8 | u16 | u32 | u64 | i8 | i16 | i32 | i64 | bf16 | f16 | f32 | f64
    | c64 | c128 | i* | f* | c* |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '|  | b | u8 | u16 | u32 | u64 | i8 | i16 | i32 | i64 | bf16 | f16 | f32 | f64
    | c64 | c128 | i* | f* | c* |'
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | ---
    | --- | --- | --- | --- | --- | --- |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | ---
    | --- | --- | --- | --- | --- | --- |'
- en: '| b | b | u8 | u16 | u32 | u64 | i8 | i16 | i32 | i64 | bf16 | f16 | f32 |
    f64 | c64 | c128 | i* | f* | c* |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| b | b | u8 | u16 | u32 | u64 | i8 | i16 | i32 | i64 | bf16 | f16 | f32 |
    f64 | c64 | c128 | i* | f* | c* |'
- en: '| u8 | u8 | u8 | u16 | u32 | u64 | i16 | i16 | i32 | i64 | bf16 | f16 | f32
    | f64 | c64 | c128 | u8 | f* | c* |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| u8 | u8 | u8 | u16 | u32 | u64 | i16 | i16 | i32 | i64 | bf16 | f16 | f32
    | f64 | c64 | c128 | u8 | f* | c* |'
- en: '| u16 | u16 | u16 | u16 | u32 | u64 | i32 | i32 | i32 | i64 | bf16 | f16 |
    f32 | f64 | c64 | c128 | u16 | f* | c* |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| u16 | u16 | u16 | u16 | u32 | u64 | i32 | i32 | i32 | i64 | bf16 | f16 |
    f32 | f64 | c64 | c128 | u16 | f* | c* |'
- en: '| u32 | u32 | u32 | u32 | u32 | u64 | i64 | i64 | i64 | i64 | bf16 | f16 |
    f32 | f64 | c64 | c128 | u32 | f* | c* |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| u32 | u32 | u32 | u32 | u32 | u64 | i64 | i64 | i64 | i64 | bf16 | f16 |
    f32 | f64 | c64 | c128 | u32 | f* | c* |'
- en: '| u64 | u64 | u64 | u64 | u64 | u64 | f* | f* | f* | f* | bf16 | f16 | f32
    | f64 | c64 | c128 | u64 | f* | c* |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| u64 | u64 | u64 | u64 | u64 | u64 | f* | f* | f* | f* | bf16 | f16 | f32
    | f64 | c64 | c128 | u64 | f* | c* |'
- en: '| i8 | i8 | i16 | i32 | i64 | f* | i8 | i16 | i32 | i64 | bf16 | f16 | f32
    | f64 | c64 | c128 | i8 | f* | c* |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| i8 | i8 | i16 | i32 | i64 | f* | i8 | i16 | i32 | i64 | bf16 | f16 | f32
    | f64 | c64 | c128 | i8 | f* | c* |'
- en: '| i16 | i16 | i16 | i32 | i64 | f* | i16 | i16 | i32 | i64 | bf16 | f16 | f32
    | f64 | c64 | c128 | i16 | f* | c* |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| i16 | i16 | i16 | i32 | i64 | f* | i16 | i16 | i32 | i64 | bf16 | f16 | f32
    | f64 | c64 | c128 | i16 | f* | c* |'
- en: '| i32 | i32 | i32 | i32 | i64 | f* | i32 | i32 | i32 | i64 | bf16 | f16 | f32
    | f64 | c64 | c128 | i32 | f* | c* |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| i32 | i32 | i32 | i32 | i64 | f* | i32 | i32 | i32 | i64 | bf16 | f16 | f32
    | f64 | c64 | c128 | i32 | f* | c* |'
- en: '| i64 | i64 | i64 | i64 | i64 | f* | i64 | i64 | i64 | i64 | bf16 | f16 | f32
    | f64 | c64 | c128 | i64 | f* | c* |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| i64 | i64 | i64 | i64 | i64 | f* | i64 | i64 | i64 | i64 | bf16 | f16 | f32
    | f64 | c64 | c128 | i64 | f* | c* |'
- en: '| bf16 | bf16 | bf16 | bf16 | bf16 | bf16 | bf16 | bf16 | bf16 | bf16 | bf16
    | f32 | f32 | f64 | c64 | c128 | bf16 | bf16 | c64 |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| bf16 | bf16 | bf16 | bf16 | bf16 | bf16 | bf16 | bf16 | bf16 | bf16 | bf16
    | f32 | f32 | f64 | c64 | c128 | bf16 | bf16 | c64 |'
- en: '| f16 | f16 | f16 | f16 | f16 | f16 | f16 | f16 | f16 | f16 | f32 | f16 | f32
    | f64 | c64 | c128 | f16 | f16 | c64 |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| f16 | f16 | f16 | f16 | f16 | f16 | f16 | f16 | f16 | f16 | f32 | f16 | f32
    | f64 | c64 | c128 | f16 | f16 | c64 |'
- en: '| f32 | f32 | f32 | f32 | f32 | f32 | f32 | f32 | f32 | f32 | f32 | f32 | f32
    | f64 | c64 | c128 | f32 | f32 | c64 |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| f32 | f32 | f32 | f32 | f32 | f32 | f32 | f32 | f32 | f32 | f32 | f32 | f32
    | f64 | c64 | c128 | f32 | f32 | c64 |'
- en: '| f64 | f64 | f64 | f64 | f64 | f64 | f64 | f64 | f64 | f64 | f64 | f64 | f64
    | f64 | c128 | c128 | f64 | f64 | c128 |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| f64 | f64 | f64 | f64 | f64 | f64 | f64 | f64 | f64 | f64 | f64 | f64 | f64
    | f64 | c128 | c128 | f64 | f64 | c128 |'
- en: '| c64 | c64 | c64 | c64 | c64 | c64 | c64 | c64 | c64 | c64 | c64 | c64 | c64
    | c128 | c64 | c128 | c64 | c64 | c64 |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| c64 | c64 | c64 | c64 | c64 | c64 | c64 | c64 | c64 | c64 | c64 | c64 | c64
    | c128 | c64 | c128 | c64 | c64 | c64 |'
- en: '| c128 | c128 | c128 | c128 | c128 | c128 | c128 | c128 | c128 | c128 | c128
    | c128 | c128 | c128 | c128 | c128 | c128 | c128 | c128 |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| c128 | c128 | c128 | c128 | c128 | c128 | c128 | c128 | c128 | c128 | c128
    | c128 | c128 | c128 | c128 | c128 | c128 | c128 | c128 |'
- en: '| i* | i* | u8 | u16 | u32 | u64 | i8 | i16 | i32 | i64 | bf16 | f16 | f32
    | f64 | c64 | c128 | i* | f* | c* |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| i* | i* | u8 | u16 | u32 | u64 | i8 | i16 | i32 | i64 | bf16 | f16 | f32
    | f64 | c64 | c128 | i* | f* | c* |'
- en: '| f* | f* | f* | f* | f* | f* | f* | f* | f* | f* | bf16 | f16 | f32 | f64
    | c64 | c128 | f* | f* | c* |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| f* | f* | f* | f* | f* | f* | f* | f* | f* | f* | bf16 | f16 | f32 | f64
    | c64 | c128 | f* | f* | c* |'
- en: '| c* | c* | c* | c* | c* | c* | c* | c* | c* | c* | c64 | c64 | c64 | c128
    | c64 | c128 | c* | c* | c* |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '| c* | c* | c* | c* | c* | c* | c* | c* | c* | c* | c64 | c64 | c64 | c128
    | c64 | c128 | c* | c* | c* |'
- en: 'JAX Type Promotion: `jax.lax`'
  id: totrans-254
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JAX 类型提升：`jax.lax`
- en: '`jax.lax` is lower-level, and does not do any implicit promotion. Here we use
    `i*`, `f*`, `c*` to indicate both Python scalars and weakly-typed arrays.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`jax.lax` 是较低级的库，不执行任何隐式类型提升。在这里，我们使用 `i*`、`f*`、`c*` 来表示 Python 标量和弱类型数组。'
- en: <details class="hide above-input"><summary aria-label="Toggle hidden content">Show
    code cell source Hide code cell source</summary>
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: <details class="hide above-input"><summary aria-label="Toggle hidden content">显示代码单元格源代码
    隐藏代码单元格源代码</summary>
- en: '[PRE34]</details>'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE34]</details>'
- en: '|  | b | u8 | u16 | u32 | u64 | i8 | i16 | i32 | i64 | bf16 | f16 | f32 | f64
    | c64 | c128 | i* | f* | c* |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '|  | b | u8 | u16 | u32 | u64 | i8 | i16 | i32 | i64 | bf16 | f16 | f32 | f64
    | c64 | c128 | i* | f* | c* |'
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | ---
    | --- | --- | --- | --- | --- | --- |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | ---
    | --- | --- | --- | --- | --- | --- |'
- en: '| b | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | -
    |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '| b | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | -
    |'
- en: '| u8 | - | u8 | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - |
    - |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '| u8 | - | u8 | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - |
    - |'
- en: '| u16 | - | - | u16 | - | - | - | - | - | - | - | - | - | - | - | - | - | -
    | - |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '| u16 | - | - | u16 | - | - | - | - | - | - | - | - | - | - | - | - | - | -
    | - |'
- en: '| u32 | - | - | - | u32 | - | - | - | - | - | - | - | - | - | - | - | - | -
    | - |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '| u32 | - | - | - | u32 | - | - | - | - | - | - | - | - | - | - | - | - | -
    | - |'
- en: '| u64 | - | - | - | - | u64 | - | - | - | - | - | - | - | - | - | - | - | -
    | - |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '| u64 | - | - | - | - | u64 | - | - | - | - | - | - | - | - | - | - | - | -
    | - |'
- en: '| i8 | - | - | - | - | - | i8 | - | - | - | - | - | - | - | - | - | - | - |
    - |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| i8 | - | - | - | - | - | i8 | - | - | - | - | - | - | - | - | - | - | - |
    - |'
- en: '| i16 | - | - | - | - | - | - | i16 | - | - | - | - | - | - | - | - | - | -
    | - |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| i16 | - | - | - | - | - | - | i16 | - | - | - | - | - | - | - | - | - | -
    | - |'
- en: '| i32 | - | - | - | - | - | - | - | i32 | - | - | - | - | - | - | - | - | -
    | - |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| i32 | - | - | - | - | - | - | - | i32 | - | - | - | - | - | - | - | - | -
    | - |'
- en: '| i64 | - | - | - | - | - | - | - | - | i64 | - | - | - | - | - | - | i64 |
    - | - |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| i64 | - | - | - | - | - | - | - | - | i64 | - | - | - | - | - | - | i64 |
    - | - |'
- en: '| bf16 | - | - | - | - | - | - | - | - | - | bf16 | - | - | - | - | - | - |
    - | - |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| bf16 | - | - | - | - | - | - | - | - | - | bf16 | - | - | - | - | - | - |
    - | - |'
- en: '| f16 | - | - | - | - | - | - | - | - | - | - | f16 | - | - | - | - | - | -
    | - |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '| f16 | - | - | - | - | - | - | - | - | - | - | f16 | - | - | - | - | - | -
    | - |'
- en: '| f32 | - | - | - | - | - | - | - | - | - | - | - | f32 | - | - | - | - | -
    | - |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '| f32 | - | - | - | - | - | - | - | - | - | - | - | f32 | - | - | - | - | -
    | - |'
- en: '| f64 | - | - | - | - | - | - | - | - | - | - | - | - | f64 | - | - | - | f64
    | - |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '| f64 | - | - | - | - | - | - | - | - | - | - | - | - | f64 | - | - | - | f64
    | - |'
- en: '| c64 | - | - | - | - | - | - | - | - | - | - | - | - | - | c64 | - | - | -
    | - |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
  zh: '| c64 | - | - | - | - | - | - | - | - | - | - | - | - | - | c64 | - | - | -
    | - |'
- en: '| c128 | - | - | - | - | - | - | - | - | - | - | - | - | - | - | c128 | - |
    - | c128 |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
  zh: '| c128 | - | - | - | - | - | - | - | - | - | - | - | - | - | - | c128 | - |
    - | c128 |'
- en: '| i* | - | - | - | - | - | - | - | - | i64 | - | - | - | - | - | - | i* | -
    | - |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '| i* | - | - | - | - | - | - | - | - | i64 | - | - | - | - | - | - | i* | -
    | - |'
- en: '| f* | - | - | - | - | - | - | - | - | - | - | - | - | f64 | - | - | - | f*
    | - |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '| f* | - | - | - | - | - | - | - | - | - | - | - | - | f64 | - | - | - | f*
    | - |'
- en: '| c* | - | - | - | - | - | - | - | - | - | - | - | - | - | - | c128 | - | -
    | c* |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '| c* | - | - | - | - | - | - | - | - | - | - | - | - | - | - | c128 | - | -
    | c* |'
