- en: Design of Type Promotion Semantics for JAX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[`jax.readthedocs.io/en/latest/jep/9407-type-promotion.html`](https://jax.readthedocs.io/en/latest/jep/9407-type-promotion.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '![Open in Colab](https://colab.research.google.com/github/google/jax/blob/main/docs/jep/9407-type-promotion.ipynb)
    ![Open in Kaggle](https://kaggle.com/kernels/welcome?src=https://github.com/google/jax/blob/main/docs/jep/9407-type-promotion.ipynb)'
  prefs: []
  type: TYPE_IMG
- en: '*Jake VanderPlas, December 2021*'
  prefs: []
  type: TYPE_NORMAL
- en: One of the challenges faced in the design of any numerical computing library
    is the choice of how to handle operations between values of different types. This
    document outlines the thought process behind the promotion semantics used by JAX,
    summarized in [JAX Type Promotion Semantics](https://jax.readthedocs.io/en/latest/type_promotion.html).
  prefs: []
  type: TYPE_NORMAL
- en: Goals of JAX Type Promotion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'JAX’s numerical computing API is modeled after that of NumPy, with a few enhancements
    including the ability to target accelerators like GPU and TPU. This makes adoption
    of NumPy’s type promotion system disadvantageous for JAX users: NumPy’s type promotion
    rules heavily favor 64-bit outputs, which is problematic for computation on accelerators.
    Devices such as GPUs and TPUs often pay a significant performance penalty to use
    64-bit floating point types, and in some cases do not support native 64-bit floating
    point types at all.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple example of this problematic type promotion semantics can be seen in
    binary operations between 32-bit integers and floats:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: NumPy’s tendency to produce 64-bit values is a [long-standing issue](https://github.com/numpy/numpy/issues/6860)
    with using NumPy’s API for accelerator computations, for which there isn’t yet
    a good solution. For this reason, JAX has sought to re-think NumPy-style type
    promotion with accelerators in mind.
  prefs: []
  type: TYPE_NORMAL
- en: 'Stepping Back: Tables and Lattices'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we dive into the details, let’s take a moment to step back and think
    about *how* to think about the problem of type promotion. Consider arithmetic
    operations between built-in numerical types in Python, namely those of type `int`,
    `float`, and `complex`. With a few lines of code we can generate the type promotion
    table used by Python for addition between values of these types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '|  | int | float | complex |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| int | int | float | complex |'
  prefs: []
  type: TYPE_TB
- en: '| float | float | float | complex |'
  prefs: []
  type: TYPE_TB
- en: '| complex | complex | complex | complex |'
  prefs: []
  type: TYPE_TB
- en: 'This table enumerates Python’s numerical type promotion behavior, but it turns
    out there is a complementary representation that is much more compact: a [Lattice](https://en.wikipedia.org/wiki/Lattice_(order))
    representation, where the [supremum](https://en.wikipedia.org/wiki/Infimum_and_supremum)
    between any two nodes is the type that they promote to. The lattice representation
    of Python’s promotion table is much simpler:'
  prefs: []
  type: TYPE_NORMAL
- en: <details class="hide above-input"><summary aria-label="Toggle hidden content">Show
    code cell source Hide code cell source</summary>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]</details> ![../_images/818a3cf499d15c3be1d4c116db142da0418c174873f21e1ffcde679c6058f918.png](img/1adb771731c921aaf44122c0c8a2c96f.png)'
  prefs: []
  type: TYPE_NORMAL
- en: This lattice is a compact encoding of the information in the promotion table
    above. You can find the result of a type promotion for two inputs by tracing the
    graph to the first common child of the two nodes (including the nodes themselves);
    mathematically, this common child is known as the *supremum*, or *least upper
    bound*, or *join* of the pair on the lattice; here we will refer to this operation
    as the **join**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Conceptually, an arrow means that *implicit type promotion is allowed* between
    the source and the destination: for example, implicit promotion from integer to
    float is allowed, but implicit promotion from float to integer is not.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Keep in mind that in general not every directed acyclic graph (DAG) will satisfy
    the properties of a lattice. A lattice requires the existence of a unique least
    upper bound for every pair of nodes; so, for example the following two DAGs are
    not lattices:'
  prefs: []
  type: TYPE_NORMAL
- en: <details class="hide above-input"><summary aria-label="Toggle hidden content">Show
    code cell source Hide code cell source</summary>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]</details> ![../_images/a0acbd07f9486d95c10a36c11301d528fb7e65d671d622226151c431b3e36c62.png](img/5a266a4810ed90d79776de9034ad3c61.png)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The left DAG is not a lattice because there exists no upper bound for nodes
    `B` and `C`; the right DAG fails on two counts: first, there exists no upper bound
    for nodes `C` and `D`, and for nodes `A` and `B` the least upper bound cannot
    be *uniquely* determined: both `C` and `D` are candidates, but they are unorderable.'
  prefs: []
  type: TYPE_NORMAL
- en: Properties of a Type Promotion Lattice
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Specifying type promotions in terms of a lattice ensures a number of useful
    properties. Denoting the join on the lattice with the \(\vee\) operator, we have:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Existence:** A lattice by definition requires that a unique lattice join
    exists for every pair of elements: \(\forall (a, b): \exists !(a \vee b)\)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Commutativity:** The lattice join is commutative: \(\forall (a, b): a\vee
    b = b \vee a\).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Associativity:** The lattice join is associative: \(\forall (a, b, c): a
    \vee (b \vee c) = (a \vee b) \vee c\).'
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, these properties imply restrictions on the type promotion
    systems they can represent; in particular **not every type promotion table can
    be represented by a lattice**. A ready example of this is NumPy’s full type promotion
    table; this can be shown quickly by counterexample: here are three scalar types
    whose promotion behavior in NumPy is non-associative:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Such a result may come as a surprise to users: we generally expect mathematical
    expressions to map to mathematical concepts, so, for example, `a + b + c` should
    be equivalent to `c + b + a`; `x * (y + z)` should be equivalent to `x * y + x
    * z`. If type promotion is non-associative or non-commutative, these properties
    no longer apply.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Further, a lattice-based type promotion system is simpler to conceptualize
    and understand when compared to a table-based system. For example, JAX recognizes
    18 distinct types: a promotion lattice consisting of 18 nodes and sparse, well-motivated
    connections between them is far easier to hold in one’s mind than a table of 324
    entries.'
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, we opt to use a lattice-based type promotion system for JAX.
  prefs: []
  type: TYPE_NORMAL
- en: Type Promotion within Categories
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Numerical computing libraries generally provide more than just `int`, `float`,
    and `complex`; within each of these categories there are a variety of possible
    precisions, denoted by the number of bits used in the numerical representation.
    The categories we will consider here are:'
  prefs: []
  type: TYPE_NORMAL
- en: '*unsigned integers* which include `uint8`, `uint16`, `uint32` & `uint64` (we’ll
    use `u8`, `u16`, `u32`, `u64` for short)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*signed integers* which include `int8`, `int16`, `int32` & `int64` (we’ll use
    `i8`, `i16`, `i32`, `i64` for short)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*floating point*, which include `float16`, `float32` & `float64` (we’ll use
    `f16`, `f32`, `f64` for short)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*complex floating point*, which include `complex64` & `complex128` (we’ll use
    `c64`, `c128` for short)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Numpy’s type promotion semantics **within** each of these four categories is
    relatively straightforward: the ordered hierarchy of types translates directly
    to four separate lattices representing in-category type promotion rules:'
  prefs: []
  type: TYPE_NORMAL
- en: <details class="hide above-input"><summary aria-label="Toggle hidden content">Show
    code cell source Hide code cell source</summary>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]</details> ![../_images/2d8495bcb006c34b42eeb4f3e0c6530fdef0bd7364c56184993925f0cf157abc.png](img/3704ee4a86ce603a27b8fdb41d064d81.png)'
  prefs: []
  type: TYPE_NORMAL
- en: 'In terms of promotion of values to 64-bit that JAX seeks to avoid, these same-kind
    promotion semantics within each type category are unproblematic: the only way
    to produce a 64-bit output is to have a 64-bit input.'
  prefs: []
  type: TYPE_NORMAL
- en: Enter Python Scalars
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s now think about where Python scalars fit into the mix.
  prefs: []
  type: TYPE_NORMAL
- en: 'In NumPy, promotion behavior differs depending on whether the inputs are arrays
    or scalars. For example, when operating on two scalars, normal promotion rules
    apply:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Here the Python value `1` is treated as an `int64`, and straightforward within-category
    rules lead to an `int64` result.
  prefs: []
  type: TYPE_NORMAL
- en: 'In operations between Python scalars and NumPy arrays, however, scalars defer
    to the dtype of the array. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Here the bit width of the `int64` scalar is ignored, deferring to the bit width
    of the array.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is another detail here: when NumPy type promotion involves a scalar,
    the output dtype is value-dependent: if the Python scalar is too large for the
    given dtype, it is promoted to a compatible type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: For the purposes of JAX, **value-dependent promotion is a non-starter** because
    of the nature of JIT compilation and other transformations, which act on abstract
    representations of data without reference to their value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ignoring value-dependent effects, the signed integer branch of NumPy’s type
    promotion can be represented in the following lattice, where we’ll use `*` to
    mark scalar dtypes:'
  prefs: []
  type: TYPE_NORMAL
- en: <details class="hide above-input"><summary aria-label="Toggle hidden content">Show
    code cell source Hide code cell source</summary>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]</details> ![../_images/7e8c3295e403209560d8e142c5c830d79456a4e6d207dd1a7e4d15b55c56006b.png](img/e129510e5b34d2fc6197a149b22de27c.png)'
  prefs: []
  type: TYPE_NORMAL
- en: A similar pattern holds within the `uint`, `float`, and `complex` lattices.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the sake of simplicity, let’s collapse each category of scalar types into
    a single node, denoted by `u*`, `i*`, `f*`, and `c*` respectively. Our set of
    in-category lattices can now be represented like this:'
  prefs: []
  type: TYPE_NORMAL
- en: <details class="hide above-input"><summary aria-label="Toggle hidden content">Show
    code cell source Hide code cell source</summary>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]</details> ![../_images/0fbe0c20cd350821e64f3742aa7864ec729565572b136950042095881672fdb9.png](img/f1e06280fcda633736c3159251434cfc.png)'
  prefs: []
  type: TYPE_NORMAL
- en: 'In some senses, putting scalars at the left is a strange choice: the scalar
    types may contain values of any width, but when interacting with an array of a
    given type, the promotion result defers to the array type. The benefit of this
    is that when you perform an operation like `x + 2` for an array `x`, the type
    of `x` will carry to the result no matter its width:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This behavior gives motivation to our `*` notation for scalar values: the `*`
    is reminiscent of a wildcard that can take on any desired value.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The benefit of these semantics is that you can readily express sequences of
    operations with clean Python code, without having to explicitly cast scalars to
    the appropriate type. Imagine if rather than writing this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'you had to write this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Although it is explicit, numerical code would become tedious to read or write.
    With the scalar promotion semantics described above, given an array `x` of type
    `int32`, the types in the second statement are implicit within the first.
  prefs: []
  type: TYPE_NORMAL
- en: Combining Lattices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Recall that we began our discussion by introducing the lattice representing
    type promotion within Python: `int -> float -> complex`. Let’s rewrite this as
    `i* -> f* -> c*`, and let’s further allow `i*` to subsume `u*` (after all, there
    is no unsigned integer scalar type in Python).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Putting these all together, we get the following partial lattice representing
    type promotion between Python scalars and numpy arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: <details class="hide above-input"><summary aria-label="Toggle hidden content">Show
    code cell source Hide code cell source</summary>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]</details> ![../_images/796586be87180b0de3171d39763f2d33a80a641b72d82c00f0c0e352f754f201.png](img/dd4a0cdc7416bcb8469bfa5424566191.png)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that this is not (yet) a true lattice: there are many pairs of nodes
    for which a join does not exist. However, we can think of this as a *partial*
    lattice, in which some pairs of nodes do not have a defined promotion behavior,
    and the defined portion of this partial lattice does correctly describe NumPy’s
    array promotion behavior (leaving aside value-dependent semantics mentioned above).'
  prefs: []
  type: TYPE_NORMAL
- en: 'This sets up a nice framework by which we can think about filling-out these
    undefined promotion rules, by adding connections on this graph. But which connections
    to add? Broadly speaking, we want any additional connections to satisfy a few
    properties:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Promotion should satisfy the commutative and associative properties: in other
    words, the graph should remain a (partial) lattice.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Promotion should never allow for dropping entire components of data: for example,
    we should never promote `complex` to `float`, as it would discard any imaginary
    parts.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Promotion should never lead to an unhandled overflow. For example, the maximum
    possible `uint32` is twice as large as the maximum possible `int32`, so we should
    not implicitly promote `uint32` to `int32`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Wherever possible, promotion should avoid loss of precision. For example, an
    `int64` value may have 64 bits of mantissa, so promoting `int64` to `float64`
    represents a possible loss of precision. However, the maximum representable float64
    is larger than the maximum representable int64, so in this case criterion #3 is
    still satisfied.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wherever possible, binary promotion should avoid resulting in types that are
    wider than the inputs. This is to ensure that JAX’s implicit promotions remain
    friendly to accelerator-based workflows, in which users often want to restrict
    types to 32-bit (or in some cases 16-bit) values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Each new connection on the lattice introduces some level of convenience to the
    user (a new set of types that can interact without explicit casting), but the
    convenience may become too costly if any of the above criteria are violated. Developing
    a full promotion lattice involves striking a balance between this convenience
    and this cost.
  prefs: []
  type: TYPE_NORMAL
- en: 'Mixed Promotion: Float and Complex'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s begin with what is perhaps the easiest case, that of promotion between
    float and complex values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Complex numbers are made up of pairs of floating point numbers, and so we have
    a natural path of promotion between them: cast float to complex while maintaining
    the width of the real part. In terms of our partial lattice representation, it
    would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: <details class="hide above-input"><summary aria-label="Toggle hidden content">Show
    code cell source Hide code cell source</summary>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]</details> ![../_images/bf87909b2344aed80590d1c6d91585a02b25898ac217526cb49948d91205318f.png](img/5d610fde93b793459425e06d94094f8f.png)'
  prefs: []
  type: TYPE_NORMAL
- en: This turns out to represent exactly the semantics used by Numpy in mixed float/complex
    type promotion.
  prefs: []
  type: TYPE_NORMAL
- en: 'Mixed Promotion: Signed & Unsigned Integers'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For the next case, let’s consider something a bit more difficult: promotion
    between signed and unsigned integers. For example, when promoting `uint8` to a
    signed integer, how many bits do we need?'
  prefs: []
  type: TYPE_NORMAL
- en: 'At first glance, you might think it natural to promote `uint8` to `int8`; but
    the largest `uint8` numbers are not representable in `int8`. For this reason,
    it makes more sense to promote unsigned integers to integers with twice the number
    of bits; this promotion behavior can be represented by adding the following connections
    to the promotion lattice:'
  prefs: []
  type: TYPE_NORMAL
- en: <details class="hide above-input"><summary aria-label="Toggle hidden content">Show
    code cell source Hide code cell source</summary>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]</details> ![../_images/3be7e17889458ac823bb5dacf31525c0d96578c6854962f45dcc60ec987a30bd.png](img/1a7d3b78b45858ca77d9810e77d053b9.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Again, the connections added here are precisely the promotion semantics implemented
    by Numpy for mixed-integer promotion.
  prefs: []
  type: TYPE_NORMAL
- en: How to handle `uint64`?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The approach to mixed signed/unsigned integer promotion leaves out one type:
    `uint64`. Following the pattern above, the output of a mixed-integer operation
    involving `uint64` should result in `int128`, but this is not a standard available
    dtype.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Numpy’s choice here is to promote to `float64`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'However, this may be a surprising convention: it’s the only case in which promotion
    of integer types does not result in an integer. For now, we will leave `uint64`
    promotion undefined, and return to it later.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Mixed Promotion: Integer and Floating'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When promoting integers to floating point, we might start with the same thought
    process as mixed promotion between signed and unsigned integers. A 16-bit signed
    or unsigned integer cannot be represented at full precision by a 16-bit float,
    which has only 10 bits of mantissa. Therefore, it might make sense to promote
    integers to floats represented by twice the number of bits:'
  prefs: []
  type: TYPE_NORMAL
- en: <details class="hide above-input"><summary aria-label="Toggle hidden content">Show
    code cell source Hide code cell source</summary>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]</details> ![../_images/8b3247e8189fbfad46a7e5583b636866fc45576e07c9bfd904457926306299d1.png](img/830c2790dfd6b146ef474a036558f81e.png)'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is effectively what Numpy type promotion does, but in doing so it breaks
    the lattice property of the graph: for example, the pair *{i8, u8}* no longer
    has a unique least upper bound: the possibilities are *i16* and *f16*, which are
    unorderable on the graph. This turns out to be the source of NumPy’s non-associative
    type promotion highlighted above.'
  prefs: []
  type: TYPE_NORMAL
- en: Can we come up with a modification of NumPy’s promotion rules, such that it
    will satisfy the lattice property, while also giving sensible results for mixed
    type promotion? There are a few approaches we could take here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Option 0: Leave integer/floating mixed precision undefined'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To make behavior utterly predictable (at some cost to user convenience), a defensible
    choice would be to leave as undefined any mixed integer/float promotion beyond
    Python scalars, stopping with the partial lattice from the previous section. The
    downside would be the requirement for users to explicitly type-cast when operating
    between integer and floating-point quantities.
  prefs: []
  type: TYPE_NORMAL
- en: 'Option 1: Avoiding All Precision Loss'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If our focus is on avoiding precision loss at all costs, we can restore the
    lattice property by promoting unsigned integers to float via their existing signed
    integer paths:'
  prefs: []
  type: TYPE_NORMAL
- en: <details class="hide above-input"><summary aria-label="Toggle hidden content">Show
    code cell source Hide code cell source</summary>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]</details> ![../_images/1eda89d008a8c6dadf926229bf9f2245722006c5bc1c42961c555a2595c95117.png](img/c062177f41f5c0a66d94848e91df12e8.png)'
  prefs: []
  type: TYPE_NORMAL
- en: A disadvantage of this approach is that it still leaves `int64` and `uint64`
    promotion undefined, because there is no standard floating point type with enough
    bits of mantissa to represent their full range of values. We could relax the precision
    constraint and complete the lattice by drawing connections from `i64->f64` and
    `u64->f64`, but those links would run counter to the motivation for this promotion
    scheme.
  prefs: []
  type: TYPE_NORMAL
- en: A second disadvantage is that this lattice makes it difficult to find a sensible
    place to insert `bfloat16` (see below) while maintaining the lattice property.
  prefs: []
  type: TYPE_NORMAL
- en: A third disadvantage of this approach, more important for JAX’s accelerator
    backends, is that some operations result in types that are much wider than necessary;
    for example mixed operations between `uint16` and `float16` would promote all
    the way to `float64`, which is not ideal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Option 2: Avoid most wider-than-necessary promotions'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To address the unnecessary promotions to wider types, we could accept the possibility
    of some precision loss in integer/float promotion, promoting signed integers to
    floats of the same width:'
  prefs: []
  type: TYPE_NORMAL
- en: <details class="hide above-input"><summary aria-label="Toggle hidden content">Show
    code cell source Hide code cell source</summary>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]</details> ![../_images/f41cee38a476bf636be901e7f64a5dc3687002f9d12532ab706b9077d602b175.png](img/053dcc1c67022eff2e093d2a9e6989ce.png)'
  prefs: []
  type: TYPE_NORMAL
- en: 'While this does allow for precision-losing promotions between integers and
    floats, these promotions will not mis-represent the *magnitude* of the result:
    though the floating point mantissa is not wide enough to represent all values,
    the exponent is wide enough to approximate them.'
  prefs: []
  type: TYPE_NORMAL
- en: This approach also allows a natural promotion path from `int64` to `float64`,
    though `uint64` remains unpromotable in this scheme. That said, a connection from
    `u64` to `f64` could be justified more readily here than before.
  prefs: []
  type: TYPE_NORMAL
- en: This promotion scheme still results in some wider than necessary promotion paths;
    for example operations between `float32` and `uint32` result in `float64`. Additionally,
    this lattice makes it difficult to find a sensible place to insert `bfloat16`
    (see below) while maintaining the lattice property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Option 3: Avoid all wider-than-necessary promotions'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can avoid *all* non-ideal 64-bit promotions if we’re willing to fundamentally
    change our thinking around integer and float promotions. Just as scalars always
    defer to the widths of array types, we can make integers always defer to the width
    of float types:'
  prefs: []
  type: TYPE_NORMAL
- en: <details class="hide above-input"><summary aria-label="Toggle hidden content">Show
    code cell source Hide code cell source</summary>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]</details> ![../_images/d3f5e5be4354238a60698cb4f228d4e1f75a665577343c36b2c1ade1207783a0.png](img/bf94c44dddef5be193e1a2aa9a9bf685.png)'
  prefs: []
  type: TYPE_NORMAL
- en: 'This involves a small sleight of hand: previously we had used `f*` to refer
    to a scalar type. In this lattice, `f*` might be applied to the array output of
    a mixed computation. Instead of thinking of `f*` as a scalar, we could think of
    it as a special kind of `float` value with distinct promotion rules: in JAX we
    refer to this as a *weak float*; see below.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The advantage of this approach is that, outside unsigned ints, it avoids *all*
    wider-than-necessary promotions: you can never get an f64 output without a 64-bit
    input, and you can never get an f32 output without a 32-bit input: this results
    in convenient semantics for working on accelerators while avoiding inadvertent
    64-bit values.'
  prefs: []
  type: TYPE_NORMAL
- en: This feature of giving primacy to floating point types resembles the type promotion
    behavior of PyTorch. This lattice also happens to generate a promotion table that
    very closely resembles JAX’s original *ad hoc* type promotion scheme, which was
    not based on a lattice but had the property of giving primacy to floating point
    types.
  prefs: []
  type: TYPE_NORMAL
- en: 'This lattice additionally offers a natural location to insert `bfloat16`, without
    the need to impose an ordering between `bf16` and `f16`:'
  prefs: []
  type: TYPE_NORMAL
- en: <details class="hide above-input"><summary aria-label="Toggle hidden content">Show
    code cell source Hide code cell source</summary>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]</details> ![../_images/aa73688b580b02776fce218d6efe58792ae3b0976160a4b0c130b797780578af.png](img/774df410c611ee33896b0d5d7ef34e35.png)'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is important because `f16` and `bf16` are not comparable because they
    utilize their bits differently: `bf16` represents a larger range at lower precision,
    while `f16` represents a smaller range at higher precision.'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, these advantages comes with a few tradeoffs:'
  prefs: []
  type: TYPE_NORMAL
- en: 'mixed float/integer promotion is very prone to precision loss: for example,
    `int64` (with a maximum value of \(9.2 \times 10^{18}\)) can be promoted to `float16`
    (with a maximum value of \(6.5 \times 10⁴\)), meaning most representable values
    will become `inf`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: as mentioned above, `f*` can no longer be thought of as a “scalar type”, but
    as a different flavor of float64\. In JAX’s parlance, this is referred to as a
    [*weak type*](https://jax.readthedocs.io/en/latest/type_promotion.html#weakly-typed-values-in-jax),
    in that it is represented as 64-bit, but only weakly holds to this bit width in
    promotion with other values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that also, this approach still leaves the `uint64` promotion question unanswered,
    although it is perhaps reasonable to close the lattice by connecting `u64` to
    `f*`.
  prefs: []
  type: TYPE_NORMAL
- en: Type Promotion in JAX
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In designing the type promotion semantics of JAX, we kept in mind many of these
    ideas, and leaned heavily on a few things:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We chose to constrain JAX’s type promotion semantics to graphs that satisfy
    the lattice property: this is to ensure associativity and commutativity, but also
    to allow the semantics to be compactly described in a DAG, rather than requiring
    a large table.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We leaned toward semantics that avoid inadvertent promotion to wider types,
    particularly when it comes to float values, in order to benefit computation on
    accelerators.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We were fine accepting potential loss of precision (but not loss of magnitude)
    in mixed type promotion if it were required to maintain (1) and (2)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With this in mind, JAX has adopted Option 3\. Or rather, a slightly modified
    version of Option 3 that draws the connection between `u64` and `f*`, in order
    to create a true lattice. Rearranging the nodes for clarity, JAX’s type promotion
    lattice then looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: <details class="hide above-input"><summary aria-label="Toggle hidden content">Show
    code cell source Hide code cell source</summary>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]</details> ![../_images/d261add493a579484d9772634ce146f1240af3966d0845839c354417a3de2e53.png](img/e2f9680e0c4d097070698630af5edf61.png)'
  prefs: []
  type: TYPE_NORMAL
- en: The behavior resulting from this choice is summarized in [JAX Type Promotion
    Semantics](https://jax.readthedocs.io/en/latest/type_promotion.html). Notably,
    aside from the inclusion of larger unsigned types (`u16`, `u32`, `u64`) and some
    details about the behavior of scalar/weak types (`i*`, `f*`, `c*`), this type
    promotion scheme turns out to be very close to that chosen by PyTorch.
  prefs: []
  type: TYPE_NORMAL
- en: For those interested, the appendix below prints the full promotion tables used
    by NumPy, Tensorflow, PyTorch, and JAX.
  prefs: []
  type: TYPE_NORMAL
- en: 'Appendix: Example Type Promotion Tables'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following are some examples of implicit type promotion tables implemented
    by various Python array computing libraries.
  prefs: []
  type: TYPE_NORMAL
- en: NumPy Type Promotion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that NumPy does not include the `bfloat16` dtype, and that the table below
    ignores value-dependent effects.
  prefs: []
  type: TYPE_NORMAL
- en: <details class="hide above-input"><summary aria-label="Toggle hidden content">Show
    code cell source Hide code cell source</summary>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]</details>'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | b | u8 | u16 | u32 | u64 | i8 | i16 | i32 | i64 | bf16 | f16 | f32 | f64
    | c64 | c128 | i* | f* | c* |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | ---
    | --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| b | b | u8 | u16 | u32 | u64 | i8 | i16 | i32 | i64 | - | f16 | f32 | f64
    | c64 | c128 | i64 | f64 | c128 |'
  prefs: []
  type: TYPE_TB
- en: '| u8 | u8 | u8 | u16 | u32 | u64 | i16 | i16 | i32 | i64 | - | f16 | f32 |
    f64 | c64 | c128 | u8 | f64 | c128 |'
  prefs: []
  type: TYPE_TB
- en: '| u16 | u16 | u16 | u16 | u32 | u64 | i32 | i32 | i32 | i64 | - | f32 | f32
    | f64 | c64 | c128 | u16 | f64 | c128 |'
  prefs: []
  type: TYPE_TB
- en: '| u32 | u32 | u32 | u32 | u32 | u64 | i64 | i64 | i64 | i64 | - | f64 | f64
    | f64 | c128 | c128 | u32 | f64 | c128 |'
  prefs: []
  type: TYPE_TB
- en: '| u64 | u64 | u64 | u64 | u64 | u64 | f64 | f64 | f64 | f64 | - | f64 | f64
    | f64 | c128 | c128 | u64 | f64 | c128 |'
  prefs: []
  type: TYPE_TB
- en: '| i8 | i8 | i16 | i32 | i64 | f64 | i8 | i16 | i32 | i64 | - | f16 | f32 |
    f64 | c64 | c128 | i8 | f64 | c128 |'
  prefs: []
  type: TYPE_TB
- en: '| i16 | i16 | i16 | i32 | i64 | f64 | i16 | i16 | i32 | i64 | - | f32 | f32
    | f64 | c64 | c128 | i16 | f64 | c128 |'
  prefs: []
  type: TYPE_TB
- en: '| i32 | i32 | i32 | i32 | i64 | f64 | i32 | i32 | i32 | i64 | - | f64 | f64
    | f64 | c128 | c128 | i32 | f64 | c128 |'
  prefs: []
  type: TYPE_TB
- en: '| i64 | i64 | i64 | i64 | i64 | f64 | i64 | i64 | i64 | i64 | - | f64 | f64
    | f64 | c128 | c128 | i64 | f64 | c128 |'
  prefs: []
  type: TYPE_TB
- en: '| bf16 | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | -
    | - |'
  prefs: []
  type: TYPE_TB
- en: '| f16 | f16 | f16 | f32 | f64 | f64 | f16 | f32 | f64 | f64 | - | f16 | f32
    | f64 | c64 | c128 | f16 | f16 | c64 |'
  prefs: []
  type: TYPE_TB
- en: '| f32 | f32 | f32 | f32 | f64 | f64 | f32 | f32 | f64 | f64 | - | f32 | f32
    | f64 | c64 | c128 | f32 | f32 | c64 |'
  prefs: []
  type: TYPE_TB
- en: '| f64 | f64 | f64 | f64 | f64 | f64 | f64 | f64 | f64 | f64 | - | f64 | f64
    | f64 | c128 | c128 | f64 | f64 | c128 |'
  prefs: []
  type: TYPE_TB
- en: '| c64 | c64 | c64 | c64 | c128 | c128 | c64 | c64 | c128 | c128 | - | c64 |
    c64 | c128 | c64 | c128 | c64 | c64 | c64 |'
  prefs: []
  type: TYPE_TB
- en: '| c128 | c128 | c128 | c128 | c128 | c128 | c128 | c128 | c128 | c128 | - |
    c128 | c128 | c128 | c128 | c128 | c128 | c128 | c128 |'
  prefs: []
  type: TYPE_TB
- en: '| i* | i64 | u8 | u16 | u32 | u64 | i8 | i16 | i32 | i64 | - | f16 | f32 |
    f64 | c64 | c128 | i64 | f64 | c128 |'
  prefs: []
  type: TYPE_TB
- en: '| f* | f64 | f64 | f64 | f64 | f64 | f64 | f64 | f64 | f64 | - | f16 | f32
    | f64 | c64 | c128 | f64 | f64 | c128 |'
  prefs: []
  type: TYPE_TB
- en: '| c* | c128 | c128 | c128 | c128 | c128 | c128 | c128 | c128 | c128 | - | c64
    | c64 | c128 | c64 | c128 | c128 | c128 | c128 |'
  prefs: []
  type: TYPE_TB
- en: Tensorflow Type Promotion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Tensorflow avoids defining implicit type promotion, except for Python scalars
    in limited cases. The table is asymmetric because in `tf.add(x, y)`, the type
    of `y` must be coercible to the type of `x`.
  prefs: []
  type: TYPE_NORMAL
- en: <details class="hide above-input"><summary aria-label="Toggle hidden content">Show
    code cell source Hide code cell source</summary>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]</details>'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | b | u8 | u16 | u32 | u64 | i8 | i16 | i32 | i64 | bf16 | f16 | f32 | f64
    | c64 | c128 | i* | f* | c* |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | ---
    | --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| b | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | -
    |'
  prefs: []
  type: TYPE_TB
- en: '| u8 | - | u8 | - | - | - | - | - | - | - | - | - | - | - | - | - | u8 | -
    | - |'
  prefs: []
  type: TYPE_TB
- en: '| u16 | - | - | u16 | - | - | - | - | - | - | - | - | - | - | - | - | u16 |
    - | - |'
  prefs: []
  type: TYPE_TB
- en: '| u32 | - | - | - | u32 | - | - | - | - | - | - | - | - | - | - | - | u32 |
    - | - |'
  prefs: []
  type: TYPE_TB
- en: '| u64 | - | - | - | - | u64 | - | - | - | - | - | - | - | - | - | - | u64 |
    - | - |'
  prefs: []
  type: TYPE_TB
- en: '| i8 | - | - | - | - | - | i8 | - | - | - | - | - | - | - | - | - | i8 | -
    | - |'
  prefs: []
  type: TYPE_TB
- en: '| i16 | - | - | - | - | - | - | i16 | - | - | - | - | - | - | - | - | i16 |
    - | - |'
  prefs: []
  type: TYPE_TB
- en: '| i32 | - | - | - | - | - | - | - | i32 | - | - | - | - | - | - | - | i32 |
    - | - |'
  prefs: []
  type: TYPE_TB
- en: '| i64 | - | - | - | - | - | - | - | - | i64 | - | - | - | - | - | - | i64 |
    - | - |'
  prefs: []
  type: TYPE_TB
- en: '| bf16 | - | - | - | - | - | - | - | - | - | bf16 | - | - | - | - | - | bf16
    | bf16 | - |'
  prefs: []
  type: TYPE_TB
- en: '| f16 | - | - | - | - | - | - | - | - | - | - | f16 | - | - | - | - | f16 |
    f16 | - |'
  prefs: []
  type: TYPE_TB
- en: '| f32 | - | - | - | - | - | - | - | - | - | - | - | f32 | - | - | - | f32 |
    f32 | - |'
  prefs: []
  type: TYPE_TB
- en: '| f64 | - | - | - | - | - | - | - | - | - | - | - | - | f64 | - | - | f64 |
    f64 | - |'
  prefs: []
  type: TYPE_TB
- en: '| c64 | - | - | - | - | - | - | - | - | - | - | - | - | - | c64 | - | c64 |
    c64 | c64 |'
  prefs: []
  type: TYPE_TB
- en: '| c128 | - | - | - | - | - | - | - | - | - | - | - | - | - | - | c128 | c128
    | c128 | c128 |'
  prefs: []
  type: TYPE_TB
- en: '| i* | - | - | - | - | - | - | - | i32 | - | - | - | - | - | - | - | i32 |
    - | - |'
  prefs: []
  type: TYPE_TB
- en: '| f* | - | - | - | - | - | - | - | - | - | - | - | f32 | - | - | - | f32 |
    f32 | - |'
  prefs: []
  type: TYPE_TB
- en: '| c* | - | - | - | - | - | - | - | - | - | - | - | - | - | - | c128 | c128
    | c128 | c128 |'
  prefs: []
  type: TYPE_TB
- en: PyTorch Type Promotion
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Notice that torch does not include unsigned integer types larger than `uint8`.
    Aside from this and some details about promotion with scalar/weak types, the table
    is close to that used by `jax.numpy`.
  prefs: []
  type: TYPE_NORMAL
- en: <details class="hide above-input"><summary aria-label="Toggle hidden content">Show
    code cell source Hide code cell source</summary>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]</details>'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | b | u8 | u16 | u32 | u64 | i8 | i16 | i32 | i64 | bf16 | f16 | f32 | f64
    | c64 | c128 | i* | f* | c* |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | ---
    | --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| b | b | u8 | - | - | - | i8 | i16 | i32 | i64 | bf16 | f16 | f32 | f64 |
    c64 | c128 | i64 | f32 | c64 |'
  prefs: []
  type: TYPE_TB
- en: '| u8 | u8 | u8 | - | - | - | i16 | i16 | i32 | i64 | bf16 | f16 | f32 | f64
    | c64 | c128 | u8 | f32 | c64 |'
  prefs: []
  type: TYPE_TB
- en: '| u16 | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - |
    - |'
  prefs: []
  type: TYPE_TB
- en: '| u32 | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - |
    - |'
  prefs: []
  type: TYPE_TB
- en: '| u64 | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - |
    - |'
  prefs: []
  type: TYPE_TB
- en: '| i8 | i8 | i16 | - | - | - | i8 | i16 | i32 | i64 | bf16 | f16 | f32 | f64
    | c64 | c128 | i8 | f32 | c64 |'
  prefs: []
  type: TYPE_TB
- en: '| i16 | i16 | i16 | - | - | - | i16 | i16 | i32 | i64 | bf16 | f16 | f32 |
    f64 | c64 | c128 | i16 | f32 | c64 |'
  prefs: []
  type: TYPE_TB
- en: '| i32 | i32 | i32 | - | - | - | i32 | i32 | i32 | i64 | bf16 | f16 | f32 |
    f64 | c64 | c128 | i32 | f32 | c64 |'
  prefs: []
  type: TYPE_TB
- en: '| i64 | i64 | i64 | - | - | - | i64 | i64 | i64 | i64 | bf16 | f16 | f32 |
    f64 | c64 | c128 | i64 | f32 | c64 |'
  prefs: []
  type: TYPE_TB
- en: '| bf16 | bf16 | bf16 | - | - | - | bf16 | bf16 | bf16 | bf16 | bf16 | f32 |
    f32 | f64 | c64 | c128 | bf16 | bf16 | c64 |'
  prefs: []
  type: TYPE_TB
- en: '| f16 | f16 | f16 | - | - | - | f16 | f16 | f16 | f16 | f32 | f16 | f32 | f64
    | c64 | c128 | f16 | f16 | c64 |'
  prefs: []
  type: TYPE_TB
- en: '| f32 | f32 | f32 | - | - | - | f32 | f32 | f32 | f32 | f32 | f32 | f32 | f64
    | c64 | c128 | f32 | f32 | c64 |'
  prefs: []
  type: TYPE_TB
- en: '| f64 | f64 | f64 | - | - | - | f64 | f64 | f64 | f64 | f64 | f64 | f64 | f64
    | c128 | c128 | f64 | f64 | c128 |'
  prefs: []
  type: TYPE_TB
- en: '| c64 | c64 | c64 | - | - | - | c64 | c64 | c64 | c64 | c64 | c64 | c64 | c128
    | c64 | c128 | c64 | c64 | c64 |'
  prefs: []
  type: TYPE_TB
- en: '| c128 | c128 | c128 | - | - | - | c128 | c128 | c128 | c128 | c128 | c128
    | c128 | c128 | c128 | c128 | c128 | c128 | c128 |'
  prefs: []
  type: TYPE_TB
- en: '| i* | i64 | u8 | - | - | - | i8 | i16 | i32 | i64 | bf16 | f16 | f32 | f64
    | c64 | c128 | i64 | f32 | c64 |'
  prefs: []
  type: TYPE_TB
- en: '| f* | f32 | f32 | - | - | - | f32 | f32 | f32 | f32 | bf16 | f16 | f32 | f64
    | c64 | c128 | f32 | f64 | c64 |'
  prefs: []
  type: TYPE_TB
- en: '| c* | c64 | c64 | - | - | - | c64 | c64 | c64 | c64 | c64 | c64 | c64 | c128
    | c64 | c128 | c64 | c64 | c128 |'
  prefs: []
  type: TYPE_TB
- en: 'JAX Type Promotion: `jax.numpy`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`jax.numpy` follows type promotion rules laid out at https://jax.readthedocs.io/en/latest/type_promotion.html.
    Here we use `i*`, `f*`, `c*` to indicate both Python scalars and weakly-typed
    arrays.'
  prefs: []
  type: TYPE_NORMAL
- en: <details class="hide above-input"><summary aria-label="Toggle hidden content">Show
    code cell source Hide code cell source</summary>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]</details>'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | b | u8 | u16 | u32 | u64 | i8 | i16 | i32 | i64 | bf16 | f16 | f32 | f64
    | c64 | c128 | i* | f* | c* |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | ---
    | --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| b | b | u8 | u16 | u32 | u64 | i8 | i16 | i32 | i64 | bf16 | f16 | f32 |
    f64 | c64 | c128 | i* | f* | c* |'
  prefs: []
  type: TYPE_TB
- en: '| u8 | u8 | u8 | u16 | u32 | u64 | i16 | i16 | i32 | i64 | bf16 | f16 | f32
    | f64 | c64 | c128 | u8 | f* | c* |'
  prefs: []
  type: TYPE_TB
- en: '| u16 | u16 | u16 | u16 | u32 | u64 | i32 | i32 | i32 | i64 | bf16 | f16 |
    f32 | f64 | c64 | c128 | u16 | f* | c* |'
  prefs: []
  type: TYPE_TB
- en: '| u32 | u32 | u32 | u32 | u32 | u64 | i64 | i64 | i64 | i64 | bf16 | f16 |
    f32 | f64 | c64 | c128 | u32 | f* | c* |'
  prefs: []
  type: TYPE_TB
- en: '| u64 | u64 | u64 | u64 | u64 | u64 | f* | f* | f* | f* | bf16 | f16 | f32
    | f64 | c64 | c128 | u64 | f* | c* |'
  prefs: []
  type: TYPE_TB
- en: '| i8 | i8 | i16 | i32 | i64 | f* | i8 | i16 | i32 | i64 | bf16 | f16 | f32
    | f64 | c64 | c128 | i8 | f* | c* |'
  prefs: []
  type: TYPE_TB
- en: '| i16 | i16 | i16 | i32 | i64 | f* | i16 | i16 | i32 | i64 | bf16 | f16 | f32
    | f64 | c64 | c128 | i16 | f* | c* |'
  prefs: []
  type: TYPE_TB
- en: '| i32 | i32 | i32 | i32 | i64 | f* | i32 | i32 | i32 | i64 | bf16 | f16 | f32
    | f64 | c64 | c128 | i32 | f* | c* |'
  prefs: []
  type: TYPE_TB
- en: '| i64 | i64 | i64 | i64 | i64 | f* | i64 | i64 | i64 | i64 | bf16 | f16 | f32
    | f64 | c64 | c128 | i64 | f* | c* |'
  prefs: []
  type: TYPE_TB
- en: '| bf16 | bf16 | bf16 | bf16 | bf16 | bf16 | bf16 | bf16 | bf16 | bf16 | bf16
    | f32 | f32 | f64 | c64 | c128 | bf16 | bf16 | c64 |'
  prefs: []
  type: TYPE_TB
- en: '| f16 | f16 | f16 | f16 | f16 | f16 | f16 | f16 | f16 | f16 | f32 | f16 | f32
    | f64 | c64 | c128 | f16 | f16 | c64 |'
  prefs: []
  type: TYPE_TB
- en: '| f32 | f32 | f32 | f32 | f32 | f32 | f32 | f32 | f32 | f32 | f32 | f32 | f32
    | f64 | c64 | c128 | f32 | f32 | c64 |'
  prefs: []
  type: TYPE_TB
- en: '| f64 | f64 | f64 | f64 | f64 | f64 | f64 | f64 | f64 | f64 | f64 | f64 | f64
    | f64 | c128 | c128 | f64 | f64 | c128 |'
  prefs: []
  type: TYPE_TB
- en: '| c64 | c64 | c64 | c64 | c64 | c64 | c64 | c64 | c64 | c64 | c64 | c64 | c64
    | c128 | c64 | c128 | c64 | c64 | c64 |'
  prefs: []
  type: TYPE_TB
- en: '| c128 | c128 | c128 | c128 | c128 | c128 | c128 | c128 | c128 | c128 | c128
    | c128 | c128 | c128 | c128 | c128 | c128 | c128 | c128 |'
  prefs: []
  type: TYPE_TB
- en: '| i* | i* | u8 | u16 | u32 | u64 | i8 | i16 | i32 | i64 | bf16 | f16 | f32
    | f64 | c64 | c128 | i* | f* | c* |'
  prefs: []
  type: TYPE_TB
- en: '| f* | f* | f* | f* | f* | f* | f* | f* | f* | f* | bf16 | f16 | f32 | f64
    | c64 | c128 | f* | f* | c* |'
  prefs: []
  type: TYPE_TB
- en: '| c* | c* | c* | c* | c* | c* | c* | c* | c* | c* | c64 | c64 | c64 | c128
    | c64 | c128 | c* | c* | c* |'
  prefs: []
  type: TYPE_TB
- en: 'JAX Type Promotion: `jax.lax`'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`jax.lax` is lower-level, and does not do any implicit promotion. Here we use
    `i*`, `f*`, `c*` to indicate both Python scalars and weakly-typed arrays.'
  prefs: []
  type: TYPE_NORMAL
- en: <details class="hide above-input"><summary aria-label="Toggle hidden content">Show
    code cell source Hide code cell source</summary>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]</details>'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | b | u8 | u16 | u32 | u64 | i8 | i16 | i32 | i64 | bf16 | f16 | f32 | f64
    | c64 | c128 | i* | f* | c* |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | ---
    | --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| b | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - | -
    |'
  prefs: []
  type: TYPE_TB
- en: '| u8 | - | u8 | - | - | - | - | - | - | - | - | - | - | - | - | - | - | - |
    - |'
  prefs: []
  type: TYPE_TB
- en: '| u16 | - | - | u16 | - | - | - | - | - | - | - | - | - | - | - | - | - | -
    | - |'
  prefs: []
  type: TYPE_TB
- en: '| u32 | - | - | - | u32 | - | - | - | - | - | - | - | - | - | - | - | - | -
    | - |'
  prefs: []
  type: TYPE_TB
- en: '| u64 | - | - | - | - | u64 | - | - | - | - | - | - | - | - | - | - | - | -
    | - |'
  prefs: []
  type: TYPE_TB
- en: '| i8 | - | - | - | - | - | i8 | - | - | - | - | - | - | - | - | - | - | - |
    - |'
  prefs: []
  type: TYPE_TB
- en: '| i16 | - | - | - | - | - | - | i16 | - | - | - | - | - | - | - | - | - | -
    | - |'
  prefs: []
  type: TYPE_TB
- en: '| i32 | - | - | - | - | - | - | - | i32 | - | - | - | - | - | - | - | - | -
    | - |'
  prefs: []
  type: TYPE_TB
- en: '| i64 | - | - | - | - | - | - | - | - | i64 | - | - | - | - | - | - | i64 |
    - | - |'
  prefs: []
  type: TYPE_TB
- en: '| bf16 | - | - | - | - | - | - | - | - | - | bf16 | - | - | - | - | - | - |
    - | - |'
  prefs: []
  type: TYPE_TB
- en: '| f16 | - | - | - | - | - | - | - | - | - | - | f16 | - | - | - | - | - | -
    | - |'
  prefs: []
  type: TYPE_TB
- en: '| f32 | - | - | - | - | - | - | - | - | - | - | - | f32 | - | - | - | - | -
    | - |'
  prefs: []
  type: TYPE_TB
- en: '| f64 | - | - | - | - | - | - | - | - | - | - | - | - | f64 | - | - | - | f64
    | - |'
  prefs: []
  type: TYPE_TB
- en: '| c64 | - | - | - | - | - | - | - | - | - | - | - | - | - | c64 | - | - | -
    | - |'
  prefs: []
  type: TYPE_TB
- en: '| c128 | - | - | - | - | - | - | - | - | - | - | - | - | - | - | c128 | - |
    - | c128 |'
  prefs: []
  type: TYPE_TB
- en: '| i* | - | - | - | - | - | - | - | - | i64 | - | - | - | - | - | - | i* | -
    | - |'
  prefs: []
  type: TYPE_TB
- en: '| f* | - | - | - | - | - | - | - | - | - | - | - | - | f64 | - | - | - | f*
    | - |'
  prefs: []
  type: TYPE_TB
- en: '| c* | - | - | - | - | - | - | - | - | - | - | - | - | - | - | c128 | - | -
    | c* |'
  prefs: []
  type: TYPE_TB
