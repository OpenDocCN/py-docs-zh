- en: Sessions / Queries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.sqlalchemy.org/en/20/faq/sessions.html](https://docs.sqlalchemy.org/en/20/faq/sessions.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[I’m re-loading data with my Session but it isn’t seeing changes that I committed
    elsewhere](#i-m-re-loading-data-with-my-session-but-it-isn-t-seeing-changes-that-i-committed-elsewhere)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“This Session’s transaction has been rolled back due to a previous exception
    during flush.” (or similar)](#this-session-s-transaction-has-been-rolled-back-due-to-a-previous-exception-during-flush-or-similar)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[But why does flush() insist on issuing a ROLLBACK?](#but-why-does-flush-insist-on-issuing-a-rollback)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[But why isn’t the one automatic call to ROLLBACK enough? Why must I ROLLBACK
    again?](#but-why-isn-t-the-one-automatic-call-to-rollback-enough-why-must-i-rollback-again)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[How do I make a Query that always adds a certain filter to every query?](#how-do-i-make-a-query-that-always-adds-a-certain-filter-to-every-query)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[My Query does not return the same number of objects as query.count() tells
    me - why?](#my-query-does-not-return-the-same-number-of-objects-as-query-count-tells-me-why)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[I’ve created a mapping against an Outer Join, and while the query returns
    rows, no objects are returned. Why not?](#i-ve-created-a-mapping-against-an-outer-join-and-while-the-query-returns-rows-no-objects-are-returned-why-not)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[I’m using `joinedload()` or `lazy=False` to create a JOIN/OUTER JOIN and SQLAlchemy
    is not constructing the correct query when I try to add a WHERE, ORDER BY, LIMIT,
    etc. (which relies upon the (OUTER) JOIN)](#i-m-using-joinedload-or-lazy-false-to-create-a-join-outer-join-and-sqlalchemy-is-not-constructing-the-correct-query-when-i-try-to-add-a-where-order-by-limit-etc-which-relies-upon-the-outer-join)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Query has no `__len__()`, why not?](#query-has-no-len-why-not)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[How Do I use Textual SQL with ORM Queries?](#how-do-i-use-textual-sql-with-orm-queries)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[I’m calling `Session.delete(myobject)` and it isn’t removed from the parent
    collection!](#i-m-calling-session-delete-myobject-and-it-isn-t-removed-from-the-parent-collection)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[why isn’t my `__init__()` called when I load objects?](#why-isn-t-my-init-called-when-i-load-objects)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[how do I use ON DELETE CASCADE with SA’s ORM?](#how-do-i-use-on-delete-cascade-with-sa-s-orm)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[I set the “foo_id” attribute on my instance to “7”, but the “foo” attribute
    is still `None` - shouldn’t it have loaded Foo with id #7?](#i-set-the-foo-id-attribute-on-my-instance-to-7-but-the-foo-attribute-is-still-none-shouldn-t-it-have-loaded-foo-with-id-7)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[How do I walk all objects that are related to a given object?](#how-do-i-walk-all-objects-that-are-related-to-a-given-object)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Is there a way to automagically have only unique keywords (or other kinds
    of objects) without doing a query for the keyword and getting a reference to the
    row containing that keyword?](#is-there-a-way-to-automagically-have-only-unique-keywords-or-other-kinds-of-objects-without-doing-a-query-for-the-keyword-and-getting-a-reference-to-the-row-containing-that-keyword)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Why does post_update emit UPDATE in addition to the first UPDATE?](#why-does-post-update-emit-update-in-addition-to-the-first-update)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '## I’m re-loading data with my Session but it isn’t seeing changes that I committed
    elsewhere'
  prefs: []
  type: TYPE_NORMAL
- en: The main issue regarding this behavior is that the session acts as though the
    transaction is in the *serializable* isolation state, even if it’s not (and it
    usually is not). In practical terms, this means that the session does not alter
    any data that it’s already read within the scope of a transaction.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the term “isolation level” is unfamiliar, then you first need to read this
    link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Isolation Level](https://en.wikipedia.org/wiki/Isolation_%28database_systems%29)'
  prefs: []
  type: TYPE_NORMAL
- en: In short, serializable isolation level generally means that once you SELECT
    a series of rows in a transaction, you will get *the identical data* back each
    time you re-emit that SELECT. If you are in the next-lower isolation level, “repeatable
    read”, you’ll see newly added rows (and no longer see deleted rows), but for rows
    that you’ve *already* loaded, you won’t see any change. Only if you are in a lower
    isolation level, e.g. “read committed”, does it become possible to see a row of
    data change its value.
  prefs: []
  type: TYPE_NORMAL
- en: For information on controlling the isolation level when using the SQLAlchemy
    ORM, see [Setting Transaction Isolation Levels / DBAPI AUTOCOMMIT](../orm/session_transaction.html#session-transaction-isolation).
  prefs: []
  type: TYPE_NORMAL
- en: To simplify things dramatically, the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") itself works in terms of a completely isolated transaction,
    and doesn’t overwrite any mapped attributes it’s already read unless you tell
    it to. The use case of trying to re-read data you’ve already loaded in an ongoing
    transaction is an *uncommon* use case that in many cases has no effect, so this
    is considered to be the exception, not the norm; to work within this exception,
    several methods are provided to allow specific data to be reloaded within the
    context of an ongoing transaction.
  prefs: []
  type: TYPE_NORMAL
- en: To understand what we mean by “the transaction” when we talk about the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), your [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is intended to only work within a transaction. An overview
    of this is at [Managing Transactions](../orm/session_transaction.html#unitofwork-transaction).
  prefs: []
  type: TYPE_NORMAL
- en: Once we’ve figured out what our isolation level is, and we think that our isolation
    level is set at a low enough level so that if we re-SELECT a row, we should see
    new data in our [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session"),
    how do we see it?
  prefs: []
  type: TYPE_NORMAL
- en: 'Three ways, from most common to least:'
  prefs: []
  type: TYPE_NORMAL
- en: We simply end our transaction and start a new one on next access with our [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") by calling [`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") (note that if the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is in the lesser-used “autocommit” mode, there would
    be a call to [`Session.begin()`](../orm/session_api.html#sqlalchemy.orm.Session.begin
    "sqlalchemy.orm.Session.begin") as well). The vast majority of applications and
    use cases do not have any issues with not being able to “see” data in other transactions
    because they stick to this pattern, which is at the core of the best practice
    of **short lived transactions**. See [When do I construct a Session, when do I
    commit it, and when do I close it?](../orm/session_basics.html#session-faq-whentocreate)
    for some thoughts on this.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We tell our [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    to re-read rows that it has already read, either when we next query for them using
    [`Session.expire_all()`](../orm/session_api.html#sqlalchemy.orm.Session.expire_all
    "sqlalchemy.orm.Session.expire_all") or [`Session.expire()`](../orm/session_api.html#sqlalchemy.orm.Session.expire
    "sqlalchemy.orm.Session.expire"), or immediately on an object using `refresh`.
    See [Refreshing / Expiring](../orm/session_state_management.html#session-expire)
    for detail on this.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can run whole queries while setting them to definitely overwrite already-loaded
    objects as they read rows by using “populate existing”. This is an execution option
    described at [Populate Existing](../orm/queryguide/api.html#orm-queryguide-populate-existing).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'But remember, **the ORM cannot see changes in rows if our isolation level is
    repeatable read or higher, unless we start a new transaction**.  ## “This Session’s
    transaction has been rolled back due to a previous exception during flush.” (or
    similar)'
  prefs: []
  type: TYPE_NORMAL
- en: This is an error that occurs when a [`Session.flush()`](../orm/session_api.html#sqlalchemy.orm.Session.flush
    "sqlalchemy.orm.Session.flush") raises an exception, rolls back the transaction,
    but further commands upon the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") are called without an explicit call to [`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") or [`Session.close()`](../orm/session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close").
  prefs: []
  type: TYPE_NORMAL
- en: 'It usually corresponds to an application that catches an exception upon [`Session.flush()`](../orm/session_api.html#sqlalchemy.orm.Session.flush
    "sqlalchemy.orm.Session.flush") or [`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") and does not properly handle the exception. For
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The usage of the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") should fit within a structure similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Many things can cause a failure within the try/except besides flushes. Applications
    should ensure some system of “framing” is applied to ORM-oriented processes so
    that connection and transaction resources have a definitive boundary, and so that
    transactions can be explicitly rolled back if any failure conditions occur.
  prefs: []
  type: TYPE_NORMAL
- en: This does not mean there should be try/except blocks throughout an application,
    which would not be a scalable architecture. Instead, a typical approach is that
    when ORM-oriented methods and functions are first called, the process that’s calling
    the functions from the very top would be within a block that commits transactions
    at the successful completion of a series of operations, as well as rolls transactions
    back if operations fail for any reason, including failed flushes. There are also
    approaches using function decorators or context managers to achieve similar results.
    The kind of approach taken depends very much on the kind of application being
    written.
  prefs: []
  type: TYPE_NORMAL
- en: For a detailed discussion on how to organize usage of the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), please see [When do I construct a Session, when do
    I commit it, and when do I close it?](../orm/session_basics.html#session-faq-whentocreate).
  prefs: []
  type: TYPE_NORMAL
- en: But why does flush() insist on issuing a ROLLBACK?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It would be great if [`Session.flush()`](../orm/session_api.html#sqlalchemy.orm.Session.flush
    "sqlalchemy.orm.Session.flush") could partially complete and then not roll back,
    however this is beyond its current capabilities since its internal bookkeeping
    would have to be modified such that it can be halted at any time and be exactly
    consistent with what’s been flushed to the database. While this is theoretically
    possible, the usefulness of the enhancement is greatly decreased by the fact that
    many database operations require a ROLLBACK in any case. Postgres in particular
    has operations which, once failed, the transaction is not allowed to continue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: What SQLAlchemy offers that solves both issues is support of SAVEPOINT, via
    [`Session.begin_nested()`](../orm/session_api.html#sqlalchemy.orm.Session.begin_nested
    "sqlalchemy.orm.Session.begin_nested"). Using [`Session.begin_nested()`](../orm/session_api.html#sqlalchemy.orm.Session.begin_nested
    "sqlalchemy.orm.Session.begin_nested"), you can frame an operation that may potentially
    fail within a transaction, and then “roll back” to the point before its failure
    while maintaining the enclosing transaction.
  prefs: []
  type: TYPE_NORMAL
- en: But why isn’t the one automatic call to ROLLBACK enough? Why must I ROLLBACK
    again?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The rollback that’s caused by the flush() is not the end of the complete transaction
    block; while it ends the database transaction in play, from the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") point of view there is still a transaction that is now
    in an inactive state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given a block such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Above, when a [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    is first created, assuming “autocommit mode” isn’t used, a logical transaction
    is established within the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"). This transaction is “logical” in that it does not actually
    use any database resources until a SQL statement is invoked, at which point a
    connection-level and DBAPI-level transaction is started. However, whether or not
    database-level transactions are part of its state, the logical transaction will
    stay in place until it is ended using [`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit"), [`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback"), or [`Session.close()`](../orm/session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close").
  prefs: []
  type: TYPE_NORMAL
- en: When the `flush()` above fails, the code is still within the transaction framed
    by the try/commit/except/rollback block. If `flush()` were to fully roll back
    the logical transaction, it would mean that when we then reach the `except:` block
    the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    would be in a clean state, ready to emit new SQL on an all new transaction, and
    the call to [`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") would be out of sequence. In particular, the
    [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    would have begun a new transaction by this point, which the [`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") would be acting upon erroneously. Rather than
    allowing SQL operations to proceed on a new transaction in this place where normal
    usage dictates a rollback is about to take place, the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") instead refuses to continue until the explicit rollback
    actually occurs.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, it is expected that the calling code will **always** call [`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit"), [`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback"), or [`Session.close()`](../orm/session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") to correspond to the current transaction block.
    `flush()` keeps the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") within this transaction block so that the behavior of
    the above code is predictable and consistent.
  prefs: []
  type: TYPE_NORMAL
- en: How do I make a Query that always adds a certain filter to every query?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See the recipe at [FilteredQuery](https://www.sqlalchemy.org/trac/wiki/UsageRecipes/FilteredQuery).
  prefs: []
  type: TYPE_NORMAL
- en: '## My Query does not return the same number of objects as query.count() tells
    me - why?'
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    object, when asked to return a list of ORM-mapped objects, will **deduplicate
    the objects based on primary key**. That is, if we for example use the `User`
    mapping described at [Using ORM Declarative Forms to Define Table Metadata](../tutorial/metadata.html#tutorial-orm-table-metadata),
    and we had a SQL query like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Above, the sample data used in the tutorial has two rows in the `addresses`
    table for the `users` row with the name `''jack''`, primary key value 5. If we
    ask the above query for a [`Query.count()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.count
    "sqlalchemy.orm.Query.count"), we will get the answer **2**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if we run [`Query.all()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.all
    "sqlalchemy.orm.Query.all") or iterate over the query, we get back **one element**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This is because when the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object returns full entities, they are **deduplicated**.
    This does not occur if we instead request individual columns back:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two main reasons the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") will deduplicate:'
  prefs: []
  type: TYPE_NORMAL
- en: '**To allow joined eager loading to work correctly** - [Joined Eager Loading](../orm/queryguide/relationships.html#joined-eager-loading)
    works by querying rows using joins against related tables, where it then routes
    rows from those joins into collections upon the lead objects. In order to do this,
    it has to fetch rows where the lead object primary key is repeated for each sub-entry.
    This pattern can then continue into further sub-collections such that a multiple
    of rows may be processed for a single lead object, such as `User(id=5)`. The dedpulication
    allows us to receive objects in the way they were queried, e.g. all the `User()`
    objects whose name is `''jack''` which for us is one object, with the `User.addresses`
    collection eagerly loaded as was indicated either by `lazy=''joined''` on the
    [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")
    or via the [`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload") option. For consistency, the deduplication is still
    applied whether or not the joinedload is established, as the key philosophy behind
    eager loading is that these options never affect the result.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**To eliminate confusion regarding the identity map** - this is admittedly
    the less critical reason. As the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") makes use of an [identity map](../glossary.html#term-identity-map),
    even though our SQL result set has two rows with primary key 5, there is only
    one `User(id=5)` object inside the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") which must be maintained uniquely on its identity, that
    is, its primary key / class combination. It doesn’t actually make much sense,
    if one is querying for `User()` objects, to get the same object multiple times
    in the list. An ordered set would potentially be a better representation of what
    [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    seeks to return when it returns full objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The issue of [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    deduplication remains problematic, mostly for the single reason that the [`Query.count()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.count
    "sqlalchemy.orm.Query.count") method is inconsistent, and the current status is
    that joined eager loading has in recent releases been superseded first by the
    “subquery eager loading” strategy and more recently the “select IN eager loading”
    strategy, both of which are generally more appropriate for collection eager loading.
    As this evolution continues, SQLAlchemy may alter this behavior on [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query"), which may also involve new APIs in order to more directly
    control this behavior, and may also alter the behavior of joined eager loading
    in order to create a more consistent usage pattern.
  prefs: []
  type: TYPE_NORMAL
- en: I’ve created a mapping against an Outer Join, and while the query returns rows,
    no objects are returned. Why not?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Rows returned by an outer join may contain NULL for part of the primary key,
    as the primary key is the composite of both tables. The [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object ignores incoming rows that don’t have an acceptable
    primary key. Based on the setting of the `allow_partial_pks` flag on [`Mapper`](../orm/mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper"), a primary key is accepted if the value has at least
    one non-NULL value, or alternatively if the value has no NULL values. See `allow_partial_pks`
    at [`Mapper`](../orm/mapping_api.html#sqlalchemy.orm.Mapper "sqlalchemy.orm.Mapper").
  prefs: []
  type: TYPE_NORMAL
- en: I’m using `joinedload()` or `lazy=False` to create a JOIN/OUTER JOIN and SQLAlchemy
    is not constructing the correct query when I try to add a WHERE, ORDER BY, LIMIT,
    etc. (which relies upon the (OUTER) JOIN)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The joins generated by joined eager loading are only used to fully load related
    collections, and are designed to have no impact on the primary results of the
    query. Since they are anonymously aliased, they cannot be referenced directly.
  prefs: []
  type: TYPE_NORMAL
- en: For detail on this behavior, see [The Zen of Joined Eager Loading](../orm/queryguide/relationships.html#zen-of-eager-loading).
  prefs: []
  type: TYPE_NORMAL
- en: Query has no `__len__()`, why not?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Python `__len__()` magic method applied to an object allows the `len()`
    builtin to be used to determine the length of the collection. It’s intuitive that
    a SQL query object would link `__len__()` to the [`Query.count()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.count
    "sqlalchemy.orm.Query.count") method, which emits a SELECT COUNT. The reason this
    is not possible is because evaluating the query as a list would incur two SQL
    calls instead of one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: How Do I use Textual SQL with ORM Queries?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'See:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Getting ORM Results from Textual Statements](../orm/queryguide/select.html#orm-queryguide-selecting-text)
    - Ad-hoc textual blocks with [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Using SQL Expressions with Sessions](../orm/persistence_techniques.html#session-sql-expressions)
    - Using [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    with textual SQL directly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I’m calling `Session.delete(myobject)` and it isn’t removed from the parent
    collection!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See [Notes on Delete - Deleting Objects Referenced from Collections and Scalar
    Relationships](../orm/cascades.html#session-deleting-from-collections) for a description
    of this behavior.
  prefs: []
  type: TYPE_NORMAL
- en: why isn’t my `__init__()` called when I load objects?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See [Maintaining Non-Mapped State Across Loads](../orm/mapping_styles.html#mapped-class-load-events)
    for a description of this behavior.
  prefs: []
  type: TYPE_NORMAL
- en: how do I use ON DELETE CASCADE with SA’s ORM?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SQLAlchemy will always issue UPDATE or DELETE statements for dependent rows
    which are currently loaded in the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"). For rows which are not loaded, it will by default issue
    SELECT statements to load those rows and update/delete those as well; in other
    words it assumes there is no ON DELETE CASCADE configured. To configure SQLAlchemy
    to cooperate with ON DELETE CASCADE, see [Using foreign key ON DELETE cascade
    with ORM relationships](../orm/cascades.html#passive-deletes).
  prefs: []
  type: TYPE_NORMAL
- en: 'I set the “foo_id” attribute on my instance to “7”, but the “foo” attribute
    is still `None` - shouldn’t it have loaded Foo with id #7?'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The ORM is not constructed in such a way as to support immediate population
    of relationships driven from foreign key attribute changes - instead, it is designed
    to work the other way around - foreign key attributes are handled by the ORM behind
    the scenes, the end user sets up object relationships naturally. Therefore, the
    recommended way to set `o.foo` is to do just that - set it!:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Manipulation of foreign key attributes is of course entirely legal. However,
    setting a foreign-key attribute to a new value currently does not trigger an “expire”
    event of the [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") in which it’s involved. This means that for the
    following sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '`o.foo` is loaded with its effective database value of `None` when it is first
    accessed. Setting `o.foo_id = 7` will have the value of “7” as a pending change,
    but no flush has occurred - so `o.foo` is still `None`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'For `o.foo` to load based on the foreign key mutation is usually achieved naturally
    after the commit, which both flushes the new foreign key value and expires all
    state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'A more minimal operation is to expire the attribute individually - this can
    be performed for any [persistent](../glossary.html#term-persistent) object using
    [`Session.expire()`](../orm/session_api.html#sqlalchemy.orm.Session.expire "sqlalchemy.orm.Session.expire"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that if the object is not persistent but present in the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), it’s known as [pending](../glossary.html#term-pending).
    This means the row for the object has not been INSERTed into the database yet.
    For such an object, setting `foo_id` does not have meaning until the row is inserted;
    otherwise there is no row yet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The recipe [ExpireRelationshipOnFKChange](https://www.sqlalchemy.org/trac/wiki/UsageRecipes/ExpireRelationshipOnFKChange)
    features an example using SQLAlchemy events in order to coordinate the setting
    of foreign key attributes with many-to-one relationships.
  prefs: []
  type: TYPE_NORMAL
- en: '## How do I walk all objects that are related to a given object?'
  prefs: []
  type: TYPE_NORMAL
- en: 'An object that has other objects related to it will correspond to the [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") constructs set up between mappers. This code fragment
    will iterate all the objects, correcting for cycles as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The function can be demonstrated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Is there a way to automagically have only unique keywords (or other kinds of
    objects) without doing a query for the keyword and getting a reference to the
    row containing that keyword?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When people read the many-to-many example in the docs, they get hit with the
    fact that if you create the same `Keyword` twice, it gets put in the DB twice.
    Which is somewhat inconvenient.
  prefs: []
  type: TYPE_NORMAL
- en: This [UniqueObject](https://www.sqlalchemy.org/trac/wiki/UsageRecipes/UniqueObject)
    recipe was created to address this issue.
  prefs: []
  type: TYPE_NORMAL
- en: '## Why does post_update emit UPDATE in addition to the first UPDATE?'
  prefs: []
  type: TYPE_NORMAL
- en: The post_update feature, documented at [Rows that point to themselves / Mutually
    Dependent Rows](../orm/relationship_persistence.html#post-update), involves that
    an UPDATE statement is emitted in response to changes to a particular relationship-bound
    foreign key, in addition to the INSERT/UPDATE/DELETE that would normally be emitted
    for the target row. While the primary purpose of this UPDATE statement is that
    it pairs up with an INSERT or DELETE of that row, so that it can post-set or pre-unset
    a foreign key reference in order to break a cycle with a mutually dependent foreign
    key, it currently is also bundled as a second UPDATE that emits when the target
    row itself is subject to an UPDATE. In this case, the UPDATE emitted by post_update
    is *usually* unnecessary and will often appear wasteful.
  prefs: []
  type: TYPE_NORMAL
- en: However, some research into trying to remove this “UPDATE / UPDATE” behavior
    reveals that major changes to the unit of work process would need to occur not
    just throughout the post_update implementation, but also in areas that aren’t
    related to post_update for this to work, in that the order of operations would
    need to be reversed on the non-post_update side in some cases, which in turn can
    impact other cases, such as correctly handling an UPDATE of a referenced primary
    key value (see [#1063](https://www.sqlalchemy.org/trac/ticket/1063) for a proof
    of concept).
  prefs: []
  type: TYPE_NORMAL
- en: 'The answer is that “post_update” is used to break a cycle between two mutually
    dependent foreign keys, and to have this cycle breaking be limited to just INSERT/DELETE
    of the target table implies that the ordering of UPDATE statements elsewhere would
    need to be liberalized, leading to breakage in other edge cases.  ## I’m re-loading
    data with my Session but it isn’t seeing changes that I committed elsewhere'
  prefs: []
  type: TYPE_NORMAL
- en: The main issue regarding this behavior is that the session acts as though the
    transaction is in the *serializable* isolation state, even if it’s not (and it
    usually is not). In practical terms, this means that the session does not alter
    any data that it’s already read within the scope of a transaction.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the term “isolation level” is unfamiliar, then you first need to read this
    link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Isolation Level](https://en.wikipedia.org/wiki/Isolation_%28database_systems%29)'
  prefs: []
  type: TYPE_NORMAL
- en: In short, serializable isolation level generally means that once you SELECT
    a series of rows in a transaction, you will get *the identical data* back each
    time you re-emit that SELECT. If you are in the next-lower isolation level, “repeatable
    read”, you’ll see newly added rows (and no longer see deleted rows), but for rows
    that you’ve *already* loaded, you won’t see any change. Only if you are in a lower
    isolation level, e.g. “read committed”, does it become possible to see a row of
    data change its value.
  prefs: []
  type: TYPE_NORMAL
- en: For information on controlling the isolation level when using the SQLAlchemy
    ORM, see [Setting Transaction Isolation Levels / DBAPI AUTOCOMMIT](../orm/session_transaction.html#session-transaction-isolation).
  prefs: []
  type: TYPE_NORMAL
- en: To simplify things dramatically, the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") itself works in terms of a completely isolated transaction,
    and doesn’t overwrite any mapped attributes it’s already read unless you tell
    it to. The use case of trying to re-read data you’ve already loaded in an ongoing
    transaction is an *uncommon* use case that in many cases has no effect, so this
    is considered to be the exception, not the norm; to work within this exception,
    several methods are provided to allow specific data to be reloaded within the
    context of an ongoing transaction.
  prefs: []
  type: TYPE_NORMAL
- en: To understand what we mean by “the transaction” when we talk about the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), your [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is intended to only work within a transaction. An overview
    of this is at [Managing Transactions](../orm/session_transaction.html#unitofwork-transaction).
  prefs: []
  type: TYPE_NORMAL
- en: Once we’ve figured out what our isolation level is, and we think that our isolation
    level is set at a low enough level so that if we re-SELECT a row, we should see
    new data in our [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session"),
    how do we see it?
  prefs: []
  type: TYPE_NORMAL
- en: 'Three ways, from most common to least:'
  prefs: []
  type: TYPE_NORMAL
- en: We simply end our transaction and start a new one on next access with our [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") by calling [`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") (note that if the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is in the lesser-used “autocommit” mode, there would
    be a call to [`Session.begin()`](../orm/session_api.html#sqlalchemy.orm.Session.begin
    "sqlalchemy.orm.Session.begin") as well). The vast majority of applications and
    use cases do not have any issues with not being able to “see” data in other transactions
    because they stick to this pattern, which is at the core of the best practice
    of **short lived transactions**. See [When do I construct a Session, when do I
    commit it, and when do I close it?](../orm/session_basics.html#session-faq-whentocreate)
    for some thoughts on this.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We tell our [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    to re-read rows that it has already read, either when we next query for them using
    [`Session.expire_all()`](../orm/session_api.html#sqlalchemy.orm.Session.expire_all
    "sqlalchemy.orm.Session.expire_all") or [`Session.expire()`](../orm/session_api.html#sqlalchemy.orm.Session.expire
    "sqlalchemy.orm.Session.expire"), or immediately on an object using `refresh`.
    See [Refreshing / Expiring](../orm/session_state_management.html#session-expire)
    for detail on this.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can run whole queries while setting them to definitely overwrite already-loaded
    objects as they read rows by using “populate existing”. This is an execution option
    described at [Populate Existing](../orm/queryguide/api.html#orm-queryguide-populate-existing).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: But remember, **the ORM cannot see changes in rows if our isolation level is
    repeatable read or higher, unless we start a new transaction**.
  prefs: []
  type: TYPE_NORMAL
- en: '## “This Session’s transaction has been rolled back due to a previous exception
    during flush.” (or similar)'
  prefs: []
  type: TYPE_NORMAL
- en: This is an error that occurs when a [`Session.flush()`](../orm/session_api.html#sqlalchemy.orm.Session.flush
    "sqlalchemy.orm.Session.flush") raises an exception, rolls back the transaction,
    but further commands upon the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") are called without an explicit call to [`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") or [`Session.close()`](../orm/session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close").
  prefs: []
  type: TYPE_NORMAL
- en: 'It usually corresponds to an application that catches an exception upon [`Session.flush()`](../orm/session_api.html#sqlalchemy.orm.Session.flush
    "sqlalchemy.orm.Session.flush") or [`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") and does not properly handle the exception. For
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The usage of the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") should fit within a structure similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Many things can cause a failure within the try/except besides flushes. Applications
    should ensure some system of “framing” is applied to ORM-oriented processes so
    that connection and transaction resources have a definitive boundary, and so that
    transactions can be explicitly rolled back if any failure conditions occur.
  prefs: []
  type: TYPE_NORMAL
- en: This does not mean there should be try/except blocks throughout an application,
    which would not be a scalable architecture. Instead, a typical approach is that
    when ORM-oriented methods and functions are first called, the process that’s calling
    the functions from the very top would be within a block that commits transactions
    at the successful completion of a series of operations, as well as rolls transactions
    back if operations fail for any reason, including failed flushes. There are also
    approaches using function decorators or context managers to achieve similar results.
    The kind of approach taken depends very much on the kind of application being
    written.
  prefs: []
  type: TYPE_NORMAL
- en: For a detailed discussion on how to organize usage of the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), please see [When do I construct a Session, when do
    I commit it, and when do I close it?](../orm/session_basics.html#session-faq-whentocreate).
  prefs: []
  type: TYPE_NORMAL
- en: But why does flush() insist on issuing a ROLLBACK?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It would be great if [`Session.flush()`](../orm/session_api.html#sqlalchemy.orm.Session.flush
    "sqlalchemy.orm.Session.flush") could partially complete and then not roll back,
    however this is beyond its current capabilities since its internal bookkeeping
    would have to be modified such that it can be halted at any time and be exactly
    consistent with what’s been flushed to the database. While this is theoretically
    possible, the usefulness of the enhancement is greatly decreased by the fact that
    many database operations require a ROLLBACK in any case. Postgres in particular
    has operations which, once failed, the transaction is not allowed to continue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: What SQLAlchemy offers that solves both issues is support of SAVEPOINT, via
    [`Session.begin_nested()`](../orm/session_api.html#sqlalchemy.orm.Session.begin_nested
    "sqlalchemy.orm.Session.begin_nested"). Using [`Session.begin_nested()`](../orm/session_api.html#sqlalchemy.orm.Session.begin_nested
    "sqlalchemy.orm.Session.begin_nested"), you can frame an operation that may potentially
    fail within a transaction, and then “roll back” to the point before its failure
    while maintaining the enclosing transaction.
  prefs: []
  type: TYPE_NORMAL
- en: But why isn’t the one automatic call to ROLLBACK enough? Why must I ROLLBACK
    again?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The rollback that’s caused by the flush() is not the end of the complete transaction
    block; while it ends the database transaction in play, from the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") point of view there is still a transaction that is now
    in an inactive state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given a block such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Above, when a [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    is first created, assuming “autocommit mode” isn’t used, a logical transaction
    is established within the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"). This transaction is “logical” in that it does not actually
    use any database resources until a SQL statement is invoked, at which point a
    connection-level and DBAPI-level transaction is started. However, whether or not
    database-level transactions are part of its state, the logical transaction will
    stay in place until it is ended using [`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit"), [`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback"), or [`Session.close()`](../orm/session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close").
  prefs: []
  type: TYPE_NORMAL
- en: When the `flush()` above fails, the code is still within the transaction framed
    by the try/commit/except/rollback block. If `flush()` were to fully roll back
    the logical transaction, it would mean that when we then reach the `except:` block
    the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    would be in a clean state, ready to emit new SQL on an all new transaction, and
    the call to [`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") would be out of sequence. In particular, the
    [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    would have begun a new transaction by this point, which the [`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") would be acting upon erroneously. Rather than
    allowing SQL operations to proceed on a new transaction in this place where normal
    usage dictates a rollback is about to take place, the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") instead refuses to continue until the explicit rollback
    actually occurs.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, it is expected that the calling code will **always** call [`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit"), [`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback"), or [`Session.close()`](../orm/session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") to correspond to the current transaction block.
    `flush()` keeps the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") within this transaction block so that the behavior of
    the above code is predictable and consistent.
  prefs: []
  type: TYPE_NORMAL
- en: But why does flush() insist on issuing a ROLLBACK?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It would be great if [`Session.flush()`](../orm/session_api.html#sqlalchemy.orm.Session.flush
    "sqlalchemy.orm.Session.flush") could partially complete and then not roll back,
    however this is beyond its current capabilities since its internal bookkeeping
    would have to be modified such that it can be halted at any time and be exactly
    consistent with what’s been flushed to the database. While this is theoretically
    possible, the usefulness of the enhancement is greatly decreased by the fact that
    many database operations require a ROLLBACK in any case. Postgres in particular
    has operations which, once failed, the transaction is not allowed to continue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: What SQLAlchemy offers that solves both issues is support of SAVEPOINT, via
    [`Session.begin_nested()`](../orm/session_api.html#sqlalchemy.orm.Session.begin_nested
    "sqlalchemy.orm.Session.begin_nested"). Using [`Session.begin_nested()`](../orm/session_api.html#sqlalchemy.orm.Session.begin_nested
    "sqlalchemy.orm.Session.begin_nested"), you can frame an operation that may potentially
    fail within a transaction, and then “roll back” to the point before its failure
    while maintaining the enclosing transaction.
  prefs: []
  type: TYPE_NORMAL
- en: But why isn’t the one automatic call to ROLLBACK enough? Why must I ROLLBACK
    again?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The rollback that’s caused by the flush() is not the end of the complete transaction
    block; while it ends the database transaction in play, from the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") point of view there is still a transaction that is now
    in an inactive state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given a block such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Above, when a [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    is first created, assuming “autocommit mode” isn’t used, a logical transaction
    is established within the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"). This transaction is “logical” in that it does not actually
    use any database resources until a SQL statement is invoked, at which point a
    connection-level and DBAPI-level transaction is started. However, whether or not
    database-level transactions are part of its state, the logical transaction will
    stay in place until it is ended using [`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit"), [`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback"), or [`Session.close()`](../orm/session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close").
  prefs: []
  type: TYPE_NORMAL
- en: When the `flush()` above fails, the code is still within the transaction framed
    by the try/commit/except/rollback block. If `flush()` were to fully roll back
    the logical transaction, it would mean that when we then reach the `except:` block
    the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    would be in a clean state, ready to emit new SQL on an all new transaction, and
    the call to [`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") would be out of sequence. In particular, the
    [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    would have begun a new transaction by this point, which the [`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") would be acting upon erroneously. Rather than
    allowing SQL operations to proceed on a new transaction in this place where normal
    usage dictates a rollback is about to take place, the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") instead refuses to continue until the explicit rollback
    actually occurs.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, it is expected that the calling code will **always** call [`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit"), [`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback"), or [`Session.close()`](../orm/session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") to correspond to the current transaction block.
    `flush()` keeps the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") within this transaction block so that the behavior of
    the above code is predictable and consistent.
  prefs: []
  type: TYPE_NORMAL
- en: How do I make a Query that always adds a certain filter to every query?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See the recipe at [FilteredQuery](https://www.sqlalchemy.org/trac/wiki/UsageRecipes/FilteredQuery).
  prefs: []
  type: TYPE_NORMAL
- en: '## My Query does not return the same number of objects as query.count() tells
    me - why?'
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    object, when asked to return a list of ORM-mapped objects, will **deduplicate
    the objects based on primary key**. That is, if we for example use the `User`
    mapping described at [Using ORM Declarative Forms to Define Table Metadata](../tutorial/metadata.html#tutorial-orm-table-metadata),
    and we had a SQL query like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Above, the sample data used in the tutorial has two rows in the `addresses`
    table for the `users` row with the name `''jack''`, primary key value 5. If we
    ask the above query for a [`Query.count()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.count
    "sqlalchemy.orm.Query.count"), we will get the answer **2**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if we run [`Query.all()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.all
    "sqlalchemy.orm.Query.all") or iterate over the query, we get back **one element**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This is because when the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object returns full entities, they are **deduplicated**.
    This does not occur if we instead request individual columns back:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two main reasons the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") will deduplicate:'
  prefs: []
  type: TYPE_NORMAL
- en: '**To allow joined eager loading to work correctly** - [Joined Eager Loading](../orm/queryguide/relationships.html#joined-eager-loading)
    works by querying rows using joins against related tables, where it then routes
    rows from those joins into collections upon the lead objects. In order to do this,
    it has to fetch rows where the lead object primary key is repeated for each sub-entry.
    This pattern can then continue into further sub-collections such that a multiple
    of rows may be processed for a single lead object, such as `User(id=5)`. The dedpulication
    allows us to receive objects in the way they were queried, e.g. all the `User()`
    objects whose name is `''jack''` which for us is one object, with the `User.addresses`
    collection eagerly loaded as was indicated either by `lazy=''joined''` on the
    [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")
    or via the [`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload") option. For consistency, the deduplication is still
    applied whether or not the joinedload is established, as the key philosophy behind
    eager loading is that these options never affect the result.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**To eliminate confusion regarding the identity map** - this is admittedly
    the less critical reason. As the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") makes use of an [identity map](../glossary.html#term-identity-map),
    even though our SQL result set has two rows with primary key 5, there is only
    one `User(id=5)` object inside the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") which must be maintained uniquely on its identity, that
    is, its primary key / class combination. It doesn’t actually make much sense,
    if one is querying for `User()` objects, to get the same object multiple times
    in the list. An ordered set would potentially be a better representation of what
    [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    seeks to return when it returns full objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The issue of [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    deduplication remains problematic, mostly for the single reason that the [`Query.count()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.count
    "sqlalchemy.orm.Query.count") method is inconsistent, and the current status is
    that joined eager loading has in recent releases been superseded first by the
    “subquery eager loading” strategy and more recently the “select IN eager loading”
    strategy, both of which are generally more appropriate for collection eager loading.
    As this evolution continues, SQLAlchemy may alter this behavior on [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query"), which may also involve new APIs in order to more directly
    control this behavior, and may also alter the behavior of joined eager loading
    in order to create a more consistent usage pattern.
  prefs: []
  type: TYPE_NORMAL
- en: I’ve created a mapping against an Outer Join, and while the query returns rows,
    no objects are returned. Why not?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Rows returned by an outer join may contain NULL for part of the primary key,
    as the primary key is the composite of both tables. The [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object ignores incoming rows that don’t have an acceptable
    primary key. Based on the setting of the `allow_partial_pks` flag on [`Mapper`](../orm/mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper"), a primary key is accepted if the value has at least
    one non-NULL value, or alternatively if the value has no NULL values. See `allow_partial_pks`
    at [`Mapper`](../orm/mapping_api.html#sqlalchemy.orm.Mapper "sqlalchemy.orm.Mapper").
  prefs: []
  type: TYPE_NORMAL
- en: I’m using `joinedload()` or `lazy=False` to create a JOIN/OUTER JOIN and SQLAlchemy
    is not constructing the correct query when I try to add a WHERE, ORDER BY, LIMIT,
    etc. (which relies upon the (OUTER) JOIN)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The joins generated by joined eager loading are only used to fully load related
    collections, and are designed to have no impact on the primary results of the
    query. Since they are anonymously aliased, they cannot be referenced directly.
  prefs: []
  type: TYPE_NORMAL
- en: For detail on this behavior, see [The Zen of Joined Eager Loading](../orm/queryguide/relationships.html#zen-of-eager-loading).
  prefs: []
  type: TYPE_NORMAL
- en: Query has no `__len__()`, why not?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Python `__len__()` magic method applied to an object allows the `len()`
    builtin to be used to determine the length of the collection. It’s intuitive that
    a SQL query object would link `__len__()` to the [`Query.count()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.count
    "sqlalchemy.orm.Query.count") method, which emits a SELECT COUNT. The reason this
    is not possible is because evaluating the query as a list would incur two SQL
    calls instead of one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: How Do I use Textual SQL with ORM Queries?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'See:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Getting ORM Results from Textual Statements](../orm/queryguide/select.html#orm-queryguide-selecting-text)
    - Ad-hoc textual blocks with [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Using SQL Expressions with Sessions](../orm/persistence_techniques.html#session-sql-expressions)
    - Using [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    with textual SQL directly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I’m calling `Session.delete(myobject)` and it isn’t removed from the parent
    collection!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See [Notes on Delete - Deleting Objects Referenced from Collections and Scalar
    Relationships](../orm/cascades.html#session-deleting-from-collections) for a description
    of this behavior.
  prefs: []
  type: TYPE_NORMAL
- en: why isn’t my `__init__()` called when I load objects?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: See [Maintaining Non-Mapped State Across Loads](../orm/mapping_styles.html#mapped-class-load-events)
    for a description of this behavior.
  prefs: []
  type: TYPE_NORMAL
- en: how do I use ON DELETE CASCADE with SA’s ORM?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SQLAlchemy will always issue UPDATE or DELETE statements for dependent rows
    which are currently loaded in the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"). For rows which are not loaded, it will by default issue
    SELECT statements to load those rows and update/delete those as well; in other
    words it assumes there is no ON DELETE CASCADE configured. To configure SQLAlchemy
    to cooperate with ON DELETE CASCADE, see [Using foreign key ON DELETE cascade
    with ORM relationships](../orm/cascades.html#passive-deletes).
  prefs: []
  type: TYPE_NORMAL
- en: 'I set the “foo_id” attribute on my instance to “7”, but the “foo” attribute
    is still `None` - shouldn’t it have loaded Foo with id #7?'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The ORM is not constructed in such a way as to support immediate population
    of relationships driven from foreign key attribute changes - instead, it is designed
    to work the other way around - foreign key attributes are handled by the ORM behind
    the scenes, the end user sets up object relationships naturally. Therefore, the
    recommended way to set `o.foo` is to do just that - set it!:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Manipulation of foreign key attributes is of course entirely legal. However,
    setting a foreign-key attribute to a new value currently does not trigger an “expire”
    event of the [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") in which it’s involved. This means that for the
    following sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '`o.foo` is loaded with its effective database value of `None` when it is first
    accessed. Setting `o.foo_id = 7` will have the value of “7” as a pending change,
    but no flush has occurred - so `o.foo` is still `None`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'For `o.foo` to load based on the foreign key mutation is usually achieved naturally
    after the commit, which both flushes the new foreign key value and expires all
    state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'A more minimal operation is to expire the attribute individually - this can
    be performed for any [persistent](../glossary.html#term-persistent) object using
    [`Session.expire()`](../orm/session_api.html#sqlalchemy.orm.Session.expire "sqlalchemy.orm.Session.expire"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that if the object is not persistent but present in the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), it’s known as [pending](../glossary.html#term-pending).
    This means the row for the object has not been INSERTed into the database yet.
    For such an object, setting `foo_id` does not have meaning until the row is inserted;
    otherwise there is no row yet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The recipe [ExpireRelationshipOnFKChange](https://www.sqlalchemy.org/trac/wiki/UsageRecipes/ExpireRelationshipOnFKChange)
    features an example using SQLAlchemy events in order to coordinate the setting
    of foreign key attributes with many-to-one relationships.
  prefs: []
  type: TYPE_NORMAL
- en: '## How do I walk all objects that are related to a given object?'
  prefs: []
  type: TYPE_NORMAL
- en: 'An object that has other objects related to it will correspond to the [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") constructs set up between mappers. This code fragment
    will iterate all the objects, correcting for cycles as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The function can be demonstrated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Is there a way to automagically have only unique keywords (or other kinds of
    objects) without doing a query for the keyword and getting a reference to the
    row containing that keyword?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When people read the many-to-many example in the docs, they get hit with the
    fact that if you create the same `Keyword` twice, it gets put in the DB twice.
    Which is somewhat inconvenient.
  prefs: []
  type: TYPE_NORMAL
- en: This [UniqueObject](https://www.sqlalchemy.org/trac/wiki/UsageRecipes/UniqueObject)
    recipe was created to address this issue.
  prefs: []
  type: TYPE_NORMAL
- en: '## Why does post_update emit UPDATE in addition to the first UPDATE?'
  prefs: []
  type: TYPE_NORMAL
- en: The post_update feature, documented at [Rows that point to themselves / Mutually
    Dependent Rows](../orm/relationship_persistence.html#post-update), involves that
    an UPDATE statement is emitted in response to changes to a particular relationship-bound
    foreign key, in addition to the INSERT/UPDATE/DELETE that would normally be emitted
    for the target row. While the primary purpose of this UPDATE statement is that
    it pairs up with an INSERT or DELETE of that row, so that it can post-set or pre-unset
    a foreign key reference in order to break a cycle with a mutually dependent foreign
    key, it currently is also bundled as a second UPDATE that emits when the target
    row itself is subject to an UPDATE. In this case, the UPDATE emitted by post_update
    is *usually* unnecessary and will often appear wasteful.
  prefs: []
  type: TYPE_NORMAL
- en: However, some research into trying to remove this “UPDATE / UPDATE” behavior
    reveals that major changes to the unit of work process would need to occur not
    just throughout the post_update implementation, but also in areas that aren’t
    related to post_update for this to work, in that the order of operations would
    need to be reversed on the non-post_update side in some cases, which in turn can
    impact other cases, such as correctly handling an UPDATE of a referenced primary
    key value (see [#1063](https://www.sqlalchemy.org/trac/ticket/1063) for a proof
    of concept).
  prefs: []
  type: TYPE_NORMAL
- en: The answer is that “post_update” is used to break a cycle between two mutually
    dependent foreign keys, and to have this cycle breaking be limited to just INSERT/DELETE
    of the target table implies that the ordering of UPDATE statements elsewhere would
    need to be liberalized, leading to breakage in other edge cases.
  prefs: []
  type: TYPE_NORMAL
