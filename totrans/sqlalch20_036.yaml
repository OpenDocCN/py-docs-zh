- en: Working with Large Collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.sqlalchemy.org/en/20/orm/large_collections.html](https://docs.sqlalchemy.org/en/20/orm/large_collections.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The default behavior of [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") is to fully load the contents of collections into
    memory, based on a configured [loader strategy](queryguide/relationships.html#orm-queryguide-relationship-loaders)
    that controls when and how these contents are loaded from the database. Related
    collections may be loaded into memory not just when they are accessed, or eagerly
    loaded, but in most cases will require population when the collection itself is
    mutated, as well as in cases where the owning object is to be deleted by the unit
    of work system.
  prefs: []
  type: TYPE_NORMAL
- en: When a related collection is potentially very large, it may not be feasible
    for such a collection to be populated into memory under any circumstances, as
    the operation may be overly consuming of time, network and memory resources.
  prefs: []
  type: TYPE_NORMAL
- en: This section includes API features intended to allow [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") to be used with large collections while maintaining
    adequate performance.
  prefs: []
  type: TYPE_NORMAL
- en: '## Write Only Relationships'
  prefs: []
  type: TYPE_NORMAL
- en: 'The **write only** loader strategy is the primary means of configuring a [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") that will remain writeable, but will not load its
    contents into memory. A write-only ORM configuration in modern type-annotated
    Declarative form is illustrated below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Above, the `account_transactions` relationship is configured not using the ordinary
    [`Mapped`](internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped") annotation,
    but instead using the [`WriteOnlyMapped`](#sqlalchemy.orm.WriteOnlyMapped "sqlalchemy.orm.WriteOnlyMapped")
    type annotation, which at runtime will assign the [loader strategy](queryguide/relationships.html#orm-queryguide-relationship-loaders)
    of `lazy="write_only"` to the target [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship"). The [`WriteOnlyMapped`](#sqlalchemy.orm.WriteOnlyMapped
    "sqlalchemy.orm.WriteOnlyMapped") annotation is an alternative form of the [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") annotation which indicate the use of the [`WriteOnlyCollection`](#sqlalchemy.orm.WriteOnlyCollection
    "sqlalchemy.orm.WriteOnlyCollection") collection type on instances of the object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The above [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") configuration also includes several elements that
    are specific to what action to take when `Account` objects are deleted, as well
    as when `AccountTransaction` objects are removed from the `account_transactions`
    collection. These elements are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`passive_deletes=True` - allows the [unit of work](../glossary.html#term-unit-of-work)
    to forego having to load the collection when `Account` is deleted; see [Using
    foreign key ON DELETE cascade with ORM relationships](cascades.html#passive-deletes).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ondelete="cascade"` configured on the [`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey") constraint. This is also detailed at [Using foreign
    key ON DELETE cascade with ORM relationships](cascades.html#passive-deletes).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cascade="all, delete-orphan"` - instructs the [unit of work](../glossary.html#term-unit-of-work)
    to delete `AccountTransaction` objects when they are removed from the collection.
    See [delete-orphan](cascades.html#cascade-delete-orphan) in the [Cascades](cascades.html#unitofwork-cascades)
    document.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'New in version 2.0: Added “Write only” relationship loaders.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating and Persisting New Write Only Collections
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The write-only collection allows for direct assignment of the collection as
    a whole **only** for [transient](../glossary.html#term-transient) or [pending](../glossary.html#term-pending)
    objects. With our above mapping, this indicates we can create a new `Account`
    object with a sequence of `AccountTransaction` objects to be added to a [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"). Any Python iterable may be used as the source of objects
    to start, where below we use a Python `list`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Once an object is database-persisted (i.e. in the [persistent](../glossary.html#term-persistent)
    or [detached](../glossary.html#term-detached) state), the collection has the ability
    to be extended with new items as well as the ability for individual items to be
    removed. However, the collection may **no longer be re-assigned with a full replacement
    collection**, as such an operation requires that the previous collection is fully
    loaded into memory in order to reconcile the old entries with the new ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Adding New Items to an Existing Collection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For write-only collections of persistent objects, modifications to the collection
    using [unit of work](../glossary.html#term-unit-of-work) processes may proceed
    only by using the [`WriteOnlyCollection.add()`](#sqlalchemy.orm.WriteOnlyCollection.add
    "sqlalchemy.orm.WriteOnlyCollection.add"), [`WriteOnlyCollection.add_all()`](#sqlalchemy.orm.WriteOnlyCollection.add_all
    "sqlalchemy.orm.WriteOnlyCollection.add_all") and [`WriteOnlyCollection.remove()`](#sqlalchemy.orm.WriteOnlyCollection.remove
    "sqlalchemy.orm.WriteOnlyCollection.remove") methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The items added above are held in a pending queue within the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") until the next flush, at which point they are INSERTed
    into the database, assuming the added objects were previously [transient](../glossary.html#term-transient).
  prefs: []
  type: TYPE_NORMAL
- en: Querying Items
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The [`WriteOnlyCollection`](#sqlalchemy.orm.WriteOnlyCollection "sqlalchemy.orm.WriteOnlyCollection")
    does not at any point store a reference to the current contents of the collection,
    nor does it have any behavior where it would directly emit a SELECT to the database
    in order to load them; the overriding assumption is that the collection may contain
    many thousands or millions of rows, and should never be fully loaded into memory
    as a side effect of any other operation.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, the [`WriteOnlyCollection`](#sqlalchemy.orm.WriteOnlyCollection "sqlalchemy.orm.WriteOnlyCollection")
    includes SQL-generating helpers such as [`WriteOnlyCollection.select()`](#sqlalchemy.orm.WriteOnlyCollection.select
    "sqlalchemy.orm.WriteOnlyCollection.select"), which will generate a [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") construct pre-configured with the correct
    WHERE / FROM criteria for the current parent row, which can then be further modified
    in order to SELECT any range of rows desired, as well as invoked using features
    like [server side cursors](queryguide/api.html#orm-queryguide-yield-per) for processes
    that wish to iterate through the full collection in a memory-efficient manner.
  prefs: []
  type: TYPE_NORMAL
- en: 'The statement generated is illustrated below. Note it also includes ORDER BY
    criteria, indicated in the example mapping by the [`relationship.order_by`](relationship_api.html#sqlalchemy.orm.relationship.params.order_by
    "sqlalchemy.orm.relationship") parameter of [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship"); this criteria would be omitted if the parameter
    were not configured:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We may use this [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") construct along with the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") in order to query for `AccountTransaction` objects,
    most easily using the [`Session.scalars()`](session_api.html#sqlalchemy.orm.Session.scalars
    "sqlalchemy.orm.Session.scalars") method that will return a [`Result`](../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") that yields ORM objects directly. It’s typical, though
    not required, that the [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") would be modified further to limit the records
    returned; in the example below, additional WHERE criteria to load only “debit”
    account transactions is added, along with “LIMIT 10” to retrieve only the first
    ten rows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Removing Items
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Individual items that are loaded in the [persistent](../glossary.html#term-persistent)
    state against the current [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") may be marked for removal from the collection using
    the [`WriteOnlyCollection.remove()`](#sqlalchemy.orm.WriteOnlyCollection.remove
    "sqlalchemy.orm.WriteOnlyCollection.remove") method. The flush process will implicitly
    consider the object to be already part of the collection when the operation proceeds.
    The example below illustrates removal of an individual `AccountTransaction` item,
    which per [cascade](cascades.html#unitofwork-cascades) settings results in a DELETE
    of that row:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As with any ORM-mapped collection, object removal may proceed either to de-associate
    the object from the collection while leaving the object present in the database,
    or may issue a DELETE for its row, based on the [delete-orphan](cascades.html#cascade-delete-orphan)
    configuration of the [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship").
  prefs: []
  type: TYPE_NORMAL
- en: Collection removal without deletion involves setting foreign key columns to
    NULL for a [one-to-many](basic_relationships.html#relationship-patterns-o2m) relationship,
    or deleting the corresponding association row for a [many-to-many](basic_relationships.html#relationships-many-to-many)
    relationship.
  prefs: []
  type: TYPE_NORMAL
- en: Bulk INSERT of New Items
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The [`WriteOnlyCollection`](#sqlalchemy.orm.WriteOnlyCollection "sqlalchemy.orm.WriteOnlyCollection")
    can generate DML constructs such as [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") objects, which may be used in an ORM context
    to produce bulk insert behavior. See the section [ORM Bulk INSERT Statements](queryguide/dml.html#orm-queryguide-bulk-insert)
    for an overview of ORM bulk inserts.
  prefs: []
  type: TYPE_NORMAL
- en: One to Many Collections
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'For a **regular one to many collection only**, the [`WriteOnlyCollection.insert()`](#sqlalchemy.orm.WriteOnlyCollection.insert
    "sqlalchemy.orm.WriteOnlyCollection.insert") method will produce an [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") construct which is pre-established with VALUES
    criteria corresponding to the parent object. As this VALUES criteria is entirely
    against the related table, the statement can be used to INSERT new rows that will
    at the same time become new records in the related collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[ORM Bulk INSERT Statements](queryguide/dml.html#orm-queryguide-bulk-insert)
    - in the [ORM Querying Guide](queryguide/index.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[One To Many](basic_relationships.html#relationship-patterns-o2m) - at [Basic
    Relationship Patterns](basic_relationships.html#relationship-patterns)'
  prefs: []
  type: TYPE_NORMAL
- en: Many to Many Collections
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For a **many to many collection**, the relationship between two classes involves
    a third table that is configured using the [`relationship.secondary`](relationship_api.html#sqlalchemy.orm.relationship.params.secondary
    "sqlalchemy.orm.relationship") parameter of [`relationship`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship"). To bulk insert rows into a collection of this
    type using [`WriteOnlyCollection`](#sqlalchemy.orm.WriteOnlyCollection "sqlalchemy.orm.WriteOnlyCollection"),
    the new records may be bulk-inserted separately first, retrieved using RETURNING,
    and those records then passed to the [`WriteOnlyCollection.add_all()`](#sqlalchemy.orm.WriteOnlyCollection.add_all
    "sqlalchemy.orm.WriteOnlyCollection.add_all") method where the unit of work process
    will proceed to persist them as part of the collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Supposing a class `BankAudit` referred to many `AccountTransaction` records
    using a many-to-many table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'To illustrate the two operations, we add more `AccountTransaction` objects
    using bulk insert, which we retrieve using RETURNING by adding `returning(AccountTransaction)`
    to the bulk INSERT statement (note that we could just as easily use existing `AccountTransaction`
    objects as well):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'With a list of `AccountTransaction` objects ready, the [`WriteOnlyCollection.add_all()`](#sqlalchemy.orm.WriteOnlyCollection.add_all
    "sqlalchemy.orm.WriteOnlyCollection.add_all") method is used to associate many
    rows at once with a new `BankAudit` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[ORM Bulk INSERT Statements](queryguide/dml.html#orm-queryguide-bulk-insert)
    - in the [ORM Querying Guide](queryguide/index.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Many To Many](basic_relationships.html#relationships-many-to-many) - at [Basic
    Relationship Patterns](basic_relationships.html#relationship-patterns)'
  prefs: []
  type: TYPE_NORMAL
- en: Bulk UPDATE and DELETE of Items
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In a similar way in which [`WriteOnlyCollection`](#sqlalchemy.orm.WriteOnlyCollection
    "sqlalchemy.orm.WriteOnlyCollection") can generate [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") constructs with WHERE criteria pre-established,
    it can also generate [`Update`](../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update") and [`Delete`](../core/dml.html#sqlalchemy.sql.expression.Delete
    "sqlalchemy.sql.expression.Delete") constructs with that same WHERE criteria,
    to allow criteria-oriented UPDATE and DELETE statements against the elements in
    a large collection.
  prefs: []
  type: TYPE_NORMAL
- en: One To Many Collections
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As is the case with INSERT, this feature is most straightforward with **one
    to many collections**.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the example below, the [`WriteOnlyCollection.update()`](#sqlalchemy.orm.WriteOnlyCollection.update
    "sqlalchemy.orm.WriteOnlyCollection.update") method is used to generate an UPDATE
    statement is emitted against the elements in the collection, locating rows where
    the “amount” is equal to `-800` and adding the amount of `200` to them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In a similar way, [`WriteOnlyCollection.delete()`](#sqlalchemy.orm.WriteOnlyCollection.delete
    "sqlalchemy.orm.WriteOnlyCollection.delete") will produce a DELETE statement that
    is invoked in the same way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Many to Many Collections
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: The techniques here involve multi-table UPDATE expressions, which are slightly
    more advanced.
  prefs: []
  type: TYPE_NORMAL
- en: For bulk UPDATE and DELETE of **many to many collections**, in order for an
    UPDATE or DELETE statement to relate to the primary key of the parent object,
    the association table must be explicitly part of the UPDATE/DELETE statement,
    which requires either that the backend includes supports for non-standard SQL
    syntaxes, or extra explicit steps when constructing the UPDATE or DELETE statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'For backends that support multi-table versions of UPDATE, the [`WriteOnlyCollection.update()`](#sqlalchemy.orm.WriteOnlyCollection.update
    "sqlalchemy.orm.WriteOnlyCollection.update") method should work without extra
    steps for a many-to-many collection, as in the example below where an UPDATE is
    emitted against `AccountTransaction` objects in terms of the many-to-many `BankAudit.account_transactions`
    collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The above statement automatically makes use of “UPDATE..FROM” syntax, supported
    by SQLite and others, to name the additional `audit_transaction` table in the
    WHERE clause.
  prefs: []
  type: TYPE_NORMAL
- en: 'To UPDATE or DELETE a many-to-many collection where multi-table syntax is not
    available, the many-to-many criteria may be moved into SELECT that for example
    may be combined with IN to match rows. The [`WriteOnlyCollection`](#sqlalchemy.orm.WriteOnlyCollection
    "sqlalchemy.orm.WriteOnlyCollection") still helps us here, as we use the [`WriteOnlyCollection.select()`](#sqlalchemy.orm.WriteOnlyCollection.select
    "sqlalchemy.orm.WriteOnlyCollection.select") method to generate this SELECT for
    us, making use of the [`Select.with_only_columns()`](../core/selectable.html#sqlalchemy.sql.expression.Select.with_only_columns
    "sqlalchemy.sql.expression.Select.with_only_columns") method to produce a [scalar
    subquery](../glossary.html#term-scalar-subquery):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Write Only Collections - API Documentation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '| Object Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| [WriteOnlyCollection](#sqlalchemy.orm.WriteOnlyCollection) | Write-only collection
    which can synchronize changes into the attribute event system. |'
  prefs: []
  type: TYPE_TB
- en: '| [WriteOnlyMapped](#sqlalchemy.orm.WriteOnlyMapped) | Represent the ORM mapped
    attribute type for a “write only” relationship. |'
  prefs: []
  type: TYPE_TB
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Write-only collection which can synchronize changes into the attribute event
    system.
  prefs: []
  type: TYPE_NORMAL
- en: The [`WriteOnlyCollection`](#sqlalchemy.orm.WriteOnlyCollection "sqlalchemy.orm.WriteOnlyCollection")
    is used in a mapping by using the `"write_only"` lazy loading strategy with [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship"). For background on this configuration, see [Write
    Only Relationships](#write-only-relationship).
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Write Only Relationships](#write-only-relationship)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[add()](#sqlalchemy.orm.WriteOnlyCollection.add), [add_all()](#sqlalchemy.orm.WriteOnlyCollection.add_all),
    [delete()](#sqlalchemy.orm.WriteOnlyCollection.delete), [insert()](#sqlalchemy.orm.WriteOnlyCollection.insert),
    [remove()](#sqlalchemy.orm.WriteOnlyCollection.remove), [select()](#sqlalchemy.orm.WriteOnlyCollection.select),
    [update()](#sqlalchemy.orm.WriteOnlyCollection.update)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.orm.WriteOnlyCollection`](#sqlalchemy.orm.WriteOnlyCollection
    "sqlalchemy.orm.WriteOnlyCollection") (`sqlalchemy.orm.writeonly.AbstractCollectionWriter`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Add an item to this [`WriteOnlyCollection`](#sqlalchemy.orm.WriteOnlyCollection
    "sqlalchemy.orm.WriteOnlyCollection").
  prefs: []
  type: TYPE_NORMAL
- en: The given item will be persisted to the database in terms of the parent instance’s
    collection on the next flush.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Add an iterable of items to this [`WriteOnlyCollection`](#sqlalchemy.orm.WriteOnlyCollection
    "sqlalchemy.orm.WriteOnlyCollection").
  prefs: []
  type: TYPE_NORMAL
- en: The given items will be persisted to the database in terms of the parent instance’s
    collection on the next flush.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Produce a [`Delete`](../core/dml.html#sqlalchemy.sql.expression.Delete "sqlalchemy.sql.expression.Delete")
    which will refer to rows in terms of this instance-local [`WriteOnlyCollection`](#sqlalchemy.orm.WriteOnlyCollection
    "sqlalchemy.orm.WriteOnlyCollection").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: For one-to-many collections, produce a [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") which will insert new rows in terms of this
    this instance-local [`WriteOnlyCollection`](#sqlalchemy.orm.WriteOnlyCollection
    "sqlalchemy.orm.WriteOnlyCollection").
  prefs: []
  type: TYPE_NORMAL
- en: This construct is only supported for a [`Relationship`](internals.html#sqlalchemy.orm.Relationship
    "sqlalchemy.orm.Relationship") that does **not** include the [`relationship.secondary`](relationship_api.html#sqlalchemy.orm.relationship.params.secondary
    "sqlalchemy.orm.relationship") parameter. For relationships that refer to a many-to-many
    table, use ordinary bulk insert techniques to produce new objects, then use `AbstractCollectionWriter.add_all()`
    to associate them with the collection.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Remove an item from this [`WriteOnlyCollection`](#sqlalchemy.orm.WriteOnlyCollection
    "sqlalchemy.orm.WriteOnlyCollection").
  prefs: []
  type: TYPE_NORMAL
- en: The given item will be removed from the parent instance’s collection on the
    next flush.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Produce a [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") construct that represents the rows within
    this instance-local [`WriteOnlyCollection`](#sqlalchemy.orm.WriteOnlyCollection
    "sqlalchemy.orm.WriteOnlyCollection").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Produce a [`Update`](../core/dml.html#sqlalchemy.sql.expression.Update "sqlalchemy.sql.expression.Update")
    which will refer to rows in terms of this instance-local [`WriteOnlyCollection`](#sqlalchemy.orm.WriteOnlyCollection
    "sqlalchemy.orm.WriteOnlyCollection").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Represent the ORM mapped attribute type for a “write only” relationship.
  prefs: []
  type: TYPE_NORMAL
- en: The [`WriteOnlyMapped`](#sqlalchemy.orm.WriteOnlyMapped "sqlalchemy.orm.WriteOnlyMapped")
    type annotation may be used in an [Annotated Declarative Table](declarative_tables.html#orm-declarative-mapped-column)
    mapping to indicate that the `lazy="write_only"` loader strategy should be used
    for a particular [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship").
  prefs: []
  type: TYPE_NORMAL
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: See the section [Write Only Relationships](#write-only-relationship) for background.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Write Only Relationships](#write-only-relationship) - complete background'
  prefs: []
  type: TYPE_NORMAL
- en: '[`DynamicMapped`](#sqlalchemy.orm.DynamicMapped "sqlalchemy.orm.DynamicMapped")
    - includes legacy [`Query`](queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    support'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: 'class [`sqlalchemy.orm.WriteOnlyMapped`](#sqlalchemy.orm.WriteOnlyMapped "sqlalchemy.orm.WriteOnlyMapped")
    (`sqlalchemy.orm.base._MappedAnnotationBase`)  ## Dynamic Relationship Loaders'
  prefs: []
  type: TYPE_NORMAL
- en: Legacy Feature
  prefs: []
  type: TYPE_NORMAL
- en: The “dynamic” lazy loader strategy is the legacy form of what is now the “write_only”
    strategy described in the section [Write Only Relationships](#write-only-relationship).
  prefs: []
  type: TYPE_NORMAL
- en: The “dynamic” strategy produces a legacy [`Query`](queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object from the related collection. However, a major drawback
    of “dynamic” relationships is that there are several cases where the collection
    will fully iterate, some of which are non-obvious, which can only be prevented
    with careful programming and testing on a case-by-case basis. Therefore, for truly
    large collection management, the [`WriteOnlyCollection`](#sqlalchemy.orm.WriteOnlyCollection
    "sqlalchemy.orm.WriteOnlyCollection") should be preferred.
  prefs: []
  type: TYPE_NORMAL
- en: The dynamic loader is also not compatible with the [Asynchronous I/O (asyncio)](extensions/asyncio.html)
    extension. It can be used with some limitations, as indicated in [Asyncio dynamic
    guidelines](extensions/asyncio.html#dynamic-asyncio), but again the [`WriteOnlyCollection`](#sqlalchemy.orm.WriteOnlyCollection
    "sqlalchemy.orm.WriteOnlyCollection"), which is fully compatible with asyncio,
    should be preferred.
  prefs: []
  type: TYPE_NORMAL
- en: The dynamic relationship strategy allows configuration of a [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") which when accessed on an instance will return
    a legacy [`Query`](queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    object in place of the collection. The [`Query`](queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") can then be modified further so that the database collection
    may be iterated based on filtering criteria. The returned [`Query`](queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object is an instance of [`AppenderQuery`](#sqlalchemy.orm.AppenderQuery
    "sqlalchemy.orm.AppenderQuery"), which combines the loading and iteration behavior
    of [`Query`](queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    along with rudimentary collection mutation methods such as [`AppenderQuery.append()`](#sqlalchemy.orm.AppenderQuery.append
    "sqlalchemy.orm.AppenderQuery.append") and [`AppenderQuery.remove()`](#sqlalchemy.orm.AppenderQuery.remove
    "sqlalchemy.orm.AppenderQuery.remove").
  prefs: []
  type: TYPE_NORMAL
- en: 'The “dynamic” loader strategy may be configured with type-annotated Declarative
    form using the [`DynamicMapped`](#sqlalchemy.orm.DynamicMapped "sqlalchemy.orm.DynamicMapped")
    annotation class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Above, the `User.posts` collection on an individual `User` object will return
    the [`AppenderQuery`](#sqlalchemy.orm.AppenderQuery "sqlalchemy.orm.AppenderQuery")
    object, which is a subclass of [`Query`](queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") that also supports basic collection mutation operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The dynamic relationship supports limited write operations, via the [`AppenderQuery.append()`](#sqlalchemy.orm.AppenderQuery.append
    "sqlalchemy.orm.AppenderQuery.append") and [`AppenderQuery.remove()`](#sqlalchemy.orm.AppenderQuery.remove
    "sqlalchemy.orm.AppenderQuery.remove") methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Since the read side of the dynamic relationship always queries the database,
    changes to the underlying collection will not be visible until the data has been
    flushed. However, as long as “autoflush” is enabled on the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") in use, this will occur automatically each time the
    collection is about to emit a query.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic Relationship Loaders - API
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '| Object Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| [AppenderQuery](#sqlalchemy.orm.AppenderQuery) | A dynamic query that supports
    basic collection storage operations. |'
  prefs: []
  type: TYPE_TB
- en: '| [DynamicMapped](#sqlalchemy.orm.DynamicMapped) | Represent the ORM mapped
    attribute type for a “dynamic” relationship. |'
  prefs: []
  type: TYPE_TB
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: A dynamic query that supports basic collection storage operations.
  prefs: []
  type: TYPE_NORMAL
- en: Methods on [`AppenderQuery`](#sqlalchemy.orm.AppenderQuery "sqlalchemy.orm.AppenderQuery")
    include all methods of [`Query`](queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query"),
    plus additional methods used for collection persistence.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[add()](#sqlalchemy.orm.AppenderQuery.add), [add_all()](#sqlalchemy.orm.AppenderQuery.add_all),
    [append()](#sqlalchemy.orm.AppenderQuery.append), [count()](#sqlalchemy.orm.AppenderQuery.count),
    [extend()](#sqlalchemy.orm.AppenderQuery.extend), [remove()](#sqlalchemy.orm.AppenderQuery.remove)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.orm.AppenderQuery`](#sqlalchemy.orm.AppenderQuery "sqlalchemy.orm.AppenderQuery")
    (`sqlalchemy.orm.dynamic.AppenderMixin`, [`sqlalchemy.orm.Query`](queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `AppenderMixin.add()` *method of* `AppenderMixin`'
  prefs: []
  type: TYPE_NORMAL
- en: Add an item to this [`AppenderQuery`](#sqlalchemy.orm.AppenderQuery "sqlalchemy.orm.AppenderQuery").
  prefs: []
  type: TYPE_NORMAL
- en: The given item will be persisted to the database in terms of the parent instance’s
    collection on the next flush.
  prefs: []
  type: TYPE_NORMAL
- en: This method is provided to assist in delivering forwards-compatibility with
    the [`WriteOnlyCollection`](#sqlalchemy.orm.WriteOnlyCollection "sqlalchemy.orm.WriteOnlyCollection")
    collection class.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `AppenderMixin.add_all()` *method of* `AppenderMixin`'
  prefs: []
  type: TYPE_NORMAL
- en: Add an iterable of items to this [`AppenderQuery`](#sqlalchemy.orm.AppenderQuery
    "sqlalchemy.orm.AppenderQuery").
  prefs: []
  type: TYPE_NORMAL
- en: The given items will be persisted to the database in terms of the parent instance’s
    collection on the next flush.
  prefs: []
  type: TYPE_NORMAL
- en: This method is provided to assist in delivering forwards-compatibility with
    the [`WriteOnlyCollection`](#sqlalchemy.orm.WriteOnlyCollection "sqlalchemy.orm.WriteOnlyCollection")
    collection class.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `AppenderMixin.append()` *method of* `AppenderMixin`'
  prefs: []
  type: TYPE_NORMAL
- en: Append an item to this [`AppenderQuery`](#sqlalchemy.orm.AppenderQuery "sqlalchemy.orm.AppenderQuery").
  prefs: []
  type: TYPE_NORMAL
- en: The given item will be persisted to the database in terms of the parent instance’s
    collection on the next flush.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `AppenderMixin.count()` *method of* `AppenderMixin`'
  prefs: []
  type: TYPE_NORMAL
- en: Return a count of rows this the SQL formed by this [`Query`](queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") would return.
  prefs: []
  type: TYPE_NORMAL
- en: 'This generates the SQL for this Query as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The above SQL returns a single row, which is the aggregate value of the count
    function; the [`Query.count()`](queryguide/query.html#sqlalchemy.orm.Query.count
    "sqlalchemy.orm.Query.count") method then returns that single integer value.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that the value returned by count() is **not the same
    as the number of ORM objects that this Query would return from a method such as
    the .all() method**. The [`Query`](queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object, when asked to return full entities, will **deduplicate
    entries based on primary key**, meaning if the same primary key value would appear
    in the results more than once, only one object of that primary key would be present.
    This does not apply to a query that is against individual columns.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[My Query does not return the same number of objects as query.count() tells
    me - why?](../faq/sessions.html#faq-query-deduplicating)'
  prefs: []
  type: TYPE_NORMAL
- en: 'For fine grained control over specific columns to count, to skip the usage
    of a subquery or otherwise control of the FROM clause, or to use other aggregate
    functions, use [`expression.func`](../core/sqlelement.html#sqlalchemy.sql.expression.func
    "sqlalchemy.sql.expression.func") expressions in conjunction with [`Session.query()`](session_api.html#sqlalchemy.orm.Session.query
    "sqlalchemy.orm.Session.query"), i.e.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[2.0 Migration - ORM Usage](../changelog/migration_20.html#migration-20-query-usage)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `AppenderMixin.extend()` *method of* `AppenderMixin`'
  prefs: []
  type: TYPE_NORMAL
- en: Add an iterable of items to this [`AppenderQuery`](#sqlalchemy.orm.AppenderQuery
    "sqlalchemy.orm.AppenderQuery").
  prefs: []
  type: TYPE_NORMAL
- en: The given items will be persisted to the database in terms of the parent instance’s
    collection on the next flush.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `AppenderMixin.remove()` *method of* `AppenderMixin`'
  prefs: []
  type: TYPE_NORMAL
- en: Remove an item from this [`AppenderQuery`](#sqlalchemy.orm.AppenderQuery "sqlalchemy.orm.AppenderQuery").
  prefs: []
  type: TYPE_NORMAL
- en: The given item will be removed from the parent instance’s collection on the
    next flush.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Represent the ORM mapped attribute type for a “dynamic” relationship.
  prefs: []
  type: TYPE_NORMAL
- en: The [`DynamicMapped`](#sqlalchemy.orm.DynamicMapped "sqlalchemy.orm.DynamicMapped")
    type annotation may be used in an [Annotated Declarative Table](declarative_tables.html#orm-declarative-mapped-column)
    mapping to indicate that the `lazy="dynamic"` loader strategy should be used for
    a particular [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship").
  prefs: []
  type: TYPE_NORMAL
- en: Legacy Feature
  prefs: []
  type: TYPE_NORMAL
- en: The “dynamic” lazy loader strategy is the legacy form of what is now the “write_only”
    strategy described in the section [Write Only Relationships](#write-only-relationship).
  prefs: []
  type: TYPE_NORMAL
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: See the section [Dynamic Relationship Loaders](#dynamic-relationship) for background.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Dynamic Relationship Loaders](#dynamic-relationship) - complete background'
  prefs: []
  type: TYPE_NORMAL
- en: '[`WriteOnlyMapped`](#sqlalchemy.orm.WriteOnlyMapped "sqlalchemy.orm.WriteOnlyMapped")
    - fully 2.0 style version'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: 'class [`sqlalchemy.orm.DynamicMapped`](#sqlalchemy.orm.DynamicMapped "sqlalchemy.orm.DynamicMapped")
    (`sqlalchemy.orm.base._MappedAnnotationBase`)  ## Setting RaiseLoad'
  prefs: []
  type: TYPE_NORMAL
- en: 'A “raise”-loaded relationship will raise an [`InvalidRequestError`](../core/exceptions.html#sqlalchemy.exc.InvalidRequestError
    "sqlalchemy.exc.InvalidRequestError") where the attribute would normally emit
    a lazy load:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Above, attribute access on the `children` collection will raise an exception
    if it was not previously populated. This includes read access but for collections
    will also affect write access, as collections can’t be mutated without first loading
    them. The rationale for this is to ensure that an application is not emitting
    any unexpected lazy loads within a certain context. Rather than having to read
    through SQL logs to determine that all necessary attributes were eager loaded,
    the “raise” strategy will cause unloaded attributes to raise immediately if accessed.
    The raise strategy is also available on a query option basis using the [`raiseload()`](queryguide/relationships.html#sqlalchemy.orm.raiseload
    "sqlalchemy.orm.raiseload") loader option.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Preventing unwanted lazy loads using raiseload](queryguide/relationships.html#prevent-lazy-with-raiseload)'
  prefs: []
  type: TYPE_NORMAL
- en: Using Passive Deletes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An important aspect of collection management in SQLAlchemy is that when an object
    that refers to a collection is deleted, SQLAlchemy needs to consider the objects
    that are inside this collection. Those objects will need to be de-associated from
    the parent, which for a one-to-many collection would mean that foreign key columns
    are set to NULL, or based on [cascade](cascades.html#unitofwork-cascades) settings,
    may instead want to emit a DELETE for these rows.
  prefs: []
  type: TYPE_NORMAL
- en: The [unit of work](../glossary.html#term-unit-of-work) process only considers
    objects on a row-by-row basis, meaning a DELETE operation implies that all rows
    within a collection must be fully loaded into memory inside the flush process.
    This is not feasible for large collections, so we instead seek to rely upon the
    database’s own capability to update or delete the rows automatically using foreign
    key ON DELETE rules, instructing the unit of work to forego actually needing to
    load these rows in order to handle them. The unit of work can be instructed to
    work in this manner by configuring [`relationship.passive_deletes`](relationship_api.html#sqlalchemy.orm.relationship.params.passive_deletes
    "sqlalchemy.orm.relationship") on the [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") construct; the foreign key constraints in use must
    also be correctly configured.
  prefs: []
  type: TYPE_NORMAL
- en: For further detail on a complete “passive delete” configuration, see the section
    [Using foreign key ON DELETE cascade with ORM relationships](cascades.html#passive-deletes).
  prefs: []
  type: TYPE_NORMAL
- en: '## Write Only Relationships'
  prefs: []
  type: TYPE_NORMAL
- en: 'The **write only** loader strategy is the primary means of configuring a [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") that will remain writeable, but will not load its
    contents into memory. A write-only ORM configuration in modern type-annotated
    Declarative form is illustrated below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Above, the `account_transactions` relationship is configured not using the ordinary
    [`Mapped`](internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped") annotation,
    but instead using the [`WriteOnlyMapped`](#sqlalchemy.orm.WriteOnlyMapped "sqlalchemy.orm.WriteOnlyMapped")
    type annotation, which at runtime will assign the [loader strategy](queryguide/relationships.html#orm-queryguide-relationship-loaders)
    of `lazy="write_only"` to the target [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship"). The [`WriteOnlyMapped`](#sqlalchemy.orm.WriteOnlyMapped
    "sqlalchemy.orm.WriteOnlyMapped") annotation is an alternative form of the [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") annotation which indicate the use of the [`WriteOnlyCollection`](#sqlalchemy.orm.WriteOnlyCollection
    "sqlalchemy.orm.WriteOnlyCollection") collection type on instances of the object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The above [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") configuration also includes several elements that
    are specific to what action to take when `Account` objects are deleted, as well
    as when `AccountTransaction` objects are removed from the `account_transactions`
    collection. These elements are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`passive_deletes=True` - allows the [unit of work](../glossary.html#term-unit-of-work)
    to forego having to load the collection when `Account` is deleted; see [Using
    foreign key ON DELETE cascade with ORM relationships](cascades.html#passive-deletes).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ondelete="cascade"` configured on the [`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey") constraint. This is also detailed at [Using foreign
    key ON DELETE cascade with ORM relationships](cascades.html#passive-deletes).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cascade="all, delete-orphan"` - instructs the [unit of work](../glossary.html#term-unit-of-work)
    to delete `AccountTransaction` objects when they are removed from the collection.
    See [delete-orphan](cascades.html#cascade-delete-orphan) in the [Cascades](cascades.html#unitofwork-cascades)
    document.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'New in version 2.0: Added “Write only” relationship loaders.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating and Persisting New Write Only Collections
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The write-only collection allows for direct assignment of the collection as
    a whole **only** for [transient](../glossary.html#term-transient) or [pending](../glossary.html#term-pending)
    objects. With our above mapping, this indicates we can create a new `Account`
    object with a sequence of `AccountTransaction` objects to be added to a [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"). Any Python iterable may be used as the source of objects
    to start, where below we use a Python `list`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Once an object is database-persisted (i.e. in the [persistent](../glossary.html#term-persistent)
    or [detached](../glossary.html#term-detached) state), the collection has the ability
    to be extended with new items as well as the ability for individual items to be
    removed. However, the collection may **no longer be re-assigned with a full replacement
    collection**, as such an operation requires that the previous collection is fully
    loaded into memory in order to reconcile the old entries with the new ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Adding New Items to an Existing Collection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For write-only collections of persistent objects, modifications to the collection
    using [unit of work](../glossary.html#term-unit-of-work) processes may proceed
    only by using the [`WriteOnlyCollection.add()`](#sqlalchemy.orm.WriteOnlyCollection.add
    "sqlalchemy.orm.WriteOnlyCollection.add"), [`WriteOnlyCollection.add_all()`](#sqlalchemy.orm.WriteOnlyCollection.add_all
    "sqlalchemy.orm.WriteOnlyCollection.add_all") and [`WriteOnlyCollection.remove()`](#sqlalchemy.orm.WriteOnlyCollection.remove
    "sqlalchemy.orm.WriteOnlyCollection.remove") methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The items added above are held in a pending queue within the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") until the next flush, at which point they are INSERTed
    into the database, assuming the added objects were previously [transient](../glossary.html#term-transient).
  prefs: []
  type: TYPE_NORMAL
- en: Querying Items
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The [`WriteOnlyCollection`](#sqlalchemy.orm.WriteOnlyCollection "sqlalchemy.orm.WriteOnlyCollection")
    does not at any point store a reference to the current contents of the collection,
    nor does it have any behavior where it would directly emit a SELECT to the database
    in order to load them; the overriding assumption is that the collection may contain
    many thousands or millions of rows, and should never be fully loaded into memory
    as a side effect of any other operation.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, the [`WriteOnlyCollection`](#sqlalchemy.orm.WriteOnlyCollection "sqlalchemy.orm.WriteOnlyCollection")
    includes SQL-generating helpers such as [`WriteOnlyCollection.select()`](#sqlalchemy.orm.WriteOnlyCollection.select
    "sqlalchemy.orm.WriteOnlyCollection.select"), which will generate a [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") construct pre-configured with the correct
    WHERE / FROM criteria for the current parent row, which can then be further modified
    in order to SELECT any range of rows desired, as well as invoked using features
    like [server side cursors](queryguide/api.html#orm-queryguide-yield-per) for processes
    that wish to iterate through the full collection in a memory-efficient manner.
  prefs: []
  type: TYPE_NORMAL
- en: 'The statement generated is illustrated below. Note it also includes ORDER BY
    criteria, indicated in the example mapping by the [`relationship.order_by`](relationship_api.html#sqlalchemy.orm.relationship.params.order_by
    "sqlalchemy.orm.relationship") parameter of [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship"); this criteria would be omitted if the parameter
    were not configured:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'We may use this [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") construct along with the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") in order to query for `AccountTransaction` objects,
    most easily using the [`Session.scalars()`](session_api.html#sqlalchemy.orm.Session.scalars
    "sqlalchemy.orm.Session.scalars") method that will return a [`Result`](../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") that yields ORM objects directly. It’s typical, though
    not required, that the [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") would be modified further to limit the records
    returned; in the example below, additional WHERE criteria to load only “debit”
    account transactions is added, along with “LIMIT 10” to retrieve only the first
    ten rows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Removing Items
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Individual items that are loaded in the [persistent](../glossary.html#term-persistent)
    state against the current [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") may be marked for removal from the collection using
    the [`WriteOnlyCollection.remove()`](#sqlalchemy.orm.WriteOnlyCollection.remove
    "sqlalchemy.orm.WriteOnlyCollection.remove") method. The flush process will implicitly
    consider the object to be already part of the collection when the operation proceeds.
    The example below illustrates removal of an individual `AccountTransaction` item,
    which per [cascade](cascades.html#unitofwork-cascades) settings results in a DELETE
    of that row:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: As with any ORM-mapped collection, object removal may proceed either to de-associate
    the object from the collection while leaving the object present in the database,
    or may issue a DELETE for its row, based on the [delete-orphan](cascades.html#cascade-delete-orphan)
    configuration of the [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship").
  prefs: []
  type: TYPE_NORMAL
- en: Collection removal without deletion involves setting foreign key columns to
    NULL for a [one-to-many](basic_relationships.html#relationship-patterns-o2m) relationship,
    or deleting the corresponding association row for a [many-to-many](basic_relationships.html#relationships-many-to-many)
    relationship.
  prefs: []
  type: TYPE_NORMAL
- en: Bulk INSERT of New Items
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The [`WriteOnlyCollection`](#sqlalchemy.orm.WriteOnlyCollection "sqlalchemy.orm.WriteOnlyCollection")
    can generate DML constructs such as [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") objects, which may be used in an ORM context
    to produce bulk insert behavior. See the section [ORM Bulk INSERT Statements](queryguide/dml.html#orm-queryguide-bulk-insert)
    for an overview of ORM bulk inserts.
  prefs: []
  type: TYPE_NORMAL
- en: One to Many Collections
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'For a **regular one to many collection only**, the [`WriteOnlyCollection.insert()`](#sqlalchemy.orm.WriteOnlyCollection.insert
    "sqlalchemy.orm.WriteOnlyCollection.insert") method will produce an [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") construct which is pre-established with VALUES
    criteria corresponding to the parent object. As this VALUES criteria is entirely
    against the related table, the statement can be used to INSERT new rows that will
    at the same time become new records in the related collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[ORM Bulk INSERT Statements](queryguide/dml.html#orm-queryguide-bulk-insert)
    - in the [ORM Querying Guide](queryguide/index.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[One To Many](basic_relationships.html#relationship-patterns-o2m) - at [Basic
    Relationship Patterns](basic_relationships.html#relationship-patterns)'
  prefs: []
  type: TYPE_NORMAL
- en: Many to Many Collections
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For a **many to many collection**, the relationship between two classes involves
    a third table that is configured using the [`relationship.secondary`](relationship_api.html#sqlalchemy.orm.relationship.params.secondary
    "sqlalchemy.orm.relationship") parameter of [`relationship`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship"). To bulk insert rows into a collection of this
    type using [`WriteOnlyCollection`](#sqlalchemy.orm.WriteOnlyCollection "sqlalchemy.orm.WriteOnlyCollection"),
    the new records may be bulk-inserted separately first, retrieved using RETURNING,
    and those records then passed to the [`WriteOnlyCollection.add_all()`](#sqlalchemy.orm.WriteOnlyCollection.add_all
    "sqlalchemy.orm.WriteOnlyCollection.add_all") method where the unit of work process
    will proceed to persist them as part of the collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Supposing a class `BankAudit` referred to many `AccountTransaction` records
    using a many-to-many table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'To illustrate the two operations, we add more `AccountTransaction` objects
    using bulk insert, which we retrieve using RETURNING by adding `returning(AccountTransaction)`
    to the bulk INSERT statement (note that we could just as easily use existing `AccountTransaction`
    objects as well):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'With a list of `AccountTransaction` objects ready, the [`WriteOnlyCollection.add_all()`](#sqlalchemy.orm.WriteOnlyCollection.add_all
    "sqlalchemy.orm.WriteOnlyCollection.add_all") method is used to associate many
    rows at once with a new `BankAudit` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[ORM Bulk INSERT Statements](queryguide/dml.html#orm-queryguide-bulk-insert)
    - in the [ORM Querying Guide](queryguide/index.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Many To Many](basic_relationships.html#relationships-many-to-many) - at [Basic
    Relationship Patterns](basic_relationships.html#relationship-patterns)'
  prefs: []
  type: TYPE_NORMAL
- en: Bulk UPDATE and DELETE of Items
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In a similar way in which [`WriteOnlyCollection`](#sqlalchemy.orm.WriteOnlyCollection
    "sqlalchemy.orm.WriteOnlyCollection") can generate [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") constructs with WHERE criteria pre-established,
    it can also generate [`Update`](../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update") and [`Delete`](../core/dml.html#sqlalchemy.sql.expression.Delete
    "sqlalchemy.sql.expression.Delete") constructs with that same WHERE criteria,
    to allow criteria-oriented UPDATE and DELETE statements against the elements in
    a large collection.
  prefs: []
  type: TYPE_NORMAL
- en: One To Many Collections
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As is the case with INSERT, this feature is most straightforward with **one
    to many collections**.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the example below, the [`WriteOnlyCollection.update()`](#sqlalchemy.orm.WriteOnlyCollection.update
    "sqlalchemy.orm.WriteOnlyCollection.update") method is used to generate an UPDATE
    statement is emitted against the elements in the collection, locating rows where
    the “amount” is equal to `-800` and adding the amount of `200` to them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'In a similar way, [`WriteOnlyCollection.delete()`](#sqlalchemy.orm.WriteOnlyCollection.delete
    "sqlalchemy.orm.WriteOnlyCollection.delete") will produce a DELETE statement that
    is invoked in the same way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Many to Many Collections
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: The techniques here involve multi-table UPDATE expressions, which are slightly
    more advanced.
  prefs: []
  type: TYPE_NORMAL
- en: For bulk UPDATE and DELETE of **many to many collections**, in order for an
    UPDATE or DELETE statement to relate to the primary key of the parent object,
    the association table must be explicitly part of the UPDATE/DELETE statement,
    which requires either that the backend includes supports for non-standard SQL
    syntaxes, or extra explicit steps when constructing the UPDATE or DELETE statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'For backends that support multi-table versions of UPDATE, the [`WriteOnlyCollection.update()`](#sqlalchemy.orm.WriteOnlyCollection.update
    "sqlalchemy.orm.WriteOnlyCollection.update") method should work without extra
    steps for a many-to-many collection, as in the example below where an UPDATE is
    emitted against `AccountTransaction` objects in terms of the many-to-many `BankAudit.account_transactions`
    collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The above statement automatically makes use of “UPDATE..FROM” syntax, supported
    by SQLite and others, to name the additional `audit_transaction` table in the
    WHERE clause.
  prefs: []
  type: TYPE_NORMAL
- en: 'To UPDATE or DELETE a many-to-many collection where multi-table syntax is not
    available, the many-to-many criteria may be moved into SELECT that for example
    may be combined with IN to match rows. The [`WriteOnlyCollection`](#sqlalchemy.orm.WriteOnlyCollection
    "sqlalchemy.orm.WriteOnlyCollection") still helps us here, as we use the [`WriteOnlyCollection.select()`](#sqlalchemy.orm.WriteOnlyCollection.select
    "sqlalchemy.orm.WriteOnlyCollection.select") method to generate this SELECT for
    us, making use of the [`Select.with_only_columns()`](../core/selectable.html#sqlalchemy.sql.expression.Select.with_only_columns
    "sqlalchemy.sql.expression.Select.with_only_columns") method to produce a [scalar
    subquery](../glossary.html#term-scalar-subquery):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Write Only Collections - API Documentation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '| Object Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| [WriteOnlyCollection](#sqlalchemy.orm.WriteOnlyCollection) | Write-only collection
    which can synchronize changes into the attribute event system. |'
  prefs: []
  type: TYPE_TB
- en: '| [WriteOnlyMapped](#sqlalchemy.orm.WriteOnlyMapped) | Represent the ORM mapped
    attribute type for a “write only” relationship. |'
  prefs: []
  type: TYPE_TB
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Write-only collection which can synchronize changes into the attribute event
    system.
  prefs: []
  type: TYPE_NORMAL
- en: The [`WriteOnlyCollection`](#sqlalchemy.orm.WriteOnlyCollection "sqlalchemy.orm.WriteOnlyCollection")
    is used in a mapping by using the `"write_only"` lazy loading strategy with [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship"). For background on this configuration, see [Write
    Only Relationships](#write-only-relationship).
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Write Only Relationships](#write-only-relationship)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[add()](#sqlalchemy.orm.WriteOnlyCollection.add), [add_all()](#sqlalchemy.orm.WriteOnlyCollection.add_all),
    [delete()](#sqlalchemy.orm.WriteOnlyCollection.delete), [insert()](#sqlalchemy.orm.WriteOnlyCollection.insert),
    [remove()](#sqlalchemy.orm.WriteOnlyCollection.remove), [select()](#sqlalchemy.orm.WriteOnlyCollection.select),
    [update()](#sqlalchemy.orm.WriteOnlyCollection.update)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.orm.WriteOnlyCollection`](#sqlalchemy.orm.WriteOnlyCollection
    "sqlalchemy.orm.WriteOnlyCollection") (`sqlalchemy.orm.writeonly.AbstractCollectionWriter`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Add an item to this [`WriteOnlyCollection`](#sqlalchemy.orm.WriteOnlyCollection
    "sqlalchemy.orm.WriteOnlyCollection").
  prefs: []
  type: TYPE_NORMAL
- en: The given item will be persisted to the database in terms of the parent instance’s
    collection on the next flush.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Add an iterable of items to this [`WriteOnlyCollection`](#sqlalchemy.orm.WriteOnlyCollection
    "sqlalchemy.orm.WriteOnlyCollection").
  prefs: []
  type: TYPE_NORMAL
- en: The given items will be persisted to the database in terms of the parent instance’s
    collection on the next flush.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Produce a [`Delete`](../core/dml.html#sqlalchemy.sql.expression.Delete "sqlalchemy.sql.expression.Delete")
    which will refer to rows in terms of this instance-local [`WriteOnlyCollection`](#sqlalchemy.orm.WriteOnlyCollection
    "sqlalchemy.orm.WriteOnlyCollection").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: For one-to-many collections, produce a [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") which will insert new rows in terms of this
    this instance-local [`WriteOnlyCollection`](#sqlalchemy.orm.WriteOnlyCollection
    "sqlalchemy.orm.WriteOnlyCollection").
  prefs: []
  type: TYPE_NORMAL
- en: This construct is only supported for a [`Relationship`](internals.html#sqlalchemy.orm.Relationship
    "sqlalchemy.orm.Relationship") that does **not** include the [`relationship.secondary`](relationship_api.html#sqlalchemy.orm.relationship.params.secondary
    "sqlalchemy.orm.relationship") parameter. For relationships that refer to a many-to-many
    table, use ordinary bulk insert techniques to produce new objects, then use `AbstractCollectionWriter.add_all()`
    to associate them with the collection.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Remove an item from this [`WriteOnlyCollection`](#sqlalchemy.orm.WriteOnlyCollection
    "sqlalchemy.orm.WriteOnlyCollection").
  prefs: []
  type: TYPE_NORMAL
- en: The given item will be removed from the parent instance’s collection on the
    next flush.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Produce a [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") construct that represents the rows within
    this instance-local [`WriteOnlyCollection`](#sqlalchemy.orm.WriteOnlyCollection
    "sqlalchemy.orm.WriteOnlyCollection").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Produce a [`Update`](../core/dml.html#sqlalchemy.sql.expression.Update "sqlalchemy.sql.expression.Update")
    which will refer to rows in terms of this instance-local [`WriteOnlyCollection`](#sqlalchemy.orm.WriteOnlyCollection
    "sqlalchemy.orm.WriteOnlyCollection").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Represent the ORM mapped attribute type for a “write only” relationship.
  prefs: []
  type: TYPE_NORMAL
- en: The [`WriteOnlyMapped`](#sqlalchemy.orm.WriteOnlyMapped "sqlalchemy.orm.WriteOnlyMapped")
    type annotation may be used in an [Annotated Declarative Table](declarative_tables.html#orm-declarative-mapped-column)
    mapping to indicate that the `lazy="write_only"` loader strategy should be used
    for a particular [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship").
  prefs: []
  type: TYPE_NORMAL
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: See the section [Write Only Relationships](#write-only-relationship) for background.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Write Only Relationships](#write-only-relationship) - complete background'
  prefs: []
  type: TYPE_NORMAL
- en: '[`DynamicMapped`](#sqlalchemy.orm.DynamicMapped "sqlalchemy.orm.DynamicMapped")
    - includes legacy [`Query`](queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    support'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.orm.WriteOnlyMapped`](#sqlalchemy.orm.WriteOnlyMapped "sqlalchemy.orm.WriteOnlyMapped")
    (`sqlalchemy.orm.base._MappedAnnotationBase`)
  prefs: []
  type: TYPE_NORMAL
- en: Creating and Persisting New Write Only Collections
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The write-only collection allows for direct assignment of the collection as
    a whole **only** for [transient](../glossary.html#term-transient) or [pending](../glossary.html#term-pending)
    objects. With our above mapping, this indicates we can create a new `Account`
    object with a sequence of `AccountTransaction` objects to be added to a [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"). Any Python iterable may be used as the source of objects
    to start, where below we use a Python `list`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Once an object is database-persisted (i.e. in the [persistent](../glossary.html#term-persistent)
    or [detached](../glossary.html#term-detached) state), the collection has the ability
    to be extended with new items as well as the ability for individual items to be
    removed. However, the collection may **no longer be re-assigned with a full replacement
    collection**, as such an operation requires that the previous collection is fully
    loaded into memory in order to reconcile the old entries with the new ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Adding New Items to an Existing Collection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For write-only collections of persistent objects, modifications to the collection
    using [unit of work](../glossary.html#term-unit-of-work) processes may proceed
    only by using the [`WriteOnlyCollection.add()`](#sqlalchemy.orm.WriteOnlyCollection.add
    "sqlalchemy.orm.WriteOnlyCollection.add"), [`WriteOnlyCollection.add_all()`](#sqlalchemy.orm.WriteOnlyCollection.add_all
    "sqlalchemy.orm.WriteOnlyCollection.add_all") and [`WriteOnlyCollection.remove()`](#sqlalchemy.orm.WriteOnlyCollection.remove
    "sqlalchemy.orm.WriteOnlyCollection.remove") methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: The items added above are held in a pending queue within the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") until the next flush, at which point they are INSERTed
    into the database, assuming the added objects were previously [transient](../glossary.html#term-transient).
  prefs: []
  type: TYPE_NORMAL
- en: Querying Items
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The [`WriteOnlyCollection`](#sqlalchemy.orm.WriteOnlyCollection "sqlalchemy.orm.WriteOnlyCollection")
    does not at any point store a reference to the current contents of the collection,
    nor does it have any behavior where it would directly emit a SELECT to the database
    in order to load them; the overriding assumption is that the collection may contain
    many thousands or millions of rows, and should never be fully loaded into memory
    as a side effect of any other operation.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, the [`WriteOnlyCollection`](#sqlalchemy.orm.WriteOnlyCollection "sqlalchemy.orm.WriteOnlyCollection")
    includes SQL-generating helpers such as [`WriteOnlyCollection.select()`](#sqlalchemy.orm.WriteOnlyCollection.select
    "sqlalchemy.orm.WriteOnlyCollection.select"), which will generate a [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") construct pre-configured with the correct
    WHERE / FROM criteria for the current parent row, which can then be further modified
    in order to SELECT any range of rows desired, as well as invoked using features
    like [server side cursors](queryguide/api.html#orm-queryguide-yield-per) for processes
    that wish to iterate through the full collection in a memory-efficient manner.
  prefs: []
  type: TYPE_NORMAL
- en: 'The statement generated is illustrated below. Note it also includes ORDER BY
    criteria, indicated in the example mapping by the [`relationship.order_by`](relationship_api.html#sqlalchemy.orm.relationship.params.order_by
    "sqlalchemy.orm.relationship") parameter of [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship"); this criteria would be omitted if the parameter
    were not configured:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'We may use this [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") construct along with the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") in order to query for `AccountTransaction` objects,
    most easily using the [`Session.scalars()`](session_api.html#sqlalchemy.orm.Session.scalars
    "sqlalchemy.orm.Session.scalars") method that will return a [`Result`](../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") that yields ORM objects directly. It’s typical, though
    not required, that the [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") would be modified further to limit the records
    returned; in the example below, additional WHERE criteria to load only “debit”
    account transactions is added, along with “LIMIT 10” to retrieve only the first
    ten rows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Removing Items
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Individual items that are loaded in the [persistent](../glossary.html#term-persistent)
    state against the current [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") may be marked for removal from the collection using
    the [`WriteOnlyCollection.remove()`](#sqlalchemy.orm.WriteOnlyCollection.remove
    "sqlalchemy.orm.WriteOnlyCollection.remove") method. The flush process will implicitly
    consider the object to be already part of the collection when the operation proceeds.
    The example below illustrates removal of an individual `AccountTransaction` item,
    which per [cascade](cascades.html#unitofwork-cascades) settings results in a DELETE
    of that row:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: As with any ORM-mapped collection, object removal may proceed either to de-associate
    the object from the collection while leaving the object present in the database,
    or may issue a DELETE for its row, based on the [delete-orphan](cascades.html#cascade-delete-orphan)
    configuration of the [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship").
  prefs: []
  type: TYPE_NORMAL
- en: Collection removal without deletion involves setting foreign key columns to
    NULL for a [one-to-many](basic_relationships.html#relationship-patterns-o2m) relationship,
    or deleting the corresponding association row for a [many-to-many](basic_relationships.html#relationships-many-to-many)
    relationship.
  prefs: []
  type: TYPE_NORMAL
- en: Bulk INSERT of New Items
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The [`WriteOnlyCollection`](#sqlalchemy.orm.WriteOnlyCollection "sqlalchemy.orm.WriteOnlyCollection")
    can generate DML constructs such as [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") objects, which may be used in an ORM context
    to produce bulk insert behavior. See the section [ORM Bulk INSERT Statements](queryguide/dml.html#orm-queryguide-bulk-insert)
    for an overview of ORM bulk inserts.
  prefs: []
  type: TYPE_NORMAL
- en: One to Many Collections
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'For a **regular one to many collection only**, the [`WriteOnlyCollection.insert()`](#sqlalchemy.orm.WriteOnlyCollection.insert
    "sqlalchemy.orm.WriteOnlyCollection.insert") method will produce an [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") construct which is pre-established with VALUES
    criteria corresponding to the parent object. As this VALUES criteria is entirely
    against the related table, the statement can be used to INSERT new rows that will
    at the same time become new records in the related collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[ORM Bulk INSERT Statements](queryguide/dml.html#orm-queryguide-bulk-insert)
    - in the [ORM Querying Guide](queryguide/index.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[One To Many](basic_relationships.html#relationship-patterns-o2m) - at [Basic
    Relationship Patterns](basic_relationships.html#relationship-patterns)'
  prefs: []
  type: TYPE_NORMAL
- en: Many to Many Collections
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For a **many to many collection**, the relationship between two classes involves
    a third table that is configured using the [`relationship.secondary`](relationship_api.html#sqlalchemy.orm.relationship.params.secondary
    "sqlalchemy.orm.relationship") parameter of [`relationship`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship"). To bulk insert rows into a collection of this
    type using [`WriteOnlyCollection`](#sqlalchemy.orm.WriteOnlyCollection "sqlalchemy.orm.WriteOnlyCollection"),
    the new records may be bulk-inserted separately first, retrieved using RETURNING,
    and those records then passed to the [`WriteOnlyCollection.add_all()`](#sqlalchemy.orm.WriteOnlyCollection.add_all
    "sqlalchemy.orm.WriteOnlyCollection.add_all") method where the unit of work process
    will proceed to persist them as part of the collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Supposing a class `BankAudit` referred to many `AccountTransaction` records
    using a many-to-many table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'To illustrate the two operations, we add more `AccountTransaction` objects
    using bulk insert, which we retrieve using RETURNING by adding `returning(AccountTransaction)`
    to the bulk INSERT statement (note that we could just as easily use existing `AccountTransaction`
    objects as well):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'With a list of `AccountTransaction` objects ready, the [`WriteOnlyCollection.add_all()`](#sqlalchemy.orm.WriteOnlyCollection.add_all
    "sqlalchemy.orm.WriteOnlyCollection.add_all") method is used to associate many
    rows at once with a new `BankAudit` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[ORM Bulk INSERT Statements](queryguide/dml.html#orm-queryguide-bulk-insert)
    - in the [ORM Querying Guide](queryguide/index.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Many To Many](basic_relationships.html#relationships-many-to-many) - at [Basic
    Relationship Patterns](basic_relationships.html#relationship-patterns)'
  prefs: []
  type: TYPE_NORMAL
- en: One to Many Collections
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'For a **regular one to many collection only**, the [`WriteOnlyCollection.insert()`](#sqlalchemy.orm.WriteOnlyCollection.insert
    "sqlalchemy.orm.WriteOnlyCollection.insert") method will produce an [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") construct which is pre-established with VALUES
    criteria corresponding to the parent object. As this VALUES criteria is entirely
    against the related table, the statement can be used to INSERT new rows that will
    at the same time become new records in the related collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[ORM Bulk INSERT Statements](queryguide/dml.html#orm-queryguide-bulk-insert)
    - in the [ORM Querying Guide](queryguide/index.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[One To Many](basic_relationships.html#relationship-patterns-o2m) - at [Basic
    Relationship Patterns](basic_relationships.html#relationship-patterns)'
  prefs: []
  type: TYPE_NORMAL
- en: Many to Many Collections
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For a **many to many collection**, the relationship between two classes involves
    a third table that is configured using the [`relationship.secondary`](relationship_api.html#sqlalchemy.orm.relationship.params.secondary
    "sqlalchemy.orm.relationship") parameter of [`relationship`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship"). To bulk insert rows into a collection of this
    type using [`WriteOnlyCollection`](#sqlalchemy.orm.WriteOnlyCollection "sqlalchemy.orm.WriteOnlyCollection"),
    the new records may be bulk-inserted separately first, retrieved using RETURNING,
    and those records then passed to the [`WriteOnlyCollection.add_all()`](#sqlalchemy.orm.WriteOnlyCollection.add_all
    "sqlalchemy.orm.WriteOnlyCollection.add_all") method where the unit of work process
    will proceed to persist them as part of the collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Supposing a class `BankAudit` referred to many `AccountTransaction` records
    using a many-to-many table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'To illustrate the two operations, we add more `AccountTransaction` objects
    using bulk insert, which we retrieve using RETURNING by adding `returning(AccountTransaction)`
    to the bulk INSERT statement (note that we could just as easily use existing `AccountTransaction`
    objects as well):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'With a list of `AccountTransaction` objects ready, the [`WriteOnlyCollection.add_all()`](#sqlalchemy.orm.WriteOnlyCollection.add_all
    "sqlalchemy.orm.WriteOnlyCollection.add_all") method is used to associate many
    rows at once with a new `BankAudit` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[ORM Bulk INSERT Statements](queryguide/dml.html#orm-queryguide-bulk-insert)
    - in the [ORM Querying Guide](queryguide/index.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Many To Many](basic_relationships.html#relationships-many-to-many) - at [Basic
    Relationship Patterns](basic_relationships.html#relationship-patterns)'
  prefs: []
  type: TYPE_NORMAL
- en: Bulk UPDATE and DELETE of Items
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In a similar way in which [`WriteOnlyCollection`](#sqlalchemy.orm.WriteOnlyCollection
    "sqlalchemy.orm.WriteOnlyCollection") can generate [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") constructs with WHERE criteria pre-established,
    it can also generate [`Update`](../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update") and [`Delete`](../core/dml.html#sqlalchemy.sql.expression.Delete
    "sqlalchemy.sql.expression.Delete") constructs with that same WHERE criteria,
    to allow criteria-oriented UPDATE and DELETE statements against the elements in
    a large collection.
  prefs: []
  type: TYPE_NORMAL
- en: One To Many Collections
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As is the case with INSERT, this feature is most straightforward with **one
    to many collections**.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the example below, the [`WriteOnlyCollection.update()`](#sqlalchemy.orm.WriteOnlyCollection.update
    "sqlalchemy.orm.WriteOnlyCollection.update") method is used to generate an UPDATE
    statement is emitted against the elements in the collection, locating rows where
    the “amount” is equal to `-800` and adding the amount of `200` to them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'In a similar way, [`WriteOnlyCollection.delete()`](#sqlalchemy.orm.WriteOnlyCollection.delete
    "sqlalchemy.orm.WriteOnlyCollection.delete") will produce a DELETE statement that
    is invoked in the same way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Many to Many Collections
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: The techniques here involve multi-table UPDATE expressions, which are slightly
    more advanced.
  prefs: []
  type: TYPE_NORMAL
- en: For bulk UPDATE and DELETE of **many to many collections**, in order for an
    UPDATE or DELETE statement to relate to the primary key of the parent object,
    the association table must be explicitly part of the UPDATE/DELETE statement,
    which requires either that the backend includes supports for non-standard SQL
    syntaxes, or extra explicit steps when constructing the UPDATE or DELETE statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'For backends that support multi-table versions of UPDATE, the [`WriteOnlyCollection.update()`](#sqlalchemy.orm.WriteOnlyCollection.update
    "sqlalchemy.orm.WriteOnlyCollection.update") method should work without extra
    steps for a many-to-many collection, as in the example below where an UPDATE is
    emitted against `AccountTransaction` objects in terms of the many-to-many `BankAudit.account_transactions`
    collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: The above statement automatically makes use of “UPDATE..FROM” syntax, supported
    by SQLite and others, to name the additional `audit_transaction` table in the
    WHERE clause.
  prefs: []
  type: TYPE_NORMAL
- en: 'To UPDATE or DELETE a many-to-many collection where multi-table syntax is not
    available, the many-to-many criteria may be moved into SELECT that for example
    may be combined with IN to match rows. The [`WriteOnlyCollection`](#sqlalchemy.orm.WriteOnlyCollection
    "sqlalchemy.orm.WriteOnlyCollection") still helps us here, as we use the [`WriteOnlyCollection.select()`](#sqlalchemy.orm.WriteOnlyCollection.select
    "sqlalchemy.orm.WriteOnlyCollection.select") method to generate this SELECT for
    us, making use of the [`Select.with_only_columns()`](../core/selectable.html#sqlalchemy.sql.expression.Select.with_only_columns
    "sqlalchemy.sql.expression.Select.with_only_columns") method to produce a [scalar
    subquery](../glossary.html#term-scalar-subquery):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: One To Many Collections
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As is the case with INSERT, this feature is most straightforward with **one
    to many collections**.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the example below, the [`WriteOnlyCollection.update()`](#sqlalchemy.orm.WriteOnlyCollection.update
    "sqlalchemy.orm.WriteOnlyCollection.update") method is used to generate an UPDATE
    statement is emitted against the elements in the collection, locating rows where
    the “amount” is equal to `-800` and adding the amount of `200` to them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'In a similar way, [`WriteOnlyCollection.delete()`](#sqlalchemy.orm.WriteOnlyCollection.delete
    "sqlalchemy.orm.WriteOnlyCollection.delete") will produce a DELETE statement that
    is invoked in the same way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Many to Many Collections
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: The techniques here involve multi-table UPDATE expressions, which are slightly
    more advanced.
  prefs: []
  type: TYPE_NORMAL
- en: For bulk UPDATE and DELETE of **many to many collections**, in order for an
    UPDATE or DELETE statement to relate to the primary key of the parent object,
    the association table must be explicitly part of the UPDATE/DELETE statement,
    which requires either that the backend includes supports for non-standard SQL
    syntaxes, or extra explicit steps when constructing the UPDATE or DELETE statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'For backends that support multi-table versions of UPDATE, the [`WriteOnlyCollection.update()`](#sqlalchemy.orm.WriteOnlyCollection.update
    "sqlalchemy.orm.WriteOnlyCollection.update") method should work without extra
    steps for a many-to-many collection, as in the example below where an UPDATE is
    emitted against `AccountTransaction` objects in terms of the many-to-many `BankAudit.account_transactions`
    collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: The above statement automatically makes use of “UPDATE..FROM” syntax, supported
    by SQLite and others, to name the additional `audit_transaction` table in the
    WHERE clause.
  prefs: []
  type: TYPE_NORMAL
- en: 'To UPDATE or DELETE a many-to-many collection where multi-table syntax is not
    available, the many-to-many criteria may be moved into SELECT that for example
    may be combined with IN to match rows. The [`WriteOnlyCollection`](#sqlalchemy.orm.WriteOnlyCollection
    "sqlalchemy.orm.WriteOnlyCollection") still helps us here, as we use the [`WriteOnlyCollection.select()`](#sqlalchemy.orm.WriteOnlyCollection.select
    "sqlalchemy.orm.WriteOnlyCollection.select") method to generate this SELECT for
    us, making use of the [`Select.with_only_columns()`](../core/selectable.html#sqlalchemy.sql.expression.Select.with_only_columns
    "sqlalchemy.sql.expression.Select.with_only_columns") method to produce a [scalar
    subquery](../glossary.html#term-scalar-subquery):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Write Only Collections - API Documentation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '| Object Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| [WriteOnlyCollection](#sqlalchemy.orm.WriteOnlyCollection) | Write-only collection
    which can synchronize changes into the attribute event system. |'
  prefs: []
  type: TYPE_TB
- en: '| [WriteOnlyMapped](#sqlalchemy.orm.WriteOnlyMapped) | Represent the ORM mapped
    attribute type for a “write only” relationship. |'
  prefs: []
  type: TYPE_TB
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Write-only collection which can synchronize changes into the attribute event
    system.
  prefs: []
  type: TYPE_NORMAL
- en: The [`WriteOnlyCollection`](#sqlalchemy.orm.WriteOnlyCollection "sqlalchemy.orm.WriteOnlyCollection")
    is used in a mapping by using the `"write_only"` lazy loading strategy with [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship"). For background on this configuration, see [Write
    Only Relationships](#write-only-relationship).
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Write Only Relationships](#write-only-relationship)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[add()](#sqlalchemy.orm.WriteOnlyCollection.add), [add_all()](#sqlalchemy.orm.WriteOnlyCollection.add_all),
    [delete()](#sqlalchemy.orm.WriteOnlyCollection.delete), [insert()](#sqlalchemy.orm.WriteOnlyCollection.insert),
    [remove()](#sqlalchemy.orm.WriteOnlyCollection.remove), [select()](#sqlalchemy.orm.WriteOnlyCollection.select),
    [update()](#sqlalchemy.orm.WriteOnlyCollection.update)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.orm.WriteOnlyCollection`](#sqlalchemy.orm.WriteOnlyCollection
    "sqlalchemy.orm.WriteOnlyCollection") (`sqlalchemy.orm.writeonly.AbstractCollectionWriter`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: Add an item to this [`WriteOnlyCollection`](#sqlalchemy.orm.WriteOnlyCollection
    "sqlalchemy.orm.WriteOnlyCollection").
  prefs: []
  type: TYPE_NORMAL
- en: The given item will be persisted to the database in terms of the parent instance’s
    collection on the next flush.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Add an iterable of items to this [`WriteOnlyCollection`](#sqlalchemy.orm.WriteOnlyCollection
    "sqlalchemy.orm.WriteOnlyCollection").
  prefs: []
  type: TYPE_NORMAL
- en: The given items will be persisted to the database in terms of the parent instance’s
    collection on the next flush.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Produce a [`Delete`](../core/dml.html#sqlalchemy.sql.expression.Delete "sqlalchemy.sql.expression.Delete")
    which will refer to rows in terms of this instance-local [`WriteOnlyCollection`](#sqlalchemy.orm.WriteOnlyCollection
    "sqlalchemy.orm.WriteOnlyCollection").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: For one-to-many collections, produce a [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") which will insert new rows in terms of this
    this instance-local [`WriteOnlyCollection`](#sqlalchemy.orm.WriteOnlyCollection
    "sqlalchemy.orm.WriteOnlyCollection").
  prefs: []
  type: TYPE_NORMAL
- en: This construct is only supported for a [`Relationship`](internals.html#sqlalchemy.orm.Relationship
    "sqlalchemy.orm.Relationship") that does **not** include the [`relationship.secondary`](relationship_api.html#sqlalchemy.orm.relationship.params.secondary
    "sqlalchemy.orm.relationship") parameter. For relationships that refer to a many-to-many
    table, use ordinary bulk insert techniques to produce new objects, then use `AbstractCollectionWriter.add_all()`
    to associate them with the collection.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: Remove an item from this [`WriteOnlyCollection`](#sqlalchemy.orm.WriteOnlyCollection
    "sqlalchemy.orm.WriteOnlyCollection").
  prefs: []
  type: TYPE_NORMAL
- en: The given item will be removed from the parent instance’s collection on the
    next flush.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: Produce a [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") construct that represents the rows within
    this instance-local [`WriteOnlyCollection`](#sqlalchemy.orm.WriteOnlyCollection
    "sqlalchemy.orm.WriteOnlyCollection").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: Produce a [`Update`](../core/dml.html#sqlalchemy.sql.expression.Update "sqlalchemy.sql.expression.Update")
    which will refer to rows in terms of this instance-local [`WriteOnlyCollection`](#sqlalchemy.orm.WriteOnlyCollection
    "sqlalchemy.orm.WriteOnlyCollection").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: Represent the ORM mapped attribute type for a “write only” relationship.
  prefs: []
  type: TYPE_NORMAL
- en: The [`WriteOnlyMapped`](#sqlalchemy.orm.WriteOnlyMapped "sqlalchemy.orm.WriteOnlyMapped")
    type annotation may be used in an [Annotated Declarative Table](declarative_tables.html#orm-declarative-mapped-column)
    mapping to indicate that the `lazy="write_only"` loader strategy should be used
    for a particular [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship").
  prefs: []
  type: TYPE_NORMAL
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: See the section [Write Only Relationships](#write-only-relationship) for background.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Write Only Relationships](#write-only-relationship) - complete background'
  prefs: []
  type: TYPE_NORMAL
- en: '[`DynamicMapped`](#sqlalchemy.orm.DynamicMapped "sqlalchemy.orm.DynamicMapped")
    - includes legacy [`Query`](queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    support'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.orm.WriteOnlyMapped`](#sqlalchemy.orm.WriteOnlyMapped "sqlalchemy.orm.WriteOnlyMapped")
    (`sqlalchemy.orm.base._MappedAnnotationBase`)
  prefs: []
  type: TYPE_NORMAL
- en: '## Dynamic Relationship Loaders'
  prefs: []
  type: TYPE_NORMAL
- en: Legacy Feature
  prefs: []
  type: TYPE_NORMAL
- en: The “dynamic” lazy loader strategy is the legacy form of what is now the “write_only”
    strategy described in the section [Write Only Relationships](#write-only-relationship).
  prefs: []
  type: TYPE_NORMAL
- en: The “dynamic” strategy produces a legacy [`Query`](queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object from the related collection. However, a major drawback
    of “dynamic” relationships is that there are several cases where the collection
    will fully iterate, some of which are non-obvious, which can only be prevented
    with careful programming and testing on a case-by-case basis. Therefore, for truly
    large collection management, the [`WriteOnlyCollection`](#sqlalchemy.orm.WriteOnlyCollection
    "sqlalchemy.orm.WriteOnlyCollection") should be preferred.
  prefs: []
  type: TYPE_NORMAL
- en: The dynamic loader is also not compatible with the [Asynchronous I/O (asyncio)](extensions/asyncio.html)
    extension. It can be used with some limitations, as indicated in [Asyncio dynamic
    guidelines](extensions/asyncio.html#dynamic-asyncio), but again the [`WriteOnlyCollection`](#sqlalchemy.orm.WriteOnlyCollection
    "sqlalchemy.orm.WriteOnlyCollection"), which is fully compatible with asyncio,
    should be preferred.
  prefs: []
  type: TYPE_NORMAL
- en: The dynamic relationship strategy allows configuration of a [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") which when accessed on an instance will return
    a legacy [`Query`](queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    object in place of the collection. The [`Query`](queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") can then be modified further so that the database collection
    may be iterated based on filtering criteria. The returned [`Query`](queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object is an instance of [`AppenderQuery`](#sqlalchemy.orm.AppenderQuery
    "sqlalchemy.orm.AppenderQuery"), which combines the loading and iteration behavior
    of [`Query`](queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    along with rudimentary collection mutation methods such as [`AppenderQuery.append()`](#sqlalchemy.orm.AppenderQuery.append
    "sqlalchemy.orm.AppenderQuery.append") and [`AppenderQuery.remove()`](#sqlalchemy.orm.AppenderQuery.remove
    "sqlalchemy.orm.AppenderQuery.remove").
  prefs: []
  type: TYPE_NORMAL
- en: 'The “dynamic” loader strategy may be configured with type-annotated Declarative
    form using the [`DynamicMapped`](#sqlalchemy.orm.DynamicMapped "sqlalchemy.orm.DynamicMapped")
    annotation class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'Above, the `User.posts` collection on an individual `User` object will return
    the [`AppenderQuery`](#sqlalchemy.orm.AppenderQuery "sqlalchemy.orm.AppenderQuery")
    object, which is a subclass of [`Query`](queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") that also supports basic collection mutation operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'The dynamic relationship supports limited write operations, via the [`AppenderQuery.append()`](#sqlalchemy.orm.AppenderQuery.append
    "sqlalchemy.orm.AppenderQuery.append") and [`AppenderQuery.remove()`](#sqlalchemy.orm.AppenderQuery.remove
    "sqlalchemy.orm.AppenderQuery.remove") methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: Since the read side of the dynamic relationship always queries the database,
    changes to the underlying collection will not be visible until the data has been
    flushed. However, as long as “autoflush” is enabled on the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") in use, this will occur automatically each time the
    collection is about to emit a query.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic Relationship Loaders - API
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '| Object Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| [AppenderQuery](#sqlalchemy.orm.AppenderQuery) | A dynamic query that supports
    basic collection storage operations. |'
  prefs: []
  type: TYPE_TB
- en: '| [DynamicMapped](#sqlalchemy.orm.DynamicMapped) | Represent the ORM mapped
    attribute type for a “dynamic” relationship. |'
  prefs: []
  type: TYPE_TB
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: A dynamic query that supports basic collection storage operations.
  prefs: []
  type: TYPE_NORMAL
- en: Methods on [`AppenderQuery`](#sqlalchemy.orm.AppenderQuery "sqlalchemy.orm.AppenderQuery")
    include all methods of [`Query`](queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query"),
    plus additional methods used for collection persistence.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[add()](#sqlalchemy.orm.AppenderQuery.add), [add_all()](#sqlalchemy.orm.AppenderQuery.add_all),
    [append()](#sqlalchemy.orm.AppenderQuery.append), [count()](#sqlalchemy.orm.AppenderQuery.count),
    [extend()](#sqlalchemy.orm.AppenderQuery.extend), [remove()](#sqlalchemy.orm.AppenderQuery.remove)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.orm.AppenderQuery`](#sqlalchemy.orm.AppenderQuery "sqlalchemy.orm.AppenderQuery")
    (`sqlalchemy.orm.dynamic.AppenderMixin`, [`sqlalchemy.orm.Query`](queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `AppenderMixin.add()` *method of* `AppenderMixin`'
  prefs: []
  type: TYPE_NORMAL
- en: Add an item to this [`AppenderQuery`](#sqlalchemy.orm.AppenderQuery "sqlalchemy.orm.AppenderQuery").
  prefs: []
  type: TYPE_NORMAL
- en: The given item will be persisted to the database in terms of the parent instance’s
    collection on the next flush.
  prefs: []
  type: TYPE_NORMAL
- en: This method is provided to assist in delivering forwards-compatibility with
    the [`WriteOnlyCollection`](#sqlalchemy.orm.WriteOnlyCollection "sqlalchemy.orm.WriteOnlyCollection")
    collection class.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `AppenderMixin.add_all()` *method of* `AppenderMixin`'
  prefs: []
  type: TYPE_NORMAL
- en: Add an iterable of items to this [`AppenderQuery`](#sqlalchemy.orm.AppenderQuery
    "sqlalchemy.orm.AppenderQuery").
  prefs: []
  type: TYPE_NORMAL
- en: The given items will be persisted to the database in terms of the parent instance’s
    collection on the next flush.
  prefs: []
  type: TYPE_NORMAL
- en: This method is provided to assist in delivering forwards-compatibility with
    the [`WriteOnlyCollection`](#sqlalchemy.orm.WriteOnlyCollection "sqlalchemy.orm.WriteOnlyCollection")
    collection class.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `AppenderMixin.append()` *method of* `AppenderMixin`'
  prefs: []
  type: TYPE_NORMAL
- en: Append an item to this [`AppenderQuery`](#sqlalchemy.orm.AppenderQuery "sqlalchemy.orm.AppenderQuery").
  prefs: []
  type: TYPE_NORMAL
- en: The given item will be persisted to the database in terms of the parent instance’s
    collection on the next flush.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `AppenderMixin.count()` *method of* `AppenderMixin`'
  prefs: []
  type: TYPE_NORMAL
- en: Return a count of rows this the SQL formed by this [`Query`](queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") would return.
  prefs: []
  type: TYPE_NORMAL
- en: 'This generates the SQL for this Query as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: The above SQL returns a single row, which is the aggregate value of the count
    function; the [`Query.count()`](queryguide/query.html#sqlalchemy.orm.Query.count
    "sqlalchemy.orm.Query.count") method then returns that single integer value.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that the value returned by count() is **not the same
    as the number of ORM objects that this Query would return from a method such as
    the .all() method**. The [`Query`](queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object, when asked to return full entities, will **deduplicate
    entries based on primary key**, meaning if the same primary key value would appear
    in the results more than once, only one object of that primary key would be present.
    This does not apply to a query that is against individual columns.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[My Query does not return the same number of objects as query.count() tells
    me - why?](../faq/sessions.html#faq-query-deduplicating)'
  prefs: []
  type: TYPE_NORMAL
- en: 'For fine grained control over specific columns to count, to skip the usage
    of a subquery or otherwise control of the FROM clause, or to use other aggregate
    functions, use [`expression.func`](../core/sqlelement.html#sqlalchemy.sql.expression.func
    "sqlalchemy.sql.expression.func") expressions in conjunction with [`Session.query()`](session_api.html#sqlalchemy.orm.Session.query
    "sqlalchemy.orm.Session.query"), i.e.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[2.0 Migration - ORM Usage](../changelog/migration_20.html#migration-20-query-usage)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `AppenderMixin.extend()` *method of* `AppenderMixin`'
  prefs: []
  type: TYPE_NORMAL
- en: Add an iterable of items to this [`AppenderQuery`](#sqlalchemy.orm.AppenderQuery
    "sqlalchemy.orm.AppenderQuery").
  prefs: []
  type: TYPE_NORMAL
- en: The given items will be persisted to the database in terms of the parent instance’s
    collection on the next flush.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `AppenderMixin.remove()` *method of* `AppenderMixin`'
  prefs: []
  type: TYPE_NORMAL
- en: Remove an item from this [`AppenderQuery`](#sqlalchemy.orm.AppenderQuery "sqlalchemy.orm.AppenderQuery").
  prefs: []
  type: TYPE_NORMAL
- en: The given item will be removed from the parent instance’s collection on the
    next flush.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: Represent the ORM mapped attribute type for a “dynamic” relationship.
  prefs: []
  type: TYPE_NORMAL
- en: The [`DynamicMapped`](#sqlalchemy.orm.DynamicMapped "sqlalchemy.orm.DynamicMapped")
    type annotation may be used in an [Annotated Declarative Table](declarative_tables.html#orm-declarative-mapped-column)
    mapping to indicate that the `lazy="dynamic"` loader strategy should be used for
    a particular [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship").
  prefs: []
  type: TYPE_NORMAL
- en: Legacy Feature
  prefs: []
  type: TYPE_NORMAL
- en: The “dynamic” lazy loader strategy is the legacy form of what is now the “write_only”
    strategy described in the section [Write Only Relationships](#write-only-relationship).
  prefs: []
  type: TYPE_NORMAL
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: See the section [Dynamic Relationship Loaders](#dynamic-relationship) for background.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Dynamic Relationship Loaders](#dynamic-relationship) - complete background'
  prefs: []
  type: TYPE_NORMAL
- en: '[`WriteOnlyMapped`](#sqlalchemy.orm.WriteOnlyMapped "sqlalchemy.orm.WriteOnlyMapped")
    - fully 2.0 style version'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.orm.DynamicMapped`](#sqlalchemy.orm.DynamicMapped "sqlalchemy.orm.DynamicMapped")
    (`sqlalchemy.orm.base._MappedAnnotationBase`)
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic Relationship Loaders - API
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '| Object Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| [AppenderQuery](#sqlalchemy.orm.AppenderQuery) | A dynamic query that supports
    basic collection storage operations. |'
  prefs: []
  type: TYPE_TB
- en: '| [DynamicMapped](#sqlalchemy.orm.DynamicMapped) | Represent the ORM mapped
    attribute type for a “dynamic” relationship. |'
  prefs: []
  type: TYPE_TB
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: A dynamic query that supports basic collection storage operations.
  prefs: []
  type: TYPE_NORMAL
- en: Methods on [`AppenderQuery`](#sqlalchemy.orm.AppenderQuery "sqlalchemy.orm.AppenderQuery")
    include all methods of [`Query`](queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query"),
    plus additional methods used for collection persistence.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[add()](#sqlalchemy.orm.AppenderQuery.add), [add_all()](#sqlalchemy.orm.AppenderQuery.add_all),
    [append()](#sqlalchemy.orm.AppenderQuery.append), [count()](#sqlalchemy.orm.AppenderQuery.count),
    [extend()](#sqlalchemy.orm.AppenderQuery.extend), [remove()](#sqlalchemy.orm.AppenderQuery.remove)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.orm.AppenderQuery`](#sqlalchemy.orm.AppenderQuery "sqlalchemy.orm.AppenderQuery")
    (`sqlalchemy.orm.dynamic.AppenderMixin`, [`sqlalchemy.orm.Query`](queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `AppenderMixin.add()` *method of* `AppenderMixin`'
  prefs: []
  type: TYPE_NORMAL
- en: Add an item to this [`AppenderQuery`](#sqlalchemy.orm.AppenderQuery "sqlalchemy.orm.AppenderQuery").
  prefs: []
  type: TYPE_NORMAL
- en: The given item will be persisted to the database in terms of the parent instance’s
    collection on the next flush.
  prefs: []
  type: TYPE_NORMAL
- en: This method is provided to assist in delivering forwards-compatibility with
    the [`WriteOnlyCollection`](#sqlalchemy.orm.WriteOnlyCollection "sqlalchemy.orm.WriteOnlyCollection")
    collection class.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `AppenderMixin.add_all()` *method of* `AppenderMixin`'
  prefs: []
  type: TYPE_NORMAL
- en: Add an iterable of items to this [`AppenderQuery`](#sqlalchemy.orm.AppenderQuery
    "sqlalchemy.orm.AppenderQuery").
  prefs: []
  type: TYPE_NORMAL
- en: The given items will be persisted to the database in terms of the parent instance’s
    collection on the next flush.
  prefs: []
  type: TYPE_NORMAL
- en: This method is provided to assist in delivering forwards-compatibility with
    the [`WriteOnlyCollection`](#sqlalchemy.orm.WriteOnlyCollection "sqlalchemy.orm.WriteOnlyCollection")
    collection class.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `AppenderMixin.append()` *method of* `AppenderMixin`'
  prefs: []
  type: TYPE_NORMAL
- en: Append an item to this [`AppenderQuery`](#sqlalchemy.orm.AppenderQuery "sqlalchemy.orm.AppenderQuery").
  prefs: []
  type: TYPE_NORMAL
- en: The given item will be persisted to the database in terms of the parent instance’s
    collection on the next flush.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `AppenderMixin.count()` *method of* `AppenderMixin`'
  prefs: []
  type: TYPE_NORMAL
- en: Return a count of rows this the SQL formed by this [`Query`](queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") would return.
  prefs: []
  type: TYPE_NORMAL
- en: 'This generates the SQL for this Query as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: The above SQL returns a single row, which is the aggregate value of the count
    function; the [`Query.count()`](queryguide/query.html#sqlalchemy.orm.Query.count
    "sqlalchemy.orm.Query.count") method then returns that single integer value.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that the value returned by count() is **not the same
    as the number of ORM objects that this Query would return from a method such as
    the .all() method**. The [`Query`](queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object, when asked to return full entities, will **deduplicate
    entries based on primary key**, meaning if the same primary key value would appear
    in the results more than once, only one object of that primary key would be present.
    This does not apply to a query that is against individual columns.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[My Query does not return the same number of objects as query.count() tells
    me - why?](../faq/sessions.html#faq-query-deduplicating)'
  prefs: []
  type: TYPE_NORMAL
- en: 'For fine grained control over specific columns to count, to skip the usage
    of a subquery or otherwise control of the FROM clause, or to use other aggregate
    functions, use [`expression.func`](../core/sqlelement.html#sqlalchemy.sql.expression.func
    "sqlalchemy.sql.expression.func") expressions in conjunction with [`Session.query()`](session_api.html#sqlalchemy.orm.Session.query
    "sqlalchemy.orm.Session.query"), i.e.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[2.0 Migration - ORM Usage](../changelog/migration_20.html#migration-20-query-usage)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `AppenderMixin.extend()` *method of* `AppenderMixin`'
  prefs: []
  type: TYPE_NORMAL
- en: Add an iterable of items to this [`AppenderQuery`](#sqlalchemy.orm.AppenderQuery
    "sqlalchemy.orm.AppenderQuery").
  prefs: []
  type: TYPE_NORMAL
- en: The given items will be persisted to the database in terms of the parent instance’s
    collection on the next flush.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `AppenderMixin.remove()` *method of* `AppenderMixin`'
  prefs: []
  type: TYPE_NORMAL
- en: Remove an item from this [`AppenderQuery`](#sqlalchemy.orm.AppenderQuery "sqlalchemy.orm.AppenderQuery").
  prefs: []
  type: TYPE_NORMAL
- en: The given item will be removed from the parent instance’s collection on the
    next flush.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: Represent the ORM mapped attribute type for a “dynamic” relationship.
  prefs: []
  type: TYPE_NORMAL
- en: The [`DynamicMapped`](#sqlalchemy.orm.DynamicMapped "sqlalchemy.orm.DynamicMapped")
    type annotation may be used in an [Annotated Declarative Table](declarative_tables.html#orm-declarative-mapped-column)
    mapping to indicate that the `lazy="dynamic"` loader strategy should be used for
    a particular [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship").
  prefs: []
  type: TYPE_NORMAL
- en: Legacy Feature
  prefs: []
  type: TYPE_NORMAL
- en: The “dynamic” lazy loader strategy is the legacy form of what is now the “write_only”
    strategy described in the section [Write Only Relationships](#write-only-relationship).
  prefs: []
  type: TYPE_NORMAL
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: See the section [Dynamic Relationship Loaders](#dynamic-relationship) for background.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Dynamic Relationship Loaders](#dynamic-relationship) - complete background'
  prefs: []
  type: TYPE_NORMAL
- en: '[`WriteOnlyMapped`](#sqlalchemy.orm.WriteOnlyMapped "sqlalchemy.orm.WriteOnlyMapped")
    - fully 2.0 style version'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.orm.DynamicMapped`](#sqlalchemy.orm.DynamicMapped "sqlalchemy.orm.DynamicMapped")
    (`sqlalchemy.orm.base._MappedAnnotationBase`)
  prefs: []
  type: TYPE_NORMAL
- en: '## Setting RaiseLoad'
  prefs: []
  type: TYPE_NORMAL
- en: 'A “raise”-loaded relationship will raise an [`InvalidRequestError`](../core/exceptions.html#sqlalchemy.exc.InvalidRequestError
    "sqlalchemy.exc.InvalidRequestError") where the attribute would normally emit
    a lazy load:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: Above, attribute access on the `children` collection will raise an exception
    if it was not previously populated. This includes read access but for collections
    will also affect write access, as collections can’t be mutated without first loading
    them. The rationale for this is to ensure that an application is not emitting
    any unexpected lazy loads within a certain context. Rather than having to read
    through SQL logs to determine that all necessary attributes were eager loaded,
    the “raise” strategy will cause unloaded attributes to raise immediately if accessed.
    The raise strategy is also available on a query option basis using the [`raiseload()`](queryguide/relationships.html#sqlalchemy.orm.raiseload
    "sqlalchemy.orm.raiseload") loader option.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Preventing unwanted lazy loads using raiseload](queryguide/relationships.html#prevent-lazy-with-raiseload)'
  prefs: []
  type: TYPE_NORMAL
- en: Using Passive Deletes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An important aspect of collection management in SQLAlchemy is that when an object
    that refers to a collection is deleted, SQLAlchemy needs to consider the objects
    that are inside this collection. Those objects will need to be de-associated from
    the parent, which for a one-to-many collection would mean that foreign key columns
    are set to NULL, or based on [cascade](cascades.html#unitofwork-cascades) settings,
    may instead want to emit a DELETE for these rows.
  prefs: []
  type: TYPE_NORMAL
- en: The [unit of work](../glossary.html#term-unit-of-work) process only considers
    objects on a row-by-row basis, meaning a DELETE operation implies that all rows
    within a collection must be fully loaded into memory inside the flush process.
    This is not feasible for large collections, so we instead seek to rely upon the
    database’s own capability to update or delete the rows automatically using foreign
    key ON DELETE rules, instructing the unit of work to forego actually needing to
    load these rows in order to handle them. The unit of work can be instructed to
    work in this manner by configuring [`relationship.passive_deletes`](relationship_api.html#sqlalchemy.orm.relationship.params.passive_deletes
    "sqlalchemy.orm.relationship") on the [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") construct; the foreign key constraints in use must
    also be correctly configured.
  prefs: []
  type: TYPE_NORMAL
- en: For further detail on a complete “passive delete” configuration, see the section
    [Using foreign key ON DELETE cascade with ORM relationships](cascades.html#passive-deletes).
  prefs: []
  type: TYPE_NORMAL
