["```py\njax.experimental.custom_partitioning.custom_partitioning(fun, static_argnums=())\n```", "```py\n@custom_partitioning\ndef f(*args):\n  return ...\n\ndef propagate_user_sharding(mesh, user_shape):\n  '''Update the sharding of the op from a user's shape.sharding.'''\n  user_sharding = jax.tree.map(lambda x: x.sharding, user_shape)\n\ndef partition(mesh, arg_shapes, result_shape):\n  def lower_fn(*args):\n    ... builds computation on per-device shapes ...\n  result_shardings = jax.tree.map(lambda x: x.sharding, result_shape)\n  arg_shardings = jax.tree.map(lambda x: x.sharding, arg_shapes)\n  # result_sharding and arg_shardings may optionally be modified and the\n  # partitioner will insert collectives to reshape.\n  return mesh, lower_fn, result_sharding, arg_shardings\n\ndef infer_sharding_from_operands(mesh, arg_shapes, shape):\n  '''Compute the result sharding from the sharding of the operands.'''\n  arg_shardings = jax.tree.map(lambda x: x.sharding, arg_shapes)\n\nf.def_partition(partition, propagate_user_sharding, infer_sharding_from_operands) \n```", "```pyGSPMDSharding``s to ``NamedSharding```", "```py\nimport jax\nfrom jax.sharding import NamedSharding\nfrom jax.experimental.custom_partitioning import custom_partitioning\nfrom jax.experimental.pjit import pjit\nfrom jax.sharding import PartitionSpec as P\nfrom jax.sharding import Mesh\nfrom jax.numpy.fft import fft\nimport regex as re\nimport numpy as np\n\n# Pattern to detect all-gather or dynamic-slice in the generated HLO\n_PATTERN = '(dynamic-slice|all-gather)'\n\n# For an N-D input, keeps sharding along the first N-1 dimensions\n# but replicate along the last dimension\ndef supported_sharding(sharding, shape):\n    rank = len(shape.shape)\n    max_shared_dims = min(len(sharding.spec), rank-1)\n    names = tuple(sharding.spec[:max_shared_dims]) + tuple(None for _ in range(rank - max_shared_dims))\n    return NamedSharding(sharding.mesh, P(*names))\n\ndef partition(mesh, arg_shapes, result_shape):\n    result_shardings = jax.tree.map(lambda x: x.sharding, result_shape)\n    arg_shardings = jax.tree.map(lambda x: x.sharding, arg_shapes)\n    return mesh, fft,               supported_sharding(arg_shardings[0], arg_shapes[0]),               (supported_sharding(arg_shardings[0], arg_shapes[0]),)\n\ndef infer_sharding_from_operands(mesh, arg_shapes, result_shape):\n    arg_shardings = jax.tree.map(lambda x: x.sharding, arg_shapes)\n    return supported_sharding(arg_shardings[0], arg_shapes[0])\n\n@custom_partitioning\ndef my_fft(x):\n    return fft(x)\n\nmy_fft.def_partition(\n    infer_sharding_from_operands=infer_sharding_from_operands,\n    partition=partition) \n```", "```py\nwith Mesh(np.array(jax.devices()), ('x',)):\n  x = np.asarray(np.random.randn(32*1024, 1024), dtype=np.complex64)\n  y = pjit(lambda x: x, in_shardings=None, out_shardings=P('x'))(x)\n  pjit_my_fft = pjit(my_fft, in_shardings=P('x'), out_shardings=P('x'))\n  pjit_fft    = pjit(fft,    in_shardings=P('x'), out_shardings=P('x'))\n  print(pjit_my_fft(y))\n  print(pjit_fft(y))\n  # dynamic-slice or all-gather are not present in the HLO for my_fft, because x is a 2D array\n  assert(re.search(_PATTERN, pjit_my_fft.lower(x).compile().runtime_executable().hlo_modules()[0].to_string()) is None)\n  # dynamic-slice or all-gather are present in the HLO for fft\n  assert(re.search(_PATTERN, pjit_fft.lower(x).compile().runtime_executable().hlo_modules()[0].to_string())    is not None) \n```", "```py\n# my_fft\n[[-38.840824   +0.j        -40.649452  +11.845365j\n...\n  -1.6937828  +0.8402481j  15.999859   -4.0156755j]]\n\n# jax.numpy.fft.fft\n[[-38.840824   +0.j        -40.649452  +11.845365j\n  ...\n  -1.6937828  +0.8402481j  15.999859   -4.0156755j]] \n```", "```py\nwith Mesh(np.array(jax.devices()), ('x',)):\n  x = np.asarray(np.random.randn(32*1024*1024), dtype=np.complex64)\n  y = pjit(lambda x: x, in_shardings=None, out_shardings=P('x'))(x)\n  pjit_my_fft = pjit(my_fft, in_shardings=P('x'), out_shardings=P('x'))\n  pjit_fft    = pjit(fft,    in_shardings=P('x'), out_shardings=P('x'))\n  print(pjit_my_fft(y))\n  print(pjit_fft(y))\n  # dynamic-slice or all-gather are present in the HLO for my_fft, because x is a 1D array\n  assert(re.search(_PATTERN, pjit_my_fft.lower(x).compile().runtime_executable().hlo_modules()[0].to_string()) is None)\n  # dynamic-slice or all-gather are present in the HLO for fft\n  assert(re.search(_PATTERN, pjit_fft.lower(x).compile().runtime_executable().hlo_modules()[0].to_string())    is not None) \n```", "```py\n# my_fft\n[    7.217285   +0.j     -3012.4937  +4287.635j   -405.83594 +3042.984j\n...  1422.4502  +7271.4297j  -405.84033 -3042.983j\n-3012.4963  -4287.6343j]\n\n# jax.numpy.fft.fft\n[    7.217285   +0.j     -3012.4937  +4287.635j   -405.83594 +3042.984j\n...  1422.4502  +7271.4297j  -405.84033 -3042.983j\n-3012.4963  -4287.6343j] \n```"]