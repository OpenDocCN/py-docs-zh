- en: PostgreSQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.sqlalchemy.org/en/20/dialects/postgresql.html](https://docs.sqlalchemy.org/en/20/dialects/postgresql.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Support for the PostgreSQL database.
  prefs: []
  type: TYPE_NORMAL
- en: The following table summarizes current support levels for database release versions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Supported PostgreSQL versions**'
  prefs: []
  type: TYPE_NORMAL
- en: '| Support type | Versions |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| [Fully tested in CI](index.html#term-Fully-tested-in-CI) | 12, 13, 14, 15
    |'
  prefs: []
  type: TYPE_TB
- en: '| [Normal support](index.html#term-Normal-support) | 9.6+ |'
  prefs: []
  type: TYPE_TB
- en: '| [Best effort](index.html#term-Best-effort) | 9+ |'
  prefs: []
  type: TYPE_TB
- en: DBAPI Support
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following dialect/DBAPI options are available. Please refer to individual
    DBAPI sections for connect information.
  prefs: []
  type: TYPE_NORMAL
- en: '[psycopg2](#module-sqlalchemy.dialects.postgresql.psycopg2)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[psycopg (a.k.a. psycopg 3)](#module-sqlalchemy.dialects.postgresql.psycopg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[pg8000](#module-sqlalchemy.dialects.postgresql.pg8000)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[asyncpg](#module-sqlalchemy.dialects.postgresql.asyncpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[psycopg2cffi](#module-sqlalchemy.dialects.postgresql.psycopg2cffi)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '## Sequences/SERIAL/IDENTITY'
  prefs: []
  type: TYPE_NORMAL
- en: PostgreSQL supports sequences, and SQLAlchemy uses these as the default means
    of creating new primary key values for integer-based primary key columns. When
    creating tables, SQLAlchemy will issue the `SERIAL` datatype for integer-based
    primary key columns, which generates a sequence and server side default corresponding
    to the column.
  prefs: []
  type: TYPE_NORMAL
- en: 'To specify a specific named sequence to be used for primary key generation,
    use the [`Sequence()`](../core/defaults.html#sqlalchemy.schema.Sequence "sqlalchemy.schema.Sequence")
    construct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: When SQLAlchemy issues a single INSERT statement, to fulfill the contract of
    having the “last insert identifier” available, a RETURNING clause is added to
    the INSERT statement which specifies the primary key columns should be returned
    after the statement completes. The RETURNING functionality only takes place if
    PostgreSQL 8.2 or later is in use. As a fallback approach, the sequence, whether
    specified explicitly or implicitly via `SERIAL`, is executed independently beforehand,
    the returned value to be used in the subsequent insert. Note that when an [`insert()`](../core/dml.html#sqlalchemy.sql.expression.insert
    "sqlalchemy.sql.expression.insert") construct is executed using “executemany”
    semantics, the “last inserted identifier” functionality does not apply; no RETURNING
    clause is emitted nor is the sequence pre-executed in this case.
  prefs: []
  type: TYPE_NORMAL
- en: PostgreSQL 10 and above IDENTITY columns
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'PostgreSQL 10 and above have a new IDENTITY feature that supersedes the use
    of SERIAL. The [`Identity`](../core/defaults.html#sqlalchemy.schema.Identity "sqlalchemy.schema.Identity")
    construct in a [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    can be used to control its behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The CREATE TABLE for the above [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") object would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Changed in version 1.4: Added [`Identity`](../core/defaults.html#sqlalchemy.schema.Identity
    "sqlalchemy.schema.Identity") construct in a [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") to specify the option of an autoincrementing column.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Previous versions of SQLAlchemy did not have built-in support for rendering
    of IDENTITY, and could use the following compilation hook to replace occurrences
    of SERIAL with IDENTITY:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the above, a table such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Will generate on the backing database as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]  ## Server Side Cursors'
  prefs: []
  type: TYPE_NORMAL
- en: Server-side cursor support is available for the psycopg2, asyncpg dialects and
    may also be available in others.
  prefs: []
  type: TYPE_NORMAL
- en: 'Server side cursors are enabled on a per-statement basis by using the [`Connection.execution_options.stream_results`](../core/connections.html#sqlalchemy.engine.Connection.execution_options.params.stream_results
    "sqlalchemy.engine.Connection.execution_options") connection execution option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Note that some kinds of SQL statements may not be supported with server side
    cursors; generally, only SQL statements that return rows should be used with this
    option.
  prefs: []
  type: TYPE_NORMAL
- en: 'Deprecated since version 1.4: The dialect-level server_side_cursors flag is
    deprecated and will be removed in a future release. Please use the [`Connection.stream_results`](../core/connections.html#sqlalchemy.engine.Connection.params.stream_results
    "sqlalchemy.engine.Connection") execution option for unbuffered cursor support.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Using Server Side Cursors (a.k.a. stream results)](../core/connections.html#engine-stream-results)  ##
    Transaction Isolation Level'
  prefs: []
  type: TYPE_NORMAL
- en: Most SQLAlchemy dialects support setting of transaction isolation level using
    the [`create_engine.isolation_level`](../core/engines.html#sqlalchemy.create_engine.params.isolation_level
    "sqlalchemy.create_engine") parameter at the [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") level, and at the [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") level via the [`Connection.execution_options.isolation_level`](../core/connections.html#sqlalchemy.engine.Connection.execution_options.params.isolation_level
    "sqlalchemy.engine.Connection.execution_options") parameter.
  prefs: []
  type: TYPE_NORMAL
- en: For PostgreSQL dialects, this feature works either by making use of the DBAPI-specific
    features, such as psycopg2’s isolation level flags which will embed the isolation
    level setting inline with the `"BEGIN"` statement, or for DBAPIs with no direct
    support by emitting `SET SESSION CHARACTERISTICS AS TRANSACTION ISOLATION LEVEL
    <level>` ahead of the `"BEGIN"` statement emitted by the DBAPI. For the special
    AUTOCOMMIT isolation level, DBAPI-specific techniques are used which is typically
    an `.autocommit` flag on the DBAPI connection object.
  prefs: []
  type: TYPE_NORMAL
- en: 'To set isolation level using [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'To set using per-connection execution options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: There are also more options for isolation level configurations, such as “sub-engine”
    objects linked to a main [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") which each apply different isolation level settings.
    See the discussion at [Setting Transaction Isolation Levels including DBAPI Autocommit](../core/connections.html#dbapi-autocommit)
    for background.
  prefs: []
  type: TYPE_NORMAL
- en: 'Valid values for `isolation_level` on most PostgreSQL dialects include:'
  prefs: []
  type: TYPE_NORMAL
- en: '`READ COMMITTED`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`READ UNCOMMITTED`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`REPEATABLE READ`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SERIALIZABLE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AUTOCOMMIT`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Setting Transaction Isolation Levels including DBAPI Autocommit](../core/connections.html#dbapi-autocommit)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Setting READ ONLY / DEFERRABLE](#postgresql-readonly-deferrable)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Psycopg2 Transaction Isolation Level](#psycopg2-isolation-level)'
  prefs: []
  type: TYPE_NORMAL
- en: '[pg8000 Transaction Isolation Level](#pg8000-isolation-level)  ## Setting READ
    ONLY / DEFERRABLE'
  prefs: []
  type: TYPE_NORMAL
- en: 'Most PostgreSQL dialects support setting the “READ ONLY” and “DEFERRABLE” characteristics
    of the transaction, which is in addition to the isolation level setting. These
    two attributes can be established either in conjunction with or independently
    of the isolation level by passing the `postgresql_readonly` and `postgresql_deferrable`
    flags with [`Connection.execution_options()`](../core/connections.html#sqlalchemy.engine.Connection.execution_options
    "sqlalchemy.engine.Connection.execution_options"). The example below illustrates
    passing the `"SERIALIZABLE"` isolation level at the same time as setting “READ
    ONLY” and “DEFERRABLE”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note that some DBAPIs such as asyncpg only support “readonly” with SERIALIZABLE
    isolation.
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 1.4: added support for the `postgresql_readonly` and `postgresql_deferrable`
    execution options.  ## Temporary Table / Resource Reset for Connection Pooling'
  prefs: []
  type: TYPE_NORMAL
- en: The [`QueuePool`](../core/pooling.html#sqlalchemy.pool.QueuePool "sqlalchemy.pool.QueuePool")
    connection pool implementation used by the SQLAlchemy [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") object includes [reset on return](../core/pooling.html#pool-reset-on-return)
    behavior that will invoke the DBAPI `.rollback()` method when connections are
    returned to the pool. While this rollback will clear out the immediate state used
    by the previous transaction, it does not cover a wider range of session-level
    state, including temporary tables as well as other server state such as prepared
    statement handles and statement caches. The PostgreSQL database includes a variety
    of commands which may be used to reset this state, including `DISCARD`, `RESET`,
    `DEALLOCATE`, and `UNLISTEN`.
  prefs: []
  type: TYPE_NORMAL
- en: To install one or more of these commands as the means of performing reset-on-return,
    the [`PoolEvents.reset()`](../core/events.html#sqlalchemy.events.PoolEvents.reset
    "sqlalchemy.events.PoolEvents.reset") event hook may be used, as demonstrated
    in the example below. The implementation will end transactions in progress as
    well as discard temporary tables using the `CLOSE`, `RESET` and `DISCARD` commands;
    see the PostgreSQL documentation for background on what each of these statements
    do.
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`create_engine.pool_reset_on_return`](../core/engines.html#sqlalchemy.create_engine.params.pool_reset_on_return
    "sqlalchemy.create_engine") parameter is set to `None` so that the custom scheme
    can replace the default behavior completely. The custom hook implementation calls
    `.rollback()` in any case, as it’s usually important that the DBAPI’s own tracking
    of commit/rollback will remain consistent with the state of the transaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Changed in version 2.0.0b3: Added additional state arguments to the [`PoolEvents.reset()`](../core/events.html#sqlalchemy.events.PoolEvents.reset
    "sqlalchemy.events.PoolEvents.reset") event and additionally ensured the event
    is invoked for all “reset” occurrences, so that it’s appropriate as a place for
    custom “reset” handlers. Previous schemes which use the [`PoolEvents.checkin()`](../core/events.html#sqlalchemy.events.PoolEvents.checkin
    "sqlalchemy.events.PoolEvents.checkin") handler remain usable as well.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Reset On Return](../core/pooling.html#pool-reset-on-return) - in the [Connection
    Pooling](../core/pooling.html) documentation  ## Setting Alternate Search Paths
    on Connect'
  prefs: []
  type: TYPE_NORMAL
- en: 'The PostgreSQL `search_path` variable refers to the list of schema names that
    will be implicitly referenced when a particular table or other object is referenced
    in a SQL statement. As detailed in the next section [Remote-Schema Table Introspection
    and PostgreSQL search_path](#postgresql-schema-reflection), SQLAlchemy is generally
    organized around the concept of keeping this variable at its default value of
    `public`, however, in order to have it set to any arbitrary name or names when
    connections are used automatically, the “SET SESSION search_path” command may
    be invoked for all connections in a pool using the following event handler, as
    discussed at [Setting a Default Schema for New Connections](../core/metadata.html#schema-set-default-connections):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The reason the recipe is complicated by use of the `.autocommit` DBAPI attribute
    is so that when the `SET SESSION search_path` directive is invoked, it is invoked
    outside of the scope of any transaction and therefore will not be reverted when
    the DBAPI connection has a rollback.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Setting a Default Schema for New Connections](../core/metadata.html#schema-set-default-connections)
    - in the [Describing Databases with MetaData](../core/metadata.html) documentation  ##
    Remote-Schema Table Introspection and PostgreSQL search_path'
  prefs: []
  type: TYPE_NORMAL
- en: Section Best Practices Summarized
  prefs: []
  type: TYPE_NORMAL
- en: keep the `search_path` variable set to its default of `public`, without any
    other schema names. Ensure the username used to connect **does not** match remote
    schemas, or ensure the `"$user"` token is **removed** from `search_path`. For
    other schema names, name these explicitly within [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") definitions. Alternatively, the `postgresql_ignore_search_path`
    option will cause all reflected [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects to have a [`Table.schema`](../core/metadata.html#sqlalchemy.schema.Table.schema
    "sqlalchemy.schema.Table.schema") attribute set up.
  prefs: []
  type: TYPE_NORMAL
- en: The PostgreSQL dialect can reflect tables from any schema, as outlined in [Reflecting
    Tables from Other Schemas](../core/reflection.html#metadata-reflection-schemas).
  prefs: []
  type: TYPE_NORMAL
- en: 'In all cases, the first thing SQLAlchemy does when reflecting tables is to
    **determine the default schema for the current database connection**. It does
    this using the PostgreSQL `current_schema()` function, illustated below using
    a PostgreSQL client session (i.e. using the `psql` tool):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Above we see that on a plain install of PostgreSQL, the default schema name
    is the name `public`.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if your database username **matches the name of a schema**, PostgreSQL’s
    default is to then **use that name as the default schema**. Below, we log in using
    the username `scott`. When we create a schema named `scott`, **it implicitly changes
    the default schema**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The behavior of `current_schema()` is derived from the [PostgreSQL search path](https://www.postgresql.org/docs/current/static/ddl-schemas.html#DDL-SCHEMAS-PATH)
    variable `search_path`, which in modern PostgreSQL versions defaults to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Where above, the `"$user"` variable will inject the current username as the
    default schema, if one exists. Otherwise, `public` is used.
  prefs: []
  type: TYPE_NORMAL
- en: When a [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    object is reflected, if it is present in the schema indicated by the `current_schema()`
    function, **the schema name assigned to the “.schema” attribute of the Table is
    the Python “None” value**. Otherwise, the “.schema” attribute will be assigned
    the string name of that schema.
  prefs: []
  type: TYPE_NORMAL
- en: With regards to tables which these [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects refer to via foreign key constraint, a decision
    must be made as to how the `.schema` is represented in those remote tables, in
    the case where that remote schema name is also a member of the current `search_path`.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, the PostgreSQL dialect mimics the behavior encouraged by PostgreSQL’s
    own `pg_get_constraintdef()` builtin procedure. This function returns a sample
    definition for a particular foreign key constraint, omitting the referenced schema
    name from that definition when the name is also in the PostgreSQL schema search
    path. The interaction below illustrates this behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Above, we created a table `referred` as a member of the remote schema `test_schema`,
    however when we added `test_schema` to the PG `search_path` and then asked `pg_get_constraintdef()`
    for the `FOREIGN KEY` syntax, `test_schema` was not included in the output of
    the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, if we set the search path back to the typical default of
    `public`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The same query against `pg_get_constraintdef()` now returns the fully schema-qualified
    name for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'SQLAlchemy will by default use the return value of `pg_get_constraintdef()`
    in order to determine the remote schema name. That is, if our `search_path` were
    set to include `test_schema`, and we invoked a table reflection process as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The above process would deliver to the [`MetaData.tables`](../core/metadata.html#sqlalchemy.schema.MetaData.tables
    "sqlalchemy.schema.MetaData.tables") collection `referred` table named **without**
    the schema:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'To alter the behavior of reflection such that the referred schema is maintained
    regardless of the `search_path` setting, use the `postgresql_ignore_search_path`
    option, which can be specified as a dialect-specific argument to both [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") as well as [`MetaData.reflect()`](../core/metadata.html#sqlalchemy.schema.MetaData.reflect
    "sqlalchemy.schema.MetaData.reflect"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We will now have `test_schema.referred` stored as schema-qualified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Interaction of Schema-qualified Reflection with the Default Schema](../core/reflection.html#reflection-schema-qualified-interaction)
    - discussion of the issue from a backend-agnostic perspective'
  prefs: []
  type: TYPE_NORMAL
- en: '[The Schema Search Path](https://www.postgresql.org/docs/current/static/ddl-schemas.html#DDL-SCHEMAS-PATH)
    - on the PostgreSQL website.'
  prefs: []
  type: TYPE_NORMAL
- en: INSERT/UPDATE…RETURNING
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The dialect supports PG 8.2’s `INSERT..RETURNING`, `UPDATE..RETURNING` and
    `DELETE..RETURNING` syntaxes. `INSERT..RETURNING` is used by default for single-row
    INSERT statements in order to fetch newly generated primary key identifiers. To
    specify an explicit `RETURNING` clause, use the `_UpdateBase.returning()` method
    on a per-statement basis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '## INSERT…ON CONFLICT (Upsert)'
  prefs: []
  type: TYPE_NORMAL
- en: Starting with version 9.5, PostgreSQL allows “upserts” (update or insert) of
    rows into a table via the `ON CONFLICT` clause of the `INSERT` statement. A candidate
    row will only be inserted if that row does not violate any unique constraints.
    In the case of a unique constraint violation, a secondary action can occur which
    can be either “DO UPDATE”, indicating that the data in the target row should be
    updated, or “DO NOTHING”, which indicates to silently skip this row.
  prefs: []
  type: TYPE_NORMAL
- en: Conflicts are determined using existing unique constraints and indexes. These
    constraints may be identified either using their name as stated in DDL, or they
    may be inferred by stating the columns and conditions that comprise the indexes.
  prefs: []
  type: TYPE_NORMAL
- en: 'SQLAlchemy provides `ON CONFLICT` support via the PostgreSQL-specific [`insert()`](#sqlalchemy.dialects.postgresql.insert
    "sqlalchemy.dialects.postgresql.insert") function, which provides the generative
    methods [`Insert.on_conflict_do_update()`](#sqlalchemy.dialects.postgresql.Insert.on_conflict_do_update
    "sqlalchemy.dialects.postgresql.Insert.on_conflict_do_update") and [`Insert.on_conflict_do_nothing()`](#sqlalchemy.dialects.postgresql.Insert.on_conflict_do_nothing
    "sqlalchemy.dialects.postgresql.Insert.on_conflict_do_nothing"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[INSERT .. ON CONFLICT](https://www.postgresql.org/docs/current/static/sql-insert.html#SQL-ON-CONFLICT)
    - in the PostgreSQL documentation.'
  prefs: []
  type: TYPE_NORMAL
- en: Specifying the Target
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Both methods supply the “target” of the conflict using either the named constraint
    or by column inference:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`Insert.on_conflict_do_update.index_elements`](#sqlalchemy.dialects.postgresql.Insert.on_conflict_do_update.params.index_elements
    "sqlalchemy.dialects.postgresql.Insert.on_conflict_do_update") argument specifies
    a sequence containing string column names, [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects, and/or SQL expression elements, which would
    identify a unique index:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When using [`Insert.on_conflict_do_update.index_elements`](#sqlalchemy.dialects.postgresql.Insert.on_conflict_do_update.params.index_elements
    "sqlalchemy.dialects.postgresql.Insert.on_conflict_do_update") to infer an index,
    a partial index can be inferred by also specifying the use the [`Insert.on_conflict_do_update.index_where`](#sqlalchemy.dialects.postgresql.Insert.on_conflict_do_update.params.index_where
    "sqlalchemy.dialects.postgresql.Insert.on_conflict_do_update") parameter:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The [`Insert.on_conflict_do_update.constraint`](#sqlalchemy.dialects.postgresql.Insert.on_conflict_do_update.params.constraint
    "sqlalchemy.dialects.postgresql.Insert.on_conflict_do_update") argument is used
    to specify an index directly rather than inferring it. This can be the name of
    a UNIQUE constraint, a PRIMARY KEY constraint, or an INDEX:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The [`Insert.on_conflict_do_update.constraint`](#sqlalchemy.dialects.postgresql.Insert.on_conflict_do_update.params.constraint
    "sqlalchemy.dialects.postgresql.Insert.on_conflict_do_update") argument may also
    refer to a SQLAlchemy construct representing a constraint, e.g. [`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint"), [`PrimaryKeyConstraint`](../core/constraints.html#sqlalchemy.schema.PrimaryKeyConstraint
    "sqlalchemy.schema.PrimaryKeyConstraint"), [`Index`](../core/constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index"), or [`ExcludeConstraint`](#sqlalchemy.dialects.postgresql.ExcludeConstraint
    "sqlalchemy.dialects.postgresql.ExcludeConstraint"). In this use, if the constraint
    has a name, it is used directly. Otherwise, if the constraint is unnamed, then
    inference will be used, where the expressions and optional WHERE clause of the
    constraint will be spelled out in the construct. This use is especially convenient
    to refer to the named or unnamed primary key of a [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") using the [`Table.primary_key`](../core/metadata.html#sqlalchemy.schema.Table.primary_key
    "sqlalchemy.schema.Table.primary_key") attribute:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The SET Clause
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`ON CONFLICT...DO UPDATE` is used to perform an update of the already existing
    row, using any combination of new values as well as values from the proposed insertion.
    These values are specified using the [`Insert.on_conflict_do_update.set_`](#sqlalchemy.dialects.postgresql.Insert.on_conflict_do_update.params.set_
    "sqlalchemy.dialects.postgresql.Insert.on_conflict_do_update") parameter. This
    parameter accepts a dictionary which consists of direct values for UPDATE:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: The `Insert.on_conflict_do_update()` method does **not** take into account Python-side
    default UPDATE values or generation functions, e.g. those specified using [`Column.onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.onupdate
    "sqlalchemy.schema.Column"). These values will not be exercised for an ON CONFLICT
    style of UPDATE, unless they are manually specified in the [`Insert.on_conflict_do_update.set_`](#sqlalchemy.dialects.postgresql.Insert.on_conflict_do_update.params.set_
    "sqlalchemy.dialects.postgresql.Insert.on_conflict_do_update") dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: Updating using the Excluded INSERT Values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In order to refer to the proposed insertion row, the special alias [`Insert.excluded`](#sqlalchemy.dialects.postgresql.Insert.excluded
    "sqlalchemy.dialects.postgresql.Insert.excluded") is available as an attribute
    on the [`Insert`](#sqlalchemy.dialects.postgresql.Insert "sqlalchemy.dialects.postgresql.Insert")
    object; this object is a [`ColumnCollection`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnCollection
    "sqlalchemy.sql.expression.ColumnCollection") which alias contains all columns
    of the target table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Additional WHERE Criteria
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `Insert.on_conflict_do_update()` method also accepts a WHERE clause using
    the [`Insert.on_conflict_do_update.where`](#sqlalchemy.dialects.postgresql.Insert.on_conflict_do_update.params.where
    "sqlalchemy.dialects.postgresql.Insert.on_conflict_do_update") parameter, which
    will limit those rows which receive an UPDATE:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Skipping Rows with DO NOTHING
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`ON CONFLICT` may be used to skip inserting a row entirely if any conflict
    with a unique or exclusion constraint occurs; below this is illustrated using
    the [`Insert.on_conflict_do_nothing()`](#sqlalchemy.dialects.postgresql.Insert.on_conflict_do_nothing
    "sqlalchemy.dialects.postgresql.Insert.on_conflict_do_nothing") method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'If `DO NOTHING` is used without specifying any columns or constraint, it has
    the effect of skipping the INSERT for any unique or exclusion constraint violation
    which occurs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]  ## Full Text Search'
  prefs: []
  type: TYPE_NORMAL
- en: PostgreSQL’s full text search system is available through the use of the [`func`](../core/sqlelement.html#sqlalchemy.sql.expression.func
    "sqlalchemy.sql.expression.func") namespace, combined with the use of custom operators
    via the [`Operators.bool_op()`](../core/sqlelement.html#sqlalchemy.sql.expression.Operators.bool_op
    "sqlalchemy.sql.expression.Operators.bool_op") method. For simple cases with some
    degree of cross-backend compatibility, the `Operators.match()` operator may also
    be used.
  prefs: []
  type: TYPE_NORMAL
- en: '### Simple plain text matching with `match()`'
  prefs: []
  type: TYPE_NORMAL
- en: The `Operators.match()` operator provides for cross-compatible simple text matching.
    For the PostgreSQL backend, it’s hardcoded to generate an expression using the
    `@@` operator in conjunction with the `plainto_tsquery()` PostgreSQL function.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the PostgreSQL dialect, an expression like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'would emit to the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Above, passing a plain string to `Operators.match()` will automatically make
    use of `plainto_tsquery()` to specify the type of tsquery. This establishes basic
    database cross-compatibility for `Operators.match()` with other backends.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 2.0: The default tsquery generation function used by the
    PostgreSQL dialect with `Operators.match()` is `plainto_tsquery()`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To render exactly what was rendered in 1.4, use the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Which would emit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Using PostgreSQL full text functions and operators directly
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Text search operations beyond the simple use of `Operators.match()` may make
    use of the [`func`](../core/sqlelement.html#sqlalchemy.sql.expression.func "sqlalchemy.sql.expression.func")
    namespace to generate PostgreSQL full-text functions, in combination with [`Operators.bool_op()`](../core/sqlelement.html#sqlalchemy.sql.expression.Operators.bool_op
    "sqlalchemy.sql.expression.Operators.bool_op") to generate any boolean operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'would generate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The [`TSVECTOR`](#sqlalchemy.dialects.postgresql.TSVECTOR "sqlalchemy.dialects.postgresql.TSVECTOR")
    type can provide for explicit CAST:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'produces a statement equivalent to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The `func` namespace is augmented by the PostgreSQL dialect to set up correct
    argument and return types for most full text search functions. These functions
    are used automatically by the [`sqlalchemy.sql.expression.func`](../core/sqlelement.html#sqlalchemy.sql.expression.func
    "sqlalchemy.sql.expression.func") namespace assuming the `sqlalchemy.dialects.postgresql`
    package has been imported, or [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") has been invoked using a `postgresql` dialect. These
    functions are documented at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`to_tsvector`](#sqlalchemy.dialects.postgresql.to_tsvector "sqlalchemy.dialects.postgresql.to_tsvector")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`to_tsquery`](#sqlalchemy.dialects.postgresql.to_tsquery "sqlalchemy.dialects.postgresql.to_tsquery")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`plainto_tsquery`](#sqlalchemy.dialects.postgresql.plainto_tsquery "sqlalchemy.dialects.postgresql.plainto_tsquery")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`phraseto_tsquery`](#sqlalchemy.dialects.postgresql.phraseto_tsquery "sqlalchemy.dialects.postgresql.phraseto_tsquery")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`websearch_to_tsquery`](#sqlalchemy.dialects.postgresql.websearch_to_tsquery
    "sqlalchemy.dialects.postgresql.websearch_to_tsquery")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`ts_headline`](#sqlalchemy.dialects.postgresql.ts_headline "sqlalchemy.dialects.postgresql.ts_headline")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specifying the “regconfig” with `match()` or custom operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'PostgreSQL’s `plainto_tsquery()` function accepts an optional “regconfig” argument
    that is used to instruct PostgreSQL to use a particular pre-computed GIN or GiST
    index in order to perform the search. When using `Operators.match()`, this additional
    parameter may be specified using the `postgresql_regconfig` parameter, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Which would emit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'When using other PostgreSQL search functions with [`func`](../core/sqlelement.html#sqlalchemy.sql.expression.func
    "sqlalchemy.sql.expression.func"), the “regconfig” parameter may be passed directly
    as the initial argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'produces a statement equivalent to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: It is recommended that you use the `EXPLAIN ANALYZE...` tool from PostgreSQL
    to ensure that you are generating queries with SQLAlchemy that take full advantage
    of any indexes you may have created for full text search.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Full Text Search](https://www.postgresql.org/docs/current/textsearch-controls.html)
    - in the PostgreSQL documentation'
  prefs: []
  type: TYPE_NORMAL
- en: FROM ONLY …
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The dialect supports PostgreSQL’s ONLY keyword for targeting only a particular
    table in an inheritance hierarchy. This can be used to produce the `SELECT ...
    FROM ONLY`, `UPDATE ONLY ...`, and `DELETE FROM ONLY ...` syntaxes. It uses SQLAlchemy’s
    hints mechanism:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '## PostgreSQL-Specific Index Options'
  prefs: []
  type: TYPE_NORMAL
- en: Several extensions to the [`Index`](../core/constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index") construct are available, specific to the PostgreSQL
    dialect.
  prefs: []
  type: TYPE_NORMAL
- en: Covering Indexes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `postgresql_include` option renders INCLUDE(colname) for the given string
    names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: would render the index as `CREATE INDEX my_index ON table (x) INCLUDE (y)`
  prefs: []
  type: TYPE_NORMAL
- en: Note that this feature requires PostgreSQL 11 or later.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.4.
  prefs: []
  type: TYPE_NORMAL
- en: '### Partial Indexes'
  prefs: []
  type: TYPE_NORMAL
- en: 'Partial indexes add criterion to the index definition so that the index is
    applied to a subset of rows. These can be specified on [`Index`](../core/constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index") using the `postgresql_where` keyword argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]  ### Operator Classes'
  prefs: []
  type: TYPE_NORMAL
- en: 'PostgreSQL allows the specification of an *operator class* for each column
    of an index (see [https://www.postgresql.org/docs/current/interactive/indexes-opclass.html](https://www.postgresql.org/docs/current/interactive/indexes-opclass.html)).
    The [`Index`](../core/constraints.html#sqlalchemy.schema.Index "sqlalchemy.schema.Index")
    construct allows these to be specified via the `postgresql_ops` keyword argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Note that the keys in the `postgresql_ops` dictionaries are the “key” name of
    the [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column"),
    i.e. the name used to access it from the `.c` collection of [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table"), which can be configured to be different than the actual
    name of the column as expressed in the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'If `postgresql_ops` is to be used against a complex SQL expression such as
    a function call, then to apply to the column it must be given a label that is
    identified in the dictionary by name, e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Operator classes are also supported by the [`ExcludeConstraint`](#sqlalchemy.dialects.postgresql.ExcludeConstraint
    "sqlalchemy.dialects.postgresql.ExcludeConstraint") construct using the [`ExcludeConstraint.ops`](#sqlalchemy.dialects.postgresql.ExcludeConstraint.params.ops
    "sqlalchemy.dialects.postgresql.ExcludeConstraint") parameter. See that parameter
    for details.
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 1.3.21: added support for operator classes with [`ExcludeConstraint`](#sqlalchemy.dialects.postgresql.ExcludeConstraint
    "sqlalchemy.dialects.postgresql.ExcludeConstraint").'
  prefs: []
  type: TYPE_NORMAL
- en: Index Types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'PostgreSQL provides several index types: B-Tree, Hash, GiST, and GIN, as well
    as the ability for users to create their own (see [https://www.postgresql.org/docs/current/static/indexes-types.html](https://www.postgresql.org/docs/current/static/indexes-types.html)).
    These can be specified on [`Index`](../core/constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index") using the `postgresql_using` keyword argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The value passed to the keyword argument will be simply passed through to the
    underlying CREATE INDEX command, so it *must* be a valid index type for your version
    of PostgreSQL.
  prefs: []
  type: TYPE_NORMAL
- en: '### Index Storage Parameters'
  prefs: []
  type: TYPE_NORMAL
- en: 'PostgreSQL allows storage parameters to be set on indexes. The storage parameters
    available depend on the index method used by the index. Storage parameters can
    be specified on [`Index`](../core/constraints.html#sqlalchemy.schema.Index "sqlalchemy.schema.Index")
    using the `postgresql_with` keyword argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'PostgreSQL allows to define the tablespace in which to create the index. The
    tablespace can be specified on [`Index`](../core/constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index") using the `postgresql_tablespace` keyword argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the same option is available on [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") as well.  ### Indexes with CONCURRENTLY'
  prefs: []
  type: TYPE_NORMAL
- en: 'The PostgreSQL index option CONCURRENTLY is supported by passing the flag `postgresql_concurrently`
    to the [`Index`](../core/constraints.html#sqlalchemy.schema.Index "sqlalchemy.schema.Index")
    construct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The above index construct will render DDL for CREATE INDEX, assuming PostgreSQL
    8.2 or higher is detected or for a connection-less dialect, as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'For DROP INDEX, assuming PostgreSQL 9.2 or higher is detected or for a connection-less
    dialect, it will emit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'When using CONCURRENTLY, the PostgreSQL database requires that the statement
    be invoked outside of a transaction block. The Python DBAPI enforces that even
    for a single statement, a transaction is present, so to use this construct, the
    DBAPI’s “autocommit” mode must be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Transaction Isolation Level](#postgresql-isolation-level)  ## PostgreSQL Index
    Reflection'
  prefs: []
  type: TYPE_NORMAL
- en: The PostgreSQL database creates a UNIQUE INDEX implicitly whenever the UNIQUE
    CONSTRAINT construct is used. When inspecting a table using [`Inspector`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector
    "sqlalchemy.engine.reflection.Inspector"), the [`Inspector.get_indexes()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_indexes
    "sqlalchemy.engine.reflection.Inspector.get_indexes") and the [`Inspector.get_unique_constraints()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_unique_constraints
    "sqlalchemy.engine.reflection.Inspector.get_unique_constraints") will report on
    these two constructs distinctly; in the case of the index, the key `duplicates_constraint`
    will be present in the index entry if it is detected as mirroring a constraint.
    When performing reflection using `Table(..., autoload_with=engine)`, the UNIQUE
    INDEX is **not** returned in [`Table.indexes`](../core/metadata.html#sqlalchemy.schema.Table.indexes
    "sqlalchemy.schema.Table.indexes") when it is detected as mirroring a [`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint") in the [`Table.constraints`](../core/metadata.html#sqlalchemy.schema.Table.constraints
    "sqlalchemy.schema.Table.constraints") collection .
  prefs: []
  type: TYPE_NORMAL
- en: Special Reflection Options
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The [`Inspector`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector
    "sqlalchemy.engine.reflection.Inspector") used for the PostgreSQL backend is an
    instance of [`PGInspector`](#sqlalchemy.dialects.postgresql.base.PGInspector "sqlalchemy.dialects.postgresql.base.PGInspector"),
    which offers additional methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '| Object Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| [PGInspector](#sqlalchemy.dialects.postgresql.base.PGInspector) |  |'
  prefs: []
  type: TYPE_TB
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[get_domains()](#sqlalchemy.dialects.postgresql.base.PGInspector.get_domains),
    [get_enums()](#sqlalchemy.dialects.postgresql.base.PGInspector.get_enums), [get_foreign_table_names()](#sqlalchemy.dialects.postgresql.base.PGInspector.get_foreign_table_names),
    [get_table_oid()](#sqlalchemy.dialects.postgresql.base.PGInspector.get_table_oid),
    [has_type()](#sqlalchemy.dialects.postgresql.base.PGInspector.has_type)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.postgresql.base.PGInspector`](#sqlalchemy.dialects.postgresql.base.PGInspector
    "sqlalchemy.dialects.postgresql.base.PGInspector") ([`sqlalchemy.engine.reflection.Inspector`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector
    "sqlalchemy.engine.reflection.Inspector"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Return a list of DOMAIN objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each member is a dictionary containing these fields:'
  prefs: []
  type: TYPE_NORMAL
- en: name - name of the domain
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: schema - the schema name for the domain.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: visible - boolean, whether or not this domain is visible in the default search
    path.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: type - the type defined by this domain.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: nullable - Indicates if this domain can be `NULL`.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: default - The default value of the domain or `None` if the domain has no default.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'constraints - A list of dict wit the constraint defined by this domain. Each
    element constaints two keys: `name` of the constraint and `check` with the constraint
    text.'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**schema** – schema name. If None, the default schema (typically ‘public’)
    is used. May also be set to `''*''` to indicate load domains for all schemas.'
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Return a list of ENUM objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each member is a dictionary containing these fields:'
  prefs: []
  type: TYPE_NORMAL
- en: name - name of the enum
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: schema - the schema name for the enum.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: visible - boolean, whether or not this enum is visible in the default search
    path.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: labels - a list of string labels that apply to the enum.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**schema** – schema name. If None, the default schema (typically ‘public’)
    is used. May also be set to `''*''` to indicate load enums for all schemas.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Return a list of FOREIGN TABLE names.
  prefs: []
  type: TYPE_NORMAL
- en: Behavior is similar to that of [`Inspector.get_table_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_table_names
    "sqlalchemy.engine.reflection.Inspector.get_table_names"), except that the list
    is limited to those tables that report a `relkind` value of `f`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Return the OID for the given table name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`table_name` – string name of the table. For special quoting, use [`quoted_name`](../core/sqlelement.html#sqlalchemy.sql.expression.quoted_name
    "sqlalchemy.sql.expression.quoted_name").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`schema` – string schema name; if omitted, uses the default schema of the database
    connection. For special quoting, use [`quoted_name`](../core/sqlelement.html#sqlalchemy.sql.expression.quoted_name
    "sqlalchemy.sql.expression.quoted_name").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Return if the database has the specified type in the provided schema.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`type_name` – the type to check.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`schema` – schema name. If None, the default schema (typically ‘public’) is
    used. May also be set to `''*''` to check in all schemas.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: '## PostgreSQL Table Options'
  prefs: []
  type: TYPE_NORMAL
- en: 'Several options for CREATE TABLE are supported directly by the PostgreSQL dialect
    in conjunction with the [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") construct:'
  prefs: []
  type: TYPE_NORMAL
- en: '`INHERITS`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`ON COMMIT`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`PARTITION BY`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`TABLESPACE`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The above option is also available on the [`Index`](../core/constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index") construct.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`USING`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`WITH OIDS`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`WITHOUT OIDS`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[PostgreSQL CREATE TABLE options](https://www.postgresql.org/docs/current/static/sql-createtable.html)
    - in the PostgreSQL documentation.  ## PostgreSQL Constraint Options'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following option(s) are supported by the PostgreSQL dialect in conjunction
    with selected constraint constructs:'
  prefs: []
  type: TYPE_NORMAL
- en: '`NOT VALID`: This option applies towards CHECK and FOREIGN KEY constraints
    when the constraint is being added to an existing table via ALTER TABLE, and has
    the effect that existing rows are not scanned during the ALTER operation against
    the constraint being added.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When using a SQL migration tool such as [Alembic](https://alembic.sqlalchemy.org)
    that renders ALTER TABLE constructs, the `postgresql_not_valid` argument may be
    specified as an additional keyword argument within the operation that creates
    the constraint, as in the following Alembic example:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The keyword is ultimately accepted directly by the [`CheckConstraint`](../core/constraints.html#sqlalchemy.schema.CheckConstraint
    "sqlalchemy.schema.CheckConstraint"), [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") and [`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey") constructs; when using a tool like Alembic, dialect-specific
    keyword arguments are passed through to these constructs from the migration operation
    directives:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: New in version 1.4.32.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PostgreSQL ALTER TABLE options](https://www.postgresql.org/docs/current/static/sql-altertable.html)
    - in the PostgreSQL documentation.  ## Table values, Table and Column valued functions,
    Row and Tuple objects'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: PostgreSQL makes great use of modern SQL forms such as table-valued functions,
    tables and rows as values. These constructs are commonly used as part of PostgreSQL’s
    support for complex datatypes such as JSON, ARRAY, and other datatypes. SQLAlchemy’s
    SQL expression language has native support for most table-valued and row-valued
    forms.
  prefs: []
  type: TYPE_NORMAL
- en: '### Table-Valued Functions'
  prefs: []
  type: TYPE_NORMAL
- en: Many PostgreSQL built-in functions are intended to be used in the FROM clause
    of a SELECT statement, and are capable of returning table rows or sets of table
    rows. A large portion of PostgreSQL’s JSON functions for example such as `json_array_elements()`,
    `json_object_keys()`, `json_each_text()`, `json_each()`, `json_to_record()`, `json_populate_recordset()`
    use such forms. These classes of SQL function calling forms in SQLAlchemy are
    available using the [`FunctionElement.table_valued()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.table_valued
    "sqlalchemy.sql.functions.FunctionElement.table_valued") method in conjunction
    with [`Function`](../core/functions.html#sqlalchemy.sql.functions.Function "sqlalchemy.sql.functions.Function")
    objects generated from the [`func`](../core/sqlelement.html#sqlalchemy.sql.expression.func
    "sqlalchemy.sql.expression.func") namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'Examples from PostgreSQL’s reference documentation follow below:'
  prefs: []
  type: TYPE_NORMAL
- en: '`json_each()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`json_populate_record()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`json_to_record()` - this form uses a PostgreSQL specific form of derived columns
    in the alias, where we may make use of [`column()`](../core/sqlelement.html#sqlalchemy.sql.expression.column
    "sqlalchemy.sql.expression.column") elements with types to produce them. The [`FunctionElement.table_valued()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.table_valued
    "sqlalchemy.sql.functions.FunctionElement.table_valued") method produces a [`TableValuedAlias`](../core/selectable.html#sqlalchemy.sql.expression.TableValuedAlias
    "sqlalchemy.sql.expression.TableValuedAlias") construct, and the method [`TableValuedAlias.render_derived()`](../core/selectable.html#sqlalchemy.sql.expression.TableValuedAlias.render_derived
    "sqlalchemy.sql.expression.TableValuedAlias.render_derived") method sets up the
    derived columns specification:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`WITH ORDINALITY` - part of the SQL standard, `WITH ORDINALITY` adds an ordinal
    counter to the output of a function and is accepted by a limited set of PostgreSQL
    functions including `unnest()` and `generate_series()`. The [`FunctionElement.table_valued()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.table_valued
    "sqlalchemy.sql.functions.FunctionElement.table_valued") method accepts a keyword
    parameter `with_ordinality` for this purpose, which accepts the string name that
    will be applied to the “ordinality” column:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: New in version 1.4.0b2.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Table-Valued Functions](../tutorial/data_select.html#tutorial-functions-table-valued)
    - in the [SQLAlchemy Unified Tutorial](../tutorial/index.html#unified-tutorial)  ###
    Column Valued Functions'
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to the table valued function, a column valued function is present in
    the FROM clause, but delivers itself to the columns clause as a single scalar
    value. PostgreSQL functions such as `json_array_elements()`, `unnest()` and `generate_series()`
    may use this form. Column valued functions are available using the [`FunctionElement.column_valued()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.column_valued
    "sqlalchemy.sql.functions.FunctionElement.column_valued") method of [`FunctionElement`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement
    "sqlalchemy.sql.functions.FunctionElement"):'
  prefs: []
  type: TYPE_NORMAL
- en: '`json_array_elements()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`unnest()` - in order to generate a PostgreSQL ARRAY literal, the [`array()`](#sqlalchemy.dialects.postgresql.array
    "sqlalchemy.dialects.postgresql.array") construct may be used:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The function can of course be used against an existing table-bound column that’s
    of type [`ARRAY`](../core/type_basics.html#sqlalchemy.types.ARRAY "sqlalchemy.types.ARRAY"):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Column Valued Functions - Table Valued Function as a Scalar Column](../tutorial/data_select.html#tutorial-functions-column-valued)
    - in the [SQLAlchemy Unified Tutorial](../tutorial/index.html#unified-tutorial)'
  prefs: []
  type: TYPE_NORMAL
- en: Row Types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Built-in support for rendering a `ROW` may be approximated using `func.ROW`
    with the `sqlalchemy.func` namespace, or by using the [`tuple_()`](../core/sqlelement.html#sqlalchemy.sql.expression.tuple_
    "sqlalchemy.sql.expression.tuple_") construct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[PostgreSQL Row Constructors](https://www.postgresql.org/docs/current/sql-expressions.html#SQL-SYNTAX-ROW-CONSTRUCTORS)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PostgreSQL Row Constructor Comparison](https://www.postgresql.org/docs/current/functions-comparisons.html#ROW-WISE-COMPARISON)'
  prefs: []
  type: TYPE_NORMAL
- en: Table Types passed to Functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'PostgreSQL supports passing a table as an argument to a function, which is
    known as a “record” type. SQLAlchemy [`FromClause`](../core/selectable.html#sqlalchemy.sql.expression.FromClause
    "sqlalchemy.sql.expression.FromClause") objects such as [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") support this special form using the `FromClause.table_valued()`
    method, which is comparable to the [`FunctionElement.table_valued()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.table_valued
    "sqlalchemy.sql.functions.FunctionElement.table_valued") method except that the
    collection of columns is already established by that of the [`FromClause`](../core/selectable.html#sqlalchemy.sql.expression.FromClause
    "sqlalchemy.sql.expression.FromClause") itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: New in version 1.4.0b2.
  prefs: []
  type: TYPE_NORMAL
- en: ARRAY Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The PostgreSQL dialect supports arrays, both as multidimensional column types
    as well as array literals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`ARRAY`](#sqlalchemy.dialects.postgresql.ARRAY "sqlalchemy.dialects.postgresql.ARRAY")
    - ARRAY datatype'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`array`](#sqlalchemy.dialects.postgresql.array "sqlalchemy.dialects.postgresql.array")
    - array literal'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`array_agg()`](#sqlalchemy.dialects.postgresql.array_agg "sqlalchemy.dialects.postgresql.array_agg")
    - ARRAY_AGG SQL function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`aggregate_order_by`](#sqlalchemy.dialects.postgresql.aggregate_order_by "sqlalchemy.dialects.postgresql.aggregate_order_by")
    - helper for PG’s ORDER BY aggregate function syntax.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '## JSON Types'
  prefs: []
  type: TYPE_NORMAL
- en: 'The PostgreSQL dialect supports both JSON and JSONB datatypes, including psycopg2’s
    native support and support for all of PostgreSQL’s special operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`JSON`](#sqlalchemy.dialects.postgresql.JSON "sqlalchemy.dialects.postgresql.JSON")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`JSONB`](#sqlalchemy.dialects.postgresql.JSONB "sqlalchemy.dialects.postgresql.JSONB")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`JSONPATH`](#sqlalchemy.dialects.postgresql.JSONPATH "sqlalchemy.dialects.postgresql.JSONPATH")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HSTORE Type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The PostgreSQL HSTORE type as well as hstore literals are supported:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`HSTORE`](#sqlalchemy.dialects.postgresql.HSTORE "sqlalchemy.dialects.postgresql.HSTORE")
    - HSTORE datatype'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`hstore`](#sqlalchemy.dialects.postgresql.hstore "sqlalchemy.dialects.postgresql.hstore")
    - hstore literal'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ENUM Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'PostgreSQL has an independently creatable TYPE structure which is used to implement
    an enumerated type. This approach introduces significant complexity on the SQLAlchemy
    side in terms of when this type should be CREATED and DROPPED. The type object
    is also an independently reflectable entity. The following sections should be
    consulted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`ENUM`](#sqlalchemy.dialects.postgresql.ENUM "sqlalchemy.dialects.postgresql.ENUM")
    - DDL and typing support for ENUM.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`PGInspector.get_enums()`](#sqlalchemy.dialects.postgresql.base.PGInspector.get_enums
    "sqlalchemy.dialects.postgresql.base.PGInspector.get_enums") - retrieve a listing
    of current ENUM types'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`ENUM.create()`](#sqlalchemy.dialects.postgresql.ENUM.create "sqlalchemy.dialects.postgresql.ENUM.create")
    , [`ENUM.drop()`](#sqlalchemy.dialects.postgresql.ENUM.drop "sqlalchemy.dialects.postgresql.ENUM.drop")
    - individual CREATE and DROP commands for ENUM.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '### Using ENUM with ARRAY'
  prefs: []
  type: TYPE_NORMAL
- en: The combination of ENUM and ARRAY is not directly supported by backend DBAPIs
    at this time. Prior to SQLAlchemy 1.3.17, a special workaround was needed in order
    to allow this combination to work, described below.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.3.17: The combination of ENUM and ARRAY is now directly
    handled by SQLAlchemy’s implementation without any workarounds needed.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'This type is not included as a built-in type as it would be incompatible with
    a DBAPI that suddenly decides to support ARRAY of ENUM directly in a new version.  ###
    Using JSON/JSONB with ARRAY'
  prefs: []
  type: TYPE_NORMAL
- en: Similar to using ENUM, prior to SQLAlchemy 1.3.17, for an ARRAY of JSON/JSONB
    we need to render the appropriate CAST. Current psycopg2 drivers accommodate the
    result set correctly without any special steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.3.17: The combination of JSON/JSONB and ARRAY is now directly
    handled by SQLAlchemy’s implementation without any workarounds needed.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]  ## Range and Multirange Types'
  prefs: []
  type: TYPE_NORMAL
- en: PostgreSQL range and multirange types are supported for the psycopg, pg8000
    and asyncpg dialects; the psycopg2 dialect supports the range types only.
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 2.0.17: Added range and multirange support for the pg8000 dialect.
    pg8000 1.29.8 or greater is required.'
  prefs: []
  type: TYPE_NORMAL
- en: Data values being passed to the database may be passed as string values or by
    using the [`Range`](#sqlalchemy.dialects.postgresql.Range "sqlalchemy.dialects.postgresql.Range")
    data object.
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 2.0: Added the backend-agnostic [`Range`](#sqlalchemy.dialects.postgresql.Range
    "sqlalchemy.dialects.postgresql.Range") object used to indicate ranges. The `psycopg2`-specific
    range classes are no longer exposed and are only used internally by that particular
    dialect.'
  prefs: []
  type: TYPE_NORMAL
- en: 'E.g. an example of a fully typed model using the [`TSRANGE`](#sqlalchemy.dialects.postgresql.TSRANGE
    "sqlalchemy.dialects.postgresql.TSRANGE") datatype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'To represent data for the `during` column above, the [`Range`](#sqlalchemy.dialects.postgresql.Range
    "sqlalchemy.dialects.postgresql.Range") type is a simple dataclass that will represent
    the bounds of the range. Below illustrates an INSERT of a row into the above `room_booking`
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Selecting from any range column will also return [`Range`](#sqlalchemy.dialects.postgresql.Range
    "sqlalchemy.dialects.postgresql.Range") objects as indicated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'The available range datatypes are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`INT4RANGE`](#sqlalchemy.dialects.postgresql.INT4RANGE "sqlalchemy.dialects.postgresql.INT4RANGE")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`INT8RANGE`](#sqlalchemy.dialects.postgresql.INT8RANGE "sqlalchemy.dialects.postgresql.INT8RANGE")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`NUMRANGE`](#sqlalchemy.dialects.postgresql.NUMRANGE "sqlalchemy.dialects.postgresql.NUMRANGE")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`DATERANGE`](#sqlalchemy.dialects.postgresql.DATERANGE "sqlalchemy.dialects.postgresql.DATERANGE")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`TSRANGE`](#sqlalchemy.dialects.postgresql.TSRANGE "sqlalchemy.dialects.postgresql.TSRANGE")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`TSTZRANGE`](#sqlalchemy.dialects.postgresql.TSTZRANGE "sqlalchemy.dialects.postgresql.TSTZRANGE")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| Object Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| [Range](#sqlalchemy.dialects.postgresql.Range) | Represent a PostgreSQL range.
    |'
  prefs: []
  type: TYPE_TB
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Represent a PostgreSQL range.
  prefs: []
  type: TYPE_NORMAL
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: The calling style is similar to that of psycopg and psycopg2, in part to allow
    easier migration from previous SQLAlchemy versions that used these objects directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`lower` – Lower bound value, or None'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`upper` – Upper bound value, or None'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bounds` – keyword-only, optional string value that is one of `"()"`, `"[)"`,
    `"(]"`, `"[]"`. Defaults to `"[)"`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`empty` – keyword-only, optional bool indicating this is an “empty” range'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__eq__()](#sqlalchemy.dialects.postgresql.Range.__eq__), [adjacent_to()](#sqlalchemy.dialects.postgresql.Range.adjacent_to),
    [contained_by()](#sqlalchemy.dialects.postgresql.Range.contained_by), [contains()](#sqlalchemy.dialects.postgresql.Range.contains),
    [difference()](#sqlalchemy.dialects.postgresql.Range.difference), [intersection()](#sqlalchemy.dialects.postgresql.Range.intersection),
    [is_empty](#sqlalchemy.dialects.postgresql.Range.is_empty), [isempty](#sqlalchemy.dialects.postgresql.Range.isempty),
    [lower](#sqlalchemy.dialects.postgresql.Range.lower), [lower_inc](#sqlalchemy.dialects.postgresql.Range.lower_inc),
    [lower_inf](#sqlalchemy.dialects.postgresql.Range.lower_inf), [not_extend_left_of()](#sqlalchemy.dialects.postgresql.Range.not_extend_left_of),
    [not_extend_right_of()](#sqlalchemy.dialects.postgresql.Range.not_extend_right_of),
    [overlaps()](#sqlalchemy.dialects.postgresql.Range.overlaps), [strictly_left_of()](#sqlalchemy.dialects.postgresql.Range.strictly_left_of),
    [strictly_right_of()](#sqlalchemy.dialects.postgresql.Range.strictly_right_of),
    [union()](#sqlalchemy.dialects.postgresql.Range.union), [upper](#sqlalchemy.dialects.postgresql.Range.upper),
    [upper_inc](#sqlalchemy.dialects.postgresql.Range.upper_inc), [upper_inf](#sqlalchemy.dialects.postgresql.Range.upper_inf)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.postgresql.Range`](#sqlalchemy.dialects.postgresql.Range
    "sqlalchemy.dialects.postgresql.Range") (`typing.Generic`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: Compare this range to the other taking into account bounds inclusivity, returning
    `True` if they are equal.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: Determine whether this range is adjacent to the other.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: Determine whether this range is a contained by other.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: Determine whether this range contains value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: Compute the difference between this range and the other.
  prefs: []
  type: TYPE_NORMAL
- en: This raises a `ValueError` exception if the two ranges are “disjunct”, that
    is neither adjacent nor overlapping.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: Compute the intersection of this range with the other.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.10.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: A synonym for the ‘empty’ attribute.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: A synonym for the ‘empty’ attribute.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: the lower bound
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: Return True if the lower bound is inclusive.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: Return True if this range is non-empty and lower bound is infinite.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: Determine whether this does not extend to the left of other.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: Determine whether this does not extend to the right of other.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: Determine whether this range overlaps with other.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: Determine whether this range is completely to the left of other.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: Determine whether this range is completely to the right of other.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: Compute the union of this range with the other.
  prefs: []
  type: TYPE_NORMAL
- en: This raises a `ValueError` exception if the two ranges are “disjunct”, that
    is neither adjacent nor overlapping.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: the upper bound
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: Return True if the upper bound is inclusive.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: Return True if this range is non-empty and the upper bound is infinite.
  prefs: []
  type: TYPE_NORMAL
- en: Multiranges
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Multiranges are supported by PostgreSQL 14 and above. SQLAlchemy’s multirange
    datatypes deal in lists of [`Range`](#sqlalchemy.dialects.postgresql.Range "sqlalchemy.dialects.postgresql.Range")
    types.
  prefs: []
  type: TYPE_NORMAL
- en: Multiranges are supported on the psycopg, asyncpg, and pg8000 dialects **only**.
    The psycopg2 dialect, which is SQLAlchemy’s default `postgresql` dialect, **does
    not** support multirange datatypes.
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 2.0: Added support for MULTIRANGE datatypes. SQLAlchemy represents
    a multirange value as a list of [`Range`](#sqlalchemy.dialects.postgresql.Range
    "sqlalchemy.dialects.postgresql.Range") objects.'
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 2.0.17: Added multirange support for the pg8000 dialect. pg8000
    1.29.8 or greater is required.'
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 2.0.26: [`MultiRange`](#sqlalchemy.dialects.postgresql.MultiRange
    "sqlalchemy.dialects.postgresql.MultiRange") sequence added.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The example below illustrates use of the [`TSMULTIRANGE`](#sqlalchemy.dialects.postgresql.TSMULTIRANGE
    "sqlalchemy.dialects.postgresql.TSMULTIRANGE") datatype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'Illustrating insertion and selecting of a record:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In the above example, the list of [`Range`](#sqlalchemy.dialects.postgresql.Range
    "sqlalchemy.dialects.postgresql.Range") types as handled by the ORM will not automatically
    detect in-place changes to a particular list value; to update list values with
    the ORM, either re-assign a new list to the attribute, or use the [`MutableList`](../orm/extensions/mutable.html#sqlalchemy.ext.mutable.MutableList
    "sqlalchemy.ext.mutable.MutableList") type modifier. See the section [Mutation
    Tracking](../orm/extensions/mutable.html) for background.
  prefs: []
  type: TYPE_NORMAL
- en: '#### Use of a MultiRange sequence to infer the multirange type'
  prefs: []
  type: TYPE_NORMAL
- en: 'When using a multirange as a literal without specifying the type the utility
    [`MultiRange`](#sqlalchemy.dialects.postgresql.MultiRange "sqlalchemy.dialects.postgresql.MultiRange")
    sequence can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: Using a simple `list` instead of [`MultiRange`](#sqlalchemy.dialects.postgresql.MultiRange
    "sqlalchemy.dialects.postgresql.MultiRange") would require manually setting the
    type of the literal value to the appropriate multirange type.
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 2.0.26: [`MultiRange`](#sqlalchemy.dialects.postgresql.MultiRange
    "sqlalchemy.dialects.postgresql.MultiRange") sequence added.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The available multirange datatypes are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`INT4MULTIRANGE`](#sqlalchemy.dialects.postgresql.INT4MULTIRANGE "sqlalchemy.dialects.postgresql.INT4MULTIRANGE")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`INT8MULTIRANGE`](#sqlalchemy.dialects.postgresql.INT8MULTIRANGE "sqlalchemy.dialects.postgresql.INT8MULTIRANGE")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`NUMMULTIRANGE`](#sqlalchemy.dialects.postgresql.NUMMULTIRANGE "sqlalchemy.dialects.postgresql.NUMMULTIRANGE")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`DATEMULTIRANGE`](#sqlalchemy.dialects.postgresql.DATEMULTIRANGE "sqlalchemy.dialects.postgresql.DATEMULTIRANGE")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`TSMULTIRANGE`](#sqlalchemy.dialects.postgresql.TSMULTIRANGE "sqlalchemy.dialects.postgresql.TSMULTIRANGE")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`TSTZMULTIRANGE`](#sqlalchemy.dialects.postgresql.TSTZMULTIRANGE "sqlalchemy.dialects.postgresql.TSTZMULTIRANGE")  ##
    Network Data Types'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The included networking datatypes are [`INET`](#sqlalchemy.dialects.postgresql.INET
    "sqlalchemy.dialects.postgresql.INET"), [`CIDR`](#sqlalchemy.dialects.postgresql.CIDR
    "sqlalchemy.dialects.postgresql.CIDR"), [`MACADDR`](#sqlalchemy.dialects.postgresql.MACADDR
    "sqlalchemy.dialects.postgresql.MACADDR").
  prefs: []
  type: TYPE_NORMAL
- en: For [`INET`](#sqlalchemy.dialects.postgresql.INET "sqlalchemy.dialects.postgresql.INET")
    and [`CIDR`](#sqlalchemy.dialects.postgresql.CIDR "sqlalchemy.dialects.postgresql.CIDR")
    datatypes, conditional support is available for these datatypes to send and retrieve
    Python `ipaddress` objects including `ipaddress.IPv4Network`, `ipaddress.IPv6Network`,
    `ipaddress.IPv4Address`, `ipaddress.IPv6Address`. This support is currently **the
    default behavior of the DBAPI itself, and varies per DBAPI. SQLAlchemy does not
    yet implement its own network address conversion logic**.
  prefs: []
  type: TYPE_NORMAL
- en: The [psycopg](#postgresql-psycopg) and [asyncpg](#postgresql-asyncpg) support
    these datatypes fully; objects from the `ipaddress` family are returned in rows
    by default.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [psycopg2](#postgresql-psycopg2) dialect only sends and receives strings.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [pg8000](#postgresql-pg8000) dialect supports `ipaddress.IPv4Address` and
    `ipaddress.IPv6Address` objects for the [`INET`](#sqlalchemy.dialects.postgresql.INET
    "sqlalchemy.dialects.postgresql.INET") datatype, but uses strings for [`CIDR`](#sqlalchemy.dialects.postgresql.CIDR
    "sqlalchemy.dialects.postgresql.CIDR") types.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To **normalize all the above DBAPIs to only return strings**, use the `native_inet_types`
    parameter, passing a value of `False`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: With the above parameter, the `psycopg`, `asyncpg` and `pg8000` dialects will
    disable the DBAPI’s adaptation of these types and will return only strings, matching
    the behavior of the older `psycopg2` dialect.
  prefs: []
  type: TYPE_NORMAL
- en: The parameter may also be set to `True`, where it will have the effect of raising
    `NotImplementedError` for those backends that don’t support, or don’t yet fully
    support, conversion of rows to Python `ipaddress` datatypes (currently psycopg2
    and pg8000).
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 2.0.18: - added the `native_inet_types` parameter.'
  prefs: []
  type: TYPE_NORMAL
- en: PostgreSQL Data Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As with all SQLAlchemy dialects, all UPPERCASE types that are known to be valid
    with PostgreSQL are importable from the top level dialect, whether they originate
    from [`sqlalchemy.types`](../core/type_basics.html#module-sqlalchemy.types "sqlalchemy.types")
    or from the local dialect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'Types which are specific to PostgreSQL, or have PostgreSQL-specific construction
    arguments, are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Object Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| [AbstractMultiRange](#sqlalchemy.dialects.postgresql.AbstractMultiRange)
    | Base for PostgreSQL MULTIRANGE types. |'
  prefs: []
  type: TYPE_TB
- en: '| [AbstractRange](#sqlalchemy.dialects.postgresql.AbstractRange) | Base class
    for single and multi Range SQL types. |'
  prefs: []
  type: TYPE_TB
- en: '| [AbstractSingleRange](#sqlalchemy.dialects.postgresql.AbstractSingleRange)
    | Base for PostgreSQL RANGE types. |'
  prefs: []
  type: TYPE_TB
- en: '| [ARRAY](#sqlalchemy.dialects.postgresql.ARRAY) | PostgreSQL ARRAY type. |'
  prefs: []
  type: TYPE_TB
- en: '| [BIT](#sqlalchemy.dialects.postgresql.BIT) |  |'
  prefs: []
  type: TYPE_TB
- en: '| [BYTEA](#sqlalchemy.dialects.postgresql.BYTEA) |  |'
  prefs: []
  type: TYPE_TB
- en: '| [CIDR](#sqlalchemy.dialects.postgresql.CIDR) |  |'
  prefs: []
  type: TYPE_TB
- en: '| [CITEXT](#sqlalchemy.dialects.postgresql.CITEXT) | Provide the PostgreSQL
    CITEXT type. |'
  prefs: []
  type: TYPE_TB
- en: '| [DATEMULTIRANGE](#sqlalchemy.dialects.postgresql.DATEMULTIRANGE) | Represent
    the PostgreSQL DATEMULTIRANGE type. |'
  prefs: []
  type: TYPE_TB
- en: '| [DATERANGE](#sqlalchemy.dialects.postgresql.DATERANGE) | Represent the PostgreSQL
    DATERANGE type. |'
  prefs: []
  type: TYPE_TB
- en: '| [DOMAIN](#sqlalchemy.dialects.postgresql.DOMAIN) | Represent the DOMAIN PostgreSQL
    type. |'
  prefs: []
  type: TYPE_TB
- en: '| [ENUM](#sqlalchemy.dialects.postgresql.ENUM) | PostgreSQL ENUM type. |'
  prefs: []
  type: TYPE_TB
- en: '| [HSTORE](#sqlalchemy.dialects.postgresql.HSTORE) | Represent the PostgreSQL
    HSTORE type. |'
  prefs: []
  type: TYPE_TB
- en: '| [INET](#sqlalchemy.dialects.postgresql.INET) |  |'
  prefs: []
  type: TYPE_TB
- en: '| [INT4MULTIRANGE](#sqlalchemy.dialects.postgresql.INT4MULTIRANGE) | Represent
    the PostgreSQL INT4MULTIRANGE type. |'
  prefs: []
  type: TYPE_TB
- en: '| [INT4RANGE](#sqlalchemy.dialects.postgresql.INT4RANGE) | Represent the PostgreSQL
    INT4RANGE type. |'
  prefs: []
  type: TYPE_TB
- en: '| [INT8MULTIRANGE](#sqlalchemy.dialects.postgresql.INT8MULTIRANGE) | Represent
    the PostgreSQL INT8MULTIRANGE type. |'
  prefs: []
  type: TYPE_TB
- en: '| [INT8RANGE](#sqlalchemy.dialects.postgresql.INT8RANGE) | Represent the PostgreSQL
    INT8RANGE type. |'
  prefs: []
  type: TYPE_TB
- en: '| [INTERVAL](#sqlalchemy.dialects.postgresql.INTERVAL) | PostgreSQL INTERVAL
    type. |'
  prefs: []
  type: TYPE_TB
- en: '| [JSON](#sqlalchemy.dialects.postgresql.JSON) | Represent the PostgreSQL JSON
    type. |'
  prefs: []
  type: TYPE_TB
- en: '| [JSONB](#sqlalchemy.dialects.postgresql.JSONB) | Represent the PostgreSQL
    JSONB type. |'
  prefs: []
  type: TYPE_TB
- en: '| [JSONPATH](#sqlalchemy.dialects.postgresql.JSONPATH) | JSON Path Type. |'
  prefs: []
  type: TYPE_TB
- en: '| [MACADDR](#sqlalchemy.dialects.postgresql.MACADDR) |  |'
  prefs: []
  type: TYPE_TB
- en: '| [MACADDR8](#sqlalchemy.dialects.postgresql.MACADDR8) |  |'
  prefs: []
  type: TYPE_TB
- en: '| [MONEY](#sqlalchemy.dialects.postgresql.MONEY) | Provide the PostgreSQL MONEY
    type. |'
  prefs: []
  type: TYPE_TB
- en: '| [MultiRange](#sqlalchemy.dialects.postgresql.MultiRange) | Represents a multirange
    sequence. |'
  prefs: []
  type: TYPE_TB
- en: '| [NUMMULTIRANGE](#sqlalchemy.dialects.postgresql.NUMMULTIRANGE) | Represent
    the PostgreSQL NUMMULTIRANGE type. |'
  prefs: []
  type: TYPE_TB
- en: '| [NUMRANGE](#sqlalchemy.dialects.postgresql.NUMRANGE) | Represent the PostgreSQL
    NUMRANGE type. |'
  prefs: []
  type: TYPE_TB
- en: '| [OID](#sqlalchemy.dialects.postgresql.OID) | Provide the PostgreSQL OID type.
    |'
  prefs: []
  type: TYPE_TB
- en: '| [REGCLASS](#sqlalchemy.dialects.postgresql.REGCLASS) | Provide the PostgreSQL
    REGCLASS type. |'
  prefs: []
  type: TYPE_TB
- en: '| [REGCONFIG](#sqlalchemy.dialects.postgresql.REGCONFIG) | Provide the PostgreSQL
    REGCONFIG type. |'
  prefs: []
  type: TYPE_TB
- en: '| [TIME](#sqlalchemy.dialects.postgresql.TIME) | PostgreSQL TIME type. |'
  prefs: []
  type: TYPE_TB
- en: '| [TIMESTAMP](#sqlalchemy.dialects.postgresql.TIMESTAMP) | Provide the PostgreSQL
    TIMESTAMP type. |'
  prefs: []
  type: TYPE_TB
- en: '| [TSMULTIRANGE](#sqlalchemy.dialects.postgresql.TSMULTIRANGE) | Represent
    the PostgreSQL TSRANGE type. |'
  prefs: []
  type: TYPE_TB
- en: '| [TSQUERY](#sqlalchemy.dialects.postgresql.TSQUERY) | Provide the PostgreSQL
    TSQUERY type. |'
  prefs: []
  type: TYPE_TB
- en: '| [TSRANGE](#sqlalchemy.dialects.postgresql.TSRANGE) | Represent the PostgreSQL
    TSRANGE type. |'
  prefs: []
  type: TYPE_TB
- en: '| [TSTZMULTIRANGE](#sqlalchemy.dialects.postgresql.TSTZMULTIRANGE) | Represent
    the PostgreSQL TSTZRANGE type. |'
  prefs: []
  type: TYPE_TB
- en: '| [TSTZRANGE](#sqlalchemy.dialects.postgresql.TSTZRANGE) | Represent the PostgreSQL
    TSTZRANGE type. |'
  prefs: []
  type: TYPE_TB
- en: '| [TSVECTOR](#sqlalchemy.dialects.postgresql.TSVECTOR) | The [`TSVECTOR`](#sqlalchemy.dialects.postgresql.TSVECTOR
    "sqlalchemy.dialects.postgresql.TSVECTOR") type implements the PostgreSQL text
    search type TSVECTOR. |'
  prefs: []
  type: TYPE_TB
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: Base class for single and multi Range SQL types.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[adjacent_to()](#sqlalchemy.dialects.postgresql.AbstractRange.comparator_factory.adjacent_to),
    [contained_by()](#sqlalchemy.dialects.postgresql.AbstractRange.comparator_factory.contained_by),
    [contains()](#sqlalchemy.dialects.postgresql.AbstractRange.comparator_factory.contains),
    [difference()](#sqlalchemy.dialects.postgresql.AbstractRange.comparator_factory.difference),
    [intersection()](#sqlalchemy.dialects.postgresql.AbstractRange.comparator_factory.intersection),
    [not_extend_left_of()](#sqlalchemy.dialects.postgresql.AbstractRange.comparator_factory.not_extend_left_of),
    [not_extend_right_of()](#sqlalchemy.dialects.postgresql.AbstractRange.comparator_factory.not_extend_right_of),
    [overlaps()](#sqlalchemy.dialects.postgresql.AbstractRange.comparator_factory.overlaps),
    [strictly_left_of()](#sqlalchemy.dialects.postgresql.AbstractRange.comparator_factory.strictly_left_of),
    [strictly_right_of()](#sqlalchemy.dialects.postgresql.AbstractRange.comparator_factory.strictly_right_of),
    [union()](#sqlalchemy.dialects.postgresql.AbstractRange.comparator_factory.union)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.postgresql.AbstractRange`](#sqlalchemy.dialects.postgresql.AbstractRange
    "sqlalchemy.dialects.postgresql.AbstractRange") ([`sqlalchemy.types.TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: Define comparison operations for range types.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.postgresql.AbstractRange.comparator_factory`](#sqlalchemy.dialects.postgresql.AbstractRange.comparator_factory
    "sqlalchemy.dialects.postgresql.AbstractRange.comparator_factory") (`sqlalchemy.types.Comparator`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: Boolean expression. Returns true if the range in the column is adjacent to the
    range in the operand.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: Boolean expression. Returns true if the column is contained within the right
    hand operand.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: Boolean expression. Returns true if the right hand operand, which can be an
    element or a range, is contained within the column.
  prefs: []
  type: TYPE_NORMAL
- en: kwargs may be ignored by this operator but are required for API conformance.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: Range expression. Returns the union of the two ranges. Will raise an exception
    if the resulting range is not contiguous.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: Range expression. Returns the intersection of the two ranges. Will raise an
    exception if the resulting range is not contiguous.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: Boolean expression. Returns true if the range in the column does not extend
    left of the range in the operand.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: Boolean expression. Returns true if the range in the column does not extend
    right of the range in the operand.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: Boolean expression. Returns true if the column overlaps (has points in common
    with) the right hand operand.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: Boolean expression. Returns true if the column is strictly left of the right
    hand operand.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: Boolean expression. Returns true if the column is strictly right of the right
    hand operand.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: Range expression. Returns the union of the two ranges. Will raise an exception
    if the resulting range is not contiguous.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: Base for PostgreSQL RANGE types.
  prefs: []
  type: TYPE_NORMAL
- en: These are types that return a single [`Range`](#sqlalchemy.dialects.postgresql.Range
    "sqlalchemy.dialects.postgresql.Range") object.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[PostgreSQL range functions](https://www.postgresql.org/docs/current/static/functions-range.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.postgresql.AbstractSingleRange`](#sqlalchemy.dialects.postgresql.AbstractSingleRange
    "sqlalchemy.dialects.postgresql.AbstractSingleRange") ([`sqlalchemy.dialects.postgresql.ranges.AbstractRange`](#sqlalchemy.dialects.postgresql.AbstractRange
    "sqlalchemy.dialects.postgresql.ranges.AbstractRange"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: Base for PostgreSQL MULTIRANGE types.
  prefs: []
  type: TYPE_NORMAL
- en: these are types that return a sequence of [`Range`](#sqlalchemy.dialects.postgresql.Range
    "sqlalchemy.dialects.postgresql.Range") objects.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.postgresql.AbstractMultiRange`](#sqlalchemy.dialects.postgresql.AbstractMultiRange
    "sqlalchemy.dialects.postgresql.AbstractMultiRange") ([`sqlalchemy.dialects.postgresql.ranges.AbstractRange`](#sqlalchemy.dialects.postgresql.AbstractRange
    "sqlalchemy.dialects.postgresql.ranges.AbstractRange"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: PostgreSQL ARRAY type.
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`ARRAY`](#sqlalchemy.dialects.postgresql.ARRAY "sqlalchemy.dialects.postgresql.ARRAY")
    type is constructed in the same way as the core [`ARRAY`](../core/type_basics.html#sqlalchemy.types.ARRAY
    "sqlalchemy.types.ARRAY") type; a member type is required, and a number of dimensions
    is recommended if the type is to be used for more than one dimension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: 'The [`ARRAY`](#sqlalchemy.dialects.postgresql.ARRAY "sqlalchemy.dialects.postgresql.ARRAY")
    type provides all operations defined on the core [`ARRAY`](../core/type_basics.html#sqlalchemy.types.ARRAY
    "sqlalchemy.types.ARRAY") type, including support for “dimensions”, indexed access,
    and simple matching such as [`Comparator.any()`](../core/type_basics.html#sqlalchemy.types.ARRAY.Comparator.any
    "sqlalchemy.types.ARRAY.Comparator.any") and [`Comparator.all()`](../core/type_basics.html#sqlalchemy.types.ARRAY.Comparator.all
    "sqlalchemy.types.ARRAY.Comparator.all"). [`ARRAY`](#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY") class also provides PostgreSQL-specific
    methods for containment operations, including [`Comparator.contains()`](#sqlalchemy.dialects.postgresql.ARRAY.Comparator.contains
    "sqlalchemy.dialects.postgresql.ARRAY.Comparator.contains") [`Comparator.contained_by()`](#sqlalchemy.dialects.postgresql.ARRAY.Comparator.contained_by
    "sqlalchemy.dialects.postgresql.ARRAY.Comparator.contained_by"), and [`Comparator.overlap()`](#sqlalchemy.dialects.postgresql.ARRAY.Comparator.overlap
    "sqlalchemy.dialects.postgresql.ARRAY.Comparator.overlap"), e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: Indexed access is one-based by default, to match that of PostgreSQL; for zero-based
    indexed access, set [`ARRAY.zero_indexes`](#sqlalchemy.dialects.postgresql.ARRAY.params.zero_indexes
    "sqlalchemy.dialects.postgresql.ARRAY").
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, the [`ARRAY`](#sqlalchemy.dialects.postgresql.ARRAY "sqlalchemy.dialects.postgresql.ARRAY")
    type does not work directly in conjunction with the [`ENUM`](#sqlalchemy.dialects.postgresql.ENUM
    "sqlalchemy.dialects.postgresql.ENUM") type. For a workaround, see the special
    type at [Using ENUM with ARRAY](#postgresql-array-of-enum).
  prefs: []
  type: TYPE_NORMAL
- en: '**Detecting Changes in ARRAY columns when using the ORM**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`ARRAY`](#sqlalchemy.dialects.postgresql.ARRAY "sqlalchemy.dialects.postgresql.ARRAY")
    type, when used with the SQLAlchemy ORM, does not detect in-place mutations to
    the array. In order to detect these, the [`sqlalchemy.ext.mutable`](../orm/extensions/mutable.html#module-sqlalchemy.ext.mutable
    "sqlalchemy.ext.mutable") extension must be used, using the [`MutableList`](../orm/extensions/mutable.html#sqlalchemy.ext.mutable.MutableList
    "sqlalchemy.ext.mutable.MutableList") class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: This extension will allow “in-place” changes such to the array such as `.append()`
    to produce events which will be detected by the unit of work. Note that changes
    to elements **inside** the array, including subarrays that are mutated in place,
    are **not** detected.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, assigning a new array value to an ORM element that replaces the
    old one will always trigger a change event.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`ARRAY`](../core/type_basics.html#sqlalchemy.types.ARRAY "sqlalchemy.types.ARRAY")
    - base array type'
  prefs: []
  type: TYPE_NORMAL
- en: '[`array`](#sqlalchemy.dialects.postgresql.array "sqlalchemy.dialects.postgresql.array")
    - produces a literal array value.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.dialects.postgresql.ARRAY.__init__), [contains()](#sqlalchemy.dialects.postgresql.ARRAY.Comparator.contains),
    [contained_by()](#sqlalchemy.dialects.postgresql.ARRAY.Comparator.contained_by),
    [overlap()](#sqlalchemy.dialects.postgresql.ARRAY.Comparator.overlap)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.postgresql.ARRAY`](#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY") ([`sqlalchemy.types.ARRAY`](../core/type_basics.html#sqlalchemy.types.ARRAY
    "sqlalchemy.types.ARRAY"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: Construct an ARRAY.
  prefs: []
  type: TYPE_NORMAL
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: 'Arguments are:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`item_type` – The data type of items of this array. Note that dimensionality
    is irrelevant here, so multi-dimensional arrays like `INTEGER[][]`, are constructed
    as `ARRAY(Integer)`, not as `ARRAY(ARRAY(Integer))` or such.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`as_tuple=False` – Specify whether return results should be converted to tuples
    from lists. DBAPIs such as psycopg2 return lists by default. When tuples are returned,
    the results are hashable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dimensions` – if non-None, the ARRAY will assume a fixed number of dimensions.
    This will cause the DDL emitted for this ARRAY to include the exact number of
    bracket clauses `[]`, and will also optimize the performance of the type overall.
    Note that PG arrays are always implicitly “non-dimensioned”, meaning they can
    store any number of dimensions no matter how they were declared.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`zero_indexes=False` – when True, index values will be converted between Python
    zero-based and PostgreSQL one-based indexes, e.g. a value of one will be added
    to all index values before passing to the database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: Define comparison operations for [`ARRAY`](../core/type_basics.html#sqlalchemy.types.ARRAY
    "sqlalchemy.types.ARRAY").
  prefs: []
  type: TYPE_NORMAL
- en: Note that these operations are in addition to those provided by the base [`Comparator`](../core/type_basics.html#sqlalchemy.types.ARRAY.Comparator
    "sqlalchemy.types.ARRAY.Comparator") class, including [`Comparator.any()`](../core/type_basics.html#sqlalchemy.types.ARRAY.Comparator.any
    "sqlalchemy.types.ARRAY.Comparator.any") and [`Comparator.all()`](../core/type_basics.html#sqlalchemy.types.ARRAY.Comparator.all
    "sqlalchemy.types.ARRAY.Comparator.all").
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.postgresql.ARRAY.Comparator`](#sqlalchemy.dialects.postgresql.ARRAY.Comparator
    "sqlalchemy.dialects.postgresql.ARRAY.Comparator") (`sqlalchemy.types.Comparator`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: Boolean expression. Test if elements are a superset of the elements of the argument
    array expression.
  prefs: []
  type: TYPE_NORMAL
- en: kwargs may be ignored by this operator but are required for API conformance.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: Boolean expression. Test if elements are a proper subset of the elements of
    the argument array expression.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: Boolean expression. Test if array has elements in common with an argument array
    expression.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.postgresql.BIT`](#sqlalchemy.dialects.postgresql.BIT
    "sqlalchemy.dialects.postgresql.BIT") ([`sqlalchemy.types.TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.dialects.postgresql.BYTEA.__init__)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.postgresql.BYTEA`](#sqlalchemy.dialects.postgresql.BYTEA
    "sqlalchemy.dialects.postgresql.BYTEA") ([`sqlalchemy.types.LargeBinary`](../core/type_basics.html#sqlalchemy.types.LargeBinary
    "sqlalchemy.types.LargeBinary"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `sqlalchemy.types.LargeBinary.__init__` *method of* [`LargeBinary`](../core/type_basics.html#sqlalchemy.types.LargeBinary
    "sqlalchemy.types.LargeBinary")'
  prefs: []
  type: TYPE_NORMAL
- en: Construct a LargeBinary type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**length** – optional, a length for the column for use in DDL statements, for
    those binary types that accept a length, such as the MySQL BLOB type.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.postgresql.CIDR`](#sqlalchemy.dialects.postgresql.CIDR
    "sqlalchemy.dialects.postgresql.CIDR") ([`sqlalchemy.types.TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: Provide the PostgreSQL CITEXT type.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.7.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.dialects.postgresql.CITEXT.__init__)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.postgresql.CITEXT`](#sqlalchemy.dialects.postgresql.CITEXT
    "sqlalchemy.dialects.postgresql.CITEXT") ([`sqlalchemy.types.TEXT`](../core/type_basics.html#sqlalchemy.types.TEXT
    "sqlalchemy.types.TEXT"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `sqlalchemy.types.String.__init__` *method of* [`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String")'
  prefs: []
  type: TYPE_NORMAL
- en: Create a string-holding type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`length` – optional, a length for the column for use in DDL and CAST expressions.
    May be safely omitted if no `CREATE TABLE` will be issued. Certain databases may
    require a `length` for use in DDL, and will raise an exception when the `CREATE
    TABLE` DDL is issued if a `VARCHAR` with no length is included. Whether the value
    is interpreted as bytes or characters is database specific.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`collation` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Optional, a column-level collation for use in DDL and CAST expressions. Renders
    using the COLLATE keyword supported by SQLite, MySQL, and PostgreSQL. E.g.:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In most cases, the [`Unicode`](../core/type_basics.html#sqlalchemy.types.Unicode
    "sqlalchemy.types.Unicode") or [`UnicodeText`](../core/type_basics.html#sqlalchemy.types.UnicodeText
    "sqlalchemy.types.UnicodeText") datatypes should be used for a [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") that expects to store non-ascii data. These datatypes
    will ensure that the correct types are used on the database.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: Represent the DOMAIN PostgreSQL type.
  prefs: []
  type: TYPE_NORMAL
- en: 'A domain is essentially a data type with optional constraints that restrict
    the allowed set of values. E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: See the [PostgreSQL documentation](https://www.postgresql.org/docs/current/sql-createdomain.html)
    for additional details
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.dialects.postgresql.DOMAIN.__init__), [create()](#sqlalchemy.dialects.postgresql.DOMAIN.create),
    [drop()](#sqlalchemy.dialects.postgresql.DOMAIN.drop)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.postgresql.DOMAIN`](#sqlalchemy.dialects.postgresql.DOMAIN
    "sqlalchemy.dialects.postgresql.DOMAIN") (`sqlalchemy.dialects.postgresql.named_types.NamedType`,
    [`sqlalchemy.types.SchemaType`](../core/type_basics.html#sqlalchemy.types.SchemaType
    "sqlalchemy.types.SchemaType"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: Construct a DOMAIN.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`name` – the name of the domain'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`data_type` – The underlying data type of the domain. This can include array
    specifiers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`collation` – An optional collation for the domain. If no collation is specified,
    the underlying data type’s default collation is used. The underlying type must
    be collatable if `collation` is specified.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`default` – The DEFAULT clause specifies a default value for columns of the
    domain data type. The default should be a string or a [`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text
    "sqlalchemy.sql.expression.text") value. If no default value is specified, then
    the default value is the null value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`constraint_name` – An optional name for a constraint. If not specified, the
    backend generates a name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`not_null` – Values of this domain are prevented from being null. By default
    domain are allowed to be null. If not specified no nullability clause will be
    emitted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`check` – CHECK clause specify integrity constraint or test which values of
    the domain must satisfy. A constraint must be an expression producing a Boolean
    result that can use the key word VALUE to refer to the value being tested. Differently
    from PostgreSQL, only a single check clause is currently allowed in SQLAlchemy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`schema` – optional schema name'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`metadata` – optional [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") object which this [`DOMAIN`](#sqlalchemy.dialects.postgresql.DOMAIN
    "sqlalchemy.dialects.postgresql.DOMAIN") will be directly associated'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`create_type` – Defaults to True. Indicates that `CREATE TYPE` should be emitted,
    after optionally checking for the presence of the type, when the parent table
    is being created; and additionally that `DROP TYPE` is called when the table is
    dropped.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `NamedType.create()` *method of* `NamedType`'
  prefs: []
  type: TYPE_NORMAL
- en: Emit `CREATE` DDL for this type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`bind` – a connectable [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine"), [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection"), or similar object to emit SQL.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`checkfirst` – if `True`, a query against the PG catalog will be first performed
    to see if the type does not exist already before creating.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `NamedType.drop()` *method of* `NamedType`'
  prefs: []
  type: TYPE_NORMAL
- en: Emit `DROP` DDL for this type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`bind` – a connectable [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine"), [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection"), or similar object to emit SQL.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`checkfirst` – if `True`, a query against the PG catalog will be first performed
    to see if the type actually exists before dropping.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: The SQL DOUBLE PRECISION type.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Double`](../core/type_basics.html#sqlalchemy.types.Double "sqlalchemy.types.Double")
    - documentation for the base type.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class `sqlalchemy.dialects.postgresql.DOUBLE_PRECISION` ([`sqlalchemy.types.Double`](../core/type_basics.html#sqlalchemy.types.Double
    "sqlalchemy.types.Double"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `sqlalchemy.types.Float.__init__` *method of* [`Float`](../core/type_basics.html#sqlalchemy.types.Float
    "sqlalchemy.types.Float")'
  prefs: []
  type: TYPE_NORMAL
- en: Construct a Float.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`precision` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the numeric precision for use in DDL `CREATE TABLE`. Backends **should** attempt
    to ensure this precision indicates a number of digits for the generic [`Float`](../core/type_basics.html#sqlalchemy.types.Float
    "sqlalchemy.types.Float") datatype.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For the Oracle backend, the [`Float.precision`](../core/type_basics.html#sqlalchemy.types.Float.params.precision
    "sqlalchemy.types.Float") parameter is not accepted when rendering DDL, as Oracle
    does not support float precision specified as a number of decimal places. Instead,
    use the Oracle-specific [`FLOAT`](oracle.html#sqlalchemy.dialects.oracle.FLOAT
    "sqlalchemy.dialects.oracle.FLOAT") datatype and specify the [`FLOAT.binary_precision`](oracle.html#sqlalchemy.dialects.oracle.FLOAT.params.binary_precision
    "sqlalchemy.dialects.oracle.FLOAT") parameter. This is new in version 2.0 of SQLAlchemy.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To create a database agnostic [`Float`](../core/type_basics.html#sqlalchemy.types.Float
    "sqlalchemy.types.Float") that separately specifies binary precision for Oracle,
    use [`TypeEngine.with_variant()`](../core/type_api.html#sqlalchemy.types.TypeEngine.with_variant
    "sqlalchemy.types.TypeEngine.with_variant") as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`asdecimal` – the same flag as that of [`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric
    "sqlalchemy.types.Numeric"), but defaults to `False`. Note that setting this flag
    to `True` results in floating point conversion.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`decimal_return_scale` – Default scale to use when converting from floats to
    Python decimals. Floating point values will typically be much longer due to decimal
    inaccuracy, and most floating point database types don’t have a notion of “scale”,
    so by default the float type looks for the first ten decimal places when converting.
    Specifying this value will override that length. Note that the MySQL float types,
    which do include “scale”, will use “scale” as the default for decimal_return_scale,
    if not otherwise specified.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: PostgreSQL ENUM type.
  prefs: []
  type: TYPE_NORMAL
- en: This is a subclass of [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum") which includes support for PG’s `CREATE TYPE` and `DROP
    TYPE`.
  prefs: []
  type: TYPE_NORMAL
- en: When the builtin type [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum") is used and the [`Enum.native_enum`](../core/type_basics.html#sqlalchemy.types.Enum.params.native_enum
    "sqlalchemy.types.Enum") flag is left at its default of True, the PostgreSQL backend
    will use a [`ENUM`](#sqlalchemy.dialects.postgresql.ENUM "sqlalchemy.dialects.postgresql.ENUM")
    type as the implementation, so the special create/drop rules will be used.
  prefs: []
  type: TYPE_NORMAL
- en: The create/drop behavior of ENUM is necessarily intricate, due to the awkward
    relationship the ENUM type has in relationship to the parent table, in that it
    may be “owned” by just a single table, or may be shared among many tables.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.types.Enum")
    or [`ENUM`](#sqlalchemy.dialects.postgresql.ENUM "sqlalchemy.dialects.postgresql.ENUM")
    in an “inline” fashion, the `CREATE TYPE` and `DROP TYPE` is emitted corresponding
    to when the [`Table.create()`](../core/metadata.html#sqlalchemy.schema.Table.create
    "sqlalchemy.schema.Table.create") and [`Table.drop()`](../core/metadata.html#sqlalchemy.schema.Table.drop
    "sqlalchemy.schema.Table.drop") methods are called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: 'To use a common enumerated type between multiple tables, the best practice
    is to declare the [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.types.Enum")
    or [`ENUM`](#sqlalchemy.dialects.postgresql.ENUM "sqlalchemy.dialects.postgresql.ENUM")
    independently, and associate it with the [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") object itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: 'When this pattern is used, care must still be taken at the level of individual
    table creates. Emitting CREATE TABLE without also specifying `checkfirst=True`
    will still cause issues:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: 'If we specify `checkfirst=True`, the individual table-level create operation
    will check for the `ENUM` and create if not exists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: 'When using a metadata-level ENUM type, the type will always be created and
    dropped if either the metadata-wide create/drop is called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: 'The type can also be created and dropped directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.dialects.postgresql.ENUM.__init__), [create()](#sqlalchemy.dialects.postgresql.ENUM.create),
    [drop()](#sqlalchemy.dialects.postgresql.ENUM.drop)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.postgresql.ENUM`](#sqlalchemy.dialects.postgresql.ENUM
    "sqlalchemy.dialects.postgresql.ENUM") (`sqlalchemy.dialects.postgresql.named_types.NamedType`,
    `sqlalchemy.types.NativeForEmulated`, [`sqlalchemy.types.Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: Construct an [`ENUM`](#sqlalchemy.dialects.postgresql.ENUM "sqlalchemy.dialects.postgresql.ENUM").
  prefs: []
  type: TYPE_NORMAL
- en: Arguments are the same as that of [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum"), but also including the following parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**create_type** – Defaults to True. Indicates that `CREATE TYPE` should be
    emitted, after optionally checking for the presence of the type, when the parent
    table is being created; and additionally that `DROP TYPE` is called when the table
    is dropped. When `False`, no check will be performed and no `CREATE TYPE` or `DROP
    TYPE` is emitted, unless [`ENUM.create()`](#sqlalchemy.dialects.postgresql.ENUM.create
    "sqlalchemy.dialects.postgresql.ENUM.create") or [`ENUM.drop()`](#sqlalchemy.dialects.postgresql.ENUM.drop
    "sqlalchemy.dialects.postgresql.ENUM.drop") are called directly. Setting to `False`
    is helpful when invoking a creation scheme to a SQL file without access to the
    actual database - the [`ENUM.create()`](#sqlalchemy.dialects.postgresql.ENUM.create
    "sqlalchemy.dialects.postgresql.ENUM.create") and [`ENUM.drop()`](#sqlalchemy.dialects.postgresql.ENUM.drop
    "sqlalchemy.dialects.postgresql.ENUM.drop") methods can be used to emit SQL to
    a target bind.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: Emit `CREATE TYPE` for this [`ENUM`](#sqlalchemy.dialects.postgresql.ENUM "sqlalchemy.dialects.postgresql.ENUM").
  prefs: []
  type: TYPE_NORMAL
- en: If the underlying dialect does not support PostgreSQL CREATE TYPE, no action
    is taken.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`bind` – a connectable [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine"), [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection"), or similar object to emit SQL.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`checkfirst` – if `True`, a query against the PG catalog will be first performed
    to see if the type does not exist already before creating.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: Emit `DROP TYPE` for this [`ENUM`](#sqlalchemy.dialects.postgresql.ENUM "sqlalchemy.dialects.postgresql.ENUM").
  prefs: []
  type: TYPE_NORMAL
- en: If the underlying dialect does not support PostgreSQL DROP TYPE, no action is
    taken.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`bind` – a connectable [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine"), [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection"), or similar object to emit SQL.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`checkfirst` – if `True`, a query against the PG catalog will be first performed
    to see if the type actually exists before dropping.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: Represent the PostgreSQL HSTORE type.
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`HSTORE`](#sqlalchemy.dialects.postgresql.HSTORE "sqlalchemy.dialects.postgresql.HSTORE")
    type stores dictionaries containing strings, e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: '[`HSTORE`](#sqlalchemy.dialects.postgresql.HSTORE "sqlalchemy.dialects.postgresql.HSTORE")
    provides for a wide range of operations, including:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Index operations:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Containment operations:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Concatenation:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: For a full list of special methods see `comparator_factory`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Detecting Changes in HSTORE columns when using the ORM**'
  prefs: []
  type: TYPE_NORMAL
- en: 'For usage with the SQLAlchemy ORM, it may be desirable to combine the usage
    of [`HSTORE`](#sqlalchemy.dialects.postgresql.HSTORE "sqlalchemy.dialects.postgresql.HSTORE")
    with [`MutableDict`](../orm/extensions/mutable.html#sqlalchemy.ext.mutable.MutableDict
    "sqlalchemy.ext.mutable.MutableDict") dictionary now part of the [`sqlalchemy.ext.mutable`](../orm/extensions/mutable.html#module-sqlalchemy.ext.mutable
    "sqlalchemy.ext.mutable") extension. This extension will allow “in-place” changes
    to the dictionary, e.g. addition of new keys or replacement/removal of existing
    keys to/from the current dictionary, to produce events which will be detected
    by the unit of work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: When the [`sqlalchemy.ext.mutable`](../orm/extensions/mutable.html#module-sqlalchemy.ext.mutable
    "sqlalchemy.ext.mutable") extension is not used, the ORM will not be alerted to
    any changes to the contents of an existing dictionary, unless that dictionary
    value is re-assigned to the HSTORE-attribute itself, thus generating a change
    event.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`hstore`](#sqlalchemy.dialects.postgresql.hstore "sqlalchemy.dialects.postgresql.hstore")
    - render the PostgreSQL `hstore()` function.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[array()](#sqlalchemy.dialects.postgresql.HSTORE.Comparator.array), [contained_by()](#sqlalchemy.dialects.postgresql.HSTORE.Comparator.contained_by),
    [contains()](#sqlalchemy.dialects.postgresql.HSTORE.Comparator.contains), [defined()](#sqlalchemy.dialects.postgresql.HSTORE.Comparator.defined),
    [delete()](#sqlalchemy.dialects.postgresql.HSTORE.Comparator.delete), [has_all()](#sqlalchemy.dialects.postgresql.HSTORE.Comparator.has_all),
    [has_any()](#sqlalchemy.dialects.postgresql.HSTORE.Comparator.has_any), [has_key()](#sqlalchemy.dialects.postgresql.HSTORE.Comparator.has_key),
    [keys()](#sqlalchemy.dialects.postgresql.HSTORE.Comparator.keys), [matrix()](#sqlalchemy.dialects.postgresql.HSTORE.Comparator.matrix),
    [slice()](#sqlalchemy.dialects.postgresql.HSTORE.Comparator.slice), [vals()](#sqlalchemy.dialects.postgresql.HSTORE.Comparator.vals),
    [__init__()](#sqlalchemy.dialects.postgresql.HSTORE.__init__), [bind_processor()](#sqlalchemy.dialects.postgresql.HSTORE.bind_processor),
    [comparator_factory](#sqlalchemy.dialects.postgresql.HSTORE.comparator_factory),
    [hashable](#sqlalchemy.dialects.postgresql.HSTORE.hashable), [result_processor()](#sqlalchemy.dialects.postgresql.HSTORE.result_processor)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.postgresql.HSTORE`](#sqlalchemy.dialects.postgresql.HSTORE
    "sqlalchemy.dialects.postgresql.HSTORE") ([`sqlalchemy.types.Indexable`](../core/type_api.html#sqlalchemy.types.Indexable
    "sqlalchemy.types.Indexable"), [`sqlalchemy.types.Concatenable`](../core/type_api.html#sqlalchemy.types.Concatenable
    "sqlalchemy.types.Concatenable"), [`sqlalchemy.types.TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: Define comparison operations for [`HSTORE`](#sqlalchemy.dialects.postgresql.HSTORE
    "sqlalchemy.dialects.postgresql.HSTORE").
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.postgresql.HSTORE.Comparator`](#sqlalchemy.dialects.postgresql.HSTORE.Comparator
    "sqlalchemy.dialects.postgresql.HSTORE.Comparator") (`sqlalchemy.types.Comparator`,
    `sqlalchemy.types.Comparator`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: Text array expression. Returns array of alternating keys and values.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: Boolean expression. Test if keys are a proper subset of the keys of the argument
    jsonb expression.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: Boolean expression. Test if keys (or array) are a superset of/contained the
    keys of the argument jsonb expression.
  prefs: []
  type: TYPE_NORMAL
- en: kwargs may be ignored by this operator but are required for API conformance.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: Boolean expression. Test for presence of a non-NULL value for the key. Note
    that the key may be a SQLA expression.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: HStore expression. Returns the contents of this hstore with the given key deleted.
    Note that the key may be a SQLA expression.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: Boolean expression. Test for presence of all keys in jsonb
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: Boolean expression. Test for presence of any key in jsonb
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: Boolean expression. Test for presence of a key. Note that the key may be a SQLA
    expression.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: Text array expression. Returns array of keys.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: Text array expression. Returns array of [key, value] pairs.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: HStore expression. Returns a subset of an hstore defined by array of keys.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: Text array expression. Returns array of values.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: Construct a new [`HSTORE`](#sqlalchemy.dialects.postgresql.HSTORE "sqlalchemy.dialects.postgresql.HSTORE").
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**text_type** – the type that should be used for indexed values. Defaults to
    [`Text`](../core/type_basics.html#sqlalchemy.types.Text "sqlalchemy.types.Text").'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: Return a conversion function for processing bind values.
  prefs: []
  type: TYPE_NORMAL
- en: Returns a callable which will receive a bind parameter value as the sole positional
    argument and will return a value to send to the DB-API.
  prefs: []
  type: TYPE_NORMAL
- en: If processing is not necessary, the method should return `None`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This method is only called relative to a **dialect specific type object**, which
    is often **private to a dialect in use** and is not the same type object as the
    public facing one, which means it’s not feasible to subclass a [`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") class in order to provide an alternate [`TypeEngine.bind_processor()`](../core/type_api.html#sqlalchemy.types.TypeEngine.bind_processor
    "sqlalchemy.types.TypeEngine.bind_processor") method, unless subclassing the [`UserDefinedType`](../core/custom_types.html#sqlalchemy.types.UserDefinedType
    "sqlalchemy.types.UserDefinedType") class explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: To provide alternate behavior for [`TypeEngine.bind_processor()`](../core/type_api.html#sqlalchemy.types.TypeEngine.bind_processor
    "sqlalchemy.types.TypeEngine.bind_processor"), implement a [`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") class and provide an implementation of [`TypeDecorator.process_bind_param()`](../core/custom_types.html#sqlalchemy.types.TypeDecorator.process_bind_param
    "sqlalchemy.types.TypeDecorator.process_bind_param").
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Augmenting Existing Types](../core/custom_types.html#types-typedecorator)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**dialect** – Dialect instance in use.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: alias of [`Comparator`](#sqlalchemy.dialects.postgresql.HSTORE.Comparator "sqlalchemy.dialects.postgresql.hstore.HSTORE.Comparator")
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: Flag, if False, means values from this type aren’t hashable.
  prefs: []
  type: TYPE_NORMAL
- en: Used by the ORM when uniquing result lists.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: Return a conversion function for processing result row values.
  prefs: []
  type: TYPE_NORMAL
- en: Returns a callable which will receive a result row column value as the sole
    positional argument and will return a value to return to the user.
  prefs: []
  type: TYPE_NORMAL
- en: If processing is not necessary, the method should return `None`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This method is only called relative to a **dialect specific type object**, which
    is often **private to a dialect in use** and is not the same type object as the
    public facing one, which means it’s not feasible to subclass a [`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") class in order to provide an alternate [`TypeEngine.result_processor()`](../core/type_api.html#sqlalchemy.types.TypeEngine.result_processor
    "sqlalchemy.types.TypeEngine.result_processor") method, unless subclassing the
    [`UserDefinedType`](../core/custom_types.html#sqlalchemy.types.UserDefinedType
    "sqlalchemy.types.UserDefinedType") class explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: To provide alternate behavior for [`TypeEngine.result_processor()`](../core/type_api.html#sqlalchemy.types.TypeEngine.result_processor
    "sqlalchemy.types.TypeEngine.result_processor"), implement a [`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") class and provide an implementation of [`TypeDecorator.process_result_value()`](../core/custom_types.html#sqlalchemy.types.TypeDecorator.process_result_value
    "sqlalchemy.types.TypeDecorator.process_result_value").
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Augmenting Existing Types](../core/custom_types.html#types-typedecorator)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dialect` – Dialect instance in use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`coltype` – DBAPI coltype argument received in cursor.description.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.postgresql.INET`](#sqlalchemy.dialects.postgresql.INET
    "sqlalchemy.dialects.postgresql.INET") ([`sqlalchemy.types.TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: PostgreSQL INTERVAL type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.dialects.postgresql.INTERVAL.__init__)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.postgresql.INTERVAL`](#sqlalchemy.dialects.postgresql.INTERVAL
    "sqlalchemy.dialects.postgresql.INTERVAL") (`sqlalchemy.types.NativeForEmulated`,
    `sqlalchemy.types._AbstractInterval`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: Construct an INTERVAL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`precision` – optional integer precision value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fields` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: string fields specifier. allows storage of fields to be limited, such as `"YEAR"`,
    `"MONTH"`, `"DAY TO HOUR"`, etc.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: New in version 1.2.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: Represent the PostgreSQL JSON type.
  prefs: []
  type: TYPE_NORMAL
- en: '[`JSON`](#sqlalchemy.dialects.postgresql.JSON "sqlalchemy.dialects.postgresql.JSON")
    is used automatically whenever the base [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON") datatype is used against a PostgreSQL backend, however
    base [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON")
    datatype does not provide Python accessors for PostgreSQL-specific comparison
    methods such as [`Comparator.astext()`](#sqlalchemy.dialects.postgresql.JSON.Comparator.astext
    "sqlalchemy.dialects.postgresql.JSON.Comparator.astext"); additionally, to use
    PostgreSQL `JSONB`, the [`JSONB`](#sqlalchemy.dialects.postgresql.JSONB "sqlalchemy.dialects.postgresql.JSONB")
    datatype should be used explicitly.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON")
    - main documentation for the generic cross-platform JSON datatype.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The operators provided by the PostgreSQL version of [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON") include:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Index operations (the `->` operator):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE194]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Index operations returning text (the `->>` operator):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE195]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that equivalent functionality is available via the [`Comparator.as_string`](../core/type_basics.html#sqlalchemy.types.JSON.Comparator.as_string
    "sqlalchemy.types.JSON.Comparator.as_string") accessor.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Index operations with CAST (equivalent to `CAST(col ->> [''some key''] AS <type>)`):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE196]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that equivalent functionality is available via the [`Comparator.as_integer`](../core/type_basics.html#sqlalchemy.types.JSON.Comparator.as_integer
    "sqlalchemy.types.JSON.Comparator.as_integer") and similar accessors.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Path index operations (the `#>` operator):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE197]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Path index operations returning text (the `#>>` operator):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE198]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Index operations return an expression object whose type defaults to [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON") by default, so that further JSON-oriented instructions
    may be called upon the result type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Custom serializers and deserializers are specified at the dialect level, that
    is using [`create_engine()`](../core/engines.html#sqlalchemy.create_engine "sqlalchemy.create_engine").
    The reason for this is that when using psycopg2, the DBAPI only allows serializers
    at the per-cursor or per-connection level. E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: When using the psycopg2 dialect, the json_deserializer is registered against
    the database using `psycopg2.extras.register_default_json`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON")
    - Core level JSON type'
  prefs: []
  type: TYPE_NORMAL
- en: '[`JSONB`](#sqlalchemy.dialects.postgresql.JSONB "sqlalchemy.dialects.postgresql.JSONB")'
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[astext](#sqlalchemy.dialects.postgresql.JSON.Comparator.astext), [__init__()](#sqlalchemy.dialects.postgresql.JSON.__init__),
    [comparator_factory](#sqlalchemy.dialects.postgresql.JSON.comparator_factory)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.postgresql.JSON`](#sqlalchemy.dialects.postgresql.JSON
    "sqlalchemy.dialects.postgresql.JSON") ([`sqlalchemy.types.JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: Define comparison operations for [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON").
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.postgresql.JSON.Comparator`](#sqlalchemy.dialects.postgresql.JSON.Comparator
    "sqlalchemy.dialects.postgresql.JSON.Comparator") (`sqlalchemy.types.Comparator`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: On an indexed expression, use the “astext” (e.g. “->>”) conversion when rendered
    in SQL.
  prefs: []
  type: TYPE_NORMAL
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnElement.cast()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnElement.cast
    "sqlalchemy.sql.expression.ColumnElement.cast")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: Construct a [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON")
    type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`none_as_null` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'if True, persist the value `None` as a SQL NULL value, not the JSON encoding
    of `null`. Note that when this flag is False, the [`null()`](../core/sqlelement.html#sqlalchemy.sql.expression.null
    "sqlalchemy.sql.expression.null") construct can still be used to persist a NULL
    value:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE204]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`JSON.NULL`](../core/type_basics.html#sqlalchemy.types.JSON.NULL "sqlalchemy.types.JSON.NULL")'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`astext_type` – the type to use for the [`Comparator.astext`](#sqlalchemy.dialects.postgresql.JSON.Comparator.astext
    "sqlalchemy.dialects.postgresql.JSON.Comparator.astext") accessor on indexed attributes.
    Defaults to [`Text`](../core/type_basics.html#sqlalchemy.types.Text "sqlalchemy.types.Text").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: alias of [`Comparator`](#sqlalchemy.dialects.postgresql.JSON.Comparator "sqlalchemy.dialects.postgresql.json.JSON.Comparator")
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: Represent the PostgreSQL JSONB type.
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`JSONB`](#sqlalchemy.dialects.postgresql.JSONB "sqlalchemy.dialects.postgresql.JSONB")
    type stores arbitrary JSONB format data, e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: The [`JSONB`](#sqlalchemy.dialects.postgresql.JSONB "sqlalchemy.dialects.postgresql.JSONB")
    type includes all operations provided by [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON"), including the same behaviors for indexing operations.
    It also adds additional operators specific to JSONB, including [`Comparator.has_key()`](#sqlalchemy.dialects.postgresql.JSONB.Comparator.has_key
    "sqlalchemy.dialects.postgresql.JSONB.Comparator.has_key"), [`Comparator.has_all()`](#sqlalchemy.dialects.postgresql.JSONB.Comparator.has_all
    "sqlalchemy.dialects.postgresql.JSONB.Comparator.has_all"), [`Comparator.has_any()`](#sqlalchemy.dialects.postgresql.JSONB.Comparator.has_any
    "sqlalchemy.dialects.postgresql.JSONB.Comparator.has_any"), [`Comparator.contains()`](#sqlalchemy.dialects.postgresql.JSONB.Comparator.contains
    "sqlalchemy.dialects.postgresql.JSONB.Comparator.contains"), [`Comparator.contained_by()`](#sqlalchemy.dialects.postgresql.JSONB.Comparator.contained_by
    "sqlalchemy.dialects.postgresql.JSONB.Comparator.contained_by"), [`Comparator.delete_path()`](#sqlalchemy.dialects.postgresql.JSONB.Comparator.delete_path
    "sqlalchemy.dialects.postgresql.JSONB.Comparator.delete_path"), [`Comparator.path_exists()`](#sqlalchemy.dialects.postgresql.JSONB.Comparator.path_exists
    "sqlalchemy.dialects.postgresql.JSONB.Comparator.path_exists") and [`Comparator.path_match()`](#sqlalchemy.dialects.postgresql.JSONB.Comparator.path_match
    "sqlalchemy.dialects.postgresql.JSONB.Comparator.path_match").
  prefs: []
  type: TYPE_NORMAL
- en: Like the [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON")
    type, the [`JSONB`](#sqlalchemy.dialects.postgresql.JSONB "sqlalchemy.dialects.postgresql.JSONB")
    type does not detect in-place changes when used with the ORM, unless the [`sqlalchemy.ext.mutable`](../orm/extensions/mutable.html#module-sqlalchemy.ext.mutable
    "sqlalchemy.ext.mutable") extension is used.
  prefs: []
  type: TYPE_NORMAL
- en: Custom serializers and deserializers are shared with the [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON") class, using the `json_serializer` and `json_deserializer`
    keyword arguments. These must be specified at the dialect level using [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine"). When using psycopg2, the serializers are associated
    with the jsonb type using `psycopg2.extras.register_default_jsonb` on a per-connection
    basis, in the same way that `psycopg2.extras.register_default_json` is used to
    register these handlers with the json type.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON")'
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[contained_by()](#sqlalchemy.dialects.postgresql.JSONB.Comparator.contained_by),
    [contains()](#sqlalchemy.dialects.postgresql.JSONB.Comparator.contains), [delete_path()](#sqlalchemy.dialects.postgresql.JSONB.Comparator.delete_path),
    [has_all()](#sqlalchemy.dialects.postgresql.JSONB.Comparator.has_all), [has_any()](#sqlalchemy.dialects.postgresql.JSONB.Comparator.has_any),
    [has_key()](#sqlalchemy.dialects.postgresql.JSONB.Comparator.has_key), [path_exists()](#sqlalchemy.dialects.postgresql.JSONB.Comparator.path_exists),
    [path_match()](#sqlalchemy.dialects.postgresql.JSONB.Comparator.path_match), [comparator_factory](#sqlalchemy.dialects.postgresql.JSONB.comparator_factory)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.postgresql.JSONB`](#sqlalchemy.dialects.postgresql.JSONB
    "sqlalchemy.dialects.postgresql.JSONB") ([`sqlalchemy.dialects.postgresql.json.JSON`](#sqlalchemy.dialects.postgresql.JSON
    "sqlalchemy.dialects.postgresql.json.JSON"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: Define comparison operations for [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON").
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.postgresql.JSONB.Comparator`](#sqlalchemy.dialects.postgresql.JSONB.Comparator
    "sqlalchemy.dialects.postgresql.JSONB.Comparator") (`sqlalchemy.dialects.postgresql.json.Comparator`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: Boolean expression. Test if keys are a proper subset of the keys of the argument
    jsonb expression.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: Boolean expression. Test if keys (or array) are a superset of/contained the
    keys of the argument jsonb expression.
  prefs: []
  type: TYPE_NORMAL
- en: kwargs may be ignored by this operator but are required for API conformance.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: JSONB expression. Deletes field or array element specified in the argument array.
  prefs: []
  type: TYPE_NORMAL
- en: The input may be a list of strings that will be coerced to an `ARRAY` or an
    instance of `_postgres.array()`.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: Boolean expression. Test for presence of all keys in jsonb
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: Boolean expression. Test for presence of any key in jsonb
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: Boolean expression. Test for presence of a key. Note that the key may be a SQLA
    expression.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: Boolean expression. Test for presence of item given by the argument JSONPath
    expression.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: Boolean expression. Test if JSONPath predicate given by the argument JSONPath
    expression matches.
  prefs: []
  type: TYPE_NORMAL
- en: Only the first item of the result is taken into account.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: alias of [`Comparator`](#sqlalchemy.dialects.postgresql.JSONB.Comparator "sqlalchemy.dialects.postgresql.json.JSONB.Comparator")
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: JSON Path Type.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is usually required to cast literal values to json path when using json
    search like function, such as `jsonb_path_query_array` or `jsonb_path_exists`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.postgresql.JSONPATH`](#sqlalchemy.dialects.postgresql.JSONPATH
    "sqlalchemy.dialects.postgresql.JSONPATH") (`sqlalchemy.dialects.postgresql.json.JSONPathType`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.postgresql.MACADDR`](#sqlalchemy.dialects.postgresql.MACADDR
    "sqlalchemy.dialects.postgresql.MACADDR") ([`sqlalchemy.types.TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.postgresql.MACADDR8`](#sqlalchemy.dialects.postgresql.MACADDR8
    "sqlalchemy.dialects.postgresql.MACADDR8") ([`sqlalchemy.types.TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: Provide the PostgreSQL MONEY type.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on driver, result rows using this type may return a string value which
    includes currency symbols.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this reason, it may be preferable to provide conversion to a numerically-based
    currency datatype using [`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, the conversion may be applied as a CAST using the [`TypeDecorator.column_expression()`](../core/custom_types.html#sqlalchemy.types.TypeDecorator.column_expression
    "sqlalchemy.types.TypeDecorator.column_expression") method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: New in version 1.2.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.postgresql.MONEY`](#sqlalchemy.dialects.postgresql.MONEY
    "sqlalchemy.dialects.postgresql.MONEY") ([`sqlalchemy.types.TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE225]'
  prefs: []
  type: TYPE_PRE
- en: Provide the PostgreSQL OID type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.postgresql.OID`](#sqlalchemy.dialects.postgresql.OID
    "sqlalchemy.dialects.postgresql.OID") ([`sqlalchemy.types.TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: The SQL REAL type.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Float`](../core/type_basics.html#sqlalchemy.types.Float "sqlalchemy.types.Float")
    - documentation for the base type.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class `sqlalchemy.dialects.postgresql.REAL` ([`sqlalchemy.types.Float`](../core/type_basics.html#sqlalchemy.types.Float
    "sqlalchemy.types.Float"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE227]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `sqlalchemy.types.Float.__init__` *method of* [`Float`](../core/type_basics.html#sqlalchemy.types.Float
    "sqlalchemy.types.Float")'
  prefs: []
  type: TYPE_NORMAL
- en: Construct a Float.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`precision` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the numeric precision for use in DDL `CREATE TABLE`. Backends **should** attempt
    to ensure this precision indicates a number of digits for the generic [`Float`](../core/type_basics.html#sqlalchemy.types.Float
    "sqlalchemy.types.Float") datatype.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For the Oracle backend, the [`Float.precision`](../core/type_basics.html#sqlalchemy.types.Float.params.precision
    "sqlalchemy.types.Float") parameter is not accepted when rendering DDL, as Oracle
    does not support float precision specified as a number of decimal places. Instead,
    use the Oracle-specific [`FLOAT`](oracle.html#sqlalchemy.dialects.oracle.FLOAT
    "sqlalchemy.dialects.oracle.FLOAT") datatype and specify the [`FLOAT.binary_precision`](oracle.html#sqlalchemy.dialects.oracle.FLOAT.params.binary_precision
    "sqlalchemy.dialects.oracle.FLOAT") parameter. This is new in version 2.0 of SQLAlchemy.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To create a database agnostic [`Float`](../core/type_basics.html#sqlalchemy.types.Float
    "sqlalchemy.types.Float") that separately specifies binary precision for Oracle,
    use [`TypeEngine.with_variant()`](../core/type_api.html#sqlalchemy.types.TypeEngine.with_variant
    "sqlalchemy.types.TypeEngine.with_variant") as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE228]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`asdecimal` – the same flag as that of [`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric
    "sqlalchemy.types.Numeric"), but defaults to `False`. Note that setting this flag
    to `True` results in floating point conversion.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`decimal_return_scale` – Default scale to use when converting from floats to
    Python decimals. Floating point values will typically be much longer due to decimal
    inaccuracy, and most floating point database types don’t have a notion of “scale”,
    so by default the float type looks for the first ten decimal places when converting.
    Specifying this value will override that length. Note that the MySQL float types,
    which do include “scale”, will use “scale” as the default for decimal_return_scale,
    if not otherwise specified.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE229]'
  prefs: []
  type: TYPE_PRE
- en: Provide the PostgreSQL REGCONFIG type.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.0rc1.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.postgresql.REGCONFIG`](#sqlalchemy.dialects.postgresql.REGCONFIG
    "sqlalchemy.dialects.postgresql.REGCONFIG") ([`sqlalchemy.types.TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE230]'
  prefs: []
  type: TYPE_PRE
- en: Provide the PostgreSQL REGCLASS type.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.2.7.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.postgresql.REGCLASS`](#sqlalchemy.dialects.postgresql.REGCLASS
    "sqlalchemy.dialects.postgresql.REGCLASS") ([`sqlalchemy.types.TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE231]'
  prefs: []
  type: TYPE_PRE
- en: Provide the PostgreSQL TIMESTAMP type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.dialects.postgresql.TIMESTAMP.__init__)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.postgresql.TIMESTAMP`](#sqlalchemy.dialects.postgresql.TIMESTAMP
    "sqlalchemy.dialects.postgresql.TIMESTAMP") ([`sqlalchemy.types.TIMESTAMP`](../core/type_basics.html#sqlalchemy.types.TIMESTAMP
    "sqlalchemy.types.TIMESTAMP"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE232]'
  prefs: []
  type: TYPE_PRE
- en: Construct a TIMESTAMP.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`timezone` – boolean value if timezone present, default False'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`precision` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: optional integer precision value
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: New in version 1.4.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE233]'
  prefs: []
  type: TYPE_PRE
- en: PostgreSQL TIME type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.dialects.postgresql.TIME.__init__)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.postgresql.TIME`](#sqlalchemy.dialects.postgresql.TIME
    "sqlalchemy.dialects.postgresql.TIME") ([`sqlalchemy.types.TIME`](../core/type_basics.html#sqlalchemy.types.TIME
    "sqlalchemy.types.TIME"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE234]'
  prefs: []
  type: TYPE_PRE
- en: Construct a TIME.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`timezone` – boolean value if timezone present, default False'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`precision` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: optional integer precision value
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: New in version 1.4.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE235]'
  prefs: []
  type: TYPE_PRE
- en: Provide the PostgreSQL TSQUERY type.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.0rc1.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.postgresql.TSQUERY`](#sqlalchemy.dialects.postgresql.TSQUERY
    "sqlalchemy.dialects.postgresql.TSQUERY") ([`sqlalchemy.types.TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE236]'
  prefs: []
  type: TYPE_PRE
- en: The [`TSVECTOR`](#sqlalchemy.dialects.postgresql.TSVECTOR "sqlalchemy.dialects.postgresql.TSVECTOR")
    type implements the PostgreSQL text search type TSVECTOR.
  prefs: []
  type: TYPE_NORMAL
- en: It can be used to do full text queries on natural language documents.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Full Text Search](#postgresql-match)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.postgresql.TSVECTOR`](#sqlalchemy.dialects.postgresql.TSVECTOR
    "sqlalchemy.dialects.postgresql.TSVECTOR") ([`sqlalchemy.types.TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE237]'
  prefs: []
  type: TYPE_PRE
- en: Represent the SQL UUID type.
  prefs: []
  type: TYPE_NORMAL
- en: This is the SQL-native form of the [`Uuid`](../core/type_basics.html#sqlalchemy.types.Uuid
    "sqlalchemy.types.Uuid") database agnostic datatype, and is backwards compatible
    with the previous PostgreSQL-only version of `UUID`.
  prefs: []
  type: TYPE_NORMAL
- en: The [`UUID`](../core/type_basics.html#sqlalchemy.types.UUID "sqlalchemy.types.UUID")
    datatype only works on databases that have a SQL datatype named `UUID`. It will
    not function for backends which don’t have this exact-named type, including SQL
    Server. For backend-agnostic UUID values with native support, including for SQL
    Server’s `UNIQUEIDENTIFIER` datatype, use the [`Uuid`](../core/type_basics.html#sqlalchemy.types.Uuid
    "sqlalchemy.types.Uuid") datatype.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Uuid`](../core/type_basics.html#sqlalchemy.types.Uuid "sqlalchemy.types.Uuid")'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class `sqlalchemy.dialects.postgresql.UUID` ([`sqlalchemy.types.Uuid`](../core/type_basics.html#sqlalchemy.types.Uuid
    "sqlalchemy.types.Uuid"), `sqlalchemy.types.NativeForEmulated`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE238]'
  prefs: []
  type: TYPE_PRE
- en: Construct a [`UUID`](../core/type_basics.html#sqlalchemy.types.UUID "sqlalchemy.types.UUID")
    type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**as_uuid=True** –'
  prefs: []
  type: TYPE_NORMAL
- en: if True, values will be interpreted as Python uuid objects, converting to/from
    string via the DBAPI.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE239]'
  prefs: []
  type: TYPE_PRE
- en: Represent the PostgreSQL INT4RANGE type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.postgresql.INT4RANGE`](#sqlalchemy.dialects.postgresql.INT4RANGE
    "sqlalchemy.dialects.postgresql.INT4RANGE") ([`sqlalchemy.dialects.postgresql.ranges.AbstractSingleRange`](#sqlalchemy.dialects.postgresql.AbstractSingleRange
    "sqlalchemy.dialects.postgresql.ranges.AbstractSingleRange"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE240]'
  prefs: []
  type: TYPE_PRE
- en: Represent the PostgreSQL INT8RANGE type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.postgresql.INT8RANGE`](#sqlalchemy.dialects.postgresql.INT8RANGE
    "sqlalchemy.dialects.postgresql.INT8RANGE") ([`sqlalchemy.dialects.postgresql.ranges.AbstractSingleRange`](#sqlalchemy.dialects.postgresql.AbstractSingleRange
    "sqlalchemy.dialects.postgresql.ranges.AbstractSingleRange"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE241]'
  prefs: []
  type: TYPE_PRE
- en: Represent the PostgreSQL NUMRANGE type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.postgresql.NUMRANGE`](#sqlalchemy.dialects.postgresql.NUMRANGE
    "sqlalchemy.dialects.postgresql.NUMRANGE") ([`sqlalchemy.dialects.postgresql.ranges.AbstractSingleRange`](#sqlalchemy.dialects.postgresql.AbstractSingleRange
    "sqlalchemy.dialects.postgresql.ranges.AbstractSingleRange"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE242]'
  prefs: []
  type: TYPE_PRE
- en: Represent the PostgreSQL DATERANGE type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.postgresql.DATERANGE`](#sqlalchemy.dialects.postgresql.DATERANGE
    "sqlalchemy.dialects.postgresql.DATERANGE") ([`sqlalchemy.dialects.postgresql.ranges.AbstractSingleRange`](#sqlalchemy.dialects.postgresql.AbstractSingleRange
    "sqlalchemy.dialects.postgresql.ranges.AbstractSingleRange"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE243]'
  prefs: []
  type: TYPE_PRE
- en: Represent the PostgreSQL TSRANGE type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.postgresql.TSRANGE`](#sqlalchemy.dialects.postgresql.TSRANGE
    "sqlalchemy.dialects.postgresql.TSRANGE") ([`sqlalchemy.dialects.postgresql.ranges.AbstractSingleRange`](#sqlalchemy.dialects.postgresql.AbstractSingleRange
    "sqlalchemy.dialects.postgresql.ranges.AbstractSingleRange"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE244]'
  prefs: []
  type: TYPE_PRE
- en: Represent the PostgreSQL TSTZRANGE type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.postgresql.TSTZRANGE`](#sqlalchemy.dialects.postgresql.TSTZRANGE
    "sqlalchemy.dialects.postgresql.TSTZRANGE") ([`sqlalchemy.dialects.postgresql.ranges.AbstractSingleRange`](#sqlalchemy.dialects.postgresql.AbstractSingleRange
    "sqlalchemy.dialects.postgresql.ranges.AbstractSingleRange"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE245]'
  prefs: []
  type: TYPE_PRE
- en: Represent the PostgreSQL INT4MULTIRANGE type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.postgresql.INT4MULTIRANGE`](#sqlalchemy.dialects.postgresql.INT4MULTIRANGE
    "sqlalchemy.dialects.postgresql.INT4MULTIRANGE") ([`sqlalchemy.dialects.postgresql.ranges.AbstractMultiRange`](#sqlalchemy.dialects.postgresql.AbstractMultiRange
    "sqlalchemy.dialects.postgresql.ranges.AbstractMultiRange"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE246]'
  prefs: []
  type: TYPE_PRE
- en: Represent the PostgreSQL INT8MULTIRANGE type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.postgresql.INT8MULTIRANGE`](#sqlalchemy.dialects.postgresql.INT8MULTIRANGE
    "sqlalchemy.dialects.postgresql.INT8MULTIRANGE") ([`sqlalchemy.dialects.postgresql.ranges.AbstractMultiRange`](#sqlalchemy.dialects.postgresql.AbstractMultiRange
    "sqlalchemy.dialects.postgresql.ranges.AbstractMultiRange"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE247]'
  prefs: []
  type: TYPE_PRE
- en: Represent the PostgreSQL NUMMULTIRANGE type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.postgresql.NUMMULTIRANGE`](#sqlalchemy.dialects.postgresql.NUMMULTIRANGE
    "sqlalchemy.dialects.postgresql.NUMMULTIRANGE") ([`sqlalchemy.dialects.postgresql.ranges.AbstractMultiRange`](#sqlalchemy.dialects.postgresql.AbstractMultiRange
    "sqlalchemy.dialects.postgresql.ranges.AbstractMultiRange"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE248]'
  prefs: []
  type: TYPE_PRE
- en: Represent the PostgreSQL DATEMULTIRANGE type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.postgresql.DATEMULTIRANGE`](#sqlalchemy.dialects.postgresql.DATEMULTIRANGE
    "sqlalchemy.dialects.postgresql.DATEMULTIRANGE") ([`sqlalchemy.dialects.postgresql.ranges.AbstractMultiRange`](#sqlalchemy.dialects.postgresql.AbstractMultiRange
    "sqlalchemy.dialects.postgresql.ranges.AbstractMultiRange"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE249]'
  prefs: []
  type: TYPE_PRE
- en: Represent the PostgreSQL TSRANGE type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.postgresql.TSMULTIRANGE`](#sqlalchemy.dialects.postgresql.TSMULTIRANGE
    "sqlalchemy.dialects.postgresql.TSMULTIRANGE") ([`sqlalchemy.dialects.postgresql.ranges.AbstractMultiRange`](#sqlalchemy.dialects.postgresql.AbstractMultiRange
    "sqlalchemy.dialects.postgresql.ranges.AbstractMultiRange"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE250]'
  prefs: []
  type: TYPE_PRE
- en: Represent the PostgreSQL TSTZRANGE type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.postgresql.TSTZMULTIRANGE`](#sqlalchemy.dialects.postgresql.TSTZMULTIRANGE
    "sqlalchemy.dialects.postgresql.TSTZMULTIRANGE") ([`sqlalchemy.dialects.postgresql.ranges.AbstractMultiRange`](#sqlalchemy.dialects.postgresql.AbstractMultiRange
    "sqlalchemy.dialects.postgresql.ranges.AbstractMultiRange"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE251]'
  prefs: []
  type: TYPE_PRE
- en: Represents a multirange sequence.
  prefs: []
  type: TYPE_NORMAL
- en: 'This list subclass is an utility to allow automatic type inference of the proper
    multi-range SQL type depending on the single range values. This is useful when
    operating on literal multi-ranges:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE252]'
  prefs: []
  type: TYPE_PRE
- en: New in version 2.0.26.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Use of a MultiRange sequence to infer the multirange type](#postgresql-multirange-list-use).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.postgresql.MultiRange`](#sqlalchemy.dialects.postgresql.MultiRange
    "sqlalchemy.dialects.postgresql.MultiRange") (`builtins.list`, `typing.Generic`)
  prefs: []
  type: TYPE_NORMAL
- en: PostgreSQL SQL Elements and Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '| Object Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| [aggregate_order_by](#sqlalchemy.dialects.postgresql.aggregate_order_by)
    | Represent a PostgreSQL aggregate order by expression. |'
  prefs: []
  type: TYPE_TB
- en: '| [All](#sqlalchemy.dialects.postgresql.All)(other, arrexpr[, operator]) |
    A synonym for the ARRAY-level [`Comparator.all()`](../core/type_basics.html#sqlalchemy.types.ARRAY.Comparator.all
    "sqlalchemy.types.ARRAY.Comparator.all") method. See that method for details.
    |'
  prefs: []
  type: TYPE_TB
- en: '| [Any](#sqlalchemy.dialects.postgresql.Any)(other, arrexpr[, operator]) |
    A synonym for the ARRAY-level [`Comparator.any()`](../core/type_basics.html#sqlalchemy.types.ARRAY.Comparator.any
    "sqlalchemy.types.ARRAY.Comparator.any") method. See that method for details.
    |'
  prefs: []
  type: TYPE_TB
- en: '| [array](#sqlalchemy.dialects.postgresql.array) | A PostgreSQL ARRAY literal.
    |'
  prefs: []
  type: TYPE_TB
- en: '| [array_agg](#sqlalchemy.dialects.postgresql.array_agg)(*arg, **kw) | PostgreSQL-specific
    form of [`array_agg`](../core/functions.html#sqlalchemy.sql.functions.array_agg
    "sqlalchemy.sql.functions.array_agg"), ensures return type is [`ARRAY`](#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY") and not the plain [`ARRAY`](../core/type_basics.html#sqlalchemy.types.ARRAY
    "sqlalchemy.types.ARRAY"), unless an explicit `type_` is passed. |'
  prefs: []
  type: TYPE_TB
- en: '| [hstore](#sqlalchemy.dialects.postgresql.hstore) | Construct an hstore value
    within a SQL expression using the PostgreSQL `hstore()` function. |'
  prefs: []
  type: TYPE_TB
- en: '| [phraseto_tsquery](#sqlalchemy.dialects.postgresql.phraseto_tsquery) | The
    PostgreSQL `phraseto_tsquery` SQL function. |'
  prefs: []
  type: TYPE_TB
- en: '| [plainto_tsquery](#sqlalchemy.dialects.postgresql.plainto_tsquery) | The
    PostgreSQL `plainto_tsquery` SQL function. |'
  prefs: []
  type: TYPE_TB
- en: '| [to_tsquery](#sqlalchemy.dialects.postgresql.to_tsquery) | The PostgreSQL
    `to_tsquery` SQL function. |'
  prefs: []
  type: TYPE_TB
- en: '| [to_tsvector](#sqlalchemy.dialects.postgresql.to_tsvector) | The PostgreSQL
    `to_tsvector` SQL function. |'
  prefs: []
  type: TYPE_TB
- en: '| [ts_headline](#sqlalchemy.dialects.postgresql.ts_headline) | The PostgreSQL
    `ts_headline` SQL function. |'
  prefs: []
  type: TYPE_TB
- en: '| [websearch_to_tsquery](#sqlalchemy.dialects.postgresql.websearch_to_tsquery)
    | The PostgreSQL `websearch_to_tsquery` SQL function. |'
  prefs: []
  type: TYPE_TB
- en: '[PRE253]'
  prefs: []
  type: TYPE_PRE
- en: Represent a PostgreSQL aggregate order by expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE254]'
  prefs: []
  type: TYPE_PRE
- en: 'would represent the expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE255]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE256]'
  prefs: []
  type: TYPE_PRE
- en: 'Would represent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE257]'
  prefs: []
  type: TYPE_PRE
- en: 'Changed in version 1.2.13: - the ORDER BY argument may be multiple terms'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`array_agg`](../core/functions.html#sqlalchemy.sql.functions.array_agg "sqlalchemy.sql.functions.array_agg")'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.postgresql.aggregate_order_by`](#sqlalchemy.dialects.postgresql.aggregate_order_by
    "sqlalchemy.dialects.postgresql.aggregate_order_by") ([`sqlalchemy.sql.expression.ColumnElement`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE258]'
  prefs: []
  type: TYPE_PRE
- en: A PostgreSQL ARRAY literal.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is used to produce ARRAY literals in SQL expressions, e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE259]'
  prefs: []
  type: TYPE_PRE
- en: 'Produces the SQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE260]'
  prefs: []
  type: TYPE_PRE
- en: 'An instance of [`array`](#sqlalchemy.dialects.postgresql.array "sqlalchemy.dialects.postgresql.array.array")
    will always have the datatype [`ARRAY`](../core/type_basics.html#sqlalchemy.types.ARRAY
    "sqlalchemy.types.ARRAY"). The “inner” type of the array is inferred from the
    values present, unless the `type_` keyword argument is passed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE261]'
  prefs: []
  type: TYPE_PRE
- en: 'Multidimensional arrays are produced by nesting [`array`](#sqlalchemy.dialects.postgresql.array
    "sqlalchemy.dialects.postgresql.array.array") constructs. The dimensionality of
    the final [`ARRAY`](../core/type_basics.html#sqlalchemy.types.ARRAY "sqlalchemy.types.ARRAY")
    type is calculated by recursively adding the dimensions of the inner [`ARRAY`](../core/type_basics.html#sqlalchemy.types.ARRAY
    "sqlalchemy.types.ARRAY") type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE262]'
  prefs: []
  type: TYPE_PRE
- en: 'Produces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE263]'
  prefs: []
  type: TYPE_PRE
- en: 'New in version 1.3.6: added support for multidimensional array literals'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`ARRAY`](#sqlalchemy.dialects.postgresql.ARRAY "sqlalchemy.dialects.postgresql.ARRAY")'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.postgresql.array`](#sqlalchemy.dialects.postgresql.array
    "sqlalchemy.dialects.postgresql.array") (`sqlalchemy.sql.expression.ExpressionClauseList`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE264]'
  prefs: []
  type: TYPE_PRE
- en: PostgreSQL-specific form of [`array_agg`](../core/functions.html#sqlalchemy.sql.functions.array_agg
    "sqlalchemy.sql.functions.array_agg"), ensures return type is [`ARRAY`](#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY") and not the plain [`ARRAY`](../core/type_basics.html#sqlalchemy.types.ARRAY
    "sqlalchemy.types.ARRAY"), unless an explicit `type_` is passed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE265]'
  prefs: []
  type: TYPE_PRE
- en: A synonym for the ARRAY-level [`Comparator.any()`](../core/type_basics.html#sqlalchemy.types.ARRAY.Comparator.any
    "sqlalchemy.types.ARRAY.Comparator.any") method. See that method for details.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE266]'
  prefs: []
  type: TYPE_PRE
- en: A synonym for the ARRAY-level [`Comparator.all()`](../core/type_basics.html#sqlalchemy.types.ARRAY.Comparator.all
    "sqlalchemy.types.ARRAY.Comparator.all") method. See that method for details.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE267]'
  prefs: []
  type: TYPE_PRE
- en: Construct an hstore value within a SQL expression using the PostgreSQL `hstore()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: The [`hstore`](#sqlalchemy.dialects.postgresql.hstore "sqlalchemy.dialects.postgresql.hstore.hstore")
    function accepts one or two arguments as described in the PostgreSQL documentation.
  prefs: []
  type: TYPE_NORMAL
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE268]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`HSTORE`](#sqlalchemy.dialects.postgresql.HSTORE "sqlalchemy.dialects.postgresql.hstore.HSTORE")
    - the PostgreSQL `HSTORE` datatype.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[inherit_cache](#sqlalchemy.dialects.postgresql.hstore.inherit_cache), [type](#sqlalchemy.dialects.postgresql.hstore.type)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.postgresql.hstore`](#sqlalchemy.dialects.postgresql.hstore
    "sqlalchemy.dialects.postgresql.hstore") ([`sqlalchemy.sql.functions.GenericFunction`](../core/functions.html#sqlalchemy.sql.functions.GenericFunction
    "sqlalchemy.sql.functions.GenericFunction"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE269]'
  prefs: []
  type: TYPE_PRE
- en: Indicate if this [`HasCacheKey`](../core/foundation.html#sqlalchemy.sql.traversals.HasCacheKey
    "sqlalchemy.sql.traversals.HasCacheKey") instance should make use of the cache
    key generation scheme used by its immediate superclass.
  prefs: []
  type: TYPE_NORMAL
- en: The attribute defaults to `None`, which indicates that a construct has not yet
    taken into account whether or not its appropriate for it to participate in caching;
    this is functionally equivalent to setting the value to `False`, except that a
    warning is also emitted.
  prefs: []
  type: TYPE_NORMAL
- en: This flag can be set to `True` on a particular class, if the SQL that corresponds
    to the object does not change based on attributes which are local to this class,
    and not its superclass.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Enabling Caching Support for Custom Constructs](../core/compiler.html#compilerext-caching)
    - General guideslines for setting the [`HasCacheKey.inherit_cache`](../core/foundation.html#sqlalchemy.sql.traversals.HasCacheKey.inherit_cache
    "sqlalchemy.sql.traversals.HasCacheKey.inherit_cache") attribute for third-party
    or user defined SQL constructs.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE270]'
  prefs: []
  type: TYPE_PRE
- en: alias of [`HSTORE`](#sqlalchemy.dialects.postgresql.HSTORE "sqlalchemy.dialects.postgresql.hstore.HSTORE")
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE271]'
  prefs: []
  type: TYPE_PRE
- en: The PostgreSQL `to_tsvector` SQL function.
  prefs: []
  type: TYPE_NORMAL
- en: This function applies automatic casting of the REGCONFIG argument to use the
    [`REGCONFIG`](#sqlalchemy.dialects.postgresql.REGCONFIG "sqlalchemy.dialects.postgresql.REGCONFIG")
    datatype automatically, and applies a return type of [`TSVECTOR`](#sqlalchemy.dialects.postgresql.TSVECTOR
    "sqlalchemy.dialects.postgresql.TSVECTOR").
  prefs: []
  type: TYPE_NORMAL
- en: Assuming the PostgreSQL dialect has been imported, either by invoking `from
    sqlalchemy.dialects import postgresql`, or by creating a PostgreSQL engine using
    `create_engine("postgresql...")`, [`to_tsvector`](#sqlalchemy.dialects.postgresql.to_tsvector
    "sqlalchemy.dialects.postgresql.to_tsvector") will be used automatically when
    invoking `sqlalchemy.func.to_tsvector()`, ensuring the correct argument and return
    type handlers are used at compile and execution time.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.0rc1.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.postgresql.to_tsvector`](#sqlalchemy.dialects.postgresql.to_tsvector
    "sqlalchemy.dialects.postgresql.to_tsvector") (`sqlalchemy.dialects.postgresql.ext._regconfig_fn`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE272]'
  prefs: []
  type: TYPE_PRE
- en: The PostgreSQL `to_tsquery` SQL function.
  prefs: []
  type: TYPE_NORMAL
- en: This function applies automatic casting of the REGCONFIG argument to use the
    [`REGCONFIG`](#sqlalchemy.dialects.postgresql.REGCONFIG "sqlalchemy.dialects.postgresql.REGCONFIG")
    datatype automatically, and applies a return type of [`TSQUERY`](#sqlalchemy.dialects.postgresql.TSQUERY
    "sqlalchemy.dialects.postgresql.TSQUERY").
  prefs: []
  type: TYPE_NORMAL
- en: Assuming the PostgreSQL dialect has been imported, either by invoking `from
    sqlalchemy.dialects import postgresql`, or by creating a PostgreSQL engine using
    `create_engine("postgresql...")`, [`to_tsquery`](#sqlalchemy.dialects.postgresql.to_tsquery
    "sqlalchemy.dialects.postgresql.to_tsquery") will be used automatically when invoking
    `sqlalchemy.func.to_tsquery()`, ensuring the correct argument and return type
    handlers are used at compile and execution time.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.0rc1.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.postgresql.to_tsquery`](#sqlalchemy.dialects.postgresql.to_tsquery
    "sqlalchemy.dialects.postgresql.to_tsquery") (`sqlalchemy.dialects.postgresql.ext._regconfig_fn`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE273]'
  prefs: []
  type: TYPE_PRE
- en: The PostgreSQL `plainto_tsquery` SQL function.
  prefs: []
  type: TYPE_NORMAL
- en: This function applies automatic casting of the REGCONFIG argument to use the
    [`REGCONFIG`](#sqlalchemy.dialects.postgresql.REGCONFIG "sqlalchemy.dialects.postgresql.REGCONFIG")
    datatype automatically, and applies a return type of [`TSQUERY`](#sqlalchemy.dialects.postgresql.TSQUERY
    "sqlalchemy.dialects.postgresql.TSQUERY").
  prefs: []
  type: TYPE_NORMAL
- en: Assuming the PostgreSQL dialect has been imported, either by invoking `from
    sqlalchemy.dialects import postgresql`, or by creating a PostgreSQL engine using
    `create_engine("postgresql...")`, [`plainto_tsquery`](#sqlalchemy.dialects.postgresql.plainto_tsquery
    "sqlalchemy.dialects.postgresql.plainto_tsquery") will be used automatically when
    invoking `sqlalchemy.func.plainto_tsquery()`, ensuring the correct argument and
    return type handlers are used at compile and execution time.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.0rc1.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.postgresql.plainto_tsquery`](#sqlalchemy.dialects.postgresql.plainto_tsquery
    "sqlalchemy.dialects.postgresql.plainto_tsquery") (`sqlalchemy.dialects.postgresql.ext._regconfig_fn`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE274]'
  prefs: []
  type: TYPE_PRE
- en: The PostgreSQL `phraseto_tsquery` SQL function.
  prefs: []
  type: TYPE_NORMAL
- en: This function applies automatic casting of the REGCONFIG argument to use the
    [`REGCONFIG`](#sqlalchemy.dialects.postgresql.REGCONFIG "sqlalchemy.dialects.postgresql.REGCONFIG")
    datatype automatically, and applies a return type of [`TSQUERY`](#sqlalchemy.dialects.postgresql.TSQUERY
    "sqlalchemy.dialects.postgresql.TSQUERY").
  prefs: []
  type: TYPE_NORMAL
- en: Assuming the PostgreSQL dialect has been imported, either by invoking `from
    sqlalchemy.dialects import postgresql`, or by creating a PostgreSQL engine using
    `create_engine("postgresql...")`, [`phraseto_tsquery`](#sqlalchemy.dialects.postgresql.phraseto_tsquery
    "sqlalchemy.dialects.postgresql.phraseto_tsquery") will be used automatically
    when invoking `sqlalchemy.func.phraseto_tsquery()`, ensuring the correct argument
    and return type handlers are used at compile and execution time.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.0rc1.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.postgresql.phraseto_tsquery`](#sqlalchemy.dialects.postgresql.phraseto_tsquery
    "sqlalchemy.dialects.postgresql.phraseto_tsquery") (`sqlalchemy.dialects.postgresql.ext._regconfig_fn`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE275]'
  prefs: []
  type: TYPE_PRE
- en: The PostgreSQL `websearch_to_tsquery` SQL function.
  prefs: []
  type: TYPE_NORMAL
- en: This function applies automatic casting of the REGCONFIG argument to use the
    [`REGCONFIG`](#sqlalchemy.dialects.postgresql.REGCONFIG "sqlalchemy.dialects.postgresql.REGCONFIG")
    datatype automatically, and applies a return type of [`TSQUERY`](#sqlalchemy.dialects.postgresql.TSQUERY
    "sqlalchemy.dialects.postgresql.TSQUERY").
  prefs: []
  type: TYPE_NORMAL
- en: Assuming the PostgreSQL dialect has been imported, either by invoking `from
    sqlalchemy.dialects import postgresql`, or by creating a PostgreSQL engine using
    `create_engine("postgresql...")`, [`websearch_to_tsquery`](#sqlalchemy.dialects.postgresql.websearch_to_tsquery
    "sqlalchemy.dialects.postgresql.websearch_to_tsquery") will be used automatically
    when invoking `sqlalchemy.func.websearch_to_tsquery()`, ensuring the correct argument
    and return type handlers are used at compile and execution time.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.0rc1.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.postgresql.websearch_to_tsquery`](#sqlalchemy.dialects.postgresql.websearch_to_tsquery
    "sqlalchemy.dialects.postgresql.websearch_to_tsquery") (`sqlalchemy.dialects.postgresql.ext._regconfig_fn`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE276]'
  prefs: []
  type: TYPE_PRE
- en: The PostgreSQL `ts_headline` SQL function.
  prefs: []
  type: TYPE_NORMAL
- en: This function applies automatic casting of the REGCONFIG argument to use the
    [`REGCONFIG`](#sqlalchemy.dialects.postgresql.REGCONFIG "sqlalchemy.dialects.postgresql.REGCONFIG")
    datatype automatically, and applies a return type of [`TEXT`](../core/type_basics.html#sqlalchemy.types.TEXT
    "sqlalchemy.types.TEXT").
  prefs: []
  type: TYPE_NORMAL
- en: Assuming the PostgreSQL dialect has been imported, either by invoking `from
    sqlalchemy.dialects import postgresql`, or by creating a PostgreSQL engine using
    `create_engine("postgresql...")`, [`ts_headline`](#sqlalchemy.dialects.postgresql.ts_headline
    "sqlalchemy.dialects.postgresql.ts_headline") will be used automatically when
    invoking `sqlalchemy.func.ts_headline()`, ensuring the correct argument and return
    type handlers are used at compile and execution time.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.0rc1.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.postgresql.ts_headline`](#sqlalchemy.dialects.postgresql.ts_headline
    "sqlalchemy.dialects.postgresql.ts_headline") (`sqlalchemy.dialects.postgresql.ext._regconfig_fn`)
  prefs: []
  type: TYPE_NORMAL
- en: PostgreSQL Constraint Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'SQLAlchemy supports PostgreSQL EXCLUDE constraints via the [`ExcludeConstraint`](#sqlalchemy.dialects.postgresql.ExcludeConstraint
    "sqlalchemy.dialects.postgresql.ExcludeConstraint") class:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Object Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| [ExcludeConstraint](#sqlalchemy.dialects.postgresql.ExcludeConstraint) |
    A table-level EXCLUDE constraint. |'
  prefs: []
  type: TYPE_TB
- en: '[PRE277]'
  prefs: []
  type: TYPE_PRE
- en: A table-level EXCLUDE constraint.
  prefs: []
  type: TYPE_NORMAL
- en: Defines an EXCLUDE constraint as described in the [PostgreSQL documentation](https://www.postgresql.org/docs/current/static/sql-createtable.html#SQL-CREATETABLE-EXCLUDE).
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.dialects.postgresql.ExcludeConstraint.__init__)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.postgresql.ExcludeConstraint`](#sqlalchemy.dialects.postgresql.ExcludeConstraint
    "sqlalchemy.dialects.postgresql.ExcludeConstraint") ([`sqlalchemy.schema.ColumnCollectionConstraint`](../core/constraints.html#sqlalchemy.schema.ColumnCollectionConstraint
    "sqlalchemy.schema.ColumnCollectionConstraint"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE278]'
  prefs: []
  type: TYPE_PRE
- en: Create an [`ExcludeConstraint`](#sqlalchemy.dialects.postgresql.ExcludeConstraint
    "sqlalchemy.dialects.postgresql.ExcludeConstraint") object.
  prefs: []
  type: TYPE_NORMAL
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE279]'
  prefs: []
  type: TYPE_PRE
- en: 'The constraint is normally embedded into the [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") construct directly, or added later using [`append_constraint()`](../core/metadata.html#sqlalchemy.schema.Table.append_constraint
    "sqlalchemy.schema.Table.append_constraint"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE280]'
  prefs: []
  type: TYPE_PRE
- en: The exclude constraint defined in this example requires the `btree_gist` extension,
    that can be created using the command `CREATE EXTENSION btree_gist;`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`*elements` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A sequence of two tuples of the form `(column, operator)` where “column” is
    either a [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    object, or a SQL expression element (e.g. `func.int8range(table.from, table.to)`)
    or the name of a column as string, and “operator” is a string containing the operator
    to use (e.g. “&&” or “=”).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In order to specify a column name when a [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") object is not available, while ensuring that any necessary
    quoting rules take effect, an ad-hoc [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") or [`column()`](../core/sqlelement.html#sqlalchemy.sql.expression.column
    "sqlalchemy.sql.expression.column") object should be used. The `column` may also
    be a string SQL expression when passed as [`literal_column()`](../core/sqlelement.html#sqlalchemy.sql.expression.literal_column
    "sqlalchemy.sql.expression.literal_column") or [`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text
    "sqlalchemy.sql.expression.text")
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`name` – Optional, the in-database name of this constraint.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`deferrable` – Optional bool. If set, emit DEFERRABLE or NOT DEFERRABLE when
    issuing DDL for this constraint.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`initially` – Optional string. If set, emit INITIALLY <value>when issuing DDL
    for this constraint.</value>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`using` – Optional string. If set, emit USING <index_method>when issuing DDL
    for this constraint. Defaults to ‘gist’.</index_method>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`where` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optional SQL expression construct or literal SQL string. If set, emit WHERE
    <predicate> when issuing DDL for this constraint.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The [`ExcludeConstraint.where`](#sqlalchemy.dialects.postgresql.ExcludeConstraint.params.where
    "sqlalchemy.dialects.postgresql.ExcludeConstraint") argument to [`ExcludeConstraint`](#sqlalchemy.dialects.postgresql.ExcludeConstraint
    "sqlalchemy.dialects.postgresql.ExcludeConstraint") can be passed as a Python
    string argument, which will be treated as **trusted SQL text** and rendered as
    given. **DO NOT PASS UNTRUSTED INPUT TO THIS PARAMETER**.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`ops` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optional dictionary. Used to define operator classes for the elements; works
    the same way as that of the [postgresql_ops](#postgresql-operator-classes) parameter
    specified to the [`Index`](../core/constraints.html#sqlalchemy.schema.Index "sqlalchemy.schema.Index")
    construct.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: New in version 1.3.21.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Operator Classes](#postgresql-operator-classes) - general description of how
    PostgreSQL operator classes are specified.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE281]'
  prefs: []
  type: TYPE_PRE
- en: PostgreSQL DML Constructs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '| Object Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| [insert](#sqlalchemy.dialects.postgresql.insert)(table) | Construct a PostgreSQL-specific
    variant [`Insert`](#sqlalchemy.dialects.postgresql.Insert "sqlalchemy.dialects.postgresql.Insert")
    construct. |'
  prefs: []
  type: TYPE_TB
- en: '| [Insert](#sqlalchemy.dialects.postgresql.Insert) | PostgreSQL-specific implementation
    of INSERT. |'
  prefs: []
  type: TYPE_TB
- en: '[PRE282]'
  prefs: []
  type: TYPE_PRE
- en: Construct a PostgreSQL-specific variant [`Insert`](#sqlalchemy.dialects.postgresql.Insert
    "sqlalchemy.dialects.postgresql.Insert") construct.
  prefs: []
  type: TYPE_NORMAL
- en: The [`sqlalchemy.dialects.postgresql.insert()`](#sqlalchemy.dialects.postgresql.insert
    "sqlalchemy.dialects.postgresql.insert") function creates a [`sqlalchemy.dialects.postgresql.Insert`](#sqlalchemy.dialects.postgresql.Insert
    "sqlalchemy.dialects.postgresql.Insert"). This class is based on the dialect-agnostic
    [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert "sqlalchemy.sql.expression.Insert")
    construct which may be constructed using the [`insert()`](../core/dml.html#sqlalchemy.sql.expression.insert
    "sqlalchemy.sql.expression.insert") function in SQLAlchemy Core.
  prefs: []
  type: TYPE_NORMAL
- en: The [`Insert`](#sqlalchemy.dialects.postgresql.Insert "sqlalchemy.dialects.postgresql.Insert")
    construct includes additional methods [`Insert.on_conflict_do_update()`](#sqlalchemy.dialects.postgresql.Insert.on_conflict_do_update
    "sqlalchemy.dialects.postgresql.Insert.on_conflict_do_update"), [`Insert.on_conflict_do_nothing()`](#sqlalchemy.dialects.postgresql.Insert.on_conflict_do_nothing
    "sqlalchemy.dialects.postgresql.Insert.on_conflict_do_nothing").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE283]'
  prefs: []
  type: TYPE_PRE
- en: PostgreSQL-specific implementation of INSERT.
  prefs: []
  type: TYPE_NORMAL
- en: Adds methods for PG-specific syntaxes such as ON CONFLICT.
  prefs: []
  type: TYPE_NORMAL
- en: The [`Insert`](#sqlalchemy.dialects.postgresql.Insert "sqlalchemy.dialects.postgresql.Insert")
    object is created using the [`sqlalchemy.dialects.postgresql.insert()`](#sqlalchemy.dialects.postgresql.insert
    "sqlalchemy.dialects.postgresql.insert") function.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[excluded](#sqlalchemy.dialects.postgresql.Insert.excluded), [inherit_cache](#sqlalchemy.dialects.postgresql.Insert.inherit_cache),
    [on_conflict_do_nothing()](#sqlalchemy.dialects.postgresql.Insert.on_conflict_do_nothing),
    [on_conflict_do_update()](#sqlalchemy.dialects.postgresql.Insert.on_conflict_do_update)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.postgresql.Insert`](#sqlalchemy.dialects.postgresql.Insert
    "sqlalchemy.dialects.postgresql.Insert") ([`sqlalchemy.sql.expression.Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE284]'
  prefs: []
  type: TYPE_PRE
- en: Provide the `excluded` namespace for an ON CONFLICT statement
  prefs: []
  type: TYPE_NORMAL
- en: PG’s ON CONFLICT clause allows reference to the row that would be inserted,
    known as `excluded`. This attribute provides all columns in this row to be referenceable.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: The [`Insert.excluded`](#sqlalchemy.dialects.postgresql.Insert.excluded "sqlalchemy.dialects.postgresql.Insert.excluded")
    attribute is an instance of [`ColumnCollection`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnCollection
    "sqlalchemy.sql.expression.ColumnCollection"), which provides an interface the
    same as that of the [`Table.c`](../core/metadata.html#sqlalchemy.schema.Table.c
    "sqlalchemy.schema.Table.c") collection described at [Accessing Tables and Columns](../core/metadata.html#metadata-tables-and-columns).
    With this collection, ordinary names are accessible like attributes (e.g. `stmt.excluded.some_column`),
    but special names and dictionary method names should be accessed using indexed
    access, such as `stmt.excluded["column name"]` or `stmt.excluded["values"]`. See
    the docstring for [`ColumnCollection`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnCollection
    "sqlalchemy.sql.expression.ColumnCollection") for further examples.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[INSERT…ON CONFLICT (Upsert)](#postgresql-insert-on-conflict) - example of
    how to use `Insert.excluded`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE285]'
  prefs: []
  type: TYPE_PRE
- en: Indicate if this [`HasCacheKey`](../core/foundation.html#sqlalchemy.sql.traversals.HasCacheKey
    "sqlalchemy.sql.traversals.HasCacheKey") instance should make use of the cache
    key generation scheme used by its immediate superclass.
  prefs: []
  type: TYPE_NORMAL
- en: The attribute defaults to `None`, which indicates that a construct has not yet
    taken into account whether or not its appropriate for it to participate in caching;
    this is functionally equivalent to setting the value to `False`, except that a
    warning is also emitted.
  prefs: []
  type: TYPE_NORMAL
- en: This flag can be set to `True` on a particular class, if the SQL that corresponds
    to the object does not change based on attributes which are local to this class,
    and not its superclass.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Enabling Caching Support for Custom Constructs](../core/compiler.html#compilerext-caching)
    - General guideslines for setting the [`HasCacheKey.inherit_cache`](../core/foundation.html#sqlalchemy.sql.traversals.HasCacheKey.inherit_cache
    "sqlalchemy.sql.traversals.HasCacheKey.inherit_cache") attribute for third-party
    or user defined SQL constructs.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE286]'
  prefs: []
  type: TYPE_PRE
- en: Specifies a DO NOTHING action for ON CONFLICT clause.
  prefs: []
  type: TYPE_NORMAL
- en: The `constraint` and `index_elements` arguments are optional, but only one of
    these can be specified.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`constraint` – The name of a unique or exclusion constraint on the table, or
    the constraint object itself if it has a .name attribute.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`index_elements` – A sequence consisting of string column names, [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects, or other column expression objects that will
    be used to infer a target index.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`index_where` – Additional WHERE criterion that can be used to infer a conditional
    target index.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[INSERT…ON CONFLICT (Upsert)](#postgresql-insert-on-conflict)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE287]'
  prefs: []
  type: TYPE_PRE
- en: Specifies a DO UPDATE SET action for ON CONFLICT clause.
  prefs: []
  type: TYPE_NORMAL
- en: Either the `constraint` or `index_elements` argument is required, but only one
    of these can be specified.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`constraint` – The name of a unique or exclusion constraint on the table, or
    the constraint object itself if it has a .name attribute.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`index_elements` – A sequence consisting of string column names, [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects, or other column expression objects that will
    be used to infer a target index.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`index_where` – Additional WHERE criterion that can be used to infer a conditional
    target index.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`set_` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A dictionary or other mapping object where the keys are either names of columns
    in the target table, or [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects or other ORM-mapped columns matching that
    of the target table, and expressions or literals as values, specifying the `SET`
    actions to take.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'New in version 1.4: The [`Insert.on_conflict_do_update.set_`](#sqlalchemy.dialects.postgresql.Insert.on_conflict_do_update.params.set_
    "sqlalchemy.dialects.postgresql.Insert.on_conflict_do_update") parameter supports
    [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    objects from the target [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") as keys.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This dictionary does **not** take into account Python-specified default UPDATE
    values or generation functions, e.g. those specified using [`Column.onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.onupdate
    "sqlalchemy.schema.Column"). These values will not be exercised for an ON CONFLICT
    style of UPDATE, unless they are manually specified in the [`Insert.on_conflict_do_update.set_`](#sqlalchemy.dialects.postgresql.Insert.on_conflict_do_update.params.set_
    "sqlalchemy.dialects.postgresql.Insert.on_conflict_do_update") dictionary.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`where` – Optional argument. If present, can be a literal SQL string or an
    acceptable expression for a `WHERE` clause that restricts the rows affected by
    `DO UPDATE SET`. Rows not meeting the `WHERE` condition will not be updated (effectively
    a `DO NOTHING` for those rows).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[INSERT…ON CONFLICT (Upsert)](#postgresql-insert-on-conflict)'
  prefs: []
  type: TYPE_NORMAL
- en: '## psycopg2'
  prefs: []
  type: TYPE_NORMAL
- en: Support for the PostgreSQL database via the psycopg2 driver.
  prefs: []
  type: TYPE_NORMAL
- en: DBAPI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Documentation and download information (if applicable) for psycopg2 is available
    at: [https://pypi.org/project/psycopg2/](https://pypi.org/project/psycopg2/)'
  prefs: []
  type: TYPE_NORMAL
- en: Connecting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Connect String:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE288]'
  prefs: []
  type: TYPE_PRE
- en: '### psycopg2 Connect Arguments'
  prefs: []
  type: TYPE_NORMAL
- en: 'Keyword arguments that are specific to the SQLAlchemy psycopg2 dialect may
    be passed to [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine"), and include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`isolation_level`: This option, available for all PostgreSQL dialects, includes
    the `AUTOCOMMIT` isolation level when using the psycopg2 dialect. This option
    sets the **default** isolation level for the connection that is set immediately
    upon connection to the database before the connection is pooled. This option is
    generally superseded by the more modern [`Connection.execution_options.isolation_level`](../core/connections.html#sqlalchemy.engine.Connection.execution_options.params.isolation_level
    "sqlalchemy.engine.Connection.execution_options") execution option, detailed at
    [Setting Transaction Isolation Levels including DBAPI Autocommit](../core/connections.html#dbapi-autocommit).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Psycopg2 Transaction Isolation Level](#psycopg2-isolation-level)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Setting Transaction Isolation Levels including DBAPI Autocommit](../core/connections.html#dbapi-autocommit)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`client_encoding`: sets the client encoding in a libpq-agnostic way, using
    psycopg2’s `set_client_encoding()` method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Unicode with Psycopg2](#psycopg2-unicode)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`executemany_mode`, `executemany_batch_page_size`, `executemany_values_page_size`:
    Allows use of psycopg2 extensions for optimizing “executemany”-style queries.
    See the referenced section below for details.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Psycopg2 Fast Execution Helpers](#psycopg2-executemany-mode)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: 'The above keyword arguments are **dialect** keyword arguments, meaning that
    they are passed as explicit keyword arguments to [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE289]'
  prefs: []
  type: TYPE_PRE
- en: 'These should not be confused with **DBAPI** connect arguments, which are passed
    as part of the [`create_engine.connect_args`](../core/engines.html#sqlalchemy.create_engine.params.connect_args
    "sqlalchemy.create_engine") dictionary and/or are passed in the URL query string,
    as detailed in the section [Custom DBAPI connect() arguments / on-connect routines](../core/engines.html#custom-dbapi-args).  ###
    SSL Connections'
  prefs: []
  type: TYPE_NORMAL
- en: The psycopg2 module has a connection argument named `sslmode` for controlling
    its behavior regarding secure (SSL) connections. The default is `sslmode=prefer`;
    it will attempt an SSL connection and if that fails it will fall back to an unencrypted
    connection. `sslmode=require` may be used to ensure that only secure connections
    are established. Consult the psycopg2 / libpq documentation for further options
    that are available.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that `sslmode` is specific to psycopg2 so it is included in the connection
    URI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE290]'
  prefs: []
  type: TYPE_PRE
- en: Unix Domain Connections
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'psycopg2 supports connecting via Unix domain connections. When the `host` portion
    of the URL is omitted, SQLAlchemy passes `None` to psycopg2, which specifies Unix-domain
    communication rather than TCP/IP communication:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE291]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, the socket file used is to connect to a Unix-domain socket in `/tmp`,
    or whatever socket directory was specified when PostgreSQL was built. This value
    can be overridden by passing a pathname to psycopg2, using `host` as an additional
    keyword argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE292]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: 'The format accepted here allows for a hostname in the main URL in addition
    to the “host” query string argument. **When using this URL format, the initial
    host is silently ignored**. That is, this URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE293]'
  prefs: []
  type: TYPE_PRE
- en: Above, the hostname `myhost1` is **silently ignored and discarded.** The host
    which is connected is the `myhost2` host.
  prefs: []
  type: TYPE_NORMAL
- en: This is to maintain some degree of compatibility with PostgreSQL’s own URL format
    which has been tested to behave the same way and for which tools like PifPaf hardcode
    two hostnames.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[PQconnectdbParams](https://www.postgresql.org/docs/current/static/libpq-connect.html#LIBPQ-PQCONNECTDBPARAMS)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Specifying multiple fallback hosts'
  prefs: []
  type: TYPE_NORMAL
- en: 'psycopg2 supports multiple connection points in the connection string. When
    the `host` parameter is used multiple times in the query section of the URL, SQLAlchemy
    will create a single string of the host and port information provided to make
    the connections. Tokens may consist of `host::port` or just `host`; in the latter
    case, the default port is selected by libpq. In the example below, three host
    connections are specified, for `HostA::PortA`, `HostB` connecting to the default
    port, and `HostC::PortC`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE294]'
  prefs: []
  type: TYPE_PRE
- en: 'As an alternative, libpq query string format also may be used; this specifies
    `host` and `port` as single query string arguments with comma-separated lists
    - the default port can be chosen by indicating an empty value in the comma separated
    list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE295]'
  prefs: []
  type: TYPE_PRE
- en: With either URL style, connections to each host is attempted based on a configurable
    strategy, which may be configured using the libpq `target_session_attrs` parameter.
    Per libpq this defaults to `any` which indicates a connection to each host is
    then attempted until a connection is successful. Other strategies include `primary`,
    `prefer-standby`, etc. The complete list is documented by PostgreSQL at [libpq
    connection strings](https://www.postgresql.org/docs/current/libpq-connect.html#LIBPQ-CONNSTRING).
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to indicate two hosts using the `primary` strategy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE296]'
  prefs: []
  type: TYPE_PRE
- en: 'Changed in version 1.4.40: Port specification in psycopg2 multiple host format
    is repaired, previously ports were not correctly interpreted in this context.
    libpq comma-separated format is also now supported.'
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 1.3.20: Support for multiple hosts in PostgreSQL connection
    string.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[libpq connection strings](https://www.postgresql.org/docs/current/libpq-connect.html#LIBPQ-CONNSTRING)
    - please refer to this section in the libpq documentation for complete background
    on multiple host support.'
  prefs: []
  type: TYPE_NORMAL
- en: Empty DSN Connections / Environment Variable Connections
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The psycopg2 DBAPI can connect to PostgreSQL by passing an empty DSN to the
    libpq client library, which by default indicates to connect to a localhost PostgreSQL
    database that is open for “trust” connections. This behavior can be further tailored
    using a particular set of environment variables which are prefixed with `PG_...`,
    which are consumed by `libpq` to take the place of any or all elements of the
    connection string.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this form, the URL can be passed without any elements other than the initial
    scheme:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE297]'
  prefs: []
  type: TYPE_PRE
- en: In the above form, a blank “dsn” string is passed to the `psycopg2.connect()`
    function which in turn represents an empty DSN passed to libpq.
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 1.3.2: support for parameter-less connections with psycopg2.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Environment Variables](https://www.postgresql.org/docs/current/libpq-envars.html)
    - PostgreSQL documentation on how to use `PG_...` environment variables for connections.'
  prefs: []
  type: TYPE_NORMAL
- en: '### Per-Statement/Connection Execution Options'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following DBAPI-specific options are respected when used with [`Connection.execution_options()`](../core/connections.html#sqlalchemy.engine.Connection.execution_options
    "sqlalchemy.engine.Connection.execution_options"), [`Executable.execution_options()`](../core/selectable.html#sqlalchemy.sql.expression.Executable.execution_options
    "sqlalchemy.sql.expression.Executable.execution_options"), [`Query.execution_options()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.execution_options
    "sqlalchemy.orm.Query.execution_options"), in addition to those not specific to
    DBAPIs:'
  prefs: []
  type: TYPE_NORMAL
- en: '`isolation_level` - Set the transaction isolation level for the lifespan of
    a [`Connection`](../core/connections.html#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    (can only be set on a connection, not a statement or query). See [Psycopg2 Transaction
    Isolation Level](#psycopg2-isolation-level).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stream_results` - Enable or disable usage of psycopg2 server side cursors
    - this feature makes use of “named” cursors in combination with special result
    handling methods so that result rows are not fully buffered. Defaults to False,
    meaning cursors are buffered by default.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`max_row_buffer` - when using `stream_results`, an integer value that specifies
    the maximum number of rows to buffer at a time. This is interpreted by the `BufferedRowCursorResult`,
    and if omitted the buffer will grow to ultimately store 1000 rows at a time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Changed in version 1.4: The `max_row_buffer` size can now be greater than 1000,
    and the buffer will grow to that size.  ### Psycopg2 Fast Execution Helpers'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Modern versions of psycopg2 include a feature known as [Fast Execution Helpers](https://www.psycopg.org/docs/extras.html#fast-execution-helpers)
    , which have been shown in benchmarking to improve psycopg2’s executemany() performance,
    primarily with INSERT statements, by at least an order of magnitude.
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy implements a native form of the “insert many values” handler that
    will rewrite a single-row INSERT statement to accommodate for many values at once
    within an extended VALUES clause; this handler is equivalent to psycopg2’s `execute_values()`
    handler; an overview of this feature and its configuration are at [“Insert Many
    Values” Behavior for INSERT statements](../core/connections.html#engine-insertmanyvalues).
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 2.0: Replaced psycopg2’s `execute_values()` fast execution helper
    with a native SQLAlchemy mechanism known as [insertmanyvalues](../core/connections.html#engine-insertmanyvalues).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The psycopg2 dialect retains the ability to use the psycopg2-specific `execute_batch()`
    feature, although it is not expected that this is a widely used feature. The use
    of this extension may be enabled using the `executemany_mode` flag which may be
    passed to [`create_engine()`](../core/engines.html#sqlalchemy.create_engine "sqlalchemy.create_engine"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE298]'
  prefs: []
  type: TYPE_PRE
- en: 'Possible options for `executemany_mode` include:'
  prefs: []
  type: TYPE_NORMAL
- en: '`values_only` - this is the default value. SQLAlchemy’s native [insertmanyvalues](../core/connections.html#engine-insertmanyvalues)
    handler is used for qualifying INSERT statements, assuming [`create_engine.use_insertmanyvalues`](../core/engines.html#sqlalchemy.create_engine.params.use_insertmanyvalues
    "sqlalchemy.create_engine") is left at its default value of `True`. This handler
    rewrites simple INSERT statements to include multiple VALUES clauses so that many
    parameter sets can be inserted with one statement.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''values_plus_batch''`- SQLAlchemy’s native [insertmanyvalues](../core/connections.html#engine-insertmanyvalues)
    handler is used for qualifying INSERT statements, assuming [`create_engine.use_insertmanyvalues`](../core/engines.html#sqlalchemy.create_engine.params.use_insertmanyvalues
    "sqlalchemy.create_engine") is left at its default value of `True`. Then, psycopg2’s
    `execute_batch()` handler is used for qualifying UPDATE and DELETE statements
    when executed with multiple parameter sets. When using this mode, the [`CursorResult.rowcount`](../core/connections.html#sqlalchemy.engine.CursorResult.rowcount
    "sqlalchemy.engine.CursorResult.rowcount") attribute will not contain a value
    for executemany-style executions against UPDATE and DELETE statements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Changed in version 2.0: Removed the `''batch''` and `''None''` options from
    psycopg2 `executemany_mode`. Control over batching for INSERT statements is now
    configured via the [`create_engine.use_insertmanyvalues`](../core/engines.html#sqlalchemy.create_engine.params.use_insertmanyvalues
    "sqlalchemy.create_engine") engine-level parameter.'
  prefs: []
  type: TYPE_NORMAL
- en: The term “qualifying statements” refers to the statement being executed being
    a Core [`insert()`](../core/dml.html#sqlalchemy.sql.expression.insert "sqlalchemy.sql.expression.insert"),
    [`update()`](../core/dml.html#sqlalchemy.sql.expression.update "sqlalchemy.sql.expression.update")
    or [`delete()`](../core/dml.html#sqlalchemy.sql.expression.delete "sqlalchemy.sql.expression.delete")
    construct, and **not** a plain textual SQL string or one constructed using [`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text
    "sqlalchemy.sql.expression.text"). It also may **not** be a special “extension”
    statement such as an “ON CONFLICT” “upsert” statement. When using the ORM, all
    insert/update/delete statements used by the ORM flush process are qualifying.
  prefs: []
  type: TYPE_NORMAL
- en: The “page size” for the psycopg2 “batch” strategy can be affected by using the
    `executemany_batch_page_size` parameter, which defaults to 100.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the “insertmanyvalues” feature, the page size can be controlled using the
    [`create_engine.insertmanyvalues_page_size`](../core/engines.html#sqlalchemy.create_engine.params.insertmanyvalues_page_size
    "sqlalchemy.create_engine") parameter, which defaults to 1000\. An example of
    modifying both parameters is below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE299]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[“Insert Many Values” Behavior for INSERT statements](../core/connections.html#engine-insertmanyvalues)
    - background on “insertmanyvalues”'
  prefs: []
  type: TYPE_NORMAL
- en: '[Sending Multiple Parameters](../tutorial/dbapi_transactions.html#tutorial-multiple-parameters)
    - General information on using the [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") object to execute statements in such a way as
    to make use of the DBAPI `.executemany()` method.  ### Unicode with Psycopg2'
  prefs: []
  type: TYPE_NORMAL
- en: The psycopg2 DBAPI driver supports Unicode data transparently.
  prefs: []
  type: TYPE_NORMAL
- en: 'The client character encoding can be controlled for the psycopg2 dialect in
    the following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For PostgreSQL 9.1 and above, the `client_encoding` parameter may be passed
    in the database URL; this parameter is consumed by the underlying `libpq` PostgreSQL
    client library:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE300]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Alternatively, the above `client_encoding` value may be passed using [`create_engine.connect_args`](../core/engines.html#sqlalchemy.create_engine.params.connect_args
    "sqlalchemy.create_engine") for programmatic establishment with `libpq`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE301]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For all PostgreSQL versions, psycopg2 supports a client-side encoding value
    that will be passed to database connections when they are first established. The
    SQLAlchemy psycopg2 dialect supports this using the `client_encoding` parameter
    passed to [`create_engine()`](../core/engines.html#sqlalchemy.create_engine "sqlalchemy.create_engine"):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE302]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The above `client_encoding` parameter admittedly is very similar in appearance
    to usage of the parameter within the [`create_engine.connect_args`](../core/engines.html#sqlalchemy.create_engine.params.connect_args
    "sqlalchemy.create_engine") dictionary; the difference above is that the parameter
    is consumed by psycopg2 and is passed to the database connection using `SET client_encoding
    TO 'utf8'`; in the previously mentioned style, the parameter is instead passed
    through psycopg2 and consumed by the `libpq` library.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'A common way to set up client encoding with PostgreSQL databases is to ensure
    it is configured within the server-side postgresql.conf file; this is the recommended
    way to set encoding for a server that is consistently of one encoding in all databases:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE303]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Transactions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The psycopg2 dialect fully supports SAVEPOINT and two-phase commit operations.
  prefs: []
  type: TYPE_NORMAL
- en: '### Psycopg2 Transaction Isolation Level'
  prefs: []
  type: TYPE_NORMAL
- en: As discussed in [Transaction Isolation Level](#postgresql-isolation-level),
    all PostgreSQL dialects support setting of transaction isolation level both via
    the `isolation_level` parameter passed to [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") , as well as the `isolation_level` argument used by
    [`Connection.execution_options()`](../core/connections.html#sqlalchemy.engine.Connection.execution_options
    "sqlalchemy.engine.Connection.execution_options"). When using the psycopg2 dialect
    , these options make use of psycopg2’s `set_isolation_level()` connection method,
    rather than emitting a PostgreSQL directive; this is because psycopg2’s API-level
    setting is always emitted at the start of each transaction in any case.
  prefs: []
  type: TYPE_NORMAL
- en: 'The psycopg2 dialect supports these constants for isolation level:'
  prefs: []
  type: TYPE_NORMAL
- en: '`READ COMMITTED`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`READ UNCOMMITTED`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`REPEATABLE READ`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SERIALIZABLE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AUTOCOMMIT`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Transaction Isolation Level](#postgresql-isolation-level)'
  prefs: []
  type: TYPE_NORMAL
- en: '[pg8000 Transaction Isolation Level](#pg8000-isolation-level)'
  prefs: []
  type: TYPE_NORMAL
- en: NOTICE logging
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The psycopg2 dialect will log PostgreSQL NOTICE messages via the `sqlalchemy.dialects.postgresql`
    logger. When this logger is set to the `logging.INFO` level, notice messages will
    be logged:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE304]'
  prefs: []
  type: TYPE_PRE
- en: 'Above, it is assumed that logging is configured externally. If this is not
    the case, configuration such as `logging.basicConfig()` must be utilized:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE305]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Logging HOWTO](https://docs.python.org/3/howto/logging.html) - on the python.org
    website'
  prefs: []
  type: TYPE_NORMAL
- en: '### HSTORE type'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `psycopg2` DBAPI includes an extension to natively handle marshalling of
    the HSTORE type. The SQLAlchemy psycopg2 dialect will enable this extension by
    default when psycopg2 version 2.4 or greater is used, and it is detected that
    the target database has the HSTORE type set up for use. In other words, when the
    dialect makes the first connection, a sequence like the following is performed:'
  prefs: []
  type: TYPE_NORMAL
- en: Request the available HSTORE oids using `psycopg2.extras.HstoreAdapter.get_oids()`.
    If this function returns a list of HSTORE identifiers, we then determine that
    the `HSTORE` extension is present. This function is **skipped** if the version
    of psycopg2 installed is less than version 2.4.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the `use_native_hstore` flag is at its default of `True`, and we’ve detected
    that `HSTORE` oids are available, the `psycopg2.extensions.register_hstore()`
    extension is invoked for all connections.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `register_hstore()` extension has the effect of **all Python dictionaries
    being accepted as parameters regardless of the type of target column in SQL**.
    The dictionaries are converted by this extension into a textual HSTORE expression.
    If this behavior is not desired, disable the use of the hstore extension by setting
    `use_native_hstore` to `False` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE306]'
  prefs: []
  type: TYPE_PRE
- en: 'The `HSTORE` type is **still supported** when the `psycopg2.extensions.register_hstore()`
    extension is not used. It merely means that the coercion between Python dictionaries
    and the HSTORE string format, on both the parameter side and the result side,
    will take place within SQLAlchemy’s own marshalling logic, and not that of `psycopg2`
    which may be more performant.  ## psycopg'
  prefs: []
  type: TYPE_NORMAL
- en: Support for the PostgreSQL database via the psycopg (a.k.a. psycopg 3) driver.
  prefs: []
  type: TYPE_NORMAL
- en: DBAPI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Documentation and download information (if applicable) for psycopg (a.k.a.
    psycopg 3) is available at: [https://pypi.org/project/psycopg/](https://pypi.org/project/psycopg/)'
  prefs: []
  type: TYPE_NORMAL
- en: Connecting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Connect String:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE307]'
  prefs: []
  type: TYPE_PRE
- en: '`psycopg` is the package and module name for version 3 of the `psycopg` database
    driver, formerly known as `psycopg2`. This driver is different enough from its
    `psycopg2` predecessor that SQLAlchemy supports it via a totally separate dialect;
    support for `psycopg2` is expected to remain for as long as that package continues
    to function for modern Python versions, and also remains the default dialect for
    the `postgresql://` dialect series.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The SQLAlchemy `psycopg` dialect provides both a sync and an async implementation
    under the same dialect name. The proper version is selected depending on how the
    engine is created:'
  prefs: []
  type: TYPE_NORMAL
- en: 'calling [`create_engine()`](../core/engines.html#sqlalchemy.create_engine "sqlalchemy.create_engine")
    with `postgresql+psycopg://...` will automatically select the sync version, e.g.:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE308]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'calling [`create_async_engine()`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.create_async_engine
    "sqlalchemy.ext.asyncio.create_async_engine") with `postgresql+psycopg://...`
    will automatically select the async version, e.g.:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE309]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The asyncio version of the dialect may also be specified explicitly using the
    `psycopg_async` suffix, as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE310]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[psycopg2](#postgresql-psycopg2) - The SQLAlchemy `psycopg` dialect shares
    most of its behavior with the `psycopg2` dialect. Further documentation is available
    there.'
  prefs: []
  type: TYPE_NORMAL
- en: Using a different Cursor class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One of the differences between `psycopg` and the older `psycopg2` is how bound
    parameters are handled: `psycopg2` would bind them client side, while `psycopg`
    by default will bind them server side.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s possible to configure `psycopg` to do client side binding by specifying
    the `cursor_factory` to be `ClientCursor` when creating the engine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE311]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly when using an async engine the `AsyncClientCursor` can be specified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE312]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Client-side-binding cursors](https://www.psycopg.org/psycopg3/docs/advanced/cursors.html#client-side-binding-cursors)  ##
    pg8000'
  prefs: []
  type: TYPE_NORMAL
- en: Support for the PostgreSQL database via the pg8000 driver.
  prefs: []
  type: TYPE_NORMAL
- en: DBAPI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Documentation and download information (if applicable) for pg8000 is available
    at: [https://pypi.org/project/pg8000/](https://pypi.org/project/pg8000/)'
  prefs: []
  type: TYPE_NORMAL
- en: Connecting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Connect String:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE313]'
  prefs: []
  type: TYPE_PRE
- en: 'Changed in version 1.4: The pg8000 dialect has been updated for version 1.16.6
    and higher, and is again part of SQLAlchemy’s continuous integration with full
    feature support.'
  prefs: []
  type: TYPE_NORMAL
- en: '### Unicode'
  prefs: []
  type: TYPE_NORMAL
- en: 'pg8000 will encode / decode string values between it and the server using the
    PostgreSQL `client_encoding` parameter; by default this is the value in the `postgresql.conf`
    file, which often defaults to `SQL_ASCII`. Typically, this can be changed to `utf-8`,
    as a more useful default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE314]'
  prefs: []
  type: TYPE_PRE
- en: 'The `client_encoding` can be overridden for a session by executing the SQL:'
  prefs: []
  type: TYPE_NORMAL
- en: SET CLIENT_ENCODING TO ‘utf8’;
  prefs: []
  type: TYPE_NORMAL
- en: 'SQLAlchemy will execute this SQL on all new connections based on the value
    passed to [`create_engine()`](../core/engines.html#sqlalchemy.create_engine "sqlalchemy.create_engine")
    using the `client_encoding` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE315]  ### SSL Connections'
  prefs: []
  type: TYPE_NORMAL
- en: 'pg8000 accepts a Python `SSLContext` object which may be specified using the
    [`create_engine.connect_args`](../core/engines.html#sqlalchemy.create_engine.params.connect_args
    "sqlalchemy.create_engine") dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE316]'
  prefs: []
  type: TYPE_PRE
- en: 'If the server uses an automatically-generated certificate that is self-signed
    or does not match the host name (as seen from the client), it may also be necessary
    to disable hostname checking:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE317]  ### pg8000 Transaction Isolation Level'
  prefs: []
  type: TYPE_NORMAL
- en: 'The pg8000 dialect offers the same isolation level settings as that of the
    [psycopg2](#psycopg2-isolation-level) dialect:'
  prefs: []
  type: TYPE_NORMAL
- en: '`READ COMMITTED`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`READ UNCOMMITTED`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`REPEATABLE READ`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SERIALIZABLE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AUTOCOMMIT`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Transaction Isolation Level](#postgresql-isolation-level)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Psycopg2 Transaction Isolation Level](#psycopg2-isolation-level)  ## asyncpg'
  prefs: []
  type: TYPE_NORMAL
- en: Support for the PostgreSQL database via the asyncpg driver.
  prefs: []
  type: TYPE_NORMAL
- en: DBAPI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Documentation and download information (if applicable) for asyncpg is available
    at: [https://magicstack.github.io/asyncpg/](https://magicstack.github.io/asyncpg/)'
  prefs: []
  type: TYPE_NORMAL
- en: Connecting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Connect String:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE318]'
  prefs: []
  type: TYPE_PRE
- en: The asyncpg dialect is SQLAlchemy’s first Python asyncio dialect.
  prefs: []
  type: TYPE_NORMAL
- en: Using a special asyncio mediation layer, the asyncpg dialect is usable as the
    backend for the [SQLAlchemy asyncio](../orm/extensions/asyncio.html) extension
    package.
  prefs: []
  type: TYPE_NORMAL
- en: 'This dialect should normally be used only with the [`create_async_engine()`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.create_async_engine
    "sqlalchemy.ext.asyncio.create_async_engine") engine creation function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE319]'
  prefs: []
  type: TYPE_PRE
- en: New in version 1.4.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: By default asyncpg does not decode the `json` and `jsonb` types and returns
    them as strings. SQLAlchemy sets default type decoder for `json` and `jsonb` types
    using the python builtin `json.loads` function. The json implementation used can
    be changed by setting the attribute `json_deserializer` when creating the engine
    with `create_engine()` or `create_async_engine()`.
  prefs: []
  type: TYPE_NORMAL
- en: '### Multihost Connections'
  prefs: []
  type: TYPE_NORMAL
- en: 'The asyncpg dialect features support for multiple fallback hosts in the same
    way as that of the psycopg2 and psycopg dialects. The syntax is the same, using
    `host=<host>:<port>` combinations as additional query string arguments; however,
    there is no default port, so all hosts must have a complete port number present,
    otherwise an exception is raised:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE320]'
  prefs: []
  type: TYPE_PRE
- en: For complete background on this syntax, see [Specifying multiple fallback hosts](#psycopg2-multi-host).
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.18.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Specifying multiple fallback hosts](#psycopg2-multi-host)  ### Prepared Statement
    Cache'
  prefs: []
  type: TYPE_NORMAL
- en: 'The asyncpg SQLAlchemy dialect makes use of `asyncpg.connection.prepare()`
    for all statements. The prepared statement objects are cached after construction
    which appears to grant a 10% or more performance improvement for statement invocation.
    The cache is on a per-DBAPI connection basis, which means that the primary storage
    for prepared statements is within DBAPI connections pooled within the connection
    pool. The size of this cache defaults to 100 statements per DBAPI connection and
    may be adjusted using the `prepared_statement_cache_size` DBAPI argument (note
    that while this argument is implemented by SQLAlchemy, it is part of the DBAPI
    emulation portion of the asyncpg dialect, therefore is handled as a DBAPI argument,
    not a dialect argument):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE321]'
  prefs: []
  type: TYPE_PRE
- en: 'To disable the prepared statement cache, use a value of zero:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE322]'
  prefs: []
  type: TYPE_PRE
- en: 'New in version 1.4.0b2: Added `prepared_statement_cache_size` for asyncpg.'
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: The `asyncpg` database driver necessarily uses caches for PostgreSQL type OIDs,
    which become stale when custom PostgreSQL datatypes such as `ENUM` objects are
    changed via DDL operations. Additionally, prepared statements themselves which
    are optionally cached by SQLAlchemy’s driver as described above may also become
    “stale” when DDL has been emitted to the PostgreSQL database which modifies the
    tables or other objects involved in a particular prepared statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'The SQLAlchemy asyncpg dialect will invalidate these caches within its local
    process when statements that represent DDL are emitted on a local connection,
    but this is only controllable within a single Python process / database engine.
    If DDL changes are made from other database engines and/or processes, a running
    application may encounter asyncpg exceptions `InvalidCachedStatementError` and/or
    `InternalServerError("cache lookup failed for type <oid>")` if it refers to pooled
    database connections which operated upon the previous structures. The SQLAlchemy
    asyncpg dialect will recover from these error cases when the driver raises these
    exceptions by clearing its internal caches as well as those of the asyncpg driver
    in response to them, but cannot prevent them from being raised in the first place
    if the cached prepared statement or asyncpg type caches have gone stale, nor can
    it retry the statement as the PostgreSQL transaction is invalidated when these
    errors occur.  ### Prepared Statement Name with PGBouncer'
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, asyncpg enumerates prepared statements in numeric order, which
    can lead to errors if a name has already been taken for another prepared statement.
    This issue can arise if your application uses database proxies such as PgBouncer
    to handle connections. One possible workaround is to use dynamic prepared statement
    names, which asyncpg now supports through an optional `name` value for the statement
    name. This allows you to generate your own unique names that won’t conflict with
    existing ones. To achieve this, you can provide a function that will be called
    every time a prepared statement is prepared:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE323]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/MagicStack/asyncpg/issues/837](https://github.com/MagicStack/asyncpg/issues/837)'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/sqlalchemy/sqlalchemy/issues/6467](https://github.com/sqlalchemy/sqlalchemy/issues/6467)'
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: When using PGBouncer, to prevent a buildup of useless prepared statements in
    your application, it’s important to use the [`NullPool`](../core/pooling.html#sqlalchemy.pool.NullPool
    "sqlalchemy.pool.NullPool") pool class, and to configure PgBouncer to use [DISCARD](https://www.postgresql.org/docs/current/sql-discard.html)
    when returning connections. The DISCARD command is used to release resources held
    by the db connection, including prepared statements. Without proper setup, prepared
    statements can accumulate quickly and cause performance issues.
  prefs: []
  type: TYPE_NORMAL
- en: Disabling the PostgreSQL JIT to improve ENUM datatype handling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Asyncpg has an [issue](https://github.com/MagicStack/asyncpg/issues/727) when
    using PostgreSQL ENUM datatypes, where upon the creation of new database connections,
    an expensive query may be emitted in order to retrieve metadata regarding custom
    types which has been shown to negatively affect performance. To mitigate this
    issue, the PostgreSQL “jit” setting may be disabled from the client using this
    setting passed to [`create_async_engine()`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.create_async_engine
    "sqlalchemy.ext.asyncio.create_async_engine"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE324]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/MagicStack/asyncpg/issues/727](https://github.com/MagicStack/asyncpg/issues/727)  ##
    psycopg2cffi'
  prefs: []
  type: TYPE_NORMAL
- en: Support for the PostgreSQL database via the psycopg2cffi driver.
  prefs: []
  type: TYPE_NORMAL
- en: DBAPI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Documentation and download information (if applicable) for psycopg2cffi is
    available at: [https://pypi.org/project/psycopg2cffi/](https://pypi.org/project/psycopg2cffi/)'
  prefs: []
  type: TYPE_NORMAL
- en: Connecting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Connect String:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE325]'
  prefs: []
  type: TYPE_PRE
- en: '`psycopg2cffi` is an adaptation of `psycopg2`, using CFFI for the C layer.
    This makes it suitable for use in e.g. PyPy. Documentation is as per `psycopg2`.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sqlalchemy.dialects.postgresql.psycopg2`](#module-sqlalchemy.dialects.postgresql.psycopg2
    "sqlalchemy.dialects.postgresql.psycopg2")'
  prefs: []
  type: TYPE_NORMAL
- en: Support for the PostgreSQL database.
  prefs: []
  type: TYPE_NORMAL
- en: The following table summarizes current support levels for database release versions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Supported PostgreSQL versions**'
  prefs: []
  type: TYPE_NORMAL
- en: '| Support type | Versions |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| [Fully tested in CI](index.html#term-Fully-tested-in-CI) | 12, 13, 14, 15
    |'
  prefs: []
  type: TYPE_TB
- en: '| [Normal support](index.html#term-Normal-support) | 9.6+ |'
  prefs: []
  type: TYPE_TB
- en: '| [Best effort](index.html#term-Best-effort) | 9+ |'
  prefs: []
  type: TYPE_TB
- en: DBAPI Support
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following dialect/DBAPI options are available. Please refer to individual
    DBAPI sections for connect information.
  prefs: []
  type: TYPE_NORMAL
- en: '[psycopg2](#module-sqlalchemy.dialects.postgresql.psycopg2)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[psycopg (a.k.a. psycopg 3)](#module-sqlalchemy.dialects.postgresql.psycopg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[pg8000](#module-sqlalchemy.dialects.postgresql.pg8000)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[asyncpg](#module-sqlalchemy.dialects.postgresql.asyncpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[psycopg2cffi](#module-sqlalchemy.dialects.postgresql.psycopg2cffi)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '## Sequences/SERIAL/IDENTITY'
  prefs: []
  type: TYPE_NORMAL
- en: PostgreSQL supports sequences, and SQLAlchemy uses these as the default means
    of creating new primary key values for integer-based primary key columns. When
    creating tables, SQLAlchemy will issue the `SERIAL` datatype for integer-based
    primary key columns, which generates a sequence and server side default corresponding
    to the column.
  prefs: []
  type: TYPE_NORMAL
- en: 'To specify a specific named sequence to be used for primary key generation,
    use the [`Sequence()`](../core/defaults.html#sqlalchemy.schema.Sequence "sqlalchemy.schema.Sequence")
    construct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE326]'
  prefs: []
  type: TYPE_PRE
- en: When SQLAlchemy issues a single INSERT statement, to fulfill the contract of
    having the “last insert identifier” available, a RETURNING clause is added to
    the INSERT statement which specifies the primary key columns should be returned
    after the statement completes. The RETURNING functionality only takes place if
    PostgreSQL 8.2 or later is in use. As a fallback approach, the sequence, whether
    specified explicitly or implicitly via `SERIAL`, is executed independently beforehand,
    the returned value to be used in the subsequent insert. Note that when an [`insert()`](../core/dml.html#sqlalchemy.sql.expression.insert
    "sqlalchemy.sql.expression.insert") construct is executed using “executemany”
    semantics, the “last inserted identifier” functionality does not apply; no RETURNING
    clause is emitted nor is the sequence pre-executed in this case.
  prefs: []
  type: TYPE_NORMAL
- en: PostgreSQL 10 and above IDENTITY columns
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'PostgreSQL 10 and above have a new IDENTITY feature that supersedes the use
    of SERIAL. The [`Identity`](../core/defaults.html#sqlalchemy.schema.Identity "sqlalchemy.schema.Identity")
    construct in a [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    can be used to control its behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE327]'
  prefs: []
  type: TYPE_PRE
- en: 'The CREATE TABLE for the above [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") object would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE328]'
  prefs: []
  type: TYPE_PRE
- en: 'Changed in version 1.4: Added [`Identity`](../core/defaults.html#sqlalchemy.schema.Identity
    "sqlalchemy.schema.Identity") construct in a [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") to specify the option of an autoincrementing column.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Previous versions of SQLAlchemy did not have built-in support for rendering
    of IDENTITY, and could use the following compilation hook to replace occurrences
    of SERIAL with IDENTITY:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE329]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the above, a table such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE330]'
  prefs: []
  type: TYPE_PRE
- en: 'Will generate on the backing database as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE331]'
  prefs: []
  type: TYPE_PRE
- en: PostgreSQL 10 and above IDENTITY columns
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'PostgreSQL 10 and above have a new IDENTITY feature that supersedes the use
    of SERIAL. The [`Identity`](../core/defaults.html#sqlalchemy.schema.Identity "sqlalchemy.schema.Identity")
    construct in a [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    can be used to control its behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE332]'
  prefs: []
  type: TYPE_PRE
- en: 'The CREATE TABLE for the above [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") object would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE333]'
  prefs: []
  type: TYPE_PRE
- en: 'Changed in version 1.4: Added [`Identity`](../core/defaults.html#sqlalchemy.schema.Identity
    "sqlalchemy.schema.Identity") construct in a [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") to specify the option of an autoincrementing column.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Previous versions of SQLAlchemy did not have built-in support for rendering
    of IDENTITY, and could use the following compilation hook to replace occurrences
    of SERIAL with IDENTITY:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE334]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the above, a table such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE335]'
  prefs: []
  type: TYPE_PRE
- en: 'Will generate on the backing database as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE336]'
  prefs: []
  type: TYPE_PRE
- en: '## Server Side Cursors'
  prefs: []
  type: TYPE_NORMAL
- en: Server-side cursor support is available for the psycopg2, asyncpg dialects and
    may also be available in others.
  prefs: []
  type: TYPE_NORMAL
- en: 'Server side cursors are enabled on a per-statement basis by using the [`Connection.execution_options.stream_results`](../core/connections.html#sqlalchemy.engine.Connection.execution_options.params.stream_results
    "sqlalchemy.engine.Connection.execution_options") connection execution option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE337]'
  prefs: []
  type: TYPE_PRE
- en: Note that some kinds of SQL statements may not be supported with server side
    cursors; generally, only SQL statements that return rows should be used with this
    option.
  prefs: []
  type: TYPE_NORMAL
- en: 'Deprecated since version 1.4: The dialect-level server_side_cursors flag is
    deprecated and will be removed in a future release. Please use the [`Connection.stream_results`](../core/connections.html#sqlalchemy.engine.Connection.params.stream_results
    "sqlalchemy.engine.Connection") execution option for unbuffered cursor support.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Using Server Side Cursors (a.k.a. stream results)](../core/connections.html#engine-stream-results)'
  prefs: []
  type: TYPE_NORMAL
- en: '## Transaction Isolation Level'
  prefs: []
  type: TYPE_NORMAL
- en: Most SQLAlchemy dialects support setting of transaction isolation level using
    the [`create_engine.isolation_level`](../core/engines.html#sqlalchemy.create_engine.params.isolation_level
    "sqlalchemy.create_engine") parameter at the [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") level, and at the [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") level via the [`Connection.execution_options.isolation_level`](../core/connections.html#sqlalchemy.engine.Connection.execution_options.params.isolation_level
    "sqlalchemy.engine.Connection.execution_options") parameter.
  prefs: []
  type: TYPE_NORMAL
- en: For PostgreSQL dialects, this feature works either by making use of the DBAPI-specific
    features, such as psycopg2’s isolation level flags which will embed the isolation
    level setting inline with the `"BEGIN"` statement, or for DBAPIs with no direct
    support by emitting `SET SESSION CHARACTERISTICS AS TRANSACTION ISOLATION LEVEL
    <level>` ahead of the `"BEGIN"` statement emitted by the DBAPI. For the special
    AUTOCOMMIT isolation level, DBAPI-specific techniques are used which is typically
    an `.autocommit` flag on the DBAPI connection object.
  prefs: []
  type: TYPE_NORMAL
- en: 'To set isolation level using [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE338]'
  prefs: []
  type: TYPE_PRE
- en: 'To set using per-connection execution options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE339]'
  prefs: []
  type: TYPE_PRE
- en: There are also more options for isolation level configurations, such as “sub-engine”
    objects linked to a main [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") which each apply different isolation level settings.
    See the discussion at [Setting Transaction Isolation Levels including DBAPI Autocommit](../core/connections.html#dbapi-autocommit)
    for background.
  prefs: []
  type: TYPE_NORMAL
- en: 'Valid values for `isolation_level` on most PostgreSQL dialects include:'
  prefs: []
  type: TYPE_NORMAL
- en: '`READ COMMITTED`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`READ UNCOMMITTED`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`REPEATABLE READ`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SERIALIZABLE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AUTOCOMMIT`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Setting Transaction Isolation Levels including DBAPI Autocommit](../core/connections.html#dbapi-autocommit)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Setting READ ONLY / DEFERRABLE](#postgresql-readonly-deferrable)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Psycopg2 Transaction Isolation Level](#psycopg2-isolation-level)'
  prefs: []
  type: TYPE_NORMAL
- en: '[pg8000 Transaction Isolation Level](#pg8000-isolation-level)'
  prefs: []
  type: TYPE_NORMAL
- en: '## Setting READ ONLY / DEFERRABLE'
  prefs: []
  type: TYPE_NORMAL
- en: 'Most PostgreSQL dialects support setting the “READ ONLY” and “DEFERRABLE” characteristics
    of the transaction, which is in addition to the isolation level setting. These
    two attributes can be established either in conjunction with or independently
    of the isolation level by passing the `postgresql_readonly` and `postgresql_deferrable`
    flags with [`Connection.execution_options()`](../core/connections.html#sqlalchemy.engine.Connection.execution_options
    "sqlalchemy.engine.Connection.execution_options"). The example below illustrates
    passing the `"SERIALIZABLE"` isolation level at the same time as setting “READ
    ONLY” and “DEFERRABLE”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE340]'
  prefs: []
  type: TYPE_PRE
- en: Note that some DBAPIs such as asyncpg only support “readonly” with SERIALIZABLE
    isolation.
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 1.4: added support for the `postgresql_readonly` and `postgresql_deferrable`
    execution options.'
  prefs: []
  type: TYPE_NORMAL
- en: '## Temporary Table / Resource Reset for Connection Pooling'
  prefs: []
  type: TYPE_NORMAL
- en: The [`QueuePool`](../core/pooling.html#sqlalchemy.pool.QueuePool "sqlalchemy.pool.QueuePool")
    connection pool implementation used by the SQLAlchemy [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") object includes [reset on return](../core/pooling.html#pool-reset-on-return)
    behavior that will invoke the DBAPI `.rollback()` method when connections are
    returned to the pool. While this rollback will clear out the immediate state used
    by the previous transaction, it does not cover a wider range of session-level
    state, including temporary tables as well as other server state such as prepared
    statement handles and statement caches. The PostgreSQL database includes a variety
    of commands which may be used to reset this state, including `DISCARD`, `RESET`,
    `DEALLOCATE`, and `UNLISTEN`.
  prefs: []
  type: TYPE_NORMAL
- en: To install one or more of these commands as the means of performing reset-on-return,
    the [`PoolEvents.reset()`](../core/events.html#sqlalchemy.events.PoolEvents.reset
    "sqlalchemy.events.PoolEvents.reset") event hook may be used, as demonstrated
    in the example below. The implementation will end transactions in progress as
    well as discard temporary tables using the `CLOSE`, `RESET` and `DISCARD` commands;
    see the PostgreSQL documentation for background on what each of these statements
    do.
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`create_engine.pool_reset_on_return`](../core/engines.html#sqlalchemy.create_engine.params.pool_reset_on_return
    "sqlalchemy.create_engine") parameter is set to `None` so that the custom scheme
    can replace the default behavior completely. The custom hook implementation calls
    `.rollback()` in any case, as it’s usually important that the DBAPI’s own tracking
    of commit/rollback will remain consistent with the state of the transaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE341]'
  prefs: []
  type: TYPE_PRE
- en: 'Changed in version 2.0.0b3: Added additional state arguments to the [`PoolEvents.reset()`](../core/events.html#sqlalchemy.events.PoolEvents.reset
    "sqlalchemy.events.PoolEvents.reset") event and additionally ensured the event
    is invoked for all “reset” occurrences, so that it’s appropriate as a place for
    custom “reset” handlers. Previous schemes which use the [`PoolEvents.checkin()`](../core/events.html#sqlalchemy.events.PoolEvents.checkin
    "sqlalchemy.events.PoolEvents.checkin") handler remain usable as well.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Reset On Return](../core/pooling.html#pool-reset-on-return) - in the [Connection
    Pooling](../core/pooling.html) documentation'
  prefs: []
  type: TYPE_NORMAL
- en: '## Setting Alternate Search Paths on Connect'
  prefs: []
  type: TYPE_NORMAL
- en: 'The PostgreSQL `search_path` variable refers to the list of schema names that
    will be implicitly referenced when a particular table or other object is referenced
    in a SQL statement. As detailed in the next section [Remote-Schema Table Introspection
    and PostgreSQL search_path](#postgresql-schema-reflection), SQLAlchemy is generally
    organized around the concept of keeping this variable at its default value of
    `public`, however, in order to have it set to any arbitrary name or names when
    connections are used automatically, the “SET SESSION search_path” command may
    be invoked for all connections in a pool using the following event handler, as
    discussed at [Setting a Default Schema for New Connections](../core/metadata.html#schema-set-default-connections):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE342]'
  prefs: []
  type: TYPE_PRE
- en: The reason the recipe is complicated by use of the `.autocommit` DBAPI attribute
    is so that when the `SET SESSION search_path` directive is invoked, it is invoked
    outside of the scope of any transaction and therefore will not be reverted when
    the DBAPI connection has a rollback.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Setting a Default Schema for New Connections](../core/metadata.html#schema-set-default-connections)
    - in the [Describing Databases with MetaData](../core/metadata.html) documentation'
  prefs: []
  type: TYPE_NORMAL
- en: '## Remote-Schema Table Introspection and PostgreSQL search_path'
  prefs: []
  type: TYPE_NORMAL
- en: Section Best Practices Summarized
  prefs: []
  type: TYPE_NORMAL
- en: keep the `search_path` variable set to its default of `public`, without any
    other schema names. Ensure the username used to connect **does not** match remote
    schemas, or ensure the `"$user"` token is **removed** from `search_path`. For
    other schema names, name these explicitly within [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") definitions. Alternatively, the `postgresql_ignore_search_path`
    option will cause all reflected [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects to have a [`Table.schema`](../core/metadata.html#sqlalchemy.schema.Table.schema
    "sqlalchemy.schema.Table.schema") attribute set up.
  prefs: []
  type: TYPE_NORMAL
- en: The PostgreSQL dialect can reflect tables from any schema, as outlined in [Reflecting
    Tables from Other Schemas](../core/reflection.html#metadata-reflection-schemas).
  prefs: []
  type: TYPE_NORMAL
- en: 'In all cases, the first thing SQLAlchemy does when reflecting tables is to
    **determine the default schema for the current database connection**. It does
    this using the PostgreSQL `current_schema()` function, illustated below using
    a PostgreSQL client session (i.e. using the `psql` tool):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE343]'
  prefs: []
  type: TYPE_PRE
- en: Above we see that on a plain install of PostgreSQL, the default schema name
    is the name `public`.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if your database username **matches the name of a schema**, PostgreSQL’s
    default is to then **use that name as the default schema**. Below, we log in using
    the username `scott`. When we create a schema named `scott`, **it implicitly changes
    the default schema**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE344]'
  prefs: []
  type: TYPE_PRE
- en: 'The behavior of `current_schema()` is derived from the [PostgreSQL search path](https://www.postgresql.org/docs/current/static/ddl-schemas.html#DDL-SCHEMAS-PATH)
    variable `search_path`, which in modern PostgreSQL versions defaults to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE345]'
  prefs: []
  type: TYPE_PRE
- en: Where above, the `"$user"` variable will inject the current username as the
    default schema, if one exists. Otherwise, `public` is used.
  prefs: []
  type: TYPE_NORMAL
- en: When a [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    object is reflected, if it is present in the schema indicated by the `current_schema()`
    function, **the schema name assigned to the “.schema” attribute of the Table is
    the Python “None” value**. Otherwise, the “.schema” attribute will be assigned
    the string name of that schema.
  prefs: []
  type: TYPE_NORMAL
- en: With regards to tables which these [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects refer to via foreign key constraint, a decision
    must be made as to how the `.schema` is represented in those remote tables, in
    the case where that remote schema name is also a member of the current `search_path`.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, the PostgreSQL dialect mimics the behavior encouraged by PostgreSQL’s
    own `pg_get_constraintdef()` builtin procedure. This function returns a sample
    definition for a particular foreign key constraint, omitting the referenced schema
    name from that definition when the name is also in the PostgreSQL schema search
    path. The interaction below illustrates this behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE346]'
  prefs: []
  type: TYPE_PRE
- en: Above, we created a table `referred` as a member of the remote schema `test_schema`,
    however when we added `test_schema` to the PG `search_path` and then asked `pg_get_constraintdef()`
    for the `FOREIGN KEY` syntax, `test_schema` was not included in the output of
    the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, if we set the search path back to the typical default of
    `public`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE347]'
  prefs: []
  type: TYPE_PRE
- en: 'The same query against `pg_get_constraintdef()` now returns the fully schema-qualified
    name for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE348]'
  prefs: []
  type: TYPE_PRE
- en: 'SQLAlchemy will by default use the return value of `pg_get_constraintdef()`
    in order to determine the remote schema name. That is, if our `search_path` were
    set to include `test_schema`, and we invoked a table reflection process as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE349]'
  prefs: []
  type: TYPE_PRE
- en: 'The above process would deliver to the [`MetaData.tables`](../core/metadata.html#sqlalchemy.schema.MetaData.tables
    "sqlalchemy.schema.MetaData.tables") collection `referred` table named **without**
    the schema:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE350]'
  prefs: []
  type: TYPE_PRE
- en: 'To alter the behavior of reflection such that the referred schema is maintained
    regardless of the `search_path` setting, use the `postgresql_ignore_search_path`
    option, which can be specified as a dialect-specific argument to both [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") as well as [`MetaData.reflect()`](../core/metadata.html#sqlalchemy.schema.MetaData.reflect
    "sqlalchemy.schema.MetaData.reflect"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE351]'
  prefs: []
  type: TYPE_PRE
- en: 'We will now have `test_schema.referred` stored as schema-qualified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE352]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Interaction of Schema-qualified Reflection with the Default Schema](../core/reflection.html#reflection-schema-qualified-interaction)
    - discussion of the issue from a backend-agnostic perspective'
  prefs: []
  type: TYPE_NORMAL
- en: '[The Schema Search Path](https://www.postgresql.org/docs/current/static/ddl-schemas.html#DDL-SCHEMAS-PATH)
    - on the PostgreSQL website.'
  prefs: []
  type: TYPE_NORMAL
- en: INSERT/UPDATE…RETURNING
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The dialect supports PG 8.2’s `INSERT..RETURNING`, `UPDATE..RETURNING` and
    `DELETE..RETURNING` syntaxes. `INSERT..RETURNING` is used by default for single-row
    INSERT statements in order to fetch newly generated primary key identifiers. To
    specify an explicit `RETURNING` clause, use the `_UpdateBase.returning()` method
    on a per-statement basis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE353]'
  prefs: []
  type: TYPE_PRE
- en: '## INSERT…ON CONFLICT (Upsert)'
  prefs: []
  type: TYPE_NORMAL
- en: Starting with version 9.5, PostgreSQL allows “upserts” (update or insert) of
    rows into a table via the `ON CONFLICT` clause of the `INSERT` statement. A candidate
    row will only be inserted if that row does not violate any unique constraints.
    In the case of a unique constraint violation, a secondary action can occur which
    can be either “DO UPDATE”, indicating that the data in the target row should be
    updated, or “DO NOTHING”, which indicates to silently skip this row.
  prefs: []
  type: TYPE_NORMAL
- en: Conflicts are determined using existing unique constraints and indexes. These
    constraints may be identified either using their name as stated in DDL, or they
    may be inferred by stating the columns and conditions that comprise the indexes.
  prefs: []
  type: TYPE_NORMAL
- en: 'SQLAlchemy provides `ON CONFLICT` support via the PostgreSQL-specific [`insert()`](#sqlalchemy.dialects.postgresql.insert
    "sqlalchemy.dialects.postgresql.insert") function, which provides the generative
    methods [`Insert.on_conflict_do_update()`](#sqlalchemy.dialects.postgresql.Insert.on_conflict_do_update
    "sqlalchemy.dialects.postgresql.Insert.on_conflict_do_update") and [`Insert.on_conflict_do_nothing()`](#sqlalchemy.dialects.postgresql.Insert.on_conflict_do_nothing
    "sqlalchemy.dialects.postgresql.Insert.on_conflict_do_nothing"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE354]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[INSERT .. ON CONFLICT](https://www.postgresql.org/docs/current/static/sql-insert.html#SQL-ON-CONFLICT)
    - in the PostgreSQL documentation.'
  prefs: []
  type: TYPE_NORMAL
- en: Specifying the Target
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Both methods supply the “target” of the conflict using either the named constraint
    or by column inference:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`Insert.on_conflict_do_update.index_elements`](#sqlalchemy.dialects.postgresql.Insert.on_conflict_do_update.params.index_elements
    "sqlalchemy.dialects.postgresql.Insert.on_conflict_do_update") argument specifies
    a sequence containing string column names, [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects, and/or SQL expression elements, which would
    identify a unique index:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE355]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When using [`Insert.on_conflict_do_update.index_elements`](#sqlalchemy.dialects.postgresql.Insert.on_conflict_do_update.params.index_elements
    "sqlalchemy.dialects.postgresql.Insert.on_conflict_do_update") to infer an index,
    a partial index can be inferred by also specifying the use the [`Insert.on_conflict_do_update.index_where`](#sqlalchemy.dialects.postgresql.Insert.on_conflict_do_update.params.index_where
    "sqlalchemy.dialects.postgresql.Insert.on_conflict_do_update") parameter:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE356]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The [`Insert.on_conflict_do_update.constraint`](#sqlalchemy.dialects.postgresql.Insert.on_conflict_do_update.params.constraint
    "sqlalchemy.dialects.postgresql.Insert.on_conflict_do_update") argument is used
    to specify an index directly rather than inferring it. This can be the name of
    a UNIQUE constraint, a PRIMARY KEY constraint, or an INDEX:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE357]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The [`Insert.on_conflict_do_update.constraint`](#sqlalchemy.dialects.postgresql.Insert.on_conflict_do_update.params.constraint
    "sqlalchemy.dialects.postgresql.Insert.on_conflict_do_update") argument may also
    refer to a SQLAlchemy construct representing a constraint, e.g. [`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint"), [`PrimaryKeyConstraint`](../core/constraints.html#sqlalchemy.schema.PrimaryKeyConstraint
    "sqlalchemy.schema.PrimaryKeyConstraint"), [`Index`](../core/constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index"), or [`ExcludeConstraint`](#sqlalchemy.dialects.postgresql.ExcludeConstraint
    "sqlalchemy.dialects.postgresql.ExcludeConstraint"). In this use, if the constraint
    has a name, it is used directly. Otherwise, if the constraint is unnamed, then
    inference will be used, where the expressions and optional WHERE clause of the
    constraint will be spelled out in the construct. This use is especially convenient
    to refer to the named or unnamed primary key of a [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") using the [`Table.primary_key`](../core/metadata.html#sqlalchemy.schema.Table.primary_key
    "sqlalchemy.schema.Table.primary_key") attribute:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE358]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The SET Clause
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`ON CONFLICT...DO UPDATE` is used to perform an update of the already existing
    row, using any combination of new values as well as values from the proposed insertion.
    These values are specified using the [`Insert.on_conflict_do_update.set_`](#sqlalchemy.dialects.postgresql.Insert.on_conflict_do_update.params.set_
    "sqlalchemy.dialects.postgresql.Insert.on_conflict_do_update") parameter. This
    parameter accepts a dictionary which consists of direct values for UPDATE:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE359]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: The `Insert.on_conflict_do_update()` method does **not** take into account Python-side
    default UPDATE values or generation functions, e.g. those specified using [`Column.onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.onupdate
    "sqlalchemy.schema.Column"). These values will not be exercised for an ON CONFLICT
    style of UPDATE, unless they are manually specified in the [`Insert.on_conflict_do_update.set_`](#sqlalchemy.dialects.postgresql.Insert.on_conflict_do_update.params.set_
    "sqlalchemy.dialects.postgresql.Insert.on_conflict_do_update") dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: Updating using the Excluded INSERT Values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In order to refer to the proposed insertion row, the special alias [`Insert.excluded`](#sqlalchemy.dialects.postgresql.Insert.excluded
    "sqlalchemy.dialects.postgresql.Insert.excluded") is available as an attribute
    on the [`Insert`](#sqlalchemy.dialects.postgresql.Insert "sqlalchemy.dialects.postgresql.Insert")
    object; this object is a [`ColumnCollection`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnCollection
    "sqlalchemy.sql.expression.ColumnCollection") which alias contains all columns
    of the target table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE360]'
  prefs: []
  type: TYPE_PRE
- en: Additional WHERE Criteria
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `Insert.on_conflict_do_update()` method also accepts a WHERE clause using
    the [`Insert.on_conflict_do_update.where`](#sqlalchemy.dialects.postgresql.Insert.on_conflict_do_update.params.where
    "sqlalchemy.dialects.postgresql.Insert.on_conflict_do_update") parameter, which
    will limit those rows which receive an UPDATE:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE361]'
  prefs: []
  type: TYPE_PRE
- en: Skipping Rows with DO NOTHING
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`ON CONFLICT` may be used to skip inserting a row entirely if any conflict
    with a unique or exclusion constraint occurs; below this is illustrated using
    the [`Insert.on_conflict_do_nothing()`](#sqlalchemy.dialects.postgresql.Insert.on_conflict_do_nothing
    "sqlalchemy.dialects.postgresql.Insert.on_conflict_do_nothing") method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE362]'
  prefs: []
  type: TYPE_PRE
- en: 'If `DO NOTHING` is used without specifying any columns or constraint, it has
    the effect of skipping the INSERT for any unique or exclusion constraint violation
    which occurs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE363]'
  prefs: []
  type: TYPE_PRE
- en: Specifying the Target
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Both methods supply the “target” of the conflict using either the named constraint
    or by column inference:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`Insert.on_conflict_do_update.index_elements`](#sqlalchemy.dialects.postgresql.Insert.on_conflict_do_update.params.index_elements
    "sqlalchemy.dialects.postgresql.Insert.on_conflict_do_update") argument specifies
    a sequence containing string column names, [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects, and/or SQL expression elements, which would
    identify a unique index:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE364]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When using [`Insert.on_conflict_do_update.index_elements`](#sqlalchemy.dialects.postgresql.Insert.on_conflict_do_update.params.index_elements
    "sqlalchemy.dialects.postgresql.Insert.on_conflict_do_update") to infer an index,
    a partial index can be inferred by also specifying the use the [`Insert.on_conflict_do_update.index_where`](#sqlalchemy.dialects.postgresql.Insert.on_conflict_do_update.params.index_where
    "sqlalchemy.dialects.postgresql.Insert.on_conflict_do_update") parameter:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE365]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The [`Insert.on_conflict_do_update.constraint`](#sqlalchemy.dialects.postgresql.Insert.on_conflict_do_update.params.constraint
    "sqlalchemy.dialects.postgresql.Insert.on_conflict_do_update") argument is used
    to specify an index directly rather than inferring it. This can be the name of
    a UNIQUE constraint, a PRIMARY KEY constraint, or an INDEX:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE366]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The [`Insert.on_conflict_do_update.constraint`](#sqlalchemy.dialects.postgresql.Insert.on_conflict_do_update.params.constraint
    "sqlalchemy.dialects.postgresql.Insert.on_conflict_do_update") argument may also
    refer to a SQLAlchemy construct representing a constraint, e.g. [`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint"), [`PrimaryKeyConstraint`](../core/constraints.html#sqlalchemy.schema.PrimaryKeyConstraint
    "sqlalchemy.schema.PrimaryKeyConstraint"), [`Index`](../core/constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index"), or [`ExcludeConstraint`](#sqlalchemy.dialects.postgresql.ExcludeConstraint
    "sqlalchemy.dialects.postgresql.ExcludeConstraint"). In this use, if the constraint
    has a name, it is used directly. Otherwise, if the constraint is unnamed, then
    inference will be used, where the expressions and optional WHERE clause of the
    constraint will be spelled out in the construct. This use is especially convenient
    to refer to the named or unnamed primary key of a [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") using the [`Table.primary_key`](../core/metadata.html#sqlalchemy.schema.Table.primary_key
    "sqlalchemy.schema.Table.primary_key") attribute:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE367]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The SET Clause
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`ON CONFLICT...DO UPDATE` is used to perform an update of the already existing
    row, using any combination of new values as well as values from the proposed insertion.
    These values are specified using the [`Insert.on_conflict_do_update.set_`](#sqlalchemy.dialects.postgresql.Insert.on_conflict_do_update.params.set_
    "sqlalchemy.dialects.postgresql.Insert.on_conflict_do_update") parameter. This
    parameter accepts a dictionary which consists of direct values for UPDATE:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE368]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: The `Insert.on_conflict_do_update()` method does **not** take into account Python-side
    default UPDATE values or generation functions, e.g. those specified using [`Column.onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.onupdate
    "sqlalchemy.schema.Column"). These values will not be exercised for an ON CONFLICT
    style of UPDATE, unless they are manually specified in the [`Insert.on_conflict_do_update.set_`](#sqlalchemy.dialects.postgresql.Insert.on_conflict_do_update.params.set_
    "sqlalchemy.dialects.postgresql.Insert.on_conflict_do_update") dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: Updating using the Excluded INSERT Values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In order to refer to the proposed insertion row, the special alias [`Insert.excluded`](#sqlalchemy.dialects.postgresql.Insert.excluded
    "sqlalchemy.dialects.postgresql.Insert.excluded") is available as an attribute
    on the [`Insert`](#sqlalchemy.dialects.postgresql.Insert "sqlalchemy.dialects.postgresql.Insert")
    object; this object is a [`ColumnCollection`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnCollection
    "sqlalchemy.sql.expression.ColumnCollection") which alias contains all columns
    of the target table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE369]'
  prefs: []
  type: TYPE_PRE
- en: Additional WHERE Criteria
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `Insert.on_conflict_do_update()` method also accepts a WHERE clause using
    the [`Insert.on_conflict_do_update.where`](#sqlalchemy.dialects.postgresql.Insert.on_conflict_do_update.params.where
    "sqlalchemy.dialects.postgresql.Insert.on_conflict_do_update") parameter, which
    will limit those rows which receive an UPDATE:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE370]'
  prefs: []
  type: TYPE_PRE
- en: Skipping Rows with DO NOTHING
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`ON CONFLICT` may be used to skip inserting a row entirely if any conflict
    with a unique or exclusion constraint occurs; below this is illustrated using
    the [`Insert.on_conflict_do_nothing()`](#sqlalchemy.dialects.postgresql.Insert.on_conflict_do_nothing
    "sqlalchemy.dialects.postgresql.Insert.on_conflict_do_nothing") method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE371]'
  prefs: []
  type: TYPE_PRE
- en: 'If `DO NOTHING` is used without specifying any columns or constraint, it has
    the effect of skipping the INSERT for any unique or exclusion constraint violation
    which occurs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE372]'
  prefs: []
  type: TYPE_PRE
- en: '## Full Text Search'
  prefs: []
  type: TYPE_NORMAL
- en: PostgreSQL’s full text search system is available through the use of the [`func`](../core/sqlelement.html#sqlalchemy.sql.expression.func
    "sqlalchemy.sql.expression.func") namespace, combined with the use of custom operators
    via the [`Operators.bool_op()`](../core/sqlelement.html#sqlalchemy.sql.expression.Operators.bool_op
    "sqlalchemy.sql.expression.Operators.bool_op") method. For simple cases with some
    degree of cross-backend compatibility, the `Operators.match()` operator may also
    be used.
  prefs: []
  type: TYPE_NORMAL
- en: '### Simple plain text matching with `match()`'
  prefs: []
  type: TYPE_NORMAL
- en: The `Operators.match()` operator provides for cross-compatible simple text matching.
    For the PostgreSQL backend, it’s hardcoded to generate an expression using the
    `@@` operator in conjunction with the `plainto_tsquery()` PostgreSQL function.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the PostgreSQL dialect, an expression like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE373]'
  prefs: []
  type: TYPE_PRE
- en: 'would emit to the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE374]'
  prefs: []
  type: TYPE_PRE
- en: Above, passing a plain string to `Operators.match()` will automatically make
    use of `plainto_tsquery()` to specify the type of tsquery. This establishes basic
    database cross-compatibility for `Operators.match()` with other backends.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 2.0: The default tsquery generation function used by the
    PostgreSQL dialect with `Operators.match()` is `plainto_tsquery()`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To render exactly what was rendered in 1.4, use the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE375]'
  prefs: []
  type: TYPE_PRE
- en: 'Which would emit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE376]'
  prefs: []
  type: TYPE_PRE
- en: Using PostgreSQL full text functions and operators directly
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Text search operations beyond the simple use of `Operators.match()` may make
    use of the [`func`](../core/sqlelement.html#sqlalchemy.sql.expression.func "sqlalchemy.sql.expression.func")
    namespace to generate PostgreSQL full-text functions, in combination with [`Operators.bool_op()`](../core/sqlelement.html#sqlalchemy.sql.expression.Operators.bool_op
    "sqlalchemy.sql.expression.Operators.bool_op") to generate any boolean operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE377]'
  prefs: []
  type: TYPE_PRE
- en: 'would generate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE378]'
  prefs: []
  type: TYPE_PRE
- en: 'The [`TSVECTOR`](#sqlalchemy.dialects.postgresql.TSVECTOR "sqlalchemy.dialects.postgresql.TSVECTOR")
    type can provide for explicit CAST:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE379]'
  prefs: []
  type: TYPE_PRE
- en: 'produces a statement equivalent to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE380]'
  prefs: []
  type: TYPE_PRE
- en: 'The `func` namespace is augmented by the PostgreSQL dialect to set up correct
    argument and return types for most full text search functions. These functions
    are used automatically by the [`sqlalchemy.sql.expression.func`](../core/sqlelement.html#sqlalchemy.sql.expression.func
    "sqlalchemy.sql.expression.func") namespace assuming the `sqlalchemy.dialects.postgresql`
    package has been imported, or [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") has been invoked using a `postgresql` dialect. These
    functions are documented at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`to_tsvector`](#sqlalchemy.dialects.postgresql.to_tsvector "sqlalchemy.dialects.postgresql.to_tsvector")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`to_tsquery`](#sqlalchemy.dialects.postgresql.to_tsquery "sqlalchemy.dialects.postgresql.to_tsquery")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`plainto_tsquery`](#sqlalchemy.dialects.postgresql.plainto_tsquery "sqlalchemy.dialects.postgresql.plainto_tsquery")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`phraseto_tsquery`](#sqlalchemy.dialects.postgresql.phraseto_tsquery "sqlalchemy.dialects.postgresql.phraseto_tsquery")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`websearch_to_tsquery`](#sqlalchemy.dialects.postgresql.websearch_to_tsquery
    "sqlalchemy.dialects.postgresql.websearch_to_tsquery")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`ts_headline`](#sqlalchemy.dialects.postgresql.ts_headline "sqlalchemy.dialects.postgresql.ts_headline")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specifying the “regconfig” with `match()` or custom operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'PostgreSQL’s `plainto_tsquery()` function accepts an optional “regconfig” argument
    that is used to instruct PostgreSQL to use a particular pre-computed GIN or GiST
    index in order to perform the search. When using `Operators.match()`, this additional
    parameter may be specified using the `postgresql_regconfig` parameter, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE381]'
  prefs: []
  type: TYPE_PRE
- en: 'Which would emit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE382]'
  prefs: []
  type: TYPE_PRE
- en: 'When using other PostgreSQL search functions with [`func`](../core/sqlelement.html#sqlalchemy.sql.expression.func
    "sqlalchemy.sql.expression.func"), the “regconfig” parameter may be passed directly
    as the initial argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE383]'
  prefs: []
  type: TYPE_PRE
- en: 'produces a statement equivalent to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE384]'
  prefs: []
  type: TYPE_PRE
- en: It is recommended that you use the `EXPLAIN ANALYZE...` tool from PostgreSQL
    to ensure that you are generating queries with SQLAlchemy that take full advantage
    of any indexes you may have created for full text search.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Full Text Search](https://www.postgresql.org/docs/current/textsearch-controls.html)
    - in the PostgreSQL documentation'
  prefs: []
  type: TYPE_NORMAL
- en: '### Simple plain text matching with `match()`'
  prefs: []
  type: TYPE_NORMAL
- en: The `Operators.match()` operator provides for cross-compatible simple text matching.
    For the PostgreSQL backend, it’s hardcoded to generate an expression using the
    `@@` operator in conjunction with the `plainto_tsquery()` PostgreSQL function.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the PostgreSQL dialect, an expression like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE385]'
  prefs: []
  type: TYPE_PRE
- en: 'would emit to the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE386]'
  prefs: []
  type: TYPE_PRE
- en: Above, passing a plain string to `Operators.match()` will automatically make
    use of `plainto_tsquery()` to specify the type of tsquery. This establishes basic
    database cross-compatibility for `Operators.match()` with other backends.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 2.0: The default tsquery generation function used by the
    PostgreSQL dialect with `Operators.match()` is `plainto_tsquery()`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To render exactly what was rendered in 1.4, use the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE387]'
  prefs: []
  type: TYPE_PRE
- en: 'Which would emit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE388]'
  prefs: []
  type: TYPE_PRE
- en: Using PostgreSQL full text functions and operators directly
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Text search operations beyond the simple use of `Operators.match()` may make
    use of the [`func`](../core/sqlelement.html#sqlalchemy.sql.expression.func "sqlalchemy.sql.expression.func")
    namespace to generate PostgreSQL full-text functions, in combination with [`Operators.bool_op()`](../core/sqlelement.html#sqlalchemy.sql.expression.Operators.bool_op
    "sqlalchemy.sql.expression.Operators.bool_op") to generate any boolean operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE389]'
  prefs: []
  type: TYPE_PRE
- en: 'would generate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE390]'
  prefs: []
  type: TYPE_PRE
- en: 'The [`TSVECTOR`](#sqlalchemy.dialects.postgresql.TSVECTOR "sqlalchemy.dialects.postgresql.TSVECTOR")
    type can provide for explicit CAST:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE391]'
  prefs: []
  type: TYPE_PRE
- en: 'produces a statement equivalent to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE392]'
  prefs: []
  type: TYPE_PRE
- en: 'The `func` namespace is augmented by the PostgreSQL dialect to set up correct
    argument and return types for most full text search functions. These functions
    are used automatically by the [`sqlalchemy.sql.expression.func`](../core/sqlelement.html#sqlalchemy.sql.expression.func
    "sqlalchemy.sql.expression.func") namespace assuming the `sqlalchemy.dialects.postgresql`
    package has been imported, or [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") has been invoked using a `postgresql` dialect. These
    functions are documented at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`to_tsvector`](#sqlalchemy.dialects.postgresql.to_tsvector "sqlalchemy.dialects.postgresql.to_tsvector")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`to_tsquery`](#sqlalchemy.dialects.postgresql.to_tsquery "sqlalchemy.dialects.postgresql.to_tsquery")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`plainto_tsquery`](#sqlalchemy.dialects.postgresql.plainto_tsquery "sqlalchemy.dialects.postgresql.plainto_tsquery")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`phraseto_tsquery`](#sqlalchemy.dialects.postgresql.phraseto_tsquery "sqlalchemy.dialects.postgresql.phraseto_tsquery")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`websearch_to_tsquery`](#sqlalchemy.dialects.postgresql.websearch_to_tsquery
    "sqlalchemy.dialects.postgresql.websearch_to_tsquery")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`ts_headline`](#sqlalchemy.dialects.postgresql.ts_headline "sqlalchemy.dialects.postgresql.ts_headline")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specifying the “regconfig” with `match()` or custom operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'PostgreSQL’s `plainto_tsquery()` function accepts an optional “regconfig” argument
    that is used to instruct PostgreSQL to use a particular pre-computed GIN or GiST
    index in order to perform the search. When using `Operators.match()`, this additional
    parameter may be specified using the `postgresql_regconfig` parameter, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE393]'
  prefs: []
  type: TYPE_PRE
- en: 'Which would emit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE394]'
  prefs: []
  type: TYPE_PRE
- en: 'When using other PostgreSQL search functions with [`func`](../core/sqlelement.html#sqlalchemy.sql.expression.func
    "sqlalchemy.sql.expression.func"), the “regconfig” parameter may be passed directly
    as the initial argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE395]'
  prefs: []
  type: TYPE_PRE
- en: 'produces a statement equivalent to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE396]'
  prefs: []
  type: TYPE_PRE
- en: It is recommended that you use the `EXPLAIN ANALYZE...` tool from PostgreSQL
    to ensure that you are generating queries with SQLAlchemy that take full advantage
    of any indexes you may have created for full text search.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Full Text Search](https://www.postgresql.org/docs/current/textsearch-controls.html)
    - in the PostgreSQL documentation'
  prefs: []
  type: TYPE_NORMAL
- en: FROM ONLY …
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The dialect supports PostgreSQL’s ONLY keyword for targeting only a particular
    table in an inheritance hierarchy. This can be used to produce the `SELECT ...
    FROM ONLY`, `UPDATE ONLY ...`, and `DELETE FROM ONLY ...` syntaxes. It uses SQLAlchemy’s
    hints mechanism:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE397]'
  prefs: []
  type: TYPE_PRE
- en: '## PostgreSQL-Specific Index Options'
  prefs: []
  type: TYPE_NORMAL
- en: Several extensions to the [`Index`](../core/constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index") construct are available, specific to the PostgreSQL
    dialect.
  prefs: []
  type: TYPE_NORMAL
- en: Covering Indexes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `postgresql_include` option renders INCLUDE(colname) for the given string
    names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE398]'
  prefs: []
  type: TYPE_PRE
- en: would render the index as `CREATE INDEX my_index ON table (x) INCLUDE (y)`
  prefs: []
  type: TYPE_NORMAL
- en: Note that this feature requires PostgreSQL 11 or later.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.4.
  prefs: []
  type: TYPE_NORMAL
- en: '### Partial Indexes'
  prefs: []
  type: TYPE_NORMAL
- en: 'Partial indexes add criterion to the index definition so that the index is
    applied to a subset of rows. These can be specified on [`Index`](../core/constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index") using the `postgresql_where` keyword argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE399]  ### Operator Classes'
  prefs: []
  type: TYPE_NORMAL
- en: 'PostgreSQL allows the specification of an *operator class* for each column
    of an index (see [https://www.postgresql.org/docs/current/interactive/indexes-opclass.html](https://www.postgresql.org/docs/current/interactive/indexes-opclass.html)).
    The [`Index`](../core/constraints.html#sqlalchemy.schema.Index "sqlalchemy.schema.Index")
    construct allows these to be specified via the `postgresql_ops` keyword argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE400]'
  prefs: []
  type: TYPE_PRE
- en: Note that the keys in the `postgresql_ops` dictionaries are the “key” name of
    the [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column"),
    i.e. the name used to access it from the `.c` collection of [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table"), which can be configured to be different than the actual
    name of the column as expressed in the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'If `postgresql_ops` is to be used against a complex SQL expression such as
    a function call, then to apply to the column it must be given a label that is
    identified in the dictionary by name, e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE401]'
  prefs: []
  type: TYPE_PRE
- en: Operator classes are also supported by the [`ExcludeConstraint`](#sqlalchemy.dialects.postgresql.ExcludeConstraint
    "sqlalchemy.dialects.postgresql.ExcludeConstraint") construct using the [`ExcludeConstraint.ops`](#sqlalchemy.dialects.postgresql.ExcludeConstraint.params.ops
    "sqlalchemy.dialects.postgresql.ExcludeConstraint") parameter. See that parameter
    for details.
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 1.3.21: added support for operator classes with [`ExcludeConstraint`](#sqlalchemy.dialects.postgresql.ExcludeConstraint
    "sqlalchemy.dialects.postgresql.ExcludeConstraint").'
  prefs: []
  type: TYPE_NORMAL
- en: Index Types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'PostgreSQL provides several index types: B-Tree, Hash, GiST, and GIN, as well
    as the ability for users to create their own (see [https://www.postgresql.org/docs/current/static/indexes-types.html](https://www.postgresql.org/docs/current/static/indexes-types.html)).
    These can be specified on [`Index`](../core/constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index") using the `postgresql_using` keyword argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE402]'
  prefs: []
  type: TYPE_PRE
- en: The value passed to the keyword argument will be simply passed through to the
    underlying CREATE INDEX command, so it *must* be a valid index type for your version
    of PostgreSQL.
  prefs: []
  type: TYPE_NORMAL
- en: '### Index Storage Parameters'
  prefs: []
  type: TYPE_NORMAL
- en: 'PostgreSQL allows storage parameters to be set on indexes. The storage parameters
    available depend on the index method used by the index. Storage parameters can
    be specified on [`Index`](../core/constraints.html#sqlalchemy.schema.Index "sqlalchemy.schema.Index")
    using the `postgresql_with` keyword argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE403]'
  prefs: []
  type: TYPE_PRE
- en: 'PostgreSQL allows to define the tablespace in which to create the index. The
    tablespace can be specified on [`Index`](../core/constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index") using the `postgresql_tablespace` keyword argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE404]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the same option is available on [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") as well.  ### Indexes with CONCURRENTLY'
  prefs: []
  type: TYPE_NORMAL
- en: 'The PostgreSQL index option CONCURRENTLY is supported by passing the flag `postgresql_concurrently`
    to the [`Index`](../core/constraints.html#sqlalchemy.schema.Index "sqlalchemy.schema.Index")
    construct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE405]'
  prefs: []
  type: TYPE_PRE
- en: 'The above index construct will render DDL for CREATE INDEX, assuming PostgreSQL
    8.2 or higher is detected or for a connection-less dialect, as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE406]'
  prefs: []
  type: TYPE_PRE
- en: 'For DROP INDEX, assuming PostgreSQL 9.2 or higher is detected or for a connection-less
    dialect, it will emit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE407]'
  prefs: []
  type: TYPE_PRE
- en: 'When using CONCURRENTLY, the PostgreSQL database requires that the statement
    be invoked outside of a transaction block. The Python DBAPI enforces that even
    for a single statement, a transaction is present, so to use this construct, the
    DBAPI’s “autocommit” mode must be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE408]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Transaction Isolation Level](#postgresql-isolation-level)'
  prefs: []
  type: TYPE_NORMAL
- en: Covering Indexes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `postgresql_include` option renders INCLUDE(colname) for the given string
    names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE409]'
  prefs: []
  type: TYPE_PRE
- en: would render the index as `CREATE INDEX my_index ON table (x) INCLUDE (y)`
  prefs: []
  type: TYPE_NORMAL
- en: Note that this feature requires PostgreSQL 11 or later.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.4.
  prefs: []
  type: TYPE_NORMAL
- en: '### Partial Indexes'
  prefs: []
  type: TYPE_NORMAL
- en: 'Partial indexes add criterion to the index definition so that the index is
    applied to a subset of rows. These can be specified on [`Index`](../core/constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index") using the `postgresql_where` keyword argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE410]'
  prefs: []
  type: TYPE_PRE
- en: '### Operator Classes'
  prefs: []
  type: TYPE_NORMAL
- en: 'PostgreSQL allows the specification of an *operator class* for each column
    of an index (see [https://www.postgresql.org/docs/current/interactive/indexes-opclass.html](https://www.postgresql.org/docs/current/interactive/indexes-opclass.html)).
    The [`Index`](../core/constraints.html#sqlalchemy.schema.Index "sqlalchemy.schema.Index")
    construct allows these to be specified via the `postgresql_ops` keyword argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE411]'
  prefs: []
  type: TYPE_PRE
- en: Note that the keys in the `postgresql_ops` dictionaries are the “key” name of
    the [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column"),
    i.e. the name used to access it from the `.c` collection of [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table"), which can be configured to be different than the actual
    name of the column as expressed in the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'If `postgresql_ops` is to be used against a complex SQL expression such as
    a function call, then to apply to the column it must be given a label that is
    identified in the dictionary by name, e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE412]'
  prefs: []
  type: TYPE_PRE
- en: Operator classes are also supported by the [`ExcludeConstraint`](#sqlalchemy.dialects.postgresql.ExcludeConstraint
    "sqlalchemy.dialects.postgresql.ExcludeConstraint") construct using the [`ExcludeConstraint.ops`](#sqlalchemy.dialects.postgresql.ExcludeConstraint.params.ops
    "sqlalchemy.dialects.postgresql.ExcludeConstraint") parameter. See that parameter
    for details.
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 1.3.21: added support for operator classes with [`ExcludeConstraint`](#sqlalchemy.dialects.postgresql.ExcludeConstraint
    "sqlalchemy.dialects.postgresql.ExcludeConstraint").'
  prefs: []
  type: TYPE_NORMAL
- en: Index Types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'PostgreSQL provides several index types: B-Tree, Hash, GiST, and GIN, as well
    as the ability for users to create their own (see [https://www.postgresql.org/docs/current/static/indexes-types.html](https://www.postgresql.org/docs/current/static/indexes-types.html)).
    These can be specified on [`Index`](../core/constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index") using the `postgresql_using` keyword argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE413]'
  prefs: []
  type: TYPE_PRE
- en: The value passed to the keyword argument will be simply passed through to the
    underlying CREATE INDEX command, so it *must* be a valid index type for your version
    of PostgreSQL.
  prefs: []
  type: TYPE_NORMAL
- en: '### Index Storage Parameters'
  prefs: []
  type: TYPE_NORMAL
- en: 'PostgreSQL allows storage parameters to be set on indexes. The storage parameters
    available depend on the index method used by the index. Storage parameters can
    be specified on [`Index`](../core/constraints.html#sqlalchemy.schema.Index "sqlalchemy.schema.Index")
    using the `postgresql_with` keyword argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE414]'
  prefs: []
  type: TYPE_PRE
- en: 'PostgreSQL allows to define the tablespace in which to create the index. The
    tablespace can be specified on [`Index`](../core/constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index") using the `postgresql_tablespace` keyword argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE415]'
  prefs: []
  type: TYPE_PRE
- en: Note that the same option is available on [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") as well.
  prefs: []
  type: TYPE_NORMAL
- en: '### Indexes with CONCURRENTLY'
  prefs: []
  type: TYPE_NORMAL
- en: 'The PostgreSQL index option CONCURRENTLY is supported by passing the flag `postgresql_concurrently`
    to the [`Index`](../core/constraints.html#sqlalchemy.schema.Index "sqlalchemy.schema.Index")
    construct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE416]'
  prefs: []
  type: TYPE_PRE
- en: 'The above index construct will render DDL for CREATE INDEX, assuming PostgreSQL
    8.2 or higher is detected or for a connection-less dialect, as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE417]'
  prefs: []
  type: TYPE_PRE
- en: 'For DROP INDEX, assuming PostgreSQL 9.2 or higher is detected or for a connection-less
    dialect, it will emit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE418]'
  prefs: []
  type: TYPE_PRE
- en: 'When using CONCURRENTLY, the PostgreSQL database requires that the statement
    be invoked outside of a transaction block. The Python DBAPI enforces that even
    for a single statement, a transaction is present, so to use this construct, the
    DBAPI’s “autocommit” mode must be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE419]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Transaction Isolation Level](#postgresql-isolation-level)'
  prefs: []
  type: TYPE_NORMAL
- en: '## PostgreSQL Index Reflection'
  prefs: []
  type: TYPE_NORMAL
- en: The PostgreSQL database creates a UNIQUE INDEX implicitly whenever the UNIQUE
    CONSTRAINT construct is used. When inspecting a table using [`Inspector`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector
    "sqlalchemy.engine.reflection.Inspector"), the [`Inspector.get_indexes()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_indexes
    "sqlalchemy.engine.reflection.Inspector.get_indexes") and the [`Inspector.get_unique_constraints()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_unique_constraints
    "sqlalchemy.engine.reflection.Inspector.get_unique_constraints") will report on
    these two constructs distinctly; in the case of the index, the key `duplicates_constraint`
    will be present in the index entry if it is detected as mirroring a constraint.
    When performing reflection using `Table(..., autoload_with=engine)`, the UNIQUE
    INDEX is **not** returned in [`Table.indexes`](../core/metadata.html#sqlalchemy.schema.Table.indexes
    "sqlalchemy.schema.Table.indexes") when it is detected as mirroring a [`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint") in the [`Table.constraints`](../core/metadata.html#sqlalchemy.schema.Table.constraints
    "sqlalchemy.schema.Table.constraints") collection .
  prefs: []
  type: TYPE_NORMAL
- en: Special Reflection Options
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The [`Inspector`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector
    "sqlalchemy.engine.reflection.Inspector") used for the PostgreSQL backend is an
    instance of [`PGInspector`](#sqlalchemy.dialects.postgresql.base.PGInspector "sqlalchemy.dialects.postgresql.base.PGInspector"),
    which offers additional methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE420]'
  prefs: []
  type: TYPE_PRE
- en: '| Object Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| [PGInspector](#sqlalchemy.dialects.postgresql.base.PGInspector) |  |'
  prefs: []
  type: TYPE_TB
- en: '[PRE421]'
  prefs: []
  type: TYPE_PRE
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[get_domains()](#sqlalchemy.dialects.postgresql.base.PGInspector.get_domains),
    [get_enums()](#sqlalchemy.dialects.postgresql.base.PGInspector.get_enums), [get_foreign_table_names()](#sqlalchemy.dialects.postgresql.base.PGInspector.get_foreign_table_names),
    [get_table_oid()](#sqlalchemy.dialects.postgresql.base.PGInspector.get_table_oid),
    [has_type()](#sqlalchemy.dialects.postgresql.base.PGInspector.has_type)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.postgresql.base.PGInspector`](#sqlalchemy.dialects.postgresql.base.PGInspector
    "sqlalchemy.dialects.postgresql.base.PGInspector") ([`sqlalchemy.engine.reflection.Inspector`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector
    "sqlalchemy.engine.reflection.Inspector"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE422]'
  prefs: []
  type: TYPE_PRE
- en: Return a list of DOMAIN objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each member is a dictionary containing these fields:'
  prefs: []
  type: TYPE_NORMAL
- en: name - name of the domain
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: schema - the schema name for the domain.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: visible - boolean, whether or not this domain is visible in the default search
    path.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: type - the type defined by this domain.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: nullable - Indicates if this domain can be `NULL`.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: default - The default value of the domain or `None` if the domain has no default.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: 'constraints - A list of dict wit the constraint defined by this domain. Each
    element constaints two keys: `name` of the constraint and `check` with the constraint
    text.'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**schema** – schema name. If None, the default schema (typically ‘public’)
    is used. May also be set to `''*''` to indicate load domains for all schemas.'
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE423]'
  prefs: []
  type: TYPE_PRE
- en: Return a list of ENUM objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each member is a dictionary containing these fields:'
  prefs: []
  type: TYPE_NORMAL
- en: name - name of the enum
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: schema - the schema name for the enum.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: visible - boolean, whether or not this enum is visible in the default search
    path.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: labels - a list of string labels that apply to the enum.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**schema** – schema name. If None, the default schema (typically ‘public’)
    is used. May also be set to `''*''` to indicate load enums for all schemas.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE424]'
  prefs: []
  type: TYPE_PRE
- en: Return a list of FOREIGN TABLE names.
  prefs: []
  type: TYPE_NORMAL
- en: Behavior is similar to that of [`Inspector.get_table_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_table_names
    "sqlalchemy.engine.reflection.Inspector.get_table_names"), except that the list
    is limited to those tables that report a `relkind` value of `f`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE425]'
  prefs: []
  type: TYPE_PRE
- en: Return the OID for the given table name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`table_name` – string name of the table. For special quoting, use [`quoted_name`](../core/sqlelement.html#sqlalchemy.sql.expression.quoted_name
    "sqlalchemy.sql.expression.quoted_name").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`schema` – string schema name; if omitted, uses the default schema of the database
    connection. For special quoting, use [`quoted_name`](../core/sqlelement.html#sqlalchemy.sql.expression.quoted_name
    "sqlalchemy.sql.expression.quoted_name").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE426]'
  prefs: []
  type: TYPE_PRE
- en: Return if the database has the specified type in the provided schema.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`type_name` – the type to check.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`schema` – schema name. If None, the default schema (typically ‘public’) is
    used. May also be set to `''*''` to check in all schemas.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: '## PostgreSQL Table Options'
  prefs: []
  type: TYPE_NORMAL
- en: 'Several options for CREATE TABLE are supported directly by the PostgreSQL dialect
    in conjunction with the [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") construct:'
  prefs: []
  type: TYPE_NORMAL
- en: '`INHERITS`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE427]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`ON COMMIT`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE428]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`PARTITION BY`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE429]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`TABLESPACE`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE430]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The above option is also available on the [`Index`](../core/constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index") construct.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`USING`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE431]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`WITH OIDS`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE432]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`WITHOUT OIDS`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE433]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[PostgreSQL CREATE TABLE options](https://www.postgresql.org/docs/current/static/sql-createtable.html)
    - in the PostgreSQL documentation.'
  prefs: []
  type: TYPE_NORMAL
- en: '## PostgreSQL Constraint Options'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following option(s) are supported by the PostgreSQL dialect in conjunction
    with selected constraint constructs:'
  prefs: []
  type: TYPE_NORMAL
- en: '`NOT VALID`: This option applies towards CHECK and FOREIGN KEY constraints
    when the constraint is being added to an existing table via ALTER TABLE, and has
    the effect that existing rows are not scanned during the ALTER operation against
    the constraint being added.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When using a SQL migration tool such as [Alembic](https://alembic.sqlalchemy.org)
    that renders ALTER TABLE constructs, the `postgresql_not_valid` argument may be
    specified as an additional keyword argument within the operation that creates
    the constraint, as in the following Alembic example:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE434]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The keyword is ultimately accepted directly by the [`CheckConstraint`](../core/constraints.html#sqlalchemy.schema.CheckConstraint
    "sqlalchemy.schema.CheckConstraint"), [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") and [`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey") constructs; when using a tool like Alembic, dialect-specific
    keyword arguments are passed through to these constructs from the migration operation
    directives:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE435]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: New in version 1.4.32.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PostgreSQL ALTER TABLE options](https://www.postgresql.org/docs/current/static/sql-altertable.html)
    - in the PostgreSQL documentation.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '## Table values, Table and Column valued functions, Row and Tuple objects'
  prefs: []
  type: TYPE_NORMAL
- en: PostgreSQL makes great use of modern SQL forms such as table-valued functions,
    tables and rows as values. These constructs are commonly used as part of PostgreSQL’s
    support for complex datatypes such as JSON, ARRAY, and other datatypes. SQLAlchemy’s
    SQL expression language has native support for most table-valued and row-valued
    forms.
  prefs: []
  type: TYPE_NORMAL
- en: '### Table-Valued Functions'
  prefs: []
  type: TYPE_NORMAL
- en: Many PostgreSQL built-in functions are intended to be used in the FROM clause
    of a SELECT statement, and are capable of returning table rows or sets of table
    rows. A large portion of PostgreSQL’s JSON functions for example such as `json_array_elements()`,
    `json_object_keys()`, `json_each_text()`, `json_each()`, `json_to_record()`, `json_populate_recordset()`
    use such forms. These classes of SQL function calling forms in SQLAlchemy are
    available using the [`FunctionElement.table_valued()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.table_valued
    "sqlalchemy.sql.functions.FunctionElement.table_valued") method in conjunction
    with [`Function`](../core/functions.html#sqlalchemy.sql.functions.Function "sqlalchemy.sql.functions.Function")
    objects generated from the [`func`](../core/sqlelement.html#sqlalchemy.sql.expression.func
    "sqlalchemy.sql.expression.func") namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'Examples from PostgreSQL’s reference documentation follow below:'
  prefs: []
  type: TYPE_NORMAL
- en: '`json_each()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE436]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`json_populate_record()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE437]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`json_to_record()` - this form uses a PostgreSQL specific form of derived columns
    in the alias, where we may make use of [`column()`](../core/sqlelement.html#sqlalchemy.sql.expression.column
    "sqlalchemy.sql.expression.column") elements with types to produce them. The [`FunctionElement.table_valued()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.table_valued
    "sqlalchemy.sql.functions.FunctionElement.table_valued") method produces a [`TableValuedAlias`](../core/selectable.html#sqlalchemy.sql.expression.TableValuedAlias
    "sqlalchemy.sql.expression.TableValuedAlias") construct, and the method [`TableValuedAlias.render_derived()`](../core/selectable.html#sqlalchemy.sql.expression.TableValuedAlias.render_derived
    "sqlalchemy.sql.expression.TableValuedAlias.render_derived") method sets up the
    derived columns specification:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE438]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`WITH ORDINALITY` - part of the SQL standard, `WITH ORDINALITY` adds an ordinal
    counter to the output of a function and is accepted by a limited set of PostgreSQL
    functions including `unnest()` and `generate_series()`. The [`FunctionElement.table_valued()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.table_valued
    "sqlalchemy.sql.functions.FunctionElement.table_valued") method accepts a keyword
    parameter `with_ordinality` for this purpose, which accepts the string name that
    will be applied to the “ordinality” column:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE439]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: New in version 1.4.0b2.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Table-Valued Functions](../tutorial/data_select.html#tutorial-functions-table-valued)
    - in the [SQLAlchemy Unified Tutorial](../tutorial/index.html#unified-tutorial)  ###
    Column Valued Functions'
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to the table valued function, a column valued function is present in
    the FROM clause, but delivers itself to the columns clause as a single scalar
    value. PostgreSQL functions such as `json_array_elements()`, `unnest()` and `generate_series()`
    may use this form. Column valued functions are available using the [`FunctionElement.column_valued()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.column_valued
    "sqlalchemy.sql.functions.FunctionElement.column_valued") method of [`FunctionElement`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement
    "sqlalchemy.sql.functions.FunctionElement"):'
  prefs: []
  type: TYPE_NORMAL
- en: '`json_array_elements()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE440]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`unnest()` - in order to generate a PostgreSQL ARRAY literal, the [`array()`](#sqlalchemy.dialects.postgresql.array
    "sqlalchemy.dialects.postgresql.array") construct may be used:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE441]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The function can of course be used against an existing table-bound column that’s
    of type [`ARRAY`](../core/type_basics.html#sqlalchemy.types.ARRAY "sqlalchemy.types.ARRAY"):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE442]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Column Valued Functions - Table Valued Function as a Scalar Column](../tutorial/data_select.html#tutorial-functions-column-valued)
    - in the [SQLAlchemy Unified Tutorial](../tutorial/index.html#unified-tutorial)'
  prefs: []
  type: TYPE_NORMAL
- en: Row Types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Built-in support for rendering a `ROW` may be approximated using `func.ROW`
    with the `sqlalchemy.func` namespace, or by using the [`tuple_()`](../core/sqlelement.html#sqlalchemy.sql.expression.tuple_
    "sqlalchemy.sql.expression.tuple_") construct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE443]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[PostgreSQL Row Constructors](https://www.postgresql.org/docs/current/sql-expressions.html#SQL-SYNTAX-ROW-CONSTRUCTORS)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PostgreSQL Row Constructor Comparison](https://www.postgresql.org/docs/current/functions-comparisons.html#ROW-WISE-COMPARISON)'
  prefs: []
  type: TYPE_NORMAL
- en: Table Types passed to Functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'PostgreSQL supports passing a table as an argument to a function, which is
    known as a “record” type. SQLAlchemy [`FromClause`](../core/selectable.html#sqlalchemy.sql.expression.FromClause
    "sqlalchemy.sql.expression.FromClause") objects such as [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") support this special form using the `FromClause.table_valued()`
    method, which is comparable to the [`FunctionElement.table_valued()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.table_valued
    "sqlalchemy.sql.functions.FunctionElement.table_valued") method except that the
    collection of columns is already established by that of the [`FromClause`](../core/selectable.html#sqlalchemy.sql.expression.FromClause
    "sqlalchemy.sql.expression.FromClause") itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE444]'
  prefs: []
  type: TYPE_PRE
- en: New in version 1.4.0b2.
  prefs: []
  type: TYPE_NORMAL
- en: '### Table-Valued Functions'
  prefs: []
  type: TYPE_NORMAL
- en: Many PostgreSQL built-in functions are intended to be used in the FROM clause
    of a SELECT statement, and are capable of returning table rows or sets of table
    rows. A large portion of PostgreSQL’s JSON functions for example such as `json_array_elements()`,
    `json_object_keys()`, `json_each_text()`, `json_each()`, `json_to_record()`, `json_populate_recordset()`
    use such forms. These classes of SQL function calling forms in SQLAlchemy are
    available using the [`FunctionElement.table_valued()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.table_valued
    "sqlalchemy.sql.functions.FunctionElement.table_valued") method in conjunction
    with [`Function`](../core/functions.html#sqlalchemy.sql.functions.Function "sqlalchemy.sql.functions.Function")
    objects generated from the [`func`](../core/sqlelement.html#sqlalchemy.sql.expression.func
    "sqlalchemy.sql.expression.func") namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'Examples from PostgreSQL’s reference documentation follow below:'
  prefs: []
  type: TYPE_NORMAL
- en: '`json_each()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE445]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`json_populate_record()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE446]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`json_to_record()` - this form uses a PostgreSQL specific form of derived columns
    in the alias, where we may make use of [`column()`](../core/sqlelement.html#sqlalchemy.sql.expression.column
    "sqlalchemy.sql.expression.column") elements with types to produce them. The [`FunctionElement.table_valued()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.table_valued
    "sqlalchemy.sql.functions.FunctionElement.table_valued") method produces a [`TableValuedAlias`](../core/selectable.html#sqlalchemy.sql.expression.TableValuedAlias
    "sqlalchemy.sql.expression.TableValuedAlias") construct, and the method [`TableValuedAlias.render_derived()`](../core/selectable.html#sqlalchemy.sql.expression.TableValuedAlias.render_derived
    "sqlalchemy.sql.expression.TableValuedAlias.render_derived") method sets up the
    derived columns specification:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE447]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`WITH ORDINALITY` - part of the SQL standard, `WITH ORDINALITY` adds an ordinal
    counter to the output of a function and is accepted by a limited set of PostgreSQL
    functions including `unnest()` and `generate_series()`. The [`FunctionElement.table_valued()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.table_valued
    "sqlalchemy.sql.functions.FunctionElement.table_valued") method accepts a keyword
    parameter `with_ordinality` for this purpose, which accepts the string name that
    will be applied to the “ordinality” column:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE448]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: New in version 1.4.0b2.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Table-Valued Functions](../tutorial/data_select.html#tutorial-functions-table-valued)
    - in the [SQLAlchemy Unified Tutorial](../tutorial/index.html#unified-tutorial)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Column Valued Functions'
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to the table valued function, a column valued function is present in
    the FROM clause, but delivers itself to the columns clause as a single scalar
    value. PostgreSQL functions such as `json_array_elements()`, `unnest()` and `generate_series()`
    may use this form. Column valued functions are available using the [`FunctionElement.column_valued()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.column_valued
    "sqlalchemy.sql.functions.FunctionElement.column_valued") method of [`FunctionElement`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement
    "sqlalchemy.sql.functions.FunctionElement"):'
  prefs: []
  type: TYPE_NORMAL
- en: '`json_array_elements()`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE449]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`unnest()` - in order to generate a PostgreSQL ARRAY literal, the [`array()`](#sqlalchemy.dialects.postgresql.array
    "sqlalchemy.dialects.postgresql.array") construct may be used:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE450]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The function can of course be used against an existing table-bound column that’s
    of type [`ARRAY`](../core/type_basics.html#sqlalchemy.types.ARRAY "sqlalchemy.types.ARRAY"):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE451]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Column Valued Functions - Table Valued Function as a Scalar Column](../tutorial/data_select.html#tutorial-functions-column-valued)
    - in the [SQLAlchemy Unified Tutorial](../tutorial/index.html#unified-tutorial)'
  prefs: []
  type: TYPE_NORMAL
- en: Row Types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Built-in support for rendering a `ROW` may be approximated using `func.ROW`
    with the `sqlalchemy.func` namespace, or by using the [`tuple_()`](../core/sqlelement.html#sqlalchemy.sql.expression.tuple_
    "sqlalchemy.sql.expression.tuple_") construct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE452]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[PostgreSQL Row Constructors](https://www.postgresql.org/docs/current/sql-expressions.html#SQL-SYNTAX-ROW-CONSTRUCTORS)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PostgreSQL Row Constructor Comparison](https://www.postgresql.org/docs/current/functions-comparisons.html#ROW-WISE-COMPARISON)'
  prefs: []
  type: TYPE_NORMAL
- en: Table Types passed to Functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'PostgreSQL supports passing a table as an argument to a function, which is
    known as a “record” type. SQLAlchemy [`FromClause`](../core/selectable.html#sqlalchemy.sql.expression.FromClause
    "sqlalchemy.sql.expression.FromClause") objects such as [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") support this special form using the `FromClause.table_valued()`
    method, which is comparable to the [`FunctionElement.table_valued()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.table_valued
    "sqlalchemy.sql.functions.FunctionElement.table_valued") method except that the
    collection of columns is already established by that of the [`FromClause`](../core/selectable.html#sqlalchemy.sql.expression.FromClause
    "sqlalchemy.sql.expression.FromClause") itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE453]'
  prefs: []
  type: TYPE_PRE
- en: New in version 1.4.0b2.
  prefs: []
  type: TYPE_NORMAL
- en: ARRAY Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The PostgreSQL dialect supports arrays, both as multidimensional column types
    as well as array literals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`ARRAY`](#sqlalchemy.dialects.postgresql.ARRAY "sqlalchemy.dialects.postgresql.ARRAY")
    - ARRAY datatype'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`array`](#sqlalchemy.dialects.postgresql.array "sqlalchemy.dialects.postgresql.array")
    - array literal'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`array_agg()`](#sqlalchemy.dialects.postgresql.array_agg "sqlalchemy.dialects.postgresql.array_agg")
    - ARRAY_AGG SQL function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`aggregate_order_by`](#sqlalchemy.dialects.postgresql.aggregate_order_by "sqlalchemy.dialects.postgresql.aggregate_order_by")
    - helper for PG’s ORDER BY aggregate function syntax.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '## JSON Types'
  prefs: []
  type: TYPE_NORMAL
- en: 'The PostgreSQL dialect supports both JSON and JSONB datatypes, including psycopg2’s
    native support and support for all of PostgreSQL’s special operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`JSON`](#sqlalchemy.dialects.postgresql.JSON "sqlalchemy.dialects.postgresql.JSON")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`JSONB`](#sqlalchemy.dialects.postgresql.JSONB "sqlalchemy.dialects.postgresql.JSONB")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`JSONPATH`](#sqlalchemy.dialects.postgresql.JSONPATH "sqlalchemy.dialects.postgresql.JSONPATH")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HSTORE Type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The PostgreSQL HSTORE type as well as hstore literals are supported:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`HSTORE`](#sqlalchemy.dialects.postgresql.HSTORE "sqlalchemy.dialects.postgresql.HSTORE")
    - HSTORE datatype'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`hstore`](#sqlalchemy.dialects.postgresql.hstore "sqlalchemy.dialects.postgresql.hstore")
    - hstore literal'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ENUM Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'PostgreSQL has an independently creatable TYPE structure which is used to implement
    an enumerated type. This approach introduces significant complexity on the SQLAlchemy
    side in terms of when this type should be CREATED and DROPPED. The type object
    is also an independently reflectable entity. The following sections should be
    consulted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`ENUM`](#sqlalchemy.dialects.postgresql.ENUM "sqlalchemy.dialects.postgresql.ENUM")
    - DDL and typing support for ENUM.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`PGInspector.get_enums()`](#sqlalchemy.dialects.postgresql.base.PGInspector.get_enums
    "sqlalchemy.dialects.postgresql.base.PGInspector.get_enums") - retrieve a listing
    of current ENUM types'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`ENUM.create()`](#sqlalchemy.dialects.postgresql.ENUM.create "sqlalchemy.dialects.postgresql.ENUM.create")
    , [`ENUM.drop()`](#sqlalchemy.dialects.postgresql.ENUM.drop "sqlalchemy.dialects.postgresql.ENUM.drop")
    - individual CREATE and DROP commands for ENUM.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '### Using ENUM with ARRAY'
  prefs: []
  type: TYPE_NORMAL
- en: The combination of ENUM and ARRAY is not directly supported by backend DBAPIs
    at this time. Prior to SQLAlchemy 1.3.17, a special workaround was needed in order
    to allow this combination to work, described below.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.3.17: The combination of ENUM and ARRAY is now directly
    handled by SQLAlchemy’s implementation without any workarounds needed.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE454]'
  prefs: []
  type: TYPE_PRE
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE455]'
  prefs: []
  type: TYPE_PRE
- en: 'This type is not included as a built-in type as it would be incompatible with
    a DBAPI that suddenly decides to support ARRAY of ENUM directly in a new version.  ###
    Using JSON/JSONB with ARRAY'
  prefs: []
  type: TYPE_NORMAL
- en: Similar to using ENUM, prior to SQLAlchemy 1.3.17, for an ARRAY of JSON/JSONB
    we need to render the appropriate CAST. Current psycopg2 drivers accommodate the
    result set correctly without any special steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.3.17: The combination of JSON/JSONB and ARRAY is now directly
    handled by SQLAlchemy’s implementation without any workarounds needed.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE456]'
  prefs: []
  type: TYPE_PRE
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE457]  ### Using ENUM with ARRAY'
  prefs: []
  type: TYPE_NORMAL
- en: The combination of ENUM and ARRAY is not directly supported by backend DBAPIs
    at this time. Prior to SQLAlchemy 1.3.17, a special workaround was needed in order
    to allow this combination to work, described below.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.3.17: The combination of ENUM and ARRAY is now directly
    handled by SQLAlchemy’s implementation without any workarounds needed.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE458]'
  prefs: []
  type: TYPE_PRE
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE459]'
  prefs: []
  type: TYPE_PRE
- en: This type is not included as a built-in type as it would be incompatible with
    a DBAPI that suddenly decides to support ARRAY of ENUM directly in a new version.
  prefs: []
  type: TYPE_NORMAL
- en: '### Using JSON/JSONB with ARRAY'
  prefs: []
  type: TYPE_NORMAL
- en: Similar to using ENUM, prior to SQLAlchemy 1.3.17, for an ARRAY of JSON/JSONB
    we need to render the appropriate CAST. Current psycopg2 drivers accommodate the
    result set correctly without any special steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.3.17: The combination of JSON/JSONB and ARRAY is now directly
    handled by SQLAlchemy’s implementation without any workarounds needed.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE460]'
  prefs: []
  type: TYPE_PRE
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE461]'
  prefs: []
  type: TYPE_PRE
- en: '## Range and Multirange Types'
  prefs: []
  type: TYPE_NORMAL
- en: PostgreSQL range and multirange types are supported for the psycopg, pg8000
    and asyncpg dialects; the psycopg2 dialect supports the range types only.
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 2.0.17: Added range and multirange support for the pg8000 dialect.
    pg8000 1.29.8 or greater is required.'
  prefs: []
  type: TYPE_NORMAL
- en: Data values being passed to the database may be passed as string values or by
    using the [`Range`](#sqlalchemy.dialects.postgresql.Range "sqlalchemy.dialects.postgresql.Range")
    data object.
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 2.0: Added the backend-agnostic [`Range`](#sqlalchemy.dialects.postgresql.Range
    "sqlalchemy.dialects.postgresql.Range") object used to indicate ranges. The `psycopg2`-specific
    range classes are no longer exposed and are only used internally by that particular
    dialect.'
  prefs: []
  type: TYPE_NORMAL
- en: 'E.g. an example of a fully typed model using the [`TSRANGE`](#sqlalchemy.dialects.postgresql.TSRANGE
    "sqlalchemy.dialects.postgresql.TSRANGE") datatype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE462]'
  prefs: []
  type: TYPE_PRE
- en: 'To represent data for the `during` column above, the [`Range`](#sqlalchemy.dialects.postgresql.Range
    "sqlalchemy.dialects.postgresql.Range") type is a simple dataclass that will represent
    the bounds of the range. Below illustrates an INSERT of a row into the above `room_booking`
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE463]'
  prefs: []
  type: TYPE_PRE
- en: 'Selecting from any range column will also return [`Range`](#sqlalchemy.dialects.postgresql.Range
    "sqlalchemy.dialects.postgresql.Range") objects as indicated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE464]'
  prefs: []
  type: TYPE_PRE
- en: 'The available range datatypes are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`INT4RANGE`](#sqlalchemy.dialects.postgresql.INT4RANGE "sqlalchemy.dialects.postgresql.INT4RANGE")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`INT8RANGE`](#sqlalchemy.dialects.postgresql.INT8RANGE "sqlalchemy.dialects.postgresql.INT8RANGE")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`NUMRANGE`](#sqlalchemy.dialects.postgresql.NUMRANGE "sqlalchemy.dialects.postgresql.NUMRANGE")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`DATERANGE`](#sqlalchemy.dialects.postgresql.DATERANGE "sqlalchemy.dialects.postgresql.DATERANGE")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`TSRANGE`](#sqlalchemy.dialects.postgresql.TSRANGE "sqlalchemy.dialects.postgresql.TSRANGE")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`TSTZRANGE`](#sqlalchemy.dialects.postgresql.TSTZRANGE "sqlalchemy.dialects.postgresql.TSTZRANGE")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| Object Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| [Range](#sqlalchemy.dialects.postgresql.Range) | Represent a PostgreSQL range.
    |'
  prefs: []
  type: TYPE_TB
- en: '[PRE465]'
  prefs: []
  type: TYPE_PRE
- en: Represent a PostgreSQL range.
  prefs: []
  type: TYPE_NORMAL
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE466]'
  prefs: []
  type: TYPE_PRE
- en: The calling style is similar to that of psycopg and psycopg2, in part to allow
    easier migration from previous SQLAlchemy versions that used these objects directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`lower` – Lower bound value, or None'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`upper` – Upper bound value, or None'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bounds` – keyword-only, optional string value that is one of `"()"`, `"[)"`,
    `"(]"`, `"[]"`. Defaults to `"[)"`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`empty` – keyword-only, optional bool indicating this is an “empty” range'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__eq__()](#sqlalchemy.dialects.postgresql.Range.__eq__), [adjacent_to()](#sqlalchemy.dialects.postgresql.Range.adjacent_to),
    [contained_by()](#sqlalchemy.dialects.postgresql.Range.contained_by), [contains()](#sqlalchemy.dialects.postgresql.Range.contains),
    [difference()](#sqlalchemy.dialects.postgresql.Range.difference), [intersection()](#sqlalchemy.dialects.postgresql.Range.intersection),
    [is_empty](#sqlalchemy.dialects.postgresql.Range.is_empty), [isempty](#sqlalchemy.dialects.postgresql.Range.isempty),
    [lower](#sqlalchemy.dialects.postgresql.Range.lower), [lower_inc](#sqlalchemy.dialects.postgresql.Range.lower_inc),
    [lower_inf](#sqlalchemy.dialects.postgresql.Range.lower_inf), [not_extend_left_of()](#sqlalchemy.dialects.postgresql.Range.not_extend_left_of),
    [not_extend_right_of()](#sqlalchemy.dialects.postgresql.Range.not_extend_right_of),
    [overlaps()](#sqlalchemy.dialects.postgresql.Range.overlaps), [strictly_left_of()](#sqlalchemy.dialects.postgresql.Range.strictly_left_of),
    [strictly_right_of()](#sqlalchemy.dialects.postgresql.Range.strictly_right_of),
    [union()](#sqlalchemy.dialects.postgresql.Range.union), [upper](#sqlalchemy.dialects.postgresql.Range.upper),
    [upper_inc](#sqlalchemy.dialects.postgresql.Range.upper_inc), [upper_inf](#sqlalchemy.dialects.postgresql.Range.upper_inf)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.postgresql.Range`](#sqlalchemy.dialects.postgresql.Range
    "sqlalchemy.dialects.postgresql.Range") (`typing.Generic`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE467]'
  prefs: []
  type: TYPE_PRE
- en: Compare this range to the other taking into account bounds inclusivity, returning
    `True` if they are equal.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE468]'
  prefs: []
  type: TYPE_PRE
- en: Determine whether this range is adjacent to the other.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE469]'
  prefs: []
  type: TYPE_PRE
- en: Determine whether this range is a contained by other.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE470]'
  prefs: []
  type: TYPE_PRE
- en: Determine whether this range contains value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE471]'
  prefs: []
  type: TYPE_PRE
- en: Compute the difference between this range and the other.
  prefs: []
  type: TYPE_NORMAL
- en: This raises a `ValueError` exception if the two ranges are “disjunct”, that
    is neither adjacent nor overlapping.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE472]'
  prefs: []
  type: TYPE_PRE
- en: Compute the intersection of this range with the other.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.10.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE473]'
  prefs: []
  type: TYPE_PRE
- en: A synonym for the ‘empty’ attribute.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE474]'
  prefs: []
  type: TYPE_PRE
- en: A synonym for the ‘empty’ attribute.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE475]'
  prefs: []
  type: TYPE_PRE
- en: the lower bound
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE476]'
  prefs: []
  type: TYPE_PRE
- en: Return True if the lower bound is inclusive.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE477]'
  prefs: []
  type: TYPE_PRE
- en: Return True if this range is non-empty and lower bound is infinite.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE478]'
  prefs: []
  type: TYPE_PRE
- en: Determine whether this does not extend to the left of other.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE479]'
  prefs: []
  type: TYPE_PRE
- en: Determine whether this does not extend to the right of other.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE480]'
  prefs: []
  type: TYPE_PRE
- en: Determine whether this range overlaps with other.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE481]'
  prefs: []
  type: TYPE_PRE
- en: Determine whether this range is completely to the left of other.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE482]'
  prefs: []
  type: TYPE_PRE
- en: Determine whether this range is completely to the right of other.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE483]'
  prefs: []
  type: TYPE_PRE
- en: Compute the union of this range with the other.
  prefs: []
  type: TYPE_NORMAL
- en: This raises a `ValueError` exception if the two ranges are “disjunct”, that
    is neither adjacent nor overlapping.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE484]'
  prefs: []
  type: TYPE_PRE
- en: the upper bound
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE485]'
  prefs: []
  type: TYPE_PRE
- en: Return True if the upper bound is inclusive.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE486]'
  prefs: []
  type: TYPE_PRE
- en: Return True if this range is non-empty and the upper bound is infinite.
  prefs: []
  type: TYPE_NORMAL
- en: Multiranges
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Multiranges are supported by PostgreSQL 14 and above. SQLAlchemy’s multirange
    datatypes deal in lists of [`Range`](#sqlalchemy.dialects.postgresql.Range "sqlalchemy.dialects.postgresql.Range")
    types.
  prefs: []
  type: TYPE_NORMAL
- en: Multiranges are supported on the psycopg, asyncpg, and pg8000 dialects **only**.
    The psycopg2 dialect, which is SQLAlchemy’s default `postgresql` dialect, **does
    not** support multirange datatypes.
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 2.0: Added support for MULTIRANGE datatypes. SQLAlchemy represents
    a multirange value as a list of [`Range`](#sqlalchemy.dialects.postgresql.Range
    "sqlalchemy.dialects.postgresql.Range") objects.'
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 2.0.17: Added multirange support for the pg8000 dialect. pg8000
    1.29.8 or greater is required.'
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 2.0.26: [`MultiRange`](#sqlalchemy.dialects.postgresql.MultiRange
    "sqlalchemy.dialects.postgresql.MultiRange") sequence added.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The example below illustrates use of the [`TSMULTIRANGE`](#sqlalchemy.dialects.postgresql.TSMULTIRANGE
    "sqlalchemy.dialects.postgresql.TSMULTIRANGE") datatype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE487]'
  prefs: []
  type: TYPE_PRE
- en: 'Illustrating insertion and selecting of a record:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE488]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In the above example, the list of [`Range`](#sqlalchemy.dialects.postgresql.Range
    "sqlalchemy.dialects.postgresql.Range") types as handled by the ORM will not automatically
    detect in-place changes to a particular list value; to update list values with
    the ORM, either re-assign a new list to the attribute, or use the [`MutableList`](../orm/extensions/mutable.html#sqlalchemy.ext.mutable.MutableList
    "sqlalchemy.ext.mutable.MutableList") type modifier. See the section [Mutation
    Tracking](../orm/extensions/mutable.html) for background.
  prefs: []
  type: TYPE_NORMAL
- en: '#### Use of a MultiRange sequence to infer the multirange type'
  prefs: []
  type: TYPE_NORMAL
- en: 'When using a multirange as a literal without specifying the type the utility
    [`MultiRange`](#sqlalchemy.dialects.postgresql.MultiRange "sqlalchemy.dialects.postgresql.MultiRange")
    sequence can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE489]'
  prefs: []
  type: TYPE_PRE
- en: Using a simple `list` instead of [`MultiRange`](#sqlalchemy.dialects.postgresql.MultiRange
    "sqlalchemy.dialects.postgresql.MultiRange") would require manually setting the
    type of the literal value to the appropriate multirange type.
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 2.0.26: [`MultiRange`](#sqlalchemy.dialects.postgresql.MultiRange
    "sqlalchemy.dialects.postgresql.MultiRange") sequence added.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The available multirange datatypes are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`INT4MULTIRANGE`](#sqlalchemy.dialects.postgresql.INT4MULTIRANGE "sqlalchemy.dialects.postgresql.INT4MULTIRANGE")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`INT8MULTIRANGE`](#sqlalchemy.dialects.postgresql.INT8MULTIRANGE "sqlalchemy.dialects.postgresql.INT8MULTIRANGE")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`NUMMULTIRANGE`](#sqlalchemy.dialects.postgresql.NUMMULTIRANGE "sqlalchemy.dialects.postgresql.NUMMULTIRANGE")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`DATEMULTIRANGE`](#sqlalchemy.dialects.postgresql.DATEMULTIRANGE "sqlalchemy.dialects.postgresql.DATEMULTIRANGE")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`TSMULTIRANGE`](#sqlalchemy.dialects.postgresql.TSMULTIRANGE "sqlalchemy.dialects.postgresql.TSMULTIRANGE")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`TSTZMULTIRANGE`](#sqlalchemy.dialects.postgresql.TSTZMULTIRANGE "sqlalchemy.dialects.postgresql.TSTZMULTIRANGE")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiranges
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Multiranges are supported by PostgreSQL 14 and above. SQLAlchemy’s multirange
    datatypes deal in lists of [`Range`](#sqlalchemy.dialects.postgresql.Range "sqlalchemy.dialects.postgresql.Range")
    types.
  prefs: []
  type: TYPE_NORMAL
- en: Multiranges are supported on the psycopg, asyncpg, and pg8000 dialects **only**.
    The psycopg2 dialect, which is SQLAlchemy’s default `postgresql` dialect, **does
    not** support multirange datatypes.
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 2.0: Added support for MULTIRANGE datatypes. SQLAlchemy represents
    a multirange value as a list of [`Range`](#sqlalchemy.dialects.postgresql.Range
    "sqlalchemy.dialects.postgresql.Range") objects.'
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 2.0.17: Added multirange support for the pg8000 dialect. pg8000
    1.29.8 or greater is required.'
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 2.0.26: [`MultiRange`](#sqlalchemy.dialects.postgresql.MultiRange
    "sqlalchemy.dialects.postgresql.MultiRange") sequence added.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The example below illustrates use of the [`TSMULTIRANGE`](#sqlalchemy.dialects.postgresql.TSMULTIRANGE
    "sqlalchemy.dialects.postgresql.TSMULTIRANGE") datatype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE490]'
  prefs: []
  type: TYPE_PRE
- en: 'Illustrating insertion and selecting of a record:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE491]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In the above example, the list of [`Range`](#sqlalchemy.dialects.postgresql.Range
    "sqlalchemy.dialects.postgresql.Range") types as handled by the ORM will not automatically
    detect in-place changes to a particular list value; to update list values with
    the ORM, either re-assign a new list to the attribute, or use the [`MutableList`](../orm/extensions/mutable.html#sqlalchemy.ext.mutable.MutableList
    "sqlalchemy.ext.mutable.MutableList") type modifier. See the section [Mutation
    Tracking](../orm/extensions/mutable.html) for background.
  prefs: []
  type: TYPE_NORMAL
- en: '#### Use of a MultiRange sequence to infer the multirange type'
  prefs: []
  type: TYPE_NORMAL
- en: 'When using a multirange as a literal without specifying the type the utility
    [`MultiRange`](#sqlalchemy.dialects.postgresql.MultiRange "sqlalchemy.dialects.postgresql.MultiRange")
    sequence can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE492]'
  prefs: []
  type: TYPE_PRE
- en: Using a simple `list` instead of [`MultiRange`](#sqlalchemy.dialects.postgresql.MultiRange
    "sqlalchemy.dialects.postgresql.MultiRange") would require manually setting the
    type of the literal value to the appropriate multirange type.
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 2.0.26: [`MultiRange`](#sqlalchemy.dialects.postgresql.MultiRange
    "sqlalchemy.dialects.postgresql.MultiRange") sequence added.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The available multirange datatypes are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`INT4MULTIRANGE`](#sqlalchemy.dialects.postgresql.INT4MULTIRANGE "sqlalchemy.dialects.postgresql.INT4MULTIRANGE")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`INT8MULTIRANGE`](#sqlalchemy.dialects.postgresql.INT8MULTIRANGE "sqlalchemy.dialects.postgresql.INT8MULTIRANGE")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`NUMMULTIRANGE`](#sqlalchemy.dialects.postgresql.NUMMULTIRANGE "sqlalchemy.dialects.postgresql.NUMMULTIRANGE")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`DATEMULTIRANGE`](#sqlalchemy.dialects.postgresql.DATEMULTIRANGE "sqlalchemy.dialects.postgresql.DATEMULTIRANGE")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`TSMULTIRANGE`](#sqlalchemy.dialects.postgresql.TSMULTIRANGE "sqlalchemy.dialects.postgresql.TSMULTIRANGE")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`TSTZMULTIRANGE`](#sqlalchemy.dialects.postgresql.TSTZMULTIRANGE "sqlalchemy.dialects.postgresql.TSTZMULTIRANGE")  ####
    Use of a MultiRange sequence to infer the multirange type'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When using a multirange as a literal without specifying the type the utility
    [`MultiRange`](#sqlalchemy.dialects.postgresql.MultiRange "sqlalchemy.dialects.postgresql.MultiRange")
    sequence can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE493]'
  prefs: []
  type: TYPE_PRE
- en: Using a simple `list` instead of [`MultiRange`](#sqlalchemy.dialects.postgresql.MultiRange
    "sqlalchemy.dialects.postgresql.MultiRange") would require manually setting the
    type of the literal value to the appropriate multirange type.
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 2.0.26: [`MultiRange`](#sqlalchemy.dialects.postgresql.MultiRange
    "sqlalchemy.dialects.postgresql.MultiRange") sequence added.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The available multirange datatypes are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`INT4MULTIRANGE`](#sqlalchemy.dialects.postgresql.INT4MULTIRANGE "sqlalchemy.dialects.postgresql.INT4MULTIRANGE")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`INT8MULTIRANGE`](#sqlalchemy.dialects.postgresql.INT8MULTIRANGE "sqlalchemy.dialects.postgresql.INT8MULTIRANGE")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`NUMMULTIRANGE`](#sqlalchemy.dialects.postgresql.NUMMULTIRANGE "sqlalchemy.dialects.postgresql.NUMMULTIRANGE")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`DATEMULTIRANGE`](#sqlalchemy.dialects.postgresql.DATEMULTIRANGE "sqlalchemy.dialects.postgresql.DATEMULTIRANGE")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`TSMULTIRANGE`](#sqlalchemy.dialects.postgresql.TSMULTIRANGE "sqlalchemy.dialects.postgresql.TSMULTIRANGE")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`TSTZMULTIRANGE`](#sqlalchemy.dialects.postgresql.TSTZMULTIRANGE "sqlalchemy.dialects.postgresql.TSTZMULTIRANGE")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '## Network Data Types'
  prefs: []
  type: TYPE_NORMAL
- en: The included networking datatypes are [`INET`](#sqlalchemy.dialects.postgresql.INET
    "sqlalchemy.dialects.postgresql.INET"), [`CIDR`](#sqlalchemy.dialects.postgresql.CIDR
    "sqlalchemy.dialects.postgresql.CIDR"), [`MACADDR`](#sqlalchemy.dialects.postgresql.MACADDR
    "sqlalchemy.dialects.postgresql.MACADDR").
  prefs: []
  type: TYPE_NORMAL
- en: For [`INET`](#sqlalchemy.dialects.postgresql.INET "sqlalchemy.dialects.postgresql.INET")
    and [`CIDR`](#sqlalchemy.dialects.postgresql.CIDR "sqlalchemy.dialects.postgresql.CIDR")
    datatypes, conditional support is available for these datatypes to send and retrieve
    Python `ipaddress` objects including `ipaddress.IPv4Network`, `ipaddress.IPv6Network`,
    `ipaddress.IPv4Address`, `ipaddress.IPv6Address`. This support is currently **the
    default behavior of the DBAPI itself, and varies per DBAPI. SQLAlchemy does not
    yet implement its own network address conversion logic**.
  prefs: []
  type: TYPE_NORMAL
- en: The [psycopg](#postgresql-psycopg) and [asyncpg](#postgresql-asyncpg) support
    these datatypes fully; objects from the `ipaddress` family are returned in rows
    by default.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [psycopg2](#postgresql-psycopg2) dialect only sends and receives strings.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [pg8000](#postgresql-pg8000) dialect supports `ipaddress.IPv4Address` and
    `ipaddress.IPv6Address` objects for the [`INET`](#sqlalchemy.dialects.postgresql.INET
    "sqlalchemy.dialects.postgresql.INET") datatype, but uses strings for [`CIDR`](#sqlalchemy.dialects.postgresql.CIDR
    "sqlalchemy.dialects.postgresql.CIDR") types.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To **normalize all the above DBAPIs to only return strings**, use the `native_inet_types`
    parameter, passing a value of `False`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE494]'
  prefs: []
  type: TYPE_PRE
- en: With the above parameter, the `psycopg`, `asyncpg` and `pg8000` dialects will
    disable the DBAPI’s adaptation of these types and will return only strings, matching
    the behavior of the older `psycopg2` dialect.
  prefs: []
  type: TYPE_NORMAL
- en: The parameter may also be set to `True`, where it will have the effect of raising
    `NotImplementedError` for those backends that don’t support, or don’t yet fully
    support, conversion of rows to Python `ipaddress` datatypes (currently psycopg2
    and pg8000).
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 2.0.18: - added the `native_inet_types` parameter.'
  prefs: []
  type: TYPE_NORMAL
- en: PostgreSQL Data Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As with all SQLAlchemy dialects, all UPPERCASE types that are known to be valid
    with PostgreSQL are importable from the top level dialect, whether they originate
    from [`sqlalchemy.types`](../core/type_basics.html#module-sqlalchemy.types "sqlalchemy.types")
    or from the local dialect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE495]'
  prefs: []
  type: TYPE_PRE
- en: 'Types which are specific to PostgreSQL, or have PostgreSQL-specific construction
    arguments, are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Object Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| [AbstractMultiRange](#sqlalchemy.dialects.postgresql.AbstractMultiRange)
    | Base for PostgreSQL MULTIRANGE types. |'
  prefs: []
  type: TYPE_TB
- en: '| [AbstractRange](#sqlalchemy.dialects.postgresql.AbstractRange) | Base class
    for single and multi Range SQL types. |'
  prefs: []
  type: TYPE_TB
- en: '| [AbstractSingleRange](#sqlalchemy.dialects.postgresql.AbstractSingleRange)
    | Base for PostgreSQL RANGE types. |'
  prefs: []
  type: TYPE_TB
- en: '| [ARRAY](#sqlalchemy.dialects.postgresql.ARRAY) | PostgreSQL ARRAY type. |'
  prefs: []
  type: TYPE_TB
- en: '| [BIT](#sqlalchemy.dialects.postgresql.BIT) |  |'
  prefs: []
  type: TYPE_TB
- en: '| [BYTEA](#sqlalchemy.dialects.postgresql.BYTEA) |  |'
  prefs: []
  type: TYPE_TB
- en: '| [CIDR](#sqlalchemy.dialects.postgresql.CIDR) |  |'
  prefs: []
  type: TYPE_TB
- en: '| [CITEXT](#sqlalchemy.dialects.postgresql.CITEXT) | Provide the PostgreSQL
    CITEXT type. |'
  prefs: []
  type: TYPE_TB
- en: '| [DATEMULTIRANGE](#sqlalchemy.dialects.postgresql.DATEMULTIRANGE) | Represent
    the PostgreSQL DATEMULTIRANGE type. |'
  prefs: []
  type: TYPE_TB
- en: '| [DATERANGE](#sqlalchemy.dialects.postgresql.DATERANGE) | Represent the PostgreSQL
    DATERANGE type. |'
  prefs: []
  type: TYPE_TB
- en: '| [DOMAIN](#sqlalchemy.dialects.postgresql.DOMAIN) | Represent the DOMAIN PostgreSQL
    type. |'
  prefs: []
  type: TYPE_TB
- en: '| [ENUM](#sqlalchemy.dialects.postgresql.ENUM) | PostgreSQL ENUM type. |'
  prefs: []
  type: TYPE_TB
- en: '| [HSTORE](#sqlalchemy.dialects.postgresql.HSTORE) | Represent the PostgreSQL
    HSTORE type. |'
  prefs: []
  type: TYPE_TB
- en: '| [INET](#sqlalchemy.dialects.postgresql.INET) |  |'
  prefs: []
  type: TYPE_TB
- en: '| [INT4MULTIRANGE](#sqlalchemy.dialects.postgresql.INT4MULTIRANGE) | Represent
    the PostgreSQL INT4MULTIRANGE type. |'
  prefs: []
  type: TYPE_TB
- en: '| [INT4RANGE](#sqlalchemy.dialects.postgresql.INT4RANGE) | Represent the PostgreSQL
    INT4RANGE type. |'
  prefs: []
  type: TYPE_TB
- en: '| [INT8MULTIRANGE](#sqlalchemy.dialects.postgresql.INT8MULTIRANGE) | Represent
    the PostgreSQL INT8MULTIRANGE type. |'
  prefs: []
  type: TYPE_TB
- en: '| [INT8RANGE](#sqlalchemy.dialects.postgresql.INT8RANGE) | Represent the PostgreSQL
    INT8RANGE type. |'
  prefs: []
  type: TYPE_TB
- en: '| [INTERVAL](#sqlalchemy.dialects.postgresql.INTERVAL) | PostgreSQL INTERVAL
    type. |'
  prefs: []
  type: TYPE_TB
- en: '| [JSON](#sqlalchemy.dialects.postgresql.JSON) | Represent the PostgreSQL JSON
    type. |'
  prefs: []
  type: TYPE_TB
- en: '| [JSONB](#sqlalchemy.dialects.postgresql.JSONB) | Represent the PostgreSQL
    JSONB type. |'
  prefs: []
  type: TYPE_TB
- en: '| [JSONPATH](#sqlalchemy.dialects.postgresql.JSONPATH) | JSON Path Type. |'
  prefs: []
  type: TYPE_TB
- en: '| [MACADDR](#sqlalchemy.dialects.postgresql.MACADDR) |  |'
  prefs: []
  type: TYPE_TB
- en: '| [MACADDR8](#sqlalchemy.dialects.postgresql.MACADDR8) |  |'
  prefs: []
  type: TYPE_TB
- en: '| [MONEY](#sqlalchemy.dialects.postgresql.MONEY) | Provide the PostgreSQL MONEY
    type. |'
  prefs: []
  type: TYPE_TB
- en: '| [MultiRange](#sqlalchemy.dialects.postgresql.MultiRange) | Represents a multirange
    sequence. |'
  prefs: []
  type: TYPE_TB
- en: '| [NUMMULTIRANGE](#sqlalchemy.dialects.postgresql.NUMMULTIRANGE) | Represent
    the PostgreSQL NUMMULTIRANGE type. |'
  prefs: []
  type: TYPE_TB
- en: '| [NUMRANGE](#sqlalchemy.dialects.postgresql.NUMRANGE) | Represent the PostgreSQL
    NUMRANGE type. |'
  prefs: []
  type: TYPE_TB
- en: '| [OID](#sqlalchemy.dialects.postgresql.OID) | Provide the PostgreSQL OID type.
    |'
  prefs: []
  type: TYPE_TB
- en: '| [REGCLASS](#sqlalchemy.dialects.postgresql.REGCLASS) | Provide the PostgreSQL
    REGCLASS type. |'
  prefs: []
  type: TYPE_TB
- en: '| [REGCONFIG](#sqlalchemy.dialects.postgresql.REGCONFIG) | Provide the PostgreSQL
    REGCONFIG type. |'
  prefs: []
  type: TYPE_TB
- en: '| [TIME](#sqlalchemy.dialects.postgresql.TIME) | PostgreSQL TIME type. |'
  prefs: []
  type: TYPE_TB
- en: '| [TIMESTAMP](#sqlalchemy.dialects.postgresql.TIMESTAMP) | Provide the PostgreSQL
    TIMESTAMP type. |'
  prefs: []
  type: TYPE_TB
- en: '| [TSMULTIRANGE](#sqlalchemy.dialects.postgresql.TSMULTIRANGE) | Represent
    the PostgreSQL TSRANGE type. |'
  prefs: []
  type: TYPE_TB
- en: '| [TSQUERY](#sqlalchemy.dialects.postgresql.TSQUERY) | Provide the PostgreSQL
    TSQUERY type. |'
  prefs: []
  type: TYPE_TB
- en: '| [TSRANGE](#sqlalchemy.dialects.postgresql.TSRANGE) | Represent the PostgreSQL
    TSRANGE type. |'
  prefs: []
  type: TYPE_TB
- en: '| [TSTZMULTIRANGE](#sqlalchemy.dialects.postgresql.TSTZMULTIRANGE) | Represent
    the PostgreSQL TSTZRANGE type. |'
  prefs: []
  type: TYPE_TB
- en: '| [TSTZRANGE](#sqlalchemy.dialects.postgresql.TSTZRANGE) | Represent the PostgreSQL
    TSTZRANGE type. |'
  prefs: []
  type: TYPE_TB
- en: '| [TSVECTOR](#sqlalchemy.dialects.postgresql.TSVECTOR) | The [`TSVECTOR`](#sqlalchemy.dialects.postgresql.TSVECTOR
    "sqlalchemy.dialects.postgresql.TSVECTOR") type implements the PostgreSQL text
    search type TSVECTOR. |'
  prefs: []
  type: TYPE_TB
- en: '[PRE496]'
  prefs: []
  type: TYPE_PRE
- en: Base class for single and multi Range SQL types.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[adjacent_to()](#sqlalchemy.dialects.postgresql.AbstractRange.comparator_factory.adjacent_to),
    [contained_by()](#sqlalchemy.dialects.postgresql.AbstractRange.comparator_factory.contained_by),
    [contains()](#sqlalchemy.dialects.postgresql.AbstractRange.comparator_factory.contains),
    [difference()](#sqlalchemy.dialects.postgresql.AbstractRange.comparator_factory.difference),
    [intersection()](#sqlalchemy.dialects.postgresql.AbstractRange.comparator_factory.intersection),
    [not_extend_left_of()](#sqlalchemy.dialects.postgresql.AbstractRange.comparator_factory.not_extend_left_of),
    [not_extend_right_of()](#sqlalchemy.dialects.postgresql.AbstractRange.comparator_factory.not_extend_right_of),
    [overlaps()](#sqlalchemy.dialects.postgresql.AbstractRange.comparator_factory.overlaps),
    [strictly_left_of()](#sqlalchemy.dialects.postgresql.AbstractRange.comparator_factory.strictly_left_of),
    [strictly_right_of()](#sqlalchemy.dialects.postgresql.AbstractRange.comparator_factory.strictly_right_of),
    [union()](#sqlalchemy.dialects.postgresql.AbstractRange.comparator_factory.union)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.postgresql.AbstractRange`](#sqlalchemy.dialects.postgresql.AbstractRange
    "sqlalchemy.dialects.postgresql.AbstractRange") ([`sqlalchemy.types.TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE497]'
  prefs: []
  type: TYPE_PRE
- en: Define comparison operations for range types.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.postgresql.AbstractRange.comparator_factory`](#sqlalchemy.dialects.postgresql.AbstractRange.comparator_factory
    "sqlalchemy.dialects.postgresql.AbstractRange.comparator_factory") (`sqlalchemy.types.Comparator`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE498]'
  prefs: []
  type: TYPE_PRE
- en: Boolean expression. Returns true if the range in the column is adjacent to the
    range in the operand.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE499]'
  prefs: []
  type: TYPE_PRE
- en: Boolean expression. Returns true if the column is contained within the right
    hand operand.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE500]'
  prefs: []
  type: TYPE_PRE
- en: Boolean expression. Returns true if the right hand operand, which can be an
    element or a range, is contained within the column.
  prefs: []
  type: TYPE_NORMAL
- en: kwargs may be ignored by this operator but are required for API conformance.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE501]'
  prefs: []
  type: TYPE_PRE
- en: Range expression. Returns the union of the two ranges. Will raise an exception
    if the resulting range is not contiguous.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE502]'
  prefs: []
  type: TYPE_PRE
- en: Range expression. Returns the intersection of the two ranges. Will raise an
    exception if the resulting range is not contiguous.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE503]'
  prefs: []
  type: TYPE_PRE
- en: Boolean expression. Returns true if the range in the column does not extend
    left of the range in the operand.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE504]'
  prefs: []
  type: TYPE_PRE
- en: Boolean expression. Returns true if the range in the column does not extend
    right of the range in the operand.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE505]'
  prefs: []
  type: TYPE_PRE
- en: Boolean expression. Returns true if the column overlaps (has points in common
    with) the right hand operand.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE506]'
  prefs: []
  type: TYPE_PRE
- en: Boolean expression. Returns true if the column is strictly left of the right
    hand operand.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE507]'
  prefs: []
  type: TYPE_PRE
- en: Boolean expression. Returns true if the column is strictly right of the right
    hand operand.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE508]'
  prefs: []
  type: TYPE_PRE
- en: Range expression. Returns the union of the two ranges. Will raise an exception
    if the resulting range is not contiguous.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE509]'
  prefs: []
  type: TYPE_PRE
- en: Base for PostgreSQL RANGE types.
  prefs: []
  type: TYPE_NORMAL
- en: These are types that return a single [`Range`](#sqlalchemy.dialects.postgresql.Range
    "sqlalchemy.dialects.postgresql.Range") object.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[PostgreSQL range functions](https://www.postgresql.org/docs/current/static/functions-range.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.postgresql.AbstractSingleRange`](#sqlalchemy.dialects.postgresql.AbstractSingleRange
    "sqlalchemy.dialects.postgresql.AbstractSingleRange") ([`sqlalchemy.dialects.postgresql.ranges.AbstractRange`](#sqlalchemy.dialects.postgresql.AbstractRange
    "sqlalchemy.dialects.postgresql.ranges.AbstractRange"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE510]'
  prefs: []
  type: TYPE_PRE
- en: Base for PostgreSQL MULTIRANGE types.
  prefs: []
  type: TYPE_NORMAL
- en: these are types that return a sequence of [`Range`](#sqlalchemy.dialects.postgresql.Range
    "sqlalchemy.dialects.postgresql.Range") objects.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.postgresql.AbstractMultiRange`](#sqlalchemy.dialects.postgresql.AbstractMultiRange
    "sqlalchemy.dialects.postgresql.AbstractMultiRange") ([`sqlalchemy.dialects.postgresql.ranges.AbstractRange`](#sqlalchemy.dialects.postgresql.AbstractRange
    "sqlalchemy.dialects.postgresql.ranges.AbstractRange"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE511]'
  prefs: []
  type: TYPE_PRE
- en: PostgreSQL ARRAY type.
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`ARRAY`](#sqlalchemy.dialects.postgresql.ARRAY "sqlalchemy.dialects.postgresql.ARRAY")
    type is constructed in the same way as the core [`ARRAY`](../core/type_basics.html#sqlalchemy.types.ARRAY
    "sqlalchemy.types.ARRAY") type; a member type is required, and a number of dimensions
    is recommended if the type is to be used for more than one dimension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE512]'
  prefs: []
  type: TYPE_PRE
- en: 'The [`ARRAY`](#sqlalchemy.dialects.postgresql.ARRAY "sqlalchemy.dialects.postgresql.ARRAY")
    type provides all operations defined on the core [`ARRAY`](../core/type_basics.html#sqlalchemy.types.ARRAY
    "sqlalchemy.types.ARRAY") type, including support for “dimensions”, indexed access,
    and simple matching such as [`Comparator.any()`](../core/type_basics.html#sqlalchemy.types.ARRAY.Comparator.any
    "sqlalchemy.types.ARRAY.Comparator.any") and [`Comparator.all()`](../core/type_basics.html#sqlalchemy.types.ARRAY.Comparator.all
    "sqlalchemy.types.ARRAY.Comparator.all"). [`ARRAY`](#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY") class also provides PostgreSQL-specific
    methods for containment operations, including [`Comparator.contains()`](#sqlalchemy.dialects.postgresql.ARRAY.Comparator.contains
    "sqlalchemy.dialects.postgresql.ARRAY.Comparator.contains") [`Comparator.contained_by()`](#sqlalchemy.dialects.postgresql.ARRAY.Comparator.contained_by
    "sqlalchemy.dialects.postgresql.ARRAY.Comparator.contained_by"), and [`Comparator.overlap()`](#sqlalchemy.dialects.postgresql.ARRAY.Comparator.overlap
    "sqlalchemy.dialects.postgresql.ARRAY.Comparator.overlap"), e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE513]'
  prefs: []
  type: TYPE_PRE
- en: Indexed access is one-based by default, to match that of PostgreSQL; for zero-based
    indexed access, set [`ARRAY.zero_indexes`](#sqlalchemy.dialects.postgresql.ARRAY.params.zero_indexes
    "sqlalchemy.dialects.postgresql.ARRAY").
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, the [`ARRAY`](#sqlalchemy.dialects.postgresql.ARRAY "sqlalchemy.dialects.postgresql.ARRAY")
    type does not work directly in conjunction with the [`ENUM`](#sqlalchemy.dialects.postgresql.ENUM
    "sqlalchemy.dialects.postgresql.ENUM") type. For a workaround, see the special
    type at [Using ENUM with ARRAY](#postgresql-array-of-enum).
  prefs: []
  type: TYPE_NORMAL
- en: '**Detecting Changes in ARRAY columns when using the ORM**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`ARRAY`](#sqlalchemy.dialects.postgresql.ARRAY "sqlalchemy.dialects.postgresql.ARRAY")
    type, when used with the SQLAlchemy ORM, does not detect in-place mutations to
    the array. In order to detect these, the [`sqlalchemy.ext.mutable`](../orm/extensions/mutable.html#module-sqlalchemy.ext.mutable
    "sqlalchemy.ext.mutable") extension must be used, using the [`MutableList`](../orm/extensions/mutable.html#sqlalchemy.ext.mutable.MutableList
    "sqlalchemy.ext.mutable.MutableList") class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE514]'
  prefs: []
  type: TYPE_PRE
- en: This extension will allow “in-place” changes such to the array such as `.append()`
    to produce events which will be detected by the unit of work. Note that changes
    to elements **inside** the array, including subarrays that are mutated in place,
    are **not** detected.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, assigning a new array value to an ORM element that replaces the
    old one will always trigger a change event.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`ARRAY`](../core/type_basics.html#sqlalchemy.types.ARRAY "sqlalchemy.types.ARRAY")
    - base array type'
  prefs: []
  type: TYPE_NORMAL
- en: '[`array`](#sqlalchemy.dialects.postgresql.array "sqlalchemy.dialects.postgresql.array")
    - produces a literal array value.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.dialects.postgresql.ARRAY.__init__), [contains()](#sqlalchemy.dialects.postgresql.ARRAY.Comparator.contains),
    [contained_by()](#sqlalchemy.dialects.postgresql.ARRAY.Comparator.contained_by),
    [overlap()](#sqlalchemy.dialects.postgresql.ARRAY.Comparator.overlap)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.postgresql.ARRAY`](#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY") ([`sqlalchemy.types.ARRAY`](../core/type_basics.html#sqlalchemy.types.ARRAY
    "sqlalchemy.types.ARRAY"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE515]'
  prefs: []
  type: TYPE_PRE
- en: Construct an ARRAY.
  prefs: []
  type: TYPE_NORMAL
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE516]'
  prefs: []
  type: TYPE_PRE
- en: 'Arguments are:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`item_type` – The data type of items of this array. Note that dimensionality
    is irrelevant here, so multi-dimensional arrays like `INTEGER[][]`, are constructed
    as `ARRAY(Integer)`, not as `ARRAY(ARRAY(Integer))` or such.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`as_tuple=False` – Specify whether return results should be converted to tuples
    from lists. DBAPIs such as psycopg2 return lists by default. When tuples are returned,
    the results are hashable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dimensions` – if non-None, the ARRAY will assume a fixed number of dimensions.
    This will cause the DDL emitted for this ARRAY to include the exact number of
    bracket clauses `[]`, and will also optimize the performance of the type overall.
    Note that PG arrays are always implicitly “non-dimensioned”, meaning they can
    store any number of dimensions no matter how they were declared.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`zero_indexes=False` – when True, index values will be converted between Python
    zero-based and PostgreSQL one-based indexes, e.g. a value of one will be added
    to all index values before passing to the database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE517]'
  prefs: []
  type: TYPE_PRE
- en: Define comparison operations for [`ARRAY`](../core/type_basics.html#sqlalchemy.types.ARRAY
    "sqlalchemy.types.ARRAY").
  prefs: []
  type: TYPE_NORMAL
- en: Note that these operations are in addition to those provided by the base [`Comparator`](../core/type_basics.html#sqlalchemy.types.ARRAY.Comparator
    "sqlalchemy.types.ARRAY.Comparator") class, including [`Comparator.any()`](../core/type_basics.html#sqlalchemy.types.ARRAY.Comparator.any
    "sqlalchemy.types.ARRAY.Comparator.any") and [`Comparator.all()`](../core/type_basics.html#sqlalchemy.types.ARRAY.Comparator.all
    "sqlalchemy.types.ARRAY.Comparator.all").
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.postgresql.ARRAY.Comparator`](#sqlalchemy.dialects.postgresql.ARRAY.Comparator
    "sqlalchemy.dialects.postgresql.ARRAY.Comparator") (`sqlalchemy.types.Comparator`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE518]'
  prefs: []
  type: TYPE_PRE
- en: Boolean expression. Test if elements are a superset of the elements of the argument
    array expression.
  prefs: []
  type: TYPE_NORMAL
- en: kwargs may be ignored by this operator but are required for API conformance.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE519]'
  prefs: []
  type: TYPE_PRE
- en: Boolean expression. Test if elements are a proper subset of the elements of
    the argument array expression.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE520]'
  prefs: []
  type: TYPE_PRE
- en: Boolean expression. Test if array has elements in common with an argument array
    expression.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE521]'
  prefs: []
  type: TYPE_PRE
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.postgresql.BIT`](#sqlalchemy.dialects.postgresql.BIT
    "sqlalchemy.dialects.postgresql.BIT") ([`sqlalchemy.types.TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE522]'
  prefs: []
  type: TYPE_PRE
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.dialects.postgresql.BYTEA.__init__)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.postgresql.BYTEA`](#sqlalchemy.dialects.postgresql.BYTEA
    "sqlalchemy.dialects.postgresql.BYTEA") ([`sqlalchemy.types.LargeBinary`](../core/type_basics.html#sqlalchemy.types.LargeBinary
    "sqlalchemy.types.LargeBinary"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE523]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `sqlalchemy.types.LargeBinary.__init__` *method of* [`LargeBinary`](../core/type_basics.html#sqlalchemy.types.LargeBinary
    "sqlalchemy.types.LargeBinary")'
  prefs: []
  type: TYPE_NORMAL
- en: Construct a LargeBinary type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**length** – optional, a length for the column for use in DDL statements, for
    those binary types that accept a length, such as the MySQL BLOB type.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE524]'
  prefs: []
  type: TYPE_PRE
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.postgresql.CIDR`](#sqlalchemy.dialects.postgresql.CIDR
    "sqlalchemy.dialects.postgresql.CIDR") ([`sqlalchemy.types.TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE525]'
  prefs: []
  type: TYPE_PRE
- en: Provide the PostgreSQL CITEXT type.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.7.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.dialects.postgresql.CITEXT.__init__)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.postgresql.CITEXT`](#sqlalchemy.dialects.postgresql.CITEXT
    "sqlalchemy.dialects.postgresql.CITEXT") ([`sqlalchemy.types.TEXT`](../core/type_basics.html#sqlalchemy.types.TEXT
    "sqlalchemy.types.TEXT"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE526]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `sqlalchemy.types.String.__init__` *method of* [`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String")'
  prefs: []
  type: TYPE_NORMAL
- en: Create a string-holding type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`length` – optional, a length for the column for use in DDL and CAST expressions.
    May be safely omitted if no `CREATE TABLE` will be issued. Certain databases may
    require a `length` for use in DDL, and will raise an exception when the `CREATE
    TABLE` DDL is issued if a `VARCHAR` with no length is included. Whether the value
    is interpreted as bytes or characters is database specific.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`collation` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Optional, a column-level collation for use in DDL and CAST expressions. Renders
    using the COLLATE keyword supported by SQLite, MySQL, and PostgreSQL. E.g.:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE527]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In most cases, the [`Unicode`](../core/type_basics.html#sqlalchemy.types.Unicode
    "sqlalchemy.types.Unicode") or [`UnicodeText`](../core/type_basics.html#sqlalchemy.types.UnicodeText
    "sqlalchemy.types.UnicodeText") datatypes should be used for a [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") that expects to store non-ascii data. These datatypes
    will ensure that the correct types are used on the database.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE528]'
  prefs: []
  type: TYPE_PRE
- en: Represent the DOMAIN PostgreSQL type.
  prefs: []
  type: TYPE_NORMAL
- en: 'A domain is essentially a data type with optional constraints that restrict
    the allowed set of values. E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE529]'
  prefs: []
  type: TYPE_PRE
- en: See the [PostgreSQL documentation](https://www.postgresql.org/docs/current/sql-createdomain.html)
    for additional details
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.dialects.postgresql.DOMAIN.__init__), [create()](#sqlalchemy.dialects.postgresql.DOMAIN.create),
    [drop()](#sqlalchemy.dialects.postgresql.DOMAIN.drop)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.postgresql.DOMAIN`](#sqlalchemy.dialects.postgresql.DOMAIN
    "sqlalchemy.dialects.postgresql.DOMAIN") (`sqlalchemy.dialects.postgresql.named_types.NamedType`,
    [`sqlalchemy.types.SchemaType`](../core/type_basics.html#sqlalchemy.types.SchemaType
    "sqlalchemy.types.SchemaType"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE530]'
  prefs: []
  type: TYPE_PRE
- en: Construct a DOMAIN.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`name` – the name of the domain'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`data_type` – The underlying data type of the domain. This can include array
    specifiers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`collation` – An optional collation for the domain. If no collation is specified,
    the underlying data type’s default collation is used. The underlying type must
    be collatable if `collation` is specified.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`default` – The DEFAULT clause specifies a default value for columns of the
    domain data type. The default should be a string or a [`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text
    "sqlalchemy.sql.expression.text") value. If no default value is specified, then
    the default value is the null value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`constraint_name` – An optional name for a constraint. If not specified, the
    backend generates a name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`not_null` – Values of this domain are prevented from being null. By default
    domain are allowed to be null. If not specified no nullability clause will be
    emitted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`check` – CHECK clause specify integrity constraint or test which values of
    the domain must satisfy. A constraint must be an expression producing a Boolean
    result that can use the key word VALUE to refer to the value being tested. Differently
    from PostgreSQL, only a single check clause is currently allowed in SQLAlchemy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`schema` – optional schema name'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`metadata` – optional [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") object which this [`DOMAIN`](#sqlalchemy.dialects.postgresql.DOMAIN
    "sqlalchemy.dialects.postgresql.DOMAIN") will be directly associated'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`create_type` – Defaults to True. Indicates that `CREATE TYPE` should be emitted,
    after optionally checking for the presence of the type, when the parent table
    is being created; and additionally that `DROP TYPE` is called when the table is
    dropped.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE531]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `NamedType.create()` *method of* `NamedType`'
  prefs: []
  type: TYPE_NORMAL
- en: Emit `CREATE` DDL for this type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`bind` – a connectable [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine"), [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection"), or similar object to emit SQL.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`checkfirst` – if `True`, a query against the PG catalog will be first performed
    to see if the type does not exist already before creating.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE532]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `NamedType.drop()` *method of* `NamedType`'
  prefs: []
  type: TYPE_NORMAL
- en: Emit `DROP` DDL for this type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`bind` – a connectable [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine"), [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection"), or similar object to emit SQL.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`checkfirst` – if `True`, a query against the PG catalog will be first performed
    to see if the type actually exists before dropping.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE533]'
  prefs: []
  type: TYPE_PRE
- en: The SQL DOUBLE PRECISION type.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Double`](../core/type_basics.html#sqlalchemy.types.Double "sqlalchemy.types.Double")
    - documentation for the base type.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class `sqlalchemy.dialects.postgresql.DOUBLE_PRECISION` ([`sqlalchemy.types.Double`](../core/type_basics.html#sqlalchemy.types.Double
    "sqlalchemy.types.Double"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE534]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `sqlalchemy.types.Float.__init__` *method of* [`Float`](../core/type_basics.html#sqlalchemy.types.Float
    "sqlalchemy.types.Float")'
  prefs: []
  type: TYPE_NORMAL
- en: Construct a Float.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`precision` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the numeric precision for use in DDL `CREATE TABLE`. Backends **should** attempt
    to ensure this precision indicates a number of digits for the generic [`Float`](../core/type_basics.html#sqlalchemy.types.Float
    "sqlalchemy.types.Float") datatype.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For the Oracle backend, the [`Float.precision`](../core/type_basics.html#sqlalchemy.types.Float.params.precision
    "sqlalchemy.types.Float") parameter is not accepted when rendering DDL, as Oracle
    does not support float precision specified as a number of decimal places. Instead,
    use the Oracle-specific [`FLOAT`](oracle.html#sqlalchemy.dialects.oracle.FLOAT
    "sqlalchemy.dialects.oracle.FLOAT") datatype and specify the [`FLOAT.binary_precision`](oracle.html#sqlalchemy.dialects.oracle.FLOAT.params.binary_precision
    "sqlalchemy.dialects.oracle.FLOAT") parameter. This is new in version 2.0 of SQLAlchemy.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To create a database agnostic [`Float`](../core/type_basics.html#sqlalchemy.types.Float
    "sqlalchemy.types.Float") that separately specifies binary precision for Oracle,
    use [`TypeEngine.with_variant()`](../core/type_api.html#sqlalchemy.types.TypeEngine.with_variant
    "sqlalchemy.types.TypeEngine.with_variant") as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE535]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`asdecimal` – the same flag as that of [`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric
    "sqlalchemy.types.Numeric"), but defaults to `False`. Note that setting this flag
    to `True` results in floating point conversion.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`decimal_return_scale` – Default scale to use when converting from floats to
    Python decimals. Floating point values will typically be much longer due to decimal
    inaccuracy, and most floating point database types don’t have a notion of “scale”,
    so by default the float type looks for the first ten decimal places when converting.
    Specifying this value will override that length. Note that the MySQL float types,
    which do include “scale”, will use “scale” as the default for decimal_return_scale,
    if not otherwise specified.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE536]'
  prefs: []
  type: TYPE_PRE
- en: PostgreSQL ENUM type.
  prefs: []
  type: TYPE_NORMAL
- en: This is a subclass of [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum") which includes support for PG’s `CREATE TYPE` and `DROP
    TYPE`.
  prefs: []
  type: TYPE_NORMAL
- en: When the builtin type [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum") is used and the [`Enum.native_enum`](../core/type_basics.html#sqlalchemy.types.Enum.params.native_enum
    "sqlalchemy.types.Enum") flag is left at its default of True, the PostgreSQL backend
    will use a [`ENUM`](#sqlalchemy.dialects.postgresql.ENUM "sqlalchemy.dialects.postgresql.ENUM")
    type as the implementation, so the special create/drop rules will be used.
  prefs: []
  type: TYPE_NORMAL
- en: The create/drop behavior of ENUM is necessarily intricate, due to the awkward
    relationship the ENUM type has in relationship to the parent table, in that it
    may be “owned” by just a single table, or may be shared among many tables.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.types.Enum")
    or [`ENUM`](#sqlalchemy.dialects.postgresql.ENUM "sqlalchemy.dialects.postgresql.ENUM")
    in an “inline” fashion, the `CREATE TYPE` and `DROP TYPE` is emitted corresponding
    to when the [`Table.create()`](../core/metadata.html#sqlalchemy.schema.Table.create
    "sqlalchemy.schema.Table.create") and [`Table.drop()`](../core/metadata.html#sqlalchemy.schema.Table.drop
    "sqlalchemy.schema.Table.drop") methods are called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE537]'
  prefs: []
  type: TYPE_PRE
- en: 'To use a common enumerated type between multiple tables, the best practice
    is to declare the [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.types.Enum")
    or [`ENUM`](#sqlalchemy.dialects.postgresql.ENUM "sqlalchemy.dialects.postgresql.ENUM")
    independently, and associate it with the [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") object itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE538]'
  prefs: []
  type: TYPE_PRE
- en: 'When this pattern is used, care must still be taken at the level of individual
    table creates. Emitting CREATE TABLE without also specifying `checkfirst=True`
    will still cause issues:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE539]'
  prefs: []
  type: TYPE_PRE
- en: 'If we specify `checkfirst=True`, the individual table-level create operation
    will check for the `ENUM` and create if not exists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE540]'
  prefs: []
  type: TYPE_PRE
- en: 'When using a metadata-level ENUM type, the type will always be created and
    dropped if either the metadata-wide create/drop is called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE541]'
  prefs: []
  type: TYPE_PRE
- en: 'The type can also be created and dropped directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE542]'
  prefs: []
  type: TYPE_PRE
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.dialects.postgresql.ENUM.__init__), [create()](#sqlalchemy.dialects.postgresql.ENUM.create),
    [drop()](#sqlalchemy.dialects.postgresql.ENUM.drop)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.postgresql.ENUM`](#sqlalchemy.dialects.postgresql.ENUM
    "sqlalchemy.dialects.postgresql.ENUM") (`sqlalchemy.dialects.postgresql.named_types.NamedType`,
    `sqlalchemy.types.NativeForEmulated`, [`sqlalchemy.types.Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE543]'
  prefs: []
  type: TYPE_PRE
- en: Construct an [`ENUM`](#sqlalchemy.dialects.postgresql.ENUM "sqlalchemy.dialects.postgresql.ENUM").
  prefs: []
  type: TYPE_NORMAL
- en: Arguments are the same as that of [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum"), but also including the following parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**create_type** – Defaults to True. Indicates that `CREATE TYPE` should be
    emitted, after optionally checking for the presence of the type, when the parent
    table is being created; and additionally that `DROP TYPE` is called when the table
    is dropped. When `False`, no check will be performed and no `CREATE TYPE` or `DROP
    TYPE` is emitted, unless [`ENUM.create()`](#sqlalchemy.dialects.postgresql.ENUM.create
    "sqlalchemy.dialects.postgresql.ENUM.create") or [`ENUM.drop()`](#sqlalchemy.dialects.postgresql.ENUM.drop
    "sqlalchemy.dialects.postgresql.ENUM.drop") are called directly. Setting to `False`
    is helpful when invoking a creation scheme to a SQL file without access to the
    actual database - the [`ENUM.create()`](#sqlalchemy.dialects.postgresql.ENUM.create
    "sqlalchemy.dialects.postgresql.ENUM.create") and [`ENUM.drop()`](#sqlalchemy.dialects.postgresql.ENUM.drop
    "sqlalchemy.dialects.postgresql.ENUM.drop") methods can be used to emit SQL to
    a target bind.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE544]'
  prefs: []
  type: TYPE_PRE
- en: Emit `CREATE TYPE` for this [`ENUM`](#sqlalchemy.dialects.postgresql.ENUM "sqlalchemy.dialects.postgresql.ENUM").
  prefs: []
  type: TYPE_NORMAL
- en: If the underlying dialect does not support PostgreSQL CREATE TYPE, no action
    is taken.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`bind` – a connectable [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine"), [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection"), or similar object to emit SQL.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`checkfirst` – if `True`, a query against the PG catalog will be first performed
    to see if the type does not exist already before creating.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE545]'
  prefs: []
  type: TYPE_PRE
- en: Emit `DROP TYPE` for this [`ENUM`](#sqlalchemy.dialects.postgresql.ENUM "sqlalchemy.dialects.postgresql.ENUM").
  prefs: []
  type: TYPE_NORMAL
- en: If the underlying dialect does not support PostgreSQL DROP TYPE, no action is
    taken.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`bind` – a connectable [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine"), [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection"), or similar object to emit SQL.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`checkfirst` – if `True`, a query against the PG catalog will be first performed
    to see if the type actually exists before dropping.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE546]'
  prefs: []
  type: TYPE_PRE
- en: Represent the PostgreSQL HSTORE type.
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`HSTORE`](#sqlalchemy.dialects.postgresql.HSTORE "sqlalchemy.dialects.postgresql.HSTORE")
    type stores dictionaries containing strings, e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE547]'
  prefs: []
  type: TYPE_PRE
- en: '[`HSTORE`](#sqlalchemy.dialects.postgresql.HSTORE "sqlalchemy.dialects.postgresql.HSTORE")
    provides for a wide range of operations, including:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Index operations:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE548]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Containment operations:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE549]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Concatenation:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE550]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: For a full list of special methods see `comparator_factory`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Detecting Changes in HSTORE columns when using the ORM**'
  prefs: []
  type: TYPE_NORMAL
- en: 'For usage with the SQLAlchemy ORM, it may be desirable to combine the usage
    of [`HSTORE`](#sqlalchemy.dialects.postgresql.HSTORE "sqlalchemy.dialects.postgresql.HSTORE")
    with [`MutableDict`](../orm/extensions/mutable.html#sqlalchemy.ext.mutable.MutableDict
    "sqlalchemy.ext.mutable.MutableDict") dictionary now part of the [`sqlalchemy.ext.mutable`](../orm/extensions/mutable.html#module-sqlalchemy.ext.mutable
    "sqlalchemy.ext.mutable") extension. This extension will allow “in-place” changes
    to the dictionary, e.g. addition of new keys or replacement/removal of existing
    keys to/from the current dictionary, to produce events which will be detected
    by the unit of work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE551]'
  prefs: []
  type: TYPE_PRE
- en: When the [`sqlalchemy.ext.mutable`](../orm/extensions/mutable.html#module-sqlalchemy.ext.mutable
    "sqlalchemy.ext.mutable") extension is not used, the ORM will not be alerted to
    any changes to the contents of an existing dictionary, unless that dictionary
    value is re-assigned to the HSTORE-attribute itself, thus generating a change
    event.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`hstore`](#sqlalchemy.dialects.postgresql.hstore "sqlalchemy.dialects.postgresql.hstore")
    - render the PostgreSQL `hstore()` function.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[array()](#sqlalchemy.dialects.postgresql.HSTORE.Comparator.array), [contained_by()](#sqlalchemy.dialects.postgresql.HSTORE.Comparator.contained_by),
    [contains()](#sqlalchemy.dialects.postgresql.HSTORE.Comparator.contains), [defined()](#sqlalchemy.dialects.postgresql.HSTORE.Comparator.defined),
    [delete()](#sqlalchemy.dialects.postgresql.HSTORE.Comparator.delete), [has_all()](#sqlalchemy.dialects.postgresql.HSTORE.Comparator.has_all),
    [has_any()](#sqlalchemy.dialects.postgresql.HSTORE.Comparator.has_any), [has_key()](#sqlalchemy.dialects.postgresql.HSTORE.Comparator.has_key),
    [keys()](#sqlalchemy.dialects.postgresql.HSTORE.Comparator.keys), [matrix()](#sqlalchemy.dialects.postgresql.HSTORE.Comparator.matrix),
    [slice()](#sqlalchemy.dialects.postgresql.HSTORE.Comparator.slice), [vals()](#sqlalchemy.dialects.postgresql.HSTORE.Comparator.vals),
    [__init__()](#sqlalchemy.dialects.postgresql.HSTORE.__init__), [bind_processor()](#sqlalchemy.dialects.postgresql.HSTORE.bind_processor),
    [comparator_factory](#sqlalchemy.dialects.postgresql.HSTORE.comparator_factory),
    [hashable](#sqlalchemy.dialects.postgresql.HSTORE.hashable), [result_processor()](#sqlalchemy.dialects.postgresql.HSTORE.result_processor)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.postgresql.HSTORE`](#sqlalchemy.dialects.postgresql.HSTORE
    "sqlalchemy.dialects.postgresql.HSTORE") ([`sqlalchemy.types.Indexable`](../core/type_api.html#sqlalchemy.types.Indexable
    "sqlalchemy.types.Indexable"), [`sqlalchemy.types.Concatenable`](../core/type_api.html#sqlalchemy.types.Concatenable
    "sqlalchemy.types.Concatenable"), [`sqlalchemy.types.TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE552]'
  prefs: []
  type: TYPE_PRE
- en: Define comparison operations for [`HSTORE`](#sqlalchemy.dialects.postgresql.HSTORE
    "sqlalchemy.dialects.postgresql.HSTORE").
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.postgresql.HSTORE.Comparator`](#sqlalchemy.dialects.postgresql.HSTORE.Comparator
    "sqlalchemy.dialects.postgresql.HSTORE.Comparator") (`sqlalchemy.types.Comparator`,
    `sqlalchemy.types.Comparator`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE553]'
  prefs: []
  type: TYPE_PRE
- en: Text array expression. Returns array of alternating keys and values.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE554]'
  prefs: []
  type: TYPE_PRE
- en: Boolean expression. Test if keys are a proper subset of the keys of the argument
    jsonb expression.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE555]'
  prefs: []
  type: TYPE_PRE
- en: Boolean expression. Test if keys (or array) are a superset of/contained the
    keys of the argument jsonb expression.
  prefs: []
  type: TYPE_NORMAL
- en: kwargs may be ignored by this operator but are required for API conformance.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE556]'
  prefs: []
  type: TYPE_PRE
- en: Boolean expression. Test for presence of a non-NULL value for the key. Note
    that the key may be a SQLA expression.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE557]'
  prefs: []
  type: TYPE_PRE
- en: HStore expression. Returns the contents of this hstore with the given key deleted.
    Note that the key may be a SQLA expression.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE558]'
  prefs: []
  type: TYPE_PRE
- en: Boolean expression. Test for presence of all keys in jsonb
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE559]'
  prefs: []
  type: TYPE_PRE
- en: Boolean expression. Test for presence of any key in jsonb
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE560]'
  prefs: []
  type: TYPE_PRE
- en: Boolean expression. Test for presence of a key. Note that the key may be a SQLA
    expression.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE561]'
  prefs: []
  type: TYPE_PRE
- en: Text array expression. Returns array of keys.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE562]'
  prefs: []
  type: TYPE_PRE
- en: Text array expression. Returns array of [key, value] pairs.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE563]'
  prefs: []
  type: TYPE_PRE
- en: HStore expression. Returns a subset of an hstore defined by array of keys.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE564]'
  prefs: []
  type: TYPE_PRE
- en: Text array expression. Returns array of values.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE565]'
  prefs: []
  type: TYPE_PRE
- en: Construct a new [`HSTORE`](#sqlalchemy.dialects.postgresql.HSTORE "sqlalchemy.dialects.postgresql.HSTORE").
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**text_type** – the type that should be used for indexed values. Defaults to
    [`Text`](../core/type_basics.html#sqlalchemy.types.Text "sqlalchemy.types.Text").'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE566]'
  prefs: []
  type: TYPE_PRE
- en: Return a conversion function for processing bind values.
  prefs: []
  type: TYPE_NORMAL
- en: Returns a callable which will receive a bind parameter value as the sole positional
    argument and will return a value to send to the DB-API.
  prefs: []
  type: TYPE_NORMAL
- en: If processing is not necessary, the method should return `None`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This method is only called relative to a **dialect specific type object**, which
    is often **private to a dialect in use** and is not the same type object as the
    public facing one, which means it’s not feasible to subclass a [`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") class in order to provide an alternate [`TypeEngine.bind_processor()`](../core/type_api.html#sqlalchemy.types.TypeEngine.bind_processor
    "sqlalchemy.types.TypeEngine.bind_processor") method, unless subclassing the [`UserDefinedType`](../core/custom_types.html#sqlalchemy.types.UserDefinedType
    "sqlalchemy.types.UserDefinedType") class explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: To provide alternate behavior for [`TypeEngine.bind_processor()`](../core/type_api.html#sqlalchemy.types.TypeEngine.bind_processor
    "sqlalchemy.types.TypeEngine.bind_processor"), implement a [`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") class and provide an implementation of [`TypeDecorator.process_bind_param()`](../core/custom_types.html#sqlalchemy.types.TypeDecorator.process_bind_param
    "sqlalchemy.types.TypeDecorator.process_bind_param").
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Augmenting Existing Types](../core/custom_types.html#types-typedecorator)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**dialect** – Dialect instance in use.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE567]'
  prefs: []
  type: TYPE_PRE
- en: alias of [`Comparator`](#sqlalchemy.dialects.postgresql.HSTORE.Comparator "sqlalchemy.dialects.postgresql.hstore.HSTORE.Comparator")
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE568]'
  prefs: []
  type: TYPE_PRE
- en: Flag, if False, means values from this type aren’t hashable.
  prefs: []
  type: TYPE_NORMAL
- en: Used by the ORM when uniquing result lists.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE569]'
  prefs: []
  type: TYPE_PRE
- en: Return a conversion function for processing result row values.
  prefs: []
  type: TYPE_NORMAL
- en: Returns a callable which will receive a result row column value as the sole
    positional argument and will return a value to return to the user.
  prefs: []
  type: TYPE_NORMAL
- en: If processing is not necessary, the method should return `None`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This method is only called relative to a **dialect specific type object**, which
    is often **private to a dialect in use** and is not the same type object as the
    public facing one, which means it’s not feasible to subclass a [`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") class in order to provide an alternate [`TypeEngine.result_processor()`](../core/type_api.html#sqlalchemy.types.TypeEngine.result_processor
    "sqlalchemy.types.TypeEngine.result_processor") method, unless subclassing the
    [`UserDefinedType`](../core/custom_types.html#sqlalchemy.types.UserDefinedType
    "sqlalchemy.types.UserDefinedType") class explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: To provide alternate behavior for [`TypeEngine.result_processor()`](../core/type_api.html#sqlalchemy.types.TypeEngine.result_processor
    "sqlalchemy.types.TypeEngine.result_processor"), implement a [`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") class and provide an implementation of [`TypeDecorator.process_result_value()`](../core/custom_types.html#sqlalchemy.types.TypeDecorator.process_result_value
    "sqlalchemy.types.TypeDecorator.process_result_value").
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Augmenting Existing Types](../core/custom_types.html#types-typedecorator)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dialect` – Dialect instance in use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`coltype` – DBAPI coltype argument received in cursor.description.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE570]'
  prefs: []
  type: TYPE_PRE
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.postgresql.INET`](#sqlalchemy.dialects.postgresql.INET
    "sqlalchemy.dialects.postgresql.INET") ([`sqlalchemy.types.TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE571]'
  prefs: []
  type: TYPE_PRE
- en: PostgreSQL INTERVAL type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.dialects.postgresql.INTERVAL.__init__)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.postgresql.INTERVAL`](#sqlalchemy.dialects.postgresql.INTERVAL
    "sqlalchemy.dialects.postgresql.INTERVAL") (`sqlalchemy.types.NativeForEmulated`,
    `sqlalchemy.types._AbstractInterval`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE572]'
  prefs: []
  type: TYPE_PRE
- en: Construct an INTERVAL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`precision` – optional integer precision value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fields` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: string fields specifier. allows storage of fields to be limited, such as `"YEAR"`,
    `"MONTH"`, `"DAY TO HOUR"`, etc.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: New in version 1.2.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE573]'
  prefs: []
  type: TYPE_PRE
- en: Represent the PostgreSQL JSON type.
  prefs: []
  type: TYPE_NORMAL
- en: '[`JSON`](#sqlalchemy.dialects.postgresql.JSON "sqlalchemy.dialects.postgresql.JSON")
    is used automatically whenever the base [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON") datatype is used against a PostgreSQL backend, however
    base [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON")
    datatype does not provide Python accessors for PostgreSQL-specific comparison
    methods such as [`Comparator.astext()`](#sqlalchemy.dialects.postgresql.JSON.Comparator.astext
    "sqlalchemy.dialects.postgresql.JSON.Comparator.astext"); additionally, to use
    PostgreSQL `JSONB`, the [`JSONB`](#sqlalchemy.dialects.postgresql.JSONB "sqlalchemy.dialects.postgresql.JSONB")
    datatype should be used explicitly.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON")
    - main documentation for the generic cross-platform JSON datatype.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The operators provided by the PostgreSQL version of [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON") include:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Index operations (the `->` operator):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE574]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Index operations returning text (the `->>` operator):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE575]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that equivalent functionality is available via the [`Comparator.as_string`](../core/type_basics.html#sqlalchemy.types.JSON.Comparator.as_string
    "sqlalchemy.types.JSON.Comparator.as_string") accessor.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Index operations with CAST (equivalent to `CAST(col ->> [''some key''] AS <type>)`):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE576]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that equivalent functionality is available via the [`Comparator.as_integer`](../core/type_basics.html#sqlalchemy.types.JSON.Comparator.as_integer
    "sqlalchemy.types.JSON.Comparator.as_integer") and similar accessors.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Path index operations (the `#>` operator):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE577]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Path index operations returning text (the `#>>` operator):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE578]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Index operations return an expression object whose type defaults to [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON") by default, so that further JSON-oriented instructions
    may be called upon the result type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Custom serializers and deserializers are specified at the dialect level, that
    is using [`create_engine()`](../core/engines.html#sqlalchemy.create_engine "sqlalchemy.create_engine").
    The reason for this is that when using psycopg2, the DBAPI only allows serializers
    at the per-cursor or per-connection level. E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE579]'
  prefs: []
  type: TYPE_PRE
- en: When using the psycopg2 dialect, the json_deserializer is registered against
    the database using `psycopg2.extras.register_default_json`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON")
    - Core level JSON type'
  prefs: []
  type: TYPE_NORMAL
- en: '[`JSONB`](#sqlalchemy.dialects.postgresql.JSONB "sqlalchemy.dialects.postgresql.JSONB")'
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[astext](#sqlalchemy.dialects.postgresql.JSON.Comparator.astext), [__init__()](#sqlalchemy.dialects.postgresql.JSON.__init__),
    [comparator_factory](#sqlalchemy.dialects.postgresql.JSON.comparator_factory)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.postgresql.JSON`](#sqlalchemy.dialects.postgresql.JSON
    "sqlalchemy.dialects.postgresql.JSON") ([`sqlalchemy.types.JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE580]'
  prefs: []
  type: TYPE_PRE
- en: Define comparison operations for [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON").
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.postgresql.JSON.Comparator`](#sqlalchemy.dialects.postgresql.JSON.Comparator
    "sqlalchemy.dialects.postgresql.JSON.Comparator") (`sqlalchemy.types.Comparator`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE581]'
  prefs: []
  type: TYPE_PRE
- en: On an indexed expression, use the “astext” (e.g. “->>”) conversion when rendered
    in SQL.
  prefs: []
  type: TYPE_NORMAL
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE582]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnElement.cast()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnElement.cast
    "sqlalchemy.sql.expression.ColumnElement.cast")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE583]'
  prefs: []
  type: TYPE_PRE
- en: Construct a [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON")
    type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`none_as_null` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'if True, persist the value `None` as a SQL NULL value, not the JSON encoding
    of `null`. Note that when this flag is False, the [`null()`](../core/sqlelement.html#sqlalchemy.sql.expression.null
    "sqlalchemy.sql.expression.null") construct can still be used to persist a NULL
    value:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE584]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`JSON.NULL`](../core/type_basics.html#sqlalchemy.types.JSON.NULL "sqlalchemy.types.JSON.NULL")'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`astext_type` – the type to use for the [`Comparator.astext`](#sqlalchemy.dialects.postgresql.JSON.Comparator.astext
    "sqlalchemy.dialects.postgresql.JSON.Comparator.astext") accessor on indexed attributes.
    Defaults to [`Text`](../core/type_basics.html#sqlalchemy.types.Text "sqlalchemy.types.Text").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE585]'
  prefs: []
  type: TYPE_PRE
- en: alias of [`Comparator`](#sqlalchemy.dialects.postgresql.JSON.Comparator "sqlalchemy.dialects.postgresql.json.JSON.Comparator")
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE586]'
  prefs: []
  type: TYPE_PRE
- en: Represent the PostgreSQL JSONB type.
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`JSONB`](#sqlalchemy.dialects.postgresql.JSONB "sqlalchemy.dialects.postgresql.JSONB")
    type stores arbitrary JSONB format data, e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE587]'
  prefs: []
  type: TYPE_PRE
- en: The [`JSONB`](#sqlalchemy.dialects.postgresql.JSONB "sqlalchemy.dialects.postgresql.JSONB")
    type includes all operations provided by [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON"), including the same behaviors for indexing operations.
    It also adds additional operators specific to JSONB, including [`Comparator.has_key()`](#sqlalchemy.dialects.postgresql.JSONB.Comparator.has_key
    "sqlalchemy.dialects.postgresql.JSONB.Comparator.has_key"), [`Comparator.has_all()`](#sqlalchemy.dialects.postgresql.JSONB.Comparator.has_all
    "sqlalchemy.dialects.postgresql.JSONB.Comparator.has_all"), [`Comparator.has_any()`](#sqlalchemy.dialects.postgresql.JSONB.Comparator.has_any
    "sqlalchemy.dialects.postgresql.JSONB.Comparator.has_any"), [`Comparator.contains()`](#sqlalchemy.dialects.postgresql.JSONB.Comparator.contains
    "sqlalchemy.dialects.postgresql.JSONB.Comparator.contains"), [`Comparator.contained_by()`](#sqlalchemy.dialects.postgresql.JSONB.Comparator.contained_by
    "sqlalchemy.dialects.postgresql.JSONB.Comparator.contained_by"), [`Comparator.delete_path()`](#sqlalchemy.dialects.postgresql.JSONB.Comparator.delete_path
    "sqlalchemy.dialects.postgresql.JSONB.Comparator.delete_path"), [`Comparator.path_exists()`](#sqlalchemy.dialects.postgresql.JSONB.Comparator.path_exists
    "sqlalchemy.dialects.postgresql.JSONB.Comparator.path_exists") and [`Comparator.path_match()`](#sqlalchemy.dialects.postgresql.JSONB.Comparator.path_match
    "sqlalchemy.dialects.postgresql.JSONB.Comparator.path_match").
  prefs: []
  type: TYPE_NORMAL
- en: Like the [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON")
    type, the [`JSONB`](#sqlalchemy.dialects.postgresql.JSONB "sqlalchemy.dialects.postgresql.JSONB")
    type does not detect in-place changes when used with the ORM, unless the [`sqlalchemy.ext.mutable`](../orm/extensions/mutable.html#module-sqlalchemy.ext.mutable
    "sqlalchemy.ext.mutable") extension is used.
  prefs: []
  type: TYPE_NORMAL
- en: Custom serializers and deserializers are shared with the [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON") class, using the `json_serializer` and `json_deserializer`
    keyword arguments. These must be specified at the dialect level using [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine"). When using psycopg2, the serializers are associated
    with the jsonb type using `psycopg2.extras.register_default_jsonb` on a per-connection
    basis, in the same way that `psycopg2.extras.register_default_json` is used to
    register these handlers with the json type.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON")'
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[contained_by()](#sqlalchemy.dialects.postgresql.JSONB.Comparator.contained_by),
    [contains()](#sqlalchemy.dialects.postgresql.JSONB.Comparator.contains), [delete_path()](#sqlalchemy.dialects.postgresql.JSONB.Comparator.delete_path),
    [has_all()](#sqlalchemy.dialects.postgresql.JSONB.Comparator.has_all), [has_any()](#sqlalchemy.dialects.postgresql.JSONB.Comparator.has_any),
    [has_key()](#sqlalchemy.dialects.postgresql.JSONB.Comparator.has_key), [path_exists()](#sqlalchemy.dialects.postgresql.JSONB.Comparator.path_exists),
    [path_match()](#sqlalchemy.dialects.postgresql.JSONB.Comparator.path_match), [comparator_factory](#sqlalchemy.dialects.postgresql.JSONB.comparator_factory)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.postgresql.JSONB`](#sqlalchemy.dialects.postgresql.JSONB
    "sqlalchemy.dialects.postgresql.JSONB") ([`sqlalchemy.dialects.postgresql.json.JSON`](#sqlalchemy.dialects.postgresql.JSON
    "sqlalchemy.dialects.postgresql.json.JSON"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE588]'
  prefs: []
  type: TYPE_PRE
- en: Define comparison operations for [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON").
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.postgresql.JSONB.Comparator`](#sqlalchemy.dialects.postgresql.JSONB.Comparator
    "sqlalchemy.dialects.postgresql.JSONB.Comparator") (`sqlalchemy.dialects.postgresql.json.Comparator`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE589]'
  prefs: []
  type: TYPE_PRE
- en: Boolean expression. Test if keys are a proper subset of the keys of the argument
    jsonb expression.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE590]'
  prefs: []
  type: TYPE_PRE
- en: Boolean expression. Test if keys (or array) are a superset of/contained the
    keys of the argument jsonb expression.
  prefs: []
  type: TYPE_NORMAL
- en: kwargs may be ignored by this operator but are required for API conformance.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE591]'
  prefs: []
  type: TYPE_PRE
- en: JSONB expression. Deletes field or array element specified in the argument array.
  prefs: []
  type: TYPE_NORMAL
- en: The input may be a list of strings that will be coerced to an `ARRAY` or an
    instance of `_postgres.array()`.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE592]'
  prefs: []
  type: TYPE_PRE
- en: Boolean expression. Test for presence of all keys in jsonb
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE593]'
  prefs: []
  type: TYPE_PRE
- en: Boolean expression. Test for presence of any key in jsonb
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE594]'
  prefs: []
  type: TYPE_PRE
- en: Boolean expression. Test for presence of a key. Note that the key may be a SQLA
    expression.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE595]'
  prefs: []
  type: TYPE_PRE
- en: Boolean expression. Test for presence of item given by the argument JSONPath
    expression.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE596]'
  prefs: []
  type: TYPE_PRE
- en: Boolean expression. Test if JSONPath predicate given by the argument JSONPath
    expression matches.
  prefs: []
  type: TYPE_NORMAL
- en: Only the first item of the result is taken into account.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE597]'
  prefs: []
  type: TYPE_PRE
- en: alias of [`Comparator`](#sqlalchemy.dialects.postgresql.JSONB.Comparator "sqlalchemy.dialects.postgresql.json.JSONB.Comparator")
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE598]'
  prefs: []
  type: TYPE_PRE
- en: JSON Path Type.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is usually required to cast literal values to json path when using json
    search like function, such as `jsonb_path_query_array` or `jsonb_path_exists`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE599]'
  prefs: []
  type: TYPE_PRE
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.postgresql.JSONPATH`](#sqlalchemy.dialects.postgresql.JSONPATH
    "sqlalchemy.dialects.postgresql.JSONPATH") (`sqlalchemy.dialects.postgresql.json.JSONPathType`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE600]'
  prefs: []
  type: TYPE_PRE
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.postgresql.MACADDR`](#sqlalchemy.dialects.postgresql.MACADDR
    "sqlalchemy.dialects.postgresql.MACADDR") ([`sqlalchemy.types.TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE601]'
  prefs: []
  type: TYPE_PRE
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.postgresql.MACADDR8`](#sqlalchemy.dialects.postgresql.MACADDR8
    "sqlalchemy.dialects.postgresql.MACADDR8") ([`sqlalchemy.types.TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE602]'
  prefs: []
  type: TYPE_PRE
- en: Provide the PostgreSQL MONEY type.
  prefs: []
  type: TYPE_NORMAL
- en: Depending on driver, result rows using this type may return a string value which
    includes currency symbols.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this reason, it may be preferable to provide conversion to a numerically-based
    currency datatype using [`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE603]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, the conversion may be applied as a CAST using the [`TypeDecorator.column_expression()`](../core/custom_types.html#sqlalchemy.types.TypeDecorator.column_expression
    "sqlalchemy.types.TypeDecorator.column_expression") method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE604]'
  prefs: []
  type: TYPE_PRE
- en: New in version 1.2.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.postgresql.MONEY`](#sqlalchemy.dialects.postgresql.MONEY
    "sqlalchemy.dialects.postgresql.MONEY") ([`sqlalchemy.types.TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE605]'
  prefs: []
  type: TYPE_PRE
- en: Provide the PostgreSQL OID type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.postgresql.OID`](#sqlalchemy.dialects.postgresql.OID
    "sqlalchemy.dialects.postgresql.OID") ([`sqlalchemy.types.TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE606]'
  prefs: []
  type: TYPE_PRE
- en: The SQL REAL type.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Float`](../core/type_basics.html#sqlalchemy.types.Float "sqlalchemy.types.Float")
    - documentation for the base type.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class `sqlalchemy.dialects.postgresql.REAL` ([`sqlalchemy.types.Float`](../core/type_basics.html#sqlalchemy.types.Float
    "sqlalchemy.types.Float"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE607]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `sqlalchemy.types.Float.__init__` *method of* [`Float`](../core/type_basics.html#sqlalchemy.types.Float
    "sqlalchemy.types.Float")'
  prefs: []
  type: TYPE_NORMAL
- en: Construct a Float.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`precision` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the numeric precision for use in DDL `CREATE TABLE`. Backends **should** attempt
    to ensure this precision indicates a number of digits for the generic [`Float`](../core/type_basics.html#sqlalchemy.types.Float
    "sqlalchemy.types.Float") datatype.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For the Oracle backend, the [`Float.precision`](../core/type_basics.html#sqlalchemy.types.Float.params.precision
    "sqlalchemy.types.Float") parameter is not accepted when rendering DDL, as Oracle
    does not support float precision specified as a number of decimal places. Instead,
    use the Oracle-specific [`FLOAT`](oracle.html#sqlalchemy.dialects.oracle.FLOAT
    "sqlalchemy.dialects.oracle.FLOAT") datatype and specify the [`FLOAT.binary_precision`](oracle.html#sqlalchemy.dialects.oracle.FLOAT.params.binary_precision
    "sqlalchemy.dialects.oracle.FLOAT") parameter. This is new in version 2.0 of SQLAlchemy.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To create a database agnostic [`Float`](../core/type_basics.html#sqlalchemy.types.Float
    "sqlalchemy.types.Float") that separately specifies binary precision for Oracle,
    use [`TypeEngine.with_variant()`](../core/type_api.html#sqlalchemy.types.TypeEngine.with_variant
    "sqlalchemy.types.TypeEngine.with_variant") as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE608]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`asdecimal` – the same flag as that of [`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric
    "sqlalchemy.types.Numeric"), but defaults to `False`. Note that setting this flag
    to `True` results in floating point conversion.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`decimal_return_scale` – Default scale to use when converting from floats to
    Python decimals. Floating point values will typically be much longer due to decimal
    inaccuracy, and most floating point database types don’t have a notion of “scale”,
    so by default the float type looks for the first ten decimal places when converting.
    Specifying this value will override that length. Note that the MySQL float types,
    which do include “scale”, will use “scale” as the default for decimal_return_scale,
    if not otherwise specified.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE609]'
  prefs: []
  type: TYPE_PRE
- en: Provide the PostgreSQL REGCONFIG type.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.0rc1.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.postgresql.REGCONFIG`](#sqlalchemy.dialects.postgresql.REGCONFIG
    "sqlalchemy.dialects.postgresql.REGCONFIG") ([`sqlalchemy.types.TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE610]'
  prefs: []
  type: TYPE_PRE
- en: Provide the PostgreSQL REGCLASS type.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.2.7.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.postgresql.REGCLASS`](#sqlalchemy.dialects.postgresql.REGCLASS
    "sqlalchemy.dialects.postgresql.REGCLASS") ([`sqlalchemy.types.TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE611]'
  prefs: []
  type: TYPE_PRE
- en: Provide the PostgreSQL TIMESTAMP type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.dialects.postgresql.TIMESTAMP.__init__)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.postgresql.TIMESTAMP`](#sqlalchemy.dialects.postgresql.TIMESTAMP
    "sqlalchemy.dialects.postgresql.TIMESTAMP") ([`sqlalchemy.types.TIMESTAMP`](../core/type_basics.html#sqlalchemy.types.TIMESTAMP
    "sqlalchemy.types.TIMESTAMP"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE612]'
  prefs: []
  type: TYPE_PRE
- en: Construct a TIMESTAMP.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`timezone` – boolean value if timezone present, default False'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`precision` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: optional integer precision value
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: New in version 1.4.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE613]'
  prefs: []
  type: TYPE_PRE
- en: PostgreSQL TIME type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.dialects.postgresql.TIME.__init__)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.postgresql.TIME`](#sqlalchemy.dialects.postgresql.TIME
    "sqlalchemy.dialects.postgresql.TIME") ([`sqlalchemy.types.TIME`](../core/type_basics.html#sqlalchemy.types.TIME
    "sqlalchemy.types.TIME"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE614]'
  prefs: []
  type: TYPE_PRE
- en: Construct a TIME.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`timezone` – boolean value if timezone present, default False'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`precision` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: optional integer precision value
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: New in version 1.4.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE615]'
  prefs: []
  type: TYPE_PRE
- en: Provide the PostgreSQL TSQUERY type.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.0rc1.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.postgresql.TSQUERY`](#sqlalchemy.dialects.postgresql.TSQUERY
    "sqlalchemy.dialects.postgresql.TSQUERY") ([`sqlalchemy.types.TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE616]'
  prefs: []
  type: TYPE_PRE
- en: The [`TSVECTOR`](#sqlalchemy.dialects.postgresql.TSVECTOR "sqlalchemy.dialects.postgresql.TSVECTOR")
    type implements the PostgreSQL text search type TSVECTOR.
  prefs: []
  type: TYPE_NORMAL
- en: It can be used to do full text queries on natural language documents.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Full Text Search](#postgresql-match)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.postgresql.TSVECTOR`](#sqlalchemy.dialects.postgresql.TSVECTOR
    "sqlalchemy.dialects.postgresql.TSVECTOR") ([`sqlalchemy.types.TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE617]'
  prefs: []
  type: TYPE_PRE
- en: Represent the SQL UUID type.
  prefs: []
  type: TYPE_NORMAL
- en: This is the SQL-native form of the [`Uuid`](../core/type_basics.html#sqlalchemy.types.Uuid
    "sqlalchemy.types.Uuid") database agnostic datatype, and is backwards compatible
    with the previous PostgreSQL-only version of `UUID`.
  prefs: []
  type: TYPE_NORMAL
- en: The [`UUID`](../core/type_basics.html#sqlalchemy.types.UUID "sqlalchemy.types.UUID")
    datatype only works on databases that have a SQL datatype named `UUID`. It will
    not function for backends which don’t have this exact-named type, including SQL
    Server. For backend-agnostic UUID values with native support, including for SQL
    Server’s `UNIQUEIDENTIFIER` datatype, use the [`Uuid`](../core/type_basics.html#sqlalchemy.types.Uuid
    "sqlalchemy.types.Uuid") datatype.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Uuid`](../core/type_basics.html#sqlalchemy.types.Uuid "sqlalchemy.types.Uuid")'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class `sqlalchemy.dialects.postgresql.UUID` ([`sqlalchemy.types.Uuid`](../core/type_basics.html#sqlalchemy.types.Uuid
    "sqlalchemy.types.Uuid"), `sqlalchemy.types.NativeForEmulated`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE618]'
  prefs: []
  type: TYPE_PRE
- en: Construct a [`UUID`](../core/type_basics.html#sqlalchemy.types.UUID "sqlalchemy.types.UUID")
    type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**as_uuid=True** –'
  prefs: []
  type: TYPE_NORMAL
- en: if True, values will be interpreted as Python uuid objects, converting to/from
    string via the DBAPI.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE619]'
  prefs: []
  type: TYPE_PRE
- en: Represent the PostgreSQL INT4RANGE type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.postgresql.INT4RANGE`](#sqlalchemy.dialects.postgresql.INT4RANGE
    "sqlalchemy.dialects.postgresql.INT4RANGE") ([`sqlalchemy.dialects.postgresql.ranges.AbstractSingleRange`](#sqlalchemy.dialects.postgresql.AbstractSingleRange
    "sqlalchemy.dialects.postgresql.ranges.AbstractSingleRange"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE620]'
  prefs: []
  type: TYPE_PRE
- en: Represent the PostgreSQL INT8RANGE type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.postgresql.INT8RANGE`](#sqlalchemy.dialects.postgresql.INT8RANGE
    "sqlalchemy.dialects.postgresql.INT8RANGE") ([`sqlalchemy.dialects.postgresql.ranges.AbstractSingleRange`](#sqlalchemy.dialects.postgresql.AbstractSingleRange
    "sqlalchemy.dialects.postgresql.ranges.AbstractSingleRange"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE621]'
  prefs: []
  type: TYPE_PRE
- en: Represent the PostgreSQL NUMRANGE type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.postgresql.NUMRANGE`](#sqlalchemy.dialects.postgresql.NUMRANGE
    "sqlalchemy.dialects.postgresql.NUMRANGE") ([`sqlalchemy.dialects.postgresql.ranges.AbstractSingleRange`](#sqlalchemy.dialects.postgresql.AbstractSingleRange
    "sqlalchemy.dialects.postgresql.ranges.AbstractSingleRange"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE622]'
  prefs: []
  type: TYPE_PRE
- en: Represent the PostgreSQL DATERANGE type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.postgresql.DATERANGE`](#sqlalchemy.dialects.postgresql.DATERANGE
    "sqlalchemy.dialects.postgresql.DATERANGE") ([`sqlalchemy.dialects.postgresql.ranges.AbstractSingleRange`](#sqlalchemy.dialects.postgresql.AbstractSingleRange
    "sqlalchemy.dialects.postgresql.ranges.AbstractSingleRange"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE623]'
  prefs: []
  type: TYPE_PRE
- en: Represent the PostgreSQL TSRANGE type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.postgresql.TSRANGE`](#sqlalchemy.dialects.postgresql.TSRANGE
    "sqlalchemy.dialects.postgresql.TSRANGE") ([`sqlalchemy.dialects.postgresql.ranges.AbstractSingleRange`](#sqlalchemy.dialects.postgresql.AbstractSingleRange
    "sqlalchemy.dialects.postgresql.ranges.AbstractSingleRange"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE624]'
  prefs: []
  type: TYPE_PRE
- en: Represent the PostgreSQL TSTZRANGE type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.postgresql.TSTZRANGE`](#sqlalchemy.dialects.postgresql.TSTZRANGE
    "sqlalchemy.dialects.postgresql.TSTZRANGE") ([`sqlalchemy.dialects.postgresql.ranges.AbstractSingleRange`](#sqlalchemy.dialects.postgresql.AbstractSingleRange
    "sqlalchemy.dialects.postgresql.ranges.AbstractSingleRange"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE625]'
  prefs: []
  type: TYPE_PRE
- en: Represent the PostgreSQL INT4MULTIRANGE type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.postgresql.INT4MULTIRANGE`](#sqlalchemy.dialects.postgresql.INT4MULTIRANGE
    "sqlalchemy.dialects.postgresql.INT4MULTIRANGE") ([`sqlalchemy.dialects.postgresql.ranges.AbstractMultiRange`](#sqlalchemy.dialects.postgresql.AbstractMultiRange
    "sqlalchemy.dialects.postgresql.ranges.AbstractMultiRange"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE626]'
  prefs: []
  type: TYPE_PRE
- en: Represent the PostgreSQL INT8MULTIRANGE type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.postgresql.INT8MULTIRANGE`](#sqlalchemy.dialects.postgresql.INT8MULTIRANGE
    "sqlalchemy.dialects.postgresql.INT8MULTIRANGE") ([`sqlalchemy.dialects.postgresql.ranges.AbstractMultiRange`](#sqlalchemy.dialects.postgresql.AbstractMultiRange
    "sqlalchemy.dialects.postgresql.ranges.AbstractMultiRange"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE627]'
  prefs: []
  type: TYPE_PRE
- en: Represent the PostgreSQL NUMMULTIRANGE type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.postgresql.NUMMULTIRANGE`](#sqlalchemy.dialects.postgresql.NUMMULTIRANGE
    "sqlalchemy.dialects.postgresql.NUMMULTIRANGE") ([`sqlalchemy.dialects.postgresql.ranges.AbstractMultiRange`](#sqlalchemy.dialects.postgresql.AbstractMultiRange
    "sqlalchemy.dialects.postgresql.ranges.AbstractMultiRange"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE628]'
  prefs: []
  type: TYPE_PRE
- en: Represent the PostgreSQL DATEMULTIRANGE type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.postgresql.DATEMULTIRANGE`](#sqlalchemy.dialects.postgresql.DATEMULTIRANGE
    "sqlalchemy.dialects.postgresql.DATEMULTIRANGE") ([`sqlalchemy.dialects.postgresql.ranges.AbstractMultiRange`](#sqlalchemy.dialects.postgresql.AbstractMultiRange
    "sqlalchemy.dialects.postgresql.ranges.AbstractMultiRange"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE629]'
  prefs: []
  type: TYPE_PRE
- en: Represent the PostgreSQL TSRANGE type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.postgresql.TSMULTIRANGE`](#sqlalchemy.dialects.postgresql.TSMULTIRANGE
    "sqlalchemy.dialects.postgresql.TSMULTIRANGE") ([`sqlalchemy.dialects.postgresql.ranges.AbstractMultiRange`](#sqlalchemy.dialects.postgresql.AbstractMultiRange
    "sqlalchemy.dialects.postgresql.ranges.AbstractMultiRange"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE630]'
  prefs: []
  type: TYPE_PRE
- en: Represent the PostgreSQL TSTZRANGE type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.postgresql.TSTZMULTIRANGE`](#sqlalchemy.dialects.postgresql.TSTZMULTIRANGE
    "sqlalchemy.dialects.postgresql.TSTZMULTIRANGE") ([`sqlalchemy.dialects.postgresql.ranges.AbstractMultiRange`](#sqlalchemy.dialects.postgresql.AbstractMultiRange
    "sqlalchemy.dialects.postgresql.ranges.AbstractMultiRange"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE631]'
  prefs: []
  type: TYPE_PRE
- en: Represents a multirange sequence.
  prefs: []
  type: TYPE_NORMAL
- en: 'This list subclass is an utility to allow automatic type inference of the proper
    multi-range SQL type depending on the single range values. This is useful when
    operating on literal multi-ranges:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE632]'
  prefs: []
  type: TYPE_PRE
- en: New in version 2.0.26.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Use of a MultiRange sequence to infer the multirange type](#postgresql-multirange-list-use).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.postgresql.MultiRange`](#sqlalchemy.dialects.postgresql.MultiRange
    "sqlalchemy.dialects.postgresql.MultiRange") (`builtins.list`, `typing.Generic`)
  prefs: []
  type: TYPE_NORMAL
- en: PostgreSQL SQL Elements and Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '| Object Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| [aggregate_order_by](#sqlalchemy.dialects.postgresql.aggregate_order_by)
    | Represent a PostgreSQL aggregate order by expression. |'
  prefs: []
  type: TYPE_TB
- en: '| [All](#sqlalchemy.dialects.postgresql.All)(other, arrexpr[, operator]) |
    A synonym for the ARRAY-level [`Comparator.all()`](../core/type_basics.html#sqlalchemy.types.ARRAY.Comparator.all
    "sqlalchemy.types.ARRAY.Comparator.all") method. See that method for details.
    |'
  prefs: []
  type: TYPE_TB
- en: '| [Any](#sqlalchemy.dialects.postgresql.Any)(other, arrexpr[, operator]) |
    A synonym for the ARRAY-level [`Comparator.any()`](../core/type_basics.html#sqlalchemy.types.ARRAY.Comparator.any
    "sqlalchemy.types.ARRAY.Comparator.any") method. See that method for details.
    |'
  prefs: []
  type: TYPE_TB
- en: '| [array](#sqlalchemy.dialects.postgresql.array) | A PostgreSQL ARRAY literal.
    |'
  prefs: []
  type: TYPE_TB
- en: '| [array_agg](#sqlalchemy.dialects.postgresql.array_agg)(*arg, **kw) | PostgreSQL-specific
    form of [`array_agg`](../core/functions.html#sqlalchemy.sql.functions.array_agg
    "sqlalchemy.sql.functions.array_agg"), ensures return type is [`ARRAY`](#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY") and not the plain [`ARRAY`](../core/type_basics.html#sqlalchemy.types.ARRAY
    "sqlalchemy.types.ARRAY"), unless an explicit `type_` is passed. |'
  prefs: []
  type: TYPE_TB
- en: '| [hstore](#sqlalchemy.dialects.postgresql.hstore) | Construct an hstore value
    within a SQL expression using the PostgreSQL `hstore()` function. |'
  prefs: []
  type: TYPE_TB
- en: '| [phraseto_tsquery](#sqlalchemy.dialects.postgresql.phraseto_tsquery) | The
    PostgreSQL `phraseto_tsquery` SQL function. |'
  prefs: []
  type: TYPE_TB
- en: '| [plainto_tsquery](#sqlalchemy.dialects.postgresql.plainto_tsquery) | The
    PostgreSQL `plainto_tsquery` SQL function. |'
  prefs: []
  type: TYPE_TB
- en: '| [to_tsquery](#sqlalchemy.dialects.postgresql.to_tsquery) | The PostgreSQL
    `to_tsquery` SQL function. |'
  prefs: []
  type: TYPE_TB
- en: '| [to_tsvector](#sqlalchemy.dialects.postgresql.to_tsvector) | The PostgreSQL
    `to_tsvector` SQL function. |'
  prefs: []
  type: TYPE_TB
- en: '| [ts_headline](#sqlalchemy.dialects.postgresql.ts_headline) | The PostgreSQL
    `ts_headline` SQL function. |'
  prefs: []
  type: TYPE_TB
- en: '| [websearch_to_tsquery](#sqlalchemy.dialects.postgresql.websearch_to_tsquery)
    | The PostgreSQL `websearch_to_tsquery` SQL function. |'
  prefs: []
  type: TYPE_TB
- en: '[PRE633]'
  prefs: []
  type: TYPE_PRE
- en: Represent a PostgreSQL aggregate order by expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE634]'
  prefs: []
  type: TYPE_PRE
- en: 'would represent the expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE635]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE636]'
  prefs: []
  type: TYPE_PRE
- en: 'Would represent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE637]'
  prefs: []
  type: TYPE_PRE
- en: 'Changed in version 1.2.13: - the ORDER BY argument may be multiple terms'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`array_agg`](../core/functions.html#sqlalchemy.sql.functions.array_agg "sqlalchemy.sql.functions.array_agg")'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.postgresql.aggregate_order_by`](#sqlalchemy.dialects.postgresql.aggregate_order_by
    "sqlalchemy.dialects.postgresql.aggregate_order_by") ([`sqlalchemy.sql.expression.ColumnElement`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE638]'
  prefs: []
  type: TYPE_PRE
- en: A PostgreSQL ARRAY literal.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is used to produce ARRAY literals in SQL expressions, e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE639]'
  prefs: []
  type: TYPE_PRE
- en: 'Produces the SQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE640]'
  prefs: []
  type: TYPE_PRE
- en: 'An instance of [`array`](#sqlalchemy.dialects.postgresql.array "sqlalchemy.dialects.postgresql.array.array")
    will always have the datatype [`ARRAY`](../core/type_basics.html#sqlalchemy.types.ARRAY
    "sqlalchemy.types.ARRAY"). The “inner” type of the array is inferred from the
    values present, unless the `type_` keyword argument is passed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE641]'
  prefs: []
  type: TYPE_PRE
- en: 'Multidimensional arrays are produced by nesting [`array`](#sqlalchemy.dialects.postgresql.array
    "sqlalchemy.dialects.postgresql.array.array") constructs. The dimensionality of
    the final [`ARRAY`](../core/type_basics.html#sqlalchemy.types.ARRAY "sqlalchemy.types.ARRAY")
    type is calculated by recursively adding the dimensions of the inner [`ARRAY`](../core/type_basics.html#sqlalchemy.types.ARRAY
    "sqlalchemy.types.ARRAY") type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE642]'
  prefs: []
  type: TYPE_PRE
- en: 'Produces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE643]'
  prefs: []
  type: TYPE_PRE
- en: 'New in version 1.3.6: added support for multidimensional array literals'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`ARRAY`](#sqlalchemy.dialects.postgresql.ARRAY "sqlalchemy.dialects.postgresql.ARRAY")'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.postgresql.array`](#sqlalchemy.dialects.postgresql.array
    "sqlalchemy.dialects.postgresql.array") (`sqlalchemy.sql.expression.ExpressionClauseList`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE644]'
  prefs: []
  type: TYPE_PRE
- en: PostgreSQL-specific form of [`array_agg`](../core/functions.html#sqlalchemy.sql.functions.array_agg
    "sqlalchemy.sql.functions.array_agg"), ensures return type is [`ARRAY`](#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY") and not the plain [`ARRAY`](../core/type_basics.html#sqlalchemy.types.ARRAY
    "sqlalchemy.types.ARRAY"), unless an explicit `type_` is passed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE645]'
  prefs: []
  type: TYPE_PRE
- en: A synonym for the ARRAY-level [`Comparator.any()`](../core/type_basics.html#sqlalchemy.types.ARRAY.Comparator.any
    "sqlalchemy.types.ARRAY.Comparator.any") method. See that method for details.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE646]'
  prefs: []
  type: TYPE_PRE
- en: A synonym for the ARRAY-level [`Comparator.all()`](../core/type_basics.html#sqlalchemy.types.ARRAY.Comparator.all
    "sqlalchemy.types.ARRAY.Comparator.all") method. See that method for details.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE647]'
  prefs: []
  type: TYPE_PRE
- en: Construct an hstore value within a SQL expression using the PostgreSQL `hstore()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: The [`hstore`](#sqlalchemy.dialects.postgresql.hstore "sqlalchemy.dialects.postgresql.hstore.hstore")
    function accepts one or two arguments as described in the PostgreSQL documentation.
  prefs: []
  type: TYPE_NORMAL
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE648]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`HSTORE`](#sqlalchemy.dialects.postgresql.HSTORE "sqlalchemy.dialects.postgresql.hstore.HSTORE")
    - the PostgreSQL `HSTORE` datatype.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[inherit_cache](#sqlalchemy.dialects.postgresql.hstore.inherit_cache), [type](#sqlalchemy.dialects.postgresql.hstore.type)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.postgresql.hstore`](#sqlalchemy.dialects.postgresql.hstore
    "sqlalchemy.dialects.postgresql.hstore") ([`sqlalchemy.sql.functions.GenericFunction`](../core/functions.html#sqlalchemy.sql.functions.GenericFunction
    "sqlalchemy.sql.functions.GenericFunction"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE649]'
  prefs: []
  type: TYPE_PRE
- en: Indicate if this [`HasCacheKey`](../core/foundation.html#sqlalchemy.sql.traversals.HasCacheKey
    "sqlalchemy.sql.traversals.HasCacheKey") instance should make use of the cache
    key generation scheme used by its immediate superclass.
  prefs: []
  type: TYPE_NORMAL
- en: The attribute defaults to `None`, which indicates that a construct has not yet
    taken into account whether or not its appropriate for it to participate in caching;
    this is functionally equivalent to setting the value to `False`, except that a
    warning is also emitted.
  prefs: []
  type: TYPE_NORMAL
- en: This flag can be set to `True` on a particular class, if the SQL that corresponds
    to the object does not change based on attributes which are local to this class,
    and not its superclass.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Enabling Caching Support for Custom Constructs](../core/compiler.html#compilerext-caching)
    - General guideslines for setting the [`HasCacheKey.inherit_cache`](../core/foundation.html#sqlalchemy.sql.traversals.HasCacheKey.inherit_cache
    "sqlalchemy.sql.traversals.HasCacheKey.inherit_cache") attribute for third-party
    or user defined SQL constructs.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE650]'
  prefs: []
  type: TYPE_PRE
- en: alias of [`HSTORE`](#sqlalchemy.dialects.postgresql.HSTORE "sqlalchemy.dialects.postgresql.hstore.HSTORE")
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE651]'
  prefs: []
  type: TYPE_PRE
- en: The PostgreSQL `to_tsvector` SQL function.
  prefs: []
  type: TYPE_NORMAL
- en: This function applies automatic casting of the REGCONFIG argument to use the
    [`REGCONFIG`](#sqlalchemy.dialects.postgresql.REGCONFIG "sqlalchemy.dialects.postgresql.REGCONFIG")
    datatype automatically, and applies a return type of [`TSVECTOR`](#sqlalchemy.dialects.postgresql.TSVECTOR
    "sqlalchemy.dialects.postgresql.TSVECTOR").
  prefs: []
  type: TYPE_NORMAL
- en: Assuming the PostgreSQL dialect has been imported, either by invoking `from
    sqlalchemy.dialects import postgresql`, or by creating a PostgreSQL engine using
    `create_engine("postgresql...")`, [`to_tsvector`](#sqlalchemy.dialects.postgresql.to_tsvector
    "sqlalchemy.dialects.postgresql.to_tsvector") will be used automatically when
    invoking `sqlalchemy.func.to_tsvector()`, ensuring the correct argument and return
    type handlers are used at compile and execution time.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.0rc1.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.postgresql.to_tsvector`](#sqlalchemy.dialects.postgresql.to_tsvector
    "sqlalchemy.dialects.postgresql.to_tsvector") (`sqlalchemy.dialects.postgresql.ext._regconfig_fn`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE652]'
  prefs: []
  type: TYPE_PRE
- en: The PostgreSQL `to_tsquery` SQL function.
  prefs: []
  type: TYPE_NORMAL
- en: This function applies automatic casting of the REGCONFIG argument to use the
    [`REGCONFIG`](#sqlalchemy.dialects.postgresql.REGCONFIG "sqlalchemy.dialects.postgresql.REGCONFIG")
    datatype automatically, and applies a return type of [`TSQUERY`](#sqlalchemy.dialects.postgresql.TSQUERY
    "sqlalchemy.dialects.postgresql.TSQUERY").
  prefs: []
  type: TYPE_NORMAL
- en: Assuming the PostgreSQL dialect has been imported, either by invoking `from
    sqlalchemy.dialects import postgresql`, or by creating a PostgreSQL engine using
    `create_engine("postgresql...")`, [`to_tsquery`](#sqlalchemy.dialects.postgresql.to_tsquery
    "sqlalchemy.dialects.postgresql.to_tsquery") will be used automatically when invoking
    `sqlalchemy.func.to_tsquery()`, ensuring the correct argument and return type
    handlers are used at compile and execution time.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.0rc1.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.postgresql.to_tsquery`](#sqlalchemy.dialects.postgresql.to_tsquery
    "sqlalchemy.dialects.postgresql.to_tsquery") (`sqlalchemy.dialects.postgresql.ext._regconfig_fn`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE653]'
  prefs: []
  type: TYPE_PRE
- en: The PostgreSQL `plainto_tsquery` SQL function.
  prefs: []
  type: TYPE_NORMAL
- en: This function applies automatic casting of the REGCONFIG argument to use the
    [`REGCONFIG`](#sqlalchemy.dialects.postgresql.REGCONFIG "sqlalchemy.dialects.postgresql.REGCONFIG")
    datatype automatically, and applies a return type of [`TSQUERY`](#sqlalchemy.dialects.postgresql.TSQUERY
    "sqlalchemy.dialects.postgresql.TSQUERY").
  prefs: []
  type: TYPE_NORMAL
- en: Assuming the PostgreSQL dialect has been imported, either by invoking `from
    sqlalchemy.dialects import postgresql`, or by creating a PostgreSQL engine using
    `create_engine("postgresql...")`, [`plainto_tsquery`](#sqlalchemy.dialects.postgresql.plainto_tsquery
    "sqlalchemy.dialects.postgresql.plainto_tsquery") will be used automatically when
    invoking `sqlalchemy.func.plainto_tsquery()`, ensuring the correct argument and
    return type handlers are used at compile and execution time.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.0rc1.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.postgresql.plainto_tsquery`](#sqlalchemy.dialects.postgresql.plainto_tsquery
    "sqlalchemy.dialects.postgresql.plainto_tsquery") (`sqlalchemy.dialects.postgresql.ext._regconfig_fn`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE654]'
  prefs: []
  type: TYPE_PRE
- en: The PostgreSQL `phraseto_tsquery` SQL function.
  prefs: []
  type: TYPE_NORMAL
- en: This function applies automatic casting of the REGCONFIG argument to use the
    [`REGCONFIG`](#sqlalchemy.dialects.postgresql.REGCONFIG "sqlalchemy.dialects.postgresql.REGCONFIG")
    datatype automatically, and applies a return type of [`TSQUERY`](#sqlalchemy.dialects.postgresql.TSQUERY
    "sqlalchemy.dialects.postgresql.TSQUERY").
  prefs: []
  type: TYPE_NORMAL
- en: Assuming the PostgreSQL dialect has been imported, either by invoking `from
    sqlalchemy.dialects import postgresql`, or by creating a PostgreSQL engine using
    `create_engine("postgresql...")`, [`phraseto_tsquery`](#sqlalchemy.dialects.postgresql.phraseto_tsquery
    "sqlalchemy.dialects.postgresql.phraseto_tsquery") will be used automatically
    when invoking `sqlalchemy.func.phraseto_tsquery()`, ensuring the correct argument
    and return type handlers are used at compile and execution time.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.0rc1.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.postgresql.phraseto_tsquery`](#sqlalchemy.dialects.postgresql.phraseto_tsquery
    "sqlalchemy.dialects.postgresql.phraseto_tsquery") (`sqlalchemy.dialects.postgresql.ext._regconfig_fn`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE655]'
  prefs: []
  type: TYPE_PRE
- en: The PostgreSQL `websearch_to_tsquery` SQL function.
  prefs: []
  type: TYPE_NORMAL
- en: This function applies automatic casting of the REGCONFIG argument to use the
    [`REGCONFIG`](#sqlalchemy.dialects.postgresql.REGCONFIG "sqlalchemy.dialects.postgresql.REGCONFIG")
    datatype automatically, and applies a return type of [`TSQUERY`](#sqlalchemy.dialects.postgresql.TSQUERY
    "sqlalchemy.dialects.postgresql.TSQUERY").
  prefs: []
  type: TYPE_NORMAL
- en: Assuming the PostgreSQL dialect has been imported, either by invoking `from
    sqlalchemy.dialects import postgresql`, or by creating a PostgreSQL engine using
    `create_engine("postgresql...")`, [`websearch_to_tsquery`](#sqlalchemy.dialects.postgresql.websearch_to_tsquery
    "sqlalchemy.dialects.postgresql.websearch_to_tsquery") will be used automatically
    when invoking `sqlalchemy.func.websearch_to_tsquery()`, ensuring the correct argument
    and return type handlers are used at compile and execution time.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.0rc1.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.postgresql.websearch_to_tsquery`](#sqlalchemy.dialects.postgresql.websearch_to_tsquery
    "sqlalchemy.dialects.postgresql.websearch_to_tsquery") (`sqlalchemy.dialects.postgresql.ext._regconfig_fn`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE656]'
  prefs: []
  type: TYPE_PRE
- en: The PostgreSQL `ts_headline` SQL function.
  prefs: []
  type: TYPE_NORMAL
- en: This function applies automatic casting of the REGCONFIG argument to use the
    [`REGCONFIG`](#sqlalchemy.dialects.postgresql.REGCONFIG "sqlalchemy.dialects.postgresql.REGCONFIG")
    datatype automatically, and applies a return type of [`TEXT`](../core/type_basics.html#sqlalchemy.types.TEXT
    "sqlalchemy.types.TEXT").
  prefs: []
  type: TYPE_NORMAL
- en: Assuming the PostgreSQL dialect has been imported, either by invoking `from
    sqlalchemy.dialects import postgresql`, or by creating a PostgreSQL engine using
    `create_engine("postgresql...")`, [`ts_headline`](#sqlalchemy.dialects.postgresql.ts_headline
    "sqlalchemy.dialects.postgresql.ts_headline") will be used automatically when
    invoking `sqlalchemy.func.ts_headline()`, ensuring the correct argument and return
    type handlers are used at compile and execution time.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.0rc1.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.postgresql.ts_headline`](#sqlalchemy.dialects.postgresql.ts_headline
    "sqlalchemy.dialects.postgresql.ts_headline") (`sqlalchemy.dialects.postgresql.ext._regconfig_fn`)
  prefs: []
  type: TYPE_NORMAL
- en: PostgreSQL Constraint Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'SQLAlchemy supports PostgreSQL EXCLUDE constraints via the [`ExcludeConstraint`](#sqlalchemy.dialects.postgresql.ExcludeConstraint
    "sqlalchemy.dialects.postgresql.ExcludeConstraint") class:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Object Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| [ExcludeConstraint](#sqlalchemy.dialects.postgresql.ExcludeConstraint) |
    A table-level EXCLUDE constraint. |'
  prefs: []
  type: TYPE_TB
- en: '[PRE657]'
  prefs: []
  type: TYPE_PRE
- en: A table-level EXCLUDE constraint.
  prefs: []
  type: TYPE_NORMAL
- en: Defines an EXCLUDE constraint as described in the [PostgreSQL documentation](https://www.postgresql.org/docs/current/static/sql-createtable.html#SQL-CREATETABLE-EXCLUDE).
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.dialects.postgresql.ExcludeConstraint.__init__)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.postgresql.ExcludeConstraint`](#sqlalchemy.dialects.postgresql.ExcludeConstraint
    "sqlalchemy.dialects.postgresql.ExcludeConstraint") ([`sqlalchemy.schema.ColumnCollectionConstraint`](../core/constraints.html#sqlalchemy.schema.ColumnCollectionConstraint
    "sqlalchemy.schema.ColumnCollectionConstraint"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE658]'
  prefs: []
  type: TYPE_PRE
- en: Create an [`ExcludeConstraint`](#sqlalchemy.dialects.postgresql.ExcludeConstraint
    "sqlalchemy.dialects.postgresql.ExcludeConstraint") object.
  prefs: []
  type: TYPE_NORMAL
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE659]'
  prefs: []
  type: TYPE_PRE
- en: 'The constraint is normally embedded into the [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") construct directly, or added later using [`append_constraint()`](../core/metadata.html#sqlalchemy.schema.Table.append_constraint
    "sqlalchemy.schema.Table.append_constraint"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE660]'
  prefs: []
  type: TYPE_PRE
- en: The exclude constraint defined in this example requires the `btree_gist` extension,
    that can be created using the command `CREATE EXTENSION btree_gist;`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`*elements` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A sequence of two tuples of the form `(column, operator)` where “column” is
    either a [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    object, or a SQL expression element (e.g. `func.int8range(table.from, table.to)`)
    or the name of a column as string, and “operator” is a string containing the operator
    to use (e.g. “&&” or “=”).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In order to specify a column name when a [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") object is not available, while ensuring that any necessary
    quoting rules take effect, an ad-hoc [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") or [`column()`](../core/sqlelement.html#sqlalchemy.sql.expression.column
    "sqlalchemy.sql.expression.column") object should be used. The `column` may also
    be a string SQL expression when passed as [`literal_column()`](../core/sqlelement.html#sqlalchemy.sql.expression.literal_column
    "sqlalchemy.sql.expression.literal_column") or [`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text
    "sqlalchemy.sql.expression.text")
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`name` – Optional, the in-database name of this constraint.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`deferrable` – Optional bool. If set, emit DEFERRABLE or NOT DEFERRABLE when
    issuing DDL for this constraint.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`initially` – Optional string. If set, emit INITIALLY <value>when issuing DDL
    for this constraint.</value>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`using` – Optional string. If set, emit USING <index_method>when issuing DDL
    for this constraint. Defaults to ‘gist’.</index_method>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`where` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optional SQL expression construct or literal SQL string. If set, emit WHERE
    <predicate> when issuing DDL for this constraint.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The [`ExcludeConstraint.where`](#sqlalchemy.dialects.postgresql.ExcludeConstraint.params.where
    "sqlalchemy.dialects.postgresql.ExcludeConstraint") argument to [`ExcludeConstraint`](#sqlalchemy.dialects.postgresql.ExcludeConstraint
    "sqlalchemy.dialects.postgresql.ExcludeConstraint") can be passed as a Python
    string argument, which will be treated as **trusted SQL text** and rendered as
    given. **DO NOT PASS UNTRUSTED INPUT TO THIS PARAMETER**.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`ops` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optional dictionary. Used to define operator classes for the elements; works
    the same way as that of the [postgresql_ops](#postgresql-operator-classes) parameter
    specified to the [`Index`](../core/constraints.html#sqlalchemy.schema.Index "sqlalchemy.schema.Index")
    construct.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: New in version 1.3.21.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Operator Classes](#postgresql-operator-classes) - general description of how
    PostgreSQL operator classes are specified.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE661]'
  prefs: []
  type: TYPE_PRE
- en: PostgreSQL DML Constructs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '| Object Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| [insert](#sqlalchemy.dialects.postgresql.insert)(table) | Construct a PostgreSQL-specific
    variant [`Insert`](#sqlalchemy.dialects.postgresql.Insert "sqlalchemy.dialects.postgresql.Insert")
    construct. |'
  prefs: []
  type: TYPE_TB
- en: '| [Insert](#sqlalchemy.dialects.postgresql.Insert) | PostgreSQL-specific implementation
    of INSERT. |'
  prefs: []
  type: TYPE_TB
- en: '[PRE662]'
  prefs: []
  type: TYPE_PRE
- en: Construct a PostgreSQL-specific variant [`Insert`](#sqlalchemy.dialects.postgresql.Insert
    "sqlalchemy.dialects.postgresql.Insert") construct.
  prefs: []
  type: TYPE_NORMAL
- en: The [`sqlalchemy.dialects.postgresql.insert()`](#sqlalchemy.dialects.postgresql.insert
    "sqlalchemy.dialects.postgresql.insert") function creates a [`sqlalchemy.dialects.postgresql.Insert`](#sqlalchemy.dialects.postgresql.Insert
    "sqlalchemy.dialects.postgresql.Insert"). This class is based on the dialect-agnostic
    [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert "sqlalchemy.sql.expression.Insert")
    construct which may be constructed using the [`insert()`](../core/dml.html#sqlalchemy.sql.expression.insert
    "sqlalchemy.sql.expression.insert") function in SQLAlchemy Core.
  prefs: []
  type: TYPE_NORMAL
- en: The [`Insert`](#sqlalchemy.dialects.postgresql.Insert "sqlalchemy.dialects.postgresql.Insert")
    construct includes additional methods [`Insert.on_conflict_do_update()`](#sqlalchemy.dialects.postgresql.Insert.on_conflict_do_update
    "sqlalchemy.dialects.postgresql.Insert.on_conflict_do_update"), [`Insert.on_conflict_do_nothing()`](#sqlalchemy.dialects.postgresql.Insert.on_conflict_do_nothing
    "sqlalchemy.dialects.postgresql.Insert.on_conflict_do_nothing").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE663]'
  prefs: []
  type: TYPE_PRE
- en: PostgreSQL-specific implementation of INSERT.
  prefs: []
  type: TYPE_NORMAL
- en: Adds methods for PG-specific syntaxes such as ON CONFLICT.
  prefs: []
  type: TYPE_NORMAL
- en: The [`Insert`](#sqlalchemy.dialects.postgresql.Insert "sqlalchemy.dialects.postgresql.Insert")
    object is created using the [`sqlalchemy.dialects.postgresql.insert()`](#sqlalchemy.dialects.postgresql.insert
    "sqlalchemy.dialects.postgresql.insert") function.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[excluded](#sqlalchemy.dialects.postgresql.Insert.excluded), [inherit_cache](#sqlalchemy.dialects.postgresql.Insert.inherit_cache),
    [on_conflict_do_nothing()](#sqlalchemy.dialects.postgresql.Insert.on_conflict_do_nothing),
    [on_conflict_do_update()](#sqlalchemy.dialects.postgresql.Insert.on_conflict_do_update)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.postgresql.Insert`](#sqlalchemy.dialects.postgresql.Insert
    "sqlalchemy.dialects.postgresql.Insert") ([`sqlalchemy.sql.expression.Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE664]'
  prefs: []
  type: TYPE_PRE
- en: Provide the `excluded` namespace for an ON CONFLICT statement
  prefs: []
  type: TYPE_NORMAL
- en: PG’s ON CONFLICT clause allows reference to the row that would be inserted,
    known as `excluded`. This attribute provides all columns in this row to be referenceable.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: The [`Insert.excluded`](#sqlalchemy.dialects.postgresql.Insert.excluded "sqlalchemy.dialects.postgresql.Insert.excluded")
    attribute is an instance of [`ColumnCollection`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnCollection
    "sqlalchemy.sql.expression.ColumnCollection"), which provides an interface the
    same as that of the [`Table.c`](../core/metadata.html#sqlalchemy.schema.Table.c
    "sqlalchemy.schema.Table.c") collection described at [Accessing Tables and Columns](../core/metadata.html#metadata-tables-and-columns).
    With this collection, ordinary names are accessible like attributes (e.g. `stmt.excluded.some_column`),
    but special names and dictionary method names should be accessed using indexed
    access, such as `stmt.excluded["column name"]` or `stmt.excluded["values"]`. See
    the docstring for [`ColumnCollection`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnCollection
    "sqlalchemy.sql.expression.ColumnCollection") for further examples.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[INSERT…ON CONFLICT (Upsert)](#postgresql-insert-on-conflict) - example of
    how to use `Insert.excluded`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE665]'
  prefs: []
  type: TYPE_PRE
- en: Indicate if this [`HasCacheKey`](../core/foundation.html#sqlalchemy.sql.traversals.HasCacheKey
    "sqlalchemy.sql.traversals.HasCacheKey") instance should make use of the cache
    key generation scheme used by its immediate superclass.
  prefs: []
  type: TYPE_NORMAL
- en: The attribute defaults to `None`, which indicates that a construct has not yet
    taken into account whether or not its appropriate for it to participate in caching;
    this is functionally equivalent to setting the value to `False`, except that a
    warning is also emitted.
  prefs: []
  type: TYPE_NORMAL
- en: This flag can be set to `True` on a particular class, if the SQL that corresponds
    to the object does not change based on attributes which are local to this class,
    and not its superclass.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Enabling Caching Support for Custom Constructs](../core/compiler.html#compilerext-caching)
    - General guideslines for setting the [`HasCacheKey.inherit_cache`](../core/foundation.html#sqlalchemy.sql.traversals.HasCacheKey.inherit_cache
    "sqlalchemy.sql.traversals.HasCacheKey.inherit_cache") attribute for third-party
    or user defined SQL constructs.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE666]'
  prefs: []
  type: TYPE_PRE
- en: Specifies a DO NOTHING action for ON CONFLICT clause.
  prefs: []
  type: TYPE_NORMAL
- en: The `constraint` and `index_elements` arguments are optional, but only one of
    these can be specified.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`constraint` – The name of a unique or exclusion constraint on the table, or
    the constraint object itself if it has a .name attribute.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`index_elements` – A sequence consisting of string column names, [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects, or other column expression objects that will
    be used to infer a target index.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`index_where` – Additional WHERE criterion that can be used to infer a conditional
    target index.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[INSERT…ON CONFLICT (Upsert)](#postgresql-insert-on-conflict)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE667]'
  prefs: []
  type: TYPE_PRE
- en: Specifies a DO UPDATE SET action for ON CONFLICT clause.
  prefs: []
  type: TYPE_NORMAL
- en: Either the `constraint` or `index_elements` argument is required, but only one
    of these can be specified.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`constraint` – The name of a unique or exclusion constraint on the table, or
    the constraint object itself if it has a .name attribute.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`index_elements` – A sequence consisting of string column names, [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects, or other column expression objects that will
    be used to infer a target index.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`index_where` – Additional WHERE criterion that can be used to infer a conditional
    target index.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`set_` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A dictionary or other mapping object where the keys are either names of columns
    in the target table, or [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects or other ORM-mapped columns matching that
    of the target table, and expressions or literals as values, specifying the `SET`
    actions to take.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'New in version 1.4: The [`Insert.on_conflict_do_update.set_`](#sqlalchemy.dialects.postgresql.Insert.on_conflict_do_update.params.set_
    "sqlalchemy.dialects.postgresql.Insert.on_conflict_do_update") parameter supports
    [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    objects from the target [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") as keys.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This dictionary does **not** take into account Python-specified default UPDATE
    values or generation functions, e.g. those specified using [`Column.onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.onupdate
    "sqlalchemy.schema.Column"). These values will not be exercised for an ON CONFLICT
    style of UPDATE, unless they are manually specified in the [`Insert.on_conflict_do_update.set_`](#sqlalchemy.dialects.postgresql.Insert.on_conflict_do_update.params.set_
    "sqlalchemy.dialects.postgresql.Insert.on_conflict_do_update") dictionary.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`where` – Optional argument. If present, can be a literal SQL string or an
    acceptable expression for a `WHERE` clause that restricts the rows affected by
    `DO UPDATE SET`. Rows not meeting the `WHERE` condition will not be updated (effectively
    a `DO NOTHING` for those rows).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[INSERT…ON CONFLICT (Upsert)](#postgresql-insert-on-conflict)'
  prefs: []
  type: TYPE_NORMAL
- en: '## psycopg2'
  prefs: []
  type: TYPE_NORMAL
- en: Support for the PostgreSQL database via the psycopg2 driver.
  prefs: []
  type: TYPE_NORMAL
- en: DBAPI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Documentation and download information (if applicable) for psycopg2 is available
    at: [https://pypi.org/project/psycopg2/](https://pypi.org/project/psycopg2/)'
  prefs: []
  type: TYPE_NORMAL
- en: Connecting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Connect String:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE668]'
  prefs: []
  type: TYPE_PRE
- en: '### psycopg2 Connect Arguments'
  prefs: []
  type: TYPE_NORMAL
- en: 'Keyword arguments that are specific to the SQLAlchemy psycopg2 dialect may
    be passed to [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine"), and include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`isolation_level`: This option, available for all PostgreSQL dialects, includes
    the `AUTOCOMMIT` isolation level when using the psycopg2 dialect. This option
    sets the **default** isolation level for the connection that is set immediately
    upon connection to the database before the connection is pooled. This option is
    generally superseded by the more modern [`Connection.execution_options.isolation_level`](../core/connections.html#sqlalchemy.engine.Connection.execution_options.params.isolation_level
    "sqlalchemy.engine.Connection.execution_options") execution option, detailed at
    [Setting Transaction Isolation Levels including DBAPI Autocommit](../core/connections.html#dbapi-autocommit).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Psycopg2 Transaction Isolation Level](#psycopg2-isolation-level)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Setting Transaction Isolation Levels including DBAPI Autocommit](../core/connections.html#dbapi-autocommit)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`client_encoding`: sets the client encoding in a libpq-agnostic way, using
    psycopg2’s `set_client_encoding()` method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Unicode with Psycopg2](#psycopg2-unicode)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`executemany_mode`, `executemany_batch_page_size`, `executemany_values_page_size`:
    Allows use of psycopg2 extensions for optimizing “executemany”-style queries.
    See the referenced section below for details.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Psycopg2 Fast Execution Helpers](#psycopg2-executemany-mode)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: 'The above keyword arguments are **dialect** keyword arguments, meaning that
    they are passed as explicit keyword arguments to [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE669]'
  prefs: []
  type: TYPE_PRE
- en: 'These should not be confused with **DBAPI** connect arguments, which are passed
    as part of the [`create_engine.connect_args`](../core/engines.html#sqlalchemy.create_engine.params.connect_args
    "sqlalchemy.create_engine") dictionary and/or are passed in the URL query string,
    as detailed in the section [Custom DBAPI connect() arguments / on-connect routines](../core/engines.html#custom-dbapi-args).  ###
    SSL Connections'
  prefs: []
  type: TYPE_NORMAL
- en: The psycopg2 module has a connection argument named `sslmode` for controlling
    its behavior regarding secure (SSL) connections. The default is `sslmode=prefer`;
    it will attempt an SSL connection and if that fails it will fall back to an unencrypted
    connection. `sslmode=require` may be used to ensure that only secure connections
    are established. Consult the psycopg2 / libpq documentation for further options
    that are available.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that `sslmode` is specific to psycopg2 so it is included in the connection
    URI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE670]'
  prefs: []
  type: TYPE_PRE
- en: Unix Domain Connections
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'psycopg2 supports connecting via Unix domain connections. When the `host` portion
    of the URL is omitted, SQLAlchemy passes `None` to psycopg2, which specifies Unix-domain
    communication rather than TCP/IP communication:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE671]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, the socket file used is to connect to a Unix-domain socket in `/tmp`,
    or whatever socket directory was specified when PostgreSQL was built. This value
    can be overridden by passing a pathname to psycopg2, using `host` as an additional
    keyword argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE672]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: 'The format accepted here allows for a hostname in the main URL in addition
    to the “host” query string argument. **When using this URL format, the initial
    host is silently ignored**. That is, this URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE673]'
  prefs: []
  type: TYPE_PRE
- en: Above, the hostname `myhost1` is **silently ignored and discarded.** The host
    which is connected is the `myhost2` host.
  prefs: []
  type: TYPE_NORMAL
- en: This is to maintain some degree of compatibility with PostgreSQL’s own URL format
    which has been tested to behave the same way and for which tools like PifPaf hardcode
    two hostnames.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[PQconnectdbParams](https://www.postgresql.org/docs/current/static/libpq-connect.html#LIBPQ-PQCONNECTDBPARAMS)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Specifying multiple fallback hosts'
  prefs: []
  type: TYPE_NORMAL
- en: 'psycopg2 supports multiple connection points in the connection string. When
    the `host` parameter is used multiple times in the query section of the URL, SQLAlchemy
    will create a single string of the host and port information provided to make
    the connections. Tokens may consist of `host::port` or just `host`; in the latter
    case, the default port is selected by libpq. In the example below, three host
    connections are specified, for `HostA::PortA`, `HostB` connecting to the default
    port, and `HostC::PortC`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE674]'
  prefs: []
  type: TYPE_PRE
- en: 'As an alternative, libpq query string format also may be used; this specifies
    `host` and `port` as single query string arguments with comma-separated lists
    - the default port can be chosen by indicating an empty value in the comma separated
    list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE675]'
  prefs: []
  type: TYPE_PRE
- en: With either URL style, connections to each host is attempted based on a configurable
    strategy, which may be configured using the libpq `target_session_attrs` parameter.
    Per libpq this defaults to `any` which indicates a connection to each host is
    then attempted until a connection is successful. Other strategies include `primary`,
    `prefer-standby`, etc. The complete list is documented by PostgreSQL at [libpq
    connection strings](https://www.postgresql.org/docs/current/libpq-connect.html#LIBPQ-CONNSTRING).
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to indicate two hosts using the `primary` strategy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE676]'
  prefs: []
  type: TYPE_PRE
- en: 'Changed in version 1.4.40: Port specification in psycopg2 multiple host format
    is repaired, previously ports were not correctly interpreted in this context.
    libpq comma-separated format is also now supported.'
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 1.3.20: Support for multiple hosts in PostgreSQL connection
    string.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[libpq connection strings](https://www.postgresql.org/docs/current/libpq-connect.html#LIBPQ-CONNSTRING)
    - please refer to this section in the libpq documentation for complete background
    on multiple host support.'
  prefs: []
  type: TYPE_NORMAL
- en: Empty DSN Connections / Environment Variable Connections
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The psycopg2 DBAPI can connect to PostgreSQL by passing an empty DSN to the
    libpq client library, which by default indicates to connect to a localhost PostgreSQL
    database that is open for “trust” connections. This behavior can be further tailored
    using a particular set of environment variables which are prefixed with `PG_...`,
    which are consumed by `libpq` to take the place of any or all elements of the
    connection string.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this form, the URL can be passed without any elements other than the initial
    scheme:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE677]'
  prefs: []
  type: TYPE_PRE
- en: In the above form, a blank “dsn” string is passed to the `psycopg2.connect()`
    function which in turn represents an empty DSN passed to libpq.
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 1.3.2: support for parameter-less connections with psycopg2.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Environment Variables](https://www.postgresql.org/docs/current/libpq-envars.html)
    - PostgreSQL documentation on how to use `PG_...` environment variables for connections.'
  prefs: []
  type: TYPE_NORMAL
- en: '### Per-Statement/Connection Execution Options'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following DBAPI-specific options are respected when used with [`Connection.execution_options()`](../core/connections.html#sqlalchemy.engine.Connection.execution_options
    "sqlalchemy.engine.Connection.execution_options"), [`Executable.execution_options()`](../core/selectable.html#sqlalchemy.sql.expression.Executable.execution_options
    "sqlalchemy.sql.expression.Executable.execution_options"), [`Query.execution_options()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.execution_options
    "sqlalchemy.orm.Query.execution_options"), in addition to those not specific to
    DBAPIs:'
  prefs: []
  type: TYPE_NORMAL
- en: '`isolation_level` - Set the transaction isolation level for the lifespan of
    a [`Connection`](../core/connections.html#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    (can only be set on a connection, not a statement or query). See [Psycopg2 Transaction
    Isolation Level](#psycopg2-isolation-level).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stream_results` - Enable or disable usage of psycopg2 server side cursors
    - this feature makes use of “named” cursors in combination with special result
    handling methods so that result rows are not fully buffered. Defaults to False,
    meaning cursors are buffered by default.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`max_row_buffer` - when using `stream_results`, an integer value that specifies
    the maximum number of rows to buffer at a time. This is interpreted by the `BufferedRowCursorResult`,
    and if omitted the buffer will grow to ultimately store 1000 rows at a time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Changed in version 1.4: The `max_row_buffer` size can now be greater than 1000,
    and the buffer will grow to that size.  ### Psycopg2 Fast Execution Helpers'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Modern versions of psycopg2 include a feature known as [Fast Execution Helpers](https://www.psycopg.org/docs/extras.html#fast-execution-helpers)
    , which have been shown in benchmarking to improve psycopg2’s executemany() performance,
    primarily with INSERT statements, by at least an order of magnitude.
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy implements a native form of the “insert many values” handler that
    will rewrite a single-row INSERT statement to accommodate for many values at once
    within an extended VALUES clause; this handler is equivalent to psycopg2’s `execute_values()`
    handler; an overview of this feature and its configuration are at [“Insert Many
    Values” Behavior for INSERT statements](../core/connections.html#engine-insertmanyvalues).
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 2.0: Replaced psycopg2’s `execute_values()` fast execution helper
    with a native SQLAlchemy mechanism known as [insertmanyvalues](../core/connections.html#engine-insertmanyvalues).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The psycopg2 dialect retains the ability to use the psycopg2-specific `execute_batch()`
    feature, although it is not expected that this is a widely used feature. The use
    of this extension may be enabled using the `executemany_mode` flag which may be
    passed to [`create_engine()`](../core/engines.html#sqlalchemy.create_engine "sqlalchemy.create_engine"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE678]'
  prefs: []
  type: TYPE_PRE
- en: 'Possible options for `executemany_mode` include:'
  prefs: []
  type: TYPE_NORMAL
- en: '`values_only` - this is the default value. SQLAlchemy’s native [insertmanyvalues](../core/connections.html#engine-insertmanyvalues)
    handler is used for qualifying INSERT statements, assuming [`create_engine.use_insertmanyvalues`](../core/engines.html#sqlalchemy.create_engine.params.use_insertmanyvalues
    "sqlalchemy.create_engine") is left at its default value of `True`. This handler
    rewrites simple INSERT statements to include multiple VALUES clauses so that many
    parameter sets can be inserted with one statement.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''values_plus_batch''`- SQLAlchemy’s native [insertmanyvalues](../core/connections.html#engine-insertmanyvalues)
    handler is used for qualifying INSERT statements, assuming [`create_engine.use_insertmanyvalues`](../core/engines.html#sqlalchemy.create_engine.params.use_insertmanyvalues
    "sqlalchemy.create_engine") is left at its default value of `True`. Then, psycopg2’s
    `execute_batch()` handler is used for qualifying UPDATE and DELETE statements
    when executed with multiple parameter sets. When using this mode, the [`CursorResult.rowcount`](../core/connections.html#sqlalchemy.engine.CursorResult.rowcount
    "sqlalchemy.engine.CursorResult.rowcount") attribute will not contain a value
    for executemany-style executions against UPDATE and DELETE statements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Changed in version 2.0: Removed the `''batch''` and `''None''` options from
    psycopg2 `executemany_mode`. Control over batching for INSERT statements is now
    configured via the [`create_engine.use_insertmanyvalues`](../core/engines.html#sqlalchemy.create_engine.params.use_insertmanyvalues
    "sqlalchemy.create_engine") engine-level parameter.'
  prefs: []
  type: TYPE_NORMAL
- en: The term “qualifying statements” refers to the statement being executed being
    a Core [`insert()`](../core/dml.html#sqlalchemy.sql.expression.insert "sqlalchemy.sql.expression.insert"),
    [`update()`](../core/dml.html#sqlalchemy.sql.expression.update "sqlalchemy.sql.expression.update")
    or [`delete()`](../core/dml.html#sqlalchemy.sql.expression.delete "sqlalchemy.sql.expression.delete")
    construct, and **not** a plain textual SQL string or one constructed using [`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text
    "sqlalchemy.sql.expression.text"). It also may **not** be a special “extension”
    statement such as an “ON CONFLICT” “upsert” statement. When using the ORM, all
    insert/update/delete statements used by the ORM flush process are qualifying.
  prefs: []
  type: TYPE_NORMAL
- en: The “page size” for the psycopg2 “batch” strategy can be affected by using the
    `executemany_batch_page_size` parameter, which defaults to 100.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the “insertmanyvalues” feature, the page size can be controlled using the
    [`create_engine.insertmanyvalues_page_size`](../core/engines.html#sqlalchemy.create_engine.params.insertmanyvalues_page_size
    "sqlalchemy.create_engine") parameter, which defaults to 1000\. An example of
    modifying both parameters is below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE679]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[“Insert Many Values” Behavior for INSERT statements](../core/connections.html#engine-insertmanyvalues)
    - background on “insertmanyvalues”'
  prefs: []
  type: TYPE_NORMAL
- en: '[Sending Multiple Parameters](../tutorial/dbapi_transactions.html#tutorial-multiple-parameters)
    - General information on using the [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") object to execute statements in such a way as
    to make use of the DBAPI `.executemany()` method.  ### Unicode with Psycopg2'
  prefs: []
  type: TYPE_NORMAL
- en: The psycopg2 DBAPI driver supports Unicode data transparently.
  prefs: []
  type: TYPE_NORMAL
- en: 'The client character encoding can be controlled for the psycopg2 dialect in
    the following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For PostgreSQL 9.1 and above, the `client_encoding` parameter may be passed
    in the database URL; this parameter is consumed by the underlying `libpq` PostgreSQL
    client library:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE680]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Alternatively, the above `client_encoding` value may be passed using [`create_engine.connect_args`](../core/engines.html#sqlalchemy.create_engine.params.connect_args
    "sqlalchemy.create_engine") for programmatic establishment with `libpq`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE681]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For all PostgreSQL versions, psycopg2 supports a client-side encoding value
    that will be passed to database connections when they are first established. The
    SQLAlchemy psycopg2 dialect supports this using the `client_encoding` parameter
    passed to [`create_engine()`](../core/engines.html#sqlalchemy.create_engine "sqlalchemy.create_engine"):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE682]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The above `client_encoding` parameter admittedly is very similar in appearance
    to usage of the parameter within the [`create_engine.connect_args`](../core/engines.html#sqlalchemy.create_engine.params.connect_args
    "sqlalchemy.create_engine") dictionary; the difference above is that the parameter
    is consumed by psycopg2 and is passed to the database connection using `SET client_encoding
    TO 'utf8'`; in the previously mentioned style, the parameter is instead passed
    through psycopg2 and consumed by the `libpq` library.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'A common way to set up client encoding with PostgreSQL databases is to ensure
    it is configured within the server-side postgresql.conf file; this is the recommended
    way to set encoding for a server that is consistently of one encoding in all databases:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE683]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Transactions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The psycopg2 dialect fully supports SAVEPOINT and two-phase commit operations.
  prefs: []
  type: TYPE_NORMAL
- en: '### Psycopg2 Transaction Isolation Level'
  prefs: []
  type: TYPE_NORMAL
- en: As discussed in [Transaction Isolation Level](#postgresql-isolation-level),
    all PostgreSQL dialects support setting of transaction isolation level both via
    the `isolation_level` parameter passed to [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") , as well as the `isolation_level` argument used by
    [`Connection.execution_options()`](../core/connections.html#sqlalchemy.engine.Connection.execution_options
    "sqlalchemy.engine.Connection.execution_options"). When using the psycopg2 dialect
    , these options make use of psycopg2’s `set_isolation_level()` connection method,
    rather than emitting a PostgreSQL directive; this is because psycopg2’s API-level
    setting is always emitted at the start of each transaction in any case.
  prefs: []
  type: TYPE_NORMAL
- en: 'The psycopg2 dialect supports these constants for isolation level:'
  prefs: []
  type: TYPE_NORMAL
- en: '`READ COMMITTED`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`READ UNCOMMITTED`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`REPEATABLE READ`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SERIALIZABLE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AUTOCOMMIT`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Transaction Isolation Level](#postgresql-isolation-level)'
  prefs: []
  type: TYPE_NORMAL
- en: '[pg8000 Transaction Isolation Level](#pg8000-isolation-level)'
  prefs: []
  type: TYPE_NORMAL
- en: NOTICE logging
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The psycopg2 dialect will log PostgreSQL NOTICE messages via the `sqlalchemy.dialects.postgresql`
    logger. When this logger is set to the `logging.INFO` level, notice messages will
    be logged:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE684]'
  prefs: []
  type: TYPE_PRE
- en: 'Above, it is assumed that logging is configured externally. If this is not
    the case, configuration such as `logging.basicConfig()` must be utilized:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE685]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Logging HOWTO](https://docs.python.org/3/howto/logging.html) - on the python.org
    website'
  prefs: []
  type: TYPE_NORMAL
- en: '### HSTORE type'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `psycopg2` DBAPI includes an extension to natively handle marshalling of
    the HSTORE type. The SQLAlchemy psycopg2 dialect will enable this extension by
    default when psycopg2 version 2.4 or greater is used, and it is detected that
    the target database has the HSTORE type set up for use. In other words, when the
    dialect makes the first connection, a sequence like the following is performed:'
  prefs: []
  type: TYPE_NORMAL
- en: Request the available HSTORE oids using `psycopg2.extras.HstoreAdapter.get_oids()`.
    If this function returns a list of HSTORE identifiers, we then determine that
    the `HSTORE` extension is present. This function is **skipped** if the version
    of psycopg2 installed is less than version 2.4.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the `use_native_hstore` flag is at its default of `True`, and we’ve detected
    that `HSTORE` oids are available, the `psycopg2.extensions.register_hstore()`
    extension is invoked for all connections.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `register_hstore()` extension has the effect of **all Python dictionaries
    being accepted as parameters regardless of the type of target column in SQL**.
    The dictionaries are converted by this extension into a textual HSTORE expression.
    If this behavior is not desired, disable the use of the hstore extension by setting
    `use_native_hstore` to `False` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE686]'
  prefs: []
  type: TYPE_PRE
- en: The `HSTORE` type is **still supported** when the `psycopg2.extensions.register_hstore()`
    extension is not used. It merely means that the coercion between Python dictionaries
    and the HSTORE string format, on both the parameter side and the result side,
    will take place within SQLAlchemy’s own marshalling logic, and not that of `psycopg2`
    which may be more performant.
  prefs: []
  type: TYPE_NORMAL
- en: DBAPI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Documentation and download information (if applicable) for psycopg2 is available
    at: [https://pypi.org/project/psycopg2/](https://pypi.org/project/psycopg2/)'
  prefs: []
  type: TYPE_NORMAL
- en: Connecting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Connect String:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE687]'
  prefs: []
  type: TYPE_PRE
- en: '### psycopg2 Connect Arguments'
  prefs: []
  type: TYPE_NORMAL
- en: 'Keyword arguments that are specific to the SQLAlchemy psycopg2 dialect may
    be passed to [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine"), and include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`isolation_level`: This option, available for all PostgreSQL dialects, includes
    the `AUTOCOMMIT` isolation level when using the psycopg2 dialect. This option
    sets the **default** isolation level for the connection that is set immediately
    upon connection to the database before the connection is pooled. This option is
    generally superseded by the more modern [`Connection.execution_options.isolation_level`](../core/connections.html#sqlalchemy.engine.Connection.execution_options.params.isolation_level
    "sqlalchemy.engine.Connection.execution_options") execution option, detailed at
    [Setting Transaction Isolation Levels including DBAPI Autocommit](../core/connections.html#dbapi-autocommit).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Psycopg2 Transaction Isolation Level](#psycopg2-isolation-level)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Setting Transaction Isolation Levels including DBAPI Autocommit](../core/connections.html#dbapi-autocommit)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`client_encoding`: sets the client encoding in a libpq-agnostic way, using
    psycopg2’s `set_client_encoding()` method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Unicode with Psycopg2](#psycopg2-unicode)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`executemany_mode`, `executemany_batch_page_size`, `executemany_values_page_size`:
    Allows use of psycopg2 extensions for optimizing “executemany”-style queries.
    See the referenced section below for details.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Psycopg2 Fast Execution Helpers](#psycopg2-executemany-mode)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: 'The above keyword arguments are **dialect** keyword arguments, meaning that
    they are passed as explicit keyword arguments to [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE688]'
  prefs: []
  type: TYPE_PRE
- en: These should not be confused with **DBAPI** connect arguments, which are passed
    as part of the [`create_engine.connect_args`](../core/engines.html#sqlalchemy.create_engine.params.connect_args
    "sqlalchemy.create_engine") dictionary and/or are passed in the URL query string,
    as detailed in the section [Custom DBAPI connect() arguments / on-connect routines](../core/engines.html#custom-dbapi-args).
  prefs: []
  type: TYPE_NORMAL
- en: '### SSL Connections'
  prefs: []
  type: TYPE_NORMAL
- en: The psycopg2 module has a connection argument named `sslmode` for controlling
    its behavior regarding secure (SSL) connections. The default is `sslmode=prefer`;
    it will attempt an SSL connection and if that fails it will fall back to an unencrypted
    connection. `sslmode=require` may be used to ensure that only secure connections
    are established. Consult the psycopg2 / libpq documentation for further options
    that are available.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that `sslmode` is specific to psycopg2 so it is included in the connection
    URI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE689]'
  prefs: []
  type: TYPE_PRE
- en: Unix Domain Connections
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'psycopg2 supports connecting via Unix domain connections. When the `host` portion
    of the URL is omitted, SQLAlchemy passes `None` to psycopg2, which specifies Unix-domain
    communication rather than TCP/IP communication:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE690]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, the socket file used is to connect to a Unix-domain socket in `/tmp`,
    or whatever socket directory was specified when PostgreSQL was built. This value
    can be overridden by passing a pathname to psycopg2, using `host` as an additional
    keyword argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE691]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: 'The format accepted here allows for a hostname in the main URL in addition
    to the “host” query string argument. **When using this URL format, the initial
    host is silently ignored**. That is, this URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE692]'
  prefs: []
  type: TYPE_PRE
- en: Above, the hostname `myhost1` is **silently ignored and discarded.** The host
    which is connected is the `myhost2` host.
  prefs: []
  type: TYPE_NORMAL
- en: This is to maintain some degree of compatibility with PostgreSQL’s own URL format
    which has been tested to behave the same way and for which tools like PifPaf hardcode
    two hostnames.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[PQconnectdbParams](https://www.postgresql.org/docs/current/static/libpq-connect.html#LIBPQ-PQCONNECTDBPARAMS)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Specifying multiple fallback hosts'
  prefs: []
  type: TYPE_NORMAL
- en: 'psycopg2 supports multiple connection points in the connection string. When
    the `host` parameter is used multiple times in the query section of the URL, SQLAlchemy
    will create a single string of the host and port information provided to make
    the connections. Tokens may consist of `host::port` or just `host`; in the latter
    case, the default port is selected by libpq. In the example below, three host
    connections are specified, for `HostA::PortA`, `HostB` connecting to the default
    port, and `HostC::PortC`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE693]'
  prefs: []
  type: TYPE_PRE
- en: 'As an alternative, libpq query string format also may be used; this specifies
    `host` and `port` as single query string arguments with comma-separated lists
    - the default port can be chosen by indicating an empty value in the comma separated
    list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE694]'
  prefs: []
  type: TYPE_PRE
- en: With either URL style, connections to each host is attempted based on a configurable
    strategy, which may be configured using the libpq `target_session_attrs` parameter.
    Per libpq this defaults to `any` which indicates a connection to each host is
    then attempted until a connection is successful. Other strategies include `primary`,
    `prefer-standby`, etc. The complete list is documented by PostgreSQL at [libpq
    connection strings](https://www.postgresql.org/docs/current/libpq-connect.html#LIBPQ-CONNSTRING).
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to indicate two hosts using the `primary` strategy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE695]'
  prefs: []
  type: TYPE_PRE
- en: 'Changed in version 1.4.40: Port specification in psycopg2 multiple host format
    is repaired, previously ports were not correctly interpreted in this context.
    libpq comma-separated format is also now supported.'
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 1.3.20: Support for multiple hosts in PostgreSQL connection
    string.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[libpq connection strings](https://www.postgresql.org/docs/current/libpq-connect.html#LIBPQ-CONNSTRING)
    - please refer to this section in the libpq documentation for complete background
    on multiple host support.'
  prefs: []
  type: TYPE_NORMAL
- en: Empty DSN Connections / Environment Variable Connections
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The psycopg2 DBAPI can connect to PostgreSQL by passing an empty DSN to the
    libpq client library, which by default indicates to connect to a localhost PostgreSQL
    database that is open for “trust” connections. This behavior can be further tailored
    using a particular set of environment variables which are prefixed with `PG_...`,
    which are consumed by `libpq` to take the place of any or all elements of the
    connection string.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this form, the URL can be passed without any elements other than the initial
    scheme:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE696]'
  prefs: []
  type: TYPE_PRE
- en: In the above form, a blank “dsn” string is passed to the `psycopg2.connect()`
    function which in turn represents an empty DSN passed to libpq.
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 1.3.2: support for parameter-less connections with psycopg2.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Environment Variables](https://www.postgresql.org/docs/current/libpq-envars.html)
    - PostgreSQL documentation on how to use `PG_...` environment variables for connections.'
  prefs: []
  type: TYPE_NORMAL
- en: '### Per-Statement/Connection Execution Options'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following DBAPI-specific options are respected when used with [`Connection.execution_options()`](../core/connections.html#sqlalchemy.engine.Connection.execution_options
    "sqlalchemy.engine.Connection.execution_options"), [`Executable.execution_options()`](../core/selectable.html#sqlalchemy.sql.expression.Executable.execution_options
    "sqlalchemy.sql.expression.Executable.execution_options"), [`Query.execution_options()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.execution_options
    "sqlalchemy.orm.Query.execution_options"), in addition to those not specific to
    DBAPIs:'
  prefs: []
  type: TYPE_NORMAL
- en: '`isolation_level` - Set the transaction isolation level for the lifespan of
    a [`Connection`](../core/connections.html#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    (can only be set on a connection, not a statement or query). See [Psycopg2 Transaction
    Isolation Level](#psycopg2-isolation-level).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stream_results` - Enable or disable usage of psycopg2 server side cursors
    - this feature makes use of “named” cursors in combination with special result
    handling methods so that result rows are not fully buffered. Defaults to False,
    meaning cursors are buffered by default.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`max_row_buffer` - when using `stream_results`, an integer value that specifies
    the maximum number of rows to buffer at a time. This is interpreted by the `BufferedRowCursorResult`,
    and if omitted the buffer will grow to ultimately store 1000 rows at a time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Changed in version 1.4: The `max_row_buffer` size can now be greater than 1000,
    and the buffer will grow to that size.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '### Psycopg2 Fast Execution Helpers'
  prefs: []
  type: TYPE_NORMAL
- en: Modern versions of psycopg2 include a feature known as [Fast Execution Helpers](https://www.psycopg.org/docs/extras.html#fast-execution-helpers)
    , which have been shown in benchmarking to improve psycopg2’s executemany() performance,
    primarily with INSERT statements, by at least an order of magnitude.
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy implements a native form of the “insert many values” handler that
    will rewrite a single-row INSERT statement to accommodate for many values at once
    within an extended VALUES clause; this handler is equivalent to psycopg2’s `execute_values()`
    handler; an overview of this feature and its configuration are at [“Insert Many
    Values” Behavior for INSERT statements](../core/connections.html#engine-insertmanyvalues).
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 2.0: Replaced psycopg2’s `execute_values()` fast execution helper
    with a native SQLAlchemy mechanism known as [insertmanyvalues](../core/connections.html#engine-insertmanyvalues).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The psycopg2 dialect retains the ability to use the psycopg2-specific `execute_batch()`
    feature, although it is not expected that this is a widely used feature. The use
    of this extension may be enabled using the `executemany_mode` flag which may be
    passed to [`create_engine()`](../core/engines.html#sqlalchemy.create_engine "sqlalchemy.create_engine"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE697]'
  prefs: []
  type: TYPE_PRE
- en: 'Possible options for `executemany_mode` include:'
  prefs: []
  type: TYPE_NORMAL
- en: '`values_only` - this is the default value. SQLAlchemy’s native [insertmanyvalues](../core/connections.html#engine-insertmanyvalues)
    handler is used for qualifying INSERT statements, assuming [`create_engine.use_insertmanyvalues`](../core/engines.html#sqlalchemy.create_engine.params.use_insertmanyvalues
    "sqlalchemy.create_engine") is left at its default value of `True`. This handler
    rewrites simple INSERT statements to include multiple VALUES clauses so that many
    parameter sets can be inserted with one statement.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`''values_plus_batch''`- SQLAlchemy’s native [insertmanyvalues](../core/connections.html#engine-insertmanyvalues)
    handler is used for qualifying INSERT statements, assuming [`create_engine.use_insertmanyvalues`](../core/engines.html#sqlalchemy.create_engine.params.use_insertmanyvalues
    "sqlalchemy.create_engine") is left at its default value of `True`. Then, psycopg2’s
    `execute_batch()` handler is used for qualifying UPDATE and DELETE statements
    when executed with multiple parameter sets. When using this mode, the [`CursorResult.rowcount`](../core/connections.html#sqlalchemy.engine.CursorResult.rowcount
    "sqlalchemy.engine.CursorResult.rowcount") attribute will not contain a value
    for executemany-style executions against UPDATE and DELETE statements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Changed in version 2.0: Removed the `''batch''` and `''None''` options from
    psycopg2 `executemany_mode`. Control over batching for INSERT statements is now
    configured via the [`create_engine.use_insertmanyvalues`](../core/engines.html#sqlalchemy.create_engine.params.use_insertmanyvalues
    "sqlalchemy.create_engine") engine-level parameter.'
  prefs: []
  type: TYPE_NORMAL
- en: The term “qualifying statements” refers to the statement being executed being
    a Core [`insert()`](../core/dml.html#sqlalchemy.sql.expression.insert "sqlalchemy.sql.expression.insert"),
    [`update()`](../core/dml.html#sqlalchemy.sql.expression.update "sqlalchemy.sql.expression.update")
    or [`delete()`](../core/dml.html#sqlalchemy.sql.expression.delete "sqlalchemy.sql.expression.delete")
    construct, and **not** a plain textual SQL string or one constructed using [`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text
    "sqlalchemy.sql.expression.text"). It also may **not** be a special “extension”
    statement such as an “ON CONFLICT” “upsert” statement. When using the ORM, all
    insert/update/delete statements used by the ORM flush process are qualifying.
  prefs: []
  type: TYPE_NORMAL
- en: The “page size” for the psycopg2 “batch” strategy can be affected by using the
    `executemany_batch_page_size` parameter, which defaults to 100.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the “insertmanyvalues” feature, the page size can be controlled using the
    [`create_engine.insertmanyvalues_page_size`](../core/engines.html#sqlalchemy.create_engine.params.insertmanyvalues_page_size
    "sqlalchemy.create_engine") parameter, which defaults to 1000\. An example of
    modifying both parameters is below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE698]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[“Insert Many Values” Behavior for INSERT statements](../core/connections.html#engine-insertmanyvalues)
    - background on “insertmanyvalues”'
  prefs: []
  type: TYPE_NORMAL
- en: '[Sending Multiple Parameters](../tutorial/dbapi_transactions.html#tutorial-multiple-parameters)
    - General information on using the [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") object to execute statements in such a way as
    to make use of the DBAPI `.executemany()` method.'
  prefs: []
  type: TYPE_NORMAL
- en: '### Unicode with Psycopg2'
  prefs: []
  type: TYPE_NORMAL
- en: The psycopg2 DBAPI driver supports Unicode data transparently.
  prefs: []
  type: TYPE_NORMAL
- en: 'The client character encoding can be controlled for the psycopg2 dialect in
    the following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For PostgreSQL 9.1 and above, the `client_encoding` parameter may be passed
    in the database URL; this parameter is consumed by the underlying `libpq` PostgreSQL
    client library:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE699]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Alternatively, the above `client_encoding` value may be passed using [`create_engine.connect_args`](../core/engines.html#sqlalchemy.create_engine.params.connect_args
    "sqlalchemy.create_engine") for programmatic establishment with `libpq`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE700]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For all PostgreSQL versions, psycopg2 supports a client-side encoding value
    that will be passed to database connections when they are first established. The
    SQLAlchemy psycopg2 dialect supports this using the `client_encoding` parameter
    passed to [`create_engine()`](../core/engines.html#sqlalchemy.create_engine "sqlalchemy.create_engine"):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE701]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The above `client_encoding` parameter admittedly is very similar in appearance
    to usage of the parameter within the [`create_engine.connect_args`](../core/engines.html#sqlalchemy.create_engine.params.connect_args
    "sqlalchemy.create_engine") dictionary; the difference above is that the parameter
    is consumed by psycopg2 and is passed to the database connection using `SET client_encoding
    TO 'utf8'`; in the previously mentioned style, the parameter is instead passed
    through psycopg2 and consumed by the `libpq` library.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'A common way to set up client encoding with PostgreSQL databases is to ensure
    it is configured within the server-side postgresql.conf file; this is the recommended
    way to set encoding for a server that is consistently of one encoding in all databases:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE702]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Transactions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The psycopg2 dialect fully supports SAVEPOINT and two-phase commit operations.
  prefs: []
  type: TYPE_NORMAL
- en: '### Psycopg2 Transaction Isolation Level'
  prefs: []
  type: TYPE_NORMAL
- en: As discussed in [Transaction Isolation Level](#postgresql-isolation-level),
    all PostgreSQL dialects support setting of transaction isolation level both via
    the `isolation_level` parameter passed to [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") , as well as the `isolation_level` argument used by
    [`Connection.execution_options()`](../core/connections.html#sqlalchemy.engine.Connection.execution_options
    "sqlalchemy.engine.Connection.execution_options"). When using the psycopg2 dialect
    , these options make use of psycopg2’s `set_isolation_level()` connection method,
    rather than emitting a PostgreSQL directive; this is because psycopg2’s API-level
    setting is always emitted at the start of each transaction in any case.
  prefs: []
  type: TYPE_NORMAL
- en: 'The psycopg2 dialect supports these constants for isolation level:'
  prefs: []
  type: TYPE_NORMAL
- en: '`READ COMMITTED`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`READ UNCOMMITTED`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`REPEATABLE READ`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SERIALIZABLE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AUTOCOMMIT`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Transaction Isolation Level](#postgresql-isolation-level)'
  prefs: []
  type: TYPE_NORMAL
- en: '[pg8000 Transaction Isolation Level](#pg8000-isolation-level)'
  prefs: []
  type: TYPE_NORMAL
- en: NOTICE logging
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The psycopg2 dialect will log PostgreSQL NOTICE messages via the `sqlalchemy.dialects.postgresql`
    logger. When this logger is set to the `logging.INFO` level, notice messages will
    be logged:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE703]'
  prefs: []
  type: TYPE_PRE
- en: 'Above, it is assumed that logging is configured externally. If this is not
    the case, configuration such as `logging.basicConfig()` must be utilized:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE704]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Logging HOWTO](https://docs.python.org/3/howto/logging.html) - on the python.org
    website'
  prefs: []
  type: TYPE_NORMAL
- en: '### HSTORE type'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `psycopg2` DBAPI includes an extension to natively handle marshalling of
    the HSTORE type. The SQLAlchemy psycopg2 dialect will enable this extension by
    default when psycopg2 version 2.4 or greater is used, and it is detected that
    the target database has the HSTORE type set up for use. In other words, when the
    dialect makes the first connection, a sequence like the following is performed:'
  prefs: []
  type: TYPE_NORMAL
- en: Request the available HSTORE oids using `psycopg2.extras.HstoreAdapter.get_oids()`.
    If this function returns a list of HSTORE identifiers, we then determine that
    the `HSTORE` extension is present. This function is **skipped** if the version
    of psycopg2 installed is less than version 2.4.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the `use_native_hstore` flag is at its default of `True`, and we’ve detected
    that `HSTORE` oids are available, the `psycopg2.extensions.register_hstore()`
    extension is invoked for all connections.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `register_hstore()` extension has the effect of **all Python dictionaries
    being accepted as parameters regardless of the type of target column in SQL**.
    The dictionaries are converted by this extension into a textual HSTORE expression.
    If this behavior is not desired, disable the use of the hstore extension by setting
    `use_native_hstore` to `False` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE705]'
  prefs: []
  type: TYPE_PRE
- en: The `HSTORE` type is **still supported** when the `psycopg2.extensions.register_hstore()`
    extension is not used. It merely means that the coercion between Python dictionaries
    and the HSTORE string format, on both the parameter side and the result side,
    will take place within SQLAlchemy’s own marshalling logic, and not that of `psycopg2`
    which may be more performant.
  prefs: []
  type: TYPE_NORMAL
- en: '## psycopg'
  prefs: []
  type: TYPE_NORMAL
- en: Support for the PostgreSQL database via the psycopg (a.k.a. psycopg 3) driver.
  prefs: []
  type: TYPE_NORMAL
- en: DBAPI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Documentation and download information (if applicable) for psycopg (a.k.a.
    psycopg 3) is available at: [https://pypi.org/project/psycopg/](https://pypi.org/project/psycopg/)'
  prefs: []
  type: TYPE_NORMAL
- en: Connecting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Connect String:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE706]'
  prefs: []
  type: TYPE_PRE
- en: '`psycopg` is the package and module name for version 3 of the `psycopg` database
    driver, formerly known as `psycopg2`. This driver is different enough from its
    `psycopg2` predecessor that SQLAlchemy supports it via a totally separate dialect;
    support for `psycopg2` is expected to remain for as long as that package continues
    to function for modern Python versions, and also remains the default dialect for
    the `postgresql://` dialect series.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The SQLAlchemy `psycopg` dialect provides both a sync and an async implementation
    under the same dialect name. The proper version is selected depending on how the
    engine is created:'
  prefs: []
  type: TYPE_NORMAL
- en: 'calling [`create_engine()`](../core/engines.html#sqlalchemy.create_engine "sqlalchemy.create_engine")
    with `postgresql+psycopg://...` will automatically select the sync version, e.g.:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE707]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'calling [`create_async_engine()`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.create_async_engine
    "sqlalchemy.ext.asyncio.create_async_engine") with `postgresql+psycopg://...`
    will automatically select the async version, e.g.:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE708]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The asyncio version of the dialect may also be specified explicitly using the
    `psycopg_async` suffix, as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE709]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[psycopg2](#postgresql-psycopg2) - The SQLAlchemy `psycopg` dialect shares
    most of its behavior with the `psycopg2` dialect. Further documentation is available
    there.'
  prefs: []
  type: TYPE_NORMAL
- en: Using a different Cursor class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One of the differences between `psycopg` and the older `psycopg2` is how bound
    parameters are handled: `psycopg2` would bind them client side, while `psycopg`
    by default will bind them server side.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s possible to configure `psycopg` to do client side binding by specifying
    the `cursor_factory` to be `ClientCursor` when creating the engine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE710]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly when using an async engine the `AsyncClientCursor` can be specified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE711]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Client-side-binding cursors](https://www.psycopg.org/psycopg3/docs/advanced/cursors.html#client-side-binding-cursors)'
  prefs: []
  type: TYPE_NORMAL
- en: DBAPI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Documentation and download information (if applicable) for psycopg (a.k.a.
    psycopg 3) is available at: [https://pypi.org/project/psycopg/](https://pypi.org/project/psycopg/)'
  prefs: []
  type: TYPE_NORMAL
- en: Connecting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Connect String:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE712]'
  prefs: []
  type: TYPE_PRE
- en: Using a different Cursor class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One of the differences between `psycopg` and the older `psycopg2` is how bound
    parameters are handled: `psycopg2` would bind them client side, while `psycopg`
    by default will bind them server side.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s possible to configure `psycopg` to do client side binding by specifying
    the `cursor_factory` to be `ClientCursor` when creating the engine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE713]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly when using an async engine the `AsyncClientCursor` can be specified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE714]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Client-side-binding cursors](https://www.psycopg.org/psycopg3/docs/advanced/cursors.html#client-side-binding-cursors)'
  prefs: []
  type: TYPE_NORMAL
- en: '## pg8000'
  prefs: []
  type: TYPE_NORMAL
- en: Support for the PostgreSQL database via the pg8000 driver.
  prefs: []
  type: TYPE_NORMAL
- en: DBAPI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Documentation and download information (if applicable) for pg8000 is available
    at: [https://pypi.org/project/pg8000/](https://pypi.org/project/pg8000/)'
  prefs: []
  type: TYPE_NORMAL
- en: Connecting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Connect String:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE715]'
  prefs: []
  type: TYPE_PRE
- en: 'Changed in version 1.4: The pg8000 dialect has been updated for version 1.16.6
    and higher, and is again part of SQLAlchemy’s continuous integration with full
    feature support.'
  prefs: []
  type: TYPE_NORMAL
- en: '### Unicode'
  prefs: []
  type: TYPE_NORMAL
- en: 'pg8000 will encode / decode string values between it and the server using the
    PostgreSQL `client_encoding` parameter; by default this is the value in the `postgresql.conf`
    file, which often defaults to `SQL_ASCII`. Typically, this can be changed to `utf-8`,
    as a more useful default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE716]'
  prefs: []
  type: TYPE_PRE
- en: 'The `client_encoding` can be overridden for a session by executing the SQL:'
  prefs: []
  type: TYPE_NORMAL
- en: SET CLIENT_ENCODING TO ‘utf8’;
  prefs: []
  type: TYPE_NORMAL
- en: 'SQLAlchemy will execute this SQL on all new connections based on the value
    passed to [`create_engine()`](../core/engines.html#sqlalchemy.create_engine "sqlalchemy.create_engine")
    using the `client_encoding` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE717]  ### SSL Connections'
  prefs: []
  type: TYPE_NORMAL
- en: 'pg8000 accepts a Python `SSLContext` object which may be specified using the
    [`create_engine.connect_args`](../core/engines.html#sqlalchemy.create_engine.params.connect_args
    "sqlalchemy.create_engine") dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE718]'
  prefs: []
  type: TYPE_PRE
- en: 'If the server uses an automatically-generated certificate that is self-signed
    or does not match the host name (as seen from the client), it may also be necessary
    to disable hostname checking:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE719]  ### pg8000 Transaction Isolation Level'
  prefs: []
  type: TYPE_NORMAL
- en: 'The pg8000 dialect offers the same isolation level settings as that of the
    [psycopg2](#psycopg2-isolation-level) dialect:'
  prefs: []
  type: TYPE_NORMAL
- en: '`READ COMMITTED`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`READ UNCOMMITTED`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`REPEATABLE READ`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SERIALIZABLE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AUTOCOMMIT`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Transaction Isolation Level](#postgresql-isolation-level)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Psycopg2 Transaction Isolation Level](#psycopg2-isolation-level)'
  prefs: []
  type: TYPE_NORMAL
- en: DBAPI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Documentation and download information (if applicable) for pg8000 is available
    at: [https://pypi.org/project/pg8000/](https://pypi.org/project/pg8000/)'
  prefs: []
  type: TYPE_NORMAL
- en: Connecting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Connect String:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE720]'
  prefs: []
  type: TYPE_PRE
- en: '### Unicode'
  prefs: []
  type: TYPE_NORMAL
- en: 'pg8000 will encode / decode string values between it and the server using the
    PostgreSQL `client_encoding` parameter; by default this is the value in the `postgresql.conf`
    file, which often defaults to `SQL_ASCII`. Typically, this can be changed to `utf-8`,
    as a more useful default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE721]'
  prefs: []
  type: TYPE_PRE
- en: 'The `client_encoding` can be overridden for a session by executing the SQL:'
  prefs: []
  type: TYPE_NORMAL
- en: SET CLIENT_ENCODING TO ‘utf8’;
  prefs: []
  type: TYPE_NORMAL
- en: 'SQLAlchemy will execute this SQL on all new connections based on the value
    passed to [`create_engine()`](../core/engines.html#sqlalchemy.create_engine "sqlalchemy.create_engine")
    using the `client_encoding` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE722]'
  prefs: []
  type: TYPE_PRE
- en: '### SSL Connections'
  prefs: []
  type: TYPE_NORMAL
- en: 'pg8000 accepts a Python `SSLContext` object which may be specified using the
    [`create_engine.connect_args`](../core/engines.html#sqlalchemy.create_engine.params.connect_args
    "sqlalchemy.create_engine") dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE723]'
  prefs: []
  type: TYPE_PRE
- en: 'If the server uses an automatically-generated certificate that is self-signed
    or does not match the host name (as seen from the client), it may also be necessary
    to disable hostname checking:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE724]'
  prefs: []
  type: TYPE_PRE
- en: '### pg8000 Transaction Isolation Level'
  prefs: []
  type: TYPE_NORMAL
- en: 'The pg8000 dialect offers the same isolation level settings as that of the
    [psycopg2](#psycopg2-isolation-level) dialect:'
  prefs: []
  type: TYPE_NORMAL
- en: '`READ COMMITTED`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`READ UNCOMMITTED`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`REPEATABLE READ`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SERIALIZABLE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AUTOCOMMIT`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Transaction Isolation Level](#postgresql-isolation-level)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Psycopg2 Transaction Isolation Level](#psycopg2-isolation-level)'
  prefs: []
  type: TYPE_NORMAL
- en: '## asyncpg'
  prefs: []
  type: TYPE_NORMAL
- en: Support for the PostgreSQL database via the asyncpg driver.
  prefs: []
  type: TYPE_NORMAL
- en: DBAPI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Documentation and download information (if applicable) for asyncpg is available
    at: [https://magicstack.github.io/asyncpg/](https://magicstack.github.io/asyncpg/)'
  prefs: []
  type: TYPE_NORMAL
- en: Connecting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Connect String:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE725]'
  prefs: []
  type: TYPE_PRE
- en: The asyncpg dialect is SQLAlchemy’s first Python asyncio dialect.
  prefs: []
  type: TYPE_NORMAL
- en: Using a special asyncio mediation layer, the asyncpg dialect is usable as the
    backend for the [SQLAlchemy asyncio](../orm/extensions/asyncio.html) extension
    package.
  prefs: []
  type: TYPE_NORMAL
- en: 'This dialect should normally be used only with the [`create_async_engine()`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.create_async_engine
    "sqlalchemy.ext.asyncio.create_async_engine") engine creation function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE726]'
  prefs: []
  type: TYPE_PRE
- en: New in version 1.4.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: By default asyncpg does not decode the `json` and `jsonb` types and returns
    them as strings. SQLAlchemy sets default type decoder for `json` and `jsonb` types
    using the python builtin `json.loads` function. The json implementation used can
    be changed by setting the attribute `json_deserializer` when creating the engine
    with `create_engine()` or `create_async_engine()`.
  prefs: []
  type: TYPE_NORMAL
- en: '### Multihost Connections'
  prefs: []
  type: TYPE_NORMAL
- en: 'The asyncpg dialect features support for multiple fallback hosts in the same
    way as that of the psycopg2 and psycopg dialects. The syntax is the same, using
    `host=<host>:<port>` combinations as additional query string arguments; however,
    there is no default port, so all hosts must have a complete port number present,
    otherwise an exception is raised:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE727]'
  prefs: []
  type: TYPE_PRE
- en: For complete background on this syntax, see [Specifying multiple fallback hosts](#psycopg2-multi-host).
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.18.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Specifying multiple fallback hosts](#psycopg2-multi-host)  ### Prepared Statement
    Cache'
  prefs: []
  type: TYPE_NORMAL
- en: 'The asyncpg SQLAlchemy dialect makes use of `asyncpg.connection.prepare()`
    for all statements. The prepared statement objects are cached after construction
    which appears to grant a 10% or more performance improvement for statement invocation.
    The cache is on a per-DBAPI connection basis, which means that the primary storage
    for prepared statements is within DBAPI connections pooled within the connection
    pool. The size of this cache defaults to 100 statements per DBAPI connection and
    may be adjusted using the `prepared_statement_cache_size` DBAPI argument (note
    that while this argument is implemented by SQLAlchemy, it is part of the DBAPI
    emulation portion of the asyncpg dialect, therefore is handled as a DBAPI argument,
    not a dialect argument):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE728]'
  prefs: []
  type: TYPE_PRE
- en: 'To disable the prepared statement cache, use a value of zero:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE729]'
  prefs: []
  type: TYPE_PRE
- en: 'New in version 1.4.0b2: Added `prepared_statement_cache_size` for asyncpg.'
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: The `asyncpg` database driver necessarily uses caches for PostgreSQL type OIDs,
    which become stale when custom PostgreSQL datatypes such as `ENUM` objects are
    changed via DDL operations. Additionally, prepared statements themselves which
    are optionally cached by SQLAlchemy’s driver as described above may also become
    “stale” when DDL has been emitted to the PostgreSQL database which modifies the
    tables or other objects involved in a particular prepared statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'The SQLAlchemy asyncpg dialect will invalidate these caches within its local
    process when statements that represent DDL are emitted on a local connection,
    but this is only controllable within a single Python process / database engine.
    If DDL changes are made from other database engines and/or processes, a running
    application may encounter asyncpg exceptions `InvalidCachedStatementError` and/or
    `InternalServerError("cache lookup failed for type <oid>")` if it refers to pooled
    database connections which operated upon the previous structures. The SQLAlchemy
    asyncpg dialect will recover from these error cases when the driver raises these
    exceptions by clearing its internal caches as well as those of the asyncpg driver
    in response to them, but cannot prevent them from being raised in the first place
    if the cached prepared statement or asyncpg type caches have gone stale, nor can
    it retry the statement as the PostgreSQL transaction is invalidated when these
    errors occur.  ### Prepared Statement Name with PGBouncer'
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, asyncpg enumerates prepared statements in numeric order, which
    can lead to errors if a name has already been taken for another prepared statement.
    This issue can arise if your application uses database proxies such as PgBouncer
    to handle connections. One possible workaround is to use dynamic prepared statement
    names, which asyncpg now supports through an optional `name` value for the statement
    name. This allows you to generate your own unique names that won’t conflict with
    existing ones. To achieve this, you can provide a function that will be called
    every time a prepared statement is prepared:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE730]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/MagicStack/asyncpg/issues/837](https://github.com/MagicStack/asyncpg/issues/837)'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/sqlalchemy/sqlalchemy/issues/6467](https://github.com/sqlalchemy/sqlalchemy/issues/6467)'
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: When using PGBouncer, to prevent a buildup of useless prepared statements in
    your application, it’s important to use the [`NullPool`](../core/pooling.html#sqlalchemy.pool.NullPool
    "sqlalchemy.pool.NullPool") pool class, and to configure PgBouncer to use [DISCARD](https://www.postgresql.org/docs/current/sql-discard.html)
    when returning connections. The DISCARD command is used to release resources held
    by the db connection, including prepared statements. Without proper setup, prepared
    statements can accumulate quickly and cause performance issues.
  prefs: []
  type: TYPE_NORMAL
- en: Disabling the PostgreSQL JIT to improve ENUM datatype handling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Asyncpg has an [issue](https://github.com/MagicStack/asyncpg/issues/727) when
    using PostgreSQL ENUM datatypes, where upon the creation of new database connections,
    an expensive query may be emitted in order to retrieve metadata regarding custom
    types which has been shown to negatively affect performance. To mitigate this
    issue, the PostgreSQL “jit” setting may be disabled from the client using this
    setting passed to [`create_async_engine()`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.create_async_engine
    "sqlalchemy.ext.asyncio.create_async_engine"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE731]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/MagicStack/asyncpg/issues/727](https://github.com/MagicStack/asyncpg/issues/727)'
  prefs: []
  type: TYPE_NORMAL
- en: DBAPI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Documentation and download information (if applicable) for asyncpg is available
    at: [https://magicstack.github.io/asyncpg/](https://magicstack.github.io/asyncpg/)'
  prefs: []
  type: TYPE_NORMAL
- en: Connecting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Connect String:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE732]'
  prefs: []
  type: TYPE_PRE
- en: '### Multihost Connections'
  prefs: []
  type: TYPE_NORMAL
- en: 'The asyncpg dialect features support for multiple fallback hosts in the same
    way as that of the psycopg2 and psycopg dialects. The syntax is the same, using
    `host=<host>:<port>` combinations as additional query string arguments; however,
    there is no default port, so all hosts must have a complete port number present,
    otherwise an exception is raised:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE733]'
  prefs: []
  type: TYPE_PRE
- en: For complete background on this syntax, see [Specifying multiple fallback hosts](#psycopg2-multi-host).
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.18.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Specifying multiple fallback hosts](#psycopg2-multi-host)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Prepared Statement Cache'
  prefs: []
  type: TYPE_NORMAL
- en: 'The asyncpg SQLAlchemy dialect makes use of `asyncpg.connection.prepare()`
    for all statements. The prepared statement objects are cached after construction
    which appears to grant a 10% or more performance improvement for statement invocation.
    The cache is on a per-DBAPI connection basis, which means that the primary storage
    for prepared statements is within DBAPI connections pooled within the connection
    pool. The size of this cache defaults to 100 statements per DBAPI connection and
    may be adjusted using the `prepared_statement_cache_size` DBAPI argument (note
    that while this argument is implemented by SQLAlchemy, it is part of the DBAPI
    emulation portion of the asyncpg dialect, therefore is handled as a DBAPI argument,
    not a dialect argument):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE734]'
  prefs: []
  type: TYPE_PRE
- en: 'To disable the prepared statement cache, use a value of zero:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE735]'
  prefs: []
  type: TYPE_PRE
- en: 'New in version 1.4.0b2: Added `prepared_statement_cache_size` for asyncpg.'
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: The `asyncpg` database driver necessarily uses caches for PostgreSQL type OIDs,
    which become stale when custom PostgreSQL datatypes such as `ENUM` objects are
    changed via DDL operations. Additionally, prepared statements themselves which
    are optionally cached by SQLAlchemy’s driver as described above may also become
    “stale” when DDL has been emitted to the PostgreSQL database which modifies the
    tables or other objects involved in a particular prepared statement.
  prefs: []
  type: TYPE_NORMAL
- en: The SQLAlchemy asyncpg dialect will invalidate these caches within its local
    process when statements that represent DDL are emitted on a local connection,
    but this is only controllable within a single Python process / database engine.
    If DDL changes are made from other database engines and/or processes, a running
    application may encounter asyncpg exceptions `InvalidCachedStatementError` and/or
    `InternalServerError("cache lookup failed for type <oid>")` if it refers to pooled
    database connections which operated upon the previous structures. The SQLAlchemy
    asyncpg dialect will recover from these error cases when the driver raises these
    exceptions by clearing its internal caches as well as those of the asyncpg driver
    in response to them, but cannot prevent them from being raised in the first place
    if the cached prepared statement or asyncpg type caches have gone stale, nor can
    it retry the statement as the PostgreSQL transaction is invalidated when these
    errors occur.
  prefs: []
  type: TYPE_NORMAL
- en: '### Prepared Statement Name with PGBouncer'
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, asyncpg enumerates prepared statements in numeric order, which
    can lead to errors if a name has already been taken for another prepared statement.
    This issue can arise if your application uses database proxies such as PgBouncer
    to handle connections. One possible workaround is to use dynamic prepared statement
    names, which asyncpg now supports through an optional `name` value for the statement
    name. This allows you to generate your own unique names that won’t conflict with
    existing ones. To achieve this, you can provide a function that will be called
    every time a prepared statement is prepared:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE736]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/MagicStack/asyncpg/issues/837](https://github.com/MagicStack/asyncpg/issues/837)'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/sqlalchemy/sqlalchemy/issues/6467](https://github.com/sqlalchemy/sqlalchemy/issues/6467)'
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: When using PGBouncer, to prevent a buildup of useless prepared statements in
    your application, it’s important to use the [`NullPool`](../core/pooling.html#sqlalchemy.pool.NullPool
    "sqlalchemy.pool.NullPool") pool class, and to configure PgBouncer to use [DISCARD](https://www.postgresql.org/docs/current/sql-discard.html)
    when returning connections. The DISCARD command is used to release resources held
    by the db connection, including prepared statements. Without proper setup, prepared
    statements can accumulate quickly and cause performance issues.
  prefs: []
  type: TYPE_NORMAL
- en: Disabling the PostgreSQL JIT to improve ENUM datatype handling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Asyncpg has an [issue](https://github.com/MagicStack/asyncpg/issues/727) when
    using PostgreSQL ENUM datatypes, where upon the creation of new database connections,
    an expensive query may be emitted in order to retrieve metadata regarding custom
    types which has been shown to negatively affect performance. To mitigate this
    issue, the PostgreSQL “jit” setting may be disabled from the client using this
    setting passed to [`create_async_engine()`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.create_async_engine
    "sqlalchemy.ext.asyncio.create_async_engine"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE737]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/MagicStack/asyncpg/issues/727](https://github.com/MagicStack/asyncpg/issues/727)'
  prefs: []
  type: TYPE_NORMAL
- en: '## psycopg2cffi'
  prefs: []
  type: TYPE_NORMAL
- en: Support for the PostgreSQL database via the psycopg2cffi driver.
  prefs: []
  type: TYPE_NORMAL
- en: DBAPI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Documentation and download information (if applicable) for psycopg2cffi is
    available at: [https://pypi.org/project/psycopg2cffi/](https://pypi.org/project/psycopg2cffi/)'
  prefs: []
  type: TYPE_NORMAL
- en: Connecting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Connect String:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE738]'
  prefs: []
  type: TYPE_PRE
- en: '`psycopg2cffi` is an adaptation of `psycopg2`, using CFFI for the C layer.
    This makes it suitable for use in e.g. PyPy. Documentation is as per `psycopg2`.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sqlalchemy.dialects.postgresql.psycopg2`](#module-sqlalchemy.dialects.postgresql.psycopg2
    "sqlalchemy.dialects.postgresql.psycopg2")'
  prefs: []
  type: TYPE_NORMAL
- en: DBAPI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Documentation and download information (if applicable) for psycopg2cffi is
    available at: [https://pypi.org/project/psycopg2cffi/](https://pypi.org/project/psycopg2cffi/)'
  prefs: []
  type: TYPE_NORMAL
- en: Connecting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Connect String:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE739]'
  prefs: []
  type: TYPE_PRE
