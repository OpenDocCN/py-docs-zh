- en: Composite Column Types
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 复合列类型
- en: 原文：[https://docs.sqlalchemy.org/en/20/orm/composites.html](https://docs.sqlalchemy.org/en/20/orm/composites.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://docs.sqlalchemy.org/en/20/orm/composites.html](https://docs.sqlalchemy.org/en/20/orm/composites.html)
- en: Sets of columns can be associated with a single user-defined datatype, which
    in modern use is normally a Python [dataclass](https://docs.python.org/3/library/dataclasses.html).
    The ORM provides a single attribute which represents the group of columns using
    the class you provide.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 列集合可以关联到一个单一用户定义的数据类型，现代使用中通常是一个 Python [dataclass](https://docs.python.org/3/library/dataclasses.html)。ORM
    提供了一个属性，使用您提供的类来表示列的组。
- en: 'A simple example represents pairs of [`Integer`](../core/type_basics.html#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer") columns as a `Point` object, with attributes `.x`
    and `.y`. Using a dataclass, these attributes are defined with the corresponding
    `int` Python type:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的例子表示一对 [`Integer`](../core/type_basics.html#sqlalchemy.types.Integer "sqlalchemy.types.Integer")
    列作为一个 `Point` 对象，带有属性 `.x` 和 `.y`。使用 dataclass，这些属性使用相应的 `int` Python 类型定义：
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Non-dataclass forms are also accepted, but require additional methods to be
    implemented. For an example using a non-dataclass class, see the section [Using
    Legacy Non-Dataclasses](#composite-legacy-no-dataclass).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 也接受非 dataclass 形式，但需要实现额外的方法。有关使用非 dataclass 类的示例，请参见 [Using Legacy Non-Dataclasses](#composite-legacy-no-dataclass)
    部分。
- en: 'New in version 2.0: The [`composite()`](#sqlalchemy.orm.composite "sqlalchemy.orm.composite")
    construct fully supports Python dataclasses including the ability to derive mapped
    column datatypes from the composite class.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 2.0 版中新增：[`composite()`](#sqlalchemy.orm.composite "sqlalchemy.orm.composite")
    构造完全支持 Python dataclasses，包括从复合类派生映射列数据类型的能力。
- en: We will create a mapping to a table `vertices`, which represents two points
    as `x1/y1` and `x2/y2`. The `Point` class is associated with the mapped columns
    using the [`composite()`](#sqlalchemy.orm.composite "sqlalchemy.orm.composite")
    construct.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个映射到表 `vertices` 的映射，表示两个点为 `x1/y1` 和 `x2/y2`。使用 [`composite()`](#sqlalchemy.orm.composite
    "sqlalchemy.orm.composite") 构造将 `Point` 类与映射列关联起来。
- en: 'The example below illustrates the most modern form of [`composite()`](#sqlalchemy.orm.composite
    "sqlalchemy.orm.composite") as used with a fully [Annotated Declarative Table](declarative_tables.html#orm-declarative-mapped-column)
    configuration. [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") constructs representing each column are passed
    directly to [`composite()`](#sqlalchemy.orm.composite "sqlalchemy.orm.composite"),
    indicating zero or more aspects of the columns to be generated, in this case the
    names; the [`composite()`](#sqlalchemy.orm.composite "sqlalchemy.orm.composite")
    construct derives the column types (in this case `int`, corresponding to [`Integer`](../core/type_basics.html#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer")) from the dataclass directly:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的示例说明了与完全 [Annotated Declarative Table](declarative_tables.html#orm-declarative-mapped-column)
    配置一起使用的最现代形式的 [`composite()`](#sqlalchemy.orm.composite "sqlalchemy.orm.composite")，[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") 构造表示每个列直接传递给 [`composite()`](#sqlalchemy.orm.composite
    "sqlalchemy.orm.composite")，指示要生成的列的零个或多个方面，在这种情况下是名称；[`composite()`](#sqlalchemy.orm.composite
    "sqlalchemy.orm.composite") 构造直接从数据类中推导列类型（在本例中为 `int`，对应于 [`Integer`](../core/type_basics.html#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer")）：
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Tip
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: In the example above the columns that represent the composites (`x1`, `y1`,
    etc.) are also accessible on the class but are not correctly understood by type
    checkers. If accessing the single columns is important they can be explicitly
    declared, as shown in [Map columns directly, pass attribute names to composite](#composite-with-typing).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，表示复合的列（`x1`、`y1` 等）也可以在类上访问，但类型检查器不能正确理解。如果访问单列很重要，可以明确声明它们，如 [Map columns
    directly, pass attribute names to composite](#composite-with-typing) 中所示。
- en: 'The above mapping would correspond to a CREATE TABLE statement as:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 上述映射将对应于 CREATE TABLE 语句：
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Working with Mapped Composite Column Types
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用映射复合列类型
- en: 'With a mapping as illustrated in the top section, we can work with the `Vertex`
    class, where the `.start` and `.end` attributes will transparently refer to the
    columns referenced by the `Point` class, as well as with instances of the `Vertex`
    class, where the `.start` and `.end` attributes will refer to instances of the
    `Point` class. The `x1`, `y1`, `x2`, and `y2` columns are handled transparently:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 使用顶部部分示例中说明的映射，我们可以使用 `Vertex` 类，在其中 `.start` 和 `.end` 属性将透明地引用 `Point` 类引用的列，以及使用
    `Vertex` 类的实例，在其中 `.start` 和 `.end` 属性将引用 `Point` 类的实例。 `x1`、`y1`、`x2` 和 `y2`
    列被透明处理：
- en: '**Persisting Point objects**'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持久化 Point 对象**'
- en: 'We can create a `Vertex` object, assign `Point` objects as members, and they
    will be persisted as expected:'
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以创建一个 `Vertex` 对象，将 `Point` 对象分配为成员，并且它们将如预期一样持久化：
- en: '[PRE3]'
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '**Selecting Point objects as columns**'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选择 Point 对象作为列**'
- en: '[`composite()`](#sqlalchemy.orm.composite "sqlalchemy.orm.composite") will
    allow the `Vertex.start` and `Vertex.end` attributes to behave like a single SQL
    expression to as much an extent as possible when using the ORM [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") (including the legacy [`Query`](queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object) to select `Point` objects:'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[`composite()`](#sqlalchemy.orm.composite "sqlalchemy.orm.composite") 将允许 `Vertex.start`
    和 `Vertex.end` 属性在使用 ORM [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")（包括传统的
    [`Query`](queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query") 对象）选择
    `Point` 对象时尽可能地行为像单个 SQL 表达式：'
- en: '[PRE4]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '**Comparing Point objects in SQL expressions**'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在 SQL 表达式中比较 Point 对象**'
- en: 'The `Vertex.start` and `Vertex.end` attributes may be used in WHERE criteria
    and similar, using ad-hoc `Point` objects for comparisons:'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Vertex.start` 和 `Vertex.end` 属性可以在 WHERE 条件和类似情况下使用，使用临时的 `Point` 对象进行比较：'
- en: '[PRE5]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'New in version 2.0: [`composite()`](#sqlalchemy.orm.composite "sqlalchemy.orm.composite")
    constructs now support “ordering” comparisons such as `<`, `>=`, and similar,
    in addition to the already-present support for `==`, `!=`.'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从 2.0 版开始：[`composite()`](#sqlalchemy.orm.composite "sqlalchemy.orm.composite")
    构造现在支持“排序”比较，例如 `<`、`>=` 等，除了已经存在的支持 `==`、`!=`。
- en: Tip
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 提示
- en: The “ordering” comparison above using the “less than” operator (`<`) as well
    as the “equality” comparison using `==`, when used to generate SQL expressions,
    are implemented by the `Comparator` class, and don’t make use of the comparison
    methods on the composite class itself, e.g. the `__lt__()` or `__eq__()` methods.
    From this it follows that the `Point` dataclass above also need not implement
    the dataclasses `order=True` parameter for the above SQL operations to work. The
    section [Redefining Comparison Operations for Composites](#composite-operations)
    contains background on how to customize the comparison operations.
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上面使用“小于”运算符 (`<`) 的“排序”比较以及使用 `==` 的“相等”比较，当用于生成 SQL 表达式时，是由 `Comparator` 类实现的，并不使用复合类本身的比较方法，例如
    `__lt__()` 或 `__eq__()` 方法。 由此可见，上述 SQL 操作也不需要实现数据类 `order=True` 参数。[重新定义复合操作](#composite-operations)部分包含如何自定义比较操作的背景信息。
- en: '**Updating Point objects on Vertex Instances**'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更新顶点实例上的 Point 对象**'
- en: 'By default, the `Point` object **must be replaced by a new object** for changes
    to be detected:'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 默认情况下，必须用新对象替换 `Point` 对象才能检测到更改：
- en: '[PRE6]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In order to allow in place changes on the composite object, the [Mutation Tracking](extensions/mutable.html)
    extension must be used. See the section [Establishing Mutability on Composites](extensions/mutable.html#mutable-composites)
    for examples.
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了允许在复合对象上进行原地更改，必须使用 [Mutation Tracking](extensions/mutable.html) 扩展。请参阅[在复合对象上建立可变性](extensions/mutable.html#mutable-composites)部分以获取示例。
- en: '## Other mapping forms for composites'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '## 复合对象的其他映射形式'
- en: The [`composite()`](#sqlalchemy.orm.composite "sqlalchemy.orm.composite") construct
    may be passed the relevant columns using a [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct, a [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column"), or the string name of an existing mapped column.
    The following examples illustrate an equivalent mapping as that of the main section
    above.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '[`composite()`](#sqlalchemy.orm.composite "sqlalchemy.orm.composite") 构造可以使用
    [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    构造、[`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    或现有映射列的字符串名称来传递相关列。以下示例说明了与上述主要部分相同的等效映射。'
- en: Map columns directly, then pass to composite
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 直接映射列，然后传递给复合对象
- en: 'Here we pass the existing [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") instances to the [`composite()`](#sqlalchemy.orm.composite
    "sqlalchemy.orm.composite") construct, as in the non-annotated example below where
    we also pass the `Point` class as the first argument to [`composite()`](#sqlalchemy.orm.composite
    "sqlalchemy.orm.composite"):'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将现有的 [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") 实例传递给 [`composite()`](#sqlalchemy.orm.composite
    "sqlalchemy.orm.composite") 构造函数，就像下面的非注释示例中一样，我们还将 `Point` 类作为第一个参数传递给 [`composite()`](#sqlalchemy.orm.composite
    "sqlalchemy.orm.composite")：
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '### Map columns directly, pass attribute names to composite'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '### 直接映射列，将属性名称传递给组合类型'
- en: 'We can write the same example above using more annotated forms where we have
    the option to pass attribute names to [`composite()`](#sqlalchemy.orm.composite
    "sqlalchemy.orm.composite") instead of full column constructs:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用更多的注释形式编写上面相同的示例，其中我们有选项将属性名称传递给 [`composite()`](#sqlalchemy.orm.composite
    "sqlalchemy.orm.composite")，而不是完整的列构造：
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Imperative mapping and imperative table
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命令式映射和命令式表
- en: 'When using [imperative table](declarative_tables.html#orm-imperative-table-configuration)
    or fully [imperative](mapping_styles.html#orm-imperative-mapping) mappings, we
    have access to [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    objects directly. These may be passed to [`composite()`](#sqlalchemy.orm.composite
    "sqlalchemy.orm.composite") as well, as in the imperative example below:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用[命令式表](declarative_tables.html#orm-imperative-table-configuration)或完全[命令式](mapping_styles.html#orm-imperative-mapping)映射时，我们可以直接访问
    [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    对象。这些也可以传递给 [`composite()`](#sqlalchemy.orm.composite "sqlalchemy.orm.composite")，就像下面的命令式示例中一样：
- en: '[PRE9]  ## Using Legacy Non-Dataclasses'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE9]  ## 使用遗留的非数据类'
- en: If not using a dataclass, the requirements for the custom datatype class are
    that it have a constructor which accepts positional arguments corresponding to
    its column format, and also provides a method `__composite_values__()` which returns
    the state of the object as a list or tuple, in order of its column-based attributes.
    It also should supply adequate `__eq__()` and `__ne__()` methods which test the
    equality of two instances.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不使用数据类，则自定义数据类型类的要求是，它具有一个构造函数，该构造函数接受与其列格式相对应的位置参数，并且还提供一个方法 `__composite_values__()`，该方法返回对象的状态作为列表或元组，按照其基于列的属性顺序。它还应该提供足够的
    `__eq__()` 和 `__ne__()` 方法，用于测试两个实例的相等性。
- en: 'To illustrate the equivalent `Point` class from the main section not using
    a dataclass:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明主要部分中的等效 `Point` 类不使用数据类：
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Usage with [`composite()`](#sqlalchemy.orm.composite "sqlalchemy.orm.composite")
    then proceeds where the columns to be associated with the `Point` class must also
    be declared with explicit types, using one of the forms at [Other mapping forms
    for composites](#orm-composite-other-forms).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 [`composite()`](#sqlalchemy.orm.composite "sqlalchemy.orm.composite") 时，需要先声明要与
    `Point` 类关联的列，并使用 [其他复合类型的映射形式](#orm-composite-other-forms) 中的一种形式进行显式类型声明。
- en: Tracking In-Place Mutations on Composites
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跟踪组合类型的就地变更
- en: In-place changes to an existing composite value are not tracked automatically.
    Instead, the composite class needs to provide events to its parent object explicitly.
    This task is largely automated via the usage of the [`MutableComposite`](extensions/mutable.html#sqlalchemy.ext.mutable.MutableComposite
    "sqlalchemy.ext.mutable.MutableComposite") mixin, which uses events to associate
    each user-defined composite object with all parent associations. Please see the
    example in [Establishing Mutability on Composites](extensions/mutable.html#mutable-composites).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 对现有的组合类型值进行的就地更改不会自动跟踪。相反，组合类需要显式向其父对象提供事件。通过使用 [`MutableComposite`](extensions/mutable.html#sqlalchemy.ext.mutable.MutableComposite
    "sqlalchemy.ext.mutable.MutableComposite") 混合类，大部分工作已自动化，该类使用事件将每个用户定义的组合对象与所有父关联关联起来。请参阅[在组合类型上建立可变性](extensions/mutable.html#mutable-composites)中的示例。
- en: '## Redefining Comparison Operations for Composites'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '## 重新定义组合类型的比较操作'
- en: 'The “equals” comparison operation by default produces an AND of all corresponding
    columns equated to one another. This can be changed using the `comparator_factory`
    argument to [`composite()`](#sqlalchemy.orm.composite "sqlalchemy.orm.composite"),
    where we specify a custom [`Comparator`](internals.html#sqlalchemy.orm.CompositeProperty.Comparator
    "sqlalchemy.orm.CompositeProperty.Comparator") class to define existing or new
    operations. Below we illustrate the “greater than” operator, implementing the
    same expression that the base “greater than” does:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，“equals”比较操作产生所有相应列相等的AND。这可以通过[`composite()`](#sqlalchemy.orm.composite
    "sqlalchemy.orm.composite")的`comparator_factory`参数进行更改，其中我们指定一个自定义的[`Comparator`](internals.html#sqlalchemy.orm.CompositeProperty.Comparator
    "sqlalchemy.orm.CompositeProperty.Comparator")类来定义现有或新的操作。下面我们举例说明“大于”运算符，实现与基本“大于”相同的表达式：
- en: '[PRE11]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Since `Point` is a dataclass, we may make use of `dataclasses.astuple()` to
    get a tuple form of `Point` instances.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`Point`是一个数据类，我们可以使用`dataclasses.astuple()`来获得`Point`实例的元组形式。
- en: 'The custom comparator then returns the appropriate SQL expression:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，自定义比较器返回适当的SQL表达式：
- en: '[PRE12]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Nesting Composites
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 嵌套复合体
- en: Composite objects can be defined to work in simple nested schemes, by redefining
    behaviors within the composite class to work as desired, then mapping the composite
    class to the full length of individual columns normally. This requires that additional
    methods to move between the “nested” and “flat” forms are defined.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 复合对象可以被定义为在简单的嵌套方案中工作，通过在复合类内重新定义所需的行为，然后将复合类映射到通常的各列的全长。这需要定义额外的方法来在“嵌套”和“平面”形式之间移动。
- en: Below we reorganize the `Vertex` class to itself be a composite object which
    refers to `Point` objects. `Vertex` and `Point` can be dataclasses, however we
    will add a custom construction method to `Vertex` that can be used to create new
    `Vertex` objects given four column values, which will will arbitrarily name `_generate()`
    and define as a classmethod so that we can make new `Vertex` objects by passing
    values to the `Vertex._generate()` method.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 下面我们重新组织`Vertex`类，使其本身成为一个复合对象，引用`Point`对象。`Vertex`和`Point`可以是数据类，但是我们将在`Vertex`中添加一个自定义的构造方法，该方法可以用于根据四个列值创建新的`Vertex`对象，我们将其任意命名为`_generate()`并定义为一个类方法，这样我们就可以通过向`Vertex._generate()`方法传递值来创建新的`Vertex`对象。
- en: We will also implement the `__composite_values__()` method, which is a fixed
    name recognized by the [`composite()`](#sqlalchemy.orm.composite "sqlalchemy.orm.composite")
    construct (introduced previously at [Using Legacy Non-Dataclasses](#composite-legacy-no-dataclass))
    that indicates a standard way of receiving the object as a flat tuple of column
    values, which in this case will supersede the usual dataclass-oriented methodology.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将实现`__composite_values__()`方法，这是一个固定名称，被[`composite()`](#sqlalchemy.orm.composite
    "sqlalchemy.orm.composite")构造函数所识别（在[使用传统非数据类](#composite-legacy-no-dataclass)中介绍过），它指示了一种接收对象作为列值的标准方式，这种情况下将取代通常的数据类方法论。
- en: With our custom `_generate()` constructor and `__composite_values__()` serializer
    method, we can now move between a flat tuple of columns and `Vertex` objects that
    contain `Point` instances. The `Vertex._generate` method is passed as the first
    argument to the [`composite()`](#sqlalchemy.orm.composite "sqlalchemy.orm.composite")
    construct as the source of new `Vertex` instances, and the `__composite_values__()`
    method will be used implicitly by [`composite()`](#sqlalchemy.orm.composite "sqlalchemy.orm.composite").
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 有了我们自定义的`_generate()`构造函数和`__composite_values__()`序列化方法，我们现在可以在列的平面元组和包含`Point`实例的`Vertex`对象之间进行转换。`Vertex._generate`方法作为[`composite()`](#sqlalchemy.orm.composite
    "sqlalchemy.orm.composite")构造函数的第一个参数传递，用于源`Vertex`实例的创建，并且`__composite_values__()`方法将隐式地被[`composite()`](#sqlalchemy.orm.composite
    "sqlalchemy.orm.composite")使用。
- en: 'For the purposes of the example, the `Vertex` composite is then mapped to a
    class called `HasVertex`, which is where the [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") containing the four source columns ultimately resides:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为了例子的目的，`Vertex`复合体随后被映射到一个名为`HasVertex`的类中，该类是包含四个源列的[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")最终所在的地方：
- en: '[PRE13]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The above mapping can then be used in terms of `HasVertex`, `Vertex`, and `Point`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，上述映射可以根据`HasVertex`、`Vertex`和`Point`来使用：
- en: '[PRE14]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Composite API
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复合API
- en: '| Object Name | Description |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| 对象名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| [composite](#sqlalchemy.orm.composite)([_class_or_attr], *attrs, [group,
    deferred, raiseload, comparator_factory, active_history, init, repr, default,
    default_factory, compare, kw_only, info, doc], **__kw) | Return a composite column-based
    property for use with a Mapper. |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| [composite](#sqlalchemy.orm.composite)([_class_or_attr], *attrs, [group,
    deferred, raiseload, comparator_factory, active_history, init, repr, default,
    default_factory, compare, kw_only, info, doc], **__kw) | 返回一个基于复合列的属性，供 Mapper
    使用。 |'
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Return a composite column-based property for use with a Mapper.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 返回一个基于复合列的属性，供 Mapper 使用。
- en: See the mapping documentation section [Composite Column Types](#mapper-composite)
    for a full usage example.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 参见映射文档部分 [复合列类型](#mapper-composite) 以获取完整的使用示例。
- en: The [`MapperProperty`](internals.html#sqlalchemy.orm.MapperProperty "sqlalchemy.orm.MapperProperty")
    returned by [`composite()`](#sqlalchemy.orm.composite "sqlalchemy.orm.composite")
    is the [`Composite`](internals.html#sqlalchemy.orm.Composite "sqlalchemy.orm.Composite").
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 由 [`composite()`](#sqlalchemy.orm.composite "sqlalchemy.orm.composite") 返回的
    [`MapperProperty`](internals.html#sqlalchemy.orm.MapperProperty "sqlalchemy.orm.MapperProperty")
    是 [`Composite`](internals.html#sqlalchemy.orm.Composite "sqlalchemy.orm.Composite")。
- en: 'Parameters:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '参数:'
- en: '`class_` – The “composite type” class, or any classmethod or callable which
    will produce a new instance of the composite object given the column values in
    order.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`class_` – “复合类型”类，或任何类方法或可调用对象，根据顺序给出列值来产生复合对象的新实例。'
- en: '`*attrs` –'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*attrs` –'
- en: 'List of elements to be mapped, which may include:'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '要映射的元素列表，可能包括:'
- en: '[`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    objects'
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    对象'
- en: '[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    constructs'
  id: totrans-77
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    构造'
- en: string names of other attributes on the mapped class, which may be any other
    SQL or object-mapped attribute. This can for example allow a composite that refers
    to a many-to-one relationship
  id: totrans-78
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 映射类上的其他属性的字符串名称，这些属性可以是任何其他 SQL 或对象映射属性。例如，这可以允许一个复合列引用一个一对多关系。
- en: '`active_history=False` – When `True`, indicates that the “previous” value for
    a scalar attribute should be loaded when replaced, if not already loaded. See
    the same flag on [`column_property()`](mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property").'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`active_history=False` – 当为 `True` 时，表示替换时标量属性的“上一个”值应加载，如果尚未加载。请参见 [`column_property()`](mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property") 上相同的标志。'
- en: '`group` – A group name for this property when marked as deferred.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`group` – 当标记为延迟加载时，此属性的分组名称。'
- en: '`deferred` – When True, the column property is “deferred”, meaning that it
    does not load immediately, and is instead loaded when the attribute is first accessed
    on an instance. See also [`deferred()`](queryguide/columns.html#sqlalchemy.orm.deferred
    "sqlalchemy.orm.deferred").'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`deferred` – 如果为 True，则列属性是“延迟加载”的，意味着它不会立即加载，而是在首次在实例上访问属性时加载。另请参见 [`deferred()`](queryguide/columns.html#sqlalchemy.orm.deferred
    "sqlalchemy.orm.deferred")。'
- en: '`comparator_factory` – a class which extends `Comparator` which provides custom
    SQL clause generation for comparison operations.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`comparator_factory` – 一个扩展了 `Comparator` 的类，为比较操作提供自定义的 SQL 子句生成。'
- en: '`doc` – optional string that will be applied as the doc on the class-bound
    descriptor.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`doc` – 可选字符串，将作为类绑定描述符的文档应用。'
- en: '`info` – Optional data dictionary which will be populated into the [`MapperProperty.info`](internals.html#sqlalchemy.orm.MapperProperty.info
    "sqlalchemy.orm.MapperProperty.info") attribute of this object.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`info` – 可选的数据字典，将填充到此对象的 [`MapperProperty.info`](internals.html#sqlalchemy.orm.MapperProperty.info
    "sqlalchemy.orm.MapperProperty.info") 属性中。'
- en: '`init` – Specific to [Declarative Dataclass Mapping](dataclasses.html#orm-declarative-native-dataclasses),
    specifies if the mapped attribute should be part of the `__init__()` method as
    generated by the dataclass process.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`init` – 特定于 [声明性数据类映射](dataclasses.html#orm-declarative-native-dataclasses)，指定映射属性是否应该是由数据类流程生成的
    `__init__()` 方法的一部分。'
- en: '`repr` – Specific to [Declarative Dataclass Mapping](dataclasses.html#orm-declarative-native-dataclasses),
    specifies if the mapped attribute should be part of the `__repr__()` method as
    generated by the dataclass process.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`repr` – 特定于 [声明性数据类映射](dataclasses.html#orm-declarative-native-dataclasses)，指定映射属性是否应该是由数据类流程生成的
    `__repr__()` 方法的一部分。'
- en: '`default_factory` – Specific to [Declarative Dataclass Mapping](dataclasses.html#orm-declarative-native-dataclasses),
    specifies a default-value generation function that will take place as part of
    the `__init__()` method as generated by the dataclass process.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`default_factory` – 特定于 [声明性 Dataclass 映射](dataclasses.html#orm-declarative-native-dataclasses)，指定将作为
    `__init__()` 方法的一部分执行的默认值生成函数。'
- en: '`compare` –'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`compare` –'
- en: Specific to [Declarative Dataclass Mapping](dataclasses.html#orm-declarative-native-dataclasses),
    indicates if this field should be included in comparison operations when generating
    the `__eq__()` and `__ne__()` methods for the mapped class.
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 特定于 [声明性 Dataclass 映射](dataclasses.html#orm-declarative-native-dataclasses)，指示在生成映射类的
    `__eq__()` 和 `__ne__()` 方法时是否应包括此字段的比较操作。
- en: New in version 2.0.0b4.
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 新版本 2.0.0b4 中。
- en: '`kw_only` – Specific to [Declarative Dataclass Mapping](dataclasses.html#orm-declarative-native-dataclasses),
    indicates if this field should be marked as keyword-only when generating the `__init__()`.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kw_only` – 特定于 [声明性 Dataclass 映射](dataclasses.html#orm-declarative-native-dataclasses)，指示是否在生成
    `__init__()` 时将此字段标记为关键字参数。'
- en: Working with Mapped Composite Column Types
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用映射复合列类型
- en: 'With a mapping as illustrated in the top section, we can work with the `Vertex`
    class, where the `.start` and `.end` attributes will transparently refer to the
    columns referenced by the `Point` class, as well as with instances of the `Vertex`
    class, where the `.start` and `.end` attributes will refer to instances of the
    `Point` class. The `x1`, `y1`, `x2`, and `y2` columns are handled transparently:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如上一节所示的映射，我们可以使用 `Vertex` 类，其中 `.start` 和 `.end` 属性将透明地引用 `Point` 类引用的列，以及使用
    `Vertex` 类的实例，其中 `.start` 和 `.end` 属性将引用 `Point` 类的实例。`x1`、`y1`、`x2` 和 `y2` 列将被透明处理：
- en: '**Persisting Point objects**'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持久化 Point 对象**'
- en: 'We can create a `Vertex` object, assign `Point` objects as members, and they
    will be persisted as expected:'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以创建一个 `Vertex` 对象，将 `Point` 对象分配为成员，并且它们将按预期持久化：
- en: '[PRE16]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '**Selecting Point objects as columns**'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选择 Point 对象作为列**'
- en: '[`composite()`](#sqlalchemy.orm.composite "sqlalchemy.orm.composite") will
    allow the `Vertex.start` and `Vertex.end` attributes to behave like a single SQL
    expression to as much an extent as possible when using the ORM [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") (including the legacy [`Query`](queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object) to select `Point` objects:'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[`composite()`](#sqlalchemy.orm.composite "sqlalchemy.orm.composite") 将允许 `Vertex.start`
    和 `Vertex.end` 属性在使用 ORM [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")（包括传统的
    [`Query`](queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query") 对象）选择
    `Point` 对象时尽可能地像单个 SQL 表达式一样行为：'
- en: '[PRE17]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '**Comparing Point objects in SQL expressions**'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**比较 SQL 表达式中的 Point 对象**'
- en: 'The `Vertex.start` and `Vertex.end` attributes may be used in WHERE criteria
    and similar, using ad-hoc `Point` objects for comparisons:'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Vertex.start` 和 `Vertex.end` 属性可用于 WHERE 条件和类似条件，使用临时 `Point` 对象进行比较：'
- en: '[PRE18]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'New in version 2.0: [`composite()`](#sqlalchemy.orm.composite "sqlalchemy.orm.composite")
    constructs now support “ordering” comparisons such as `<`, `>=`, and similar,
    in addition to the already-present support for `==`, `!=`.'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 新版本 2.0 中：[`composite()`](#sqlalchemy.orm.composite "sqlalchemy.orm.composite")
    构造现在支持“排序”比较，如 `<`、`>=`，以及已经存在的 `==`、`!=` 的支持。
- en: Tip
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 提示
- en: The “ordering” comparison above using the “less than” operator (`<`) as well
    as the “equality” comparison using `==`, when used to generate SQL expressions,
    are implemented by the `Comparator` class, and don’t make use of the comparison
    methods on the composite class itself, e.g. the `__lt__()` or `__eq__()` methods.
    From this it follows that the `Point` dataclass above also need not implement
    the dataclasses `order=True` parameter for the above SQL operations to work. The
    section [Redefining Comparison Operations for Composites](#composite-operations)
    contains background on how to customize the comparison operations.
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用“小于”运算符（`<`）的“排序”比较以及使用 `==` 的“相等性”比较，用于生成 SQL 表达式时，由 `Comparator` 类实现，并不使用复合类本身的比较方法，例如
    `__lt__()` 或 `__eq__()` 方法。由此可见，上面的 `Point` 数据类也无需实现 dataclasses 的 `order=True`
    参数，上述 SQL 操作就可以正常工作。[复合操作重新定义比较操作](#composite-operations) 包含了如何定制比较操作的背景信息。
- en: '**Updating Point objects on Vertex Instances**'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在 Vertex 实例上更新 Point 对象**'
- en: 'By default, the `Point` object **must be replaced by a new object** for changes
    to be detected:'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 默认情况下，必须通过一个新对象来替换 `Point` 对象才能检测到更改：
- en: '[PRE19]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In order to allow in place changes on the composite object, the [Mutation Tracking](extensions/mutable.html)
    extension must be used. See the section [Establishing Mutability on Composites](extensions/mutable.html#mutable-composites)
    for examples.
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了允许对复合对象进行原地更改，必须使用 [Mutation Tracking](extensions/mutable.html) 扩展。参见[在复合对象上建立可变性](extensions/mutable.html#mutable-composites)部分中的示例。
- en: '## Other mapping forms for composites'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '## 复合对象的其他映射形式'
- en: The [`composite()`](#sqlalchemy.orm.composite "sqlalchemy.orm.composite") construct
    may be passed the relevant columns using a [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct, a [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column"), or the string name of an existing mapped column.
    The following examples illustrate an equivalent mapping as that of the main section
    above.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '[`composite()`](#sqlalchemy.orm.composite "sqlalchemy.orm.composite") 构造可以使用
    [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    构造、[`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    或现有映射列的字符串名称来传递相关列。以下示例说明了与上述主要部分相同的等效映射。'
- en: Map columns directly, then pass to composite
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 直接映射列，然后传递给复合对象
- en: 'Here we pass the existing [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") instances to the [`composite()`](#sqlalchemy.orm.composite
    "sqlalchemy.orm.composite") construct, as in the non-annotated example below where
    we also pass the `Point` class as the first argument to [`composite()`](#sqlalchemy.orm.composite
    "sqlalchemy.orm.composite"):'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将现有的 [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") 实例传递给 [`composite()`](#sqlalchemy.orm.composite
    "sqlalchemy.orm.composite") 构造，就像下面的非注释示例中我们还将 `Point` 类作为 [`composite()`](#sqlalchemy.orm.composite
    "sqlalchemy.orm.composite") 的第一个参数传递一样：
- en: '[PRE20]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '### Map columns directly, pass attribute names to composite'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '### 直接映射列，将属性名称传递给复合对象'
- en: 'We can write the same example above using more annotated forms where we have
    the option to pass attribute names to [`composite()`](#sqlalchemy.orm.composite
    "sqlalchemy.orm.composite") instead of full column constructs:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用更多带有注释形式编写上面相同的示例，其中我们可以选择将属性名称传递给 [`composite()`](#sqlalchemy.orm.composite
    "sqlalchemy.orm.composite") 而不是完整的列构造：
- en: '[PRE21]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Imperative mapping and imperative table
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命令式映射和命令式表
- en: 'When using [imperative table](declarative_tables.html#orm-imperative-table-configuration)
    or fully [imperative](mapping_styles.html#orm-imperative-mapping) mappings, we
    have access to [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    objects directly. These may be passed to [`composite()`](#sqlalchemy.orm.composite
    "sqlalchemy.orm.composite") as well, as in the imperative example below:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用[命令式表](declarative_tables.html#orm-imperative-table-configuration)或完全[命令式](mapping_styles.html#orm-imperative-mapping)映射时，我们直接可以访问
    [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    对象。这些也可以像以下命令式示例中那样传递给 [`composite()`](#sqlalchemy.orm.composite "sqlalchemy.orm.composite")：
- en: '[PRE22]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Map columns directly, then pass to composite
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 直接映射列，然后传递给复合对象
- en: 'Here we pass the existing [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") instances to the [`composite()`](#sqlalchemy.orm.composite
    "sqlalchemy.orm.composite") construct, as in the non-annotated example below where
    we also pass the `Point` class as the first argument to [`composite()`](#sqlalchemy.orm.composite
    "sqlalchemy.orm.composite"):'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将现有的 [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") 实例传递给 [`composite()`](#sqlalchemy.orm.composite
    "sqlalchemy.orm.composite") 构造，就像下面的非注释示例中我们还将 `Point` 类作为 [`composite()`](#sqlalchemy.orm.composite
    "sqlalchemy.orm.composite") 的第一个参数传递一样：
- en: '[PRE23]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '### Map columns directly, pass attribute names to composite'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '### 直接映射列，将属性名称传递给复合对象'
- en: 'We can write the same example above using more annotated forms where we have
    the option to pass attribute names to [`composite()`](#sqlalchemy.orm.composite
    "sqlalchemy.orm.composite") instead of full column constructs:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用更多带有注释形式编写上面相同的示例，其中我们可以选择将属性名称传递给 [`composite()`](#sqlalchemy.orm.composite
    "sqlalchemy.orm.composite") 而不是完整的列构造：
- en: '[PRE24]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Imperative mapping and imperative table
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 命令式映射和命令式表
- en: 'When using [imperative table](declarative_tables.html#orm-imperative-table-configuration)
    or fully [imperative](mapping_styles.html#orm-imperative-mapping) mappings, we
    have access to [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    objects directly. These may be passed to [`composite()`](#sqlalchemy.orm.composite
    "sqlalchemy.orm.composite") as well, as in the imperative example below:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用[命令式表](declarative_tables.html#orm-imperative-table-configuration)或完全[命令式](mapping_styles.html#orm-imperative-mapping)映射时，我们可以直接访问[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")对象。这些也可以传递给[`composite()`](#sqlalchemy.orm.composite
    "sqlalchemy.orm.composite")，如下所示的命令式示例：
- en: '[PRE25]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '## Using Legacy Non-Dataclasses'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '## 使用传统非数据类'
- en: If not using a dataclass, the requirements for the custom datatype class are
    that it have a constructor which accepts positional arguments corresponding to
    its column format, and also provides a method `__composite_values__()` which returns
    the state of the object as a list or tuple, in order of its column-based attributes.
    It also should supply adequate `__eq__()` and `__ne__()` methods which test the
    equality of two instances.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不使用数据类，则自定义数据类型类的要求是它具有一个构造函数，该构造函数接受与其列格式对应的位置参数，并且还提供一个`__composite_values__()`方法，该方法按照其基于列的属性的顺序返回对象的状态列表或元组。它还应该提供足够的`__eq__()`和`__ne__()`方法来测试两个实例的相等性。
- en: 'To illustrate the equivalent `Point` class from the main section not using
    a dataclass:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明主要部分中的等效`Point`类不使用数据类的情况：
- en: '[PRE26]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Usage with [`composite()`](#sqlalchemy.orm.composite "sqlalchemy.orm.composite")
    then proceeds where the columns to be associated with the `Point` class must also
    be declared with explicit types, using one of the forms at [Other mapping forms
    for composites](#orm-composite-other-forms).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[`composite()`](#sqlalchemy.orm.composite "sqlalchemy.orm.composite")进行如下操作，必须使用显式类型声明与`Point`类关联的列，使用[其他复合对象映射形式](#orm-composite-other-forms)中的一种形式。
- en: Tracking In-Place Mutations on Composites
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跟踪复合对象的原位变化
- en: In-place changes to an existing composite value are not tracked automatically.
    Instead, the composite class needs to provide events to its parent object explicitly.
    This task is largely automated via the usage of the [`MutableComposite`](extensions/mutable.html#sqlalchemy.ext.mutable.MutableComposite
    "sqlalchemy.ext.mutable.MutableComposite") mixin, which uses events to associate
    each user-defined composite object with all parent associations. Please see the
    example in [Establishing Mutability on Composites](extensions/mutable.html#mutable-composites).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 对现有复合值的原位更改不会自动跟踪。相反，复合类需要显式为其父对象提供事件。通过使用[`MutableComposite`](extensions/mutable.html#sqlalchemy.ext.mutable.MutableComposite
    "sqlalchemy.ext.mutable.MutableComposite") mixin，这项任务主要通过使用事件将每个用户定义的复合对象与所有父关联关联起来来自动完成。请参阅[为复合对象建立可变性](extensions/mutable.html#mutable-composites)中的示例。
- en: '## Redefining Comparison Operations for Composites'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '## 重新定义复合对象的比较操作'
- en: 'The “equals” comparison operation by default produces an AND of all corresponding
    columns equated to one another. This can be changed using the `comparator_factory`
    argument to [`composite()`](#sqlalchemy.orm.composite "sqlalchemy.orm.composite"),
    where we specify a custom [`Comparator`](internals.html#sqlalchemy.orm.CompositeProperty.Comparator
    "sqlalchemy.orm.CompositeProperty.Comparator") class to define existing or new
    operations. Below we illustrate the “greater than” operator, implementing the
    same expression that the base “greater than” does:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，“equals”比较操作会产生所有对应列等于彼此的AND。可以使用[`composite()`](#sqlalchemy.orm.composite
    "sqlalchemy.orm.composite")的`comparator_factory`参数进行更改，其中我们指定一个自定义的[`Comparator`](internals.html#sqlalchemy.orm.CompositeProperty.Comparator
    "sqlalchemy.orm.CompositeProperty.Comparator")类来定义现有或新的操作。下面我们说明“greater than”运算符，实现与基本“greater
    than”相同的表达式：
- en: '[PRE27]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Since `Point` is a dataclass, we may make use of `dataclasses.astuple()` to
    get a tuple form of `Point` instances.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`Point`是一个数据类，我们可以利用`dataclasses.astuple()`来获得`Point`实例的元组形式。
- en: 'The custom comparator then returns the appropriate SQL expression:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，自定义比较器返回适当的SQL表达式：
- en: '[PRE28]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Nesting Composites
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 嵌套复合对象
- en: Composite objects can be defined to work in simple nested schemes, by redefining
    behaviors within the composite class to work as desired, then mapping the composite
    class to the full length of individual columns normally. This requires that additional
    methods to move between the “nested” and “flat” forms are defined.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 可以定义复合对象以在简单的嵌套方案中工作，方法是在复合类中重新定义所需的行为，然后将复合类映射到通常的单个列的完整长度。这要求定义额外的方法来在“嵌套”和“扁平”形式之间移动。
- en: Below we reorganize the `Vertex` class to itself be a composite object which
    refers to `Point` objects. `Vertex` and `Point` can be dataclasses, however we
    will add a custom construction method to `Vertex` that can be used to create new
    `Vertex` objects given four column values, which will will arbitrarily name `_generate()`
    and define as a classmethod so that we can make new `Vertex` objects by passing
    values to the `Vertex._generate()` method.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们重新组织`Vertex`类本身成为一个引用`Point`对象的复合对象。 `Vertex`和`Point`可以是数据类，但是我们将向`Vertex`添加一个自定义构造方法，该方法可用于根据四个列值创建新的`Vertex`对象，我们将任意命名为`_generate()`并定义为类方法，以便我们可以通过将值传递给`Vertex._generate()`方法来创建新的`Vertex`对象。
- en: We will also implement the `__composite_values__()` method, which is a fixed
    name recognized by the [`composite()`](#sqlalchemy.orm.composite "sqlalchemy.orm.composite")
    construct (introduced previously at [Using Legacy Non-Dataclasses](#composite-legacy-no-dataclass))
    that indicates a standard way of receiving the object as a flat tuple of column
    values, which in this case will supersede the usual dataclass-oriented methodology.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将实现`__composite_values__()`方法，这是由[`composite()`](#sqlalchemy.orm.composite
    "sqlalchemy.orm.composite")构造（在[使用传统非数据类](#composite-legacy-no-dataclass)中介绍）中识别的固定名称，表示以列值的扁平元组形式接收对象的标准方式，在这种情况下将取代通常的数据类导向方法。
- en: With our custom `_generate()` constructor and `__composite_values__()` serializer
    method, we can now move between a flat tuple of columns and `Vertex` objects that
    contain `Point` instances. The `Vertex._generate` method is passed as the first
    argument to the [`composite()`](#sqlalchemy.orm.composite "sqlalchemy.orm.composite")
    construct as the source of new `Vertex` instances, and the `__composite_values__()`
    method will be used implicitly by [`composite()`](#sqlalchemy.orm.composite "sqlalchemy.orm.composite").
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 通过我们的自定义`_generate()`构造函数和`__composite_values__()`序列化方法，我们现在可以在扁平列元组和包含`Point`实例的`Vertex`对象之间进行转换。
    `Vertex._generate`方法作为[`composite()`](#sqlalchemy.orm.composite "sqlalchemy.orm.composite")构造的第一个参数传递，用作新`Vertex`实例的来源，并且`__composite_values__()`方法将隐式地被[`composite()`](#sqlalchemy.orm.composite
    "sqlalchemy.orm.composite")使用。
- en: 'For the purposes of the example, the `Vertex` composite is then mapped to a
    class called `HasVertex`, which is where the [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") containing the four source columns ultimately resides:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 为了示例的目的，`Vertex`复合然后映射到一个名为`HasVertex`的类，其中包含最终包含四个源列的[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")：
- en: '[PRE29]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The above mapping can then be used in terms of `HasVertex`, `Vertex`, and `Point`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 上述映射可以根据`HasVertex`、`Vertex`和`Point`来使用：
- en: '[PRE30]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Composite API
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复合API
- en: '| Object Name | Description |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| 对象名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| [composite](#sqlalchemy.orm.composite)([_class_or_attr], *attrs, [group,
    deferred, raiseload, comparator_factory, active_history, init, repr, default,
    default_factory, compare, kw_only, info, doc], **__kw) | Return a composite column-based
    property for use with a Mapper. |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| [composite](#sqlalchemy.orm.composite)([_class_or_attr], *attrs, [group,
    deferred, raiseload, comparator_factory, active_history, init, repr, default,
    default_factory, compare, kw_only, info, doc], **__kw) | 返回用于与Mapper一起使用的基于复合列的属性。
    |'
- en: '[PRE31]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Return a composite column-based property for use with a Mapper.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 返回用于与Mapper一起使用的基于复合列的属性。
- en: See the mapping documentation section [Composite Column Types](#mapper-composite)
    for a full usage example.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 查看映射文档部分[复合列类型](#mapper-composite)以获取完整的使用示例。
- en: The [`MapperProperty`](internals.html#sqlalchemy.orm.MapperProperty "sqlalchemy.orm.MapperProperty")
    returned by [`composite()`](#sqlalchemy.orm.composite "sqlalchemy.orm.composite")
    is the [`Composite`](internals.html#sqlalchemy.orm.Composite "sqlalchemy.orm.Composite").
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '[`composite()`](#sqlalchemy.orm.composite "sqlalchemy.orm.composite")返回的[`MapperProperty`](internals.html#sqlalchemy.orm.MapperProperty
    "sqlalchemy.orm.MapperProperty")是[`Composite`](internals.html#sqlalchemy.orm.Composite
    "sqlalchemy.orm.Composite")。'
- en: 'Parameters:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '`class_` – The “composite type” class, or any classmethod or callable which
    will produce a new instance of the composite object given the column values in
    order.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`class_` – “复合类型”类，或任何类方法或可调用对象，将根据顺序的列值生成复合对象的新实例。'
- en: '`*attrs` –'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*attrs` –'
- en: 'List of elements to be mapped, which may include:'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要映射的元素列表，可能包括：
- en: '[`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    objects'
  id: totrans-164
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")对象'
- en: '[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    constructs'
  id: totrans-165
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")构造'
- en: string names of other attributes on the mapped class, which may be any other
    SQL or object-mapped attribute. This can for example allow a composite that refers
    to a many-to-one relationship
  id: totrans-166
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 映射类上的其他属性的字符串名称，这些属性可以是任何其他 SQL 或对象映射的属性。例如，这可以允许一个复合属性引用到一个多对一的关系。
- en: '`active_history=False` – When `True`, indicates that the “previous” value for
    a scalar attribute should be loaded when replaced, if not already loaded. See
    the same flag on [`column_property()`](mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property").'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`active_history=False` – 当为`True`时，指示在替换时应加载标量属性的“先前”值，如果尚未加载。请参阅[`column_property()`](mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property")上的相同标志。'
- en: '`group` – A group name for this property when marked as deferred.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`group` – 标记为延迟加载时，此属性的组名。'
- en: '`deferred` – When True, the column property is “deferred”, meaning that it
    does not load immediately, and is instead loaded when the attribute is first accessed
    on an instance. See also [`deferred()`](queryguide/columns.html#sqlalchemy.orm.deferred
    "sqlalchemy.orm.deferred").'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`deferred` – 当为 True 时，列属性为“延迟加载”，意味着它不会立即加载，而是在首次访问实例上的属性时加载。另请参阅[`deferred()`](queryguide/columns.html#sqlalchemy.orm.deferred
    "sqlalchemy.orm.deferred")。'
- en: '`comparator_factory` – a class which extends `Comparator` which provides custom
    SQL clause generation for comparison operations.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`comparator_factory` – 一个扩展`Comparator`的类，提供自定义的 SQL 子句生成以进行比较操作。'
- en: '`doc` – optional string that will be applied as the doc on the class-bound
    descriptor.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`doc` – 可选字符串，将应用为类绑定描述符的文档。'
- en: '`info` – Optional data dictionary which will be populated into the [`MapperProperty.info`](internals.html#sqlalchemy.orm.MapperProperty.info
    "sqlalchemy.orm.MapperProperty.info") attribute of this object.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`info` – 可选的数据字典，将填充到此对象的[`MapperProperty.info`](internals.html#sqlalchemy.orm.MapperProperty.info
    "sqlalchemy.orm.MapperProperty.info")属性中。'
- en: '`init` – Specific to [Declarative Dataclass Mapping](dataclasses.html#orm-declarative-native-dataclasses),
    specifies if the mapped attribute should be part of the `__init__()` method as
    generated by the dataclass process.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`init` – 特定于[声明式数据类映射](dataclasses.html#orm-declarative-native-dataclasses)，指定映射属性是否应作为数据类处理生成的`__init__()`方法的一部分。'
- en: '`repr` – Specific to [Declarative Dataclass Mapping](dataclasses.html#orm-declarative-native-dataclasses),
    specifies if the mapped attribute should be part of the `__repr__()` method as
    generated by the dataclass process.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`repr` – 特定于[声明式数据类映射](dataclasses.html#orm-declarative-native-dataclasses)，指定映射属性是否应作为数据类处理生成的`__repr__()`方法的一部分。'
- en: '`default_factory` – Specific to [Declarative Dataclass Mapping](dataclasses.html#orm-declarative-native-dataclasses),
    specifies a default-value generation function that will take place as part of
    the `__init__()` method as generated by the dataclass process.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`default_factory` – 特定于[声明式数据类映射](dataclasses.html#orm-declarative-native-dataclasses)，指定将作为数据类处理生成的`__init__()`方法的一部分而发生的默认值生成函数。'
- en: '`compare` –'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`compare` –'
- en: Specific to [Declarative Dataclass Mapping](dataclasses.html#orm-declarative-native-dataclasses),
    indicates if this field should be included in comparison operations when generating
    the `__eq__()` and `__ne__()` methods for the mapped class.
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 特定于[声明式数据类映射](dataclasses.html#orm-declarative-native-dataclasses)，指示在为映射类生成`__eq__()`和`__ne__()`方法时，此字段是否应包含在比较操作中。
- en: New in version 2.0.0b4.
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 新功能在版本 2.0.0b4 中引入。
- en: '`kw_only` – Specific to [Declarative Dataclass Mapping](dataclasses.html#orm-declarative-native-dataclasses),
    indicates if this field should be marked as keyword-only when generating the `__init__()`.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kw_only` – 特定于[声明式数据类映射](dataclasses.html#orm-declarative-native-dataclasses)，指示在生成`__init__()`时此字段是否应标记为关键字参数。'
