["```py\nimport jax\nimport jax.numpy as jnp\n\nglobal_list = []\n\ndef log2(x):\n  global_list.append(x)\n  ln_x = jnp.log(x)\n  ln_2 = jnp.log(2.0)\n  return ln_x / ln_2\n\nprint(jax.make_jaxpr(log2)(3.0)) \n```", "```py\n{ lambda ; a:f32[]. let\n    b:f32[] = log a\n    c:f32[] = log 2.0\n    d:f32[] = div b c\n  in (d,) } \n```", "```py\ndef log2_with_print(x):\n  print(\"printed x:\", x)\n  ln_x = jnp.log(x)\n  ln_2 = jnp.log(2.0)\n  return ln_x / ln_2\n\nprint(jax.make_jaxpr(log2_with_print)(3.)) \n```", "```py\nprinted x: Traced<ShapedArray(float32[], weak_type=True)>with<DynamicJaxprTrace(level=1/0)>\n{ lambda ; a:f32[]. let\n    b:f32[] = log a\n    c:f32[] = log 2.0\n    d:f32[] = div b c\n  in (d,) } \n```", "```py\ndef log2_if_rank_2(x):\n  if x.ndim == 2:\n    ln_x = jnp.log(x)\n    ln_2 = jnp.log(2.0)\n    return ln_x / ln_2\n  else:\n    return x\n\nprint(jax.make_jaxpr(log2_if_rank_2)(jax.numpy.array([1, 2, 3]))) \n```", "```py\n{ lambda ; a:i32[3]. let  in (a,) } \n```", "```py\nimport jax\nimport jax.numpy as jnp\n\ndef selu(x, alpha=1.67, lambda_=1.05):\n  return lambda_ * jnp.where(x > 0, x, alpha * jnp.exp(x) - alpha)\n\nx = jnp.arange(1000000)\n%timeit selu(x).block_until_ready() \n```", "```py\n2.81 ms ± 27 μs per loop (mean ± std. dev. of 7 runs, 100 loops each) \n```", "```py\nselu_jit = jax.jit(selu)\n\n# Pre-compile the function before timing...\nselu_jit(x).block_until_ready()\n\n%timeit selu_jit(x).block_until_ready() \n```", "```py\n1.01 ms ± 2.6 μs per loop (mean ± std. dev. of 7 runs, 1,000 loops each) \n```", "```py\n# Condition on value of x.\n\ndef f(x):\n  if x > 0:\n    return x\n  else:\n    return 2 * x\n\njax.jit(f)(10)  # Raises an error \n```", "```py\nTracerBoolConversionError: Attempted boolean conversion of traced array with shape bool[]..\nThe error occurred while tracing the function f at /tmp/ipykernel_1169/2956679937.py:3 for jit. This concrete value was not available in Python because it depends on the value of the argument x.\nSee https://jax.readthedocs.io/en/latest/errors.html#jax.errors.TracerBoolConversionError \n```", "```py\n# While loop conditioned on x and n.\n\ndef g(x, n):\n  i = 0\n  while i < n:\n    i += 1\n  return x + i\n\njax.jit(g)(10, 20)  # Raises an error \n```", "```py\nTracerBoolConversionError: Attempted boolean conversion of traced array with shape bool[]..\nThe error occurred while tracing the function g at /tmp/ipykernel_1169/722961019.py:3 for jit. This concrete value was not available in Python because it depends on the value of the argument n.\nSee https://jax.readthedocs.io/en/latest/errors.html#jax.errors.TracerBoolConversionError \n```", "```py\n# While loop conditioned on x and n with a jitted body.\n\n@jax.jit\ndef loop_body(prev_i):\n  return prev_i + 1\n\ndef g_inner_jitted(x, n):\n  i = 0\n  while i < n:\n    i = loop_body(i)\n  return x + i\n\ng_inner_jitted(10, 20) \n```", "```py\nArray(30, dtype=int32, weak_type=True) \n```", "```py\nf_jit_correct = jax.jit(f, static_argnums=0)\nprint(f_jit_correct(10)) \n```", "```py\n10 \n```", "```py\ng_jit_correct = jax.jit(g, static_argnames=['n'])\nprint(g_jit_correct(10, 20)) \n```", "```py\n30 \n```", "```py\nfrom functools import partial\n\n@partial(jax.jit, static_argnames=['n'])\ndef g_jit_decorated(x, n):\n  i = 0\n  while i < n:\n    i += 1\n  return x + i\n\nprint(g_jit_decorated(10, 20)) \n```", "```py\n30 \n```", "```py\nfrom functools import partial\n\ndef unjitted_loop_body(prev_i):\n  return prev_i + 1\n\ndef g_inner_jitted_partial(x, n):\n  i = 0\n  while i < n:\n    # Don't do this! each time the partial returns\n    # a function with different hash\n    i = jax.jit(partial(unjitted_loop_body))(i)\n  return x + i\n\ndef g_inner_jitted_lambda(x, n):\n  i = 0\n  while i < n:\n    # Don't do this!, lambda will also return\n    # a function with a different hash\n    i = jax.jit(lambda x: unjitted_loop_body(x))(i)\n  return x + i\n\ndef g_inner_jitted_normal(x, n):\n  i = 0\n  while i < n:\n    # this is OK, since JAX can find the\n    # cached, compiled function\n    i = jax.jit(unjitted_loop_body)(i)\n  return x + i\n\nprint(\"jit called in a loop with partials:\")\n%timeit g_inner_jitted_partial(10, 20).block_until_ready()\n\nprint(\"jit called in a loop with lambdas:\")\n%timeit g_inner_jitted_lambda(10, 20).block_until_ready()\n\nprint(\"jit called in a loop with caching:\")\n%timeit g_inner_jitted_normal(10, 20).block_until_ready() \n```", "```py\njit called in a loop with partials:\n217 ms ± 2.03 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)\njit called in a loop with lambdas:\n219 ms ± 5.44 ms per loop (mean ± std. dev. of 7 runs, 1 loop each)\njit called in a loop with caching:\n2.33 ms ± 29.5 μs per loop (mean ± std. dev. of 7 runs, 100 loops each) \n```"]