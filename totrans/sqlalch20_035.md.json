["```py\nfrom sqlalchemy import Integer, ForeignKey, String, Column\nfrom sqlalchemy.orm import DeclarativeBase\nfrom sqlalchemy.orm import relationship\n\nclass Base(DeclarativeBase):\n    pass\n\nclass Customer(Base):\n    __tablename__ = \"customer\"\n    id = mapped_column(Integer, primary_key=True)\n    name = mapped_column(String)\n\n    billing_address_id = mapped_column(Integer, ForeignKey(\"address.id\"))\n    shipping_address_id = mapped_column(Integer, ForeignKey(\"address.id\"))\n\n    billing_address = relationship(\"Address\")\n    shipping_address = relationship(\"Address\")\n\nclass Address(Base):\n    __tablename__ = \"address\"\n    id = mapped_column(Integer, primary_key=True)\n    street = mapped_column(String)\n    city = mapped_column(String)\n    state = mapped_column(String)\n    zip = mapped_column(String)\n```", "```py\nsqlalchemy.exc.AmbiguousForeignKeysError: Could not determine join\ncondition between parent/child tables on relationship\nCustomer.billing_address - there are multiple foreign key\npaths linking the tables.  Specify the 'foreign_keys' argument,\nproviding a list of those columns which should be\ncounted as containing a foreign key reference to the parent table.\n```", "```py\nclass Customer(Base):\n    __tablename__ = \"customer\"\n    id = mapped_column(Integer, primary_key=True)\n    name = mapped_column(String)\n\n    billing_address_id = mapped_column(Integer, ForeignKey(\"address.id\"))\n    shipping_address_id = mapped_column(Integer, ForeignKey(\"address.id\"))\n\n    billing_address = relationship(\"Address\", foreign_keys=[billing_address_id])\n    shipping_address = relationship(\"Address\", foreign_keys=[shipping_address_id])\n```", "```py\nbilling_address = relationship(\"Address\", foreign_keys=\"[Customer.billing_address_id]\")\n```", "```py\nbilling_address = relationship(\"Address\", foreign_keys=\"Customer.billing_address_id\")\n```", "```py\nfrom sqlalchemy import Integer, ForeignKey, String, Column\nfrom sqlalchemy.orm import DeclarativeBase\nfrom sqlalchemy.orm import relationship\n\nclass Base(DeclarativeBase):\n    pass\n\nclass User(Base):\n    __tablename__ = \"user\"\n    id = mapped_column(Integer, primary_key=True)\n    name = mapped_column(String)\n    boston_addresses = relationship(\n        \"Address\",\n        primaryjoin=\"and_(User.id==Address.user_id, Address.city=='Boston')\",\n    )\n\nclass Address(Base):\n    __tablename__ = \"address\"\n    id = mapped_column(Integer, primary_key=True)\n    user_id = mapped_column(Integer, ForeignKey(\"user.id\"))\n\n    street = mapped_column(String)\n    city = mapped_column(String)\n    state = mapped_column(String)\n    zip = mapped_column(String)\n```", "```py\nfrom sqlalchemy import cast, String, Column, Integer\nfrom sqlalchemy.orm import relationship\nfrom sqlalchemy.dialects.postgresql import INET\n\nfrom sqlalchemy.orm import DeclarativeBase\n\nclass Base(DeclarativeBase):\n    pass\n\nclass HostEntry(Base):\n    __tablename__ = \"host_entry\"\n\n    id = mapped_column(Integer, primary_key=True)\n    ip_address = mapped_column(INET)\n    content = mapped_column(String(50))\n\n    # relationship() using explicit foreign_keys, remote_side\n    parent_host = relationship(\n        \"HostEntry\",\n        primaryjoin=ip_address == cast(content, INET),\n        foreign_keys=content,\n        remote_side=ip_address,\n    )\n```", "```py\nSELECT  host_entry.id,  host_entry.ip_address,  host_entry.content\nFROM  host_entry  JOIN  host_entry  AS  host_entry_1\nON  host_entry_1.ip_address  =  CAST(host_entry.content  AS  INET)\n```", "```py\nfrom sqlalchemy.orm import foreign, remote\n\nclass HostEntry(Base):\n    __tablename__ = \"host_entry\"\n\n    id = mapped_column(Integer, primary_key=True)\n    ip_address = mapped_column(INET)\n    content = mapped_column(String(50))\n\n    # relationship() using explicit foreign() and remote() annotations\n    # in lieu of separate arguments\n    parent_host = relationship(\n        \"HostEntry\",\n        primaryjoin=remote(ip_address) == cast(foreign(content), INET),\n    )\n```", "```py\ninet_column.bool_op(\"<<\")(cidr_column)\n```", "```py\nclass IPA(Base):\n    __tablename__ = \"ip_address\"\n\n    id = mapped_column(Integer, primary_key=True)\n    v4address = mapped_column(INET)\n\n    network = relationship(\n        \"Network\",\n        primaryjoin=\"IPA.v4address.bool_op('<<')(foreign(Network.v4representation))\",\n        viewonly=True,\n    )\n\nclass Network(Base):\n    __tablename__ = \"network\"\n\n    id = mapped_column(Integer, primary_key=True)\n    v4representation = mapped_column(CIDR)\n```", "```py\nselect(IPA).join(IPA.network)\n```", "```py\nSELECT  ip_address.id  AS  ip_address_id,  ip_address.v4address  AS  ip_address_v4address\nFROM  ip_address  JOIN  network  ON  ip_address.v4address  <<  network.v4representation\n```", "```py\nfrom geoalchemy2 import Geometry\nfrom sqlalchemy import Column, Integer, func\nfrom sqlalchemy.orm import relationship, foreign\n\nclass Polygon(Base):\n    __tablename__ = \"polygon\"\n    id = mapped_column(Integer, primary_key=True)\n    geom = mapped_column(Geometry(\"POLYGON\", srid=4326))\n    points = relationship(\n        \"Point\",\n        primaryjoin=\"func.ST_Contains(foreign(Polygon.geom), Point.geom).as_comparison(1, 2)\",\n        viewonly=True,\n    )\n\nclass Point(Base):\n    __tablename__ = \"point\"\n    id = mapped_column(Integer, primary_key=True)\n    geom = mapped_column(Geometry(\"POINT\", srid=4326))\n```", "```py\nclass Magazine(Base):\n    __tablename__ = \"magazine\"\n\n    id = mapped_column(Integer, primary_key=True)\n\nclass Article(Base):\n    __tablename__ = \"article\"\n\n    article_id = mapped_column(Integer)\n    magazine_id = mapped_column(ForeignKey(\"magazine.id\"))\n    writer_id = mapped_column()\n\n    magazine = relationship(\"Magazine\")\n    writer = relationship(\"Writer\")\n\n    __table_args__ = (\n        PrimaryKeyConstraint(\"article_id\", \"magazine_id\"),\n        ForeignKeyConstraint(\n            [\"writer_id\", \"magazine_id\"], [\"writer.id\", \"writer.magazine_id\"]\n        ),\n    )\n\nclass Writer(Base):\n    __tablename__ = \"writer\"\n\n    id = mapped_column(Integer, primary_key=True)\n    magazine_id = mapped_column(ForeignKey(\"magazine.id\"), primary_key=True)\n    magazine = relationship(\"Magazine\")\n```", "```py\nSAWarning: relationship 'Article.writer' will copy column\nwriter.magazine_id to column article.magazine_id,\nwhich conflicts with relationship(s): 'Article.magazine'\n(copies magazine.id to article.magazine_id). Consider applying\nviewonly=True to read-only relationships, or provide a primaryjoin\ncondition marking writable columns with the foreign() annotation.\n```", "```py\nclass Article(Base):\n    # ...\n\n    writer = relationship(\"Writer\", foreign_keys=\"Article.writer_id\")\n```", "```py\nSELECT  article.article_id  AS  article_article_id,\n  article.magazine_id  AS  article_magazine_id,\n  article.writer_id  AS  article_writer_id\nFROM  article\nJOIN  writer  ON  writer.id  =  article.writer_id\n```", "```py\nclass Article(Base):\n    # ...\n\n    writer = relationship(\n        \"Writer\",\n        primaryjoin=\"and_(Writer.id == foreign(Article.writer_id), \"\n        \"Writer.magazine_id == Article.magazine_id)\",\n    )\n```", "```py\nclass Element(Base):\n    __tablename__ = \"element\"\n\n    path = mapped_column(String, primary_key=True)\n\n    descendants = relationship(\n        \"Element\",\n        primaryjoin=remote(foreign(path)).like(path.concat(\"/%\")),\n        viewonly=True,\n        order_by=path,\n    )\n```", "```py\nSELECT  element.path  AS  element_path\nFROM  element\nWHERE  element.path  LIKE  ('/foo/bar2'  ||  '/%')  ORDER  BY  element.path\n```", "```py\nfrom typing import List\n\nfrom sqlalchemy import Integer, ForeignKey, Column, Table\nfrom sqlalchemy.orm import DeclarativeBase, Mapped\nfrom sqlalchemy.orm import mapped_column, relationship\n\nclass Base(DeclarativeBase):\n    pass\n\nnode_to_node = Table(\n    \"node_to_node\",\n    Base.metadata,\n    Column(\"left_node_id\", Integer, ForeignKey(\"node.id\"), primary_key=True),\n    Column(\"right_node_id\", Integer, ForeignKey(\"node.id\"), primary_key=True),\n)\n\nclass Node(Base):\n    __tablename__ = \"node\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    label: Mapped[str]\n    right_nodes: Mapped[List[\"Node\"]] = relationship(\n        \"Node\",\n        secondary=node_to_node,\n        primaryjoin=id == node_to_node.c.left_node_id,\n        secondaryjoin=id == node_to_node.c.right_node_id,\n        back_populates=\"left_nodes\",\n    )\n    left_nodes: Mapped[List[\"Node\"]] = relationship(\n        \"Node\",\n        secondary=node_to_node,\n        primaryjoin=id == node_to_node.c.right_node_id,\n        secondaryjoin=id == node_to_node.c.left_node_id,\n        back_populates=\"right_nodes\",\n    )\n```", "```py\nclass Node(Base):\n    __tablename__ = \"node\"\n    id = mapped_column(Integer, primary_key=True)\n    label = mapped_column(String)\n    right_nodes = relationship(\n        \"Node\",\n        secondary=\"node_to_node\",\n        primaryjoin=\"Node.id==node_to_node.c.left_node_id\",\n        secondaryjoin=\"Node.id==node_to_node.c.right_node_id\",\n        backref=\"left_nodes\",\n    )\n```", "```py\nfrom sqlalchemy import Integer, ForeignKey, String, Column, Table, MetaData\nfrom sqlalchemy.orm import relationship, registry\n\nmetadata_obj = MetaData()\nmapper_registry = registry()\n\nnode_to_node = Table(\n    \"node_to_node\",\n    metadata_obj,\n    Column(\"left_node_id\", Integer, ForeignKey(\"node.id\"), primary_key=True),\n    Column(\"right_node_id\", Integer, ForeignKey(\"node.id\"), primary_key=True),\n)\n\nnode = Table(\n    \"node\",\n    metadata_obj,\n    Column(\"id\", Integer, primary_key=True),\n    Column(\"label\", String),\n)\n\nclass Node:\n    pass\n\nmapper_registry.map_imperatively(\n    Node,\n    node,\n    properties={\n        \"right_nodes\": relationship(\n            Node,\n            secondary=node_to_node,\n            primaryjoin=node.c.id == node_to_node.c.left_node_id,\n            secondaryjoin=node.c.id == node_to_node.c.right_node_id,\n            backref=\"left_nodes\",\n        )\n    },\n)\n```", "```py\nclass A(Base):\n    __tablename__ = \"a\"\n\n    id = mapped_column(Integer, primary_key=True)\n    b_id = mapped_column(ForeignKey(\"b.id\"))\n\n    d = relationship(\n        \"D\",\n        secondary=\"join(B, D, B.d_id == D.id).join(C, C.d_id == D.id)\",\n        primaryjoin=\"and_(A.b_id == B.id, A.id == C.a_id)\",\n        secondaryjoin=\"D.id == B.d_id\",\n        uselist=False,\n        viewonly=True,\n    )\n\nclass B(Base):\n    __tablename__ = \"b\"\n\n    id = mapped_column(Integer, primary_key=True)\n    d_id = mapped_column(ForeignKey(\"d.id\"))\n\nclass C(Base):\n    __tablename__ = \"c\"\n\n    id = mapped_column(Integer, primary_key=True)\n    a_id = mapped_column(ForeignKey(\"a.id\"))\n    d_id = mapped_column(ForeignKey(\"d.id\"))\n\nclass D(Base):\n    __tablename__ = \"d\"\n\n    id = mapped_column(Integer, primary_key=True)\n```", "```py\nsess.scalars(select(A).join(A.d)).all()\n\nSELECT  a.id  AS  a_id,  a.b_id  AS  a_b_id\nFROM  a  JOIN  (\n  b  AS  b_1  JOIN  d  AS  d_1  ON  b_1.d_id  =  d_1.id\n  JOIN  c  AS  c_1  ON  c_1.d_id  =  d_1.id)\n  ON  a.b_id  =  b_1.id  AND  a.id  =  c_1.a_id  JOIN  d  ON  d.id  =  b_1.d_id \n```", "```py\nclass A(Base):\n    __tablename__ = \"a\"\n\n    id = mapped_column(Integer, primary_key=True)\n    b_id = mapped_column(ForeignKey(\"b.id\"))\n\nclass B(Base):\n    __tablename__ = \"b\"\n\n    id = mapped_column(Integer, primary_key=True)\n\nclass C(Base):\n    __tablename__ = \"c\"\n\n    id = mapped_column(Integer, primary_key=True)\n    a_id = mapped_column(ForeignKey(\"a.id\"))\n\n    some_c_value = mapped_column(String)\n\nclass D(Base):\n    __tablename__ = \"d\"\n\n    id = mapped_column(Integer, primary_key=True)\n    c_id = mapped_column(ForeignKey(\"c.id\"))\n    b_id = mapped_column(ForeignKey(\"b.id\"))\n\n    some_d_value = mapped_column(String)\n\n# 1\\. set up the join() as a variable, so we can refer\n# to it in the mapping multiple times.\nj = join(B, D, D.b_id == B.id).join(C, C.id == D.c_id)\n\n# 2\\. Create an AliasedClass to B\nB_viacd = aliased(B, j, flat=True)\n\nA.b = relationship(B_viacd, primaryjoin=A.b_id == j.c.b_id)\n```", "```py\nsess.scalars(select(A).join(A.b)).all()\n\nSELECT  a.id  AS  a_id,  a.b_id  AS  a_b_id\nFROM  a  JOIN  (b  JOIN  d  ON  d.b_id  =  b.id  JOIN  c  ON  c.id  =  d.c_id)  ON  a.b_id  =  b.id \n```", "```py\nfrom sqlalchemy import event\n\nclass A(Base):\n    __tablename__ = \"a\"\n\n    id = mapped_column(Integer, primary_key=True)\n    b_id = mapped_column(ForeignKey(\"b.id\"))\n\n@event.listens_for(A, \"before_mapper_configured\")\ndef _configure_ab_relationship(mapper, cls):\n    # do the above configuration in a configuration hook\n\n    j = join(B, D, D.b_id == B.id).join(C, C.id == D.c_id)\n    B_viacd = aliased(B, j, flat=True)\n    A.b = relationship(B_viacd, primaryjoin=A.b_id == j.c.b_id)\n```", "```py\nfrom typing import Any\n\nB_viacd: Any = None\nb_viacd_join: Any = None\n\nclass A(Base):\n    __tablename__ = \"a\"\n\n    id: Mapped[int] = mapped_column(primary_key=True)\n    b_id: Mapped[int] = mapped_column(ForeignKey(\"b.id\"))\n\n    # 1\\. the relationship can be declared using lambdas, allowing it to resolve\n    #    to targets that are late-configured\n    b: Mapped[B] = relationship(\n        lambda: B_viacd, primaryjoin=lambda: A.b_id == b_viacd_join.c.b_id\n    )\n\n# 2\\. configure the targets of the relationship using a before_mapper_configured\n#    hook.\n@event.listens_for(A, \"before_mapper_configured\")\ndef _configure_ab_relationship(mapper, cls):\n    # 3\\. set up the join() and AliasedClass as globals from within\n    #    the configuration hook.\n\n    global B_viacd, b_viacd_join\n\n    b_viacd_join = join(B, D, D.b_id == B.id).join(C, C.id == D.c_id)\n    B_viacd = aliased(B, b_viacd_join, flat=True)\n```", "```py\nsubq = select(B).join(D, D.b_id == B.id).join(C, C.id == D.c_id).subquery()\n\nB_viacd_subquery = aliased(B, subq)\n\nA.b = relationship(B_viacd_subquery, primaryjoin=A.b_id == subq.c.id)\n```", "```py\nsess.scalars(select(A).join(A.b)).all()\n\nSELECT  a.id  AS  a_id,  a.b_id  AS  a_b_id\nFROM  a  JOIN  (SELECT  b.id  AS  id,  b.some_b_column  AS  some_b_column\nFROM  b  JOIN  d  ON  d.b_id  =  b.id  JOIN  c  ON  c.id  =  d.c_id)  AS  anon_1  ON  a.b_id  =  anon_1.id \n```", "```py\nsess.scalars(\n    select(A)\n    .join(A.b)\n    .where(B_viacd_subquery.some_b_column == \"some b\")\n    .order_by(B_viacd_subquery.id)\n).all()\n\nSELECT  a.id  AS  a_id,  a.b_id  AS  a_b_id\nFROM  a  JOIN  (SELECT  b.id  AS  id,  b.some_b_column  AS  some_b_column\nFROM  b  JOIN  d  ON  d.b_id  =  b.id  JOIN  c  ON  c.id  =  d.c_id)  AS  anon_1  ON  a.b_id  =  anon_1.id\nWHERE  anon_1.some_b_column  =  ?  ORDER  BY  anon_1.id \n```", "```py\nclass A(Base):\n    __tablename__ = \"a\"\n\n    id = mapped_column(Integer, primary_key=True)\n\nclass B(Base):\n    __tablename__ = \"b\"\n    id = mapped_column(Integer, primary_key=True)\n    a_id = mapped_column(ForeignKey(\"a.id\"))\n\npartition = select(\n    B, func.row_number().over(order_by=B.id, partition_by=B.a_id).label(\"index\")\n).alias()\n\npartitioned_b = aliased(B, partition)\n\nA.partitioned_bs = relationship(\n    partitioned_b, primaryjoin=and_(partitioned_b.a_id == A.id, partition.c.index < 10)\n)\n```", "```py\nfor a1 in session.scalars(select(A).options(selectinload(A.partitioned_bs))):\n    print(a1.partitioned_bs)  # <-- will be no more than ten objects\n```", "```py\nSELECT\n  a_1.id  AS  a_1_id,  anon_1.id  AS  anon_1_id,  anon_1.a_id  AS  anon_1_a_id,\n  anon_1.data  AS  anon_1_data,  anon_1.index  AS  anon_1_index\nFROM  a  AS  a_1\nJOIN  (\n  SELECT  b.id  AS  id,  b.a_id  AS  a_id,  b.data  AS  data,\n  row_number()  OVER  (PARTITION  BY  b.a_id  ORDER  BY  b.id)  AS  index\n  FROM  b)  AS  anon_1\nON  anon_1.a_id  =  a_1.id  AND  anon_1.index  <  %(index_1)s\nWHERE  a_1.id  IN  (  ...  primary  key  collection  ...)\nORDER  BY  a_1.id\n```", "```py\nclass User(Base):\n    __tablename__ = \"user\"\n    id = mapped_column(Integer, primary_key=True)\n\n    @property\n    def addresses(self):\n        return object_session(self).query(Address).with_parent(self).filter(...).all()\n```", "```py\nfrom __future__ import annotations\n\nimport datetime\n\nfrom sqlalchemy import and_\nfrom sqlalchemy import ForeignKey\nfrom sqlalchemy import func\nfrom sqlalchemy.orm import DeclarativeBase\nfrom sqlalchemy.orm import Mapped\nfrom sqlalchemy.orm import mapped_column\nfrom sqlalchemy.orm import relationship\n\nclass Base(DeclarativeBase):\n    pass\n\nclass User(Base):\n    __tablename__ = \"user_account\"\n\n    id: Mapped[int] = mapped_column(primary_key=True)\n    name: Mapped[str | None]\n\n    all_tasks: Mapped[list[Task]] = relationship()\n\n    current_week_tasks: Mapped[list[Task]] = relationship(\n        primaryjoin=lambda: and_(\n            User.id == Task.user_account_id,\n            # this expression works on PostgreSQL but may not be supported\n            # by other database engines\n            Task.task_date >= func.now() - datetime.timedelta(days=7),\n        ),\n        viewonly=True,\n    )\n\nclass Task(Base):\n    __tablename__ = \"task\"\n\n    id: Mapped[int] = mapped_column(primary_key=True)\n    user_account_id: Mapped[int] = mapped_column(ForeignKey(\"user_account.id\"))\n    description: Mapped[str | None]\n    task_date: Mapped[datetime.datetime] = mapped_column(server_default=func.now())\n\n    user: Mapped[User] = relationship(back_populates=\"current_week_tasks\")\n```", "```py\n>>> u1 = User()\n>>> t1 = Task(task_date=datetime.datetime.now())\n>>> t1.user = u1\n>>> u1.current_week_tasks\n[]\n```", "```py\nclass User(Base):\n    __tablename__ = \"user_account\"\n\n    id: Mapped[int] = mapped_column(primary_key=True)\n    name: Mapped[str | None]\n\n    all_tasks: Mapped[list[Task]] = relationship(back_populates=\"user\")\n\n    @property\n    def current_week_tasks(self) -> list[Task]:\n        past_seven_days = datetime.datetime.now() - datetime.timedelta(days=7)\n        return [t for t in self.all_tasks if t.task_date >= past_seven_days]\n\nclass Task(Base):\n    __tablename__ = \"task\"\n\n    id: Mapped[int] = mapped_column(primary_key=True)\n    user_account_id: Mapped[int] = mapped_column(ForeignKey(\"user_account.id\"))\n    description: Mapped[str | None]\n    task_date: Mapped[datetime.datetime] = mapped_column(server_default=func.now())\n\n    user: Mapped[User] = relationship(back_populates=\"all_tasks\")\n```", "```py\n>>> u1 = User()\n>>> t1 = Task(task_date=datetime.datetime.now())\n>>> t1.user = u1\n>>> u1.current_week_tasks\n[<__main__.Task object at 0x7f3d699523c0>]\n```", "```py\n>>> with Session(e) as sess:\n...     u1 = sess.scalar(select(User).where(User.id == 1))\n...     print(u1.current_week_tasks)\n[<__main__.Task object at 0x7f8711b906b0>]\n```", "```py\n>>> with Session(e) as sess:\n...     u1 = sess.scalar(select(User).where(User.id == 1))\n...     u1.all_tasks.append(Task(task_date=datetime.datetime.now()))\n...     sess.commit()\n...     print(u1.current_week_tasks)\n[<__main__.Task object at 0x7f8711b90ec0>, <__main__.Task object at 0x7f8711b90a10>]\n```", "```py\n>>> with Session(e) as sess:\n...     u1 = sess.scalar(select(User).where(User.id == 1))\n...     u1.all_tasks.append(Task(task_date=datetime.datetime.now()))\n...     sess.flush()\n...     sess.expire(u1, [\"current_week_tasks\"])\n...     print(u1.current_week_tasks)\n[<__main__.Task object at 0x7fd95a4c8c50>, <__main__.Task object at 0x7fd95a4c8c80>]\n```", "```py\n>>> with Session(e) as sess:\n...     u1 = sess.scalar(select(User).where(User.id == 1))\n...     u1.all_tasks.append(Task(task_date=datetime.datetime.now()))\n...     sess.expire(u1, [\"current_week_tasks\"])\n...     print(u1.current_week_tasks)  # triggers autoflush before querying\n[<__main__.Task object at 0x7fd95a4c8c50>, <__main__.Task object at 0x7fd95a4c8c80>]\n```", "```py\nfrom sqlalchemy import event, inspect\n\n@event.listens_for(User.all_tasks, \"append\")\n@event.listens_for(User.all_tasks, \"remove\")\n@event.listens_for(User.all_tasks, \"bulk_replace\")\ndef _expire_User_current_week_tasks(target, value, initiator):\n    inspect(target).session.expire(target, [\"current_week_tasks\"])\n```", "```py\n>>> with Session(e) as sess:\n...     u1 = sess.scalar(select(User).where(User.id == 1))\n...     u1.all_tasks.append(Task(task_date=datetime.datetime.now()))\n...     print(u1.current_week_tasks)\n[<__main__.Task object at 0x7f66d093ccb0>, <__main__.Task object at 0x7f66d093cce0>]\n```", "```py\n>>> with Session(e) as sess:\n...     u1 = sess.scalar(select(User).where(User.id == 1))\n...     t1 = Task(task_date=datetime.datetime.now())\n...     t1.user = u1\n...     sess.add(t1)\n...     print(u1.current_week_tasks)\n[<__main__.Task object at 0x7f3b0c070d10>, <__main__.Task object at 0x7f3b0c057d10>]\n```", "```py\nfrom sqlalchemy import Integer, ForeignKey, String, Column\nfrom sqlalchemy.orm import DeclarativeBase\nfrom sqlalchemy.orm import relationship\n\nclass Base(DeclarativeBase):\n    pass\n\nclass Customer(Base):\n    __tablename__ = \"customer\"\n    id = mapped_column(Integer, primary_key=True)\n    name = mapped_column(String)\n\n    billing_address_id = mapped_column(Integer, ForeignKey(\"address.id\"))\n    shipping_address_id = mapped_column(Integer, ForeignKey(\"address.id\"))\n\n    billing_address = relationship(\"Address\")\n    shipping_address = relationship(\"Address\")\n\nclass Address(Base):\n    __tablename__ = \"address\"\n    id = mapped_column(Integer, primary_key=True)\n    street = mapped_column(String)\n    city = mapped_column(String)\n    state = mapped_column(String)\n    zip = mapped_column(String)\n```", "```py\nsqlalchemy.exc.AmbiguousForeignKeysError: Could not determine join\ncondition between parent/child tables on relationship\nCustomer.billing_address - there are multiple foreign key\npaths linking the tables.  Specify the 'foreign_keys' argument,\nproviding a list of those columns which should be\ncounted as containing a foreign key reference to the parent table.\n```", "```py\nclass Customer(Base):\n    __tablename__ = \"customer\"\n    id = mapped_column(Integer, primary_key=True)\n    name = mapped_column(String)\n\n    billing_address_id = mapped_column(Integer, ForeignKey(\"address.id\"))\n    shipping_address_id = mapped_column(Integer, ForeignKey(\"address.id\"))\n\n    billing_address = relationship(\"Address\", foreign_keys=[billing_address_id])\n    shipping_address = relationship(\"Address\", foreign_keys=[shipping_address_id])\n```", "```py\nbilling_address = relationship(\"Address\", foreign_keys=\"[Customer.billing_address_id]\")\n```", "```py\nbilling_address = relationship(\"Address\", foreign_keys=\"Customer.billing_address_id\")\n```", "```py\nfrom sqlalchemy import Integer, ForeignKey, String, Column\nfrom sqlalchemy.orm import DeclarativeBase\nfrom sqlalchemy.orm import relationship\n\nclass Base(DeclarativeBase):\n    pass\n\nclass User(Base):\n    __tablename__ = \"user\"\n    id = mapped_column(Integer, primary_key=True)\n    name = mapped_column(String)\n    boston_addresses = relationship(\n        \"Address\",\n        primaryjoin=\"and_(User.id==Address.user_id, Address.city=='Boston')\",\n    )\n\nclass Address(Base):\n    __tablename__ = \"address\"\n    id = mapped_column(Integer, primary_key=True)\n    user_id = mapped_column(Integer, ForeignKey(\"user.id\"))\n\n    street = mapped_column(String)\n    city = mapped_column(String)\n    state = mapped_column(String)\n    zip = mapped_column(String)\n```", "```py\nfrom sqlalchemy import cast, String, Column, Integer\nfrom sqlalchemy.orm import relationship\nfrom sqlalchemy.dialects.postgresql import INET\n\nfrom sqlalchemy.orm import DeclarativeBase\n\nclass Base(DeclarativeBase):\n    pass\n\nclass HostEntry(Base):\n    __tablename__ = \"host_entry\"\n\n    id = mapped_column(Integer, primary_key=True)\n    ip_address = mapped_column(INET)\n    content = mapped_column(String(50))\n\n    # relationship() using explicit foreign_keys, remote_side\n    parent_host = relationship(\n        \"HostEntry\",\n        primaryjoin=ip_address == cast(content, INET),\n        foreign_keys=content,\n        remote_side=ip_address,\n    )\n```", "```py\nSELECT  host_entry.id,  host_entry.ip_address,  host_entry.content\nFROM  host_entry  JOIN  host_entry  AS  host_entry_1\nON  host_entry_1.ip_address  =  CAST(host_entry.content  AS  INET)\n```", "```py\nfrom sqlalchemy.orm import foreign, remote\n\nclass HostEntry(Base):\n    __tablename__ = \"host_entry\"\n\n    id = mapped_column(Integer, primary_key=True)\n    ip_address = mapped_column(INET)\n    content = mapped_column(String(50))\n\n    # relationship() using explicit foreign() and remote() annotations\n    # in lieu of separate arguments\n    parent_host = relationship(\n        \"HostEntry\",\n        primaryjoin=remote(ip_address) == cast(foreign(content), INET),\n    )\n```", "```py\ninet_column.bool_op(\"<<\")(cidr_column)\n```", "```py\nclass IPA(Base):\n    __tablename__ = \"ip_address\"\n\n    id = mapped_column(Integer, primary_key=True)\n    v4address = mapped_column(INET)\n\n    network = relationship(\n        \"Network\",\n        primaryjoin=\"IPA.v4address.bool_op('<<')(foreign(Network.v4representation))\",\n        viewonly=True,\n    )\n\nclass Network(Base):\n    __tablename__ = \"network\"\n\n    id = mapped_column(Integer, primary_key=True)\n    v4representation = mapped_column(CIDR)\n```", "```py\nselect(IPA).join(IPA.network)\n```", "```py\nSELECT  ip_address.id  AS  ip_address_id,  ip_address.v4address  AS  ip_address_v4address\nFROM  ip_address  JOIN  network  ON  ip_address.v4address  <<  network.v4representation\n```", "```py\nfrom geoalchemy2 import Geometry\nfrom sqlalchemy import Column, Integer, func\nfrom sqlalchemy.orm import relationship, foreign\n\nclass Polygon(Base):\n    __tablename__ = \"polygon\"\n    id = mapped_column(Integer, primary_key=True)\n    geom = mapped_column(Geometry(\"POLYGON\", srid=4326))\n    points = relationship(\n        \"Point\",\n        primaryjoin=\"func.ST_Contains(foreign(Polygon.geom), Point.geom).as_comparison(1, 2)\",\n        viewonly=True,\n    )\n\nclass Point(Base):\n    __tablename__ = \"point\"\n    id = mapped_column(Integer, primary_key=True)\n    geom = mapped_column(Geometry(\"POINT\", srid=4326))\n```", "```py\nclass Magazine(Base):\n    __tablename__ = \"magazine\"\n\n    id = mapped_column(Integer, primary_key=True)\n\nclass Article(Base):\n    __tablename__ = \"article\"\n\n    article_id = mapped_column(Integer)\n    magazine_id = mapped_column(ForeignKey(\"magazine.id\"))\n    writer_id = mapped_column()\n\n    magazine = relationship(\"Magazine\")\n    writer = relationship(\"Writer\")\n\n    __table_args__ = (\n        PrimaryKeyConstraint(\"article_id\", \"magazine_id\"),\n        ForeignKeyConstraint(\n            [\"writer_id\", \"magazine_id\"], [\"writer.id\", \"writer.magazine_id\"]\n        ),\n    )\n\nclass Writer(Base):\n    __tablename__ = \"writer\"\n\n    id = mapped_column(Integer, primary_key=True)\n    magazine_id = mapped_column(ForeignKey(\"magazine.id\"), primary_key=True)\n    magazine = relationship(\"Magazine\")\n```", "```py\nSAWarning: relationship 'Article.writer' will copy column\nwriter.magazine_id to column article.magazine_id,\nwhich conflicts with relationship(s): 'Article.magazine'\n(copies magazine.id to article.magazine_id). Consider applying\nviewonly=True to read-only relationships, or provide a primaryjoin\ncondition marking writable columns with the foreign() annotation.\n```", "```py\nclass Article(Base):\n    # ...\n\n    writer = relationship(\"Writer\", foreign_keys=\"Article.writer_id\")\n```", "```py\nSELECT  article.article_id  AS  article_article_id,\n  article.magazine_id  AS  article_magazine_id,\n  article.writer_id  AS  article_writer_id\nFROM  article\nJOIN  writer  ON  writer.id  =  article.writer_id\n```", "```py\nclass Article(Base):\n    # ...\n\n    writer = relationship(\n        \"Writer\",\n        primaryjoin=\"and_(Writer.id == foreign(Article.writer_id), \"\n        \"Writer.magazine_id == Article.magazine_id)\",\n    )\n```", "```py\nclass Element(Base):\n    __tablename__ = \"element\"\n\n    path = mapped_column(String, primary_key=True)\n\n    descendants = relationship(\n        \"Element\",\n        primaryjoin=remote(foreign(path)).like(path.concat(\"/%\")),\n        viewonly=True,\n        order_by=path,\n    )\n```", "```py\nSELECT  element.path  AS  element_path\nFROM  element\nWHERE  element.path  LIKE  ('/foo/bar2'  ||  '/%')  ORDER  BY  element.path\n```", "```py\nfrom typing import List\n\nfrom sqlalchemy import Integer, ForeignKey, Column, Table\nfrom sqlalchemy.orm import DeclarativeBase, Mapped\nfrom sqlalchemy.orm import mapped_column, relationship\n\nclass Base(DeclarativeBase):\n    pass\n\nnode_to_node = Table(\n    \"node_to_node\",\n    Base.metadata,\n    Column(\"left_node_id\", Integer, ForeignKey(\"node.id\"), primary_key=True),\n    Column(\"right_node_id\", Integer, ForeignKey(\"node.id\"), primary_key=True),\n)\n\nclass Node(Base):\n    __tablename__ = \"node\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    label: Mapped[str]\n    right_nodes: Mapped[List[\"Node\"]] = relationship(\n        \"Node\",\n        secondary=node_to_node,\n        primaryjoin=id == node_to_node.c.left_node_id,\n        secondaryjoin=id == node_to_node.c.right_node_id,\n        back_populates=\"left_nodes\",\n    )\n    left_nodes: Mapped[List[\"Node\"]] = relationship(\n        \"Node\",\n        secondary=node_to_node,\n        primaryjoin=id == node_to_node.c.right_node_id,\n        secondaryjoin=id == node_to_node.c.left_node_id,\n        back_populates=\"right_nodes\",\n    )\n```", "```py\nclass Node(Base):\n    __tablename__ = \"node\"\n    id = mapped_column(Integer, primary_key=True)\n    label = mapped_column(String)\n    right_nodes = relationship(\n        \"Node\",\n        secondary=\"node_to_node\",\n        primaryjoin=\"Node.id==node_to_node.c.left_node_id\",\n        secondaryjoin=\"Node.id==node_to_node.c.right_node_id\",\n        backref=\"left_nodes\",\n    )\n```", "```py\nfrom sqlalchemy import Integer, ForeignKey, String, Column, Table, MetaData\nfrom sqlalchemy.orm import relationship, registry\n\nmetadata_obj = MetaData()\nmapper_registry = registry()\n\nnode_to_node = Table(\n    \"node_to_node\",\n    metadata_obj,\n    Column(\"left_node_id\", Integer, ForeignKey(\"node.id\"), primary_key=True),\n    Column(\"right_node_id\", Integer, ForeignKey(\"node.id\"), primary_key=True),\n)\n\nnode = Table(\n    \"node\",\n    metadata_obj,\n    Column(\"id\", Integer, primary_key=True),\n    Column(\"label\", String),\n)\n\nclass Node:\n    pass\n\nmapper_registry.map_imperatively(\n    Node,\n    node,\n    properties={\n        \"right_nodes\": relationship(\n            Node,\n            secondary=node_to_node,\n            primaryjoin=node.c.id == node_to_node.c.left_node_id,\n            secondaryjoin=node.c.id == node_to_node.c.right_node_id,\n            backref=\"left_nodes\",\n        )\n    },\n)\n```", "```py\nclass A(Base):\n    __tablename__ = \"a\"\n\n    id = mapped_column(Integer, primary_key=True)\n    b_id = mapped_column(ForeignKey(\"b.id\"))\n\n    d = relationship(\n        \"D\",\n        secondary=\"join(B, D, B.d_id == D.id).join(C, C.d_id == D.id)\",\n        primaryjoin=\"and_(A.b_id == B.id, A.id == C.a_id)\",\n        secondaryjoin=\"D.id == B.d_id\",\n        uselist=False,\n        viewonly=True,\n    )\n\nclass B(Base):\n    __tablename__ = \"b\"\n\n    id = mapped_column(Integer, primary_key=True)\n    d_id = mapped_column(ForeignKey(\"d.id\"))\n\nclass C(Base):\n    __tablename__ = \"c\"\n\n    id = mapped_column(Integer, primary_key=True)\n    a_id = mapped_column(ForeignKey(\"a.id\"))\n    d_id = mapped_column(ForeignKey(\"d.id\"))\n\nclass D(Base):\n    __tablename__ = \"d\"\n\n    id = mapped_column(Integer, primary_key=True)\n```", "```py\nsess.scalars(select(A).join(A.d)).all()\n\nSELECT  a.id  AS  a_id,  a.b_id  AS  a_b_id\nFROM  a  JOIN  (\n  b  AS  b_1  JOIN  d  AS  d_1  ON  b_1.d_id  =  d_1.id\n  JOIN  c  AS  c_1  ON  c_1.d_id  =  d_1.id)\n  ON  a.b_id  =  b_1.id  AND  a.id  =  c_1.a_id  JOIN  d  ON  d.id  =  b_1.d_id \n```", "```py\nclass A(Base):\n    __tablename__ = \"a\"\n\n    id = mapped_column(Integer, primary_key=True)\n    b_id = mapped_column(ForeignKey(\"b.id\"))\n\nclass B(Base):\n    __tablename__ = \"b\"\n\n    id = mapped_column(Integer, primary_key=True)\n\nclass C(Base):\n    __tablename__ = \"c\"\n\n    id = mapped_column(Integer, primary_key=True)\n    a_id = mapped_column(ForeignKey(\"a.id\"))\n\n    some_c_value = mapped_column(String)\n\nclass D(Base):\n    __tablename__ = \"d\"\n\n    id = mapped_column(Integer, primary_key=True)\n    c_id = mapped_column(ForeignKey(\"c.id\"))\n    b_id = mapped_column(ForeignKey(\"b.id\"))\n\n    some_d_value = mapped_column(String)\n\n# 1\\. set up the join() as a variable, so we can refer\n# to it in the mapping multiple times.\nj = join(B, D, D.b_id == B.id).join(C, C.id == D.c_id)\n\n# 2\\. Create an AliasedClass to B\nB_viacd = aliased(B, j, flat=True)\n\nA.b = relationship(B_viacd, primaryjoin=A.b_id == j.c.b_id)\n```", "```py\nsess.scalars(select(A).join(A.b)).all()\n\nSELECT  a.id  AS  a_id,  a.b_id  AS  a_b_id\nFROM  a  JOIN  (b  JOIN  d  ON  d.b_id  =  b.id  JOIN  c  ON  c.id  =  d.c_id)  ON  a.b_id  =  b.id \n```", "```py\nfrom sqlalchemy import event\n\nclass A(Base):\n    __tablename__ = \"a\"\n\n    id = mapped_column(Integer, primary_key=True)\n    b_id = mapped_column(ForeignKey(\"b.id\"))\n\n@event.listens_for(A, \"before_mapper_configured\")\ndef _configure_ab_relationship(mapper, cls):\n    # do the above configuration in a configuration hook\n\n    j = join(B, D, D.b_id == B.id).join(C, C.id == D.c_id)\n    B_viacd = aliased(B, j, flat=True)\n    A.b = relationship(B_viacd, primaryjoin=A.b_id == j.c.b_id)\n```", "```py\nfrom typing import Any\n\nB_viacd: Any = None\nb_viacd_join: Any = None\n\nclass A(Base):\n    __tablename__ = \"a\"\n\n    id: Mapped[int] = mapped_column(primary_key=True)\n    b_id: Mapped[int] = mapped_column(ForeignKey(\"b.id\"))\n\n    # 1\\. the relationship can be declared using lambdas, allowing it to resolve\n    #    to targets that are late-configured\n    b: Mapped[B] = relationship(\n        lambda: B_viacd, primaryjoin=lambda: A.b_id == b_viacd_join.c.b_id\n    )\n\n# 2\\. configure the targets of the relationship using a before_mapper_configured\n#    hook.\n@event.listens_for(A, \"before_mapper_configured\")\ndef _configure_ab_relationship(mapper, cls):\n    # 3\\. set up the join() and AliasedClass as globals from within\n    #    the configuration hook.\n\n    global B_viacd, b_viacd_join\n\n    b_viacd_join = join(B, D, D.b_id == B.id).join(C, C.id == D.c_id)\n    B_viacd = aliased(B, b_viacd_join, flat=True)\n```", "```py\nsubq = select(B).join(D, D.b_id == B.id).join(C, C.id == D.c_id).subquery()\n\nB_viacd_subquery = aliased(B, subq)\n\nA.b = relationship(B_viacd_subquery, primaryjoin=A.b_id == subq.c.id)\n```", "```py\nsess.scalars(select(A).join(A.b)).all()\n\nSELECT  a.id  AS  a_id,  a.b_id  AS  a_b_id\nFROM  a  JOIN  (SELECT  b.id  AS  id,  b.some_b_column  AS  some_b_column\nFROM  b  JOIN  d  ON  d.b_id  =  b.id  JOIN  c  ON  c.id  =  d.c_id)  AS  anon_1  ON  a.b_id  =  anon_1.id \n```", "```py\nsess.scalars(\n    select(A)\n    .join(A.b)\n    .where(B_viacd_subquery.some_b_column == \"some b\")\n    .order_by(B_viacd_subquery.id)\n).all()\n\nSELECT  a.id  AS  a_id,  a.b_id  AS  a_b_id\nFROM  a  JOIN  (SELECT  b.id  AS  id,  b.some_b_column  AS  some_b_column\nFROM  b  JOIN  d  ON  d.b_id  =  b.id  JOIN  c  ON  c.id  =  d.c_id)  AS  anon_1  ON  a.b_id  =  anon_1.id\nWHERE  anon_1.some_b_column  =  ?  ORDER  BY  anon_1.id \n```", "```py\nfrom sqlalchemy import event\n\nclass A(Base):\n    __tablename__ = \"a\"\n\n    id = mapped_column(Integer, primary_key=True)\n    b_id = mapped_column(ForeignKey(\"b.id\"))\n\n@event.listens_for(A, \"before_mapper_configured\")\ndef _configure_ab_relationship(mapper, cls):\n    # do the above configuration in a configuration hook\n\n    j = join(B, D, D.b_id == B.id).join(C, C.id == D.c_id)\n    B_viacd = aliased(B, j, flat=True)\n    A.b = relationship(B_viacd, primaryjoin=A.b_id == j.c.b_id)\n```", "```py\nfrom typing import Any\n\nB_viacd: Any = None\nb_viacd_join: Any = None\n\nclass A(Base):\n    __tablename__ = \"a\"\n\n    id: Mapped[int] = mapped_column(primary_key=True)\n    b_id: Mapped[int] = mapped_column(ForeignKey(\"b.id\"))\n\n    # 1\\. the relationship can be declared using lambdas, allowing it to resolve\n    #    to targets that are late-configured\n    b: Mapped[B] = relationship(\n        lambda: B_viacd, primaryjoin=lambda: A.b_id == b_viacd_join.c.b_id\n    )\n\n# 2\\. configure the targets of the relationship using a before_mapper_configured\n#    hook.\n@event.listens_for(A, \"before_mapper_configured\")\ndef _configure_ab_relationship(mapper, cls):\n    # 3\\. set up the join() and AliasedClass as globals from within\n    #    the configuration hook.\n\n    global B_viacd, b_viacd_join\n\n    b_viacd_join = join(B, D, D.b_id == B.id).join(C, C.id == D.c_id)\n    B_viacd = aliased(B, b_viacd_join, flat=True)\n```", "```py\nsubq = select(B).join(D, D.b_id == B.id).join(C, C.id == D.c_id).subquery()\n\nB_viacd_subquery = aliased(B, subq)\n\nA.b = relationship(B_viacd_subquery, primaryjoin=A.b_id == subq.c.id)\n```", "```py\nsess.scalars(select(A).join(A.b)).all()\n\nSELECT  a.id  AS  a_id,  a.b_id  AS  a_b_id\nFROM  a  JOIN  (SELECT  b.id  AS  id,  b.some_b_column  AS  some_b_column\nFROM  b  JOIN  d  ON  d.b_id  =  b.id  JOIN  c  ON  c.id  =  d.c_id)  AS  anon_1  ON  a.b_id  =  anon_1.id \n```", "```py\nsess.scalars(\n    select(A)\n    .join(A.b)\n    .where(B_viacd_subquery.some_b_column == \"some b\")\n    .order_by(B_viacd_subquery.id)\n).all()\n\nSELECT  a.id  AS  a_id,  a.b_id  AS  a_b_id\nFROM  a  JOIN  (SELECT  b.id  AS  id,  b.some_b_column  AS  some_b_column\nFROM  b  JOIN  d  ON  d.b_id  =  b.id  JOIN  c  ON  c.id  =  d.c_id)  AS  anon_1  ON  a.b_id  =  anon_1.id\nWHERE  anon_1.some_b_column  =  ?  ORDER  BY  anon_1.id \n```", "```py\nclass A(Base):\n    __tablename__ = \"a\"\n\n    id = mapped_column(Integer, primary_key=True)\n\nclass B(Base):\n    __tablename__ = \"b\"\n    id = mapped_column(Integer, primary_key=True)\n    a_id = mapped_column(ForeignKey(\"a.id\"))\n\npartition = select(\n    B, func.row_number().over(order_by=B.id, partition_by=B.a_id).label(\"index\")\n).alias()\n\npartitioned_b = aliased(B, partition)\n\nA.partitioned_bs = relationship(\n    partitioned_b, primaryjoin=and_(partitioned_b.a_id == A.id, partition.c.index < 10)\n)\n```", "```py\nfor a1 in session.scalars(select(A).options(selectinload(A.partitioned_bs))):\n    print(a1.partitioned_bs)  # <-- will be no more than ten objects\n```", "```py\nSELECT\n  a_1.id  AS  a_1_id,  anon_1.id  AS  anon_1_id,  anon_1.a_id  AS  anon_1_a_id,\n  anon_1.data  AS  anon_1_data,  anon_1.index  AS  anon_1_index\nFROM  a  AS  a_1\nJOIN  (\n  SELECT  b.id  AS  id,  b.a_id  AS  a_id,  b.data  AS  data,\n  row_number()  OVER  (PARTITION  BY  b.a_id  ORDER  BY  b.id)  AS  index\n  FROM  b)  AS  anon_1\nON  anon_1.a_id  =  a_1.id  AND  anon_1.index  <  %(index_1)s\nWHERE  a_1.id  IN  (  ...  primary  key  collection  ...)\nORDER  BY  a_1.id\n```", "```py\nclass User(Base):\n    __tablename__ = \"user\"\n    id = mapped_column(Integer, primary_key=True)\n\n    @property\n    def addresses(self):\n        return object_session(self).query(Address).with_parent(self).filter(...).all()\n```", "```py\nfrom __future__ import annotations\n\nimport datetime\n\nfrom sqlalchemy import and_\nfrom sqlalchemy import ForeignKey\nfrom sqlalchemy import func\nfrom sqlalchemy.orm import DeclarativeBase\nfrom sqlalchemy.orm import Mapped\nfrom sqlalchemy.orm import mapped_column\nfrom sqlalchemy.orm import relationship\n\nclass Base(DeclarativeBase):\n    pass\n\nclass User(Base):\n    __tablename__ = \"user_account\"\n\n    id: Mapped[int] = mapped_column(primary_key=True)\n    name: Mapped[str | None]\n\n    all_tasks: Mapped[list[Task]] = relationship()\n\n    current_week_tasks: Mapped[list[Task]] = relationship(\n        primaryjoin=lambda: and_(\n            User.id == Task.user_account_id,\n            # this expression works on PostgreSQL but may not be supported\n            # by other database engines\n            Task.task_date >= func.now() - datetime.timedelta(days=7),\n        ),\n        viewonly=True,\n    )\n\nclass Task(Base):\n    __tablename__ = \"task\"\n\n    id: Mapped[int] = mapped_column(primary_key=True)\n    user_account_id: Mapped[int] = mapped_column(ForeignKey(\"user_account.id\"))\n    description: Mapped[str | None]\n    task_date: Mapped[datetime.datetime] = mapped_column(server_default=func.now())\n\n    user: Mapped[User] = relationship(back_populates=\"current_week_tasks\")\n```", "```py\n>>> u1 = User()\n>>> t1 = Task(task_date=datetime.datetime.now())\n>>> t1.user = u1\n>>> u1.current_week_tasks\n[]\n```", "```py\nclass User(Base):\n    __tablename__ = \"user_account\"\n\n    id: Mapped[int] = mapped_column(primary_key=True)\n    name: Mapped[str | None]\n\n    all_tasks: Mapped[list[Task]] = relationship(back_populates=\"user\")\n\n    @property\n    def current_week_tasks(self) -> list[Task]:\n        past_seven_days = datetime.datetime.now() - datetime.timedelta(days=7)\n        return [t for t in self.all_tasks if t.task_date >= past_seven_days]\n\nclass Task(Base):\n    __tablename__ = \"task\"\n\n    id: Mapped[int] = mapped_column(primary_key=True)\n    user_account_id: Mapped[int] = mapped_column(ForeignKey(\"user_account.id\"))\n    description: Mapped[str | None]\n    task_date: Mapped[datetime.datetime] = mapped_column(server_default=func.now())\n\n    user: Mapped[User] = relationship(back_populates=\"all_tasks\")\n```", "```py\n>>> u1 = User()\n>>> t1 = Task(task_date=datetime.datetime.now())\n>>> t1.user = u1\n>>> u1.current_week_tasks\n[<__main__.Task object at 0x7f3d699523c0>]\n```", "```py\n>>> with Session(e) as sess:\n...     u1 = sess.scalar(select(User).where(User.id == 1))\n...     print(u1.current_week_tasks)\n[<__main__.Task object at 0x7f8711b906b0>]\n```", "```py\n>>> with Session(e) as sess:\n...     u1 = sess.scalar(select(User).where(User.id == 1))\n...     u1.all_tasks.append(Task(task_date=datetime.datetime.now()))\n...     sess.commit()\n...     print(u1.current_week_tasks)\n[<__main__.Task object at 0x7f8711b90ec0>, <__main__.Task object at 0x7f8711b90a10>]\n```", "```py\n>>> with Session(e) as sess:\n...     u1 = sess.scalar(select(User).where(User.id == 1))\n...     u1.all_tasks.append(Task(task_date=datetime.datetime.now()))\n...     sess.flush()\n...     sess.expire(u1, [\"current_week_tasks\"])\n...     print(u1.current_week_tasks)\n[<__main__.Task object at 0x7fd95a4c8c50>, <__main__.Task object at 0x7fd95a4c8c80>]\n```", "```py\n>>> with Session(e) as sess:\n...     u1 = sess.scalar(select(User).where(User.id == 1))\n...     u1.all_tasks.append(Task(task_date=datetime.datetime.now()))\n...     sess.expire(u1, [\"current_week_tasks\"])\n...     print(u1.current_week_tasks)  # triggers autoflush before querying\n[<__main__.Task object at 0x7fd95a4c8c50>, <__main__.Task object at 0x7fd95a4c8c80>]\n```", "```py\nfrom sqlalchemy import event, inspect\n\n@event.listens_for(User.all_tasks, \"append\")\n@event.listens_for(User.all_tasks, \"remove\")\n@event.listens_for(User.all_tasks, \"bulk_replace\")\ndef _expire_User_current_week_tasks(target, value, initiator):\n    inspect(target).session.expire(target, [\"current_week_tasks\"])\n```", "```py\n>>> with Session(e) as sess:\n...     u1 = sess.scalar(select(User).where(User.id == 1))\n...     u1.all_tasks.append(Task(task_date=datetime.datetime.now()))\n...     print(u1.current_week_tasks)\n[<__main__.Task object at 0x7f66d093ccb0>, <__main__.Task object at 0x7f66d093cce0>]\n```", "```py\n>>> with Session(e) as sess:\n...     u1 = sess.scalar(select(User).where(User.id == 1))\n...     t1 = Task(task_date=datetime.datetime.now())\n...     t1.user = u1\n...     sess.add(t1)\n...     print(u1.current_week_tasks)\n[<__main__.Task object at 0x7f3b0c070d10>, <__main__.Task object at 0x7f3b0c057d10>]\n```", "```py\n>>> u1 = User()\n>>> t1 = Task(task_date=datetime.datetime.now())\n>>> t1.user = u1\n>>> u1.current_week_tasks\n[]\n```", "```py\nclass User(Base):\n    __tablename__ = \"user_account\"\n\n    id: Mapped[int] = mapped_column(primary_key=True)\n    name: Mapped[str | None]\n\n    all_tasks: Mapped[list[Task]] = relationship(back_populates=\"user\")\n\n    @property\n    def current_week_tasks(self) -> list[Task]:\n        past_seven_days = datetime.datetime.now() - datetime.timedelta(days=7)\n        return [t for t in self.all_tasks if t.task_date >= past_seven_days]\n\nclass Task(Base):\n    __tablename__ = \"task\"\n\n    id: Mapped[int] = mapped_column(primary_key=True)\n    user_account_id: Mapped[int] = mapped_column(ForeignKey(\"user_account.id\"))\n    description: Mapped[str | None]\n    task_date: Mapped[datetime.datetime] = mapped_column(server_default=func.now())\n\n    user: Mapped[User] = relationship(back_populates=\"all_tasks\")\n```", "```py\n>>> u1 = User()\n>>> t1 = Task(task_date=datetime.datetime.now())\n>>> t1.user = u1\n>>> u1.current_week_tasks\n[<__main__.Task object at 0x7f3d699523c0>]\n```", "```py\n>>> with Session(e) as sess:\n...     u1 = sess.scalar(select(User).where(User.id == 1))\n...     print(u1.current_week_tasks)\n[<__main__.Task object at 0x7f8711b906b0>]\n```", "```py\n>>> with Session(e) as sess:\n...     u1 = sess.scalar(select(User).where(User.id == 1))\n...     u1.all_tasks.append(Task(task_date=datetime.datetime.now()))\n...     sess.commit()\n...     print(u1.current_week_tasks)\n[<__main__.Task object at 0x7f8711b90ec0>, <__main__.Task object at 0x7f8711b90a10>]\n```", "```py\n>>> with Session(e) as sess:\n...     u1 = sess.scalar(select(User).where(User.id == 1))\n...     u1.all_tasks.append(Task(task_date=datetime.datetime.now()))\n...     sess.flush()\n...     sess.expire(u1, [\"current_week_tasks\"])\n...     print(u1.current_week_tasks)\n[<__main__.Task object at 0x7fd95a4c8c50>, <__main__.Task object at 0x7fd95a4c8c80>]\n```", "```py\n>>> with Session(e) as sess:\n...     u1 = sess.scalar(select(User).where(User.id == 1))\n...     u1.all_tasks.append(Task(task_date=datetime.datetime.now()))\n...     sess.expire(u1, [\"current_week_tasks\"])\n...     print(u1.current_week_tasks)  # triggers autoflush before querying\n[<__main__.Task object at 0x7fd95a4c8c50>, <__main__.Task object at 0x7fd95a4c8c80>]\n```", "```py\nfrom sqlalchemy import event, inspect\n\n@event.listens_for(User.all_tasks, \"append\")\n@event.listens_for(User.all_tasks, \"remove\")\n@event.listens_for(User.all_tasks, \"bulk_replace\")\ndef _expire_User_current_week_tasks(target, value, initiator):\n    inspect(target).session.expire(target, [\"current_week_tasks\"])\n```", "```py\n>>> with Session(e) as sess:\n...     u1 = sess.scalar(select(User).where(User.id == 1))\n...     u1.all_tasks.append(Task(task_date=datetime.datetime.now()))\n...     print(u1.current_week_tasks)\n[<__main__.Task object at 0x7f66d093ccb0>, <__main__.Task object at 0x7f66d093cce0>]\n```", "```py\n>>> with Session(e) as sess:\n...     u1 = sess.scalar(select(User).where(User.id == 1))\n...     t1 = Task(task_date=datetime.datetime.now())\n...     t1.user = u1\n...     sess.add(t1)\n...     print(u1.current_week_tasks)\n[<__main__.Task object at 0x7f3b0c070d10>, <__main__.Task object at 0x7f3b0c057d10>]\n```"]