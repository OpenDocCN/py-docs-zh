["```py\nTable(\"mytable\", metadata_obj, Column(\"somecolumn\", Integer, default=12))\n```", "```py\nTable(\"mytable\", metadata_obj, Column(\"somecolumn\", Integer, onupdate=25))\n```", "```py\n# a function which counts upwards\ni = 0\n\ndef mydefault():\n    global i\n    i += 1\n    return i\n\nt = Table(\n    \"mytable\",\n    metadata_obj,\n    Column(\"id\", Integer, primary_key=True, default=mydefault),\n)\n```", "```py\nimport datetime\n\nt = Table(\n    \"mytable\",\n    metadata_obj,\n    Column(\"id\", Integer, primary_key=True),\n    # define 'last_updated' to be populated with datetime.now()\n    Column(\"last_updated\", DateTime, onupdate=datetime.datetime.now),\n)\n```", "```py\ndef mydefault(context):\n    return context.get_current_parameters()[\"counter\"] + 12\n\nt = Table(\n    \"mytable\",\n    metadata_obj,\n    Column(\"counter\", Integer),\n    Column(\"counter_plus_twelve\", Integer, default=mydefault, onupdate=mydefault),\n)\n```", "```py\nt = Table(\n    \"mytable\",\n    metadata_obj,\n    Column(\"id\", Integer, primary_key=True),\n    # define 'create_date' to default to now()\n    Column(\"create_date\", DateTime, default=func.now()),\n    # define 'key' to pull its default from the 'keyvalues' table\n    Column(\n        \"key\",\n        String(20),\n        default=select(keyvalues.c.key).where(keyvalues.c.type=\"type1\"),\n    ),\n    # define 'last_modified' to use the current_timestamp SQL function on update\n    Column(\"last_modified\", DateTime, onupdate=func.utc_timestamp()),\n)\n```", "```py\nt = Table(\n    \"test\",\n    metadata_obj,\n    Column(\"abc\", String(20), server_default=\"abc\"),\n    Column(\"created_at\", DateTime, server_default=func.sysdate()),\n    Column(\"index_value\", Integer, server_default=text(\"0\")),\n)\n```", "```py\nCREATE  TABLE  test  (\n  abc  varchar(20)  default  'abc',\n  created_at  datetime  default  sysdate,\n  index_value  integer  default  0\n)\n```", "```py\nfrom sqlalchemy.schema import FetchedValue\n\nt = Table(\n    \"test\",\n    metadata_obj,\n    Column(\"id\", Integer, primary_key=True),\n    Column(\"abc\", TIMESTAMP, server_default=FetchedValue()),\n    Column(\"def\", String(20), server_onupdate=FetchedValue()),\n)\n```", "```py\ntable = Table(\n    \"cartitems\",\n    metadata_obj,\n    Column(\n        \"cart_id\",\n        Integer,\n        Sequence(\"cart_id_seq\", start=1),\n        primary_key=True,\n    ),\n    Column(\"description\", String(40)),\n    Column(\"createdate\", DateTime()),\n)\n```", "```py\nCREATE  SEQUENCE  cart_id_seq  START  WITH  1\n\nCREATE  TABLE  cartitems  (\n  cart_id  INTEGER  NOT  NULL,\n  description  VARCHAR(40),\n  createdate  TIMESTAMP  WITHOUT  TIME  ZONE,\n  PRIMARY  KEY  (cart_id)\n)\n```", "```py\nSequence(\"cart_id_seq\", start=1, schema=\"some_schema\")\n```", "```py\nINSERT  INTO  cartitems  (cart_id,  description,  createdate)\nVALUES  (next_val(cart_id_seq),  'some description',  '2015-10-15 12:00:15')\nRETURNING  cart_id\n```", "```py\ntable = Table(\n    \"cartitems\",\n    metadata_obj,\n    Column(\n        \"cart_id\",\n        Integer,\n        # use an explicit Sequence where available, but not on\n        # PostgreSQL where SERIAL will be used\n        Sequence(\"cart_id_seq\", start=1, optional=True),\n        primary_key=True,\n    ),\n    Column(\"description\", String(40)),\n    Column(\"createdate\", DateTime()),\n)\n```", "```py\nwith my_engine.connect() as conn:\n    seq = Sequence(\"some_sequence\", start=1)\n    nextid = conn.execute(seq)\n```", "```py\n>>> my_seq = Sequence(\"some_sequence\", start=1)\n>>> stmt = select(my_seq.next_value())\n>>> print(stmt.compile(dialect=postgresql.dialect()))\nSELECT  nextval('some_sequence')  AS  next_value_1 \n```", "```py\nseq = Sequence(\"my_general_seq\", metadata=metadata_obj, start=1)\n```", "```py\ntable = Table(\n    \"cartitems\",\n    metadata_obj,\n    seq,\n    Column(\"description\", String(40)),\n    Column(\"createdate\", DateTime()),\n)\n```", "```py\nColumn(\n    \"cart_id\",\n    Integer,\n    Sequence(\"cart_id_seq\", metadata=metadata_obj, start=1),\n    primary_key=True,\n)\n```", "```py\ncart_id_seq = Sequence(\"cart_id_seq\", metadata=metadata_obj, start=1)\ntable = Table(\n    \"cartitems\",\n    metadata_obj,\n    Column(\n        \"cart_id\",\n        Integer,\n        cart_id_seq,\n        server_default=cart_id_seq.next_value(),\n        primary_key=True,\n    ),\n    Column(\"description\", String(40)),\n    Column(\"createdate\", DateTime()),\n)\n```", "```py\nclass CartItem(Base):\n    __tablename__ = \"cartitems\"\n\n    cart_id_seq = Sequence(\"cart_id_seq\", metadata=Base.metadata, start=1)\n    cart_id = Column(\n        Integer, cart_id_seq, server_default=cart_id_seq.next_value(), primary_key=True\n    )\n    description = Column(String(40))\n    createdate = Column(DateTime)\n```", "```py\nCREATE  TABLE  cartitems  (\n  cart_id  INTEGER  DEFAULT  nextval('cart_id_seq')  NOT  NULL,\n  description  VARCHAR(40),\n  createdate  TIMESTAMP  WITHOUT  TIME  ZONE,\n  PRIMARY  KEY  (cart_id)\n)\n```", "```py\nfrom sqlalchemy import Table, Column, MetaData, Integer, Computed\n\nmetadata_obj = MetaData()\n\nsquare = Table(\n    \"square\",\n    metadata_obj,\n    Column(\"id\", Integer, primary_key=True),\n    Column(\"side\", Integer),\n    Column(\"area\", Integer, Computed(\"side * side\")),\n    Column(\"perimeter\", Integer, Computed(\"4 * side\")),\n)\n```", "```py\nCREATE  TABLE  square  (\n  id  SERIAL  NOT  NULL,\n  side  INTEGER,\n  area  INTEGER  GENERATED  ALWAYS  AS  (side  *  side)  STORED,\n  perimeter  INTEGER  GENERATED  ALWAYS  AS  (4  *  side)  STORED,\n  PRIMARY  KEY  (id)\n)\n```", "```py\nfrom sqlalchemy import Table, Column, MetaData, Integer, Identity, String\n\nmetadata_obj = MetaData()\n\ndata = Table(\n    \"data\",\n    metadata_obj,\n    Column(\"id\", Integer, Identity(start=42, cycle=True), primary_key=True),\n    Column(\"data\", String),\n)\n```", "```py\nCREATE  TABLE  data  (\n  id  INTEGER  GENERATED  BY  DEFAULT  AS  IDENTITY  (START  WITH  42  CYCLE)  NOT  NULL,\n  data  VARCHAR,\n  PRIMARY  KEY  (id)\n)\n```", "```py\nCREATE  TABLE  data  (\n  id  INTEGER  GENERATED  ALWAYS  AS  IDENTITY  (START  WITH  42  CYCLE)  NOT  NULL,\n  data  VARCHAR,\n  PRIMARY  KEY  (id)\n)\n```", "```py\nclass sqlalchemy.schema.Computed\n```", "```py\nfrom sqlalchemy import Computed\n\nTable('square', metadata_obj,\n    Column('side', Float, nullable=False),\n    Column('area', Float, Computed('side * side'))\n)\n```", "```py\nmethod __init__(sqltext: _DDLColumnArgument, persisted: bool | None = None) \u2192 None\n```", "```py\nmethod copy(*, target_table: Table | None = None, **kw: Any) \u2192 Computed\n```", "```py\nclass sqlalchemy.schema.ColumnDefault\n```", "```py\nColumn('foo', Integer, default=50)\n```", "```py\nColumn('foo', Integer, ColumnDefault(50))\n```", "```py\nclass sqlalchemy.schema.DefaultClause\n```", "```py\nColumn('foo', Integer, server_default=\"50\")\n```", "```py\nColumn('foo', Integer, DefaultClause(\"50\"))\n```", "```py\nclass sqlalchemy.schema.DefaultGenerator\n```", "```py\nclass sqlalchemy.schema.FetchedValue\n```", "```py\nColumn('foo', Integer, FetchedValue())\n```", "```py\nclass sqlalchemy.schema.Sequence\n```", "```py\nsome_table = Table(\n    'some_table', metadata,\n    Column('id', Integer, Sequence('some_table_seq', start=1),\n    primary_key=True)\n)\n```", "```py\nmethod __init__(name: str, start: int | None = None, increment: int | None = None, minvalue: int | None = None, maxvalue: int | None = None, nominvalue: bool | None = None, nomaxvalue: bool | None = None, cycle: bool | None = None, schema: str | Literal[SchemaConst.BLANK_SCHEMA] | None = None, cache: int | None = None, order: bool | None = None, data_type: _TypeEngineArgument[int] | None = None, optional: bool = False, quote: bool | None = None, metadata: MetaData | None = None, quote_schema: bool | None = None, for_update: bool = False) \u2192 None\n```", "```py\nmethod create(bind: _CreateDropBind, checkfirst: bool = True) \u2192 None\n```", "```py\nmethod drop(bind: _CreateDropBind, checkfirst: bool = True) \u2192 None\n```", "```py\nmethod next_value() \u2192 Function[int]\n```", "```py\nclass sqlalchemy.schema.Identity\n```", "```py\nfrom sqlalchemy import Identity\n\nTable('foo', metadata_obj,\n    Column('id', Integer, Identity())\n    Column('description', Text),\n)\n```", "```py\nmethod __init__(always: bool = False, on_null: bool | None = None, start: int | None = None, increment: int | None = None, minvalue: int | None = None, maxvalue: int | None = None, nominvalue: bool | None = None, nomaxvalue: bool | None = None, cycle: bool | None = None, cache: int | None = None, order: bool | None = None) \u2192 None\n```", "```py\nmethod copy(**kw: Any) \u2192 Identity\n```", "```py\nTable(\"mytable\", metadata_obj, Column(\"somecolumn\", Integer, default=12))\n```", "```py\nTable(\"mytable\", metadata_obj, Column(\"somecolumn\", Integer, onupdate=25))\n```", "```py\n# a function which counts upwards\ni = 0\n\ndef mydefault():\n    global i\n    i += 1\n    return i\n\nt = Table(\n    \"mytable\",\n    metadata_obj,\n    Column(\"id\", Integer, primary_key=True, default=mydefault),\n)\n```", "```py\nimport datetime\n\nt = Table(\n    \"mytable\",\n    metadata_obj,\n    Column(\"id\", Integer, primary_key=True),\n    # define 'last_updated' to be populated with datetime.now()\n    Column(\"last_updated\", DateTime, onupdate=datetime.datetime.now),\n)\n```", "```py\ndef mydefault(context):\n    return context.get_current_parameters()[\"counter\"] + 12\n\nt = Table(\n    \"mytable\",\n    metadata_obj,\n    Column(\"counter\", Integer),\n    Column(\"counter_plus_twelve\", Integer, default=mydefault, onupdate=mydefault),\n)\n```", "```py\ndef mydefault(context):\n    return context.get_current_parameters()[\"counter\"] + 12\n\nt = Table(\n    \"mytable\",\n    metadata_obj,\n    Column(\"counter\", Integer),\n    Column(\"counter_plus_twelve\", Integer, default=mydefault, onupdate=mydefault),\n)\n```", "```py\nt = Table(\n    \"mytable\",\n    metadata_obj,\n    Column(\"id\", Integer, primary_key=True),\n    # define 'create_date' to default to now()\n    Column(\"create_date\", DateTime, default=func.now()),\n    # define 'key' to pull its default from the 'keyvalues' table\n    Column(\n        \"key\",\n        String(20),\n        default=select(keyvalues.c.key).where(keyvalues.c.type=\"type1\"),\n    ),\n    # define 'last_modified' to use the current_timestamp SQL function on update\n    Column(\"last_modified\", DateTime, onupdate=func.utc_timestamp()),\n)\n```", "```py\nt = Table(\n    \"test\",\n    metadata_obj,\n    Column(\"abc\", String(20), server_default=\"abc\"),\n    Column(\"created_at\", DateTime, server_default=func.sysdate()),\n    Column(\"index_value\", Integer, server_default=text(\"0\")),\n)\n```", "```py\nCREATE  TABLE  test  (\n  abc  varchar(20)  default  'abc',\n  created_at  datetime  default  sysdate,\n  index_value  integer  default  0\n)\n```", "```py\nfrom sqlalchemy.schema import FetchedValue\n\nt = Table(\n    \"test\",\n    metadata_obj,\n    Column(\"id\", Integer, primary_key=True),\n    Column(\"abc\", TIMESTAMP, server_default=FetchedValue()),\n    Column(\"def\", String(20), server_onupdate=FetchedValue()),\n)\n```", "```py\ntable = Table(\n    \"cartitems\",\n    metadata_obj,\n    Column(\n        \"cart_id\",\n        Integer,\n        Sequence(\"cart_id_seq\", start=1),\n        primary_key=True,\n    ),\n    Column(\"description\", String(40)),\n    Column(\"createdate\", DateTime()),\n)\n```", "```py\nCREATE  SEQUENCE  cart_id_seq  START  WITH  1\n\nCREATE  TABLE  cartitems  (\n  cart_id  INTEGER  NOT  NULL,\n  description  VARCHAR(40),\n  createdate  TIMESTAMP  WITHOUT  TIME  ZONE,\n  PRIMARY  KEY  (cart_id)\n)\n```", "```py\nSequence(\"cart_id_seq\", start=1, schema=\"some_schema\")\n```", "```py\nINSERT  INTO  cartitems  (cart_id,  description,  createdate)\nVALUES  (next_val(cart_id_seq),  'some description',  '2015-10-15 12:00:15')\nRETURNING  cart_id\n```", "```py\ntable = Table(\n    \"cartitems\",\n    metadata_obj,\n    Column(\n        \"cart_id\",\n        Integer,\n        # use an explicit Sequence where available, but not on\n        # PostgreSQL where SERIAL will be used\n        Sequence(\"cart_id_seq\", start=1, optional=True),\n        primary_key=True,\n    ),\n    Column(\"description\", String(40)),\n    Column(\"createdate\", DateTime()),\n)\n```", "```py\nwith my_engine.connect() as conn:\n    seq = Sequence(\"some_sequence\", start=1)\n    nextid = conn.execute(seq)\n```", "```py\n>>> my_seq = Sequence(\"some_sequence\", start=1)\n>>> stmt = select(my_seq.next_value())\n>>> print(stmt.compile(dialect=postgresql.dialect()))\nSELECT  nextval('some_sequence')  AS  next_value_1 \n```", "```py\nseq = Sequence(\"my_general_seq\", metadata=metadata_obj, start=1)\n```", "```py\ntable = Table(\n    \"cartitems\",\n    metadata_obj,\n    seq,\n    Column(\"description\", String(40)),\n    Column(\"createdate\", DateTime()),\n)\n```", "```py\nColumn(\n    \"cart_id\",\n    Integer,\n    Sequence(\"cart_id_seq\", metadata=metadata_obj, start=1),\n    primary_key=True,\n)\n```", "```py\ncart_id_seq = Sequence(\"cart_id_seq\", metadata=metadata_obj, start=1)\ntable = Table(\n    \"cartitems\",\n    metadata_obj,\n    Column(\n        \"cart_id\",\n        Integer,\n        cart_id_seq,\n        server_default=cart_id_seq.next_value(),\n        primary_key=True,\n    ),\n    Column(\"description\", String(40)),\n    Column(\"createdate\", DateTime()),\n)\n```", "```py\nclass CartItem(Base):\n    __tablename__ = \"cartitems\"\n\n    cart_id_seq = Sequence(\"cart_id_seq\", metadata=Base.metadata, start=1)\n    cart_id = Column(\n        Integer, cart_id_seq, server_default=cart_id_seq.next_value(), primary_key=True\n    )\n    description = Column(String(40))\n    createdate = Column(DateTime)\n```", "```py\nCREATE  TABLE  cartitems  (\n  cart_id  INTEGER  DEFAULT  nextval('cart_id_seq')  NOT  NULL,\n  description  VARCHAR(40),\n  createdate  TIMESTAMP  WITHOUT  TIME  ZONE,\n  PRIMARY  KEY  (cart_id)\n)\n```", "```py\ntable = Table(\n    \"cartitems\",\n    metadata_obj,\n    Column(\n        \"cart_id\",\n        Integer,\n        # use an explicit Sequence where available, but not on\n        # PostgreSQL where SERIAL will be used\n        Sequence(\"cart_id_seq\", start=1, optional=True),\n        primary_key=True,\n    ),\n    Column(\"description\", String(40)),\n    Column(\"createdate\", DateTime()),\n)\n```", "```py\nwith my_engine.connect() as conn:\n    seq = Sequence(\"some_sequence\", start=1)\n    nextid = conn.execute(seq)\n```", "```py\n>>> my_seq = Sequence(\"some_sequence\", start=1)\n>>> stmt = select(my_seq.next_value())\n>>> print(stmt.compile(dialect=postgresql.dialect()))\nSELECT  nextval('some_sequence')  AS  next_value_1 \n```", "```py\nseq = Sequence(\"my_general_seq\", metadata=metadata_obj, start=1)\n```", "```py\ntable = Table(\n    \"cartitems\",\n    metadata_obj,\n    seq,\n    Column(\"description\", String(40)),\n    Column(\"createdate\", DateTime()),\n)\n```", "```py\nColumn(\n    \"cart_id\",\n    Integer,\n    Sequence(\"cart_id_seq\", metadata=metadata_obj, start=1),\n    primary_key=True,\n)\n```", "```py\ncart_id_seq = Sequence(\"cart_id_seq\", metadata=metadata_obj, start=1)\ntable = Table(\n    \"cartitems\",\n    metadata_obj,\n    Column(\n        \"cart_id\",\n        Integer,\n        cart_id_seq,\n        server_default=cart_id_seq.next_value(),\n        primary_key=True,\n    ),\n    Column(\"description\", String(40)),\n    Column(\"createdate\", DateTime()),\n)\n```", "```py\nclass CartItem(Base):\n    __tablename__ = \"cartitems\"\n\n    cart_id_seq = Sequence(\"cart_id_seq\", metadata=Base.metadata, start=1)\n    cart_id = Column(\n        Integer, cart_id_seq, server_default=cart_id_seq.next_value(), primary_key=True\n    )\n    description = Column(String(40))\n    createdate = Column(DateTime)\n```", "```py\nCREATE  TABLE  cartitems  (\n  cart_id  INTEGER  DEFAULT  nextval('cart_id_seq')  NOT  NULL,\n  description  VARCHAR(40),\n  createdate  TIMESTAMP  WITHOUT  TIME  ZONE,\n  PRIMARY  KEY  (cart_id)\n)\n```", "```py\nfrom sqlalchemy import Table, Column, MetaData, Integer, Computed\n\nmetadata_obj = MetaData()\n\nsquare = Table(\n    \"square\",\n    metadata_obj,\n    Column(\"id\", Integer, primary_key=True),\n    Column(\"side\", Integer),\n    Column(\"area\", Integer, Computed(\"side * side\")),\n    Column(\"perimeter\", Integer, Computed(\"4 * side\")),\n)\n```", "```py\nCREATE  TABLE  square  (\n  id  SERIAL  NOT  NULL,\n  side  INTEGER,\n  area  INTEGER  GENERATED  ALWAYS  AS  (side  *  side)  STORED,\n  perimeter  INTEGER  GENERATED  ALWAYS  AS  (4  *  side)  STORED,\n  PRIMARY  KEY  (id)\n)\n```", "```py\nfrom sqlalchemy import Table, Column, MetaData, Integer, Identity, String\n\nmetadata_obj = MetaData()\n\ndata = Table(\n    \"data\",\n    metadata_obj,\n    Column(\"id\", Integer, Identity(start=42, cycle=True), primary_key=True),\n    Column(\"data\", String),\n)\n```", "```py\nCREATE  TABLE  data  (\n  id  INTEGER  GENERATED  BY  DEFAULT  AS  IDENTITY  (START  WITH  42  CYCLE)  NOT  NULL,\n  data  VARCHAR,\n  PRIMARY  KEY  (id)\n)\n```", "```py\nCREATE  TABLE  data  (\n  id  INTEGER  GENERATED  ALWAYS  AS  IDENTITY  (START  WITH  42  CYCLE)  NOT  NULL,\n  data  VARCHAR,\n  PRIMARY  KEY  (id)\n)\n```", "```py\nclass sqlalchemy.schema.Computed\n```", "```py\nfrom sqlalchemy import Computed\n\nTable('square', metadata_obj,\n    Column('side', Float, nullable=False),\n    Column('area', Float, Computed('side * side'))\n)\n```", "```py\nmethod __init__(sqltext: _DDLColumnArgument, persisted: bool | None = None) \u2192 None\n```", "```py\nmethod copy(*, target_table: Table | None = None, **kw: Any) \u2192 Computed\n```", "```py\nclass sqlalchemy.schema.ColumnDefault\n```", "```py\nColumn('foo', Integer, default=50)\n```", "```py\nColumn('foo', Integer, ColumnDefault(50))\n```", "```py\nclass sqlalchemy.schema.DefaultClause\n```", "```py\nColumn('foo', Integer, server_default=\"50\")\n```", "```py\nColumn('foo', Integer, DefaultClause(\"50\"))\n```", "```py\nclass sqlalchemy.schema.DefaultGenerator\n```", "```py\nclass sqlalchemy.schema.FetchedValue\n```", "```py\nColumn('foo', Integer, FetchedValue())\n```", "```py\nclass sqlalchemy.schema.Sequence\n```", "```py\nsome_table = Table(\n    'some_table', metadata,\n    Column('id', Integer, Sequence('some_table_seq', start=1),\n    primary_key=True)\n)\n```", "```py\nmethod __init__(name: str, start: int | None = None, increment: int | None = None, minvalue: int | None = None, maxvalue: int | None = None, nominvalue: bool | None = None, nomaxvalue: bool | None = None, cycle: bool | None = None, schema: str | Literal[SchemaConst.BLANK_SCHEMA] | None = None, cache: int | None = None, order: bool | None = None, data_type: _TypeEngineArgument[int] | None = None, optional: bool = False, quote: bool | None = None, metadata: MetaData | None = None, quote_schema: bool | None = None, for_update: bool = False) \u2192 None\n```", "```py\nmethod create(bind: _CreateDropBind, checkfirst: bool = True) \u2192 None\n```", "```py\nmethod drop(bind: _CreateDropBind, checkfirst: bool = True) \u2192 None\n```", "```py\nmethod next_value() \u2192 Function[int]\n```", "```py\nclass sqlalchemy.schema.Identity\n```", "```py\nfrom sqlalchemy import Identity\n\nTable('foo', metadata_obj,\n    Column('id', Integer, Identity())\n    Column('description', Text),\n)\n```", "```py\nmethod __init__(always: bool = False, on_null: bool | None = None, start: int | None = None, increment: int | None = None, minvalue: int | None = None, maxvalue: int | None = None, nominvalue: bool | None = None, nomaxvalue: bool | None = None, cycle: bool | None = None, cache: int | None = None, order: bool | None = None) \u2192 None\n```", "```py\nmethod copy(**kw: Any) \u2192 Identity\n```"]