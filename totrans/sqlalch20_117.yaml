- en: SQL Expressions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SQL 表达式
- en: 原文：[https://docs.sqlalchemy.org/en/20/faq/sqlexpressions.html](https://docs.sqlalchemy.org/en/20/faq/sqlexpressions.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://docs.sqlalchemy.org/en/20/faq/sqlexpressions.html](https://docs.sqlalchemy.org/en/20/faq/sqlexpressions.html)
- en: '[How do I render SQL expressions as strings, possibly with bound parameters
    inlined?](#how-do-i-render-sql-expressions-as-strings-possibly-with-bound-parameters-inlined)'
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[如何将 SQL 表达式呈现为字符串，可能包含内联的绑定参数？](#how-do-i-render-sql-expressions-as-strings-possibly-with-bound-parameters-inlined)'
- en: '[Stringifying for Specific Databases](#stringifying-for-specific-databases)'
  id: totrans-3
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[针对特定数据库进行字符串化](#stringifying-for-specific-databases)'
- en: '[Rendering Bound Parameters Inline](#rendering-bound-parameters-inline)'
  id: totrans-4
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[内联呈现绑定参数](#rendering-bound-parameters-inline)'
- en: '[Rendering “POSTCOMPILE” Parameters as Bound Parameters](#rendering-postcompile-parameters-as-bound-parameters)'
  id: totrans-5
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[将“POSTCOMPILE”参数呈现为绑定参数](#rendering-postcompile-parameters-as-bound-parameters)'
- en: '[Why are percent signs being doubled up when stringifying SQL statements?](#why-are-percent-signs-being-doubled-up-when-stringifying-sql-statements)'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[在字符串化 SQL 语句时为什么百分号会被双倍显示？](#why-are-percent-signs-being-doubled-up-when-stringifying-sql-statements)'
- en: '[I’m using op() to generate a custom operator and my parenthesis are not coming
    out correctly](#i-m-using-op-to-generate-a-custom-operator-and-my-parenthesis-are-not-coming-out-correctly)'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[我正在使用 op() 生成自定义运算符，但我的括号没有正确显示](#i-m-using-op-to-generate-a-custom-operator-and-my-parenthesis-are-not-coming-out-correctly)'
- en: '[Why are the parentheses rules like this?](#why-are-the-parentheses-rules-like-this)'
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[为什么括号规则是这样的？](#why-are-the-parentheses-rules-like-this)'
- en: '## How do I render SQL expressions as strings, possibly with bound parameters
    inlined?'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '## 如何将 SQL 表达式呈现为字符串，可能包含内联的绑定参数？'
- en: 'The “stringification” of a SQLAlchemy Core statement object or expression fragment,
    as well as that of an ORM [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object, in the majority of simple cases is as simple as
    using the `str()` builtin function, as below when use it with the `print` function
    (note the Python `print` function also calls `str()` automatically if we don’t
    use it explicitly):'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy Core 语句对象或表达式片段的“字符串化”，以及 ORM [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") 对象，在大多数简单情况下都可以简单地使用 `str()` 内置函数来实现，如下所示，当与 `print` 函数一起使用时（请注意
    Python `print` 函数如果不显式使用 `str()`，也会自动调用它）：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `str()` builtin, or an equivalent, can be invoked on ORM [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object as well as any statement such as that of [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select"), [`insert()`](../core/dml.html#sqlalchemy.sql.expression.insert
    "sqlalchemy.sql.expression.insert") etc. and also any expression fragment, such
    as:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`str()` 内置函数或等效函数，可在 ORM [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") 对象上调用，也可在诸如 [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select")、[`insert()`](../core/dml.html#sqlalchemy.sql.expression.insert
    "sqlalchemy.sql.expression.insert") 等语句上调用，还可在任何表达式片段上调用，例如：'
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Stringifying for Specific Databases
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 针对特定数据库进行字符串化
- en: 'A complication arises when the statement or fragment we are stringifying contains
    elements that have a database-specific string format, or when it contains elements
    that are only available within a certain kind of database. In these cases, we
    might get a stringified statement that is not in the correct syntax for the database
    we are targeting, or the operation may raise a [`UnsupportedCompilationError`](../core/exceptions.html#sqlalchemy.exc.UnsupportedCompilationError
    "sqlalchemy.exc.UnsupportedCompilationError") exception. In these cases, it is
    necessary that we stringify the statement using the [`ClauseElement.compile()`](../core/foundation.html#sqlalchemy.sql.expression.ClauseElement.compile
    "sqlalchemy.sql.expression.ClauseElement.compile") method, while passing along
    an [`Engine`](../core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    or [`Dialect`](../core/internals.html#sqlalchemy.engine.Dialect "sqlalchemy.engine.Dialect")
    object that represents the target database. Such as below, if we have a MySQL
    database engine, we can stringify a statement in terms of the MySQL dialect:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们要将语句或片段字符串化时，如果包含具有特定于数据库的字符串格式的元素，或者包含仅在某种类型的数据库中可用的元素，则会出现复杂情况。在这些情况下，我们可能会得到一个不符合我们目标数据库正确语法的字符串化语句，或者操作可能会引发一个[`UnsupportedCompilationError`](../core/exceptions.html#sqlalchemy.exc.UnsupportedCompilationError
    "sqlalchemy.exc.UnsupportedCompilationError")异常。在这些情况下，有必要使用[`ClauseElement.compile()`](../core/foundation.html#sqlalchemy.sql.expression.ClauseElement.compile
    "sqlalchemy.sql.expression.ClauseElement.compile")方法将语句字符串化，同时传递一个代表目标数据库的[`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine")或[`Dialect`](../core/internals.html#sqlalchemy.engine.Dialect
    "sqlalchemy.engine.Dialect")对象。例如，如果我们有一个MySQL数据库引擎，我们可以按照MySQL方言字符串化一个语句：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'More directly, without building up an [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") object we can instantiate a [`Dialect`](../core/internals.html#sqlalchemy.engine.Dialect
    "sqlalchemy.engine.Dialect") object directly, as below where we use a PostgreSQL
    dialect:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 更直接地，不需要构建一个[`Engine`](../core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")对象，我们可以直接实例化一个[`Dialect`](../core/internals.html#sqlalchemy.engine.Dialect
    "sqlalchemy.engine.Dialect")对象，如下所示，我们使用一个PostgreSQL方言：
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Note that any dialect can be assembled using [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") itself with a dummy URL and then accessing the `Engine.dialect`
    attribute, such as if we wanted a dialect object for psycopg2:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，任何方言都可以使用[`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine")本身组装，使用一个虚拟URL，然后访问`Engine.dialect`属性，比如如果我们想要一个psycopg2的方言对象：
- en: '[PRE4]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'When given an ORM [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.query.Query") object, in order to get at the [`ClauseElement.compile()`](../core/foundation.html#sqlalchemy.sql.expression.ClauseElement.compile
    "sqlalchemy.sql.expression.ClauseElement.compile") method we only need access
    the `Query.statement` accessor first:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个ORM [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.query.Query")对象时，为了访问[`ClauseElement.compile()`](../core/foundation.html#sqlalchemy.sql.expression.ClauseElement.compile
    "sqlalchemy.sql.expression.ClauseElement.compile")方法，我们只需要首先访问`Query.statement`访问器：
- en: '[PRE5]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Rendering Bound Parameters Inline
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内联渲染绑定参数
- en: Warning
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: '**Never** use these techniques with string content received from untrusted
    input, such as from web forms or other user-input applications. SQLAlchemy’s facilities
    to coerce Python values into direct SQL string values are **not secure against
    untrusted input and do not validate the type of data being passed**. Always use
    bound parameters when programmatically invoking non-DDL SQL statements against
    a relational database.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**永远**不要使用这些技术处理来自不受信任输入的字符串内容，比如来自Web表单或其他用户输入应用程序。SQLAlchemy将Python值强制转换为直接SQL字符串值的功能**不安全**，并且不验证传递的数据类型。在针对关系数据库编程调用非DDL
    SQL语句时，始终使用绑定参数。'
- en: 'The above forms will render the SQL statement as it is passed to the Python
    [DBAPI](../glossary.html#term-DBAPI), which includes that bound parameters are
    not rendered inline. SQLAlchemy normally does not stringify bound parameters,
    as this is handled appropriately by the Python DBAPI, not to mention bypassing
    bound parameters is probably the most widely exploited security hole in modern
    web applications. SQLAlchemy has limited ability to do this stringification in
    certain circumstances such as that of emitting DDL. In order to access this functionality
    one can use the `literal_binds` flag, passed to `compile_kwargs`:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 上述形式将渲染SQL语句，因为它被传递到Python [DBAPI](../glossary.html#term-DBAPI)，其中包括绑定参数不会内联渲染。SQLAlchemy通常不会对绑定参数进行字符串化处理，因为这由Python
    DBAPI适当处理，更不用说绕过绑定参数可能是现代Web应用中被广泛利用的安全漏洞之一了。SQLAlchemy在某些情况下有限的能力执行此字符串化，例如发出DDL时。为了访问此功能，可以使用传递给`compile_kwargs`的`literal_binds`标志：
- en: '[PRE6]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This functionality is provided mainly for logging or debugging purposes, where
    having the raw sql string of a query may prove useful.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 此功能主要用于日志记录或调试目的，其中获得查询的原始sql字符串可能会很有用。
- en: The above approach has the caveats that it is only supported for basic types,
    such as ints and strings, and furthermore if a [`bindparam()`](../core/sqlelement.html#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam") without a pre-set value is used directly,
    it won’t be able to stringify that either. Methods of stringifying all parameters
    unconditionally are detailed below.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 上述方法的注意事项是，它仅支持基本类型，如整数和字符串，而且如果直接使用未设置预设值的[`bindparam()`](../core/sqlelement.html#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam")，它也无法对其进行字符串化处理。下面详细介绍了无条件对所有参数进行字符串化的方法。
- en: Tip
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'The reason SQLAlchemy does not support full stringification of all datatypes
    is threefold:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy不支持对所有数据类型进行完全字符串化的原因有三个：
- en: This is a functionality that is already supported by the DBAPI in use when the
    DBAPI is used normally. The SQLAlchemy project cannot be tasked with duplicating
    this functionality for every datatype for all backends, as this is redundant work
    which also incurs significant testing and ongoing support overhead.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当正常使用DBAPI时，该功能已被当前DBAPI支持。SQLAlchemy项目不能被要求为所有后端的所有数据类型重复这种功能，因为这是多余的工作，还带来了重大的测试和持续支持开销。
- en: Stringifying with bound parameters inlined for specific databases suggests a
    usage that is actually passing these fully stringified statements onto the database
    for execution. This is unnecessary and insecure, and SQLAlchemy does not want
    to encourage this use in any way.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于特定数据库的绑定参数进行字符串化建议一种实际上将这些完全字符串化的语句传递给数据库以进行执行的用法。这是不必要和不安全的，SQLAlchemy不希望以任何方式鼓励这种用法。
- en: The area of rendering literal values is the most likely area for security issues
    to be reported. SQLAlchemy tries to keep the area of safe parameter stringification
    an issue for the DBAPI drivers as much as possible where the specifics for each
    DBAPI can be handled appropriately and securely.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 渲染字面值的区域是最有可能报告安全问题的地方。SQLAlchemy尽量将安全参数字符串化的区域留给DBAPI驱动程序，这样每个DBAPI的具体细节可以得到适当和安全地处理。
- en: 'As SQLAlchemy intentionally does not support full stringification of literal
    values, techniques to do so within specific debugging scenarios include the following.
    As an example, we will use the PostgreSQL `UUID` datatype:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 由于SQLAlchemy故意不支持对所有数据类型的完全字符串化，因此在特定调试场景下执行此操作的技术包括以下内容。作为示例，我们将使用PostgreSQL的`UUID`数据类型：
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Given the above model and statement which will compare a column to a single
    UUID value, options for stringifying this statement with inline values include:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 给定上述模型和语句，将比较一列与单个UUID值，将此语句与内联值一起进行字符串化的选项包括：
- en: 'Some DBAPIs such as psycopg2 support helper functions like [mogrify()](https://www.psycopg.org/docs/cursor.html#cursor.mogrify)
    which provide access to their literal-rendering functionality. To use such features,
    render the SQL string without using `literal_binds` and pass the parameters separately
    via the [`SQLCompiler.params`](../core/internals.html#sqlalchemy.sql.compiler.SQLCompiler.params
    "sqlalchemy.sql.compiler.SQLCompiler.params") accessor:'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些DBAPI，如psycopg2，支持像[mogrify()](https://www.psycopg.org/docs/cursor.html#cursor.mogrify)这样的辅助函数，提供对它们的字面渲染功能的访问。要使用此类功能，请渲染SQL字符串而不使用`literal_binds`，并通过[`SQLCompiler.params`](../core/internals.html#sqlalchemy.sql.compiler.SQLCompiler.params
    "sqlalchemy.sql.compiler.SQLCompiler.params")访问器分别传递参数：
- en: '[PRE8]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The above code will produce psycopg2’s raw bytestring:'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述代码将生成 psycopg2 的原始字节串：
- en: '[PRE9]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Render the [`SQLCompiler.params`](../core/internals.html#sqlalchemy.sql.compiler.SQLCompiler.params
    "sqlalchemy.sql.compiler.SQLCompiler.params") directly into the statement, using
    the appropriate [paramstyle](https://www.python.org/dev/peps/pep-0249/#paramstyle)
    of the target DBAPI. For example, the psycopg2 DBAPI uses the named `pyformat`
    style. The meaning of `render_postcompile` will be discussed in the next section.
    **WARNING this is NOT secure, do NOT use untrusted input**:'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直接将[`SQLCompiler.params`](../core/internals.html#sqlalchemy.sql.compiler.SQLCompiler.params
    "sqlalchemy.sql.compiler.SQLCompiler.params")渲染到语句中，使用目标 DBAPI 的适当[paramstyle](https://www.python.org/dev/peps/pep-0249/#paramstyle)。例如，psycopg2
    DBAPI 使用命名的`pyformat`样式。`render_postcompile`的含义将在下一节中讨论。**警告，这是不安全的，请勿使用不受信任的输入**：
- en: '[PRE10]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This will produce a non-working string, that nonetheless is suitable for debugging:'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将产生一个非工作的字符串，但仍然适合调试：
- en: '[PRE11]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Another example using a positional paramstyle such as `qmark`, we can render
    our above statement in terms of SQLite by also using the [`SQLCompiler.positiontup`](../core/internals.html#sqlalchemy.sql.compiler.SQLCompiler.positiontup
    "sqlalchemy.sql.compiler.SQLCompiler.positiontup") collection in conjunction with
    [`SQLCompiler.params`](../core/internals.html#sqlalchemy.sql.compiler.SQLCompiler.params
    "sqlalchemy.sql.compiler.SQLCompiler.params"), in order to retrieve the parameters
    in their positional order for the statement as compiled:'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 另一个示例使用位置参数风格，如`qmark`，我们可以使用[`SQLCompiler.positiontup`](../core/internals.html#sqlalchemy.sql.compiler.SQLCompiler.positiontup
    "sqlalchemy.sql.compiler.SQLCompiler.positiontup")集合与[`SQLCompiler.params`](../core/internals.html#sqlalchemy.sql.compiler.SQLCompiler.params
    "sqlalchemy.sql.compiler.SQLCompiler.params")一起编译我们上面的语句，以便按其位置顺序检索语句的参数：
- en: '[PRE12]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The above snippet prints:'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述片段打印：
- en: '[PRE13]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Use the [Custom SQL Constructs and Compilation Extension](../core/compiler.html)
    extension to render [`BindParameter`](../core/sqlelement.html#sqlalchemy.sql.expression.BindParameter
    "sqlalchemy.sql.expression.BindParameter") objects in a custom way when a user-defined
    flag is present. This flag is sent through the `compile_kwargs` dictionary like
    any other flag:'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用[自定义 SQL 构造和编译扩展](../core/compiler.html)扩展，在用户定义的标志存在时以自定义方式渲染[`BindParameter`](../core/sqlelement.html#sqlalchemy.sql.expression.BindParameter
    "sqlalchemy.sql.expression.BindParameter")对象。这个标志通过`compile_kwargs`字典发送，就像任何其他标志一样：
- en: '[PRE14]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The above recipe will print:'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述配方将打印：
- en: '[PRE15]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'For type-specific stringification that’s built into a model or a statement,
    the [`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") class may be used to provide custom stringification
    of any datatype using the [`TypeDecorator.process_literal_param()`](../core/custom_types.html#sqlalchemy.types.TypeDecorator.process_literal_param
    "sqlalchemy.types.TypeDecorator.process_literal_param") method:'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于内置于模型或语句中的特定类型的字符串化，可以使用[`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator")类使用[`TypeDecorator.process_literal_param()`](../core/custom_types.html#sqlalchemy.types.TypeDecorator.process_literal_param
    "sqlalchemy.types.TypeDecorator.process_literal_param")方法来提供任何数据类型的自定义字符串化：
- en: '[PRE16]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The above datatype needs to be used either explicitly within the model or locally
    within the statement using [`type_coerce()`](../core/sqlelement.html#sqlalchemy.sql.expression.type_coerce
    "sqlalchemy.sql.expression.type_coerce"), such as
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述数据类型需要在模型内部明确使用，或者在语句内部使用[`type_coerce()`](../core/sqlelement.html#sqlalchemy.sql.expression.type_coerce
    "sqlalchemy.sql.expression.type_coerce")，例如
- en: '[PRE17]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Again printing the same form:'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 再次打印相同形式：
- en: '[PRE18]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Rendering “POSTCOMPILE” Parameters as Bound Parameters
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将“POSTCOMPILE”参数渲染为绑定参数
- en: 'SQLAlchemy includes a variant on a bound parameter known as [`BindParameter.expanding`](../core/sqlelement.html#sqlalchemy.sql.expression.BindParameter.params.expanding
    "sqlalchemy.sql.expression.BindParameter"), which is a “late evaluated” parameter
    that is rendered in an intermediary state when a SQL construct is compiled, which
    is then further processed at statement execution time when the actual known values
    are passed. “Expanding” parameters are used for [`ColumnOperators.in_()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.in_
    "sqlalchemy.sql.expression.ColumnOperators.in_") expressions by default so that
    the SQL string can be safely cached independently of the actual lists of values
    being passed to a particular invocation of [`ColumnOperators.in_()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.in_
    "sqlalchemy.sql.expression.ColumnOperators.in_"):'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 包含一个称为 [`BindParameter.expanding`](../core/sqlelement.html#sqlalchemy.sql.expression.BindParameter.params.expanding
    "sqlalchemy.sql.expression.BindParameter") 的绑定参数变体，这是一个“延迟评估”的参数，当 SQL 构造编译时以中间状态呈现，然后在语句执行时进一步处理，当传递实际已知值时。默认情况下，通过
    [`ColumnOperators.in_()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.in_
    "sqlalchemy.sql.expression.ColumnOperators.in_") 表达式使用“扩展”参数，以便 SQL 字符串可以安全地独立缓存，而不受传递给
    [`ColumnOperators.in_()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.in_
    "sqlalchemy.sql.expression.ColumnOperators.in_") 的特定调用的实际值列表的影响：
- en: '[PRE19]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To render the IN clause with real bound parameter symbols, use the `render_postcompile=True`
    flag with [`ClauseElement.compile()`](../core/foundation.html#sqlalchemy.sql.expression.ClauseElement.compile
    "sqlalchemy.sql.expression.ClauseElement.compile"):'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 若要将 IN 子句呈现为真实的绑定参数符号，请在 [`ClauseElement.compile()`](../core/foundation.html#sqlalchemy.sql.expression.ClauseElement.compile
    "sqlalchemy.sql.expression.ClauseElement.compile") 中使用 `render_postcompile=True`
    标志：
- en: '[PRE20]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `literal_binds` flag, described in the previous section regarding rendering
    of bound parameters, automatically sets `render_postcompile` to True, so for a
    statement with simple ints/strings, these can be stringified directly:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在关于呈现绑定参数的前一节中描述的 `literal_binds` 标志会自动将 `render_postcompile` 设置为 True，因此对于带有简单整数/字符串的语句，这些可以直接转换为字符串：
- en: '[PRE21]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The [`SQLCompiler.params`](../core/internals.html#sqlalchemy.sql.compiler.SQLCompiler.params
    "sqlalchemy.sql.compiler.SQLCompiler.params") and [`SQLCompiler.positiontup`](../core/internals.html#sqlalchemy.sql.compiler.SQLCompiler.positiontup
    "sqlalchemy.sql.compiler.SQLCompiler.positiontup") are also compatible with `render_postcompile`,
    so that the previous recipes for rendering inline bound parameters will work here
    in the same way, such as SQLite’s positional form:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '[`SQLCompiler.params`](../core/internals.html#sqlalchemy.sql.compiler.SQLCompiler.params
    "sqlalchemy.sql.compiler.SQLCompiler.params") 和 [`SQLCompiler.positiontup`](../core/internals.html#sqlalchemy.sql.compiler.SQLCompiler.positiontup
    "sqlalchemy.sql.compiler.SQLCompiler.positiontup") 也与 `render_postcompile` 兼容，因此在这里以相同的方式工作，例如
    SQLite 的位置形式：'
- en: '[PRE22]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Warning
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: 'Remember, **all** of the above code recipes which stringify literal values,
    bypassing the use of bound parameters when sending statements to the database,
    are **only to be used when**:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，**所有**上述代码配方都是用于字符串化字面值，在将语句发送到数据库时绕过绑定参数的情况下，仅适用于：
- en: the use is **debugging purposes only**
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用仅限于**调试目的**
- en: the string **is not to be passed to a live production database**
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 字符串**不应传递到活动的生产数据库**
- en: only with **local, trusted input**
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仅与**本地、可信赖的输入**一起使用
- en: 'The above recipes for stringification of literal values are **not secure in
    any way and should never be used against production databases**.  ## Why are percent
    signs being doubled up when stringifying SQL statements?'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 上述用于字符串化字面值的配方在任何情况下都**不安全**，绝不应该用于生产数据库。## 字符串化 SQL 语句时为什么要双倍百分号？
- en: 'Many [DBAPI](../glossary.html#term-DBAPI) implementations make use of the `pyformat`
    or `format` [paramstyle](https://www.python.org/dev/peps/pep-0249/#paramstyle),
    which necessarily involve percent signs in their syntax. Most DBAPIs that do this
    expect percent signs used for other reasons to be doubled up (i.e. escaped) in
    the string form of the statements used, e.g.:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 [DBAPI](../glossary.html#term-DBAPI) 实现使用 `pyformat` 或 `format` [paramstyle](https://www.python.org/dev/peps/pep-0249/#paramstyle)，其语法中必然涉及百分号。大多数这样做的
    DBAPI 期望在用于语句的字符串形式中，百分号用于其他目的时应该是双倍的（即转义），例如：
- en: '[PRE23]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'When SQL statements are passed to the underlying DBAPI by SQLAlchemy, substitution
    of bound parameters works in the same way as the Python string interpolation operator
    `%`, and in many cases the DBAPI actually uses this operator directly. Above,
    the substitution of bound parameters would then look like:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当 SQL 语句由 SQLAlchemy 传递给底层的 DBAPI 时，绑定参数的替换方式与 Python 字符串插值运算符 `%` 相同，在许多情况下，DBAPI
    实际上直接使用此运算符。以上，绑定参数的替换看起来像：
- en: '[PRE24]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The default compilers for databases like PostgreSQL (default DBAPI is psycopg2)
    and MySQL (default DBAPI is mysqlclient) will have this percent sign escaping
    behavior:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 像 PostgreSQL（默认 DBAPI 是 psycopg2）和 MySQL（默认 DBAPI 是 mysqlclient）这样的数据库的默认编译器将具有百分号转义行为：
- en: '[PRE25]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'When such a dialect is being used, if non-DBAPI statements are desired that
    don’t include bound parameter symbols, one quick way to remove the percent signs
    is to simply substitute in an empty set of parameters using Python’s `%` operator
    directly:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用此类方言时，如果需要非 DBAPI 语句，而这些语句不包括绑定的参数符号，则可通过直接使用 Python 的 `%` 运算符来简单地替换空参数集来删除百分号：
- en: '[PRE26]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The other is to set a different parameter style on the dialect being used;
    all [`Dialect`](../core/internals.html#sqlalchemy.engine.Dialect "sqlalchemy.engine.Dialect")
    implementations accept a parameter `paramstyle` which will cause the compiler
    for that dialect to use the given parameter style. Below, the very common `named`
    parameter style is set within the dialect used for the compilation so that percent
    signs are no longer significant in the compiled form of SQL, and will no longer
    be escaped:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是在使用的方言上设置不同的参数样式；所有 [`Dialect`](../core/internals.html#sqlalchemy.engine.Dialect
    "sqlalchemy.engine.Dialect") 实现都接受一个参数 `paramstyle`，将导致该方言的编译器使用给定的参数样式。下面，在用于编译的方言中设置了非常常见的
    `named` 参数样式，以便百分号在 SQL 的编译形式中不再具有重要意义，并且将不再被转义：
- en: '[PRE27]  ## I’m using op() to generate a custom operator and my parenthesis
    are not coming out correctly'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE27]  ## 我使用 op() 来生成自定义操作符，但是我的括号没有正确显示'
- en: 'The [`Operators.op()`](../core/sqlelement.html#sqlalchemy.sql.expression.Operators.op
    "sqlalchemy.sql.expression.Operators.op") method allows one to create a custom
    database operator otherwise not known by SQLAlchemy:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Operators.op()`](../core/sqlelement.html#sqlalchemy.sql.expression.Operators.op
    "sqlalchemy.sql.expression.Operators.op") 方法允许创建自定义数据库操作符，否则 SQLAlchemy 不会识别：'
- en: '[PRE28]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'However, when using it on the right side of a compound expression, it doesn’t
    generate parenthesis as we expect:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，当在复合表达式的右侧使用时，它不会按我们的预期生成括号：
- en: '[PRE29]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Where above, we probably want `(q1 + q2) -> p`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的情况下，我们可能希望 `(q1 + q2) -> p`。
- en: 'The solution to this case is to set the precedence of the operator, using the
    [`Operators.op.precedence`](../core/sqlelement.html#sqlalchemy.sql.expression.Operators.op.params.precedence
    "sqlalchemy.sql.expression.Operators.op") parameter, to a high number, where 100
    is the maximum value, and the highest number used by any SQLAlchemy operator is
    currently 15:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此情况的解决方案是设置操作符的优先级，使用 [`Operators.op.precedence`](../core/sqlelement.html#sqlalchemy.sql.expression.Operators.op.params.precedence
    "sqlalchemy.sql.expression.Operators.op") 参数，将其设置为一个较高的数字，其中 `100` 是最大值，而 SQLAlchemy
    当前使用的任何操作符的最高数字为 `15`：
- en: '[PRE30]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We can also usually force parenthesization around a binary expression (e.g.
    an expression that has left/right operands and an operator) using the [`ColumnElement.self_group()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnElement.self_group
    "sqlalchemy.sql.expression.ColumnElement.self_group") method:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用 [`ColumnElement.self_group()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnElement.self_group
    "sqlalchemy.sql.expression.ColumnElement.self_group") 方法通常强制将二元表达式（例如具有左/右操作数和运算符的表达式）括在括号中：
- en: '[PRE31]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Why are the parentheses rules like this?
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为什么括号规则是这样的？
- en: 'A lot of databases barf when there are excessive parenthesis or when parenthesis
    are in unusual places they doesn’t expect, so SQLAlchemy does not generate parenthesis
    based on groupings, it uses operator precedence and if the operator is known to
    be associative, so that parenthesis are generated minimally. Otherwise, an expression
    like:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 当存在过多的括号或括号处于它们不期望的不寻常位置时，很多数据库都会出现问题，因此 SQLAlchemy 不会基于分组生成括号，它使用操作符优先级，如果操作符已知是可结合的，那么生成的括号将最小化。否则，像下面这样的表达式：
- en: '[PRE32]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'would produce:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 将产生：
- en: '[PRE33]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'which is fine but would probably annoy people (and be reported as a bug). In
    other cases, it leads to things that are more likely to confuse databases or at
    the very least readability, such as:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这是可以接受的，但可能会让人们感到恼火（并被报告为错误）。在其他情况下，它会导致更容易混淆数据库或至少可读性更差的事物，例如：
- en: '[PRE34]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'would produce:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 将产生：
- en: '[PRE35]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: There are also some edge cases where we get things like `"(x) = 7"` and databases
    really don’t like that either. So parenthesization doesn’t naively parenthesize,
    it uses operator precedence and associativity to determine groupings.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 也有一些边缘情况，我们会得到类似`"(x) = 7"`这样的东西，数据库真的不喜欢这样。所以括号化并不是简单地加括号，它使用运算符优先级和结合性来确定分组。
- en: For [`Operators.op()`](../core/sqlelement.html#sqlalchemy.sql.expression.Operators.op
    "sqlalchemy.sql.expression.Operators.op"), the value of precedence defaults to
    zero.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 对于[`Operators.op()`](../core/sqlelement.html#sqlalchemy.sql.expression.Operators.op
    "sqlalchemy.sql.expression.Operators.op")，优先级的值默认为零。
- en: 'What if we defaulted the value of [`Operators.op.precedence`](../core/sqlelement.html#sqlalchemy.sql.expression.Operators.op.params.precedence
    "sqlalchemy.sql.expression.Operators.op") to 100, e.g. the highest? Then this
    expression makes more parenthesis, but is otherwise OK, that is, these two are
    equivalent:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将[`Operators.op.precedence`](../core/sqlelement.html#sqlalchemy.sql.expression.Operators.op.params.precedence
    "sqlalchemy.sql.expression.Operators.op")的值默认为100，例如最高值，会怎么样？然后这个表达式会加更多括号，但其他方面都没问题，也就是说，这两个是等价的：
- en: '[PRE36]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'but these two are not:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 但这两个不是：
- en: '[PRE37]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: For now, it’s not clear that as long as we are doing parenthesization based
    on operator precedence and associativity, if there is really a way to parenthesize
    automatically for a generic operator with no precedence given that is going to
    work in all cases, because sometimes you want a custom op to have a lower precedence
    than the other operators and sometimes you want it to be higher.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，尚不清楚只要我们根据运算符优先级和结合性进行括号化，是否真的有一种方法可以自动为没有给定优先级的通用运算符进行括号化，以使其在所有情况下都有效，因为有时您希望自定义运算符具有比其他运算符更低的优先级，有时您希望它更高。
- en: 'It is possible that maybe if the “binary” expression above forced the use of
    the `self_group()` method when `op()` is called, making the assumption that a
    compound expression on the left side can always be parenthesized harmlessly. Perhaps
    this change can be made at some point, however for the time being keeping the
    parenthesization rules more internally consistent seems to be the safer approach.  ##
    How do I render SQL expressions as strings, possibly with bound parameters inlined?'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '可能如果上面的“二元”表达式在调用`op()`时强制使用`self_group()`方法，假设左侧的复合表达式总是可以无害地加括号。也许这种改变可以在某个时候实现，但是目前保持括号化规则更加内部一致似乎是更安全的方法。  ##
    如何将SQL表达式呈现为字符串，可能包含内联的绑定参数？'
- en: 'The “stringification” of a SQLAlchemy Core statement object or expression fragment,
    as well as that of an ORM [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object, in the majority of simple cases is as simple as
    using the `str()` builtin function, as below when use it with the `print` function
    (note the Python `print` function also calls `str()` automatically if we don’t
    use it explicitly):'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数简单情况下，将SQLAlchemy Core语句对象或表达式片段以及ORM [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") 对象“字符串化”，就像在使用`str()`内置函数时一样简单，如下所示，当与`print`函数一起使用时（请注意Python的`print`函数如果我们不显式使用`str()`，也会自动调用它）：
- en: '[PRE38]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `str()` builtin, or an equivalent, can be invoked on ORM [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object as well as any statement such as that of [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select"), [`insert()`](../core/dml.html#sqlalchemy.sql.expression.insert
    "sqlalchemy.sql.expression.insert") etc. and also any expression fragment, such
    as:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 内置函数`str()`，或者等效函数，可以在ORM [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") 对象上调用，也可以在任何语句上调用，比如[`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select")，[`insert()`](../core/dml.html#sqlalchemy.sql.expression.insert
    "sqlalchemy.sql.expression.insert")等，以及任何表达式片段，比如：
- en: '[PRE39]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Stringifying for Specific Databases
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 针对特定数据库的字符串化
- en: 'A complication arises when the statement or fragment we are stringifying contains
    elements that have a database-specific string format, or when it contains elements
    that are only available within a certain kind of database. In these cases, we
    might get a stringified statement that is not in the correct syntax for the database
    we are targeting, or the operation may raise a [`UnsupportedCompilationError`](../core/exceptions.html#sqlalchemy.exc.UnsupportedCompilationError
    "sqlalchemy.exc.UnsupportedCompilationError") exception. In these cases, it is
    necessary that we stringify the statement using the [`ClauseElement.compile()`](../core/foundation.html#sqlalchemy.sql.expression.ClauseElement.compile
    "sqlalchemy.sql.expression.ClauseElement.compile") method, while passing along
    an [`Engine`](../core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    or [`Dialect`](../core/internals.html#sqlalchemy.engine.Dialect "sqlalchemy.engine.Dialect")
    object that represents the target database. Such as below, if we have a MySQL
    database engine, we can stringify a statement in terms of the MySQL dialect:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们要字符串化的语句或片段包含具有数据库特定字符串格式的元素，或者包含仅在某种类型的数据库中可用的元素时，会出现一个复杂性。在这些情况下，我们可能会得到一个不符合我们所针对的数据库的正确语法的字符串化语句，或者该操作可能会引发一个[`UnsupportedCompilationError`](../core/exceptions.html#sqlalchemy.exc.UnsupportedCompilationError
    "sqlalchemy.exc.UnsupportedCompilationError")异常。在这些情况下，必须使用[`ClauseElement.compile()`](../core/foundation.html#sqlalchemy.sql.expression.ClauseElement.compile
    "sqlalchemy.sql.expression.ClauseElement.compile")方法对语句进行字符串化，同时传递一个表示目标数据库的[`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine")或[`Dialect`](../core/internals.html#sqlalchemy.engine.Dialect
    "sqlalchemy.engine.Dialect")对象。例如，如果我们有一个 MySQL 数据库引擎，我们可以如下将语句字符串化为 MySQL 方言：
- en: '[PRE40]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'More directly, without building up an [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") object we can instantiate a [`Dialect`](../core/internals.html#sqlalchemy.engine.Dialect
    "sqlalchemy.engine.Dialect") object directly, as below where we use a PostgreSQL
    dialect:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 更直接地，不需要构建[`Engine`](../core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")对象，我们可以直接实例化一个[`Dialect`](../core/internals.html#sqlalchemy.engine.Dialect
    "sqlalchemy.engine.Dialect")对象，如下所示，我们使用 PostgreSQL 方言：
- en: '[PRE41]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Note that any dialect can be assembled using [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") itself with a dummy URL and then accessing the `Engine.dialect`
    attribute, such as if we wanted a dialect object for psycopg2:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，可以使用[`create_engine()`](../core/engines.html#sqlalchemy.create_engine "sqlalchemy.create_engine")本身来组装任何方言，只需使用一个虚拟
    URL 并访问`Engine.dialect`属性即可，例如，如果我们想要 psycopg2 的方言对象：
- en: '[PRE42]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'When given an ORM [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.query.Query") object, in order to get at the [`ClauseElement.compile()`](../core/foundation.html#sqlalchemy.sql.expression.ClauseElement.compile
    "sqlalchemy.sql.expression.ClauseElement.compile") method we only need access
    the `Query.statement` accessor first:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个 ORM [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.query.Query")
    对象，为了获取[`ClauseElement.compile()`](../core/foundation.html#sqlalchemy.sql.expression.ClauseElement.compile
    "sqlalchemy.sql.expression.ClauseElement.compile")方法，我们只需要先访问`Query.statement`访问器：
- en: '[PRE43]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Rendering Bound Parameters Inline
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将绑定参数嵌入渲染
- en: Warning
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: '**Never** use these techniques with string content received from untrusted
    input, such as from web forms or other user-input applications. SQLAlchemy’s facilities
    to coerce Python values into direct SQL string values are **not secure against
    untrusted input and do not validate the type of data being passed**. Always use
    bound parameters when programmatically invoking non-DDL SQL statements against
    a relational database.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '**永远**不要将这些技术与来自不受信任输入的字符串内容一起使用，例如来自 Web 表单或其他用户输入应用程序。SQLAlchemy 将 Python
    值强制转换为直接 SQL 字符串值的设施**不安全**，不安全地针对不受信任的输入，并且不验证传递的数据类型。在针对关系数据库程序化地调用非 DDL SQL
    语句时，始终使用绑定参数。'
- en: 'The above forms will render the SQL statement as it is passed to the Python
    [DBAPI](../glossary.html#term-DBAPI), which includes that bound parameters are
    not rendered inline. SQLAlchemy normally does not stringify bound parameters,
    as this is handled appropriately by the Python DBAPI, not to mention bypassing
    bound parameters is probably the most widely exploited security hole in modern
    web applications. SQLAlchemy has limited ability to do this stringification in
    certain circumstances such as that of emitting DDL. In order to access this functionality
    one can use the `literal_binds` flag, passed to `compile_kwargs`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 上述形式将呈现 SQL 语句，就像它传递给 Python [DBAPI](../glossary.html#term-DBAPI) 一样，其中绑定参数不会被内联呈现。SQLAlchemy
    通常不会将绑定参数字符串化，因为这由 Python DBAPI 适当处理，更不用说绕过绑定参数可能是现代 Web 应用程序中最广泛利用的安全漏洞之一。SQLAlchemy
    在某些情况下有限地能够执行此字符串化，比如发出 DDL。为了访问此功能，可以使用传递给 `compile_kwargs` 的 `literal_binds`
    标志：
- en: '[PRE44]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This functionality is provided mainly for logging or debugging purposes, where
    having the raw sql string of a query may prove useful.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 此功能主要用于记录或调试目的，其中查询的原始 SQL 字符串可能会证明有用。
- en: The above approach has the caveats that it is only supported for basic types,
    such as ints and strings, and furthermore if a [`bindparam()`](../core/sqlelement.html#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam") without a pre-set value is used directly,
    it won’t be able to stringify that either. Methods of stringifying all parameters
    unconditionally are detailed below.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 上述方法的注意事项是它仅支持基本类型，如整数和字符串，而且如果直接使用没有预设值的 [`bindparam()`](../core/sqlelement.html#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam")，它也无法将其字符串化。无条件地将所有参数字符串化的方法如下所述。
- en: Tip
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'The reason SQLAlchemy does not support full stringification of all datatypes
    is threefold:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 不支持所有数据类型的完全字符串化的原因有三个：
- en: This is a functionality that is already supported by the DBAPI in use when the
    DBAPI is used normally. The SQLAlchemy project cannot be tasked with duplicating
    this functionality for every datatype for all backends, as this is redundant work
    which also incurs significant testing and ongoing support overhead.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当正常使用 DBAPI 时，这是已经受支持的功能。SQLAlchemy 项目无法被要求为所有后端的每种数据类型复制这种功能，因为这是多余的工作，还会带来重大的测试和持续支持开销。
- en: Stringifying with bound parameters inlined for specific databases suggests a
    usage that is actually passing these fully stringified statements onto the database
    for execution. This is unnecessary and insecure, and SQLAlchemy does not want
    to encourage this use in any way.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用内联绑定参数进行字符串化，针对特定数据库，表明了一种实际将这些完全字符串化的语句传递到数据库执行的用法。这是不必要且不安全的，SQLAlchemy
    不希望以任何方式鼓励这种用法。
- en: The area of rendering literal values is the most likely area for security issues
    to be reported. SQLAlchemy tries to keep the area of safe parameter stringification
    an issue for the DBAPI drivers as much as possible where the specifics for each
    DBAPI can be handled appropriately and securely.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 渲染字面值的领域是最有可能报告安全问题的领域。SQLAlchemy 尽量将安全参数字符串化的问题留给 DBAPI 驱动程序处理，其中每个 DBAPI 的具体情况可以得到适当和安全的处理。
- en: 'As SQLAlchemy intentionally does not support full stringification of literal
    values, techniques to do so within specific debugging scenarios include the following.
    As an example, we will use the PostgreSQL `UUID` datatype:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 SQLAlchemy 故意不支持对字面值的完全字符串化，因此在特定调试场景中执行此操作的技术包括以下内容。作为示例，我们将使用 PostgreSQL
    的 `UUID` 数据类型：
- en: '[PRE45]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Given the above model and statement which will compare a column to a single
    UUID value, options for stringifying this statement with inline values include:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于上述模型和语句，将比较列与单个 UUID 值，将此语句与内联值字符串化的选项包括：
- en: 'Some DBAPIs such as psycopg2 support helper functions like [mogrify()](https://www.psycopg.org/docs/cursor.html#cursor.mogrify)
    which provide access to their literal-rendering functionality. To use such features,
    render the SQL string without using `literal_binds` and pass the parameters separately
    via the [`SQLCompiler.params`](../core/internals.html#sqlalchemy.sql.compiler.SQLCompiler.params
    "sqlalchemy.sql.compiler.SQLCompiler.params") accessor:'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些 DBAPI，如 psycopg2，支持像 [mogrify()](https://www.psycopg.org/docs/cursor.html#cursor.mogrify)
    这样的辅助函数，提供对它们的字面渲染功能的访问。要使用这些功能，渲染 SQL 字符串时不要使用 `literal_binds`，并通过 [`SQLCompiler.params`](../core/internals.html#sqlalchemy.sql.compiler.SQLCompiler.params
    "sqlalchemy.sql.compiler.SQLCompiler.params") 访问器单独传递参数：
- en: '[PRE46]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The above code will produce psycopg2’s raw bytestring:'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述代码将生成psycopg2的原始字节串：
- en: '[PRE47]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Render the [`SQLCompiler.params`](../core/internals.html#sqlalchemy.sql.compiler.SQLCompiler.params
    "sqlalchemy.sql.compiler.SQLCompiler.params") directly into the statement, using
    the appropriate [paramstyle](https://www.python.org/dev/peps/pep-0249/#paramstyle)
    of the target DBAPI. For example, the psycopg2 DBAPI uses the named `pyformat`
    style. The meaning of `render_postcompile` will be discussed in the next section.
    **WARNING this is NOT secure, do NOT use untrusted input**:'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直接将[`SQLCompiler.params`](../core/internals.html#sqlalchemy.sql.compiler.SQLCompiler.params
    "sqlalchemy.sql.compiler.SQLCompiler.params")渲染到语句中，使用目标 DBAPI 的适当[paramstyle](https://www.python.org/dev/peps/pep-0249/#paramstyle)。例如，psycopg2
    DBAPI 使用命名的`pyformat`样式。`render_postcompile`的含义将在下一节中讨论。**警告这不安全，请勿使用不受信任的输入**：
- en: '[PRE48]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'This will produce a non-working string, that nonetheless is suitable for debugging:'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将产生一个非工作的字符串，但适合用于调试：
- en: '[PRE49]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Another example using a positional paramstyle such as `qmark`, we can render
    our above statement in terms of SQLite by also using the [`SQLCompiler.positiontup`](../core/internals.html#sqlalchemy.sql.compiler.SQLCompiler.positiontup
    "sqlalchemy.sql.compiler.SQLCompiler.positiontup") collection in conjunction with
    [`SQLCompiler.params`](../core/internals.html#sqlalchemy.sql.compiler.SQLCompiler.params
    "sqlalchemy.sql.compiler.SQLCompiler.params"), in order to retrieve the parameters
    in their positional order for the statement as compiled:'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 另一个例子是使用位置参数风格，例如`qmark`，我们可以结合使用[`SQLCompiler.positiontup`](../core/internals.html#sqlalchemy.sql.compiler.SQLCompiler.positiontup
    "sqlalchemy.sql.compiler.SQLCompiler.positiontup")集合和[`SQLCompiler.params`](../core/internals.html#sqlalchemy.sql.compiler.SQLCompiler.params
    "sqlalchemy.sql.compiler.SQLCompiler.params")来在SQLite中呈现上述语句，以便按照编译后的顺序检索参数：
- en: '[PRE50]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The above snippet prints:'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述片段打印：
- en: '[PRE51]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Use the [Custom SQL Constructs and Compilation Extension](../core/compiler.html)
    extension to render [`BindParameter`](../core/sqlelement.html#sqlalchemy.sql.expression.BindParameter
    "sqlalchemy.sql.expression.BindParameter") objects in a custom way when a user-defined
    flag is present. This flag is sent through the `compile_kwargs` dictionary like
    any other flag:'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当存在用户定义的标志时，使用[自定义 SQL 构造和编译扩展](../core/compiler.html)扩展以自定义方式呈现[`BindParameter`](../core/sqlelement.html#sqlalchemy.sql.expression.BindParameter
    "sqlalchemy.sql.expression.BindParameter")对象。此标志通过`compile_kwargs`字典像其他标志一样发送：
- en: '[PRE52]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The above recipe will print:'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述配方将打印：
- en: '[PRE53]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'For type-specific stringification that’s built into a model or a statement,
    the [`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") class may be used to provide custom stringification
    of any datatype using the [`TypeDecorator.process_literal_param()`](../core/custom_types.html#sqlalchemy.types.TypeDecorator.process_literal_param
    "sqlalchemy.types.TypeDecorator.process_literal_param") method:'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于内置于模型或语句的特定类型字符串化的[`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator")类可使用[`TypeDecorator.process_literal_param()`](../core/custom_types.html#sqlalchemy.types.TypeDecorator.process_literal_param
    "sqlalchemy.types.TypeDecorator.process_literal_param")方法来提供任何数据类型的自定义字符串化：
- en: '[PRE54]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The above datatype needs to be used either explicitly within the model or locally
    within the statement using [`type_coerce()`](../core/sqlelement.html#sqlalchemy.sql.expression.type_coerce
    "sqlalchemy.sql.expression.type_coerce"), such as
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述数据类型需要在模型内明确使用或在语句内部使用[`type_coerce()`](../core/sqlelement.html#sqlalchemy.sql.expression.type_coerce
    "sqlalchemy.sql.expression.type_coerce")，例如
- en: '[PRE55]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Again printing the same form:'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 再次打印相同形式：
- en: '[PRE56]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Rendering “POSTCOMPILE” Parameters as Bound Parameters
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将“POSTCOMPILE”参数呈现为绑定参数
- en: 'SQLAlchemy includes a variant on a bound parameter known as [`BindParameter.expanding`](../core/sqlelement.html#sqlalchemy.sql.expression.BindParameter.params.expanding
    "sqlalchemy.sql.expression.BindParameter"), which is a “late evaluated” parameter
    that is rendered in an intermediary state when a SQL construct is compiled, which
    is then further processed at statement execution time when the actual known values
    are passed. “Expanding” parameters are used for [`ColumnOperators.in_()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.in_
    "sqlalchemy.sql.expression.ColumnOperators.in_") expressions by default so that
    the SQL string can be safely cached independently of the actual lists of values
    being passed to a particular invocation of [`ColumnOperators.in_()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.in_
    "sqlalchemy.sql.expression.ColumnOperators.in_"):'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 包括一个变体绑定参数，称为 [`BindParameter.expanding`](../core/sqlelement.html#sqlalchemy.sql.expression.BindParameter.params.expanding
    "sqlalchemy.sql.expression.BindParameter.params.expanding")，它是一个“延迟评估”的参数，在编译
    SQL 构造时呈现为中间状态，然后在语句执行时进一步处理，当实际已知值传递时。 “扩展”参数默认用于 [`ColumnOperators.in_()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.in_
    "sqlalchemy.sql.expression.ColumnOperators.in_") 表达式，以便 SQL 字符串可以安全地独立于传递给 [`ColumnOperators.in_()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.in_
    "sqlalchemy.sql.expression.ColumnOperators.in_") 的特定值列表进行缓存：
- en: '[PRE57]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'To render the IN clause with real bound parameter symbols, use the `render_postcompile=True`
    flag with [`ClauseElement.compile()`](../core/foundation.html#sqlalchemy.sql.expression.ClauseElement.compile
    "sqlalchemy.sql.expression.ClauseElement.compile"):'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用实际的绑定参数符号呈现 IN 子句，请在 [`ClauseElement.compile()`](../core/foundation.html#sqlalchemy.sql.expression.ClauseElement.compile
    "sqlalchemy.sql.expression.ClauseElement.compile") 中使用 `render_postcompile=True`
    标志：
- en: '[PRE58]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The `literal_binds` flag, described in the previous section regarding rendering
    of bound parameters, automatically sets `render_postcompile` to True, so for a
    statement with simple ints/strings, these can be stringified directly:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 前一节中关于渲染绑定参数的 `literal_binds` 标志自动将 `render_postcompile` 设置为 True，因此对于具有简单整数/字符串的语句，可以直接进行字符串化：
- en: '[PRE59]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The [`SQLCompiler.params`](../core/internals.html#sqlalchemy.sql.compiler.SQLCompiler.params
    "sqlalchemy.sql.compiler.SQLCompiler.params") and [`SQLCompiler.positiontup`](../core/internals.html#sqlalchemy.sql.compiler.SQLCompiler.positiontup
    "sqlalchemy.sql.compiler.SQLCompiler.positiontup") are also compatible with `render_postcompile`,
    so that the previous recipes for rendering inline bound parameters will work here
    in the same way, such as SQLite’s positional form:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '[`SQLCompiler.params`](../core/internals.html#sqlalchemy.sql.compiler.SQLCompiler.params
    "sqlalchemy.sql.compiler.SQLCompiler.params") 和 [`SQLCompiler.positiontup`](../core/internals.html#sqlalchemy.sql.compiler.SQLCompiler.positiontup
    "sqlalchemy.sql.compiler.SQLCompiler.positiontup") 也与 `render_postcompile` 兼容，因此以前的渲染内联绑定参数的方法在这里也可以正常工作，例如
    SQLite 的位置形式：'
- en: '[PRE60]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Warning
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: 'Remember, **all** of the above code recipes which stringify literal values,
    bypassing the use of bound parameters when sending statements to the database,
    are **only to be used when**:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，**所有**上述代码示例，用于将字面值字符串化，将语句发送到数据库时绕过绑定参数的使用，**仅在以下情况下使用**：
- en: the use is **debugging purposes only**
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仅用于**调试目的**。
- en: the string **is not to be passed to a live production database**
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 字符串**不应传递给生产数据库**。
- en: only with **local, trusted input**
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仅用于**本地、可信的输入**。
- en: The above recipes for stringification of literal values are **not secure in
    any way and should never be used against production databases**.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 上述对字面值字符串化的方法**在任何情况下都不安全，绝不应该用于生产数据库**。
- en: Stringifying for Specific Databases
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 针对特定数据库的字符串化
- en: 'A complication arises when the statement or fragment we are stringifying contains
    elements that have a database-specific string format, or when it contains elements
    that are only available within a certain kind of database. In these cases, we
    might get a stringified statement that is not in the correct syntax for the database
    we are targeting, or the operation may raise a [`UnsupportedCompilationError`](../core/exceptions.html#sqlalchemy.exc.UnsupportedCompilationError
    "sqlalchemy.exc.UnsupportedCompilationError") exception. In these cases, it is
    necessary that we stringify the statement using the [`ClauseElement.compile()`](../core/foundation.html#sqlalchemy.sql.expression.ClauseElement.compile
    "sqlalchemy.sql.expression.ClauseElement.compile") method, while passing along
    an [`Engine`](../core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    or [`Dialect`](../core/internals.html#sqlalchemy.engine.Dialect "sqlalchemy.engine.Dialect")
    object that represents the target database. Such as below, if we have a MySQL
    database engine, we can stringify a statement in terms of the MySQL dialect:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们要将要串化的语句或片段包含有特定于数据库的字符串格式的元素，或者当它包含有仅在某种类型的数据库中可用的元素时，就会出现一些复杂情况。在这些情况下，我们可能会得到一个串化的语句，该语句不符合我们所针对的数据库的正确语法，或者该操作可能会引发一个
    [`UnsupportedCompilationError`](../core/exceptions.html#sqlalchemy.exc.UnsupportedCompilationError
    "sqlalchemy.exc.UnsupportedCompilationError") 异常。在这些情况下，有必要使用 [`ClauseElement.compile()`](../core/foundation.html#sqlalchemy.sql.expression.ClauseElement.compile
    "sqlalchemy.sql.expression.ClauseElement.compile") 方法串化该语句，同时传递一个代表目标数据库的 [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") 或 [`Dialect`](../core/internals.html#sqlalchemy.engine.Dialect
    "sqlalchemy.engine.Dialect") 对象。如下，如果我们有一个 MySQL 数据库引擎，我们可以根据 MySQL 方言串化一个语句：
- en: '[PRE61]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'More directly, without building up an [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") object we can instantiate a [`Dialect`](../core/internals.html#sqlalchemy.engine.Dialect
    "sqlalchemy.engine.Dialect") object directly, as below where we use a PostgreSQL
    dialect:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 更直接地，我们可以在不构建 [`Engine`](../core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    对象的情况下直接实例化一个 [`Dialect`](../core/internals.html#sqlalchemy.engine.Dialect "sqlalchemy.engine.Dialect")
    对象，如下所示，我们使用了一个 PostgreSQL 方言：
- en: '[PRE62]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Note that any dialect can be assembled using [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") itself with a dummy URL and then accessing the `Engine.dialect`
    attribute, such as if we wanted a dialect object for psycopg2:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，任何方言都可以使用 [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") 方法与一个虚拟 URL 配合组装，然后访问 `Engine.dialect` 属性，比如说如果我们想要一个
    psycopg2 的方言对象：
- en: '[PRE63]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'When given an ORM [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.query.Query") object, in order to get at the [`ClauseElement.compile()`](../core/foundation.html#sqlalchemy.sql.expression.ClauseElement.compile
    "sqlalchemy.sql.expression.ClauseElement.compile") method we only need access
    the `Query.statement` accessor first:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当给定一个 ORM [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.query.Query")
    对象时，为了获取到 [`ClauseElement.compile()`](../core/foundation.html#sqlalchemy.sql.expression.ClauseElement.compile
    "sqlalchemy.sql.expression.ClauseElement.compile") 方法，我们只需要先访问 `Query.statement`
    属性：
- en: '[PRE64]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Rendering Bound Parameters Inline
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将绑定参数内联渲染
- en: Warning
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: '**Never** use these techniques with string content received from untrusted
    input, such as from web forms or other user-input applications. SQLAlchemy’s facilities
    to coerce Python values into direct SQL string values are **not secure against
    untrusted input and do not validate the type of data being passed**. Always use
    bound parameters when programmatically invoking non-DDL SQL statements against
    a relational database.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '**永远**不要使用这些技术处理来自不受信任输入的字符串内容，比如来自网络表单或其他用户输入应用程序。SQLAlchemy 将 Python 值强制转换为直接的
    SQL 字符串值的能力**不安全且不验证传递的数据类型**。在针对关系数据库进行非 DDL SQL 语句的编程调用时，始终使用绑定参数。'
- en: 'The above forms will render the SQL statement as it is passed to the Python
    [DBAPI](../glossary.html#term-DBAPI), which includes that bound parameters are
    not rendered inline. SQLAlchemy normally does not stringify bound parameters,
    as this is handled appropriately by the Python DBAPI, not to mention bypassing
    bound parameters is probably the most widely exploited security hole in modern
    web applications. SQLAlchemy has limited ability to do this stringification in
    certain circumstances such as that of emitting DDL. In order to access this functionality
    one can use the `literal_binds` flag, passed to `compile_kwargs`:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 上述形式将渲染传递给 Python [DBAPI](../glossary.html#term-DBAPI) 的 SQL 语句，其中包括绑定参数不会内联渲染。SQLAlchemy
    通常不会字符串化绑定参数，因为这由 Python DBAPI 适当处理，更不用说绕过绑定参数可能是现代 Web 应用程序中被广泛利用的安全漏洞之一。SQLAlchemy
    在某些情况下（如发出 DDL）有限地执行此字符串化。为了访问此功能，可以使用传递给 `compile_kwargs` 的 `literal_binds` 标志：
- en: '[PRE65]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: This functionality is provided mainly for logging or debugging purposes, where
    having the raw sql string of a query may prove useful.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 此功能主要用于日志记录或调试目的，其中查询的原始 SQL 字符串可能会证明有用。
- en: The above approach has the caveats that it is only supported for basic types,
    such as ints and strings, and furthermore if a [`bindparam()`](../core/sqlelement.html#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam") without a pre-set value is used directly,
    it won’t be able to stringify that either. Methods of stringifying all parameters
    unconditionally are detailed below.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 上述方法的注意事项是，它仅支持基本类型，如整数和字符串，而且如果直接使用没有预设值的 [`bindparam()`](../core/sqlelement.html#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam")，它也无法将其字符串化。在下面详细描述了无条件字符串化所有参数的方法。
- en: Tip
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'The reason SQLAlchemy does not support full stringification of all datatypes
    is threefold:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 不支持所有数据类型的完全字符串化的原因有三：
- en: This is a functionality that is already supported by the DBAPI in use when the
    DBAPI is used normally. The SQLAlchemy project cannot be tasked with duplicating
    this functionality for every datatype for all backends, as this is redundant work
    which also incurs significant testing and ongoing support overhead.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当正常使用 DBAPI 时，已经支持此功能。SQLAlchemy 项目不能被要求为所有后端的每种数据类型复制此功能，因为这是多余的工作，还会产生重大的测试和持续支持开销。
- en: Stringifying with bound parameters inlined for specific databases suggests a
    usage that is actually passing these fully stringified statements onto the database
    for execution. This is unnecessary and insecure, and SQLAlchemy does not want
    to encourage this use in any way.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于特定数据库，将边界参数内联化字符串化建议使用实际将这些完全字符串化的语句传递给数据库执行。这是不必要且不安全的，SQLAlchemy 不希望以任何方式鼓励这种用法。
- en: The area of rendering literal values is the most likely area for security issues
    to be reported. SQLAlchemy tries to keep the area of safe parameter stringification
    an issue for the DBAPI drivers as much as possible where the specifics for each
    DBAPI can be handled appropriately and securely.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 字面值渲染领域是最有可能报告安全问题的领域。SQLAlchemy 尽量使安全参数字符串化领域成为 DBAPI 驱动程序的问题，其中每个 DBAPI 的具体情况都可以得到适当和安全地处理。
- en: 'As SQLAlchemy intentionally does not support full stringification of literal
    values, techniques to do so within specific debugging scenarios include the following.
    As an example, we will use the PostgreSQL `UUID` datatype:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 SQLAlchemy 故意不支持对字面值的完全字符串化，因此在特定调试场景中进行这样的技术包括以下内容。例如，我们将使用 PostgreSQL 的
    `UUID` 数据类型：
- en: '[PRE66]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Given the above model and statement which will compare a column to a single
    UUID value, options for stringifying this statement with inline values include:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 针对以上模型和语句将比较一列与单个 UUID 值的情况，使用内联值对该语句进行字符串化的选项包括：
- en: 'Some DBAPIs such as psycopg2 support helper functions like [mogrify()](https://www.psycopg.org/docs/cursor.html#cursor.mogrify)
    which provide access to their literal-rendering functionality. To use such features,
    render the SQL string without using `literal_binds` and pass the parameters separately
    via the [`SQLCompiler.params`](../core/internals.html#sqlalchemy.sql.compiler.SQLCompiler.params
    "sqlalchemy.sql.compiler.SQLCompiler.params") accessor:'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些 DBAPI（如 psycopg2）支持像 [mogrify()](https://www.psycopg.org/docs/cursor.html#cursor.mogrify)
    这样的辅助函数，提供对它们的字面值渲染功能的访问。要使用这些特性，渲染 SQL 字符串时不要使用 `literal_binds`，而是通过 [`SQLCompiler.params`](../core/internals.html#sqlalchemy.sql.compiler.SQLCompiler.params
    "sqlalchemy.sql.compiler.SQLCompiler.params") 访问器分别传递参数：
- en: '[PRE67]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The above code will produce psycopg2’s raw bytestring:'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述代码将产生 psycopg2 的原始字节字符串：
- en: '[PRE68]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Render the [`SQLCompiler.params`](../core/internals.html#sqlalchemy.sql.compiler.SQLCompiler.params
    "sqlalchemy.sql.compiler.SQLCompiler.params") directly into the statement, using
    the appropriate [paramstyle](https://www.python.org/dev/peps/pep-0249/#paramstyle)
    of the target DBAPI. For example, the psycopg2 DBAPI uses the named `pyformat`
    style. The meaning of `render_postcompile` will be discussed in the next section.
    **WARNING this is NOT secure, do NOT use untrusted input**:'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直接将 [`SQLCompiler.params`](../core/internals.html#sqlalchemy.sql.compiler.SQLCompiler.params
    "sqlalchemy.sql.compiler.SQLCompiler.params") 渲染到语句中，使用目标 DBAPI 的适当 [paramstyle](https://www.python.org/dev/peps/pep-0249/#paramstyle)。例如，psycopg2
    DBAPI 使用命名的 `pyformat` 样式。 `render_postcompile` 的含义将在下一节中讨论。 **警告：这不安全，请不要使用不受信任的输入**：
- en: '[PRE69]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'This will produce a non-working string, that nonetheless is suitable for debugging:'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将产生一个无效的字符串，尽管它适用于调试：
- en: '[PRE70]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Another example using a positional paramstyle such as `qmark`, we can render
    our above statement in terms of SQLite by also using the [`SQLCompiler.positiontup`](../core/internals.html#sqlalchemy.sql.compiler.SQLCompiler.positiontup
    "sqlalchemy.sql.compiler.SQLCompiler.positiontup") collection in conjunction with
    [`SQLCompiler.params`](../core/internals.html#sqlalchemy.sql.compiler.SQLCompiler.params
    "sqlalchemy.sql.compiler.SQLCompiler.params"), in order to retrieve the parameters
    in their positional order for the statement as compiled:'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 另一个示例使用了位置参数风格，如 `qmark`，我们还可以使用 [`SQLCompiler.positiontup`](../core/internals.html#sqlalchemy.sql.compiler.SQLCompiler.positiontup
    "sqlalchemy.sql.compiler.SQLCompiler.positiontup") 集合与 [`SQLCompiler.params`](../core/internals.html#sqlalchemy.sql.compiler.SQLCompiler.params
    "sqlalchemy.sql.compiler.SQLCompiler.params") 结合使用，以便按编译后的语句中的位置顺序检索参数：
- en: '[PRE71]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The above snippet prints:'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述代码段将打印：
- en: '[PRE72]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Use the [Custom SQL Constructs and Compilation Extension](../core/compiler.html)
    extension to render [`BindParameter`](../core/sqlelement.html#sqlalchemy.sql.expression.BindParameter
    "sqlalchemy.sql.expression.BindParameter") objects in a custom way when a user-defined
    flag is present. This flag is sent through the `compile_kwargs` dictionary like
    any other flag:'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当存在用户定义的标志时，使用 [自定义 SQL 构造和编译扩展](../core/compiler.html) 扩展以自定义方式渲染 [`BindParameter`](../core/sqlelement.html#sqlalchemy.sql.expression.BindParameter
    "sqlalchemy.sql.expression.BindParameter") 对象。此标志通过 `compile_kwargs` 字典发送，就像发送任何其他标志一样：
- en: '[PRE73]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The above recipe will print:'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述示例将打印：
- en: '[PRE74]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'For type-specific stringification that’s built into a model or a statement,
    the [`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") class may be used to provide custom stringification
    of any datatype using the [`TypeDecorator.process_literal_param()`](../core/custom_types.html#sqlalchemy.types.TypeDecorator.process_literal_param
    "sqlalchemy.types.TypeDecorator.process_literal_param") method:'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于内置于模型或语句中的特定类型字符串化，可以使用 [`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") 类来使用 [`TypeDecorator.process_literal_param()`](../core/custom_types.html#sqlalchemy.types.TypeDecorator.process_literal_param
    "sqlalchemy.types.TypeDecorator.process_literal_param") 方法提供任何数据类型的自定义字符串化：
- en: '[PRE75]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: The above datatype needs to be used either explicitly within the model or locally
    within the statement using [`type_coerce()`](../core/sqlelement.html#sqlalchemy.sql.expression.type_coerce
    "sqlalchemy.sql.expression.type_coerce"), such as
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述数据类型需要在模型内或在语句中本地使用 [`type_coerce()`](../core/sqlelement.html#sqlalchemy.sql.expression.type_coerce
    "sqlalchemy.sql.expression.type_coerce") 明确使用，例如
- en: '[PRE76]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Again printing the same form:'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 再次打印相同的形式：
- en: '[PRE77]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Rendering “POSTCOMPILE” Parameters as Bound Parameters
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将 “POSTCOMPILE” 参数呈现为绑定参数
- en: 'SQLAlchemy includes a variant on a bound parameter known as [`BindParameter.expanding`](../core/sqlelement.html#sqlalchemy.sql.expression.BindParameter.params.expanding
    "sqlalchemy.sql.expression.BindParameter"), which is a “late evaluated” parameter
    that is rendered in an intermediary state when a SQL construct is compiled, which
    is then further processed at statement execution time when the actual known values
    are passed. “Expanding” parameters are used for [`ColumnOperators.in_()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.in_
    "sqlalchemy.sql.expression.ColumnOperators.in_") expressions by default so that
    the SQL string can be safely cached independently of the actual lists of values
    being passed to a particular invocation of [`ColumnOperators.in_()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.in_
    "sqlalchemy.sql.expression.ColumnOperators.in_"):'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy包含一个称为[`BindParameter.expanding`](../core/sqlelement.html#sqlalchemy.sql.expression.BindParameter.params.expanding
    "sqlalchemy.sql.expression.BindParameter")的绑定参数变体，这是一个“延迟评估”的参数，当编译SQL结构时以中间状态呈现，然后在语句执行时进一步处理，当实际已知值被传递时。
    “扩展”参数默认用于[`ColumnOperators.in_()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.in_
    "sqlalchemy.sql.expression.ColumnOperators.in_")表达式，以便SQL字符串可以安全地独立于传递给[`ColumnOperators.in_()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.in_
    "sqlalchemy.sql.expression.ColumnOperators.in_")的特定调用的实际值被缓存：
- en: '[PRE78]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'To render the IN clause with real bound parameter symbols, use the `render_postcompile=True`
    flag with [`ClauseElement.compile()`](../core/foundation.html#sqlalchemy.sql.expression.ClauseElement.compile
    "sqlalchemy.sql.expression.ClauseElement.compile"):'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用实际的绑定参数符号呈现IN子句，请在[`ClauseElement.compile()`](../core/foundation.html#sqlalchemy.sql.expression.ClauseElement.compile
    "sqlalchemy.sql.expression.ClauseElement.compile")中使用`render_postcompile=True`标志：
- en: '[PRE79]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'The `literal_binds` flag, described in the previous section regarding rendering
    of bound parameters, automatically sets `render_postcompile` to True, so for a
    statement with simple ints/strings, these can be stringified directly:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前有关渲染绑定参数的部分中描述的`literal_binds`标志会自动将`render_postcompile`设置为True，因此对于具有简单int/字符串的语句，可以直接将它们字符串化：
- en: '[PRE80]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The [`SQLCompiler.params`](../core/internals.html#sqlalchemy.sql.compiler.SQLCompiler.params
    "sqlalchemy.sql.compiler.SQLCompiler.params") and [`SQLCompiler.positiontup`](../core/internals.html#sqlalchemy.sql.compiler.SQLCompiler.positiontup
    "sqlalchemy.sql.compiler.SQLCompiler.positiontup") are also compatible with `render_postcompile`,
    so that the previous recipes for rendering inline bound parameters will work here
    in the same way, such as SQLite’s positional form:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '[`SQLCompiler.params`](../core/internals.html#sqlalchemy.sql.compiler.SQLCompiler.params
    "sqlalchemy.sql.compiler.SQLCompiler.params")和[`SQLCompiler.positiontup`](../core/internals.html#sqlalchemy.sql.compiler.SQLCompiler.positiontup
    "sqlalchemy.sql.compiler.SQLCompiler.positiontup")与`render_postcompile`兼容，因此在此处渲染内联绑定参数的先前方法也将以相同的方式工作，例如SQLite的位置形式：'
- en: '[PRE81]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Warning
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: 'Remember, **all** of the above code recipes which stringify literal values,
    bypassing the use of bound parameters when sending statements to the database,
    are **only to be used when**:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，**所有**上述字符串化文字值的代码示例，当将语句发送到数据库时绕过绑定参数的使用，**只能在以下情况下使用**：
- en: the use is **debugging purposes only**
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仅用于**调试目的**
- en: the string **is not to be passed to a live production database**
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该字符串**不应传递给实时生产数据库**
- en: only with **local, trusted input**
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仅限于**本地，可信任的输入**
- en: The above recipes for stringification of literal values are **not secure in
    any way and should never be used against production databases**.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 上述用于将文字值字符串化的方法**在任何情况下都不安全，绝对不应该用于生产数据库**。
- en: '## Why are percent signs being doubled up when stringifying SQL statements?'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '## 为什么在将SQL语句字符串化时百分号会被加倍？'
- en: 'Many [DBAPI](../glossary.html#term-DBAPI) implementations make use of the `pyformat`
    or `format` [paramstyle](https://www.python.org/dev/peps/pep-0249/#paramstyle),
    which necessarily involve percent signs in their syntax. Most DBAPIs that do this
    expect percent signs used for other reasons to be doubled up (i.e. escaped) in
    the string form of the statements used, e.g.:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 许多[DBAPI](../glossary.html#term-DBAPI)实现采用`pyformat`或`format` [paramstyle](https://www.python.org/dev/peps/pep-0249/#paramstyle)，这在其语法中必然涉及百分号。这样做的大多数DBAPI都希望在使用的语句的字符串形式中，用于其他目的的百分号被双倍化（即转义），例如：
- en: '[PRE82]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'When SQL statements are passed to the underlying DBAPI by SQLAlchemy, substitution
    of bound parameters works in the same way as the Python string interpolation operator
    `%`, and in many cases the DBAPI actually uses this operator directly. Above,
    the substitution of bound parameters would then look like:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 当SQL语句通过SQLAlchemy传递给底层DBAPI时，绑定参数的替换方式与Python字符串插值运算符`%`相同，在许多情况下，DBAPI实际上直接使用这个运算符。上面，绑定参数的替换看起来像是：
- en: '[PRE83]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'The default compilers for databases like PostgreSQL (default DBAPI is psycopg2)
    and MySQL (default DBAPI is mysqlclient) will have this percent sign escaping
    behavior:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 像PostgreSQL（默认DBAPI是psycopg2）和MySQL（默认DBAPI是mysqlclient）这样的数据库的默认编译器将具有这种百分号转义行为：
- en: '[PRE84]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'When such a dialect is being used, if non-DBAPI statements are desired that
    don’t include bound parameter symbols, one quick way to remove the percent signs
    is to simply substitute in an empty set of parameters using Python’s `%` operator
    directly:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用这样的方言时，如果需要不包含绑定参数符号的非DBAPI语句，一种快速删除百分号的方法是直接使用Python的`%`运算符替换一个空的参数集：
- en: '[PRE85]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'The other is to set a different parameter style on the dialect being used;
    all [`Dialect`](../core/internals.html#sqlalchemy.engine.Dialect "sqlalchemy.engine.Dialect")
    implementations accept a parameter `paramstyle` which will cause the compiler
    for that dialect to use the given parameter style. Below, the very common `named`
    parameter style is set within the dialect used for the compilation so that percent
    signs are no longer significant in the compiled form of SQL, and will no longer
    be escaped:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是在使用的方言上设置不同的参数样式；所有[`Dialect`](../core/internals.html#sqlalchemy.engine.Dialect
    "sqlalchemy.engine.Dialect")实现都接受一个`paramstyle`参数，该参数将导致该方言的编译器使用给定的参数样式。下面，非常常见的`named`参数样式在用于编译的方言中设置，以便百分号在SQL的编译形式中不再重要，并且不再被转义：
- en: '[PRE86]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '## I’m using op() to generate a custom operator and my parenthesis are not
    coming out correctly'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '## 我正在使用op()生成自定义运算符，但我的括号没出来正确'
- en: 'The [`Operators.op()`](../core/sqlelement.html#sqlalchemy.sql.expression.Operators.op
    "sqlalchemy.sql.expression.Operators.op") method allows one to create a custom
    database operator otherwise not known by SQLAlchemy:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Operators.op()`](../core/sqlelement.html#sqlalchemy.sql.expression.Operators.op
    "sqlalchemy.sql.expression.Operators.op")方法允许创建一个SQLAlchemy中未知的自定义数据库操作符：'
- en: '[PRE87]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'However, when using it on the right side of a compound expression, it doesn’t
    generate parenthesis as we expect:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当将其用于复合表达式的右侧时，它不会生成我们期望的括号：
- en: '[PRE88]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Where above, we probably want `(q1 + q2) -> p`.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的情况下，我们可能想要`(q1 + q2) -> p`。
- en: 'The solution to this case is to set the precedence of the operator, using the
    [`Operators.op.precedence`](../core/sqlelement.html#sqlalchemy.sql.expression.Operators.op.params.precedence
    "sqlalchemy.sql.expression.Operators.op") parameter, to a high number, where 100
    is the maximum value, and the highest number used by any SQLAlchemy operator is
    currently 15:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这种情况的解决方案是设置运算符的优先级，使用[`Operators.op.precedence`](../core/sqlelement.html#sqlalchemy.sql.expression.Operators.op.params.precedence
    "sqlalchemy.sql.expression.Operators.op")参数，设置为一个高数字，其中100是最大值，当前任何SQLAlchemy运算符使用的最高数字是15：
- en: '[PRE89]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'We can also usually force parenthesization around a binary expression (e.g.
    an expression that has left/right operands and an operator) using the [`ColumnElement.self_group()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnElement.self_group
    "sqlalchemy.sql.expression.ColumnElement.self_group") method:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通常通过使用[`ColumnElement.self_group()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnElement.self_group
    "sqlalchemy.sql.expression.ColumnElement.self_group")方法强制在二元表达式（例如具有左/右操作数和运算符的表达式）周围加上括号：
- en: '[PRE90]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Why are the parentheses rules like this?
  id: totrans-258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为什么括号的规则是这样的？
- en: 'A lot of databases barf when there are excessive parenthesis or when parenthesis
    are in unusual places they doesn’t expect, so SQLAlchemy does not generate parenthesis
    based on groupings, it uses operator precedence and if the operator is known to
    be associative, so that parenthesis are generated minimally. Otherwise, an expression
    like:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 当存在过多的括号或者括号处于数据库不期望的不寻常位置时，许多数据库会报错，因此SQLAlchemy不基于分组生成括号，它使用操作符优先级以及如果操作符已知是可结合的，则生成最小的括号。否则，表达式如下：
- en: '[PRE91]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'would produce:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 将产生：
- en: '[PRE92]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'which is fine but would probably annoy people (and be reported as a bug). In
    other cases, it leads to things that are more likely to confuse databases or at
    the very least readability, such as:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做可能会让人们感到不爽（并被报告为错误）。在其他情况下，它会导致更容易让数据库混淆或至少降低可读性，比如：
- en: '[PRE93]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'would produce:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 将产生：
- en: '[PRE94]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: There are also some edge cases where we get things like `"(x) = 7"` and databases
    really don’t like that either. So parenthesization doesn’t naively parenthesize,
    it uses operator precedence and associativity to determine groupings.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些边界情况，我们会得到像`"(x) = 7"`这样的东西，数据库真的不喜欢这样。因此，括号化不是简单地添加括号，而是使用运算符优先级和结合性来确定分组。
- en: For [`Operators.op()`](../core/sqlelement.html#sqlalchemy.sql.expression.Operators.op
    "sqlalchemy.sql.expression.Operators.op"), the value of precedence defaults to
    zero.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 对于[`Operators.op()`](../core/sqlelement.html#sqlalchemy.sql.expression.Operators.op
    "sqlalchemy.sql.expression.Operators.op")，优先级的值默认为零。
- en: 'What if we defaulted the value of [`Operators.op.precedence`](../core/sqlelement.html#sqlalchemy.sql.expression.Operators.op.params.precedence
    "sqlalchemy.sql.expression.Operators.op") to 100, e.g. the highest? Then this
    expression makes more parenthesis, but is otherwise OK, that is, these two are
    equivalent:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将[`Operators.op.precedence`](../core/sqlelement.html#sqlalchemy.sql.expression.Operators.op.params.precedence
    "sqlalchemy.sql.expression.Operators.op")的值默认为100，即最高值，会怎样呢？然后这个表达式会多加括号，但除此之外还是可以的，也就是说，这两个表达式是等价的：
- en: '[PRE95]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'but these two are not:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 但是这两种情况不是：
- en: '[PRE96]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: For now, it’s not clear that as long as we are doing parenthesization based
    on operator precedence and associativity, if there is really a way to parenthesize
    automatically for a generic operator with no precedence given that is going to
    work in all cases, because sometimes you want a custom op to have a lower precedence
    than the other operators and sometimes you want it to be higher.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 目前来看，只要我们根据运算符的优先级和结合性进行括号化，如果真的有一种方法可以自动为没有给定优先级的通用运算符进行括号化，从而在所有情况下都能正常工作，这还不清楚，因为有时您希望自定义的运算符具有比其他运算符更低的优先级，有时您希望它更高。
- en: It is possible that maybe if the “binary” expression above forced the use of
    the `self_group()` method when `op()` is called, making the assumption that a
    compound expression on the left side can always be parenthesized harmlessly. Perhaps
    this change can be made at some point, however for the time being keeping the
    parenthesization rules more internally consistent seems to be the safer approach.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 如果上面的“binary”表达式强制在调用`op()`时使用`self_group()`方法，假设左侧的复合表达式总是可以无害地加上括号，那么这种可能性是存在的。也许这种改变以后可以实现，但是目前来看，保持括号规则在内部更一致似乎是更安全的方法。
- en: Why are the parentheses rules like this?
  id: totrans-275
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为什么括号规则会是这样？
- en: 'A lot of databases barf when there are excessive parenthesis or when parenthesis
    are in unusual places they doesn’t expect, so SQLAlchemy does not generate parenthesis
    based on groupings, it uses operator precedence and if the operator is known to
    be associative, so that parenthesis are generated minimally. Otherwise, an expression
    like:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 当括号过多或者括号出现在它们不期望的不寻常位置时，许多数据库会抛出错误，因此 SQLAlchemy 不基于分组生成括号，而是使用运算符优先级，如果运算符已知为结合性，那么会尽量生成最少的括号。否则，表达式如下：
- en: '[PRE97]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'would produce:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 会产生：
- en: '[PRE98]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'which is fine but would probably annoy people (and be reported as a bug). In
    other cases, it leads to things that are more likely to confuse databases or at
    the very least readability, such as:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 这是可以的，但可能会让人们感到烦恼（并报告为错误）。在其他情况下，它会导致更容易让数据库混淆，或者至少影响可读性，比如：
- en: '[PRE99]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'would produce:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 会产生：
- en: '[PRE100]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: There are also some edge cases where we get things like `"(x) = 7"` and databases
    really don’t like that either. So parenthesization doesn’t naively parenthesize,
    it uses operator precedence and associativity to determine groupings.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些边界情况，我们会得到像`"(x) = 7"`这样的东西，数据库真的不喜欢这样。因此，括号化不是简单地添加括号，而是使用运算符优先级和结合性来确定分组。
- en: For [`Operators.op()`](../core/sqlelement.html#sqlalchemy.sql.expression.Operators.op
    "sqlalchemy.sql.expression.Operators.op"), the value of precedence defaults to
    zero.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 对于[`Operators.op()`](../core/sqlelement.html#sqlalchemy.sql.expression.Operators.op
    "sqlalchemy.sql.expression.Operators.op")，优先级的值默认为零。
- en: 'What if we defaulted the value of [`Operators.op.precedence`](../core/sqlelement.html#sqlalchemy.sql.expression.Operators.op.params.precedence
    "sqlalchemy.sql.expression.Operators.op") to 100, e.g. the highest? Then this
    expression makes more parenthesis, but is otherwise OK, that is, these two are
    equivalent:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将[`Operators.op.precedence`](../core/sqlelement.html#sqlalchemy.sql.expression.Operators.op.params.precedence
    "sqlalchemy.sql.expression.Operators.op")的值默认为100，即最高值，会怎样呢？然后这个表达式会多加括号，但除此之外还是可以的，也就是说，这两个表达式是等价的：
- en: '[PRE101]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'but these two are not:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 但是这两种情况不是：
- en: '[PRE102]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: For now, it’s not clear that as long as we are doing parenthesization based
    on operator precedence and associativity, if there is really a way to parenthesize
    automatically for a generic operator with no precedence given that is going to
    work in all cases, because sometimes you want a custom op to have a lower precedence
    than the other operators and sometimes you want it to be higher.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，尚不清楚只要我们基于操作符优先级和结合性进行括号化，是否真的有一种方法可以自动为没有给定优先级的通用运算符添加括号，以便在所有情况下都能正常工作，因为有时您希望自定义操作符的优先级低于其他操作符，有时您希望它更高。
- en: It is possible that maybe if the “binary” expression above forced the use of
    the `self_group()` method when `op()` is called, making the assumption that a
    compound expression on the left side can always be parenthesized harmlessly. Perhaps
    this change can be made at some point, however for the time being keeping the
    parenthesization rules more internally consistent seems to be the safer approach.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 也许，如果上面的“二元”表达式在调用`op()`时强制使用了`self_group()`方法，假设左侧的复合表达式总是可以无害地加括号。也许这种改变可以在某个时候实现，然而就目前而言，保持括号规则更加内部一致似乎是更安全的做法。
