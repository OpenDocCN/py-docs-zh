- en: Cascades
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 级联
- en: 原文：[https://docs.sqlalchemy.org/en/20/orm/cascades.html](https://docs.sqlalchemy.org/en/20/orm/cascades.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://docs.sqlalchemy.org/en/20/orm/cascades.html](https://docs.sqlalchemy.org/en/20/orm/cascades.html)
- en: Mappers support the concept of configurable [cascade](../glossary.html#term-cascade)
    behavior on [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") constructs. This refers to how operations performed
    on a “parent” object relative to a particular [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") should be propagated to items referred to by that relationship
    (e.g. “child” objects), and is affected by the [`relationship.cascade`](relationship_api.html#sqlalchemy.orm.relationship.params.cascade
    "sqlalchemy.orm.relationship") option.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 映射器支持在[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")构造上配置可配置级联行为的概念。这涉及到相对于特定[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")上执行的操作应如何传播到由该关系引用的项目（例如“子”对象），并且受到[`relationship.cascade`](relationship_api.html#sqlalchemy.orm.relationship.params.cascade
    "sqlalchemy.orm.relationship")选项的影响。
- en: The default behavior of cascade is limited to cascades of the so-called [save-update](#cascade-save-update)
    and [merge](#cascade-merge) settings. The typical “alternative” setting for cascade
    is to add the [delete](#cascade-delete) and [delete-orphan](#cascade-delete-orphan)
    options; these settings are appropriate for related objects which only exist as
    long as they are attached to their parent, and are otherwise deleted.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 级联的默认行为仅限于所谓的[save-update](#cascade-save-update)和[merge](#cascade-merge)设置的级联。级联的典型“替代”设置是添加[delete](#cascade-delete)和[delete-orphan](#cascade-delete-orphan)选项；这些设置适用于只有在附加到其父对象时才存在的相关对象，并且在其他情况下将被删除。
- en: 'Cascade behavior is configured using the [`relationship.cascade`](relationship_api.html#sqlalchemy.orm.relationship.params.cascade
    "sqlalchemy.orm.relationship") option on [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship"):'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")上的[`relationship.cascade`](relationship_api.html#sqlalchemy.orm.relationship.params.cascade
    "sqlalchemy.orm.relationship")选项配置级联行为：
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To set cascades on a backref, the same flag can be used with the [`backref()`](relationship_api.html#sqlalchemy.orm.backref
    "sqlalchemy.orm.backref") function, which ultimately feeds its arguments back
    into [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship"):'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 要在反向引用上设置级联，可以使用相同的标志与[`backref()`](relationship_api.html#sqlalchemy.orm.backref
    "sqlalchemy.orm.backref")函数一起使用，该函数最终将其参数反馈到[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")中：
- en: '[PRE1]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The default value of [`relationship.cascade`](relationship_api.html#sqlalchemy.orm.relationship.params.cascade
    "sqlalchemy.orm.relationship") is `save-update, merge`. The typical alternative
    setting for this parameter is either `all` or more commonly `all, delete-orphan`.
    The `all` symbol is a synonym for `save-update, merge, refresh-expire, expunge,
    delete`, and using it in conjunction with `delete-orphan` indicates that the child
    object should follow along with its parent in all cases, and be deleted once it
    is no longer associated with that parent.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '[`relationship.cascade`](relationship_api.html#sqlalchemy.orm.relationship.params.cascade
    "sqlalchemy.orm.relationship")的默认值为`save-update, merge`。此参数的典型替代设置为`all`或更常见的是`all,
    delete-orphan`。`all`符号是`save-update, merge, refresh-expire, expunge, delete`的同义词，与`delete-orphan`结合使用表示子对象应在所有情况下跟随其父对象，并且一旦不再与该父对象关联就应该被删除。'
- en: Warning
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: The `all` cascade option implies the [refresh-expire](#cascade-refresh-expire)
    cascade setting which may not be desirable when using the [Asynchronous I/O (asyncio)](extensions/asyncio.html)
    extension, as it will expire related objects more aggressively than is typically
    appropriate in an explicit IO context. See the notes at [Preventing Implicit IO
    when Using AsyncSession](extensions/asyncio.html#asyncio-orm-avoid-lazyloads)
    for further background.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '`all`级联选项意味着[refresh-expire](#cascade-refresh-expire)级联设置，当使用[异步I/O（asyncio）](extensions/asyncio.html)扩展时可能不可取，因为它将比在显式I/O上下文中通常适当地更积极地使相关对象过期。有关更多背景信息，请参阅[在使用AsyncSession时防止隐式I/O](extensions/asyncio.html#asyncio-orm-avoid-lazyloads)中的注释。'
- en: The list of available values which can be specified for the [`relationship.cascade`](relationship_api.html#sqlalchemy.orm.relationship.params.cascade
    "sqlalchemy.orm.relationship") parameter are described in the following subsections.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 可以为[`relationship.cascade`](relationship_api.html#sqlalchemy.orm.relationship.params.cascade
    "sqlalchemy.orm.relationship")参数指定的可用值列表在以下各小节中进行描述。
- en: '## save-update'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '## save-update'
- en: '`save-update` cascade indicates that when an object is placed into a [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") via [`Session.add()`](session_api.html#sqlalchemy.orm.Session.add
    "sqlalchemy.orm.Session.add"), all the objects associated with it via this [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") should also be added to that same [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"). Suppose we have an object `user1` with two related
    objects `address1`, `address2`:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`save-update`级联指示当通过[`Session.add()`](session_api.html#sqlalchemy.orm.Session.add
    "sqlalchemy.orm.Session.add")将对象放入[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")中时，通过这个[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")与之关联的所有对象也应该添加到同一个[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")中。假设我们有一个对象`user1`，其中包含两个相关对象`address1`、`address2`：'
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If we add `user1` to a [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), it will also add `address1`, `address2` implicitly:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将`user1`添加到[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")中，它也会隐式添加`address1`、`address2`：
- en: '[PRE3]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`save-update` cascade also affects attribute operations for objects that are
    already present in a [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session").
    If we add a third object, `address3` to the `user1.addresses` collection, it becomes
    part of the state of that [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"):'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`save-update`级联也会影响已经存在于[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")中的对象的属性操作。如果我们将第三个对象`address3`添加到`user1.addresses`集合中，它将成为该[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")的状态的一部分：'
- en: '[PRE4]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'A `save-update` cascade can exhibit surprising behavior when removing an item
    from a collection or de-associating an object from a scalar attribute. In some
    cases, the orphaned objects may still be pulled into the ex-parent’s [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"); this is so that the flush process may handle that related
    object appropriately. This case usually only arises if an object is removed from
    one [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    and added to another:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当从集合中移除一个项目或将对象从标量属性中解除关联时，`save-update`级联可能会表现出令人惊讶的行为。在某些情况下，被孤立的对象仍然可能被拉入原父级的[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")中；这是为了使刷新过程可以适当地处理相关对象。这种情况通常只会在一个对象从一个[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")中移除并添加到另一个对象时出现：
- en: '[PRE5]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `save-update` cascade is on by default, and is typically taken for granted;
    it simplifies code by allowing a single call to [`Session.add()`](session_api.html#sqlalchemy.orm.Session.add
    "sqlalchemy.orm.Session.add") to register an entire structure of objects within
    that [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    at once. While it can be disabled, there is usually not a need to do so.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`save-update`级联默认启用，并且通常被视为理所当然；它通过允许单个调用[`Session.add()`](session_api.html#sqlalchemy.orm.Session.add
    "sqlalchemy.orm.Session.add")一次性在该[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")中注册整个对象结构来简化代码。虽然它可以被禁用，但通常没有必要这样做。'
- en: '### Behavior of save-update cascade with bi-directional relationships'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '### 双向关系中save-update级联的行为'
- en: The `save-update` cascade takes place **uni-directionally** in the context of
    a bi-directional relationship, i.e. when using the [`relationship.back_populates`](relationship_api.html#sqlalchemy.orm.relationship.params.back_populates
    "sqlalchemy.orm.relationship") or [`relationship.backref`](relationship_api.html#sqlalchemy.orm.relationship.params.backref
    "sqlalchemy.orm.relationship") parameters to create two separate [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") objects which refer to each other.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在双向关系的上下文中，即使用[`relationship.back_populates`](relationship_api.html#sqlalchemy.orm.relationship.params.back_populates
    "sqlalchemy.orm.relationship")或[`relationship.backref`](relationship_api.html#sqlalchemy.orm.relationship.params.backref
    "sqlalchemy.orm.relationship")参数创建相互引用的两个独立的[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")对象时，`save-update`级联是**单向的**。
- en: An object that’s not associated with a [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), when assigned to an attribute or collection on a parent
    object that is associated with a [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), will be automatically added to that same [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"). However, the same operation in reverse will not have
    this effect; an object that’s not associated with a [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), upon which a child object that is associated with a
    [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    is assigned, will not result in an automatic addition of that parent object to
    the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session").
    The overall subject of this behavior is known as “cascade backrefs”, and represents
    a change in behavior that was standardized as of SQLAlchemy 2.0.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个未关联[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")的对象被赋给与关联[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")相关的父对象的属性或集合时，它将自动添加到同一[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")中。然而，反向操作不会产生此效果；当一个未关联[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")的对象被赋给与关联[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")相关的子对象时，不会自动将该父对象添加到[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")中。这种行为的总体主题称为“级联反向引用”，并代表了从SQLAlchemy 2.0开始标准化的行为变更。
- en: 'To illustrate, given a mapping of `Order` objects which relate bi-directionally
    to a series of `Item` objects via relationships `Order.items` and `Item.order`:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 以示例说明，假设给定了一个`Order`对象的映射，它与一系列`Item`对象通过关系`Order.items`和`Item.order`双向关联：
- en: '[PRE6]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If an `Order` is already associated with a [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), and an `Item` object is then created and appended to
    the `Order.items` collection of that `Order`, the `Item` will be automatically
    cascaded into that same [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session"):'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个`Order`已经与一个[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")相关联，并且然后创建一个`Item`对象并将其附加到该`Order`的`Order.items`集合中，`Item`将自动级联到相同的[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")中：
- en: '[PRE7]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Above, the bidirectional nature of `Order.items` and `Item.order` means that
    appending to `Order.items` also assigns to `Item.order`. At the same time, the
    `save-update` cascade allowed for the `Item` object to be added to the same [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") which the parent `Order` was already associated.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述情况下，`Order.items`和`Item.order`的双向性意味着附加到`Order.items`也会赋值给`Item.order`。同时，`save-update`级联允许将`Item`对象添加到与父`Order`已关联的相同[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")中。
- en: 'However, if the operation above is performed in the **reverse** direction,
    where `Item.order` is assigned rather than appending directly to `Order.item`,
    the cascade operation into the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") will **not** take place automatically, even though the
    object assignments `Order.items` and `Item.order` will be in the same state as
    in the previous example:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果上述操作以**反向**方向执行，即赋值`Item.order`而不是直接附加到`Order.item`，则级联操作不会自动进行，即使对象赋值`Order.items`和`Item.order`与上一个示例中的状态相同：
- en: '[PRE8]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In the above case, after the `Item` object is created and all the desired state
    is set upon it, it should then be added to the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") explicitly:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述情况下，`Item`对象创建并设置完所有期望的状态后，应明确将其添加到[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")中：
- en: '[PRE9]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In older versions of SQLAlchemy, the save-update cascade would occur bidirectionally
    in all cases. It was then made optional using an option known as `cascade_backrefs`.
    Finally, in SQLAlchemy 1.4 the old behavior was deprecated and the `cascade_backrefs`
    option was removed in SQLAlchemy 2.0. The rationale is that users generally do
    not find it intuitive that assigning to an attribute on an object, illustrated
    above as the assignment of `i1.order = o1`, would alter the persistence state
    of that object `i1` such that it’s now pending within a [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), and there would frequently be subsequent issues where
    autoflush would prematurely flush the object and cause errors, in those cases
    where the given object was still being constructed and wasn’t in a ready state
    to be flushed. The option to select between uni-directional and bi-directional
    behvaiors was also removed, as this option created two slightly different ways
    of working, adding to the overall learning curve of the ORM as well as to the
    documentation and user support burden.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在较旧版本的SQLAlchemy中，保存-更新级联在所有情况下都会双向发生。然后，使用一个称为`cascade_backrefs`的选项使其成为可选项。最后，在SQLAlchemy
    1.4中，旧行为被弃用，并且在SQLAlchemy 2.0中删除了`cascade_backrefs`选项。其理由是用户通常不会觉得将对象的属性分配给对象上的属性是直观的，如上面所示的`i1.order
    = o1`的分配，会改变对象`i1`的持久状态，使其现在在[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")中处于挂起状态，并且在那些给定对象仍在构建并且尚未准备好被刷新的情况下，自动刷新会过早地刷新对象并导致错误。选择在单向和双向行为之间选择的选项也被删除，因为此选项创建了两种略有不同的工作方式，增加了ORM的整体学习曲线以及文档和用户支持负担。
- en: See also
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[cascade_backrefs behavior deprecated for removal in 2.0](../changelog/migration_14.html#change-5150)
    - background on the change in behavior for “cascade backrefs”  ## delete'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '[在2.0中弃用以删除的cascade_backrefs行为](../changelog/migration_14.html#change-5150)
    - 关于“级联反向引用”行为变更的背景 ## 删除'
- en: 'The `delete` cascade indicates that when a “parent” object is marked for deletion,
    its related “child” objects should also be marked for deletion. If for example
    we have a relationship `User.addresses` with `delete` cascade configured:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`delete`级联表示当“父”对象标记为删除时，其相关的“子”对象也应标记为删除。例如，如果我们有一个关系`User.addresses`配置了`delete`级联：'
- en: '[PRE10]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If using the above mapping, we have a `User` object and two related `Address`
    objects:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用上述映射，我们有一个`User`对象和两个相关的`Address`对象：
- en: '[PRE11]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If we mark `user1` for deletion, after the flush operation proceeds, `address1`
    and `address2` will also be deleted:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们标记`user1`进行删除，在刷新操作进行后，`address1`和`address2`也将被删除：
- en: '[PRE12]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Alternatively, if our `User.addresses` relationship does *not* have `delete`
    cascade, SQLAlchemy’s default behavior is to instead de-associate `address1` and
    `address2` from `user1` by setting their foreign key reference to `NULL`. Using
    a mapping as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果我们的`User.addresses`关系*没有*`delete`级联，SQLAlchemy的默认行为是通过将它们的外键引用设置为`NULL`来解除`user1`与`address1`和`address2`的关联。使用以下映射：
- en: '[PRE13]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Upon deletion of a parent `User` object, the rows in `address` are not deleted,
    but are instead de-associated:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在删除父`User`对象时，`address`中的行不会被删除，而是被解除关联：
- en: '[PRE14]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[delete](#cascade-delete) cascade on one-to-many relationships is often combined
    with [delete-orphan](#cascade-delete-orphan) cascade, which will emit a DELETE
    for the related row if the “child” object is deassociated from the parent. The
    combination of `delete` and `delete-orphan` cascade covers both situations where
    SQLAlchemy has to decide between setting a foreign key column to NULL versus deleting
    the row entirely.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在一对多关系中，`delete`级联通常与`delete-orphan`级联结合使用，如果“子”对象与父对象解除关联，则会为相关行发出DELETE。`delete`和`delete-orphan`级联的组合涵盖了SQLAlchemy必须在将外键列设置为NULL与完全删除行之间做出决定的两种情况。
- en: The feature by default works completely independently of database-configured
    `FOREIGN KEY` constraints that may themselves configure `CASCADE` behavior. In
    order to integrate more efficiently with this configuration, additional directives
    described at [Using foreign key ON DELETE cascade with ORM relationships](#passive-deletes)
    should be used.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 该功能默认完全独立于数据库配置的`FOREIGN KEY`约束，这些约束本身可能配置`CASCADE`行为。为了更有效地与此配置集成，应使用描述在[使用ORM关系中的外键ON
    DELETE级联](#passive-deletes)的附加指令。
- en: Warning
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: Note that the ORM’s “delete” and “delete-orphan” behavior applies **only** to
    the use of the [`Session.delete()`](session_api.html#sqlalchemy.orm.Session.delete
    "sqlalchemy.orm.Session.delete") method to mark individual ORM instances for deletion
    within the [unit of work](../glossary.html#term-unit-of-work) process. It does
    **not** apply to “bulk” deletes, which would be emitted using the [`delete()`](../core/dml.html#sqlalchemy.sql.expression.delete
    "sqlalchemy.sql.expression.delete") construct as illustrated at [ORM UPDATE and
    DELETE with Custom WHERE Criteria](queryguide/dml.html#orm-queryguide-update-delete-where).
    See [Important Notes and Caveats for ORM-Enabled Update and Delete](queryguide/dml.html#orm-queryguide-update-delete-caveats)
    for additional background.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，ORM的“delete”和“delete-orphan”行为**仅**适用于使用[`Session.delete()`](session_api.html#sqlalchemy.orm.Session.delete
    "sqlalchemy.orm.Session.delete")方法在[unit of work](../glossary.html#term-unit-of-work)过程中标记单个ORM实例以进行删除。它**不**适用于“批量”删除，这将使用[`delete()`](../core/dml.html#sqlalchemy.sql.expression.delete
    "sqlalchemy.sql.expression.delete")构造发出，如在[ORM UPDATE and DELETE with Custom WHERE
    Criteria](queryguide/dml.html#orm-queryguide-update-delete-where)中所示。有关更多背景信息，请参阅[ORM启用的更新和删除的重要说明和警告](queryguide/dml.html#orm-queryguide-update-delete-caveats)。
- en: See also
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Using foreign key ON DELETE cascade with ORM relationships](#passive-deletes)'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用ORM关系的外键ON DELETE级联](#passive-deletes)'
- en: '[Using delete cascade with many-to-many relationships](#cascade-delete-many-to-many)'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用删除级联处理多对多关系](#cascade-delete-many-to-many)'
- en: '[delete-orphan](#cascade-delete-orphan)'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '[delete-orphan](#cascade-delete-orphan)'
- en: '### Using delete cascade with many-to-many relationships'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '### 使用删除级联处理多对多关系'
- en: The `cascade="all, delete"` option works equally well with a many-to-many relationship,
    one that uses [`relationship.secondary`](relationship_api.html#sqlalchemy.orm.relationship.params.secondary
    "sqlalchemy.orm.relationship") to indicate an association table. When a parent
    object is deleted, and therefore de-associated with its related objects, the unit
    of work process will normally delete rows from the association table, but leave
    the related objects intact. When combined with `cascade="all, delete"`, additional
    `DELETE` statements will take place for the child rows themselves.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`cascade="all, delete"`选项在多对多关系中同样有效，该关系使用[`relationship.secondary`](relationship_api.html#sqlalchemy.orm.relationship.params.secondary
    "sqlalchemy.orm.relationship")指示一个关联表。当删除父对象，因此与其相关对象解除关联时，工作单元过程通常会从关联表中删除行，但保留相关对象。与`cascade="all,
    delete"`结合使用时，将为子行本身执行额外的`DELETE`语句。'
- en: 'The following example adapts that of [Many To Many](basic_relationships.html#relationships-many-to-many)
    to illustrate the `cascade="all, delete"` setting on **one** side of the association:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例将[Many To Many](basic_relationships.html#relationships-many-to-many)的示例调整为说明关联的**一侧**设置为`cascade="all,
    delete"`：
- en: '[PRE15]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Above, when a `Parent` object is marked for deletion using [`Session.delete()`](session_api.html#sqlalchemy.orm.Session.delete
    "sqlalchemy.orm.Session.delete"), the flush process will as usual delete the associated
    rows from the `association` table, however per cascade rules it will also delete
    all related `Child` rows.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述情况下，当使用[`Session.delete()`](session_api.html#sqlalchemy.orm.Session.delete
    "sqlalchemy.orm.Session.delete")标记`Parent`对象进行删除时，刷新过程通常会从`association`表中删除相关行，但根据级联规则，它还将删除所有相关的`Child`行。
- en: Warning
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: If the above `cascade="all, delete"` setting were configured on **both** relationships,
    then the cascade action would continue cascading through all `Parent` and `Child`
    objects, loading each `children` and `parents` collection encountered and deleting
    everything that’s connected. It is typically not desirable for “delete” cascade
    to be configured bidirectionally.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果上述`cascade="all, delete"`设置在**两个**关系上都配置了，则级联操作将继续通过所有`Parent`和`Child`对象进行级联，加载遇到的每个`children`和`parents`集合并删除所有连接的内容。通常不希望“delete”级联双向配置。
- en: See also
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Deleting Rows from the Many to Many Table](basic_relationships.html#relationships-many-to-many-deletion)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '[从多对多表中删除行](basic_relationships.html#relationships-many-to-many-deletion)'
- en: '[Using foreign key ON DELETE with many-to-many relationships](#passive-deletes-many-to-many)  ###
    Using foreign key ON DELETE cascade with ORM relationships'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用外键ON DELETE处理多对多关系](#passive-deletes-many-to-many)  ### 使用ORM关系的外键ON DELETE级联处理'
- en: The behavior of SQLAlchemy’s “delete” cascade overlaps with the `ON DELETE`
    feature of a database `FOREIGN KEY` constraint. SQLAlchemy allows configuration
    of these schema-level [DDL](../glossary.html#term-DDL) behaviors using the [`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey") and [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") constructs; usage of these objects in
    conjunction with [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    metadata is described at [ON UPDATE and ON DELETE](../core/constraints.html#on-update-on-delete).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 的“delete”级联行为与数据库 `FOREIGN KEY` 约束的 `ON DELETE` 特性重叠。SQLAlchemy 允许使用
    [`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey "sqlalchemy.schema.ForeignKey")
    和 [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") 构造配置这些模式级 [DDL](../glossary.html#term-DDL)
    行为；如何在 [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    元数据与这些对象的使用一起配置，在 [ON UPDATE and ON DELETE](../core/constraints.html#on-update-on-delete)
    中有描述。
- en: In order to use `ON DELETE` foreign key cascades in conjunction with [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship"), it’s important to note first and foremost that
    the [`relationship.cascade`](relationship_api.html#sqlalchemy.orm.relationship.params.cascade
    "sqlalchemy.orm.relationship") setting must still be configured to match the desired
    “delete” or “set null” behavior (using `delete` cascade or leaving it omitted),
    so that whether the ORM or the database level constraints will handle the task
    of actually modifying the data in the database, the ORM will still be able to
    appropriately track the state of locally present objects that may be affected.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将 `ON DELETE` 外键级联与 [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") 结合使用，首先必须注意 [`relationship.cascade`](relationship_api.html#sqlalchemy.orm.relationship.params.cascade
    "sqlalchemy.orm.relationship") 设置仍然必须配置为匹配所需的“delete”或“set null”行为（使用 `delete`
    级联或将其省略），以便无论是 ORM 还是数据库级约束将处理实际修改数据库中的数据的任务，ORM 仍将能够适当跟踪可能受到影响的本地存在对象的状态。
- en: There is then an additional option on [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") which indicates the degree to which the ORM should
    try to run DELETE/UPDATE operations on related rows itself, vs. how much it should
    rely upon expecting the database-side FOREIGN KEY constraint cascade to handle
    the task; this is the [`relationship.passive_deletes`](relationship_api.html#sqlalchemy.orm.relationship.params.passive_deletes
    "sqlalchemy.orm.relationship") parameter and it accepts options `False` (the default),
    `True` and `"all"`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")
    上有一个额外的选项，指示 ORM 应该尝试自行运行与相关行的 DELETE/UPDATE 操作的程度，而不是依赖于期望数据库端的 FOREIGN KEY 约束级联处理任务；这是
    [`relationship.passive_deletes`](relationship_api.html#sqlalchemy.orm.relationship.params.passive_deletes
    "sqlalchemy.orm.relationship") 参数，它接受 `False`（默认值）、`True` 和 `"all"` 选项。
- en: 'The most typical example is that where child rows are to be deleted when parent
    rows are deleted, and that `ON DELETE CASCADE` is configured on the relevant `FOREIGN
    KEY` constraint as well:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 最典型的例子是当删除父行时要删除子行，并且在相关的 `FOREIGN KEY` 约束上配置了 `ON DELETE CASCADE`：
- en: '[PRE16]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The behavior of the above configuration when a parent row is deleted is as
    follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当删除父行时，上述配置的行为如下：
- en: The application calls `session.delete(my_parent)`, where `my_parent` is an instance
    of `Parent`.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序调用 `session.delete(my_parent)`，其中 `my_parent` 是 `Parent` 的一个实例。
- en: When the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    next flushes changes to the database, all of the **currently loaded** items within
    the `my_parent.children` collection are deleted by the ORM, meaning a `DELETE`
    statement is emitted for each record.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当 [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    下次将更改刷新到数据库时，`my_parent.children` 集合中的所有 **当前加载的** 项目都将由 ORM 删除，这意味着为每条记录发出一个
    `DELETE` 语句。
- en: If the `my_parent.children` collection is **unloaded**, then no `DELETE` statements
    are emitted. If the [`relationship.passive_deletes`](relationship_api.html#sqlalchemy.orm.relationship.params.passive_deletes
    "sqlalchemy.orm.relationship") flag were **not** set on this [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship"), then a `SELECT` statement for unloaded `Child`
    objects would have been emitted.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`my_parent.children`集合是**未加载**的，则不会发出`DELETE`语句。如果在此[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")上未设置[`relationship.passive_deletes`](relationship_api.html#sqlalchemy.orm.relationship.params.passive_deletes
    "sqlalchemy.orm.relationship")标志，则将为未加载的`Child`对象发出`SELECT`语句。
- en: A `DELETE` statement is then emitted for the `my_parent` row itself.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后会为`my_parent`行本身发出`DELETE`语句。
- en: The database-level `ON DELETE CASCADE` setting ensures that all rows in `child`
    which refer to the affected row in `parent` are also deleted.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据库级别的`ON DELETE CASCADE`设置确保将删除所有引用受影响的`parent`行的`child`中的行。
- en: The `Parent` instance referred to by `my_parent`, as well as all instances of
    `Child` that were related to this object and were **loaded** (i.e. step 2 above
    took place), are de-associated from the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session").
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由`my_parent`引用的`Parent`实例，以及所有与该对象相关联且已**加载**（即执行了步骤2）的`Child`实例，将从[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")中解除关联。
- en: Note
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'To use “ON DELETE CASCADE”, the underlying database engine must support `FOREIGN
    KEY` constraints and they must be enforcing:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用“ON DELETE CASCADE”，底层数据库引擎必须支持`FOREIGN KEY`约束，并且它们必须被强制执行：
- en: When using MySQL, an appropriate storage engine must be selected. See [CREATE
    TABLE arguments including Storage Engines](../dialects/mysql.html#mysql-storage-engines)
    for details.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在使用MySQL时，必须选择适当的存储引擎。有关详细信息，请参见[CREATE TABLE arguments including Storage Engines](../dialects/mysql.html#mysql-storage-engines)。
- en: 'When using SQLite, foreign key support must be enabled explicitly. See [Foreign
    Key Support](../dialects/sqlite.html#sqlite-foreign-keys) for details.  ### Using
    foreign key ON DELETE with many-to-many relationships'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在使用SQLite时，必须显式启用外键支持。有关详细信息，请参见[Foreign Key Support](../dialects/sqlite.html#sqlite-foreign-keys)。###
    使用外键 ON DELETE 处理多对多关系
- en: As described at [Using delete cascade with many-to-many relationships](#cascade-delete-many-to-many),
    “delete” cascade works for many-to-many relationships as well. To make use of
    `ON DELETE CASCADE` foreign keys in conjunction with many to many, `FOREIGN KEY`
    directives are configured on the association table. These directives can handle
    the task of automatically deleting from the association table, but cannot accommodate
    the automatic deletion of the related objects themselves.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在[使用级联删除处理多对多关系](#cascade-delete-many-to-many)中描述的那样，“删除”级联也适用于多对多关系。要利用`ON
    DELETE CASCADE`外键与多对多结合使用，需要在关联表上配置`FOREIGN KEY`指令。这些指令可以处理自动从关联表中删除，但不能自动删除相关对象本身。
- en: In this case, the [`relationship.passive_deletes`](relationship_api.html#sqlalchemy.orm.relationship.params.passive_deletes
    "sqlalchemy.orm.relationship") directive can save us some additional `SELECT`
    statements during a delete operation but there are still some collections that
    the ORM will continue to load, in order to locate affected child objects and handle
    them correctly.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，[`relationship.passive_deletes`](relationship_api.html#sqlalchemy.orm.relationship.params.passive_deletes
    "sqlalchemy.orm.relationship")指令可以在删除操作期间节省一些额外的`SELECT`语句，但仍然有一些集合，ORM将继续加载它们，以定位受影响的子对象并正确处理它们。
- en: Note
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Hypothetical optimizations to this could include a single `DELETE` statement
    against all parent-associated rows of the association table at once, then use
    `RETURNING` to locate affected related child rows, however this is not currently
    part of the ORM unit of work implementation.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 对此的假设优化可以包括一次针对关联表的所有父关联行的单个`DELETE`语句，然后使用`RETURNING`来定位受影响的相关子行，但是这目前不是ORM工作单元实现的一部分。
- en: 'In this configuration, we configure `ON DELETE CASCADE` on both foreign key
    constraints of the association table. We configure `cascade="all, delete"` on
    the parent->child side of the relationship, and we can then configure `passive_deletes=True`
    on the **other** side of the bidirectional relationship as illustrated below:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配置中，我们在关联表的两个外键约束上都配置了`ON DELETE CASCADE`。我们在父->子关系的一侧配置了`cascade="all, delete"`，然后我们可以在双向关系的**另一侧**上配置`passive_deletes=True`，如下所示：
- en: '[PRE17]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Using the above configuration, the deletion of a `Parent` object proceeds as
    follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上述配置，删除`Parent`对象的操作如下：
- en: A `Parent` object is marked for deletion using [`Session.delete()`](session_api.html#sqlalchemy.orm.Session.delete
    "sqlalchemy.orm.Session.delete").
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用[`Session.delete()`](session_api.html#sqlalchemy.orm.Session.delete "sqlalchemy.orm.Session.delete")标记要删除的`Parent`对象。
- en: When the flush occurs, if the `Parent.children` collection is not loaded, the
    ORM will first emit a SELECT statement in order to load the `Child` objects that
    correspond to `Parent.children`.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当发生刷新时，如果未加载`Parent.children`集合，则ORM将首先发出SELECT语句，以加载与`Parent.children`对应的`Child`对象。
- en: It will then then emit `DELETE` statements for the rows in `association` which
    correspond to that parent row.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将发出针对与该父行对应的`association`中的行的`DELETE`语句。
- en: for each `Child` object affected by this immediate deletion, because `passive_deletes=True`
    is configured, the unit of work will not need to try to emit SELECT statements
    for each `Child.parents` collection as it is assumed the corresponding rows in
    `association` will be deleted.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个受此立即删除影响的`Child`对象，由于配置了`passive_deletes=True`，工作单元将不需要尝试为每个`Child.parents`集合发出SELECT语句，因为假定将删除`association`中的相应行。
- en: '`DELETE` statements are then emitted for each `Child` object that was loaded
    from `Parent.children`.  ## delete-orphan'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '对于从`Parent.children`加载的每个`Child`对象，都会发出`DELETE`语句。  ## delete-orphan'
- en: '`delete-orphan` cascade adds behavior to the `delete` cascade, such that a
    child object will be marked for deletion when it is de-associated from the parent,
    not just when the parent is marked for deletion. This is a common feature when
    dealing with a related object that is “owned” by its parent, with a NOT NULL foreign
    key, so that removal of the item from the parent collection results in its deletion.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`delete-orphan`级联会为`delete`级联添加行为，这样当子对象与父对象取消关联时，子对象将被标记为删除，而不仅仅是在父对象被标记为删除时。当处理一个与父对象“拥有”关系的相关对象时，这是一种常见的特性，该关系具有NOT
    NULL外键，因此从父集合中删除项目会导致其被删除。'
- en: '`delete-orphan` cascade implies that each child object can only have one parent
    at a time, and in the **vast majority of cases is configured only on a one-to-many
    relationship.** For the much less common case of setting it on a many-to-one or
    many-to-many relationship, the “many” side can be forced to allow only a single
    object at a time by configuring the [`relationship.single_parent`](relationship_api.html#sqlalchemy.orm.relationship.params.single_parent
    "sqlalchemy.orm.relationship") argument, which establishes Python-side validation
    that ensures the object is associated with only one parent at a time, however
    this greatly limits the functionality of the “many” relationship and is usually
    not what’s desired.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`delete-orphan`级联意味着每个子对象一次只能有一个父对象，并且在绝大多数情况下，它只配置在一对多关系上。对于设置在多对一或多对多关系上的非常罕见的情况，可以通过配置[`relationship.single_parent`](relationship_api.html#sqlalchemy.orm.relationship.params.single_parent
    "sqlalchemy.orm.relationship")参数来强制“多”端一次只允许一个对象，该参数建立了Python端验证，确保对象一次只与一个父对象关联，但这大大限制了“多”关系的功能，通常不是所需的。'
- en: See also
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[For relationship <relationship>, delete-orphan cascade is normally configured
    only on the “one” side of a one-to-many relationship, and not on the “many” side
    of a many-to-one or many-to-many relationship.](../errors.html#error-bbf0) - background
    on a common error scenario involving delete-orphan cascade.  ## merge'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '[对于关系<relationship>，delete-orphan级联通常仅配置在一对多关系的“一”端，而不是多对一或多对多关系的“多”端。](../errors.html#error-bbf0)
    - 关于涉及delete-orphan级联的常见错误场景的背景。  ## merge'
- en: '`merge` cascade indicates that the [`Session.merge()`](session_api.html#sqlalchemy.orm.Session.merge
    "sqlalchemy.orm.Session.merge") operation should be propagated from a parent that’s
    the subject of the [`Session.merge()`](session_api.html#sqlalchemy.orm.Session.merge
    "sqlalchemy.orm.Session.merge") call down to referred objects. This cascade is
    also on by default.  ## refresh-expire'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`merge`级联表示应该从`Session.merge()`操作从调用`Session.merge()`的主体父对象向下传播到引用的对象。这个级联也是默认开启的。  ##
    refresh-expire'
- en: '`refresh-expire` is an uncommon option, indicating that the [`Session.expire()`](session_api.html#sqlalchemy.orm.Session.expire
    "sqlalchemy.orm.Session.expire") operation should be propagated from a parent
    down to referred objects. When using [`Session.refresh()`](session_api.html#sqlalchemy.orm.Session.refresh
    "sqlalchemy.orm.Session.refresh"), the referred objects are expired only, but
    not actually refreshed.  ## expunge'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`refresh-expire` 是一个不常见的选项，表示[`Session.refresh()`](session_api.html#sqlalchemy.orm.Session.refresh
    "sqlalchemy.orm.Session.refresh")操作应该从父对象传播到引用的对象。当使用[`Session.refresh()`](session_api.html#sqlalchemy.orm.Session.refresh
    "sqlalchemy.orm.Session.refresh")时，引用的对象仅被过期，而不会实际刷新。## expunge'
- en: '`expunge` cascade indicates that when the parent object is removed from the
    [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    using [`Session.expunge()`](session_api.html#sqlalchemy.orm.Session.expunge "sqlalchemy.orm.Session.expunge"),
    the operation should be propagated down to referred objects.  ## Notes on Delete
    - Deleting Objects Referenced from Collections and Scalar Relationships'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`expunge` 级联表示当使用[`Session.expunge()`](session_api.html#sqlalchemy.orm.Session.expunge
    "sqlalchemy.orm.Session.expunge")从[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")中移除父对象时，操作应该向下传播到引用的对象。## 删除说明 - 删除从集合和标量关系引用的对象'
- en: The ORM in general never modifies the contents of a collection or scalar relationship
    during the flush process. This means, if your class has a [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") that refers to a collection of objects, or a reference
    to a single object such as many-to-one, the contents of this attribute will not
    be modified when the flush process occurs. Instead, it is expected that the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") would eventually be expired, either through the expire-on-commit
    behavior of [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") or through explicit use of [`Session.expire()`](session_api.html#sqlalchemy.orm.Session.expire
    "sqlalchemy.orm.Session.expire"). At that point, any referenced object or collection
    associated with that [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    will be cleared and will re-load itself upon next access.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，ORM 在刷新过程中不会修改集合或标量关系的内容。这意味着，如果你的类有一个指向对象集合的[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")，或者一个指向单个对象的引用，比如一对多关系，那么当刷新过程发生时，这个属性的内容不会被修改。相反，预期的是[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")最终会过期，要么通过[`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit")的提交时过期行为，要么通过显式使用[`Session.expire()`](session_api.html#sqlalchemy.orm.Session.expire
    "sqlalchemy.orm.Session.expire")。在那时，与该[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")关联的任何引用对象或集合将被清除，并且在下次访问时将重新加载自己。
- en: A common confusion that arises regarding this behavior involves the use of the
    [`Session.delete()`](session_api.html#sqlalchemy.orm.Session.delete "sqlalchemy.orm.Session.delete")
    method. When [`Session.delete()`](session_api.html#sqlalchemy.orm.Session.delete
    "sqlalchemy.orm.Session.delete") is invoked upon an object and the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is flushed, the row is deleted from the database. Rows
    that refer to the target row via foreign key, assuming they are tracked using
    a [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")
    between the two mapped object types, will also see their foreign key attributes
    UPDATED to null, or if delete cascade is set up, the related rows will be deleted
    as well. However, even though rows related to the deleted object might be themselves
    modified as well, **no changes occur to relationship-bound collections or object
    references on the objects** involved in the operation within the scope of the
    flush itself. This means if the object was a member of a related collection, it
    will still be present on the Python side until that collection is expired. Similarly,
    if the object were referenced via many-to-one or one-to-one from another object,
    that reference will remain present on that object until the object is expired
    as well.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 关于此行为常见的混淆涉及 [`Session.delete()`](session_api.html#sqlalchemy.orm.Session.delete
    "sqlalchemy.orm.Session.delete") 方法的使用。当调用 [`Session.delete()`](session_api.html#sqlalchemy.orm.Session.delete
    "sqlalchemy.orm.Session.delete") 删除一个对象并且刷新了 [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 时，该行将从数据库中删除。通过外键引用目标行的行，假设它们使用两个映射对象类型之间的 [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") 跟踪，还将看到它们的外键属性被更新为 null，或者如果设置了级联删除，则相关行也将被删除。然而，即使与被删除对象相关的行可能也被修改，**在刷新本身的范围内，涉及操作的关系绑定集合或对象引用上不会发生任何更改**。这意味着如果对象是相关集合的成员，则在
    Python 端它仍然存在，直到该集合过期。同样，如果对象通过多对一或一对一从另一个对象引用，那个引用也将保留在该对象上，直到该对象也过期。
- en: 'Below, we illustrate that after an `Address` object is marked for deletion,
    it’s still present in the collection associated with the parent `User`, even after
    a flush:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的例子中，我们可以看到，即使将一个 `Address` 对象标记为删除，在刷新后，它仍然存在于与父 `User` 关联的集合中：
- en: '[PRE18]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'When the above session is committed, all attributes are expired. The next access
    of `user.addresses` will re-load the collection, revealing the desired state:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当上述会话提交时，所有属性都将过期。下一次访问 `user.addresses` 将重新加载集合，显示所需的状态：
- en: '[PRE19]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'There is a recipe for intercepting [`Session.delete()`](session_api.html#sqlalchemy.orm.Session.delete
    "sqlalchemy.orm.Session.delete") and invoking this expiration automatically; see
    [ExpireRelationshipOnFKChange](https://www.sqlalchemy.org/trac/wiki/UsageRecipes/ExpireRelationshipOnFKChange)
    for this. However, the usual practice of deleting items within collections is
    to forego the usage of [`Session.delete()`](session_api.html#sqlalchemy.orm.Session.delete
    "sqlalchemy.orm.Session.delete") directly, and instead use cascade behavior to
    automatically invoke the deletion as a result of removing the object from the
    parent collection. The `delete-orphan` cascade accomplishes this, as illustrated
    in the example below:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 拦截 [`Session.delete()`](session_api.html#sqlalchemy.orm.Session.delete "sqlalchemy.orm.Session.delete")
    并自动调用其过期的方法有一种方法；请参阅 [ExpireRelationshipOnFKChange](https://www.sqlalchemy.org/trac/wiki/UsageRecipes/ExpireRelationshipOnFKChange)
    查看详情。然而，通常的做法是在集合内删除项目时直接放弃使用 [`Session.delete()`](session_api.html#sqlalchemy.orm.Session.delete
    "sqlalchemy.orm.Session.delete")，而是使用级联行为自动调用删除操作，因为将对象从父集合中删除的结果。`delete-orphan`
    级联可以实现这一点，如下例所示：
- en: '[PRE20]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Where above, upon removing the `Address` object from the `User.addresses` collection,
    the `delete-orphan` cascade has the effect of marking the `Address` object for
    deletion in the same way as passing it to [`Session.delete()`](session_api.html#sqlalchemy.orm.Session.delete
    "sqlalchemy.orm.Session.delete").
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的情况中，从 `User.addresses` 集合中移除 `Address` 对象后，`delete-orphan` 级联的效果与将其传递给 [`Session.delete()`](session_api.html#sqlalchemy.orm.Session.delete
    "sqlalchemy.orm.Session.delete") 相同，标记了 `Address` 对象以删除。
- en: 'The `delete-orphan` cascade can also be applied to a many-to-one or one-to-one
    relationship, so that when an object is de-associated from its parent, it is also
    automatically marked for deletion. Using `delete-orphan` cascade on a many-to-one
    or one-to-one requires an additional flag [`relationship.single_parent`](relationship_api.html#sqlalchemy.orm.relationship.params.single_parent
    "sqlalchemy.orm.relationship") which invokes an assertion that this related object
    is not to shared with any other parent simultaneously:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`delete-orphan` 级联也可以应用于多对一或一对一关系，这样当一个对象从其父对象中取消关联时，它也会自动标记为删除。在多对一或一对一关系上使用`delete-orphan`级联需要额外的标志[`relationship.single_parent`](relationship_api.html#sqlalchemy.orm.relationship.params.single_parent
    "sqlalchemy.orm.relationship")，该标志会触发一个断言，即此相关对象不应同时与任何其他父对象共享：'
- en: '[PRE21]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Above, if a hypothetical `Preference` object is removed from a `User`, it will
    be deleted on flush:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果上面的情况下，一个假设的`Preference`对象从一个`User`中移除，它将在 flush 时被删除：
- en: '[PRE22]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: See also
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Cascades](#unitofwork-cascades) for detail on cascades.  ## save-update'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 有关级联的详细信息，请参阅[Cascades](#unitofwork-cascades)。## save-update
- en: '`save-update` cascade indicates that when an object is placed into a [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") via [`Session.add()`](session_api.html#sqlalchemy.orm.Session.add
    "sqlalchemy.orm.Session.add"), all the objects associated with it via this [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") should also be added to that same [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"). Suppose we have an object `user1` with two related
    objects `address1`, `address2`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`save-update` 级联表示当通过[`Session.add()`](session_api.html#sqlalchemy.orm.Session.add
    "sqlalchemy.orm.Session.add")将对象放入[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")时，通过此[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")与之关联的所有对象也应该被添加到同一个[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")中。假设我们有一个对象`user1`，它有两个相关对象`address1`、`address2`：'
- en: '[PRE23]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If we add `user1` to a [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), it will also add `address1`, `address2` implicitly:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将`user1`添加到[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")中，它也会隐式添加`address1`、`address2`：
- en: '[PRE24]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '`save-update` cascade also affects attribute operations for objects that are
    already present in a [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session").
    If we add a third object, `address3` to the `user1.addresses` collection, it becomes
    part of the state of that [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"):'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`save-update` 级联也会影响已经存在于[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")中的对象的属性操作。如果我们向`user1.addresses`集合添加第三个对象`address3`，它将成为该[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")的状态的一部分：'
- en: '[PRE25]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'A `save-update` cascade can exhibit surprising behavior when removing an item
    from a collection or de-associating an object from a scalar attribute. In some
    cases, the orphaned objects may still be pulled into the ex-parent’s [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"); this is so that the flush process may handle that related
    object appropriately. This case usually only arises if an object is removed from
    one [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    and added to another:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当从集合中删除项目或将对象与标量属性取消关联时，`save-update` 级联可能会表现出令人惊讶的行为。在某些情况下，被孤立的对象仍然可能被拉入原父对象的[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")；这是为了 flush 进程能够适当处理该相关对象。这种情况通常只会在对象从一个[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")中移除并添加到另一个[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")时出现：
- en: '[PRE26]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `save-update` cascade is on by default, and is typically taken for granted;
    it simplifies code by allowing a single call to [`Session.add()`](session_api.html#sqlalchemy.orm.Session.add
    "sqlalchemy.orm.Session.add") to register an entire structure of objects within
    that [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    at once. While it can be disabled, there is usually not a need to do so.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`save-update` 级联默认启用，并且通常被视为理所当然；它通过允许对那个[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")一次注册整个对象结构的单个调用来简化代码。虽然它可以被禁用，但通常没有必要这样做。'
- en: '### Behavior of save-update cascade with bi-directional relationships'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '### 具有双向关系的 save-update 级联的行为'
- en: The `save-update` cascade takes place **uni-directionally** in the context of
    a bi-directional relationship, i.e. when using the [`relationship.back_populates`](relationship_api.html#sqlalchemy.orm.relationship.params.back_populates
    "sqlalchemy.orm.relationship") or [`relationship.backref`](relationship_api.html#sqlalchemy.orm.relationship.params.backref
    "sqlalchemy.orm.relationship") parameters to create two separate [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") objects which refer to each other.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`save-update`级联在双向关系的情况下**单向**发生，即当使用[`relationship.back_populates`](relationship_api.html#sqlalchemy.orm.relationship.params.back_populates
    "sqlalchemy.orm.relationship")或[`relationship.backref`](relationship_api.html#sqlalchemy.orm.relationship.params.backref
    "sqlalchemy.orm.relationship")参数创建两个相互引用的[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")对象时。'
- en: An object that’s not associated with a [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), when assigned to an attribute or collection on a parent
    object that is associated with a [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), will be automatically added to that same [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"). However, the same operation in reverse will not have
    this effect; an object that’s not associated with a [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), upon which a child object that is associated with a
    [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    is assigned, will not result in an automatic addition of that parent object to
    the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session").
    The overall subject of this behavior is known as “cascade backrefs”, and represents
    a change in behavior that was standardized as of SQLAlchemy 2.0.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当将一个未与[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")关联的对象分配给与[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")关联的父对象的属性或集合时，该对象将自动添加到同一个[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")中。然而，反向操作不会产生这种效果；当分配一个未与[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")关联的对象时，分配给一个与[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")关联的子对象，不会自动将父对象添加到[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")中。这种行为的总体主题被称为“级联反向引用”，代表了作为SQLAlchemy 2.0的标准化行为的变化。
- en: 'To illustrate, given a mapping of `Order` objects which relate bi-directionally
    to a series of `Item` objects via relationships `Order.items` and `Item.order`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明，假设有一系列通过关系`Order.items`和`Item.order`与`Item`对象双向关联的`Order`对象的映射：
- en: '[PRE27]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If an `Order` is already associated with a [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), and an `Item` object is then created and appended to
    the `Order.items` collection of that `Order`, the `Item` will be automatically
    cascaded into that same [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session"):'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`Order`已经与一个[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")关联，并且然后创建一个`Item`对象并附加到该`Order`的`Order.items`集合中，`Item`将自动级联到相同的[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")中：
- en: '[PRE28]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Above, the bidirectional nature of `Order.items` and `Item.order` means that
    appending to `Order.items` also assigns to `Item.order`. At the same time, the
    `save-update` cascade allowed for the `Item` object to be added to the same [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") which the parent `Order` was already associated.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，`Order.items`和`Item.order`的双向性意味着附加到`Order.items`也会赋值给`Item.order`。同时，`save-update`级联允许将`Item`对象添加到与父`Order`已关联的同一个[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")中。
- en: 'However, if the operation above is performed in the **reverse** direction,
    where `Item.order` is assigned rather than appending directly to `Order.item`,
    the cascade operation into the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") will **not** take place automatically, even though the
    object assignments `Order.items` and `Item.order` will be in the same state as
    in the previous example:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果上述操作在**反向**方向进行，即将`Item.order`赋值而不是直接附加到`Order.item`，则级联操作不会自动进行到[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")中，即使对象赋值`Order.items`和`Item.order`的状态与前面的示例相同：
- en: '[PRE29]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In the above case, after the `Item` object is created and all the desired state
    is set upon it, it should then be added to the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") explicitly:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述情况下，在创建`Item`对象并设置所有所需状态之后，应明确将其添加到[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")中：
- en: '[PRE30]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In older versions of SQLAlchemy, the save-update cascade would occur bidirectionally
    in all cases. It was then made optional using an option known as `cascade_backrefs`.
    Finally, in SQLAlchemy 1.4 the old behavior was deprecated and the `cascade_backrefs`
    option was removed in SQLAlchemy 2.0. The rationale is that users generally do
    not find it intuitive that assigning to an attribute on an object, illustrated
    above as the assignment of `i1.order = o1`, would alter the persistence state
    of that object `i1` such that it’s now pending within a [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), and there would frequently be subsequent issues where
    autoflush would prematurely flush the object and cause errors, in those cases
    where the given object was still being constructed and wasn’t in a ready state
    to be flushed. The option to select between uni-directional and bi-directional
    behvaiors was also removed, as this option created two slightly different ways
    of working, adding to the overall learning curve of the ORM as well as to the
    documentation and user support burden.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在旧版本的SQLAlchemy中，保存-更新级 learning method 会在所有情况下双向发生。然后，通过一个名为`cascade_backrefs`的选项将其变为可选。最后，在SQLAlchemy
    1.4中，旧行为被弃用，并且在SQLAlchemy 2.0中删除了`cascade_backrefs`选项。其理由是，用户通常不会觉得在对象的属性上赋值（如上面所示的`i1.order
    = o1`的赋值）会改变该对象`i1`的持久化状态，使其现在处于[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")中处于挂起状态，并且经常会出现自动刷新会过早刷新对象并导致错误的情况，在这些情况下，给定对象仍在构建中且尚未处于准备好刷新的状态状态。选择单向和双向行为之间的选项也被删除，因为此选项创建了两种略有不同的工作方式，增加了ORM的整体学习曲线以及文档和用户支持负担。
- en: See also
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[cascade_backrefs behavior deprecated for removal in 2.0](../changelog/migration_14.html#change-5150)
    - background on the change in behavior for “cascade backrefs”  ### Behavior of
    save-update cascade with bi-directional relationships'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '[在2.0中弃用了cascade_backrefs行为](../changelog/migration_14.html#change-5150) -
    关于“级联 backrefs”行为变更的背景 ### 双向关系中保存-更新级联的行为'
- en: The `save-update` cascade takes place **uni-directionally** in the context of
    a bi-directional relationship, i.e. when using the [`relationship.back_populates`](relationship_api.html#sqlalchemy.orm.relationship.params.back_populates
    "sqlalchemy.orm.relationship") or [`relationship.backref`](relationship_api.html#sqlalchemy.orm.relationship.params.backref
    "sqlalchemy.orm.relationship") parameters to create two separate [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") objects which refer to each other.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`save-update`级联在双向关系的上下文中**单向**发生，即在使用[`relationship.back_populates`](relationship_api.html#sqlalchemy.orm.relationship.params.back_populates
    "sqlalchemy.orm.relationship")或[`relationship.backref`](relationship_api.html#sqlalchemy.orm.relationship.params.backref
    "sqlalchemy.orm.relationship")参数创建相互引用的两个单独的[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")对象时。'
- en: An object that’s not associated with a [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), when assigned to an attribute or collection on a parent
    object that is associated with a [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), will be automatically added to that same [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"). However, the same operation in reverse will not have
    this effect; an object that’s not associated with a [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), upon which a child object that is associated with a
    [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    is assigned, will not result in an automatic addition of that parent object to
    the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session").
    The overall subject of this behavior is known as “cascade backrefs”, and represents
    a change in behavior that was standardized as of SQLAlchemy 2.0.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 一个未与[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")相关联的对象，当分配给与[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")相关联的父对象的属性或集合时，将自动添加到相同的[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")中。但是，相反的操作不会产生这种效果；一个未与[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")相关联的对象，其中一个与[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")相关联的子对象被分配，将不会自动将该父对象添加到[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")中。此行为的整体主题称为“级联反向引用”，并代表了作为SQLAlchemy 2.0的标准化行为的变化。
- en: 'To illustrate, given a mapping of `Order` objects which relate bi-directionally
    to a series of `Item` objects via relationships `Order.items` and `Item.order`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明，假设有一系列通过关系`Order.items`和`Item.order`与`Item`对象双向关联的`Order`对象的映射：
- en: '[PRE31]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'If an `Order` is already associated with a [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), and an `Item` object is then created and appended to
    the `Order.items` collection of that `Order`, the `Item` will be automatically
    cascaded into that same [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session"):'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`Order`已与[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")相关联，并且然后创建`Item`对象并将其附加到该`Order`的`Order.items`集合中，那么`Item`将自动级联到相同的[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")中：
- en: '[PRE32]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Above, the bidirectional nature of `Order.items` and `Item.order` means that
    appending to `Order.items` also assigns to `Item.order`. At the same time, the
    `save-update` cascade allowed for the `Item` object to be added to the same [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") which the parent `Order` was already associated.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 上述案例中，`Order.items`和`Item.order`的双向性意味着附加到`Order.items`也会赋值给`Item.order`。同时，“save-update”级联允许将`Item`对象添加到与父`Order`已关联的相同[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")中。
- en: 'However, if the operation above is performed in the **reverse** direction,
    where `Item.order` is assigned rather than appending directly to `Order.item`,
    the cascade operation into the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") will **not** take place automatically, even though the
    object assignments `Order.items` and `Item.order` will be in the same state as
    in the previous example:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果上述操作是以**相反**方向执行的，即将`Item.order`赋值而不是直接附加到`Order.item`，则即使对象分配`Order.items`和`Item.order`的状态与前面的示例相同，也不会自动进入到[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")的级联操作中：
- en: '[PRE33]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In the above case, after the `Item` object is created and all the desired state
    is set upon it, it should then be added to the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") explicitly:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述情况下，在创建`Item`对象并设置所有所需状态之后，应明确将其添加到[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")中：
- en: '[PRE34]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In older versions of SQLAlchemy, the save-update cascade would occur bidirectionally
    in all cases. It was then made optional using an option known as `cascade_backrefs`.
    Finally, in SQLAlchemy 1.4 the old behavior was deprecated and the `cascade_backrefs`
    option was removed in SQLAlchemy 2.0. The rationale is that users generally do
    not find it intuitive that assigning to an attribute on an object, illustrated
    above as the assignment of `i1.order = o1`, would alter the persistence state
    of that object `i1` such that it’s now pending within a [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), and there would frequently be subsequent issues where
    autoflush would prematurely flush the object and cause errors, in those cases
    where the given object was still being constructed and wasn’t in a ready state
    to be flushed. The option to select between uni-directional and bi-directional
    behvaiors was also removed, as this option created two slightly different ways
    of working, adding to the overall learning curve of the ORM as well as to the
    documentation and user support burden.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在较旧版本的SQLAlchemy中，保存-更新级联在所有情况下都会双向发生。然后，使用称为`cascade_backrefs`的选项将其变为可选。最后，在SQLAlchemy
    1.4中，旧行为被弃用，并且在SQLAlchemy 2.0中删除了`cascade_backrefs`选项。其理由是用户通常不会觉得将对象的属性分配给对象上的属性是直观的，如上面所示的`i1.order
    = o1`的赋值会改变对象`i1`的持久化状态，使其现在处于[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")中处于挂起状态，并且在那些给定对象仍在构建并且尚未准备好被刷新的情况下，会经常出现自动刷新会过早刷新对象并导致错误的情况。选择单向和双向行为之间的选项也被删除，因为此选项创建了两种略有不同的工作方式，增加了ORM的整体学习曲线以及文档和用户支持负担。
- en: See also
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[cascade_backrefs behavior deprecated for removal in 2.0](../changelog/migration_14.html#change-5150)
    - background on the change in behavior for “cascade backrefs”'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '[2.0中将删除的cascade_backrefs行为已弃用](../changelog/migration_14.html#change-5150)
    - 关于“级联反向引用”行为变更的背景信息'
- en: '## delete'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '## 删除'
- en: 'The `delete` cascade indicates that when a “parent” object is marked for deletion,
    its related “child” objects should also be marked for deletion. If for example
    we have a relationship `User.addresses` with `delete` cascade configured:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '`删除`级联表示当“父”对象标记为删除时，其相关的“子”对象也应标记为删除。例如，如果我们有一个配置了`删除`级联的关系`User.addresses`：'
- en: '[PRE35]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'If using the above mapping, we have a `User` object and two related `Address`
    objects:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用上述映射，我们有一个`User`对象和两个相关的`Address`对象：
- en: '[PRE36]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'If we mark `user1` for deletion, after the flush operation proceeds, `address1`
    and `address2` will also be deleted:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们标记`user1`进行删除，在刷新操作进行后，`address1`和`address2`也将被删除：
- en: '[PRE37]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Alternatively, if our `User.addresses` relationship does *not* have `delete`
    cascade, SQLAlchemy’s default behavior is to instead de-associate `address1` and
    `address2` from `user1` by setting their foreign key reference to `NULL`. Using
    a mapping as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果我们的`User.addresses`关系*没有*`删除`级联，SQLAlchemy的默认行为是通过将它们的外键引用设置为`NULL`来解除`user1`与`address1`和`address2`的关联。使用以下映射：
- en: '[PRE38]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Upon deletion of a parent `User` object, the rows in `address` are not deleted,
    but are instead de-associated:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在删除父`User`对象时，`address`中的行不会被删除，而是被解除关联：
- en: '[PRE39]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[delete](#cascade-delete) cascade on one-to-many relationships is often combined
    with [delete-orphan](#cascade-delete-orphan) cascade, which will emit a DELETE
    for the related row if the “child” object is deassociated from the parent. The
    combination of `delete` and `delete-orphan` cascade covers both situations where
    SQLAlchemy has to decide between setting a foreign key column to NULL versus deleting
    the row entirely.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '[删除](#cascade-delete) 在一对多关系上的级联通常与[删除孤儿](#cascade-delete-orphan)级联结合使用，如果“子”对象与父对象解除关联，则会发出与相关行相关的DELETE操作。`删除`和`删除孤儿`级联的组合涵盖了SQLAlchemy需要在将外键列设置为NULL与完全删除行之间做出决定的情况。'
- en: The feature by default works completely independently of database-configured
    `FOREIGN KEY` constraints that may themselves configure `CASCADE` behavior. In
    order to integrate more efficiently with this configuration, additional directives
    described at [Using foreign key ON DELETE cascade with ORM relationships](#passive-deletes)
    should be used.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，该功能完全独立于数据库配置的可能配置`CASCADE`行为的`FOREIGN KEY`约束。为了更有效地与此配置集成，应使用在[使用ORM关系的外键ON
    DELETE级联](#passive-deletes)中描述的附加指令。
- en: Warning
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: Note that the ORM’s “delete” and “delete-orphan” behavior applies **only** to
    the use of the [`Session.delete()`](session_api.html#sqlalchemy.orm.Session.delete
    "sqlalchemy.orm.Session.delete") method to mark individual ORM instances for deletion
    within the [unit of work](../glossary.html#term-unit-of-work) process. It does
    **not** apply to “bulk” deletes, which would be emitted using the [`delete()`](../core/dml.html#sqlalchemy.sql.expression.delete
    "sqlalchemy.sql.expression.delete") construct as illustrated at [ORM UPDATE and
    DELETE with Custom WHERE Criteria](queryguide/dml.html#orm-queryguide-update-delete-where).
    See [Important Notes and Caveats for ORM-Enabled Update and Delete](queryguide/dml.html#orm-queryguide-update-delete-caveats)
    for additional background.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，ORM的“删除”和“删除孤立对象”行为仅适用于使用[`Session.delete()`](session_api.html#sqlalchemy.orm.Session.delete
    "sqlalchemy.orm.Session.delete")方法在[工作单元](../glossary.html#term-unit-of-work)过程中标记个别ORM实例进行删除。它不适用于“批量”删除，这将使用[`delete()`](../core/dml.html#sqlalchemy.sql.expression.delete
    "sqlalchemy.sql.expression.delete")构造来发出，如[ORM UPDATE and DELETE with Custom WHERE
    Criteria](queryguide/dml.html#orm-queryguide-update-delete-where)中所示。有关更多背景信息，请参见[ORM-启用的更新和删除的重要说明和注意事项](queryguide/dml.html#orm-queryguide-update-delete-caveats)。
- en: See also
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 另见
- en: '[Using foreign key ON DELETE cascade with ORM relationships](#passive-deletes)'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用 ORM 关系的外键 ON DELETE 级联](#passive-deletes)'
- en: '[Using delete cascade with many-to-many relationships](#cascade-delete-many-to-many)'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用多对多关系的级联删除](#cascade-delete-many-to-many)'
- en: '[delete-orphan](#cascade-delete-orphan)'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '[delete-orphan](#cascade-delete-orphan)'
- en: '### Using delete cascade with many-to-many relationships'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '### 使用多对多关系的级联删除'
- en: The `cascade="all, delete"` option works equally well with a many-to-many relationship,
    one that uses [`relationship.secondary`](relationship_api.html#sqlalchemy.orm.relationship.params.secondary
    "sqlalchemy.orm.relationship") to indicate an association table. When a parent
    object is deleted, and therefore de-associated with its related objects, the unit
    of work process will normally delete rows from the association table, but leave
    the related objects intact. When combined with `cascade="all, delete"`, additional
    `DELETE` statements will take place for the child rows themselves.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`cascade="all, delete"`选项与多对多关系同样适用，这种关系使用[`relationship.secondary`](relationship_api.html#sqlalchemy.orm.relationship.params.secondary
    "sqlalchemy.orm.relationship")来指示一个关联表。当删除父对象时，因此取消与其相关的对象的关联时，工作单元过程通常会从关联表中删除行，但会保留相关的对象。当与`cascade="all,
    delete"`组合时，额外的`DELETE`语句将对子行本身进行操作。'
- en: 'The following example adapts that of [Many To Many](basic_relationships.html#relationships-many-to-many)
    to illustrate the `cascade="all, delete"` setting on **one** side of the association:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的示例调整了[多对多](basic_relationships.html#relationships-many-to-many)的例子，以说明关联的**一**端上的`cascade="all,
    delete"`设置：
- en: '[PRE40]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Above, when a `Parent` object is marked for deletion using [`Session.delete()`](session_api.html#sqlalchemy.orm.Session.delete
    "sqlalchemy.orm.Session.delete"), the flush process will as usual delete the associated
    rows from the `association` table, however per cascade rules it will also delete
    all related `Child` rows.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用[`Session.delete()`](session_api.html#sqlalchemy.orm.Session.delete "sqlalchemy.orm.Session.delete")标记要删除的`Parent`对象时，上述情况下，刷新过程通常会从`association`表中删除关联行，但根据级联规则，它还将删除所有相关的`Child`行。
- en: Warning
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: If the above `cascade="all, delete"` setting were configured on **both** relationships,
    then the cascade action would continue cascading through all `Parent` and `Child`
    objects, loading each `children` and `parents` collection encountered and deleting
    everything that’s connected. It is typically not desirable for “delete” cascade
    to be configured bidirectionally.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果上述`cascade="all, delete"`设置在**两个**关系上都配置了，则级联操作将继续通过所有`Parent`和`Child`对象，加载遇到的每个`children`和`parents`集合，并删除所有连接的内容。通常不希望将“删除”级联配置为双向。
- en: See also
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 另见
- en: '[Deleting Rows from the Many to Many Table](basic_relationships.html#relationships-many-to-many-deletion)'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '[从多对多表中删除行](basic_relationships.html#relationships-many-to-many-deletion)'
- en: '[Using foreign key ON DELETE with many-to-many relationships](#passive-deletes-many-to-many)  ###
    Using foreign key ON DELETE cascade with ORM relationships'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用外键 ON DELETE 与多对多关系](#passive-deletes-many-to-many)  ### 使用 ORM 关系的外键 ON
    DELETE 级联'
- en: The behavior of SQLAlchemy’s “delete” cascade overlaps with the `ON DELETE`
    feature of a database `FOREIGN KEY` constraint. SQLAlchemy allows configuration
    of these schema-level [DDL](../glossary.html#term-DDL) behaviors using the [`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey") and [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") constructs; usage of these objects in
    conjunction with [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    metadata is described at [ON UPDATE and ON DELETE](../core/constraints.html#on-update-on-delete).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy的“delete”级联行为与数据库`FOREIGN KEY`约束的`ON DELETE`特性重叠。SQLAlchemy允许使用[`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey")和[`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint")构造配置这些模式级[DDL](../glossary.html#term-DDL)行为；与[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")元数据一起使用这些对象的用法在[ON UPDATE and ON DELETE](../core/constraints.html#on-update-on-delete)中有描述。
- en: In order to use `ON DELETE` foreign key cascades in conjunction with [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship"), it’s important to note first and foremost that
    the [`relationship.cascade`](relationship_api.html#sqlalchemy.orm.relationship.params.cascade
    "sqlalchemy.orm.relationship") setting must still be configured to match the desired
    “delete” or “set null” behavior (using `delete` cascade or leaving it omitted),
    so that whether the ORM or the database level constraints will handle the task
    of actually modifying the data in the database, the ORM will still be able to
    appropriately track the state of locally present objects that may be affected.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在与[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")一起使用`ON
    DELETE`外键级联时，首先需要注意的是[`relationship.cascade`](relationship_api.html#sqlalchemy.orm.relationship.params.cascade
    "sqlalchemy.orm.relationship")设置仍然必须配置为与所需的“delete”或“set null”行为匹配（使用`delete`级联或将其省略），以便ORM或数据库级约束将处理实际修改数据库中数据的任务时，ORM仍然能够适当跟踪可能受影响的本地存在的对象的状态。
- en: There is then an additional option on [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") which indicates the degree to which the ORM should
    try to run DELETE/UPDATE operations on related rows itself, vs. how much it should
    rely upon expecting the database-side FOREIGN KEY constraint cascade to handle
    the task; this is the [`relationship.passive_deletes`](relationship_api.html#sqlalchemy.orm.relationship.params.passive_deletes
    "sqlalchemy.orm.relationship") parameter and it accepts options `False` (the default),
    `True` and `"all"`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")上有一个附加选项，指示ORM应该尝试自己运行DELETE/UPDATE操作相关行的程度，还是应该依赖于期望数据库端FOREIGN
    KEY约束级联处理任务；这是[`relationship.passive_deletes`](relationship_api.html#sqlalchemy.orm.relationship.params.passive_deletes
    "sqlalchemy.orm.relationship")参数，它接受`False`（默认值），`True`和`"all"`选项。
- en: 'The most typical example is that where child rows are to be deleted when parent
    rows are deleted, and that `ON DELETE CASCADE` is configured on the relevant `FOREIGN
    KEY` constraint as well:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 最典型的示例是，在删除父行时删除子行，并且在相关的`FOREIGN KEY`约束上配置了`ON DELETE CASCADE`：
- en: '[PRE41]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The behavior of the above configuration when a parent row is deleted is as
    follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 当删除父行时，上述配置的行为如下：
- en: The application calls `session.delete(my_parent)`, where `my_parent` is an instance
    of `Parent`.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序调用`session.delete(my_parent)`，其中`my_parent`是`Parent`类的一个实例。
- en: When the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    next flushes changes to the database, all of the **currently loaded** items within
    the `my_parent.children` collection are deleted by the ORM, meaning a `DELETE`
    statement is emitted for each record.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")下次将更改刷新到数据库时，`my_parent.children`集合中的**当前加载的**所有项目都将被ORM删除，这意味着为每个记录发出一个`DELETE`语句。
- en: If the `my_parent.children` collection is **unloaded**, then no `DELETE` statements
    are emitted. If the [`relationship.passive_deletes`](relationship_api.html#sqlalchemy.orm.relationship.params.passive_deletes
    "sqlalchemy.orm.relationship") flag were **not** set on this [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship"), then a `SELECT` statement for unloaded `Child`
    objects would have been emitted.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 `my_parent.children` 集合**未加载**，则不会发出任何 `DELETE` 语句。如果在这个 [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") 上**未**设置 [`relationship.passive_deletes`](relationship_api.html#sqlalchemy.orm.relationship.params.passive_deletes
    "sqlalchemy.orm.relationship") 标志，则会发出一个用于未加载的 `Child` 对象的 `SELECT` 语句。
- en: A `DELETE` statement is then emitted for the `my_parent` row itself.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后为 `my_parent` 行本身发出一个 `DELETE` 语句。
- en: The database-level `ON DELETE CASCADE` setting ensures that all rows in `child`
    which refer to the affected row in `parent` are also deleted.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据库级别的 `ON DELETE CASCADE` 设置确保了所有引用受影响的 `parent` 行的 `child` 行也被删除。
- en: The `Parent` instance referred to by `my_parent`, as well as all instances of
    `Child` that were related to this object and were **loaded** (i.e. step 2 above
    took place), are de-associated from the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session").
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由 `my_parent` 引用的 `Parent` 实例，以及与此对象相关且已经**加载**（即发生了步骤2）的所有 `Child` 实例，都会从 [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 中解除关联。
- en: Note
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'To use “ON DELETE CASCADE”, the underlying database engine must support `FOREIGN
    KEY` constraints and they must be enforcing:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用“ON DELETE CASCADE”，底层数据库引擎必须支持`FOREIGN KEY`约束，并且它们必须是强制执行的：
- en: When using MySQL, an appropriate storage engine must be selected. See [CREATE
    TABLE arguments including Storage Engines](../dialects/mysql.html#mysql-storage-engines)
    for details.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用 MySQL 时，必须选择适当的存储引擎。详情请参阅[包括存储引擎的 CREATE TABLE 参数](../dialects/mysql.html#mysql-storage-engines)。
- en: 'When using SQLite, foreign key support must be enabled explicitly. See [Foreign
    Key Support](../dialects/sqlite.html#sqlite-foreign-keys) for details.  ### Using
    foreign key ON DELETE with many-to-many relationships'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用 SQLite 时，必须显式启用外键支持。详情请参阅[外键支持](../dialects/sqlite.html#sqlite-foreign-keys)。###
    使用外键 ON DELETE 处理多对多关系
- en: As described at [Using delete cascade with many-to-many relationships](#cascade-delete-many-to-many),
    “delete” cascade works for many-to-many relationships as well. To make use of
    `ON DELETE CASCADE` foreign keys in conjunction with many to many, `FOREIGN KEY`
    directives are configured on the association table. These directives can handle
    the task of automatically deleting from the association table, but cannot accommodate
    the automatic deletion of the related objects themselves.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [使用级联删除处理多对多关系](#cascade-delete-many-to-many) 中所述，“delete”级联也适用于多对多关系。要使用
    `ON DELETE CASCADE` 外键与多对多一起使用，必须在关联表上配置 `FOREIGN KEY` 指令。这些指令可以处理自动从关联表中删除，但不能自动删除相关对象本身。
- en: In this case, the [`relationship.passive_deletes`](relationship_api.html#sqlalchemy.orm.relationship.params.passive_deletes
    "sqlalchemy.orm.relationship") directive can save us some additional `SELECT`
    statements during a delete operation but there are still some collections that
    the ORM will continue to load, in order to locate affected child objects and handle
    them correctly.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，[`relationship.passive_deletes`](relationship_api.html#sqlalchemy.orm.relationship.params.passive_deletes
    "sqlalchemy.orm.relationship") 指令可以在删除操作期间为我们节省一些额外的 `SELECT` 语句，但仍然有一些集合 ORM
    将继续加载，以便定位受影响的子对象并正确处理它们。
- en: Note
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Hypothetical optimizations to this could include a single `DELETE` statement
    against all parent-associated rows of the association table at once, then use
    `RETURNING` to locate affected related child rows, however this is not currently
    part of the ORM unit of work implementation.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 对此的假设优化可能包括一条针对关联表的所有父关联行的单个 `DELETE` 语句，然后使用 `RETURNING` 定位受影响的相关子行，但是这目前不是
    ORM 工作单元实现的一部分。
- en: 'In this configuration, we configure `ON DELETE CASCADE` on both foreign key
    constraints of the association table. We configure `cascade="all, delete"` on
    the parent->child side of the relationship, and we can then configure `passive_deletes=True`
    on the **other** side of the bidirectional relationship as illustrated below:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在此配置中，我们在关联表的两个外键约束上都配置了 `ON DELETE CASCADE`。我们在关系的父->子方向上配置了 `cascade="all,
    delete"`，然后我们可以在双向关系的**另一侧**上配置 `passive_deletes=True`，如下所示：
- en: '[PRE42]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Using the above configuration, the deletion of a `Parent` object proceeds as
    follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上述配置，删除 `Parent` 对象的过程如下：
- en: A `Parent` object is marked for deletion using [`Session.delete()`](session_api.html#sqlalchemy.orm.Session.delete
    "sqlalchemy.orm.Session.delete").
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 [`Session.delete()`](session_api.html#sqlalchemy.orm.Session.delete "sqlalchemy.orm.Session.delete")
    标记要删除的 `Parent` 对象。
- en: When the flush occurs, if the `Parent.children` collection is not loaded, the
    ORM will first emit a SELECT statement in order to load the `Child` objects that
    correspond to `Parent.children`.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当刷新发生时，如果未加载 `Parent.children` 集合，则 ORM 将首先发出 SELECT 语句以加载与 `Parent.children`
    对应的 `Child` 对象。
- en: It will then then emit `DELETE` statements for the rows in `association` which
    correspond to that parent row.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后会为对应于该父行的 `association` 中的行发出 `DELETE` 语句。
- en: for each `Child` object affected by this immediate deletion, because `passive_deletes=True`
    is configured, the unit of work will not need to try to emit SELECT statements
    for each `Child.parents` collection as it is assumed the corresponding rows in
    `association` will be deleted.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于由此立即删除受影响的每个 `Child` 对象，因为配置了 `passive_deletes=True`，工作单元不需要尝试为每个 `Child.parents`
    集合发出 SELECT 语句，因为假设将删除 `association` 中对应的行。
- en: '`DELETE` statements are then emitted for each `Child` object that was loaded
    from `Parent.children`.  ### Using delete cascade with many-to-many relationships'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '然后对从 `Parent.children` 加载的每个 `Child` 对象发出 `DELETE` 语句。 ### 使用删除级联处理多对多关系'
- en: The `cascade="all, delete"` option works equally well with a many-to-many relationship,
    one that uses [`relationship.secondary`](relationship_api.html#sqlalchemy.orm.relationship.params.secondary
    "sqlalchemy.orm.relationship") to indicate an association table. When a parent
    object is deleted, and therefore de-associated with its related objects, the unit
    of work process will normally delete rows from the association table, but leave
    the related objects intact. When combined with `cascade="all, delete"`, additional
    `DELETE` statements will take place for the child rows themselves.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`cascade="all, delete"` 选项与多对多关系同样有效，即使用 [`relationship.secondary`](relationship_api.html#sqlalchemy.orm.relationship.params.secondary
    "sqlalchemy.orm.relationship") 指示关联表的关系。当删除父对象并因此取消关联其相关对象时，工作单元进程通常会删除关联表中的行，但保留相关对象。当与
    `cascade="all, delete"` 结合使用时，将为子行本身执行额外的 `DELETE` 语句。'
- en: 'The following example adapts that of [Many To Many](basic_relationships.html#relationships-many-to-many)
    to illustrate the `cascade="all, delete"` setting on **one** side of the association:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例将[多对多](basic_relationships.html#relationships-many-to-many)的示例调整为示例，以说明在关联的**一侧**上设置
    `cascade="all, delete"`。
- en: '[PRE43]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Above, when a `Parent` object is marked for deletion using [`Session.delete()`](session_api.html#sqlalchemy.orm.Session.delete
    "sqlalchemy.orm.Session.delete"), the flush process will as usual delete the associated
    rows from the `association` table, however per cascade rules it will also delete
    all related `Child` rows.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 上面，当使用 [`Session.delete()`](session_api.html#sqlalchemy.orm.Session.delete "sqlalchemy.orm.Session.delete")
    标记要删除的 `Parent` 对象时，刷新过程将按照惯例从 `association` 表中删除相关行，但根据级联规则，它还将删除所有相关的 `Child`
    行。
- en: Warning
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: If the above `cascade="all, delete"` setting were configured on **both** relationships,
    then the cascade action would continue cascading through all `Parent` and `Child`
    objects, loading each `children` and `parents` collection encountered and deleting
    everything that’s connected. It is typically not desirable for “delete” cascade
    to be configured bidirectionally.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如果上述 `cascade="all, delete"` 设置被配置在**两个**关系上，那么级联操作将继续通过所有 `Parent` 和 `Child`
    对象进行级联，加载遇到的每个 `children` 和 `parents` 集合，并删除所有连接的内容。通常不希望双向配置“delete”级联。
- en: See also
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Deleting Rows from the Many to Many Table](basic_relationships.html#relationships-many-to-many-deletion)'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '[从多对多表中删除行](basic_relationships.html#relationships-many-to-many-deletion)'
- en: '[Using foreign key ON DELETE with many-to-many relationships](#passive-deletes-many-to-many)'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用外键 ON DELETE 处理多对多关系](#passive-deletes-many-to-many)'
- en: '### Using foreign key ON DELETE cascade with ORM relationships'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '### 使用 ORM 关系中的外键 ON DELETE 级联'
- en: The behavior of SQLAlchemy’s “delete” cascade overlaps with the `ON DELETE`
    feature of a database `FOREIGN KEY` constraint. SQLAlchemy allows configuration
    of these schema-level [DDL](../glossary.html#term-DDL) behaviors using the [`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey") and [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") constructs; usage of these objects in
    conjunction with [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    metadata is described at [ON UPDATE and ON DELETE](../core/constraints.html#on-update-on-delete).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy的“delete”级联的行为与数据库`FOREIGN KEY`约束的`ON DELETE`特性重叠。SQLAlchemy允许使用 [`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey") 和 [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") 构造配置这些模式级别的[DDL](../glossary.html#term-DDL)行为；在与
    [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    元数据结合使用这些对象的用法在[ON UPDATE and ON DELETE](../core/constraints.html#on-update-on-delete)中有描述。
- en: In order to use `ON DELETE` foreign key cascades in conjunction with [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship"), it’s important to note first and foremost that
    the [`relationship.cascade`](relationship_api.html#sqlalchemy.orm.relationship.params.cascade
    "sqlalchemy.orm.relationship") setting must still be configured to match the desired
    “delete” or “set null” behavior (using `delete` cascade or leaving it omitted),
    so that whether the ORM or the database level constraints will handle the task
    of actually modifying the data in the database, the ORM will still be able to
    appropriately track the state of locally present objects that may be affected.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")
    中使用`ON DELETE`外键级联，首先要注意的是 [`relationship.cascade`](relationship_api.html#sqlalchemy.orm.relationship.params.cascade
    "sqlalchemy.orm.relationship") 设置必须仍然配置为匹配所需的“删除”或“设置为null”行为（使用`delete`级联或将其省略），以便ORM或数据库级别的约束将处理实际修改数据库中的数据的任务时，ORM仍将能够适当地跟踪可能受到影响的本地存在的对象的状态。
- en: There is then an additional option on [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") which indicates the degree to which the ORM should
    try to run DELETE/UPDATE operations on related rows itself, vs. how much it should
    rely upon expecting the database-side FOREIGN KEY constraint cascade to handle
    the task; this is the [`relationship.passive_deletes`](relationship_api.html#sqlalchemy.orm.relationship.params.passive_deletes
    "sqlalchemy.orm.relationship") parameter and it accepts options `False` (the default),
    `True` and `"all"`.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")
    上有一个额外的选项，指示ORM应该尝试在相关行上自行运行DELETE/UPDATE操作的程度，而不是依靠期望数据库端FOREIGN KEY约束级联处理该任务；这是
    [`relationship.passive_deletes`](relationship_api.html#sqlalchemy.orm.relationship.params.passive_deletes
    "sqlalchemy.orm.relationship") 参数，它接受选项 `False`（默认值）、`True` 和 `"all"`。
- en: 'The most typical example is that where child rows are to be deleted when parent
    rows are deleted, and that `ON DELETE CASCADE` is configured on the relevant `FOREIGN
    KEY` constraint as well:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 最典型的例子是，在删除父行时要删除子行，并且在相关的`FOREIGN KEY`约束上配置了`ON DELETE CASCADE`：
- en: '[PRE44]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The behavior of the above configuration when a parent row is deleted is as
    follows:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 当删除父行时，上述配置的行为如下：
- en: The application calls `session.delete(my_parent)`, where `my_parent` is an instance
    of `Parent`.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序调用`session.delete(my_parent)`，其中`my_parent`是`Parent`的实例。
- en: When the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    next flushes changes to the database, all of the **currently loaded** items within
    the `my_parent.children` collection are deleted by the ORM, meaning a `DELETE`
    statement is emitted for each record.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当 [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    下次将更改刷新到数据库时，`my_parent.children` 集合中的所有**当前加载的**项目都将被ORM删除，这意味着为每个记录发出了一个`DELETE`语句。
- en: If the `my_parent.children` collection is **unloaded**, then no `DELETE` statements
    are emitted. If the [`relationship.passive_deletes`](relationship_api.html#sqlalchemy.orm.relationship.params.passive_deletes
    "sqlalchemy.orm.relationship") flag were **not** set on this [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship"), then a `SELECT` statement for unloaded `Child`
    objects would have been emitted.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`my_parent.children`集合**未加载**，则不会发出`DELETE`语句。 如果在此[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")上未设置[`relationship.passive_deletes`](relationship_api.html#sqlalchemy.orm.relationship.params.passive_deletes
    "sqlalchemy.orm.relationship")标志，那么将会发出一个针对未加载的`Child`对象的`SELECT`语句。
- en: A `DELETE` statement is then emitted for the `my_parent` row itself.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 针对`my_parent`行本身发出了一个`DELETE`语句。
- en: The database-level `ON DELETE CASCADE` setting ensures that all rows in `child`
    which refer to the affected row in `parent` are also deleted.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数据库级别的`ON DELETE CASCADE`设置确保了所有引用受影响的`parent`行的`child`中的行也被删除。
- en: The `Parent` instance referred to by `my_parent`, as well as all instances of
    `Child` that were related to this object and were **loaded** (i.e. step 2 above
    took place), are de-associated from the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session").
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由`my_parent`引用的`Parent`实例以及所有与此对象相关联且已**加载**的`Child`实例（即发生了步骤2）都将从[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")中解除关联。
- en: Note
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'To use “ON DELETE CASCADE”, the underlying database engine must support `FOREIGN
    KEY` constraints and they must be enforcing:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用“ON DELETE CASCADE”，底层数据库引擎必须支持`FOREIGN KEY`约束，并且它们必须是强制性的：
- en: When using MySQL, an appropriate storage engine must be selected. See [CREATE
    TABLE arguments including Storage Engines](../dialects/mysql.html#mysql-storage-engines)
    for details.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用MySQL时，必须选择适当的存储引擎。 有关详细信息，请参阅[CREATE TABLE arguments including Storage Engines](../dialects/mysql.html#mysql-storage-engines)。
- en: When using SQLite, foreign key support must be enabled explicitly. See [Foreign
    Key Support](../dialects/sqlite.html#sqlite-foreign-keys) for details.
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用SQLite时，必须显式启用外键支持。 有关详细信息，请参阅[Foreign Key Support](../dialects/sqlite.html#sqlite-foreign-keys)。
- en: '### Using foreign key ON DELETE with many-to-many relationships'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '### 在多对多关系中使用外键ON DELETE'
- en: As described at [Using delete cascade with many-to-many relationships](#cascade-delete-many-to-many),
    “delete” cascade works for many-to-many relationships as well. To make use of
    `ON DELETE CASCADE` foreign keys in conjunction with many to many, `FOREIGN KEY`
    directives are configured on the association table. These directives can handle
    the task of automatically deleting from the association table, but cannot accommodate
    the automatic deletion of the related objects themselves.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如[使用delete cascade与多对多关系](#cascade-delete-many-to-many)所述，“delete”级联也适用于多对多关系。
    要利用`ON DELETE CASCADE`外键与多对多关系，必须在关联表上配置`FOREIGN KEY`指令。 这些指令可以处理自动从关联表中删除，但无法适应相关对象本身的自动删除。
- en: In this case, the [`relationship.passive_deletes`](relationship_api.html#sqlalchemy.orm.relationship.params.passive_deletes
    "sqlalchemy.orm.relationship") directive can save us some additional `SELECT`
    statements during a delete operation but there are still some collections that
    the ORM will continue to load, in order to locate affected child objects and handle
    them correctly.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，[`relationship.passive_deletes`](relationship_api.html#sqlalchemy.orm.relationship.params.passive_deletes
    "sqlalchemy.orm.relationship")指令可以在删除操作期间为我们节省一些额外的`SELECT`语句，但仍然有一些集合是ORM将继续加载的，以定位受影响的子对象并正确处理它们。
- en: Note
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Hypothetical optimizations to this could include a single `DELETE` statement
    against all parent-associated rows of the association table at once, then use
    `RETURNING` to locate affected related child rows, however this is not currently
    part of the ORM unit of work implementation.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 对此的假设优化可以包括一次针对关联表的所有父关联行的单个`DELETE`语句，然后使用`RETURNING`来定位受影响的相关子行，但这目前不是ORM工作单元实现的一部分。
- en: 'In this configuration, we configure `ON DELETE CASCADE` on both foreign key
    constraints of the association table. We configure `cascade="all, delete"` on
    the parent->child side of the relationship, and we can then configure `passive_deletes=True`
    on the **other** side of the bidirectional relationship as illustrated below:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在此配置中，我们在关联表的两个外键约束上都配置了`ON DELETE CASCADE`。我们在关系的父->子方向上配置了`cascade="all, delete"`，然后我们可以在双向关系的**另一侧**上配置`passive_deletes=True`，如下所示：
- en: '[PRE45]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Using the above configuration, the deletion of a `Parent` object proceeds as
    follows:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上述配置，删除 `Parent` 对象的过程如下：
- en: A `Parent` object is marked for deletion using [`Session.delete()`](session_api.html#sqlalchemy.orm.Session.delete
    "sqlalchemy.orm.Session.delete").
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 [`Session.delete()`](session_api.html#sqlalchemy.orm.Session.delete "sqlalchemy.orm.Session.delete")
    标记要删除的 `Parent` 对象。
- en: When the flush occurs, if the `Parent.children` collection is not loaded, the
    ORM will first emit a SELECT statement in order to load the `Child` objects that
    correspond to `Parent.children`.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当发生刷新时，如果未加载 `Parent.children` 集合，则 ORM 首先会发出 SELECT 语句，以加载与 `Parent.children`
    对应的 `Child` 对象。
- en: It will then then emit `DELETE` statements for the rows in `association` which
    correspond to that parent row.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后会为与该父行对应的 `association` 中的行发出 `DELETE` 语句。
- en: for each `Child` object affected by this immediate deletion, because `passive_deletes=True`
    is configured, the unit of work will not need to try to emit SELECT statements
    for each `Child.parents` collection as it is assumed the corresponding rows in
    `association` will be deleted.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于受此即时删除影响的每个 `Child` 对象，因为配置了 `passive_deletes=True`，工作单元不需要尝试为每个 `Child.parents`
    集合发出 SELECT 语句，因为假设将删除 `association` 中的相应行。
- en: '`DELETE` statements are then emitted for each `Child` object that was loaded
    from `Parent.children`.'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后会为从 `Parent.children` 中加载的每个 `Child` 对象发出 `DELETE` 语句。
- en: '## delete-orphan'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '## 删除孤立'
- en: '`delete-orphan` cascade adds behavior to the `delete` cascade, such that a
    child object will be marked for deletion when it is de-associated from the parent,
    not just when the parent is marked for deletion. This is a common feature when
    dealing with a related object that is “owned” by its parent, with a NOT NULL foreign
    key, so that removal of the item from the parent collection results in its deletion.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`delete-orphan` 级联为 `delete` 级联增加了行为，使得当子对象与父对象取消关联时，子对象将被标记为删除，而不仅仅是当父对象被标记为删除时。当处理由其父对象“拥有”的相关对象时，这是一个常见功能，具有非空的外键，以便从父集合中移除项目会导致其删除。'
- en: '`delete-orphan` cascade implies that each child object can only have one parent
    at a time, and in the **vast majority of cases is configured only on a one-to-many
    relationship.** For the much less common case of setting it on a many-to-one or
    many-to-many relationship, the “many” side can be forced to allow only a single
    object at a time by configuring the [`relationship.single_parent`](relationship_api.html#sqlalchemy.orm.relationship.params.single_parent
    "sqlalchemy.orm.relationship") argument, which establishes Python-side validation
    that ensures the object is associated with only one parent at a time, however
    this greatly limits the functionality of the “many” relationship and is usually
    not what’s desired.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`delete-orphan` 级联意味着每个子对象一次只能有一个父对象，并且在绝大多数情况下仅配置在一对多关系上。在很少见的情况下，在多对一或多对多关系上设置它，“多”方可以通过配置
    [`relationship.single_parent`](relationship_api.html#sqlalchemy.orm.relationship.params.single_parent
    "sqlalchemy.orm.relationship") 参数，强制允许一次只有一个对象与父对象关联，从而在 Python 端建立验证，确保对象一次只与一个父对象关联，但这严重限制了“多”关系的功能，通常不是所期望的。'
- en: See also
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[For relationship <relationship>, delete-orphan cascade is normally configured
    only on the “one” side of a one-to-many relationship, and not on the “many” side
    of a many-to-one or many-to-many relationship.](../errors.html#error-bbf0) - background
    on a common error scenario involving delete-orphan cascade.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '[对于关系<relationship>，`delete-orphan` 级联通常仅配置在一对多关系的“一”方，并且不配置在多对一或多对多关系的“多”方。](../errors.html#error-bbf0)
    - 关于涉及 `delete-orphan` 级联的常见错误场景的背景信息。'
- en: '## merge'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '## 合并'
- en: '`merge` cascade indicates that the [`Session.merge()`](session_api.html#sqlalchemy.orm.Session.merge
    "sqlalchemy.orm.Session.merge") operation should be propagated from a parent that’s
    the subject of the [`Session.merge()`](session_api.html#sqlalchemy.orm.Session.merge
    "sqlalchemy.orm.Session.merge") call down to referred objects. This cascade is
    also on by default.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`merge` 级联表示 [`Session.merge()`](session_api.html#sqlalchemy.orm.Session.merge
    "sqlalchemy.orm.Session.merge") 操作应从 [`Session.merge()`](session_api.html#sqlalchemy.orm.Session.merge
    "sqlalchemy.orm.Session.merge") 调用的主体父对象传播到引用对象。此级联默认也是打开的。'
- en: '## refresh-expire'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '## 刷新-过期'
- en: '`refresh-expire` is an uncommon option, indicating that the [`Session.expire()`](session_api.html#sqlalchemy.orm.Session.expire
    "sqlalchemy.orm.Session.expire") operation should be propagated from a parent
    down to referred objects. When using [`Session.refresh()`](session_api.html#sqlalchemy.orm.Session.refresh
    "sqlalchemy.orm.Session.refresh"), the referred objects are expired only, but
    not actually refreshed.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '`refresh-expire`是一个不常见的选项，表示[`Session.expire()`](session_api.html#sqlalchemy.orm.Session.expire
    "sqlalchemy.orm.Session.expire")操作应该从父对象传播到引用的对象。当使用[`Session.refresh()`](session_api.html#sqlalchemy.orm.Session.refresh
    "sqlalchemy.orm.Session.refresh")时，引用的对象只是过期了，而不是实际刷新了。'
- en: '## expunge'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '## 清除'
- en: '`expunge` cascade indicates that when the parent object is removed from the
    [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    using [`Session.expunge()`](session_api.html#sqlalchemy.orm.Session.expunge "sqlalchemy.orm.Session.expunge"),
    the operation should be propagated down to referred objects.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`清除`级联指的是当父对象从[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")中使用[`Session.expunge()`](session_api.html#sqlalchemy.orm.Session.expunge
    "sqlalchemy.orm.Session.expunge")移除时，该操作应传播到引用的对象。'
- en: '## Notes on Delete - Deleting Objects Referenced from Collections and Scalar
    Relationships'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '## 删除注意事项 - 删除集合和标量关系中引用的对象'
- en: The ORM in general never modifies the contents of a collection or scalar relationship
    during the flush process. This means, if your class has a [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") that refers to a collection of objects, or a reference
    to a single object such as many-to-one, the contents of this attribute will not
    be modified when the flush process occurs. Instead, it is expected that the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") would eventually be expired, either through the expire-on-commit
    behavior of [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") or through explicit use of [`Session.expire()`](session_api.html#sqlalchemy.orm.Session.expire
    "sqlalchemy.orm.Session.expire"). At that point, any referenced object or collection
    associated with that [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    will be cleared and will re-load itself upon next access.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，ORM在刷新过程中永远不会修改集合或标量关系的内容。这意味着，如果你的类有一个指向对象集合的[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")，或者一个指向单个对象的引用，比如多对一，当刷新过程发生时，这个属性的内容不会被修改。相反，预计[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")最终会过期，通过[`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit")的提交时过期行为或通过[`Session.expire()`](session_api.html#sqlalchemy.orm.Session.expire
    "sqlalchemy.orm.Session.expire")的显式使用。在那时，与该[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")相关联的任何引用对象或集合都将被清除，并在下次访问时重新加载自身。
- en: A common confusion that arises regarding this behavior involves the use of the
    [`Session.delete()`](session_api.html#sqlalchemy.orm.Session.delete "sqlalchemy.orm.Session.delete")
    method. When [`Session.delete()`](session_api.html#sqlalchemy.orm.Session.delete
    "sqlalchemy.orm.Session.delete") is invoked upon an object and the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is flushed, the row is deleted from the database. Rows
    that refer to the target row via foreign key, assuming they are tracked using
    a [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")
    between the two mapped object types, will also see their foreign key attributes
    UPDATED to null, or if delete cascade is set up, the related rows will be deleted
    as well. However, even though rows related to the deleted object might be themselves
    modified as well, **no changes occur to relationship-bound collections or object
    references on the objects** involved in the operation within the scope of the
    flush itself. This means if the object was a member of a related collection, it
    will still be present on the Python side until that collection is expired. Similarly,
    if the object were referenced via many-to-one or one-to-one from another object,
    that reference will remain present on that object until the object is expired
    as well.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这种行为产生的常见困惑涉及到[`Session.delete()`](session_api.html#sqlalchemy.orm.Session.delete
    "sqlalchemy.orm.Session.delete")方法的使用。当在一个对象上调用[`Session.delete()`](session_api.html#sqlalchemy.orm.Session.delete
    "sqlalchemy.orm.Session.delete")并且[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")被刷新时，该行将从数据库中删除。通过外键引用目标行的行，假设它们是使用两个映射对象类型之间的[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")进行跟踪的，也会看到它们的外键属性被更新为null，或者如果设置了删除级联，相关行也将被删除。然而，即使与已删除对象相关的行可能也被修改，**在刷新范围内操作的对象上的关系绑定集合或对象引用不会发生任何更改**。这意味着如果对象是相关集合的成员，它将仍然存在于Python端，直到该集合过期为止。同样，如果对象通过另一个对象的多对一或一对一引用，则该引用也将保留在该对象上，直到该对象也过期为止。
- en: 'Below, we illustrate that after an `Address` object is marked for deletion,
    it’s still present in the collection associated with the parent `User`, even after
    a flush:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 下面，我们说明了在将`Address`对象标记为删除后，即使在刷新后，它仍然存在于与父`User`关联的集合中：
- en: '[PRE46]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'When the above session is committed, all attributes are expired. The next access
    of `user.addresses` will re-load the collection, revealing the desired state:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 当以上会话提交时，所有属性都会过期。对`user.addresses`的下一次访问将重新加载集合，显示所需的状态：
- en: '[PRE47]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'There is a recipe for intercepting [`Session.delete()`](session_api.html#sqlalchemy.orm.Session.delete
    "sqlalchemy.orm.Session.delete") and invoking this expiration automatically; see
    [ExpireRelationshipOnFKChange](https://www.sqlalchemy.org/trac/wiki/UsageRecipes/ExpireRelationshipOnFKChange)
    for this. However, the usual practice of deleting items within collections is
    to forego the usage of [`Session.delete()`](session_api.html#sqlalchemy.orm.Session.delete
    "sqlalchemy.orm.Session.delete") directly, and instead use cascade behavior to
    automatically invoke the deletion as a result of removing the object from the
    parent collection. The `delete-orphan` cascade accomplishes this, as illustrated
    in the example below:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个拦截[`Session.delete()`](session_api.html#sqlalchemy.orm.Session.delete "sqlalchemy.orm.Session.delete")并自动调用此过期的配方；参见[ExpireRelationshipOnFKChange](https://www.sqlalchemy.org/trac/wiki/UsageRecipes/ExpireRelationshipOnFKChange)。然而，删除集合中的项目的通常做法是直接放弃使用[`Session.delete()`](session_api.html#sqlalchemy.orm.Session.delete
    "sqlalchemy.orm.Session.delete")，而是使用级联行为自动调用删除作为从父集合中删除对象的结果。`delete-orphan`级联实现了这一点，如下例所示：
- en: '[PRE48]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Where above, upon removing the `Address` object from the `User.addresses` collection,
    the `delete-orphan` cascade has the effect of marking the `Address` object for
    deletion in the same way as passing it to [`Session.delete()`](session_api.html#sqlalchemy.orm.Session.delete
    "sqlalchemy.orm.Session.delete").
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，当从`User.addresses`集合中移除`Address`对象时，`delete-orphan`级联的效果与将其传递给[`Session.delete()`](session_api.html#sqlalchemy.orm.Session.delete
    "sqlalchemy.orm.Session.delete")相同，都将`Address`对象标记为删除。
- en: 'The `delete-orphan` cascade can also be applied to a many-to-one or one-to-one
    relationship, so that when an object is de-associated from its parent, it is also
    automatically marked for deletion. Using `delete-orphan` cascade on a many-to-one
    or one-to-one requires an additional flag [`relationship.single_parent`](relationship_api.html#sqlalchemy.orm.relationship.params.single_parent
    "sqlalchemy.orm.relationship") which invokes an assertion that this related object
    is not to shared with any other parent simultaneously:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '`delete-orphan`级联也可以应用于多对一或一对一关系，这样当一个对象与其父对象解除关联时，它也会被自动标记为删除。在多对一或一对一关系上使用`delete-orphan`级联需要一个额外的标志[`relationship.single_parent`](relationship_api.html#sqlalchemy.orm.relationship.params.single_parent
    "sqlalchemy.orm.relationship")，它调用一个断言，指出这个相关对象不会同时与任何其他父对象共享：'
- en: '[PRE49]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Above, if a hypothetical `Preference` object is removed from a `User`, it will
    be deleted on flush:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 上面，如果一个假设的`Preference`对象从一个`User`中移除，它将在刷新时被删除：
- en: '[PRE50]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: See also
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Cascades](#unitofwork-cascades) for detail on cascades.'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '[级联](#unitofwork-cascades)以获取级联的详细信息。'
