["```py\nfrom sqlalchemy import MetaData\n\nmetadata_obj = MetaData()\n```", "```py\nfrom sqlalchemy import Table, Column, Integer, String\n\nuser = Table(\n    \"user\",\n    metadata_obj,\n    Column(\"user_id\", Integer, primary_key=True),\n    Column(\"user_name\", String(16), nullable=False),\n    Column(\"email_address\", String(60)),\n    Column(\"nickname\", String(50), nullable=False),\n)\n```", "```py\n>>> for t in metadata_obj.sorted_tables:\n...     print(t.name)\nuser\nuser_preference\ninvoice\ninvoice_item\n```", "```py\nemployees = Table(\n    \"employees\",\n    metadata_obj,\n    Column(\"employee_id\", Integer, primary_key=True),\n    Column(\"employee_name\", String(60), nullable=False),\n    Column(\"employee_dept\", Integer, ForeignKey(\"departments.department_id\")),\n)\n```", "```py\n# access the column \"employee_id\":\nemployees.columns.employee_id\n\n# or just\nemployees.c.employee_id\n\n# via string\nemployees.c[\"employee_id\"]\n\n# a tuple of columns may be returned using multiple strings\n# (new in 2.0)\nemp_id, name, type = employees.c[\"employee_id\", \"name\", \"type\"]\n\n# iterate through all columns\nfor c in employees.c:\n    print(c)\n\n# get the table's primary key columns\nfor primary_key in employees.primary_key:\n    print(primary_key)\n\n# get the table's foreign key objects:\nfor fkey in employees.foreign_keys:\n    print(fkey)\n\n# access the table's MetaData:\nemployees.metadata\n\n# access a column's name, type, nullable, primary key, foreign key\nemployees.c.employee_id.name\nemployees.c.employee_id.type\nemployees.c.employee_id.nullable\nemployees.c.employee_id.primary_key\nemployees.c.employee_dept.foreign_keys\n\n# get the \"key\" of a column, which defaults to its name, but can\n# be any user-defined string:\nemployees.c.employee_name.key\n\n# access a column's table:\nemployees.c.employee_id.table is employees\n\n# get the table related by a foreign key\nlist(employees.c.employee_dept.foreign_keys)[0].column.table\n```", "```py\nengine = create_engine(\"sqlite:///:memory:\")\n\nmetadata_obj = MetaData()\n\nuser = Table(\n    \"user\",\n    metadata_obj,\n    Column(\"user_id\", Integer, primary_key=True),\n    Column(\"user_name\", String(16), nullable=False),\n    Column(\"email_address\", String(60), key=\"email\"),\n    Column(\"nickname\", String(50), nullable=False),\n)\n\nuser_prefs = Table(\n    \"user_prefs\",\n    metadata_obj,\n    Column(\"pref_id\", Integer, primary_key=True),\n    Column(\"user_id\", Integer, ForeignKey(\"user.user_id\"), nullable=False),\n    Column(\"pref_name\", String(40), nullable=False),\n    Column(\"pref_value\", String(100)),\n)\n\nmetadata_obj.create_all(engine)\nPRAGMA  table_info(user){}\nCREATE  TABLE  user(\n  user_id  INTEGER  NOT  NULL  PRIMARY  KEY,\n  user_name  VARCHAR(16)  NOT  NULL,\n  email_address  VARCHAR(60),\n  nickname  VARCHAR(50)  NOT  NULL\n)\nPRAGMA  table_info(user_prefs){}\nCREATE  TABLE  user_prefs(\n  pref_id  INTEGER  NOT  NULL  PRIMARY  KEY,\n  user_id  INTEGER  NOT  NULL  REFERENCES  user(user_id),\n  pref_name  VARCHAR(40)  NOT  NULL,\n  pref_value  VARCHAR(100)\n) \n```", "```py\nengine = create_engine(\"sqlite:///:memory:\")\n\nmetadata_obj = MetaData()\n\nemployees = Table(\n    \"employees\",\n    metadata_obj,\n    Column(\"employee_id\", Integer, primary_key=True),\n    Column(\"employee_name\", String(60), nullable=False, key=\"name\"),\n    Column(\"employee_dept\", Integer, ForeignKey(\"departments.department_id\")),\n)\nemployees.create(engine)\nCREATE  TABLE  employees(\n  employee_id  SERIAL  NOT  NULL  PRIMARY  KEY,\n  employee_name  VARCHAR(60)  NOT  NULL,\n  employee_dept  INTEGER  REFERENCES  departments(department_id)\n)\n{} \n```", "```py\nemployees.drop(engine)\nDROP  TABLE  employees\n{} \n```", "```py\nemployees.create(engine, checkfirst=True)\nemployees.drop(engine, checkfirst=False)\n```", "```py\nmetadata_obj = MetaData()\n\nfinancial_info = Table(\n    \"financial_info\",\n    metadata_obj,\n    Column(\"id\", Integer, primary_key=True),\n    Column(\"value\", String(100), nullable=False),\n    schema=\"remote_banks\",\n)\n```", "```py\n>>> print(select(financial_info))\nSELECT  remote_banks.financial_info.id,  remote_banks.financial_info.value\nFROM  remote_banks.financial_info \n```", "```py\n>>> metadata_obj.tables[\"remote_banks.financial_info\"]\nTable('financial_info', MetaData(),\nColumn('id', Integer(), table=<financial_info>, primary_key=True, nullable=False),\nColumn('value', String(length=100), table=<financial_info>, nullable=False),\nschema='remote_banks')\n```", "```py\ncustomer = Table(\n    \"customer\",\n    metadata_obj,\n    Column(\"id\", Integer, primary_key=True),\n    Column(\"financial_info_id\", ForeignKey(\"remote_banks.financial_info.id\")),\n    schema=\"remote_banks\",\n)\n```", "```py\nschema = \"dbo.scott\"\n```", "```py\nmetadata_obj = MetaData(schema=\"remote_banks\")\n\nfinancial_info = Table(\n    \"financial_info\",\n    metadata_obj,\n    Column(\"id\", Integer, primary_key=True),\n    Column(\"value\", String(100), nullable=False),\n)\n```", "```py\nmetadata_obj.tables[\"remote_banks.financial_info\"]\n```", "```py\n# either will work:\n\nrefers_to_financial_info = Table(\n    \"refers_to_financial_info\",\n    metadata_obj,\n    Column(\"id\", Integer, primary_key=True),\n    Column(\"fiid\", ForeignKey(\"financial_info.id\")),\n)\n\n# or\n\nrefers_to_financial_info = Table(\n    \"refers_to_financial_info\",\n    metadata_obj,\n    Column(\"id\", Integer, primary_key=True),\n    Column(\"fiid\", ForeignKey(\"remote_banks.financial_info.id\")),\n)\n```", "```py\nfrom sqlalchemy import BLANK_SCHEMA\n\nmetadata_obj = MetaData(schema=\"remote_banks\")\n\nfinancial_info = Table(\n    \"financial_info\",\n    metadata_obj,\n    Column(\"id\", Integer, primary_key=True),\n    Column(\"value\", String(100), nullable=False),\n    schema=BLANK_SCHEMA,  # will not use \"remote_banks\"\n)\n```", "```py\nfrom sqlalchemy import event\nfrom sqlalchemy import create_engine\n\nengine = create_engine(\"oracle+cx_oracle://scott:tiger@tsn_name\")\n\n@event.listens_for(engine, \"connect\", insert=True)\ndef set_current_schema(dbapi_connection, connection_record):\n    cursor_obj = dbapi_connection.cursor()\n    cursor_obj.execute(\"ALTER SESSION SET CURRENT_SCHEMA=%s\" % schema_name)\n    cursor_obj.close()\n```", "```py\naddresses = Table(\n    \"engine_email_addresses\",\n    metadata_obj,\n    Column(\"address_id\", Integer, primary_key=True),\n    Column(\"remote_user_id\", Integer, ForeignKey(users.c.user_id)),\n    Column(\"email_address\", String(20)),\n    mysql_engine=\"InnoDB\",\n)\n```", "```py\nattribute sqlalchemy.schema.BLANK_SCHEMA\n```", "```py\nattribute sqlalchemy.schema.RETAIN_SCHEMA\n```", "```py\nclass sqlalchemy.schema.Column\n```", "```py\nmethod __eq__(other: Any) \u2192 ColumnOperators\n```", "```py\nmethod __init__(_Column__name_pos: str | _TypeEngineArgument[_T] | SchemaEventTarget | None = None, _Column__type_pos: _TypeEngineArgument[_T] | SchemaEventTarget | None = None, *args: SchemaEventTarget, name: str | None = None, type_: _TypeEngineArgument[_T] | None = None, autoincrement: _AutoIncrementType = 'auto', default: Any | None = None, doc: str | None = None, key: str | None = None, index: bool | None = None, unique: bool | None = None, info: _InfoType | None = None, nullable: bool | Literal[SchemaConst.NULL_UNSPECIFIED] | None = SchemaConst.NULL_UNSPECIFIED, onupdate: Any | None = None, primary_key: bool = False, server_default: _ServerDefaultArgument | None = None, server_onupdate: FetchedValue | None = None, quote: bool | None = None, system: bool = False, comment: str | None = None, insert_sentinel: bool = False, _omit_from_statements: bool = False, _proxies: Any | None = None, **dialect_kwargs: Any)\n```", "```py\n    # use a type with arguments\n    Column('data', String(50))\n\n    # use no arguments\n    Column('level', Integer)\n    ```", "```py\n        # turn on autoincrement for this column despite\n        # the ForeignKey()\n        Column('id', ForeignKey('other.id'),\n                    primary_key=True, autoincrement='ignore_fk')\n        ```", "```py\n    Table(\n        \"some_table\",\n        metadata,\n        Column(\"x\", Integer),\n        Index(\"ix_some_table_x\", \"x\")\n    )\n    ```", "```py\n    Column('x', Text, server_default=\"val\")\n\n    x TEXT DEFAULT 'val'\n    ```", "```py\n    Column('y', DateTime, server_default=text('NOW()'))\n\n    y DATETIME DEFAULT NOW()\n    ```", "```py\n    from sqlalchemy import create_engine\n    from sqlalchemy import Table, Column, MetaData, ARRAY, Text\n    from sqlalchemy.dialects.postgresql import array\n\n    engine = create_engine(\n        'postgresql+psycopg2://scott:tiger@localhost/mydatabase'\n    )\n    metadata_obj = MetaData()\n    tbl = Table(\n            \"foo\",\n            metadata_obj,\n            Column(\"bar\",\n                   ARRAY(Text),\n                   server_default=array([\"biz\", \"bang\", \"bash\"])\n                   )\n    )\n    metadata_obj.create_all(engine)\n    ```", "```py\n    CREATE TABLE foo (\n        bar TEXT[] DEFAULT ARRAY['biz', 'bang', 'bash']\n    )\n    ```", "```py\n    Table(\n        \"some_table\",\n        metadata,\n        Column(\"x\", Integer),\n        UniqueConstraint(\"x\")\n    )\n    ```", "```py\nmethod __le__(other: Any) \u2192 ColumnOperators\n```", "```py\nmethod __lt__(other: Any) \u2192 ColumnOperators\n```", "```py\nmethod __ne__(other: Any) \u2192 ColumnOperators\n```", "```py\nmethod all_() \u2192 ColumnOperators\n```", "```py\nattribute anon_key_label\n```", "```py\nattribute anon_label\n```", "```py\nmethod any_() \u2192 ColumnOperators\n```", "```py\nclassmethod argument_for(dialect_name, argument_name, default)\n```", "```py\nIndex.argument_for(\"mydialect\", \"length\", None)\n\nsome_index = Index('a', 'b', mydialect_length=5)\n```", "```py\nmethod asc() \u2192 ColumnOperators\n```", "```py\nmethod between(cleft: Any, cright: Any, symmetric: bool = False) \u2192 ColumnOperators\n```", "```py\nmethod bitwise_and(other: Any) \u2192 ColumnOperators\n```", "```py\nmethod bitwise_lshift(other: Any) \u2192 ColumnOperators\n```", "```py\nmethod bitwise_not() \u2192 ColumnOperators\n```", "```py\nmethod bitwise_or(other: Any) \u2192 ColumnOperators\n```", "```py\nmethod bitwise_rshift(other: Any) \u2192 ColumnOperators\n```", "```py\nmethod bitwise_xor(other: Any) \u2192 ColumnOperators\n```", "```py\nmethod bool_op(opstring: str, precedence: int = 0, python_impl: Callable[[...], Any] | None = None) \u2192 Callable[[Any], Operators]\n```", "```py\nmethod cast(type_: _TypeEngineArgument[_OPT]) \u2192 Cast[_OPT]\n```", "```py\nmethod collate(collation: str) \u2192 ColumnOperators\n```", "```py\nmethod compare(other: ClauseElement, **kw: Any) \u2192 bool\n```", "```py\nmethod compile(bind: _HasDialect | None = None, dialect: Dialect | None = None, **kw: Any) \u2192 Compiled\n```", "```py\n    from sqlalchemy.sql import table, column, select\n\n    t = table('t', column('x'))\n\n    s = select(t).where(t.c.x == 5)\n\n    print(s.compile(compile_kwargs={\"literal_binds\": True}))\n    ```", "```py\nmethod concat(other: Any) \u2192 ColumnOperators\n```", "```py\nmethod contains(other: Any, **kw: Any) \u2192 ColumnOperators\n```", "```py\ncolumn LIKE '%' || <other> || '%'\n```", "```py\nstmt = select(sometable).\\\n    where(sometable.c.column.contains(\"foobar\"))\n```", "```py\n    somecolumn.contains(\"foo%bar\", autoescape=True)\n    ```", "```py\n    somecolumn LIKE '%' || :param || '%' ESCAPE '/'\n    ```", "```py\n    somecolumn.contains(\"foo/%bar\", escape=\"^\")\n    ```", "```py\n    somecolumn LIKE '%' || :param || '%' ESCAPE '^'\n    ```", "```py\n    somecolumn.contains(\"foo%bar^bat\", escape=\"^\", autoescape=True)\n    ```", "```py\nmethod copy(**kw: Any) \u2192 Column[Any]\n```", "```py\nmethod desc() \u2192 ColumnOperators\n```", "```py\nattribute dialect_kwargs\n```", "```py\nattribute dialect_options\n```", "```py\narg = my_object.dialect_options['postgresql']['where']\n```", "```py\nmethod distinct() \u2192 ColumnOperators\n```", "```py\nmethod endswith(other: Any, escape: str | None = None, autoescape: bool = False) \u2192 ColumnOperators\n```", "```py\ncolumn LIKE '%' || <other>\n```", "```py\nstmt = select(sometable).\\\n    where(sometable.c.column.endswith(\"foobar\"))\n```", "```py\n    somecolumn.endswith(\"foo%bar\", autoescape=True)\n    ```", "```py\n    somecolumn LIKE '%' || :param ESCAPE '/'\n    ```", "```py\n    somecolumn.endswith(\"foo/%bar\", escape=\"^\")\n    ```", "```py\n    somecolumn LIKE '%' || :param ESCAPE '^'\n    ```", "```py\n    somecolumn.endswith(\"foo%bar^bat\", escape=\"^\", autoescape=True)\n    ```", "```py\nattribute expression\n```", "```py\nattribute foreign_keys: Set[ForeignKey] = frozenset({})\n```", "```py\nmethod get_children(*, column_tables=False, **kw)\n```", "```py\nmethod icontains(other: Any, **kw: Any) \u2192 ColumnOperators\n```", "```py\nlower(column) LIKE '%' || lower(<other>) || '%'\n```", "```py\nstmt = select(sometable).\\\n    where(sometable.c.column.icontains(\"foobar\"))\n```", "```py\n    somecolumn.icontains(\"foo%bar\", autoescape=True)\n    ```", "```py\n    lower(somecolumn) LIKE '%' || lower(:param) || '%' ESCAPE '/'\n    ```", "```py\n    somecolumn.icontains(\"foo/%bar\", escape=\"^\")\n    ```", "```py\n    lower(somecolumn) LIKE '%' || lower(:param) || '%' ESCAPE '^'\n    ```", "```py\n    somecolumn.icontains(\"foo%bar^bat\", escape=\"^\", autoescape=True)\n    ```", "```py\nmethod iendswith(other: Any, escape: str | None = None, autoescape: bool = False) \u2192 ColumnOperators\n```", "```py\nlower(column) LIKE '%' || lower(<other>)\n```", "```py\nstmt = select(sometable).\\\n    where(sometable.c.column.iendswith(\"foobar\"))\n```", "```py\n    somecolumn.iendswith(\"foo%bar\", autoescape=True)\n    ```", "```py\n    lower(somecolumn) LIKE '%' || lower(:param) ESCAPE '/'\n    ```", "```py\n    somecolumn.iendswith(\"foo/%bar\", escape=\"^\")\n    ```", "```py\n    lower(somecolumn) LIKE '%' || lower(:param) ESCAPE '^'\n    ```", "```py\n    somecolumn.endswith(\"foo%bar^bat\", escape=\"^\", autoescape=True)\n    ```", "```py\nmethod ilike(other: Any, escape: str | None = None) \u2192 ColumnOperators\n```", "```py\nlower(a) LIKE lower(other)\n```", "```py\na ILIKE other\n```", "```py\nstmt = select(sometable).\\\n    where(sometable.c.column.ilike(\"%foobar%\"))\n```", "```py\n    somecolumn.ilike(\"foo/%bar\", escape=\"/\")\n    ```", "```py\nmethod in_(other: Any) \u2192 ColumnOperators\n```", "```py\n    stmt.where(column.in_([1, 2, 3]))\n    ```", "```py\n    WHERE COL IN (?, ?, ?)\n    ```", "```py\n    from sqlalchemy import tuple_\n    stmt.where(tuple_(col1, col2).in_([(1, 10), (2, 20), (3, 30)]))\n    ```", "```py\n    stmt.where(column.in_([]))\n    ```", "```py\n    WHERE col IN (SELECT 1 FROM (SELECT 1) WHERE 1!=1)\n    ```", "```py\n    stmt.where(column.in_(bindparam('value', expanding=True)))\n    ```", "```py\n    WHERE COL IN ([EXPANDING_value])\n    ```", "```py\n    connection.execute(stmt, {\"value\": [1, 2, 3]})\n    ```", "```py\n    WHERE COL IN (?, ?, ?)\n    ```", "```py\n    WHERE COL IN (SELECT 1 FROM (SELECT 1) WHERE 1!=1)\n    ```", "```py\n    stmt.where(\n        column.in_(\n            select(othertable.c.y).\n            where(table.c.x == othertable.c.x)\n        )\n    )\n    ```", "```py\n    WHERE COL IN (SELECT othertable.y\n    FROM othertable WHERE othertable.x = table.x)\n    ```", "```py\nattribute index: bool | None\n```", "```py\nattribute info\n```", "```py\nattribute inherit_cache: bool | None = True\n```", "```py\nmethod is_(other: Any) \u2192 ColumnOperators\n```", "```py\nmethod is_distinct_from(other: Any) \u2192 ColumnOperators\n```", "```py\nmethod is_not(other: Any) \u2192 ColumnOperators\n```", "```py\nmethod is_not_distinct_from(other: Any) \u2192 ColumnOperators\n```", "```py\nmethod isnot(other: Any) \u2192 ColumnOperators\n```", "```py\nmethod isnot_distinct_from(other: Any) \u2192 ColumnOperators\n```", "```py\nmethod istartswith(other: Any, escape: str | None = None, autoescape: bool = False) \u2192 ColumnOperators\n```", "```py\nlower(column) LIKE lower(<other>) || '%'\n```", "```py\nstmt = select(sometable).\\\n    where(sometable.c.column.istartswith(\"foobar\"))\n```", "```py\n    somecolumn.istartswith(\"foo%bar\", autoescape=True)\n    ```", "```py\n    lower(somecolumn) LIKE lower(:param) || '%' ESCAPE '/'\n    ```", "```py\n    somecolumn.istartswith(\"foo/%bar\", escape=\"^\")\n    ```", "```py\n    lower(somecolumn) LIKE lower(:param) || '%' ESCAPE '^'\n    ```", "```py\n    somecolumn.istartswith(\"foo%bar^bat\", escape=\"^\", autoescape=True)\n    ```", "```py\nattribute key: str = None\n```", "```py\nattribute kwargs\n```", "```py\nmethod label(name: str | None) \u2192 Label[_T]\n```", "```py\nmethod like(other: Any, escape: str | None = None) \u2192 ColumnOperators\n```", "```py\na LIKE other\n```", "```py\nstmt = select(sometable).\\\n    where(sometable.c.column.like(\"%foobar%\"))\n```", "```py\n    somecolumn.like(\"foo/%bar\", escape=\"/\")\n    ```", "```py\nmethod match(other: Any, **kwargs: Any) \u2192 ColumnOperators\n```", "```py\nmethod not_ilike(other: Any, escape: str | None = None) \u2192 ColumnOperators\n```", "```py\nmethod not_in(other: Any) \u2192 ColumnOperators\n```", "```py\nmethod not_like(other: Any, escape: str | None = None) \u2192 ColumnOperators\n```", "```py\nmethod notilike(other: Any, escape: str | None = None) \u2192 ColumnOperators\n```", "```py\nmethod notin_(other: Any) \u2192 ColumnOperators\n```", "```py\nmethod notlike(other: Any, escape: str | None = None) \u2192 ColumnOperators\n```", "```py\nmethod nulls_first() \u2192 ColumnOperators\n```", "```py\nmethod nulls_last() \u2192 ColumnOperators\n```", "```py\nmethod nullsfirst() \u2192 ColumnOperators\n```", "```py\nmethod nullslast() \u2192 ColumnOperators\n```", "```py\nmethod op(opstring: str, precedence: int = 0, is_comparison: bool = False, return_type: Type[TypeEngine[Any]] | TypeEngine[Any] | None = None, python_impl: Callable[..., Any] | None = None) \u2192 Callable[[Any], Operators]\n```", "```py\nsomecolumn.op(\"*\")(5)\n```", "```py\nsomecolumn * 5\n```", "```py\nsomecolumn.op('&')(0xff)\n```", "```py\n    >>> expr = column('x').op('+', python_impl=lambda a, b: a + b)('y')\n    ```", "```py\n    >>> expr.operator(5, 10)\n    15\n    ```", "```py\nmethod operate(op: OperatorType, *other: Any, **kwargs: Any) \u2192 ColumnElement[Any]\n```", "```py\nclass MyComparator(ColumnOperators):\n    def operate(self, op, other, **kwargs):\n        return op(func.lower(self), func.lower(other), **kwargs)\n```", "```py\nmethod params(*optionaldict, **kwargs)\n```", "```py\n>>> clause = column('x') + bindparam('foo')\n>>> print(clause.compile().params)\n{'foo':None}\n>>> print(clause.params({'foo':7}).compile().params)\n{'foo':7}\n```", "```py\nattribute proxy_set: util.generic_fn_descriptor[FrozenSet[Any]]\n```", "```py\nmethod references(column: Column[Any]) \u2192 bool\n```", "```py\nmethod regexp_match(pattern: Any, flags: str | None = None) \u2192 ColumnOperators\n```", "```py\nstmt = select(table.c.some_column).where(\n    table.c.some_column.regexp_match('^(b|c)')\n)\n```", "```py\nmethod regexp_replace(pattern: Any, replacement: Any, flags: str | None = None) \u2192 ColumnOperators\n```", "```py\nstmt = select(\n    table.c.some_column.regexp_replace(\n        'b(..)',\n        'XY',\n        flags='g'\n    )\n)\n```", "```py\nmethod reverse_operate(op: OperatorType, other: Any, **kwargs: Any) \u2192 ColumnElement[Any]\n```", "```py\nmethod self_group(against: OperatorType | None = None) \u2192 ColumnElement[Any]\n```", "```py\nmethod shares_lineage(othercolumn: ColumnElement[Any]) \u2192 bool\n```", "```py\nmethod startswith(other: Any, escape: str | None = None, autoescape: bool = False) \u2192 ColumnOperators\n```", "```py\ncolumn LIKE <other> || '%'\n```", "```py\nstmt = select(sometable).\\\n    where(sometable.c.column.startswith(\"foobar\"))\n```", "```py\n    somecolumn.startswith(\"foo%bar\", autoescape=True)\n    ```", "```py\n    somecolumn LIKE :param || '%' ESCAPE '/'\n    ```", "```py\n    somecolumn.startswith(\"foo/%bar\", escape=\"^\")\n    ```", "```py\n    somecolumn LIKE :param || '%' ESCAPE '^'\n    ```", "```py\n    somecolumn.startswith(\"foo%bar^bat\", escape=\"^\", autoescape=True)\n    ```", "```py\nattribute timetuple: Literal[None] = None\n```", "```py\nattribute unique: bool | None\n```", "```py\nmethod unique_params(*optionaldict, **kwargs)\n```", "```py\nclass sqlalchemy.schema.MetaData\n```", "```py\nmethod __init__(schema: str | None = None, quote_schema: bool | None = None, naming_convention: _NamingSchemaParameter | None = None, info: _InfoType | None = None) \u2192 None\n```", "```py\nmethod clear() \u2192 None\n```", "```py\nmethod create_all(bind: _CreateDropBind, tables: _typing_Sequence[Table] | None = None, checkfirst: bool = True) \u2192 None\n```", "```py\nmethod drop_all(bind: _CreateDropBind, tables: _typing_Sequence[Table] | None = None, checkfirst: bool = True) \u2192 None\n```", "```py\nmethod reflect(bind: Engine | Connection, schema: str | None = None, views: bool = False, only: _typing_Sequence[str] | Callable[[str, MetaData], bool] | None = None, extend_existing: bool = False, autoload_replace: bool = True, resolve_fks: bool = True, **dialect_kwargs: Any) \u2192 None\n```", "```py\nmethod remove(table: Table) \u2192 None\n```", "```py\nattribute sorted_tables\n```", "```py\nattribute tables: util.FacadeDict[str, Table]\n```", "```py\nclass sqlalchemy.schema.SchemaConst\n```", "```py\nattribute BLANK_SCHEMA = 2\n```", "```py\nattribute NULL_UNSPECIFIED = 3\n```", "```py\nattribute RETAIN_SCHEMA = 1\n```", "```py\nclass sqlalchemy.schema.SchemaItem\n```", "```py\nattribute info\n```", "```py\nfunction sqlalchemy.schema.insert_sentinel(name: str | None = None, type_: _TypeEngineArgument[_T] | None = None, *, default: Any | None = None, omit_from_statements: bool = True) \u2192 Column[Any]\n```", "```py\nclass sqlalchemy.schema.Table\n```", "```py\nmytable = Table(\n    \"mytable\", metadata,\n    Column('mytable_id', Integer, primary_key=True),\n    Column('value', String(50))\n)\n```", "```py\nmethod __init__(name: str, metadata: MetaData, *args: SchemaItem, schema: str | Literal[SchemaConst.BLANK_SCHEMA] | None = None, quote: bool | None = None, quote_schema: bool | None = None, autoload_with: Engine | Connection | None = None, autoload_replace: bool = True, keep_existing: bool = False, extend_existing: bool = False, resolve_fks: bool = True, include_columns: Collection[str] | None = None, implicit_returning: bool = True, comment: str | None = None, info: Dict[Any, Any] | None = None, listeners: _typing_Sequence[Tuple[str, Callable[..., Any]]] | None = None, prefixes: _typing_Sequence[str] | None = None, _extend_on: Set[Table] | None = None, _no_init: bool = True, **kw: Any) \u2192 None\n```", "```py\n    Table(\"mytable\", metadata,\n                Column('y', Integer),\n                extend_existing=True,\n                autoload_with=engine\n            )\n    ```", "```py\n    def listen_for_reflect(table, column_info):\n        \"handle the column reflection event\"\n        # ...\n\n    t = Table(\n        'sometable',\n        autoload_with=engine,\n        listeners=[\n            ('column_reflect', listen_for_reflect)\n        ])\n    ```", "```py\nmethod add_is_dependent_on(table: Table) \u2192 None\n```", "```py\nmethod alias(name: str | None = None, flat: bool = False) \u2192 NamedFromClause\n```", "```py\na2 = some_table.alias('a2')\n```", "```py\nmethod append_column(column: ColumnClause[Any], replace_existing: bool = False) \u2192 None\n```", "```py\nmethod append_constraint(constraint: Index | Constraint) \u2192 None\n```", "```py\nclassmethod argument_for(dialect_name, argument_name, default)\n```", "```py\nIndex.argument_for(\"mydialect\", \"length\", None)\n\nsome_index = Index('a', 'b', mydialect_length=5)\n```", "```py\nattribute autoincrement_column\n```", "```py\nattribute c\n```", "```py\nattribute columns\n```", "```py\nselect(mytable).where(mytable.c.somecolumn == 5)\n```", "```py\nmethod compare(other: ClauseElement, **kw: Any) \u2192 bool\n```", "```py\nmethod compile(bind: _HasDialect | None = None, dialect: Dialect | None = None, **kw: Any) \u2192 Compiled\n```", "```py\n    from sqlalchemy.sql import table, column, select\n\n    t = table('t', column('x'))\n\n    s = select(t).where(t.c.x == 5)\n\n    print(s.compile(compile_kwargs={\"literal_binds\": True}))\n    ```", "```py\nattribute constraints: Set[Constraint]\n```", "```py\nmethod corresponding_column(column: KeyedColumnElement[Any], require_embedded: bool = False) \u2192 KeyedColumnElement[Any] | None\n```", "```py\nmethod create(bind: _CreateDropBind, checkfirst: bool = False) \u2192 None\n```", "```py\nmethod delete() \u2192 Delete\n```", "```py\ntable.delete().where(table.c.id==7)\n```", "```py\nattribute description\n```", "```py\nattribute dialect_kwargs\n```", "```py\nattribute dialect_options\n```", "```py\narg = my_object.dialect_options['postgresql']['where']\n```", "```py\nmethod drop(bind: _CreateDropBind, checkfirst: bool = False) \u2192 None\n```", "```py\nattribute entity_namespace\n```", "```py\nstmt.filter_by(address='some address')\n```", "```py\nattribute exported_columns\n```", "```py\nattribute foreign_key_constraints\n```", "```py\nattribute foreign_keys\n```", "```py\nmethod get_children(*, omit_attrs: Tuple[str, ...] = (), **kw: Any) \u2192 Iterable[HasTraverseInternals]\n```", "```py\nattribute implicit_returning = False\n```", "```py\nattribute indexes: Set[Index]\n```", "```py\nattribute info\n```", "```py\nattribute inherit_cache: bool | None = None\n```", "```py\nmethod insert() \u2192 Insert\n```", "```py\ntable.insert().values(name='foo')\n```", "```py\nmethod is_derived_from(fromclause: FromClause | None) \u2192 bool\n```", "```py\nmethod join(right: _FromClauseArgument, onclause: _ColumnExpressionArgument[bool] | None = None, isouter: bool = False, full: bool = False) \u2192 Join\n```", "```py\nfrom sqlalchemy import join\n\nj = user_table.join(address_table,\n                user_table.c.id == address_table.c.user_id)\nstmt = select(user_table).select_from(j)\n```", "```py\nSELECT user.id, user.name FROM user\nJOIN address ON user.id = address.user_id\n```", "```py\nattribute key\n```", "```py\nattribute kwargs\n```", "```py\nmethod lateral(name: str | None = None) \u2192 LateralFromClause\n```", "```py\nmethod outerjoin(right: _FromClauseArgument, onclause: _ColumnExpressionArgument[bool] | None = None, full: bool = False) \u2192 Join\n```", "```py\nfrom sqlalchemy import outerjoin\n\nj = user_table.outerjoin(address_table,\n                user_table.c.id == address_table.c.user_id)\n```", "```py\nj = user_table.join(\n    address_table,\n    user_table.c.id == address_table.c.user_id,\n    isouter=True)\n```", "```py\nmethod params(*optionaldict, **kwargs)\n```", "```py\n>>> clause = column('x') + bindparam('foo')\n>>> print(clause.compile().params)\n{'foo':None}\n>>> print(clause.params({'foo':7}).compile().params)\n{'foo':7}\n```", "```py\nattribute primary_key\n```", "```py\nmethod replace_selectable(old: FromClause, alias: Alias) \u2192 Self\n```", "```py\nattribute schema: str | None = None\n```", "```py\nmethod select() \u2192 Select\n```", "```py\nstmt = some_table.select().where(some_table.c.id == 5)\n```", "```py\nmethod self_group(against: OperatorType | None = None) \u2192 ClauseElement\n```", "```py\nmethod table_valued() \u2192 TableValuedColumn[Any]\n```", "```py\n>>> from sqlalchemy import select, column, func, table\n>>> a = table(\"a\", column(\"id\"), column(\"x\"), column(\"y\"))\n>>> stmt = select(func.row_to_json(a.table_valued()))\n>>> print(stmt)\nSELECT  row_to_json(a)  AS  row_to_json_1\nFROM  a \n```", "```py\nmethod tablesample(sampling: float | Function[Any], name: str | None = None, seed: roles.ExpressionElementRole[Any] | None = None) \u2192 TableSample\n```", "```py\nmethod to_metadata(metadata: MetaData, schema: str | Literal[SchemaConst.RETAIN_SCHEMA] = SchemaConst.RETAIN_SCHEMA, referred_schema_fn: Callable[[Table, str | None, ForeignKeyConstraint, str | None], str | None] | None = None, name: str | None = None) \u2192 Table\n```", "```py\nm1 = MetaData()\n\nuser = Table('user', m1, Column('id', Integer, primary_key=True))\n\nm2 = MetaData()\nuser_copy = user.to_metadata(m2)\n```", "```py\n    m2 = MetaData(schema='newschema')\n\n    # user_copy_one will have \"newschema\" as the schema name\n    user_copy_one = user.to_metadata(m2, schema=None)\n\n    m3 = MetaData()  # schema defaults to None\n\n    # user_copy_two will have None as the schema name\n    user_copy_two = user.to_metadata(m3, schema=None)\n    ```", "```py\n    def referred_schema_fn(table, to_schema,\n                                    constraint, referred_schema):\n        if referred_schema == 'base_tables':\n            return referred_schema\n        else:\n            return to_schema\n\n    new_table = table.to_metadata(m2, schema=\"alt_schema\",\n                            referred_schema_fn=referred_schema_fn)\n    ```", "```py\nmethod tometadata(metadata: MetaData, schema: str | Literal[SchemaConst.RETAIN_SCHEMA] = SchemaConst.RETAIN_SCHEMA, referred_schema_fn: Callable[[Table, str | None, ForeignKeyConstraint, str | None], str | None] | None = None, name: str | None = None) \u2192 Table\n```", "```py\nmethod unique_params(*optionaldict, **kwargs)\n```", "```py\nmethod update() \u2192 Update\n```", "```py\ntable.update().where(table.c.id==7).values(name='foo')\n```", "```py\n>>> for t in metadata_obj.sorted_tables:\n...     print(t.name)\nuser\nuser_preference\ninvoice\ninvoice_item\n```", "```py\nemployees = Table(\n    \"employees\",\n    metadata_obj,\n    Column(\"employee_id\", Integer, primary_key=True),\n    Column(\"employee_name\", String(60), nullable=False),\n    Column(\"employee_dept\", Integer, ForeignKey(\"departments.department_id\")),\n)\n```", "```py\n# access the column \"employee_id\":\nemployees.columns.employee_id\n\n# or just\nemployees.c.employee_id\n\n# via string\nemployees.c[\"employee_id\"]\n\n# a tuple of columns may be returned using multiple strings\n# (new in 2.0)\nemp_id, name, type = employees.c[\"employee_id\", \"name\", \"type\"]\n\n# iterate through all columns\nfor c in employees.c:\n    print(c)\n\n# get the table's primary key columns\nfor primary_key in employees.primary_key:\n    print(primary_key)\n\n# get the table's foreign key objects:\nfor fkey in employees.foreign_keys:\n    print(fkey)\n\n# access the table's MetaData:\nemployees.metadata\n\n# access a column's name, type, nullable, primary key, foreign key\nemployees.c.employee_id.name\nemployees.c.employee_id.type\nemployees.c.employee_id.nullable\nemployees.c.employee_id.primary_key\nemployees.c.employee_dept.foreign_keys\n\n# get the \"key\" of a column, which defaults to its name, but can\n# be any user-defined string:\nemployees.c.employee_name.key\n\n# access a column's table:\nemployees.c.employee_id.table is employees\n\n# get the table related by a foreign key\nlist(employees.c.employee_dept.foreign_keys)[0].column.table\n```", "```py\nengine = create_engine(\"sqlite:///:memory:\")\n\nmetadata_obj = MetaData()\n\nuser = Table(\n    \"user\",\n    metadata_obj,\n    Column(\"user_id\", Integer, primary_key=True),\n    Column(\"user_name\", String(16), nullable=False),\n    Column(\"email_address\", String(60), key=\"email\"),\n    Column(\"nickname\", String(50), nullable=False),\n)\n\nuser_prefs = Table(\n    \"user_prefs\",\n    metadata_obj,\n    Column(\"pref_id\", Integer, primary_key=True),\n    Column(\"user_id\", Integer, ForeignKey(\"user.user_id\"), nullable=False),\n    Column(\"pref_name\", String(40), nullable=False),\n    Column(\"pref_value\", String(100)),\n)\n\nmetadata_obj.create_all(engine)\nPRAGMA  table_info(user){}\nCREATE  TABLE  user(\n  user_id  INTEGER  NOT  NULL  PRIMARY  KEY,\n  user_name  VARCHAR(16)  NOT  NULL,\n  email_address  VARCHAR(60),\n  nickname  VARCHAR(50)  NOT  NULL\n)\nPRAGMA  table_info(user_prefs){}\nCREATE  TABLE  user_prefs(\n  pref_id  INTEGER  NOT  NULL  PRIMARY  KEY,\n  user_id  INTEGER  NOT  NULL  REFERENCES  user(user_id),\n  pref_name  VARCHAR(40)  NOT  NULL,\n  pref_value  VARCHAR(100)\n) \n```", "```py\nengine = create_engine(\"sqlite:///:memory:\")\n\nmetadata_obj = MetaData()\n\nemployees = Table(\n    \"employees\",\n    metadata_obj,\n    Column(\"employee_id\", Integer, primary_key=True),\n    Column(\"employee_name\", String(60), nullable=False, key=\"name\"),\n    Column(\"employee_dept\", Integer, ForeignKey(\"departments.department_id\")),\n)\nemployees.create(engine)\nCREATE  TABLE  employees(\n  employee_id  SERIAL  NOT  NULL  PRIMARY  KEY,\n  employee_name  VARCHAR(60)  NOT  NULL,\n  employee_dept  INTEGER  REFERENCES  departments(department_id)\n)\n{} \n```", "```py\nemployees.drop(engine)\nDROP  TABLE  employees\n{} \n```", "```py\nemployees.create(engine, checkfirst=True)\nemployees.drop(engine, checkfirst=False)\n```", "```py\nmetadata_obj = MetaData()\n\nfinancial_info = Table(\n    \"financial_info\",\n    metadata_obj,\n    Column(\"id\", Integer, primary_key=True),\n    Column(\"value\", String(100), nullable=False),\n    schema=\"remote_banks\",\n)\n```", "```py\n>>> print(select(financial_info))\nSELECT  remote_banks.financial_info.id,  remote_banks.financial_info.value\nFROM  remote_banks.financial_info \n```", "```py\n>>> metadata_obj.tables[\"remote_banks.financial_info\"]\nTable('financial_info', MetaData(),\nColumn('id', Integer(), table=<financial_info>, primary_key=True, nullable=False),\nColumn('value', String(length=100), table=<financial_info>, nullable=False),\nschema='remote_banks')\n```", "```py\ncustomer = Table(\n    \"customer\",\n    metadata_obj,\n    Column(\"id\", Integer, primary_key=True),\n    Column(\"financial_info_id\", ForeignKey(\"remote_banks.financial_info.id\")),\n    schema=\"remote_banks\",\n)\n```", "```py\nschema = \"dbo.scott\"\n```", "```py\nmetadata_obj = MetaData(schema=\"remote_banks\")\n\nfinancial_info = Table(\n    \"financial_info\",\n    metadata_obj,\n    Column(\"id\", Integer, primary_key=True),\n    Column(\"value\", String(100), nullable=False),\n)\n```", "```py\nmetadata_obj.tables[\"remote_banks.financial_info\"]\n```", "```py\n# either will work:\n\nrefers_to_financial_info = Table(\n    \"refers_to_financial_info\",\n    metadata_obj,\n    Column(\"id\", Integer, primary_key=True),\n    Column(\"fiid\", ForeignKey(\"financial_info.id\")),\n)\n\n# or\n\nrefers_to_financial_info = Table(\n    \"refers_to_financial_info\",\n    metadata_obj,\n    Column(\"id\", Integer, primary_key=True),\n    Column(\"fiid\", ForeignKey(\"remote_banks.financial_info.id\")),\n)\n```", "```py\nfrom sqlalchemy import BLANK_SCHEMA\n\nmetadata_obj = MetaData(schema=\"remote_banks\")\n\nfinancial_info = Table(\n    \"financial_info\",\n    metadata_obj,\n    Column(\"id\", Integer, primary_key=True),\n    Column(\"value\", String(100), nullable=False),\n    schema=BLANK_SCHEMA,  # will not use \"remote_banks\"\n)\n```", "```py\nfrom sqlalchemy import event\nfrom sqlalchemy import create_engine\n\nengine = create_engine(\"oracle+cx_oracle://scott:tiger@tsn_name\")\n\n@event.listens_for(engine, \"connect\", insert=True)\ndef set_current_schema(dbapi_connection, connection_record):\n    cursor_obj = dbapi_connection.cursor()\n    cursor_obj.execute(\"ALTER SESSION SET CURRENT_SCHEMA=%s\" % schema_name)\n    cursor_obj.close()\n```", "```py\nmetadata_obj = MetaData(schema=\"remote_banks\")\n\nfinancial_info = Table(\n    \"financial_info\",\n    metadata_obj,\n    Column(\"id\", Integer, primary_key=True),\n    Column(\"value\", String(100), nullable=False),\n)\n```", "```py\nmetadata_obj.tables[\"remote_banks.financial_info\"]\n```", "```py\n# either will work:\n\nrefers_to_financial_info = Table(\n    \"refers_to_financial_info\",\n    metadata_obj,\n    Column(\"id\", Integer, primary_key=True),\n    Column(\"fiid\", ForeignKey(\"financial_info.id\")),\n)\n\n# or\n\nrefers_to_financial_info = Table(\n    \"refers_to_financial_info\",\n    metadata_obj,\n    Column(\"id\", Integer, primary_key=True),\n    Column(\"fiid\", ForeignKey(\"remote_banks.financial_info.id\")),\n)\n```", "```py\nfrom sqlalchemy import BLANK_SCHEMA\n\nmetadata_obj = MetaData(schema=\"remote_banks\")\n\nfinancial_info = Table(\n    \"financial_info\",\n    metadata_obj,\n    Column(\"id\", Integer, primary_key=True),\n    Column(\"value\", String(100), nullable=False),\n    schema=BLANK_SCHEMA,  # will not use \"remote_banks\"\n)\n```", "```py\nfrom sqlalchemy import event\nfrom sqlalchemy import create_engine\n\nengine = create_engine(\"oracle+cx_oracle://scott:tiger@tsn_name\")\n\n@event.listens_for(engine, \"connect\", insert=True)\ndef set_current_schema(dbapi_connection, connection_record):\n    cursor_obj = dbapi_connection.cursor()\n    cursor_obj.execute(\"ALTER SESSION SET CURRENT_SCHEMA=%s\" % schema_name)\n    cursor_obj.close()\n```", "```py\naddresses = Table(\n    \"engine_email_addresses\",\n    metadata_obj,\n    Column(\"address_id\", Integer, primary_key=True),\n    Column(\"remote_user_id\", Integer, ForeignKey(users.c.user_id)),\n    Column(\"email_address\", String(20)),\n    mysql_engine=\"InnoDB\",\n)\n```", "```py\nattribute sqlalchemy.schema.BLANK_SCHEMA\n```", "```py\nattribute sqlalchemy.schema.RETAIN_SCHEMA\n```", "```py\nclass sqlalchemy.schema.Column\n```", "```py\nmethod __eq__(other: Any) \u2192 ColumnOperators\n```", "```py\nmethod __init__(_Column__name_pos: str | _TypeEngineArgument[_T] | SchemaEventTarget | None = None, _Column__type_pos: _TypeEngineArgument[_T] | SchemaEventTarget | None = None, *args: SchemaEventTarget, name: str | None = None, type_: _TypeEngineArgument[_T] | None = None, autoincrement: _AutoIncrementType = 'auto', default: Any | None = None, doc: str | None = None, key: str | None = None, index: bool | None = None, unique: bool | None = None, info: _InfoType | None = None, nullable: bool | Literal[SchemaConst.NULL_UNSPECIFIED] | None = SchemaConst.NULL_UNSPECIFIED, onupdate: Any | None = None, primary_key: bool = False, server_default: _ServerDefaultArgument | None = None, server_onupdate: FetchedValue | None = None, quote: bool | None = None, system: bool = False, comment: str | None = None, insert_sentinel: bool = False, _omit_from_statements: bool = False, _proxies: Any | None = None, **dialect_kwargs: Any)\n```", "```py\n    # use a type with arguments\n    Column('data', String(50))\n\n    # use no arguments\n    Column('level', Integer)\n    ```", "```py\n        # turn on autoincrement for this column despite\n        # the ForeignKey()\n        Column('id', ForeignKey('other.id'),\n                    primary_key=True, autoincrement='ignore_fk')\n        ```", "```py\n    Table(\n        \"some_table\",\n        metadata,\n        Column(\"x\", Integer),\n        Index(\"ix_some_table_x\", \"x\")\n    )\n    ```", "```py\n    Column('x', Text, server_default=\"val\")\n\n    x TEXT DEFAULT 'val'\n    ```", "```py\n    Column('y', DateTime, server_default=text('NOW()'))\n\n    y DATETIME DEFAULT NOW()\n    ```", "```py\n    from sqlalchemy import create_engine\n    from sqlalchemy import Table, Column, MetaData, ARRAY, Text\n    from sqlalchemy.dialects.postgresql import array\n\n    engine = create_engine(\n        'postgresql+psycopg2://scott:tiger@localhost/mydatabase'\n    )\n    metadata_obj = MetaData()\n    tbl = Table(\n            \"foo\",\n            metadata_obj,\n            Column(\"bar\",\n                   ARRAY(Text),\n                   server_default=array([\"biz\", \"bang\", \"bash\"])\n                   )\n    )\n    metadata_obj.create_all(engine)\n    ```", "```py\n    CREATE TABLE foo (\n        bar TEXT[] DEFAULT ARRAY['biz', 'bang', 'bash']\n    )\n    ```", "```py\n    Table(\n        \"some_table\",\n        metadata,\n        Column(\"x\", Integer),\n        UniqueConstraint(\"x\")\n    )\n    ```", "```py\nmethod __le__(other: Any) \u2192 ColumnOperators\n```", "```py\nmethod __lt__(other: Any) \u2192 ColumnOperators\n```", "```py\nmethod __ne__(other: Any) \u2192 ColumnOperators\n```", "```py\nmethod all_() \u2192 ColumnOperators\n```", "```py\nattribute anon_key_label\n```", "```py\nattribute anon_label\n```", "```py\nmethod any_() \u2192 ColumnOperators\n```", "```py\nclassmethod argument_for(dialect_name, argument_name, default)\n```", "```py\nIndex.argument_for(\"mydialect\", \"length\", None)\n\nsome_index = Index('a', 'b', mydialect_length=5)\n```", "```py\nmethod asc() \u2192 ColumnOperators\n```", "```py\nmethod between(cleft: Any, cright: Any, symmetric: bool = False) \u2192 ColumnOperators\n```", "```py\nmethod bitwise_and(other: Any) \u2192 ColumnOperators\n```", "```py\nmethod bitwise_lshift(other: Any) \u2192 ColumnOperators\n```", "```py\nmethod bitwise_not() \u2192 ColumnOperators\n```", "```py\nmethod bitwise_or(other: Any) \u2192 ColumnOperators\n```", "```py\nmethod bitwise_rshift(other: Any) \u2192 ColumnOperators\n```", "```py\nmethod bitwise_xor(other: Any) \u2192 ColumnOperators\n```", "```py\nmethod bool_op(opstring: str, precedence: int = 0, python_impl: Callable[[...], Any] | None = None) \u2192 Callable[[Any], Operators]\n```", "```py\nmethod cast(type_: _TypeEngineArgument[_OPT]) \u2192 Cast[_OPT]\n```", "```py\nmethod collate(collation: str) \u2192 ColumnOperators\n```", "```py\nmethod compare(other: ClauseElement, **kw: Any) \u2192 bool\n```", "```py\nmethod compile(bind: _HasDialect | None = None, dialect: Dialect | None = None, **kw: Any) \u2192 Compiled\n```", "```py\n    from sqlalchemy.sql import table, column, select\n\n    t = table('t', column('x'))\n\n    s = select(t).where(t.c.x == 5)\n\n    print(s.compile(compile_kwargs={\"literal_binds\": True}))\n    ```", "```py\nmethod concat(other: Any) \u2192 ColumnOperators\n```", "```py\nmethod contains(other: Any, **kw: Any) \u2192 ColumnOperators\n```", "```py\ncolumn LIKE '%' || <other> || '%'\n```", "```py\nstmt = select(sometable).\\\n    where(sometable.c.column.contains(\"foobar\"))\n```", "```py\n    somecolumn.contains(\"foo%bar\", autoescape=True)\n    ```", "```py\n    somecolumn LIKE '%' || :param || '%' ESCAPE '/'\n    ```", "```py\n    somecolumn.contains(\"foo/%bar\", escape=\"^\")\n    ```", "```py\n    somecolumn LIKE '%' || :param || '%' ESCAPE '^'\n    ```", "```py\n    somecolumn.contains(\"foo%bar^bat\", escape=\"^\", autoescape=True)\n    ```", "```py\nmethod copy(**kw: Any) \u2192 Column[Any]\n```", "```py\nmethod desc() \u2192 ColumnOperators\n```", "```py\nattribute dialect_kwargs\n```", "```py\nattribute dialect_options\n```", "```py\narg = my_object.dialect_options['postgresql']['where']\n```", "```py\nmethod distinct() \u2192 ColumnOperators\n```", "```py\nmethod endswith(other: Any, escape: str | None = None, autoescape: bool = False) \u2192 ColumnOperators\n```", "```py\ncolumn LIKE '%' || <other>\n```", "```py\nstmt = select(sometable).\\\n    where(sometable.c.column.endswith(\"foobar\"))\n```", "```py\n    somecolumn.endswith(\"foo%bar\", autoescape=True)\n    ```", "```py\n    somecolumn LIKE '%' || :param ESCAPE '/'\n    ```", "```py\n    somecolumn.endswith(\"foo/%bar\", escape=\"^\")\n    ```", "```py\n    somecolumn LIKE '%' || :param ESCAPE '^'\n    ```", "```py\n    somecolumn.endswith(\"foo%bar^bat\", escape=\"^\", autoescape=True)\n    ```", "```py\nattribute expression\n```", "```py\nattribute foreign_keys: Set[ForeignKey] = frozenset({})\n```", "```py\nmethod get_children(*, column_tables=False, **kw)\n```", "```py\nmethod icontains(other: Any, **kw: Any) \u2192 ColumnOperators\n```", "```py\nlower(column) LIKE '%' || lower(<other>) || '%'\n```", "```py\nstmt = select(sometable).\\\n    where(sometable.c.column.icontains(\"foobar\"))\n```", "```py\n    somecolumn.icontains(\"foo%bar\", autoescape=True)\n    ```", "```py\n    lower(somecolumn) LIKE '%' || lower(:param) || '%' ESCAPE '/'\n    ```", "```py\n    somecolumn.icontains(\"foo/%bar\", escape=\"^\")\n    ```", "```py\n    lower(somecolumn) LIKE '%' || lower(:param) || '%' ESCAPE '^'\n    ```", "```py\n    somecolumn.icontains(\"foo%bar^bat\", escape=\"^\", autoescape=True)\n    ```", "```py\nmethod iendswith(other: Any, escape: str | None = None, autoescape: bool = False) \u2192 ColumnOperators\n```", "```py\nlower(column) LIKE '%' || lower(<other>)\n```", "```py\nstmt = select(sometable).\\\n    where(sometable.c.column.iendswith(\"foobar\"))\n```", "```py\n    somecolumn.iendswith(\"foo%bar\", autoescape=True)\n    ```", "```py\n    lower(somecolumn) LIKE '%' || lower(:param) ESCAPE '/'\n    ```", "```py\n    somecolumn.iendswith(\"foo/%bar\", escape=\"^\")\n    ```", "```py\n    lower(somecolumn) LIKE '%' || lower(:param) ESCAPE '^'\n    ```", "```py\n    somecolumn.endswith(\"foo%bar^bat\", escape=\"^\", autoescape=True)\n    ```", "```py\nmethod ilike(other: Any, escape: str | None = None) \u2192 ColumnOperators\n```", "```py\nlower(a) LIKE lower(other)\n```", "```py\na ILIKE other\n```", "```py\nstmt = select(sometable).\\\n    where(sometable.c.column.ilike(\"%foobar%\"))\n```", "```py\n    somecolumn.ilike(\"foo/%bar\", escape=\"/\")\n    ```", "```py\nmethod in_(other: Any) \u2192 ColumnOperators\n```", "```py\n    stmt.where(column.in_([1, 2, 3]))\n    ```", "```py\n    WHERE COL IN (?, ?, ?)\n    ```", "```py\n    from sqlalchemy import tuple_\n    stmt.where(tuple_(col1, col2).in_([(1, 10), (2, 20), (3, 30)]))\n    ```", "```py\n    stmt.where(column.in_([]))\n    ```", "```py\n    WHERE col IN (SELECT 1 FROM (SELECT 1) WHERE 1!=1)\n    ```", "```py\n    stmt.where(column.in_(bindparam('value', expanding=True)))\n    ```", "```py\n    WHERE COL IN ([EXPANDING_value])\n    ```", "```py\n    connection.execute(stmt, {\"value\": [1, 2, 3]})\n    ```", "```py\n    WHERE COL IN (?, ?, ?)\n    ```", "```py\n    WHERE COL IN (SELECT 1 FROM (SELECT 1) WHERE 1!=1)\n    ```", "```py\n    stmt.where(\n        column.in_(\n            select(othertable.c.y).\n            where(table.c.x == othertable.c.x)\n        )\n    )\n    ```", "```py\n    WHERE COL IN (SELECT othertable.y\n    FROM othertable WHERE othertable.x = table.x)\n    ```", "```py\nattribute index: bool | None\n```", "```py\nattribute info\n```", "```py\nattribute inherit_cache: bool | None = True\n```", "```py\nmethod is_(other: Any) \u2192 ColumnOperators\n```", "```py\nmethod is_distinct_from(other: Any) \u2192 ColumnOperators\n```", "```py\nmethod is_not(other: Any) \u2192 ColumnOperators\n```", "```py\nmethod is_not_distinct_from(other: Any) \u2192 ColumnOperators\n```", "```py\nmethod isnot(other: Any) \u2192 ColumnOperators\n```", "```py\nmethod isnot_distinct_from(other: Any) \u2192 ColumnOperators\n```", "```py\nmethod istartswith(other: Any, escape: str | None = None, autoescape: bool = False) \u2192 ColumnOperators\n```", "```py\nlower(column) LIKE lower(<other>) || '%'\n```", "```py\nstmt = select(sometable).\\\n    where(sometable.c.column.istartswith(\"foobar\"))\n```", "```py\n    somecolumn.istartswith(\"foo%bar\", autoescape=True)\n    ```", "```py\n    lower(somecolumn) LIKE lower(:param) || '%' ESCAPE '/'\n    ```", "```py\n    somecolumn.istartswith(\"foo/%bar\", escape=\"^\")\n    ```", "```py\n    lower(somecolumn) LIKE lower(:param) || '%' ESCAPE '^'\n    ```", "```py\n    somecolumn.istartswith(\"foo%bar^bat\", escape=\"^\", autoescape=True)\n    ```", "```py\nattribute key: str = None\n```", "```py\nattribute kwargs\n```", "```py\nmethod label(name: str | None) \u2192 Label[_T]\n```", "```py\nmethod like(other: Any, escape: str | None = None) \u2192 ColumnOperators\n```", "```py\na LIKE other\n```", "```py\nstmt = select(sometable).\\\n    where(sometable.c.column.like(\"%foobar%\"))\n```", "```py\n    somecolumn.like(\"foo/%bar\", escape=\"/\")\n    ```", "```py\nmethod match(other: Any, **kwargs: Any) \u2192 ColumnOperators\n```", "```py\nmethod not_ilike(other: Any, escape: str | None = None) \u2192 ColumnOperators\n```", "```py\nmethod not_in(other: Any) \u2192 ColumnOperators\n```", "```py\nmethod not_like(other: Any, escape: str | None = None) \u2192 ColumnOperators\n```", "```py\nmethod notilike(other: Any, escape: str | None = None) \u2192 ColumnOperators\n```", "```py\nmethod notin_(other: Any) \u2192 ColumnOperators\n```", "```py\nmethod notlike(other: Any, escape: str | None = None) \u2192 ColumnOperators\n```", "```py\nmethod nulls_first() \u2192 ColumnOperators\n```", "```py\nmethod nulls_last() \u2192 ColumnOperators\n```", "```py\nmethod nullsfirst() \u2192 ColumnOperators\n```", "```py\nmethod nullslast() \u2192 ColumnOperators\n```", "```py\nmethod op(opstring: str, precedence: int = 0, is_comparison: bool = False, return_type: Type[TypeEngine[Any]] | TypeEngine[Any] | None = None, python_impl: Callable[..., Any] | None = None) \u2192 Callable[[Any], Operators]\n```", "```py\nsomecolumn.op(\"*\")(5)\n```", "```py\nsomecolumn * 5\n```", "```py\nsomecolumn.op('&')(0xff)\n```", "```py\n    >>> expr = column('x').op('+', python_impl=lambda a, b: a + b)('y')\n    ```", "```py\n    >>> expr.operator(5, 10)\n    15\n    ```", "```py\nmethod operate(op: OperatorType, *other: Any, **kwargs: Any) \u2192 ColumnElement[Any]\n```", "```py\nclass MyComparator(ColumnOperators):\n    def operate(self, op, other, **kwargs):\n        return op(func.lower(self), func.lower(other), **kwargs)\n```", "```py\nmethod params(*optionaldict, **kwargs)\n```", "```py\n>>> clause = column('x') + bindparam('foo')\n>>> print(clause.compile().params)\n{'foo':None}\n>>> print(clause.params({'foo':7}).compile().params)\n{'foo':7}\n```", "```py\nattribute proxy_set: util.generic_fn_descriptor[FrozenSet[Any]]\n```", "```py\nmethod references(column: Column[Any]) \u2192 bool\n```", "```py\nmethod regexp_match(pattern: Any, flags: str | None = None) \u2192 ColumnOperators\n```", "```py\nstmt = select(table.c.some_column).where(\n    table.c.some_column.regexp_match('^(b|c)')\n)\n```", "```py\nmethod regexp_replace(pattern: Any, replacement: Any, flags: str | None = None) \u2192 ColumnOperators\n```", "```py\nstmt = select(\n    table.c.some_column.regexp_replace(\n        'b(..)',\n        'XY',\n        flags='g'\n    )\n)\n```", "```py\nmethod reverse_operate(op: OperatorType, other: Any, **kwargs: Any) \u2192 ColumnElement[Any]\n```", "```py\nmethod self_group(against: OperatorType | None = None) \u2192 ColumnElement[Any]\n```", "```py\nmethod shares_lineage(othercolumn: ColumnElement[Any]) \u2192 bool\n```", "```py\nmethod startswith(other: Any, escape: str | None = None, autoescape: bool = False) \u2192 ColumnOperators\n```", "```py\ncolumn LIKE <other> || '%'\n```", "```py\nstmt = select(sometable).\\\n    where(sometable.c.column.startswith(\"foobar\"))\n```", "```py\n    somecolumn.startswith(\"foo%bar\", autoescape=True)\n    ```", "```py\n    somecolumn LIKE :param || '%' ESCAPE '/'\n    ```", "```py\n    somecolumn.startswith(\"foo/%bar\", escape=\"^\")\n    ```", "```py\n    somecolumn LIKE :param || '%' ESCAPE '^'\n    ```", "```py\n    somecolumn.startswith(\"foo%bar^bat\", escape=\"^\", autoescape=True)\n    ```", "```py\nattribute timetuple: Literal[None] = None\n```", "```py\nattribute unique: bool | None\n```", "```py\nmethod unique_params(*optionaldict, **kwargs)\n```", "```py\nclass sqlalchemy.schema.MetaData\n```", "```py\nmethod __init__(schema: str | None = None, quote_schema: bool | None = None, naming_convention: _NamingSchemaParameter | None = None, info: _InfoType | None = None) \u2192 None\n```", "```py\nmethod clear() \u2192 None\n```", "```py\nmethod create_all(bind: _CreateDropBind, tables: _typing_Sequence[Table] | None = None, checkfirst: bool = True) \u2192 None\n```", "```py\nmethod drop_all(bind: _CreateDropBind, tables: _typing_Sequence[Table] | None = None, checkfirst: bool = True) \u2192 None\n```", "```py\nmethod reflect(bind: Engine | Connection, schema: str | None = None, views: bool = False, only: _typing_Sequence[str] | Callable[[str, MetaData], bool] | None = None, extend_existing: bool = False, autoload_replace: bool = True, resolve_fks: bool = True, **dialect_kwargs: Any) \u2192 None\n```", "```py\nmethod remove(table: Table) \u2192 None\n```", "```py\nattribute sorted_tables\n```", "```py\nattribute tables: util.FacadeDict[str, Table]\n```", "```py\nclass sqlalchemy.schema.SchemaConst\n```", "```py\nattribute BLANK_SCHEMA = 2\n```", "```py\nattribute NULL_UNSPECIFIED = 3\n```", "```py\nattribute RETAIN_SCHEMA = 1\n```", "```py\nclass sqlalchemy.schema.SchemaItem\n```", "```py\nattribute info\n```", "```py\nfunction sqlalchemy.schema.insert_sentinel(name: str | None = None, type_: _TypeEngineArgument[_T] | None = None, *, default: Any | None = None, omit_from_statements: bool = True) \u2192 Column[Any]\n```", "```py\nclass sqlalchemy.schema.Table\n```", "```py\nmytable = Table(\n    \"mytable\", metadata,\n    Column('mytable_id', Integer, primary_key=True),\n    Column('value', String(50))\n)\n```", "```py\nmethod __init__(name: str, metadata: MetaData, *args: SchemaItem, schema: str | Literal[SchemaConst.BLANK_SCHEMA] | None = None, quote: bool | None = None, quote_schema: bool | None = None, autoload_with: Engine | Connection | None = None, autoload_replace: bool = True, keep_existing: bool = False, extend_existing: bool = False, resolve_fks: bool = True, include_columns: Collection[str] | None = None, implicit_returning: bool = True, comment: str | None = None, info: Dict[Any, Any] | None = None, listeners: _typing_Sequence[Tuple[str, Callable[..., Any]]] | None = None, prefixes: _typing_Sequence[str] | None = None, _extend_on: Set[Table] | None = None, _no_init: bool = True, **kw: Any) \u2192 None\n```", "```py\n    Table(\"mytable\", metadata,\n                Column('y', Integer),\n                extend_existing=True,\n                autoload_with=engine\n            )\n    ```", "```py\n    def listen_for_reflect(table, column_info):\n        \"handle the column reflection event\"\n        # ...\n\n    t = Table(\n        'sometable',\n        autoload_with=engine,\n        listeners=[\n            ('column_reflect', listen_for_reflect)\n        ])\n    ```", "```py\nmethod add_is_dependent_on(table: Table) \u2192 None\n```", "```py\nmethod alias(name: str | None = None, flat: bool = False) \u2192 NamedFromClause\n```", "```py\na2 = some_table.alias('a2')\n```", "```py\nmethod append_column(column: ColumnClause[Any], replace_existing: bool = False) \u2192 None\n```", "```py\nmethod append_constraint(constraint: Index | Constraint) \u2192 None\n```", "```py\nclassmethod argument_for(dialect_name, argument_name, default)\n```", "```py\nIndex.argument_for(\"mydialect\", \"length\", None)\n\nsome_index = Index('a', 'b', mydialect_length=5)\n```", "```py\nattribute autoincrement_column\n```", "```py\nattribute c\n```", "```py\nattribute columns\n```", "```py\nselect(mytable).where(mytable.c.somecolumn == 5)\n```", "```py\nmethod compare(other: ClauseElement, **kw: Any) \u2192 bool\n```", "```py\nmethod compile(bind: _HasDialect | None = None, dialect: Dialect | None = None, **kw: Any) \u2192 Compiled\n```", "```py\n    from sqlalchemy.sql import table, column, select\n\n    t = table('t', column('x'))\n\n    s = select(t).where(t.c.x == 5)\n\n    print(s.compile(compile_kwargs={\"literal_binds\": True}))\n    ```", "```py\nattribute constraints: Set[Constraint]\n```", "```py\nmethod corresponding_column(column: KeyedColumnElement[Any], require_embedded: bool = False) \u2192 KeyedColumnElement[Any] | None\n```", "```py\nmethod create(bind: _CreateDropBind, checkfirst: bool = False) \u2192 None\n```", "```py\nmethod delete() \u2192 Delete\n```", "```py\ntable.delete().where(table.c.id==7)\n```", "```py\nattribute description\n```", "```py\nattribute dialect_kwargs\n```", "```py\nattribute dialect_options\n```", "```py\narg = my_object.dialect_options['postgresql']['where']\n```", "```py\nmethod drop(bind: _CreateDropBind, checkfirst: bool = False) \u2192 None\n```", "```py\nattribute entity_namespace\n```", "```py\nstmt.filter_by(address='some address')\n```", "```py\nattribute exported_columns\n```", "```py\nattribute foreign_key_constraints\n```", "```py\nattribute foreign_keys\n```", "```py\nmethod get_children(*, omit_attrs: Tuple[str, ...] = (), **kw: Any) \u2192 Iterable[HasTraverseInternals]\n```", "```py\nattribute implicit_returning = False\n```", "```py\nattribute indexes: Set[Index]\n```", "```py\nattribute info\n```", "```py\nattribute inherit_cache: bool | None = None\n```", "```py\nmethod insert() \u2192 Insert\n```", "```py\ntable.insert().values(name='foo')\n```", "```py\nmethod is_derived_from(fromclause: FromClause | None) \u2192 bool\n```", "```py\nmethod join(right: _FromClauseArgument, onclause: _ColumnExpressionArgument[bool] | None = None, isouter: bool = False, full: bool = False) \u2192 Join\n```", "```py\nfrom sqlalchemy import join\n\nj = user_table.join(address_table,\n                user_table.c.id == address_table.c.user_id)\nstmt = select(user_table).select_from(j)\n```", "```py\nSELECT user.id, user.name FROM user\nJOIN address ON user.id = address.user_id\n```", "```py\nattribute key\n```", "```py\nattribute kwargs\n```", "```py\nmethod lateral(name: str | None = None) \u2192 LateralFromClause\n```", "```py\nmethod outerjoin(right: _FromClauseArgument, onclause: _ColumnExpressionArgument[bool] | None = None, full: bool = False) \u2192 Join\n```", "```py\nfrom sqlalchemy import outerjoin\n\nj = user_table.outerjoin(address_table,\n                user_table.c.id == address_table.c.user_id)\n```", "```py\nj = user_table.join(\n    address_table,\n    user_table.c.id == address_table.c.user_id,\n    isouter=True)\n```", "```py\nmethod params(*optionaldict, **kwargs)\n```", "```py\n>>> clause = column('x') + bindparam('foo')\n>>> print(clause.compile().params)\n{'foo':None}\n>>> print(clause.params({'foo':7}).compile().params)\n{'foo':7}\n```", "```py\nattribute primary_key\n```", "```py\nmethod replace_selectable(old: FromClause, alias: Alias) \u2192 Self\n```", "```py\nattribute schema: str | None = None\n```", "```py\nmethod select() \u2192 Select\n```", "```py\nstmt = some_table.select().where(some_table.c.id == 5)\n```", "```py\nmethod self_group(against: OperatorType | None = None) \u2192 ClauseElement\n```", "```py\nmethod table_valued() \u2192 TableValuedColumn[Any]\n```", "```py\n>>> from sqlalchemy import select, column, func, table\n>>> a = table(\"a\", column(\"id\"), column(\"x\"), column(\"y\"))\n>>> stmt = select(func.row_to_json(a.table_valued()))\n>>> print(stmt)\nSELECT  row_to_json(a)  AS  row_to_json_1\nFROM  a \n```", "```py\nmethod tablesample(sampling: float | Function[Any], name: str | None = None, seed: roles.ExpressionElementRole[Any] | None = None) \u2192 TableSample\n```", "```py\nmethod to_metadata(metadata: MetaData, schema: str | Literal[SchemaConst.RETAIN_SCHEMA] = SchemaConst.RETAIN_SCHEMA, referred_schema_fn: Callable[[Table, str | None, ForeignKeyConstraint, str | None], str | None] | None = None, name: str | None = None) \u2192 Table\n```", "```py\nm1 = MetaData()\n\nuser = Table('user', m1, Column('id', Integer, primary_key=True))\n\nm2 = MetaData()\nuser_copy = user.to_metadata(m2)\n```", "```py\n    m2 = MetaData(schema='newschema')\n\n    # user_copy_one will have \"newschema\" as the schema name\n    user_copy_one = user.to_metadata(m2, schema=None)\n\n    m3 = MetaData()  # schema defaults to None\n\n    # user_copy_two will have None as the schema name\n    user_copy_two = user.to_metadata(m3, schema=None)\n    ```", "```py\n    def referred_schema_fn(table, to_schema,\n                                    constraint, referred_schema):\n        if referred_schema == 'base_tables':\n            return referred_schema\n        else:\n            return to_schema\n\n    new_table = table.to_metadata(m2, schema=\"alt_schema\",\n                            referred_schema_fn=referred_schema_fn)\n    ```", "```py\nmethod tometadata(metadata: MetaData, schema: str | Literal[SchemaConst.RETAIN_SCHEMA] = SchemaConst.RETAIN_SCHEMA, referred_schema_fn: Callable[[Table, str | None, ForeignKeyConstraint, str | None], str | None] | None = None, name: str | None = None) \u2192 Table\n```", "```py\nmethod unique_params(*optionaldict, **kwargs)\n```", "```py\nmethod update() \u2192 Update\n```", "```py\ntable.update().where(table.c.id==7).values(name='foo')\n```"]