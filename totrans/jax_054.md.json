["```py\nimport jax.numpy as jnp\nfrom jax import custom_jvp\n\n@custom_jvp\ndef f(x, y):\n  return jnp.sin(x) * y\n\n@f.defjvp\ndef f_jvp(primals, tangents):\n  x, y = primals\n  x_dot, y_dot = tangents\n  primal_out = f(x, y)\n  tangent_out = jnp.cos(x) * x_dot * y + jnp.sin(x) * y_dot\n  return primal_out, tangent_out \n```", "```py\nfrom jax import jvp, grad\n\nprint(f(2., 3.))\ny, y_dot = jvp(f, (2., 3.), (1., 0.))\nprint(y)\nprint(y_dot)\nprint(grad(f)(2., 3.)) \n```", "```py\n2.7278922\n2.7278922\n-1.2484405\n-1.2484405 \n```", "```py\n# Equivalent alternative using the defjvps convenience wrapper\n\n@custom_jvp\ndef f(x, y):\n  return jnp.sin(x) * y\n\nf.defjvps(lambda x_dot, primal_out, x, y: jnp.cos(x) * x_dot * y,\n          lambda y_dot, primal_out, x, y: jnp.sin(x) * y_dot) \n```", "```py\nprint(f(2., 3.))\ny, y_dot = jvp(f, (2., 3.), (1., 0.))\nprint(y)\nprint(y_dot)\nprint(grad(f)(2., 3.)) \n```", "```py\n2.7278922\n2.7278922\n-1.2484405\n-1.2484405 \n```", "```py\nfrom jax import custom_vjp\n\n@custom_vjp\ndef f(x, y):\n  return jnp.sin(x) * y\n\ndef f_fwd(x, y):\n# Returns primal output and residuals to be used in backward pass by f_bwd.\n  return f(x, y), (jnp.cos(x), jnp.sin(x), y)\n\ndef f_bwd(res, g):\n  cos_x, sin_x, y = res # Gets residuals computed in f_fwd\n  return (cos_x * g * y, sin_x * g)\n\nf.defvjp(f_fwd, f_bwd) \n```", "```py\nprint(grad(f)(2., 3.)) \n```", "```py\n-1.2484405 \n```", "```py\nimport jax.numpy as jnp\n\ndef log1pexp(x):\n  return jnp.log(1. + jnp.exp(x))\n\nlog1pexp(3.) \n```", "```py\nArray(3.0485873, dtype=float32, weak_type=True) \n```", "```py\nfrom jax import jit, grad, vmap\n\nprint(jit(log1pexp)(3.))\nprint(jit(grad(log1pexp))(3.))\nprint(vmap(jit(grad(log1pexp)))(jnp.arange(3.))) \n```", "```py\n3.0485873\n0.95257413\n[0.5       0.7310586 0.8807971] \n```", "```py\nprint(grad(log1pexp)(100.)) \n```", "```py\nnan \n```", "```py\nfrom jax import make_jaxpr\n\nmake_jaxpr(grad(log1pexp))(100.) \n```", "```py\n{ lambda ; a:f32[]. let\n    b:f32[] = exp a\n    c:f32[] = add 1.0 b\n    _:f32[] = log c\n    d:f32[] = div 1.0 c\n    e:f32[] = mul d b\n  in (e,) } \n```", "```py\nfrom jax import custom_jvp\n\n@custom_jvp\ndef log1pexp(x):\n  return jnp.log(1. + jnp.exp(x))\n\n@log1pexp.defjvp\ndef log1pexp_jvp(primals, tangents):\n  x, = primals\n  x_dot, = tangents\n  ans = log1pexp(x)\n  ans_dot = (1 - 1/(1 + jnp.exp(x))) * x_dot\n  return ans, ans_dot \n```", "```py\nprint(grad(log1pexp)(100.)) \n```", "```py\n1.0 \n```", "```py\nprint(jit(log1pexp)(3.))\nprint(jit(grad(log1pexp))(3.))\nprint(vmap(jit(grad(log1pexp)))(jnp.arange(3.))) \n```", "```py\n3.0485873\n0.95257413\n[0.5       0.7310586 0.8807971] \n```", "```py\n@custom_jvp\ndef log1pexp(x):\n  return jnp.log(1. + jnp.exp(x))\n\nlog1pexp.defjvps(lambda t, ans, x: (1 - 1/(1 + jnp.exp(x))) * t) \n```", "```py\nprint(grad(log1pexp)(100.))\nprint(jit(log1pexp)(3.))\nprint(jit(grad(log1pexp))(3.))\nprint(vmap(jit(grad(log1pexp)))(jnp.arange(3.))) \n```", "```py\n1.0\n3.0485873\n0.95257413\n[0.5       0.7310586 0.8807971] \n```", "```py\ndef f(x):\n  return x / (1 + jnp.sqrt(x)) \n```", "```py\nprint(grad(f)(0.)) \n```", "```py\nnan \n```", "```py\n@custom_jvp\ndef f(x):\n  return x / (1 + jnp.sqrt(x))\n\n@f.defjvp\ndef f_jvp(primals, tangents):\n  x, = primals\n  x_dot, = tangents\n  ans = f(x)\n  ans_dot = ((jnp.sqrt(x) + 2) / (2 * (jnp.sqrt(x) + 1)**2)) * x_dot\n  return ans, ans_dot \n```", "```py\nprint(grad(f)(0.)) \n```", "```py\n1.0 \n```", "```py\n@custom_jvp\ndef f(x):\n  return x / (1 + jnp.sqrt(x))\n\nf.defjvps(lambda t, ans, x: ((jnp.sqrt(x) + 2) / (2 * (jnp.sqrt(x) + 1)**2)) * t) \n```", "```py\nprint(grad(f)(0.)) \n```", "```py\n1.0 \n```", "```py\nfrom functools import partial\nfrom jax import custom_vjp\n\n@custom_vjp\ndef clip_gradient(lo, hi, x):\n  return x  # identity function\n\ndef clip_gradient_fwd(lo, hi, x):\n  return x, (lo, hi)  # save bounds as residuals\n\ndef clip_gradient_bwd(res, g):\n  lo, hi = res\n  return (None, None, jnp.clip(g, lo, hi))  # use None to indicate zero cotangents for lo and hi\n\nclip_gradient.defvjp(clip_gradient_fwd, clip_gradient_bwd) \n```", "```py\nimport matplotlib.pyplot as plt\nfrom jax import vmap\n\nt = jnp.linspace(0, 10, 1000)\n\nplt.plot(jnp.sin(t))\nplt.plot(vmap(grad(jnp.sin))(t)) \n```", "```py\n[<matplotlib.lines.Line2D at 0x7f43dfc210f0>] \n```", "```py\ndef clip_sin(x):\n  x = clip_gradient(-0.75, 0.75, x)\n  return jnp.sin(x)\n\nplt.plot(clip_sin(t))\nplt.plot(vmap(grad(clip_sin))(t)) \n```", "```py\n[<matplotlib.lines.Line2D at 0x7f43ddb15fc0>] \n```", "```py\nfrom jax.lax import while_loop\n\ndef fixed_point(f, a, x_guess):\n  def cond_fun(carry):\n    x_prev, x = carry\n    return jnp.abs(x_prev - x) > 1e-6\n\n  def body_fun(carry):\n    _, x = carry\n    return x, f(a, x)\n\n  _, x_star = while_loop(cond_fun, body_fun, (x_guess, f(a, x_guess)))\n  return x_star \n```", "```py\ndef newton_sqrt(a):\n  update = lambda a, x: 0.5 * (x + a / x)\n  return fixed_point(update, a, a) \n```", "```py\nprint(newton_sqrt(2.)) \n```", "```py\n1.4142135 \n```", "```py\nprint(jit(vmap(newton_sqrt))(jnp.array([1., 2., 3., 4.]))) \n```", "```py\n[1\\.        1.4142135 1.7320509 2\\.       ] \n```", "```py\nfrom jax import vjp\n\n@partial(custom_vjp, nondiff_argnums=(0,))\ndef fixed_point(f, a, x_guess):\n  def cond_fun(carry):\n    x_prev, x = carry\n    return jnp.abs(x_prev - x) > 1e-6\n\n  def body_fun(carry):\n    _, x = carry\n    return x, f(a, x)\n\n  _, x_star = while_loop(cond_fun, body_fun, (x_guess, f(a, x_guess)))\n  return x_star\n\ndef fixed_point_fwd(f, a, x_init):\n  x_star = fixed_point(f, a, x_init)\n  return x_star, (a, x_star)\n\ndef fixed_point_rev(f, res, x_star_bar):\n  a, x_star = res\n  _, vjp_a = vjp(lambda a: f(a, x_star), a)\n  a_bar, = vjp_a(fixed_point(partial(rev_iter, f),\n                             (a, x_star, x_star_bar),\n                             x_star_bar))\n  return a_bar, jnp.zeros_like(x_star)\n\ndef rev_iter(f, packed, u):\n  a, x_star, x_star_bar = packed\n  _, vjp_x = vjp(lambda x: f(a, x), x_star)\n  return x_star_bar + vjp_x(u)[0]\n\nfixed_point.defvjp(fixed_point_fwd, fixed_point_rev) \n```", "```py\nprint(newton_sqrt(2.)) \n```", "```py\n1.4142135 \n```", "```py\nprint(grad(newton_sqrt)(2.))\nprint(grad(grad(newton_sqrt))(2.)) \n```", "```py\n0.35355338\n-0.088388346 \n```", "```py\nprint(grad(jnp.sqrt)(2.))\nprint(grad(grad(jnp.sqrt))(2.)) \n```", "```py\n0.35355338\n-0.08838835 \n```", "```py\nfrom jax import custom_jvp\nimport jax.numpy as jnp\n\n# f :: a -> b\n@custom_jvp\ndef f(x):\n  return jnp.sin(x)\n\n# f_jvp :: (a, T a) -> (b, T b)\ndef f_jvp(primals, tangents):\n  x, = primals\n  t, = tangents\n  return f(x), jnp.cos(x) * t\n\nf.defjvp(f_jvp) \n```", "```py\n<function __main__.f_jvp(primals, tangents)> \n```", "```py\nfrom jax import jvp\n\nprint(f(3.))\n\ny, y_dot = jvp(f, (3.,), (1.,))\nprint(y)\nprint(y_dot) \n```", "```py\n0.14112\n0.14112\n-0.9899925 \n```", "```py\n@custom_jvp\ndef f(x):\n  ...\n\n@f.defjvp\ndef f_jvp(primals, tangents):\n  ... \n```", "```py\nfrom jax import grad\n\nprint(grad(f)(3.))\nprint(grad(grad(f))(3.)) \n```", "```py\n-0.9899925\n-0.14112 \n```", "```py\n@custom_jvp\ndef f(x, y):\n  return x ** 2 * y\n\n@f.defjvp\ndef f_jvp(primals, tangents):\n  x, y = primals\n  x_dot, y_dot = tangents\n  primal_out = f(x, y)\n  tangent_out = 2 * x * y * x_dot + x ** 2 * y_dot\n  return primal_out, tangent_out \n```", "```py\nprint(grad(f)(2., 3.)) \n```", "```py\n12.0 \n```", "```py\n@custom_jvp\ndef f(x):\n  return jnp.sin(x)\n\nf.defjvps(lambda t, ans, x: jnp.cos(x) * t) \n```", "```py\nprint(grad(f)(3.)) \n```", "```py\n-0.9899925 \n```", "```py\n@custom_jvp\ndef f(x, y):\n  return x ** 2 * y\n\nf.defjvps(lambda x_dot, primal_out, x, y: 2 * x * y * x_dot,\n          lambda y_dot, primal_out, x, y: x ** 2 * y_dot) \n```", "```py\nprint(grad(f)(2., 3.))\nprint(grad(f, 0)(2., 3.))  # same as above\nprint(grad(f, 1)(2., 3.)) \n```", "```py\n12.0\n12.0\n4.0 \n```", "```py\n@custom_jvp\ndef f(x, y):\n  return x ** 2 * y\n\nf.defjvps(lambda x_dot, primal_out, x, y: 2 * x * y * x_dot,\n          None) \n```", "```py\nprint(grad(f)(2., 3.))\nprint(grad(f, 0)(2., 3.))  # same as above\nprint(grad(f, 1)(2., 3.)) \n```", "```py\n12.0\n12.0\n0.0 \n```", "```py\n@custom_jvp\ndef f(x):\n  print('called f!')  # a harmless side-effect\n  return jnp.sin(x)\n\n@f.defjvp\ndef f_jvp(primals, tangents):\n  print('called f_jvp!')  # a harmless side-effect\n  x, = primals\n  t, = tangents\n  return f(x), jnp.cos(x) * t \n```", "```py\nfrom jax import vmap, jit\n\nprint(f(3.)) \n```", "```py\ncalled f!\n0.14112 \n```", "```py\nprint(vmap(f)(jnp.arange(3.)))\nprint(jit(f)(3.)) \n```", "```py\ncalled f!\n[0\\.         0.84147096 0.9092974 ]\ncalled f!\n0.14112 \n```", "```py\ny, y_dot = jvp(f, (3.,), (1.,))\nprint(y_dot) \n```", "```py\ncalled f_jvp!\ncalled f!\n-0.9899925 \n```", "```py\nprint(grad(f)(3.)) \n```", "```py\ncalled f_jvp!\ncalled f!\n-0.9899925 \n```", "```py\ngrad(grad(f))(3.) \n```", "```py\ncalled f_jvp!\ncalled f_jvp!\ncalled f! \n```", "```py\nArray(-0.14112, dtype=float32, weak_type=True) \n```", "```py\n@custom_jvp\ndef f(x):\n  if x > 0:\n    return jnp.sin(x)\n  else:\n    return jnp.cos(x)\n\n@f.defjvp\ndef f_jvp(primals, tangents):\n  x, = primals\n  x_dot, = tangents\n  ans = f(x)\n  if x > 0:\n    return ans, 2 * x_dot\n  else:\n    return ans, 3 * x_dot \n```", "```py\nprint(grad(f)(1.))\nprint(grad(f)(-1.)) \n```", "```py\n2.0\n3.0 \n```", "```py\nfrom jax import custom_vjp\nimport jax.numpy as jnp\n\n# f :: a -> b\n@custom_vjp\ndef f(x):\n  return jnp.sin(x)\n\n# f_fwd :: a -> (b, c)\ndef f_fwd(x):\n  return f(x), jnp.cos(x)\n\n# f_bwd :: (c, CT b) -> CT a\ndef f_bwd(cos_x, y_bar):\n  return (cos_x * y_bar,)\n\nf.defvjp(f_fwd, f_bwd) \n```", "```py\nfrom jax import grad\n\nprint(f(3.))\nprint(grad(f)(3.)) \n```", "```py\n0.14112\n-0.9899925 \n```", "```py\nfrom jax import custom_vjp\n\n@custom_vjp\ndef f(x, y):\n  return jnp.sin(x) * y\n\ndef f_fwd(x, y):\n  return f(x, y), (jnp.cos(x), jnp.sin(x), y)\n\ndef f_bwd(res, g):\n  cos_x, sin_x, y = res\n  return (cos_x * g * y, sin_x * g)\n\nf.defvjp(f_fwd, f_bwd) \n```", "```py\nprint(grad(f)(2., 3.)) \n```", "```py\n-1.2484405 \n```", "```py\n@custom_vjp\ndef f(x):\n  print(\"called f!\")\n  return jnp.sin(x)\n\ndef f_fwd(x):\n  print(\"called f_fwd!\")\n  return f(x), jnp.cos(x)\n\ndef f_bwd(cos_x, y_bar):\n  print(\"called f_bwd!\")\n  return (cos_x * y_bar,)\n\nf.defvjp(f_fwd, f_bwd) \n```", "```py\nprint(f(3.)) \n```", "```py\ncalled f!\n0.14112 \n```", "```py\nprint(grad(f)(3.)) \n```", "```py\ncalled f_fwd!\ncalled f!\ncalled f_bwd!\n-0.9899925 \n```", "```py\nfrom jax import vjp\n\ny, f_vjp = vjp(f, 3.)\nprint(y) \n```", "```py\ncalled f_fwd!\ncalled f!\n0.14112 \n```", "```py\nprint(f_vjp(1.)) \n```", "```py\ncalled f_bwd!\n(Array(-0.9899925, dtype=float32, weak_type=True),) \n```", "```py\nfrom jax import jvp\n\ntry:\n  jvp(f, (3.,), (1.,))\nexcept TypeError as e:\n  print('ERROR! {}'.format(e)) \n```", "```py\ncalled f_fwd!\ncalled f!\nERROR! can't apply forward-mode autodiff (jvp) to a custom_vjp function. \n```", "```py\nimport pdb\n\n@custom_vjp\ndef debug(x):\n  return x  # acts like identity\n\ndef debug_fwd(x):\n  return x, x\n\ndef debug_bwd(x, g):\n  import pdb; pdb.set_trace()\n  return g\n\ndebug.defvjp(debug_fwd, debug_bwd) \n```", "```py\ndef foo(x):\n  y = x ** 2\n  y = debug(y)  # insert pdb in corresponding backward pass step\n  return jnp.sin(y) \n```", "```py\njax.grad(foo)(3.)\n\n> <ipython-input-113-b19a2dc1abf7>(12)debug_bwd()\n-> return g\n(Pdb) p x\nArray(9., dtype=float32)\n(Pdb) p g\nArray(-0.91113025, dtype=float32)\n(Pdb) q \n```", "```py\nfrom collections import namedtuple\nPoint = namedtuple(\"Point\", [\"x\", \"y\"])\n\n@custom_jvp\ndef f(pt):\n  x, y = pt.x, pt.y\n  return {'a': x ** 2,\n          'b': (jnp.sin(x), jnp.cos(y))}\n\n@f.defjvp\ndef f_jvp(primals, tangents):\n  pt, = primals\n  pt_dot, =  tangents\n  ans = f(pt)\n  ans_dot = {'a': 2 * pt.x * pt_dot.x,\n             'b': (jnp.cos(pt.x) * pt_dot.x, -jnp.sin(pt.y) * pt_dot.y)}\n  return ans, ans_dot\n\ndef fun(pt):\n  dct = f(pt)\n  return dct['a'] + dct['b'][0] \n```", "```py\npt = Point(1., 2.)\n\nprint(f(pt)) \n```", "```py\n{'a': 1.0, 'b': (Array(0.84147096, dtype=float32, weak_type=True), Array(-0.41614684, dtype=float32, weak_type=True))} \n```", "```py\nprint(grad(fun)(pt)) \n```", "```py\nPoint(x=Array(2.5403023, dtype=float32, weak_type=True), y=Array(0., dtype=float32, weak_type=True)) \n```", "```py\n@custom_vjp\ndef f(pt):\n  x, y = pt.x, pt.y\n  return {'a': x ** 2,\n          'b': (jnp.sin(x), jnp.cos(y))}\n\ndef f_fwd(pt):\n  return f(pt), pt\n\ndef f_bwd(pt, g):\n  a_bar, (b0_bar, b1_bar) = g['a'], g['b']\n  x_bar = 2 * pt.x * a_bar + jnp.cos(pt.x) * b0_bar\n  y_bar = -jnp.sin(pt.y) * b1_bar\n  return (Point(x_bar, y_bar),)\n\nf.defvjp(f_fwd, f_bwd)\n\ndef fun(pt):\n  dct = f(pt)\n  return dct['a'] + dct['b'][0] \n```", "```py\npt = Point(1., 2.)\n\nprint(f(pt)) \n```", "```py\n{'a': 1.0, 'b': (Array(0.84147096, dtype=float32, weak_type=True), Array(-0.41614684, dtype=float32, weak_type=True))} \n```", "```py\nprint(grad(fun)(pt)) \n```", "```py\nPoint(x=Array(2.5403023, dtype=float32, weak_type=True), y=Array(-0., dtype=float32, weak_type=True)) \n```", "```py\nfrom functools import partial\n\n@partial(custom_jvp, nondiff_argnums=(0,))\ndef app(f, x):\n  return f(x)\n\n@app.defjvp\ndef app_jvp(f, primals, tangents):\n  x, = primals\n  x_dot, = tangents\n  return f(x), 2. * x_dot \n```", "```py\nprint(app(lambda x: x ** 3, 3.)) \n```", "```py\n27.0 \n```", "```py\nprint(grad(app, 1)(lambda x: x ** 3, 3.)) \n```", "```py\n2.0 \n```", "```py\n@partial(custom_jvp, nondiff_argnums=(0, 2))\ndef app2(f, x, g):\n  return f(g((x)))\n\n@app2.defjvp\ndef app2_jvp(f, g, primals, tangents):\n  x, = primals\n  x_dot, = tangents\n  return f(g(x)), 3. * x_dot \n```", "```py\nprint(app2(lambda x: x ** 3, 3., lambda y: 5 * y)) \n```", "```py\n3375.0 \n```", "```py\nprint(grad(app2, 1)(lambda x: x ** 3, 3., lambda y: 5 * y)) \n```", "```py\n3.0 \n```", "```py\n@partial(custom_vjp, nondiff_argnums=(0,))\ndef app(f, x):\n  return f(x)\n\ndef app_fwd(f, x):\n  return f(x), x\n\ndef app_bwd(f, x, g):\n  return (5 * g,)\n\napp.defvjp(app_fwd, app_bwd) \n```", "```py\nprint(app(lambda x: x ** 2, 4.)) \n```", "```py\n16.0 \n```", "```py\nprint(grad(app, 1)(lambda x: x ** 2, 4.)) \n```", "```py\n5.0 \n```"]