["```py\nimport sys\nfrom io import BytesIO\nfrom pdfrw import PdfReader\nimport pymupdf\n\n#---------------------------------------\n# 'Tolerant' PDF reader\n#---------------------------------------\ndef reader(fname, password = None):\n    idata = open(fname, \"rb\").read()  # read the PDF into memory and\n    ibuffer = BytesIO(idata)  # convert to stream\n    if password is None:\n        try:\n            return PdfReader(ibuffer)  # if this works: fine!\n        except:\n            pass\n\n    # either we need a password or it is a problem-PDF\n    # create a repaired / decompressed / decrypted version\n    doc = pymupdf.open(\"pdf\", ibuffer)\n    if password is not None:  # decrypt if password provided\n        rc = doc.authenticate(password)\n        if not rc > 0:\n            raise ValueError(\"wrong password\")\n    c = doc.tobytes(garbage=3, deflate=True)\n    del doc  # close & delete doc\n    return PdfReader(BytesIO(c))  # let pdfrw retry\n#---------------------------------------\n# Main program\n#---------------------------------------\npdf = reader(\"pymupdf.pdf\", password = None) # include a password if necessary\nprint pdf.Info\n# do further processing \n```", "```py\n\"\"\"\nDemo script: Convert input file to a PDF\n-----------------------------------------\nIntended for multi-page input files like XPS, EPUB etc.\n\nFeatures:\n---------\nRecovery of table of contents and links of input file.\nWhile this works well for bookmarks (outlines, table of contents),\nlinks will only work if they are not of type \"LINK_NAMED\".\nThis link type is skipped by the script.\n\nFor XPS and EPUB input, internal links however **are** of type \"LINK_NAMED\".\nBase library MuPDF does not resolve them to page numbers.\n\nSo, for anyone expert enough to know the internal structure of these\ndocument types, can further interpret and resolve these link types.\n\nDependencies\n--------------\nPyMuPDF v1.14.0+\n\"\"\"\nimport sys\nimport pymupdf\nif not (list(map(int, pymupdf.VersionBind.split(\".\"))) >= [1,14,0]):\n    raise SystemExit(\"need PyMuPDF v1.14.0+\")\nfn = sys.argv[1]\n\nprint(\"Converting '%s' to '%s.pdf'\" % (fn, fn))\n\ndoc = pymupdf.open(fn)\n\nb = doc.convert_to_pdf()  # convert to pdf\npdf = pymupdf.open(\"pdf\", b)  # open as pdf\n\ntoc= doc.get_toc()  # table of contents of input\npdf.set_toc(toc)  # simply set it for output\nmeta = doc.metadata  # read and set metadata\nif not meta[\"producer\"]:\n    meta[\"producer\"] = \"PyMuPDF v\" + pymupdf.VersionBind\n\nif not meta[\"creator\"]:\n    meta[\"creator\"] = \"PyMuPDF PDF converter\"\nmeta[\"modDate\"] = pymupdf.get_pdf_now()\nmeta[\"creationDate\"] = meta[\"modDate\"]\npdf.set_metadata(meta)\n\n# now process the links\nlink_cnti = 0\nlink_skip = 0\nfor pinput in doc:  # iterate through input pages\n    links = pinput.get_links()  # get list of links\n    link_cnti += len(links)  # count how many\n    pout = pdf[pinput.number]  # read corresp. output page\n    for l in links:  # iterate though the links\n        if l[\"kind\"] == pymupdf.LINK_NAMED:  # we do not handle named links\n            print(\"named link page\", pinput.number, l)\n            link_skip += 1  # count them\n            continue\n        pout.insert_link(l)  # simply output the others\n\n# save the conversion result\npdf.save(fn + \".pdf\", garbage=4, deflate=True)\n# say how many named links we skipped\nif link_cnti > 0:\n    print(\"Skipped %i named links of a total of %i in input.\" % (link_skip, link_cnti)) \n```", "```py\n>>> import pymupdf\n>>> doc = pymupdf.open(\"damaged-file.pdf\")  # leads to a sys.stderr message:\nmupdf: cannot find startxref\n>>> print(pymupdf.TOOLS.mupdf_warnings())  # check if there is more info:\ncannot find startxref\ntrying to repair broken xref\nrepairing PDF document\nobject missing 'endobj' token\n>>> doc.can_save_incrementally()  # this is to be expected:\nFalse\n>>> # the following indicates whether there are updates so far\n>>> # this is the case because of the repair actions:\n>>> doc.is_dirty\nTrue\n>>> # the document has nevertheless been created:\n>>> doc\npymupdf.Document('damaged-file.pdf')\n>>> # we now know that any save must occur to a new file \n```", "```py\n>>> import pymupdf\n>>> doc = pymupdf.open(\"does-not-exist.pdf\")\nmupdf: cannot open does-not-exist.pdf: No such file or directory\nTraceback (most recent call last):\n  File \"<pyshell#1>\", line 1, in <module>\n  doc = pymupdf.open(\"does-not-exist.pdf\")\n  File \"C:\\Users\\Jorj\\AppData\\Local\\Programs\\Python\\Python37\\lib\\site-packages\\fitz\\pymupdf.py\", line 2200, in __init__\n  _pymupdf.Document_swiginit(self, _pymupdf.new_Document(filename, stream, filetype, rect, width, height, fontsize))\nRuntimeError: cannot open does-not-exist.pdf: No such file or directory\n>>> \n```", "```py\nimport sys\nfrom io import BytesIO\nfrom pdfrw import PdfReader\nimport pymupdf\n\n#---------------------------------------\n# 'Tolerant' PDF reader\n#---------------------------------------\ndef reader(fname, password = None):\n    idata = open(fname, \"rb\").read()  # read the PDF into memory and\n    ibuffer = BytesIO(idata)  # convert to stream\n    if password is None:\n        try:\n            return PdfReader(ibuffer)  # if this works: fine!\n        except:\n            pass\n\n    # either we need a password or it is a problem-PDF\n    # create a repaired / decompressed / decrypted version\n    doc = pymupdf.open(\"pdf\", ibuffer)\n    if password is not None:  # decrypt if password provided\n        rc = doc.authenticate(password)\n        if not rc > 0:\n            raise ValueError(\"wrong password\")\n    c = doc.tobytes(garbage=3, deflate=True)\n    del doc  # close & delete doc\n    return PdfReader(BytesIO(c))  # let pdfrw retry\n#---------------------------------------\n# Main program\n#---------------------------------------\npdf = reader(\"pymupdf.pdf\", password = None) # include a password if necessary\nprint pdf.Info\n# do further processing \n```", "```py\n\"\"\"\nDemo script: Convert input file to a PDF\n-----------------------------------------\nIntended for multi-page input files like XPS, EPUB etc.\n\nFeatures:\n---------\nRecovery of table of contents and links of input file.\nWhile this works well for bookmarks (outlines, table of contents),\nlinks will only work if they are not of type \"LINK_NAMED\".\nThis link type is skipped by the script.\n\nFor XPS and EPUB input, internal links however **are** of type \"LINK_NAMED\".\nBase library MuPDF does not resolve them to page numbers.\n\nSo, for anyone expert enough to know the internal structure of these\ndocument types, can further interpret and resolve these link types.\n\nDependencies\n--------------\nPyMuPDF v1.14.0+\n\"\"\"\nimport sys\nimport pymupdf\nif not (list(map(int, pymupdf.VersionBind.split(\".\"))) >= [1,14,0]):\n    raise SystemExit(\"need PyMuPDF v1.14.0+\")\nfn = sys.argv[1]\n\nprint(\"Converting '%s' to '%s.pdf'\" % (fn, fn))\n\ndoc = pymupdf.open(fn)\n\nb = doc.convert_to_pdf()  # convert to pdf\npdf = pymupdf.open(\"pdf\", b)  # open as pdf\n\ntoc= doc.get_toc()  # table of contents of input\npdf.set_toc(toc)  # simply set it for output\nmeta = doc.metadata  # read and set metadata\nif not meta[\"producer\"]:\n    meta[\"producer\"] = \"PyMuPDF v\" + pymupdf.VersionBind\n\nif not meta[\"creator\"]:\n    meta[\"creator\"] = \"PyMuPDF PDF converter\"\nmeta[\"modDate\"] = pymupdf.get_pdf_now()\nmeta[\"creationDate\"] = meta[\"modDate\"]\npdf.set_metadata(meta)\n\n# now process the links\nlink_cnti = 0\nlink_skip = 0\nfor pinput in doc:  # iterate through input pages\n    links = pinput.get_links()  # get list of links\n    link_cnti += len(links)  # count how many\n    pout = pdf[pinput.number]  # read corresp. output page\n    for l in links:  # iterate though the links\n        if l[\"kind\"] == pymupdf.LINK_NAMED:  # we do not handle named links\n            print(\"named link page\", pinput.number, l)\n            link_skip += 1  # count them\n            continue\n        pout.insert_link(l)  # simply output the others\n\n# save the conversion result\npdf.save(fn + \".pdf\", garbage=4, deflate=True)\n# say how many named links we skipped\nif link_cnti > 0:\n    print(\"Skipped %i named links of a total of %i in input.\" % (link_skip, link_cnti)) \n```", "```py\n>>> import pymupdf\n>>> doc = pymupdf.open(\"damaged-file.pdf\")  # leads to a sys.stderr message:\nmupdf: cannot find startxref\n>>> print(pymupdf.TOOLS.mupdf_warnings())  # check if there is more info:\ncannot find startxref\ntrying to repair broken xref\nrepairing PDF document\nobject missing 'endobj' token\n>>> doc.can_save_incrementally()  # this is to be expected:\nFalse\n>>> # the following indicates whether there are updates so far\n>>> # this is the case because of the repair actions:\n>>> doc.is_dirty\nTrue\n>>> # the document has nevertheless been created:\n>>> doc\npymupdf.Document('damaged-file.pdf')\n>>> # we now know that any save must occur to a new file \n```", "```py\n>>> import pymupdf\n>>> doc = pymupdf.open(\"does-not-exist.pdf\")\nmupdf: cannot open does-not-exist.pdf: No such file or directory\nTraceback (most recent call last):\n  File \"<pyshell#1>\", line 1, in <module>\n  doc = pymupdf.open(\"does-not-exist.pdf\")\n  File \"C:\\Users\\Jorj\\AppData\\Local\\Programs\\Python\\Python37\\lib\\site-packages\\fitz\\pymupdf.py\", line 2200, in __init__\n  _pymupdf.Document_swiginit(self, _pymupdf.new_Document(filename, stream, filetype, rect, width, height, fontsize))\nRuntimeError: cannot open does-not-exist.pdf: No such file or directory\n>>> \n```"]