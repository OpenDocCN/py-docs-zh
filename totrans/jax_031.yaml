- en: Ahead-of-time lowering and compilation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[`jax.readthedocs.io/en/latest/aot.html`](https://jax.readthedocs.io/en/latest/aot.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: JAX offers several transformations, such as `jax.jit` and `jax.pmap`, returning
    a function that is compiled and runs on accelerators or the CPU. As the JIT acronym
    indicates, all compilation happens *just-in-time* for execution.
  prefs: []
  type: TYPE_NORMAL
- en: Some situations call for *ahead-of-time* (AOT) compilation instead. When you
    want to fully compile prior to execution time, or you want control over when different
    parts of the compilation process take place, JAX has some options for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s review the stages of compilation. Suppose that `f` is a function/callable
    output by `jax.jit()`, say `f = jax.jit(F)` for some input callable `F`. When
    it is invoked with arguments, say `f(x, y)` where `x` and `y` are arrays, JAX
    does the following in order:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Stage out** a specialized version of the original Python callable `F` to
    an internal representation. The specialization reflects a restriction of `F` to
    input types inferred from properties of the arguments `x` and `y` (usually their
    shape and element type).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Lower** this specialized, staged-out computation to the XLA compiler’s input
    language, StableHLO.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Compile** the lowered HLO program to produce an optimized executable for
    the target device (CPU, GPU, or TPU).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Execute** the compiled executable with the arrays `x` and `y` as arguments.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'JAX’s AOT API gives you direct control over steps #2, #3, and #4 (but not #1),
    plus some other features along the way. An example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note that the lowered objects can be used only in the same process in which
    they were lowered. For exporting use cases, see the Exporting and serialization
    APIs.
  prefs: []
  type: TYPE_NORMAL
- en: See the `jax.stages` documentation for more details on what functionality the
    lowering and compiled functions provide.
  prefs: []
  type: TYPE_NORMAL
- en: In place of `jax.jit` above, you can also `lower(...)` the result of `jax.pmap()`,
    as well as `pjit` and `xmap` (from `jax.experimental.pjit` and `jax.experimental.maps`
    respectively). In each case, you can `compile()` the result similarly.
  prefs: []
  type: TYPE_NORMAL
- en: All optional arguments to `jit`—such as `static_argnums`—are respected in the
    corresponding lowering, compilation, and execution. Again the same goes for `pmap`,
    `pjit`, and `xmap`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the example above, we can replace the arguments to `lower` with any objects
    that have `shape` and `dtype` attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: More generally, `lower` only needs its arguments to structurally supply what
    JAX must know for specialization and lowering. For typical array arguments like
    the ones above, this means `shape` and `dtype` fields. For static arguments, by
    contrast, JAX needs actual array values (more on this below).
  prefs: []
  type: TYPE_NORMAL
- en: 'Invoking an AOT-compiled function with arguments that are incompatible with
    its lowering raises an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Relatedly, AOT-compiled functions cannot be transformed by JAX’s just-in-time
    transformations such as `jax.jit`, `jax.grad()`, and `jax.vmap()`.
  prefs: []
  type: TYPE_NORMAL
- en: Lowering with static arguments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Lowering with static arguments underscores the interaction between options
    passed to `jax.jit`, the arguments passed to `lower`, and the arguments needed
    to invoke the resulting compiled function. Continuing with our example above:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The result of `lower` is not safe to serialize directly for use in a different
    process. See Exporting and serialization for additional APIs for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Note that `lower` here takes two arguments as usual, but the subsequent compiled
    function accepts only the remaining non-static second argument. The static first
    argument (value 7) is taken as a constant at lowering time and built into the
    lowered computation, where it is possibly folded in with other constants. In this
    case, its multiplication by 2 is simplified, resulting in the constant 14.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although the second argument to `lower` above can be replaced by a hollow shape/dtype
    structure, it is necessary that the static first argument be a concrete value.
    Otherwise, lowering would err:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: AOT-compiled functions cannot be transformed
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Compiled functions are specialized to a particular set of argument “types,”
    such as arrays with a specific shape and element type in our running example.
    From JAX’s internal point of view, transformations such as `jax.vmap()` alter
    the type signature of functions in a way that invalidates the compiled-for type
    signature. As a policy, JAX simply disallows compiled functions to be involved
    in transformations. Example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: A similar error is raised when `g_aot` is involved in autodiff (e.g. `jax.grad()`).
    For consistency, transformation by `jax.jit` is disallowed as well, even though
    `jit` does not meaningfully modify its argument’s type signature.
  prefs: []
  type: TYPE_NORMAL
- en: Debug information and analyses, when available
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to the primary AOT functionality (separate and explicit lowering,
    compilation, and execution), JAX’s various AOT stages also offer some additional
    features to help with debugging and gathering compiler feedback.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, as the initial example above shows, lowered functions often offer
    a text representation. Compiled functions do the same, and also offer cost and
    memory analyses from the compiler. All of these are provided via methods on the
    `jax.stages.Lowered` and `jax.stages.Compiled` objects (e.g., `lowered.as_text()`
    and `compiled.cost_analysis()` above).
  prefs: []
  type: TYPE_NORMAL
- en: 'These methods are meant as an aid for manual inspection and debugging, not
    as a reliably programmable API. Their availability and output vary by compiler,
    platform, and runtime. This makes for two important caveats:'
  prefs: []
  type: TYPE_NORMAL
- en: If some functionality is unavailable on JAX’s current backend, then the method
    for it returns something trivial (and `False`-like). For example, if the compiler
    underlying JAX does not provide a cost analysis, then `compiled.cost_analysis()`
    will be `None`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If some functionality is available, there are still very limited guarantees
    on what the corresponding method provides. The return value is not required to
    be consistent—in type, structure, or value—across JAX configurations, backends/platforms,
    versions, or even invocations of the method. JAX cannot guarantee that the output
    of `compiled.cost_analysis()` on one day will remain the same on the following
    day.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When in doubt, see the package API documentation for `jax.stages`.
  prefs: []
  type: TYPE_NORMAL
- en: Inspecting staged-out computations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Stage #1 in the list at the top of this note mentions specialization and staging,
    prior to lowering. JAX’s internal notion of a function specialized to the types
    of its arguments is not always a reified data structure in memory. To explicitly
    construct a view of JAX’s specialization of a function in the internal [Jaxpr
    intermediate language](https://jax.readthedocs.io/en/latest/jaxpr.html), see `jax.make_jaxpr()`.'
  prefs: []
  type: TYPE_NORMAL
