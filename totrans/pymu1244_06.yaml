- en: Tutorial
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://pymupdf.readthedocs.io/en/latest/tutorial.html](https://pymupdf.readthedocs.io/en/latest/tutorial.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This tutorial will show you the use of PyMuPDF, MuPDF in Python, step by step.
  prefs: []
  type: TYPE_NORMAL
- en: Because MuPDF supports not only PDF, but also XPS, OpenXPS, CBZ, CBR, FB2 and
    EPUB formats, so does PyMuPDF [[1]](#f1). Nevertheless, for the sake of brevity
    we will only talk about PDF files. At places where indeed only PDF files are supported,
    this will be mentioned explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: Importing the Bindings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Python bindings to MuPDF are made available by this import statement. We
    also show here how your version can be checked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note on the Name *fitz*
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Old versions of PyMuPDF had their **Python** import name as `fitz`. Newer versions
    use `pymupdf` instead, and offer `fitz` as a fallback so that old code will still
    work.
  prefs: []
  type: TYPE_NORMAL
- en: 'The reason for the name `fitz` is a historical curiosity:'
  prefs: []
  type: TYPE_NORMAL
- en: The original rendering library for MuPDF was called *Libart*.
  prefs: []
  type: TYPE_NORMAL
- en: '*“After Artifex Software acquired the MuPDF project, the development focus
    shifted on writing a new modern graphics library called “Fitz”. Fitz was originally
    intended as an R&D project to replace the aging Ghostscript graphics library,
    but has instead become the rendering engine powering MuPDF.”* (Quoted from [Wikipedia](https://en.wikipedia.org/wiki/MuPDF)).'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Importing PyMuPDF as `fitz` still works however PyMuPDF **cannot coexist** with
    other packages named “fitz” in the same Python environment.
  prefs: []
  type: TYPE_NORMAL
- en: '## Opening a Document'
  prefs: []
  type: TYPE_NORMAL
- en: 'To access a [supported document](how-to-open-a-file.html#supported-file-types),
    it must be opened with the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This creates the [Document](document.html#document) object *doc*. *filename*
    must be a Python string (or a `pathlib.Path`) specifying the name of an existing
    file.
  prefs: []
  type: TYPE_NORMAL
- en: It is also possible to open a document from memory data, or to create a new,
    empty PDF. See [Document](document.html#document) for details. You can also use
    [Document](document.html#document) as a *context manager*.
  prefs: []
  type: TYPE_NORMAL
- en: A document contains many attributes and functions. Among them are meta information
    (like “author” or “subject”), number of total pages, outline and encryption information.
  prefs: []
  type: TYPE_NORMAL
- en: Some [Document](document.html#document) Methods and Attributes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '| **Method / Attribute** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| [`Document.page_count`](document.html#Document.page_count "Document.page_count")
    | the number of pages (*int*) |'
  prefs: []
  type: TYPE_TB
- en: '| [`Document.metadata`](document.html#Document.metadata "Document.metadata")
    | the metadata (*dict*) |'
  prefs: []
  type: TYPE_TB
- en: '| [`Document.get_toc()`](document.html#Document.get_toc "Document.get_toc")
    | get the table of contents (*list*) |'
  prefs: []
  type: TYPE_TB
- en: '| [`Document.load_page()`](document.html#Document.load_page "Document.load_page")
    | read a [Page](page.html#page) |'
  prefs: []
  type: TYPE_TB
- en: Accessing Meta Data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: PyMuPDF fully supports standard metadata. [`Document.metadata`](document.html#Document.metadata
    "Document.metadata") is a Python dictionary with the following keys. It is available
    for **all document types**, though not all entries may always contain data. For
    details of their meanings and formats consult the respective manuals, e.g. [Adobe
    PDF References](app3.html#adobemanual) for PDF. Further information can also be
    found in chapter [Document](document.html#document). The meta data fields are
    strings or *None* if not otherwise indicated. Also be aware that not all of them
    always contain meaningful data – even if they are not *None*.
  prefs: []
  type: TYPE_NORMAL
- en: '| Key | Value |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| producer | producer (producing software) |'
  prefs: []
  type: TYPE_TB
- en: '| format | format: ‘PDF-1.4’, ‘EPUB’, etc. |'
  prefs: []
  type: TYPE_TB
- en: '| encryption | encryption method used if any |'
  prefs: []
  type: TYPE_TB
- en: '| author | author |'
  prefs: []
  type: TYPE_TB
- en: '| modDate | date of last modification |'
  prefs: []
  type: TYPE_TB
- en: '| keywords | keywords |'
  prefs: []
  type: TYPE_TB
- en: '| title | title |'
  prefs: []
  type: TYPE_TB
- en: '| creationDate | date of creation |'
  prefs: []
  type: TYPE_TB
- en: '| creator | creating application |'
  prefs: []
  type: TYPE_TB
- en: '| subject | subject |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Apart from these standard metadata, **PDF documents** starting from PDF version
    1.4 may also contain so-called *“metadata streams”* (see also [`stream`](glossary.html#stream
    "stream")). Information in such streams is coded in XML. PyMuPDF deliberately
    contains no XML components for this purpose (the [PyMuPDF Xml class](xml-class.html#xml)
    is a helper class intended to access the DOM content of a [Story](story-class.html#story)
    object), so we do not directly support access to information contained therein.
    But you can extract the stream as a whole, inspect or modify it using a package
    like [lxml](https://pypi.org/project/lxml/) and then store the result back into
    the PDF. If you want, you can also delete this data altogether.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: There are two utility scripts in the repository that [metadata import (PDF only)](https://github.com/pymupdf/PyMuPDF-Utilities/blob/master/examples/import-metadata/import.py)
    resp. [metadata export](https://github.com/pymupdf/PyMuPDF-Utilities/blob/master/examples/export-metadata/export.py)
    metadata from resp. to CSV files.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Outlines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The easiest way to get all outlines (also called “bookmarks”) of a document,
    is by loading its *table of contents*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This will return a Python list of lists *[[lvl, title, page, …], …]* which looks
    much like a conventional table of contents found in books.
  prefs: []
  type: TYPE_NORMAL
- en: '*lvl* is the hierarchy level of the entry (starting from 1), *title* is the
    entry’s title, and *page* the page number (1-based!). Other parameters describe
    details of the bookmark target.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: There are two utility scripts in the repository that [toc import (PDF only)](https://github.com/pymupdf/PyMuPDF-Utilities/blob/master/examples/import-toc/import.py)
    resp. [toc export](https://github.com/pymupdf/PyMuPDF-Utilities/blob/master/examples/export-toc/export.py)
    table of contents from resp. to CSV files.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Pages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Page](page.html#page) handling is at the core of MuPDF’s functionality.'
  prefs: []
  type: TYPE_NORMAL
- en: You can render a page into a raster or vector (SVG) image, optionally zooming,
    rotating, shifting or shearing it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can extract a page’s text and images in many formats and search for text
    strings.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For PDF documents many more methods are available to add text or images to pages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'First, a [Page](page.html#page) must be created. This is a method of [Document](document.html#document):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Any integer `-∞ < pno < page_count` is possible here. Negative numbers count
    backwards from the end, so *doc[-1]* is the last page, like with Python sequences.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some more advanced way would be using the document as an **iterator** over
    its pages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have your page, here is what you would typically do with it:'
  prefs: []
  type: TYPE_NORMAL
- en: Inspecting the Links, Annotations or Form Fields of a Page
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Links are shown as “hot areas” when a document is displayed with some viewer
    software. If you click while your cursor shows a hand symbol, you will usually
    be taken to the target that is encoded in that hot area. Here is how to get all
    links:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '*links* is a Python list of dictionaries. For details see [`Page.get_links()`](page.html#Page.get_links
    "Page.get_links").'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use an iterator which emits one link at a time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If dealing with a PDF document page, there may also exist annotations ([Annot](annot.html#annot))
    or form fields ([Widget](widget.html#widget)), each of which have their own iterators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Rendering a Page
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This example creates a **raster** image of a page’s content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '*pix* is a [Pixmap](pixmap.html#pixmap) object which (in this case) contains
    an **RGB** image of the page, ready to be used for many purposes. Method [`Page.get_pixmap()`](page.html#Page.get_pixmap
    "Page.get_pixmap") offers lots of variations for controlling the image: resolution
    / DPI, colorspace (e.g. to produce a grayscale image or an image with a subtractive
    color scheme), transparency, rotation, mirroring, shifting, shearing, etc. For
    example: to create an **RGBA** image (i.e. containing an alpha channel), specify
    *pix = page.get_pixmap(alpha=True)*.'
  prefs: []
  type: TYPE_NORMAL
- en: A [Pixmap](pixmap.html#pixmap) contains a number of methods and attributes which
    are referenced below. Among them are the integers *width*, *height* (each in pixels)
    and *stride* (number of bytes of one horizontal image line). Attribute *samples*
    represents a rectangular area of bytes representing the image data (a Python *bytes*
    object).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can also create a **vector** image of a page by using [`Page.get_svg_image()`](page.html#Page.get_svg_image
    "Page.get_svg_image"). Refer to this [Vector Image Support page](https://github.com/pymupdf/PyMuPDF/wiki/Vector-Image-Support)
    for details.
  prefs: []
  type: TYPE_NORMAL
- en: Saving the Page Image in a File
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can simply store the image in a PNG file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Displaying the Image in GUIs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can also use it in GUI dialog managers. [`Pixmap.samples`](pixmap.html#Pixmap.samples
    "Pixmap.samples") represents an area of bytes of all the pixels as a Python bytes
    object. Here are some examples, find more in the [examples](https://github.com/pymupdf/PyMuPDF/tree/master/examples)
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: wxPython
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Consult their documentation for adjustments to RGB(A) pixmaps and, potentially,
    specifics for your wxPython release:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Tkinter
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Please also see section 3.19 of the [Pillow documentation](https://Pillow.readthedocs.io):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The following **avoids using Pillow**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: If you are looking for a complete Tkinter script paging through **any supported**
    document, [here it is!](https://github.com/pymupdf/PyMuPDF-Utilities/blob/master/examples/browse-document/browse.py).
    It can also zoom into pages, and it runs under Python 2 or 3\. It requires the
    extremely handy [PySimpleGUI](https://pypi.org/project/PySimpleGUI/) pure Python
    package.
  prefs: []
  type: TYPE_NORMAL
- en: PyQt4, PyQt5, PySide
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Please also see section 3.16 of the [Pillow documentation](https://Pillow.readthedocs.io):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, you also can get along **without using Pillow.** Qt’s `QImage` luckily
    supports native Python pointers, so the following is the recommended way to create
    Qt images:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Extracting Text and Images
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can also extract all text, images and other information of a page in many
    different forms, and levels of detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Use one of the following strings for *opt* to obtain different formats [[2]](#f2):'
  prefs: []
  type: TYPE_NORMAL
- en: '**“text”**: (default) plain text with line breaks. No formatting, no text position
    details, no images.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**“blocks”**: generate a list of text blocks (= paragraphs).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**“words”**: generate a list of words (strings not containing spaces).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**“html”**: creates a full visual version of the page including any images.
    This can be displayed with your internet browser.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**“dict”** / **“json”**: same information level as HTML, but provided as a
    Python dictionary or resp. JSON string. See [`TextPage.extractDICT()`](textpage.html#TextPage.extractDICT
    "TextPage.extractDICT") for details of its structure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**“rawdict”** / **“rawjson”**: a super-set of **“dict”** / **“json”**. It additionally
    provides character detail information like XML. See [`TextPage.extractRAWDICT()`](textpage.html#TextPage.extractRAWDICT
    "TextPage.extractRAWDICT") for details of its structure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**“xhtml”**: text information level as the TEXT version but includes images.
    Can also be displayed by internet browsers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**“xml”**: contains no images, but full position and font information down
    to each single text character. Use an XML module to interpret.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To give you an idea about the output of these alternatives, we did text example
    extracts. See [Appendix 2: Considerations on Embedded Files](app2.html#appendix2).'
  prefs: []
  type: TYPE_NORMAL
- en: Searching for Text
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can find out, exactly where on a page a certain text string appears:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This delivers a list of rectangles (see [Rect](rect.html#rect)), each of which
    surrounds one occurrence of the string “mupdf” (case insensitive). You could use
    this information to e.g. highlight those areas (PDF only) or create a cross reference
    of the document.
  prefs: []
  type: TYPE_NORMAL
- en: 'Please also do have a look at chapter [Working together: DisplayList and TextPage](coop_low.html#cooperation)
    and at demo programs [demo.py](https://github.com/pymupdf/PyMuPDF-Utilities/tree/master/demo/demo.py)
    and [demo-lowlevel.py](https://github.com/pymupdf/PyMuPDF-Utilities/tree/master/demo/demo-lowlevel.py).
    Among other things they contain details on how the [TextPage](textpage.html#textpage),
    [Device](device.html#device) and [DisplayList](displaylist.html#displaylist) classes
    can be used for a more direct control, e.g. when performance considerations suggest
    it.'
  prefs: []
  type: TYPE_NORMAL
- en: '## Stories: Generating PDF from HTML Source'
  prefs: []
  type: TYPE_NORMAL
- en: The [Story](story-class.html#story) class is a new feature of PyMuPDF version
    1.21.0\. It represents support for MuPDF’s **“story”** interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a quote from the book [“MuPDF Explored”](https://mupdf.com/docs/mupdf-explored.html)
    by Robin Watts from [Artifex](https://www.artifex.com):'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '*Stories provide a way to easily layout styled content for use with devices,
    such as those offered by Document Writers (…). The concept of a story comes from
    desktop publishing, which in turn (…) gets it from newspapers. If you consider
    a traditional newspaper layout, it will consist of various news articles (stories)
    that are laid out into multiple columns, possibly across multiple pages.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Accordingly, MuPDF uses a story to represent a flow of text with styling information.
    The user of the story can then supply a sequence of rectangles into which the
    story will be laid out, and the positioned text can then be drawn to an output
    device. This keeps the concept of the text itself (the story) to be separated
    from the areas into which the text should be flowed (the layout).*'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'A Story works somewhat similar to an internet browser: It faithfully parses
    and renders HTML hypertext and also optional stylesheets (CSS). But its **output
    is a PDF** – not web pages.'
  prefs: []
  type: TYPE_NORMAL
- en: When creating a [Story](story-class.html#story), the input from up to three
    different information sources is taken into account. All these items are optional.
  prefs: []
  type: TYPE_NORMAL
- en: HTML source code, either a Python string or **created by the script** using
    methods of [Xml](xml-class.html#xml).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: CSS (Cascaded Style Sheet) source code, provided as a Python string. CSS can
    be used to provide styling information (text font size, color, etc.) like it would
    happen for web pages. Obviously, this string may also be read from a file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An [Archive](archive-class.html#archive) **must be used** whenever the DOM references
    images, or uses text fonts except the standard [PDF Base 14 Fonts](app3.html#base-14-fonts),
    CJK fonts and the NOTO fonts generated into the PyMuPDF binary.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The [API](xml-class.html#xml) allows creating DOMs completely from scratch,
    including desired styling information. It can also be used to modify or extend
    **provided** HTML: text can be deleted or replaced, or its styling can be changed.
    Text – for example extracted from databases – can also be added and fill template-like
    HTML documents.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It is **not required** to provide syntactically complete HTML documents: snippets
    like `<b>Hello` are fully accepted, and many / most syntax errors are automatically
    corrected.'
  prefs: []
  type: TYPE_NORMAL
- en: After the HTML is considered complete, it can be used to create a PDF document.
    This happens via the new [DocumentWriter](document-writer-class.html#documentwriter)
    class. The programmer calls its methods to create a new empty page, and passes
    rectangles to the Story to fill them.
  prefs: []
  type: TYPE_NORMAL
- en: The story in turn will return completion codes indicating whether or not more
    content is waiting to be written. Which part of the content will land in which
    rectangle or on which page is automatically determined by the story itself – it
    cannot be influenced other than by providing the rectangles.
  prefs: []
  type: TYPE_NORMAL
- en: Please see the [Stories recipes](recipes-stories.html#recipesstories) for a
    number of typical use cases.
  prefs: []
  type: TYPE_NORMAL
- en: PDF Maintenance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: PDFs are the only document type that can be **modified** using PyMuPDF. Other
    file types are read-only.
  prefs: []
  type: TYPE_NORMAL
- en: However, you can convert **any document** (including images) to a PDF and then
    apply all PyMuPDF features to the conversion result. Find out more here [`Document.convert_to_pdf()`](document.html#Document.convert_to_pdf
    "Document.convert_to_pdf"), and also look at the demo script [pdf-converter.py](https://github.com/pymupdf/PyMuPDF-Utilities/blob/master/examples/convert-document/convert.py)
    which can convert any [supported document](how-to-open-a-file.html#supported-file-types)
    to PDF.
  prefs: []
  type: TYPE_NORMAL
- en: '[`Document.save()`](document.html#Document.save "Document.save") always stores
    a PDF in its current (potentially modified) state on disk.'
  prefs: []
  type: TYPE_NORMAL
- en: You normally can choose whether to save to a new file, or just append your modifications
    to the existing one (“incremental save”), which often is very much faster.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following describes ways how you can manipulate PDF documents. This description
    is by no means complete: much more can be found in the following chapters.'
  prefs: []
  type: TYPE_NORMAL
- en: Modifying, Creating, Re-arranging and Deleting Pages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are several ways to manipulate the so-called **page tree** (a structure
    describing all the pages) of a PDF:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Document.delete_page()`](document.html#Document.delete_page "Document.delete_page")
    and [`Document.delete_pages()`](document.html#Document.delete_pages "Document.delete_pages")
    delete pages.'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Document.copy_page()`](document.html#Document.copy_page "Document.copy_page"),
    [`Document.fullcopy_page()`](document.html#Document.fullcopy_page "Document.fullcopy_page")
    and [`Document.move_page()`](document.html#Document.move_page "Document.move_page")
    copy or move a page to other locations within the same document.'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Document.select()`](document.html#Document.select "Document.select") shrinks
    a PDF down to selected pages. Parameter is a sequence [[3]](#f3) of the page numbers
    that you want to keep. These integers must all be in range *0 <= i < page_count*.
    When executed, all pages **missing** in this list will be deleted. Remaining pages
    will occur **in the sequence and as many times (!) as you specify them**.'
  prefs: []
  type: TYPE_NORMAL
- en: So you can easily create new PDFs with
  prefs: []
  type: TYPE_NORMAL
- en: the first or last 10 pages,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: only the odd or only the even pages (for doing double-sided printing),
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: pages that **do** or **don’t** contain a given text,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: reverse the page sequence, …
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: … whatever you can think of.
  prefs: []
  type: TYPE_NORMAL
- en: The saved new document will contain links, annotations and bookmarks that are
    still valid (i.a.w. either pointing to a selected page or to some external resource).
  prefs: []
  type: TYPE_NORMAL
- en: '[`Document.insert_page()`](document.html#Document.insert_page "Document.insert_page")
    and [`Document.new_page()`](document.html#Document.new_page "Document.new_page")
    insert new pages.'
  prefs: []
  type: TYPE_NORMAL
- en: Pages themselves can moreover be modified by a range of methods (e.g. page rotation,
    annotation and link maintenance, text and image insertion).
  prefs: []
  type: TYPE_NORMAL
- en: Joining and Splitting PDF Documents
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Method [`Document.insert_pdf()`](document.html#Document.insert_pdf "Document.insert_pdf")
    copies pages **between different** PDF documents. Here is a simple **joiner**
    example (*doc1* and *doc2* being opened PDFs):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a snippet that **splits** *doc1*. It creates a new document of its
    first and its last 10 pages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: More can be found in the [Document](document.html#document) chapter. Also have
    a look at [PDFjoiner.py](https://github.com/pymupdf/PyMuPDF-Utilities/blob/master/examples/join-documents/join.py).
  prefs: []
  type: TYPE_NORMAL
- en: Embedding Data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: PDFs can be used as containers for arbitrary data (executables, other PDFs,
    text or binary files, etc.) much like ZIP archives.
  prefs: []
  type: TYPE_NORMAL
- en: PyMuPDF fully supports this feature via [Document](document.html#document) *embfile_**
    methods and attributes. For some detail read Appendix 3, consult the Wiki on [dealing
    with embedding files](https://github.com/pymupdf/PyMuPDF/wiki/Dealing-with-Embedded-Files),
    or the example scripts [embedded-copy.py](https://github.com/pymupdf/PyMuPDF-Utilities/blob/master/examples/copy-embedded/copy.py),
    [embedded-export.py](https://github.com/pymupdf/PyMuPDF-Utilities/blob/master/examples/export-embedded/export.py),
    [embedded-import.py](https://github.com/pymupdf/PyMuPDF-Utilities/blob/master/examples/import-embedded/import.py),
    and [embedded-list.py](https://github.com/pymupdf/PyMuPDF-Utilities/blob/master/examples/list-embedded/list.py).
  prefs: []
  type: TYPE_NORMAL
- en: Saving
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As mentioned above, [`Document.save()`](document.html#Document.save "Document.save")
    will **always** save the document in its current state.
  prefs: []
  type: TYPE_NORMAL
- en: You can write changes back to the **original PDF** by specifying option *incremental=True*.
    This process is (usually) **extremely fast**, since changes are **appended to
    the original file** without completely rewriting it.
  prefs: []
  type: TYPE_NORMAL
- en: '[`Document.save()`](document.html#Document.save "Document.save") options correspond
    to options of MuPDF’s command line utility *mutool clean*, see the following table.'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Save Option** | **mutool** | **Effect** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| garbage=1 | g | garbage collect unused objects |'
  prefs: []
  type: TYPE_TB
- en: '| garbage=2 | gg | in addition to 1, compact [`xref`](glossary.html#xref "xref")
    tables |'
  prefs: []
  type: TYPE_TB
- en: '| garbage=3 | ggg | in addition to 2, merge duplicate objects |'
  prefs: []
  type: TYPE_TB
- en: '| garbage=4 | gggg | in addition to 3, merge duplicate stream content |'
  prefs: []
  type: TYPE_TB
- en: '| clean=True | cs | clean and sanitize content streams |'
  prefs: []
  type: TYPE_TB
- en: '| deflate=True | z | deflate uncompressed streams |'
  prefs: []
  type: TYPE_TB
- en: '| deflate_images=True | i | deflate image streams |'
  prefs: []
  type: TYPE_TB
- en: '| deflate_fonts=True | f | deflate fontfile streams |'
  prefs: []
  type: TYPE_TB
- en: '| ascii=True | a | convert binary data to ASCII format |'
  prefs: []
  type: TYPE_TB
- en: '| linear=True | l | create a linearized version |'
  prefs: []
  type: TYPE_TB
- en: '| expand=True | d | decompress all streams |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: For an explanation of terms like *object, stream, xref* consult the [Glossary](glossary.html#glossary)
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: For example, *mutool clean -ggggz file.pdf* yields excellent compression results.
    It corresponds to *doc.save(filename, garbage=4, deflate=True)*.
  prefs: []
  type: TYPE_NORMAL
- en: Closing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is often desirable to “close” a document to relinquish control of the underlying
    file to the OS, while your program continues.
  prefs: []
  type: TYPE_NORMAL
- en: This can be achieved by the [`Document.close()`](document.html#Document.close
    "Document.close") method. Apart from closing the underlying file, buffer areas
    associated with the document will be freed.
  prefs: []
  type: TYPE_NORMAL
- en: Further Reading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Also have a look at PyMuPDF’s [Wiki](https://github.com/pymupdf/PyMuPDF/wiki)
    pages. Especially those named in the sidebar under title **“Recipes”** cover over
    15 topics written in “How-To” style.
  prefs: []
  type: TYPE_NORMAL
- en: This document also contains a [FAQ](faq.html#faq). This chapter has close connection
    to the aforementioned recipes, and it will be extended with more content over
    time.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Footnotes
  prefs: []
  type: TYPE_NORMAL
- en: Do you have any feedback on this page?
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: This software is provided AS-IS with no warranty, either express or implied.
    This software is distributed under license and may not be copied, modified or
    distributed except as expressly authorized under the terms of that license. Refer
    to licensing information at [artifex.com](https://www.artifex.com?utm_source=rtd-pymupdf&utm_medium=rtd&utm_content=footer-link)
    or contact Artifex Software Inc., 39 Mesa Street, Suite 108A, San Francisco CA
    94129, United States for further information.
  prefs: []
  type: TYPE_NORMAL
- en: This documentation covers all versions up to 1.24.4.
  prefs: []
  type: TYPE_NORMAL
- en: '[![Discord logo](../Images/66cbb5081103a580193aa66c87b90d9a.png)](https://discord.gg/TSpYGBW4eq)'
  prefs: []
  type: TYPE_NORMAL
- en: Importing the Bindings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Python bindings to MuPDF are made available by this import statement. We
    also show here how your version can be checked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Note on the Name *fitz*
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Old versions of PyMuPDF had their **Python** import name as `fitz`. Newer versions
    use `pymupdf` instead, and offer `fitz` as a fallback so that old code will still
    work.
  prefs: []
  type: TYPE_NORMAL
- en: 'The reason for the name `fitz` is a historical curiosity:'
  prefs: []
  type: TYPE_NORMAL
- en: The original rendering library for MuPDF was called *Libart*.
  prefs: []
  type: TYPE_NORMAL
- en: '*“After Artifex Software acquired the MuPDF project, the development focus
    shifted on writing a new modern graphics library called “Fitz”. Fitz was originally
    intended as an R&D project to replace the aging Ghostscript graphics library,
    but has instead become the rendering engine powering MuPDF.”* (Quoted from [Wikipedia](https://en.wikipedia.org/wiki/MuPDF)).'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Importing PyMuPDF as `fitz` still works however PyMuPDF **cannot coexist** with
    other packages named “fitz” in the same Python environment.
  prefs: []
  type: TYPE_NORMAL
- en: Note on the Name *fitz*
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Old versions of PyMuPDF had their **Python** import name as `fitz`. Newer versions
    use `pymupdf` instead, and offer `fitz` as a fallback so that old code will still
    work.
  prefs: []
  type: TYPE_NORMAL
- en: 'The reason for the name `fitz` is a historical curiosity:'
  prefs: []
  type: TYPE_NORMAL
- en: The original rendering library for MuPDF was called *Libart*.
  prefs: []
  type: TYPE_NORMAL
- en: '*“After Artifex Software acquired the MuPDF project, the development focus
    shifted on writing a new modern graphics library called “Fitz”. Fitz was originally
    intended as an R&D project to replace the aging Ghostscript graphics library,
    but has instead become the rendering engine powering MuPDF.”* (Quoted from [Wikipedia](https://en.wikipedia.org/wiki/MuPDF)).'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Importing PyMuPDF as `fitz` still works however PyMuPDF **cannot coexist** with
    other packages named “fitz” in the same Python environment.
  prefs: []
  type: TYPE_NORMAL
- en: '## Opening a Document'
  prefs: []
  type: TYPE_NORMAL
- en: 'To access a [supported document](how-to-open-a-file.html#supported-file-types),
    it must be opened with the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This creates the [Document](document.html#document) object *doc*. *filename*
    must be a Python string (or a `pathlib.Path`) specifying the name of an existing
    file.
  prefs: []
  type: TYPE_NORMAL
- en: It is also possible to open a document from memory data, or to create a new,
    empty PDF. See [Document](document.html#document) for details. You can also use
    [Document](document.html#document) as a *context manager*.
  prefs: []
  type: TYPE_NORMAL
- en: A document contains many attributes and functions. Among them are meta information
    (like “author” or “subject”), number of total pages, outline and encryption information.
  prefs: []
  type: TYPE_NORMAL
- en: Some [Document](document.html#document) Methods and Attributes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '| **Method / Attribute** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| [`Document.page_count`](document.html#Document.page_count "Document.page_count")
    | the number of pages (*int*) |'
  prefs: []
  type: TYPE_TB
- en: '| [`Document.metadata`](document.html#Document.metadata "Document.metadata")
    | the metadata (*dict*) |'
  prefs: []
  type: TYPE_TB
- en: '| [`Document.get_toc()`](document.html#Document.get_toc "Document.get_toc")
    | get the table of contents (*list*) |'
  prefs: []
  type: TYPE_TB
- en: '| [`Document.load_page()`](document.html#Document.load_page "Document.load_page")
    | read a [Page](page.html#page) |'
  prefs: []
  type: TYPE_TB
- en: Accessing Meta Data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: PyMuPDF fully supports standard metadata. [`Document.metadata`](document.html#Document.metadata
    "Document.metadata") is a Python dictionary with the following keys. It is available
    for **all document types**, though not all entries may always contain data. For
    details of their meanings and formats consult the respective manuals, e.g. [Adobe
    PDF References](app3.html#adobemanual) for PDF. Further information can also be
    found in chapter [Document](document.html#document). The meta data fields are
    strings or *None* if not otherwise indicated. Also be aware that not all of them
    always contain meaningful data – even if they are not *None*.
  prefs: []
  type: TYPE_NORMAL
- en: '| Key | Value |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| producer | producer (producing software) |'
  prefs: []
  type: TYPE_TB
- en: '| format | format: ‘PDF-1.4’, ‘EPUB’, etc. |'
  prefs: []
  type: TYPE_TB
- en: '| encryption | encryption method used if any |'
  prefs: []
  type: TYPE_TB
- en: '| author | author |'
  prefs: []
  type: TYPE_TB
- en: '| modDate | date of last modification |'
  prefs: []
  type: TYPE_TB
- en: '| keywords | keywords |'
  prefs: []
  type: TYPE_TB
- en: '| title | title |'
  prefs: []
  type: TYPE_TB
- en: '| creationDate | date of creation |'
  prefs: []
  type: TYPE_TB
- en: '| creator | creating application |'
  prefs: []
  type: TYPE_TB
- en: '| subject | subject |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Apart from these standard metadata, **PDF documents** starting from PDF version
    1.4 may also contain so-called *“metadata streams”* (see also [`stream`](glossary.html#stream
    "stream")). Information in such streams is coded in XML. PyMuPDF deliberately
    contains no XML components for this purpose (the [PyMuPDF Xml class](xml-class.html#xml)
    is a helper class intended to access the DOM content of a [Story](story-class.html#story)
    object), so we do not directly support access to information contained therein.
    But you can extract the stream as a whole, inspect or modify it using a package
    like [lxml](https://pypi.org/project/lxml/) and then store the result back into
    the PDF. If you want, you can also delete this data altogether.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: There are two utility scripts in the repository that [metadata import (PDF only)](https://github.com/pymupdf/PyMuPDF-Utilities/blob/master/examples/import-metadata/import.py)
    resp. [metadata export](https://github.com/pymupdf/PyMuPDF-Utilities/blob/master/examples/export-metadata/export.py)
    metadata from resp. to CSV files.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Outlines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The easiest way to get all outlines (also called “bookmarks”) of a document,
    is by loading its *table of contents*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This will return a Python list of lists *[[lvl, title, page, …], …]* which looks
    much like a conventional table of contents found in books.
  prefs: []
  type: TYPE_NORMAL
- en: '*lvl* is the hierarchy level of the entry (starting from 1), *title* is the
    entry’s title, and *page* the page number (1-based!). Other parameters describe
    details of the bookmark target.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: There are two utility scripts in the repository that [toc import (PDF only)](https://github.com/pymupdf/PyMuPDF-Utilities/blob/master/examples/import-toc/import.py)
    resp. [toc export](https://github.com/pymupdf/PyMuPDF-Utilities/blob/master/examples/export-toc/export.py)
    table of contents from resp. to CSV files.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Pages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Page](page.html#page) handling is at the core of MuPDF’s functionality.'
  prefs: []
  type: TYPE_NORMAL
- en: You can render a page into a raster or vector (SVG) image, optionally zooming,
    rotating, shifting or shearing it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can extract a page’s text and images in many formats and search for text
    strings.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For PDF documents many more methods are available to add text or images to pages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'First, a [Page](page.html#page) must be created. This is a method of [Document](document.html#document):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Any integer `-∞ < pno < page_count` is possible here. Negative numbers count
    backwards from the end, so *doc[-1]* is the last page, like with Python sequences.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some more advanced way would be using the document as an **iterator** over
    its pages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have your page, here is what you would typically do with it:'
  prefs: []
  type: TYPE_NORMAL
- en: Inspecting the Links, Annotations or Form Fields of a Page
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Links are shown as “hot areas” when a document is displayed with some viewer
    software. If you click while your cursor shows a hand symbol, you will usually
    be taken to the target that is encoded in that hot area. Here is how to get all
    links:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '*links* is a Python list of dictionaries. For details see [`Page.get_links()`](page.html#Page.get_links
    "Page.get_links").'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use an iterator which emits one link at a time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'If dealing with a PDF document page, there may also exist annotations ([Annot](annot.html#annot))
    or form fields ([Widget](widget.html#widget)), each of which have their own iterators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Rendering a Page
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This example creates a **raster** image of a page’s content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '*pix* is a [Pixmap](pixmap.html#pixmap) object which (in this case) contains
    an **RGB** image of the page, ready to be used for many purposes. Method [`Page.get_pixmap()`](page.html#Page.get_pixmap
    "Page.get_pixmap") offers lots of variations for controlling the image: resolution
    / DPI, colorspace (e.g. to produce a grayscale image or an image with a subtractive
    color scheme), transparency, rotation, mirroring, shifting, shearing, etc. For
    example: to create an **RGBA** image (i.e. containing an alpha channel), specify
    *pix = page.get_pixmap(alpha=True)*.'
  prefs: []
  type: TYPE_NORMAL
- en: A [Pixmap](pixmap.html#pixmap) contains a number of methods and attributes which
    are referenced below. Among them are the integers *width*, *height* (each in pixels)
    and *stride* (number of bytes of one horizontal image line). Attribute *samples*
    represents a rectangular area of bytes representing the image data (a Python *bytes*
    object).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can also create a **vector** image of a page by using [`Page.get_svg_image()`](page.html#Page.get_svg_image
    "Page.get_svg_image"). Refer to this [Vector Image Support page](https://github.com/pymupdf/PyMuPDF/wiki/Vector-Image-Support)
    for details.
  prefs: []
  type: TYPE_NORMAL
- en: Saving the Page Image in a File
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can simply store the image in a PNG file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Displaying the Image in GUIs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can also use it in GUI dialog managers. [`Pixmap.samples`](pixmap.html#Pixmap.samples
    "Pixmap.samples") represents an area of bytes of all the pixels as a Python bytes
    object. Here are some examples, find more in the [examples](https://github.com/pymupdf/PyMuPDF/tree/master/examples)
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: wxPython
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Consult their documentation for adjustments to RGB(A) pixmaps and, potentially,
    specifics for your wxPython release:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Tkinter
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Please also see section 3.19 of the [Pillow documentation](https://Pillow.readthedocs.io):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The following **avoids using Pillow**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: If you are looking for a complete Tkinter script paging through **any supported**
    document, [here it is!](https://github.com/pymupdf/PyMuPDF-Utilities/blob/master/examples/browse-document/browse.py).
    It can also zoom into pages, and it runs under Python 2 or 3\. It requires the
    extremely handy [PySimpleGUI](https://pypi.org/project/PySimpleGUI/) pure Python
    package.
  prefs: []
  type: TYPE_NORMAL
- en: PyQt4, PyQt5, PySide
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Please also see section 3.16 of the [Pillow documentation](https://Pillow.readthedocs.io):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, you also can get along **without using Pillow.** Qt’s `QImage` luckily
    supports native Python pointers, so the following is the recommended way to create
    Qt images:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Extracting Text and Images
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can also extract all text, images and other information of a page in many
    different forms, and levels of detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Use one of the following strings for *opt* to obtain different formats [[2]](#f2):'
  prefs: []
  type: TYPE_NORMAL
- en: '**“text”**: (default) plain text with line breaks. No formatting, no text position
    details, no images.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**“blocks”**: generate a list of text blocks (= paragraphs).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**“words”**: generate a list of words (strings not containing spaces).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**“html”**: creates a full visual version of the page including any images.
    This can be displayed with your internet browser.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**“dict”** / **“json”**: same information level as HTML, but provided as a
    Python dictionary or resp. JSON string. See [`TextPage.extractDICT()`](textpage.html#TextPage.extractDICT
    "TextPage.extractDICT") for details of its structure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**“rawdict”** / **“rawjson”**: a super-set of **“dict”** / **“json”**. It additionally
    provides character detail information like XML. See [`TextPage.extractRAWDICT()`](textpage.html#TextPage.extractRAWDICT
    "TextPage.extractRAWDICT") for details of its structure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**“xhtml”**: text information level as the TEXT version but includes images.
    Can also be displayed by internet browsers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**“xml”**: contains no images, but full position and font information down
    to each single text character. Use an XML module to interpret.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To give you an idea about the output of these alternatives, we did text example
    extracts. See [Appendix 2: Considerations on Embedded Files](app2.html#appendix2).'
  prefs: []
  type: TYPE_NORMAL
- en: Searching for Text
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can find out, exactly where on a page a certain text string appears:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This delivers a list of rectangles (see [Rect](rect.html#rect)), each of which
    surrounds one occurrence of the string “mupdf” (case insensitive). You could use
    this information to e.g. highlight those areas (PDF only) or create a cross reference
    of the document.
  prefs: []
  type: TYPE_NORMAL
- en: 'Please also do have a look at chapter [Working together: DisplayList and TextPage](coop_low.html#cooperation)
    and at demo programs [demo.py](https://github.com/pymupdf/PyMuPDF-Utilities/tree/master/demo/demo.py)
    and [demo-lowlevel.py](https://github.com/pymupdf/PyMuPDF-Utilities/tree/master/demo/demo-lowlevel.py).
    Among other things they contain details on how the [TextPage](textpage.html#textpage),
    [Device](device.html#device) and [DisplayList](displaylist.html#displaylist) classes
    can be used for a more direct control, e.g. when performance considerations suggest
    it.'
  prefs: []
  type: TYPE_NORMAL
- en: Inspecting the Links, Annotations or Form Fields of a Page
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Links are shown as “hot areas” when a document is displayed with some viewer
    software. If you click while your cursor shows a hand symbol, you will usually
    be taken to the target that is encoded in that hot area. Here is how to get all
    links:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '*links* is a Python list of dictionaries. For details see [`Page.get_links()`](page.html#Page.get_links
    "Page.get_links").'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use an iterator which emits one link at a time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'If dealing with a PDF document page, there may also exist annotations ([Annot](annot.html#annot))
    or form fields ([Widget](widget.html#widget)), each of which have their own iterators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Rendering a Page
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This example creates a **raster** image of a page’s content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '*pix* is a [Pixmap](pixmap.html#pixmap) object which (in this case) contains
    an **RGB** image of the page, ready to be used for many purposes. Method [`Page.get_pixmap()`](page.html#Page.get_pixmap
    "Page.get_pixmap") offers lots of variations for controlling the image: resolution
    / DPI, colorspace (e.g. to produce a grayscale image or an image with a subtractive
    color scheme), transparency, rotation, mirroring, shifting, shearing, etc. For
    example: to create an **RGBA** image (i.e. containing an alpha channel), specify
    *pix = page.get_pixmap(alpha=True)*.'
  prefs: []
  type: TYPE_NORMAL
- en: A [Pixmap](pixmap.html#pixmap) contains a number of methods and attributes which
    are referenced below. Among them are the integers *width*, *height* (each in pixels)
    and *stride* (number of bytes of one horizontal image line). Attribute *samples*
    represents a rectangular area of bytes representing the image data (a Python *bytes*
    object).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can also create a **vector** image of a page by using [`Page.get_svg_image()`](page.html#Page.get_svg_image
    "Page.get_svg_image"). Refer to this [Vector Image Support page](https://github.com/pymupdf/PyMuPDF/wiki/Vector-Image-Support)
    for details.
  prefs: []
  type: TYPE_NORMAL
- en: Saving the Page Image in a File
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can simply store the image in a PNG file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Displaying the Image in GUIs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can also use it in GUI dialog managers. [`Pixmap.samples`](pixmap.html#Pixmap.samples
    "Pixmap.samples") represents an area of bytes of all the pixels as a Python bytes
    object. Here are some examples, find more in the [examples](https://github.com/pymupdf/PyMuPDF/tree/master/examples)
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: wxPython
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Consult their documentation for adjustments to RGB(A) pixmaps and, potentially,
    specifics for your wxPython release:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Tkinter
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Please also see section 3.19 of the [Pillow documentation](https://Pillow.readthedocs.io):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The following **avoids using Pillow**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: If you are looking for a complete Tkinter script paging through **any supported**
    document, [here it is!](https://github.com/pymupdf/PyMuPDF-Utilities/blob/master/examples/browse-document/browse.py).
    It can also zoom into pages, and it runs under Python 2 or 3\. It requires the
    extremely handy [PySimpleGUI](https://pypi.org/project/PySimpleGUI/) pure Python
    package.
  prefs: []
  type: TYPE_NORMAL
- en: PyQt4, PyQt5, PySide
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Please also see section 3.16 of the [Pillow documentation](https://Pillow.readthedocs.io):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, you also can get along **without using Pillow.** Qt’s `QImage` luckily
    supports native Python pointers, so the following is the recommended way to create
    Qt images:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: wxPython
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Consult their documentation for adjustments to RGB(A) pixmaps and, potentially,
    specifics for your wxPython release:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Tkinter
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Please also see section 3.19 of the [Pillow documentation](https://Pillow.readthedocs.io):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The following **avoids using Pillow**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: If you are looking for a complete Tkinter script paging through **any supported**
    document, [here it is!](https://github.com/pymupdf/PyMuPDF-Utilities/blob/master/examples/browse-document/browse.py).
    It can also zoom into pages, and it runs under Python 2 or 3\. It requires the
    extremely handy [PySimpleGUI](https://pypi.org/project/PySimpleGUI/) pure Python
    package.
  prefs: []
  type: TYPE_NORMAL
- en: PyQt4, PyQt5, PySide
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Please also see section 3.16 of the [Pillow documentation](https://Pillow.readthedocs.io):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, you also can get along **without using Pillow.** Qt’s `QImage` luckily
    supports native Python pointers, so the following is the recommended way to create
    Qt images:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Extracting Text and Images
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can also extract all text, images and other information of a page in many
    different forms, and levels of detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Use one of the following strings for *opt* to obtain different formats [[2]](#f2):'
  prefs: []
  type: TYPE_NORMAL
- en: '**“text”**: (default) plain text with line breaks. No formatting, no text position
    details, no images.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**“blocks”**: generate a list of text blocks (= paragraphs).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**“words”**: generate a list of words (strings not containing spaces).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**“html”**: creates a full visual version of the page including any images.
    This can be displayed with your internet browser.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**“dict”** / **“json”**: same information level as HTML, but provided as a
    Python dictionary or resp. JSON string. See [`TextPage.extractDICT()`](textpage.html#TextPage.extractDICT
    "TextPage.extractDICT") for details of its structure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**“rawdict”** / **“rawjson”**: a super-set of **“dict”** / **“json”**. It additionally
    provides character detail information like XML. See [`TextPage.extractRAWDICT()`](textpage.html#TextPage.extractRAWDICT
    "TextPage.extractRAWDICT") for details of its structure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**“xhtml”**: text information level as the TEXT version but includes images.
    Can also be displayed by internet browsers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**“xml”**: contains no images, but full position and font information down
    to each single text character. Use an XML module to interpret.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To give you an idea about the output of these alternatives, we did text example
    extracts. See [Appendix 2: Considerations on Embedded Files](app2.html#appendix2).'
  prefs: []
  type: TYPE_NORMAL
- en: Searching for Text
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can find out, exactly where on a page a certain text string appears:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: This delivers a list of rectangles (see [Rect](rect.html#rect)), each of which
    surrounds one occurrence of the string “mupdf” (case insensitive). You could use
    this information to e.g. highlight those areas (PDF only) or create a cross reference
    of the document.
  prefs: []
  type: TYPE_NORMAL
- en: 'Please also do have a look at chapter [Working together: DisplayList and TextPage](coop_low.html#cooperation)
    and at demo programs [demo.py](https://github.com/pymupdf/PyMuPDF-Utilities/tree/master/demo/demo.py)
    and [demo-lowlevel.py](https://github.com/pymupdf/PyMuPDF-Utilities/tree/master/demo/demo-lowlevel.py).
    Among other things they contain details on how the [TextPage](textpage.html#textpage),
    [Device](device.html#device) and [DisplayList](displaylist.html#displaylist) classes
    can be used for a more direct control, e.g. when performance considerations suggest
    it.'
  prefs: []
  type: TYPE_NORMAL
- en: '## Stories: Generating PDF from HTML Source'
  prefs: []
  type: TYPE_NORMAL
- en: The [Story](story-class.html#story) class is a new feature of PyMuPDF version
    1.21.0\. It represents support for MuPDF’s **“story”** interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a quote from the book [“MuPDF Explored”](https://mupdf.com/docs/mupdf-explored.html)
    by Robin Watts from [Artifex](https://www.artifex.com):'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '*Stories provide a way to easily layout styled content for use with devices,
    such as those offered by Document Writers (…). The concept of a story comes from
    desktop publishing, which in turn (…) gets it from newspapers. If you consider
    a traditional newspaper layout, it will consist of various news articles (stories)
    that are laid out into multiple columns, possibly across multiple pages.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Accordingly, MuPDF uses a story to represent a flow of text with styling information.
    The user of the story can then supply a sequence of rectangles into which the
    story will be laid out, and the positioned text can then be drawn to an output
    device. This keeps the concept of the text itself (the story) to be separated
    from the areas into which the text should be flowed (the layout).*'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'A Story works somewhat similar to an internet browser: It faithfully parses
    and renders HTML hypertext and also optional stylesheets (CSS). But its **output
    is a PDF** – not web pages.'
  prefs: []
  type: TYPE_NORMAL
- en: When creating a [Story](story-class.html#story), the input from up to three
    different information sources is taken into account. All these items are optional.
  prefs: []
  type: TYPE_NORMAL
- en: HTML source code, either a Python string or **created by the script** using
    methods of [Xml](xml-class.html#xml).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: CSS (Cascaded Style Sheet) source code, provided as a Python string. CSS can
    be used to provide styling information (text font size, color, etc.) like it would
    happen for web pages. Obviously, this string may also be read from a file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An [Archive](archive-class.html#archive) **must be used** whenever the DOM references
    images, or uses text fonts except the standard [PDF Base 14 Fonts](app3.html#base-14-fonts),
    CJK fonts and the NOTO fonts generated into the PyMuPDF binary.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The [API](xml-class.html#xml) allows creating DOMs completely from scratch,
    including desired styling information. It can also be used to modify or extend
    **provided** HTML: text can be deleted or replaced, or its styling can be changed.
    Text – for example extracted from databases – can also be added and fill template-like
    HTML documents.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It is **not required** to provide syntactically complete HTML documents: snippets
    like `<b>Hello` are fully accepted, and many / most syntax errors are automatically
    corrected.'
  prefs: []
  type: TYPE_NORMAL
- en: After the HTML is considered complete, it can be used to create a PDF document.
    This happens via the new [DocumentWriter](document-writer-class.html#documentwriter)
    class. The programmer calls its methods to create a new empty page, and passes
    rectangles to the Story to fill them.
  prefs: []
  type: TYPE_NORMAL
- en: The story in turn will return completion codes indicating whether or not more
    content is waiting to be written. Which part of the content will land in which
    rectangle or on which page is automatically determined by the story itself – it
    cannot be influenced other than by providing the rectangles.
  prefs: []
  type: TYPE_NORMAL
- en: Please see the [Stories recipes](recipes-stories.html#recipesstories) for a
    number of typical use cases.
  prefs: []
  type: TYPE_NORMAL
- en: PDF Maintenance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: PDFs are the only document type that can be **modified** using PyMuPDF. Other
    file types are read-only.
  prefs: []
  type: TYPE_NORMAL
- en: However, you can convert **any document** (including images) to a PDF and then
    apply all PyMuPDF features to the conversion result. Find out more here [`Document.convert_to_pdf()`](document.html#Document.convert_to_pdf
    "Document.convert_to_pdf"), and also look at the demo script [pdf-converter.py](https://github.com/pymupdf/PyMuPDF-Utilities/blob/master/examples/convert-document/convert.py)
    which can convert any [supported document](how-to-open-a-file.html#supported-file-types)
    to PDF.
  prefs: []
  type: TYPE_NORMAL
- en: '[`Document.save()`](document.html#Document.save "Document.save") always stores
    a PDF in its current (potentially modified) state on disk.'
  prefs: []
  type: TYPE_NORMAL
- en: You normally can choose whether to save to a new file, or just append your modifications
    to the existing one (“incremental save”), which often is very much faster.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following describes ways how you can manipulate PDF documents. This description
    is by no means complete: much more can be found in the following chapters.'
  prefs: []
  type: TYPE_NORMAL
- en: Modifying, Creating, Re-arranging and Deleting Pages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are several ways to manipulate the so-called **page tree** (a structure
    describing all the pages) of a PDF:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Document.delete_page()`](document.html#Document.delete_page "Document.delete_page")
    and [`Document.delete_pages()`](document.html#Document.delete_pages "Document.delete_pages")
    delete pages.'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Document.copy_page()`](document.html#Document.copy_page "Document.copy_page"),
    [`Document.fullcopy_page()`](document.html#Document.fullcopy_page "Document.fullcopy_page")
    and [`Document.move_page()`](document.html#Document.move_page "Document.move_page")
    copy or move a page to other locations within the same document.'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Document.select()`](document.html#Document.select "Document.select") shrinks
    a PDF down to selected pages. Parameter is a sequence [[3]](#f3) of the page numbers
    that you want to keep. These integers must all be in range *0 <= i < page_count*.
    When executed, all pages **missing** in this list will be deleted. Remaining pages
    will occur **in the sequence and as many times (!) as you specify them**.'
  prefs: []
  type: TYPE_NORMAL
- en: So you can easily create new PDFs with
  prefs: []
  type: TYPE_NORMAL
- en: the first or last 10 pages,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: only the odd or only the even pages (for doing double-sided printing),
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: pages that **do** or **don’t** contain a given text,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: reverse the page sequence, …
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: … whatever you can think of.
  prefs: []
  type: TYPE_NORMAL
- en: The saved new document will contain links, annotations and bookmarks that are
    still valid (i.a.w. either pointing to a selected page or to some external resource).
  prefs: []
  type: TYPE_NORMAL
- en: '[`Document.insert_page()`](document.html#Document.insert_page "Document.insert_page")
    and [`Document.new_page()`](document.html#Document.new_page "Document.new_page")
    insert new pages.'
  prefs: []
  type: TYPE_NORMAL
- en: Pages themselves can moreover be modified by a range of methods (e.g. page rotation,
    annotation and link maintenance, text and image insertion).
  prefs: []
  type: TYPE_NORMAL
- en: Joining and Splitting PDF Documents
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Method [`Document.insert_pdf()`](document.html#Document.insert_pdf "Document.insert_pdf")
    copies pages **between different** PDF documents. Here is a simple **joiner**
    example (*doc1* and *doc2* being opened PDFs):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a snippet that **splits** *doc1*. It creates a new document of its
    first and its last 10 pages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: More can be found in the [Document](document.html#document) chapter. Also have
    a look at [PDFjoiner.py](https://github.com/pymupdf/PyMuPDF-Utilities/blob/master/examples/join-documents/join.py).
  prefs: []
  type: TYPE_NORMAL
- en: Embedding Data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: PDFs can be used as containers for arbitrary data (executables, other PDFs,
    text or binary files, etc.) much like ZIP archives.
  prefs: []
  type: TYPE_NORMAL
- en: PyMuPDF fully supports this feature via [Document](document.html#document) *embfile_**
    methods and attributes. For some detail read Appendix 3, consult the Wiki on [dealing
    with embedding files](https://github.com/pymupdf/PyMuPDF/wiki/Dealing-with-Embedded-Files),
    or the example scripts [embedded-copy.py](https://github.com/pymupdf/PyMuPDF-Utilities/blob/master/examples/copy-embedded/copy.py),
    [embedded-export.py](https://github.com/pymupdf/PyMuPDF-Utilities/blob/master/examples/export-embedded/export.py),
    [embedded-import.py](https://github.com/pymupdf/PyMuPDF-Utilities/blob/master/examples/import-embedded/import.py),
    and [embedded-list.py](https://github.com/pymupdf/PyMuPDF-Utilities/blob/master/examples/list-embedded/list.py).
  prefs: []
  type: TYPE_NORMAL
- en: Saving
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As mentioned above, [`Document.save()`](document.html#Document.save "Document.save")
    will **always** save the document in its current state.
  prefs: []
  type: TYPE_NORMAL
- en: You can write changes back to the **original PDF** by specifying option *incremental=True*.
    This process is (usually) **extremely fast**, since changes are **appended to
    the original file** without completely rewriting it.
  prefs: []
  type: TYPE_NORMAL
- en: '[`Document.save()`](document.html#Document.save "Document.save") options correspond
    to options of MuPDF’s command line utility *mutool clean*, see the following table.'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Save Option** | **mutool** | **Effect** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| garbage=1 | g | garbage collect unused objects |'
  prefs: []
  type: TYPE_TB
- en: '| garbage=2 | gg | in addition to 1, compact [`xref`](glossary.html#xref "xref")
    tables |'
  prefs: []
  type: TYPE_TB
- en: '| garbage=3 | ggg | in addition to 2, merge duplicate objects |'
  prefs: []
  type: TYPE_TB
- en: '| garbage=4 | gggg | in addition to 3, merge duplicate stream content |'
  prefs: []
  type: TYPE_TB
- en: '| clean=True | cs | clean and sanitize content streams |'
  prefs: []
  type: TYPE_TB
- en: '| deflate=True | z | deflate uncompressed streams |'
  prefs: []
  type: TYPE_TB
- en: '| deflate_images=True | i | deflate image streams |'
  prefs: []
  type: TYPE_TB
- en: '| deflate_fonts=True | f | deflate fontfile streams |'
  prefs: []
  type: TYPE_TB
- en: '| ascii=True | a | convert binary data to ASCII format |'
  prefs: []
  type: TYPE_TB
- en: '| linear=True | l | create a linearized version |'
  prefs: []
  type: TYPE_TB
- en: '| expand=True | d | decompress all streams |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: For an explanation of terms like *object, stream, xref* consult the [Glossary](glossary.html#glossary)
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: For example, *mutool clean -ggggz file.pdf* yields excellent compression results.
    It corresponds to *doc.save(filename, garbage=4, deflate=True)*.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying, Creating, Re-arranging and Deleting Pages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are several ways to manipulate the so-called **page tree** (a structure
    describing all the pages) of a PDF:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Document.delete_page()`](document.html#Document.delete_page "Document.delete_page")
    and [`Document.delete_pages()`](document.html#Document.delete_pages "Document.delete_pages")
    delete pages.'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Document.copy_page()`](document.html#Document.copy_page "Document.copy_page"),
    [`Document.fullcopy_page()`](document.html#Document.fullcopy_page "Document.fullcopy_page")
    and [`Document.move_page()`](document.html#Document.move_page "Document.move_page")
    copy or move a page to other locations within the same document.'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Document.select()`](document.html#Document.select "Document.select") shrinks
    a PDF down to selected pages. Parameter is a sequence [[3]](#f3) of the page numbers
    that you want to keep. These integers must all be in range *0 <= i < page_count*.
    When executed, all pages **missing** in this list will be deleted. Remaining pages
    will occur **in the sequence and as many times (!) as you specify them**.'
  prefs: []
  type: TYPE_NORMAL
- en: So you can easily create new PDFs with
  prefs: []
  type: TYPE_NORMAL
- en: the first or last 10 pages,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: only the odd or only the even pages (for doing double-sided printing),
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: pages that **do** or **don’t** contain a given text,
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: reverse the page sequence, …
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: … whatever you can think of.
  prefs: []
  type: TYPE_NORMAL
- en: The saved new document will contain links, annotations and bookmarks that are
    still valid (i.a.w. either pointing to a selected page or to some external resource).
  prefs: []
  type: TYPE_NORMAL
- en: '[`Document.insert_page()`](document.html#Document.insert_page "Document.insert_page")
    and [`Document.new_page()`](document.html#Document.new_page "Document.new_page")
    insert new pages.'
  prefs: []
  type: TYPE_NORMAL
- en: Pages themselves can moreover be modified by a range of methods (e.g. page rotation,
    annotation and link maintenance, text and image insertion).
  prefs: []
  type: TYPE_NORMAL
- en: Joining and Splitting PDF Documents
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Method [`Document.insert_pdf()`](document.html#Document.insert_pdf "Document.insert_pdf")
    copies pages **between different** PDF documents. Here is a simple **joiner**
    example (*doc1* and *doc2* being opened PDFs):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is a snippet that **splits** *doc1*. It creates a new document of its
    first and its last 10 pages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: More can be found in the [Document](document.html#document) chapter. Also have
    a look at [PDFjoiner.py](https://github.com/pymupdf/PyMuPDF-Utilities/blob/master/examples/join-documents/join.py).
  prefs: []
  type: TYPE_NORMAL
- en: Embedding Data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: PDFs can be used as containers for arbitrary data (executables, other PDFs,
    text or binary files, etc.) much like ZIP archives.
  prefs: []
  type: TYPE_NORMAL
- en: PyMuPDF fully supports this feature via [Document](document.html#document) *embfile_**
    methods and attributes. For some detail read Appendix 3, consult the Wiki on [dealing
    with embedding files](https://github.com/pymupdf/PyMuPDF/wiki/Dealing-with-Embedded-Files),
    or the example scripts [embedded-copy.py](https://github.com/pymupdf/PyMuPDF-Utilities/blob/master/examples/copy-embedded/copy.py),
    [embedded-export.py](https://github.com/pymupdf/PyMuPDF-Utilities/blob/master/examples/export-embedded/export.py),
    [embedded-import.py](https://github.com/pymupdf/PyMuPDF-Utilities/blob/master/examples/import-embedded/import.py),
    and [embedded-list.py](https://github.com/pymupdf/PyMuPDF-Utilities/blob/master/examples/list-embedded/list.py).
  prefs: []
  type: TYPE_NORMAL
- en: Saving
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As mentioned above, [`Document.save()`](document.html#Document.save "Document.save")
    will **always** save the document in its current state.
  prefs: []
  type: TYPE_NORMAL
- en: You can write changes back to the **original PDF** by specifying option *incremental=True*.
    This process is (usually) **extremely fast**, since changes are **appended to
    the original file** without completely rewriting it.
  prefs: []
  type: TYPE_NORMAL
- en: '[`Document.save()`](document.html#Document.save "Document.save") options correspond
    to options of MuPDF’s command line utility *mutool clean*, see the following table.'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Save Option** | **mutool** | **Effect** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| garbage=1 | g | garbage collect unused objects |'
  prefs: []
  type: TYPE_TB
- en: '| garbage=2 | gg | in addition to 1, compact [`xref`](glossary.html#xref "xref")
    tables |'
  prefs: []
  type: TYPE_TB
- en: '| garbage=3 | ggg | in addition to 2, merge duplicate objects |'
  prefs: []
  type: TYPE_TB
- en: '| garbage=4 | gggg | in addition to 3, merge duplicate stream content |'
  prefs: []
  type: TYPE_TB
- en: '| clean=True | cs | clean and sanitize content streams |'
  prefs: []
  type: TYPE_TB
- en: '| deflate=True | z | deflate uncompressed streams |'
  prefs: []
  type: TYPE_TB
- en: '| deflate_images=True | i | deflate image streams |'
  prefs: []
  type: TYPE_TB
- en: '| deflate_fonts=True | f | deflate fontfile streams |'
  prefs: []
  type: TYPE_TB
- en: '| ascii=True | a | convert binary data to ASCII format |'
  prefs: []
  type: TYPE_TB
- en: '| linear=True | l | create a linearized version |'
  prefs: []
  type: TYPE_TB
- en: '| expand=True | d | decompress all streams |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: For an explanation of terms like *object, stream, xref* consult the [Glossary](glossary.html#glossary)
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: For example, *mutool clean -ggggz file.pdf* yields excellent compression results.
    It corresponds to *doc.save(filename, garbage=4, deflate=True)*.
  prefs: []
  type: TYPE_NORMAL
- en: Closing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is often desirable to “close” a document to relinquish control of the underlying
    file to the OS, while your program continues.
  prefs: []
  type: TYPE_NORMAL
- en: This can be achieved by the [`Document.close()`](document.html#Document.close
    "Document.close") method. Apart from closing the underlying file, buffer areas
    associated with the document will be freed.
  prefs: []
  type: TYPE_NORMAL
- en: Further Reading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Also have a look at PyMuPDF’s [Wiki](https://github.com/pymupdf/PyMuPDF/wiki)
    pages. Especially those named in the sidebar under title **“Recipes”** cover over
    15 topics written in “How-To” style.
  prefs: []
  type: TYPE_NORMAL
- en: This document also contains a [FAQ](faq.html#faq). This chapter has close connection
    to the aforementioned recipes, and it will be extended with more content over
    time.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: Footnotes
  prefs: []
  type: TYPE_NORMAL
- en: Do you have any feedback on this page?
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: This software is provided AS-IS with no warranty, either express or implied.
    This software is distributed under license and may not be copied, modified or
    distributed except as expressly authorized under the terms of that license. Refer
    to licensing information at [artifex.com](https://www.artifex.com?utm_source=rtd-pymupdf&utm_medium=rtd&utm_content=footer-link)
    or contact Artifex Software Inc., 39 Mesa Street, Suite 108A, San Francisco CA
    94129, United States for further information.
  prefs: []
  type: TYPE_NORMAL
- en: This documentation covers all versions up to 1.24.4.
  prefs: []
  type: TYPE_NORMAL
- en: '[![Discord logo](../Images/66cbb5081103a580193aa66c87b90d9a.png)](https://discord.gg/TSpYGBW4eq)'
  prefs: []
  type: TYPE_NORMAL
