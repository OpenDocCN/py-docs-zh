- en: Mapping Class Inheritance Hierarchies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.sqlalchemy.org/en/20/orm/inheritance.html](https://docs.sqlalchemy.org/en/20/orm/inheritance.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'SQLAlchemy supports three forms of inheritance:'
  prefs: []
  type: TYPE_NORMAL
- en: '**single table inheritance** – several types of classes are represented by
    a single table;'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**concrete table inheritance** – each type of class is represented by independent
    tables;'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**joined table inheritance** – the class hierarchy is broken up among dependent
    tables. Each class represented by its own table that only includes those attributes
    local to that class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The most common forms of inheritance are single and joined table, while concrete
    inheritance presents more configurational challenges.
  prefs: []
  type: TYPE_NORMAL
- en: When mappers are configured in an inheritance relationship, SQLAlchemy has the
    ability to load elements [polymorphically](../glossary.html#term-polymorphically),
    meaning that a single query can return objects of multiple types.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Writing SELECT statements for Inheritance Mappings](queryguide/inheritance.html#loading-joined-inheritance)
    - in the [ORM Querying Guide](queryguide/index.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Inheritance Mapping Recipes](examples.html#examples-inheritance) - complete
    examples of joined, single and concrete inheritance'
  prefs: []
  type: TYPE_NORMAL
- en: '## Joined Table Inheritance'
  prefs: []
  type: TYPE_NORMAL
- en: In joined table inheritance, each class along a hierarchy of classes is represented
    by a distinct table. Querying for a particular subclass in the hierarchy will
    render as a SQL JOIN along all tables in its inheritance path. If the queried
    class is the base class, the base table is queried instead, with options to include
    other tables at the same time or to allow attributes specific to sub-tables to
    load later.
  prefs: []
  type: TYPE_NORMAL
- en: In all cases, the ultimate class to instantiate for a given row is determined
    by a [discriminator](../glossary.html#term-discriminator) column or SQL expression,
    defined on the base class, which will yield a scalar value that is associated
    with a particular subclass.
  prefs: []
  type: TYPE_NORMAL
- en: 'The base class in a joined inheritance hierarchy is configured with additional
    arguments that will indicate to the polymorphic discriminator column, and optionally
    a polymorphic identifier for the base class itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the above example, the discriminator is the `type` column, whichever is configured
    using the [`Mapper.polymorphic_on`](mapping_api.html#sqlalchemy.orm.Mapper.params.polymorphic_on
    "sqlalchemy.orm.Mapper") parameter. This parameter accepts a column-oriented expression,
    specified either as a string name of the mapped attribute to use or as a column
    expression object such as [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") or [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct.
  prefs: []
  type: TYPE_NORMAL
- en: The discriminator column will store a value which indicates the type of object
    represented within the row. The column may be of any datatype, though string and
    integer are the most common. The actual data value to be applied to this column
    for a particular row in the database is specified using the [`Mapper.polymorphic_identity`](mapping_api.html#sqlalchemy.orm.Mapper.params.polymorphic_identity
    "sqlalchemy.orm.Mapper") parameter, described below.
  prefs: []
  type: TYPE_NORMAL
- en: While a polymorphic discriminator expression is not strictly necessary, it is
    required if polymorphic loading is desired. Establishing a column on the base
    table is the easiest way to achieve this, however very sophisticated inheritance
    mappings may make use of SQL expressions, such as a CASE expression, as the polymorphic
    discriminator.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Currently, **only one discriminator column or SQL expression may be configured
    for the entire inheritance hierarchy**, typically on the base- most class in the
    hierarchy. “Cascading” polymorphic discriminator expressions are not yet supported.
  prefs: []
  type: TYPE_NORMAL
- en: 'We next define `Engineer` and `Manager` subclasses of `Employee`. Each contains
    columns that represent the attributes unique to the subclass they represent. Each
    table also must contain a primary key column (or columns), as well as a foreign
    key reference to the parent table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the above example, each mapping specifies the [`Mapper.polymorphic_identity`](mapping_api.html#sqlalchemy.orm.Mapper.params.polymorphic_identity
    "sqlalchemy.orm.Mapper") parameter within its mapper arguments. This value populates
    the column designated by the [`Mapper.polymorphic_on`](mapping_api.html#sqlalchemy.orm.Mapper.params.polymorphic_on
    "sqlalchemy.orm.Mapper") parameter established on the base mapper. The [`Mapper.polymorphic_identity`](mapping_api.html#sqlalchemy.orm.Mapper.params.polymorphic_identity
    "sqlalchemy.orm.Mapper") parameter should be unique to each mapped class across
    the whole hierarchy, and there should only be one “identity” per mapped class;
    as noted above, “cascading” identities where some subclasses introduce a second
    identity are not supported.
  prefs: []
  type: TYPE_NORMAL
- en: The ORM uses the value set up by [`Mapper.polymorphic_identity`](mapping_api.html#sqlalchemy.orm.Mapper.params.polymorphic_identity
    "sqlalchemy.orm.Mapper") in order to determine which class a row belongs towards
    when loading rows polymorphically. In the example above, every row which represents
    an `Employee` will have the value `'employee'` in its `type` column; similarly,
    every `Engineer` will get the value `'engineer'`, and each `Manager` will get
    the value `'manager'`. Regardless of whether the inheritance mapping uses distinct
    joined tables for subclasses as in joined table inheritance, or all one table
    as in single table inheritance, this value is expected to be persisted and available
    to the ORM when querying. The [`Mapper.polymorphic_identity`](mapping_api.html#sqlalchemy.orm.Mapper.params.polymorphic_identity
    "sqlalchemy.orm.Mapper") parameter also applies to concrete table inheritance,
    but is not actually persisted; see the later section at [Concrete Table Inheritance](#concrete-inheritance)
    for details.
  prefs: []
  type: TYPE_NORMAL
- en: In a polymorphic setup, it is most common that the foreign key constraint is
    established on the same column or columns as the primary key itself, however this
    is not required; a column distinct from the primary key may also be made to refer
    to the parent via foreign key. The way that a JOIN is constructed from the base
    table to subclasses is also directly customizable, however this is rarely necessary.
  prefs: []
  type: TYPE_NORMAL
- en: With the joined inheritance mapping complete, querying against `Employee` will
    return a combination of `Employee`, `Engineer` and `Manager` objects. Newly saved
    `Engineer`, `Manager`, and `Employee` objects will automatically populate the
    `employee.type` column with the correct “discriminator” value in this case `"engineer"`,
    `"manager"`, or `"employee"`, as appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: Relationships with Joined Inheritance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Relationships are fully supported with joined table inheritance. The relationship
    involving a joined-inheritance class should target the class in the hierarchy
    that also corresponds to the foreign key constraint; below, as the `employee`
    table has a foreign key constraint back to the `company` table, the relationships
    are set up between `Company` and `Employee`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If the foreign key constraint is on a table corresponding to a subclass, the
    relationship should target that subclass instead. In the example below, there
    is a foreign key constraint from `manager` to `company`, so the relationships
    are established between the `Manager` and `Company` classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Above, the `Manager` class will have a `Manager.company` attribute; `Company`
    will have a `Company.managers` attribute that always loads against a join of the
    `employee` and `manager` tables together.
  prefs: []
  type: TYPE_NORMAL
- en: Loading Joined Inheritance Mappings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'See the section [Writing SELECT statements for Inheritance Mappings](queryguide/inheritance.html)
    for background on inheritance loading techniques, including configuration of tables
    to be queried both at mapper configuration time as well as query time.  ## Single
    Table Inheritance'
  prefs: []
  type: TYPE_NORMAL
- en: Single table inheritance represents all attributes of all subclasses within
    a single table. A particular subclass that has attributes unique to that class
    will persist them within columns in the table that are otherwise NULL if the row
    refers to a different kind of object.
  prefs: []
  type: TYPE_NORMAL
- en: Querying for a particular subclass in the hierarchy will render as a SELECT
    against the base table, which will include a WHERE clause that limits rows to
    those with a particular value or values present in the discriminator column or
    expression.
  prefs: []
  type: TYPE_NORMAL
- en: Single table inheritance has the advantage of simplicity compared to joined
    table inheritance; queries are much more efficient as only one table needs to
    be involved in order to load objects of every represented class.
  prefs: []
  type: TYPE_NORMAL
- en: Single-table inheritance configuration looks much like joined-table inheritance,
    except only the base class specifies `__tablename__`. A discriminator column is
    also required on the base table so that classes can be differentiated from each
    other.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even though subclasses share the base table for all of their attributes, when
    using Declarative, [`mapped_column`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") objects may still be specified on subclasses,
    indicating that the column is to be mapped only to that subclass; the [`mapped_column`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") will be applied to the same base [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note that the mappers for the derived classes Manager and Engineer omit the
    `__tablename__`, indicating they do not have a mapped table of their own. Additionally,
    a [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    directive with `nullable=True` is included; as the Python types declared for these
    classes do not include `Optional[]`, the column would normally be mapped as `NOT
    NULL`, which would not be appropriate as this column only expects to be populated
    for those rows that correspond to that particular subclass.
  prefs: []
  type: TYPE_NORMAL
- en: '### Resolving Column Conflicts with `use_existing_column`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note in the previous section that the `manager_name` and `engineer_info` columns
    are “moved up” to be applied to `Employee.__table__`, as a result of their declaration
    on a subclass that has no table of its own. A tricky case comes up when two subclasses
    want to specify *the same* column, as below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Above, the `start_date` column declared on both `Engineer` and `Manager` will
    result in an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The above scenario presents an ambiguity to the Declarative mapping system
    that may be resolved by using the [`mapped_column.use_existing_column`](mapping_api.html#sqlalchemy.orm.mapped_column.params.use_existing_column
    "sqlalchemy.orm.mapped_column") parameter on [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column"), which instructs [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") to look on the inheriting superclass present and
    use the column that’s already mapped, if already present, else to map a new column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Above, when `Manager` is mapped, the `start_date` column is already present
    on the `Employee` class, having been provided by the `Engineer` mapping already.
    The [`mapped_column.use_existing_column`](mapping_api.html#sqlalchemy.orm.mapped_column.params.use_existing_column
    "sqlalchemy.orm.mapped_column") parameter indicates to [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") that it should look for the requested [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") on the mapped [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") for `Employee` first, and if present, maintain that
    existing mapping. If not present, [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") will map the column normally, adding it as one
    of the columns in the [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") referenced by the `Employee` superclass.
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 2.0.0b4: - Added [`mapped_column.use_existing_column`](mapping_api.html#sqlalchemy.orm.mapped_column.params.use_existing_column
    "sqlalchemy.orm.mapped_column"), which provides a 2.0-compatible means of mapping
    a column on an inheriting subclass conditionally. The previous approach which
    combines [`declared_attr`](mapping_api.html#sqlalchemy.orm.declared_attr "sqlalchemy.orm.declared_attr")
    with a lookup on the parent `.__table__` continues to function as well, but lacks
    [**PEP 484**](https://peps.python.org/pep-0484/) typing support.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A similar concept can be used with mixin classes (see [Composing Mapped Hierarchies
    with Mixins](declarative_mixins.html)) to define a particular series of columns
    and/or other mapped attributes from a reusable mixin class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Relationships with Single Table Inheritance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Relationships are fully supported with single table inheritance. Configuration
    is done in the same manner as that of joined inheritance; a foreign key attribute
    should be on the same class that’s the “foreign” side of the relationship:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, like the case of joined inheritance, we can create relationships that
    involve a specific subclass. When queried, the SELECT statement will include a
    WHERE clause that limits the class selection to that subclass or subclasses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Above, the `Manager` class will have a `Manager.company` attribute; `Company`
    will have a `Company.managers` attribute that always loads against the `employee`
    with an additional WHERE clause that limits rows to those with `type = 'manager'`.
  prefs: []
  type: TYPE_NORMAL
- en: '### Building Deeper Hierarchies with `polymorphic_abstract`'
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: When building any kind of inheritance hierarchy, a mapped class may include
    the [`Mapper.polymorphic_abstract`](mapping_api.html#sqlalchemy.orm.Mapper.params.polymorphic_abstract
    "sqlalchemy.orm.Mapper") parameter set to `True`, which indicates that the class
    should be mapped normally, however would not expect to be instantiated directly
    and would not include a [`Mapper.polymorphic_identity`](mapping_api.html#sqlalchemy.orm.Mapper.params.polymorphic_identity
    "sqlalchemy.orm.Mapper"). Subclasses may then be declared as subclasses of this
    mapped class, which themselves can include a [`Mapper.polymorphic_identity`](mapping_api.html#sqlalchemy.orm.Mapper.params.polymorphic_identity
    "sqlalchemy.orm.Mapper") and therefore be used normally. This allows a series
    of subclasses to be referenced at once by a common base class which is considered
    to be “abstract” within the hierarchy, both in queries as well as in [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") declarations. This use differs from the use of
    the [__abstract__](declarative_config.html#declarative-abstract) attribute with
    Declarative, which leaves the target class entirely unmapped and thus not usable
    as a mapped class by itself. [`Mapper.polymorphic_abstract`](mapping_api.html#sqlalchemy.orm.Mapper.params.polymorphic_abstract
    "sqlalchemy.orm.Mapper") may be applied to any class or classes at any level in
    the hierarchy, including on multiple levels at once.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, suppose `Manager` and `Principal` were both to be classified
    against a superclass `Executive`, and `Engineer` and `Sysadmin` were classified
    against a superclass `Technologist`. Neither `Executive` or `Technologist` is
    ever instantiated, therefore have no [`Mapper.polymorphic_identity`](mapping_api.html#sqlalchemy.orm.Mapper.params.polymorphic_identity
    "sqlalchemy.orm.Mapper"). These classes can be configured using [`Mapper.polymorphic_abstract`](mapping_api.html#sqlalchemy.orm.Mapper.params.polymorphic_abstract
    "sqlalchemy.orm.Mapper") as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In the above example, the new classes `Technologist` and `Executive` are ordinary
    mapped classes, and also indicate new columns to be added to the superclass called
    `executive_background` and `competencies`. However, they both lack a setting for
    [`Mapper.polymorphic_identity`](mapping_api.html#sqlalchemy.orm.Mapper.params.polymorphic_identity
    "sqlalchemy.orm.Mapper"); this is because it’s not expected that `Technologist`
    or `Executive` would ever be instantiated directly; we’d always have one of `Manager`,
    `Principal`, `Engineer` or `SysAdmin`. We can however query for `Principal` and
    `Technologist` roles, as well as have them be targets of [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship"). The example below demonstrates a SELECT statement
    for `Technologist` objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Technologist` and `Executive` abstract mapped classes may also be made
    the targets of [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") mappings, like any other mapped class. We can extend
    the above example to include `Company`, with separate collections `Company.technologists`
    and `Company.principals`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the above mapping we can use joins and relationship loading techniques
    across `Company.technologists` and `Company.executives` individually:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[__abstract__](declarative_config.html#declarative-abstract) - Declarative
    parameter which allows a Declarative class to be completely un-mapped within a
    hierarchy, while still extending from a mapped superclass.'
  prefs: []
  type: TYPE_NORMAL
- en: Loading Single Inheritance Mappings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The loading techniques for single-table inheritance are mostly identical to
    those used for joined-table inheritance, and a high degree of abstraction is provided
    between these two mapping types such that it is easy to switch between them as
    well as to intermix them in a single hierarchy (just omit `__tablename__` from
    whichever subclasses are to be single-inheriting). See the sections [Writing SELECT
    statements for Inheritance Mappings](queryguide/inheritance.html) and [SELECT
    Statements for Single Inheritance Mappings](queryguide/inheritance.html#loading-single-inheritance)
    for documentation on inheritance loading techniques, including configuration of
    classes to be queried both at mapper configuration time as well as query time.  ##
    Concrete Table Inheritance'
  prefs: []
  type: TYPE_NORMAL
- en: Concrete inheritance maps each subclass to its own distinct table, each of which
    contains all columns necessary to produce an instance of that class. A concrete
    inheritance configuration by default queries non-polymorphically; a query for
    a particular class will only query that class’ table and only return instances
    of that class. Polymorphic loading of concrete classes is enabled by configuring
    within the mapper a special SELECT that typically is produced as a UNION of all
    the tables.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: Concrete table inheritance is **much more complicated** than joined or single
    table inheritance, and is **much more limited in functionality** especially pertaining
    to using it with relationships, eager loading, and polymorphic loading. When used
    polymorphically it produces **very large queries** with UNIONS that won’t perform
    as well as simple joins. It is strongly advised that if flexibility in relationship
    loading and polymorphic loading is required, that joined or single table inheritance
    be used if at all possible. If polymorphic loading isn’t required, then plain
    non-inheriting mappings can be used if each class refers to its own table completely.
  prefs: []
  type: TYPE_NORMAL
- en: Whereas joined and single table inheritance are fluent in “polymorphic” loading,
    it is a more awkward affair in concrete inheritance. For this reason, concrete
    inheritance is more appropriate when **polymorphic loading is not required**.
    Establishing relationships that involve concrete inheritance classes is also more
    awkward.
  prefs: []
  type: TYPE_NORMAL
- en: 'To establish a class as using concrete inheritance, add the [`Mapper.concrete`](mapping_api.html#sqlalchemy.orm.Mapper.params.concrete
    "sqlalchemy.orm.Mapper") parameter within the `__mapper_args__`. This indicates
    to Declarative as well as the mapping that the superclass table should not be
    considered as part of the mapping:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Two critical points should be noted:'
  prefs: []
  type: TYPE_NORMAL
- en: We must **define all columns explicitly** on each subclass, even those of the
    same name. A column such as `Employee.name` here is **not** copied out to the
    tables mapped by `Manager` or `Engineer` for us.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: while the `Engineer` and `Manager` classes are mapped in an inheritance relationship
    with `Employee`, they still **do not include polymorphic loading**. Meaning, if
    we query for `Employee` objects, the `manager` and `engineer` tables are not queried
    at all.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '### Concrete Polymorphic Loading Configuration'
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphic loading with concrete inheritance requires that a specialized SELECT
    is configured against each base class that should have polymorphic loading. This
    SELECT needs to be capable of accessing all the mapped tables individually, and
    is typically a UNION statement that is constructed using a SQLAlchemy helper [`polymorphic_union()`](mapping_api.html#sqlalchemy.orm.polymorphic_union
    "sqlalchemy.orm.polymorphic_union").
  prefs: []
  type: TYPE_NORMAL
- en: As discussed in [Writing SELECT statements for Inheritance Mappings](queryguide/inheritance.html),
    mapper inheritance configurations of any type can be configured to load from a
    special selectable by default using the [`Mapper.with_polymorphic`](mapping_api.html#sqlalchemy.orm.Mapper.params.with_polymorphic
    "sqlalchemy.orm.Mapper") argument. Current public API requires that this argument
    is set on a [`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper "sqlalchemy.orm.Mapper")
    when it is first constructed.
  prefs: []
  type: TYPE_NORMAL
- en: However, in the case of Declarative, both the mapper and the [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") that is mapped are created at once, the moment the
    mapped class is defined. This means that the [`Mapper.with_polymorphic`](mapping_api.html#sqlalchemy.orm.Mapper.params.with_polymorphic
    "sqlalchemy.orm.Mapper") argument cannot be provided yet, since the [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects that correspond to the subclasses haven’t yet
    been defined.
  prefs: []
  type: TYPE_NORMAL
- en: There are a few strategies available to resolve this cycle, however Declarative
    provides helper classes [`ConcreteBase`](extensions/declarative/index.html#sqlalchemy.ext.declarative.ConcreteBase
    "sqlalchemy.ext.declarative.ConcreteBase") and [`AbstractConcreteBase`](extensions/declarative/index.html#sqlalchemy.ext.declarative.AbstractConcreteBase
    "sqlalchemy.ext.declarative.AbstractConcreteBase") which handle this issue behind
    the scenes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using [`ConcreteBase`](extensions/declarative/index.html#sqlalchemy.ext.declarative.ConcreteBase
    "sqlalchemy.ext.declarative.ConcreteBase"), we can set up our concrete mapping
    in almost the same way as we do other forms of inheritance mappings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Above, Declarative sets up the polymorphic selectable for the `Employee` class
    at mapper “initialization” time; this is the late-configuration step for mappers
    that resolves other dependent mappers. The [`ConcreteBase`](extensions/declarative/index.html#sqlalchemy.ext.declarative.ConcreteBase
    "sqlalchemy.ext.declarative.ConcreteBase") helper uses the [`polymorphic_union()`](mapping_api.html#sqlalchemy.orm.polymorphic_union
    "sqlalchemy.orm.polymorphic_union") function to create a UNION of all concrete-mapped
    tables after all the other classes are set up, and then configures this statement
    with the already existing base-class mapper.
  prefs: []
  type: TYPE_NORMAL
- en: 'Upon select, the polymorphic union produces a query like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The above UNION query needs to manufacture “NULL” columns for each subtable
    in order to accommodate for those columns that aren’t members of that particular
    subclass.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`ConcreteBase`](extensions/declarative/index.html#sqlalchemy.ext.declarative.ConcreteBase
    "sqlalchemy.ext.declarative.ConcreteBase")  ### Abstract Concrete Classes'
  prefs: []
  type: TYPE_NORMAL
- en: The concrete mappings illustrated thus far show both the subclasses as well
    as the base class mapped to individual tables. In the concrete inheritance use
    case, it is common that the base class is not represented within the database,
    only the subclasses. In other words, the base class is “abstract”.
  prefs: []
  type: TYPE_NORMAL
- en: 'Normally, when one would like to map two different subclasses to individual
    tables, and leave the base class unmapped, this can be achieved very easily. When
    using Declarative, just declare the base class with the `__abstract__` indicator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Above, we are not actually making use of SQLAlchemy’s inheritance mapping facilities;
    we can load and persist instances of `Manager` and `Engineer` normally. The situation
    changes however when we need to **query polymorphically**, that is, we’d like
    to emit `select(Employee)` and get back a collection of `Manager` and `Engineer`
    instances. This brings us back into the domain of concrete inheritance, and we
    must build a special mapper against `Employee` in order to achieve this.
  prefs: []
  type: TYPE_NORMAL
- en: To modify our concrete inheritance example to illustrate an “abstract” base
    that is capable of polymorphic loading, we will have only an `engineer` and a
    `manager` table and no `employee` table, however the `Employee` mapper will be
    mapped directly to the “polymorphic union”, rather than specifying it locally
    to the [`Mapper.with_polymorphic`](mapping_api.html#sqlalchemy.orm.Mapper.params.with_polymorphic
    "sqlalchemy.orm.Mapper") parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'To help with this, Declarative offers a variant of the [`ConcreteBase`](extensions/declarative/index.html#sqlalchemy.ext.declarative.ConcreteBase
    "sqlalchemy.ext.declarative.ConcreteBase") class called [`AbstractConcreteBase`](extensions/declarative/index.html#sqlalchemy.ext.declarative.AbstractConcreteBase
    "sqlalchemy.ext.declarative.AbstractConcreteBase") which achieves this automatically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Above, the [`registry.configure()`](mapping_api.html#sqlalchemy.orm.registry.configure
    "sqlalchemy.orm.registry.configure") method is invoked, which will trigger the
    `Employee` class to be actually mapped; before the configuration step, the class
    has no mapping as the sub-tables which it will query from have not yet been defined.
    This process is more complex than that of [`ConcreteBase`](extensions/declarative/index.html#sqlalchemy.ext.declarative.ConcreteBase
    "sqlalchemy.ext.declarative.ConcreteBase"), in that the entire mapping of the
    base class must be delayed until all the subclasses have been declared. With a
    mapping like the above, only instances of `Manager` and `Engineer` may be persisted;
    querying against the `Employee` class will always produce `Manager` and `Engineer`
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the above mapping, queries can be produced in terms of the `Employee`
    class and any attributes that are locally declared upon it, such as the `Employee.name`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The [`AbstractConcreteBase.strict_attrs`](extensions/declarative/index.html#sqlalchemy.ext.declarative.AbstractConcreteBase.params.strict_attrs
    "sqlalchemy.ext.declarative.AbstractConcreteBase") parameter indicates that the
    `Employee` class should directly map only those attributes which are local to
    the `Employee` class, in this case the `Employee.name` attribute. Other attributes
    such as `Manager.manager_data` and `Engineer.engineer_info` are present only on
    their corresponding subclass. When [`AbstractConcreteBase.strict_attrs`](extensions/declarative/index.html#sqlalchemy.ext.declarative.AbstractConcreteBase.params.strict_attrs
    "sqlalchemy.ext.declarative.AbstractConcreteBase") is not set, then all subclass
    attributes such as `Manager.manager_data` and `Engineer.engineer_info` get mapped
    onto the base `Employee` class. This is a legacy mode of use which may be more
    convenient for querying but has the effect that all subclasses share the full
    set of attributes for the whole hierarchy; in the above example, not using [`AbstractConcreteBase.strict_attrs`](extensions/declarative/index.html#sqlalchemy.ext.declarative.AbstractConcreteBase.params.strict_attrs
    "sqlalchemy.ext.declarative.AbstractConcreteBase") would have the effect of generating
    non-useful `Engineer.manager_name` and `Manager.engineer_info` attributes.
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 2.0: Added [`AbstractConcreteBase.strict_attrs`](extensions/declarative/index.html#sqlalchemy.ext.declarative.AbstractConcreteBase.params.strict_attrs
    "sqlalchemy.ext.declarative.AbstractConcreteBase") parameter to [`AbstractConcreteBase`](extensions/declarative/index.html#sqlalchemy.ext.declarative.AbstractConcreteBase
    "sqlalchemy.ext.declarative.AbstractConcreteBase") which produces a cleaner mapping;
    the default is False to allow legacy mappings to continue working as they did
    in 1.x versions.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`AbstractConcreteBase`](extensions/declarative/index.html#sqlalchemy.ext.declarative.AbstractConcreteBase
    "sqlalchemy.ext.declarative.AbstractConcreteBase")'
  prefs: []
  type: TYPE_NORMAL
- en: Classical and Semi-Classical Concrete Polymorphic Configuration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Declarative configurations illustrated with [`ConcreteBase`](extensions/declarative/index.html#sqlalchemy.ext.declarative.ConcreteBase
    "sqlalchemy.ext.declarative.ConcreteBase") and [`AbstractConcreteBase`](extensions/declarative/index.html#sqlalchemy.ext.declarative.AbstractConcreteBase
    "sqlalchemy.ext.declarative.AbstractConcreteBase") are equivalent to two other
    forms of configuration that make use of [`polymorphic_union()`](mapping_api.html#sqlalchemy.orm.polymorphic_union
    "sqlalchemy.orm.polymorphic_union") explicitly. These configurational forms make
    use of the [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    object explicitly so that the “polymorphic union” can be created first, then applied
    to the mappings. These are illustrated here to clarify the role of the [`polymorphic_union()`](mapping_api.html#sqlalchemy.orm.polymorphic_union
    "sqlalchemy.orm.polymorphic_union") function in terms of mapping.
  prefs: []
  type: TYPE_NORMAL
- en: 'A **semi-classical mapping** for example makes use of Declarative, but establishes
    the [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    objects separately:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, the UNION is produced using [`polymorphic_union()`](mapping_api.html#sqlalchemy.orm.polymorphic_union
    "sqlalchemy.orm.polymorphic_union"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'With the above [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    objects, the mappings can be produced using “semi-classical” style, where we use
    Declarative in conjunction with the `__table__` argument; our polymorphic union
    above is passed via `__mapper_args__` to the [`Mapper.with_polymorphic`](mapping_api.html#sqlalchemy.orm.Mapper.params.with_polymorphic
    "sqlalchemy.orm.Mapper") parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, the same [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects can be used in fully “classical” style, without
    using Declarative at all. A constructor similar to that supplied by Declarative
    is illustrated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The “abstract” example can also be mapped using “semi-classical” or “classical”
    style. The difference is that instead of applying the “polymorphic union” to the
    [`Mapper.with_polymorphic`](mapping_api.html#sqlalchemy.orm.Mapper.params.with_polymorphic
    "sqlalchemy.orm.Mapper") parameter, we apply it directly as the mapped selectable
    on our basemost mapper. The semi-classical mapping is illustrated below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Above, we use [`polymorphic_union()`](mapping_api.html#sqlalchemy.orm.polymorphic_union
    "sqlalchemy.orm.polymorphic_union") in the same manner as before, except that
    we omit the `employee` table.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Imperative Mapping](mapping_styles.html#orm-imperative-mapping) - background
    information on imperative, or “classical” mappings'
  prefs: []
  type: TYPE_NORMAL
- en: Relationships with Concrete Inheritance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In a concrete inheritance scenario, mapping relationships is challenging since
    the distinct classes do not share a table. If the relationships only involve specific
    classes, such as a relationship between `Company` in our previous examples and
    `Manager`, special steps aren’t needed as these are just two related tables.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if `Company` is to have a one-to-many relationship to `Employee`,
    indicating that the collection may include both `Engineer` and `Manager` objects,
    that implies that `Employee` must have polymorphic loading capabilities and also
    that each table to be related must have a foreign key back to the `company` table.
    An example of such a configuration is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The next complexity with concrete inheritance and relationships involves when
    we’d like one or all of `Employee`, `Manager` and `Engineer` to themselves refer
    back to `Company`. For this case, SQLAlchemy has special behavior in that a [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") placed on `Employee` which links to `Company` **does
    not work** against the `Manager` and `Engineer` classes, when exercised at the
    instance level. Instead, a distinct [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") must be applied to each class. In order to achieve
    bi-directional behavior in terms of three separate relationships which serve as
    the opposite of `Company.employees`, the [`relationship.back_populates`](relationship_api.html#sqlalchemy.orm.relationship.params.back_populates
    "sqlalchemy.orm.relationship") parameter is used between each of the relationships:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The above limitation is related to the current implementation, including that
    concrete inheriting classes do not share any of the attributes of the superclass
    and therefore need distinct relationships to be set up.
  prefs: []
  type: TYPE_NORMAL
- en: Loading Concrete Inheritance Mappings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The options for loading with concrete inheritance are limited; generally, if
    polymorphic loading is configured on the mapper using one of the declarative concrete
    mixins, it can’t be modified at query time in current SQLAlchemy versions. Normally,
    the [`with_polymorphic()`](queryguide/inheritance.html#sqlalchemy.orm.with_polymorphic
    "sqlalchemy.orm.with_polymorphic") function would be able to override the style
    of loading used by concrete, however due to current limitations this is not yet
    supported.  ## Joined Table Inheritance'
  prefs: []
  type: TYPE_NORMAL
- en: In joined table inheritance, each class along a hierarchy of classes is represented
    by a distinct table. Querying for a particular subclass in the hierarchy will
    render as a SQL JOIN along all tables in its inheritance path. If the queried
    class is the base class, the base table is queried instead, with options to include
    other tables at the same time or to allow attributes specific to sub-tables to
    load later.
  prefs: []
  type: TYPE_NORMAL
- en: In all cases, the ultimate class to instantiate for a given row is determined
    by a [discriminator](../glossary.html#term-discriminator) column or SQL expression,
    defined on the base class, which will yield a scalar value that is associated
    with a particular subclass.
  prefs: []
  type: TYPE_NORMAL
- en: 'The base class in a joined inheritance hierarchy is configured with additional
    arguments that will indicate to the polymorphic discriminator column, and optionally
    a polymorphic identifier for the base class itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In the above example, the discriminator is the `type` column, whichever is configured
    using the [`Mapper.polymorphic_on`](mapping_api.html#sqlalchemy.orm.Mapper.params.polymorphic_on
    "sqlalchemy.orm.Mapper") parameter. This parameter accepts a column-oriented expression,
    specified either as a string name of the mapped attribute to use or as a column
    expression object such as [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") or [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct.
  prefs: []
  type: TYPE_NORMAL
- en: The discriminator column will store a value which indicates the type of object
    represented within the row. The column may be of any datatype, though string and
    integer are the most common. The actual data value to be applied to this column
    for a particular row in the database is specified using the [`Mapper.polymorphic_identity`](mapping_api.html#sqlalchemy.orm.Mapper.params.polymorphic_identity
    "sqlalchemy.orm.Mapper") parameter, described below.
  prefs: []
  type: TYPE_NORMAL
- en: While a polymorphic discriminator expression is not strictly necessary, it is
    required if polymorphic loading is desired. Establishing a column on the base
    table is the easiest way to achieve this, however very sophisticated inheritance
    mappings may make use of SQL expressions, such as a CASE expression, as the polymorphic
    discriminator.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Currently, **only one discriminator column or SQL expression may be configured
    for the entire inheritance hierarchy**, typically on the base- most class in the
    hierarchy. “Cascading” polymorphic discriminator expressions are not yet supported.
  prefs: []
  type: TYPE_NORMAL
- en: 'We next define `Engineer` and `Manager` subclasses of `Employee`. Each contains
    columns that represent the attributes unique to the subclass they represent. Each
    table also must contain a primary key column (or columns), as well as a foreign
    key reference to the parent table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In the above example, each mapping specifies the [`Mapper.polymorphic_identity`](mapping_api.html#sqlalchemy.orm.Mapper.params.polymorphic_identity
    "sqlalchemy.orm.Mapper") parameter within its mapper arguments. This value populates
    the column designated by the [`Mapper.polymorphic_on`](mapping_api.html#sqlalchemy.orm.Mapper.params.polymorphic_on
    "sqlalchemy.orm.Mapper") parameter established on the base mapper. The [`Mapper.polymorphic_identity`](mapping_api.html#sqlalchemy.orm.Mapper.params.polymorphic_identity
    "sqlalchemy.orm.Mapper") parameter should be unique to each mapped class across
    the whole hierarchy, and there should only be one “identity” per mapped class;
    as noted above, “cascading” identities where some subclasses introduce a second
    identity are not supported.
  prefs: []
  type: TYPE_NORMAL
- en: The ORM uses the value set up by [`Mapper.polymorphic_identity`](mapping_api.html#sqlalchemy.orm.Mapper.params.polymorphic_identity
    "sqlalchemy.orm.Mapper") in order to determine which class a row belongs towards
    when loading rows polymorphically. In the example above, every row which represents
    an `Employee` will have the value `'employee'` in its `type` column; similarly,
    every `Engineer` will get the value `'engineer'`, and each `Manager` will get
    the value `'manager'`. Regardless of whether the inheritance mapping uses distinct
    joined tables for subclasses as in joined table inheritance, or all one table
    as in single table inheritance, this value is expected to be persisted and available
    to the ORM when querying. The [`Mapper.polymorphic_identity`](mapping_api.html#sqlalchemy.orm.Mapper.params.polymorphic_identity
    "sqlalchemy.orm.Mapper") parameter also applies to concrete table inheritance,
    but is not actually persisted; see the later section at [Concrete Table Inheritance](#concrete-inheritance)
    for details.
  prefs: []
  type: TYPE_NORMAL
- en: In a polymorphic setup, it is most common that the foreign key constraint is
    established on the same column or columns as the primary key itself, however this
    is not required; a column distinct from the primary key may also be made to refer
    to the parent via foreign key. The way that a JOIN is constructed from the base
    table to subclasses is also directly customizable, however this is rarely necessary.
  prefs: []
  type: TYPE_NORMAL
- en: With the joined inheritance mapping complete, querying against `Employee` will
    return a combination of `Employee`, `Engineer` and `Manager` objects. Newly saved
    `Engineer`, `Manager`, and `Employee` objects will automatically populate the
    `employee.type` column with the correct “discriminator” value in this case `"engineer"`,
    `"manager"`, or `"employee"`, as appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: Relationships with Joined Inheritance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Relationships are fully supported with joined table inheritance. The relationship
    involving a joined-inheritance class should target the class in the hierarchy
    that also corresponds to the foreign key constraint; below, as the `employee`
    table has a foreign key constraint back to the `company` table, the relationships
    are set up between `Company` and `Employee`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'If the foreign key constraint is on a table corresponding to a subclass, the
    relationship should target that subclass instead. In the example below, there
    is a foreign key constraint from `manager` to `company`, so the relationships
    are established between the `Manager` and `Company` classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Above, the `Manager` class will have a `Manager.company` attribute; `Company`
    will have a `Company.managers` attribute that always loads against a join of the
    `employee` and `manager` tables together.
  prefs: []
  type: TYPE_NORMAL
- en: Loading Joined Inheritance Mappings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: See the section [Writing SELECT statements for Inheritance Mappings](queryguide/inheritance.html)
    for background on inheritance loading techniques, including configuration of tables
    to be queried both at mapper configuration time as well as query time.
  prefs: []
  type: TYPE_NORMAL
- en: Relationships with Joined Inheritance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Relationships are fully supported with joined table inheritance. The relationship
    involving a joined-inheritance class should target the class in the hierarchy
    that also corresponds to the foreign key constraint; below, as the `employee`
    table has a foreign key constraint back to the `company` table, the relationships
    are set up between `Company` and `Employee`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'If the foreign key constraint is on a table corresponding to a subclass, the
    relationship should target that subclass instead. In the example below, there
    is a foreign key constraint from `manager` to `company`, so the relationships
    are established between the `Manager` and `Company` classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Above, the `Manager` class will have a `Manager.company` attribute; `Company`
    will have a `Company.managers` attribute that always loads against a join of the
    `employee` and `manager` tables together.
  prefs: []
  type: TYPE_NORMAL
- en: Loading Joined Inheritance Mappings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: See the section [Writing SELECT statements for Inheritance Mappings](queryguide/inheritance.html)
    for background on inheritance loading techniques, including configuration of tables
    to be queried both at mapper configuration time as well as query time.
  prefs: []
  type: TYPE_NORMAL
- en: '## Single Table Inheritance'
  prefs: []
  type: TYPE_NORMAL
- en: Single table inheritance represents all attributes of all subclasses within
    a single table. A particular subclass that has attributes unique to that class
    will persist them within columns in the table that are otherwise NULL if the row
    refers to a different kind of object.
  prefs: []
  type: TYPE_NORMAL
- en: Querying for a particular subclass in the hierarchy will render as a SELECT
    against the base table, which will include a WHERE clause that limits rows to
    those with a particular value or values present in the discriminator column or
    expression.
  prefs: []
  type: TYPE_NORMAL
- en: Single table inheritance has the advantage of simplicity compared to joined
    table inheritance; queries are much more efficient as only one table needs to
    be involved in order to load objects of every represented class.
  prefs: []
  type: TYPE_NORMAL
- en: Single-table inheritance configuration looks much like joined-table inheritance,
    except only the base class specifies `__tablename__`. A discriminator column is
    also required on the base table so that classes can be differentiated from each
    other.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even though subclasses share the base table for all of their attributes, when
    using Declarative, [`mapped_column`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") objects may still be specified on subclasses,
    indicating that the column is to be mapped only to that subclass; the [`mapped_column`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") will be applied to the same base [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Note that the mappers for the derived classes Manager and Engineer omit the
    `__tablename__`, indicating they do not have a mapped table of their own. Additionally,
    a [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    directive with `nullable=True` is included; as the Python types declared for these
    classes do not include `Optional[]`, the column would normally be mapped as `NOT
    NULL`, which would not be appropriate as this column only expects to be populated
    for those rows that correspond to that particular subclass.
  prefs: []
  type: TYPE_NORMAL
- en: '### Resolving Column Conflicts with `use_existing_column`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note in the previous section that the `manager_name` and `engineer_info` columns
    are “moved up” to be applied to `Employee.__table__`, as a result of their declaration
    on a subclass that has no table of its own. A tricky case comes up when two subclasses
    want to specify *the same* column, as below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Above, the `start_date` column declared on both `Engineer` and `Manager` will
    result in an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The above scenario presents an ambiguity to the Declarative mapping system
    that may be resolved by using the [`mapped_column.use_existing_column`](mapping_api.html#sqlalchemy.orm.mapped_column.params.use_existing_column
    "sqlalchemy.orm.mapped_column") parameter on [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column"), which instructs [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") to look on the inheriting superclass present and
    use the column that’s already mapped, if already present, else to map a new column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Above, when `Manager` is mapped, the `start_date` column is already present
    on the `Employee` class, having been provided by the `Engineer` mapping already.
    The [`mapped_column.use_existing_column`](mapping_api.html#sqlalchemy.orm.mapped_column.params.use_existing_column
    "sqlalchemy.orm.mapped_column") parameter indicates to [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") that it should look for the requested [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") on the mapped [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") for `Employee` first, and if present, maintain that
    existing mapping. If not present, [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") will map the column normally, adding it as one
    of the columns in the [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") referenced by the `Employee` superclass.
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 2.0.0b4: - Added [`mapped_column.use_existing_column`](mapping_api.html#sqlalchemy.orm.mapped_column.params.use_existing_column
    "sqlalchemy.orm.mapped_column"), which provides a 2.0-compatible means of mapping
    a column on an inheriting subclass conditionally. The previous approach which
    combines [`declared_attr`](mapping_api.html#sqlalchemy.orm.declared_attr "sqlalchemy.orm.declared_attr")
    with a lookup on the parent `.__table__` continues to function as well, but lacks
    [**PEP 484**](https://peps.python.org/pep-0484/) typing support.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A similar concept can be used with mixin classes (see [Composing Mapped Hierarchies
    with Mixins](declarative_mixins.html)) to define a particular series of columns
    and/or other mapped attributes from a reusable mixin class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Relationships with Single Table Inheritance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Relationships are fully supported with single table inheritance. Configuration
    is done in the same manner as that of joined inheritance; a foreign key attribute
    should be on the same class that’s the “foreign” side of the relationship:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, like the case of joined inheritance, we can create relationships that
    involve a specific subclass. When queried, the SELECT statement will include a
    WHERE clause that limits the class selection to that subclass or subclasses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Above, the `Manager` class will have a `Manager.company` attribute; `Company`
    will have a `Company.managers` attribute that always loads against the `employee`
    with an additional WHERE clause that limits rows to those with `type = 'manager'`.
  prefs: []
  type: TYPE_NORMAL
- en: '### Building Deeper Hierarchies with `polymorphic_abstract`'
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: When building any kind of inheritance hierarchy, a mapped class may include
    the [`Mapper.polymorphic_abstract`](mapping_api.html#sqlalchemy.orm.Mapper.params.polymorphic_abstract
    "sqlalchemy.orm.Mapper") parameter set to `True`, which indicates that the class
    should be mapped normally, however would not expect to be instantiated directly
    and would not include a [`Mapper.polymorphic_identity`](mapping_api.html#sqlalchemy.orm.Mapper.params.polymorphic_identity
    "sqlalchemy.orm.Mapper"). Subclasses may then be declared as subclasses of this
    mapped class, which themselves can include a [`Mapper.polymorphic_identity`](mapping_api.html#sqlalchemy.orm.Mapper.params.polymorphic_identity
    "sqlalchemy.orm.Mapper") and therefore be used normally. This allows a series
    of subclasses to be referenced at once by a common base class which is considered
    to be “abstract” within the hierarchy, both in queries as well as in [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") declarations. This use differs from the use of
    the [__abstract__](declarative_config.html#declarative-abstract) attribute with
    Declarative, which leaves the target class entirely unmapped and thus not usable
    as a mapped class by itself. [`Mapper.polymorphic_abstract`](mapping_api.html#sqlalchemy.orm.Mapper.params.polymorphic_abstract
    "sqlalchemy.orm.Mapper") may be applied to any class or classes at any level in
    the hierarchy, including on multiple levels at once.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, suppose `Manager` and `Principal` were both to be classified
    against a superclass `Executive`, and `Engineer` and `Sysadmin` were classified
    against a superclass `Technologist`. Neither `Executive` or `Technologist` is
    ever instantiated, therefore have no [`Mapper.polymorphic_identity`](mapping_api.html#sqlalchemy.orm.Mapper.params.polymorphic_identity
    "sqlalchemy.orm.Mapper"). These classes can be configured using [`Mapper.polymorphic_abstract`](mapping_api.html#sqlalchemy.orm.Mapper.params.polymorphic_abstract
    "sqlalchemy.orm.Mapper") as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'In the above example, the new classes `Technologist` and `Executive` are ordinary
    mapped classes, and also indicate new columns to be added to the superclass called
    `executive_background` and `competencies`. However, they both lack a setting for
    [`Mapper.polymorphic_identity`](mapping_api.html#sqlalchemy.orm.Mapper.params.polymorphic_identity
    "sqlalchemy.orm.Mapper"); this is because it’s not expected that `Technologist`
    or `Executive` would ever be instantiated directly; we’d always have one of `Manager`,
    `Principal`, `Engineer` or `SysAdmin`. We can however query for `Principal` and
    `Technologist` roles, as well as have them be targets of [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship"). The example below demonstrates a SELECT statement
    for `Technologist` objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Technologist` and `Executive` abstract mapped classes may also be made
    the targets of [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") mappings, like any other mapped class. We can extend
    the above example to include `Company`, with separate collections `Company.technologists`
    and `Company.principals`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the above mapping we can use joins and relationship loading techniques
    across `Company.technologists` and `Company.executives` individually:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[__abstract__](declarative_config.html#declarative-abstract) - Declarative
    parameter which allows a Declarative class to be completely un-mapped within a
    hierarchy, while still extending from a mapped superclass.'
  prefs: []
  type: TYPE_NORMAL
- en: Loading Single Inheritance Mappings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The loading techniques for single-table inheritance are mostly identical to
    those used for joined-table inheritance, and a high degree of abstraction is provided
    between these two mapping types such that it is easy to switch between them as
    well as to intermix them in a single hierarchy (just omit `__tablename__` from
    whichever subclasses are to be single-inheriting). See the sections [Writing SELECT
    statements for Inheritance Mappings](queryguide/inheritance.html) and [SELECT
    Statements for Single Inheritance Mappings](queryguide/inheritance.html#loading-single-inheritance)
    for documentation on inheritance loading techniques, including configuration of
    classes to be queried both at mapper configuration time as well as query time.
  prefs: []
  type: TYPE_NORMAL
- en: '### Resolving Column Conflicts with `use_existing_column`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note in the previous section that the `manager_name` and `engineer_info` columns
    are “moved up” to be applied to `Employee.__table__`, as a result of their declaration
    on a subclass that has no table of its own. A tricky case comes up when two subclasses
    want to specify *the same* column, as below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Above, the `start_date` column declared on both `Engineer` and `Manager` will
    result in an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The above scenario presents an ambiguity to the Declarative mapping system
    that may be resolved by using the [`mapped_column.use_existing_column`](mapping_api.html#sqlalchemy.orm.mapped_column.params.use_existing_column
    "sqlalchemy.orm.mapped_column") parameter on [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column"), which instructs [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") to look on the inheriting superclass present and
    use the column that’s already mapped, if already present, else to map a new column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Above, when `Manager` is mapped, the `start_date` column is already present
    on the `Employee` class, having been provided by the `Engineer` mapping already.
    The [`mapped_column.use_existing_column`](mapping_api.html#sqlalchemy.orm.mapped_column.params.use_existing_column
    "sqlalchemy.orm.mapped_column") parameter indicates to [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") that it should look for the requested [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") on the mapped [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") for `Employee` first, and if present, maintain that
    existing mapping. If not present, [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") will map the column normally, adding it as one
    of the columns in the [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") referenced by the `Employee` superclass.
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 2.0.0b4: - Added [`mapped_column.use_existing_column`](mapping_api.html#sqlalchemy.orm.mapped_column.params.use_existing_column
    "sqlalchemy.orm.mapped_column"), which provides a 2.0-compatible means of mapping
    a column on an inheriting subclass conditionally. The previous approach which
    combines [`declared_attr`](mapping_api.html#sqlalchemy.orm.declared_attr "sqlalchemy.orm.declared_attr")
    with a lookup on the parent `.__table__` continues to function as well, but lacks
    [**PEP 484**](https://peps.python.org/pep-0484/) typing support.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A similar concept can be used with mixin classes (see [Composing Mapped Hierarchies
    with Mixins](declarative_mixins.html)) to define a particular series of columns
    and/or other mapped attributes from a reusable mixin class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Relationships with Single Table Inheritance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Relationships are fully supported with single table inheritance. Configuration
    is done in the same manner as that of joined inheritance; a foreign key attribute
    should be on the same class that’s the “foreign” side of the relationship:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, like the case of joined inheritance, we can create relationships that
    involve a specific subclass. When queried, the SELECT statement will include a
    WHERE clause that limits the class selection to that subclass or subclasses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Above, the `Manager` class will have a `Manager.company` attribute; `Company`
    will have a `Company.managers` attribute that always loads against the `employee`
    with an additional WHERE clause that limits rows to those with `type = 'manager'`.
  prefs: []
  type: TYPE_NORMAL
- en: '### Building Deeper Hierarchies with `polymorphic_abstract`'
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: When building any kind of inheritance hierarchy, a mapped class may include
    the [`Mapper.polymorphic_abstract`](mapping_api.html#sqlalchemy.orm.Mapper.params.polymorphic_abstract
    "sqlalchemy.orm.Mapper") parameter set to `True`, which indicates that the class
    should be mapped normally, however would not expect to be instantiated directly
    and would not include a [`Mapper.polymorphic_identity`](mapping_api.html#sqlalchemy.orm.Mapper.params.polymorphic_identity
    "sqlalchemy.orm.Mapper"). Subclasses may then be declared as subclasses of this
    mapped class, which themselves can include a [`Mapper.polymorphic_identity`](mapping_api.html#sqlalchemy.orm.Mapper.params.polymorphic_identity
    "sqlalchemy.orm.Mapper") and therefore be used normally. This allows a series
    of subclasses to be referenced at once by a common base class which is considered
    to be “abstract” within the hierarchy, both in queries as well as in [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") declarations. This use differs from the use of
    the [__abstract__](declarative_config.html#declarative-abstract) attribute with
    Declarative, which leaves the target class entirely unmapped and thus not usable
    as a mapped class by itself. [`Mapper.polymorphic_abstract`](mapping_api.html#sqlalchemy.orm.Mapper.params.polymorphic_abstract
    "sqlalchemy.orm.Mapper") may be applied to any class or classes at any level in
    the hierarchy, including on multiple levels at once.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, suppose `Manager` and `Principal` were both to be classified
    against a superclass `Executive`, and `Engineer` and `Sysadmin` were classified
    against a superclass `Technologist`. Neither `Executive` or `Technologist` is
    ever instantiated, therefore have no [`Mapper.polymorphic_identity`](mapping_api.html#sqlalchemy.orm.Mapper.params.polymorphic_identity
    "sqlalchemy.orm.Mapper"). These classes can be configured using [`Mapper.polymorphic_abstract`](mapping_api.html#sqlalchemy.orm.Mapper.params.polymorphic_abstract
    "sqlalchemy.orm.Mapper") as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'In the above example, the new classes `Technologist` and `Executive` are ordinary
    mapped classes, and also indicate new columns to be added to the superclass called
    `executive_background` and `competencies`. However, they both lack a setting for
    [`Mapper.polymorphic_identity`](mapping_api.html#sqlalchemy.orm.Mapper.params.polymorphic_identity
    "sqlalchemy.orm.Mapper"); this is because it’s not expected that `Technologist`
    or `Executive` would ever be instantiated directly; we’d always have one of `Manager`,
    `Principal`, `Engineer` or `SysAdmin`. We can however query for `Principal` and
    `Technologist` roles, as well as have them be targets of [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship"). The example below demonstrates a SELECT statement
    for `Technologist` objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Technologist` and `Executive` abstract mapped classes may also be made
    the targets of [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") mappings, like any other mapped class. We can extend
    the above example to include `Company`, with separate collections `Company.technologists`
    and `Company.principals`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the above mapping we can use joins and relationship loading techniques
    across `Company.technologists` and `Company.executives` individually:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[__abstract__](declarative_config.html#declarative-abstract) - Declarative
    parameter which allows a Declarative class to be completely un-mapped within a
    hierarchy, while still extending from a mapped superclass.'
  prefs: []
  type: TYPE_NORMAL
- en: Loading Single Inheritance Mappings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The loading techniques for single-table inheritance are mostly identical to
    those used for joined-table inheritance, and a high degree of abstraction is provided
    between these two mapping types such that it is easy to switch between them as
    well as to intermix them in a single hierarchy (just omit `__tablename__` from
    whichever subclasses are to be single-inheriting). See the sections [Writing SELECT
    statements for Inheritance Mappings](queryguide/inheritance.html) and [SELECT
    Statements for Single Inheritance Mappings](queryguide/inheritance.html#loading-single-inheritance)
    for documentation on inheritance loading techniques, including configuration of
    classes to be queried both at mapper configuration time as well as query time.
  prefs: []
  type: TYPE_NORMAL
- en: '## Concrete Table Inheritance'
  prefs: []
  type: TYPE_NORMAL
- en: Concrete inheritance maps each subclass to its own distinct table, each of which
    contains all columns necessary to produce an instance of that class. A concrete
    inheritance configuration by default queries non-polymorphically; a query for
    a particular class will only query that class’ table and only return instances
    of that class. Polymorphic loading of concrete classes is enabled by configuring
    within the mapper a special SELECT that typically is produced as a UNION of all
    the tables.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: Concrete table inheritance is **much more complicated** than joined or single
    table inheritance, and is **much more limited in functionality** especially pertaining
    to using it with relationships, eager loading, and polymorphic loading. When used
    polymorphically it produces **very large queries** with UNIONS that won’t perform
    as well as simple joins. It is strongly advised that if flexibility in relationship
    loading and polymorphic loading is required, that joined or single table inheritance
    be used if at all possible. If polymorphic loading isn’t required, then plain
    non-inheriting mappings can be used if each class refers to its own table completely.
  prefs: []
  type: TYPE_NORMAL
- en: Whereas joined and single table inheritance are fluent in “polymorphic” loading,
    it is a more awkward affair in concrete inheritance. For this reason, concrete
    inheritance is more appropriate when **polymorphic loading is not required**.
    Establishing relationships that involve concrete inheritance classes is also more
    awkward.
  prefs: []
  type: TYPE_NORMAL
- en: 'To establish a class as using concrete inheritance, add the [`Mapper.concrete`](mapping_api.html#sqlalchemy.orm.Mapper.params.concrete
    "sqlalchemy.orm.Mapper") parameter within the `__mapper_args__`. This indicates
    to Declarative as well as the mapping that the superclass table should not be
    considered as part of the mapping:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Two critical points should be noted:'
  prefs: []
  type: TYPE_NORMAL
- en: We must **define all columns explicitly** on each subclass, even those of the
    same name. A column such as `Employee.name` here is **not** copied out to the
    tables mapped by `Manager` or `Engineer` for us.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: while the `Engineer` and `Manager` classes are mapped in an inheritance relationship
    with `Employee`, they still **do not include polymorphic loading**. Meaning, if
    we query for `Employee` objects, the `manager` and `engineer` tables are not queried
    at all.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '### Concrete Polymorphic Loading Configuration'
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphic loading with concrete inheritance requires that a specialized SELECT
    is configured against each base class that should have polymorphic loading. This
    SELECT needs to be capable of accessing all the mapped tables individually, and
    is typically a UNION statement that is constructed using a SQLAlchemy helper [`polymorphic_union()`](mapping_api.html#sqlalchemy.orm.polymorphic_union
    "sqlalchemy.orm.polymorphic_union").
  prefs: []
  type: TYPE_NORMAL
- en: As discussed in [Writing SELECT statements for Inheritance Mappings](queryguide/inheritance.html),
    mapper inheritance configurations of any type can be configured to load from a
    special selectable by default using the [`Mapper.with_polymorphic`](mapping_api.html#sqlalchemy.orm.Mapper.params.with_polymorphic
    "sqlalchemy.orm.Mapper") argument. Current public API requires that this argument
    is set on a [`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper "sqlalchemy.orm.Mapper")
    when it is first constructed.
  prefs: []
  type: TYPE_NORMAL
- en: However, in the case of Declarative, both the mapper and the [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") that is mapped are created at once, the moment the
    mapped class is defined. This means that the [`Mapper.with_polymorphic`](mapping_api.html#sqlalchemy.orm.Mapper.params.with_polymorphic
    "sqlalchemy.orm.Mapper") argument cannot be provided yet, since the [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects that correspond to the subclasses haven’t yet
    been defined.
  prefs: []
  type: TYPE_NORMAL
- en: There are a few strategies available to resolve this cycle, however Declarative
    provides helper classes [`ConcreteBase`](extensions/declarative/index.html#sqlalchemy.ext.declarative.ConcreteBase
    "sqlalchemy.ext.declarative.ConcreteBase") and [`AbstractConcreteBase`](extensions/declarative/index.html#sqlalchemy.ext.declarative.AbstractConcreteBase
    "sqlalchemy.ext.declarative.AbstractConcreteBase") which handle this issue behind
    the scenes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using [`ConcreteBase`](extensions/declarative/index.html#sqlalchemy.ext.declarative.ConcreteBase
    "sqlalchemy.ext.declarative.ConcreteBase"), we can set up our concrete mapping
    in almost the same way as we do other forms of inheritance mappings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Above, Declarative sets up the polymorphic selectable for the `Employee` class
    at mapper “initialization” time; this is the late-configuration step for mappers
    that resolves other dependent mappers. The [`ConcreteBase`](extensions/declarative/index.html#sqlalchemy.ext.declarative.ConcreteBase
    "sqlalchemy.ext.declarative.ConcreteBase") helper uses the [`polymorphic_union()`](mapping_api.html#sqlalchemy.orm.polymorphic_union
    "sqlalchemy.orm.polymorphic_union") function to create a UNION of all concrete-mapped
    tables after all the other classes are set up, and then configures this statement
    with the already existing base-class mapper.
  prefs: []
  type: TYPE_NORMAL
- en: 'Upon select, the polymorphic union produces a query like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The above UNION query needs to manufacture “NULL” columns for each subtable
    in order to accommodate for those columns that aren’t members of that particular
    subclass.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`ConcreteBase`](extensions/declarative/index.html#sqlalchemy.ext.declarative.ConcreteBase
    "sqlalchemy.ext.declarative.ConcreteBase")  ### Abstract Concrete Classes'
  prefs: []
  type: TYPE_NORMAL
- en: The concrete mappings illustrated thus far show both the subclasses as well
    as the base class mapped to individual tables. In the concrete inheritance use
    case, it is common that the base class is not represented within the database,
    only the subclasses. In other words, the base class is “abstract”.
  prefs: []
  type: TYPE_NORMAL
- en: 'Normally, when one would like to map two different subclasses to individual
    tables, and leave the base class unmapped, this can be achieved very easily. When
    using Declarative, just declare the base class with the `__abstract__` indicator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Above, we are not actually making use of SQLAlchemy’s inheritance mapping facilities;
    we can load and persist instances of `Manager` and `Engineer` normally. The situation
    changes however when we need to **query polymorphically**, that is, we’d like
    to emit `select(Employee)` and get back a collection of `Manager` and `Engineer`
    instances. This brings us back into the domain of concrete inheritance, and we
    must build a special mapper against `Employee` in order to achieve this.
  prefs: []
  type: TYPE_NORMAL
- en: To modify our concrete inheritance example to illustrate an “abstract” base
    that is capable of polymorphic loading, we will have only an `engineer` and a
    `manager` table and no `employee` table, however the `Employee` mapper will be
    mapped directly to the “polymorphic union”, rather than specifying it locally
    to the [`Mapper.with_polymorphic`](mapping_api.html#sqlalchemy.orm.Mapper.params.with_polymorphic
    "sqlalchemy.orm.Mapper") parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'To help with this, Declarative offers a variant of the [`ConcreteBase`](extensions/declarative/index.html#sqlalchemy.ext.declarative.ConcreteBase
    "sqlalchemy.ext.declarative.ConcreteBase") class called [`AbstractConcreteBase`](extensions/declarative/index.html#sqlalchemy.ext.declarative.AbstractConcreteBase
    "sqlalchemy.ext.declarative.AbstractConcreteBase") which achieves this automatically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Above, the [`registry.configure()`](mapping_api.html#sqlalchemy.orm.registry.configure
    "sqlalchemy.orm.registry.configure") method is invoked, which will trigger the
    `Employee` class to be actually mapped; before the configuration step, the class
    has no mapping as the sub-tables which it will query from have not yet been defined.
    This process is more complex than that of [`ConcreteBase`](extensions/declarative/index.html#sqlalchemy.ext.declarative.ConcreteBase
    "sqlalchemy.ext.declarative.ConcreteBase"), in that the entire mapping of the
    base class must be delayed until all the subclasses have been declared. With a
    mapping like the above, only instances of `Manager` and `Engineer` may be persisted;
    querying against the `Employee` class will always produce `Manager` and `Engineer`
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the above mapping, queries can be produced in terms of the `Employee`
    class and any attributes that are locally declared upon it, such as the `Employee.name`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: The [`AbstractConcreteBase.strict_attrs`](extensions/declarative/index.html#sqlalchemy.ext.declarative.AbstractConcreteBase.params.strict_attrs
    "sqlalchemy.ext.declarative.AbstractConcreteBase") parameter indicates that the
    `Employee` class should directly map only those attributes which are local to
    the `Employee` class, in this case the `Employee.name` attribute. Other attributes
    such as `Manager.manager_data` and `Engineer.engineer_info` are present only on
    their corresponding subclass. When [`AbstractConcreteBase.strict_attrs`](extensions/declarative/index.html#sqlalchemy.ext.declarative.AbstractConcreteBase.params.strict_attrs
    "sqlalchemy.ext.declarative.AbstractConcreteBase") is not set, then all subclass
    attributes such as `Manager.manager_data` and `Engineer.engineer_info` get mapped
    onto the base `Employee` class. This is a legacy mode of use which may be more
    convenient for querying but has the effect that all subclasses share the full
    set of attributes for the whole hierarchy; in the above example, not using [`AbstractConcreteBase.strict_attrs`](extensions/declarative/index.html#sqlalchemy.ext.declarative.AbstractConcreteBase.params.strict_attrs
    "sqlalchemy.ext.declarative.AbstractConcreteBase") would have the effect of generating
    non-useful `Engineer.manager_name` and `Manager.engineer_info` attributes.
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 2.0: Added [`AbstractConcreteBase.strict_attrs`](extensions/declarative/index.html#sqlalchemy.ext.declarative.AbstractConcreteBase.params.strict_attrs
    "sqlalchemy.ext.declarative.AbstractConcreteBase") parameter to [`AbstractConcreteBase`](extensions/declarative/index.html#sqlalchemy.ext.declarative.AbstractConcreteBase
    "sqlalchemy.ext.declarative.AbstractConcreteBase") which produces a cleaner mapping;
    the default is False to allow legacy mappings to continue working as they did
    in 1.x versions.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`AbstractConcreteBase`](extensions/declarative/index.html#sqlalchemy.ext.declarative.AbstractConcreteBase
    "sqlalchemy.ext.declarative.AbstractConcreteBase")'
  prefs: []
  type: TYPE_NORMAL
- en: Classical and Semi-Classical Concrete Polymorphic Configuration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Declarative configurations illustrated with [`ConcreteBase`](extensions/declarative/index.html#sqlalchemy.ext.declarative.ConcreteBase
    "sqlalchemy.ext.declarative.ConcreteBase") and [`AbstractConcreteBase`](extensions/declarative/index.html#sqlalchemy.ext.declarative.AbstractConcreteBase
    "sqlalchemy.ext.declarative.AbstractConcreteBase") are equivalent to two other
    forms of configuration that make use of [`polymorphic_union()`](mapping_api.html#sqlalchemy.orm.polymorphic_union
    "sqlalchemy.orm.polymorphic_union") explicitly. These configurational forms make
    use of the [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    object explicitly so that the “polymorphic union” can be created first, then applied
    to the mappings. These are illustrated here to clarify the role of the [`polymorphic_union()`](mapping_api.html#sqlalchemy.orm.polymorphic_union
    "sqlalchemy.orm.polymorphic_union") function in terms of mapping.
  prefs: []
  type: TYPE_NORMAL
- en: 'A **semi-classical mapping** for example makes use of Declarative, but establishes
    the [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    objects separately:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, the UNION is produced using [`polymorphic_union()`](mapping_api.html#sqlalchemy.orm.polymorphic_union
    "sqlalchemy.orm.polymorphic_union"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'With the above [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    objects, the mappings can be produced using “semi-classical” style, where we use
    Declarative in conjunction with the `__table__` argument; our polymorphic union
    above is passed via `__mapper_args__` to the [`Mapper.with_polymorphic`](mapping_api.html#sqlalchemy.orm.Mapper.params.with_polymorphic
    "sqlalchemy.orm.Mapper") parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, the same [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects can be used in fully “classical” style, without
    using Declarative at all. A constructor similar to that supplied by Declarative
    is illustrated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The “abstract” example can also be mapped using “semi-classical” or “classical”
    style. The difference is that instead of applying the “polymorphic union” to the
    [`Mapper.with_polymorphic`](mapping_api.html#sqlalchemy.orm.Mapper.params.with_polymorphic
    "sqlalchemy.orm.Mapper") parameter, we apply it directly as the mapped selectable
    on our basemost mapper. The semi-classical mapping is illustrated below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Above, we use [`polymorphic_union()`](mapping_api.html#sqlalchemy.orm.polymorphic_union
    "sqlalchemy.orm.polymorphic_union") in the same manner as before, except that
    we omit the `employee` table.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Imperative Mapping](mapping_styles.html#orm-imperative-mapping) - background
    information on imperative, or “classical” mappings'
  prefs: []
  type: TYPE_NORMAL
- en: Relationships with Concrete Inheritance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In a concrete inheritance scenario, mapping relationships is challenging since
    the distinct classes do not share a table. If the relationships only involve specific
    classes, such as a relationship between `Company` in our previous examples and
    `Manager`, special steps aren’t needed as these are just two related tables.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if `Company` is to have a one-to-many relationship to `Employee`,
    indicating that the collection may include both `Engineer` and `Manager` objects,
    that implies that `Employee` must have polymorphic loading capabilities and also
    that each table to be related must have a foreign key back to the `company` table.
    An example of such a configuration is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The next complexity with concrete inheritance and relationships involves when
    we’d like one or all of `Employee`, `Manager` and `Engineer` to themselves refer
    back to `Company`. For this case, SQLAlchemy has special behavior in that a [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") placed on `Employee` which links to `Company` **does
    not work** against the `Manager` and `Engineer` classes, when exercised at the
    instance level. Instead, a distinct [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") must be applied to each class. In order to achieve
    bi-directional behavior in terms of three separate relationships which serve as
    the opposite of `Company.employees`, the [`relationship.back_populates`](relationship_api.html#sqlalchemy.orm.relationship.params.back_populates
    "sqlalchemy.orm.relationship") parameter is used between each of the relationships:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: The above limitation is related to the current implementation, including that
    concrete inheriting classes do not share any of the attributes of the superclass
    and therefore need distinct relationships to be set up.
  prefs: []
  type: TYPE_NORMAL
- en: Loading Concrete Inheritance Mappings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The options for loading with concrete inheritance are limited; generally, if
    polymorphic loading is configured on the mapper using one of the declarative concrete
    mixins, it can’t be modified at query time in current SQLAlchemy versions. Normally,
    the [`with_polymorphic()`](queryguide/inheritance.html#sqlalchemy.orm.with_polymorphic
    "sqlalchemy.orm.with_polymorphic") function would be able to override the style
    of loading used by concrete, however due to current limitations this is not yet
    supported.
  prefs: []
  type: TYPE_NORMAL
- en: '### Concrete Polymorphic Loading Configuration'
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphic loading with concrete inheritance requires that a specialized SELECT
    is configured against each base class that should have polymorphic loading. This
    SELECT needs to be capable of accessing all the mapped tables individually, and
    is typically a UNION statement that is constructed using a SQLAlchemy helper [`polymorphic_union()`](mapping_api.html#sqlalchemy.orm.polymorphic_union
    "sqlalchemy.orm.polymorphic_union").
  prefs: []
  type: TYPE_NORMAL
- en: As discussed in [Writing SELECT statements for Inheritance Mappings](queryguide/inheritance.html),
    mapper inheritance configurations of any type can be configured to load from a
    special selectable by default using the [`Mapper.with_polymorphic`](mapping_api.html#sqlalchemy.orm.Mapper.params.with_polymorphic
    "sqlalchemy.orm.Mapper") argument. Current public API requires that this argument
    is set on a [`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper "sqlalchemy.orm.Mapper")
    when it is first constructed.
  prefs: []
  type: TYPE_NORMAL
- en: However, in the case of Declarative, both the mapper and the [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") that is mapped are created at once, the moment the
    mapped class is defined. This means that the [`Mapper.with_polymorphic`](mapping_api.html#sqlalchemy.orm.Mapper.params.with_polymorphic
    "sqlalchemy.orm.Mapper") argument cannot be provided yet, since the [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects that correspond to the subclasses haven’t yet
    been defined.
  prefs: []
  type: TYPE_NORMAL
- en: There are a few strategies available to resolve this cycle, however Declarative
    provides helper classes [`ConcreteBase`](extensions/declarative/index.html#sqlalchemy.ext.declarative.ConcreteBase
    "sqlalchemy.ext.declarative.ConcreteBase") and [`AbstractConcreteBase`](extensions/declarative/index.html#sqlalchemy.ext.declarative.AbstractConcreteBase
    "sqlalchemy.ext.declarative.AbstractConcreteBase") which handle this issue behind
    the scenes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using [`ConcreteBase`](extensions/declarative/index.html#sqlalchemy.ext.declarative.ConcreteBase
    "sqlalchemy.ext.declarative.ConcreteBase"), we can set up our concrete mapping
    in almost the same way as we do other forms of inheritance mappings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Above, Declarative sets up the polymorphic selectable for the `Employee` class
    at mapper “initialization” time; this is the late-configuration step for mappers
    that resolves other dependent mappers. The [`ConcreteBase`](extensions/declarative/index.html#sqlalchemy.ext.declarative.ConcreteBase
    "sqlalchemy.ext.declarative.ConcreteBase") helper uses the [`polymorphic_union()`](mapping_api.html#sqlalchemy.orm.polymorphic_union
    "sqlalchemy.orm.polymorphic_union") function to create a UNION of all concrete-mapped
    tables after all the other classes are set up, and then configures this statement
    with the already existing base-class mapper.
  prefs: []
  type: TYPE_NORMAL
- en: 'Upon select, the polymorphic union produces a query like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: The above UNION query needs to manufacture “NULL” columns for each subtable
    in order to accommodate for those columns that aren’t members of that particular
    subclass.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`ConcreteBase`](extensions/declarative/index.html#sqlalchemy.ext.declarative.ConcreteBase
    "sqlalchemy.ext.declarative.ConcreteBase")'
  prefs: []
  type: TYPE_NORMAL
- en: '### Abstract Concrete Classes'
  prefs: []
  type: TYPE_NORMAL
- en: The concrete mappings illustrated thus far show both the subclasses as well
    as the base class mapped to individual tables. In the concrete inheritance use
    case, it is common that the base class is not represented within the database,
    only the subclasses. In other words, the base class is “abstract”.
  prefs: []
  type: TYPE_NORMAL
- en: 'Normally, when one would like to map two different subclasses to individual
    tables, and leave the base class unmapped, this can be achieved very easily. When
    using Declarative, just declare the base class with the `__abstract__` indicator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Above, we are not actually making use of SQLAlchemy’s inheritance mapping facilities;
    we can load and persist instances of `Manager` and `Engineer` normally. The situation
    changes however when we need to **query polymorphically**, that is, we’d like
    to emit `select(Employee)` and get back a collection of `Manager` and `Engineer`
    instances. This brings us back into the domain of concrete inheritance, and we
    must build a special mapper against `Employee` in order to achieve this.
  prefs: []
  type: TYPE_NORMAL
- en: To modify our concrete inheritance example to illustrate an “abstract” base
    that is capable of polymorphic loading, we will have only an `engineer` and a
    `manager` table and no `employee` table, however the `Employee` mapper will be
    mapped directly to the “polymorphic union”, rather than specifying it locally
    to the [`Mapper.with_polymorphic`](mapping_api.html#sqlalchemy.orm.Mapper.params.with_polymorphic
    "sqlalchemy.orm.Mapper") parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'To help with this, Declarative offers a variant of the [`ConcreteBase`](extensions/declarative/index.html#sqlalchemy.ext.declarative.ConcreteBase
    "sqlalchemy.ext.declarative.ConcreteBase") class called [`AbstractConcreteBase`](extensions/declarative/index.html#sqlalchemy.ext.declarative.AbstractConcreteBase
    "sqlalchemy.ext.declarative.AbstractConcreteBase") which achieves this automatically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Above, the [`registry.configure()`](mapping_api.html#sqlalchemy.orm.registry.configure
    "sqlalchemy.orm.registry.configure") method is invoked, which will trigger the
    `Employee` class to be actually mapped; before the configuration step, the class
    has no mapping as the sub-tables which it will query from have not yet been defined.
    This process is more complex than that of [`ConcreteBase`](extensions/declarative/index.html#sqlalchemy.ext.declarative.ConcreteBase
    "sqlalchemy.ext.declarative.ConcreteBase"), in that the entire mapping of the
    base class must be delayed until all the subclasses have been declared. With a
    mapping like the above, only instances of `Manager` and `Engineer` may be persisted;
    querying against the `Employee` class will always produce `Manager` and `Engineer`
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the above mapping, queries can be produced in terms of the `Employee`
    class and any attributes that are locally declared upon it, such as the `Employee.name`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: The [`AbstractConcreteBase.strict_attrs`](extensions/declarative/index.html#sqlalchemy.ext.declarative.AbstractConcreteBase.params.strict_attrs
    "sqlalchemy.ext.declarative.AbstractConcreteBase") parameter indicates that the
    `Employee` class should directly map only those attributes which are local to
    the `Employee` class, in this case the `Employee.name` attribute. Other attributes
    such as `Manager.manager_data` and `Engineer.engineer_info` are present only on
    their corresponding subclass. When [`AbstractConcreteBase.strict_attrs`](extensions/declarative/index.html#sqlalchemy.ext.declarative.AbstractConcreteBase.params.strict_attrs
    "sqlalchemy.ext.declarative.AbstractConcreteBase") is not set, then all subclass
    attributes such as `Manager.manager_data` and `Engineer.engineer_info` get mapped
    onto the base `Employee` class. This is a legacy mode of use which may be more
    convenient for querying but has the effect that all subclasses share the full
    set of attributes for the whole hierarchy; in the above example, not using [`AbstractConcreteBase.strict_attrs`](extensions/declarative/index.html#sqlalchemy.ext.declarative.AbstractConcreteBase.params.strict_attrs
    "sqlalchemy.ext.declarative.AbstractConcreteBase") would have the effect of generating
    non-useful `Engineer.manager_name` and `Manager.engineer_info` attributes.
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 2.0: Added [`AbstractConcreteBase.strict_attrs`](extensions/declarative/index.html#sqlalchemy.ext.declarative.AbstractConcreteBase.params.strict_attrs
    "sqlalchemy.ext.declarative.AbstractConcreteBase") parameter to [`AbstractConcreteBase`](extensions/declarative/index.html#sqlalchemy.ext.declarative.AbstractConcreteBase
    "sqlalchemy.ext.declarative.AbstractConcreteBase") which produces a cleaner mapping;
    the default is False to allow legacy mappings to continue working as they did
    in 1.x versions.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`AbstractConcreteBase`](extensions/declarative/index.html#sqlalchemy.ext.declarative.AbstractConcreteBase
    "sqlalchemy.ext.declarative.AbstractConcreteBase")'
  prefs: []
  type: TYPE_NORMAL
- en: Classical and Semi-Classical Concrete Polymorphic Configuration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Declarative configurations illustrated with [`ConcreteBase`](extensions/declarative/index.html#sqlalchemy.ext.declarative.ConcreteBase
    "sqlalchemy.ext.declarative.ConcreteBase") and [`AbstractConcreteBase`](extensions/declarative/index.html#sqlalchemy.ext.declarative.AbstractConcreteBase
    "sqlalchemy.ext.declarative.AbstractConcreteBase") are equivalent to two other
    forms of configuration that make use of [`polymorphic_union()`](mapping_api.html#sqlalchemy.orm.polymorphic_union
    "sqlalchemy.orm.polymorphic_union") explicitly. These configurational forms make
    use of the [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    object explicitly so that the “polymorphic union” can be created first, then applied
    to the mappings. These are illustrated here to clarify the role of the [`polymorphic_union()`](mapping_api.html#sqlalchemy.orm.polymorphic_union
    "sqlalchemy.orm.polymorphic_union") function in terms of mapping.
  prefs: []
  type: TYPE_NORMAL
- en: 'A **semi-classical mapping** for example makes use of Declarative, but establishes
    the [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    objects separately:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, the UNION is produced using [`polymorphic_union()`](mapping_api.html#sqlalchemy.orm.polymorphic_union
    "sqlalchemy.orm.polymorphic_union"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'With the above [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    objects, the mappings can be produced using “semi-classical” style, where we use
    Declarative in conjunction with the `__table__` argument; our polymorphic union
    above is passed via `__mapper_args__` to the [`Mapper.with_polymorphic`](mapping_api.html#sqlalchemy.orm.Mapper.params.with_polymorphic
    "sqlalchemy.orm.Mapper") parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, the same [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects can be used in fully “classical” style, without
    using Declarative at all. A constructor similar to that supplied by Declarative
    is illustrated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'The “abstract” example can also be mapped using “semi-classical” or “classical”
    style. The difference is that instead of applying the “polymorphic union” to the
    [`Mapper.with_polymorphic`](mapping_api.html#sqlalchemy.orm.Mapper.params.with_polymorphic
    "sqlalchemy.orm.Mapper") parameter, we apply it directly as the mapped selectable
    on our basemost mapper. The semi-classical mapping is illustrated below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Above, we use [`polymorphic_union()`](mapping_api.html#sqlalchemy.orm.polymorphic_union
    "sqlalchemy.orm.polymorphic_union") in the same manner as before, except that
    we omit the `employee` table.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Imperative Mapping](mapping_styles.html#orm-imperative-mapping) - background
    information on imperative, or “classical” mappings'
  prefs: []
  type: TYPE_NORMAL
- en: Relationships with Concrete Inheritance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In a concrete inheritance scenario, mapping relationships is challenging since
    the distinct classes do not share a table. If the relationships only involve specific
    classes, such as a relationship between `Company` in our previous examples and
    `Manager`, special steps aren’t needed as these are just two related tables.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if `Company` is to have a one-to-many relationship to `Employee`,
    indicating that the collection may include both `Engineer` and `Manager` objects,
    that implies that `Employee` must have polymorphic loading capabilities and also
    that each table to be related must have a foreign key back to the `company` table.
    An example of such a configuration is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'The next complexity with concrete inheritance and relationships involves when
    we’d like one or all of `Employee`, `Manager` and `Engineer` to themselves refer
    back to `Company`. For this case, SQLAlchemy has special behavior in that a [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") placed on `Employee` which links to `Company` **does
    not work** against the `Manager` and `Engineer` classes, when exercised at the
    instance level. Instead, a distinct [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") must be applied to each class. In order to achieve
    bi-directional behavior in terms of three separate relationships which serve as
    the opposite of `Company.employees`, the [`relationship.back_populates`](relationship_api.html#sqlalchemy.orm.relationship.params.back_populates
    "sqlalchemy.orm.relationship") parameter is used between each of the relationships:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: The above limitation is related to the current implementation, including that
    concrete inheriting classes do not share any of the attributes of the superclass
    and therefore need distinct relationships to be set up.
  prefs: []
  type: TYPE_NORMAL
- en: Loading Concrete Inheritance Mappings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The options for loading with concrete inheritance are limited; generally, if
    polymorphic loading is configured on the mapper using one of the declarative concrete
    mixins, it can’t be modified at query time in current SQLAlchemy versions. Normally,
    the [`with_polymorphic()`](queryguide/inheritance.html#sqlalchemy.orm.with_polymorphic
    "sqlalchemy.orm.with_polymorphic") function would be able to override the style
    of loading used by concrete, however due to current limitations this is not yet
    supported.
  prefs: []
  type: TYPE_NORMAL
