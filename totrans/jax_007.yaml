- en: Key Concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[`jax.readthedocs.io/en/latest/key-concepts.html`](https://jax.readthedocs.io/en/latest/key-concepts.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This section briefly introduces some key concepts of the JAX package.
  prefs: []
  type: TYPE_NORMAL
- en: '## JAX arrays (`jax.Array`)'
  prefs: []
  type: TYPE_NORMAL
- en: The default array implementation in JAX is `jax.Array`. In many ways it is similar
    to the [`numpy.ndarray`](https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray
    "(in NumPy v2.0)") type that you may be familar with from the NumPy package, but
    it has some important differences.
  prefs: []
  type: TYPE_NORMAL
- en: Array creation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We typically don’t call the `jax.Array` constructor directly, but rather create
    arrays via JAX API functions. For example, `jax.numpy` provides familar NumPy-style
    array construction functionality such as `jax.numpy.zeros()`, `jax.numpy.linspace()`,
    `jax.numpy.arange()`, etc.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: If you use Python type annotations in your code, `jax.Array` is the appropriate
    annotation for jax array objects (see `jax.typing` for more discussion).
  prefs: []
  type: TYPE_NORMAL
- en: Array devices and sharding
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'JAX Array objects have a `devices` method that lets you inspect where the contents
    of the array are stored. In the simplest cases, this will be a single CPU device:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In general, an array may be *sharded* across multiple devices, in a manner
    that can be inspected via the `sharding` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Here the array is on a single device, but in general a JAX array can be sharded
    across multiple devices, or even multiple hosts. To read more about sharded arrays
    and parallel computation, refer to Introduction to sharded computation  ## Transformations'
  prefs: []
  type: TYPE_NORMAL
- en: Along with functions to operate on arrays, JAX includes a number of transformations
    which operate on JAX functions. These include
  prefs: []
  type: TYPE_NORMAL
- en: '`jax.jit()`: Just-in-time (JIT) compilation; see Just-in-time compilation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jax.vmap()`: Vectorizing transform; see Automatic vectorization'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`jax.grad()`: Gradient transform; see Automatic differentiation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'as well as several others. Transformations accept a function as an argument,
    and return a new transformed function. For example, here’s how you might JIT-compile
    a simple SELU function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Often you’ll see transformations applied using Python’s decorator syntax for
    convenience:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Transformations like `jit()`, `vmap()`, `grad()`, and others are key to using
    JAX effectively, and we’ll cover them in detail in later sections.  ## Tracing'
  prefs: []
  type: TYPE_NORMAL
- en: The magic behind transformations is the notion of a Tracer. Tracers are abstract
    stand-ins for array objects, and are passed to JAX functions in order to extract
    the sequence of operations that the function encodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see this by printing any array value within transformed JAX code; for
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The value printed is not the array `x`, but a `Tracer` instance that represents
    essential attributes of `x`, such as its `shape` and `dtype`. By executing the
    function with traced values, JAX can determine the sequence of operations encoded
    by the function before those operations are actually executed: transformations
    like `jit()`, `vmap()`, and `grad()` can then map this sequence of input operations
    to a transformed sequence of operations.  ## Jaxprs'
  prefs: []
  type: TYPE_NORMAL
- en: JAX has its own intermediate representation for sequences of operations, known
    as a jaxpr. A jaxpr (short for *JAX exPRession*) is a simple representation of
    a functional program, comprising a sequence of primitive operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider the `selu` function we defined above:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the `jax.make_jaxpr()` utility to convert this function into a jaxpr
    given a particular input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Comparing this to the Python function definition, we see that it encodes the
    precise sequence of operations that the function represents. We’ll go into more
    depth about jaxprs later in JAX internals: The jaxpr language.  ## Pytrees'
  prefs: []
  type: TYPE_NORMAL
- en: 'JAX functions and transformations fundamentally operate on arrays, but in practice
    it is convenient to write code that work with collections of arrays: for example,
    a neural network might organize its parameters in a dictionary of arrays with
    meaningful keys. Rather than handle such structures on a case-by-case basis, JAX
    relies on the pytree abstraction to treat such collections in a uniform matter.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some examples of objects that can be treated as pytrees:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: JAX has a number of general-purpose utilities for working with PyTrees; for
    example the functions `jax.tree.map()` can be used to map a function to every
    leaf in a tree, and `jax.tree.reduce()` can be used to apply a reduction across
    the leaves in a tree.
  prefs: []
  type: TYPE_NORMAL
- en: You can learn more in the Working with pytrees tutorial.
  prefs: []
  type: TYPE_NORMAL
