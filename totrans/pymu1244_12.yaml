- en: Images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://pymupdf.readthedocs.io/en/latest/recipes-images.html](https://pymupdf.readthedocs.io/en/latest/recipes-images.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '## How to Make Images from Document Pages'
  prefs: []
  type: TYPE_NORMAL
- en: This little script will take a document filename and generate a PNG file from
    each of its pages.
  prefs: []
  type: TYPE_NORMAL
- en: The document can be any [supported type](how-to-open-a-file.html#supported-file-types).
  prefs: []
  type: TYPE_NORMAL
- en: 'The script works as a command line tool which expects the filename being supplied
    as a parameter. The generated image files (1 per page) are stored in the directory
    of the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The script directory will now contain PNG image files named *page-0.png*, *page-1.png*,
    etc. Pictures have the dimension of their pages with width and height rounded
    to integers, e.g. 595 x 842 pixels for an A4 portrait sized page. They will have
    a resolution of 96 dpi in x and y dimension and have no transparency. You can
    change all that – for how to do this, read the next sections.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *  ## How to Increase Image Resolution'
  prefs: []
  type: TYPE_NORMAL
- en: The image of a document page is represented by a [Pixmap](pixmap.html#pixmap),
    and the simplest way to create a pixmap is via method [`Page.get_pixmap()`](page.html#Page.get_pixmap
    "Page.get_pixmap").
  prefs: []
  type: TYPE_NORMAL
- en: This method has many options to influence the result. The most important among
    them is the [Matrix](matrix.html#matrix), which lets you zoom, rotate, distort
    or mirror the outcome.
  prefs: []
  type: TYPE_NORMAL
- en: '[`Page.get_pixmap()`](page.html#Page.get_pixmap "Page.get_pixmap") by default
    will use the [Identity](identity.html#identity) matrix, which does nothing.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following, we apply a zoom factor of 2 to each dimension, which will
    generate an image with a four times better resolution for us (and also about 4
    times the size):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Since version 1.19.2 there is a more direct way to set the resolution: Parameter
    `"dpi"` (dots per inch) can be used in place of `"matrix"`. To create a 300 dpi
    image of a page specify `pix = page.get_pixmap(dpi=300)`. Apart from notation
    brevity, this approach has the additional advantage that the **dpi value is saved
    with the image** file – which does not happen automatically when using the Matrix
    notation.'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *  ## How to Create Partial Pixmaps (Clips)'
  prefs: []
  type: TYPE_NORMAL
- en: You do not always need or want the full image of a page. This is the case e.g.
    when you display the image in a GUI and would like to fill the respective window
    with a zoomed part of the page.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s assume your GUI window has room to display a full document page, but you
    now want to fill this room with the bottom right quarter of your page, thus using
    a four times better resolution.
  prefs: []
  type: TYPE_NORMAL
- en: To achieve this, define a rectangle equal to the area you want to appear in
    the GUI and call it “clip”. One way of constructing rectangles in PyMuPDF is by
    providing two diagonally opposite corners, which is what we are doing here.
  prefs: []
  type: TYPE_NORMAL
- en: '[![_images/img-clip.jpg](../Images/add4ff2619b65913254461289b204f58.png)](_images/img-clip.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In the above we construct *clip* by specifying two diagonally opposite points:
    the middle point *mp* of the page rectangle, and its bottom right, *rect.br*.'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *  ## How to Zoom a Clip to a GUI Window'
  prefs: []
  type: TYPE_NORMAL
- en: Please also read the previous section. This time we want to **compute the zoom
    factor** for a clip, such that its image best fits a given GUI window. This means,
    that the image’s width or height (or both) will equal the window dimension. For
    the following code snippet you need to provide the WIDTH and HEIGHT of your GUI’s
    window that should receive the page’s clip rectangle.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: For the other way round, now assume you **have** the zoom factor and need to
    **compute the fitting clip**.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case we have `zoom = HEIGHT/clip.height = WIDTH/clip.width`, so we
    must set `clip.height = HEIGHT/zoom` and, `clip.width = WIDTH/zoom`. Choose the
    top-left point [`tl`](irect.html#IRect.tl "IRect.tl") of the clip on the page
    to compute the right pixmap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '* * *  ## How to Create or Suppress Annotation Images'
  prefs: []
  type: TYPE_NORMAL
- en: Normally, the pixmap of a page also shows the page’s annotations. Occasionally,
    this may not be desirable.
  prefs: []
  type: TYPE_NORMAL
- en: To suppress the annotation images on a rendered page, just specify `annots=False`
    in [`Page.get_pixmap()`](page.html#Page.get_pixmap "Page.get_pixmap").
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also render annotations separately: they have their own [`Annot.get_pixmap()`](annot.html#Annot.get_pixmap
    "Annot.get_pixmap") method. The resulting pixmap has the same dimensions as the
    annotation rectangle.'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *  ## How to Extract Images: Non-PDF Documents'
  prefs: []
  type: TYPE_NORMAL
- en: In contrast to the previous sections, this section deals with **extracting**
    images **contained** in documents, so they can be displayed as part of one or
    more pages.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to recreate the original image in file form or as a memory area,
    you have basically two options:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Convert your document to a PDF, and then use one of the PDF-only extraction
    methods. This snippet will convert a document to PDF:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use [`Page.get_text()`](page.html#Page.get_text "Page.get_text") with the “dict”
    parameter. This works for all document types. It will extract all text and images
    shown on the page, formatted as a Python dictionary. Every image will occur in
    an image block, containing meta information and **the binary image data**. For
    details of the dictionary’s structure, see [TextPage](textpage.html#textpage).
    The method works equally well for PDF files. This creates a list of all images
    shown on a page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '* * *  ## How to Extract Images: PDF Documents'
  prefs: []
  type: TYPE_NORMAL
- en: 'Like any other “object” in a PDF, images are identified by a cross reference
    number ([`xref`](glossary.html#xref "xref"), an integer). If you know this number,
    you have two ways to access the image’s data:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Create** a [Pixmap](pixmap.html#pixmap) of the image with instruction *pix
    = pymupdf.Pixmap(doc, xref)*. This method is **very** fast (single digit micro-seconds).
    The pixmap’s properties (width, height, …) will reflect the ones of the image.
    In this case there is no way to tell which image format the embedded original
    has.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Extract** the image with *img = doc.extract_image(xref)*. This is a dictionary
    containing the binary image data as *img[“image”]*. A number of meta data are
    also provided – mostly the same as you would find in the pixmap of the image.
    The major difference is string *img[“ext”]*, which specifies the image format:
    apart from “png”, strings like “jpeg”, “bmp”, “tiff”, etc. can also occur. Use
    this string as the file extension if you want to store to disk. The execution
    speed of this method should be compared to the combined speed of the statements
    *pix = pymupdf.Pixmap(doc, xref);pix.tobytes()*. If the embedded image is in PNG
    format, the speed of [`Document.extract_image()`](document.html#Document.extract_image
    "Document.extract_image") is about the same (and the binary image data are identical).
    Otherwise, this method is **thousands of times faster**, and the **image data
    is much smaller**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The question remains: **“How do I know those ‘xref’ numbers of images?”**.
    There are two answers to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '**“Inspect the page objects:”** Loop through the items of [`Page.get_images()`](page.html#Page.get_images
    "Page.get_images"). It is a list of list, and its items look like *[xref, smask,
    …]*, containing the [`xref`](glossary.html#xref "xref") of an image. This [`xref`](glossary.html#xref
    "xref") can then be used with one of the above methods. Use this method for **valid
    (undamaged)** documents. Be wary however, that the same image may be referenced
    multiple times (by different pages), so you might want to provide a mechanism
    avoiding multiple extracts.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**“No need to know:”** Loop through the list of **all xrefs** of the document
    and perform a [`Document.extract_image()`](document.html#Document.extract_image
    "Document.extract_image") for each one. If the returned dictionary is empty, then
    continue – this [`xref`](glossary.html#xref "xref") is no image. Use this method
    if the PDF is **damaged (unusable pages)**. Note that a PDF often contains “pseudo-images”
    (“stencil masks”) with the special purpose of defining the transparency of some
    other image. You may want to provide logic to exclude those from extraction. Also
    have a look at the next section.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For both extraction approaches, there exist ready-to-use general purpose scripts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[extract-from-pages.py](https://github.com/pymupdf/PyMuPDF-Utilities/blob/master/examples/extract-images/extract-from-pages.py)
    extracts images page by page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[![_images/img-extract-imga.jpg](../Images/468eb5fcdbfd16fc54f483d903fad6fc.png)](_images/img-extract-imga.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'and [extract-from-xref.py](https://github.com/pymupdf/PyMuPDF-Utilities/blob/master/examples/extract-images/extract-from-xref.py)
    extracts images by xref table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[![_images/img-extract-imgb.jpg](../Images/9b4ab99682e71c7da8ad5b00d2c15fb3.png)](_images/img-extract-imgb.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *  ## How to Handle Image Masks'
  prefs: []
  type: TYPE_NORMAL
- en: Some images in PDFs are accompanied by **image masks**. In their simplest form,
    masks represent alpha (transparency) bytes stored as separate images. In order
    to reconstruct the original of an image, which has a mask, it must be “enriched”
    with transparency bytes taken from its mask.
  prefs: []
  type: TYPE_NORMAL
- en: 'Whether an image does have such a mask can be recognized in one of two ways
    in PyMuPDF:'
  prefs: []
  type: TYPE_NORMAL
- en: An item of [`Document.get_page_images()`](document.html#Document.get_page_images
    "Document.get_page_images") has the general format `(xref, smask, ...)`, where
    *xref* is the image’s [`xref`](glossary.html#xref "xref") and *smask*, if positive,
    then it is the [`xref`](glossary.html#xref "xref") of a mask.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The (dictionary) results of [`Document.extract_image()`](document.html#Document.extract_image
    "Document.extract_image") have a key *“smask”*, which also contains any mask’s
    [`xref`](glossary.html#xref "xref") if positive.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If *smask == 0* then the image encountered via [`xref`](glossary.html#xref "xref")
    can be processed as it is.
  prefs: []
  type: TYPE_NORMAL
- en: 'To recover the original image using PyMuPDF, the procedure depicted as follows
    must be executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[![_images/img-stencil.jpg](../Images/c052da902881f356548fe044dbc6b139.png)](_images/img-stencil.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Step (1) creates a pixmap of the basic image. Step (2) does the same with the
    image mask. Step (3) adds an alpha channel and fills it with transparency information.
  prefs: []
  type: TYPE_NORMAL
- en: The scripts [extract-from-pages.py](https://github.com/pymupdf/PyMuPDF-Utilities/blob/master/examples/extract-images/extract-from-pages.py),
    and [extract-from-xref.py](https://github.com/pymupdf/PyMuPDF-Utilities/blob/master/examples/extract-images/extract-from-xref.py)
    above also contain this logic.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *  ## How to Make one PDF of all your Pictures (or Files)'
  prefs: []
  type: TYPE_NORMAL
- en: We show here **three scripts** that take a list of (image and other) files and
    put them all in one PDF.
  prefs: []
  type: TYPE_NORMAL
- en: '**Method 1: Inserting Images as Pages**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first one converts each image to a PDF page with the same dimensions. The
    result will be a PDF with one page per image. It will only work for [supported
    image](how-to-open-a-file.html#supported-file-types) file formats:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This will generate a PDF only marginally larger than the combined pictures’
    size. Some numbers on performance:'
  prefs: []
  type: TYPE_NORMAL
- en: The above script needed about 1 minute on my machine for 149 pictures with a
    total size of 514 MB (and about the same resulting PDF size).
  prefs: []
  type: TYPE_NORMAL
- en: '[![_images/img-import-progress.jpg](../Images/7391f0359bbf5f3ef2d6ad706cdd3445.png)](_images/img-import-progress.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Look [here](https://github.com/pymupdf/PyMuPDF-Utilities/blob/master/examples/insert-images/insert.py)
    for a more complete source code: it offers a directory selection dialog and skips
    unsupported files and non-file entries.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: We might have used [`Page.insert_image()`](page.html#Page.insert_image "Page.insert_image")
    instead of [`Page.show_pdf_page()`](page.html#Page.show_pdf_page "Page.show_pdf_page"),
    and the result would have been a similar looking file. However, depending on the
    image type, it may store **images uncompressed**. Therefore, the save option *deflate
    = True* must be used to achieve a reasonable file size, which hugely increases
    the runtime for large numbers of images. So this alternative **cannot be recommended**
    here.
  prefs: []
  type: TYPE_NORMAL
- en: '**Method 2: Embedding Files**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The second script **embeds** arbitrary files – not only images. The resulting
    PDF will have just one (empty) page, required for technical reasons. To later
    access the embedded files again, you would need a suitable PDF viewer that can
    display and / or extract embedded files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[![_images/img-embed-progress.jpg](../Images/ce836e48b6614aa9180e8dc34f165c07.png)](_images/img-embed-progress.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is by far the fastest method, and it also produces the smallest possible
    output file size. The above pictures needed 20 seconds on my machine and yielded
    a PDF size of 510 MB. Look [here](https://github.com/pymupdf/PyMuPDF-Utilities/tree/master/examples/embed-images/embed.py)
    for a more complete source code: it offers a directory selection dialog and skips
    non-file entries.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Method 3: Attaching Files**'
  prefs: []
  type: TYPE_NORMAL
- en: A third way to achieve this task is **attaching files** via page annotations
    see [here](https://github.com/pymupdf/PyMuPDF-Utilities/blob/master/examples/attach-images/attach.py)
    for the complete source code.
  prefs: []
  type: TYPE_NORMAL
- en: This has a similar performance as the previous script and it also produces a
    similar file size. It will produce PDF pages which show a ‘FileAttachment’ icon
    for each attached file.
  prefs: []
  type: TYPE_NORMAL
- en: '![_images/img-attach-result.jpg](../Images/1b3217c52d144c92a4de7ec80a200d5b.png)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Both, the **embed** and the **attach** methods can be used for **arbitrary files**
    – not just images.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: We strongly recommend using the awesome package [PySimpleGUI](https://pypi.org/project/PySimpleGUI/)
    to display a progress meter for tasks that may run for an extended time span.
    It’s pure Python, uses Tkinter (no additional GUI package) and requires just one
    more line of code!
  prefs: []
  type: TYPE_NORMAL
- en: '* * *  ## How to Create Vector Images'
  prefs: []
  type: TYPE_NORMAL
- en: The usual way to create an image from a document page is [`Page.get_pixmap()`](page.html#Page.get_pixmap
    "Page.get_pixmap"). A pixmap represents a raster image, so you must decide on
    its quality (i.e. resolution) at creation time. It cannot be changed later.
  prefs: []
  type: TYPE_NORMAL
- en: PyMuPDF also offers a way to create a **vector image** of a page in SVG format
    (scalable vector graphics, defined in XML syntax). SVG images remain precise across
    zooming levels (of course with the exception of any raster graphic elements embedded
    therein).
  prefs: []
  type: TYPE_NORMAL
- en: Instruction *svg = page.get_svg_image(matrix=pymupdf.Identity)* delivers a UTF-8
    string *svg* which can be stored with extension “.svg”.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *  ## How to Convert Images'
  prefs: []
  type: TYPE_NORMAL
- en: Just as a feature among others, PyMuPDF’s image conversion is easy. It may avoid
    using other graphics packages like PIL/Pillow in many cases.
  prefs: []
  type: TYPE_NORMAL
- en: Notwithstanding that interfacing with Pillow is almost trivial.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Input Formats** | **Output Formats** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| BMP | . | Windows Bitmap |'
  prefs: []
  type: TYPE_TB
- en: '| JPEG | JPEG | Joint Photographic Experts Group |'
  prefs: []
  type: TYPE_TB
- en: '| JXR | . | JPEG Extended Range |'
  prefs: []
  type: TYPE_TB
- en: '| JPX/JP2 | . | JPEG 2000 |'
  prefs: []
  type: TYPE_TB
- en: '| GIF | . | Graphics Interchange Format |'
  prefs: []
  type: TYPE_TB
- en: '| TIFF | . | Tagged Image File Format |'
  prefs: []
  type: TYPE_TB
- en: '| PNG | PNG | Portable Network Graphics |'
  prefs: []
  type: TYPE_TB
- en: '| PNM | PNM | Portable Anymap |'
  prefs: []
  type: TYPE_TB
- en: '| PGM | PGM | Portable Graymap |'
  prefs: []
  type: TYPE_TB
- en: '| PBM | PBM | Portable Bitmap |'
  prefs: []
  type: TYPE_TB
- en: '| PPM | PPM | Portable Pixmap |'
  prefs: []
  type: TYPE_TB
- en: '| PAM | PAM | Portable Arbitrary Map |'
  prefs: []
  type: TYPE_TB
- en: '| . | PSD | Adobe Photoshop Document |'
  prefs: []
  type: TYPE_TB
- en: '| . | PS | Adobe Postscript |'
  prefs: []
  type: TYPE_TB
- en: 'The general scheme is just the following two lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '**Remarks**'
  prefs: []
  type: TYPE_NORMAL
- en: The **input** argument of *pymupdf.Pixmap(arg)* can be a file or a bytes / io.BytesIO
    object containing an image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Instead of an output **file**, you can also create a bytes object via *pix.tobytes(“yyy”)*
    and pass this around.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As a matter of course, input and output formats must be compatible in terms
    of colorspace and transparency. The *Pixmap* class has batteries included if adjustments
    are needed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '**Convert JPEG to Photoshop**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Convert **JPEG to Tkinter PhotoImage**. Any **RGB / no-alpha** image works
    exactly the same. Conversion to one of the **Portable Anymap** formats (PPM, PGM,
    etc.) does the trick, because they are supported by all Tkinter versions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Convert **PNG with alpha** to Tkinter PhotoImage. This requires **removing
    the alpha bytes**, before we can do the PPM conversion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '* * *  ## How to Use Pixmaps: Gluing Images'
  prefs: []
  type: TYPE_NORMAL
- en: 'This shows how pixmaps can be used for purely graphical, non-document purposes.
    The script reads an image file and creates a new image which consist of 3 * 4
    tiles of the original:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the input picture:'
  prefs: []
  type: TYPE_NORMAL
- en: '[![_images/img-7edges.png](../Images/1d9b8de07f5f68835dd0cd1a31155814.png)](_images/img-7edges.png)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[![_images/img-target.png](../Images/bcc6bbc09a32c78ce761c0d71420557e.png)](_images/img-target.png)'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *  ## How to Use Pixmaps: Making a Fractal'
  prefs: []
  type: TYPE_NORMAL
- en: Here is another Pixmap example that creates **Sierpinski’s Carpet** – a fractal
    generalizing the **Cantor Set** to two dimensions. Given a square carpet, mark
    its 9 sub-suqares (3 times 3) and cut out the one in the center. Treat each of
    the remaining eight sub-squares in the same way, and continue *ad infinitum*.
    The end result is a set with area zero and fractal dimension 1.8928…
  prefs: []
  type: TYPE_NORMAL
- en: 'This script creates an approximate image of it as a PNG, by going down to one-pixel
    granularity. To increase the image precision, change the value of n (precision):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The result should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[![_images/img-sierpinski.png](../Images/5a22e9f54ce281b66b39e50486ae6f3d.png)](_images/img-sierpinski.png)'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *  ## How to Interface with NumPy'
  prefs: []
  type: TYPE_NORMAL
- en: 'This shows how to create a PNG file from a numpy array (several times faster
    than most other methods):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '* * *  ## How to Add Images to a PDF Page'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two methods to add images to a PDF page: [`Page.insert_image()`](page.html#Page.insert_image
    "Page.insert_image") and [`Page.show_pdf_page()`](page.html#Page.show_pdf_page
    "Page.show_pdf_page"). Both methods have things in common, but there are also
    differences.'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Criterion** | [`Page.insert_image()`](page.html#Page.insert_image "Page.insert_image")
    | [`Page.show_pdf_page()`](page.html#Page.show_pdf_page "Page.show_pdf_page")
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| displayable content | image file, image in memory, pixmap | PDF page |'
  prefs: []
  type: TYPE_TB
- en: '| display resolution | image resolution | vectorized (except raster page content)
    |'
  prefs: []
  type: TYPE_TB
- en: '| rotation | 0, 90, 180 or 270 degrees | any angle |'
  prefs: []
  type: TYPE_TB
- en: '| clipping | no (full image only) | yes |'
  prefs: []
  type: TYPE_TB
- en: '| keep aspect ratio | yes (default option) | yes (default option) |'
  prefs: []
  type: TYPE_TB
- en: '| transparency (water marking) | depends on the image | depends on the page
    |'
  prefs: []
  type: TYPE_TB
- en: '| location / placement | scaled to fit target rectangle | scaled to fit target
    rectangle |'
  prefs: []
  type: TYPE_TB
- en: '| performance | automatic prevention of duplicates; | automatic prevention
    of duplicates; |'
  prefs: []
  type: TYPE_TB
- en: '| multi-page image support | no | yes |'
  prefs: []
  type: TYPE_TB
- en: '| ease of use | simple, intuitive; | simple, intuitive; **usable for all document
    types** (including images!) after conversion to PDF via [`Document.convert_to_pdf()`](document.html#Document.convert_to_pdf
    "Document.convert_to_pdf") |'
  prefs: []
  type: TYPE_TB
- en: 'Basic code pattern for [`Page.insert_image()`](page.html#Page.insert_image
    "Page.insert_image"). **Exactly one** of the parameters **filename / stream /
    pixmap** must be given, if not re-inserting an existing image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Basic code pattern for [`Page.show_pdf_page()`](page.html#Page.show_pdf_page
    "Page.show_pdf_page"). Source and target PDF must be different [Document](document.html#document)
    objects (but may be opened from the same file):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]  ## How to Use Pixmaps: Checking Text Visibility'
  prefs: []
  type: TYPE_NORMAL
- en: 'Whether or not a given piece of text is actually visible on a page depends
    on a number of factors:'
  prefs: []
  type: TYPE_NORMAL
- en: Text is not covered by another object but may have the same color as the background
    i.e., white-on-white etc.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Text may be covered by an image or vector graphics. Detecting this is an important
    capability, for example to uncover badly anonymized legal documents.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Text is created hidden. This technique is usually used by OCR tools to store
    the recognized text in an invisible layer on the page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following shows how to detect situation 1\. above, or situation 2\. if
    the covering object is unicolor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Method [`Pixmap.color_topusage()`](pixmap.html#Pixmap.color_topusage "Pixmap.color_topusage")
    returns a tuple `(ratio, pixel)` where 0 < ratio <= 1 and *pixel* is the pixel
    value of the color. Please note that we create a **pixmap only once**. This can
    save a lot of processing time if there are multiple hit rectangles.
  prefs: []
  type: TYPE_NORMAL
- en: 'The logic of the above code is: If the needle’s rectangle is (“almost”: > 95%)
    unicolor, then the text cannot be visible. A typical result for visible text returns
    the color of the background (mostly white) and a ratio around 0.7 to 0.8, for
    example `(0.685, b''xffxffxff'')`.'
  prefs: []
  type: TYPE_NORMAL
- en: Do you have any feedback on this page?
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: This software is provided AS-IS with no warranty, either express or implied.
    This software is distributed under license and may not be copied, modified or
    distributed except as expressly authorized under the terms of that license. Refer
    to licensing information at [artifex.com](https://www.artifex.com?utm_source=rtd-pymupdf&utm_medium=rtd&utm_content=footer-link)
    or contact Artifex Software Inc., 39 Mesa Street, Suite 108A, San Francisco CA
    94129, United States for further information.
  prefs: []
  type: TYPE_NORMAL
- en: This documentation covers all versions up to 1.24.4.
  prefs: []
  type: TYPE_NORMAL
- en: '[![Discord logo](../Images/66cbb5081103a580193aa66c87b90d9a.png)](https://discord.gg/TSpYGBW4eq)
    ## How to Make Images from Document Pages'
  prefs: []
  type: TYPE_NORMAL
- en: This little script will take a document filename and generate a PNG file from
    each of its pages.
  prefs: []
  type: TYPE_NORMAL
- en: The document can be any [supported type](how-to-open-a-file.html#supported-file-types).
  prefs: []
  type: TYPE_NORMAL
- en: 'The script works as a command line tool which expects the filename being supplied
    as a parameter. The generated image files (1 per page) are stored in the directory
    of the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The script directory will now contain PNG image files named *page-0.png*, *page-1.png*,
    etc. Pictures have the dimension of their pages with width and height rounded
    to integers, e.g. 595 x 842 pixels for an A4 portrait sized page. They will have
    a resolution of 96 dpi in x and y dimension and have no transparency. You can
    change all that – for how to do this, read the next sections.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '## How to Increase Image Resolution'
  prefs: []
  type: TYPE_NORMAL
- en: The image of a document page is represented by a [Pixmap](pixmap.html#pixmap),
    and the simplest way to create a pixmap is via method [`Page.get_pixmap()`](page.html#Page.get_pixmap
    "Page.get_pixmap").
  prefs: []
  type: TYPE_NORMAL
- en: This method has many options to influence the result. The most important among
    them is the [Matrix](matrix.html#matrix), which lets you zoom, rotate, distort
    or mirror the outcome.
  prefs: []
  type: TYPE_NORMAL
- en: '[`Page.get_pixmap()`](page.html#Page.get_pixmap "Page.get_pixmap") by default
    will use the [Identity](identity.html#identity) matrix, which does nothing.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following, we apply a zoom factor of 2 to each dimension, which will
    generate an image with a four times better resolution for us (and also about 4
    times the size):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Since version 1.19.2 there is a more direct way to set the resolution: Parameter
    `"dpi"` (dots per inch) can be used in place of `"matrix"`. To create a 300 dpi
    image of a page specify `pix = page.get_pixmap(dpi=300)`. Apart from notation
    brevity, this approach has the additional advantage that the **dpi value is saved
    with the image** file – which does not happen automatically when using the Matrix
    notation.'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '## How to Create Partial Pixmaps (Clips)'
  prefs: []
  type: TYPE_NORMAL
- en: You do not always need or want the full image of a page. This is the case e.g.
    when you display the image in a GUI and would like to fill the respective window
    with a zoomed part of the page.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s assume your GUI window has room to display a full document page, but you
    now want to fill this room with the bottom right quarter of your page, thus using
    a four times better resolution.
  prefs: []
  type: TYPE_NORMAL
- en: To achieve this, define a rectangle equal to the area you want to appear in
    the GUI and call it “clip”. One way of constructing rectangles in PyMuPDF is by
    providing two diagonally opposite corners, which is what we are doing here.
  prefs: []
  type: TYPE_NORMAL
- en: '[![_images/img-clip.jpg](../Images/add4ff2619b65913254461289b204f58.png)](_images/img-clip.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In the above we construct *clip* by specifying two diagonally opposite points:
    the middle point *mp* of the page rectangle, and its bottom right, *rect.br*.'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '## How to Zoom a Clip to a GUI Window'
  prefs: []
  type: TYPE_NORMAL
- en: Please also read the previous section. This time we want to **compute the zoom
    factor** for a clip, such that its image best fits a given GUI window. This means,
    that the image’s width or height (or both) will equal the window dimension. For
    the following code snippet you need to provide the WIDTH and HEIGHT of your GUI’s
    window that should receive the page’s clip rectangle.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: For the other way round, now assume you **have** the zoom factor and need to
    **compute the fitting clip**.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case we have `zoom = HEIGHT/clip.height = WIDTH/clip.width`, so we
    must set `clip.height = HEIGHT/zoom` and, `clip.width = WIDTH/zoom`. Choose the
    top-left point [`tl`](irect.html#IRect.tl "IRect.tl") of the clip on the page
    to compute the right pixmap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '## How to Create or Suppress Annotation Images'
  prefs: []
  type: TYPE_NORMAL
- en: Normally, the pixmap of a page also shows the page’s annotations. Occasionally,
    this may not be desirable.
  prefs: []
  type: TYPE_NORMAL
- en: To suppress the annotation images on a rendered page, just specify `annots=False`
    in [`Page.get_pixmap()`](page.html#Page.get_pixmap "Page.get_pixmap").
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also render annotations separately: they have their own [`Annot.get_pixmap()`](annot.html#Annot.get_pixmap
    "Annot.get_pixmap") method. The resulting pixmap has the same dimensions as the
    annotation rectangle.'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '## How to Extract Images: Non-PDF Documents'
  prefs: []
  type: TYPE_NORMAL
- en: In contrast to the previous sections, this section deals with **extracting**
    images **contained** in documents, so they can be displayed as part of one or
    more pages.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to recreate the original image in file form or as a memory area,
    you have basically two options:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Convert your document to a PDF, and then use one of the PDF-only extraction
    methods. This snippet will convert a document to PDF:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use [`Page.get_text()`](page.html#Page.get_text "Page.get_text") with the “dict”
    parameter. This works for all document types. It will extract all text and images
    shown on the page, formatted as a Python dictionary. Every image will occur in
    an image block, containing meta information and **the binary image data**. For
    details of the dictionary’s structure, see [TextPage](textpage.html#textpage).
    The method works equally well for PDF files. This creates a list of all images
    shown on a page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '## How to Extract Images: PDF Documents'
  prefs: []
  type: TYPE_NORMAL
- en: 'Like any other “object” in a PDF, images are identified by a cross reference
    number ([`xref`](glossary.html#xref "xref"), an integer). If you know this number,
    you have two ways to access the image’s data:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Create** a [Pixmap](pixmap.html#pixmap) of the image with instruction *pix
    = pymupdf.Pixmap(doc, xref)*. This method is **very** fast (single digit micro-seconds).
    The pixmap’s properties (width, height, …) will reflect the ones of the image.
    In this case there is no way to tell which image format the embedded original
    has.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Extract** the image with *img = doc.extract_image(xref)*. This is a dictionary
    containing the binary image data as *img[“image”]*. A number of meta data are
    also provided – mostly the same as you would find in the pixmap of the image.
    The major difference is string *img[“ext”]*, which specifies the image format:
    apart from “png”, strings like “jpeg”, “bmp”, “tiff”, etc. can also occur. Use
    this string as the file extension if you want to store to disk. The execution
    speed of this method should be compared to the combined speed of the statements
    *pix = pymupdf.Pixmap(doc, xref);pix.tobytes()*. If the embedded image is in PNG
    format, the speed of [`Document.extract_image()`](document.html#Document.extract_image
    "Document.extract_image") is about the same (and the binary image data are identical).
    Otherwise, this method is **thousands of times faster**, and the **image data
    is much smaller**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The question remains: **“How do I know those ‘xref’ numbers of images?”**.
    There are two answers to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '**“Inspect the page objects:”** Loop through the items of [`Page.get_images()`](page.html#Page.get_images
    "Page.get_images"). It is a list of list, and its items look like *[xref, smask,
    …]*, containing the [`xref`](glossary.html#xref "xref") of an image. This [`xref`](glossary.html#xref
    "xref") can then be used with one of the above methods. Use this method for **valid
    (undamaged)** documents. Be wary however, that the same image may be referenced
    multiple times (by different pages), so you might want to provide a mechanism
    avoiding multiple extracts.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**“No need to know:”** Loop through the list of **all xrefs** of the document
    and perform a [`Document.extract_image()`](document.html#Document.extract_image
    "Document.extract_image") for each one. If the returned dictionary is empty, then
    continue – this [`xref`](glossary.html#xref "xref") is no image. Use this method
    if the PDF is **damaged (unusable pages)**. Note that a PDF often contains “pseudo-images”
    (“stencil masks”) with the special purpose of defining the transparency of some
    other image. You may want to provide logic to exclude those from extraction. Also
    have a look at the next section.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For both extraction approaches, there exist ready-to-use general purpose scripts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[extract-from-pages.py](https://github.com/pymupdf/PyMuPDF-Utilities/blob/master/examples/extract-images/extract-from-pages.py)
    extracts images page by page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[![_images/img-extract-imga.jpg](../Images/468eb5fcdbfd16fc54f483d903fad6fc.png)](_images/img-extract-imga.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'and [extract-from-xref.py](https://github.com/pymupdf/PyMuPDF-Utilities/blob/master/examples/extract-images/extract-from-xref.py)
    extracts images by xref table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[![_images/img-extract-imgb.jpg](../Images/9b4ab99682e71c7da8ad5b00d2c15fb3.png)](_images/img-extract-imgb.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '## How to Handle Image Masks'
  prefs: []
  type: TYPE_NORMAL
- en: Some images in PDFs are accompanied by **image masks**. In their simplest form,
    masks represent alpha (transparency) bytes stored as separate images. In order
    to reconstruct the original of an image, which has a mask, it must be “enriched”
    with transparency bytes taken from its mask.
  prefs: []
  type: TYPE_NORMAL
- en: 'Whether an image does have such a mask can be recognized in one of two ways
    in PyMuPDF:'
  prefs: []
  type: TYPE_NORMAL
- en: An item of [`Document.get_page_images()`](document.html#Document.get_page_images
    "Document.get_page_images") has the general format `(xref, smask, ...)`, where
    *xref* is the image’s [`xref`](glossary.html#xref "xref") and *smask*, if positive,
    then it is the [`xref`](glossary.html#xref "xref") of a mask.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The (dictionary) results of [`Document.extract_image()`](document.html#Document.extract_image
    "Document.extract_image") have a key *“smask”*, which also contains any mask’s
    [`xref`](glossary.html#xref "xref") if positive.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If *smask == 0* then the image encountered via [`xref`](glossary.html#xref "xref")
    can be processed as it is.
  prefs: []
  type: TYPE_NORMAL
- en: 'To recover the original image using PyMuPDF, the procedure depicted as follows
    must be executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[![_images/img-stencil.jpg](../Images/c052da902881f356548fe044dbc6b139.png)](_images/img-stencil.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Step (1) creates a pixmap of the basic image. Step (2) does the same with the
    image mask. Step (3) adds an alpha channel and fills it with transparency information.
  prefs: []
  type: TYPE_NORMAL
- en: The scripts [extract-from-pages.py](https://github.com/pymupdf/PyMuPDF-Utilities/blob/master/examples/extract-images/extract-from-pages.py),
    and [extract-from-xref.py](https://github.com/pymupdf/PyMuPDF-Utilities/blob/master/examples/extract-images/extract-from-xref.py)
    above also contain this logic.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '## How to Make one PDF of all your Pictures (or Files)'
  prefs: []
  type: TYPE_NORMAL
- en: We show here **three scripts** that take a list of (image and other) files and
    put them all in one PDF.
  prefs: []
  type: TYPE_NORMAL
- en: '**Method 1: Inserting Images as Pages**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first one converts each image to a PDF page with the same dimensions. The
    result will be a PDF with one page per image. It will only work for [supported
    image](how-to-open-a-file.html#supported-file-types) file formats:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This will generate a PDF only marginally larger than the combined pictures’
    size. Some numbers on performance:'
  prefs: []
  type: TYPE_NORMAL
- en: The above script needed about 1 minute on my machine for 149 pictures with a
    total size of 514 MB (and about the same resulting PDF size).
  prefs: []
  type: TYPE_NORMAL
- en: '[![_images/img-import-progress.jpg](../Images/7391f0359bbf5f3ef2d6ad706cdd3445.png)](_images/img-import-progress.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Look [here](https://github.com/pymupdf/PyMuPDF-Utilities/blob/master/examples/insert-images/insert.py)
    for a more complete source code: it offers a directory selection dialog and skips
    unsupported files and non-file entries.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: We might have used [`Page.insert_image()`](page.html#Page.insert_image "Page.insert_image")
    instead of [`Page.show_pdf_page()`](page.html#Page.show_pdf_page "Page.show_pdf_page"),
    and the result would have been a similar looking file. However, depending on the
    image type, it may store **images uncompressed**. Therefore, the save option *deflate
    = True* must be used to achieve a reasonable file size, which hugely increases
    the runtime for large numbers of images. So this alternative **cannot be recommended**
    here.
  prefs: []
  type: TYPE_NORMAL
- en: '**Method 2: Embedding Files**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The second script **embeds** arbitrary files – not only images. The resulting
    PDF will have just one (empty) page, required for technical reasons. To later
    access the embedded files again, you would need a suitable PDF viewer that can
    display and / or extract embedded files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[![_images/img-embed-progress.jpg](../Images/ce836e48b6614aa9180e8dc34f165c07.png)](_images/img-embed-progress.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is by far the fastest method, and it also produces the smallest possible
    output file size. The above pictures needed 20 seconds on my machine and yielded
    a PDF size of 510 MB. Look [here](https://github.com/pymupdf/PyMuPDF-Utilities/tree/master/examples/embed-images/embed.py)
    for a more complete source code: it offers a directory selection dialog and skips
    non-file entries.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Method 3: Attaching Files**'
  prefs: []
  type: TYPE_NORMAL
- en: A third way to achieve this task is **attaching files** via page annotations
    see [here](https://github.com/pymupdf/PyMuPDF-Utilities/blob/master/examples/attach-images/attach.py)
    for the complete source code.
  prefs: []
  type: TYPE_NORMAL
- en: This has a similar performance as the previous script and it also produces a
    similar file size. It will produce PDF pages which show a ‘FileAttachment’ icon
    for each attached file.
  prefs: []
  type: TYPE_NORMAL
- en: '![_images/img-attach-result.jpg](../Images/1b3217c52d144c92a4de7ec80a200d5b.png)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Both, the **embed** and the **attach** methods can be used for **arbitrary files**
    – not just images.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: We strongly recommend using the awesome package [PySimpleGUI](https://pypi.org/project/PySimpleGUI/)
    to display a progress meter for tasks that may run for an extended time span.
    It’s pure Python, uses Tkinter (no additional GUI package) and requires just one
    more line of code!
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '## How to Create Vector Images'
  prefs: []
  type: TYPE_NORMAL
- en: The usual way to create an image from a document page is [`Page.get_pixmap()`](page.html#Page.get_pixmap
    "Page.get_pixmap"). A pixmap represents a raster image, so you must decide on
    its quality (i.e. resolution) at creation time. It cannot be changed later.
  prefs: []
  type: TYPE_NORMAL
- en: PyMuPDF also offers a way to create a **vector image** of a page in SVG format
    (scalable vector graphics, defined in XML syntax). SVG images remain precise across
    zooming levels (of course with the exception of any raster graphic elements embedded
    therein).
  prefs: []
  type: TYPE_NORMAL
- en: Instruction *svg = page.get_svg_image(matrix=pymupdf.Identity)* delivers a UTF-8
    string *svg* which can be stored with extension “.svg”.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '## How to Convert Images'
  prefs: []
  type: TYPE_NORMAL
- en: Just as a feature among others, PyMuPDF’s image conversion is easy. It may avoid
    using other graphics packages like PIL/Pillow in many cases.
  prefs: []
  type: TYPE_NORMAL
- en: Notwithstanding that interfacing with Pillow is almost trivial.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Input Formats** | **Output Formats** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| BMP | . | Windows Bitmap |'
  prefs: []
  type: TYPE_TB
- en: '| JPEG | JPEG | Joint Photographic Experts Group |'
  prefs: []
  type: TYPE_TB
- en: '| JXR | . | JPEG Extended Range |'
  prefs: []
  type: TYPE_TB
- en: '| JPX/JP2 | . | JPEG 2000 |'
  prefs: []
  type: TYPE_TB
- en: '| GIF | . | Graphics Interchange Format |'
  prefs: []
  type: TYPE_TB
- en: '| TIFF | . | Tagged Image File Format |'
  prefs: []
  type: TYPE_TB
- en: '| PNG | PNG | Portable Network Graphics |'
  prefs: []
  type: TYPE_TB
- en: '| PNM | PNM | Portable Anymap |'
  prefs: []
  type: TYPE_TB
- en: '| PGM | PGM | Portable Graymap |'
  prefs: []
  type: TYPE_TB
- en: '| PBM | PBM | Portable Bitmap |'
  prefs: []
  type: TYPE_TB
- en: '| PPM | PPM | Portable Pixmap |'
  prefs: []
  type: TYPE_TB
- en: '| PAM | PAM | Portable Arbitrary Map |'
  prefs: []
  type: TYPE_TB
- en: '| . | PSD | Adobe Photoshop Document |'
  prefs: []
  type: TYPE_TB
- en: '| . | PS | Adobe Postscript |'
  prefs: []
  type: TYPE_TB
- en: 'The general scheme is just the following two lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '**Remarks**'
  prefs: []
  type: TYPE_NORMAL
- en: The **input** argument of *pymupdf.Pixmap(arg)* can be a file or a bytes / io.BytesIO
    object containing an image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Instead of an output **file**, you can also create a bytes object via *pix.tobytes(“yyy”)*
    and pass this around.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As a matter of course, input and output formats must be compatible in terms
    of colorspace and transparency. The *Pixmap* class has batteries included if adjustments
    are needed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '**Convert JPEG to Photoshop**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Convert **JPEG to Tkinter PhotoImage**. Any **RGB / no-alpha** image works
    exactly the same. Conversion to one of the **Portable Anymap** formats (PPM, PGM,
    etc.) does the trick, because they are supported by all Tkinter versions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Convert **PNG with alpha** to Tkinter PhotoImage. This requires **removing
    the alpha bytes**, before we can do the PPM conversion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '## How to Use Pixmaps: Gluing Images'
  prefs: []
  type: TYPE_NORMAL
- en: 'This shows how pixmaps can be used for purely graphical, non-document purposes.
    The script reads an image file and creates a new image which consist of 3 * 4
    tiles of the original:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the input picture:'
  prefs: []
  type: TYPE_NORMAL
- en: '[![_images/img-7edges.png](../Images/1d9b8de07f5f68835dd0cd1a31155814.png)](_images/img-7edges.png)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[![_images/img-target.png](../Images/bcc6bbc09a32c78ce761c0d71420557e.png)](_images/img-target.png)'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '## How to Use Pixmaps: Making a Fractal'
  prefs: []
  type: TYPE_NORMAL
- en: Here is another Pixmap example that creates **Sierpinski’s Carpet** – a fractal
    generalizing the **Cantor Set** to two dimensions. Given a square carpet, mark
    its 9 sub-suqares (3 times 3) and cut out the one in the center. Treat each of
    the remaining eight sub-squares in the same way, and continue *ad infinitum*.
    The end result is a set with area zero and fractal dimension 1.8928…
  prefs: []
  type: TYPE_NORMAL
- en: 'This script creates an approximate image of it as a PNG, by going down to one-pixel
    granularity. To increase the image precision, change the value of n (precision):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The result should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[![_images/img-sierpinski.png](../Images/5a22e9f54ce281b66b39e50486ae6f3d.png)](_images/img-sierpinski.png)'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '## How to Interface with NumPy'
  prefs: []
  type: TYPE_NORMAL
- en: 'This shows how to create a PNG file from a numpy array (several times faster
    than most other methods):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: '## How to Add Images to a PDF Page'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two methods to add images to a PDF page: [`Page.insert_image()`](page.html#Page.insert_image
    "Page.insert_image") and [`Page.show_pdf_page()`](page.html#Page.show_pdf_page
    "Page.show_pdf_page"). Both methods have things in common, but there are also
    differences.'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Criterion** | [`Page.insert_image()`](page.html#Page.insert_image "Page.insert_image")
    | [`Page.show_pdf_page()`](page.html#Page.show_pdf_page "Page.show_pdf_page")
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| displayable content | image file, image in memory, pixmap | PDF page |'
  prefs: []
  type: TYPE_TB
- en: '| display resolution | image resolution | vectorized (except raster page content)
    |'
  prefs: []
  type: TYPE_TB
- en: '| rotation | 0, 90, 180 or 270 degrees | any angle |'
  prefs: []
  type: TYPE_TB
- en: '| clipping | no (full image only) | yes |'
  prefs: []
  type: TYPE_TB
- en: '| keep aspect ratio | yes (default option) | yes (default option) |'
  prefs: []
  type: TYPE_TB
- en: '| transparency (water marking) | depends on the image | depends on the page
    |'
  prefs: []
  type: TYPE_TB
- en: '| location / placement | scaled to fit target rectangle | scaled to fit target
    rectangle |'
  prefs: []
  type: TYPE_TB
- en: '| performance | automatic prevention of duplicates; | automatic prevention
    of duplicates; |'
  prefs: []
  type: TYPE_TB
- en: '| multi-page image support | no | yes |'
  prefs: []
  type: TYPE_TB
- en: '| ease of use | simple, intuitive; | simple, intuitive; **usable for all document
    types** (including images!) after conversion to PDF via [`Document.convert_to_pdf()`](document.html#Document.convert_to_pdf
    "Document.convert_to_pdf") |'
  prefs: []
  type: TYPE_TB
- en: 'Basic code pattern for [`Page.insert_image()`](page.html#Page.insert_image
    "Page.insert_image"). **Exactly one** of the parameters **filename / stream /
    pixmap** must be given, if not re-inserting an existing image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Basic code pattern for [`Page.show_pdf_page()`](page.html#Page.show_pdf_page
    "Page.show_pdf_page"). Source and target PDF must be different [Document](document.html#document)
    objects (but may be opened from the same file):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '## How to Use Pixmaps: Checking Text Visibility'
  prefs: []
  type: TYPE_NORMAL
- en: 'Whether or not a given piece of text is actually visible on a page depends
    on a number of factors:'
  prefs: []
  type: TYPE_NORMAL
- en: Text is not covered by another object but may have the same color as the background
    i.e., white-on-white etc.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Text may be covered by an image or vector graphics. Detecting this is an important
    capability, for example to uncover badly anonymized legal documents.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Text is created hidden. This technique is usually used by OCR tools to store
    the recognized text in an invisible layer on the page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following shows how to detect situation 1\. above, or situation 2\. if
    the covering object is unicolor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Method [`Pixmap.color_topusage()`](pixmap.html#Pixmap.color_topusage "Pixmap.color_topusage")
    returns a tuple `(ratio, pixel)` where 0 < ratio <= 1 and *pixel* is the pixel
    value of the color. Please note that we create a **pixmap only once**. This can
    save a lot of processing time if there are multiple hit rectangles.
  prefs: []
  type: TYPE_NORMAL
- en: 'The logic of the above code is: If the needle’s rectangle is (“almost”: > 95%)
    unicolor, then the text cannot be visible. A typical result for visible text returns
    the color of the background (mostly white) and a ratio around 0.7 to 0.8, for
    example `(0.685, b''xffxffxff'')`.'
  prefs: []
  type: TYPE_NORMAL
- en: Do you have any feedback on this page?
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: This software is provided AS-IS with no warranty, either express or implied.
    This software is distributed under license and may not be copied, modified or
    distributed except as expressly authorized under the terms of that license. Refer
    to licensing information at [artifex.com](https://www.artifex.com?utm_source=rtd-pymupdf&utm_medium=rtd&utm_content=footer-link)
    or contact Artifex Software Inc., 39 Mesa Street, Suite 108A, San Francisco CA
    94129, United States for further information.
  prefs: []
  type: TYPE_NORMAL
- en: This documentation covers all versions up to 1.24.4.
  prefs: []
  type: TYPE_NORMAL
- en: '[![Discord logo](../Images/66cbb5081103a580193aa66c87b90d9a.png)](https://discord.gg/TSpYGBW4eq)'
  prefs: []
  type: TYPE_NORMAL
