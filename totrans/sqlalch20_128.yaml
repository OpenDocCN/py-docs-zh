- en: 1.3 Changelog
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.sqlalchemy.org/en/20/changelog/changelog_13.html](https://docs.sqlalchemy.org/en/20/changelog/changelog_13.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 1.3.25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: no release date
  prefs: []
  type: TYPE_NORMAL
- en: orm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue in [`Session.bulk_save_objects()`](../orm/session_api.html#sqlalchemy.orm.Session.bulk_save_objects
    "sqlalchemy.orm.Session.bulk_save_objects") when used with persistent objects
    which would fail to track the primary key of mappings where the column name of
    the primary key were different than the attribute name.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#6392](https://www.sqlalchemy.org/trac/ticket/6392)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: schema
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[schema] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    object now raises an informative error message if it is instantiated without passing
    at least the [`Table.name`](../core/metadata.html#sqlalchemy.schema.Table.params.name
    "sqlalchemy.schema.Table") and [`Table.metadata`](../core/metadata.html#sqlalchemy.schema.Table.params.metadata
    "sqlalchemy.schema.Table") arguments positionally. Previously, if these were passed
    as keyword arguments, the object would silently fail to initialize correctly.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#6135](https://www.sqlalchemy.org/trac/ticket/6135)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: postgresql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[postgresql] [bug] [regression]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed regression caused by [#6023](https://www.sqlalchemy.org/trac/ticket/6023)
    where the PostgreSQL cast operator applied to elements within an [`ARRAY`](../core/type_basics.html#sqlalchemy.types.ARRAY
    "sqlalchemy.types.ARRAY") when using psycopg2 would fail to use the correct type
    in the case that the datatype were also embedded within an instance of the [`Variant`](../core/type_api.html#sqlalchemy.types.Variant
    "sqlalchemy.types.Variant") adapter.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Additionally, repairs support for the correct CREATE TYPE to be emitted when
    using a `Variant(ARRAY(some_schema_type))`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#6182](https://www.sqlalchemy.org/trac/ticket/6182)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: mysql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[mysql] [bug] [mariadb]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixes to accommodate for the MariaDB 10.6 series, including backwards incompatible
    changes in both the mariadb-connector Python driver (supported on SQLAlchemy 1.4
    only) as well as the native 10.6 client libraries that are used automatically
    by the mysqlclient DBAPI (applies to both 1.3 and 1.4). The “utf8mb3” encoding
    symbol is now reported by these client libraries when the encoding is stated as
    “utf8”, leading to lookup and encoding errors within the MySQL dialect that does
    not expect this symbol. Updates to both the MySQL base library to accommodate
    for this utf8mb3 symbol being reported as well as to the test suite. Thanks to
    Georg Richter for support.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#7115](https://www.sqlalchemy.org/trac/ticket/7115), [#7136](https://www.sqlalchemy.org/trac/ticket/7136)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sqlite
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[sqlite] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add note regarding encryption-related pragmas for pysqlcipher passed in the
    url.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#6589](https://www.sqlalchemy.org/trac/ticket/6589)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 1.3.24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Released: March 30, 2021'
  prefs: []
  type: TYPE_NORMAL
- en: orm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removed very old warning that states that passive_deletes is not intended for
    many-to-one relationships. While it is likely that in many cases placing this
    parameter on a many-to-one relationship is not what was intended, there are use
    cases where delete cascade may want to be disallowed following from such a relationship.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5983](https://www.sqlalchemy.org/trac/ticket/5983)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue where the process of joining two tables could fail if one of the
    tables had an unrelated, unresolvable foreign key constraint which would raise
    [`NoReferenceError`](../core/exceptions.html#sqlalchemy.exc.NoReferenceError "sqlalchemy.exc.NoReferenceError")
    within the join process, which nonetheless could be bypassed to allow the join
    to complete. The logic which tested the exception for significance within the
    process would make assumptions about the construct which would fail.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5952](https://www.sqlalchemy.org/trac/ticket/5952)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue where the [`MutableComposite`](../orm/extensions/mutable.html#sqlalchemy.ext.mutable.MutableComposite
    "sqlalchemy.ext.mutable.MutableComposite") construct could be placed into an invalid
    state when the parent object was already loaded, and then covered by a subsequent
    query, due to the composite properties’ refresh handler replacing the object with
    a new one not handled by the mutable extension.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#6001](https://www.sqlalchemy.org/trac/ticket/6001)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: engine
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[engine] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug where the “schema_translate_map” feature failed to be taken into account
    for the use case of direct execution of [`DefaultGenerator`](../core/defaults.html#sqlalchemy.schema.DefaultGenerator
    "sqlalchemy.schema.DefaultGenerator") objects such as sequences, which included
    the case where they were “pre-executed” in order to generate primary key values
    when implicit_returning was disabled.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5929](https://www.sqlalchemy.org/trac/ticket/5929)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: schema
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[schema] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug first introduced in as some combination of [#2892](https://www.sqlalchemy.org/trac/ticket/2892),
    [#2919](https://www.sqlalchemy.org/trac/ticket/2919) nnd [#3832](https://www.sqlalchemy.org/trac/ticket/3832)
    where the attachment events for a [`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") would be doubled up against the “impl” class,
    if the “impl” were also a [`SchemaType`](../core/type_basics.html#sqlalchemy.types.SchemaType
    "sqlalchemy.types.SchemaType"). The real-world case is any [`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") against [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum") or [`Boolean`](../core/type_basics.html#sqlalchemy.types.Boolean
    "sqlalchemy.types.Boolean") would get a doubled [`CheckConstraint`](../core/constraints.html#sqlalchemy.schema.CheckConstraint
    "sqlalchemy.schema.CheckConstraint") when the `create_constraint=True` flag is
    set.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#6152](https://www.sqlalchemy.org/trac/ticket/6152)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[schema] [bug] [sqlite]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Fixed issue where the CHECK constraint generated by [`Boolean`](../core/type_basics.html#sqlalchemy.types.Boolean
    "sqlalchemy.types.Boolean") or [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum") would fail to render the naming convention correctly
    after the first compilation, due to an unintended change of state within the name
    given to the constraint. This issue was first introduced in 0.9 in the fix for
    issue #3067, and the fix revises the approach taken at that time which appears
    to have been more involved than what was needed.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#6007](https://www.sqlalchemy.org/trac/ticket/6007)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[schema] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Repaired / implemented support for primary key constraint naming conventions
    that use column names/keys/etc as part of the convention. In particular, this
    includes that the [`PrimaryKeyConstraint`](../core/constraints.html#sqlalchemy.schema.PrimaryKeyConstraint
    "sqlalchemy.schema.PrimaryKeyConstraint") object that’s automatically associated
    with a [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    will update its name as new primary key [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects are added to the table and then to the constraint.
    Internal failure modes related to this constraint construction process including
    no columns present, no name present or blank name present are now accommodated.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5919](https://www.sqlalchemy.org/trac/ticket/5919)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[schema] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adjusted the logic that emits DROP statements for [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence") objects among the dropping of multiple tables, such
    that all [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence "sqlalchemy.schema.Sequence")
    objects are dropped after all tables, even if the given [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence") is related only to a [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") object and not directly to the overall [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") object. The use case supports the same [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence") being associated with more than one [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") at a time.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#6071](https://www.sqlalchemy.org/trac/ticket/6071)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: postgresql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[postgresql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue where using [`aggregate_order_by`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.aggregate_order_by
    "sqlalchemy.dialects.postgresql.aggregate_order_by") would return ARRAY(NullType)
    under certain conditions, interfering with the ability of the result object to
    return data correctly.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5989](https://www.sqlalchemy.org/trac/ticket/5989)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[postgresql] [bug] [reflection]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue in PostgreSQL reflection where a column expressing “NOT NULL” will
    supersede the nullability of a corresponding domain.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#6161](https://www.sqlalchemy.org/trac/ticket/6161)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[postgresql] [bug] [types]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adjusted the psycopg2 dialect to emit an explicit PostgreSQL-style cast for
    bound parameters that contain ARRAY elements. This allows the full range of datatypes
    to function correctly within arrays. The asyncpg dialect already generated these
    internal casts in the final statement. This also includes support for array slice
    updates as well as the PostgreSQL-specific `ARRAY.contains()` method.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#6023](https://www.sqlalchemy.org/trac/ticket/6023)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: mssql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[mssql] [bug] [reflection]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue regarding SQL Server reflection for older SQL Server 2005 version,
    a call to sp_columns would not proceed correctly without being prefixed with the
    EXEC keyword. This method is not used in current 1.4 series.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5921](https://www.sqlalchemy.org/trac/ticket/5921)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 1.3.23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Released: February 1, 2021'
  prefs: []
  type: TYPE_NORMAL
- en: sql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[sql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug where making use of the [`TypeEngine.with_variant()`](../core/type_api.html#sqlalchemy.types.TypeEngine.with_variant
    "sqlalchemy.types.TypeEngine.with_variant") method on a [`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") type would fail to take into account the dialect-specific
    mappings in use, due to a rule in [`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") that was instead attempting to check for chains
    of [`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") instances.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5816](https://www.sqlalchemy.org/trac/ticket/5816)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: postgresql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[postgresql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For SQLAlchemy 1.3 only, setup.py pins pg8000 to a version lower than 1.16.6\.
    Version 1.16.6 and above is supported by SQLAlchemy 1.4\. Pull request courtesy
    Giuseppe Lumia.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5645](https://www.sqlalchemy.org/trac/ticket/5645)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[postgresql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue where using [`Table.to_metadata()`](../core/metadata.html#sqlalchemy.schema.Table.to_metadata
    "sqlalchemy.schema.Table.to_metadata") (called [`Table.tometadata()`](../core/metadata.html#sqlalchemy.schema.Table.tometadata
    "sqlalchemy.schema.Table.tometadata") in 1.3) in conjunction with a PostgreSQL
    [`ExcludeConstraint`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ExcludeConstraint
    "sqlalchemy.dialects.postgresql.ExcludeConstraint") that made use of ad-hoc column
    expressions would fail to copy correctly.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5850](https://www.sqlalchemy.org/trac/ticket/5850)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: mysql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[mysql] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Casting to `FLOAT` is now supported in MySQL >= (8, 0, 17) and MariaDb >= (10,
    4, 5).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5808](https://www.sqlalchemy.org/trac/ticket/5808)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[mysql] [bug] [reflection]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug where MySQL server default reflection would fail for numeric values
    with a negation symbol present.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5860](https://www.sqlalchemy.org/trac/ticket/5860)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[mysql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed long-lived bug in MySQL dialect where the maximum identifier length of
    255 was too long for names of all types of constraints, not just indexes, all
    of which have a size limit of 64\. As metadata naming conventions can create too-long
    names in this area, apply the limit to the identifier generator within the DDL
    compiler.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5898](https://www.sqlalchemy.org/trac/ticket/5898)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[mysql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed deprecation warnings that arose as a result of the release of PyMySQL
    1.0, including deprecation warnings for the “db” and “passwd” parameters now replaced
    with “database” and “password”.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5821](https://www.sqlalchemy.org/trac/ticket/5821)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[mysql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed regression from SQLAlchemy 1.3.20 caused by the fix for [#5462](https://www.sqlalchemy.org/trac/ticket/5462)
    which adds double-parenthesis for MySQL functional expressions in indexes, as
    is required by the backend, this inadvertently extended to include arbitrary [`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text
    "sqlalchemy.sql.expression.text") expressions as well as Alembic’s internal textual
    component, which are required by Alembic for arbitrary index expressions which
    don’t imply double parenthesis. The check has been narrowed to include only binary/
    unary/functional expressions directly.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5800](https://www.sqlalchemy.org/trac/ticket/5800)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: oracle
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[oracle] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed regression in Oracle dialect introduced by [#4894](https://www.sqlalchemy.org/trac/ticket/4894)
    in SQLAlchemy 1.3.11 where use of a SQL expression in RETURNING for an UPDATE
    would fail to compile, due to a check for “server_default” when an arbitrary SQL
    expression is not a column.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5813](https://www.sqlalchemy.org/trac/ticket/5813)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[oracle] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug in Oracle dialect where retrieving a CLOB/BLOB column via [`Insert.returning()`](../core/dml.html#sqlalchemy.sql.expression.Insert.returning
    "sqlalchemy.sql.expression.Insert.returning") would fail as the LOB value would
    need to be read when returned; additionally, repaired support for retrieval of
    Unicode values via RETURNING under Python 2.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5812](https://www.sqlalchemy.org/trac/ticket/5812)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: misc
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[bug] [ext]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue where the stringification that is sometimes called when attempting
    to generate the “key” for the `.c` collection on a selectable would fail if the
    column were an unlabeled custom SQL construct using the `sqlalchemy.ext.compiler`
    extension, and did not provide a default compilation form; while this seems like
    an unusual case, it can get invoked for some ORM scenarios such as when the expression
    is used in an “order by” in combination with joined eager loading. The issue is
    that the lack of a default compiler function was raising [`CompileError`](../core/exceptions.html#sqlalchemy.exc.CompileError
    "sqlalchemy.exc.CompileError") and not [`UnsupportedCompilationError`](../core/exceptions.html#sqlalchemy.exc.UnsupportedCompilationError
    "sqlalchemy.exc.UnsupportedCompilationError").
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5836](https://www.sqlalchemy.org/trac/ticket/5836)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 1.3.22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Released: December 18, 2020'
  prefs: []
  type: TYPE_NORMAL
- en: oracle
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[oracle] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed regression which occurred due to [#5755](https://www.sqlalchemy.org/trac/ticket/5755)
    which implemented isolation level support for Oracle. It has been reported that
    many Oracle accounts don’t actually have permission to query the `v$transaction`
    view so this feature has been altered to gracefully fallback when it fails upon
    database connect, where the dialect will assume “READ COMMITTED” is the default
    isolation level as was the case prior to SQLAlchemy 1.3.21. However, explicit
    use of the [`Connection.get_isolation_level()`](../core/connections.html#sqlalchemy.engine.Connection.get_isolation_level
    "sqlalchemy.engine.Connection.get_isolation_level") method must now necessarily
    raise an exception, as Oracle databases with this restriction explicitly disallow
    the user from reading the current isolation level.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5784](https://www.sqlalchemy.org/trac/ticket/5784)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 1.3.21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Released: December 17, 2020'
  prefs: []
  type: TYPE_NORMAL
- en: orm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added a comprehensive check and an informative error message for the case where
    a mapped class, or a string mapped class name, is passed to [`relationship.secondary`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.secondary
    "sqlalchemy.orm.relationship"). This is an extremely common error which warrants
    a clear message.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Additionally, added a new rule to the class registry resolution such that with
    regards to the [`relationship.secondary`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.secondary
    "sqlalchemy.orm.relationship") parameter, if a mapped class and its table are
    of the identical string name, the [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") will be favored when resolving this parameter. In all
    other cases, the class continues to be favored if a class and table share the
    identical name.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5774](https://www.sqlalchemy.org/trac/ticket/5774)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug in [`Query.update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.update
    "sqlalchemy.orm.Query.update") where objects in the `_ormsession.Session` that
    were already expired would be unnecessarily SELECTed individually when they were
    refreshed by the “evaluate”synchronize strategy.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5664](https://www.sqlalchemy.org/trac/ticket/5664)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug involving the `restore_load_context` option of ORM events such as
    [`InstanceEvents.load()`](../orm/events.html#sqlalchemy.orm.InstanceEvents.load
    "sqlalchemy.orm.InstanceEvents.load") such that the flag would not be carried
    along to subclasses which were mapped after the event handler were first established.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5737](https://www.sqlalchemy.org/trac/ticket/5737)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[sql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A warning is emitted if a returning() method such as [`Insert.returning()`](../core/dml.html#sqlalchemy.sql.expression.Insert.returning
    "sqlalchemy.sql.expression.Insert.returning") is called multiple times, as this
    does not yet support additive operation. Version 1.4 will support additive operation
    for this. Additionally, any combination of the [`Insert.returning()`](../core/dml.html#sqlalchemy.sql.expression.Insert.returning
    "sqlalchemy.sql.expression.Insert.returning") and `ValuesBase.return_defaults()`
    methods now raises an error as these methods are mutually exclusive; previously
    the operation would fail silently.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5691](https://www.sqlalchemy.org/trac/ticket/5691)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[sql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed structural compiler issue where some constructs such as MySQL / PostgreSQL
    “on conflict / on duplicate key” would rely upon the state of the `Compiler` object
    being fixed against their statement as the top level statement, which would fail
    in cases where those statements are branched from a different context, such as
    a DDL construct linked to a SQL statement.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5656](https://www.sqlalchemy.org/trac/ticket/5656)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: postgresql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[postgresql] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added new parameter [`ExcludeConstraint.ops`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ExcludeConstraint.params.ops
    "sqlalchemy.dialects.postgresql.ExcludeConstraint") to the [`ExcludeConstraint`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ExcludeConstraint
    "sqlalchemy.dialects.postgresql.ExcludeConstraint") object, to support operator
    class specification with this constraint. Pull request courtesy Alon Menczer.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5604](https://www.sqlalchemy.org/trac/ticket/5604)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[postgresql] [bug] [mysql]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed regression introduced in 1.3.2 for the PostgreSQL dialect, also copied
    out to the MySQL dialect’s feature in 1.3.18, where usage of a non [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") construct such as [`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text
    "sqlalchemy.sql.expression.text") as the argument to [`Select.with_for_update.of`](../core/selectable.html#sqlalchemy.sql.expression.Select.with_for_update.params.of
    "sqlalchemy.sql.expression.Select.with_for_update") would fail to be accommodated
    correctly within the PostgreSQL or MySQL compilers.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5729](https://www.sqlalchemy.org/trac/ticket/5729)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: mysql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[mysql] [bug] [reflection]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue where reflecting a server default on MariaDB only that contained
    a decimal point in the value would fail to be reflected correctly, leading towards
    a reflected table that lacked any server default.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5744](https://www.sqlalchemy.org/trac/ticket/5744)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[mysql] [sql]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Added missing keywords to the `RESERVED_WORDS` list for the MySQL dialect:
    `action`, `level`, `mode`, `status`, `text`, `time`. Pull request courtesy Oscar
    Batori.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5696](https://www.sqlalchemy.org/trac/ticket/5696)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sqlite
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[sqlite] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added `sqlite_with_rowid=False` dialect keyword to enable creating tables as
    `CREATE TABLE … WITHOUT ROWID`. Patch courtesy Sean Anderson.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5685](https://www.sqlalchemy.org/trac/ticket/5685)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: mssql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[mssql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug where a CREATE INDEX statement was rendered incorrectly when both
    `mssql-include` and `mssql_where` were specified. Pull request courtesy @Adiorz.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5751](https://www.sqlalchemy.org/trac/ticket/5751)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[mssql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added SQL Server code “01000” to the list of disconnect codes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5646](https://www.sqlalchemy.org/trac/ticket/5646)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[mssql] [reflection] [sqlite]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue with composite primary key columns not being reported in the correct
    order. Patch courtesy @fulpm.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5661](https://www.sqlalchemy.org/trac/ticket/5661)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: oracle
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[oracle] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implemented support for the SERIALIZABLE isolation level for Oracle databases,
    as well as a real implementation for [`Connection.get_isolation_level()`](../core/connections.html#sqlalchemy.engine.Connection.get_isolation_level
    "sqlalchemy.engine.Connection.get_isolation_level").
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Transaction Isolation Level / Autocommit](../dialects/oracle.html#oracle-isolation-level)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5755](https://www.sqlalchemy.org/trac/ticket/5755)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 1.3.20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Released: October 12, 2020'
  prefs: []
  type: TYPE_NORMAL
- en: orm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An [`ArgumentError`](../core/exceptions.html#sqlalchemy.exc.ArgumentError "sqlalchemy.exc.ArgumentError")
    with more detail is now raised if the target parameter for [`Query.join()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join") is set to an unmapped object. Prior to this change
    a less detailed `AttributeError` was raised. Pull request courtesy Ramon Williams.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4428](https://www.sqlalchemy.org/trac/ticket/4428)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue where using a loader option against a string attribute name that
    is not actually a mapped attribute, such as a plain Python descriptor, would raise
    an uninformative AttributeError; a descriptive error is now raised.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4589](https://www.sqlalchemy.org/trac/ticket/4589)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: engine
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[engine] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue where a non-string object sent to [`SQLAlchemyError`](../core/exceptions.html#sqlalchemy.exc.SQLAlchemyError
    "sqlalchemy.exc.SQLAlchemyError") or a subclass, as occurs with some third party
    dialects, would fail to stringify correctly. Pull request courtesy Andrzej Bartosiński.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5599](https://www.sqlalchemy.org/trac/ticket/5599)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[engine] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Repaired a function-level import that was not using SQLAlchemy’s standard late-import
    system within the sqlalchemy.exc module.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5632](https://www.sqlalchemy.org/trac/ticket/5632)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[sql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue where the `pickle.dumps()` operation against [`Over`](../core/sqlelement.html#sqlalchemy.sql.expression.Over
    "sqlalchemy.sql.expression.Over") construct would produce a recursion overflow.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5644](https://www.sqlalchemy.org/trac/ticket/5644)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[sql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug where an error was not raised in the case where a [`column()`](../core/sqlelement.html#sqlalchemy.sql.expression.column
    "sqlalchemy.sql.expression.column") were added to more than one [`table()`](../core/selectable.html#sqlalchemy.sql.expression.table
    "sqlalchemy.sql.expression.table") at a time. This raised correctly for the [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") and [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects. An [`ArgumentError`](../core/exceptions.html#sqlalchemy.exc.ArgumentError
    "sqlalchemy.exc.ArgumentError") is now raised when this occurs.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5618](https://www.sqlalchemy.org/trac/ticket/5618)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: postgresql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[postgresql] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The psycopg2 dialect now support PostgreSQL multiple host connections, by passing
    host/port combinations to the query string. Pull request courtesy Ramon Williams.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Specifying multiple fallback hosts](../dialects/postgresql.html#psycopg2-multi-host)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4392](https://www.sqlalchemy.org/trac/ticket/4392)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[postgresql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adjusted the [`Comparator.any()`](../core/type_basics.html#sqlalchemy.types.ARRAY.Comparator.any
    "sqlalchemy.types.ARRAY.Comparator.any") and [`Comparator.all()`](../core/type_basics.html#sqlalchemy.types.ARRAY.Comparator.all
    "sqlalchemy.types.ARRAY.Comparator.all") methods to implement a straight “NOT”
    operation for negation, rather than negating the comparison operator.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5518](https://www.sqlalchemy.org/trac/ticket/5518)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[postgresql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue where the [`ENUM`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ENUM
    "sqlalchemy.dialects.postgresql.ENUM") type would not consult the schema translate
    map when emitting a CREATE TYPE or DROP TYPE during the test to see if the type
    exists or not. Additionally, repaired an issue where if the same enum were encountered
    multiple times in a single DDL sequence, the “check” query would run repeatedly
    rather than relying upon a cached value.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5520](https://www.sqlalchemy.org/trac/ticket/5520)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: mysql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[mysql] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adjusted the MySQL dialect to correctly parenthesize functional index expressions
    as accepted by MySQL 8\. Pull request courtesy Ramon Williams.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5462](https://www.sqlalchemy.org/trac/ticket/5462)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[mysql] [change]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Add new MySQL reserved words: `cube`, `lateral` added in MySQL 8.0.1 and 8.0.14,
    respectively; this indicates that these terms will be quoted if used as table
    or column identifier names.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5539](https://www.sqlalchemy.org/trac/ticket/5539)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[mysql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The “skip_locked” keyword used with `with_for_update()` will emit a warning
    when used on MariaDB backends, and will then be ignored. This is a deprecated
    behavior that will raise in SQLAlchemy 1.4, as an application that requests “skip
    locked” is looking for a non-blocking operation which is not available on those
    backends.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5568](https://www.sqlalchemy.org/trac/ticket/5568)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[mysql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug where an UPDATE statement against a JOIN using MySQL multi-table format
    would fail to include the table prefix for the target table if the statement had
    no WHERE clause, as only the WHERE clause were scanned to detect a “multi table
    update” at that particular point. The target is now also scanned if it’s a JOIN
    to get the leftmost table as the primary table and the additional entries as additional
    FROM entries.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5617](https://www.sqlalchemy.org/trac/ticket/5617)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: mssql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[mssql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue where a SQLAlchemy connection URI for Azure DW with `authentication=ActiveDirectoryIntegrated`
    (and no username+password) was not constructing the ODBC connection string in
    a way that was acceptable to the Azure DW instance.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5592](https://www.sqlalchemy.org/trac/ticket/5592)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: tests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[tests] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed incompatibilities in the test suite when running against Pytest 6.x.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5635](https://www.sqlalchemy.org/trac/ticket/5635)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: misc
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[bug] [pool]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Fixed issue where the following pool parameters were not being propagated to
    the new pool created when [`Engine.dispose()`](../core/connections.html#sqlalchemy.engine.Engine.dispose
    "sqlalchemy.engine.Engine.dispose") were called: `pre_ping`, `use_lifo`. Additionally
    the `recycle` and `reset_on_return` parameter is now propagated for the `AssertionPool`
    class.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5582](https://www.sqlalchemy.org/trac/ticket/5582)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[bug] [associationproxy] [ext]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An informative error is now raised when attempting to use an association proxy
    element as a plain column expression to be SELECTed from or used in a SQL function;
    this use case is not currently supported.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5541](https://www.sqlalchemy.org/trac/ticket/5541), [#5542](https://www.sqlalchemy.org/trac/ticket/5542)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 1.3.19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Released: August 17, 2020'
  prefs: []
  type: TYPE_NORMAL
- en: orm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[orm] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adjusted the workings of the [`Mapper.all_orm_descriptors()`](../orm/mapping_api.html#sqlalchemy.orm.Mapper.all_orm_descriptors
    "sqlalchemy.orm.Mapper.all_orm_descriptors") accessor to represent the attributes
    in the order that they are located in a deterministic way, assuming the use of
    Python 3.6 or higher which maintains the sorting order of class attributes based
    on how they were declared. This sorting is not guaranteed to match the declared
    order of attributes in all cases however; see the method documentation for the
    exact scheme.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5494](https://www.sqlalchemy.org/trac/ticket/5494)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: orm declarative
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[orm] [declarative] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The name of the virtual column used when using the [`AbstractConcreteBase`](../orm/extensions/declarative/index.html#sqlalchemy.ext.declarative.AbstractConcreteBase
    "sqlalchemy.ext.declarative.AbstractConcreteBase") and [`ConcreteBase`](../orm/extensions/declarative/index.html#sqlalchemy.ext.declarative.ConcreteBase
    "sqlalchemy.ext.declarative.ConcreteBase") classes can now be customized, to allow
    for models that have a column that is actually named `type`. Pull request courtesy
    Jesse-Bakker.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5513](https://www.sqlalchemy.org/trac/ticket/5513)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[sql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Repaired an issue where the “ORDER BY” clause rendering a label name rather
    than a complete expression, which is particularly important for SQL Server, would
    fail to occur if the expression were enclosed in a parenthesized grouping in some
    cases. This case has been added to test support. The change additionally adjusts
    the “automatically add ORDER BY columns when DISTINCT is present” behavior of
    ORM query, deprecated in 1.4, to more accurately detect column expressions that
    are already present.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5470](https://www.sqlalchemy.org/trac/ticket/5470)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[sql] [bug] [datatypes]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `LookupError` message will now provide the user with up to four possible
    values that a column is constrained to via the [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum"). Values longer than 11 characters will be truncated and
    replaced with ellipses. Pull request courtesy Ramon Williams.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4733](https://www.sqlalchemy.org/trac/ticket/4733)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[sql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue where the [`Connection.execution_options.schema_translate_map`](../core/connections.html#sqlalchemy.engine.Connection.execution_options.params.schema_translate_map
    "sqlalchemy.engine.Connection.execution_options") feature would not take effect
    when the [`Sequence.next_value()`](../core/defaults.html#sqlalchemy.schema.Sequence.next_value
    "sqlalchemy.schema.Sequence.next_value") function function for a [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence") were used in the [`Column.server_default`](../core/metadata.html#sqlalchemy.schema.Column.params.server_default
    "sqlalchemy.schema.Column") parameter and the create table DDL were emitted.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5500](https://www.sqlalchemy.org/trac/ticket/5500)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: postgresql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[postgresql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue where the return type for the various RANGE comparison operators
    would itself be the same RANGE type rather than BOOLEAN, which would cause an
    undesirable result in the case that a [`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") that defined result-processing behavior were
    in use. Pull request courtesy Jim Bosch.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5476](https://www.sqlalchemy.org/trac/ticket/5476)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: mysql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[mysql] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The MySQL dialect will render FROM DUAL for a SELECT statement that has no FROM
    clause but has a WHERE clause. This allows things like “SELECT 1 WHERE EXISTS
    (subquery)” kinds of queries to be used as well as other use cases.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5481](https://www.sqlalchemy.org/trac/ticket/5481)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[mysql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed an issue where CREATE TABLE statements were not specifying the COLLATE
    keyword correctly.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5411](https://www.sqlalchemy.org/trac/ticket/5411)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[mysql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added MariaDB code 1927 to the list of “disconnect” codes, as recent MariaDB
    versions apparently use this code when the database server was stopped.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5493](https://www.sqlalchemy.org/trac/ticket/5493)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sqlite
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[sqlite] [bug] [mssql] [reflection]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applied a sweep through all included dialects to ensure names that contain single
    or double quotes are properly escaped when querying system tables, for all [`Inspector`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector
    "sqlalchemy.engine.reflection.Inspector") methods that accept object names as
    an argument (e.g. table names, view names, etc). SQLite and MSSQL contained two
    quoting issues that were repaired.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5456](https://www.sqlalchemy.org/trac/ticket/5456)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: mssql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[mssql] [bug] [sql]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug where the mssql dialect incorrectly escaped object names that contained
    ‘]’ character(s).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5467](https://www.sqlalchemy.org/trac/ticket/5467)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: misc
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[usecase] [py3k]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added a `**kw` argument to the `DeclarativeMeta.__init__()` method. This allows
    a class to support the [**PEP 487**](https://peps.python.org/pep-0487/) metaclass
    hook `__init_subclass__`. Pull request courtesy Ewen Gillies.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [##5357](https://www.sqlalchemy.org/trac/ticket/#5357)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 1.3.18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Released: June 25, 2020'
  prefs: []
  type: TYPE_NORMAL
- en: orm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[orm] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improve error message when using [`Query.filter_by()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.filter_by
    "sqlalchemy.orm.Query.filter_by") in a query where the first entity is not a mapped
    class.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5326](https://www.sqlalchemy.org/trac/ticket/5326)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added a new parameter [`query_expression.default_expr`](../orm/queryguide/columns.html#sqlalchemy.orm.query_expression.params.default_expr
    "sqlalchemy.orm.query_expression") to the [`query_expression()`](../orm/queryguide/columns.html#sqlalchemy.orm.query_expression
    "sqlalchemy.orm.query_expression") construct, which will be appled to queries
    automatically if the [`with_expression()`](../orm/queryguide/columns.html#sqlalchemy.orm.with_expression
    "sqlalchemy.orm.with_expression") option is not used. Pull request courtesy Haoyu
    Sun.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5198](https://www.sqlalchemy.org/trac/ticket/5198)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: examples
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[examples] [change]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added new option `--raw` to the examples.performance suite which will dump the
    raw profile test for consumption by any number of profiling visualizer tools.
    Removed the “runsnake” option as runsnake is very hard to build at this point;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: engine
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[engine] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further refinements to the fixes to the “reset” agent fixed in [#5326](https://www.sqlalchemy.org/trac/ticket/5326),
    which now emits a warning when it is not being correctly invoked and corrects
    for the behavior. Additional scenarios have been identified and fixed where this
    warning was being emitted.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5326](https://www.sqlalchemy.org/trac/ticket/5326)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[engine] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue in [`URL`](../core/engines.html#sqlalchemy.engine.URL "sqlalchemy.engine.URL")
    object where stringifying the object would not URL encode special characters,
    preventing the URL from being re-consumable as a real URL. Pull request courtesy
    Miguel Grinberg.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5341](https://www.sqlalchemy.org/trac/ticket/5341)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[sql] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added a “.schema” parameter to the [`table()`](../core/selectable.html#sqlalchemy.sql.expression.table
    "sqlalchemy.sql.expression.table") construct, allowing ad-hoc table expressions
    to also include a schema name. Pull request courtesy Dylan Modesitt.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5309](https://www.sqlalchemy.org/trac/ticket/5309)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[sql] [change] [sybase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added `.offset` support to sybase dialect. Pull request courtesy Alan D. Snow.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5294](https://www.sqlalchemy.org/trac/ticket/5294)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[sql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Correctly apply self_group in type_coerce element.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The type coerce element did not correctly apply grouping rules when using in
    an expression
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5344](https://www.sqlalchemy.org/trac/ticket/5344)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[sql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added [`Select.with_hint()`](../core/selectable.html#sqlalchemy.sql.expression.Select.with_hint
    "sqlalchemy.sql.expression.Select.with_hint") output to the generic SQL string
    that is produced when calling `str()` on a statement. Previously, this clause
    would be omitted under the assumption that it was dialect specific. The hint text
    is presented within brackets to indicate the rendering of such hints varies among
    backends.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5353](https://www.sqlalchemy.org/trac/ticket/5353)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[sql] [schema]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduce `IdentityOptions` to store common parameters for sequences and identity
    columns.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5324](https://www.sqlalchemy.org/trac/ticket/5324)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: schema
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[schema] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue where `dialect_options` were omitted when a database object (e.g.,
    [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table"))
    was copied using `tometadata()`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5276](https://www.sqlalchemy.org/trac/ticket/5276)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: mysql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[mysql] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implemented row-level locking support for mysql. Pull request courtesy Quentin
    Somerville.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4860](https://www.sqlalchemy.org/trac/ticket/4860)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sqlite
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[sqlite] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SQLite 3.31 added support for computed column. This change enables their support
    in SQLAlchemy when targeting SQLite.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5297](https://www.sqlalchemy.org/trac/ticket/5297)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[sqlite] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added “exists” to the list of reserved words for SQLite so that this word will
    be quoted when used as a label or column name. Pull request courtesy Thodoris
    Sotiropoulos.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5395](https://www.sqlalchemy.org/trac/ticket/5395)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: mssql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[mssql] [change]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moved the `supports_sane_rowcount_returning = False` requirement from the `PyODBCConnector`
    level to the `MSDialect_pyodbc` since pyodbc does work properly in some circumstances.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5321](https://www.sqlalchemy.org/trac/ticket/5321)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[mssql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refined the logic used by the SQL Server dialect to interpret multi-part schema
    names that contain many dots, to not actually lose any dots if the name does not
    have bracking or quoting used, and additionally to support a “dbname” token that
    has many parts including that it may have multiple, independently-bracketed sections.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5364](https://www.sqlalchemy.org/trac/ticket/5364), [#5366](https://www.sqlalchemy.org/trac/ticket/5366)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[mssql] [bug] [pyodbc]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed an issue in the pyodbc connector such that a warning about pyodbc “drivername”
    would be emitted when using a totally empty URL. Empty URLs are normal when producing
    a non-connected dialect object or when using the “creator” argument to create_engine().
    The warning now only emits if the driver name is missing but other parameters
    are still present.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5346](https://www.sqlalchemy.org/trac/ticket/5346)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[mssql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue with assembling the ODBC connection string for the pyodbc DBAPI.
    Tokens containing semicolons and/or braces “{}” were not being correctly escaped,
    causing the ODBC driver to misinterpret the connection string attributes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5373](https://www.sqlalchemy.org/trac/ticket/5373)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[mssql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue where `datetime.time` parameters were being converted to `datetime.datetime`,
    making them incompatible with comparisons like `>=` against an actual [`TIME`](../dialects/mssql.html#sqlalchemy.dialects.mssql.TIME
    "sqlalchemy.dialects.mssql.TIME") column.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5339](https://www.sqlalchemy.org/trac/ticket/5339)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[mssql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed an issue where the `is_disconnect` function in the SQL Server pyodbc dialect
    was incorrectly reporting the disconnect state when the exception message had
    a substring that matched a SQL Server ODBC error code.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5359](https://www.sqlalchemy.org/trac/ticket/5359)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: oracle
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[oracle] [bug] [reflection]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug in Oracle dialect where indexes that contain the full set of primary
    key columns would be mistaken as the primary key index itself, which is omitted,
    even if there were multiples. The check has been refined to compare the name of
    the primary key constraint against the index name itself, rather than trying to
    guess based on the columns present in the index.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5421](https://www.sqlalchemy.org/trac/ticket/5421)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 1.3.17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Released: May 13, 2020'
  prefs: []
  type: TYPE_NORMAL
- en: orm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[orm] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added an accessor [`Comparator.expressions`](../orm/internals.html#sqlalchemy.orm.ColumnProperty.Comparator.expressions
    "sqlalchemy.orm.ColumnProperty.Comparator.expressions") which provides access
    to the group of columns mapped under a multi-column [`ColumnProperty`](../orm/internals.html#sqlalchemy.orm.ColumnProperty
    "sqlalchemy.orm.ColumnProperty") attribute.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5262](https://www.sqlalchemy.org/trac/ticket/5262)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduce [`relationship.sync_backref`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.sync_backref
    "sqlalchemy.orm.relationship") flag in a relationship to control if the synchronization
    events that mutate the in-Python attributes are added. This supersedes the previous
    change [#5149](https://www.sqlalchemy.org/trac/ticket/5149), which warned that
    `viewonly=True` relationship target of a back_populates or backref configuration
    would be disallowed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5237](https://www.sqlalchemy.org/trac/ticket/5237)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug where using [`with_polymorphic()`](../orm/queryguide/inheritance.html#sqlalchemy.orm.with_polymorphic
    "sqlalchemy.orm.with_polymorphic") as the target of a join via `RelationshipComparator.of_type()`
    on a mapper that already has a subquery-based with_polymorphic setting that’s
    equivalent to the one requested would not correctly alias the ON clause in the
    join.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5288](https://www.sqlalchemy.org/trac/ticket/5288)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue in the area of where loader options such as selectinload() interact
    with the baked query system, such that the caching of a query is not supposed
    to occur if the loader options themselves have elements such as with_polymorphic()
    objects in them that currently are not cache-compatible. The baked loader could
    sometimes not fully invalidate itself in these some of these scenarios leading
    to missed eager loads.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5303](https://www.sqlalchemy.org/trac/ticket/5303)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modified the internal “identity set” implementation, which is a set that hashes
    objects on their id() rather than their hash values, to not actually call the
    `__hash__()` method of the objects, which are typically user-mapped objects. Some
    methods were calling this method as a side effect of the implementation.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5304](https://www.sqlalchemy.org/trac/ticket/5304)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An informative error message is raised when an ORM many-to-one comparison is
    attempted against an object that is not an actual mapped instance. Comparisons
    such as those to scalar subqueries aren’t supported; generalized comparison with
    subqueries is better achieved using [`Comparator.has()`](../orm/internals.html#sqlalchemy.orm.RelationshipProperty.Comparator.has
    "sqlalchemy.orm.RelationshipProperty.Comparator.has").
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5269](https://www.sqlalchemy.org/trac/ticket/5269)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: engine
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[engine] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed fairly critical issue where the DBAPI connection could be returned to
    the connection pool while still in an un-rolled-back state. The reset agent responsible
    for rolling back the connection could be corrupted in the case that the transaction
    was “closed” without being rolled back or committed, which can occur in some scenarios
    when using ORM sessions and emitting .close() in a certain pattern involving savepoints.
    The fix ensures that the reset agent is always active.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5326](https://www.sqlalchemy.org/trac/ticket/5326)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: schema
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[schema] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue where an [`Index`](../core/constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index") that is deferred in being associated with a table,
    such as as when it contains a [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") that is not associated with any [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") yet, would fail to attach correctly if it also contained
    a non table-oriented expression.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5298](https://www.sqlalchemy.org/trac/ticket/5298)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[schema] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A warning is emitted when making use of the [`MetaData.sorted_tables`](../core/metadata.html#sqlalchemy.schema.MetaData.sorted_tables
    "sqlalchemy.schema.MetaData.sorted_tables") attribute as well as the [`sort_tables()`](../core/ddl.html#sqlalchemy.schema.sort_tables
    "sqlalchemy.schema.sort_tables") function, and the given tables cannot be correctly
    sorted due to a cyclic dependency between foreign key constraints. In this case,
    the functions will no longer sort the involved tables by foreign key, and a warning
    will be emitted. Other tables that are not part of the cycle will still be returned
    in dependency order. Previously, the sorted_table routines would return a collection
    that would unconditionally omit all foreign keys when a cycle was detected, and
    no warning was emitted.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5316](https://www.sqlalchemy.org/trac/ticket/5316)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[schema]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add `comment` attribute to [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") `__repr__` method.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4138](https://www.sqlalchemy.org/trac/ticket/4138)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: postgresql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[postgresql] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added support for columns or type [`ARRAY`](../core/type_basics.html#sqlalchemy.types.ARRAY
    "sqlalchemy.types.ARRAY") of [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum"), [`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON
    "sqlalchemy.dialects.postgresql.JSON") or [`JSONB`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSONB
    "sqlalchemy.dialects.postgresql.JSONB") in PostgreSQL. Previously a workaround
    was required in these use cases.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5265](https://www.sqlalchemy.org/trac/ticket/5265)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[postgresql] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Raise an explicit [`CompileError`](../core/exceptions.html#sqlalchemy.exc.CompileError
    "sqlalchemy.exc.CompileError") when adding a table with a column of type [`ARRAY`](../core/type_basics.html#sqlalchemy.types.ARRAY
    "sqlalchemy.types.ARRAY") of [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum") configured with [`Enum.native_enum`](../core/type_basics.html#sqlalchemy.types.Enum.params.native_enum
    "sqlalchemy.types.Enum") set to `False` when [`Enum.create_constraint`](../core/type_basics.html#sqlalchemy.types.Enum.params.create_constraint
    "sqlalchemy.types.Enum") is not set to `False`
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5266](https://www.sqlalchemy.org/trac/ticket/5266)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: mssql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[mssql] [bug] [reflection]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fix a regression introduced by the reflection of computed column in MSSQL when
    using the legacy TDS version 4.2\. The dialect will try to detect the protocol
    version of first connect and run in compatibility mode if it cannot detect it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5255](https://www.sqlalchemy.org/trac/ticket/5255)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[mssql] [bug] [reflection]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fix a regression introduced by the reflection of computed column in MSSQL when
    using SQL server versions before 2012, which does not support the `concat` function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5271](https://www.sqlalchemy.org/trac/ticket/5271)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: oracle
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[oracle] [performance] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changed the implementation of fetching CLOB and BLOB objects to use cx_Oracle’s
    native implementation which fetches CLOB/BLOB objects inline with other result
    columns, rather than performing a separate fetch. As always, this can be disabled
    by setting auto_convert_lobs to False.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As part of this change, the behavior of a CLOB that was given a blank string
    on INSERT now returns None on SELECT, which is now consistent with that of VARCHAR
    on Oracle.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5314](https://www.sqlalchemy.org/trac/ticket/5314)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[oracle] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some modifications to how the cx_oracle dialect sets up per-column outputtype
    handlers for LOB and numeric datatypes to adjust for potential changes coming
    in cx_Oracle 8.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5246](https://www.sqlalchemy.org/trac/ticket/5246)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: misc
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[change] [firebird]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adjusted dialect loading for `firebird://` URIs so the external sqlalchemy-firebird
    dialect will be used if it has been installed, otherwise fall back to the (now
    deprecated) internal Firebird dialect.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5278](https://www.sqlalchemy.org/trac/ticket/5278)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 1.3.16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Released: April 7, 2020'
  prefs: []
  type: TYPE_NORMAL
- en: orm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[orm] [performance]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modified the queries used by subqueryload and selectinload to no longer ORDER
    BY the primary key of the parent entity; this ordering was there to allow the
    rows as they come in to be copied into lists directly with a minimal level of
    Python-side collation. However, these ORDER BY clauses can negatively impact the
    performance of the query as in many scenarios these columns are derived from a
    subquery or are otherwise not actual primary key columns such that SQL planners
    cannot make use of indexes. The Python-side collation uses the native itertools.group_by()
    to collate the incoming rows, and has been modified to allow multiple row-groups-per-parent
    to be assembled together using list.extend(), which should still allow for relatively
    fast Python-side performance. There will still be an ORDER BY present for a relationship
    that includes an explicit order_by parameter, however this is the only ORDER BY
    that will be added to the query for both kinds of loading.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5162](https://www.sqlalchemy.org/trac/ticket/5162)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug in [`selectinload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.selectinload
    "sqlalchemy.orm.selectinload") loading option where two or more loaders that represent
    different relationships with the same string key name as referenced from a single
    [`with_polymorphic()`](../orm/queryguide/inheritance.html#sqlalchemy.orm.with_polymorphic
    "sqlalchemy.orm.with_polymorphic") construct with multiple subclass mappers would
    fail to invoke each subqueryload separately, instead making use of a single string-based
    slot that would prevent the other loaders from being invoked.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5228](https://www.sqlalchemy.org/trac/ticket/5228)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue where a lazyload that uses session-local “get” against a target
    many-to-one relationship where an object with the correct primary key is present,
    however it’s an instance of a sibling class, does not correctly return None as
    is the case when the lazy loader actually emits a load for that row.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5210](https://www.sqlalchemy.org/trac/ticket/5210)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: orm declarative
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[orm] [declarative] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The string argument accepted as the first positional argument by the [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") function when using the Declarative API is no longer
    interpreted using the Python `eval()` function; instead, the name is dot separated
    and the names are looked up directly in the name resolution dictionary without
    treating the value as a Python expression. However, passing a string argument
    to the other [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") parameters that necessarily must accept Python
    expressions will still use `eval()`; the documentation has been clarified to ensure
    that there is no ambiguity that this is in use.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Evaluation of relationship arguments](../orm/extensions/declarative/relationships.html#declarative-relationship-eval)
    - details on string evaluation'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5238](https://www.sqlalchemy.org/trac/ticket/5238)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[sql] [types]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add ability to literal compile a `DateTime`, `Date` or `Time` when using the
    string dialect for debugging purposes. This change does not impact real dialect
    implementation that retain their current behavior.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5052](https://www.sqlalchemy.org/trac/ticket/5052)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: schema
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[schema] [reflection]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added support for reflection of “computed” columns, which are now returned as
    part of the structure returned by [`Inspector.get_columns()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_columns
    "sqlalchemy.engine.reflection.Inspector.get_columns"). When reflecting full [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects, computed columns will be represented using
    the [`Computed`](../core/defaults.html#sqlalchemy.schema.Computed "sqlalchemy.schema.Computed")
    construct.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5063](https://www.sqlalchemy.org/trac/ticket/5063)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: postgresql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[postgresql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue where a “covering” index, e.g. those which have an INCLUDE clause,
    would be reflected including all the columns in INCLUDE clause as regular columns.
    A warning is now emitted if these additional columns are detected indicating that
    they are currently ignored. Note that full support for “covering” indexes is part
    of [#4458](https://www.sqlalchemy.org/trac/ticket/4458). Pull request courtesy
    Marat Sharafutdinov.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5205](https://www.sqlalchemy.org/trac/ticket/5205)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: mysql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[mysql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue in MySQL dialect when connecting to a pseudo-MySQL database such
    as that provided by ProxySQL, the up front check for isolation level when it returns
    no row will not prevent the dialect from continuing to connect. A warning is emitted
    that the isolation level could not be detected.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5239](https://www.sqlalchemy.org/trac/ticket/5239)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sqlite
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[sqlite] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implemented AUTOCOMMIT isolation level for SQLite when using pysqlite.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5164](https://www.sqlalchemy.org/trac/ticket/5164)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: mssql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[mssql] [usecase] [mysql] [oracle]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added support for [`ColumnOperators.is_distinct_from()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.is_distinct_from
    "sqlalchemy.sql.expression.ColumnOperators.is_distinct_from") and [`ColumnOperators.isnot_distinct_from()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.isnot_distinct_from
    "sqlalchemy.sql.expression.ColumnOperators.isnot_distinct_from") to SQL Server,
    MySQL, and Oracle.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5137](https://www.sqlalchemy.org/trac/ticket/5137)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: oracle
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[oracle] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implemented AUTOCOMMIT isolation level for Oracle when using cx_Oracle. Also
    added a fixed default isolation level of READ COMMITTED for Oracle.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5200](https://www.sqlalchemy.org/trac/ticket/5200)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[oracle] [bug] [reflection]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed regression / incorrect fix caused by fix for [#5146](https://www.sqlalchemy.org/trac/ticket/5146)
    where the Oracle dialect reads from the “all_tab_comments” view to get table comments
    but fails to accommodate for the current owner of the table being requested, causing
    it to read the wrong comment if multiple tables of the same name exist in multiple
    schemas.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5146](https://www.sqlalchemy.org/trac/ticket/5146)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: tests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[tests] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed an issue that prevented the test suite from running with the recently
    released py.test 5.4.0.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5201](https://www.sqlalchemy.org/trac/ticket/5201)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: misc
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[enum] [types]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.types.Enum")
    type now supports the parameter [`Enum.length`](../core/type_basics.html#sqlalchemy.types.Enum.params.length
    "sqlalchemy.types.Enum") to specify the length of the VARCHAR column to create
    when using non native enums by setting [`Enum.native_enum`](../core/type_basics.html#sqlalchemy.types.Enum.params.native_enum
    "sqlalchemy.types.Enum") to `False`
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5183](https://www.sqlalchemy.org/trac/ticket/5183)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[installer]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensured that the “pyproject.toml” file is not included in builds, as the presence
    of this file indicates to pip that a pep-517 installation process should be used.
    As this mode of operation appears to be not well supported by current tools /
    distros, these problems are avoided within the scope of SQLAlchemy installation
    by omitting the file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5207](https://www.sqlalchemy.org/trac/ticket/5207)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 1.3.15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Released: March 11, 2020'
  prefs: []
  type: TYPE_NORMAL
- en: orm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adjusted the error message emitted by [`Query.join()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join") when a left hand side can’t be located that the [`Query.select_from()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.select_from
    "sqlalchemy.orm.Query.select_from") method is the best way to resolve the issue.
    Also, within the 1.3 series, used a deterministic ordering when determining the
    FROM clause from a given column entity passed to [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") so that the same expression is determined each time.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5194](https://www.sqlalchemy.org/trac/ticket/5194)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed regression in 1.3.14 due to [#4849](https://www.sqlalchemy.org/trac/ticket/4849)
    where a sys.exc_info() call failed to be invoked correctly when a flush error
    would occur. Test coverage has been added for this exception case.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5196](https://www.sqlalchemy.org/trac/ticket/5196)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 1.3.14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Released: March 10, 2020'
  prefs: []
  type: TYPE_NORMAL
- en: general
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[general] [bug] [py3k]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applied an explicit “cause” to most if not all internally raised exceptions
    that are raised from within an internal exception catch, to avoid misleading stacktraces
    that suggest an error within the handling of an exception. While it would be preferable
    to suppress the internally caught exception in the way that the `__suppress_context__`
    attribute would, there does not as yet seem to be a way to do this without suppressing
    an enclosing user constructed context, so for now it exposes the internally caught
    exception as the cause so that full information about the context of the error
    is maintained.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4849](https://www.sqlalchemy.org/trac/ticket/4849)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: orm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[orm] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added a new flag [`InstanceEvents.restore_load_context`](../orm/events.html#sqlalchemy.orm.InstanceEvents.params.restore_load_context
    "sqlalchemy.orm.InstanceEvents") and [`SessionEvents.restore_load_context`](../orm/events.html#sqlalchemy.orm.SessionEvents.params.restore_load_context
    "sqlalchemy.orm.SessionEvents") which apply to the [`InstanceEvents.load()`](../orm/events.html#sqlalchemy.orm.InstanceEvents.load
    "sqlalchemy.orm.InstanceEvents.load"), [`InstanceEvents.refresh()`](../orm/events.html#sqlalchemy.orm.InstanceEvents.refresh
    "sqlalchemy.orm.InstanceEvents.refresh"), and [`SessionEvents.loaded_as_persistent()`](../orm/events.html#sqlalchemy.orm.SessionEvents.loaded_as_persistent
    "sqlalchemy.orm.SessionEvents.loaded_as_persistent") events, which when set will
    restore the “load context” of the object after the event hook has been called.
    This ensures that the object remains within the “loader context” of the load operation
    that is already ongoing, rather than the object being transferred to a new load
    context due to refresh operations which may have occurred in the event. A warning
    is now emitted when this condition occurs, which recommends use of the flag to
    resolve this case. The flag is “opt-in” so that there is no risk introduced to
    existing applications.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The change additionally adds support for the `raw=True` flag to session lifecycle
    events.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5129](https://www.sqlalchemy.org/trac/ticket/5129)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed regression caused in 1.3.13 by [#5056](https://www.sqlalchemy.org/trac/ticket/5056)
    where a refactor of the ORM path registry system made it such that a path could
    no longer be compared to an empty tuple, which can occur in a particular kind
    of joined eager loading path. The “empty tuple” use case has been resolved so
    that the path registry is compared to a path registry in all cases; the `PathRegistry`
    object itself now implements `__eq__()` and `__ne__()` methods which will take
    place for all equality comparisons and continue to succeed in the not anticipated
    case that a non- `PathRegistry` object is compared, while emitting a warning that
    this object should not be the subject of the comparison.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5110](https://www.sqlalchemy.org/trac/ticket/5110)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting a relationship to viewonly=True which is also the target of a back_populates
    or backref configuration will now emit a warning and eventually be disallowed.
    back_populates refers specifically to mutation of an attribute or collection,
    which is disallowed when the attribute is subject to viewonly=True. The viewonly
    attribute is not subject to persistence behaviors which means it will not reflect
    correct results when it is locally mutated.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5149](https://www.sqlalchemy.org/trac/ticket/5149)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed an additional regression in the same area as that of [#5080](https://www.sqlalchemy.org/trac/ticket/5080)
    introduced in 1.3.0b3 via [#4468](https://www.sqlalchemy.org/trac/ticket/4468)
    where the ability to create a joined option across a [`with_polymorphic()`](../orm/queryguide/inheritance.html#sqlalchemy.orm.with_polymorphic
    "sqlalchemy.orm.with_polymorphic") into a relationship against the base class
    of that with_polymorphic, and then further into regular mapped relationships would
    fail as the base class component would not add itself to the load path in a way
    that could be located by the loader strategy. The changes applied in [#5080](https://www.sqlalchemy.org/trac/ticket/5080)
    have been further refined to also accommodate this scenario.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5121](https://www.sqlalchemy.org/trac/ticket/5121)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: engine
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[engine] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Expanded the scope of cursor/connection cleanup when a statement is executed
    to include when the result object fails to be constructed, or an after_cursor_execute()
    event raises an error, or autocommit / autoclose fails. This allows the DBAPI
    cursor to be cleaned up on failure and for connectionless execution allows the
    connection to be closed out and returned to the connection pool, where previously
    it waiting until garbage collection would trigger a pool return.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5182](https://www.sqlalchemy.org/trac/ticket/5182)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[sql] [bug] [postgresql]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug where a CTE of an INSERT/UPDATE/DELETE that also uses RETURNING could
    then not be SELECTed from directly, as the internal state of the compiler would
    try to treat the outer SELECT as a DELETE statement itself and access nonexistent
    state.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5181](https://www.sqlalchemy.org/trac/ticket/5181)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: postgresql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[postgresql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue where the “schema_translate_map” feature would not work with a PostgreSQL
    native enumeration type (i.e. [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum"), [`ENUM`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ENUM
    "sqlalchemy.dialects.postgresql.ENUM")) in that while the “CREATE TYPE” statement
    would be emitted with the correct schema, the schema would not be rendered in
    the CREATE TABLE statement at the point at which the enumeration was referenced.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5158](https://www.sqlalchemy.org/trac/ticket/5158)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[postgresql] [bug] [reflection]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug where PostgreSQL reflection of CHECK constraints would fail to parse
    the constraint if the SQL text contained newline characters. The regular expression
    has been adjusted to accommodate for this case. Pull request courtesy Eric Borczuk.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5170](https://www.sqlalchemy.org/trac/ticket/5170)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: mysql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[mysql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue in MySQL [`Insert.on_duplicate_key_update()`](../dialects/mysql.html#sqlalchemy.dialects.mysql.Insert.on_duplicate_key_update
    "sqlalchemy.dialects.mysql.Insert.on_duplicate_key_update") construct where using
    a SQL function or other composed expression for a column argument would not properly
    render the `VALUES` keyword surrounding the column itself.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5173](https://www.sqlalchemy.org/trac/ticket/5173)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: mssql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[mssql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue where the [`DATETIMEOFFSET`](../dialects/mssql.html#sqlalchemy.dialects.mssql.DATETIMEOFFSET
    "sqlalchemy.dialects.mssql.DATETIMEOFFSET") type would not accommodate for the
    `None` value, introduced as part of the series of fixes for this type first introduced
    in [#4983](https://www.sqlalchemy.org/trac/ticket/4983), [#5045](https://www.sqlalchemy.org/trac/ticket/5045).
    Additionally, added support for passing a backend-specific date formatted string
    through this type, as is typically allowed for date/time types on most other DBAPIs.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5132](https://www.sqlalchemy.org/trac/ticket/5132)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: oracle
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[oracle] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed a reflection bug where table comments could only be retrieved for tables
    actually owned by the user but not for tables visible to the user but owned by
    someone else. Pull request courtesy Dave Hirschfeld.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5146](https://www.sqlalchemy.org/trac/ticket/5146)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: misc
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[usecase] [ext]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added keyword arguments to the [`MutableList.sort()`](../orm/extensions/mutable.html#sqlalchemy.ext.mutable.MutableList.sort
    "sqlalchemy.ext.mutable.MutableList.sort") function so that a key function as
    well as the “reverse” keyword argument can be provided.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5114](https://www.sqlalchemy.org/trac/ticket/5114)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[performance] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Revised an internal change to the test system added as a result of [#5085](https://www.sqlalchemy.org/trac/ticket/5085)
    where a testing-related module per dialect would be loaded unconditionally upon
    making use of that dialect, pulling in SQLAlchemy’s testing framework as well
    as the ORM into the module import space. This would only impact initial startup
    time and memory to a modest extent, however it’s best that these additional modules
    aren’t reverse-dependent on straight Core usage.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5180](https://www.sqlalchemy.org/trac/ticket/5180)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[bug] [installation]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vendored the `inspect.formatannotation` function inside of `sqlalchemy.util.compat`,
    which is needed for the vendored version of `inspect.formatargspec`. The function
    is not documented in cPython and is not guaranteed to be available in future Python
    versions.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5138](https://www.sqlalchemy.org/trac/ticket/5138)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 1.3.13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Released: January 22, 2020'
  prefs: []
  type: TYPE_NORMAL
- en: orm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[orm] [performance]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identified a performance issue in the system by which a join is constructed
    based on a mapped relationship. The clause adaption system would be used for the
    majority of join expressions including in the common case where no adaptation
    is needed. The conditions under which this adaptation occur have been refined
    so that average non-aliased joins along a simple relationship without a “secondary”
    table use about 70% less function calls.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug] [engine]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added test support and repaired a wide variety of unnecessary reference cycles
    created for short-lived objects, mostly in the area of ORM queries. Thanks much
    to Carson Ip for the help on this.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5050](https://www.sqlalchemy.org/trac/ticket/5050), [#5056](https://www.sqlalchemy.org/trac/ticket/5056),
    [#5071](https://www.sqlalchemy.org/trac/ticket/5071)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed regression in loader options introduced in 1.3.0b3 via [#4468](https://www.sqlalchemy.org/trac/ticket/4468)
    where the ability to create a loader option using [`PropComparator.of_type()`](../orm/internals.html#sqlalchemy.orm.PropComparator.of_type
    "sqlalchemy.orm.PropComparator.of_type") targeting an aliased entity that is an
    inheriting subclass of the entity which the preceding relationship refers to would
    fail to produce a matching path. See also [#5082](https://www.sqlalchemy.org/trac/ticket/5082)
    fixed in this same release which involves a similar kind of issue.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5107](https://www.sqlalchemy.org/trac/ticket/5107)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed regression in joined eager loading introduced in 1.3.0b3 via [#4468](https://www.sqlalchemy.org/trac/ticket/4468)
    where the ability to create a joined option across a [`with_polymorphic()`](../orm/queryguide/inheritance.html#sqlalchemy.orm.with_polymorphic
    "sqlalchemy.orm.with_polymorphic") into a polymorphic subclass using `RelationshipProperty.of_type()`
    and then further along regular mapped relationships would fail as the polymorphic
    subclass would not add itself to the load path in a way that could be located
    by the loader strategy. A tweak has been made to resolve this scenario.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5082](https://www.sqlalchemy.org/trac/ticket/5082)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Repaired a warning in the ORM flush process that was not covered by test coverage
    when deleting objects that use the “version_id” feature. This warning is generally
    unreachable unless using a dialect that sets the “supports_sane_rowcount” flag
    to False, which is not typically the case however is possible for some MySQL configurations
    as well as older Firebird drivers, and likely some third party dialects.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5068](https://www.sqlalchemy.org/trac/ticket/5068)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug where usage of joined eager loading would not properly wrap the query
    inside of a subquery when [`Query.group_by()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.group_by
    "sqlalchemy.orm.Query.group_by") were used against the query. When any kind of
    result-limiting approach is used, such as DISTINCT, LIMIT, OFFSET, joined eager
    loading embeds the row-limited query inside of a subquery so that the collection
    results are not impacted. For some reason, the presence of GROUP BY was never
    included in this criterion, even though it has a similar effect as using DISTINCT.
    Additionally, the bug would prevent using GROUP BY at all for a joined eager load
    query for most database platforms which forbid non-aggregated, non-grouped columns
    from being in the query, as the additional columns for the joined eager load would
    not be accepted by the database.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5065](https://www.sqlalchemy.org/trac/ticket/5065)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: engine
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[engine] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue where the collection of value processors on a [`Compiled`](../core/internals.html#sqlalchemy.engine.Compiled
    "sqlalchemy.engine.Compiled") object would be mutated when “expanding IN” parameters
    were used with a datatype that has bind value processors; in particular, this
    would mean that when using statement caching and/or baked queries, the same compiled._bind_processors
    collection would be mutated concurrently. Since these processors are the same
    function for a given bind parameter namespace every time, there was no actual
    negative effect of this issue, however, the execution of a [`Compiled`](../core/internals.html#sqlalchemy.engine.Compiled
    "sqlalchemy.engine.Compiled") object should never be causing any changes in its
    state, especially given that they are intended to be thread-safe and reusable
    once fully constructed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5048](https://www.sqlalchemy.org/trac/ticket/5048)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[sql] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A function created using [`GenericFunction`](../core/functions.html#sqlalchemy.sql.functions.GenericFunction
    "sqlalchemy.sql.functions.GenericFunction") can now specify that the name of the
    function should be rendered with or without quotes by assigning the [`quoted_name`](../core/sqlelement.html#sqlalchemy.sql.expression.quoted_name
    "sqlalchemy.sql.expression.quoted_name") construct to the .name element of the
    object. Prior to 1.3.4, quoting was never applied to function names, and some
    quoting was introduced in [#4467](https://www.sqlalchemy.org/trac/ticket/4467)
    but no means to force quoting for a mixed case name was available. Additionally,
    the [`quoted_name`](../core/sqlelement.html#sqlalchemy.sql.expression.quoted_name
    "sqlalchemy.sql.expression.quoted_name") construct when used as the name will
    properly register its lowercase name in the function registry so that the name
    continues to be available via the `func.` registry.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`GenericFunction`](../core/functions.html#sqlalchemy.sql.functions.GenericFunction
    "sqlalchemy.sql.functions.GenericFunction")'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5079](https://www.sqlalchemy.org/trac/ticket/5079)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: postgresql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[postgresql] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added support for prefixes to the [`CTE`](../core/selectable.html#sqlalchemy.sql.expression.CTE
    "sqlalchemy.sql.expression.CTE") construct, to allow support for Postgresql 12
    “MATERIALIZED” and “NOT MATERIALIZED” phrases. Pull request courtesy Marat Sharafutdinov.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`HasCTE.cte()`](../core/selectable.html#sqlalchemy.sql.expression.HasCTE.cte
    "sqlalchemy.sql.expression.HasCTE.cte")'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5040](https://www.sqlalchemy.org/trac/ticket/5040)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[postgresql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue where the PostgreSQL dialect would fail to parse a reflected CHECK
    constraint that was a boolean-valued function (as opposed to a boolean-valued
    expression).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5039](https://www.sqlalchemy.org/trac/ticket/5039)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: mssql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[mssql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue where a timezone-aware `datetime` value being converted to string
    for use as a parameter value of a [`DATETIMEOFFSET`](../dialects/mssql.html#sqlalchemy.dialects.mssql.DATETIMEOFFSET
    "sqlalchemy.dialects.mssql.DATETIMEOFFSET") column was omitting the fractional
    seconds.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5045](https://www.sqlalchemy.org/trac/ticket/5045)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: tests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[tests] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed a few test failures which would occur on Windows due to SQLite file locking
    issues, as well as some timing issues in connection pool related tests; pull request
    courtesy Federico Caselli.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4946](https://www.sqlalchemy.org/trac/ticket/4946)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[tests] [postgresql]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improved detection of two phase transactions requirement for the PostgreSQL
    database by testing that max_prepared_transactions is set to a value greater than
    0\. Pull request courtesy Federico Caselli.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5057](https://www.sqlalchemy.org/trac/ticket/5057)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: misc
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[bug] [ext]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug in sqlalchemy.ext.serializer where a unique [`BindParameter`](../core/sqlelement.html#sqlalchemy.sql.expression.BindParameter
    "sqlalchemy.sql.expression.BindParameter") object could conflict with itself if
    it were present in the mapping itself, as well as the filter condition of the
    query, as one side would be used against the non-deserialized version and the
    other side would use the deserialized version. Logic is added to [`BindParameter`](../core/sqlelement.html#sqlalchemy.sql.expression.BindParameter
    "sqlalchemy.sql.expression.BindParameter") similar to its “clone” method which
    will uniquify the parameter name upon deserialize so that it doesn’t conflict
    with its original.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5086](https://www.sqlalchemy.org/trac/ticket/5086)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 1.3.12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Released: December 16, 2019'
  prefs: []
  type: TYPE_NORMAL
- en: orm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue involving `lazy="raise"` strategy where an ORM delete of an object
    would raise for a simple “use-get” style many-to-one relationship that had lazy=”raise”
    configured. This is inconsistent vs. the change introduced in 1.3 as part of [#4353](https://www.sqlalchemy.org/trac/ticket/4353),
    where it was established that a history operation that does not expect emit SQL
    should bypass the `lazy="raise"` check, and instead effectively treat it as `lazy="raise_on_sql"`
    for this case. The fix adjusts the lazy loader strategy to not raise for the case
    where the lazy load was instructed that it should not emit SQL if the object were
    not present.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4997](https://www.sqlalchemy.org/trac/ticket/4997)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed regression introduced in 1.3.0 related to the association proxy refactor
    in [#4351](https://www.sqlalchemy.org/trac/ticket/4351) that prevented [`composite()`](../orm/composites.html#sqlalchemy.orm.composite
    "sqlalchemy.orm.composite") attributes from working in terms of an association
    proxy that references them.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5000](https://www.sqlalchemy.org/trac/ticket/5000)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting persistence-related flags on [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") while also setting viewonly=True will now emit
    a regular warning, as these flags do not make sense for a viewonly=True relationship.
    In particular, the “cascade” settings have their own warning that is generated
    based on the individual values, such as “delete, delete-orphan”, that should not
    apply to a viewonly relationship. Note however that in the case of “cascade”,
    these settings are still erroneously taking effect even though the relationship
    is set up as “viewonly”. In 1.4, all persistence-related cascade settings will
    be disallowed on a viewonly=True relationship in order to resolve this issue.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4993](https://www.sqlalchemy.org/trac/ticket/4993)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug] [py3k]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue where when assigning a collection to itself as a slice, the mutation
    operation would fail as it would first erase the assigned collection inadvertently.
    As an assignment that does not change the contents should not generate events,
    the operation is now a no-op. Note that the fix only applies to Python 3; in Python
    2, the `__setitem__` hook isn’t called in this case; `__setslice__` is used instead
    which recreates the list item-by-item in all cases.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4990](https://www.sqlalchemy.org/trac/ticket/4990)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue where by if the “begin” of a transaction failed at the Core engine/connection
    level, such as due to network error or database is locked for some transactional
    recipes, within the context of the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") procuring that connection from the connection pool and
    then immediately returning it, the ORM [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") would not close the connection despite this connection
    not being stored within the state of that [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"). This would lead to the connection being cleaned out
    by the connection pool weakref handler within garbage collection which is an unpreferred
    codepath that in some special configurations can emit errors in standard error.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5034](https://www.sqlalchemy.org/trac/ticket/5034)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[sql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug where “distinct” keyword passed to [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") would not treat a string value as a “label
    reference” in the same way that the `select.distinct()` does; it would instead
    raise unconditionally. This keyword argument and the others passed to [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") will ultimately be deprecated for SQLAlchemy
    2.0.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5028](https://www.sqlalchemy.org/trac/ticket/5028)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[sql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changed the text of the exception for “Can’t resolve label reference” to include
    other kinds of label coercions, namely that “DISTINCT” is also in this category
    under the PostgreSQL dialect.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sqlite
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[sqlite] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue to workaround SQLite’s behavior of assigning “numeric” affinity
    to JSON datatypes, first described at [Support for SQLite JSON Added](migration_13.html#change-3850),
    which returns scalar numeric JSON values as a number and not as a string that
    can be JSON deserialized. The SQLite-specific JSON deserializer now gracefully
    degrades for this case as an exception and bypasses deserialization for single
    numeric values, as from a JSON perspective they are already deserialized.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5014](https://www.sqlalchemy.org/trac/ticket/5014)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: mssql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[mssql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Repaired support for the [`DATETIMEOFFSET`](../dialects/mssql.html#sqlalchemy.dialects.mssql.DATETIMEOFFSET
    "sqlalchemy.dialects.mssql.DATETIMEOFFSET") datatype on PyODBC, by adding PyODBC-level
    result handlers as it does not include native support for this datatype. This
    includes usage of the Python 3 “timezone” tzinfo subclass in order to set up a
    timezone, which on Python 2 makes use of a minimal backport of “timezone” in sqlalchemy.util.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4983](https://www.sqlalchemy.org/trac/ticket/4983)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 1.3.11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Released: November 11, 2019'
  prefs: []
  type: TYPE_NORMAL
- en: orm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[orm] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added accessor [`Query.is_single_entity()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.is_single_entity
    "sqlalchemy.orm.Query.is_single_entity") to [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query"), which will indicate if the results returned by this [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") will be a list of ORM entities, or a tuple of entities
    or column expressions. SQLAlchemy hopes to improve upon the behavior of single
    entity / tuples in future releases such that the behavior would be explicit up
    front, however this attribute should be helpful with the current behavior. Pull
    request courtesy Patrick Hayes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4934](https://www.sqlalchemy.org/trac/ticket/4934)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [`relationship.omit_join`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.omit_join
    "sqlalchemy.orm.relationship") flag was not intended to be manually set to True,
    and will now emit a warning when this occurs. The omit_join optimization is detected
    automatically, and the `omit_join` flag was only intended to disable the optimization
    in the hypothetical case that the optimization may have interfered with correct
    results, which has not been observed with the modern version of this feature.
    Setting the flag to True when it is not automatically detected may cause the selectin
    load feature to not work correctly when a non-default primary join condition is
    in use.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4954](https://www.sqlalchemy.org/trac/ticket/4954)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A warning is emitted if a primary key value is passed to [`Query.get()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.get
    "sqlalchemy.orm.Query.get") that consists of None for all primary key column positions.
    Previously, passing a single None outside of a tuple would raise a `TypeError`
    and passing a composite None (tuple of None values) would silently pass through.
    The fix now coerces the single None into a tuple where it is handled consistently
    with the other None conditions. Thanks to Lev Izraelit for the help with this.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4915](https://www.sqlalchemy.org/trac/ticket/4915)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [`BakedQuery`](../orm/extensions/baked.html#sqlalchemy.ext.baked.BakedQuery
    "sqlalchemy.ext.baked.BakedQuery") will not cache a query that was modified by
    a [`QueryEvents.before_compile()`](../orm/events.html#sqlalchemy.orm.QueryEvents.before_compile
    "sqlalchemy.orm.QueryEvents.before_compile") event, so that compilation hooks
    that may be applying ad-hoc modifications to queries will take effect on each
    run. In particular this is helpful for events that modify queries used in lazy
    loading as well as eager loading such as “select in” loading. In order to re-enable
    caching for a query modified by this event, a new flag `bake_ok` is added; see
    [Using the before_compile event](../orm/extensions/baked.html#baked-with-before-compile)
    for details.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A longer term plan to provide a new form of SQL caching should solve this kind
    of issue more comprehensively.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4947](https://www.sqlalchemy.org/trac/ticket/4947)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed ORM bug where a “secondary” table that referred to a selectable which
    in some way would refer to the local primary table would apply aliasing to both
    sides of the join condition when a relationship-related join, either via [`Query.join()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join") or by [`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload"), were generated. The “local” side is now excluded.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4974](https://www.sqlalchemy.org/trac/ticket/4974)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: engine
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[engine] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug where parameter repr as used in logging and error reporting needs
    additional context in order to distinguish between a list of parameters for a
    single statement and a list of parameter lists, as the “list of lists” structure
    could also indicate a single parameter list where the first parameter itself is
    a list, such as for an array parameter. The engine/connection now passes in an
    additional boolean indicating how the parameters should be considered. The only
    SQLAlchemy backend that expects arrays as parameters is that of psycopg2 which
    uses pyformat parameters, so this issue has not been too apparent, however as
    other drivers that use positional gain more features it is important that this
    be supported. It also eliminates the need for the parameter repr function to guess
    based on the parameter structure passed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4902](https://www.sqlalchemy.org/trac/ticket/4902)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[engine] [bug] [postgresql]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug in [`Inspector`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector
    "sqlalchemy.engine.reflection.Inspector") where the cache key generation did not
    take into account arguments passed in the form of tuples, such as the tuple of
    view name styles to return for the PostgreSQL dialect. This would lead the inspector
    to cache too generally for a more specific set of criteria. The logic has been
    adjusted to include every keyword element in the cache, as every argument is expected
    to be appropriate for a cache else the caching decorator should be bypassed by
    the dialect.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4955](https://www.sqlalchemy.org/trac/ticket/4955)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[sql] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added new accessors to expressions of type [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON") to allow for specific datatype access and comparison,
    covering strings, integers, numeric, boolean elements. This revises the documented
    approach of CASTing to string when comparing values, instead adding specific functionality
    into the PostgreSQL, SQlite, MySQL dialects to reliably deliver these basic types
    in all cases.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON")'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`Comparator.as_string()`](../core/type_basics.html#sqlalchemy.types.JSON.Comparator.as_string
    "sqlalchemy.types.JSON.Comparator.as_string")'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`Comparator.as_boolean()`](../core/type_basics.html#sqlalchemy.types.JSON.Comparator.as_boolean
    "sqlalchemy.types.JSON.Comparator.as_boolean")'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`Comparator.as_float()`](../core/type_basics.html#sqlalchemy.types.JSON.Comparator.as_float
    "sqlalchemy.types.JSON.Comparator.as_float")'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`Comparator.as_integer()`](../core/type_basics.html#sqlalchemy.types.JSON.Comparator.as_integer
    "sqlalchemy.types.JSON.Comparator.as_integer")'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4276](https://www.sqlalchemy.org/trac/ticket/4276)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[sql] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text "sqlalchemy.sql.expression.text")
    construct now supports “unique” bound parameters, which will dynamically uniquify
    themselves on compilation thus allowing multiple [`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text
    "sqlalchemy.sql.expression.text") constructs with the same bound parameter names
    to be combined together.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4933](https://www.sqlalchemy.org/trac/ticket/4933)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[sql] [bug] [py3k]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changed the `repr()` of the [`quoted_name`](../core/sqlelement.html#sqlalchemy.sql.expression.quoted_name
    "sqlalchemy.sql.expression.quoted_name") construct to use regular string repr()
    under Python 3, rather than running it through “backslashreplace” escaping, which
    can be misleading.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4931](https://www.sqlalchemy.org/trac/ticket/4931)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: schema
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[schema] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added DDL support for “computed columns”; these are DDL column specifications
    for columns that have a server-computed value, either upon SELECT (known as “virtual”)
    or at the point of which they are INSERTed or UPDATEd (known as “stored”). Support
    is established for Postgresql, MySQL, Oracle SQL Server and Firebird. Thanks to
    Federico Caselli for lots of work on this one.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Computed Columns (GENERATED ALWAYS AS)](../core/defaults.html#computed-ddl)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4894](https://www.sqlalchemy.org/trac/ticket/4894)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[schema] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug where a table that would have a column label overlap with a plain
    column name, such as “foo.id AS foo_id” vs. “foo.foo_id”, would prematurely generate
    the `._label` attribute for a column before this overlap could be detected due
    to the use of the `index=True` or `unique=True` flag on the column in conjunction
    with the default naming convention of `"column_0_label"`. This would then lead
    to failures when `._label` were used later to generate a bound parameter name,
    in particular those used by the ORM when generating the WHERE clause for an UPDATE
    statement. The issue has been fixed by using an alternate `._label` accessor for
    DDL generation that does not affect the state of the [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column"). The accessor also bypasses the key-deduplication
    step as it is not necessary for DDL, the naming is now consistently `"<tablename>_<columnname>"`
    without any subsequent numeric symbols when used in DDL.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4911](https://www.sqlalchemy.org/trac/ticket/4911)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: mysql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[mysql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added “Connection was killed” message interpreted from the base pymysql.Error
    class in order to detect closed connection, based on reports that this message
    is arriving via a pymysql.InternalError() object which indicates pymysql is not
    handling it correctly.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4945](https://www.sqlalchemy.org/trac/ticket/4945)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: mssql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[mssql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue in MSSQL dialect where an expression-based OFFSET value in a SELECT
    would be rejected, even though the dialect can render this expression inside of
    a ROW NUMBER-oriented LIMIT/OFFSET construct.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4973](https://www.sqlalchemy.org/trac/ticket/4973)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[mssql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed an issue in the `Engine.table_names()` method where it would feed the
    dialect’s default schema name back into the dialect level table function, which
    in the case of SQL Server would interpret it as a dot-tokenized schema name as
    viewed by the mssql dialect, which would cause the method to fail in the case
    where the database username actually had a dot inside of it. In 1.3, this method
    is still used by the [`MetaData.reflect()`](../core/metadata.html#sqlalchemy.schema.MetaData.reflect
    "sqlalchemy.schema.MetaData.reflect") function so is a prominent codepath. In
    1.4, which is the current master development branch, this issue doesn’t exist,
    both because [`MetaData.reflect()`](../core/metadata.html#sqlalchemy.schema.MetaData.reflect
    "sqlalchemy.schema.MetaData.reflect") isn’t using this method nor does the method
    pass the default schema name explicitly. The fix nonetheless guards against the
    default server name value returned by the dialect from being interpreted as dot-tokenized
    name under any circumstances by wrapping it in quoted_name().
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4923](https://www.sqlalchemy.org/trac/ticket/4923)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: oracle
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[oracle] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added dialect-level flag `encoding_errors` to the cx_Oracle dialect, which can
    be specified as part of [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine"). This is passed to SQLAlchemy’s unicode decoding converter
    under Python 2, and to cx_Oracle’s `cursor.var()` object as the `encodingErrors`
    parameter under Python 3, for the very unusual case that broken encodings are
    present in the target database which cannot be fetched unless error handling is
    relaxed. The value is ultimately one of the Python “encoding errors” parameters
    passed to `decode()`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4799](https://www.sqlalchemy.org/trac/ticket/4799)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[oracle] [bug] [firebird]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modified the approach of “name normalization” for the Oracle and Firebird dialects,
    which converts from the UPPERCASE-as-case-insensitive convention of these dialects
    into lowercase-as-case-insensitive for SQLAlchemy, to not automatically apply
    the [`quoted_name`](../core/sqlelement.html#sqlalchemy.sql.expression.quoted_name
    "sqlalchemy.sql.expression.quoted_name") construct to a name that matches itself
    under upper or lower case conversion, as is the case for many non-european characters.
    All names used within metadata structures are converted to [`quoted_name`](../core/sqlelement.html#sqlalchemy.sql.expression.quoted_name
    "sqlalchemy.sql.expression.quoted_name") objects in any case; the change here
    would only affect the output of some inspection functions.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4931](https://www.sqlalchemy.org/trac/ticket/4931)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[oracle] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [`NCHAR`](../core/type_basics.html#sqlalchemy.types.NCHAR "sqlalchemy.types.NCHAR")
    datatype will now bind to the `cx_Oracle.FIXED_NCHAR` DBAPI data bindings when
    used in a bound parameter, which supplies proper comparison behavior against a
    variable-length string. Previously, the [`NCHAR`](../core/type_basics.html#sqlalchemy.types.NCHAR
    "sqlalchemy.types.NCHAR") datatype would bind to `cx_oracle.NCHAR` which is not
    fixed length; the [`CHAR`](../core/type_basics.html#sqlalchemy.types.CHAR "sqlalchemy.types.CHAR")
    datatype already binds to `cx_Oracle.FIXED_CHAR` so it is now consistent that
    [`NCHAR`](../core/type_basics.html#sqlalchemy.types.NCHAR "sqlalchemy.types.NCHAR")
    binds to `cx_Oracle.FIXED_NCHAR`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4913](https://www.sqlalchemy.org/trac/ticket/4913)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: tests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[tests] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed test failures which would occur with newer SQLite as of version 3.30 or
    greater, due to their addition of nulls ordering syntax as well as new restrictions
    on aggregate functions. Pull request courtesy Nils Philippsen.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4920](https://www.sqlalchemy.org/trac/ticket/4920)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: misc
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[bug] [installation] [windows]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added a workaround for a setuptools-related failure that has been observed as
    occurring on Windows installations, where setuptools is not correctly reporting
    a build error when the MSVC build dependencies are not installed and therefore
    not allowing graceful degradation into non C extensions builds.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4967](https://www.sqlalchemy.org/trac/ticket/4967)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[bug] [firebird]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added additional “disconnect” message “Error writing data to the connection”
    to Firebird disconnection detection. Pull request courtesy lukens.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4903](https://www.sqlalchemy.org/trac/ticket/4903)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 1.3.10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Released: October 9, 2019'
  prefs: []
  type: TYPE_NORMAL
- en: mssql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[mssql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug in SQL Server dialect with new “max_identifier_length” feature where
    the mssql dialect already featured this flag, and the implementation did not accommodate
    for the new initialization hook correctly.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4857](https://www.sqlalchemy.org/trac/ticket/4857)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: oracle
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[oracle] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed regression in Oracle dialect that was inadvertently using max identifier
    length of 128 characters on Oracle server 12.2 and greater even though the stated
    contract for the remainder of the 1.3 series is that this value stays at 30 until
    version SQLAlchemy 1.4\. Also repaired issues with the retrieval of the “compatibility”
    version, and removed the warning emitted when the “v$parameter” view was not accessible
    as this was causing user confusion.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4857](https://www.sqlalchemy.org/trac/ticket/4857), [#4898](https://www.sqlalchemy.org/trac/ticket/4898)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 1.3.9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Released: October 4, 2019'
  prefs: []
  type: TYPE_NORMAL
- en: orm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed regression in selectinload loader strategy caused by [#4775](https://www.sqlalchemy.org/trac/ticket/4775)
    (released in version 1.3.6) where a many-to-one attribute of None would no longer
    be populated by the loader. While this was usually not noticeable due to the lazyloader
    populating None upon get, it would lead to a detached instance error if the object
    were detached.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4872](https://www.sqlalchemy.org/trac/ticket/4872)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing a plain string expression to [`Session.query()`](../orm/session_api.html#sqlalchemy.orm.Session.query
    "sqlalchemy.orm.Session.query") is deprecated, as all string coercions were removed
    in [#4481](https://www.sqlalchemy.org/trac/ticket/4481) and this one should have
    been included. The [`literal_column()`](../core/sqlelement.html#sqlalchemy.sql.expression.literal_column
    "sqlalchemy.sql.expression.literal_column") function may be used to produce a
    textual column expression.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4873](https://www.sqlalchemy.org/trac/ticket/4873)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A warning is emitted for a condition in which the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") may implicitly swap an object out of the identity map
    for another one with the same primary key, detaching the old one, which can be
    an observed result of load operations which occur within the [`SessionEvents.after_flush()`](../orm/events.html#sqlalchemy.orm.SessionEvents.after_flush
    "sqlalchemy.orm.SessionEvents.after_flush") hook. The warning is intended to notify
    the user that some special condition has caused this to happen and that the previous
    object may not be in the expected state.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4890](https://www.sqlalchemy.org/trac/ticket/4890)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: engine
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[engine] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added new [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") parameter [`create_engine.max_identifier_length`](../core/engines.html#sqlalchemy.create_engine.params.max_identifier_length
    "sqlalchemy.create_engine"). This overrides the dialect-coded “max identifier
    length” in order to accommodate for databases that have recently changed this
    length and the SQLAlchemy dialect has not yet been adjusted to detect for that
    version. This parameter interacts with the existing [`create_engine.label_length`](../core/engines.html#sqlalchemy.create_engine.params.label_length
    "sqlalchemy.create_engine") parameter in that it establishes the maximum (and
    default) value for anonymously generated labels. Additionally, post-connection
    detection of max identifier lengths has been added to the dialect system. This
    feature is first being used by the Oracle dialect.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Max Identifier Lengths](../dialects/oracle.html#oracle-max-identifier-lengths)
    - in the Oracle dialect documentation'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4857](https://www.sqlalchemy.org/trac/ticket/4857)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[sql] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added an explicit error message for the case when objects passed to [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") are not [`SchemaItem`](../core/metadata.html#sqlalchemy.schema.SchemaItem
    "sqlalchemy.schema.SchemaItem") objects, rather than resolving to an attribute
    error.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4847](https://www.sqlalchemy.org/trac/ticket/4847)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[sql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Characters that interfere with “pyformat” or “named” formats in bound parameters,
    namely `%, (, )` and the space character, as well as a few other typically undesirable
    characters, are stripped early for a [`bindparam()`](../core/sqlelement.html#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam") that is using an anonymized name, which
    is typically generated automatically from a named column which itself includes
    these characters in its name and does not use a `.key`, so that they do not interfere
    either with the SQLAlchemy compiler’s use of string formatting or with the driver-level
    parsing of the parameter, both of which could be demonstrated before the fix.
    The change only applies to anonymized parameter names that are generated and consumed
    internally, not end-user defined names, so the change should have no impact on
    any existing code. Applies in particular to the psycopg2 driver which does not
    otherwise quote special parameter names, but also strips leading underscores to
    suit Oracle (but not yet leading numbers, as some anon parameters are currently
    entirely numeric/underscore based); Oracle in any case continues to quote parameter
    names that include special characters.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4837](https://www.sqlalchemy.org/trac/ticket/4837)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sqlite
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[sqlite] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added support for sqlite “URI” connections, which allow for sqlite-specific
    flags to be passed in the query string such as “read only” for Python sqlite3
    drivers that support this.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[URI Connections](../dialects/sqlite.html#pysqlite-uri-connections)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4863](https://www.sqlalchemy.org/trac/ticket/4863)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: mssql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[mssql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added identifier quoting to the schema name applied to the “use” statement which
    is invoked when a SQL Server multipart schema name is used within a [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") that is being reflected, as well as for [`Inspector`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector
    "sqlalchemy.engine.reflection.Inspector") methods such as [`Inspector.get_table_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_table_names
    "sqlalchemy.engine.reflection.Inspector.get_table_names"); this accommodates for
    special characters or spaces in the database name. Additionally, the “use” statement
    is not emitted if the current database matches the target owner database name
    being passed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4883](https://www.sqlalchemy.org/trac/ticket/4883)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: oracle
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[oracle] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Oracle dialect now emits a warning if Oracle version 12.2 or greater is
    used, and the [`create_engine.max_identifier_length`](../core/engines.html#sqlalchemy.create_engine.params.max_identifier_length
    "sqlalchemy.create_engine") parameter is not set. The version in this specific
    case defaults to that of the “compatibility” version set in the Oracle server
    configuration, not the actual server version. In version 1.4, the default max_identifier_length
    for 12.2 or greater will move to 128 characters. In order to maintain forwards
    compatibility, applications should set [`create_engine.max_identifier_length`](../core/engines.html#sqlalchemy.create_engine.params.max_identifier_length
    "sqlalchemy.create_engine") to 30 in order to maintain the same length behavior,
    or to 128 in order to test the upcoming behavior. This length determines among
    other things how generated constraint names are truncated for statements like
    `CREATE CONSTRAINT` and `DROP CONSTRAINT`, which means a the new length may produce
    a name-mismatch against a name that was generated with the old length, impacting
    database migrations.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Max Identifier Lengths](../dialects/oracle.html#oracle-max-identifier-lengths)
    - in the Oracle dialect documentation'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4857](https://www.sqlalchemy.org/trac/ticket/4857)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[oracle] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Restored adding cx_Oracle.DATETIME to the setinputsizes() call when a SQLAlchemy
    [`Date`](../core/type_basics.html#sqlalchemy.types.Date "sqlalchemy.types.Date"),
    [`DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime "sqlalchemy.types.DateTime")
    or [`Time`](../core/type_basics.html#sqlalchemy.types.Time "sqlalchemy.types.Time")
    datatype is used, as some complex queries require this to be present. This was
    removed in the 1.2 series for arbitrary reasons.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4886](https://www.sqlalchemy.org/trac/ticket/4886)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: tests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[tests] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed unit test regression released in 1.3.8 that would cause failure for Oracle,
    SQL Server and other non-native ENUM platforms due to new enumeration tests added
    as part of [#4285](https://www.sqlalchemy.org/trac/ticket/4285) enum sortability
    in the unit of work; the enumerations created constraints that were duplicated
    on name.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4285](https://www.sqlalchemy.org/trac/ticket/4285)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 1.3.8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Released: August 27, 2019'
  prefs: []
  type: TYPE_NORMAL
- en: orm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[orm] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added support for the use of an [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum") datatype using Python pep-435 enumeration objects as
    values for use as a primary key column mapped by the ORM. As these values are
    not inherently sortable, as required by the ORM for primary keys, a new [`TypeEngine.sort_key_function`](../core/type_api.html#sqlalchemy.types.TypeEngine.sort_key_function
    "sqlalchemy.types.TypeEngine.sort_key_function") attribute is added to the typing
    system which allows any SQL type to implement a sorting for Python objects of
    its type which is consulted by the unit of work. The [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum") type then defines this using the database value of a
    given enumeration. The sorting scheme can be also be redefined by passing a callable
    to the [`Enum.sort_key_function`](../core/type_basics.html#sqlalchemy.types.Enum.params.sort_key_function
    "sqlalchemy.types.Enum") parameter. Pull request courtesy Nicolas Caniart.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4285](https://www.sqlalchemy.org/trac/ticket/4285)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug where [`Load`](../orm/queryguide/relationships.html#sqlalchemy.orm.Load
    "sqlalchemy.orm.Load") objects were not pickleable due to mapper/relationship
    state in the internal context dictionary. These objects are now converted to picklable
    using similar techniques as that of other elements within the loader option system
    that have long been serializable.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4823](https://www.sqlalchemy.org/trac/ticket/4823)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: engine
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[engine] [feature]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added new parameter [`create_engine.hide_parameters`](../core/engines.html#sqlalchemy.create_engine.params.hide_parameters
    "sqlalchemy.create_engine") which when set to True will cause SQL parameters to
    no longer be logged, nor rendered in the string representation of a [`StatementError`](../core/exceptions.html#sqlalchemy.exc.StatementError
    "sqlalchemy.exc.StatementError") object.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4815](https://www.sqlalchemy.org/trac/ticket/4815)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[engine] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed an issue whereby if the dialect “initialize” process which occurs on first
    connect would encounter an unexpected exception, the initialize process would
    fail to complete and then no longer attempt on subsequent connection attempts,
    leaving the dialect in an un-initialized, or partially initialized state, within
    the scope of parameters that need to be established based on inspection of a live
    connection. The “invoke once” logic in the event system has been reworked to accommodate
    for this occurrence using new, private API features that establish an “exec once”
    hook that will continue to allow the initializer to fire off on subsequent connections,
    until it completes without raising an exception. This does not impact the behavior
    of the existing `once=True` flag within the event system.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4807](https://www.sqlalchemy.org/trac/ticket/4807)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: postgresql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[postgresql] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Added support for reflection of CHECK constraints that include the special
    PostgreSQL qualifier “NOT VALID”, which can be present for CHECK constraints that
    were added to an existing table with the directive that they not be applied to
    existing data in the table. The PostgreSQL dictionary for CHECK constraints as
    returned by [`Inspector.get_check_constraints()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_check_constraints
    "sqlalchemy.engine.reflection.Inspector.get_check_constraints") may include an
    additional entry `dialect_options` which within will contain an entry `"not_valid":
    True` if this symbol is detected. Pull request courtesy Bill Finn.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4824](https://www.sqlalchemy.org/trac/ticket/4824)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[postgresql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Revised the approach for the just added support for the psycopg2 “execute_values()”
    feature added in 1.3.7 for [#4623](https://www.sqlalchemy.org/trac/ticket/4623).
    The approach relied upon a regular expression that would fail to match for a more
    complex INSERT statement such as one which had subqueries involved. The new approach
    matches exactly the string that was rendered as the VALUES clause.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4623](https://www.sqlalchemy.org/trac/ticket/4623)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[postgresql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug where Postgresql operators such as [`Comparator.contains()`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY.Comparator.contains
    "sqlalchemy.dialects.postgresql.ARRAY.Comparator.contains") and [`Comparator.contained_by()`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY.Comparator.contained_by
    "sqlalchemy.dialects.postgresql.ARRAY.Comparator.contained_by") would fail to
    function correctly for non-integer values when used against a [`array`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.array
    "sqlalchemy.dialects.postgresql.array") object, due to an erroneous assert statement.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4822](https://www.sqlalchemy.org/trac/ticket/4822)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sqlite
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[sqlite] [bug] [reflection]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug where a FOREIGN KEY that was set up to refer to the parent table by
    table name only without the column names would not correctly be reflected as far
    as setting up the “referred columns”, since SQLite’s PRAGMA does not report on
    these columns if they weren’t given explicitly. For some reason this was hardcoded
    to assume the name of the local column, which might work for some cases but is
    not correct. The new approach reflects the primary key of the referred table and
    uses the constraint columns list as the referred columns list, if the remote column(s)
    aren’t present in the reflected pragma directly.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4810](https://www.sqlalchemy.org/trac/ticket/4810)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 1.3.7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Released: August 14, 2019'
  prefs: []
  type: TYPE_NORMAL
- en: orm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed regression caused by new selectinload for many-to-one logic where a primaryjoin
    condition not based on real foreign keys would cause KeyError if a related object
    did not exist for a given key value on the parent object.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4777](https://www.sqlalchemy.org/trac/ticket/4777)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug where using [`Query.first()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.first
    "sqlalchemy.orm.Query.first") or a slice expression in conjunction with a query
    that has an expression based “offset” applied would raise TypeError, due to an
    “or” conditional against “offset” that did not expect it to be a SQL expression
    as opposed to an integer or None.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4803](https://www.sqlalchemy.org/trac/ticket/4803)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[sql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue where [`Index`](../core/constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index") object which contained a mixture of functional expressions
    which were not resolvable to a particular column, in combination with string-based
    column names, would fail to initialize its internal state correctly leading to
    failures during DDL compilation.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4778](https://www.sqlalchemy.org/trac/ticket/4778)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[sql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug where [`TypeEngine.column_expression()`](../core/type_api.html#sqlalchemy.types.TypeEngine.column_expression
    "sqlalchemy.types.TypeEngine.column_expression") method would not be applied to
    subsequent SELECT statements inside of a UNION or other `_selectable.CompoundSelect`,
    even though the SELECT statements are rendered at the topmost level of the statement.
    New logic now differentiates between rendering the column expression, which is
    needed for all SELECTs in the list, vs. gathering the returned data type for the
    result row, which is needed only for the first SELECT.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4787](https://www.sqlalchemy.org/trac/ticket/4787)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[sql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue where internal cloning of SELECT constructs could lead to a key
    error if the copy of the SELECT changed its state such that its list of columns
    changed. This was observed to be occurring in some ORM scenarios which may be
    unique to 1.3 and above, so is partially a regression fix.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4780](https://www.sqlalchemy.org/trac/ticket/4780)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: postgresql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[postgresql] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added new dialect flag for the psycopg2 dialect, `executemany_mode` which supersedes
    the previous experimental `use_batch_mode` flag. `executemany_mode` supports both
    the “execute batch” and “execute values” functions provided by psycopg2, the latter
    which is used for compiled [`insert()`](../core/dml.html#sqlalchemy.sql.expression.insert
    "sqlalchemy.sql.expression.insert") constructs. Pull request courtesy Yuval Dinari.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Psycopg2 Fast Execution Helpers](../dialects/postgresql.html#psycopg2-executemany-mode)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4623](https://www.sqlalchemy.org/trac/ticket/4623)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: mysql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[mysql] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added reserved words ARRAY and MEMBER to the MySQL reserved words list, as MySQL
    8.0 has now made these reserved.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4783](https://www.sqlalchemy.org/trac/ticket/4783)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[mysql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The MySQL dialects will emit “SET NAMES” at the start of a connection when charset
    is given to the MySQL driver, to appease an apparent behavior observed in MySQL
    8.0 that raises a collation error when a UNION includes string columns unioned
    against columns of the form CAST(NULL AS CHAR(..)), which is what SQLAlchemy’s
    polymorphic_union function does. The issue seems to have affected PyMySQL for
    at least a year, however has recently appeared as of mysqlclient 1.4.4 based on
    changes in how this DBAPI creates a connection. As the presence of this directive
    impacts three separate MySQL charset settings which each have intricate effects
    based on their presence, SQLAlchemy will now emit the directive on new connections
    to ensure correct behavior.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4804](https://www.sqlalchemy.org/trac/ticket/4804)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[mysql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added another fix for an upstream MySQL 8 issue where a case sensitive table
    name is reported incorrectly in foreign key constraint reflection, this is an
    extension of the fix first added for [#4344](https://www.sqlalchemy.org/trac/ticket/4344)
    which affects a case sensitive column name. The new issue occurs through MySQL
    8.0.17, so the general logic of the 88718 fix remains in place.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[https://bugs.mysql.com/bug.php?id=96365](https://bugs.mysql.com/bug.php?id=96365)
    - upstream bug'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4751](https://www.sqlalchemy.org/trac/ticket/4751)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sqlite
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[sqlite] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The dialects that support json are supposed to take arguments `json_serializer`
    and `json_deserializer` at the create_engine() level, however the SQLite dialect
    calls them `_json_serializer` and `_json_deserilalizer`. The names have been corrected,
    the old names are accepted with a change warning, and these parameters are now
    documented as [`create_engine.json_serializer`](../core/engines.html#sqlalchemy.create_engine.params.json_serializer
    "sqlalchemy.create_engine") and [`create_engine.json_deserializer`](../core/engines.html#sqlalchemy.create_engine.params.json_deserializer
    "sqlalchemy.create_engine").
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4798](https://www.sqlalchemy.org/trac/ticket/4798)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[sqlite] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug where usage of “PRAGMA table_info” in SQLite dialect meant that reflection
    features to detect for table existence, list of table columns, and list of foreign
    keys, would default to any table in any attached database, when no schema name
    was given and the table did not exist in the base schema. The fix explicitly runs
    PRAGMA for the ‘main’ schema and then the ‘temp’ schema if the ‘main’ returned
    no rows, to maintain the behavior of tables + temp tables in the “no schema” namespace,
    attached tables only in the “schema” namespace.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4793](https://www.sqlalchemy.org/trac/ticket/4793)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: mssql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[mssql] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added new [`try_cast()`](../dialects/mssql.html#sqlalchemy.dialects.mssql.try_cast
    "sqlalchemy.dialects.mssql.try_cast") construct for SQL Server which emits “TRY_CAST”
    syntax. Pull request courtesy Leonel Atencio.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4782](https://www.sqlalchemy.org/trac/ticket/4782)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: misc
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[bug] [events]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue in event system where using the `once=True` flag with dynamically
    generated listener functions would cause event registration of future events to
    fail if those listener functions were garbage collected after they were used,
    due to an assumption that a listened function is strongly referenced. The “once”
    wrapped is now modified to strongly reference the inner function persistently,
    and documentation is updated that using “once” does not imply automatic de-registration
    of listener functions.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4794](https://www.sqlalchemy.org/trac/ticket/4794)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 1.3.6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Released: July 21, 2019'
  prefs: []
  type: TYPE_NORMAL
- en: orm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[orm] [feature]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added new loader option method [`Load.options()`](../orm/queryguide/relationships.html#sqlalchemy.orm.Load.options
    "sqlalchemy.orm.Load.options") which allows loader options to be constructed hierarchically,
    so that many sub-options can be applied to a particular path without needing to
    call [`defaultload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.defaultload
    "sqlalchemy.orm.defaultload") many times. Thanks to Alessio Bogon for the idea.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4736](https://www.sqlalchemy.org/trac/ticket/4736)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [performance]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The optimization applied to selectin loading in [#4340](https://www.sqlalchemy.org/trac/ticket/4340)
    where a JOIN is not needed to eagerly load related items is now applied to many-to-one
    relationships as well, so that only the related table is queried for a simple
    join condition. In this case, the related items are queried based on the value
    of a foreign key column on the parent; if these columns are deferred or otherwise
    not loaded on any of the parent objects in the collection, the loader falls back
    to the JOIN method.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4775](https://www.sqlalchemy.org/trac/ticket/4775)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed regression caused by [#4365](https://www.sqlalchemy.org/trac/ticket/4365)
    where a join from an entity to itself without using aliases no longer raises an
    informative error message, instead failing on an assertion. The informative error
    condition has been restored.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4773](https://www.sqlalchemy.org/trac/ticket/4773)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed an issue where the `_ORMJoin.join()` method, which is a not-internally-used
    ORM-level method that exposes what is normally an internal process of [`Query.join()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join"), did not propagate the `full` and `outerjoin` keyword
    arguments correctly. Pull request courtesy Denis Kataev.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4713](https://www.sqlalchemy.org/trac/ticket/4713)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug where a many-to-one relationship that specified `uselist=True` would
    fail to update correctly during a primary key change where a related column needs
    to change.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4772](https://www.sqlalchemy.org/trac/ticket/4772)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug where the detection for many-to-one or one-to-one use with a “dynamic”
    relationship, which is an invalid configuration, would fail to raise if the relationship
    were configured with `uselist=True`. The current fix is that it warns, instead
    of raises, as this would otherwise be backwards incompatible, however in a future
    release it will be a raise.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4772](https://www.sqlalchemy.org/trac/ticket/4772)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug where a synonym created against a mapped attribute that does not exist
    yet, as is the case when it refers to backref before mappers are configured, would
    raise recursion errors when trying to test for attributes on it which ultimately
    don’t exist (as occurs when the classes are run through Sphinx autodoc), as the
    unconfigured state of the synonym would put it into an attribute not found loop.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4767](https://www.sqlalchemy.org/trac/ticket/4767)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: engine
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[engine] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug where using reflection function such as [`MetaData.reflect()`](../core/metadata.html#sqlalchemy.schema.MetaData.reflect
    "sqlalchemy.schema.MetaData.reflect") with an [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") object that had execution options applied to it would
    fail, as the resulting `OptionEngine` proxy object failed to include a `.engine`
    attribute used within the reflection routines.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4754](https://www.sqlalchemy.org/trac/ticket/4754)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[sql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adjusted the initialization for [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum") to minimize how often it invokes the `.__members__` attribute
    of a given PEP-435 enumeration object, to suit the case where this attribute is
    expensive to invoke, as is the case for some popular third party enumeration libraries.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4758](https://www.sqlalchemy.org/trac/ticket/4758)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[sql] [bug] [postgresql]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue where the [`array_agg`](../core/functions.html#sqlalchemy.sql.functions.array_agg
    "sqlalchemy.sql.functions.array_agg") construct in combination with [`FunctionElement.filter()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.filter
    "sqlalchemy.sql.functions.FunctionElement.filter") would not produce the correct
    operator precedence in combination with the array index operator.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4760](https://www.sqlalchemy.org/trac/ticket/4760)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[sql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed an unlikely issue where the “corresponding column” routine for unions
    and other `_selectable.CompoundSelect` objects could return the wrong column in
    some overlapping column situations, thus potentially impacting some ORM operations
    when set operations are in use, if the underlying [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") constructs were used previously in other similar
    kinds of routines, due to a cached value not being cleared.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4747](https://www.sqlalchemy.org/trac/ticket/4747)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: postgresql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[postgresql] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added support for reflection of indexes on PostgreSQL partitioned tables, which
    was added to PostgreSQL as of version 11.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4771](https://www.sqlalchemy.org/trac/ticket/4771)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[postgresql] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added support for multidimensional Postgresql array literals via nesting the
    [`array`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.array "sqlalchemy.dialects.postgresql.array")
    object within another one. The multidimensional array type is detected automatically.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`array`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.array
    "sqlalchemy.dialects.postgresql.array")'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4756](https://www.sqlalchemy.org/trac/ticket/4756)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: mysql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[mysql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug where the special logic to render “NULL” for the [`TIMESTAMP`](../core/type_basics.html#sqlalchemy.types.TIMESTAMP
    "sqlalchemy.types.TIMESTAMP") datatype when `nullable=True` would not work if
    the column’s datatype were a [`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") or a [`Variant`](../core/type_api.html#sqlalchemy.types.Variant
    "sqlalchemy.types.Variant"). The logic now ensures that it unwraps down to the
    original [`TIMESTAMP`](../core/type_basics.html#sqlalchemy.types.TIMESTAMP "sqlalchemy.types.TIMESTAMP")
    so that this special case NULL keyword is correctly rendered when requested.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4743](https://www.sqlalchemy.org/trac/ticket/4743)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[mysql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enhanced MySQL/MariaDB version string parsing to accommodate for exotic MariaDB
    version strings where the “MariaDB” word is embedded among other alphanumeric
    characters such as “MariaDBV1”. This detection is critical in order to correctly
    accommodate for API features that have split between MySQL and MariaDB such as
    the “transaction_isolation” system variable.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4624](https://www.sqlalchemy.org/trac/ticket/4624)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sqlite
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[sqlite] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added support for composite (tuple) IN operators with SQLite, by rendering the
    VALUES keyword for this backend. As other backends such as DB2 are known to use
    the same syntax, the syntax is enabled in the base compiler using a dialect-level
    flag `tuple_in_values`. The change also includes support for “empty IN tuple”
    expressions for SQLite when using “in_()” between a tuple value and an empty set.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4766](https://www.sqlalchemy.org/trac/ticket/4766)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: mssql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[mssql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensured that the queries used to reflect indexes and view definitions will explicitly
    CAST string parameters into NVARCHAR, as many SQL Server drivers frequently treat
    string values, particularly those with non-ascii characters or larger string values,
    as TEXT which often don’t compare correctly against VARCHAR characters in SQL
    Server’s information schema tables for some reason. These CAST operations already
    take place for reflection queries against SQL Server `information_schema.` tables
    but were missing from three additional queries that are against `sys.` tables.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4745](https://www.sqlalchemy.org/trac/ticket/4745)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 1.3.5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Released: June 17, 2019'
  prefs: []
  type: TYPE_NORMAL
- en: orm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed a series of related bugs regarding joined table inheritance more than
    two levels deep, in conjunction with modification to primary key values, where
    those primary key columns are also linked together in a foreign key relationship
    as is typical for joined table inheritance. The intermediary table in a three-level
    inheritance hierarchy will now get its UPDATE if only the primary key value has
    changed and passive_updates=False (e.g. foreign key constraints not being enforced),
    whereas before it would be skipped; similarly, with passive_updates=True (e.g.
    ON UPDATE CASCADE in effect), the third-level table will not receive an UPDATE
    statement as was the case earlier which would fail since CASCADE already modified
    it. In a related issue, a relationship linked to a three-level inheritance hierarchy
    on the primary key of an intermediary table of a joined-inheritance hierarchy
    will also correctly have its foreign key column updated when the parent object’s
    primary key is modified, even if that parent object is a subclass of the linked
    parent class, whereas before these classes would not be counted.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4723](https://www.sqlalchemy.org/trac/ticket/4723)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug where the [`Mapper.all_orm_descriptors`](../orm/mapping_api.html#sqlalchemy.orm.Mapper.all_orm_descriptors
    "sqlalchemy.orm.Mapper.all_orm_descriptors") accessor would return an entry for
    the [`Mapper`](../orm/mapping_api.html#sqlalchemy.orm.Mapper "sqlalchemy.orm.Mapper")
    itself under the declarative `__mapper__` key, when this is not a descriptor.
    The `.is_attribute` flag that’s present on all [`InspectionAttr`](../orm/internals.html#sqlalchemy.orm.InspectionAttr
    "sqlalchemy.orm.InspectionAttr") objects is now consulted, which has also been
    modified to be `True` for an association proxy, as it was erroneously set to False
    for this object.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4729](https://www.sqlalchemy.org/trac/ticket/4729)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed regression in [`Query.join()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join") where the `aliased=True` flag would not properly
    apply clause adaptation to filter criteria, if a previous join were made to the
    same entity. This is because the adapters were placed in the wrong order. The
    order has been reversed so that the adapter for the most recent `aliased=True`
    call takes precedence as was the case in 1.2 and earlier. This broke the “elementtree”
    examples among other things.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4704](https://www.sqlalchemy.org/trac/ticket/4704)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug] [py3k]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replaced the Python compatibility routines for `getfullargspec()` with a fully
    vendored version from Python 3.3\. Originally, Python was emitting deprecation
    warnings for this function in Python 3.8 alphas. While this change was reverted,
    it was observed that Python 3 implementations for `getfullargspec()` are an order
    of magnitude slower as of the 3.4 series where it was rewritten against `Signature`.
    While Python plans to improve upon this situation, SQLAlchemy projects for now
    are using a simple replacement to avoid any future issues.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4674](https://www.sqlalchemy.org/trac/ticket/4674)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reworked the attribute mechanics used by [`AliasedClass`](../orm/queryguide/api.html#sqlalchemy.orm.util.AliasedClass
    "sqlalchemy.orm.util.AliasedClass") to no longer rely upon calling `__getattribute__`
    on the MRO of the wrapped class, and to instead resolve the attribute normally
    on the wrapped class using getattr(), and then unwrap/adapt that. This allows
    a greater range of attribute styles on the mapped class including special `__getattr__()`
    schemes; but it also makes the code simpler and more resilient in general.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4694](https://www.sqlalchemy.org/trac/ticket/4694)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[sql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Addressed a range of quoting issues originating from the use of the `literal_column`()`
    construct. When this construct is “proxied” through a subquery and referred to
    by a label matching its text, the label does not have quoting rules applied to
    it, even if the string in the [`Label`](../core/sqlelement.html#sqlalchemy.sql.expression.Label
    "sqlalchemy.sql.expression.Label") was set up using a `quoted_name`` construct.
    Not applying quoting to the text of the [`Label`](../core/sqlelement.html#sqlalchemy.sql.expression.Label
    "sqlalchemy.sql.expression.Label") is a bug because this text is strictly a SQL
    identifier name and not a SQL expression, and the string should not have quotes
    embedded into it already unlike the [`literal_column()`](../core/sqlelement.html#sqlalchemy.sql.expression.literal_column
    "sqlalchemy.sql.expression.literal_column") which it may be applied towards. The
    existing behavior of a non-labeled [`literal_column()`](../core/sqlelement.html#sqlalchemy.sql.expression.literal_column
    "sqlalchemy.sql.expression.literal_column") being propagated as is on the outside
    of a subquery is maintained in order to help with manual quoting schemes, although
    it’s not clear if valid SQL can be generated for such a construct in any case.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4730](https://www.sqlalchemy.org/trac/ticket/4730)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: postgresql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[postgresql] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added support for column sorting flags when reflecting indexes for PostgreSQL,
    including ASC, DESC, NULLSFIRST, NULLSLAST. Also adds this facility to the reflection
    system in general which can be applied to other dialects in future releases. Pull
    request courtesy Eli Collins.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4717](https://www.sqlalchemy.org/trac/ticket/4717)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[postgresql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug where PostgreSQL dialect could not correctly reflect an ENUM datatype
    that has no members, returning a list with `None` for the `get_enums()` call and
    raising a TypeError when reflecting a column which has such a datatype. The inspection
    now returns an empty list.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4701](https://www.sqlalchemy.org/trac/ticket/4701)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: mysql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[mysql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug where MySQL ON DUPLICATE KEY UPDATE would not accommodate setting
    a column to the value NULL. Pull request courtesy Lukáš Banič.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4715](https://www.sqlalchemy.org/trac/ticket/4715)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 1.3.4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Released: May 27, 2019'
  prefs: []
  type: TYPE_NORMAL
- en: orm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue where the [`AttributeEvents.active_history`](../orm/events.html#sqlalchemy.orm.AttributeEvents.params.active_history
    "sqlalchemy.orm.AttributeEvents") flag would not be set for an event listener
    that propagated to a subclass via the [`AttributeEvents.propagate`](../orm/events.html#sqlalchemy.orm.AttributeEvents.params.propagate
    "sqlalchemy.orm.AttributeEvents") flag. This bug has been present for the full
    span of the [`AttributeEvents`](../orm/events.html#sqlalchemy.orm.AttributeEvents
    "sqlalchemy.orm.AttributeEvents") system.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4695](https://www.sqlalchemy.org/trac/ticket/4695)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed regression where new association proxy system was still not proxying hybrid
    attributes when they made use of the `@hybrid_property.expression` decorator to
    return an alternate SQL expression, or when the hybrid returned an arbitrary [`PropComparator`](../orm/internals.html#sqlalchemy.orm.PropComparator
    "sqlalchemy.orm.PropComparator"), at the expression level. This involved further
    generalization of the heuristics used to detect the type of object being proxied
    at the level of [`QueryableAttribute`](../orm/internals.html#sqlalchemy.orm.QueryableAttribute
    "sqlalchemy.orm.QueryableAttribute"), to better detect if the descriptor ultimately
    serves mapped classes or column expressions.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4690](https://www.sqlalchemy.org/trac/ticket/4690)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applied the mapper “configure mutex” against the declarative class mapping process,
    to guard against the race which can occur if mappers are used while dynamic module
    import schemes are still in the process of configuring mappers for related classes.
    This does not guard against all possible race conditions, such as if the concurrent
    import has not yet encountered the dependent classes as of yet, however it guards
    against as much as possible within the SQLAlchemy declarative process.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4686](https://www.sqlalchemy.org/trac/ticket/4686)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A warning is now emitted for the case where a transient object is being merged
    into the session with [`Session.merge()`](../orm/session_api.html#sqlalchemy.orm.Session.merge
    "sqlalchemy.orm.Session.merge") when that object is already transient in the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"). This warns for the case where the object would normally
    be double-inserted.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4647](https://www.sqlalchemy.org/trac/ticket/4647)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed regression in new relationship m2o comparison logic first introduced at
    [Improvement to the behavior of many-to-one query expressions](migration_13.html#change-4359)
    when comparing to an attribute that is persisted as NULL and is in an un-fetched
    state in the mapped instance. Since the attribute has no explicit default, it
    needs to default to NULL when accessed in a persistent setting.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4676](https://www.sqlalchemy.org/trac/ticket/4676)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: engine
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[engine] [bug] [postgresql]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moved the “rollback” which occurs during dialect initialization so that it occurs
    after additional dialect-specific initialize steps, in particular those of the
    psycopg2 dialect which would inadvertently leave transactional state on the first
    new connection, which could interfere with some psycopg2-specific APIs which require
    that no transaction is started. Pull request courtesy Matthew Wilkes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4663](https://www.sqlalchemy.org/trac/ticket/4663)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[sql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed that the [`GenericFunction`](../core/functions.html#sqlalchemy.sql.functions.GenericFunction
    "sqlalchemy.sql.functions.GenericFunction") class was inadvertently registering
    itself as one of the named functions. Pull request courtesy Adrien Berchet.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4653](https://www.sqlalchemy.org/trac/ticket/4653)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[sql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue where double negation of a boolean column wouldn’t reset the “NOT”
    operator.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4618](https://www.sqlalchemy.org/trac/ticket/4618)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[sql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [`GenericFunction`](../core/functions.html#sqlalchemy.sql.functions.GenericFunction
    "sqlalchemy.sql.functions.GenericFunction") namespace is being migrated so that
    function names are looked up in a case-insensitive manner, as SQL functions do
    not collide on case sensitive differences nor is this something which would occur
    with user-defined functions or stored procedures. Lookups for functions declared
    with [`GenericFunction`](../core/functions.html#sqlalchemy.sql.functions.GenericFunction
    "sqlalchemy.sql.functions.GenericFunction") now use a case insensitive scheme,
    however a deprecation case is supported which allows two or more [`GenericFunction`](../core/functions.html#sqlalchemy.sql.functions.GenericFunction
    "sqlalchemy.sql.functions.GenericFunction") objects with the same name of different
    cases to exist, which will cause case sensitive lookups to occur for that particular
    name, while emitting a warning at function registration time. Thanks to Adrien
    Berchet for a lot of work on this complicated feature.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4569](https://www.sqlalchemy.org/trac/ticket/4569)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: postgresql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[postgresql] [bug] [orm]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed an issue where the “number of rows matched” warning would emit even if
    the dialect reported “supports_sane_multi_rowcount=False”, as is the case for
    psycogp2 with `use_batch_mode=True` and others.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4661](https://www.sqlalchemy.org/trac/ticket/4661)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: mysql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[mysql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added support for DROP CHECK constraint which is required by MySQL 8.0.16 to
    drop a CHECK constraint; MariaDB supports plain DROP CONSTRAINT. The logic distinguishes
    between the two syntaxes by checking the server version string for MariaDB presence.
    Alembic migrations has already worked around this issue by implementing its own
    DROP for MySQL / MariaDB CHECK constraints, however this change implements it
    straight in Core so that its available for general use. Pull request courtesy
    Hannes Hansen.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4650](https://www.sqlalchemy.org/trac/ticket/4650)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: mssql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[mssql] [feature]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added support for SQL Server filtered indexes, via the `mssql_where` parameter
    which works similarly to that of the `postgresql_where` index function in the
    PostgreSQL dialect.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Filtered Indexes](../dialects/mssql.html#mssql-index-where)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4657](https://www.sqlalchemy.org/trac/ticket/4657)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[mssql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added error code 20047 to “is_disconnect” for pymssql. Pull request courtesy
    Jon Schuff.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4680](https://www.sqlalchemy.org/trac/ticket/4680)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: misc
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[misc] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removed errant “sqla_nose.py” symbol from MANIFEST.in which created an undesirable
    warning message.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4625](https://www.sqlalchemy.org/trac/ticket/4625)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 1.3.3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Released: April 15, 2019'
  prefs: []
  type: TYPE_NORMAL
- en: orm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed 1.3 regression in new “ambiguous FROMs” query logic introduced in [Query.join()
    handles ambiguity in deciding the “left” side more explicitly](migration_13.html#change-4365)
    where a [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    that explicitly places an entity in the FROM clause with [`Query.select_from()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.select_from
    "sqlalchemy.orm.Query.select_from") and also joins to it using [`Query.join()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join") would later cause an “ambiguous FROM” error if that
    entity were used in additional joins, as the entity appears twice in the “from”
    list of the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query").
    The fix resolves this ambiguity by folding the standalone entity into the join
    that it’s already a part of in the same way that ultimately happens when the SELECT
    statement is rendered.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4584](https://www.sqlalchemy.org/trac/ticket/4584)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adjusted the [`Query.filter_by()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.filter_by
    "sqlalchemy.orm.Query.filter_by") method to not call `and()` internally against
    multiple criteria, instead passing it off to [`Query.filter()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.filter
    "sqlalchemy.orm.Query.filter") as a series of criteria, instead of a single criteria.
    This allows [`Query.filter_by()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.filter_by
    "sqlalchemy.orm.Query.filter_by") to defer to [`Query.filter()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.filter
    "sqlalchemy.orm.Query.filter")’s treatment of variable numbers of clauses, including
    the case where the list is empty. In this case, the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object will not have a `.whereclause`, which allows subsequent
    “no whereclause” methods like [`Query.select_from()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.select_from
    "sqlalchemy.orm.Query.select_from") to behave consistently.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4606](https://www.sqlalchemy.org/trac/ticket/4606)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: postgresql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[postgresql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed regression from release 1.3.2 caused by [#4562](https://www.sqlalchemy.org/trac/ticket/4562)
    where a URL that contained only a query string and no hostname, such as for the
    purposes of specifying a service file with connection information, would no longer
    be propagated to psycopg2 properly. The change in [#4562](https://www.sqlalchemy.org/trac/ticket/4562)
    has been adjusted to further suit psycopg2’s exact requirements, which is that
    if there are any connection parameters whatsoever, the “dsn” parameter is no longer
    required, so in this case the query string parameters are passed alone.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4601](https://www.sqlalchemy.org/trac/ticket/4601)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: mssql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[mssql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue in SQL Server dialect where if a bound parameter were present in
    an ORDER BY expression that would ultimately not be rendered in the SQL Server
    version of the statement, the parameters would still be part of the execution
    parameters, leading to DBAPI-level errors. Pull request courtesy Matt Lewellyn.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4587](https://www.sqlalchemy.org/trac/ticket/4587)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: misc
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[bug] [pool]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed behavioral regression as a result of deprecating the “use_threadlocal”
    flag for [`Pool`](../core/pooling.html#sqlalchemy.pool.Pool "sqlalchemy.pool.Pool"),
    where the [`SingletonThreadPool`](../core/pooling.html#sqlalchemy.pool.SingletonThreadPool
    "sqlalchemy.pool.SingletonThreadPool") no longer makes use of this option which
    causes the “rollback on return” logic to take place when the same [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") is used multiple times in the context of a transaction
    to connect or implicitly execute, thereby cancelling the transaction. While this
    is not the recommended way to work with engines and connections, it is nonetheless
    a confusing behavioral change as when using [`SingletonThreadPool`](../core/pooling.html#sqlalchemy.pool.SingletonThreadPool
    "sqlalchemy.pool.SingletonThreadPool"), the transaction should stay open regardless
    of what else is done with the same engine in the same thread. The `use_threadlocal`
    flag remains deprecated however the [`SingletonThreadPool`](../core/pooling.html#sqlalchemy.pool.SingletonThreadPool
    "sqlalchemy.pool.SingletonThreadPool") now implements its own version of the same
    logic.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4585](https://www.sqlalchemy.org/trac/ticket/4585)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[bug] [ext]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug where using `copy.copy()` or `copy.deepcopy()` on [`MutableList`](../orm/extensions/mutable.html#sqlalchemy.ext.mutable.MutableList
    "sqlalchemy.ext.mutable.MutableList") would cause the items within the list to
    be duplicated, due to an inconsistency in how Python pickle and copy both make
    use of `__getstate__()` and `__setstate__()` regarding lists. In order to resolve,
    a `__reduce_ex__` method had to be added to [`MutableList`](../orm/extensions/mutable.html#sqlalchemy.ext.mutable.MutableList
    "sqlalchemy.ext.mutable.MutableList"). In order to maintain backwards compatibility
    with existing pickles based on `__getstate__()`, the `__setstate__()` method remains
    as well; the test suite asserts that pickles made against the old version of the
    class can still be deserialized by the pickle module.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4603](https://www.sqlalchemy.org/trac/ticket/4603)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 1.3.2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Released: April 2, 2019'
  prefs: []
  type: TYPE_NORMAL
- en: orm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[orm] [bug] [ext]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Restored instance-level support for plain Python descriptors, e.g. `@property`
    objects, in conjunction with association proxies, in that if the proxied object
    is not within ORM scope at all, it gets classified as “ambiguous” but is proxed
    directly. For class level access, a basic class level``__get__()`` now returns
    the `AmbiguousAssociationProxyInstance` directly, rather than raising its exception,
    which is the closest approximation to the previous behavior that returned the
    [`AssociationProxy`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy
    "sqlalchemy.ext.associationproxy.AssociationProxy") itself that’s possible. Also
    improved the stringification of these objects to be more descriptive of current
    state.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4573](https://www.sqlalchemy.org/trac/ticket/4573), [#4574](https://www.sqlalchemy.org/trac/ticket/4574)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug where use of [`with_polymorphic()`](../orm/queryguide/inheritance.html#sqlalchemy.orm.with_polymorphic
    "sqlalchemy.orm.with_polymorphic") or other aliased construct would not properly
    adapt when the aliased target were used as the [`Select.correlate_except()`](../core/selectable.html#sqlalchemy.sql.expression.Select.correlate_except
    "sqlalchemy.sql.expression.Select.correlate_except") target of a subquery used
    inside of a [`column_property()`](../orm/mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property"). This required a fix to the clause adaption
    mechanics to properly handle a selectable that shows up in the “correlate except”
    list, in a similar manner as which occurs for selectables that show up in the
    “correlate” list. This is ultimately a fairly fundamental bug that has lasted
    for a long time but it is hard to come across it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4537](https://www.sqlalchemy.org/trac/ticket/4537)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed regression where a new error message that was supposed to raise when attempting
    to link a relationship option to an AliasedClass without using [`PropComparator.of_type()`](../orm/internals.html#sqlalchemy.orm.PropComparator.of_type
    "sqlalchemy.orm.PropComparator.of_type") would instead raise an `AttributeError`.
    Note that in 1.3, it is no longer valid to create an option path from a plain
    mapper relationship to an [`AliasedClass`](../orm/queryguide/api.html#sqlalchemy.orm.util.AliasedClass
    "sqlalchemy.orm.util.AliasedClass") without using [`PropComparator.of_type()`](../orm/internals.html#sqlalchemy.orm.PropComparator.of_type
    "sqlalchemy.orm.PropComparator.of_type").
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4566](https://www.sqlalchemy.org/trac/ticket/4566)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[sql] [bug] [documentation]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thanks to [TypeEngine methods bind_expression, column_expression work with Variant,
    type-specific types](migration_13.html#change-3981), we no longer need to rely
    on recipes that subclass dialect-specific types directly, [`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") can now handle all cases. Additionally, the
    above change made it slightly less likely that a direct subclass of a base SQLAlchemy
    type would work as expected, which could be misleading. Documentation has been
    updated to use [`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") for these examples including the PostgreSQL
    “ArrayOfEnum” example datatype and direct support for the “subclass a type directly”
    has been removed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4580](https://www.sqlalchemy.org/trac/ticket/4580)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: postgresql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[postgresql] [feature]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added support for parameter-less connection URLs for the psycopg2 dialect, meaning,
    the URL can be passed to [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") as `"postgresql+psycopg2://"` with no additional arguments
    to indicate an empty DSN passed to libpq, which indicates to connect to “localhost”
    with no username, password, or database given. Pull request courtesy Julian Mehnle.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4562](https://www.sqlalchemy.org/trac/ticket/4562)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[postgresql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modified the [`Select.with_for_update.of`](../core/selectable.html#sqlalchemy.sql.expression.Select.with_for_update.params.of
    "sqlalchemy.sql.expression.Select.with_for_update") parameter so that if a join
    or other composed selectable is passed, the individual [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects will be filtered from it, allowing one to pass
    a join() object to the parameter, as occurs normally when using joined table inheritance
    with the ORM. Pull request courtesy Raymond Lu.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4550](https://www.sqlalchemy.org/trac/ticket/4550)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 1.3.1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Released: March 9, 2019'
  prefs: []
  type: TYPE_NORMAL
- en: orm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[orm] [bug] [ext]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed regression where an association proxy linked to a synonym would no longer
    work, both at instance level and at class level.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4522](https://www.sqlalchemy.org/trac/ticket/4522)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: mssql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[mssql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A commit() is emitted after an isolation level change to SNAPSHOT, as both pyodbc
    and pymssql open an implicit transaction which blocks subsequent SQL from being
    emitted in the current transaction.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This change is also **backported** to: 1.2.19'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4536](https://www.sqlalchemy.org/trac/ticket/4536)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[mssql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed regression in SQL Server reflection due to [#4393](https://www.sqlalchemy.org/trac/ticket/4393)
    where the removal of open-ended `**kw` from the [`Float`](../core/type_basics.html#sqlalchemy.types.Float
    "sqlalchemy.types.Float") datatype caused reflection of this type to fail due
    to a “scale” argument being passed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4525](https://www.sqlalchemy.org/trac/ticket/4525)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 1.3.0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Released: March 4, 2019'
  prefs: []
  type: TYPE_NORMAL
- en: orm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[orm] [feature]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [`Query.get()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.get "sqlalchemy.orm.Query.get")
    method can now accept a dictionary of attribute keys and values as a means of
    indicating the primary key value to load; is particularly useful for composite
    primary keys. Pull request courtesy Sanjana S.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4316](https://www.sqlalchemy.org/trac/ticket/4316)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [feature]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A SQL expression can now be assigned to a primary key attribute for an ORM flush
    in the same manner as ordinary attributes as described in [Embedding SQL Insert/Update
    Expressions into a Flush](../orm/persistence_techniques.html#flush-embedded-sql-expressions)
    where the expression will be evaluated and then returned to the ORM using RETURNING,
    or in the case of pysqlite, works using the cursor.lastrowid attribute.Requires
    either a database that supports RETURNING (e.g. Postgresql, Oracle, SQL Server)
    or pysqlite.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#3133](https://www.sqlalchemy.org/trac/ticket/3133)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: engine
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[engine] [feature]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Revised the formatting for [`StatementError`](../core/exceptions.html#sqlalchemy.exc.StatementError
    "sqlalchemy.exc.StatementError") when stringified. Each error detail is broken
    up over multiple newlines instead of spaced out on a single line. Additionally,
    the SQL representation now stringifies the SQL statement rather than using `repr()`,
    so that newlines are rendered as is. Pull request courtesy Nate Clark.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Changed StatementError formatting (newlines and %s)](migration_13.html#change-4500)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4500](https://www.sqlalchemy.org/trac/ticket/4500)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[sql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [`Alias`](../core/selectable.html#sqlalchemy.sql.expression.Alias "sqlalchemy.sql.expression.Alias")
    class and related subclasses [`CTE`](../core/selectable.html#sqlalchemy.sql.expression.CTE
    "sqlalchemy.sql.expression.CTE"), [`Lateral`](../core/selectable.html#sqlalchemy.sql.expression.Lateral
    "sqlalchemy.sql.expression.Lateral") and [`TableSample`](../core/selectable.html#sqlalchemy.sql.expression.TableSample
    "sqlalchemy.sql.expression.TableSample") have been reworked so that it is not
    possible for a user to construct the objects directly. These constructs require
    that the standalone construction function or selectable-bound method be used to
    instantiate new objects.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4509](https://www.sqlalchemy.org/trac/ticket/4509)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: schema
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[schema] [feature]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added new parameters [`Table.resolve_fks`](../core/metadata.html#sqlalchemy.schema.Table.params.resolve_fks
    "sqlalchemy.schema.Table") and [`MetaData.reflect.resolve_fks`](../core/metadata.html#sqlalchemy.schema.MetaData.reflect.params.resolve_fks
    "sqlalchemy.schema.MetaData.reflect") which when set to False will disable the
    automatic reflection of related tables encountered in [`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey") objects, which can both reduce SQL overhead for
    omitted tables as well as avoid tables that can’t be reflected for database-specific
    reasons. Two [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    objects present in the same [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") collection can still refer to each other even if
    the reflection of the two tables occurred separately.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4517](https://www.sqlalchemy.org/trac/ticket/4517)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 1.3.0b3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Released: February 8, 2019'
  prefs: []
  type: TYPE_NORMAL
- en: orm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improved the behavior of [`with_polymorphic()`](../orm/queryguide/inheritance.html#sqlalchemy.orm.with_polymorphic
    "sqlalchemy.orm.with_polymorphic") in conjunction with loader options, in particular
    wildcard operations as well as [`load_only()`](../orm/queryguide/columns.html#sqlalchemy.orm.load_only
    "sqlalchemy.orm.load_only"). The polymorphic object will be more accurately targeted
    so that column-level options on the entity will correctly take effect.The issue
    is a continuation of the same kinds of things fixed in [#4468](https://www.sqlalchemy.org/trac/ticket/4468).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4469](https://www.sqlalchemy.org/trac/ticket/4469)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: orm declarative
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[orm] [declarative] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added some helper exceptions that invoke when a mapping based on [`AbstractConcreteBase`](../orm/extensions/declarative/index.html#sqlalchemy.ext.declarative.AbstractConcreteBase
    "sqlalchemy.ext.declarative.AbstractConcreteBase"), [`DeferredReflection`](../orm/extensions/declarative/index.html#sqlalchemy.ext.declarative.DeferredReflection
    "sqlalchemy.ext.declarative.DeferredReflection"), or `AutoMap` is used before
    the mapping is ready to be used, which contain descriptive information on the
    class, rather than falling through into other failure modes that are less informative.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4470](https://www.sqlalchemy.org/trac/ticket/4470)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[sql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fully removed the behavior of strings passed directly as components of a [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") or [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object being coerced to [`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text
    "sqlalchemy.sql.expression.text") constructs automatically; the warning that has
    been emitted is now an ArgumentError or in the case of order_by() / group_by()
    a CompileError. This has emitted a warning since version 1.0 however its presence
    continues to create concerns for the potential of mis-use of this behavior.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Note that public CVEs have been posted for order_by() / group_by() which are
    resolved by this commit: CVE-2019-7164 CVE-2019-7548'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Coercion of string SQL fragments to text() fully removed](migration_13.html#change-4481)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4481](https://www.sqlalchemy.org/trac/ticket/4481)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[sql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Quoting is applied to [`Function`](../core/functions.html#sqlalchemy.sql.functions.Function
    "sqlalchemy.sql.functions.Function") names, those which are usually but not necessarily
    generated from the [`sqlalchemy.sql.expression.func`](../core/sqlelement.html#sqlalchemy.sql.expression.func
    "sqlalchemy.sql.expression.func") construct, at compile time if they contain illegal
    characters, such as spaces or punctuation. The names are as before treated as
    case insensitive however, meaning if the names contain uppercase or mixed case
    characters, that alone does not trigger quoting. The case insensitivity is currently
    maintained for backwards compatibility.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4467](https://www.sqlalchemy.org/trac/ticket/4467)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[sql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added “SQL phrase validation” to key DDL phrases that are accepted as plain
    strings, including [`ForeignKeyConstraint.on_delete`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint.params.on_delete
    "sqlalchemy.schema.ForeignKeyConstraint"), [`ForeignKeyConstraint.on_update`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint.params.on_update
    "sqlalchemy.schema.ForeignKeyConstraint"), [`ExcludeConstraint.using`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ExcludeConstraint.params.using
    "sqlalchemy.dialects.postgresql.ExcludeConstraint"), [`ForeignKeyConstraint.initially`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint.params.initially
    "sqlalchemy.schema.ForeignKeyConstraint"), for areas where a series of SQL keywords
    only are expected.Any non-space characters that suggest the phrase would need
    to be quoted will raise a [`CompileError`](../core/exceptions.html#sqlalchemy.exc.CompileError
    "sqlalchemy.exc.CompileError"). This change is related to the series of changes
    committed as part of [#4481](https://www.sqlalchemy.org/trac/ticket/4481).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4481](https://www.sqlalchemy.org/trac/ticket/4481)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: postgresql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[postgresql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue where using an uppercase name for an index type (e.g. GIST, BTREE,
    etc. ) or an EXCLUDE constraint would treat it as an identifier to be quoted,
    rather than rendering it as is. The new behavior converts these types to lowercase
    and ensures they contain only valid SQL characters.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4473](https://www.sqlalchemy.org/trac/ticket/4473)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: tests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[tests] [change]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The test system has removed support for Nose, which is unmaintained for several
    years and is producing warnings under Python 3\. The test suite is currently standardized
    on Pytest. Pull request courtesy Parth Shandilya.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4460](https://www.sqlalchemy.org/trac/ticket/4460)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: misc
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[bug] [ext]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implemented a more comprehensive assignment operation (e.g. “bulk replace”)
    when using association proxy with sets or dictionaries. Fixes the problem of redundant
    proxy objects being created to replace the old ones, which leads to excessive
    events and SQL and in the case of unique constraints will cause the flush to fail.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Implemented bulk replace for sets, dicts with AssociationProxy](migration_13.html#change-2642)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#2642](https://www.sqlalchemy.org/trac/ticket/2642)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 1.3.0b2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Released: January 25, 2019'
  prefs: []
  type: TYPE_NORMAL
- en: general
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[general] [change]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A large change throughout the library has ensured that all objects, parameters,
    and behaviors which have been noted as deprecated or legacy now emit `DeprecationWarning`
    warnings when invoked.As the Python 3 interpreter now defaults to displaying deprecation
    warnings, as well as that modern test suites based on tools like tox and pytest
    tend to display deprecation warnings, this change should make it easier to note
    what API features are obsolete. A major rationale for this change is so that long-
    deprecated features that nonetheless still see continue to see real world use
    can finally be removed in the near future; the biggest example of this are the
    `SessionExtension` and `MapperExtension` classes as well as a handful of other
    pre-event extension hooks, which have been deprecated since version 0.7 but still
    remain in the library. Another is that several major longstanding behaviors are
    to be deprecated as well, including the threadlocal engine strategy, the convert_unicode
    flag, and non primary mappers.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Deprecation warnings are emitted for all deprecated elements; new deprecations
    added](migration_13.html#change-4393-general)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4393](https://www.sqlalchemy.org/trac/ticket/4393)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: orm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[orm] [feature]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implemented a new feature whereby the [`AliasedClass`](../orm/queryguide/api.html#sqlalchemy.orm.util.AliasedClass
    "sqlalchemy.orm.util.AliasedClass") construct can now be used as the target of
    a [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship"). This allows the concept of “non primary mappers”
    to no longer be necessary, as the [`AliasedClass`](../orm/queryguide/api.html#sqlalchemy.orm.util.AliasedClass
    "sqlalchemy.orm.util.AliasedClass") is much easier to configure and automatically
    inherits all the relationships of the mapped class, as well as preserves the ability
    for loader options to work normally.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Relationship to AliasedClass replaces the need for non primary mappers](migration_13.html#change-4423)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4423](https://www.sqlalchemy.org/trac/ticket/4423)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [feature]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added new [`MapperEvents.before_mapper_configured()`](../orm/events.html#sqlalchemy.orm.MapperEvents.before_mapper_configured
    "sqlalchemy.orm.MapperEvents.before_mapper_configured") event. This event complements
    the other “configure” stage mapper events with a per mapper event that receives
    each [`Mapper`](../orm/mapping_api.html#sqlalchemy.orm.Mapper "sqlalchemy.orm.Mapper")
    right before its configure step, and additionally may be used to prevent or delay
    the configuration of specific [`Mapper`](../orm/mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper") objects using a new return value `interfaces.EXT_SKIP`.
    See the documentation link for an example.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`MapperEvents.before_mapper_configured()`](../orm/events.html#sqlalchemy.orm.MapperEvents.before_mapper_configured
    "sqlalchemy.orm.MapperEvents.before_mapper_configured")'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4397](https://www.sqlalchemy.org/trac/ticket/4397)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [change]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added a new function [`close_all_sessions()`](../orm/session_api.html#sqlalchemy.orm.close_all_sessions
    "sqlalchemy.orm.close_all_sessions") which takes over the task of the [`Session.close_all()`](../orm/session_api.html#sqlalchemy.orm.Session.close_all
    "sqlalchemy.orm.Session.close_all") method, which is now deprecated as this is
    confusing as a classmethod. Pull request courtesy Augustin Trancart.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4412](https://www.sqlalchemy.org/trac/ticket/4412)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed long-standing issue where duplicate collection members would cause a backref
    to delete the association between the member and its parent object when one of
    the duplicates were removed, as occurs as a side effect of swapping two objects
    in one statement.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Many-to-one backref checks for collection duplicates during remove operation](migration_13.html#change-1103)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#1103](https://www.sqlalchemy.org/trac/ticket/1103)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extended the fix first made as part of [#3287](https://www.sqlalchemy.org/trac/ticket/3287),
    where a loader option made against a subclass using a wildcard would extend itself
    to include application of the wildcard to attributes on the super classes as well,
    to a “bound” loader option as well, e.g. in an expression like `Load(SomeSubClass).load_only('foo')`.
    Columns that are part of the parent class of `SomeSubClass` will also be excluded
    in the same way as if the unbound option `load_only('foo')` were used.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4373](https://www.sqlalchemy.org/trac/ticket/4373)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improved error messages emitted by the ORM in the area of loader option traversal.
    This includes early detection of mis-matched loader strategies along with a clearer
    explanation why these strategies don’t match.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4433](https://www.sqlalchemy.org/trac/ticket/4433)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The “remove” event for collections is now called before the item is removed
    in the case of the `collection.remove()` method, as is consistent with the behavior
    for most other forms of collection item removal (such as `__delitem__`, replacement
    under `__setitem__`). For `pop()` methods, the remove event still fires after
    the operation.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug] [engine]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added accessors for execution options to Core and ORM, via [`Query.get_execution_options()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.get_execution_options
    "sqlalchemy.orm.Query.get_execution_options"), [`Connection.get_execution_options()`](../core/connections.html#sqlalchemy.engine.Connection.get_execution_options
    "sqlalchemy.engine.Connection.get_execution_options"), [`Engine.get_execution_options()`](../core/connections.html#sqlalchemy.engine.Engine.get_execution_options
    "sqlalchemy.engine.Engine.get_execution_options"), and [`Executable.get_execution_options()`](../core/selectable.html#sqlalchemy.sql.expression.Executable.get_execution_options
    "sqlalchemy.sql.expression.Executable.get_execution_options"). PR courtesy Daniel
    Lister.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4464](https://www.sqlalchemy.org/trac/ticket/4464)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue in association proxy due to [#3423](https://www.sqlalchemy.org/trac/ticket/3423)
    which caused the use of custom [`PropComparator`](../orm/internals.html#sqlalchemy.orm.PropComparator
    "sqlalchemy.orm.PropComparator") objects with hybrid attributes, such as the one
    demonstrated in the `dictlike-polymorphic` example to not function within an association
    proxy. The strictness that was added in [#3423](https://www.sqlalchemy.org/trac/ticket/3423)
    has been relaxed, and additional logic to accommodate for an association proxy
    that links to a custom hybrid have been added.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4446](https://www.sqlalchemy.org/trac/ticket/4446)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implemented the `.get_history()` method, which also implies availability of
    [`AttributeState.history`](../orm/internals.html#sqlalchemy.orm.AttributeState.history
    "sqlalchemy.orm.AttributeState.history"), for [`synonym()`](../orm/mapped_attributes.html#sqlalchemy.orm.synonym
    "sqlalchemy.orm.synonym") attributes. Previously, trying to access attribute history
    via a synonym would raise an `AttributeError`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#3777](https://www.sqlalchemy.org/trac/ticket/3777)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: orm declarative
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[bug] [orm declarative]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added a `__clause_element__()` method to [`ColumnProperty`](../orm/internals.html#sqlalchemy.orm.ColumnProperty
    "sqlalchemy.orm.ColumnProperty") which can allow the usage of a not-fully-declared
    column or deferred attribute in a declarative mapped class slightly more friendly
    when it’s used in a constraint or other column-oriented scenario within the class
    declaration, though this still can’t work in open-ended expressions; prefer to
    call the [`ColumnProperty.expression`](../orm/internals.html#sqlalchemy.orm.ColumnProperty.expression
    "sqlalchemy.orm.ColumnProperty.expression") attribute if receiving `TypeError`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4372](https://www.sqlalchemy.org/trac/ticket/4372)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: engine
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[engine] [feature]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added public accessor `QueuePool.timeout()` that returns the configured timeout
    for a [`QueuePool`](../core/pooling.html#sqlalchemy.pool.QueuePool "sqlalchemy.pool.QueuePool")
    object. Pull request courtesy Irina Delamare.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#3689](https://www.sqlalchemy.org/trac/ticket/3689)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[engine] [change]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The “threadlocal” engine strategy which has been a legacy feature of SQLAlchemy
    since around version 0.2 is now deprecated, along with the [`Pool.threadlocal`](../core/pooling.html#sqlalchemy.pool.Pool.params.threadlocal
    "sqlalchemy.pool.Pool") parameter of [`Pool`](../core/pooling.html#sqlalchemy.pool.Pool
    "sqlalchemy.pool.Pool") which has no effect in most modern use cases.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[“threadlocal” engine strategy deprecated](migration_13.html#change-4393-threadlocal)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4393](https://www.sqlalchemy.org/trac/ticket/4393)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[sql] [feature]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Amended the [`AnsiFunction`](../core/functions.html#sqlalchemy.sql.functions.AnsiFunction
    "sqlalchemy.sql.functions.AnsiFunction") class, the base of common SQL functions
    like `CURRENT_TIMESTAMP`, to accept positional arguments like a regular ad-hoc
    function. This to suit the case that many of these functions on specific backends
    accept arguments such as “fractional seconds” precision and such. If the function
    is created with arguments, it renders the parenthesis and the arguments. If no
    arguments are present, the compiler generates the non-parenthesized form.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4386](https://www.sqlalchemy.org/trac/ticket/4386)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[sql] [change]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [`create_engine.convert_unicode`](../core/engines.html#sqlalchemy.create_engine.params.convert_unicode
    "sqlalchemy.create_engine") and [`String.convert_unicode`](../core/type_basics.html#sqlalchemy.types.String.params.convert_unicode
    "sqlalchemy.types.String") parameters have been deprecated. These parameters were
    built back when most Python DBAPIs had little to no support for Python Unicode
    objects, and SQLAlchemy needed to take on the very complex task of marshalling
    data and SQL strings between Unicode and bytestrings throughout the system in
    a performant way. Thanks to Python 3, DBAPIs were compelled to adapt to Unicode-aware
    APIs and today all DBAPIs supported by SQLAlchemy support Unicode natively, including
    on Python 2, allowing this long-lived and very complicated feature to finally
    be (mostly) removed. There are still of course a few Python 2 edge cases where
    SQLAlchemy has to deal with Unicode however these are handled automatically; in
    modern use, there should be no need for end-user interaction with these flags.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[convert_unicode parameters deprecated](migration_13.html#change-4393-convertunicode)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4393](https://www.sqlalchemy.org/trac/ticket/4393)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: mssql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[mssql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `literal_processor` for the [`Unicode`](../core/type_basics.html#sqlalchemy.types.Unicode
    "sqlalchemy.types.Unicode") and [`UnicodeText`](../core/type_basics.html#sqlalchemy.types.UnicodeText
    "sqlalchemy.types.UnicodeText") datatypes now render an `N` character in front
    of the literal string expression as required by SQL Server for Unicode string
    values rendered in SQL expressions.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4442](https://www.sqlalchemy.org/trac/ticket/4442)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: misc
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[bug] [ext]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed a regression in 1.3.0b1 caused by [#3423](https://www.sqlalchemy.org/trac/ticket/3423)
    where association proxy objects that access an attribute that’s only present on
    a polymorphic subclass would raise an `AttributeError` even though the actual
    instance being accessed was an instance of that subclass.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4401](https://www.sqlalchemy.org/trac/ticket/4401)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 1.3.0b1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Released: November 16, 2018'
  prefs: []
  type: TYPE_NORMAL
- en: orm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[orm] [feature]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added new feature [`Query.only_return_tuples()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.only_return_tuples
    "sqlalchemy.orm.Query.only_return_tuples"). Causes the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object to return keyed tuple objects unconditionally even
    if the query is against a single entity. Pull request courtesy Eric Atkin.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This change is also **backported** to: 1.2.5'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [feature]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added new flag [`Session.bulk_save_objects.preserve_order`](../orm/session_api.html#sqlalchemy.orm.Session.bulk_save_objects.params.preserve_order
    "sqlalchemy.orm.Session.bulk_save_objects") to the [`Session.bulk_save_objects()`](../orm/session_api.html#sqlalchemy.orm.Session.bulk_save_objects
    "sqlalchemy.orm.Session.bulk_save_objects") method, which defaults to True. When
    set to False, the given mappings will be grouped into inserts and updates per
    each object type, to allow for greater opportunities to batch common operations
    together. Pull request courtesy Alessandro Cucci.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [feature]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The “selectin” loader strategy now omits the JOIN in the case of a simple one-to-many
    load, where it instead relies loads only from the related table, relying upon
    the foreign key columns of the related table in order to match up to primary keys
    in the parent table. This optimization can be disabled by setting the [`relationship.omit_join`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.omit_join
    "sqlalchemy.orm.relationship") flag to False. Many thanks to Jayson Reis for the
    efforts on this.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[selectin loading no longer uses JOIN for simple one-to-many](migration_13.html#change-4340)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4340](https://www.sqlalchemy.org/trac/ticket/4340)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [feature]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added `.info` dictionary to the [`InstanceState`](../orm/internals.html#sqlalchemy.orm.InstanceState
    "sqlalchemy.orm.InstanceState") class, the object that comes from calling [`inspect()`](../core/inspection.html#sqlalchemy.inspect
    "sqlalchemy.inspect") on a mapped object.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[info dictionary added to InstanceState](migration_13.html#change-4257)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4257](https://www.sqlalchemy.org/trac/ticket/4257)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug where use of [`Lateral`](../core/selectable.html#sqlalchemy.sql.expression.Lateral
    "sqlalchemy.sql.expression.Lateral") construct in conjunction with [`Query.join()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join") as well as `Query.select_entity_from()` would not
    apply clause adaption to the right side of the join. “lateral” introduces the
    use case of the right side of a join being correlatable. Previously, adaptation
    of this clause wasn’t considered. Note that in 1.2 only, a selectable introduced
    by [`Query.subquery()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.subquery
    "sqlalchemy.orm.Query.subquery") is still not adapted due to [#4304](https://www.sqlalchemy.org/trac/ticket/4304);
    the selectable needs to be produced by the [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") function to be the right side of the “lateral”
    join.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This change is also **backported** to: 1.2.12'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4334](https://www.sqlalchemy.org/trac/ticket/4334)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue regarding passive_deletes=”all”, where the foreign key attribute
    of an object is maintained with its value even after the object is removed from
    its parent collection. Previously, the unit of work would set this to NULL even
    though passive_deletes indicated it should not be modified.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[passive_deletes=’all’ will leave FK unchanged for object removed from collection](migration_13.html#change-3844)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#3844](https://www.sqlalchemy.org/trac/ticket/3844)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improved the behavior of a relationship-bound many-to-one object expression
    such that the retrieval of column values on the related object are now resilient
    against the object being detached from its parent [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), even if the attribute has been expired. New features
    within the [`InstanceState`](../orm/internals.html#sqlalchemy.orm.InstanceState
    "sqlalchemy.orm.InstanceState") are used to memoize the last known value of a
    particular column attribute before its expired, so that the expression can still
    evaluate when the object is detached and expired at the same time. Error conditions
    are also improved using modern attribute state features to produce more specific
    messages as needed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Improvement to the behavior of many-to-one query expressions](migration_13.html#change-4359)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4359](https://www.sqlalchemy.org/trac/ticket/4359)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug] [mysql] [postgresql]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ORM now doubles the “FOR UPDATE” clause within the subquery that renders
    in conjunction with joined eager loading in some cases, as it has been observed
    that MySQL does not lock the rows from a subquery. This means the query renders
    with two FOR UPDATE clauses; note that on some backends such as Oracle, FOR UPDATE
    clauses on subqueries are silently ignored since they are unnecessary. Additionally,
    in the case of the “OF” clause used primarily with PostgreSQL, the FOR UPDATE
    is rendered only on the inner subquery when this is used so that the selectable
    can be targeted to the table within the SELECT statement.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[FOR UPDATE clause is rendered within the joined eager load subquery as well
    as outside](migration_13.html#change-4246)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4246](https://www.sqlalchemy.org/trac/ticket/4246)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refactored [`Query.join()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join") to further clarify the individual components of structuring
    the join. This refactor adds the ability for [`Query.join()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join") to determine the most appropriate “left” side of
    the join when there is more than one element in the FROM list or the query is
    against multiple entities. If more than one FROM/entity matches, an error is raised
    that asks for an ON clause to be specified to resolve the ambiguity. In particular
    this targets the regression we saw in [#4363](https://www.sqlalchemy.org/trac/ticket/4363)
    but is also of general use. The codepaths within [`Query.join()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join") are now easier to follow and the error cases are
    decided more specifically at an earlier point in the operation.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Query.join() handles ambiguity in deciding the “left” side more explicitly](migration_13.html#change-4365)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4365](https://www.sqlalchemy.org/trac/ticket/4365)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed long-standing issue in [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") where a scalar subquery such as produced by [`Query.exists()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.exists
    "sqlalchemy.orm.Query.exists"), [`Query.as_scalar()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.as_scalar
    "sqlalchemy.orm.Query.as_scalar") and other derivations from [`Query.statement`](../orm/queryguide/query.html#sqlalchemy.orm.Query.statement
    "sqlalchemy.orm.Query.statement") would not correctly be adapted when used in
    a new [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    that required entity adaptation, such as when the query were turned into a union,
    or a from_self(), etc. The change removes the “no adaptation” annotation from
    the [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select")
    object produced by the [`Query.statement`](../orm/queryguide/query.html#sqlalchemy.orm.Query.statement
    "sqlalchemy.orm.Query.statement") accessor.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4304](https://www.sqlalchemy.org/trac/ticket/4304)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An informative exception is re-raised when a primary key value is not sortable
    in Python during an ORM flush under Python 3, such as an `Enum` that has no `__lt__()`
    method; normally Python 3 raises a `TypeError` in this case. The flush process
    sorts persistent objects by primary key in Python so the values must be sortable.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4232](https://www.sqlalchemy.org/trac/ticket/4232)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removed the collection converter used by the `MappedCollection` class. This
    converter was used only to assert that the incoming dictionary keys matched that
    of their corresponding objects, and only during a bulk set operation. The converter
    can interfere with a custom validator or [`AttributeEvents.bulk_replace()`](../orm/events.html#sqlalchemy.orm.AttributeEvents.bulk_replace
    "sqlalchemy.orm.AttributeEvents.bulk_replace") listener that wants to convert
    incoming values further. The `TypeError` which would be raised by this converter
    when an incoming key didn’t match the value is removed; incoming values during
    a bulk assignment will be keyed to their value-generated key, and not the key
    that’s explicitly present in the dictionary.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Overall, @converter is superseded by the [`AttributeEvents.bulk_replace()`](../orm/events.html#sqlalchemy.orm.AttributeEvents.bulk_replace
    "sqlalchemy.orm.AttributeEvents.bulk_replace") event handler added as part of
    [#3896](https://www.sqlalchemy.org/trac/ticket/3896).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#3604](https://www.sqlalchemy.org/trac/ticket/3604)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added new behavior to the lazy load that takes place when the “old” value of
    a many-to-one is retrieved, such that exceptions which would be raised due to
    either `lazy="raise"` or a detached session error are skipped.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Many-to-one replacement won’t raise for “raiseload” or detached for “old”
    object](migration_13.html#change-4353)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4353](https://www.sqlalchemy.org/trac/ticket/4353)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A long-standing oversight in the ORM, the `__delete__` method for a many- to-one
    relationship was non-functional, e.g. for an operation such as `del a.b`. This
    is now implemented and is equivalent to setting the attribute to `None`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[“del” implemented for ORM attributes](migration_13.html#change-4354)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4354](https://www.sqlalchemy.org/trac/ticket/4354)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: orm declarative
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[orm] [declarative] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug where declarative would not update the state of the [`Mapper`](../orm/mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper") as far as what attributes were present, when additional
    attributes were added or removed after the mapper attribute collections had already
    been called and memoized. Additionally, a `NotImplementedError` is now raised
    if a fully mapped attribute (e.g. column, relationship, etc.) is deleted from
    a class that is currently mapped, since the mapper will not function correctly
    if the attribute has been removed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4133](https://www.sqlalchemy.org/trac/ticket/4133)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: engine
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[engine] [feature]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added new “lifo” mode to [`QueuePool`](../core/pooling.html#sqlalchemy.pool.QueuePool
    "sqlalchemy.pool.QueuePool"), typically enabled by setting the flag [`create_engine.pool_use_lifo`](../core/engines.html#sqlalchemy.create_engine.params.pool_use_lifo
    "sqlalchemy.create_engine") to True. “lifo” mode means the same connection just
    checked in will be the first to be checked out again, allowing excess connections
    to be cleaned up from the server side during periods of the pool being only partially
    utilized. Pull request courtesy Taem Park.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[New last-in-first-out strategy for QueuePool](migration_13.html#change-pr467)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[sql] [feature]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refactored [`SQLCompiler`](../core/internals.html#sqlalchemy.sql.compiler.SQLCompiler
    "sqlalchemy.sql.compiler.SQLCompiler") to expose a [`SQLCompiler.group_by_clause()`](../core/internals.html#sqlalchemy.sql.compiler.SQLCompiler.group_by_clause
    "sqlalchemy.sql.compiler.SQLCompiler.group_by_clause") method similar to the [`SQLCompiler.order_by_clause()`](../core/internals.html#sqlalchemy.sql.compiler.SQLCompiler.order_by_clause
    "sqlalchemy.sql.compiler.SQLCompiler.order_by_clause") and `SQLCompiler.limit_clause()`
    methods, which can be overridden by dialects to customize how GROUP BY renders.
    Pull request courtesy Samuel Chou.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This change is also **backported** to: 1.2.13'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[sql] [feature]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Added [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence "sqlalchemy.schema.Sequence")
    to the “string SQL” system that will render a meaningful string expression (`"<next
    sequence value: my_sequence>"`) when stringifying without a dialect a statement
    that includes a “sequence nextvalue” expression, rather than raising a compilation
    error.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4144](https://www.sqlalchemy.org/trac/ticket/4144)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[sql] [feature]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added new naming convention tokens `column_0N_name`, `column_0_N_name`, etc.,
    which will render the names / keys / labels for all columns referenced by a particular
    constraint in a sequence. In order to accommodate for the length of such a naming
    convention, the SQL compiler’s auto-truncation feature now applies itself to constraint
    names as well, which creates a shortened, deterministically generated name for
    the constraint that will apply to a target backend without going over the character
    limit of that backend.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The change also repairs two other issues. One is that the `column_0_key` token
    wasn’t available even though this token was documented, the other was that the
    `referred_column_0_name` token would inadvertently render the `.key` and not the
    `.name` of the column if these two values were different.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[New multi-column naming convention tokens, long name truncation](migration_13.html#change-3989)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#3989](https://www.sqlalchemy.org/trac/ticket/3989)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[sql] [feature]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added new logic to the “expanding IN” bound parameter feature whereby if the
    given list is empty, a special “empty set” expression that is specific to different
    backends is generated, thus allowing IN expressions to be fully dynamic including
    empty IN expressions.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Expanding IN feature now supports empty lists](migration_13.html#change-4271)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4271](https://www.sqlalchemy.org/trac/ticket/4271)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[sql] [feature]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Python builtin `dir()` is now supported for a SQLAlchemy “properties” object,
    such as that of a Core columns collection (e.g. `.c`), `mapper.attrs`, etc. Allows
    iPython autocompletion to work as well. Pull request courtesy Uwe Korn.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[sql] [feature]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added new feature [`FunctionElement.as_comparison()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.as_comparison
    "sqlalchemy.sql.functions.FunctionElement.as_comparison") which allows a SQL function
    to act as a binary comparison operation that can work within the ORM.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Binary comparison interpretation for SQL functions](migration_13.html#change-3831)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#3831](https://www.sqlalchemy.org/trac/ticket/3831)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[sql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added “like” based operators as “comparison” operators, including [`ColumnOperators.startswith()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.startswith
    "sqlalchemy.sql.expression.ColumnOperators.startswith") [`ColumnOperators.endswith()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.endswith
    "sqlalchemy.sql.expression.ColumnOperators.endswith") [`ColumnOperators.ilike()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.ilike
    "sqlalchemy.sql.expression.ColumnOperators.ilike") [`ColumnOperators.notilike()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.notilike
    "sqlalchemy.sql.expression.ColumnOperators.notilike") among many others, so that
    all of these operators can be the basis for an ORM “primaryjoin” condition.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4302](https://www.sqlalchemy.org/trac/ticket/4302)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[sql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue with [`TypeEngine.bind_expression()`](../core/type_api.html#sqlalchemy.types.TypeEngine.bind_expression
    "sqlalchemy.types.TypeEngine.bind_expression") and [`TypeEngine.column_expression()`](../core/type_api.html#sqlalchemy.types.TypeEngine.column_expression
    "sqlalchemy.types.TypeEngine.column_expression") methods where these methods would
    not work if the target type were part of a [`Variant`](../core/type_api.html#sqlalchemy.types.Variant
    "sqlalchemy.types.Variant"), or other target type of a [`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator"). Additionally, the SQL compiler now calls upon
    the dialect-level implementation when it renders these methods so that dialects
    can now provide for SQL-level processing for built-in types.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[TypeEngine methods bind_expression, column_expression work with Variant, type-specific
    types](migration_13.html#change-3981)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#3981](https://www.sqlalchemy.org/trac/ticket/3981)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: postgresql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[postgresql] [feature]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added new PG type [`REGCLASS`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.REGCLASS
    "sqlalchemy.dialects.postgresql.REGCLASS") which assists in casting table names
    to OID values. Pull request courtesy Sebastian Bank.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This change is also **backported** to: 1.2.7'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4160](https://www.sqlalchemy.org/trac/ticket/4160)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[postgresql] [feature]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added rudimental support for reflection of PostgreSQL partitioned tables, e.g.
    that relkind=’p’ is added to reflection queries that return table information.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Added basic reflection support for PostgreSQL partitioned tables](migration_13.html#change-4237)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4237](https://www.sqlalchemy.org/trac/ticket/4237)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: mysql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[mysql] [feature]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support added for the “WITH PARSER” syntax of CREATE FULLTEXT INDEX in MySQL,
    using the `mysql_with_parser` keyword argument. Reflection is also supported,
    which accommodates MySQL’s special comment format for reporting on this option
    as well. Additionally, the “FULLTEXT” and “SPATIAL” index prefixes are now reflected
    back into the `mysql_prefix` index option.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4219](https://www.sqlalchemy.org/trac/ticket/4219)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[mysql] [feature]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added support for the parameters in an ON DUPLICATE KEY UPDATE statement on
    MySQL to be ordered, since parameter order in a MySQL UPDATE clause is significant,
    in a similar manner as that described at [Parameter Ordered Updates](../tutorial/data_update.html#tutorial-parameter-ordered-updates).
    Pull request courtesy Maxim Bublis.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Control of parameter ordering within ON DUPLICATE KEY UPDATE](migration_13.html#change-mysql-ondupordering)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[mysql] [feature]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The “pre-ping” feature of the connection pool now uses the `ping()` method of
    the DBAPI connection in the case of mysqlclient, PyMySQL and mysql-connector-python.
    Pull request courtesy Maxim Bublis.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Protocol-level ping now used for pre-ping](migration_13.html#change-mysql-ping)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sqlite
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[sqlite] [feature]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added support for SQLite’s json functionality via the new SQLite implementation
    for [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON"),
    [`JSON`](../dialects/sqlite.html#sqlalchemy.dialects.sqlite.JSON "sqlalchemy.dialects.sqlite.JSON").
    The name used for the type is `JSON`, following an example found at SQLite’s own
    documentation. Pull request courtesy Ilja Everilä.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Support for SQLite JSON Added](migration_13.html#change-3850)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#3850](https://www.sqlalchemy.org/trac/ticket/3850)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[sqlite] [feature]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implemented the SQLite `ON CONFLICT` clause as understood at the DDL level,
    e.g. for primary key, unique, and CHECK constraints as well as specified on a
    [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    to satisfy inline primary key and NOT NULL. Pull request courtesy Denis Kataev.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Support for SQLite ON CONFLICT in constraints added](migration_13.html#change-4360)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4360](https://www.sqlalchemy.org/trac/ticket/4360)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: mssql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[mssql] [feature]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added `fast_executemany=True` parameter to the SQL Server pyodbc dialect, which
    enables use of pyodbc’s new performance feature of the same name when using Microsoft
    ODBC drivers.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Support for pyodbc fast_executemany](migration_13.html#change-4158)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4158](https://www.sqlalchemy.org/trac/ticket/4158)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[mssql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deprecated the use of [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence") with SQL Server in order to affect the “start” and
    “increment” of the IDENTITY value, in favor of new parameters `mssql_identity_start`
    and `mssql_identity_increment` which set these parameters directly. [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence") will be used to generate real `CREATE SEQUENCE`
    DDL with SQL Server in a future release.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[New parameters to affect IDENTITY start and increment, use of Sequence deprecated](migration_13.html#change-4362)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4362](https://www.sqlalchemy.org/trac/ticket/4362)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: oracle
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[oracle] [feature]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added a new event currently used only by the cx_Oracle dialect, `DialectEvents.setiputsizes()`.
    The event passes a dictionary of [`BindParameter`](../core/sqlelement.html#sqlalchemy.sql.expression.BindParameter
    "sqlalchemy.sql.expression.BindParameter") objects to DBAPI-specific type objects
    that will be passed, after conversion to parameter names, to the cx_Oracle `cursor.setinputsizes()`
    method. This allows both visibility into the setinputsizes process as well as
    the ability to alter the behavior of what datatypes are passed to this method.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Fine grained control over cx_Oracle data binding performance with setinputsizes](../dialects/oracle.html#cx-oracle-setinputsizes)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This change is also **backported** to: 1.2.9'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4290](https://www.sqlalchemy.org/trac/ticket/4290)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[oracle] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updated the parameters that can be sent to the cx_Oracle DBAPI to both allow
    for all current parameters as well as for future parameters not added yet. In
    addition, removed unused parameters that were deprecated in version 1.2, and additionally
    we are now defaulting “threaded” to False.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[cx_Oracle connect arguments modernized, deprecated parameters removed](migration_13.html#change-4369)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4369](https://www.sqlalchemy.org/trac/ticket/4369)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[oracle] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Oracle dialect will no longer use the NCHAR/NCLOB datatypes represent generic
    unicode strings or clob fields in conjunction with [`Unicode`](../core/type_basics.html#sqlalchemy.types.Unicode
    "sqlalchemy.types.Unicode") and [`UnicodeText`](../core/type_basics.html#sqlalchemy.types.UnicodeText
    "sqlalchemy.types.UnicodeText") unless the flag `use_nchar_for_unicode=True` is
    passed to [`create_engine()`](../core/engines.html#sqlalchemy.create_engine "sqlalchemy.create_engine")
    - this includes CREATE TABLE behavior as well as `setinputsizes()` for bound parameters.
    On the read side, automatic Unicode conversion under Python 2 has been added to
    CHAR/VARCHAR/CLOB result rows, to match the behavior of cx_Oracle under Python
    3\. In order to mitigate the performance hit under Python 2, SQLAlchemy’s very
    performant (when C extensions are built) native Unicode handlers are used under
    Python 2.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[National char datatypes de-emphasized for generic unicode, re-enabled with
    option](migration_13.html#change-4242)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4242](https://www.sqlalchemy.org/trac/ticket/4242)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: misc
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[feature] [ext]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added new attribute [`Query.lazy_loaded_from`](../orm/queryguide/query.html#sqlalchemy.orm.Query.lazy_loaded_from
    "sqlalchemy.orm.Query.lazy_loaded_from") which is populated with an [`InstanceState`](../orm/internals.html#sqlalchemy.orm.InstanceState
    "sqlalchemy.orm.InstanceState") that is using this [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") in order to lazy load a relationship. The rationale for
    this is that it serves as a hint for the horizontal sharding feature to use, such
    that the identity token of the state can be used as the default identity token
    to use for the query within id_chooser().
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This change is also **backported** to: 1.2.9'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4243](https://www.sqlalchemy.org/trac/ticket/4243)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[feature] [ext]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added new feature [`BakedQuery.to_query()`](../orm/extensions/baked.html#sqlalchemy.ext.baked.BakedQuery.to_query
    "sqlalchemy.ext.baked.BakedQuery.to_query"), which allows for a clean way of using
    one [`BakedQuery`](../orm/extensions/baked.html#sqlalchemy.ext.baked.BakedQuery
    "sqlalchemy.ext.baked.BakedQuery") as a subquery inside of another [`BakedQuery`](../orm/extensions/baked.html#sqlalchemy.ext.baked.BakedQuery
    "sqlalchemy.ext.baked.BakedQuery") without needing to refer explicitly to a [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session").
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4318](https://www.sqlalchemy.org/trac/ticket/4318)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[feature] [ext]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [`AssociationProxy`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy
    "sqlalchemy.ext.associationproxy.AssociationProxy") now has standard column comparison
    operations such as [`ColumnOperators.like()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.like
    "sqlalchemy.sql.expression.ColumnOperators.like") and [`ColumnOperators.startswith()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.startswith
    "sqlalchemy.sql.expression.ColumnOperators.startswith") available when the target
    attribute is a plain column - the EXISTS expression that joins to the target table
    is rendered as usual, but the column expression is then use within the WHERE criteria
    of the EXISTS. Note that this alters the behavior of the `.contains()` method
    on the association proxy to make use of [`ColumnOperators.contains()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.contains
    "sqlalchemy.sql.expression.ColumnOperators.contains") when used on a column-based
    attribute.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[AssociationProxy now provides standard column operators for a column-oriented
    target](migration_13.html#change-4351)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4351](https://www.sqlalchemy.org/trac/ticket/4351)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[feature] [ext]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added support for bulk [`Query.update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.update
    "sqlalchemy.orm.Query.update") and [`Query.delete()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.delete
    "sqlalchemy.orm.Query.delete") to the [`ShardedQuery`](../orm/extensions/horizontal_shard.html#sqlalchemy.ext.horizontal_shard.ShardedQuery
    "sqlalchemy.ext.horizontal_shard.ShardedQuery") class within the horizontal sharding
    extension. This also adds an additional expansion hook to the bulk update/delete
    methods `Query._execute_crud()`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Horizontal Sharding extension supports bulk update and delete methods](migration_13.html#change-4196)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4196](https://www.sqlalchemy.org/trac/ticket/4196)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[bug] [ext]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reworked [`AssociationProxy`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy
    "sqlalchemy.ext.associationproxy.AssociationProxy") to store state that’s specific
    to a parent class in a separate object, so that a single [`AssociationProxy`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy
    "sqlalchemy.ext.associationproxy.AssociationProxy") can serve for multiple parent
    classes, as is intrinsic to inheritance, without any ambiguity in the state returned
    by it. A new method [`AssociationProxy.for_class()`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy.for_class
    "sqlalchemy.ext.associationproxy.AssociationProxy.for_class") is added to allow
    inspection of class-specific state.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[AssociationProxy stores class-specific state on a per-class basis](migration_13.html#change-3423)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#3423](https://www.sqlalchemy.org/trac/ticket/3423)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[bug] [ext]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The long-standing behavior of the association proxy collection maintaining only
    a weak reference to the parent object is reverted; the proxy will now maintain
    a strong reference to the parent for as long as the proxy collection itself is
    also in memory, eliminating the “stale association proxy” error. This change is
    being made on an experimental basis to see if any use cases arise where it causes
    side effects.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[New Features and Improvements - Core](migration_13.html#change-4268)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4268](https://www.sqlalchemy.org/trac/ticket/4268)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[bug] [ext]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed multiple issues regarding de-association of scalar objects with the association
    proxy. `del` now works, and additionally a new flag [`AssociationProxy.cascade_scalar_deletes`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy.params.cascade_scalar_deletes
    "sqlalchemy.ext.associationproxy.AssociationProxy") is added, which when set to
    True indicates that setting a scalar attribute to `None` or deleting via `del`
    will also set the source association to `None`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Association proxy has new cascade_scalar_deletes flag](migration_13.html#change-4308)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4308](https://www.sqlalchemy.org/trac/ticket/4308)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 1.3.25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: no release date
  prefs: []
  type: TYPE_NORMAL
- en: orm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue in [`Session.bulk_save_objects()`](../orm/session_api.html#sqlalchemy.orm.Session.bulk_save_objects
    "sqlalchemy.orm.Session.bulk_save_objects") when used with persistent objects
    which would fail to track the primary key of mappings where the column name of
    the primary key were different than the attribute name.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#6392](https://www.sqlalchemy.org/trac/ticket/6392)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: schema
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[schema] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    object now raises an informative error message if it is instantiated without passing
    at least the [`Table.name`](../core/metadata.html#sqlalchemy.schema.Table.params.name
    "sqlalchemy.schema.Table") and [`Table.metadata`](../core/metadata.html#sqlalchemy.schema.Table.params.metadata
    "sqlalchemy.schema.Table") arguments positionally. Previously, if these were passed
    as keyword arguments, the object would silently fail to initialize correctly.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#6135](https://www.sqlalchemy.org/trac/ticket/6135)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: postgresql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[postgresql] [bug] [regression]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed regression caused by [#6023](https://www.sqlalchemy.org/trac/ticket/6023)
    where the PostgreSQL cast operator applied to elements within an [`ARRAY`](../core/type_basics.html#sqlalchemy.types.ARRAY
    "sqlalchemy.types.ARRAY") when using psycopg2 would fail to use the correct type
    in the case that the datatype were also embedded within an instance of the [`Variant`](../core/type_api.html#sqlalchemy.types.Variant
    "sqlalchemy.types.Variant") adapter.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Additionally, repairs support for the correct CREATE TYPE to be emitted when
    using a `Variant(ARRAY(some_schema_type))`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#6182](https://www.sqlalchemy.org/trac/ticket/6182)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: mysql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[mysql] [bug] [mariadb]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixes to accommodate for the MariaDB 10.6 series, including backwards incompatible
    changes in both the mariadb-connector Python driver (supported on SQLAlchemy 1.4
    only) as well as the native 10.6 client libraries that are used automatically
    by the mysqlclient DBAPI (applies to both 1.3 and 1.4). The “utf8mb3” encoding
    symbol is now reported by these client libraries when the encoding is stated as
    “utf8”, leading to lookup and encoding errors within the MySQL dialect that does
    not expect this symbol. Updates to both the MySQL base library to accommodate
    for this utf8mb3 symbol being reported as well as to the test suite. Thanks to
    Georg Richter for support.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#7115](https://www.sqlalchemy.org/trac/ticket/7115), [#7136](https://www.sqlalchemy.org/trac/ticket/7136)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sqlite
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[sqlite] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add note regarding encryption-related pragmas for pysqlcipher passed in the
    url.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#6589](https://www.sqlalchemy.org/trac/ticket/6589)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: orm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue in [`Session.bulk_save_objects()`](../orm/session_api.html#sqlalchemy.orm.Session.bulk_save_objects
    "sqlalchemy.orm.Session.bulk_save_objects") when used with persistent objects
    which would fail to track the primary key of mappings where the column name of
    the primary key were different than the attribute name.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#6392](https://www.sqlalchemy.org/trac/ticket/6392)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: schema
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[schema] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    object now raises an informative error message if it is instantiated without passing
    at least the [`Table.name`](../core/metadata.html#sqlalchemy.schema.Table.params.name
    "sqlalchemy.schema.Table") and [`Table.metadata`](../core/metadata.html#sqlalchemy.schema.Table.params.metadata
    "sqlalchemy.schema.Table") arguments positionally. Previously, if these were passed
    as keyword arguments, the object would silently fail to initialize correctly.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#6135](https://www.sqlalchemy.org/trac/ticket/6135)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: postgresql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[postgresql] [bug] [regression]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed regression caused by [#6023](https://www.sqlalchemy.org/trac/ticket/6023)
    where the PostgreSQL cast operator applied to elements within an [`ARRAY`](../core/type_basics.html#sqlalchemy.types.ARRAY
    "sqlalchemy.types.ARRAY") when using psycopg2 would fail to use the correct type
    in the case that the datatype were also embedded within an instance of the [`Variant`](../core/type_api.html#sqlalchemy.types.Variant
    "sqlalchemy.types.Variant") adapter.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Additionally, repairs support for the correct CREATE TYPE to be emitted when
    using a `Variant(ARRAY(some_schema_type))`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#6182](https://www.sqlalchemy.org/trac/ticket/6182)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: mysql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[mysql] [bug] [mariadb]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixes to accommodate for the MariaDB 10.6 series, including backwards incompatible
    changes in both the mariadb-connector Python driver (supported on SQLAlchemy 1.4
    only) as well as the native 10.6 client libraries that are used automatically
    by the mysqlclient DBAPI (applies to both 1.3 and 1.4). The “utf8mb3” encoding
    symbol is now reported by these client libraries when the encoding is stated as
    “utf8”, leading to lookup and encoding errors within the MySQL dialect that does
    not expect this symbol. Updates to both the MySQL base library to accommodate
    for this utf8mb3 symbol being reported as well as to the test suite. Thanks to
    Georg Richter for support.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#7115](https://www.sqlalchemy.org/trac/ticket/7115), [#7136](https://www.sqlalchemy.org/trac/ticket/7136)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sqlite
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[sqlite] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add note regarding encryption-related pragmas for pysqlcipher passed in the
    url.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#6589](https://www.sqlalchemy.org/trac/ticket/6589)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 1.3.24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Released: March 30, 2021'
  prefs: []
  type: TYPE_NORMAL
- en: orm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removed very old warning that states that passive_deletes is not intended for
    many-to-one relationships. While it is likely that in many cases placing this
    parameter on a many-to-one relationship is not what was intended, there are use
    cases where delete cascade may want to be disallowed following from such a relationship.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5983](https://www.sqlalchemy.org/trac/ticket/5983)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue where the process of joining two tables could fail if one of the
    tables had an unrelated, unresolvable foreign key constraint which would raise
    [`NoReferenceError`](../core/exceptions.html#sqlalchemy.exc.NoReferenceError "sqlalchemy.exc.NoReferenceError")
    within the join process, which nonetheless could be bypassed to allow the join
    to complete. The logic which tested the exception for significance within the
    process would make assumptions about the construct which would fail.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5952](https://www.sqlalchemy.org/trac/ticket/5952)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue where the [`MutableComposite`](../orm/extensions/mutable.html#sqlalchemy.ext.mutable.MutableComposite
    "sqlalchemy.ext.mutable.MutableComposite") construct could be placed into an invalid
    state when the parent object was already loaded, and then covered by a subsequent
    query, due to the composite properties’ refresh handler replacing the object with
    a new one not handled by the mutable extension.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#6001](https://www.sqlalchemy.org/trac/ticket/6001)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: engine
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[engine] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug where the “schema_translate_map” feature failed to be taken into account
    for the use case of direct execution of [`DefaultGenerator`](../core/defaults.html#sqlalchemy.schema.DefaultGenerator
    "sqlalchemy.schema.DefaultGenerator") objects such as sequences, which included
    the case where they were “pre-executed” in order to generate primary key values
    when implicit_returning was disabled.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5929](https://www.sqlalchemy.org/trac/ticket/5929)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: schema
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[schema] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug first introduced in as some combination of [#2892](https://www.sqlalchemy.org/trac/ticket/2892),
    [#2919](https://www.sqlalchemy.org/trac/ticket/2919) nnd [#3832](https://www.sqlalchemy.org/trac/ticket/3832)
    where the attachment events for a [`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") would be doubled up against the “impl” class,
    if the “impl” were also a [`SchemaType`](../core/type_basics.html#sqlalchemy.types.SchemaType
    "sqlalchemy.types.SchemaType"). The real-world case is any [`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") against [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum") or [`Boolean`](../core/type_basics.html#sqlalchemy.types.Boolean
    "sqlalchemy.types.Boolean") would get a doubled [`CheckConstraint`](../core/constraints.html#sqlalchemy.schema.CheckConstraint
    "sqlalchemy.schema.CheckConstraint") when the `create_constraint=True` flag is
    set.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#6152](https://www.sqlalchemy.org/trac/ticket/6152)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[schema] [bug] [sqlite]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Fixed issue where the CHECK constraint generated by [`Boolean`](../core/type_basics.html#sqlalchemy.types.Boolean
    "sqlalchemy.types.Boolean") or [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum") would fail to render the naming convention correctly
    after the first compilation, due to an unintended change of state within the name
    given to the constraint. This issue was first introduced in 0.9 in the fix for
    issue #3067, and the fix revises the approach taken at that time which appears
    to have been more involved than what was needed.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#6007](https://www.sqlalchemy.org/trac/ticket/6007)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[schema] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Repaired / implemented support for primary key constraint naming conventions
    that use column names/keys/etc as part of the convention. In particular, this
    includes that the [`PrimaryKeyConstraint`](../core/constraints.html#sqlalchemy.schema.PrimaryKeyConstraint
    "sqlalchemy.schema.PrimaryKeyConstraint") object that’s automatically associated
    with a [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    will update its name as new primary key [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects are added to the table and then to the constraint.
    Internal failure modes related to this constraint construction process including
    no columns present, no name present or blank name present are now accommodated.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5919](https://www.sqlalchemy.org/trac/ticket/5919)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[schema] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adjusted the logic that emits DROP statements for [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence") objects among the dropping of multiple tables, such
    that all [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence "sqlalchemy.schema.Sequence")
    objects are dropped after all tables, even if the given [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence") is related only to a [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") object and not directly to the overall [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") object. The use case supports the same [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence") being associated with more than one [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") at a time.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#6071](https://www.sqlalchemy.org/trac/ticket/6071)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: postgresql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[postgresql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue where using [`aggregate_order_by`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.aggregate_order_by
    "sqlalchemy.dialects.postgresql.aggregate_order_by") would return ARRAY(NullType)
    under certain conditions, interfering with the ability of the result object to
    return data correctly.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5989](https://www.sqlalchemy.org/trac/ticket/5989)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[postgresql] [bug] [reflection]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue in PostgreSQL reflection where a column expressing “NOT NULL” will
    supersede the nullability of a corresponding domain.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#6161](https://www.sqlalchemy.org/trac/ticket/6161)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[postgresql] [bug] [types]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adjusted the psycopg2 dialect to emit an explicit PostgreSQL-style cast for
    bound parameters that contain ARRAY elements. This allows the full range of datatypes
    to function correctly within arrays. The asyncpg dialect already generated these
    internal casts in the final statement. This also includes support for array slice
    updates as well as the PostgreSQL-specific `ARRAY.contains()` method.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#6023](https://www.sqlalchemy.org/trac/ticket/6023)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: mssql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[mssql] [bug] [reflection]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue regarding SQL Server reflection for older SQL Server 2005 version,
    a call to sp_columns would not proceed correctly without being prefixed with the
    EXEC keyword. This method is not used in current 1.4 series.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5921](https://www.sqlalchemy.org/trac/ticket/5921)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: orm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removed very old warning that states that passive_deletes is not intended for
    many-to-one relationships. While it is likely that in many cases placing this
    parameter on a many-to-one relationship is not what was intended, there are use
    cases where delete cascade may want to be disallowed following from such a relationship.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5983](https://www.sqlalchemy.org/trac/ticket/5983)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue where the process of joining two tables could fail if one of the
    tables had an unrelated, unresolvable foreign key constraint which would raise
    [`NoReferenceError`](../core/exceptions.html#sqlalchemy.exc.NoReferenceError "sqlalchemy.exc.NoReferenceError")
    within the join process, which nonetheless could be bypassed to allow the join
    to complete. The logic which tested the exception for significance within the
    process would make assumptions about the construct which would fail.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5952](https://www.sqlalchemy.org/trac/ticket/5952)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue where the [`MutableComposite`](../orm/extensions/mutable.html#sqlalchemy.ext.mutable.MutableComposite
    "sqlalchemy.ext.mutable.MutableComposite") construct could be placed into an invalid
    state when the parent object was already loaded, and then covered by a subsequent
    query, due to the composite properties’ refresh handler replacing the object with
    a new one not handled by the mutable extension.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#6001](https://www.sqlalchemy.org/trac/ticket/6001)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: engine
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[engine] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug where the “schema_translate_map” feature failed to be taken into account
    for the use case of direct execution of [`DefaultGenerator`](../core/defaults.html#sqlalchemy.schema.DefaultGenerator
    "sqlalchemy.schema.DefaultGenerator") objects such as sequences, which included
    the case where they were “pre-executed” in order to generate primary key values
    when implicit_returning was disabled.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5929](https://www.sqlalchemy.org/trac/ticket/5929)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: schema
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[schema] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug first introduced in as some combination of [#2892](https://www.sqlalchemy.org/trac/ticket/2892),
    [#2919](https://www.sqlalchemy.org/trac/ticket/2919) nnd [#3832](https://www.sqlalchemy.org/trac/ticket/3832)
    where the attachment events for a [`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") would be doubled up against the “impl” class,
    if the “impl” were also a [`SchemaType`](../core/type_basics.html#sqlalchemy.types.SchemaType
    "sqlalchemy.types.SchemaType"). The real-world case is any [`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") against [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum") or [`Boolean`](../core/type_basics.html#sqlalchemy.types.Boolean
    "sqlalchemy.types.Boolean") would get a doubled [`CheckConstraint`](../core/constraints.html#sqlalchemy.schema.CheckConstraint
    "sqlalchemy.schema.CheckConstraint") when the `create_constraint=True` flag is
    set.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#6152](https://www.sqlalchemy.org/trac/ticket/6152)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[schema] [bug] [sqlite]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Fixed issue where the CHECK constraint generated by [`Boolean`](../core/type_basics.html#sqlalchemy.types.Boolean
    "sqlalchemy.types.Boolean") or [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum") would fail to render the naming convention correctly
    after the first compilation, due to an unintended change of state within the name
    given to the constraint. This issue was first introduced in 0.9 in the fix for
    issue #3067, and the fix revises the approach taken at that time which appears
    to have been more involved than what was needed.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#6007](https://www.sqlalchemy.org/trac/ticket/6007)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[schema] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Repaired / implemented support for primary key constraint naming conventions
    that use column names/keys/etc as part of the convention. In particular, this
    includes that the [`PrimaryKeyConstraint`](../core/constraints.html#sqlalchemy.schema.PrimaryKeyConstraint
    "sqlalchemy.schema.PrimaryKeyConstraint") object that’s automatically associated
    with a [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    will update its name as new primary key [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects are added to the table and then to the constraint.
    Internal failure modes related to this constraint construction process including
    no columns present, no name present or blank name present are now accommodated.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5919](https://www.sqlalchemy.org/trac/ticket/5919)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[schema] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adjusted the logic that emits DROP statements for [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence") objects among the dropping of multiple tables, such
    that all [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence "sqlalchemy.schema.Sequence")
    objects are dropped after all tables, even if the given [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence") is related only to a [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") object and not directly to the overall [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") object. The use case supports the same [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence") being associated with more than one [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") at a time.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#6071](https://www.sqlalchemy.org/trac/ticket/6071)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: postgresql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[postgresql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue where using [`aggregate_order_by`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.aggregate_order_by
    "sqlalchemy.dialects.postgresql.aggregate_order_by") would return ARRAY(NullType)
    under certain conditions, interfering with the ability of the result object to
    return data correctly.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5989](https://www.sqlalchemy.org/trac/ticket/5989)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[postgresql] [bug] [reflection]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue in PostgreSQL reflection where a column expressing “NOT NULL” will
    supersede the nullability of a corresponding domain.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#6161](https://www.sqlalchemy.org/trac/ticket/6161)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[postgresql] [bug] [types]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adjusted the psycopg2 dialect to emit an explicit PostgreSQL-style cast for
    bound parameters that contain ARRAY elements. This allows the full range of datatypes
    to function correctly within arrays. The asyncpg dialect already generated these
    internal casts in the final statement. This also includes support for array slice
    updates as well as the PostgreSQL-specific `ARRAY.contains()` method.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#6023](https://www.sqlalchemy.org/trac/ticket/6023)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: mssql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[mssql] [bug] [reflection]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue regarding SQL Server reflection for older SQL Server 2005 version,
    a call to sp_columns would not proceed correctly without being prefixed with the
    EXEC keyword. This method is not used in current 1.4 series.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5921](https://www.sqlalchemy.org/trac/ticket/5921)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 1.3.23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Released: February 1, 2021'
  prefs: []
  type: TYPE_NORMAL
- en: sql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[sql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug where making use of the [`TypeEngine.with_variant()`](../core/type_api.html#sqlalchemy.types.TypeEngine.with_variant
    "sqlalchemy.types.TypeEngine.with_variant") method on a [`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") type would fail to take into account the dialect-specific
    mappings in use, due to a rule in [`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") that was instead attempting to check for chains
    of [`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") instances.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5816](https://www.sqlalchemy.org/trac/ticket/5816)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: postgresql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[postgresql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For SQLAlchemy 1.3 only, setup.py pins pg8000 to a version lower than 1.16.6\.
    Version 1.16.6 and above is supported by SQLAlchemy 1.4\. Pull request courtesy
    Giuseppe Lumia.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5645](https://www.sqlalchemy.org/trac/ticket/5645)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[postgresql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue where using [`Table.to_metadata()`](../core/metadata.html#sqlalchemy.schema.Table.to_metadata
    "sqlalchemy.schema.Table.to_metadata") (called [`Table.tometadata()`](../core/metadata.html#sqlalchemy.schema.Table.tometadata
    "sqlalchemy.schema.Table.tometadata") in 1.3) in conjunction with a PostgreSQL
    [`ExcludeConstraint`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ExcludeConstraint
    "sqlalchemy.dialects.postgresql.ExcludeConstraint") that made use of ad-hoc column
    expressions would fail to copy correctly.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5850](https://www.sqlalchemy.org/trac/ticket/5850)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: mysql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[mysql] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Casting to `FLOAT` is now supported in MySQL >= (8, 0, 17) and MariaDb >= (10,
    4, 5).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5808](https://www.sqlalchemy.org/trac/ticket/5808)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[mysql] [bug] [reflection]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug where MySQL server default reflection would fail for numeric values
    with a negation symbol present.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5860](https://www.sqlalchemy.org/trac/ticket/5860)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[mysql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed long-lived bug in MySQL dialect where the maximum identifier length of
    255 was too long for names of all types of constraints, not just indexes, all
    of which have a size limit of 64\. As metadata naming conventions can create too-long
    names in this area, apply the limit to the identifier generator within the DDL
    compiler.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5898](https://www.sqlalchemy.org/trac/ticket/5898)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[mysql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed deprecation warnings that arose as a result of the release of PyMySQL
    1.0, including deprecation warnings for the “db” and “passwd” parameters now replaced
    with “database” and “password”.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5821](https://www.sqlalchemy.org/trac/ticket/5821)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[mysql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed regression from SQLAlchemy 1.3.20 caused by the fix for [#5462](https://www.sqlalchemy.org/trac/ticket/5462)
    which adds double-parenthesis for MySQL functional expressions in indexes, as
    is required by the backend, this inadvertently extended to include arbitrary [`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text
    "sqlalchemy.sql.expression.text") expressions as well as Alembic’s internal textual
    component, which are required by Alembic for arbitrary index expressions which
    don’t imply double parenthesis. The check has been narrowed to include only binary/
    unary/functional expressions directly.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5800](https://www.sqlalchemy.org/trac/ticket/5800)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: oracle
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[oracle] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed regression in Oracle dialect introduced by [#4894](https://www.sqlalchemy.org/trac/ticket/4894)
    in SQLAlchemy 1.3.11 where use of a SQL expression in RETURNING for an UPDATE
    would fail to compile, due to a check for “server_default” when an arbitrary SQL
    expression is not a column.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5813](https://www.sqlalchemy.org/trac/ticket/5813)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[oracle] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug in Oracle dialect where retrieving a CLOB/BLOB column via [`Insert.returning()`](../core/dml.html#sqlalchemy.sql.expression.Insert.returning
    "sqlalchemy.sql.expression.Insert.returning") would fail as the LOB value would
    need to be read when returned; additionally, repaired support for retrieval of
    Unicode values via RETURNING under Python 2.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5812](https://www.sqlalchemy.org/trac/ticket/5812)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: misc
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[bug] [ext]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue where the stringification that is sometimes called when attempting
    to generate the “key” for the `.c` collection on a selectable would fail if the
    column were an unlabeled custom SQL construct using the `sqlalchemy.ext.compiler`
    extension, and did not provide a default compilation form; while this seems like
    an unusual case, it can get invoked for some ORM scenarios such as when the expression
    is used in an “order by” in combination with joined eager loading. The issue is
    that the lack of a default compiler function was raising [`CompileError`](../core/exceptions.html#sqlalchemy.exc.CompileError
    "sqlalchemy.exc.CompileError") and not [`UnsupportedCompilationError`](../core/exceptions.html#sqlalchemy.exc.UnsupportedCompilationError
    "sqlalchemy.exc.UnsupportedCompilationError").
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5836](https://www.sqlalchemy.org/trac/ticket/5836)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[sql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug where making use of the [`TypeEngine.with_variant()`](../core/type_api.html#sqlalchemy.types.TypeEngine.with_variant
    "sqlalchemy.types.TypeEngine.with_variant") method on a [`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") type would fail to take into account the dialect-specific
    mappings in use, due to a rule in [`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") that was instead attempting to check for chains
    of [`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") instances.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5816](https://www.sqlalchemy.org/trac/ticket/5816)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: postgresql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[postgresql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For SQLAlchemy 1.3 only, setup.py pins pg8000 to a version lower than 1.16.6\.
    Version 1.16.6 and above is supported by SQLAlchemy 1.4\. Pull request courtesy
    Giuseppe Lumia.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5645](https://www.sqlalchemy.org/trac/ticket/5645)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[postgresql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue where using [`Table.to_metadata()`](../core/metadata.html#sqlalchemy.schema.Table.to_metadata
    "sqlalchemy.schema.Table.to_metadata") (called [`Table.tometadata()`](../core/metadata.html#sqlalchemy.schema.Table.tometadata
    "sqlalchemy.schema.Table.tometadata") in 1.3) in conjunction with a PostgreSQL
    [`ExcludeConstraint`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ExcludeConstraint
    "sqlalchemy.dialects.postgresql.ExcludeConstraint") that made use of ad-hoc column
    expressions would fail to copy correctly.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5850](https://www.sqlalchemy.org/trac/ticket/5850)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: mysql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[mysql] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Casting to `FLOAT` is now supported in MySQL >= (8, 0, 17) and MariaDb >= (10,
    4, 5).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5808](https://www.sqlalchemy.org/trac/ticket/5808)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[mysql] [bug] [reflection]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug where MySQL server default reflection would fail for numeric values
    with a negation symbol present.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5860](https://www.sqlalchemy.org/trac/ticket/5860)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[mysql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed long-lived bug in MySQL dialect where the maximum identifier length of
    255 was too long for names of all types of constraints, not just indexes, all
    of which have a size limit of 64\. As metadata naming conventions can create too-long
    names in this area, apply the limit to the identifier generator within the DDL
    compiler.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5898](https://www.sqlalchemy.org/trac/ticket/5898)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[mysql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed deprecation warnings that arose as a result of the release of PyMySQL
    1.0, including deprecation warnings for the “db” and “passwd” parameters now replaced
    with “database” and “password”.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5821](https://www.sqlalchemy.org/trac/ticket/5821)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[mysql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed regression from SQLAlchemy 1.3.20 caused by the fix for [#5462](https://www.sqlalchemy.org/trac/ticket/5462)
    which adds double-parenthesis for MySQL functional expressions in indexes, as
    is required by the backend, this inadvertently extended to include arbitrary [`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text
    "sqlalchemy.sql.expression.text") expressions as well as Alembic’s internal textual
    component, which are required by Alembic for arbitrary index expressions which
    don’t imply double parenthesis. The check has been narrowed to include only binary/
    unary/functional expressions directly.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5800](https://www.sqlalchemy.org/trac/ticket/5800)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: oracle
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[oracle] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed regression in Oracle dialect introduced by [#4894](https://www.sqlalchemy.org/trac/ticket/4894)
    in SQLAlchemy 1.3.11 where use of a SQL expression in RETURNING for an UPDATE
    would fail to compile, due to a check for “server_default” when an arbitrary SQL
    expression is not a column.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5813](https://www.sqlalchemy.org/trac/ticket/5813)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[oracle] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug in Oracle dialect where retrieving a CLOB/BLOB column via [`Insert.returning()`](../core/dml.html#sqlalchemy.sql.expression.Insert.returning
    "sqlalchemy.sql.expression.Insert.returning") would fail as the LOB value would
    need to be read when returned; additionally, repaired support for retrieval of
    Unicode values via RETURNING under Python 2.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5812](https://www.sqlalchemy.org/trac/ticket/5812)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: misc
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[bug] [ext]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue where the stringification that is sometimes called when attempting
    to generate the “key” for the `.c` collection on a selectable would fail if the
    column were an unlabeled custom SQL construct using the `sqlalchemy.ext.compiler`
    extension, and did not provide a default compilation form; while this seems like
    an unusual case, it can get invoked for some ORM scenarios such as when the expression
    is used in an “order by” in combination with joined eager loading. The issue is
    that the lack of a default compiler function was raising [`CompileError`](../core/exceptions.html#sqlalchemy.exc.CompileError
    "sqlalchemy.exc.CompileError") and not [`UnsupportedCompilationError`](../core/exceptions.html#sqlalchemy.exc.UnsupportedCompilationError
    "sqlalchemy.exc.UnsupportedCompilationError").
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5836](https://www.sqlalchemy.org/trac/ticket/5836)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 1.3.22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Released: December 18, 2020'
  prefs: []
  type: TYPE_NORMAL
- en: oracle
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[oracle] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed regression which occurred due to [#5755](https://www.sqlalchemy.org/trac/ticket/5755)
    which implemented isolation level support for Oracle. It has been reported that
    many Oracle accounts don’t actually have permission to query the `v$transaction`
    view so this feature has been altered to gracefully fallback when it fails upon
    database connect, where the dialect will assume “READ COMMITTED” is the default
    isolation level as was the case prior to SQLAlchemy 1.3.21. However, explicit
    use of the [`Connection.get_isolation_level()`](../core/connections.html#sqlalchemy.engine.Connection.get_isolation_level
    "sqlalchemy.engine.Connection.get_isolation_level") method must now necessarily
    raise an exception, as Oracle databases with this restriction explicitly disallow
    the user from reading the current isolation level.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5784](https://www.sqlalchemy.org/trac/ticket/5784)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: oracle
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[oracle] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed regression which occurred due to [#5755](https://www.sqlalchemy.org/trac/ticket/5755)
    which implemented isolation level support for Oracle. It has been reported that
    many Oracle accounts don’t actually have permission to query the `v$transaction`
    view so this feature has been altered to gracefully fallback when it fails upon
    database connect, where the dialect will assume “READ COMMITTED” is the default
    isolation level as was the case prior to SQLAlchemy 1.3.21. However, explicit
    use of the [`Connection.get_isolation_level()`](../core/connections.html#sqlalchemy.engine.Connection.get_isolation_level
    "sqlalchemy.engine.Connection.get_isolation_level") method must now necessarily
    raise an exception, as Oracle databases with this restriction explicitly disallow
    the user from reading the current isolation level.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5784](https://www.sqlalchemy.org/trac/ticket/5784)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 1.3.21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Released: December 17, 2020'
  prefs: []
  type: TYPE_NORMAL
- en: orm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added a comprehensive check and an informative error message for the case where
    a mapped class, or a string mapped class name, is passed to [`relationship.secondary`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.secondary
    "sqlalchemy.orm.relationship"). This is an extremely common error which warrants
    a clear message.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Additionally, added a new rule to the class registry resolution such that with
    regards to the [`relationship.secondary`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.secondary
    "sqlalchemy.orm.relationship") parameter, if a mapped class and its table are
    of the identical string name, the [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") will be favored when resolving this parameter. In all
    other cases, the class continues to be favored if a class and table share the
    identical name.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5774](https://www.sqlalchemy.org/trac/ticket/5774)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug in [`Query.update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.update
    "sqlalchemy.orm.Query.update") where objects in the `_ormsession.Session` that
    were already expired would be unnecessarily SELECTed individually when they were
    refreshed by the “evaluate”synchronize strategy.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5664](https://www.sqlalchemy.org/trac/ticket/5664)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug involving the `restore_load_context` option of ORM events such as
    [`InstanceEvents.load()`](../orm/events.html#sqlalchemy.orm.InstanceEvents.load
    "sqlalchemy.orm.InstanceEvents.load") such that the flag would not be carried
    along to subclasses which were mapped after the event handler were first established.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5737](https://www.sqlalchemy.org/trac/ticket/5737)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[sql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A warning is emitted if a returning() method such as [`Insert.returning()`](../core/dml.html#sqlalchemy.sql.expression.Insert.returning
    "sqlalchemy.sql.expression.Insert.returning") is called multiple times, as this
    does not yet support additive operation. Version 1.4 will support additive operation
    for this. Additionally, any combination of the [`Insert.returning()`](../core/dml.html#sqlalchemy.sql.expression.Insert.returning
    "sqlalchemy.sql.expression.Insert.returning") and `ValuesBase.return_defaults()`
    methods now raises an error as these methods are mutually exclusive; previously
    the operation would fail silently.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5691](https://www.sqlalchemy.org/trac/ticket/5691)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[sql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed structural compiler issue where some constructs such as MySQL / PostgreSQL
    “on conflict / on duplicate key” would rely upon the state of the `Compiler` object
    being fixed against their statement as the top level statement, which would fail
    in cases where those statements are branched from a different context, such as
    a DDL construct linked to a SQL statement.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5656](https://www.sqlalchemy.org/trac/ticket/5656)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: postgresql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[postgresql] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added new parameter [`ExcludeConstraint.ops`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ExcludeConstraint.params.ops
    "sqlalchemy.dialects.postgresql.ExcludeConstraint") to the [`ExcludeConstraint`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ExcludeConstraint
    "sqlalchemy.dialects.postgresql.ExcludeConstraint") object, to support operator
    class specification with this constraint. Pull request courtesy Alon Menczer.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5604](https://www.sqlalchemy.org/trac/ticket/5604)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[postgresql] [bug] [mysql]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed regression introduced in 1.3.2 for the PostgreSQL dialect, also copied
    out to the MySQL dialect’s feature in 1.3.18, where usage of a non [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") construct such as [`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text
    "sqlalchemy.sql.expression.text") as the argument to [`Select.with_for_update.of`](../core/selectable.html#sqlalchemy.sql.expression.Select.with_for_update.params.of
    "sqlalchemy.sql.expression.Select.with_for_update") would fail to be accommodated
    correctly within the PostgreSQL or MySQL compilers.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5729](https://www.sqlalchemy.org/trac/ticket/5729)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: mysql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[mysql] [bug] [reflection]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue where reflecting a server default on MariaDB only that contained
    a decimal point in the value would fail to be reflected correctly, leading towards
    a reflected table that lacked any server default.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5744](https://www.sqlalchemy.org/trac/ticket/5744)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[mysql] [sql]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Added missing keywords to the `RESERVED_WORDS` list for the MySQL dialect:
    `action`, `level`, `mode`, `status`, `text`, `time`. Pull request courtesy Oscar
    Batori.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5696](https://www.sqlalchemy.org/trac/ticket/5696)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sqlite
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[sqlite] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added `sqlite_with_rowid=False` dialect keyword to enable creating tables as
    `CREATE TABLE … WITHOUT ROWID`. Patch courtesy Sean Anderson.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5685](https://www.sqlalchemy.org/trac/ticket/5685)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: mssql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[mssql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug where a CREATE INDEX statement was rendered incorrectly when both
    `mssql-include` and `mssql_where` were specified. Pull request courtesy @Adiorz.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5751](https://www.sqlalchemy.org/trac/ticket/5751)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[mssql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added SQL Server code “01000” to the list of disconnect codes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5646](https://www.sqlalchemy.org/trac/ticket/5646)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[mssql] [reflection] [sqlite]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue with composite primary key columns not being reported in the correct
    order. Patch courtesy @fulpm.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5661](https://www.sqlalchemy.org/trac/ticket/5661)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: oracle
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[oracle] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implemented support for the SERIALIZABLE isolation level for Oracle databases,
    as well as a real implementation for [`Connection.get_isolation_level()`](../core/connections.html#sqlalchemy.engine.Connection.get_isolation_level
    "sqlalchemy.engine.Connection.get_isolation_level").
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Transaction Isolation Level / Autocommit](../dialects/oracle.html#oracle-isolation-level)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5755](https://www.sqlalchemy.org/trac/ticket/5755)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: orm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added a comprehensive check and an informative error message for the case where
    a mapped class, or a string mapped class name, is passed to [`relationship.secondary`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.secondary
    "sqlalchemy.orm.relationship"). This is an extremely common error which warrants
    a clear message.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Additionally, added a new rule to the class registry resolution such that with
    regards to the [`relationship.secondary`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.secondary
    "sqlalchemy.orm.relationship") parameter, if a mapped class and its table are
    of the identical string name, the [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") will be favored when resolving this parameter. In all
    other cases, the class continues to be favored if a class and table share the
    identical name.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5774](https://www.sqlalchemy.org/trac/ticket/5774)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug in [`Query.update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.update
    "sqlalchemy.orm.Query.update") where objects in the `_ormsession.Session` that
    were already expired would be unnecessarily SELECTed individually when they were
    refreshed by the “evaluate”synchronize strategy.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5664](https://www.sqlalchemy.org/trac/ticket/5664)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug involving the `restore_load_context` option of ORM events such as
    [`InstanceEvents.load()`](../orm/events.html#sqlalchemy.orm.InstanceEvents.load
    "sqlalchemy.orm.InstanceEvents.load") such that the flag would not be carried
    along to subclasses which were mapped after the event handler were first established.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5737](https://www.sqlalchemy.org/trac/ticket/5737)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[sql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A warning is emitted if a returning() method such as [`Insert.returning()`](../core/dml.html#sqlalchemy.sql.expression.Insert.returning
    "sqlalchemy.sql.expression.Insert.returning") is called multiple times, as this
    does not yet support additive operation. Version 1.4 will support additive operation
    for this. Additionally, any combination of the [`Insert.returning()`](../core/dml.html#sqlalchemy.sql.expression.Insert.returning
    "sqlalchemy.sql.expression.Insert.returning") and `ValuesBase.return_defaults()`
    methods now raises an error as these methods are mutually exclusive; previously
    the operation would fail silently.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5691](https://www.sqlalchemy.org/trac/ticket/5691)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[sql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed structural compiler issue where some constructs such as MySQL / PostgreSQL
    “on conflict / on duplicate key” would rely upon the state of the `Compiler` object
    being fixed against their statement as the top level statement, which would fail
    in cases where those statements are branched from a different context, such as
    a DDL construct linked to a SQL statement.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5656](https://www.sqlalchemy.org/trac/ticket/5656)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: postgresql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[postgresql] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added new parameter [`ExcludeConstraint.ops`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ExcludeConstraint.params.ops
    "sqlalchemy.dialects.postgresql.ExcludeConstraint") to the [`ExcludeConstraint`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ExcludeConstraint
    "sqlalchemy.dialects.postgresql.ExcludeConstraint") object, to support operator
    class specification with this constraint. Pull request courtesy Alon Menczer.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5604](https://www.sqlalchemy.org/trac/ticket/5604)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[postgresql] [bug] [mysql]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed regression introduced in 1.3.2 for the PostgreSQL dialect, also copied
    out to the MySQL dialect’s feature in 1.3.18, where usage of a non [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") construct such as [`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text
    "sqlalchemy.sql.expression.text") as the argument to [`Select.with_for_update.of`](../core/selectable.html#sqlalchemy.sql.expression.Select.with_for_update.params.of
    "sqlalchemy.sql.expression.Select.with_for_update") would fail to be accommodated
    correctly within the PostgreSQL or MySQL compilers.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5729](https://www.sqlalchemy.org/trac/ticket/5729)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: mysql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[mysql] [bug] [reflection]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue where reflecting a server default on MariaDB only that contained
    a decimal point in the value would fail to be reflected correctly, leading towards
    a reflected table that lacked any server default.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5744](https://www.sqlalchemy.org/trac/ticket/5744)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[mysql] [sql]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Added missing keywords to the `RESERVED_WORDS` list for the MySQL dialect:
    `action`, `level`, `mode`, `status`, `text`, `time`. Pull request courtesy Oscar
    Batori.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5696](https://www.sqlalchemy.org/trac/ticket/5696)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sqlite
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[sqlite] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added `sqlite_with_rowid=False` dialect keyword to enable creating tables as
    `CREATE TABLE … WITHOUT ROWID`. Patch courtesy Sean Anderson.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5685](https://www.sqlalchemy.org/trac/ticket/5685)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: mssql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[mssql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug where a CREATE INDEX statement was rendered incorrectly when both
    `mssql-include` and `mssql_where` were specified. Pull request courtesy @Adiorz.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5751](https://www.sqlalchemy.org/trac/ticket/5751)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[mssql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added SQL Server code “01000” to the list of disconnect codes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5646](https://www.sqlalchemy.org/trac/ticket/5646)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[mssql] [reflection] [sqlite]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue with composite primary key columns not being reported in the correct
    order. Patch courtesy @fulpm.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5661](https://www.sqlalchemy.org/trac/ticket/5661)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: oracle
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[oracle] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implemented support for the SERIALIZABLE isolation level for Oracle databases,
    as well as a real implementation for [`Connection.get_isolation_level()`](../core/connections.html#sqlalchemy.engine.Connection.get_isolation_level
    "sqlalchemy.engine.Connection.get_isolation_level").
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Transaction Isolation Level / Autocommit](../dialects/oracle.html#oracle-isolation-level)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5755](https://www.sqlalchemy.org/trac/ticket/5755)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 1.3.20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Released: October 12, 2020'
  prefs: []
  type: TYPE_NORMAL
- en: orm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An [`ArgumentError`](../core/exceptions.html#sqlalchemy.exc.ArgumentError "sqlalchemy.exc.ArgumentError")
    with more detail is now raised if the target parameter for [`Query.join()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join") is set to an unmapped object. Prior to this change
    a less detailed `AttributeError` was raised. Pull request courtesy Ramon Williams.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4428](https://www.sqlalchemy.org/trac/ticket/4428)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue where using a loader option against a string attribute name that
    is not actually a mapped attribute, such as a plain Python descriptor, would raise
    an uninformative AttributeError; a descriptive error is now raised.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4589](https://www.sqlalchemy.org/trac/ticket/4589)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: engine
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[engine] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue where a non-string object sent to [`SQLAlchemyError`](../core/exceptions.html#sqlalchemy.exc.SQLAlchemyError
    "sqlalchemy.exc.SQLAlchemyError") or a subclass, as occurs with some third party
    dialects, would fail to stringify correctly. Pull request courtesy Andrzej Bartosiński.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5599](https://www.sqlalchemy.org/trac/ticket/5599)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[engine] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Repaired a function-level import that was not using SQLAlchemy’s standard late-import
    system within the sqlalchemy.exc module.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5632](https://www.sqlalchemy.org/trac/ticket/5632)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[sql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue where the `pickle.dumps()` operation against [`Over`](../core/sqlelement.html#sqlalchemy.sql.expression.Over
    "sqlalchemy.sql.expression.Over") construct would produce a recursion overflow.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5644](https://www.sqlalchemy.org/trac/ticket/5644)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[sql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug where an error was not raised in the case where a [`column()`](../core/sqlelement.html#sqlalchemy.sql.expression.column
    "sqlalchemy.sql.expression.column") were added to more than one [`table()`](../core/selectable.html#sqlalchemy.sql.expression.table
    "sqlalchemy.sql.expression.table") at a time. This raised correctly for the [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") and [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects. An [`ArgumentError`](../core/exceptions.html#sqlalchemy.exc.ArgumentError
    "sqlalchemy.exc.ArgumentError") is now raised when this occurs.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5618](https://www.sqlalchemy.org/trac/ticket/5618)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: postgresql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[postgresql] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The psycopg2 dialect now support PostgreSQL multiple host connections, by passing
    host/port combinations to the query string. Pull request courtesy Ramon Williams.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Specifying multiple fallback hosts](../dialects/postgresql.html#psycopg2-multi-host)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4392](https://www.sqlalchemy.org/trac/ticket/4392)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[postgresql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adjusted the [`Comparator.any()`](../core/type_basics.html#sqlalchemy.types.ARRAY.Comparator.any
    "sqlalchemy.types.ARRAY.Comparator.any") and [`Comparator.all()`](../core/type_basics.html#sqlalchemy.types.ARRAY.Comparator.all
    "sqlalchemy.types.ARRAY.Comparator.all") methods to implement a straight “NOT”
    operation for negation, rather than negating the comparison operator.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5518](https://www.sqlalchemy.org/trac/ticket/5518)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[postgresql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue where the [`ENUM`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ENUM
    "sqlalchemy.dialects.postgresql.ENUM") type would not consult the schema translate
    map when emitting a CREATE TYPE or DROP TYPE during the test to see if the type
    exists or not. Additionally, repaired an issue where if the same enum were encountered
    multiple times in a single DDL sequence, the “check” query would run repeatedly
    rather than relying upon a cached value.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5520](https://www.sqlalchemy.org/trac/ticket/5520)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: mysql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[mysql] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adjusted the MySQL dialect to correctly parenthesize functional index expressions
    as accepted by MySQL 8\. Pull request courtesy Ramon Williams.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5462](https://www.sqlalchemy.org/trac/ticket/5462)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[mysql] [change]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Add new MySQL reserved words: `cube`, `lateral` added in MySQL 8.0.1 and 8.0.14,
    respectively; this indicates that these terms will be quoted if used as table
    or column identifier names.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5539](https://www.sqlalchemy.org/trac/ticket/5539)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[mysql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The “skip_locked” keyword used with `with_for_update()` will emit a warning
    when used on MariaDB backends, and will then be ignored. This is a deprecated
    behavior that will raise in SQLAlchemy 1.4, as an application that requests “skip
    locked” is looking for a non-blocking operation which is not available on those
    backends.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5568](https://www.sqlalchemy.org/trac/ticket/5568)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[mysql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug where an UPDATE statement against a JOIN using MySQL multi-table format
    would fail to include the table prefix for the target table if the statement had
    no WHERE clause, as only the WHERE clause were scanned to detect a “multi table
    update” at that particular point. The target is now also scanned if it’s a JOIN
    to get the leftmost table as the primary table and the additional entries as additional
    FROM entries.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5617](https://www.sqlalchemy.org/trac/ticket/5617)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: mssql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[mssql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue where a SQLAlchemy connection URI for Azure DW with `authentication=ActiveDirectoryIntegrated`
    (and no username+password) was not constructing the ODBC connection string in
    a way that was acceptable to the Azure DW instance.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5592](https://www.sqlalchemy.org/trac/ticket/5592)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: tests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[tests] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed incompatibilities in the test suite when running against Pytest 6.x.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5635](https://www.sqlalchemy.org/trac/ticket/5635)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: misc
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[bug] [pool]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Fixed issue where the following pool parameters were not being propagated to
    the new pool created when [`Engine.dispose()`](../core/connections.html#sqlalchemy.engine.Engine.dispose
    "sqlalchemy.engine.Engine.dispose") were called: `pre_ping`, `use_lifo`. Additionally
    the `recycle` and `reset_on_return` parameter is now propagated for the `AssertionPool`
    class.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5582](https://www.sqlalchemy.org/trac/ticket/5582)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[bug] [associationproxy] [ext]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An informative error is now raised when attempting to use an association proxy
    element as a plain column expression to be SELECTed from or used in a SQL function;
    this use case is not currently supported.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5541](https://www.sqlalchemy.org/trac/ticket/5541), [#5542](https://www.sqlalchemy.org/trac/ticket/5542)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: orm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An [`ArgumentError`](../core/exceptions.html#sqlalchemy.exc.ArgumentError "sqlalchemy.exc.ArgumentError")
    with more detail is now raised if the target parameter for [`Query.join()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join") is set to an unmapped object. Prior to this change
    a less detailed `AttributeError` was raised. Pull request courtesy Ramon Williams.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4428](https://www.sqlalchemy.org/trac/ticket/4428)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue where using a loader option against a string attribute name that
    is not actually a mapped attribute, such as a plain Python descriptor, would raise
    an uninformative AttributeError; a descriptive error is now raised.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4589](https://www.sqlalchemy.org/trac/ticket/4589)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: engine
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[engine] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue where a non-string object sent to [`SQLAlchemyError`](../core/exceptions.html#sqlalchemy.exc.SQLAlchemyError
    "sqlalchemy.exc.SQLAlchemyError") or a subclass, as occurs with some third party
    dialects, would fail to stringify correctly. Pull request courtesy Andrzej Bartosiński.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5599](https://www.sqlalchemy.org/trac/ticket/5599)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[engine] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Repaired a function-level import that was not using SQLAlchemy’s standard late-import
    system within the sqlalchemy.exc module.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5632](https://www.sqlalchemy.org/trac/ticket/5632)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[sql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue where the `pickle.dumps()` operation against [`Over`](../core/sqlelement.html#sqlalchemy.sql.expression.Over
    "sqlalchemy.sql.expression.Over") construct would produce a recursion overflow.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5644](https://www.sqlalchemy.org/trac/ticket/5644)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[sql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug where an error was not raised in the case where a [`column()`](../core/sqlelement.html#sqlalchemy.sql.expression.column
    "sqlalchemy.sql.expression.column") were added to more than one [`table()`](../core/selectable.html#sqlalchemy.sql.expression.table
    "sqlalchemy.sql.expression.table") at a time. This raised correctly for the [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") and [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects. An [`ArgumentError`](../core/exceptions.html#sqlalchemy.exc.ArgumentError
    "sqlalchemy.exc.ArgumentError") is now raised when this occurs.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5618](https://www.sqlalchemy.org/trac/ticket/5618)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: postgresql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[postgresql] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The psycopg2 dialect now support PostgreSQL multiple host connections, by passing
    host/port combinations to the query string. Pull request courtesy Ramon Williams.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Specifying multiple fallback hosts](../dialects/postgresql.html#psycopg2-multi-host)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4392](https://www.sqlalchemy.org/trac/ticket/4392)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[postgresql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adjusted the [`Comparator.any()`](../core/type_basics.html#sqlalchemy.types.ARRAY.Comparator.any
    "sqlalchemy.types.ARRAY.Comparator.any") and [`Comparator.all()`](../core/type_basics.html#sqlalchemy.types.ARRAY.Comparator.all
    "sqlalchemy.types.ARRAY.Comparator.all") methods to implement a straight “NOT”
    operation for negation, rather than negating the comparison operator.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5518](https://www.sqlalchemy.org/trac/ticket/5518)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[postgresql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue where the [`ENUM`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ENUM
    "sqlalchemy.dialects.postgresql.ENUM") type would not consult the schema translate
    map when emitting a CREATE TYPE or DROP TYPE during the test to see if the type
    exists or not. Additionally, repaired an issue where if the same enum were encountered
    multiple times in a single DDL sequence, the “check” query would run repeatedly
    rather than relying upon a cached value.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5520](https://www.sqlalchemy.org/trac/ticket/5520)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: mysql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[mysql] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adjusted the MySQL dialect to correctly parenthesize functional index expressions
    as accepted by MySQL 8\. Pull request courtesy Ramon Williams.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5462](https://www.sqlalchemy.org/trac/ticket/5462)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[mysql] [change]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Add new MySQL reserved words: `cube`, `lateral` added in MySQL 8.0.1 and 8.0.14,
    respectively; this indicates that these terms will be quoted if used as table
    or column identifier names.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5539](https://www.sqlalchemy.org/trac/ticket/5539)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[mysql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The “skip_locked” keyword used with `with_for_update()` will emit a warning
    when used on MariaDB backends, and will then be ignored. This is a deprecated
    behavior that will raise in SQLAlchemy 1.4, as an application that requests “skip
    locked” is looking for a non-blocking operation which is not available on those
    backends.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5568](https://www.sqlalchemy.org/trac/ticket/5568)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[mysql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug where an UPDATE statement against a JOIN using MySQL multi-table format
    would fail to include the table prefix for the target table if the statement had
    no WHERE clause, as only the WHERE clause were scanned to detect a “multi table
    update” at that particular point. The target is now also scanned if it’s a JOIN
    to get the leftmost table as the primary table and the additional entries as additional
    FROM entries.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5617](https://www.sqlalchemy.org/trac/ticket/5617)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: mssql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[mssql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue where a SQLAlchemy connection URI for Azure DW with `authentication=ActiveDirectoryIntegrated`
    (and no username+password) was not constructing the ODBC connection string in
    a way that was acceptable to the Azure DW instance.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5592](https://www.sqlalchemy.org/trac/ticket/5592)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: tests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[tests] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed incompatibilities in the test suite when running against Pytest 6.x.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5635](https://www.sqlalchemy.org/trac/ticket/5635)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: misc
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[bug] [pool]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Fixed issue where the following pool parameters were not being propagated to
    the new pool created when [`Engine.dispose()`](../core/connections.html#sqlalchemy.engine.Engine.dispose
    "sqlalchemy.engine.Engine.dispose") were called: `pre_ping`, `use_lifo`. Additionally
    the `recycle` and `reset_on_return` parameter is now propagated for the `AssertionPool`
    class.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5582](https://www.sqlalchemy.org/trac/ticket/5582)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[bug] [associationproxy] [ext]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An informative error is now raised when attempting to use an association proxy
    element as a plain column expression to be SELECTed from or used in a SQL function;
    this use case is not currently supported.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5541](https://www.sqlalchemy.org/trac/ticket/5541), [#5542](https://www.sqlalchemy.org/trac/ticket/5542)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 1.3.19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Released: August 17, 2020'
  prefs: []
  type: TYPE_NORMAL
- en: orm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[orm] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adjusted the workings of the [`Mapper.all_orm_descriptors()`](../orm/mapping_api.html#sqlalchemy.orm.Mapper.all_orm_descriptors
    "sqlalchemy.orm.Mapper.all_orm_descriptors") accessor to represent the attributes
    in the order that they are located in a deterministic way, assuming the use of
    Python 3.6 or higher which maintains the sorting order of class attributes based
    on how they were declared. This sorting is not guaranteed to match the declared
    order of attributes in all cases however; see the method documentation for the
    exact scheme.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5494](https://www.sqlalchemy.org/trac/ticket/5494)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: orm declarative
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[orm] [declarative] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The name of the virtual column used when using the [`AbstractConcreteBase`](../orm/extensions/declarative/index.html#sqlalchemy.ext.declarative.AbstractConcreteBase
    "sqlalchemy.ext.declarative.AbstractConcreteBase") and [`ConcreteBase`](../orm/extensions/declarative/index.html#sqlalchemy.ext.declarative.ConcreteBase
    "sqlalchemy.ext.declarative.ConcreteBase") classes can now be customized, to allow
    for models that have a column that is actually named `type`. Pull request courtesy
    Jesse-Bakker.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5513](https://www.sqlalchemy.org/trac/ticket/5513)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[sql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Repaired an issue where the “ORDER BY” clause rendering a label name rather
    than a complete expression, which is particularly important for SQL Server, would
    fail to occur if the expression were enclosed in a parenthesized grouping in some
    cases. This case has been added to test support. The change additionally adjusts
    the “automatically add ORDER BY columns when DISTINCT is present” behavior of
    ORM query, deprecated in 1.4, to more accurately detect column expressions that
    are already present.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5470](https://www.sqlalchemy.org/trac/ticket/5470)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[sql] [bug] [datatypes]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `LookupError` message will now provide the user with up to four possible
    values that a column is constrained to via the [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum"). Values longer than 11 characters will be truncated and
    replaced with ellipses. Pull request courtesy Ramon Williams.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4733](https://www.sqlalchemy.org/trac/ticket/4733)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[sql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue where the [`Connection.execution_options.schema_translate_map`](../core/connections.html#sqlalchemy.engine.Connection.execution_options.params.schema_translate_map
    "sqlalchemy.engine.Connection.execution_options") feature would not take effect
    when the [`Sequence.next_value()`](../core/defaults.html#sqlalchemy.schema.Sequence.next_value
    "sqlalchemy.schema.Sequence.next_value") function function for a [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence") were used in the [`Column.server_default`](../core/metadata.html#sqlalchemy.schema.Column.params.server_default
    "sqlalchemy.schema.Column") parameter and the create table DDL were emitted.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5500](https://www.sqlalchemy.org/trac/ticket/5500)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: postgresql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[postgresql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue where the return type for the various RANGE comparison operators
    would itself be the same RANGE type rather than BOOLEAN, which would cause an
    undesirable result in the case that a [`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") that defined result-processing behavior were
    in use. Pull request courtesy Jim Bosch.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5476](https://www.sqlalchemy.org/trac/ticket/5476)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: mysql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[mysql] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The MySQL dialect will render FROM DUAL for a SELECT statement that has no FROM
    clause but has a WHERE clause. This allows things like “SELECT 1 WHERE EXISTS
    (subquery)” kinds of queries to be used as well as other use cases.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5481](https://www.sqlalchemy.org/trac/ticket/5481)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[mysql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed an issue where CREATE TABLE statements were not specifying the COLLATE
    keyword correctly.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5411](https://www.sqlalchemy.org/trac/ticket/5411)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[mysql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added MariaDB code 1927 to the list of “disconnect” codes, as recent MariaDB
    versions apparently use this code when the database server was stopped.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5493](https://www.sqlalchemy.org/trac/ticket/5493)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sqlite
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[sqlite] [bug] [mssql] [reflection]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applied a sweep through all included dialects to ensure names that contain single
    or double quotes are properly escaped when querying system tables, for all [`Inspector`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector
    "sqlalchemy.engine.reflection.Inspector") methods that accept object names as
    an argument (e.g. table names, view names, etc). SQLite and MSSQL contained two
    quoting issues that were repaired.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5456](https://www.sqlalchemy.org/trac/ticket/5456)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: mssql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[mssql] [bug] [sql]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug where the mssql dialect incorrectly escaped object names that contained
    ‘]’ character(s).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5467](https://www.sqlalchemy.org/trac/ticket/5467)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: misc
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[usecase] [py3k]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added a `**kw` argument to the `DeclarativeMeta.__init__()` method. This allows
    a class to support the [**PEP 487**](https://peps.python.org/pep-0487/) metaclass
    hook `__init_subclass__`. Pull request courtesy Ewen Gillies.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [##5357](https://www.sqlalchemy.org/trac/ticket/#5357)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: orm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[orm] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adjusted the workings of the [`Mapper.all_orm_descriptors()`](../orm/mapping_api.html#sqlalchemy.orm.Mapper.all_orm_descriptors
    "sqlalchemy.orm.Mapper.all_orm_descriptors") accessor to represent the attributes
    in the order that they are located in a deterministic way, assuming the use of
    Python 3.6 or higher which maintains the sorting order of class attributes based
    on how they were declared. This sorting is not guaranteed to match the declared
    order of attributes in all cases however; see the method documentation for the
    exact scheme.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5494](https://www.sqlalchemy.org/trac/ticket/5494)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: orm declarative
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[orm] [declarative] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The name of the virtual column used when using the [`AbstractConcreteBase`](../orm/extensions/declarative/index.html#sqlalchemy.ext.declarative.AbstractConcreteBase
    "sqlalchemy.ext.declarative.AbstractConcreteBase") and [`ConcreteBase`](../orm/extensions/declarative/index.html#sqlalchemy.ext.declarative.ConcreteBase
    "sqlalchemy.ext.declarative.ConcreteBase") classes can now be customized, to allow
    for models that have a column that is actually named `type`. Pull request courtesy
    Jesse-Bakker.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5513](https://www.sqlalchemy.org/trac/ticket/5513)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[sql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Repaired an issue where the “ORDER BY” clause rendering a label name rather
    than a complete expression, which is particularly important for SQL Server, would
    fail to occur if the expression were enclosed in a parenthesized grouping in some
    cases. This case has been added to test support. The change additionally adjusts
    the “automatically add ORDER BY columns when DISTINCT is present” behavior of
    ORM query, deprecated in 1.4, to more accurately detect column expressions that
    are already present.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5470](https://www.sqlalchemy.org/trac/ticket/5470)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[sql] [bug] [datatypes]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `LookupError` message will now provide the user with up to four possible
    values that a column is constrained to via the [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum"). Values longer than 11 characters will be truncated and
    replaced with ellipses. Pull request courtesy Ramon Williams.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4733](https://www.sqlalchemy.org/trac/ticket/4733)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[sql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue where the [`Connection.execution_options.schema_translate_map`](../core/connections.html#sqlalchemy.engine.Connection.execution_options.params.schema_translate_map
    "sqlalchemy.engine.Connection.execution_options") feature would not take effect
    when the [`Sequence.next_value()`](../core/defaults.html#sqlalchemy.schema.Sequence.next_value
    "sqlalchemy.schema.Sequence.next_value") function function for a [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence") were used in the [`Column.server_default`](../core/metadata.html#sqlalchemy.schema.Column.params.server_default
    "sqlalchemy.schema.Column") parameter and the create table DDL were emitted.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5500](https://www.sqlalchemy.org/trac/ticket/5500)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: postgresql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[postgresql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue where the return type for the various RANGE comparison operators
    would itself be the same RANGE type rather than BOOLEAN, which would cause an
    undesirable result in the case that a [`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") that defined result-processing behavior were
    in use. Pull request courtesy Jim Bosch.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5476](https://www.sqlalchemy.org/trac/ticket/5476)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: mysql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[mysql] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The MySQL dialect will render FROM DUAL for a SELECT statement that has no FROM
    clause but has a WHERE clause. This allows things like “SELECT 1 WHERE EXISTS
    (subquery)” kinds of queries to be used as well as other use cases.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5481](https://www.sqlalchemy.org/trac/ticket/5481)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[mysql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed an issue where CREATE TABLE statements were not specifying the COLLATE
    keyword correctly.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5411](https://www.sqlalchemy.org/trac/ticket/5411)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[mysql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added MariaDB code 1927 to the list of “disconnect” codes, as recent MariaDB
    versions apparently use this code when the database server was stopped.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5493](https://www.sqlalchemy.org/trac/ticket/5493)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sqlite
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[sqlite] [bug] [mssql] [reflection]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applied a sweep through all included dialects to ensure names that contain single
    or double quotes are properly escaped when querying system tables, for all [`Inspector`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector
    "sqlalchemy.engine.reflection.Inspector") methods that accept object names as
    an argument (e.g. table names, view names, etc). SQLite and MSSQL contained two
    quoting issues that were repaired.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5456](https://www.sqlalchemy.org/trac/ticket/5456)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: mssql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[mssql] [bug] [sql]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug where the mssql dialect incorrectly escaped object names that contained
    ‘]’ character(s).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5467](https://www.sqlalchemy.org/trac/ticket/5467)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: misc
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[usecase] [py3k]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added a `**kw` argument to the `DeclarativeMeta.__init__()` method. This allows
    a class to support the [**PEP 487**](https://peps.python.org/pep-0487/) metaclass
    hook `__init_subclass__`. Pull request courtesy Ewen Gillies.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [##5357](https://www.sqlalchemy.org/trac/ticket/#5357)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 1.3.18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Released: June 25, 2020'
  prefs: []
  type: TYPE_NORMAL
- en: orm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[orm] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improve error message when using [`Query.filter_by()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.filter_by
    "sqlalchemy.orm.Query.filter_by") in a query where the first entity is not a mapped
    class.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5326](https://www.sqlalchemy.org/trac/ticket/5326)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added a new parameter [`query_expression.default_expr`](../orm/queryguide/columns.html#sqlalchemy.orm.query_expression.params.default_expr
    "sqlalchemy.orm.query_expression") to the [`query_expression()`](../orm/queryguide/columns.html#sqlalchemy.orm.query_expression
    "sqlalchemy.orm.query_expression") construct, which will be appled to queries
    automatically if the [`with_expression()`](../orm/queryguide/columns.html#sqlalchemy.orm.with_expression
    "sqlalchemy.orm.with_expression") option is not used. Pull request courtesy Haoyu
    Sun.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5198](https://www.sqlalchemy.org/trac/ticket/5198)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: examples
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[examples] [change]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added new option `--raw` to the examples.performance suite which will dump the
    raw profile test for consumption by any number of profiling visualizer tools.
    Removed the “runsnake” option as runsnake is very hard to build at this point;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: engine
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[engine] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further refinements to the fixes to the “reset” agent fixed in [#5326](https://www.sqlalchemy.org/trac/ticket/5326),
    which now emits a warning when it is not being correctly invoked and corrects
    for the behavior. Additional scenarios have been identified and fixed where this
    warning was being emitted.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5326](https://www.sqlalchemy.org/trac/ticket/5326)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[engine] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue in [`URL`](../core/engines.html#sqlalchemy.engine.URL "sqlalchemy.engine.URL")
    object where stringifying the object would not URL encode special characters,
    preventing the URL from being re-consumable as a real URL. Pull request courtesy
    Miguel Grinberg.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5341](https://www.sqlalchemy.org/trac/ticket/5341)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[sql] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added a “.schema” parameter to the [`table()`](../core/selectable.html#sqlalchemy.sql.expression.table
    "sqlalchemy.sql.expression.table") construct, allowing ad-hoc table expressions
    to also include a schema name. Pull request courtesy Dylan Modesitt.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5309](https://www.sqlalchemy.org/trac/ticket/5309)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[sql] [change] [sybase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added `.offset` support to sybase dialect. Pull request courtesy Alan D. Snow.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5294](https://www.sqlalchemy.org/trac/ticket/5294)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[sql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Correctly apply self_group in type_coerce element.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The type coerce element did not correctly apply grouping rules when using in
    an expression
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5344](https://www.sqlalchemy.org/trac/ticket/5344)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[sql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added [`Select.with_hint()`](../core/selectable.html#sqlalchemy.sql.expression.Select.with_hint
    "sqlalchemy.sql.expression.Select.with_hint") output to the generic SQL string
    that is produced when calling `str()` on a statement. Previously, this clause
    would be omitted under the assumption that it was dialect specific. The hint text
    is presented within brackets to indicate the rendering of such hints varies among
    backends.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5353](https://www.sqlalchemy.org/trac/ticket/5353)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[sql] [schema]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduce `IdentityOptions` to store common parameters for sequences and identity
    columns.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5324](https://www.sqlalchemy.org/trac/ticket/5324)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: schema
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[schema] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue where `dialect_options` were omitted when a database object (e.g.,
    [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table"))
    was copied using `tometadata()`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5276](https://www.sqlalchemy.org/trac/ticket/5276)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: mysql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[mysql] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implemented row-level locking support for mysql. Pull request courtesy Quentin
    Somerville.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4860](https://www.sqlalchemy.org/trac/ticket/4860)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sqlite
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[sqlite] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SQLite 3.31 added support for computed column. This change enables their support
    in SQLAlchemy when targeting SQLite.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5297](https://www.sqlalchemy.org/trac/ticket/5297)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[sqlite] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added “exists” to the list of reserved words for SQLite so that this word will
    be quoted when used as a label or column name. Pull request courtesy Thodoris
    Sotiropoulos.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5395](https://www.sqlalchemy.org/trac/ticket/5395)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: mssql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[mssql] [change]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moved the `supports_sane_rowcount_returning = False` requirement from the `PyODBCConnector`
    level to the `MSDialect_pyodbc` since pyodbc does work properly in some circumstances.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5321](https://www.sqlalchemy.org/trac/ticket/5321)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[mssql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refined the logic used by the SQL Server dialect to interpret multi-part schema
    names that contain many dots, to not actually lose any dots if the name does not
    have bracking or quoting used, and additionally to support a “dbname” token that
    has many parts including that it may have multiple, independently-bracketed sections.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5364](https://www.sqlalchemy.org/trac/ticket/5364), [#5366](https://www.sqlalchemy.org/trac/ticket/5366)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[mssql] [bug] [pyodbc]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed an issue in the pyodbc connector such that a warning about pyodbc “drivername”
    would be emitted when using a totally empty URL. Empty URLs are normal when producing
    a non-connected dialect object or when using the “creator” argument to create_engine().
    The warning now only emits if the driver name is missing but other parameters
    are still present.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5346](https://www.sqlalchemy.org/trac/ticket/5346)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[mssql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue with assembling the ODBC connection string for the pyodbc DBAPI.
    Tokens containing semicolons and/or braces “{}” were not being correctly escaped,
    causing the ODBC driver to misinterpret the connection string attributes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5373](https://www.sqlalchemy.org/trac/ticket/5373)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[mssql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue where `datetime.time` parameters were being converted to `datetime.datetime`,
    making them incompatible with comparisons like `>=` against an actual [`TIME`](../dialects/mssql.html#sqlalchemy.dialects.mssql.TIME
    "sqlalchemy.dialects.mssql.TIME") column.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5339](https://www.sqlalchemy.org/trac/ticket/5339)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[mssql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed an issue where the `is_disconnect` function in the SQL Server pyodbc dialect
    was incorrectly reporting the disconnect state when the exception message had
    a substring that matched a SQL Server ODBC error code.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5359](https://www.sqlalchemy.org/trac/ticket/5359)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: oracle
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[oracle] [bug] [reflection]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug in Oracle dialect where indexes that contain the full set of primary
    key columns would be mistaken as the primary key index itself, which is omitted,
    even if there were multiples. The check has been refined to compare the name of
    the primary key constraint against the index name itself, rather than trying to
    guess based on the columns present in the index.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5421](https://www.sqlalchemy.org/trac/ticket/5421)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: orm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[orm] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improve error message when using [`Query.filter_by()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.filter_by
    "sqlalchemy.orm.Query.filter_by") in a query where the first entity is not a mapped
    class.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5326](https://www.sqlalchemy.org/trac/ticket/5326)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added a new parameter [`query_expression.default_expr`](../orm/queryguide/columns.html#sqlalchemy.orm.query_expression.params.default_expr
    "sqlalchemy.orm.query_expression") to the [`query_expression()`](../orm/queryguide/columns.html#sqlalchemy.orm.query_expression
    "sqlalchemy.orm.query_expression") construct, which will be appled to queries
    automatically if the [`with_expression()`](../orm/queryguide/columns.html#sqlalchemy.orm.with_expression
    "sqlalchemy.orm.with_expression") option is not used. Pull request courtesy Haoyu
    Sun.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5198](https://www.sqlalchemy.org/trac/ticket/5198)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: examples
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[examples] [change]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added new option `--raw` to the examples.performance suite which will dump the
    raw profile test for consumption by any number of profiling visualizer tools.
    Removed the “runsnake” option as runsnake is very hard to build at this point;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: engine
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[engine] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further refinements to the fixes to the “reset” agent fixed in [#5326](https://www.sqlalchemy.org/trac/ticket/5326),
    which now emits a warning when it is not being correctly invoked and corrects
    for the behavior. Additional scenarios have been identified and fixed where this
    warning was being emitted.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5326](https://www.sqlalchemy.org/trac/ticket/5326)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[engine] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue in [`URL`](../core/engines.html#sqlalchemy.engine.URL "sqlalchemy.engine.URL")
    object where stringifying the object would not URL encode special characters,
    preventing the URL from being re-consumable as a real URL. Pull request courtesy
    Miguel Grinberg.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5341](https://www.sqlalchemy.org/trac/ticket/5341)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[sql] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added a “.schema” parameter to the [`table()`](../core/selectable.html#sqlalchemy.sql.expression.table
    "sqlalchemy.sql.expression.table") construct, allowing ad-hoc table expressions
    to also include a schema name. Pull request courtesy Dylan Modesitt.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5309](https://www.sqlalchemy.org/trac/ticket/5309)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[sql] [change] [sybase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added `.offset` support to sybase dialect. Pull request courtesy Alan D. Snow.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5294](https://www.sqlalchemy.org/trac/ticket/5294)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[sql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Correctly apply self_group in type_coerce element.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The type coerce element did not correctly apply grouping rules when using in
    an expression
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5344](https://www.sqlalchemy.org/trac/ticket/5344)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[sql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added [`Select.with_hint()`](../core/selectable.html#sqlalchemy.sql.expression.Select.with_hint
    "sqlalchemy.sql.expression.Select.with_hint") output to the generic SQL string
    that is produced when calling `str()` on a statement. Previously, this clause
    would be omitted under the assumption that it was dialect specific. The hint text
    is presented within brackets to indicate the rendering of such hints varies among
    backends.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5353](https://www.sqlalchemy.org/trac/ticket/5353)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[sql] [schema]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduce `IdentityOptions` to store common parameters for sequences and identity
    columns.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5324](https://www.sqlalchemy.org/trac/ticket/5324)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: schema
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[schema] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue where `dialect_options` were omitted when a database object (e.g.,
    [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table"))
    was copied using `tometadata()`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5276](https://www.sqlalchemy.org/trac/ticket/5276)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: mysql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[mysql] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implemented row-level locking support for mysql. Pull request courtesy Quentin
    Somerville.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4860](https://www.sqlalchemy.org/trac/ticket/4860)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sqlite
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[sqlite] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SQLite 3.31 added support for computed column. This change enables their support
    in SQLAlchemy when targeting SQLite.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5297](https://www.sqlalchemy.org/trac/ticket/5297)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[sqlite] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added “exists” to the list of reserved words for SQLite so that this word will
    be quoted when used as a label or column name. Pull request courtesy Thodoris
    Sotiropoulos.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5395](https://www.sqlalchemy.org/trac/ticket/5395)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: mssql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[mssql] [change]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moved the `supports_sane_rowcount_returning = False` requirement from the `PyODBCConnector`
    level to the `MSDialect_pyodbc` since pyodbc does work properly in some circumstances.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5321](https://www.sqlalchemy.org/trac/ticket/5321)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[mssql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refined the logic used by the SQL Server dialect to interpret multi-part schema
    names that contain many dots, to not actually lose any dots if the name does not
    have bracking or quoting used, and additionally to support a “dbname” token that
    has many parts including that it may have multiple, independently-bracketed sections.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5364](https://www.sqlalchemy.org/trac/ticket/5364), [#5366](https://www.sqlalchemy.org/trac/ticket/5366)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[mssql] [bug] [pyodbc]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed an issue in the pyodbc connector such that a warning about pyodbc “drivername”
    would be emitted when using a totally empty URL. Empty URLs are normal when producing
    a non-connected dialect object or when using the “creator” argument to create_engine().
    The warning now only emits if the driver name is missing but other parameters
    are still present.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5346](https://www.sqlalchemy.org/trac/ticket/5346)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[mssql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue with assembling the ODBC connection string for the pyodbc DBAPI.
    Tokens containing semicolons and/or braces “{}” were not being correctly escaped,
    causing the ODBC driver to misinterpret the connection string attributes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5373](https://www.sqlalchemy.org/trac/ticket/5373)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[mssql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue where `datetime.time` parameters were being converted to `datetime.datetime`,
    making them incompatible with comparisons like `>=` against an actual [`TIME`](../dialects/mssql.html#sqlalchemy.dialects.mssql.TIME
    "sqlalchemy.dialects.mssql.TIME") column.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5339](https://www.sqlalchemy.org/trac/ticket/5339)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[mssql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed an issue where the `is_disconnect` function in the SQL Server pyodbc dialect
    was incorrectly reporting the disconnect state when the exception message had
    a substring that matched a SQL Server ODBC error code.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5359](https://www.sqlalchemy.org/trac/ticket/5359)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: oracle
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[oracle] [bug] [reflection]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug in Oracle dialect where indexes that contain the full set of primary
    key columns would be mistaken as the primary key index itself, which is omitted,
    even if there were multiples. The check has been refined to compare the name of
    the primary key constraint against the index name itself, rather than trying to
    guess based on the columns present in the index.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5421](https://www.sqlalchemy.org/trac/ticket/5421)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 1.3.17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Released: May 13, 2020'
  prefs: []
  type: TYPE_NORMAL
- en: orm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[orm] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added an accessor [`Comparator.expressions`](../orm/internals.html#sqlalchemy.orm.ColumnProperty.Comparator.expressions
    "sqlalchemy.orm.ColumnProperty.Comparator.expressions") which provides access
    to the group of columns mapped under a multi-column [`ColumnProperty`](../orm/internals.html#sqlalchemy.orm.ColumnProperty
    "sqlalchemy.orm.ColumnProperty") attribute.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5262](https://www.sqlalchemy.org/trac/ticket/5262)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduce [`relationship.sync_backref`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.sync_backref
    "sqlalchemy.orm.relationship") flag in a relationship to control if the synchronization
    events that mutate the in-Python attributes are added. This supersedes the previous
    change [#5149](https://www.sqlalchemy.org/trac/ticket/5149), which warned that
    `viewonly=True` relationship target of a back_populates or backref configuration
    would be disallowed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5237](https://www.sqlalchemy.org/trac/ticket/5237)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug where using [`with_polymorphic()`](../orm/queryguide/inheritance.html#sqlalchemy.orm.with_polymorphic
    "sqlalchemy.orm.with_polymorphic") as the target of a join via `RelationshipComparator.of_type()`
    on a mapper that already has a subquery-based with_polymorphic setting that’s
    equivalent to the one requested would not correctly alias the ON clause in the
    join.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5288](https://www.sqlalchemy.org/trac/ticket/5288)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue in the area of where loader options such as selectinload() interact
    with the baked query system, such that the caching of a query is not supposed
    to occur if the loader options themselves have elements such as with_polymorphic()
    objects in them that currently are not cache-compatible. The baked loader could
    sometimes not fully invalidate itself in these some of these scenarios leading
    to missed eager loads.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5303](https://www.sqlalchemy.org/trac/ticket/5303)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modified the internal “identity set” implementation, which is a set that hashes
    objects on their id() rather than their hash values, to not actually call the
    `__hash__()` method of the objects, which are typically user-mapped objects. Some
    methods were calling this method as a side effect of the implementation.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5304](https://www.sqlalchemy.org/trac/ticket/5304)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An informative error message is raised when an ORM many-to-one comparison is
    attempted against an object that is not an actual mapped instance. Comparisons
    such as those to scalar subqueries aren’t supported; generalized comparison with
    subqueries is better achieved using [`Comparator.has()`](../orm/internals.html#sqlalchemy.orm.RelationshipProperty.Comparator.has
    "sqlalchemy.orm.RelationshipProperty.Comparator.has").
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5269](https://www.sqlalchemy.org/trac/ticket/5269)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: engine
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[engine] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed fairly critical issue where the DBAPI connection could be returned to
    the connection pool while still in an un-rolled-back state. The reset agent responsible
    for rolling back the connection could be corrupted in the case that the transaction
    was “closed” without being rolled back or committed, which can occur in some scenarios
    when using ORM sessions and emitting .close() in a certain pattern involving savepoints.
    The fix ensures that the reset agent is always active.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5326](https://www.sqlalchemy.org/trac/ticket/5326)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: schema
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[schema] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue where an [`Index`](../core/constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index") that is deferred in being associated with a table,
    such as as when it contains a [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") that is not associated with any [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") yet, would fail to attach correctly if it also contained
    a non table-oriented expression.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5298](https://www.sqlalchemy.org/trac/ticket/5298)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[schema] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A warning is emitted when making use of the [`MetaData.sorted_tables`](../core/metadata.html#sqlalchemy.schema.MetaData.sorted_tables
    "sqlalchemy.schema.MetaData.sorted_tables") attribute as well as the [`sort_tables()`](../core/ddl.html#sqlalchemy.schema.sort_tables
    "sqlalchemy.schema.sort_tables") function, and the given tables cannot be correctly
    sorted due to a cyclic dependency between foreign key constraints. In this case,
    the functions will no longer sort the involved tables by foreign key, and a warning
    will be emitted. Other tables that are not part of the cycle will still be returned
    in dependency order. Previously, the sorted_table routines would return a collection
    that would unconditionally omit all foreign keys when a cycle was detected, and
    no warning was emitted.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5316](https://www.sqlalchemy.org/trac/ticket/5316)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[schema]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add `comment` attribute to [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") `__repr__` method.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4138](https://www.sqlalchemy.org/trac/ticket/4138)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: postgresql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[postgresql] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added support for columns or type [`ARRAY`](../core/type_basics.html#sqlalchemy.types.ARRAY
    "sqlalchemy.types.ARRAY") of [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum"), [`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON
    "sqlalchemy.dialects.postgresql.JSON") or [`JSONB`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSONB
    "sqlalchemy.dialects.postgresql.JSONB") in PostgreSQL. Previously a workaround
    was required in these use cases.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5265](https://www.sqlalchemy.org/trac/ticket/5265)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[postgresql] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Raise an explicit [`CompileError`](../core/exceptions.html#sqlalchemy.exc.CompileError
    "sqlalchemy.exc.CompileError") when adding a table with a column of type [`ARRAY`](../core/type_basics.html#sqlalchemy.types.ARRAY
    "sqlalchemy.types.ARRAY") of [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum") configured with [`Enum.native_enum`](../core/type_basics.html#sqlalchemy.types.Enum.params.native_enum
    "sqlalchemy.types.Enum") set to `False` when [`Enum.create_constraint`](../core/type_basics.html#sqlalchemy.types.Enum.params.create_constraint
    "sqlalchemy.types.Enum") is not set to `False`
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5266](https://www.sqlalchemy.org/trac/ticket/5266)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: mssql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[mssql] [bug] [reflection]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fix a regression introduced by the reflection of computed column in MSSQL when
    using the legacy TDS version 4.2\. The dialect will try to detect the protocol
    version of first connect and run in compatibility mode if it cannot detect it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5255](https://www.sqlalchemy.org/trac/ticket/5255)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[mssql] [bug] [reflection]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fix a regression introduced by the reflection of computed column in MSSQL when
    using SQL server versions before 2012, which does not support the `concat` function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5271](https://www.sqlalchemy.org/trac/ticket/5271)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: oracle
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[oracle] [performance] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changed the implementation of fetching CLOB and BLOB objects to use cx_Oracle’s
    native implementation which fetches CLOB/BLOB objects inline with other result
    columns, rather than performing a separate fetch. As always, this can be disabled
    by setting auto_convert_lobs to False.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As part of this change, the behavior of a CLOB that was given a blank string
    on INSERT now returns None on SELECT, which is now consistent with that of VARCHAR
    on Oracle.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5314](https://www.sqlalchemy.org/trac/ticket/5314)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[oracle] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some modifications to how the cx_oracle dialect sets up per-column outputtype
    handlers for LOB and numeric datatypes to adjust for potential changes coming
    in cx_Oracle 8.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5246](https://www.sqlalchemy.org/trac/ticket/5246)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: misc
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[change] [firebird]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adjusted dialect loading for `firebird://` URIs so the external sqlalchemy-firebird
    dialect will be used if it has been installed, otherwise fall back to the (now
    deprecated) internal Firebird dialect.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5278](https://www.sqlalchemy.org/trac/ticket/5278)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: orm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[orm] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added an accessor [`Comparator.expressions`](../orm/internals.html#sqlalchemy.orm.ColumnProperty.Comparator.expressions
    "sqlalchemy.orm.ColumnProperty.Comparator.expressions") which provides access
    to the group of columns mapped under a multi-column [`ColumnProperty`](../orm/internals.html#sqlalchemy.orm.ColumnProperty
    "sqlalchemy.orm.ColumnProperty") attribute.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5262](https://www.sqlalchemy.org/trac/ticket/5262)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduce [`relationship.sync_backref`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.sync_backref
    "sqlalchemy.orm.relationship") flag in a relationship to control if the synchronization
    events that mutate the in-Python attributes are added. This supersedes the previous
    change [#5149](https://www.sqlalchemy.org/trac/ticket/5149), which warned that
    `viewonly=True` relationship target of a back_populates or backref configuration
    would be disallowed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5237](https://www.sqlalchemy.org/trac/ticket/5237)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug where using [`with_polymorphic()`](../orm/queryguide/inheritance.html#sqlalchemy.orm.with_polymorphic
    "sqlalchemy.orm.with_polymorphic") as the target of a join via `RelationshipComparator.of_type()`
    on a mapper that already has a subquery-based with_polymorphic setting that’s
    equivalent to the one requested would not correctly alias the ON clause in the
    join.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5288](https://www.sqlalchemy.org/trac/ticket/5288)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue in the area of where loader options such as selectinload() interact
    with the baked query system, such that the caching of a query is not supposed
    to occur if the loader options themselves have elements such as with_polymorphic()
    objects in them that currently are not cache-compatible. The baked loader could
    sometimes not fully invalidate itself in these some of these scenarios leading
    to missed eager loads.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5303](https://www.sqlalchemy.org/trac/ticket/5303)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modified the internal “identity set” implementation, which is a set that hashes
    objects on their id() rather than their hash values, to not actually call the
    `__hash__()` method of the objects, which are typically user-mapped objects. Some
    methods were calling this method as a side effect of the implementation.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5304](https://www.sqlalchemy.org/trac/ticket/5304)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An informative error message is raised when an ORM many-to-one comparison is
    attempted against an object that is not an actual mapped instance. Comparisons
    such as those to scalar subqueries aren’t supported; generalized comparison with
    subqueries is better achieved using [`Comparator.has()`](../orm/internals.html#sqlalchemy.orm.RelationshipProperty.Comparator.has
    "sqlalchemy.orm.RelationshipProperty.Comparator.has").
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5269](https://www.sqlalchemy.org/trac/ticket/5269)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: engine
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[engine] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed fairly critical issue where the DBAPI connection could be returned to
    the connection pool while still in an un-rolled-back state. The reset agent responsible
    for rolling back the connection could be corrupted in the case that the transaction
    was “closed” without being rolled back or committed, which can occur in some scenarios
    when using ORM sessions and emitting .close() in a certain pattern involving savepoints.
    The fix ensures that the reset agent is always active.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5326](https://www.sqlalchemy.org/trac/ticket/5326)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: schema
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[schema] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue where an [`Index`](../core/constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index") that is deferred in being associated with a table,
    such as as when it contains a [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") that is not associated with any [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") yet, would fail to attach correctly if it also contained
    a non table-oriented expression.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5298](https://www.sqlalchemy.org/trac/ticket/5298)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[schema] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A warning is emitted when making use of the [`MetaData.sorted_tables`](../core/metadata.html#sqlalchemy.schema.MetaData.sorted_tables
    "sqlalchemy.schema.MetaData.sorted_tables") attribute as well as the [`sort_tables()`](../core/ddl.html#sqlalchemy.schema.sort_tables
    "sqlalchemy.schema.sort_tables") function, and the given tables cannot be correctly
    sorted due to a cyclic dependency between foreign key constraints. In this case,
    the functions will no longer sort the involved tables by foreign key, and a warning
    will be emitted. Other tables that are not part of the cycle will still be returned
    in dependency order. Previously, the sorted_table routines would return a collection
    that would unconditionally omit all foreign keys when a cycle was detected, and
    no warning was emitted.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5316](https://www.sqlalchemy.org/trac/ticket/5316)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[schema]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add `comment` attribute to [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") `__repr__` method.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4138](https://www.sqlalchemy.org/trac/ticket/4138)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: postgresql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[postgresql] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added support for columns or type [`ARRAY`](../core/type_basics.html#sqlalchemy.types.ARRAY
    "sqlalchemy.types.ARRAY") of [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum"), [`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON
    "sqlalchemy.dialects.postgresql.JSON") or [`JSONB`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSONB
    "sqlalchemy.dialects.postgresql.JSONB") in PostgreSQL. Previously a workaround
    was required in these use cases.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5265](https://www.sqlalchemy.org/trac/ticket/5265)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[postgresql] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Raise an explicit [`CompileError`](../core/exceptions.html#sqlalchemy.exc.CompileError
    "sqlalchemy.exc.CompileError") when adding a table with a column of type [`ARRAY`](../core/type_basics.html#sqlalchemy.types.ARRAY
    "sqlalchemy.types.ARRAY") of [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum") configured with [`Enum.native_enum`](../core/type_basics.html#sqlalchemy.types.Enum.params.native_enum
    "sqlalchemy.types.Enum") set to `False` when [`Enum.create_constraint`](../core/type_basics.html#sqlalchemy.types.Enum.params.create_constraint
    "sqlalchemy.types.Enum") is not set to `False`
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5266](https://www.sqlalchemy.org/trac/ticket/5266)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: mssql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[mssql] [bug] [reflection]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fix a regression introduced by the reflection of computed column in MSSQL when
    using the legacy TDS version 4.2\. The dialect will try to detect the protocol
    version of first connect and run in compatibility mode if it cannot detect it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5255](https://www.sqlalchemy.org/trac/ticket/5255)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[mssql] [bug] [reflection]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fix a regression introduced by the reflection of computed column in MSSQL when
    using SQL server versions before 2012, which does not support the `concat` function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5271](https://www.sqlalchemy.org/trac/ticket/5271)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: oracle
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[oracle] [performance] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changed the implementation of fetching CLOB and BLOB objects to use cx_Oracle’s
    native implementation which fetches CLOB/BLOB objects inline with other result
    columns, rather than performing a separate fetch. As always, this can be disabled
    by setting auto_convert_lobs to False.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As part of this change, the behavior of a CLOB that was given a blank string
    on INSERT now returns None on SELECT, which is now consistent with that of VARCHAR
    on Oracle.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5314](https://www.sqlalchemy.org/trac/ticket/5314)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[oracle] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some modifications to how the cx_oracle dialect sets up per-column outputtype
    handlers for LOB and numeric datatypes to adjust for potential changes coming
    in cx_Oracle 8.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5246](https://www.sqlalchemy.org/trac/ticket/5246)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: misc
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[change] [firebird]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adjusted dialect loading for `firebird://` URIs so the external sqlalchemy-firebird
    dialect will be used if it has been installed, otherwise fall back to the (now
    deprecated) internal Firebird dialect.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5278](https://www.sqlalchemy.org/trac/ticket/5278)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 1.3.16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Released: April 7, 2020'
  prefs: []
  type: TYPE_NORMAL
- en: orm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[orm] [performance]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modified the queries used by subqueryload and selectinload to no longer ORDER
    BY the primary key of the parent entity; this ordering was there to allow the
    rows as they come in to be copied into lists directly with a minimal level of
    Python-side collation. However, these ORDER BY clauses can negatively impact the
    performance of the query as in many scenarios these columns are derived from a
    subquery or are otherwise not actual primary key columns such that SQL planners
    cannot make use of indexes. The Python-side collation uses the native itertools.group_by()
    to collate the incoming rows, and has been modified to allow multiple row-groups-per-parent
    to be assembled together using list.extend(), which should still allow for relatively
    fast Python-side performance. There will still be an ORDER BY present for a relationship
    that includes an explicit order_by parameter, however this is the only ORDER BY
    that will be added to the query for both kinds of loading.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5162](https://www.sqlalchemy.org/trac/ticket/5162)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug in [`selectinload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.selectinload
    "sqlalchemy.orm.selectinload") loading option where two or more loaders that represent
    different relationships with the same string key name as referenced from a single
    [`with_polymorphic()`](../orm/queryguide/inheritance.html#sqlalchemy.orm.with_polymorphic
    "sqlalchemy.orm.with_polymorphic") construct with multiple subclass mappers would
    fail to invoke each subqueryload separately, instead making use of a single string-based
    slot that would prevent the other loaders from being invoked.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5228](https://www.sqlalchemy.org/trac/ticket/5228)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue where a lazyload that uses session-local “get” against a target
    many-to-one relationship where an object with the correct primary key is present,
    however it’s an instance of a sibling class, does not correctly return None as
    is the case when the lazy loader actually emits a load for that row.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5210](https://www.sqlalchemy.org/trac/ticket/5210)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: orm declarative
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[orm] [declarative] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The string argument accepted as the first positional argument by the [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") function when using the Declarative API is no longer
    interpreted using the Python `eval()` function; instead, the name is dot separated
    and the names are looked up directly in the name resolution dictionary without
    treating the value as a Python expression. However, passing a string argument
    to the other [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") parameters that necessarily must accept Python
    expressions will still use `eval()`; the documentation has been clarified to ensure
    that there is no ambiguity that this is in use.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Evaluation of relationship arguments](../orm/extensions/declarative/relationships.html#declarative-relationship-eval)
    - details on string evaluation'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5238](https://www.sqlalchemy.org/trac/ticket/5238)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[sql] [types]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add ability to literal compile a `DateTime`, `Date` or `Time` when using the
    string dialect for debugging purposes. This change does not impact real dialect
    implementation that retain their current behavior.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5052](https://www.sqlalchemy.org/trac/ticket/5052)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: schema
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[schema] [reflection]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added support for reflection of “computed” columns, which are now returned as
    part of the structure returned by [`Inspector.get_columns()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_columns
    "sqlalchemy.engine.reflection.Inspector.get_columns"). When reflecting full [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects, computed columns will be represented using
    the [`Computed`](../core/defaults.html#sqlalchemy.schema.Computed "sqlalchemy.schema.Computed")
    construct.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5063](https://www.sqlalchemy.org/trac/ticket/5063)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: postgresql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[postgresql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue where a “covering” index, e.g. those which have an INCLUDE clause,
    would be reflected including all the columns in INCLUDE clause as regular columns.
    A warning is now emitted if these additional columns are detected indicating that
    they are currently ignored. Note that full support for “covering” indexes is part
    of [#4458](https://www.sqlalchemy.org/trac/ticket/4458). Pull request courtesy
    Marat Sharafutdinov.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5205](https://www.sqlalchemy.org/trac/ticket/5205)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: mysql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[mysql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue in MySQL dialect when connecting to a pseudo-MySQL database such
    as that provided by ProxySQL, the up front check for isolation level when it returns
    no row will not prevent the dialect from continuing to connect. A warning is emitted
    that the isolation level could not be detected.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5239](https://www.sqlalchemy.org/trac/ticket/5239)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sqlite
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[sqlite] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implemented AUTOCOMMIT isolation level for SQLite when using pysqlite.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5164](https://www.sqlalchemy.org/trac/ticket/5164)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: mssql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[mssql] [usecase] [mysql] [oracle]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added support for [`ColumnOperators.is_distinct_from()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.is_distinct_from
    "sqlalchemy.sql.expression.ColumnOperators.is_distinct_from") and [`ColumnOperators.isnot_distinct_from()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.isnot_distinct_from
    "sqlalchemy.sql.expression.ColumnOperators.isnot_distinct_from") to SQL Server,
    MySQL, and Oracle.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5137](https://www.sqlalchemy.org/trac/ticket/5137)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: oracle
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[oracle] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implemented AUTOCOMMIT isolation level for Oracle when using cx_Oracle. Also
    added a fixed default isolation level of READ COMMITTED for Oracle.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5200](https://www.sqlalchemy.org/trac/ticket/5200)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[oracle] [bug] [reflection]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed regression / incorrect fix caused by fix for [#5146](https://www.sqlalchemy.org/trac/ticket/5146)
    where the Oracle dialect reads from the “all_tab_comments” view to get table comments
    but fails to accommodate for the current owner of the table being requested, causing
    it to read the wrong comment if multiple tables of the same name exist in multiple
    schemas.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5146](https://www.sqlalchemy.org/trac/ticket/5146)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: tests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[tests] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed an issue that prevented the test suite from running with the recently
    released py.test 5.4.0.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5201](https://www.sqlalchemy.org/trac/ticket/5201)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: misc
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[enum] [types]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.types.Enum")
    type now supports the parameter [`Enum.length`](../core/type_basics.html#sqlalchemy.types.Enum.params.length
    "sqlalchemy.types.Enum") to specify the length of the VARCHAR column to create
    when using non native enums by setting [`Enum.native_enum`](../core/type_basics.html#sqlalchemy.types.Enum.params.native_enum
    "sqlalchemy.types.Enum") to `False`
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5183](https://www.sqlalchemy.org/trac/ticket/5183)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[installer]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensured that the “pyproject.toml” file is not included in builds, as the presence
    of this file indicates to pip that a pep-517 installation process should be used.
    As this mode of operation appears to be not well supported by current tools /
    distros, these problems are avoided within the scope of SQLAlchemy installation
    by omitting the file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5207](https://www.sqlalchemy.org/trac/ticket/5207)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: orm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[orm] [performance]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modified the queries used by subqueryload and selectinload to no longer ORDER
    BY the primary key of the parent entity; this ordering was there to allow the
    rows as they come in to be copied into lists directly with a minimal level of
    Python-side collation. However, these ORDER BY clauses can negatively impact the
    performance of the query as in many scenarios these columns are derived from a
    subquery or are otherwise not actual primary key columns such that SQL planners
    cannot make use of indexes. The Python-side collation uses the native itertools.group_by()
    to collate the incoming rows, and has been modified to allow multiple row-groups-per-parent
    to be assembled together using list.extend(), which should still allow for relatively
    fast Python-side performance. There will still be an ORDER BY present for a relationship
    that includes an explicit order_by parameter, however this is the only ORDER BY
    that will be added to the query for both kinds of loading.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5162](https://www.sqlalchemy.org/trac/ticket/5162)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug in [`selectinload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.selectinload
    "sqlalchemy.orm.selectinload") loading option where two or more loaders that represent
    different relationships with the same string key name as referenced from a single
    [`with_polymorphic()`](../orm/queryguide/inheritance.html#sqlalchemy.orm.with_polymorphic
    "sqlalchemy.orm.with_polymorphic") construct with multiple subclass mappers would
    fail to invoke each subqueryload separately, instead making use of a single string-based
    slot that would prevent the other loaders from being invoked.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5228](https://www.sqlalchemy.org/trac/ticket/5228)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue where a lazyload that uses session-local “get” against a target
    many-to-one relationship where an object with the correct primary key is present,
    however it’s an instance of a sibling class, does not correctly return None as
    is the case when the lazy loader actually emits a load for that row.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5210](https://www.sqlalchemy.org/trac/ticket/5210)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: orm declarative
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[orm] [declarative] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The string argument accepted as the first positional argument by the [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") function when using the Declarative API is no longer
    interpreted using the Python `eval()` function; instead, the name is dot separated
    and the names are looked up directly in the name resolution dictionary without
    treating the value as a Python expression. However, passing a string argument
    to the other [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") parameters that necessarily must accept Python
    expressions will still use `eval()`; the documentation has been clarified to ensure
    that there is no ambiguity that this is in use.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Evaluation of relationship arguments](../orm/extensions/declarative/relationships.html#declarative-relationship-eval)
    - details on string evaluation'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5238](https://www.sqlalchemy.org/trac/ticket/5238)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[sql] [types]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add ability to literal compile a `DateTime`, `Date` or `Time` when using the
    string dialect for debugging purposes. This change does not impact real dialect
    implementation that retain their current behavior.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5052](https://www.sqlalchemy.org/trac/ticket/5052)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: schema
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[schema] [reflection]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added support for reflection of “computed” columns, which are now returned as
    part of the structure returned by [`Inspector.get_columns()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_columns
    "sqlalchemy.engine.reflection.Inspector.get_columns"). When reflecting full [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects, computed columns will be represented using
    the [`Computed`](../core/defaults.html#sqlalchemy.schema.Computed "sqlalchemy.schema.Computed")
    construct.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5063](https://www.sqlalchemy.org/trac/ticket/5063)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: postgresql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[postgresql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue where a “covering” index, e.g. those which have an INCLUDE clause,
    would be reflected including all the columns in INCLUDE clause as regular columns.
    A warning is now emitted if these additional columns are detected indicating that
    they are currently ignored. Note that full support for “covering” indexes is part
    of [#4458](https://www.sqlalchemy.org/trac/ticket/4458). Pull request courtesy
    Marat Sharafutdinov.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5205](https://www.sqlalchemy.org/trac/ticket/5205)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: mysql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[mysql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue in MySQL dialect when connecting to a pseudo-MySQL database such
    as that provided by ProxySQL, the up front check for isolation level when it returns
    no row will not prevent the dialect from continuing to connect. A warning is emitted
    that the isolation level could not be detected.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5239](https://www.sqlalchemy.org/trac/ticket/5239)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sqlite
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[sqlite] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implemented AUTOCOMMIT isolation level for SQLite when using pysqlite.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5164](https://www.sqlalchemy.org/trac/ticket/5164)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: mssql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[mssql] [usecase] [mysql] [oracle]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added support for [`ColumnOperators.is_distinct_from()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.is_distinct_from
    "sqlalchemy.sql.expression.ColumnOperators.is_distinct_from") and [`ColumnOperators.isnot_distinct_from()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.isnot_distinct_from
    "sqlalchemy.sql.expression.ColumnOperators.isnot_distinct_from") to SQL Server,
    MySQL, and Oracle.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5137](https://www.sqlalchemy.org/trac/ticket/5137)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: oracle
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[oracle] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implemented AUTOCOMMIT isolation level for Oracle when using cx_Oracle. Also
    added a fixed default isolation level of READ COMMITTED for Oracle.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5200](https://www.sqlalchemy.org/trac/ticket/5200)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[oracle] [bug] [reflection]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed regression / incorrect fix caused by fix for [#5146](https://www.sqlalchemy.org/trac/ticket/5146)
    where the Oracle dialect reads from the “all_tab_comments” view to get table comments
    but fails to accommodate for the current owner of the table being requested, causing
    it to read the wrong comment if multiple tables of the same name exist in multiple
    schemas.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5146](https://www.sqlalchemy.org/trac/ticket/5146)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: tests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[tests] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed an issue that prevented the test suite from running with the recently
    released py.test 5.4.0.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5201](https://www.sqlalchemy.org/trac/ticket/5201)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: misc
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[enum] [types]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.types.Enum")
    type now supports the parameter [`Enum.length`](../core/type_basics.html#sqlalchemy.types.Enum.params.length
    "sqlalchemy.types.Enum") to specify the length of the VARCHAR column to create
    when using non native enums by setting [`Enum.native_enum`](../core/type_basics.html#sqlalchemy.types.Enum.params.native_enum
    "sqlalchemy.types.Enum") to `False`
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5183](https://www.sqlalchemy.org/trac/ticket/5183)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[installer]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensured that the “pyproject.toml” file is not included in builds, as the presence
    of this file indicates to pip that a pep-517 installation process should be used.
    As this mode of operation appears to be not well supported by current tools /
    distros, these problems are avoided within the scope of SQLAlchemy installation
    by omitting the file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5207](https://www.sqlalchemy.org/trac/ticket/5207)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 1.3.15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Released: March 11, 2020'
  prefs: []
  type: TYPE_NORMAL
- en: orm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adjusted the error message emitted by [`Query.join()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join") when a left hand side can’t be located that the [`Query.select_from()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.select_from
    "sqlalchemy.orm.Query.select_from") method is the best way to resolve the issue.
    Also, within the 1.3 series, used a deterministic ordering when determining the
    FROM clause from a given column entity passed to [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") so that the same expression is determined each time.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5194](https://www.sqlalchemy.org/trac/ticket/5194)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed regression in 1.3.14 due to [#4849](https://www.sqlalchemy.org/trac/ticket/4849)
    where a sys.exc_info() call failed to be invoked correctly when a flush error
    would occur. Test coverage has been added for this exception case.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5196](https://www.sqlalchemy.org/trac/ticket/5196)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: orm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adjusted the error message emitted by [`Query.join()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join") when a left hand side can’t be located that the [`Query.select_from()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.select_from
    "sqlalchemy.orm.Query.select_from") method is the best way to resolve the issue.
    Also, within the 1.3 series, used a deterministic ordering when determining the
    FROM clause from a given column entity passed to [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") so that the same expression is determined each time.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5194](https://www.sqlalchemy.org/trac/ticket/5194)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed regression in 1.3.14 due to [#4849](https://www.sqlalchemy.org/trac/ticket/4849)
    where a sys.exc_info() call failed to be invoked correctly when a flush error
    would occur. Test coverage has been added for this exception case.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5196](https://www.sqlalchemy.org/trac/ticket/5196)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 1.3.14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Released: March 10, 2020'
  prefs: []
  type: TYPE_NORMAL
- en: general
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[general] [bug] [py3k]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applied an explicit “cause” to most if not all internally raised exceptions
    that are raised from within an internal exception catch, to avoid misleading stacktraces
    that suggest an error within the handling of an exception. While it would be preferable
    to suppress the internally caught exception in the way that the `__suppress_context__`
    attribute would, there does not as yet seem to be a way to do this without suppressing
    an enclosing user constructed context, so for now it exposes the internally caught
    exception as the cause so that full information about the context of the error
    is maintained.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4849](https://www.sqlalchemy.org/trac/ticket/4849)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: orm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[orm] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added a new flag [`InstanceEvents.restore_load_context`](../orm/events.html#sqlalchemy.orm.InstanceEvents.params.restore_load_context
    "sqlalchemy.orm.InstanceEvents") and [`SessionEvents.restore_load_context`](../orm/events.html#sqlalchemy.orm.SessionEvents.params.restore_load_context
    "sqlalchemy.orm.SessionEvents") which apply to the [`InstanceEvents.load()`](../orm/events.html#sqlalchemy.orm.InstanceEvents.load
    "sqlalchemy.orm.InstanceEvents.load"), [`InstanceEvents.refresh()`](../orm/events.html#sqlalchemy.orm.InstanceEvents.refresh
    "sqlalchemy.orm.InstanceEvents.refresh"), and [`SessionEvents.loaded_as_persistent()`](../orm/events.html#sqlalchemy.orm.SessionEvents.loaded_as_persistent
    "sqlalchemy.orm.SessionEvents.loaded_as_persistent") events, which when set will
    restore the “load context” of the object after the event hook has been called.
    This ensures that the object remains within the “loader context” of the load operation
    that is already ongoing, rather than the object being transferred to a new load
    context due to refresh operations which may have occurred in the event. A warning
    is now emitted when this condition occurs, which recommends use of the flag to
    resolve this case. The flag is “opt-in” so that there is no risk introduced to
    existing applications.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The change additionally adds support for the `raw=True` flag to session lifecycle
    events.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5129](https://www.sqlalchemy.org/trac/ticket/5129)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed regression caused in 1.3.13 by [#5056](https://www.sqlalchemy.org/trac/ticket/5056)
    where a refactor of the ORM path registry system made it such that a path could
    no longer be compared to an empty tuple, which can occur in a particular kind
    of joined eager loading path. The “empty tuple” use case has been resolved so
    that the path registry is compared to a path registry in all cases; the `PathRegistry`
    object itself now implements `__eq__()` and `__ne__()` methods which will take
    place for all equality comparisons and continue to succeed in the not anticipated
    case that a non- `PathRegistry` object is compared, while emitting a warning that
    this object should not be the subject of the comparison.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5110](https://www.sqlalchemy.org/trac/ticket/5110)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting a relationship to viewonly=True which is also the target of a back_populates
    or backref configuration will now emit a warning and eventually be disallowed.
    back_populates refers specifically to mutation of an attribute or collection,
    which is disallowed when the attribute is subject to viewonly=True. The viewonly
    attribute is not subject to persistence behaviors which means it will not reflect
    correct results when it is locally mutated.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5149](https://www.sqlalchemy.org/trac/ticket/5149)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed an additional regression in the same area as that of [#5080](https://www.sqlalchemy.org/trac/ticket/5080)
    introduced in 1.3.0b3 via [#4468](https://www.sqlalchemy.org/trac/ticket/4468)
    where the ability to create a joined option across a [`with_polymorphic()`](../orm/queryguide/inheritance.html#sqlalchemy.orm.with_polymorphic
    "sqlalchemy.orm.with_polymorphic") into a relationship against the base class
    of that with_polymorphic, and then further into regular mapped relationships would
    fail as the base class component would not add itself to the load path in a way
    that could be located by the loader strategy. The changes applied in [#5080](https://www.sqlalchemy.org/trac/ticket/5080)
    have been further refined to also accommodate this scenario.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5121](https://www.sqlalchemy.org/trac/ticket/5121)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: engine
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[engine] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Expanded the scope of cursor/connection cleanup when a statement is executed
    to include when the result object fails to be constructed, or an after_cursor_execute()
    event raises an error, or autocommit / autoclose fails. This allows the DBAPI
    cursor to be cleaned up on failure and for connectionless execution allows the
    connection to be closed out and returned to the connection pool, where previously
    it waiting until garbage collection would trigger a pool return.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5182](https://www.sqlalchemy.org/trac/ticket/5182)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[sql] [bug] [postgresql]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug where a CTE of an INSERT/UPDATE/DELETE that also uses RETURNING could
    then not be SELECTed from directly, as the internal state of the compiler would
    try to treat the outer SELECT as a DELETE statement itself and access nonexistent
    state.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5181](https://www.sqlalchemy.org/trac/ticket/5181)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: postgresql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[postgresql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue where the “schema_translate_map” feature would not work with a PostgreSQL
    native enumeration type (i.e. [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum"), [`ENUM`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ENUM
    "sqlalchemy.dialects.postgresql.ENUM")) in that while the “CREATE TYPE” statement
    would be emitted with the correct schema, the schema would not be rendered in
    the CREATE TABLE statement at the point at which the enumeration was referenced.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5158](https://www.sqlalchemy.org/trac/ticket/5158)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[postgresql] [bug] [reflection]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug where PostgreSQL reflection of CHECK constraints would fail to parse
    the constraint if the SQL text contained newline characters. The regular expression
    has been adjusted to accommodate for this case. Pull request courtesy Eric Borczuk.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5170](https://www.sqlalchemy.org/trac/ticket/5170)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: mysql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[mysql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue in MySQL [`Insert.on_duplicate_key_update()`](../dialects/mysql.html#sqlalchemy.dialects.mysql.Insert.on_duplicate_key_update
    "sqlalchemy.dialects.mysql.Insert.on_duplicate_key_update") construct where using
    a SQL function or other composed expression for a column argument would not properly
    render the `VALUES` keyword surrounding the column itself.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5173](https://www.sqlalchemy.org/trac/ticket/5173)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: mssql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[mssql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue where the [`DATETIMEOFFSET`](../dialects/mssql.html#sqlalchemy.dialects.mssql.DATETIMEOFFSET
    "sqlalchemy.dialects.mssql.DATETIMEOFFSET") type would not accommodate for the
    `None` value, introduced as part of the series of fixes for this type first introduced
    in [#4983](https://www.sqlalchemy.org/trac/ticket/4983), [#5045](https://www.sqlalchemy.org/trac/ticket/5045).
    Additionally, added support for passing a backend-specific date formatted string
    through this type, as is typically allowed for date/time types on most other DBAPIs.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5132](https://www.sqlalchemy.org/trac/ticket/5132)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: oracle
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[oracle] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed a reflection bug where table comments could only be retrieved for tables
    actually owned by the user but not for tables visible to the user but owned by
    someone else. Pull request courtesy Dave Hirschfeld.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5146](https://www.sqlalchemy.org/trac/ticket/5146)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: misc
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[usecase] [ext]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added keyword arguments to the [`MutableList.sort()`](../orm/extensions/mutable.html#sqlalchemy.ext.mutable.MutableList.sort
    "sqlalchemy.ext.mutable.MutableList.sort") function so that a key function as
    well as the “reverse” keyword argument can be provided.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5114](https://www.sqlalchemy.org/trac/ticket/5114)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[performance] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Revised an internal change to the test system added as a result of [#5085](https://www.sqlalchemy.org/trac/ticket/5085)
    where a testing-related module per dialect would be loaded unconditionally upon
    making use of that dialect, pulling in SQLAlchemy’s testing framework as well
    as the ORM into the module import space. This would only impact initial startup
    time and memory to a modest extent, however it’s best that these additional modules
    aren’t reverse-dependent on straight Core usage.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5180](https://www.sqlalchemy.org/trac/ticket/5180)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[bug] [installation]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vendored the `inspect.formatannotation` function inside of `sqlalchemy.util.compat`,
    which is needed for the vendored version of `inspect.formatargspec`. The function
    is not documented in cPython and is not guaranteed to be available in future Python
    versions.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5138](https://www.sqlalchemy.org/trac/ticket/5138)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: general
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[general] [bug] [py3k]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applied an explicit “cause” to most if not all internally raised exceptions
    that are raised from within an internal exception catch, to avoid misleading stacktraces
    that suggest an error within the handling of an exception. While it would be preferable
    to suppress the internally caught exception in the way that the `__suppress_context__`
    attribute would, there does not as yet seem to be a way to do this without suppressing
    an enclosing user constructed context, so for now it exposes the internally caught
    exception as the cause so that full information about the context of the error
    is maintained.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4849](https://www.sqlalchemy.org/trac/ticket/4849)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: orm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[orm] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added a new flag [`InstanceEvents.restore_load_context`](../orm/events.html#sqlalchemy.orm.InstanceEvents.params.restore_load_context
    "sqlalchemy.orm.InstanceEvents") and [`SessionEvents.restore_load_context`](../orm/events.html#sqlalchemy.orm.SessionEvents.params.restore_load_context
    "sqlalchemy.orm.SessionEvents") which apply to the [`InstanceEvents.load()`](../orm/events.html#sqlalchemy.orm.InstanceEvents.load
    "sqlalchemy.orm.InstanceEvents.load"), [`InstanceEvents.refresh()`](../orm/events.html#sqlalchemy.orm.InstanceEvents.refresh
    "sqlalchemy.orm.InstanceEvents.refresh"), and [`SessionEvents.loaded_as_persistent()`](../orm/events.html#sqlalchemy.orm.SessionEvents.loaded_as_persistent
    "sqlalchemy.orm.SessionEvents.loaded_as_persistent") events, which when set will
    restore the “load context” of the object after the event hook has been called.
    This ensures that the object remains within the “loader context” of the load operation
    that is already ongoing, rather than the object being transferred to a new load
    context due to refresh operations which may have occurred in the event. A warning
    is now emitted when this condition occurs, which recommends use of the flag to
    resolve this case. The flag is “opt-in” so that there is no risk introduced to
    existing applications.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The change additionally adds support for the `raw=True` flag to session lifecycle
    events.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5129](https://www.sqlalchemy.org/trac/ticket/5129)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed regression caused in 1.3.13 by [#5056](https://www.sqlalchemy.org/trac/ticket/5056)
    where a refactor of the ORM path registry system made it such that a path could
    no longer be compared to an empty tuple, which can occur in a particular kind
    of joined eager loading path. The “empty tuple” use case has been resolved so
    that the path registry is compared to a path registry in all cases; the `PathRegistry`
    object itself now implements `__eq__()` and `__ne__()` methods which will take
    place for all equality comparisons and continue to succeed in the not anticipated
    case that a non- `PathRegistry` object is compared, while emitting a warning that
    this object should not be the subject of the comparison.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5110](https://www.sqlalchemy.org/trac/ticket/5110)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting a relationship to viewonly=True which is also the target of a back_populates
    or backref configuration will now emit a warning and eventually be disallowed.
    back_populates refers specifically to mutation of an attribute or collection,
    which is disallowed when the attribute is subject to viewonly=True. The viewonly
    attribute is not subject to persistence behaviors which means it will not reflect
    correct results when it is locally mutated.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5149](https://www.sqlalchemy.org/trac/ticket/5149)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed an additional regression in the same area as that of [#5080](https://www.sqlalchemy.org/trac/ticket/5080)
    introduced in 1.3.0b3 via [#4468](https://www.sqlalchemy.org/trac/ticket/4468)
    where the ability to create a joined option across a [`with_polymorphic()`](../orm/queryguide/inheritance.html#sqlalchemy.orm.with_polymorphic
    "sqlalchemy.orm.with_polymorphic") into a relationship against the base class
    of that with_polymorphic, and then further into regular mapped relationships would
    fail as the base class component would not add itself to the load path in a way
    that could be located by the loader strategy. The changes applied in [#5080](https://www.sqlalchemy.org/trac/ticket/5080)
    have been further refined to also accommodate this scenario.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5121](https://www.sqlalchemy.org/trac/ticket/5121)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: engine
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[engine] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Expanded the scope of cursor/connection cleanup when a statement is executed
    to include when the result object fails to be constructed, or an after_cursor_execute()
    event raises an error, or autocommit / autoclose fails. This allows the DBAPI
    cursor to be cleaned up on failure and for connectionless execution allows the
    connection to be closed out and returned to the connection pool, where previously
    it waiting until garbage collection would trigger a pool return.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5182](https://www.sqlalchemy.org/trac/ticket/5182)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[sql] [bug] [postgresql]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug where a CTE of an INSERT/UPDATE/DELETE that also uses RETURNING could
    then not be SELECTed from directly, as the internal state of the compiler would
    try to treat the outer SELECT as a DELETE statement itself and access nonexistent
    state.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5181](https://www.sqlalchemy.org/trac/ticket/5181)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: postgresql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[postgresql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue where the “schema_translate_map” feature would not work with a PostgreSQL
    native enumeration type (i.e. [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum"), [`ENUM`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ENUM
    "sqlalchemy.dialects.postgresql.ENUM")) in that while the “CREATE TYPE” statement
    would be emitted with the correct schema, the schema would not be rendered in
    the CREATE TABLE statement at the point at which the enumeration was referenced.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5158](https://www.sqlalchemy.org/trac/ticket/5158)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[postgresql] [bug] [reflection]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug where PostgreSQL reflection of CHECK constraints would fail to parse
    the constraint if the SQL text contained newline characters. The regular expression
    has been adjusted to accommodate for this case. Pull request courtesy Eric Borczuk.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5170](https://www.sqlalchemy.org/trac/ticket/5170)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: mysql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[mysql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue in MySQL [`Insert.on_duplicate_key_update()`](../dialects/mysql.html#sqlalchemy.dialects.mysql.Insert.on_duplicate_key_update
    "sqlalchemy.dialects.mysql.Insert.on_duplicate_key_update") construct where using
    a SQL function or other composed expression for a column argument would not properly
    render the `VALUES` keyword surrounding the column itself.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5173](https://www.sqlalchemy.org/trac/ticket/5173)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: mssql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[mssql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue where the [`DATETIMEOFFSET`](../dialects/mssql.html#sqlalchemy.dialects.mssql.DATETIMEOFFSET
    "sqlalchemy.dialects.mssql.DATETIMEOFFSET") type would not accommodate for the
    `None` value, introduced as part of the series of fixes for this type first introduced
    in [#4983](https://www.sqlalchemy.org/trac/ticket/4983), [#5045](https://www.sqlalchemy.org/trac/ticket/5045).
    Additionally, added support for passing a backend-specific date formatted string
    through this type, as is typically allowed for date/time types on most other DBAPIs.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5132](https://www.sqlalchemy.org/trac/ticket/5132)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: oracle
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[oracle] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed a reflection bug where table comments could only be retrieved for tables
    actually owned by the user but not for tables visible to the user but owned by
    someone else. Pull request courtesy Dave Hirschfeld.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5146](https://www.sqlalchemy.org/trac/ticket/5146)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: misc
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[usecase] [ext]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added keyword arguments to the [`MutableList.sort()`](../orm/extensions/mutable.html#sqlalchemy.ext.mutable.MutableList.sort
    "sqlalchemy.ext.mutable.MutableList.sort") function so that a key function as
    well as the “reverse” keyword argument can be provided.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5114](https://www.sqlalchemy.org/trac/ticket/5114)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[performance] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Revised an internal change to the test system added as a result of [#5085](https://www.sqlalchemy.org/trac/ticket/5085)
    where a testing-related module per dialect would be loaded unconditionally upon
    making use of that dialect, pulling in SQLAlchemy’s testing framework as well
    as the ORM into the module import space. This would only impact initial startup
    time and memory to a modest extent, however it’s best that these additional modules
    aren’t reverse-dependent on straight Core usage.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5180](https://www.sqlalchemy.org/trac/ticket/5180)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[bug] [installation]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vendored the `inspect.formatannotation` function inside of `sqlalchemy.util.compat`,
    which is needed for the vendored version of `inspect.formatargspec`. The function
    is not documented in cPython and is not guaranteed to be available in future Python
    versions.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5138](https://www.sqlalchemy.org/trac/ticket/5138)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 1.3.13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Released: January 22, 2020'
  prefs: []
  type: TYPE_NORMAL
- en: orm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[orm] [performance]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identified a performance issue in the system by which a join is constructed
    based on a mapped relationship. The clause adaption system would be used for the
    majority of join expressions including in the common case where no adaptation
    is needed. The conditions under which this adaptation occur have been refined
    so that average non-aliased joins along a simple relationship without a “secondary”
    table use about 70% less function calls.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug] [engine]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added test support and repaired a wide variety of unnecessary reference cycles
    created for short-lived objects, mostly in the area of ORM queries. Thanks much
    to Carson Ip for the help on this.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5050](https://www.sqlalchemy.org/trac/ticket/5050), [#5056](https://www.sqlalchemy.org/trac/ticket/5056),
    [#5071](https://www.sqlalchemy.org/trac/ticket/5071)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed regression in loader options introduced in 1.3.0b3 via [#4468](https://www.sqlalchemy.org/trac/ticket/4468)
    where the ability to create a loader option using [`PropComparator.of_type()`](../orm/internals.html#sqlalchemy.orm.PropComparator.of_type
    "sqlalchemy.orm.PropComparator.of_type") targeting an aliased entity that is an
    inheriting subclass of the entity which the preceding relationship refers to would
    fail to produce a matching path. See also [#5082](https://www.sqlalchemy.org/trac/ticket/5082)
    fixed in this same release which involves a similar kind of issue.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5107](https://www.sqlalchemy.org/trac/ticket/5107)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed regression in joined eager loading introduced in 1.3.0b3 via [#4468](https://www.sqlalchemy.org/trac/ticket/4468)
    where the ability to create a joined option across a [`with_polymorphic()`](../orm/queryguide/inheritance.html#sqlalchemy.orm.with_polymorphic
    "sqlalchemy.orm.with_polymorphic") into a polymorphic subclass using `RelationshipProperty.of_type()`
    and then further along regular mapped relationships would fail as the polymorphic
    subclass would not add itself to the load path in a way that could be located
    by the loader strategy. A tweak has been made to resolve this scenario.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5082](https://www.sqlalchemy.org/trac/ticket/5082)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Repaired a warning in the ORM flush process that was not covered by test coverage
    when deleting objects that use the “version_id” feature. This warning is generally
    unreachable unless using a dialect that sets the “supports_sane_rowcount” flag
    to False, which is not typically the case however is possible for some MySQL configurations
    as well as older Firebird drivers, and likely some third party dialects.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5068](https://www.sqlalchemy.org/trac/ticket/5068)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug where usage of joined eager loading would not properly wrap the query
    inside of a subquery when [`Query.group_by()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.group_by
    "sqlalchemy.orm.Query.group_by") were used against the query. When any kind of
    result-limiting approach is used, such as DISTINCT, LIMIT, OFFSET, joined eager
    loading embeds the row-limited query inside of a subquery so that the collection
    results are not impacted. For some reason, the presence of GROUP BY was never
    included in this criterion, even though it has a similar effect as using DISTINCT.
    Additionally, the bug would prevent using GROUP BY at all for a joined eager load
    query for most database platforms which forbid non-aggregated, non-grouped columns
    from being in the query, as the additional columns for the joined eager load would
    not be accepted by the database.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5065](https://www.sqlalchemy.org/trac/ticket/5065)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: engine
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[engine] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue where the collection of value processors on a [`Compiled`](../core/internals.html#sqlalchemy.engine.Compiled
    "sqlalchemy.engine.Compiled") object would be mutated when “expanding IN” parameters
    were used with a datatype that has bind value processors; in particular, this
    would mean that when using statement caching and/or baked queries, the same compiled._bind_processors
    collection would be mutated concurrently. Since these processors are the same
    function for a given bind parameter namespace every time, there was no actual
    negative effect of this issue, however, the execution of a [`Compiled`](../core/internals.html#sqlalchemy.engine.Compiled
    "sqlalchemy.engine.Compiled") object should never be causing any changes in its
    state, especially given that they are intended to be thread-safe and reusable
    once fully constructed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5048](https://www.sqlalchemy.org/trac/ticket/5048)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[sql] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A function created using [`GenericFunction`](../core/functions.html#sqlalchemy.sql.functions.GenericFunction
    "sqlalchemy.sql.functions.GenericFunction") can now specify that the name of the
    function should be rendered with or without quotes by assigning the [`quoted_name`](../core/sqlelement.html#sqlalchemy.sql.expression.quoted_name
    "sqlalchemy.sql.expression.quoted_name") construct to the .name element of the
    object. Prior to 1.3.4, quoting was never applied to function names, and some
    quoting was introduced in [#4467](https://www.sqlalchemy.org/trac/ticket/4467)
    but no means to force quoting for a mixed case name was available. Additionally,
    the [`quoted_name`](../core/sqlelement.html#sqlalchemy.sql.expression.quoted_name
    "sqlalchemy.sql.expression.quoted_name") construct when used as the name will
    properly register its lowercase name in the function registry so that the name
    continues to be available via the `func.` registry.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`GenericFunction`](../core/functions.html#sqlalchemy.sql.functions.GenericFunction
    "sqlalchemy.sql.functions.GenericFunction")'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5079](https://www.sqlalchemy.org/trac/ticket/5079)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: postgresql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[postgresql] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added support for prefixes to the [`CTE`](../core/selectable.html#sqlalchemy.sql.expression.CTE
    "sqlalchemy.sql.expression.CTE") construct, to allow support for Postgresql 12
    “MATERIALIZED” and “NOT MATERIALIZED” phrases. Pull request courtesy Marat Sharafutdinov.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`HasCTE.cte()`](../core/selectable.html#sqlalchemy.sql.expression.HasCTE.cte
    "sqlalchemy.sql.expression.HasCTE.cte")'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5040](https://www.sqlalchemy.org/trac/ticket/5040)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[postgresql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue where the PostgreSQL dialect would fail to parse a reflected CHECK
    constraint that was a boolean-valued function (as opposed to a boolean-valued
    expression).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5039](https://www.sqlalchemy.org/trac/ticket/5039)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: mssql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[mssql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue where a timezone-aware `datetime` value being converted to string
    for use as a parameter value of a [`DATETIMEOFFSET`](../dialects/mssql.html#sqlalchemy.dialects.mssql.DATETIMEOFFSET
    "sqlalchemy.dialects.mssql.DATETIMEOFFSET") column was omitting the fractional
    seconds.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5045](https://www.sqlalchemy.org/trac/ticket/5045)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: tests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[tests] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed a few test failures which would occur on Windows due to SQLite file locking
    issues, as well as some timing issues in connection pool related tests; pull request
    courtesy Federico Caselli.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4946](https://www.sqlalchemy.org/trac/ticket/4946)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[tests] [postgresql]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improved detection of two phase transactions requirement for the PostgreSQL
    database by testing that max_prepared_transactions is set to a value greater than
    0\. Pull request courtesy Federico Caselli.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5057](https://www.sqlalchemy.org/trac/ticket/5057)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: misc
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[bug] [ext]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug in sqlalchemy.ext.serializer where a unique [`BindParameter`](../core/sqlelement.html#sqlalchemy.sql.expression.BindParameter
    "sqlalchemy.sql.expression.BindParameter") object could conflict with itself if
    it were present in the mapping itself, as well as the filter condition of the
    query, as one side would be used against the non-deserialized version and the
    other side would use the deserialized version. Logic is added to [`BindParameter`](../core/sqlelement.html#sqlalchemy.sql.expression.BindParameter
    "sqlalchemy.sql.expression.BindParameter") similar to its “clone” method which
    will uniquify the parameter name upon deserialize so that it doesn’t conflict
    with its original.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5086](https://www.sqlalchemy.org/trac/ticket/5086)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: orm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[orm] [performance]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identified a performance issue in the system by which a join is constructed
    based on a mapped relationship. The clause adaption system would be used for the
    majority of join expressions including in the common case where no adaptation
    is needed. The conditions under which this adaptation occur have been refined
    so that average non-aliased joins along a simple relationship without a “secondary”
    table use about 70% less function calls.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug] [engine]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added test support and repaired a wide variety of unnecessary reference cycles
    created for short-lived objects, mostly in the area of ORM queries. Thanks much
    to Carson Ip for the help on this.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5050](https://www.sqlalchemy.org/trac/ticket/5050), [#5056](https://www.sqlalchemy.org/trac/ticket/5056),
    [#5071](https://www.sqlalchemy.org/trac/ticket/5071)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed regression in loader options introduced in 1.3.0b3 via [#4468](https://www.sqlalchemy.org/trac/ticket/4468)
    where the ability to create a loader option using [`PropComparator.of_type()`](../orm/internals.html#sqlalchemy.orm.PropComparator.of_type
    "sqlalchemy.orm.PropComparator.of_type") targeting an aliased entity that is an
    inheriting subclass of the entity which the preceding relationship refers to would
    fail to produce a matching path. See also [#5082](https://www.sqlalchemy.org/trac/ticket/5082)
    fixed in this same release which involves a similar kind of issue.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5107](https://www.sqlalchemy.org/trac/ticket/5107)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed regression in joined eager loading introduced in 1.3.0b3 via [#4468](https://www.sqlalchemy.org/trac/ticket/4468)
    where the ability to create a joined option across a [`with_polymorphic()`](../orm/queryguide/inheritance.html#sqlalchemy.orm.with_polymorphic
    "sqlalchemy.orm.with_polymorphic") into a polymorphic subclass using `RelationshipProperty.of_type()`
    and then further along regular mapped relationships would fail as the polymorphic
    subclass would not add itself to the load path in a way that could be located
    by the loader strategy. A tweak has been made to resolve this scenario.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5082](https://www.sqlalchemy.org/trac/ticket/5082)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Repaired a warning in the ORM flush process that was not covered by test coverage
    when deleting objects that use the “version_id” feature. This warning is generally
    unreachable unless using a dialect that sets the “supports_sane_rowcount” flag
    to False, which is not typically the case however is possible for some MySQL configurations
    as well as older Firebird drivers, and likely some third party dialects.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5068](https://www.sqlalchemy.org/trac/ticket/5068)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug where usage of joined eager loading would not properly wrap the query
    inside of a subquery when [`Query.group_by()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.group_by
    "sqlalchemy.orm.Query.group_by") were used against the query. When any kind of
    result-limiting approach is used, such as DISTINCT, LIMIT, OFFSET, joined eager
    loading embeds the row-limited query inside of a subquery so that the collection
    results are not impacted. For some reason, the presence of GROUP BY was never
    included in this criterion, even though it has a similar effect as using DISTINCT.
    Additionally, the bug would prevent using GROUP BY at all for a joined eager load
    query for most database platforms which forbid non-aggregated, non-grouped columns
    from being in the query, as the additional columns for the joined eager load would
    not be accepted by the database.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5065](https://www.sqlalchemy.org/trac/ticket/5065)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: engine
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[engine] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue where the collection of value processors on a [`Compiled`](../core/internals.html#sqlalchemy.engine.Compiled
    "sqlalchemy.engine.Compiled") object would be mutated when “expanding IN” parameters
    were used with a datatype that has bind value processors; in particular, this
    would mean that when using statement caching and/or baked queries, the same compiled._bind_processors
    collection would be mutated concurrently. Since these processors are the same
    function for a given bind parameter namespace every time, there was no actual
    negative effect of this issue, however, the execution of a [`Compiled`](../core/internals.html#sqlalchemy.engine.Compiled
    "sqlalchemy.engine.Compiled") object should never be causing any changes in its
    state, especially given that they are intended to be thread-safe and reusable
    once fully constructed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5048](https://www.sqlalchemy.org/trac/ticket/5048)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[sql] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A function created using [`GenericFunction`](../core/functions.html#sqlalchemy.sql.functions.GenericFunction
    "sqlalchemy.sql.functions.GenericFunction") can now specify that the name of the
    function should be rendered with or without quotes by assigning the [`quoted_name`](../core/sqlelement.html#sqlalchemy.sql.expression.quoted_name
    "sqlalchemy.sql.expression.quoted_name") construct to the .name element of the
    object. Prior to 1.3.4, quoting was never applied to function names, and some
    quoting was introduced in [#4467](https://www.sqlalchemy.org/trac/ticket/4467)
    but no means to force quoting for a mixed case name was available. Additionally,
    the [`quoted_name`](../core/sqlelement.html#sqlalchemy.sql.expression.quoted_name
    "sqlalchemy.sql.expression.quoted_name") construct when used as the name will
    properly register its lowercase name in the function registry so that the name
    continues to be available via the `func.` registry.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`GenericFunction`](../core/functions.html#sqlalchemy.sql.functions.GenericFunction
    "sqlalchemy.sql.functions.GenericFunction")'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5079](https://www.sqlalchemy.org/trac/ticket/5079)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: postgresql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[postgresql] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added support for prefixes to the [`CTE`](../core/selectable.html#sqlalchemy.sql.expression.CTE
    "sqlalchemy.sql.expression.CTE") construct, to allow support for Postgresql 12
    “MATERIALIZED” and “NOT MATERIALIZED” phrases. Pull request courtesy Marat Sharafutdinov.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`HasCTE.cte()`](../core/selectable.html#sqlalchemy.sql.expression.HasCTE.cte
    "sqlalchemy.sql.expression.HasCTE.cte")'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5040](https://www.sqlalchemy.org/trac/ticket/5040)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[postgresql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue where the PostgreSQL dialect would fail to parse a reflected CHECK
    constraint that was a boolean-valued function (as opposed to a boolean-valued
    expression).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5039](https://www.sqlalchemy.org/trac/ticket/5039)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: mssql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[mssql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue where a timezone-aware `datetime` value being converted to string
    for use as a parameter value of a [`DATETIMEOFFSET`](../dialects/mssql.html#sqlalchemy.dialects.mssql.DATETIMEOFFSET
    "sqlalchemy.dialects.mssql.DATETIMEOFFSET") column was omitting the fractional
    seconds.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5045](https://www.sqlalchemy.org/trac/ticket/5045)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: tests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[tests] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed a few test failures which would occur on Windows due to SQLite file locking
    issues, as well as some timing issues in connection pool related tests; pull request
    courtesy Federico Caselli.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4946](https://www.sqlalchemy.org/trac/ticket/4946)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[tests] [postgresql]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improved detection of two phase transactions requirement for the PostgreSQL
    database by testing that max_prepared_transactions is set to a value greater than
    0\. Pull request courtesy Federico Caselli.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5057](https://www.sqlalchemy.org/trac/ticket/5057)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: misc
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[bug] [ext]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug in sqlalchemy.ext.serializer where a unique [`BindParameter`](../core/sqlelement.html#sqlalchemy.sql.expression.BindParameter
    "sqlalchemy.sql.expression.BindParameter") object could conflict with itself if
    it were present in the mapping itself, as well as the filter condition of the
    query, as one side would be used against the non-deserialized version and the
    other side would use the deserialized version. Logic is added to [`BindParameter`](../core/sqlelement.html#sqlalchemy.sql.expression.BindParameter
    "sqlalchemy.sql.expression.BindParameter") similar to its “clone” method which
    will uniquify the parameter name upon deserialize so that it doesn’t conflict
    with its original.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5086](https://www.sqlalchemy.org/trac/ticket/5086)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 1.3.12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Released: December 16, 2019'
  prefs: []
  type: TYPE_NORMAL
- en: orm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue involving `lazy="raise"` strategy where an ORM delete of an object
    would raise for a simple “use-get” style many-to-one relationship that had lazy=”raise”
    configured. This is inconsistent vs. the change introduced in 1.3 as part of [#4353](https://www.sqlalchemy.org/trac/ticket/4353),
    where it was established that a history operation that does not expect emit SQL
    should bypass the `lazy="raise"` check, and instead effectively treat it as `lazy="raise_on_sql"`
    for this case. The fix adjusts the lazy loader strategy to not raise for the case
    where the lazy load was instructed that it should not emit SQL if the object were
    not present.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4997](https://www.sqlalchemy.org/trac/ticket/4997)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed regression introduced in 1.3.0 related to the association proxy refactor
    in [#4351](https://www.sqlalchemy.org/trac/ticket/4351) that prevented [`composite()`](../orm/composites.html#sqlalchemy.orm.composite
    "sqlalchemy.orm.composite") attributes from working in terms of an association
    proxy that references them.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5000](https://www.sqlalchemy.org/trac/ticket/5000)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting persistence-related flags on [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") while also setting viewonly=True will now emit
    a regular warning, as these flags do not make sense for a viewonly=True relationship.
    In particular, the “cascade” settings have their own warning that is generated
    based on the individual values, such as “delete, delete-orphan”, that should not
    apply to a viewonly relationship. Note however that in the case of “cascade”,
    these settings are still erroneously taking effect even though the relationship
    is set up as “viewonly”. In 1.4, all persistence-related cascade settings will
    be disallowed on a viewonly=True relationship in order to resolve this issue.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4993](https://www.sqlalchemy.org/trac/ticket/4993)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug] [py3k]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue where when assigning a collection to itself as a slice, the mutation
    operation would fail as it would first erase the assigned collection inadvertently.
    As an assignment that does not change the contents should not generate events,
    the operation is now a no-op. Note that the fix only applies to Python 3; in Python
    2, the `__setitem__` hook isn’t called in this case; `__setslice__` is used instead
    which recreates the list item-by-item in all cases.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4990](https://www.sqlalchemy.org/trac/ticket/4990)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue where by if the “begin” of a transaction failed at the Core engine/connection
    level, such as due to network error or database is locked for some transactional
    recipes, within the context of the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") procuring that connection from the connection pool and
    then immediately returning it, the ORM [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") would not close the connection despite this connection
    not being stored within the state of that [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"). This would lead to the connection being cleaned out
    by the connection pool weakref handler within garbage collection which is an unpreferred
    codepath that in some special configurations can emit errors in standard error.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5034](https://www.sqlalchemy.org/trac/ticket/5034)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[sql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug where “distinct” keyword passed to [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") would not treat a string value as a “label
    reference” in the same way that the `select.distinct()` does; it would instead
    raise unconditionally. This keyword argument and the others passed to [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") will ultimately be deprecated for SQLAlchemy
    2.0.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5028](https://www.sqlalchemy.org/trac/ticket/5028)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[sql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changed the text of the exception for “Can’t resolve label reference” to include
    other kinds of label coercions, namely that “DISTINCT” is also in this category
    under the PostgreSQL dialect.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sqlite
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[sqlite] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue to workaround SQLite’s behavior of assigning “numeric” affinity
    to JSON datatypes, first described at [Support for SQLite JSON Added](migration_13.html#change-3850),
    which returns scalar numeric JSON values as a number and not as a string that
    can be JSON deserialized. The SQLite-specific JSON deserializer now gracefully
    degrades for this case as an exception and bypasses deserialization for single
    numeric values, as from a JSON perspective they are already deserialized.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5014](https://www.sqlalchemy.org/trac/ticket/5014)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: mssql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[mssql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Repaired support for the [`DATETIMEOFFSET`](../dialects/mssql.html#sqlalchemy.dialects.mssql.DATETIMEOFFSET
    "sqlalchemy.dialects.mssql.DATETIMEOFFSET") datatype on PyODBC, by adding PyODBC-level
    result handlers as it does not include native support for this datatype. This
    includes usage of the Python 3 “timezone” tzinfo subclass in order to set up a
    timezone, which on Python 2 makes use of a minimal backport of “timezone” in sqlalchemy.util.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4983](https://www.sqlalchemy.org/trac/ticket/4983)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: orm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue involving `lazy="raise"` strategy where an ORM delete of an object
    would raise for a simple “use-get” style many-to-one relationship that had lazy=”raise”
    configured. This is inconsistent vs. the change introduced in 1.3 as part of [#4353](https://www.sqlalchemy.org/trac/ticket/4353),
    where it was established that a history operation that does not expect emit SQL
    should bypass the `lazy="raise"` check, and instead effectively treat it as `lazy="raise_on_sql"`
    for this case. The fix adjusts the lazy loader strategy to not raise for the case
    where the lazy load was instructed that it should not emit SQL if the object were
    not present.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4997](https://www.sqlalchemy.org/trac/ticket/4997)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed regression introduced in 1.3.0 related to the association proxy refactor
    in [#4351](https://www.sqlalchemy.org/trac/ticket/4351) that prevented [`composite()`](../orm/composites.html#sqlalchemy.orm.composite
    "sqlalchemy.orm.composite") attributes from working in terms of an association
    proxy that references them.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5000](https://www.sqlalchemy.org/trac/ticket/5000)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting persistence-related flags on [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") while also setting viewonly=True will now emit
    a regular warning, as these flags do not make sense for a viewonly=True relationship.
    In particular, the “cascade” settings have their own warning that is generated
    based on the individual values, such as “delete, delete-orphan”, that should not
    apply to a viewonly relationship. Note however that in the case of “cascade”,
    these settings are still erroneously taking effect even though the relationship
    is set up as “viewonly”. In 1.4, all persistence-related cascade settings will
    be disallowed on a viewonly=True relationship in order to resolve this issue.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4993](https://www.sqlalchemy.org/trac/ticket/4993)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug] [py3k]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue where when assigning a collection to itself as a slice, the mutation
    operation would fail as it would first erase the assigned collection inadvertently.
    As an assignment that does not change the contents should not generate events,
    the operation is now a no-op. Note that the fix only applies to Python 3; in Python
    2, the `__setitem__` hook isn’t called in this case; `__setslice__` is used instead
    which recreates the list item-by-item in all cases.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4990](https://www.sqlalchemy.org/trac/ticket/4990)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue where by if the “begin” of a transaction failed at the Core engine/connection
    level, such as due to network error or database is locked for some transactional
    recipes, within the context of the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") procuring that connection from the connection pool and
    then immediately returning it, the ORM [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") would not close the connection despite this connection
    not being stored within the state of that [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"). This would lead to the connection being cleaned out
    by the connection pool weakref handler within garbage collection which is an unpreferred
    codepath that in some special configurations can emit errors in standard error.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5034](https://www.sqlalchemy.org/trac/ticket/5034)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[sql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug where “distinct” keyword passed to [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") would not treat a string value as a “label
    reference” in the same way that the `select.distinct()` does; it would instead
    raise unconditionally. This keyword argument and the others passed to [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") will ultimately be deprecated for SQLAlchemy
    2.0.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5028](https://www.sqlalchemy.org/trac/ticket/5028)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[sql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changed the text of the exception for “Can’t resolve label reference” to include
    other kinds of label coercions, namely that “DISTINCT” is also in this category
    under the PostgreSQL dialect.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sqlite
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[sqlite] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue to workaround SQLite’s behavior of assigning “numeric” affinity
    to JSON datatypes, first described at [Support for SQLite JSON Added](migration_13.html#change-3850),
    which returns scalar numeric JSON values as a number and not as a string that
    can be JSON deserialized. The SQLite-specific JSON deserializer now gracefully
    degrades for this case as an exception and bypasses deserialization for single
    numeric values, as from a JSON perspective they are already deserialized.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#5014](https://www.sqlalchemy.org/trac/ticket/5014)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: mssql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[mssql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Repaired support for the [`DATETIMEOFFSET`](../dialects/mssql.html#sqlalchemy.dialects.mssql.DATETIMEOFFSET
    "sqlalchemy.dialects.mssql.DATETIMEOFFSET") datatype on PyODBC, by adding PyODBC-level
    result handlers as it does not include native support for this datatype. This
    includes usage of the Python 3 “timezone” tzinfo subclass in order to set up a
    timezone, which on Python 2 makes use of a minimal backport of “timezone” in sqlalchemy.util.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4983](https://www.sqlalchemy.org/trac/ticket/4983)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 1.3.11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Released: November 11, 2019'
  prefs: []
  type: TYPE_NORMAL
- en: orm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[orm] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added accessor [`Query.is_single_entity()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.is_single_entity
    "sqlalchemy.orm.Query.is_single_entity") to [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query"), which will indicate if the results returned by this [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") will be a list of ORM entities, or a tuple of entities
    or column expressions. SQLAlchemy hopes to improve upon the behavior of single
    entity / tuples in future releases such that the behavior would be explicit up
    front, however this attribute should be helpful with the current behavior. Pull
    request courtesy Patrick Hayes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4934](https://www.sqlalchemy.org/trac/ticket/4934)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [`relationship.omit_join`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.omit_join
    "sqlalchemy.orm.relationship") flag was not intended to be manually set to True,
    and will now emit a warning when this occurs. The omit_join optimization is detected
    automatically, and the `omit_join` flag was only intended to disable the optimization
    in the hypothetical case that the optimization may have interfered with correct
    results, which has not been observed with the modern version of this feature.
    Setting the flag to True when it is not automatically detected may cause the selectin
    load feature to not work correctly when a non-default primary join condition is
    in use.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4954](https://www.sqlalchemy.org/trac/ticket/4954)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A warning is emitted if a primary key value is passed to [`Query.get()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.get
    "sqlalchemy.orm.Query.get") that consists of None for all primary key column positions.
    Previously, passing a single None outside of a tuple would raise a `TypeError`
    and passing a composite None (tuple of None values) would silently pass through.
    The fix now coerces the single None into a tuple where it is handled consistently
    with the other None conditions. Thanks to Lev Izraelit for the help with this.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4915](https://www.sqlalchemy.org/trac/ticket/4915)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [`BakedQuery`](../orm/extensions/baked.html#sqlalchemy.ext.baked.BakedQuery
    "sqlalchemy.ext.baked.BakedQuery") will not cache a query that was modified by
    a [`QueryEvents.before_compile()`](../orm/events.html#sqlalchemy.orm.QueryEvents.before_compile
    "sqlalchemy.orm.QueryEvents.before_compile") event, so that compilation hooks
    that may be applying ad-hoc modifications to queries will take effect on each
    run. In particular this is helpful for events that modify queries used in lazy
    loading as well as eager loading such as “select in” loading. In order to re-enable
    caching for a query modified by this event, a new flag `bake_ok` is added; see
    [Using the before_compile event](../orm/extensions/baked.html#baked-with-before-compile)
    for details.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A longer term plan to provide a new form of SQL caching should solve this kind
    of issue more comprehensively.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4947](https://www.sqlalchemy.org/trac/ticket/4947)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed ORM bug where a “secondary” table that referred to a selectable which
    in some way would refer to the local primary table would apply aliasing to both
    sides of the join condition when a relationship-related join, either via [`Query.join()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join") or by [`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload"), were generated. The “local” side is now excluded.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4974](https://www.sqlalchemy.org/trac/ticket/4974)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: engine
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[engine] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug where parameter repr as used in logging and error reporting needs
    additional context in order to distinguish between a list of parameters for a
    single statement and a list of parameter lists, as the “list of lists” structure
    could also indicate a single parameter list where the first parameter itself is
    a list, such as for an array parameter. The engine/connection now passes in an
    additional boolean indicating how the parameters should be considered. The only
    SQLAlchemy backend that expects arrays as parameters is that of psycopg2 which
    uses pyformat parameters, so this issue has not been too apparent, however as
    other drivers that use positional gain more features it is important that this
    be supported. It also eliminates the need for the parameter repr function to guess
    based on the parameter structure passed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4902](https://www.sqlalchemy.org/trac/ticket/4902)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[engine] [bug] [postgresql]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug in [`Inspector`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector
    "sqlalchemy.engine.reflection.Inspector") where the cache key generation did not
    take into account arguments passed in the form of tuples, such as the tuple of
    view name styles to return for the PostgreSQL dialect. This would lead the inspector
    to cache too generally for a more specific set of criteria. The logic has been
    adjusted to include every keyword element in the cache, as every argument is expected
    to be appropriate for a cache else the caching decorator should be bypassed by
    the dialect.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4955](https://www.sqlalchemy.org/trac/ticket/4955)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[sql] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added new accessors to expressions of type [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON") to allow for specific datatype access and comparison,
    covering strings, integers, numeric, boolean elements. This revises the documented
    approach of CASTing to string when comparing values, instead adding specific functionality
    into the PostgreSQL, SQlite, MySQL dialects to reliably deliver these basic types
    in all cases.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON")'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`Comparator.as_string()`](../core/type_basics.html#sqlalchemy.types.JSON.Comparator.as_string
    "sqlalchemy.types.JSON.Comparator.as_string")'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`Comparator.as_boolean()`](../core/type_basics.html#sqlalchemy.types.JSON.Comparator.as_boolean
    "sqlalchemy.types.JSON.Comparator.as_boolean")'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`Comparator.as_float()`](../core/type_basics.html#sqlalchemy.types.JSON.Comparator.as_float
    "sqlalchemy.types.JSON.Comparator.as_float")'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`Comparator.as_integer()`](../core/type_basics.html#sqlalchemy.types.JSON.Comparator.as_integer
    "sqlalchemy.types.JSON.Comparator.as_integer")'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4276](https://www.sqlalchemy.org/trac/ticket/4276)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[sql] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text "sqlalchemy.sql.expression.text")
    construct now supports “unique” bound parameters, which will dynamically uniquify
    themselves on compilation thus allowing multiple [`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text
    "sqlalchemy.sql.expression.text") constructs with the same bound parameter names
    to be combined together.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4933](https://www.sqlalchemy.org/trac/ticket/4933)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[sql] [bug] [py3k]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changed the `repr()` of the [`quoted_name`](../core/sqlelement.html#sqlalchemy.sql.expression.quoted_name
    "sqlalchemy.sql.expression.quoted_name") construct to use regular string repr()
    under Python 3, rather than running it through “backslashreplace” escaping, which
    can be misleading.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4931](https://www.sqlalchemy.org/trac/ticket/4931)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: schema
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[schema] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added DDL support for “computed columns”; these are DDL column specifications
    for columns that have a server-computed value, either upon SELECT (known as “virtual”)
    or at the point of which they are INSERTed or UPDATEd (known as “stored”). Support
    is established for Postgresql, MySQL, Oracle SQL Server and Firebird. Thanks to
    Federico Caselli for lots of work on this one.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Computed Columns (GENERATED ALWAYS AS)](../core/defaults.html#computed-ddl)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4894](https://www.sqlalchemy.org/trac/ticket/4894)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[schema] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug where a table that would have a column label overlap with a plain
    column name, such as “foo.id AS foo_id” vs. “foo.foo_id”, would prematurely generate
    the `._label` attribute for a column before this overlap could be detected due
    to the use of the `index=True` or `unique=True` flag on the column in conjunction
    with the default naming convention of `"column_0_label"`. This would then lead
    to failures when `._label` were used later to generate a bound parameter name,
    in particular those used by the ORM when generating the WHERE clause for an UPDATE
    statement. The issue has been fixed by using an alternate `._label` accessor for
    DDL generation that does not affect the state of the [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column"). The accessor also bypasses the key-deduplication
    step as it is not necessary for DDL, the naming is now consistently `"<tablename>_<columnname>"`
    without any subsequent numeric symbols when used in DDL.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4911](https://www.sqlalchemy.org/trac/ticket/4911)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: mysql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[mysql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added “Connection was killed” message interpreted from the base pymysql.Error
    class in order to detect closed connection, based on reports that this message
    is arriving via a pymysql.InternalError() object which indicates pymysql is not
    handling it correctly.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4945](https://www.sqlalchemy.org/trac/ticket/4945)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: mssql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[mssql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue in MSSQL dialect where an expression-based OFFSET value in a SELECT
    would be rejected, even though the dialect can render this expression inside of
    a ROW NUMBER-oriented LIMIT/OFFSET construct.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4973](https://www.sqlalchemy.org/trac/ticket/4973)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[mssql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed an issue in the `Engine.table_names()` method where it would feed the
    dialect’s default schema name back into the dialect level table function, which
    in the case of SQL Server would interpret it as a dot-tokenized schema name as
    viewed by the mssql dialect, which would cause the method to fail in the case
    where the database username actually had a dot inside of it. In 1.3, this method
    is still used by the [`MetaData.reflect()`](../core/metadata.html#sqlalchemy.schema.MetaData.reflect
    "sqlalchemy.schema.MetaData.reflect") function so is a prominent codepath. In
    1.4, which is the current master development branch, this issue doesn’t exist,
    both because [`MetaData.reflect()`](../core/metadata.html#sqlalchemy.schema.MetaData.reflect
    "sqlalchemy.schema.MetaData.reflect") isn’t using this method nor does the method
    pass the default schema name explicitly. The fix nonetheless guards against the
    default server name value returned by the dialect from being interpreted as dot-tokenized
    name under any circumstances by wrapping it in quoted_name().
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4923](https://www.sqlalchemy.org/trac/ticket/4923)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: oracle
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[oracle] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added dialect-level flag `encoding_errors` to the cx_Oracle dialect, which can
    be specified as part of [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine"). This is passed to SQLAlchemy’s unicode decoding converter
    under Python 2, and to cx_Oracle’s `cursor.var()` object as the `encodingErrors`
    parameter under Python 3, for the very unusual case that broken encodings are
    present in the target database which cannot be fetched unless error handling is
    relaxed. The value is ultimately one of the Python “encoding errors” parameters
    passed to `decode()`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4799](https://www.sqlalchemy.org/trac/ticket/4799)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[oracle] [bug] [firebird]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modified the approach of “name normalization” for the Oracle and Firebird dialects,
    which converts from the UPPERCASE-as-case-insensitive convention of these dialects
    into lowercase-as-case-insensitive for SQLAlchemy, to not automatically apply
    the [`quoted_name`](../core/sqlelement.html#sqlalchemy.sql.expression.quoted_name
    "sqlalchemy.sql.expression.quoted_name") construct to a name that matches itself
    under upper or lower case conversion, as is the case for many non-european characters.
    All names used within metadata structures are converted to [`quoted_name`](../core/sqlelement.html#sqlalchemy.sql.expression.quoted_name
    "sqlalchemy.sql.expression.quoted_name") objects in any case; the change here
    would only affect the output of some inspection functions.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4931](https://www.sqlalchemy.org/trac/ticket/4931)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[oracle] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [`NCHAR`](../core/type_basics.html#sqlalchemy.types.NCHAR "sqlalchemy.types.NCHAR")
    datatype will now bind to the `cx_Oracle.FIXED_NCHAR` DBAPI data bindings when
    used in a bound parameter, which supplies proper comparison behavior against a
    variable-length string. Previously, the [`NCHAR`](../core/type_basics.html#sqlalchemy.types.NCHAR
    "sqlalchemy.types.NCHAR") datatype would bind to `cx_oracle.NCHAR` which is not
    fixed length; the [`CHAR`](../core/type_basics.html#sqlalchemy.types.CHAR "sqlalchemy.types.CHAR")
    datatype already binds to `cx_Oracle.FIXED_CHAR` so it is now consistent that
    [`NCHAR`](../core/type_basics.html#sqlalchemy.types.NCHAR "sqlalchemy.types.NCHAR")
    binds to `cx_Oracle.FIXED_NCHAR`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4913](https://www.sqlalchemy.org/trac/ticket/4913)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: tests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[tests] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed test failures which would occur with newer SQLite as of version 3.30 or
    greater, due to their addition of nulls ordering syntax as well as new restrictions
    on aggregate functions. Pull request courtesy Nils Philippsen.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4920](https://www.sqlalchemy.org/trac/ticket/4920)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: misc
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[bug] [installation] [windows]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added a workaround for a setuptools-related failure that has been observed as
    occurring on Windows installations, where setuptools is not correctly reporting
    a build error when the MSVC build dependencies are not installed and therefore
    not allowing graceful degradation into non C extensions builds.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4967](https://www.sqlalchemy.org/trac/ticket/4967)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[bug] [firebird]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added additional “disconnect” message “Error writing data to the connection”
    to Firebird disconnection detection. Pull request courtesy lukens.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4903](https://www.sqlalchemy.org/trac/ticket/4903)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: orm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[orm] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added accessor [`Query.is_single_entity()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.is_single_entity
    "sqlalchemy.orm.Query.is_single_entity") to [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query"), which will indicate if the results returned by this [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") will be a list of ORM entities, or a tuple of entities
    or column expressions. SQLAlchemy hopes to improve upon the behavior of single
    entity / tuples in future releases such that the behavior would be explicit up
    front, however this attribute should be helpful with the current behavior. Pull
    request courtesy Patrick Hayes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4934](https://www.sqlalchemy.org/trac/ticket/4934)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [`relationship.omit_join`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.omit_join
    "sqlalchemy.orm.relationship") flag was not intended to be manually set to True,
    and will now emit a warning when this occurs. The omit_join optimization is detected
    automatically, and the `omit_join` flag was only intended to disable the optimization
    in the hypothetical case that the optimization may have interfered with correct
    results, which has not been observed with the modern version of this feature.
    Setting the flag to True when it is not automatically detected may cause the selectin
    load feature to not work correctly when a non-default primary join condition is
    in use.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4954](https://www.sqlalchemy.org/trac/ticket/4954)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A warning is emitted if a primary key value is passed to [`Query.get()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.get
    "sqlalchemy.orm.Query.get") that consists of None for all primary key column positions.
    Previously, passing a single None outside of a tuple would raise a `TypeError`
    and passing a composite None (tuple of None values) would silently pass through.
    The fix now coerces the single None into a tuple where it is handled consistently
    with the other None conditions. Thanks to Lev Izraelit for the help with this.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4915](https://www.sqlalchemy.org/trac/ticket/4915)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [`BakedQuery`](../orm/extensions/baked.html#sqlalchemy.ext.baked.BakedQuery
    "sqlalchemy.ext.baked.BakedQuery") will not cache a query that was modified by
    a [`QueryEvents.before_compile()`](../orm/events.html#sqlalchemy.orm.QueryEvents.before_compile
    "sqlalchemy.orm.QueryEvents.before_compile") event, so that compilation hooks
    that may be applying ad-hoc modifications to queries will take effect on each
    run. In particular this is helpful for events that modify queries used in lazy
    loading as well as eager loading such as “select in” loading. In order to re-enable
    caching for a query modified by this event, a new flag `bake_ok` is added; see
    [Using the before_compile event](../orm/extensions/baked.html#baked-with-before-compile)
    for details.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A longer term plan to provide a new form of SQL caching should solve this kind
    of issue more comprehensively.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4947](https://www.sqlalchemy.org/trac/ticket/4947)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed ORM bug where a “secondary” table that referred to a selectable which
    in some way would refer to the local primary table would apply aliasing to both
    sides of the join condition when a relationship-related join, either via [`Query.join()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join") or by [`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload"), were generated. The “local” side is now excluded.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4974](https://www.sqlalchemy.org/trac/ticket/4974)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: engine
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[engine] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug where parameter repr as used in logging and error reporting needs
    additional context in order to distinguish between a list of parameters for a
    single statement and a list of parameter lists, as the “list of lists” structure
    could also indicate a single parameter list where the first parameter itself is
    a list, such as for an array parameter. The engine/connection now passes in an
    additional boolean indicating how the parameters should be considered. The only
    SQLAlchemy backend that expects arrays as parameters is that of psycopg2 which
    uses pyformat parameters, so this issue has not been too apparent, however as
    other drivers that use positional gain more features it is important that this
    be supported. It also eliminates the need for the parameter repr function to guess
    based on the parameter structure passed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4902](https://www.sqlalchemy.org/trac/ticket/4902)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[engine] [bug] [postgresql]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug in [`Inspector`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector
    "sqlalchemy.engine.reflection.Inspector") where the cache key generation did not
    take into account arguments passed in the form of tuples, such as the tuple of
    view name styles to return for the PostgreSQL dialect. This would lead the inspector
    to cache too generally for a more specific set of criteria. The logic has been
    adjusted to include every keyword element in the cache, as every argument is expected
    to be appropriate for a cache else the caching decorator should be bypassed by
    the dialect.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4955](https://www.sqlalchemy.org/trac/ticket/4955)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[sql] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added new accessors to expressions of type [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON") to allow for specific datatype access and comparison,
    covering strings, integers, numeric, boolean elements. This revises the documented
    approach of CASTing to string when comparing values, instead adding specific functionality
    into the PostgreSQL, SQlite, MySQL dialects to reliably deliver these basic types
    in all cases.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON")'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`Comparator.as_string()`](../core/type_basics.html#sqlalchemy.types.JSON.Comparator.as_string
    "sqlalchemy.types.JSON.Comparator.as_string")'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`Comparator.as_boolean()`](../core/type_basics.html#sqlalchemy.types.JSON.Comparator.as_boolean
    "sqlalchemy.types.JSON.Comparator.as_boolean")'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`Comparator.as_float()`](../core/type_basics.html#sqlalchemy.types.JSON.Comparator.as_float
    "sqlalchemy.types.JSON.Comparator.as_float")'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`Comparator.as_integer()`](../core/type_basics.html#sqlalchemy.types.JSON.Comparator.as_integer
    "sqlalchemy.types.JSON.Comparator.as_integer")'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4276](https://www.sqlalchemy.org/trac/ticket/4276)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[sql] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text "sqlalchemy.sql.expression.text")
    construct now supports “unique” bound parameters, which will dynamically uniquify
    themselves on compilation thus allowing multiple [`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text
    "sqlalchemy.sql.expression.text") constructs with the same bound parameter names
    to be combined together.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4933](https://www.sqlalchemy.org/trac/ticket/4933)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[sql] [bug] [py3k]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changed the `repr()` of the [`quoted_name`](../core/sqlelement.html#sqlalchemy.sql.expression.quoted_name
    "sqlalchemy.sql.expression.quoted_name") construct to use regular string repr()
    under Python 3, rather than running it through “backslashreplace” escaping, which
    can be misleading.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4931](https://www.sqlalchemy.org/trac/ticket/4931)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: schema
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[schema] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added DDL support for “computed columns”; these are DDL column specifications
    for columns that have a server-computed value, either upon SELECT (known as “virtual”)
    or at the point of which they are INSERTed or UPDATEd (known as “stored”). Support
    is established for Postgresql, MySQL, Oracle SQL Server and Firebird. Thanks to
    Federico Caselli for lots of work on this one.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Computed Columns (GENERATED ALWAYS AS)](../core/defaults.html#computed-ddl)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4894](https://www.sqlalchemy.org/trac/ticket/4894)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[schema] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug where a table that would have a column label overlap with a plain
    column name, such as “foo.id AS foo_id” vs. “foo.foo_id”, would prematurely generate
    the `._label` attribute for a column before this overlap could be detected due
    to the use of the `index=True` or `unique=True` flag on the column in conjunction
    with the default naming convention of `"column_0_label"`. This would then lead
    to failures when `._label` were used later to generate a bound parameter name,
    in particular those used by the ORM when generating the WHERE clause for an UPDATE
    statement. The issue has been fixed by using an alternate `._label` accessor for
    DDL generation that does not affect the state of the [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column"). The accessor also bypasses the key-deduplication
    step as it is not necessary for DDL, the naming is now consistently `"<tablename>_<columnname>"`
    without any subsequent numeric symbols when used in DDL.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4911](https://www.sqlalchemy.org/trac/ticket/4911)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: mysql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[mysql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added “Connection was killed” message interpreted from the base pymysql.Error
    class in order to detect closed connection, based on reports that this message
    is arriving via a pymysql.InternalError() object which indicates pymysql is not
    handling it correctly.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4945](https://www.sqlalchemy.org/trac/ticket/4945)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: mssql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[mssql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue in MSSQL dialect where an expression-based OFFSET value in a SELECT
    would be rejected, even though the dialect can render this expression inside of
    a ROW NUMBER-oriented LIMIT/OFFSET construct.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4973](https://www.sqlalchemy.org/trac/ticket/4973)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[mssql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed an issue in the `Engine.table_names()` method where it would feed the
    dialect’s default schema name back into the dialect level table function, which
    in the case of SQL Server would interpret it as a dot-tokenized schema name as
    viewed by the mssql dialect, which would cause the method to fail in the case
    where the database username actually had a dot inside of it. In 1.3, this method
    is still used by the [`MetaData.reflect()`](../core/metadata.html#sqlalchemy.schema.MetaData.reflect
    "sqlalchemy.schema.MetaData.reflect") function so is a prominent codepath. In
    1.4, which is the current master development branch, this issue doesn’t exist,
    both because [`MetaData.reflect()`](../core/metadata.html#sqlalchemy.schema.MetaData.reflect
    "sqlalchemy.schema.MetaData.reflect") isn’t using this method nor does the method
    pass the default schema name explicitly. The fix nonetheless guards against the
    default server name value returned by the dialect from being interpreted as dot-tokenized
    name under any circumstances by wrapping it in quoted_name().
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4923](https://www.sqlalchemy.org/trac/ticket/4923)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: oracle
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[oracle] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added dialect-level flag `encoding_errors` to the cx_Oracle dialect, which can
    be specified as part of [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine"). This is passed to SQLAlchemy’s unicode decoding converter
    under Python 2, and to cx_Oracle’s `cursor.var()` object as the `encodingErrors`
    parameter under Python 3, for the very unusual case that broken encodings are
    present in the target database which cannot be fetched unless error handling is
    relaxed. The value is ultimately one of the Python “encoding errors” parameters
    passed to `decode()`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4799](https://www.sqlalchemy.org/trac/ticket/4799)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[oracle] [bug] [firebird]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modified the approach of “name normalization” for the Oracle and Firebird dialects,
    which converts from the UPPERCASE-as-case-insensitive convention of these dialects
    into lowercase-as-case-insensitive for SQLAlchemy, to not automatically apply
    the [`quoted_name`](../core/sqlelement.html#sqlalchemy.sql.expression.quoted_name
    "sqlalchemy.sql.expression.quoted_name") construct to a name that matches itself
    under upper or lower case conversion, as is the case for many non-european characters.
    All names used within metadata structures are converted to [`quoted_name`](../core/sqlelement.html#sqlalchemy.sql.expression.quoted_name
    "sqlalchemy.sql.expression.quoted_name") objects in any case; the change here
    would only affect the output of some inspection functions.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4931](https://www.sqlalchemy.org/trac/ticket/4931)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[oracle] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [`NCHAR`](../core/type_basics.html#sqlalchemy.types.NCHAR "sqlalchemy.types.NCHAR")
    datatype will now bind to the `cx_Oracle.FIXED_NCHAR` DBAPI data bindings when
    used in a bound parameter, which supplies proper comparison behavior against a
    variable-length string. Previously, the [`NCHAR`](../core/type_basics.html#sqlalchemy.types.NCHAR
    "sqlalchemy.types.NCHAR") datatype would bind to `cx_oracle.NCHAR` which is not
    fixed length; the [`CHAR`](../core/type_basics.html#sqlalchemy.types.CHAR "sqlalchemy.types.CHAR")
    datatype already binds to `cx_Oracle.FIXED_CHAR` so it is now consistent that
    [`NCHAR`](../core/type_basics.html#sqlalchemy.types.NCHAR "sqlalchemy.types.NCHAR")
    binds to `cx_Oracle.FIXED_NCHAR`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4913](https://www.sqlalchemy.org/trac/ticket/4913)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: tests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[tests] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed test failures which would occur with newer SQLite as of version 3.30 or
    greater, due to their addition of nulls ordering syntax as well as new restrictions
    on aggregate functions. Pull request courtesy Nils Philippsen.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4920](https://www.sqlalchemy.org/trac/ticket/4920)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: misc
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[bug] [installation] [windows]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added a workaround for a setuptools-related failure that has been observed as
    occurring on Windows installations, where setuptools is not correctly reporting
    a build error when the MSVC build dependencies are not installed and therefore
    not allowing graceful degradation into non C extensions builds.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4967](https://www.sqlalchemy.org/trac/ticket/4967)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[bug] [firebird]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added additional “disconnect” message “Error writing data to the connection”
    to Firebird disconnection detection. Pull request courtesy lukens.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4903](https://www.sqlalchemy.org/trac/ticket/4903)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 1.3.10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Released: October 9, 2019'
  prefs: []
  type: TYPE_NORMAL
- en: mssql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[mssql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug in SQL Server dialect with new “max_identifier_length” feature where
    the mssql dialect already featured this flag, and the implementation did not accommodate
    for the new initialization hook correctly.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4857](https://www.sqlalchemy.org/trac/ticket/4857)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: oracle
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[oracle] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed regression in Oracle dialect that was inadvertently using max identifier
    length of 128 characters on Oracle server 12.2 and greater even though the stated
    contract for the remainder of the 1.3 series is that this value stays at 30 until
    version SQLAlchemy 1.4\. Also repaired issues with the retrieval of the “compatibility”
    version, and removed the warning emitted when the “v$parameter” view was not accessible
    as this was causing user confusion.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4857](https://www.sqlalchemy.org/trac/ticket/4857), [#4898](https://www.sqlalchemy.org/trac/ticket/4898)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: mssql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[mssql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug in SQL Server dialect with new “max_identifier_length” feature where
    the mssql dialect already featured this flag, and the implementation did not accommodate
    for the new initialization hook correctly.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4857](https://www.sqlalchemy.org/trac/ticket/4857)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: oracle
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[oracle] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed regression in Oracle dialect that was inadvertently using max identifier
    length of 128 characters on Oracle server 12.2 and greater even though the stated
    contract for the remainder of the 1.3 series is that this value stays at 30 until
    version SQLAlchemy 1.4\. Also repaired issues with the retrieval of the “compatibility”
    version, and removed the warning emitted when the “v$parameter” view was not accessible
    as this was causing user confusion.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4857](https://www.sqlalchemy.org/trac/ticket/4857), [#4898](https://www.sqlalchemy.org/trac/ticket/4898)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 1.3.9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Released: October 4, 2019'
  prefs: []
  type: TYPE_NORMAL
- en: orm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed regression in selectinload loader strategy caused by [#4775](https://www.sqlalchemy.org/trac/ticket/4775)
    (released in version 1.3.6) where a many-to-one attribute of None would no longer
    be populated by the loader. While this was usually not noticeable due to the lazyloader
    populating None upon get, it would lead to a detached instance error if the object
    were detached.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4872](https://www.sqlalchemy.org/trac/ticket/4872)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing a plain string expression to [`Session.query()`](../orm/session_api.html#sqlalchemy.orm.Session.query
    "sqlalchemy.orm.Session.query") is deprecated, as all string coercions were removed
    in [#4481](https://www.sqlalchemy.org/trac/ticket/4481) and this one should have
    been included. The [`literal_column()`](../core/sqlelement.html#sqlalchemy.sql.expression.literal_column
    "sqlalchemy.sql.expression.literal_column") function may be used to produce a
    textual column expression.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4873](https://www.sqlalchemy.org/trac/ticket/4873)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A warning is emitted for a condition in which the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") may implicitly swap an object out of the identity map
    for another one with the same primary key, detaching the old one, which can be
    an observed result of load operations which occur within the [`SessionEvents.after_flush()`](../orm/events.html#sqlalchemy.orm.SessionEvents.after_flush
    "sqlalchemy.orm.SessionEvents.after_flush") hook. The warning is intended to notify
    the user that some special condition has caused this to happen and that the previous
    object may not be in the expected state.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4890](https://www.sqlalchemy.org/trac/ticket/4890)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: engine
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[engine] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added new [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") parameter [`create_engine.max_identifier_length`](../core/engines.html#sqlalchemy.create_engine.params.max_identifier_length
    "sqlalchemy.create_engine"). This overrides the dialect-coded “max identifier
    length” in order to accommodate for databases that have recently changed this
    length and the SQLAlchemy dialect has not yet been adjusted to detect for that
    version. This parameter interacts with the existing [`create_engine.label_length`](../core/engines.html#sqlalchemy.create_engine.params.label_length
    "sqlalchemy.create_engine") parameter in that it establishes the maximum (and
    default) value for anonymously generated labels. Additionally, post-connection
    detection of max identifier lengths has been added to the dialect system. This
    feature is first being used by the Oracle dialect.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Max Identifier Lengths](../dialects/oracle.html#oracle-max-identifier-lengths)
    - in the Oracle dialect documentation'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4857](https://www.sqlalchemy.org/trac/ticket/4857)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[sql] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added an explicit error message for the case when objects passed to [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") are not [`SchemaItem`](../core/metadata.html#sqlalchemy.schema.SchemaItem
    "sqlalchemy.schema.SchemaItem") objects, rather than resolving to an attribute
    error.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4847](https://www.sqlalchemy.org/trac/ticket/4847)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[sql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Characters that interfere with “pyformat” or “named” formats in bound parameters,
    namely `%, (, )` and the space character, as well as a few other typically undesirable
    characters, are stripped early for a [`bindparam()`](../core/sqlelement.html#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam") that is using an anonymized name, which
    is typically generated automatically from a named column which itself includes
    these characters in its name and does not use a `.key`, so that they do not interfere
    either with the SQLAlchemy compiler’s use of string formatting or with the driver-level
    parsing of the parameter, both of which could be demonstrated before the fix.
    The change only applies to anonymized parameter names that are generated and consumed
    internally, not end-user defined names, so the change should have no impact on
    any existing code. Applies in particular to the psycopg2 driver which does not
    otherwise quote special parameter names, but also strips leading underscores to
    suit Oracle (but not yet leading numbers, as some anon parameters are currently
    entirely numeric/underscore based); Oracle in any case continues to quote parameter
    names that include special characters.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4837](https://www.sqlalchemy.org/trac/ticket/4837)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sqlite
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[sqlite] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added support for sqlite “URI” connections, which allow for sqlite-specific
    flags to be passed in the query string such as “read only” for Python sqlite3
    drivers that support this.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[URI Connections](../dialects/sqlite.html#pysqlite-uri-connections)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4863](https://www.sqlalchemy.org/trac/ticket/4863)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: mssql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[mssql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added identifier quoting to the schema name applied to the “use” statement which
    is invoked when a SQL Server multipart schema name is used within a [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") that is being reflected, as well as for [`Inspector`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector
    "sqlalchemy.engine.reflection.Inspector") methods such as [`Inspector.get_table_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_table_names
    "sqlalchemy.engine.reflection.Inspector.get_table_names"); this accommodates for
    special characters or spaces in the database name. Additionally, the “use” statement
    is not emitted if the current database matches the target owner database name
    being passed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4883](https://www.sqlalchemy.org/trac/ticket/4883)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: oracle
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[oracle] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Oracle dialect now emits a warning if Oracle version 12.2 or greater is
    used, and the [`create_engine.max_identifier_length`](../core/engines.html#sqlalchemy.create_engine.params.max_identifier_length
    "sqlalchemy.create_engine") parameter is not set. The version in this specific
    case defaults to that of the “compatibility” version set in the Oracle server
    configuration, not the actual server version. In version 1.4, the default max_identifier_length
    for 12.2 or greater will move to 128 characters. In order to maintain forwards
    compatibility, applications should set [`create_engine.max_identifier_length`](../core/engines.html#sqlalchemy.create_engine.params.max_identifier_length
    "sqlalchemy.create_engine") to 30 in order to maintain the same length behavior,
    or to 128 in order to test the upcoming behavior. This length determines among
    other things how generated constraint names are truncated for statements like
    `CREATE CONSTRAINT` and `DROP CONSTRAINT`, which means a the new length may produce
    a name-mismatch against a name that was generated with the old length, impacting
    database migrations.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Max Identifier Lengths](../dialects/oracle.html#oracle-max-identifier-lengths)
    - in the Oracle dialect documentation'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4857](https://www.sqlalchemy.org/trac/ticket/4857)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[oracle] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Restored adding cx_Oracle.DATETIME to the setinputsizes() call when a SQLAlchemy
    [`Date`](../core/type_basics.html#sqlalchemy.types.Date "sqlalchemy.types.Date"),
    [`DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime "sqlalchemy.types.DateTime")
    or [`Time`](../core/type_basics.html#sqlalchemy.types.Time "sqlalchemy.types.Time")
    datatype is used, as some complex queries require this to be present. This was
    removed in the 1.2 series for arbitrary reasons.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4886](https://www.sqlalchemy.org/trac/ticket/4886)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: tests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[tests] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed unit test regression released in 1.3.8 that would cause failure for Oracle,
    SQL Server and other non-native ENUM platforms due to new enumeration tests added
    as part of [#4285](https://www.sqlalchemy.org/trac/ticket/4285) enum sortability
    in the unit of work; the enumerations created constraints that were duplicated
    on name.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4285](https://www.sqlalchemy.org/trac/ticket/4285)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: orm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed regression in selectinload loader strategy caused by [#4775](https://www.sqlalchemy.org/trac/ticket/4775)
    (released in version 1.3.6) where a many-to-one attribute of None would no longer
    be populated by the loader. While this was usually not noticeable due to the lazyloader
    populating None upon get, it would lead to a detached instance error if the object
    were detached.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4872](https://www.sqlalchemy.org/trac/ticket/4872)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing a plain string expression to [`Session.query()`](../orm/session_api.html#sqlalchemy.orm.Session.query
    "sqlalchemy.orm.Session.query") is deprecated, as all string coercions were removed
    in [#4481](https://www.sqlalchemy.org/trac/ticket/4481) and this one should have
    been included. The [`literal_column()`](../core/sqlelement.html#sqlalchemy.sql.expression.literal_column
    "sqlalchemy.sql.expression.literal_column") function may be used to produce a
    textual column expression.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4873](https://www.sqlalchemy.org/trac/ticket/4873)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A warning is emitted for a condition in which the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") may implicitly swap an object out of the identity map
    for another one with the same primary key, detaching the old one, which can be
    an observed result of load operations which occur within the [`SessionEvents.after_flush()`](../orm/events.html#sqlalchemy.orm.SessionEvents.after_flush
    "sqlalchemy.orm.SessionEvents.after_flush") hook. The warning is intended to notify
    the user that some special condition has caused this to happen and that the previous
    object may not be in the expected state.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4890](https://www.sqlalchemy.org/trac/ticket/4890)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: engine
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[engine] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added new [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") parameter [`create_engine.max_identifier_length`](../core/engines.html#sqlalchemy.create_engine.params.max_identifier_length
    "sqlalchemy.create_engine"). This overrides the dialect-coded “max identifier
    length” in order to accommodate for databases that have recently changed this
    length and the SQLAlchemy dialect has not yet been adjusted to detect for that
    version. This parameter interacts with the existing [`create_engine.label_length`](../core/engines.html#sqlalchemy.create_engine.params.label_length
    "sqlalchemy.create_engine") parameter in that it establishes the maximum (and
    default) value for anonymously generated labels. Additionally, post-connection
    detection of max identifier lengths has been added to the dialect system. This
    feature is first being used by the Oracle dialect.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Max Identifier Lengths](../dialects/oracle.html#oracle-max-identifier-lengths)
    - in the Oracle dialect documentation'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4857](https://www.sqlalchemy.org/trac/ticket/4857)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[sql] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added an explicit error message for the case when objects passed to [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") are not [`SchemaItem`](../core/metadata.html#sqlalchemy.schema.SchemaItem
    "sqlalchemy.schema.SchemaItem") objects, rather than resolving to an attribute
    error.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4847](https://www.sqlalchemy.org/trac/ticket/4847)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[sql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Characters that interfere with “pyformat” or “named” formats in bound parameters,
    namely `%, (, )` and the space character, as well as a few other typically undesirable
    characters, are stripped early for a [`bindparam()`](../core/sqlelement.html#sqlalchemy.sql.expression.bindparam
    "sqlalchemy.sql.expression.bindparam") that is using an anonymized name, which
    is typically generated automatically from a named column which itself includes
    these characters in its name and does not use a `.key`, so that they do not interfere
    either with the SQLAlchemy compiler’s use of string formatting or with the driver-level
    parsing of the parameter, both of which could be demonstrated before the fix.
    The change only applies to anonymized parameter names that are generated and consumed
    internally, not end-user defined names, so the change should have no impact on
    any existing code. Applies in particular to the psycopg2 driver which does not
    otherwise quote special parameter names, but also strips leading underscores to
    suit Oracle (but not yet leading numbers, as some anon parameters are currently
    entirely numeric/underscore based); Oracle in any case continues to quote parameter
    names that include special characters.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4837](https://www.sqlalchemy.org/trac/ticket/4837)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sqlite
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[sqlite] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added support for sqlite “URI” connections, which allow for sqlite-specific
    flags to be passed in the query string such as “read only” for Python sqlite3
    drivers that support this.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[URI Connections](../dialects/sqlite.html#pysqlite-uri-connections)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4863](https://www.sqlalchemy.org/trac/ticket/4863)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: mssql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[mssql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added identifier quoting to the schema name applied to the “use” statement which
    is invoked when a SQL Server multipart schema name is used within a [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") that is being reflected, as well as for [`Inspector`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector
    "sqlalchemy.engine.reflection.Inspector") methods such as [`Inspector.get_table_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_table_names
    "sqlalchemy.engine.reflection.Inspector.get_table_names"); this accommodates for
    special characters or spaces in the database name. Additionally, the “use” statement
    is not emitted if the current database matches the target owner database name
    being passed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4883](https://www.sqlalchemy.org/trac/ticket/4883)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: oracle
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[oracle] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Oracle dialect now emits a warning if Oracle version 12.2 or greater is
    used, and the [`create_engine.max_identifier_length`](../core/engines.html#sqlalchemy.create_engine.params.max_identifier_length
    "sqlalchemy.create_engine") parameter is not set. The version in this specific
    case defaults to that of the “compatibility” version set in the Oracle server
    configuration, not the actual server version. In version 1.4, the default max_identifier_length
    for 12.2 or greater will move to 128 characters. In order to maintain forwards
    compatibility, applications should set [`create_engine.max_identifier_length`](../core/engines.html#sqlalchemy.create_engine.params.max_identifier_length
    "sqlalchemy.create_engine") to 30 in order to maintain the same length behavior,
    or to 128 in order to test the upcoming behavior. This length determines among
    other things how generated constraint names are truncated for statements like
    `CREATE CONSTRAINT` and `DROP CONSTRAINT`, which means a the new length may produce
    a name-mismatch against a name that was generated with the old length, impacting
    database migrations.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Max Identifier Lengths](../dialects/oracle.html#oracle-max-identifier-lengths)
    - in the Oracle dialect documentation'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4857](https://www.sqlalchemy.org/trac/ticket/4857)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[oracle] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Restored adding cx_Oracle.DATETIME to the setinputsizes() call when a SQLAlchemy
    [`Date`](../core/type_basics.html#sqlalchemy.types.Date "sqlalchemy.types.Date"),
    [`DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime "sqlalchemy.types.DateTime")
    or [`Time`](../core/type_basics.html#sqlalchemy.types.Time "sqlalchemy.types.Time")
    datatype is used, as some complex queries require this to be present. This was
    removed in the 1.2 series for arbitrary reasons.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4886](https://www.sqlalchemy.org/trac/ticket/4886)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: tests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[tests] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed unit test regression released in 1.3.8 that would cause failure for Oracle,
    SQL Server and other non-native ENUM platforms due to new enumeration tests added
    as part of [#4285](https://www.sqlalchemy.org/trac/ticket/4285) enum sortability
    in the unit of work; the enumerations created constraints that were duplicated
    on name.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4285](https://www.sqlalchemy.org/trac/ticket/4285)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 1.3.8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Released: August 27, 2019'
  prefs: []
  type: TYPE_NORMAL
- en: orm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[orm] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added support for the use of an [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum") datatype using Python pep-435 enumeration objects as
    values for use as a primary key column mapped by the ORM. As these values are
    not inherently sortable, as required by the ORM for primary keys, a new [`TypeEngine.sort_key_function`](../core/type_api.html#sqlalchemy.types.TypeEngine.sort_key_function
    "sqlalchemy.types.TypeEngine.sort_key_function") attribute is added to the typing
    system which allows any SQL type to implement a sorting for Python objects of
    its type which is consulted by the unit of work. The [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum") type then defines this using the database value of a
    given enumeration. The sorting scheme can be also be redefined by passing a callable
    to the [`Enum.sort_key_function`](../core/type_basics.html#sqlalchemy.types.Enum.params.sort_key_function
    "sqlalchemy.types.Enum") parameter. Pull request courtesy Nicolas Caniart.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4285](https://www.sqlalchemy.org/trac/ticket/4285)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug where [`Load`](../orm/queryguide/relationships.html#sqlalchemy.orm.Load
    "sqlalchemy.orm.Load") objects were not pickleable due to mapper/relationship
    state in the internal context dictionary. These objects are now converted to picklable
    using similar techniques as that of other elements within the loader option system
    that have long been serializable.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4823](https://www.sqlalchemy.org/trac/ticket/4823)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: engine
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[engine] [feature]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added new parameter [`create_engine.hide_parameters`](../core/engines.html#sqlalchemy.create_engine.params.hide_parameters
    "sqlalchemy.create_engine") which when set to True will cause SQL parameters to
    no longer be logged, nor rendered in the string representation of a [`StatementError`](../core/exceptions.html#sqlalchemy.exc.StatementError
    "sqlalchemy.exc.StatementError") object.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4815](https://www.sqlalchemy.org/trac/ticket/4815)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[engine] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed an issue whereby if the dialect “initialize” process which occurs on first
    connect would encounter an unexpected exception, the initialize process would
    fail to complete and then no longer attempt on subsequent connection attempts,
    leaving the dialect in an un-initialized, or partially initialized state, within
    the scope of parameters that need to be established based on inspection of a live
    connection. The “invoke once” logic in the event system has been reworked to accommodate
    for this occurrence using new, private API features that establish an “exec once”
    hook that will continue to allow the initializer to fire off on subsequent connections,
    until it completes without raising an exception. This does not impact the behavior
    of the existing `once=True` flag within the event system.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4807](https://www.sqlalchemy.org/trac/ticket/4807)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: postgresql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[postgresql] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Added support for reflection of CHECK constraints that include the special
    PostgreSQL qualifier “NOT VALID”, which can be present for CHECK constraints that
    were added to an existing table with the directive that they not be applied to
    existing data in the table. The PostgreSQL dictionary for CHECK constraints as
    returned by [`Inspector.get_check_constraints()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_check_constraints
    "sqlalchemy.engine.reflection.Inspector.get_check_constraints") may include an
    additional entry `dialect_options` which within will contain an entry `"not_valid":
    True` if this symbol is detected. Pull request courtesy Bill Finn.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4824](https://www.sqlalchemy.org/trac/ticket/4824)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[postgresql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Revised the approach for the just added support for the psycopg2 “execute_values()”
    feature added in 1.3.7 for [#4623](https://www.sqlalchemy.org/trac/ticket/4623).
    The approach relied upon a regular expression that would fail to match for a more
    complex INSERT statement such as one which had subqueries involved. The new approach
    matches exactly the string that was rendered as the VALUES clause.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4623](https://www.sqlalchemy.org/trac/ticket/4623)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[postgresql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug where Postgresql operators such as [`Comparator.contains()`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY.Comparator.contains
    "sqlalchemy.dialects.postgresql.ARRAY.Comparator.contains") and [`Comparator.contained_by()`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY.Comparator.contained_by
    "sqlalchemy.dialects.postgresql.ARRAY.Comparator.contained_by") would fail to
    function correctly for non-integer values when used against a [`array`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.array
    "sqlalchemy.dialects.postgresql.array") object, due to an erroneous assert statement.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4822](https://www.sqlalchemy.org/trac/ticket/4822)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sqlite
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[sqlite] [bug] [reflection]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug where a FOREIGN KEY that was set up to refer to the parent table by
    table name only without the column names would not correctly be reflected as far
    as setting up the “referred columns”, since SQLite’s PRAGMA does not report on
    these columns if they weren’t given explicitly. For some reason this was hardcoded
    to assume the name of the local column, which might work for some cases but is
    not correct. The new approach reflects the primary key of the referred table and
    uses the constraint columns list as the referred columns list, if the remote column(s)
    aren’t present in the reflected pragma directly.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4810](https://www.sqlalchemy.org/trac/ticket/4810)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: orm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[orm] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added support for the use of an [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum") datatype using Python pep-435 enumeration objects as
    values for use as a primary key column mapped by the ORM. As these values are
    not inherently sortable, as required by the ORM for primary keys, a new [`TypeEngine.sort_key_function`](../core/type_api.html#sqlalchemy.types.TypeEngine.sort_key_function
    "sqlalchemy.types.TypeEngine.sort_key_function") attribute is added to the typing
    system which allows any SQL type to implement a sorting for Python objects of
    its type which is consulted by the unit of work. The [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum") type then defines this using the database value of a
    given enumeration. The sorting scheme can be also be redefined by passing a callable
    to the [`Enum.sort_key_function`](../core/type_basics.html#sqlalchemy.types.Enum.params.sort_key_function
    "sqlalchemy.types.Enum") parameter. Pull request courtesy Nicolas Caniart.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4285](https://www.sqlalchemy.org/trac/ticket/4285)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug where [`Load`](../orm/queryguide/relationships.html#sqlalchemy.orm.Load
    "sqlalchemy.orm.Load") objects were not pickleable due to mapper/relationship
    state in the internal context dictionary. These objects are now converted to picklable
    using similar techniques as that of other elements within the loader option system
    that have long been serializable.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4823](https://www.sqlalchemy.org/trac/ticket/4823)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: engine
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[engine] [feature]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added new parameter [`create_engine.hide_parameters`](../core/engines.html#sqlalchemy.create_engine.params.hide_parameters
    "sqlalchemy.create_engine") which when set to True will cause SQL parameters to
    no longer be logged, nor rendered in the string representation of a [`StatementError`](../core/exceptions.html#sqlalchemy.exc.StatementError
    "sqlalchemy.exc.StatementError") object.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4815](https://www.sqlalchemy.org/trac/ticket/4815)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[engine] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed an issue whereby if the dialect “initialize” process which occurs on first
    connect would encounter an unexpected exception, the initialize process would
    fail to complete and then no longer attempt on subsequent connection attempts,
    leaving the dialect in an un-initialized, or partially initialized state, within
    the scope of parameters that need to be established based on inspection of a live
    connection. The “invoke once” logic in the event system has been reworked to accommodate
    for this occurrence using new, private API features that establish an “exec once”
    hook that will continue to allow the initializer to fire off on subsequent connections,
    until it completes without raising an exception. This does not impact the behavior
    of the existing `once=True` flag within the event system.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4807](https://www.sqlalchemy.org/trac/ticket/4807)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: postgresql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[postgresql] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Added support for reflection of CHECK constraints that include the special
    PostgreSQL qualifier “NOT VALID”, which can be present for CHECK constraints that
    were added to an existing table with the directive that they not be applied to
    existing data in the table. The PostgreSQL dictionary for CHECK constraints as
    returned by [`Inspector.get_check_constraints()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_check_constraints
    "sqlalchemy.engine.reflection.Inspector.get_check_constraints") may include an
    additional entry `dialect_options` which within will contain an entry `"not_valid":
    True` if this symbol is detected. Pull request courtesy Bill Finn.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4824](https://www.sqlalchemy.org/trac/ticket/4824)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[postgresql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Revised the approach for the just added support for the psycopg2 “execute_values()”
    feature added in 1.3.7 for [#4623](https://www.sqlalchemy.org/trac/ticket/4623).
    The approach relied upon a regular expression that would fail to match for a more
    complex INSERT statement such as one which had subqueries involved. The new approach
    matches exactly the string that was rendered as the VALUES clause.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4623](https://www.sqlalchemy.org/trac/ticket/4623)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[postgresql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug where Postgresql operators such as [`Comparator.contains()`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY.Comparator.contains
    "sqlalchemy.dialects.postgresql.ARRAY.Comparator.contains") and [`Comparator.contained_by()`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY.Comparator.contained_by
    "sqlalchemy.dialects.postgresql.ARRAY.Comparator.contained_by") would fail to
    function correctly for non-integer values when used against a [`array`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.array
    "sqlalchemy.dialects.postgresql.array") object, due to an erroneous assert statement.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4822](https://www.sqlalchemy.org/trac/ticket/4822)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sqlite
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[sqlite] [bug] [reflection]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug where a FOREIGN KEY that was set up to refer to the parent table by
    table name only without the column names would not correctly be reflected as far
    as setting up the “referred columns”, since SQLite’s PRAGMA does not report on
    these columns if they weren’t given explicitly. For some reason this was hardcoded
    to assume the name of the local column, which might work for some cases but is
    not correct. The new approach reflects the primary key of the referred table and
    uses the constraint columns list as the referred columns list, if the remote column(s)
    aren’t present in the reflected pragma directly.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4810](https://www.sqlalchemy.org/trac/ticket/4810)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 1.3.7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Released: August 14, 2019'
  prefs: []
  type: TYPE_NORMAL
- en: orm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed regression caused by new selectinload for many-to-one logic where a primaryjoin
    condition not based on real foreign keys would cause KeyError if a related object
    did not exist for a given key value on the parent object.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4777](https://www.sqlalchemy.org/trac/ticket/4777)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug where using [`Query.first()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.first
    "sqlalchemy.orm.Query.first") or a slice expression in conjunction with a query
    that has an expression based “offset” applied would raise TypeError, due to an
    “or” conditional against “offset” that did not expect it to be a SQL expression
    as opposed to an integer or None.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4803](https://www.sqlalchemy.org/trac/ticket/4803)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[sql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue where [`Index`](../core/constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index") object which contained a mixture of functional expressions
    which were not resolvable to a particular column, in combination with string-based
    column names, would fail to initialize its internal state correctly leading to
    failures during DDL compilation.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4778](https://www.sqlalchemy.org/trac/ticket/4778)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[sql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug where [`TypeEngine.column_expression()`](../core/type_api.html#sqlalchemy.types.TypeEngine.column_expression
    "sqlalchemy.types.TypeEngine.column_expression") method would not be applied to
    subsequent SELECT statements inside of a UNION or other `_selectable.CompoundSelect`,
    even though the SELECT statements are rendered at the topmost level of the statement.
    New logic now differentiates between rendering the column expression, which is
    needed for all SELECTs in the list, vs. gathering the returned data type for the
    result row, which is needed only for the first SELECT.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4787](https://www.sqlalchemy.org/trac/ticket/4787)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[sql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue where internal cloning of SELECT constructs could lead to a key
    error if the copy of the SELECT changed its state such that its list of columns
    changed. This was observed to be occurring in some ORM scenarios which may be
    unique to 1.3 and above, so is partially a regression fix.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4780](https://www.sqlalchemy.org/trac/ticket/4780)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: postgresql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[postgresql] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added new dialect flag for the psycopg2 dialect, `executemany_mode` which supersedes
    the previous experimental `use_batch_mode` flag. `executemany_mode` supports both
    the “execute batch” and “execute values” functions provided by psycopg2, the latter
    which is used for compiled [`insert()`](../core/dml.html#sqlalchemy.sql.expression.insert
    "sqlalchemy.sql.expression.insert") constructs. Pull request courtesy Yuval Dinari.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Psycopg2 Fast Execution Helpers](../dialects/postgresql.html#psycopg2-executemany-mode)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4623](https://www.sqlalchemy.org/trac/ticket/4623)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: mysql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[mysql] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added reserved words ARRAY and MEMBER to the MySQL reserved words list, as MySQL
    8.0 has now made these reserved.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4783](https://www.sqlalchemy.org/trac/ticket/4783)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[mysql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The MySQL dialects will emit “SET NAMES” at the start of a connection when charset
    is given to the MySQL driver, to appease an apparent behavior observed in MySQL
    8.0 that raises a collation error when a UNION includes string columns unioned
    against columns of the form CAST(NULL AS CHAR(..)), which is what SQLAlchemy’s
    polymorphic_union function does. The issue seems to have affected PyMySQL for
    at least a year, however has recently appeared as of mysqlclient 1.4.4 based on
    changes in how this DBAPI creates a connection. As the presence of this directive
    impacts three separate MySQL charset settings which each have intricate effects
    based on their presence, SQLAlchemy will now emit the directive on new connections
    to ensure correct behavior.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4804](https://www.sqlalchemy.org/trac/ticket/4804)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[mysql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added another fix for an upstream MySQL 8 issue where a case sensitive table
    name is reported incorrectly in foreign key constraint reflection, this is an
    extension of the fix first added for [#4344](https://www.sqlalchemy.org/trac/ticket/4344)
    which affects a case sensitive column name. The new issue occurs through MySQL
    8.0.17, so the general logic of the 88718 fix remains in place.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[https://bugs.mysql.com/bug.php?id=96365](https://bugs.mysql.com/bug.php?id=96365)
    - upstream bug'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4751](https://www.sqlalchemy.org/trac/ticket/4751)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sqlite
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[sqlite] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The dialects that support json are supposed to take arguments `json_serializer`
    and `json_deserializer` at the create_engine() level, however the SQLite dialect
    calls them `_json_serializer` and `_json_deserilalizer`. The names have been corrected,
    the old names are accepted with a change warning, and these parameters are now
    documented as [`create_engine.json_serializer`](../core/engines.html#sqlalchemy.create_engine.params.json_serializer
    "sqlalchemy.create_engine") and [`create_engine.json_deserializer`](../core/engines.html#sqlalchemy.create_engine.params.json_deserializer
    "sqlalchemy.create_engine").
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4798](https://www.sqlalchemy.org/trac/ticket/4798)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[sqlite] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug where usage of “PRAGMA table_info” in SQLite dialect meant that reflection
    features to detect for table existence, list of table columns, and list of foreign
    keys, would default to any table in any attached database, when no schema name
    was given and the table did not exist in the base schema. The fix explicitly runs
    PRAGMA for the ‘main’ schema and then the ‘temp’ schema if the ‘main’ returned
    no rows, to maintain the behavior of tables + temp tables in the “no schema” namespace,
    attached tables only in the “schema” namespace.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4793](https://www.sqlalchemy.org/trac/ticket/4793)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: mssql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[mssql] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added new [`try_cast()`](../dialects/mssql.html#sqlalchemy.dialects.mssql.try_cast
    "sqlalchemy.dialects.mssql.try_cast") construct for SQL Server which emits “TRY_CAST”
    syntax. Pull request courtesy Leonel Atencio.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4782](https://www.sqlalchemy.org/trac/ticket/4782)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: misc
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[bug] [events]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue in event system where using the `once=True` flag with dynamically
    generated listener functions would cause event registration of future events to
    fail if those listener functions were garbage collected after they were used,
    due to an assumption that a listened function is strongly referenced. The “once”
    wrapped is now modified to strongly reference the inner function persistently,
    and documentation is updated that using “once” does not imply automatic de-registration
    of listener functions.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4794](https://www.sqlalchemy.org/trac/ticket/4794)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: orm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed regression caused by new selectinload for many-to-one logic where a primaryjoin
    condition not based on real foreign keys would cause KeyError if a related object
    did not exist for a given key value on the parent object.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4777](https://www.sqlalchemy.org/trac/ticket/4777)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug where using [`Query.first()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.first
    "sqlalchemy.orm.Query.first") or a slice expression in conjunction with a query
    that has an expression based “offset” applied would raise TypeError, due to an
    “or” conditional against “offset” that did not expect it to be a SQL expression
    as opposed to an integer or None.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4803](https://www.sqlalchemy.org/trac/ticket/4803)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[sql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue where [`Index`](../core/constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index") object which contained a mixture of functional expressions
    which were not resolvable to a particular column, in combination with string-based
    column names, would fail to initialize its internal state correctly leading to
    failures during DDL compilation.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4778](https://www.sqlalchemy.org/trac/ticket/4778)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[sql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug where [`TypeEngine.column_expression()`](../core/type_api.html#sqlalchemy.types.TypeEngine.column_expression
    "sqlalchemy.types.TypeEngine.column_expression") method would not be applied to
    subsequent SELECT statements inside of a UNION or other `_selectable.CompoundSelect`,
    even though the SELECT statements are rendered at the topmost level of the statement.
    New logic now differentiates between rendering the column expression, which is
    needed for all SELECTs in the list, vs. gathering the returned data type for the
    result row, which is needed only for the first SELECT.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4787](https://www.sqlalchemy.org/trac/ticket/4787)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[sql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue where internal cloning of SELECT constructs could lead to a key
    error if the copy of the SELECT changed its state such that its list of columns
    changed. This was observed to be occurring in some ORM scenarios which may be
    unique to 1.3 and above, so is partially a regression fix.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4780](https://www.sqlalchemy.org/trac/ticket/4780)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: postgresql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[postgresql] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added new dialect flag for the psycopg2 dialect, `executemany_mode` which supersedes
    the previous experimental `use_batch_mode` flag. `executemany_mode` supports both
    the “execute batch” and “execute values” functions provided by psycopg2, the latter
    which is used for compiled [`insert()`](../core/dml.html#sqlalchemy.sql.expression.insert
    "sqlalchemy.sql.expression.insert") constructs. Pull request courtesy Yuval Dinari.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Psycopg2 Fast Execution Helpers](../dialects/postgresql.html#psycopg2-executemany-mode)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4623](https://www.sqlalchemy.org/trac/ticket/4623)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: mysql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[mysql] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added reserved words ARRAY and MEMBER to the MySQL reserved words list, as MySQL
    8.0 has now made these reserved.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4783](https://www.sqlalchemy.org/trac/ticket/4783)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[mysql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The MySQL dialects will emit “SET NAMES” at the start of a connection when charset
    is given to the MySQL driver, to appease an apparent behavior observed in MySQL
    8.0 that raises a collation error when a UNION includes string columns unioned
    against columns of the form CAST(NULL AS CHAR(..)), which is what SQLAlchemy’s
    polymorphic_union function does. The issue seems to have affected PyMySQL for
    at least a year, however has recently appeared as of mysqlclient 1.4.4 based on
    changes in how this DBAPI creates a connection. As the presence of this directive
    impacts three separate MySQL charset settings which each have intricate effects
    based on their presence, SQLAlchemy will now emit the directive on new connections
    to ensure correct behavior.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4804](https://www.sqlalchemy.org/trac/ticket/4804)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[mysql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added another fix for an upstream MySQL 8 issue where a case sensitive table
    name is reported incorrectly in foreign key constraint reflection, this is an
    extension of the fix first added for [#4344](https://www.sqlalchemy.org/trac/ticket/4344)
    which affects a case sensitive column name. The new issue occurs through MySQL
    8.0.17, so the general logic of the 88718 fix remains in place.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[https://bugs.mysql.com/bug.php?id=96365](https://bugs.mysql.com/bug.php?id=96365)
    - upstream bug'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4751](https://www.sqlalchemy.org/trac/ticket/4751)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sqlite
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[sqlite] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The dialects that support json are supposed to take arguments `json_serializer`
    and `json_deserializer` at the create_engine() level, however the SQLite dialect
    calls them `_json_serializer` and `_json_deserilalizer`. The names have been corrected,
    the old names are accepted with a change warning, and these parameters are now
    documented as [`create_engine.json_serializer`](../core/engines.html#sqlalchemy.create_engine.params.json_serializer
    "sqlalchemy.create_engine") and [`create_engine.json_deserializer`](../core/engines.html#sqlalchemy.create_engine.params.json_deserializer
    "sqlalchemy.create_engine").
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4798](https://www.sqlalchemy.org/trac/ticket/4798)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[sqlite] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug where usage of “PRAGMA table_info” in SQLite dialect meant that reflection
    features to detect for table existence, list of table columns, and list of foreign
    keys, would default to any table in any attached database, when no schema name
    was given and the table did not exist in the base schema. The fix explicitly runs
    PRAGMA for the ‘main’ schema and then the ‘temp’ schema if the ‘main’ returned
    no rows, to maintain the behavior of tables + temp tables in the “no schema” namespace,
    attached tables only in the “schema” namespace.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4793](https://www.sqlalchemy.org/trac/ticket/4793)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: mssql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[mssql] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added new [`try_cast()`](../dialects/mssql.html#sqlalchemy.dialects.mssql.try_cast
    "sqlalchemy.dialects.mssql.try_cast") construct for SQL Server which emits “TRY_CAST”
    syntax. Pull request courtesy Leonel Atencio.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4782](https://www.sqlalchemy.org/trac/ticket/4782)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: misc
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[bug] [events]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue in event system where using the `once=True` flag with dynamically
    generated listener functions would cause event registration of future events to
    fail if those listener functions were garbage collected after they were used,
    due to an assumption that a listened function is strongly referenced. The “once”
    wrapped is now modified to strongly reference the inner function persistently,
    and documentation is updated that using “once” does not imply automatic de-registration
    of listener functions.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4794](https://www.sqlalchemy.org/trac/ticket/4794)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 1.3.6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Released: July 21, 2019'
  prefs: []
  type: TYPE_NORMAL
- en: orm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[orm] [feature]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added new loader option method [`Load.options()`](../orm/queryguide/relationships.html#sqlalchemy.orm.Load.options
    "sqlalchemy.orm.Load.options") which allows loader options to be constructed hierarchically,
    so that many sub-options can be applied to a particular path without needing to
    call [`defaultload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.defaultload
    "sqlalchemy.orm.defaultload") many times. Thanks to Alessio Bogon for the idea.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4736](https://www.sqlalchemy.org/trac/ticket/4736)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [performance]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The optimization applied to selectin loading in [#4340](https://www.sqlalchemy.org/trac/ticket/4340)
    where a JOIN is not needed to eagerly load related items is now applied to many-to-one
    relationships as well, so that only the related table is queried for a simple
    join condition. In this case, the related items are queried based on the value
    of a foreign key column on the parent; if these columns are deferred or otherwise
    not loaded on any of the parent objects in the collection, the loader falls back
    to the JOIN method.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4775](https://www.sqlalchemy.org/trac/ticket/4775)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed regression caused by [#4365](https://www.sqlalchemy.org/trac/ticket/4365)
    where a join from an entity to itself without using aliases no longer raises an
    informative error message, instead failing on an assertion. The informative error
    condition has been restored.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4773](https://www.sqlalchemy.org/trac/ticket/4773)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed an issue where the `_ORMJoin.join()` method, which is a not-internally-used
    ORM-level method that exposes what is normally an internal process of [`Query.join()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join"), did not propagate the `full` and `outerjoin` keyword
    arguments correctly. Pull request courtesy Denis Kataev.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4713](https://www.sqlalchemy.org/trac/ticket/4713)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug where a many-to-one relationship that specified `uselist=True` would
    fail to update correctly during a primary key change where a related column needs
    to change.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4772](https://www.sqlalchemy.org/trac/ticket/4772)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug where the detection for many-to-one or one-to-one use with a “dynamic”
    relationship, which is an invalid configuration, would fail to raise if the relationship
    were configured with `uselist=True`. The current fix is that it warns, instead
    of raises, as this would otherwise be backwards incompatible, however in a future
    release it will be a raise.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4772](https://www.sqlalchemy.org/trac/ticket/4772)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug where a synonym created against a mapped attribute that does not exist
    yet, as is the case when it refers to backref before mappers are configured, would
    raise recursion errors when trying to test for attributes on it which ultimately
    don’t exist (as occurs when the classes are run through Sphinx autodoc), as the
    unconfigured state of the synonym would put it into an attribute not found loop.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4767](https://www.sqlalchemy.org/trac/ticket/4767)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: engine
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[engine] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug where using reflection function such as [`MetaData.reflect()`](../core/metadata.html#sqlalchemy.schema.MetaData.reflect
    "sqlalchemy.schema.MetaData.reflect") with an [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") object that had execution options applied to it would
    fail, as the resulting `OptionEngine` proxy object failed to include a `.engine`
    attribute used within the reflection routines.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4754](https://www.sqlalchemy.org/trac/ticket/4754)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[sql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adjusted the initialization for [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum") to minimize how often it invokes the `.__members__` attribute
    of a given PEP-435 enumeration object, to suit the case where this attribute is
    expensive to invoke, as is the case for some popular third party enumeration libraries.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4758](https://www.sqlalchemy.org/trac/ticket/4758)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[sql] [bug] [postgresql]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue where the [`array_agg`](../core/functions.html#sqlalchemy.sql.functions.array_agg
    "sqlalchemy.sql.functions.array_agg") construct in combination with [`FunctionElement.filter()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.filter
    "sqlalchemy.sql.functions.FunctionElement.filter") would not produce the correct
    operator precedence in combination with the array index operator.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4760](https://www.sqlalchemy.org/trac/ticket/4760)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[sql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed an unlikely issue where the “corresponding column” routine for unions
    and other `_selectable.CompoundSelect` objects could return the wrong column in
    some overlapping column situations, thus potentially impacting some ORM operations
    when set operations are in use, if the underlying [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") constructs were used previously in other similar
    kinds of routines, due to a cached value not being cleared.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4747](https://www.sqlalchemy.org/trac/ticket/4747)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: postgresql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[postgresql] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added support for reflection of indexes on PostgreSQL partitioned tables, which
    was added to PostgreSQL as of version 11.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4771](https://www.sqlalchemy.org/trac/ticket/4771)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[postgresql] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added support for multidimensional Postgresql array literals via nesting the
    [`array`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.array "sqlalchemy.dialects.postgresql.array")
    object within another one. The multidimensional array type is detected automatically.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`array`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.array
    "sqlalchemy.dialects.postgresql.array")'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4756](https://www.sqlalchemy.org/trac/ticket/4756)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: mysql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[mysql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug where the special logic to render “NULL” for the [`TIMESTAMP`](../core/type_basics.html#sqlalchemy.types.TIMESTAMP
    "sqlalchemy.types.TIMESTAMP") datatype when `nullable=True` would not work if
    the column’s datatype were a [`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") or a [`Variant`](../core/type_api.html#sqlalchemy.types.Variant
    "sqlalchemy.types.Variant"). The logic now ensures that it unwraps down to the
    original [`TIMESTAMP`](../core/type_basics.html#sqlalchemy.types.TIMESTAMP "sqlalchemy.types.TIMESTAMP")
    so that this special case NULL keyword is correctly rendered when requested.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4743](https://www.sqlalchemy.org/trac/ticket/4743)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[mysql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enhanced MySQL/MariaDB version string parsing to accommodate for exotic MariaDB
    version strings where the “MariaDB” word is embedded among other alphanumeric
    characters such as “MariaDBV1”. This detection is critical in order to correctly
    accommodate for API features that have split between MySQL and MariaDB such as
    the “transaction_isolation” system variable.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4624](https://www.sqlalchemy.org/trac/ticket/4624)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sqlite
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[sqlite] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added support for composite (tuple) IN operators with SQLite, by rendering the
    VALUES keyword for this backend. As other backends such as DB2 are known to use
    the same syntax, the syntax is enabled in the base compiler using a dialect-level
    flag `tuple_in_values`. The change also includes support for “empty IN tuple”
    expressions for SQLite when using “in_()” between a tuple value and an empty set.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4766](https://www.sqlalchemy.org/trac/ticket/4766)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: mssql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[mssql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensured that the queries used to reflect indexes and view definitions will explicitly
    CAST string parameters into NVARCHAR, as many SQL Server drivers frequently treat
    string values, particularly those with non-ascii characters or larger string values,
    as TEXT which often don’t compare correctly against VARCHAR characters in SQL
    Server’s information schema tables for some reason. These CAST operations already
    take place for reflection queries against SQL Server `information_schema.` tables
    but were missing from three additional queries that are against `sys.` tables.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4745](https://www.sqlalchemy.org/trac/ticket/4745)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: orm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[orm] [feature]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added new loader option method [`Load.options()`](../orm/queryguide/relationships.html#sqlalchemy.orm.Load.options
    "sqlalchemy.orm.Load.options") which allows loader options to be constructed hierarchically,
    so that many sub-options can be applied to a particular path without needing to
    call [`defaultload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.defaultload
    "sqlalchemy.orm.defaultload") many times. Thanks to Alessio Bogon for the idea.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4736](https://www.sqlalchemy.org/trac/ticket/4736)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [performance]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The optimization applied to selectin loading in [#4340](https://www.sqlalchemy.org/trac/ticket/4340)
    where a JOIN is not needed to eagerly load related items is now applied to many-to-one
    relationships as well, so that only the related table is queried for a simple
    join condition. In this case, the related items are queried based on the value
    of a foreign key column on the parent; if these columns are deferred or otherwise
    not loaded on any of the parent objects in the collection, the loader falls back
    to the JOIN method.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4775](https://www.sqlalchemy.org/trac/ticket/4775)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed regression caused by [#4365](https://www.sqlalchemy.org/trac/ticket/4365)
    where a join from an entity to itself without using aliases no longer raises an
    informative error message, instead failing on an assertion. The informative error
    condition has been restored.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4773](https://www.sqlalchemy.org/trac/ticket/4773)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed an issue where the `_ORMJoin.join()` method, which is a not-internally-used
    ORM-level method that exposes what is normally an internal process of [`Query.join()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join"), did not propagate the `full` and `outerjoin` keyword
    arguments correctly. Pull request courtesy Denis Kataev.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4713](https://www.sqlalchemy.org/trac/ticket/4713)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug where a many-to-one relationship that specified `uselist=True` would
    fail to update correctly during a primary key change where a related column needs
    to change.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4772](https://www.sqlalchemy.org/trac/ticket/4772)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug where the detection for many-to-one or one-to-one use with a “dynamic”
    relationship, which is an invalid configuration, would fail to raise if the relationship
    were configured with `uselist=True`. The current fix is that it warns, instead
    of raises, as this would otherwise be backwards incompatible, however in a future
    release it will be a raise.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4772](https://www.sqlalchemy.org/trac/ticket/4772)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug where a synonym created against a mapped attribute that does not exist
    yet, as is the case when it refers to backref before mappers are configured, would
    raise recursion errors when trying to test for attributes on it which ultimately
    don’t exist (as occurs when the classes are run through Sphinx autodoc), as the
    unconfigured state of the synonym would put it into an attribute not found loop.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4767](https://www.sqlalchemy.org/trac/ticket/4767)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: engine
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[engine] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug where using reflection function such as [`MetaData.reflect()`](../core/metadata.html#sqlalchemy.schema.MetaData.reflect
    "sqlalchemy.schema.MetaData.reflect") with an [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") object that had execution options applied to it would
    fail, as the resulting `OptionEngine` proxy object failed to include a `.engine`
    attribute used within the reflection routines.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4754](https://www.sqlalchemy.org/trac/ticket/4754)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[sql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adjusted the initialization for [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum") to minimize how often it invokes the `.__members__` attribute
    of a given PEP-435 enumeration object, to suit the case where this attribute is
    expensive to invoke, as is the case for some popular third party enumeration libraries.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4758](https://www.sqlalchemy.org/trac/ticket/4758)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[sql] [bug] [postgresql]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue where the [`array_agg`](../core/functions.html#sqlalchemy.sql.functions.array_agg
    "sqlalchemy.sql.functions.array_agg") construct in combination with [`FunctionElement.filter()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.filter
    "sqlalchemy.sql.functions.FunctionElement.filter") would not produce the correct
    operator precedence in combination with the array index operator.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4760](https://www.sqlalchemy.org/trac/ticket/4760)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[sql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed an unlikely issue where the “corresponding column” routine for unions
    and other `_selectable.CompoundSelect` objects could return the wrong column in
    some overlapping column situations, thus potentially impacting some ORM operations
    when set operations are in use, if the underlying [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") constructs were used previously in other similar
    kinds of routines, due to a cached value not being cleared.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4747](https://www.sqlalchemy.org/trac/ticket/4747)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: postgresql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[postgresql] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added support for reflection of indexes on PostgreSQL partitioned tables, which
    was added to PostgreSQL as of version 11.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4771](https://www.sqlalchemy.org/trac/ticket/4771)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[postgresql] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added support for multidimensional Postgresql array literals via nesting the
    [`array`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.array "sqlalchemy.dialects.postgresql.array")
    object within another one. The multidimensional array type is detected automatically.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`array`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.array
    "sqlalchemy.dialects.postgresql.array")'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4756](https://www.sqlalchemy.org/trac/ticket/4756)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: mysql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[mysql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug where the special logic to render “NULL” for the [`TIMESTAMP`](../core/type_basics.html#sqlalchemy.types.TIMESTAMP
    "sqlalchemy.types.TIMESTAMP") datatype when `nullable=True` would not work if
    the column’s datatype were a [`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") or a [`Variant`](../core/type_api.html#sqlalchemy.types.Variant
    "sqlalchemy.types.Variant"). The logic now ensures that it unwraps down to the
    original [`TIMESTAMP`](../core/type_basics.html#sqlalchemy.types.TIMESTAMP "sqlalchemy.types.TIMESTAMP")
    so that this special case NULL keyword is correctly rendered when requested.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4743](https://www.sqlalchemy.org/trac/ticket/4743)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[mysql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enhanced MySQL/MariaDB version string parsing to accommodate for exotic MariaDB
    version strings where the “MariaDB” word is embedded among other alphanumeric
    characters such as “MariaDBV1”. This detection is critical in order to correctly
    accommodate for API features that have split between MySQL and MariaDB such as
    the “transaction_isolation” system variable.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4624](https://www.sqlalchemy.org/trac/ticket/4624)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sqlite
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[sqlite] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added support for composite (tuple) IN operators with SQLite, by rendering the
    VALUES keyword for this backend. As other backends such as DB2 are known to use
    the same syntax, the syntax is enabled in the base compiler using a dialect-level
    flag `tuple_in_values`. The change also includes support for “empty IN tuple”
    expressions for SQLite when using “in_()” between a tuple value and an empty set.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4766](https://www.sqlalchemy.org/trac/ticket/4766)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: mssql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[mssql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensured that the queries used to reflect indexes and view definitions will explicitly
    CAST string parameters into NVARCHAR, as many SQL Server drivers frequently treat
    string values, particularly those with non-ascii characters or larger string values,
    as TEXT which often don’t compare correctly against VARCHAR characters in SQL
    Server’s information schema tables for some reason. These CAST operations already
    take place for reflection queries against SQL Server `information_schema.` tables
    but were missing from three additional queries that are against `sys.` tables.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4745](https://www.sqlalchemy.org/trac/ticket/4745)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 1.3.5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Released: June 17, 2019'
  prefs: []
  type: TYPE_NORMAL
- en: orm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed a series of related bugs regarding joined table inheritance more than
    two levels deep, in conjunction with modification to primary key values, where
    those primary key columns are also linked together in a foreign key relationship
    as is typical for joined table inheritance. The intermediary table in a three-level
    inheritance hierarchy will now get its UPDATE if only the primary key value has
    changed and passive_updates=False (e.g. foreign key constraints not being enforced),
    whereas before it would be skipped; similarly, with passive_updates=True (e.g.
    ON UPDATE CASCADE in effect), the third-level table will not receive an UPDATE
    statement as was the case earlier which would fail since CASCADE already modified
    it. In a related issue, a relationship linked to a three-level inheritance hierarchy
    on the primary key of an intermediary table of a joined-inheritance hierarchy
    will also correctly have its foreign key column updated when the parent object’s
    primary key is modified, even if that parent object is a subclass of the linked
    parent class, whereas before these classes would not be counted.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4723](https://www.sqlalchemy.org/trac/ticket/4723)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug where the [`Mapper.all_orm_descriptors`](../orm/mapping_api.html#sqlalchemy.orm.Mapper.all_orm_descriptors
    "sqlalchemy.orm.Mapper.all_orm_descriptors") accessor would return an entry for
    the [`Mapper`](../orm/mapping_api.html#sqlalchemy.orm.Mapper "sqlalchemy.orm.Mapper")
    itself under the declarative `__mapper__` key, when this is not a descriptor.
    The `.is_attribute` flag that’s present on all [`InspectionAttr`](../orm/internals.html#sqlalchemy.orm.InspectionAttr
    "sqlalchemy.orm.InspectionAttr") objects is now consulted, which has also been
    modified to be `True` for an association proxy, as it was erroneously set to False
    for this object.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4729](https://www.sqlalchemy.org/trac/ticket/4729)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed regression in [`Query.join()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join") where the `aliased=True` flag would not properly
    apply clause adaptation to filter criteria, if a previous join were made to the
    same entity. This is because the adapters were placed in the wrong order. The
    order has been reversed so that the adapter for the most recent `aliased=True`
    call takes precedence as was the case in 1.2 and earlier. This broke the “elementtree”
    examples among other things.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4704](https://www.sqlalchemy.org/trac/ticket/4704)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug] [py3k]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replaced the Python compatibility routines for `getfullargspec()` with a fully
    vendored version from Python 3.3\. Originally, Python was emitting deprecation
    warnings for this function in Python 3.8 alphas. While this change was reverted,
    it was observed that Python 3 implementations for `getfullargspec()` are an order
    of magnitude slower as of the 3.4 series where it was rewritten against `Signature`.
    While Python plans to improve upon this situation, SQLAlchemy projects for now
    are using a simple replacement to avoid any future issues.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4674](https://www.sqlalchemy.org/trac/ticket/4674)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reworked the attribute mechanics used by [`AliasedClass`](../orm/queryguide/api.html#sqlalchemy.orm.util.AliasedClass
    "sqlalchemy.orm.util.AliasedClass") to no longer rely upon calling `__getattribute__`
    on the MRO of the wrapped class, and to instead resolve the attribute normally
    on the wrapped class using getattr(), and then unwrap/adapt that. This allows
    a greater range of attribute styles on the mapped class including special `__getattr__()`
    schemes; but it also makes the code simpler and more resilient in general.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4694](https://www.sqlalchemy.org/trac/ticket/4694)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[sql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Addressed a range of quoting issues originating from the use of the `literal_column`()`
    construct. When this construct is “proxied” through a subquery and referred to
    by a label matching its text, the label does not have quoting rules applied to
    it, even if the string in the [`Label`](../core/sqlelement.html#sqlalchemy.sql.expression.Label
    "sqlalchemy.sql.expression.Label") was set up using a `quoted_name`` construct.
    Not applying quoting to the text of the [`Label`](../core/sqlelement.html#sqlalchemy.sql.expression.Label
    "sqlalchemy.sql.expression.Label") is a bug because this text is strictly a SQL
    identifier name and not a SQL expression, and the string should not have quotes
    embedded into it already unlike the [`literal_column()`](../core/sqlelement.html#sqlalchemy.sql.expression.literal_column
    "sqlalchemy.sql.expression.literal_column") which it may be applied towards. The
    existing behavior of a non-labeled [`literal_column()`](../core/sqlelement.html#sqlalchemy.sql.expression.literal_column
    "sqlalchemy.sql.expression.literal_column") being propagated as is on the outside
    of a subquery is maintained in order to help with manual quoting schemes, although
    it’s not clear if valid SQL can be generated for such a construct in any case.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4730](https://www.sqlalchemy.org/trac/ticket/4730)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: postgresql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[postgresql] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added support for column sorting flags when reflecting indexes for PostgreSQL,
    including ASC, DESC, NULLSFIRST, NULLSLAST. Also adds this facility to the reflection
    system in general which can be applied to other dialects in future releases. Pull
    request courtesy Eli Collins.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4717](https://www.sqlalchemy.org/trac/ticket/4717)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[postgresql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug where PostgreSQL dialect could not correctly reflect an ENUM datatype
    that has no members, returning a list with `None` for the `get_enums()` call and
    raising a TypeError when reflecting a column which has such a datatype. The inspection
    now returns an empty list.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4701](https://www.sqlalchemy.org/trac/ticket/4701)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: mysql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[mysql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug where MySQL ON DUPLICATE KEY UPDATE would not accommodate setting
    a column to the value NULL. Pull request courtesy Lukáš Banič.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4715](https://www.sqlalchemy.org/trac/ticket/4715)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: orm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed a series of related bugs regarding joined table inheritance more than
    two levels deep, in conjunction with modification to primary key values, where
    those primary key columns are also linked together in a foreign key relationship
    as is typical for joined table inheritance. The intermediary table in a three-level
    inheritance hierarchy will now get its UPDATE if only the primary key value has
    changed and passive_updates=False (e.g. foreign key constraints not being enforced),
    whereas before it would be skipped; similarly, with passive_updates=True (e.g.
    ON UPDATE CASCADE in effect), the third-level table will not receive an UPDATE
    statement as was the case earlier which would fail since CASCADE already modified
    it. In a related issue, a relationship linked to a three-level inheritance hierarchy
    on the primary key of an intermediary table of a joined-inheritance hierarchy
    will also correctly have its foreign key column updated when the parent object’s
    primary key is modified, even if that parent object is a subclass of the linked
    parent class, whereas before these classes would not be counted.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4723](https://www.sqlalchemy.org/trac/ticket/4723)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug where the [`Mapper.all_orm_descriptors`](../orm/mapping_api.html#sqlalchemy.orm.Mapper.all_orm_descriptors
    "sqlalchemy.orm.Mapper.all_orm_descriptors") accessor would return an entry for
    the [`Mapper`](../orm/mapping_api.html#sqlalchemy.orm.Mapper "sqlalchemy.orm.Mapper")
    itself under the declarative `__mapper__` key, when this is not a descriptor.
    The `.is_attribute` flag that’s present on all [`InspectionAttr`](../orm/internals.html#sqlalchemy.orm.InspectionAttr
    "sqlalchemy.orm.InspectionAttr") objects is now consulted, which has also been
    modified to be `True` for an association proxy, as it was erroneously set to False
    for this object.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4729](https://www.sqlalchemy.org/trac/ticket/4729)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed regression in [`Query.join()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join") where the `aliased=True` flag would not properly
    apply clause adaptation to filter criteria, if a previous join were made to the
    same entity. This is because the adapters were placed in the wrong order. The
    order has been reversed so that the adapter for the most recent `aliased=True`
    call takes precedence as was the case in 1.2 and earlier. This broke the “elementtree”
    examples among other things.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4704](https://www.sqlalchemy.org/trac/ticket/4704)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug] [py3k]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replaced the Python compatibility routines for `getfullargspec()` with a fully
    vendored version from Python 3.3\. Originally, Python was emitting deprecation
    warnings for this function in Python 3.8 alphas. While this change was reverted,
    it was observed that Python 3 implementations for `getfullargspec()` are an order
    of magnitude slower as of the 3.4 series where it was rewritten against `Signature`.
    While Python plans to improve upon this situation, SQLAlchemy projects for now
    are using a simple replacement to avoid any future issues.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4674](https://www.sqlalchemy.org/trac/ticket/4674)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reworked the attribute mechanics used by [`AliasedClass`](../orm/queryguide/api.html#sqlalchemy.orm.util.AliasedClass
    "sqlalchemy.orm.util.AliasedClass") to no longer rely upon calling `__getattribute__`
    on the MRO of the wrapped class, and to instead resolve the attribute normally
    on the wrapped class using getattr(), and then unwrap/adapt that. This allows
    a greater range of attribute styles on the mapped class including special `__getattr__()`
    schemes; but it also makes the code simpler and more resilient in general.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4694](https://www.sqlalchemy.org/trac/ticket/4694)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[sql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Addressed a range of quoting issues originating from the use of the `literal_column`()`
    construct. When this construct is “proxied” through a subquery and referred to
    by a label matching its text, the label does not have quoting rules applied to
    it, even if the string in the [`Label`](../core/sqlelement.html#sqlalchemy.sql.expression.Label
    "sqlalchemy.sql.expression.Label") was set up using a `quoted_name`` construct.
    Not applying quoting to the text of the [`Label`](../core/sqlelement.html#sqlalchemy.sql.expression.Label
    "sqlalchemy.sql.expression.Label") is a bug because this text is strictly a SQL
    identifier name and not a SQL expression, and the string should not have quotes
    embedded into it already unlike the [`literal_column()`](../core/sqlelement.html#sqlalchemy.sql.expression.literal_column
    "sqlalchemy.sql.expression.literal_column") which it may be applied towards. The
    existing behavior of a non-labeled [`literal_column()`](../core/sqlelement.html#sqlalchemy.sql.expression.literal_column
    "sqlalchemy.sql.expression.literal_column") being propagated as is on the outside
    of a subquery is maintained in order to help with manual quoting schemes, although
    it’s not clear if valid SQL can be generated for such a construct in any case.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4730](https://www.sqlalchemy.org/trac/ticket/4730)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: postgresql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[postgresql] [usecase]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added support for column sorting flags when reflecting indexes for PostgreSQL,
    including ASC, DESC, NULLSFIRST, NULLSLAST. Also adds this facility to the reflection
    system in general which can be applied to other dialects in future releases. Pull
    request courtesy Eli Collins.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4717](https://www.sqlalchemy.org/trac/ticket/4717)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[postgresql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug where PostgreSQL dialect could not correctly reflect an ENUM datatype
    that has no members, returning a list with `None` for the `get_enums()` call and
    raising a TypeError when reflecting a column which has such a datatype. The inspection
    now returns an empty list.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4701](https://www.sqlalchemy.org/trac/ticket/4701)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: mysql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[mysql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug where MySQL ON DUPLICATE KEY UPDATE would not accommodate setting
    a column to the value NULL. Pull request courtesy Lukáš Banič.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4715](https://www.sqlalchemy.org/trac/ticket/4715)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 1.3.4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Released: May 27, 2019'
  prefs: []
  type: TYPE_NORMAL
- en: orm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue where the [`AttributeEvents.active_history`](../orm/events.html#sqlalchemy.orm.AttributeEvents.params.active_history
    "sqlalchemy.orm.AttributeEvents") flag would not be set for an event listener
    that propagated to a subclass via the [`AttributeEvents.propagate`](../orm/events.html#sqlalchemy.orm.AttributeEvents.params.propagate
    "sqlalchemy.orm.AttributeEvents") flag. This bug has been present for the full
    span of the [`AttributeEvents`](../orm/events.html#sqlalchemy.orm.AttributeEvents
    "sqlalchemy.orm.AttributeEvents") system.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4695](https://www.sqlalchemy.org/trac/ticket/4695)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed regression where new association proxy system was still not proxying hybrid
    attributes when they made use of the `@hybrid_property.expression` decorator to
    return an alternate SQL expression, or when the hybrid returned an arbitrary [`PropComparator`](../orm/internals.html#sqlalchemy.orm.PropComparator
    "sqlalchemy.orm.PropComparator"), at the expression level. This involved further
    generalization of the heuristics used to detect the type of object being proxied
    at the level of [`QueryableAttribute`](../orm/internals.html#sqlalchemy.orm.QueryableAttribute
    "sqlalchemy.orm.QueryableAttribute"), to better detect if the descriptor ultimately
    serves mapped classes or column expressions.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4690](https://www.sqlalchemy.org/trac/ticket/4690)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applied the mapper “configure mutex” against the declarative class mapping process,
    to guard against the race which can occur if mappers are used while dynamic module
    import schemes are still in the process of configuring mappers for related classes.
    This does not guard against all possible race conditions, such as if the concurrent
    import has not yet encountered the dependent classes as of yet, however it guards
    against as much as possible within the SQLAlchemy declarative process.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4686](https://www.sqlalchemy.org/trac/ticket/4686)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A warning is now emitted for the case where a transient object is being merged
    into the session with [`Session.merge()`](../orm/session_api.html#sqlalchemy.orm.Session.merge
    "sqlalchemy.orm.Session.merge") when that object is already transient in the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"). This warns for the case where the object would normally
    be double-inserted.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4647](https://www.sqlalchemy.org/trac/ticket/4647)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed regression in new relationship m2o comparison logic first introduced at
    [Improvement to the behavior of many-to-one query expressions](migration_13.html#change-4359)
    when comparing to an attribute that is persisted as NULL and is in an un-fetched
    state in the mapped instance. Since the attribute has no explicit default, it
    needs to default to NULL when accessed in a persistent setting.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4676](https://www.sqlalchemy.org/trac/ticket/4676)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: engine
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[engine] [bug] [postgresql]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moved the “rollback” which occurs during dialect initialization so that it occurs
    after additional dialect-specific initialize steps, in particular those of the
    psycopg2 dialect which would inadvertently leave transactional state on the first
    new connection, which could interfere with some psycopg2-specific APIs which require
    that no transaction is started. Pull request courtesy Matthew Wilkes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4663](https://www.sqlalchemy.org/trac/ticket/4663)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[sql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed that the [`GenericFunction`](../core/functions.html#sqlalchemy.sql.functions.GenericFunction
    "sqlalchemy.sql.functions.GenericFunction") class was inadvertently registering
    itself as one of the named functions. Pull request courtesy Adrien Berchet.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4653](https://www.sqlalchemy.org/trac/ticket/4653)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[sql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue where double negation of a boolean column wouldn’t reset the “NOT”
    operator.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4618](https://www.sqlalchemy.org/trac/ticket/4618)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[sql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [`GenericFunction`](../core/functions.html#sqlalchemy.sql.functions.GenericFunction
    "sqlalchemy.sql.functions.GenericFunction") namespace is being migrated so that
    function names are looked up in a case-insensitive manner, as SQL functions do
    not collide on case sensitive differences nor is this something which would occur
    with user-defined functions or stored procedures. Lookups for functions declared
    with [`GenericFunction`](../core/functions.html#sqlalchemy.sql.functions.GenericFunction
    "sqlalchemy.sql.functions.GenericFunction") now use a case insensitive scheme,
    however a deprecation case is supported which allows two or more [`GenericFunction`](../core/functions.html#sqlalchemy.sql.functions.GenericFunction
    "sqlalchemy.sql.functions.GenericFunction") objects with the same name of different
    cases to exist, which will cause case sensitive lookups to occur for that particular
    name, while emitting a warning at function registration time. Thanks to Adrien
    Berchet for a lot of work on this complicated feature.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4569](https://www.sqlalchemy.org/trac/ticket/4569)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: postgresql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[postgresql] [bug] [orm]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed an issue where the “number of rows matched” warning would emit even if
    the dialect reported “supports_sane_multi_rowcount=False”, as is the case for
    psycogp2 with `use_batch_mode=True` and others.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4661](https://www.sqlalchemy.org/trac/ticket/4661)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: mysql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[mysql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added support for DROP CHECK constraint which is required by MySQL 8.0.16 to
    drop a CHECK constraint; MariaDB supports plain DROP CONSTRAINT. The logic distinguishes
    between the two syntaxes by checking the server version string for MariaDB presence.
    Alembic migrations has already worked around this issue by implementing its own
    DROP for MySQL / MariaDB CHECK constraints, however this change implements it
    straight in Core so that its available for general use. Pull request courtesy
    Hannes Hansen.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4650](https://www.sqlalchemy.org/trac/ticket/4650)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: mssql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[mssql] [feature]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added support for SQL Server filtered indexes, via the `mssql_where` parameter
    which works similarly to that of the `postgresql_where` index function in the
    PostgreSQL dialect.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Filtered Indexes](../dialects/mssql.html#mssql-index-where)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4657](https://www.sqlalchemy.org/trac/ticket/4657)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[mssql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added error code 20047 to “is_disconnect” for pymssql. Pull request courtesy
    Jon Schuff.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4680](https://www.sqlalchemy.org/trac/ticket/4680)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: misc
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[misc] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removed errant “sqla_nose.py” symbol from MANIFEST.in which created an undesirable
    warning message.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4625](https://www.sqlalchemy.org/trac/ticket/4625)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: orm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue where the [`AttributeEvents.active_history`](../orm/events.html#sqlalchemy.orm.AttributeEvents.params.active_history
    "sqlalchemy.orm.AttributeEvents") flag would not be set for an event listener
    that propagated to a subclass via the [`AttributeEvents.propagate`](../orm/events.html#sqlalchemy.orm.AttributeEvents.params.propagate
    "sqlalchemy.orm.AttributeEvents") flag. This bug has been present for the full
    span of the [`AttributeEvents`](../orm/events.html#sqlalchemy.orm.AttributeEvents
    "sqlalchemy.orm.AttributeEvents") system.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4695](https://www.sqlalchemy.org/trac/ticket/4695)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed regression where new association proxy system was still not proxying hybrid
    attributes when they made use of the `@hybrid_property.expression` decorator to
    return an alternate SQL expression, or when the hybrid returned an arbitrary [`PropComparator`](../orm/internals.html#sqlalchemy.orm.PropComparator
    "sqlalchemy.orm.PropComparator"), at the expression level. This involved further
    generalization of the heuristics used to detect the type of object being proxied
    at the level of [`QueryableAttribute`](../orm/internals.html#sqlalchemy.orm.QueryableAttribute
    "sqlalchemy.orm.QueryableAttribute"), to better detect if the descriptor ultimately
    serves mapped classes or column expressions.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4690](https://www.sqlalchemy.org/trac/ticket/4690)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applied the mapper “configure mutex” against the declarative class mapping process,
    to guard against the race which can occur if mappers are used while dynamic module
    import schemes are still in the process of configuring mappers for related classes.
    This does not guard against all possible race conditions, such as if the concurrent
    import has not yet encountered the dependent classes as of yet, however it guards
    against as much as possible within the SQLAlchemy declarative process.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4686](https://www.sqlalchemy.org/trac/ticket/4686)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A warning is now emitted for the case where a transient object is being merged
    into the session with [`Session.merge()`](../orm/session_api.html#sqlalchemy.orm.Session.merge
    "sqlalchemy.orm.Session.merge") when that object is already transient in the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"). This warns for the case where the object would normally
    be double-inserted.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4647](https://www.sqlalchemy.org/trac/ticket/4647)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed regression in new relationship m2o comparison logic first introduced at
    [Improvement to the behavior of many-to-one query expressions](migration_13.html#change-4359)
    when comparing to an attribute that is persisted as NULL and is in an un-fetched
    state in the mapped instance. Since the attribute has no explicit default, it
    needs to default to NULL when accessed in a persistent setting.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4676](https://www.sqlalchemy.org/trac/ticket/4676)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: engine
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[engine] [bug] [postgresql]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moved the “rollback” which occurs during dialect initialization so that it occurs
    after additional dialect-specific initialize steps, in particular those of the
    psycopg2 dialect which would inadvertently leave transactional state on the first
    new connection, which could interfere with some psycopg2-specific APIs which require
    that no transaction is started. Pull request courtesy Matthew Wilkes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4663](https://www.sqlalchemy.org/trac/ticket/4663)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[sql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed that the [`GenericFunction`](../core/functions.html#sqlalchemy.sql.functions.GenericFunction
    "sqlalchemy.sql.functions.GenericFunction") class was inadvertently registering
    itself as one of the named functions. Pull request courtesy Adrien Berchet.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4653](https://www.sqlalchemy.org/trac/ticket/4653)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[sql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue where double negation of a boolean column wouldn’t reset the “NOT”
    operator.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4618](https://www.sqlalchemy.org/trac/ticket/4618)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[sql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [`GenericFunction`](../core/functions.html#sqlalchemy.sql.functions.GenericFunction
    "sqlalchemy.sql.functions.GenericFunction") namespace is being migrated so that
    function names are looked up in a case-insensitive manner, as SQL functions do
    not collide on case sensitive differences nor is this something which would occur
    with user-defined functions or stored procedures. Lookups for functions declared
    with [`GenericFunction`](../core/functions.html#sqlalchemy.sql.functions.GenericFunction
    "sqlalchemy.sql.functions.GenericFunction") now use a case insensitive scheme,
    however a deprecation case is supported which allows two or more [`GenericFunction`](../core/functions.html#sqlalchemy.sql.functions.GenericFunction
    "sqlalchemy.sql.functions.GenericFunction") objects with the same name of different
    cases to exist, which will cause case sensitive lookups to occur for that particular
    name, while emitting a warning at function registration time. Thanks to Adrien
    Berchet for a lot of work on this complicated feature.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4569](https://www.sqlalchemy.org/trac/ticket/4569)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: postgresql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[postgresql] [bug] [orm]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed an issue where the “number of rows matched” warning would emit even if
    the dialect reported “supports_sane_multi_rowcount=False”, as is the case for
    psycogp2 with `use_batch_mode=True` and others.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4661](https://www.sqlalchemy.org/trac/ticket/4661)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: mysql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[mysql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added support for DROP CHECK constraint which is required by MySQL 8.0.16 to
    drop a CHECK constraint; MariaDB supports plain DROP CONSTRAINT. The logic distinguishes
    between the two syntaxes by checking the server version string for MariaDB presence.
    Alembic migrations has already worked around this issue by implementing its own
    DROP for MySQL / MariaDB CHECK constraints, however this change implements it
    straight in Core so that its available for general use. Pull request courtesy
    Hannes Hansen.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4650](https://www.sqlalchemy.org/trac/ticket/4650)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: mssql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[mssql] [feature]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added support for SQL Server filtered indexes, via the `mssql_where` parameter
    which works similarly to that of the `postgresql_where` index function in the
    PostgreSQL dialect.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Filtered Indexes](../dialects/mssql.html#mssql-index-where)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4657](https://www.sqlalchemy.org/trac/ticket/4657)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[mssql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added error code 20047 to “is_disconnect” for pymssql. Pull request courtesy
    Jon Schuff.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4680](https://www.sqlalchemy.org/trac/ticket/4680)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: misc
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[misc] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removed errant “sqla_nose.py” symbol from MANIFEST.in which created an undesirable
    warning message.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4625](https://www.sqlalchemy.org/trac/ticket/4625)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 1.3.3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Released: April 15, 2019'
  prefs: []
  type: TYPE_NORMAL
- en: orm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed 1.3 regression in new “ambiguous FROMs” query logic introduced in [Query.join()
    handles ambiguity in deciding the “left” side more explicitly](migration_13.html#change-4365)
    where a [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    that explicitly places an entity in the FROM clause with [`Query.select_from()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.select_from
    "sqlalchemy.orm.Query.select_from") and also joins to it using [`Query.join()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join") would later cause an “ambiguous FROM” error if that
    entity were used in additional joins, as the entity appears twice in the “from”
    list of the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query").
    The fix resolves this ambiguity by folding the standalone entity into the join
    that it’s already a part of in the same way that ultimately happens when the SELECT
    statement is rendered.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4584](https://www.sqlalchemy.org/trac/ticket/4584)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adjusted the [`Query.filter_by()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.filter_by
    "sqlalchemy.orm.Query.filter_by") method to not call `and()` internally against
    multiple criteria, instead passing it off to [`Query.filter()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.filter
    "sqlalchemy.orm.Query.filter") as a series of criteria, instead of a single criteria.
    This allows [`Query.filter_by()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.filter_by
    "sqlalchemy.orm.Query.filter_by") to defer to [`Query.filter()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.filter
    "sqlalchemy.orm.Query.filter")’s treatment of variable numbers of clauses, including
    the case where the list is empty. In this case, the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object will not have a `.whereclause`, which allows subsequent
    “no whereclause” methods like [`Query.select_from()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.select_from
    "sqlalchemy.orm.Query.select_from") to behave consistently.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4606](https://www.sqlalchemy.org/trac/ticket/4606)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: postgresql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[postgresql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed regression from release 1.3.2 caused by [#4562](https://www.sqlalchemy.org/trac/ticket/4562)
    where a URL that contained only a query string and no hostname, such as for the
    purposes of specifying a service file with connection information, would no longer
    be propagated to psycopg2 properly. The change in [#4562](https://www.sqlalchemy.org/trac/ticket/4562)
    has been adjusted to further suit psycopg2’s exact requirements, which is that
    if there are any connection parameters whatsoever, the “dsn” parameter is no longer
    required, so in this case the query string parameters are passed alone.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4601](https://www.sqlalchemy.org/trac/ticket/4601)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: mssql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[mssql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue in SQL Server dialect where if a bound parameter were present in
    an ORDER BY expression that would ultimately not be rendered in the SQL Server
    version of the statement, the parameters would still be part of the execution
    parameters, leading to DBAPI-level errors. Pull request courtesy Matt Lewellyn.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4587](https://www.sqlalchemy.org/trac/ticket/4587)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: misc
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[bug] [pool]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed behavioral regression as a result of deprecating the “use_threadlocal”
    flag for [`Pool`](../core/pooling.html#sqlalchemy.pool.Pool "sqlalchemy.pool.Pool"),
    where the [`SingletonThreadPool`](../core/pooling.html#sqlalchemy.pool.SingletonThreadPool
    "sqlalchemy.pool.SingletonThreadPool") no longer makes use of this option which
    causes the “rollback on return” logic to take place when the same [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") is used multiple times in the context of a transaction
    to connect or implicitly execute, thereby cancelling the transaction. While this
    is not the recommended way to work with engines and connections, it is nonetheless
    a confusing behavioral change as when using [`SingletonThreadPool`](../core/pooling.html#sqlalchemy.pool.SingletonThreadPool
    "sqlalchemy.pool.SingletonThreadPool"), the transaction should stay open regardless
    of what else is done with the same engine in the same thread. The `use_threadlocal`
    flag remains deprecated however the [`SingletonThreadPool`](../core/pooling.html#sqlalchemy.pool.SingletonThreadPool
    "sqlalchemy.pool.SingletonThreadPool") now implements its own version of the same
    logic.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4585](https://www.sqlalchemy.org/trac/ticket/4585)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[bug] [ext]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug where using `copy.copy()` or `copy.deepcopy()` on [`MutableList`](../orm/extensions/mutable.html#sqlalchemy.ext.mutable.MutableList
    "sqlalchemy.ext.mutable.MutableList") would cause the items within the list to
    be duplicated, due to an inconsistency in how Python pickle and copy both make
    use of `__getstate__()` and `__setstate__()` regarding lists. In order to resolve,
    a `__reduce_ex__` method had to be added to [`MutableList`](../orm/extensions/mutable.html#sqlalchemy.ext.mutable.MutableList
    "sqlalchemy.ext.mutable.MutableList"). In order to maintain backwards compatibility
    with existing pickles based on `__getstate__()`, the `__setstate__()` method remains
    as well; the test suite asserts that pickles made against the old version of the
    class can still be deserialized by the pickle module.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4603](https://www.sqlalchemy.org/trac/ticket/4603)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: orm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed 1.3 regression in new “ambiguous FROMs” query logic introduced in [Query.join()
    handles ambiguity in deciding the “left” side more explicitly](migration_13.html#change-4365)
    where a [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    that explicitly places an entity in the FROM clause with [`Query.select_from()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.select_from
    "sqlalchemy.orm.Query.select_from") and also joins to it using [`Query.join()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join") would later cause an “ambiguous FROM” error if that
    entity were used in additional joins, as the entity appears twice in the “from”
    list of the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query").
    The fix resolves this ambiguity by folding the standalone entity into the join
    that it’s already a part of in the same way that ultimately happens when the SELECT
    statement is rendered.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4584](https://www.sqlalchemy.org/trac/ticket/4584)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adjusted the [`Query.filter_by()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.filter_by
    "sqlalchemy.orm.Query.filter_by") method to not call `and()` internally against
    multiple criteria, instead passing it off to [`Query.filter()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.filter
    "sqlalchemy.orm.Query.filter") as a series of criteria, instead of a single criteria.
    This allows [`Query.filter_by()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.filter_by
    "sqlalchemy.orm.Query.filter_by") to defer to [`Query.filter()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.filter
    "sqlalchemy.orm.Query.filter")’s treatment of variable numbers of clauses, including
    the case where the list is empty. In this case, the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object will not have a `.whereclause`, which allows subsequent
    “no whereclause” methods like [`Query.select_from()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.select_from
    "sqlalchemy.orm.Query.select_from") to behave consistently.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4606](https://www.sqlalchemy.org/trac/ticket/4606)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: postgresql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[postgresql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed regression from release 1.3.2 caused by [#4562](https://www.sqlalchemy.org/trac/ticket/4562)
    where a URL that contained only a query string and no hostname, such as for the
    purposes of specifying a service file with connection information, would no longer
    be propagated to psycopg2 properly. The change in [#4562](https://www.sqlalchemy.org/trac/ticket/4562)
    has been adjusted to further suit psycopg2’s exact requirements, which is that
    if there are any connection parameters whatsoever, the “dsn” parameter is no longer
    required, so in this case the query string parameters are passed alone.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4601](https://www.sqlalchemy.org/trac/ticket/4601)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: mssql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[mssql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue in SQL Server dialect where if a bound parameter were present in
    an ORDER BY expression that would ultimately not be rendered in the SQL Server
    version of the statement, the parameters would still be part of the execution
    parameters, leading to DBAPI-level errors. Pull request courtesy Matt Lewellyn.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4587](https://www.sqlalchemy.org/trac/ticket/4587)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: misc
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[bug] [pool]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed behavioral regression as a result of deprecating the “use_threadlocal”
    flag for [`Pool`](../core/pooling.html#sqlalchemy.pool.Pool "sqlalchemy.pool.Pool"),
    where the [`SingletonThreadPool`](../core/pooling.html#sqlalchemy.pool.SingletonThreadPool
    "sqlalchemy.pool.SingletonThreadPool") no longer makes use of this option which
    causes the “rollback on return” logic to take place when the same [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") is used multiple times in the context of a transaction
    to connect or implicitly execute, thereby cancelling the transaction. While this
    is not the recommended way to work with engines and connections, it is nonetheless
    a confusing behavioral change as when using [`SingletonThreadPool`](../core/pooling.html#sqlalchemy.pool.SingletonThreadPool
    "sqlalchemy.pool.SingletonThreadPool"), the transaction should stay open regardless
    of what else is done with the same engine in the same thread. The `use_threadlocal`
    flag remains deprecated however the [`SingletonThreadPool`](../core/pooling.html#sqlalchemy.pool.SingletonThreadPool
    "sqlalchemy.pool.SingletonThreadPool") now implements its own version of the same
    logic.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4585](https://www.sqlalchemy.org/trac/ticket/4585)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[bug] [ext]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug where using `copy.copy()` or `copy.deepcopy()` on [`MutableList`](../orm/extensions/mutable.html#sqlalchemy.ext.mutable.MutableList
    "sqlalchemy.ext.mutable.MutableList") would cause the items within the list to
    be duplicated, due to an inconsistency in how Python pickle and copy both make
    use of `__getstate__()` and `__setstate__()` regarding lists. In order to resolve,
    a `__reduce_ex__` method had to be added to [`MutableList`](../orm/extensions/mutable.html#sqlalchemy.ext.mutable.MutableList
    "sqlalchemy.ext.mutable.MutableList"). In order to maintain backwards compatibility
    with existing pickles based on `__getstate__()`, the `__setstate__()` method remains
    as well; the test suite asserts that pickles made against the old version of the
    class can still be deserialized by the pickle module.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4603](https://www.sqlalchemy.org/trac/ticket/4603)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 1.3.2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Released: April 2, 2019'
  prefs: []
  type: TYPE_NORMAL
- en: orm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[orm] [bug] [ext]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Restored instance-level support for plain Python descriptors, e.g. `@property`
    objects, in conjunction with association proxies, in that if the proxied object
    is not within ORM scope at all, it gets classified as “ambiguous” but is proxed
    directly. For class level access, a basic class level``__get__()`` now returns
    the `AmbiguousAssociationProxyInstance` directly, rather than raising its exception,
    which is the closest approximation to the previous behavior that returned the
    [`AssociationProxy`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy
    "sqlalchemy.ext.associationproxy.AssociationProxy") itself that’s possible. Also
    improved the stringification of these objects to be more descriptive of current
    state.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4573](https://www.sqlalchemy.org/trac/ticket/4573), [#4574](https://www.sqlalchemy.org/trac/ticket/4574)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug where use of [`with_polymorphic()`](../orm/queryguide/inheritance.html#sqlalchemy.orm.with_polymorphic
    "sqlalchemy.orm.with_polymorphic") or other aliased construct would not properly
    adapt when the aliased target were used as the [`Select.correlate_except()`](../core/selectable.html#sqlalchemy.sql.expression.Select.correlate_except
    "sqlalchemy.sql.expression.Select.correlate_except") target of a subquery used
    inside of a [`column_property()`](../orm/mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property"). This required a fix to the clause adaption
    mechanics to properly handle a selectable that shows up in the “correlate except”
    list, in a similar manner as which occurs for selectables that show up in the
    “correlate” list. This is ultimately a fairly fundamental bug that has lasted
    for a long time but it is hard to come across it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4537](https://www.sqlalchemy.org/trac/ticket/4537)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed regression where a new error message that was supposed to raise when attempting
    to link a relationship option to an AliasedClass without using [`PropComparator.of_type()`](../orm/internals.html#sqlalchemy.orm.PropComparator.of_type
    "sqlalchemy.orm.PropComparator.of_type") would instead raise an `AttributeError`.
    Note that in 1.3, it is no longer valid to create an option path from a plain
    mapper relationship to an [`AliasedClass`](../orm/queryguide/api.html#sqlalchemy.orm.util.AliasedClass
    "sqlalchemy.orm.util.AliasedClass") without using [`PropComparator.of_type()`](../orm/internals.html#sqlalchemy.orm.PropComparator.of_type
    "sqlalchemy.orm.PropComparator.of_type").
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4566](https://www.sqlalchemy.org/trac/ticket/4566)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[sql] [bug] [documentation]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thanks to [TypeEngine methods bind_expression, column_expression work with Variant,
    type-specific types](migration_13.html#change-3981), we no longer need to rely
    on recipes that subclass dialect-specific types directly, [`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") can now handle all cases. Additionally, the
    above change made it slightly less likely that a direct subclass of a base SQLAlchemy
    type would work as expected, which could be misleading. Documentation has been
    updated to use [`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") for these examples including the PostgreSQL
    “ArrayOfEnum” example datatype and direct support for the “subclass a type directly”
    has been removed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4580](https://www.sqlalchemy.org/trac/ticket/4580)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: postgresql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[postgresql] [feature]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added support for parameter-less connection URLs for the psycopg2 dialect, meaning,
    the URL can be passed to [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") as `"postgresql+psycopg2://"` with no additional arguments
    to indicate an empty DSN passed to libpq, which indicates to connect to “localhost”
    with no username, password, or database given. Pull request courtesy Julian Mehnle.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4562](https://www.sqlalchemy.org/trac/ticket/4562)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[postgresql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modified the [`Select.with_for_update.of`](../core/selectable.html#sqlalchemy.sql.expression.Select.with_for_update.params.of
    "sqlalchemy.sql.expression.Select.with_for_update") parameter so that if a join
    or other composed selectable is passed, the individual [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects will be filtered from it, allowing one to pass
    a join() object to the parameter, as occurs normally when using joined table inheritance
    with the ORM. Pull request courtesy Raymond Lu.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4550](https://www.sqlalchemy.org/trac/ticket/4550)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: orm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[orm] [bug] [ext]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Restored instance-level support for plain Python descriptors, e.g. `@property`
    objects, in conjunction with association proxies, in that if the proxied object
    is not within ORM scope at all, it gets classified as “ambiguous” but is proxed
    directly. For class level access, a basic class level``__get__()`` now returns
    the `AmbiguousAssociationProxyInstance` directly, rather than raising its exception,
    which is the closest approximation to the previous behavior that returned the
    [`AssociationProxy`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy
    "sqlalchemy.ext.associationproxy.AssociationProxy") itself that’s possible. Also
    improved the stringification of these objects to be more descriptive of current
    state.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4573](https://www.sqlalchemy.org/trac/ticket/4573), [#4574](https://www.sqlalchemy.org/trac/ticket/4574)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug where use of [`with_polymorphic()`](../orm/queryguide/inheritance.html#sqlalchemy.orm.with_polymorphic
    "sqlalchemy.orm.with_polymorphic") or other aliased construct would not properly
    adapt when the aliased target were used as the [`Select.correlate_except()`](../core/selectable.html#sqlalchemy.sql.expression.Select.correlate_except
    "sqlalchemy.sql.expression.Select.correlate_except") target of a subquery used
    inside of a [`column_property()`](../orm/mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property"). This required a fix to the clause adaption
    mechanics to properly handle a selectable that shows up in the “correlate except”
    list, in a similar manner as which occurs for selectables that show up in the
    “correlate” list. This is ultimately a fairly fundamental bug that has lasted
    for a long time but it is hard to come across it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4537](https://www.sqlalchemy.org/trac/ticket/4537)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed regression where a new error message that was supposed to raise when attempting
    to link a relationship option to an AliasedClass without using [`PropComparator.of_type()`](../orm/internals.html#sqlalchemy.orm.PropComparator.of_type
    "sqlalchemy.orm.PropComparator.of_type") would instead raise an `AttributeError`.
    Note that in 1.3, it is no longer valid to create an option path from a plain
    mapper relationship to an [`AliasedClass`](../orm/queryguide/api.html#sqlalchemy.orm.util.AliasedClass
    "sqlalchemy.orm.util.AliasedClass") without using [`PropComparator.of_type()`](../orm/internals.html#sqlalchemy.orm.PropComparator.of_type
    "sqlalchemy.orm.PropComparator.of_type").
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4566](https://www.sqlalchemy.org/trac/ticket/4566)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[sql] [bug] [documentation]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thanks to [TypeEngine methods bind_expression, column_expression work with Variant,
    type-specific types](migration_13.html#change-3981), we no longer need to rely
    on recipes that subclass dialect-specific types directly, [`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") can now handle all cases. Additionally, the
    above change made it slightly less likely that a direct subclass of a base SQLAlchemy
    type would work as expected, which could be misleading. Documentation has been
    updated to use [`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") for these examples including the PostgreSQL
    “ArrayOfEnum” example datatype and direct support for the “subclass a type directly”
    has been removed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4580](https://www.sqlalchemy.org/trac/ticket/4580)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: postgresql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[postgresql] [feature]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added support for parameter-less connection URLs for the psycopg2 dialect, meaning,
    the URL can be passed to [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") as `"postgresql+psycopg2://"` with no additional arguments
    to indicate an empty DSN passed to libpq, which indicates to connect to “localhost”
    with no username, password, or database given. Pull request courtesy Julian Mehnle.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4562](https://www.sqlalchemy.org/trac/ticket/4562)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[postgresql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modified the [`Select.with_for_update.of`](../core/selectable.html#sqlalchemy.sql.expression.Select.with_for_update.params.of
    "sqlalchemy.sql.expression.Select.with_for_update") parameter so that if a join
    or other composed selectable is passed, the individual [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects will be filtered from it, allowing one to pass
    a join() object to the parameter, as occurs normally when using joined table inheritance
    with the ORM. Pull request courtesy Raymond Lu.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4550](https://www.sqlalchemy.org/trac/ticket/4550)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 1.3.1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Released: March 9, 2019'
  prefs: []
  type: TYPE_NORMAL
- en: orm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[orm] [bug] [ext]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed regression where an association proxy linked to a synonym would no longer
    work, both at instance level and at class level.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4522](https://www.sqlalchemy.org/trac/ticket/4522)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: mssql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[mssql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A commit() is emitted after an isolation level change to SNAPSHOT, as both pyodbc
    and pymssql open an implicit transaction which blocks subsequent SQL from being
    emitted in the current transaction.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This change is also **backported** to: 1.2.19'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4536](https://www.sqlalchemy.org/trac/ticket/4536)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[mssql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed regression in SQL Server reflection due to [#4393](https://www.sqlalchemy.org/trac/ticket/4393)
    where the removal of open-ended `**kw` from the [`Float`](../core/type_basics.html#sqlalchemy.types.Float
    "sqlalchemy.types.Float") datatype caused reflection of this type to fail due
    to a “scale” argument being passed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4525](https://www.sqlalchemy.org/trac/ticket/4525)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: orm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[orm] [bug] [ext]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed regression where an association proxy linked to a synonym would no longer
    work, both at instance level and at class level.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4522](https://www.sqlalchemy.org/trac/ticket/4522)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: mssql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[mssql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A commit() is emitted after an isolation level change to SNAPSHOT, as both pyodbc
    and pymssql open an implicit transaction which blocks subsequent SQL from being
    emitted in the current transaction.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This change is also **backported** to: 1.2.19'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4536](https://www.sqlalchemy.org/trac/ticket/4536)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[mssql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed regression in SQL Server reflection due to [#4393](https://www.sqlalchemy.org/trac/ticket/4393)
    where the removal of open-ended `**kw` from the [`Float`](../core/type_basics.html#sqlalchemy.types.Float
    "sqlalchemy.types.Float") datatype caused reflection of this type to fail due
    to a “scale” argument being passed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4525](https://www.sqlalchemy.org/trac/ticket/4525)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 1.3.0
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Released: March 4, 2019'
  prefs: []
  type: TYPE_NORMAL
- en: orm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[orm] [feature]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [`Query.get()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.get "sqlalchemy.orm.Query.get")
    method can now accept a dictionary of attribute keys and values as a means of
    indicating the primary key value to load; is particularly useful for composite
    primary keys. Pull request courtesy Sanjana S.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4316](https://www.sqlalchemy.org/trac/ticket/4316)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [feature]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A SQL expression can now be assigned to a primary key attribute for an ORM flush
    in the same manner as ordinary attributes as described in [Embedding SQL Insert/Update
    Expressions into a Flush](../orm/persistence_techniques.html#flush-embedded-sql-expressions)
    where the expression will be evaluated and then returned to the ORM using RETURNING,
    or in the case of pysqlite, works using the cursor.lastrowid attribute.Requires
    either a database that supports RETURNING (e.g. Postgresql, Oracle, SQL Server)
    or pysqlite.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#3133](https://www.sqlalchemy.org/trac/ticket/3133)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: engine
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[engine] [feature]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Revised the formatting for [`StatementError`](../core/exceptions.html#sqlalchemy.exc.StatementError
    "sqlalchemy.exc.StatementError") when stringified. Each error detail is broken
    up over multiple newlines instead of spaced out on a single line. Additionally,
    the SQL representation now stringifies the SQL statement rather than using `repr()`,
    so that newlines are rendered as is. Pull request courtesy Nate Clark.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Changed StatementError formatting (newlines and %s)](migration_13.html#change-4500)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4500](https://www.sqlalchemy.org/trac/ticket/4500)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[sql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [`Alias`](../core/selectable.html#sqlalchemy.sql.expression.Alias "sqlalchemy.sql.expression.Alias")
    class and related subclasses [`CTE`](../core/selectable.html#sqlalchemy.sql.expression.CTE
    "sqlalchemy.sql.expression.CTE"), [`Lateral`](../core/selectable.html#sqlalchemy.sql.expression.Lateral
    "sqlalchemy.sql.expression.Lateral") and [`TableSample`](../core/selectable.html#sqlalchemy.sql.expression.TableSample
    "sqlalchemy.sql.expression.TableSample") have been reworked so that it is not
    possible for a user to construct the objects directly. These constructs require
    that the standalone construction function or selectable-bound method be used to
    instantiate new objects.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4509](https://www.sqlalchemy.org/trac/ticket/4509)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: schema
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[schema] [feature]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added new parameters [`Table.resolve_fks`](../core/metadata.html#sqlalchemy.schema.Table.params.resolve_fks
    "sqlalchemy.schema.Table") and [`MetaData.reflect.resolve_fks`](../core/metadata.html#sqlalchemy.schema.MetaData.reflect.params.resolve_fks
    "sqlalchemy.schema.MetaData.reflect") which when set to False will disable the
    automatic reflection of related tables encountered in [`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey") objects, which can both reduce SQL overhead for
    omitted tables as well as avoid tables that can’t be reflected for database-specific
    reasons. Two [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    objects present in the same [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") collection can still refer to each other even if
    the reflection of the two tables occurred separately.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4517](https://www.sqlalchemy.org/trac/ticket/4517)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: orm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[orm] [feature]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [`Query.get()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.get "sqlalchemy.orm.Query.get")
    method can now accept a dictionary of attribute keys and values as a means of
    indicating the primary key value to load; is particularly useful for composite
    primary keys. Pull request courtesy Sanjana S.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4316](https://www.sqlalchemy.org/trac/ticket/4316)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [feature]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A SQL expression can now be assigned to a primary key attribute for an ORM flush
    in the same manner as ordinary attributes as described in [Embedding SQL Insert/Update
    Expressions into a Flush](../orm/persistence_techniques.html#flush-embedded-sql-expressions)
    where the expression will be evaluated and then returned to the ORM using RETURNING,
    or in the case of pysqlite, works using the cursor.lastrowid attribute.Requires
    either a database that supports RETURNING (e.g. Postgresql, Oracle, SQL Server)
    or pysqlite.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#3133](https://www.sqlalchemy.org/trac/ticket/3133)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: engine
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[engine] [feature]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Revised the formatting for [`StatementError`](../core/exceptions.html#sqlalchemy.exc.StatementError
    "sqlalchemy.exc.StatementError") when stringified. Each error detail is broken
    up over multiple newlines instead of spaced out on a single line. Additionally,
    the SQL representation now stringifies the SQL statement rather than using `repr()`,
    so that newlines are rendered as is. Pull request courtesy Nate Clark.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Changed StatementError formatting (newlines and %s)](migration_13.html#change-4500)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4500](https://www.sqlalchemy.org/trac/ticket/4500)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[sql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [`Alias`](../core/selectable.html#sqlalchemy.sql.expression.Alias "sqlalchemy.sql.expression.Alias")
    class and related subclasses [`CTE`](../core/selectable.html#sqlalchemy.sql.expression.CTE
    "sqlalchemy.sql.expression.CTE"), [`Lateral`](../core/selectable.html#sqlalchemy.sql.expression.Lateral
    "sqlalchemy.sql.expression.Lateral") and [`TableSample`](../core/selectable.html#sqlalchemy.sql.expression.TableSample
    "sqlalchemy.sql.expression.TableSample") have been reworked so that it is not
    possible for a user to construct the objects directly. These constructs require
    that the standalone construction function or selectable-bound method be used to
    instantiate new objects.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4509](https://www.sqlalchemy.org/trac/ticket/4509)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: schema
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[schema] [feature]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added new parameters [`Table.resolve_fks`](../core/metadata.html#sqlalchemy.schema.Table.params.resolve_fks
    "sqlalchemy.schema.Table") and [`MetaData.reflect.resolve_fks`](../core/metadata.html#sqlalchemy.schema.MetaData.reflect.params.resolve_fks
    "sqlalchemy.schema.MetaData.reflect") which when set to False will disable the
    automatic reflection of related tables encountered in [`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey") objects, which can both reduce SQL overhead for
    omitted tables as well as avoid tables that can’t be reflected for database-specific
    reasons. Two [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    objects present in the same [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") collection can still refer to each other even if
    the reflection of the two tables occurred separately.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4517](https://www.sqlalchemy.org/trac/ticket/4517)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 1.3.0b3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Released: February 8, 2019'
  prefs: []
  type: TYPE_NORMAL
- en: orm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improved the behavior of [`with_polymorphic()`](../orm/queryguide/inheritance.html#sqlalchemy.orm.with_polymorphic
    "sqlalchemy.orm.with_polymorphic") in conjunction with loader options, in particular
    wildcard operations as well as [`load_only()`](../orm/queryguide/columns.html#sqlalchemy.orm.load_only
    "sqlalchemy.orm.load_only"). The polymorphic object will be more accurately targeted
    so that column-level options on the entity will correctly take effect.The issue
    is a continuation of the same kinds of things fixed in [#4468](https://www.sqlalchemy.org/trac/ticket/4468).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4469](https://www.sqlalchemy.org/trac/ticket/4469)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: orm declarative
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[orm] [declarative] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added some helper exceptions that invoke when a mapping based on [`AbstractConcreteBase`](../orm/extensions/declarative/index.html#sqlalchemy.ext.declarative.AbstractConcreteBase
    "sqlalchemy.ext.declarative.AbstractConcreteBase"), [`DeferredReflection`](../orm/extensions/declarative/index.html#sqlalchemy.ext.declarative.DeferredReflection
    "sqlalchemy.ext.declarative.DeferredReflection"), or `AutoMap` is used before
    the mapping is ready to be used, which contain descriptive information on the
    class, rather than falling through into other failure modes that are less informative.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4470](https://www.sqlalchemy.org/trac/ticket/4470)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[sql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fully removed the behavior of strings passed directly as components of a [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") or [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object being coerced to [`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text
    "sqlalchemy.sql.expression.text") constructs automatically; the warning that has
    been emitted is now an ArgumentError or in the case of order_by() / group_by()
    a CompileError. This has emitted a warning since version 1.0 however its presence
    continues to create concerns for the potential of mis-use of this behavior.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Note that public CVEs have been posted for order_by() / group_by() which are
    resolved by this commit: CVE-2019-7164 CVE-2019-7548'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Coercion of string SQL fragments to text() fully removed](migration_13.html#change-4481)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4481](https://www.sqlalchemy.org/trac/ticket/4481)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[sql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Quoting is applied to [`Function`](../core/functions.html#sqlalchemy.sql.functions.Function
    "sqlalchemy.sql.functions.Function") names, those which are usually but not necessarily
    generated from the [`sqlalchemy.sql.expression.func`](../core/sqlelement.html#sqlalchemy.sql.expression.func
    "sqlalchemy.sql.expression.func") construct, at compile time if they contain illegal
    characters, such as spaces or punctuation. The names are as before treated as
    case insensitive however, meaning if the names contain uppercase or mixed case
    characters, that alone does not trigger quoting. The case insensitivity is currently
    maintained for backwards compatibility.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4467](https://www.sqlalchemy.org/trac/ticket/4467)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[sql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added “SQL phrase validation” to key DDL phrases that are accepted as plain
    strings, including [`ForeignKeyConstraint.on_delete`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint.params.on_delete
    "sqlalchemy.schema.ForeignKeyConstraint"), [`ForeignKeyConstraint.on_update`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint.params.on_update
    "sqlalchemy.schema.ForeignKeyConstraint"), [`ExcludeConstraint.using`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ExcludeConstraint.params.using
    "sqlalchemy.dialects.postgresql.ExcludeConstraint"), [`ForeignKeyConstraint.initially`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint.params.initially
    "sqlalchemy.schema.ForeignKeyConstraint"), for areas where a series of SQL keywords
    only are expected.Any non-space characters that suggest the phrase would need
    to be quoted will raise a [`CompileError`](../core/exceptions.html#sqlalchemy.exc.CompileError
    "sqlalchemy.exc.CompileError"). This change is related to the series of changes
    committed as part of [#4481](https://www.sqlalchemy.org/trac/ticket/4481).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4481](https://www.sqlalchemy.org/trac/ticket/4481)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: postgresql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[postgresql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue where using an uppercase name for an index type (e.g. GIST, BTREE,
    etc. ) or an EXCLUDE constraint would treat it as an identifier to be quoted,
    rather than rendering it as is. The new behavior converts these types to lowercase
    and ensures they contain only valid SQL characters.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4473](https://www.sqlalchemy.org/trac/ticket/4473)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: tests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[tests] [change]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The test system has removed support for Nose, which is unmaintained for several
    years and is producing warnings under Python 3\. The test suite is currently standardized
    on Pytest. Pull request courtesy Parth Shandilya.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4460](https://www.sqlalchemy.org/trac/ticket/4460)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: misc
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[bug] [ext]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implemented a more comprehensive assignment operation (e.g. “bulk replace”)
    when using association proxy with sets or dictionaries. Fixes the problem of redundant
    proxy objects being created to replace the old ones, which leads to excessive
    events and SQL and in the case of unique constraints will cause the flush to fail.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Implemented bulk replace for sets, dicts with AssociationProxy](migration_13.html#change-2642)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#2642](https://www.sqlalchemy.org/trac/ticket/2642)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: orm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improved the behavior of [`with_polymorphic()`](../orm/queryguide/inheritance.html#sqlalchemy.orm.with_polymorphic
    "sqlalchemy.orm.with_polymorphic") in conjunction with loader options, in particular
    wildcard operations as well as [`load_only()`](../orm/queryguide/columns.html#sqlalchemy.orm.load_only
    "sqlalchemy.orm.load_only"). The polymorphic object will be more accurately targeted
    so that column-level options on the entity will correctly take effect.The issue
    is a continuation of the same kinds of things fixed in [#4468](https://www.sqlalchemy.org/trac/ticket/4468).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4469](https://www.sqlalchemy.org/trac/ticket/4469)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: orm declarative
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[orm] [declarative] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added some helper exceptions that invoke when a mapping based on [`AbstractConcreteBase`](../orm/extensions/declarative/index.html#sqlalchemy.ext.declarative.AbstractConcreteBase
    "sqlalchemy.ext.declarative.AbstractConcreteBase"), [`DeferredReflection`](../orm/extensions/declarative/index.html#sqlalchemy.ext.declarative.DeferredReflection
    "sqlalchemy.ext.declarative.DeferredReflection"), or `AutoMap` is used before
    the mapping is ready to be used, which contain descriptive information on the
    class, rather than falling through into other failure modes that are less informative.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4470](https://www.sqlalchemy.org/trac/ticket/4470)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[sql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fully removed the behavior of strings passed directly as components of a [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") or [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object being coerced to [`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text
    "sqlalchemy.sql.expression.text") constructs automatically; the warning that has
    been emitted is now an ArgumentError or in the case of order_by() / group_by()
    a CompileError. This has emitted a warning since version 1.0 however its presence
    continues to create concerns for the potential of mis-use of this behavior.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Note that public CVEs have been posted for order_by() / group_by() which are
    resolved by this commit: CVE-2019-7164 CVE-2019-7548'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Coercion of string SQL fragments to text() fully removed](migration_13.html#change-4481)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4481](https://www.sqlalchemy.org/trac/ticket/4481)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[sql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Quoting is applied to [`Function`](../core/functions.html#sqlalchemy.sql.functions.Function
    "sqlalchemy.sql.functions.Function") names, those which are usually but not necessarily
    generated from the [`sqlalchemy.sql.expression.func`](../core/sqlelement.html#sqlalchemy.sql.expression.func
    "sqlalchemy.sql.expression.func") construct, at compile time if they contain illegal
    characters, such as spaces or punctuation. The names are as before treated as
    case insensitive however, meaning if the names contain uppercase or mixed case
    characters, that alone does not trigger quoting. The case insensitivity is currently
    maintained for backwards compatibility.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4467](https://www.sqlalchemy.org/trac/ticket/4467)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[sql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added “SQL phrase validation” to key DDL phrases that are accepted as plain
    strings, including [`ForeignKeyConstraint.on_delete`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint.params.on_delete
    "sqlalchemy.schema.ForeignKeyConstraint"), [`ForeignKeyConstraint.on_update`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint.params.on_update
    "sqlalchemy.schema.ForeignKeyConstraint"), [`ExcludeConstraint.using`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ExcludeConstraint.params.using
    "sqlalchemy.dialects.postgresql.ExcludeConstraint"), [`ForeignKeyConstraint.initially`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint.params.initially
    "sqlalchemy.schema.ForeignKeyConstraint"), for areas where a series of SQL keywords
    only are expected.Any non-space characters that suggest the phrase would need
    to be quoted will raise a [`CompileError`](../core/exceptions.html#sqlalchemy.exc.CompileError
    "sqlalchemy.exc.CompileError"). This change is related to the series of changes
    committed as part of [#4481](https://www.sqlalchemy.org/trac/ticket/4481).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4481](https://www.sqlalchemy.org/trac/ticket/4481)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: postgresql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[postgresql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue where using an uppercase name for an index type (e.g. GIST, BTREE,
    etc. ) or an EXCLUDE constraint would treat it as an identifier to be quoted,
    rather than rendering it as is. The new behavior converts these types to lowercase
    and ensures they contain only valid SQL characters.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4473](https://www.sqlalchemy.org/trac/ticket/4473)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: tests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[tests] [change]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The test system has removed support for Nose, which is unmaintained for several
    years and is producing warnings under Python 3\. The test suite is currently standardized
    on Pytest. Pull request courtesy Parth Shandilya.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4460](https://www.sqlalchemy.org/trac/ticket/4460)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: misc
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[bug] [ext]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implemented a more comprehensive assignment operation (e.g. “bulk replace”)
    when using association proxy with sets or dictionaries. Fixes the problem of redundant
    proxy objects being created to replace the old ones, which leads to excessive
    events and SQL and in the case of unique constraints will cause the flush to fail.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Implemented bulk replace for sets, dicts with AssociationProxy](migration_13.html#change-2642)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#2642](https://www.sqlalchemy.org/trac/ticket/2642)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 1.3.0b2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Released: January 25, 2019'
  prefs: []
  type: TYPE_NORMAL
- en: general
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[general] [change]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A large change throughout the library has ensured that all objects, parameters,
    and behaviors which have been noted as deprecated or legacy now emit `DeprecationWarning`
    warnings when invoked.As the Python 3 interpreter now defaults to displaying deprecation
    warnings, as well as that modern test suites based on tools like tox and pytest
    tend to display deprecation warnings, this change should make it easier to note
    what API features are obsolete. A major rationale for this change is so that long-
    deprecated features that nonetheless still see continue to see real world use
    can finally be removed in the near future; the biggest example of this are the
    `SessionExtension` and `MapperExtension` classes as well as a handful of other
    pre-event extension hooks, which have been deprecated since version 0.7 but still
    remain in the library. Another is that several major longstanding behaviors are
    to be deprecated as well, including the threadlocal engine strategy, the convert_unicode
    flag, and non primary mappers.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Deprecation warnings are emitted for all deprecated elements; new deprecations
    added](migration_13.html#change-4393-general)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4393](https://www.sqlalchemy.org/trac/ticket/4393)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: orm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[orm] [feature]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implemented a new feature whereby the [`AliasedClass`](../orm/queryguide/api.html#sqlalchemy.orm.util.AliasedClass
    "sqlalchemy.orm.util.AliasedClass") construct can now be used as the target of
    a [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship"). This allows the concept of “non primary mappers”
    to no longer be necessary, as the [`AliasedClass`](../orm/queryguide/api.html#sqlalchemy.orm.util.AliasedClass
    "sqlalchemy.orm.util.AliasedClass") is much easier to configure and automatically
    inherits all the relationships of the mapped class, as well as preserves the ability
    for loader options to work normally.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Relationship to AliasedClass replaces the need for non primary mappers](migration_13.html#change-4423)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4423](https://www.sqlalchemy.org/trac/ticket/4423)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [feature]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added new [`MapperEvents.before_mapper_configured()`](../orm/events.html#sqlalchemy.orm.MapperEvents.before_mapper_configured
    "sqlalchemy.orm.MapperEvents.before_mapper_configured") event. This event complements
    the other “configure” stage mapper events with a per mapper event that receives
    each [`Mapper`](../orm/mapping_api.html#sqlalchemy.orm.Mapper "sqlalchemy.orm.Mapper")
    right before its configure step, and additionally may be used to prevent or delay
    the configuration of specific [`Mapper`](../orm/mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper") objects using a new return value `interfaces.EXT_SKIP`.
    See the documentation link for an example.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`MapperEvents.before_mapper_configured()`](../orm/events.html#sqlalchemy.orm.MapperEvents.before_mapper_configured
    "sqlalchemy.orm.MapperEvents.before_mapper_configured")'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4397](https://www.sqlalchemy.org/trac/ticket/4397)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [change]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added a new function [`close_all_sessions()`](../orm/session_api.html#sqlalchemy.orm.close_all_sessions
    "sqlalchemy.orm.close_all_sessions") which takes over the task of the [`Session.close_all()`](../orm/session_api.html#sqlalchemy.orm.Session.close_all
    "sqlalchemy.orm.Session.close_all") method, which is now deprecated as this is
    confusing as a classmethod. Pull request courtesy Augustin Trancart.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4412](https://www.sqlalchemy.org/trac/ticket/4412)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed long-standing issue where duplicate collection members would cause a backref
    to delete the association between the member and its parent object when one of
    the duplicates were removed, as occurs as a side effect of swapping two objects
    in one statement.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Many-to-one backref checks for collection duplicates during remove operation](migration_13.html#change-1103)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#1103](https://www.sqlalchemy.org/trac/ticket/1103)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extended the fix first made as part of [#3287](https://www.sqlalchemy.org/trac/ticket/3287),
    where a loader option made against a subclass using a wildcard would extend itself
    to include application of the wildcard to attributes on the super classes as well,
    to a “bound” loader option as well, e.g. in an expression like `Load(SomeSubClass).load_only('foo')`.
    Columns that are part of the parent class of `SomeSubClass` will also be excluded
    in the same way as if the unbound option `load_only('foo')` were used.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4373](https://www.sqlalchemy.org/trac/ticket/4373)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improved error messages emitted by the ORM in the area of loader option traversal.
    This includes early detection of mis-matched loader strategies along with a clearer
    explanation why these strategies don’t match.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4433](https://www.sqlalchemy.org/trac/ticket/4433)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The “remove” event for collections is now called before the item is removed
    in the case of the `collection.remove()` method, as is consistent with the behavior
    for most other forms of collection item removal (such as `__delitem__`, replacement
    under `__setitem__`). For `pop()` methods, the remove event still fires after
    the operation.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug] [engine]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added accessors for execution options to Core and ORM, via [`Query.get_execution_options()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.get_execution_options
    "sqlalchemy.orm.Query.get_execution_options"), [`Connection.get_execution_options()`](../core/connections.html#sqlalchemy.engine.Connection.get_execution_options
    "sqlalchemy.engine.Connection.get_execution_options"), [`Engine.get_execution_options()`](../core/connections.html#sqlalchemy.engine.Engine.get_execution_options
    "sqlalchemy.engine.Engine.get_execution_options"), and [`Executable.get_execution_options()`](../core/selectable.html#sqlalchemy.sql.expression.Executable.get_execution_options
    "sqlalchemy.sql.expression.Executable.get_execution_options"). PR courtesy Daniel
    Lister.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4464](https://www.sqlalchemy.org/trac/ticket/4464)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue in association proxy due to [#3423](https://www.sqlalchemy.org/trac/ticket/3423)
    which caused the use of custom [`PropComparator`](../orm/internals.html#sqlalchemy.orm.PropComparator
    "sqlalchemy.orm.PropComparator") objects with hybrid attributes, such as the one
    demonstrated in the `dictlike-polymorphic` example to not function within an association
    proxy. The strictness that was added in [#3423](https://www.sqlalchemy.org/trac/ticket/3423)
    has been relaxed, and additional logic to accommodate for an association proxy
    that links to a custom hybrid have been added.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4446](https://www.sqlalchemy.org/trac/ticket/4446)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implemented the `.get_history()` method, which also implies availability of
    [`AttributeState.history`](../orm/internals.html#sqlalchemy.orm.AttributeState.history
    "sqlalchemy.orm.AttributeState.history"), for [`synonym()`](../orm/mapped_attributes.html#sqlalchemy.orm.synonym
    "sqlalchemy.orm.synonym") attributes. Previously, trying to access attribute history
    via a synonym would raise an `AttributeError`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#3777](https://www.sqlalchemy.org/trac/ticket/3777)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: orm declarative
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[bug] [orm declarative]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added a `__clause_element__()` method to [`ColumnProperty`](../orm/internals.html#sqlalchemy.orm.ColumnProperty
    "sqlalchemy.orm.ColumnProperty") which can allow the usage of a not-fully-declared
    column or deferred attribute in a declarative mapped class slightly more friendly
    when it’s used in a constraint or other column-oriented scenario within the class
    declaration, though this still can’t work in open-ended expressions; prefer to
    call the [`ColumnProperty.expression`](../orm/internals.html#sqlalchemy.orm.ColumnProperty.expression
    "sqlalchemy.orm.ColumnProperty.expression") attribute if receiving `TypeError`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4372](https://www.sqlalchemy.org/trac/ticket/4372)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: engine
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[engine] [feature]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added public accessor `QueuePool.timeout()` that returns the configured timeout
    for a [`QueuePool`](../core/pooling.html#sqlalchemy.pool.QueuePool "sqlalchemy.pool.QueuePool")
    object. Pull request courtesy Irina Delamare.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#3689](https://www.sqlalchemy.org/trac/ticket/3689)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[engine] [change]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The “threadlocal” engine strategy which has been a legacy feature of SQLAlchemy
    since around version 0.2 is now deprecated, along with the [`Pool.threadlocal`](../core/pooling.html#sqlalchemy.pool.Pool.params.threadlocal
    "sqlalchemy.pool.Pool") parameter of [`Pool`](../core/pooling.html#sqlalchemy.pool.Pool
    "sqlalchemy.pool.Pool") which has no effect in most modern use cases.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[“threadlocal” engine strategy deprecated](migration_13.html#change-4393-threadlocal)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4393](https://www.sqlalchemy.org/trac/ticket/4393)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[sql] [feature]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Amended the [`AnsiFunction`](../core/functions.html#sqlalchemy.sql.functions.AnsiFunction
    "sqlalchemy.sql.functions.AnsiFunction") class, the base of common SQL functions
    like `CURRENT_TIMESTAMP`, to accept positional arguments like a regular ad-hoc
    function. This to suit the case that many of these functions on specific backends
    accept arguments such as “fractional seconds” precision and such. If the function
    is created with arguments, it renders the parenthesis and the arguments. If no
    arguments are present, the compiler generates the non-parenthesized form.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4386](https://www.sqlalchemy.org/trac/ticket/4386)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[sql] [change]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [`create_engine.convert_unicode`](../core/engines.html#sqlalchemy.create_engine.params.convert_unicode
    "sqlalchemy.create_engine") and [`String.convert_unicode`](../core/type_basics.html#sqlalchemy.types.String.params.convert_unicode
    "sqlalchemy.types.String") parameters have been deprecated. These parameters were
    built back when most Python DBAPIs had little to no support for Python Unicode
    objects, and SQLAlchemy needed to take on the very complex task of marshalling
    data and SQL strings between Unicode and bytestrings throughout the system in
    a performant way. Thanks to Python 3, DBAPIs were compelled to adapt to Unicode-aware
    APIs and today all DBAPIs supported by SQLAlchemy support Unicode natively, including
    on Python 2, allowing this long-lived and very complicated feature to finally
    be (mostly) removed. There are still of course a few Python 2 edge cases where
    SQLAlchemy has to deal with Unicode however these are handled automatically; in
    modern use, there should be no need for end-user interaction with these flags.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[convert_unicode parameters deprecated](migration_13.html#change-4393-convertunicode)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4393](https://www.sqlalchemy.org/trac/ticket/4393)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: mssql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[mssql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `literal_processor` for the [`Unicode`](../core/type_basics.html#sqlalchemy.types.Unicode
    "sqlalchemy.types.Unicode") and [`UnicodeText`](../core/type_basics.html#sqlalchemy.types.UnicodeText
    "sqlalchemy.types.UnicodeText") datatypes now render an `N` character in front
    of the literal string expression as required by SQL Server for Unicode string
    values rendered in SQL expressions.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4442](https://www.sqlalchemy.org/trac/ticket/4442)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: misc
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[bug] [ext]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed a regression in 1.3.0b1 caused by [#3423](https://www.sqlalchemy.org/trac/ticket/3423)
    where association proxy objects that access an attribute that’s only present on
    a polymorphic subclass would raise an `AttributeError` even though the actual
    instance being accessed was an instance of that subclass.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4401](https://www.sqlalchemy.org/trac/ticket/4401)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: general
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[general] [change]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A large change throughout the library has ensured that all objects, parameters,
    and behaviors which have been noted as deprecated or legacy now emit `DeprecationWarning`
    warnings when invoked.As the Python 3 interpreter now defaults to displaying deprecation
    warnings, as well as that modern test suites based on tools like tox and pytest
    tend to display deprecation warnings, this change should make it easier to note
    what API features are obsolete. A major rationale for this change is so that long-
    deprecated features that nonetheless still see continue to see real world use
    can finally be removed in the near future; the biggest example of this are the
    `SessionExtension` and `MapperExtension` classes as well as a handful of other
    pre-event extension hooks, which have been deprecated since version 0.7 but still
    remain in the library. Another is that several major longstanding behaviors are
    to be deprecated as well, including the threadlocal engine strategy, the convert_unicode
    flag, and non primary mappers.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Deprecation warnings are emitted for all deprecated elements; new deprecations
    added](migration_13.html#change-4393-general)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4393](https://www.sqlalchemy.org/trac/ticket/4393)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: orm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[orm] [feature]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implemented a new feature whereby the [`AliasedClass`](../orm/queryguide/api.html#sqlalchemy.orm.util.AliasedClass
    "sqlalchemy.orm.util.AliasedClass") construct can now be used as the target of
    a [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship"). This allows the concept of “non primary mappers”
    to no longer be necessary, as the [`AliasedClass`](../orm/queryguide/api.html#sqlalchemy.orm.util.AliasedClass
    "sqlalchemy.orm.util.AliasedClass") is much easier to configure and automatically
    inherits all the relationships of the mapped class, as well as preserves the ability
    for loader options to work normally.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Relationship to AliasedClass replaces the need for non primary mappers](migration_13.html#change-4423)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4423](https://www.sqlalchemy.org/trac/ticket/4423)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [feature]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added new [`MapperEvents.before_mapper_configured()`](../orm/events.html#sqlalchemy.orm.MapperEvents.before_mapper_configured
    "sqlalchemy.orm.MapperEvents.before_mapper_configured") event. This event complements
    the other “configure” stage mapper events with a per mapper event that receives
    each [`Mapper`](../orm/mapping_api.html#sqlalchemy.orm.Mapper "sqlalchemy.orm.Mapper")
    right before its configure step, and additionally may be used to prevent or delay
    the configuration of specific [`Mapper`](../orm/mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper") objects using a new return value `interfaces.EXT_SKIP`.
    See the documentation link for an example.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`MapperEvents.before_mapper_configured()`](../orm/events.html#sqlalchemy.orm.MapperEvents.before_mapper_configured
    "sqlalchemy.orm.MapperEvents.before_mapper_configured")'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4397](https://www.sqlalchemy.org/trac/ticket/4397)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [change]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added a new function [`close_all_sessions()`](../orm/session_api.html#sqlalchemy.orm.close_all_sessions
    "sqlalchemy.orm.close_all_sessions") which takes over the task of the [`Session.close_all()`](../orm/session_api.html#sqlalchemy.orm.Session.close_all
    "sqlalchemy.orm.Session.close_all") method, which is now deprecated as this is
    confusing as a classmethod. Pull request courtesy Augustin Trancart.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4412](https://www.sqlalchemy.org/trac/ticket/4412)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed long-standing issue where duplicate collection members would cause a backref
    to delete the association between the member and its parent object when one of
    the duplicates were removed, as occurs as a side effect of swapping two objects
    in one statement.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Many-to-one backref checks for collection duplicates during remove operation](migration_13.html#change-1103)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#1103](https://www.sqlalchemy.org/trac/ticket/1103)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extended the fix first made as part of [#3287](https://www.sqlalchemy.org/trac/ticket/3287),
    where a loader option made against a subclass using a wildcard would extend itself
    to include application of the wildcard to attributes on the super classes as well,
    to a “bound” loader option as well, e.g. in an expression like `Load(SomeSubClass).load_only('foo')`.
    Columns that are part of the parent class of `SomeSubClass` will also be excluded
    in the same way as if the unbound option `load_only('foo')` were used.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4373](https://www.sqlalchemy.org/trac/ticket/4373)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improved error messages emitted by the ORM in the area of loader option traversal.
    This includes early detection of mis-matched loader strategies along with a clearer
    explanation why these strategies don’t match.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4433](https://www.sqlalchemy.org/trac/ticket/4433)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The “remove” event for collections is now called before the item is removed
    in the case of the `collection.remove()` method, as is consistent with the behavior
    for most other forms of collection item removal (such as `__delitem__`, replacement
    under `__setitem__`). For `pop()` methods, the remove event still fires after
    the operation.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug] [engine]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added accessors for execution options to Core and ORM, via [`Query.get_execution_options()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.get_execution_options
    "sqlalchemy.orm.Query.get_execution_options"), [`Connection.get_execution_options()`](../core/connections.html#sqlalchemy.engine.Connection.get_execution_options
    "sqlalchemy.engine.Connection.get_execution_options"), [`Engine.get_execution_options()`](../core/connections.html#sqlalchemy.engine.Engine.get_execution_options
    "sqlalchemy.engine.Engine.get_execution_options"), and [`Executable.get_execution_options()`](../core/selectable.html#sqlalchemy.sql.expression.Executable.get_execution_options
    "sqlalchemy.sql.expression.Executable.get_execution_options"). PR courtesy Daniel
    Lister.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4464](https://www.sqlalchemy.org/trac/ticket/4464)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue in association proxy due to [#3423](https://www.sqlalchemy.org/trac/ticket/3423)
    which caused the use of custom [`PropComparator`](../orm/internals.html#sqlalchemy.orm.PropComparator
    "sqlalchemy.orm.PropComparator") objects with hybrid attributes, such as the one
    demonstrated in the `dictlike-polymorphic` example to not function within an association
    proxy. The strictness that was added in [#3423](https://www.sqlalchemy.org/trac/ticket/3423)
    has been relaxed, and additional logic to accommodate for an association proxy
    that links to a custom hybrid have been added.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4446](https://www.sqlalchemy.org/trac/ticket/4446)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implemented the `.get_history()` method, which also implies availability of
    [`AttributeState.history`](../orm/internals.html#sqlalchemy.orm.AttributeState.history
    "sqlalchemy.orm.AttributeState.history"), for [`synonym()`](../orm/mapped_attributes.html#sqlalchemy.orm.synonym
    "sqlalchemy.orm.synonym") attributes. Previously, trying to access attribute history
    via a synonym would raise an `AttributeError`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#3777](https://www.sqlalchemy.org/trac/ticket/3777)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: orm declarative
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[bug] [orm declarative]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added a `__clause_element__()` method to [`ColumnProperty`](../orm/internals.html#sqlalchemy.orm.ColumnProperty
    "sqlalchemy.orm.ColumnProperty") which can allow the usage of a not-fully-declared
    column or deferred attribute in a declarative mapped class slightly more friendly
    when it’s used in a constraint or other column-oriented scenario within the class
    declaration, though this still can’t work in open-ended expressions; prefer to
    call the [`ColumnProperty.expression`](../orm/internals.html#sqlalchemy.orm.ColumnProperty.expression
    "sqlalchemy.orm.ColumnProperty.expression") attribute if receiving `TypeError`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4372](https://www.sqlalchemy.org/trac/ticket/4372)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: engine
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[engine] [feature]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added public accessor `QueuePool.timeout()` that returns the configured timeout
    for a [`QueuePool`](../core/pooling.html#sqlalchemy.pool.QueuePool "sqlalchemy.pool.QueuePool")
    object. Pull request courtesy Irina Delamare.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#3689](https://www.sqlalchemy.org/trac/ticket/3689)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[engine] [change]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The “threadlocal” engine strategy which has been a legacy feature of SQLAlchemy
    since around version 0.2 is now deprecated, along with the [`Pool.threadlocal`](../core/pooling.html#sqlalchemy.pool.Pool.params.threadlocal
    "sqlalchemy.pool.Pool") parameter of [`Pool`](../core/pooling.html#sqlalchemy.pool.Pool
    "sqlalchemy.pool.Pool") which has no effect in most modern use cases.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[“threadlocal” engine strategy deprecated](migration_13.html#change-4393-threadlocal)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4393](https://www.sqlalchemy.org/trac/ticket/4393)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[sql] [feature]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Amended the [`AnsiFunction`](../core/functions.html#sqlalchemy.sql.functions.AnsiFunction
    "sqlalchemy.sql.functions.AnsiFunction") class, the base of common SQL functions
    like `CURRENT_TIMESTAMP`, to accept positional arguments like a regular ad-hoc
    function. This to suit the case that many of these functions on specific backends
    accept arguments such as “fractional seconds” precision and such. If the function
    is created with arguments, it renders the parenthesis and the arguments. If no
    arguments are present, the compiler generates the non-parenthesized form.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4386](https://www.sqlalchemy.org/trac/ticket/4386)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[sql] [change]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [`create_engine.convert_unicode`](../core/engines.html#sqlalchemy.create_engine.params.convert_unicode
    "sqlalchemy.create_engine") and [`String.convert_unicode`](../core/type_basics.html#sqlalchemy.types.String.params.convert_unicode
    "sqlalchemy.types.String") parameters have been deprecated. These parameters were
    built back when most Python DBAPIs had little to no support for Python Unicode
    objects, and SQLAlchemy needed to take on the very complex task of marshalling
    data and SQL strings between Unicode and bytestrings throughout the system in
    a performant way. Thanks to Python 3, DBAPIs were compelled to adapt to Unicode-aware
    APIs and today all DBAPIs supported by SQLAlchemy support Unicode natively, including
    on Python 2, allowing this long-lived and very complicated feature to finally
    be (mostly) removed. There are still of course a few Python 2 edge cases where
    SQLAlchemy has to deal with Unicode however these are handled automatically; in
    modern use, there should be no need for end-user interaction with these flags.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[convert_unicode parameters deprecated](migration_13.html#change-4393-convertunicode)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4393](https://www.sqlalchemy.org/trac/ticket/4393)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: mssql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[mssql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `literal_processor` for the [`Unicode`](../core/type_basics.html#sqlalchemy.types.Unicode
    "sqlalchemy.types.Unicode") and [`UnicodeText`](../core/type_basics.html#sqlalchemy.types.UnicodeText
    "sqlalchemy.types.UnicodeText") datatypes now render an `N` character in front
    of the literal string expression as required by SQL Server for Unicode string
    values rendered in SQL expressions.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4442](https://www.sqlalchemy.org/trac/ticket/4442)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: misc
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[bug] [ext]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed a regression in 1.3.0b1 caused by [#3423](https://www.sqlalchemy.org/trac/ticket/3423)
    where association proxy objects that access an attribute that’s only present on
    a polymorphic subclass would raise an `AttributeError` even though the actual
    instance being accessed was an instance of that subclass.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4401](https://www.sqlalchemy.org/trac/ticket/4401)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 1.3.0b1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Released: November 16, 2018'
  prefs: []
  type: TYPE_NORMAL
- en: orm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[orm] [feature]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added new feature [`Query.only_return_tuples()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.only_return_tuples
    "sqlalchemy.orm.Query.only_return_tuples"). Causes the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object to return keyed tuple objects unconditionally even
    if the query is against a single entity. Pull request courtesy Eric Atkin.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This change is also **backported** to: 1.2.5'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [feature]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added new flag [`Session.bulk_save_objects.preserve_order`](../orm/session_api.html#sqlalchemy.orm.Session.bulk_save_objects.params.preserve_order
    "sqlalchemy.orm.Session.bulk_save_objects") to the [`Session.bulk_save_objects()`](../orm/session_api.html#sqlalchemy.orm.Session.bulk_save_objects
    "sqlalchemy.orm.Session.bulk_save_objects") method, which defaults to True. When
    set to False, the given mappings will be grouped into inserts and updates per
    each object type, to allow for greater opportunities to batch common operations
    together. Pull request courtesy Alessandro Cucci.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [feature]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The “selectin” loader strategy now omits the JOIN in the case of a simple one-to-many
    load, where it instead relies loads only from the related table, relying upon
    the foreign key columns of the related table in order to match up to primary keys
    in the parent table. This optimization can be disabled by setting the [`relationship.omit_join`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.omit_join
    "sqlalchemy.orm.relationship") flag to False. Many thanks to Jayson Reis for the
    efforts on this.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[selectin loading no longer uses JOIN for simple one-to-many](migration_13.html#change-4340)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4340](https://www.sqlalchemy.org/trac/ticket/4340)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [feature]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added `.info` dictionary to the [`InstanceState`](../orm/internals.html#sqlalchemy.orm.InstanceState
    "sqlalchemy.orm.InstanceState") class, the object that comes from calling [`inspect()`](../core/inspection.html#sqlalchemy.inspect
    "sqlalchemy.inspect") on a mapped object.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[info dictionary added to InstanceState](migration_13.html#change-4257)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4257](https://www.sqlalchemy.org/trac/ticket/4257)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug where use of [`Lateral`](../core/selectable.html#sqlalchemy.sql.expression.Lateral
    "sqlalchemy.sql.expression.Lateral") construct in conjunction with [`Query.join()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join") as well as `Query.select_entity_from()` would not
    apply clause adaption to the right side of the join. “lateral” introduces the
    use case of the right side of a join being correlatable. Previously, adaptation
    of this clause wasn’t considered. Note that in 1.2 only, a selectable introduced
    by [`Query.subquery()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.subquery
    "sqlalchemy.orm.Query.subquery") is still not adapted due to [#4304](https://www.sqlalchemy.org/trac/ticket/4304);
    the selectable needs to be produced by the [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") function to be the right side of the “lateral”
    join.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This change is also **backported** to: 1.2.12'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4334](https://www.sqlalchemy.org/trac/ticket/4334)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue regarding passive_deletes=”all”, where the foreign key attribute
    of an object is maintained with its value even after the object is removed from
    its parent collection. Previously, the unit of work would set this to NULL even
    though passive_deletes indicated it should not be modified.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[passive_deletes=’all’ will leave FK unchanged for object removed from collection](migration_13.html#change-3844)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#3844](https://www.sqlalchemy.org/trac/ticket/3844)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improved the behavior of a relationship-bound many-to-one object expression
    such that the retrieval of column values on the related object are now resilient
    against the object being detached from its parent [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), even if the attribute has been expired. New features
    within the [`InstanceState`](../orm/internals.html#sqlalchemy.orm.InstanceState
    "sqlalchemy.orm.InstanceState") are used to memoize the last known value of a
    particular column attribute before its expired, so that the expression can still
    evaluate when the object is detached and expired at the same time. Error conditions
    are also improved using modern attribute state features to produce more specific
    messages as needed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Improvement to the behavior of many-to-one query expressions](migration_13.html#change-4359)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4359](https://www.sqlalchemy.org/trac/ticket/4359)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug] [mysql] [postgresql]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ORM now doubles the “FOR UPDATE” clause within the subquery that renders
    in conjunction with joined eager loading in some cases, as it has been observed
    that MySQL does not lock the rows from a subquery. This means the query renders
    with two FOR UPDATE clauses; note that on some backends such as Oracle, FOR UPDATE
    clauses on subqueries are silently ignored since they are unnecessary. Additionally,
    in the case of the “OF” clause used primarily with PostgreSQL, the FOR UPDATE
    is rendered only on the inner subquery when this is used so that the selectable
    can be targeted to the table within the SELECT statement.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[FOR UPDATE clause is rendered within the joined eager load subquery as well
    as outside](migration_13.html#change-4246)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4246](https://www.sqlalchemy.org/trac/ticket/4246)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refactored [`Query.join()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join") to further clarify the individual components of structuring
    the join. This refactor adds the ability for [`Query.join()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join") to determine the most appropriate “left” side of
    the join when there is more than one element in the FROM list or the query is
    against multiple entities. If more than one FROM/entity matches, an error is raised
    that asks for an ON clause to be specified to resolve the ambiguity. In particular
    this targets the regression we saw in [#4363](https://www.sqlalchemy.org/trac/ticket/4363)
    but is also of general use. The codepaths within [`Query.join()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join") are now easier to follow and the error cases are
    decided more specifically at an earlier point in the operation.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Query.join() handles ambiguity in deciding the “left” side more explicitly](migration_13.html#change-4365)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4365](https://www.sqlalchemy.org/trac/ticket/4365)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed long-standing issue in [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") where a scalar subquery such as produced by [`Query.exists()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.exists
    "sqlalchemy.orm.Query.exists"), [`Query.as_scalar()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.as_scalar
    "sqlalchemy.orm.Query.as_scalar") and other derivations from [`Query.statement`](../orm/queryguide/query.html#sqlalchemy.orm.Query.statement
    "sqlalchemy.orm.Query.statement") would not correctly be adapted when used in
    a new [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    that required entity adaptation, such as when the query were turned into a union,
    or a from_self(), etc. The change removes the “no adaptation” annotation from
    the [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select")
    object produced by the [`Query.statement`](../orm/queryguide/query.html#sqlalchemy.orm.Query.statement
    "sqlalchemy.orm.Query.statement") accessor.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4304](https://www.sqlalchemy.org/trac/ticket/4304)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An informative exception is re-raised when a primary key value is not sortable
    in Python during an ORM flush under Python 3, such as an `Enum` that has no `__lt__()`
    method; normally Python 3 raises a `TypeError` in this case. The flush process
    sorts persistent objects by primary key in Python so the values must be sortable.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4232](https://www.sqlalchemy.org/trac/ticket/4232)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removed the collection converter used by the `MappedCollection` class. This
    converter was used only to assert that the incoming dictionary keys matched that
    of their corresponding objects, and only during a bulk set operation. The converter
    can interfere with a custom validator or [`AttributeEvents.bulk_replace()`](../orm/events.html#sqlalchemy.orm.AttributeEvents.bulk_replace
    "sqlalchemy.orm.AttributeEvents.bulk_replace") listener that wants to convert
    incoming values further. The `TypeError` which would be raised by this converter
    when an incoming key didn’t match the value is removed; incoming values during
    a bulk assignment will be keyed to their value-generated key, and not the key
    that’s explicitly present in the dictionary.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Overall, @converter is superseded by the [`AttributeEvents.bulk_replace()`](../orm/events.html#sqlalchemy.orm.AttributeEvents.bulk_replace
    "sqlalchemy.orm.AttributeEvents.bulk_replace") event handler added as part of
    [#3896](https://www.sqlalchemy.org/trac/ticket/3896).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#3604](https://www.sqlalchemy.org/trac/ticket/3604)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added new behavior to the lazy load that takes place when the “old” value of
    a many-to-one is retrieved, such that exceptions which would be raised due to
    either `lazy="raise"` or a detached session error are skipped.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Many-to-one replacement won’t raise for “raiseload” or detached for “old”
    object](migration_13.html#change-4353)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4353](https://www.sqlalchemy.org/trac/ticket/4353)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A long-standing oversight in the ORM, the `__delete__` method for a many- to-one
    relationship was non-functional, e.g. for an operation such as `del a.b`. This
    is now implemented and is equivalent to setting the attribute to `None`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[“del” implemented for ORM attributes](migration_13.html#change-4354)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4354](https://www.sqlalchemy.org/trac/ticket/4354)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: orm declarative
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[orm] [declarative] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug where declarative would not update the state of the [`Mapper`](../orm/mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper") as far as what attributes were present, when additional
    attributes were added or removed after the mapper attribute collections had already
    been called and memoized. Additionally, a `NotImplementedError` is now raised
    if a fully mapped attribute (e.g. column, relationship, etc.) is deleted from
    a class that is currently mapped, since the mapper will not function correctly
    if the attribute has been removed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4133](https://www.sqlalchemy.org/trac/ticket/4133)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: engine
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[engine] [feature]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added new “lifo” mode to [`QueuePool`](../core/pooling.html#sqlalchemy.pool.QueuePool
    "sqlalchemy.pool.QueuePool"), typically enabled by setting the flag [`create_engine.pool_use_lifo`](../core/engines.html#sqlalchemy.create_engine.params.pool_use_lifo
    "sqlalchemy.create_engine") to True. “lifo” mode means the same connection just
    checked in will be the first to be checked out again, allowing excess connections
    to be cleaned up from the server side during periods of the pool being only partially
    utilized. Pull request courtesy Taem Park.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[New last-in-first-out strategy for QueuePool](migration_13.html#change-pr467)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[sql] [feature]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refactored [`SQLCompiler`](../core/internals.html#sqlalchemy.sql.compiler.SQLCompiler
    "sqlalchemy.sql.compiler.SQLCompiler") to expose a [`SQLCompiler.group_by_clause()`](../core/internals.html#sqlalchemy.sql.compiler.SQLCompiler.group_by_clause
    "sqlalchemy.sql.compiler.SQLCompiler.group_by_clause") method similar to the [`SQLCompiler.order_by_clause()`](../core/internals.html#sqlalchemy.sql.compiler.SQLCompiler.order_by_clause
    "sqlalchemy.sql.compiler.SQLCompiler.order_by_clause") and `SQLCompiler.limit_clause()`
    methods, which can be overridden by dialects to customize how GROUP BY renders.
    Pull request courtesy Samuel Chou.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This change is also **backported** to: 1.2.13'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[sql] [feature]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Added [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence "sqlalchemy.schema.Sequence")
    to the “string SQL” system that will render a meaningful string expression (`"<next
    sequence value: my_sequence>"`) when stringifying without a dialect a statement
    that includes a “sequence nextvalue” expression, rather than raising a compilation
    error.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4144](https://www.sqlalchemy.org/trac/ticket/4144)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[sql] [feature]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added new naming convention tokens `column_0N_name`, `column_0_N_name`, etc.,
    which will render the names / keys / labels for all columns referenced by a particular
    constraint in a sequence. In order to accommodate for the length of such a naming
    convention, the SQL compiler’s auto-truncation feature now applies itself to constraint
    names as well, which creates a shortened, deterministically generated name for
    the constraint that will apply to a target backend without going over the character
    limit of that backend.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The change also repairs two other issues. One is that the `column_0_key` token
    wasn’t available even though this token was documented, the other was that the
    `referred_column_0_name` token would inadvertently render the `.key` and not the
    `.name` of the column if these two values were different.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[New multi-column naming convention tokens, long name truncation](migration_13.html#change-3989)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#3989](https://www.sqlalchemy.org/trac/ticket/3989)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[sql] [feature]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added new logic to the “expanding IN” bound parameter feature whereby if the
    given list is empty, a special “empty set” expression that is specific to different
    backends is generated, thus allowing IN expressions to be fully dynamic including
    empty IN expressions.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Expanding IN feature now supports empty lists](migration_13.html#change-4271)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4271](https://www.sqlalchemy.org/trac/ticket/4271)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[sql] [feature]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Python builtin `dir()` is now supported for a SQLAlchemy “properties” object,
    such as that of a Core columns collection (e.g. `.c`), `mapper.attrs`, etc. Allows
    iPython autocompletion to work as well. Pull request courtesy Uwe Korn.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[sql] [feature]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added new feature [`FunctionElement.as_comparison()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.as_comparison
    "sqlalchemy.sql.functions.FunctionElement.as_comparison") which allows a SQL function
    to act as a binary comparison operation that can work within the ORM.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Binary comparison interpretation for SQL functions](migration_13.html#change-3831)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#3831](https://www.sqlalchemy.org/trac/ticket/3831)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[sql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added “like” based operators as “comparison” operators, including [`ColumnOperators.startswith()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.startswith
    "sqlalchemy.sql.expression.ColumnOperators.startswith") [`ColumnOperators.endswith()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.endswith
    "sqlalchemy.sql.expression.ColumnOperators.endswith") [`ColumnOperators.ilike()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.ilike
    "sqlalchemy.sql.expression.ColumnOperators.ilike") [`ColumnOperators.notilike()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.notilike
    "sqlalchemy.sql.expression.ColumnOperators.notilike") among many others, so that
    all of these operators can be the basis for an ORM “primaryjoin” condition.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4302](https://www.sqlalchemy.org/trac/ticket/4302)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[sql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue with [`TypeEngine.bind_expression()`](../core/type_api.html#sqlalchemy.types.TypeEngine.bind_expression
    "sqlalchemy.types.TypeEngine.bind_expression") and [`TypeEngine.column_expression()`](../core/type_api.html#sqlalchemy.types.TypeEngine.column_expression
    "sqlalchemy.types.TypeEngine.column_expression") methods where these methods would
    not work if the target type were part of a [`Variant`](../core/type_api.html#sqlalchemy.types.Variant
    "sqlalchemy.types.Variant"), or other target type of a [`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator"). Additionally, the SQL compiler now calls upon
    the dialect-level implementation when it renders these methods so that dialects
    can now provide for SQL-level processing for built-in types.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[TypeEngine methods bind_expression, column_expression work with Variant, type-specific
    types](migration_13.html#change-3981)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#3981](https://www.sqlalchemy.org/trac/ticket/3981)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: postgresql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[postgresql] [feature]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added new PG type [`REGCLASS`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.REGCLASS
    "sqlalchemy.dialects.postgresql.REGCLASS") which assists in casting table names
    to OID values. Pull request courtesy Sebastian Bank.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This change is also **backported** to: 1.2.7'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4160](https://www.sqlalchemy.org/trac/ticket/4160)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[postgresql] [feature]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added rudimental support for reflection of PostgreSQL partitioned tables, e.g.
    that relkind=’p’ is added to reflection queries that return table information.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Added basic reflection support for PostgreSQL partitioned tables](migration_13.html#change-4237)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4237](https://www.sqlalchemy.org/trac/ticket/4237)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: mysql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[mysql] [feature]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support added for the “WITH PARSER” syntax of CREATE FULLTEXT INDEX in MySQL,
    using the `mysql_with_parser` keyword argument. Reflection is also supported,
    which accommodates MySQL’s special comment format for reporting on this option
    as well. Additionally, the “FULLTEXT” and “SPATIAL” index prefixes are now reflected
    back into the `mysql_prefix` index option.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4219](https://www.sqlalchemy.org/trac/ticket/4219)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[mysql] [feature]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added support for the parameters in an ON DUPLICATE KEY UPDATE statement on
    MySQL to be ordered, since parameter order in a MySQL UPDATE clause is significant,
    in a similar manner as that described at [Parameter Ordered Updates](../tutorial/data_update.html#tutorial-parameter-ordered-updates).
    Pull request courtesy Maxim Bublis.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Control of parameter ordering within ON DUPLICATE KEY UPDATE](migration_13.html#change-mysql-ondupordering)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[mysql] [feature]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The “pre-ping” feature of the connection pool now uses the `ping()` method of
    the DBAPI connection in the case of mysqlclient, PyMySQL and mysql-connector-python.
    Pull request courtesy Maxim Bublis.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Protocol-level ping now used for pre-ping](migration_13.html#change-mysql-ping)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sqlite
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[sqlite] [feature]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added support for SQLite’s json functionality via the new SQLite implementation
    for [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON"),
    [`JSON`](../dialects/sqlite.html#sqlalchemy.dialects.sqlite.JSON "sqlalchemy.dialects.sqlite.JSON").
    The name used for the type is `JSON`, following an example found at SQLite’s own
    documentation. Pull request courtesy Ilja Everilä.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Support for SQLite JSON Added](migration_13.html#change-3850)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#3850](https://www.sqlalchemy.org/trac/ticket/3850)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[sqlite] [feature]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implemented the SQLite `ON CONFLICT` clause as understood at the DDL level,
    e.g. for primary key, unique, and CHECK constraints as well as specified on a
    [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    to satisfy inline primary key and NOT NULL. Pull request courtesy Denis Kataev.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Support for SQLite ON CONFLICT in constraints added](migration_13.html#change-4360)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4360](https://www.sqlalchemy.org/trac/ticket/4360)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: mssql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[mssql] [feature]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added `fast_executemany=True` parameter to the SQL Server pyodbc dialect, which
    enables use of pyodbc’s new performance feature of the same name when using Microsoft
    ODBC drivers.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Support for pyodbc fast_executemany](migration_13.html#change-4158)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4158](https://www.sqlalchemy.org/trac/ticket/4158)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[mssql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deprecated the use of [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence") with SQL Server in order to affect the “start” and
    “increment” of the IDENTITY value, in favor of new parameters `mssql_identity_start`
    and `mssql_identity_increment` which set these parameters directly. [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence") will be used to generate real `CREATE SEQUENCE`
    DDL with SQL Server in a future release.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[New parameters to affect IDENTITY start and increment, use of Sequence deprecated](migration_13.html#change-4362)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4362](https://www.sqlalchemy.org/trac/ticket/4362)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: oracle
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[oracle] [feature]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added a new event currently used only by the cx_Oracle dialect, `DialectEvents.setiputsizes()`.
    The event passes a dictionary of [`BindParameter`](../core/sqlelement.html#sqlalchemy.sql.expression.BindParameter
    "sqlalchemy.sql.expression.BindParameter") objects to DBAPI-specific type objects
    that will be passed, after conversion to parameter names, to the cx_Oracle `cursor.setinputsizes()`
    method. This allows both visibility into the setinputsizes process as well as
    the ability to alter the behavior of what datatypes are passed to this method.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Fine grained control over cx_Oracle data binding performance with setinputsizes](../dialects/oracle.html#cx-oracle-setinputsizes)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This change is also **backported** to: 1.2.9'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4290](https://www.sqlalchemy.org/trac/ticket/4290)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[oracle] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updated the parameters that can be sent to the cx_Oracle DBAPI to both allow
    for all current parameters as well as for future parameters not added yet. In
    addition, removed unused parameters that were deprecated in version 1.2, and additionally
    we are now defaulting “threaded” to False.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[cx_Oracle connect arguments modernized, deprecated parameters removed](migration_13.html#change-4369)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4369](https://www.sqlalchemy.org/trac/ticket/4369)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[oracle] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Oracle dialect will no longer use the NCHAR/NCLOB datatypes represent generic
    unicode strings or clob fields in conjunction with [`Unicode`](../core/type_basics.html#sqlalchemy.types.Unicode
    "sqlalchemy.types.Unicode") and [`UnicodeText`](../core/type_basics.html#sqlalchemy.types.UnicodeText
    "sqlalchemy.types.UnicodeText") unless the flag `use_nchar_for_unicode=True` is
    passed to [`create_engine()`](../core/engines.html#sqlalchemy.create_engine "sqlalchemy.create_engine")
    - this includes CREATE TABLE behavior as well as `setinputsizes()` for bound parameters.
    On the read side, automatic Unicode conversion under Python 2 has been added to
    CHAR/VARCHAR/CLOB result rows, to match the behavior of cx_Oracle under Python
    3\. In order to mitigate the performance hit under Python 2, SQLAlchemy’s very
    performant (when C extensions are built) native Unicode handlers are used under
    Python 2.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[National char datatypes de-emphasized for generic unicode, re-enabled with
    option](migration_13.html#change-4242)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4242](https://www.sqlalchemy.org/trac/ticket/4242)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: misc
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[feature] [ext]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added new attribute [`Query.lazy_loaded_from`](../orm/queryguide/query.html#sqlalchemy.orm.Query.lazy_loaded_from
    "sqlalchemy.orm.Query.lazy_loaded_from") which is populated with an [`InstanceState`](../orm/internals.html#sqlalchemy.orm.InstanceState
    "sqlalchemy.orm.InstanceState") that is using this [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") in order to lazy load a relationship. The rationale for
    this is that it serves as a hint for the horizontal sharding feature to use, such
    that the identity token of the state can be used as the default identity token
    to use for the query within id_chooser().
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This change is also **backported** to: 1.2.9'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4243](https://www.sqlalchemy.org/trac/ticket/4243)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[feature] [ext]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added new feature [`BakedQuery.to_query()`](../orm/extensions/baked.html#sqlalchemy.ext.baked.BakedQuery.to_query
    "sqlalchemy.ext.baked.BakedQuery.to_query"), which allows for a clean way of using
    one [`BakedQuery`](../orm/extensions/baked.html#sqlalchemy.ext.baked.BakedQuery
    "sqlalchemy.ext.baked.BakedQuery") as a subquery inside of another [`BakedQuery`](../orm/extensions/baked.html#sqlalchemy.ext.baked.BakedQuery
    "sqlalchemy.ext.baked.BakedQuery") without needing to refer explicitly to a [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session").
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4318](https://www.sqlalchemy.org/trac/ticket/4318)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[feature] [ext]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [`AssociationProxy`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy
    "sqlalchemy.ext.associationproxy.AssociationProxy") now has standard column comparison
    operations such as [`ColumnOperators.like()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.like
    "sqlalchemy.sql.expression.ColumnOperators.like") and [`ColumnOperators.startswith()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.startswith
    "sqlalchemy.sql.expression.ColumnOperators.startswith") available when the target
    attribute is a plain column - the EXISTS expression that joins to the target table
    is rendered as usual, but the column expression is then use within the WHERE criteria
    of the EXISTS. Note that this alters the behavior of the `.contains()` method
    on the association proxy to make use of [`ColumnOperators.contains()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.contains
    "sqlalchemy.sql.expression.ColumnOperators.contains") when used on a column-based
    attribute.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[AssociationProxy now provides standard column operators for a column-oriented
    target](migration_13.html#change-4351)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4351](https://www.sqlalchemy.org/trac/ticket/4351)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[feature] [ext]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added support for bulk [`Query.update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.update
    "sqlalchemy.orm.Query.update") and [`Query.delete()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.delete
    "sqlalchemy.orm.Query.delete") to the [`ShardedQuery`](../orm/extensions/horizontal_shard.html#sqlalchemy.ext.horizontal_shard.ShardedQuery
    "sqlalchemy.ext.horizontal_shard.ShardedQuery") class within the horizontal sharding
    extension. This also adds an additional expansion hook to the bulk update/delete
    methods `Query._execute_crud()`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Horizontal Sharding extension supports bulk update and delete methods](migration_13.html#change-4196)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4196](https://www.sqlalchemy.org/trac/ticket/4196)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[bug] [ext]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reworked [`AssociationProxy`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy
    "sqlalchemy.ext.associationproxy.AssociationProxy") to store state that’s specific
    to a parent class in a separate object, so that a single [`AssociationProxy`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy
    "sqlalchemy.ext.associationproxy.AssociationProxy") can serve for multiple parent
    classes, as is intrinsic to inheritance, without any ambiguity in the state returned
    by it. A new method [`AssociationProxy.for_class()`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy.for_class
    "sqlalchemy.ext.associationproxy.AssociationProxy.for_class") is added to allow
    inspection of class-specific state.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[AssociationProxy stores class-specific state on a per-class basis](migration_13.html#change-3423)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#3423](https://www.sqlalchemy.org/trac/ticket/3423)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[bug] [ext]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The long-standing behavior of the association proxy collection maintaining only
    a weak reference to the parent object is reverted; the proxy will now maintain
    a strong reference to the parent for as long as the proxy collection itself is
    also in memory, eliminating the “stale association proxy” error. This change is
    being made on an experimental basis to see if any use cases arise where it causes
    side effects.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[New Features and Improvements - Core](migration_13.html#change-4268)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4268](https://www.sqlalchemy.org/trac/ticket/4268)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[bug] [ext]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed multiple issues regarding de-association of scalar objects with the association
    proxy. `del` now works, and additionally a new flag [`AssociationProxy.cascade_scalar_deletes`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy.params.cascade_scalar_deletes
    "sqlalchemy.ext.associationproxy.AssociationProxy") is added, which when set to
    True indicates that setting a scalar attribute to `None` or deleting via `del`
    will also set the source association to `None`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Association proxy has new cascade_scalar_deletes flag](migration_13.html#change-4308)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4308](https://www.sqlalchemy.org/trac/ticket/4308)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: orm
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[orm] [feature]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added new feature [`Query.only_return_tuples()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.only_return_tuples
    "sqlalchemy.orm.Query.only_return_tuples"). Causes the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object to return keyed tuple objects unconditionally even
    if the query is against a single entity. Pull request courtesy Eric Atkin.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This change is also **backported** to: 1.2.5'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [feature]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added new flag [`Session.bulk_save_objects.preserve_order`](../orm/session_api.html#sqlalchemy.orm.Session.bulk_save_objects.params.preserve_order
    "sqlalchemy.orm.Session.bulk_save_objects") to the [`Session.bulk_save_objects()`](../orm/session_api.html#sqlalchemy.orm.Session.bulk_save_objects
    "sqlalchemy.orm.Session.bulk_save_objects") method, which defaults to True. When
    set to False, the given mappings will be grouped into inserts and updates per
    each object type, to allow for greater opportunities to batch common operations
    together. Pull request courtesy Alessandro Cucci.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [feature]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The “selectin” loader strategy now omits the JOIN in the case of a simple one-to-many
    load, where it instead relies loads only from the related table, relying upon
    the foreign key columns of the related table in order to match up to primary keys
    in the parent table. This optimization can be disabled by setting the [`relationship.omit_join`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.omit_join
    "sqlalchemy.orm.relationship") flag to False. Many thanks to Jayson Reis for the
    efforts on this.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[selectin loading no longer uses JOIN for simple one-to-many](migration_13.html#change-4340)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4340](https://www.sqlalchemy.org/trac/ticket/4340)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [feature]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added `.info` dictionary to the [`InstanceState`](../orm/internals.html#sqlalchemy.orm.InstanceState
    "sqlalchemy.orm.InstanceState") class, the object that comes from calling [`inspect()`](../core/inspection.html#sqlalchemy.inspect
    "sqlalchemy.inspect") on a mapped object.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[info dictionary added to InstanceState](migration_13.html#change-4257)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4257](https://www.sqlalchemy.org/trac/ticket/4257)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug where use of [`Lateral`](../core/selectable.html#sqlalchemy.sql.expression.Lateral
    "sqlalchemy.sql.expression.Lateral") construct in conjunction with [`Query.join()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join") as well as `Query.select_entity_from()` would not
    apply clause adaption to the right side of the join. “lateral” introduces the
    use case of the right side of a join being correlatable. Previously, adaptation
    of this clause wasn’t considered. Note that in 1.2 only, a selectable introduced
    by [`Query.subquery()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.subquery
    "sqlalchemy.orm.Query.subquery") is still not adapted due to [#4304](https://www.sqlalchemy.org/trac/ticket/4304);
    the selectable needs to be produced by the [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") function to be the right side of the “lateral”
    join.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This change is also **backported** to: 1.2.12'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4334](https://www.sqlalchemy.org/trac/ticket/4334)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue regarding passive_deletes=”all”, where the foreign key attribute
    of an object is maintained with its value even after the object is removed from
    its parent collection. Previously, the unit of work would set this to NULL even
    though passive_deletes indicated it should not be modified.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[passive_deletes=’all’ will leave FK unchanged for object removed from collection](migration_13.html#change-3844)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#3844](https://www.sqlalchemy.org/trac/ticket/3844)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improved the behavior of a relationship-bound many-to-one object expression
    such that the retrieval of column values on the related object are now resilient
    against the object being detached from its parent [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), even if the attribute has been expired. New features
    within the [`InstanceState`](../orm/internals.html#sqlalchemy.orm.InstanceState
    "sqlalchemy.orm.InstanceState") are used to memoize the last known value of a
    particular column attribute before its expired, so that the expression can still
    evaluate when the object is detached and expired at the same time. Error conditions
    are also improved using modern attribute state features to produce more specific
    messages as needed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Improvement to the behavior of many-to-one query expressions](migration_13.html#change-4359)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4359](https://www.sqlalchemy.org/trac/ticket/4359)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug] [mysql] [postgresql]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ORM now doubles the “FOR UPDATE” clause within the subquery that renders
    in conjunction with joined eager loading in some cases, as it has been observed
    that MySQL does not lock the rows from a subquery. This means the query renders
    with two FOR UPDATE clauses; note that on some backends such as Oracle, FOR UPDATE
    clauses on subqueries are silently ignored since they are unnecessary. Additionally,
    in the case of the “OF” clause used primarily with PostgreSQL, the FOR UPDATE
    is rendered only on the inner subquery when this is used so that the selectable
    can be targeted to the table within the SELECT statement.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[FOR UPDATE clause is rendered within the joined eager load subquery as well
    as outside](migration_13.html#change-4246)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4246](https://www.sqlalchemy.org/trac/ticket/4246)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refactored [`Query.join()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join") to further clarify the individual components of structuring
    the join. This refactor adds the ability for [`Query.join()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join") to determine the most appropriate “left” side of
    the join when there is more than one element in the FROM list or the query is
    against multiple entities. If more than one FROM/entity matches, an error is raised
    that asks for an ON clause to be specified to resolve the ambiguity. In particular
    this targets the regression we saw in [#4363](https://www.sqlalchemy.org/trac/ticket/4363)
    but is also of general use. The codepaths within [`Query.join()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join") are now easier to follow and the error cases are
    decided more specifically at an earlier point in the operation.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Query.join() handles ambiguity in deciding the “left” side more explicitly](migration_13.html#change-4365)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4365](https://www.sqlalchemy.org/trac/ticket/4365)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed long-standing issue in [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") where a scalar subquery such as produced by [`Query.exists()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.exists
    "sqlalchemy.orm.Query.exists"), [`Query.as_scalar()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.as_scalar
    "sqlalchemy.orm.Query.as_scalar") and other derivations from [`Query.statement`](../orm/queryguide/query.html#sqlalchemy.orm.Query.statement
    "sqlalchemy.orm.Query.statement") would not correctly be adapted when used in
    a new [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    that required entity adaptation, such as when the query were turned into a union,
    or a from_self(), etc. The change removes the “no adaptation” annotation from
    the [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select")
    object produced by the [`Query.statement`](../orm/queryguide/query.html#sqlalchemy.orm.Query.statement
    "sqlalchemy.orm.Query.statement") accessor.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4304](https://www.sqlalchemy.org/trac/ticket/4304)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An informative exception is re-raised when a primary key value is not sortable
    in Python during an ORM flush under Python 3, such as an `Enum` that has no `__lt__()`
    method; normally Python 3 raises a `TypeError` in this case. The flush process
    sorts persistent objects by primary key in Python so the values must be sortable.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4232](https://www.sqlalchemy.org/trac/ticket/4232)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removed the collection converter used by the `MappedCollection` class. This
    converter was used only to assert that the incoming dictionary keys matched that
    of their corresponding objects, and only during a bulk set operation. The converter
    can interfere with a custom validator or [`AttributeEvents.bulk_replace()`](../orm/events.html#sqlalchemy.orm.AttributeEvents.bulk_replace
    "sqlalchemy.orm.AttributeEvents.bulk_replace") listener that wants to convert
    incoming values further. The `TypeError` which would be raised by this converter
    when an incoming key didn’t match the value is removed; incoming values during
    a bulk assignment will be keyed to their value-generated key, and not the key
    that’s explicitly present in the dictionary.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Overall, @converter is superseded by the [`AttributeEvents.bulk_replace()`](../orm/events.html#sqlalchemy.orm.AttributeEvents.bulk_replace
    "sqlalchemy.orm.AttributeEvents.bulk_replace") event handler added as part of
    [#3896](https://www.sqlalchemy.org/trac/ticket/3896).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#3604](https://www.sqlalchemy.org/trac/ticket/3604)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added new behavior to the lazy load that takes place when the “old” value of
    a many-to-one is retrieved, such that exceptions which would be raised due to
    either `lazy="raise"` or a detached session error are skipped.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Many-to-one replacement won’t raise for “raiseload” or detached for “old”
    object](migration_13.html#change-4353)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4353](https://www.sqlalchemy.org/trac/ticket/4353)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[orm] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A long-standing oversight in the ORM, the `__delete__` method for a many- to-one
    relationship was non-functional, e.g. for an operation such as `del a.b`. This
    is now implemented and is equivalent to setting the attribute to `None`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[“del” implemented for ORM attributes](migration_13.html#change-4354)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4354](https://www.sqlalchemy.org/trac/ticket/4354)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: orm declarative
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[orm] [declarative] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed bug where declarative would not update the state of the [`Mapper`](../orm/mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper") as far as what attributes were present, when additional
    attributes were added or removed after the mapper attribute collections had already
    been called and memoized. Additionally, a `NotImplementedError` is now raised
    if a fully mapped attribute (e.g. column, relationship, etc.) is deleted from
    a class that is currently mapped, since the mapper will not function correctly
    if the attribute has been removed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4133](https://www.sqlalchemy.org/trac/ticket/4133)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: engine
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[engine] [feature]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added new “lifo” mode to [`QueuePool`](../core/pooling.html#sqlalchemy.pool.QueuePool
    "sqlalchemy.pool.QueuePool"), typically enabled by setting the flag [`create_engine.pool_use_lifo`](../core/engines.html#sqlalchemy.create_engine.params.pool_use_lifo
    "sqlalchemy.create_engine") to True. “lifo” mode means the same connection just
    checked in will be the first to be checked out again, allowing excess connections
    to be cleaned up from the server side during periods of the pool being only partially
    utilized. Pull request courtesy Taem Park.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[New last-in-first-out strategy for QueuePool](migration_13.html#change-pr467)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[sql] [feature]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refactored [`SQLCompiler`](../core/internals.html#sqlalchemy.sql.compiler.SQLCompiler
    "sqlalchemy.sql.compiler.SQLCompiler") to expose a [`SQLCompiler.group_by_clause()`](../core/internals.html#sqlalchemy.sql.compiler.SQLCompiler.group_by_clause
    "sqlalchemy.sql.compiler.SQLCompiler.group_by_clause") method similar to the [`SQLCompiler.order_by_clause()`](../core/internals.html#sqlalchemy.sql.compiler.SQLCompiler.order_by_clause
    "sqlalchemy.sql.compiler.SQLCompiler.order_by_clause") and `SQLCompiler.limit_clause()`
    methods, which can be overridden by dialects to customize how GROUP BY renders.
    Pull request courtesy Samuel Chou.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This change is also **backported** to: 1.2.13'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[sql] [feature]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Added [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence "sqlalchemy.schema.Sequence")
    to the “string SQL” system that will render a meaningful string expression (`"<next
    sequence value: my_sequence>"`) when stringifying without a dialect a statement
    that includes a “sequence nextvalue” expression, rather than raising a compilation
    error.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4144](https://www.sqlalchemy.org/trac/ticket/4144)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[sql] [feature]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added new naming convention tokens `column_0N_name`, `column_0_N_name`, etc.,
    which will render the names / keys / labels for all columns referenced by a particular
    constraint in a sequence. In order to accommodate for the length of such a naming
    convention, the SQL compiler’s auto-truncation feature now applies itself to constraint
    names as well, which creates a shortened, deterministically generated name for
    the constraint that will apply to a target backend without going over the character
    limit of that backend.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The change also repairs two other issues. One is that the `column_0_key` token
    wasn’t available even though this token was documented, the other was that the
    `referred_column_0_name` token would inadvertently render the `.key` and not the
    `.name` of the column if these two values were different.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[New multi-column naming convention tokens, long name truncation](migration_13.html#change-3989)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#3989](https://www.sqlalchemy.org/trac/ticket/3989)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[sql] [feature]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added new logic to the “expanding IN” bound parameter feature whereby if the
    given list is empty, a special “empty set” expression that is specific to different
    backends is generated, thus allowing IN expressions to be fully dynamic including
    empty IN expressions.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Expanding IN feature now supports empty lists](migration_13.html#change-4271)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4271](https://www.sqlalchemy.org/trac/ticket/4271)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[sql] [feature]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Python builtin `dir()` is now supported for a SQLAlchemy “properties” object,
    such as that of a Core columns collection (e.g. `.c`), `mapper.attrs`, etc. Allows
    iPython autocompletion to work as well. Pull request courtesy Uwe Korn.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[sql] [feature]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added new feature [`FunctionElement.as_comparison()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.as_comparison
    "sqlalchemy.sql.functions.FunctionElement.as_comparison") which allows a SQL function
    to act as a binary comparison operation that can work within the ORM.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Binary comparison interpretation for SQL functions](migration_13.html#change-3831)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#3831](https://www.sqlalchemy.org/trac/ticket/3831)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[sql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added “like” based operators as “comparison” operators, including [`ColumnOperators.startswith()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.startswith
    "sqlalchemy.sql.expression.ColumnOperators.startswith") [`ColumnOperators.endswith()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.endswith
    "sqlalchemy.sql.expression.ColumnOperators.endswith") [`ColumnOperators.ilike()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.ilike
    "sqlalchemy.sql.expression.ColumnOperators.ilike") [`ColumnOperators.notilike()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.notilike
    "sqlalchemy.sql.expression.ColumnOperators.notilike") among many others, so that
    all of these operators can be the basis for an ORM “primaryjoin” condition.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4302](https://www.sqlalchemy.org/trac/ticket/4302)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[sql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed issue with [`TypeEngine.bind_expression()`](../core/type_api.html#sqlalchemy.types.TypeEngine.bind_expression
    "sqlalchemy.types.TypeEngine.bind_expression") and [`TypeEngine.column_expression()`](../core/type_api.html#sqlalchemy.types.TypeEngine.column_expression
    "sqlalchemy.types.TypeEngine.column_expression") methods where these methods would
    not work if the target type were part of a [`Variant`](../core/type_api.html#sqlalchemy.types.Variant
    "sqlalchemy.types.Variant"), or other target type of a [`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator"). Additionally, the SQL compiler now calls upon
    the dialect-level implementation when it renders these methods so that dialects
    can now provide for SQL-level processing for built-in types.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[TypeEngine methods bind_expression, column_expression work with Variant, type-specific
    types](migration_13.html#change-3981)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#3981](https://www.sqlalchemy.org/trac/ticket/3981)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: postgresql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[postgresql] [feature]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added new PG type [`REGCLASS`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.REGCLASS
    "sqlalchemy.dialects.postgresql.REGCLASS") which assists in casting table names
    to OID values. Pull request courtesy Sebastian Bank.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This change is also **backported** to: 1.2.7'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4160](https://www.sqlalchemy.org/trac/ticket/4160)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[postgresql] [feature]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added rudimental support for reflection of PostgreSQL partitioned tables, e.g.
    that relkind=’p’ is added to reflection queries that return table information.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Added basic reflection support for PostgreSQL partitioned tables](migration_13.html#change-4237)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4237](https://www.sqlalchemy.org/trac/ticket/4237)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: mysql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[mysql] [feature]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support added for the “WITH PARSER” syntax of CREATE FULLTEXT INDEX in MySQL,
    using the `mysql_with_parser` keyword argument. Reflection is also supported,
    which accommodates MySQL’s special comment format for reporting on this option
    as well. Additionally, the “FULLTEXT” and “SPATIAL” index prefixes are now reflected
    back into the `mysql_prefix` index option.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4219](https://www.sqlalchemy.org/trac/ticket/4219)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[mysql] [feature]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added support for the parameters in an ON DUPLICATE KEY UPDATE statement on
    MySQL to be ordered, since parameter order in a MySQL UPDATE clause is significant,
    in a similar manner as that described at [Parameter Ordered Updates](../tutorial/data_update.html#tutorial-parameter-ordered-updates).
    Pull request courtesy Maxim Bublis.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Control of parameter ordering within ON DUPLICATE KEY UPDATE](migration_13.html#change-mysql-ondupordering)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[mysql] [feature]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The “pre-ping” feature of the connection pool now uses the `ping()` method of
    the DBAPI connection in the case of mysqlclient, PyMySQL and mysql-connector-python.
    Pull request courtesy Maxim Bublis.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Protocol-level ping now used for pre-ping](migration_13.html#change-mysql-ping)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: sqlite
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[sqlite] [feature]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added support for SQLite’s json functionality via the new SQLite implementation
    for [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON"),
    [`JSON`](../dialects/sqlite.html#sqlalchemy.dialects.sqlite.JSON "sqlalchemy.dialects.sqlite.JSON").
    The name used for the type is `JSON`, following an example found at SQLite’s own
    documentation. Pull request courtesy Ilja Everilä.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Support for SQLite JSON Added](migration_13.html#change-3850)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#3850](https://www.sqlalchemy.org/trac/ticket/3850)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[sqlite] [feature]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implemented the SQLite `ON CONFLICT` clause as understood at the DDL level,
    e.g. for primary key, unique, and CHECK constraints as well as specified on a
    [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    to satisfy inline primary key and NOT NULL. Pull request courtesy Denis Kataev.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Support for SQLite ON CONFLICT in constraints added](migration_13.html#change-4360)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4360](https://www.sqlalchemy.org/trac/ticket/4360)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: mssql
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[mssql] [feature]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added `fast_executemany=True` parameter to the SQL Server pyodbc dialect, which
    enables use of pyodbc’s new performance feature of the same name when using Microsoft
    ODBC drivers.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Support for pyodbc fast_executemany](migration_13.html#change-4158)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4158](https://www.sqlalchemy.org/trac/ticket/4158)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[mssql] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deprecated the use of [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence") with SQL Server in order to affect the “start” and
    “increment” of the IDENTITY value, in favor of new parameters `mssql_identity_start`
    and `mssql_identity_increment` which set these parameters directly. [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence") will be used to generate real `CREATE SEQUENCE`
    DDL with SQL Server in a future release.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[New parameters to affect IDENTITY start and increment, use of Sequence deprecated](migration_13.html#change-4362)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4362](https://www.sqlalchemy.org/trac/ticket/4362)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: oracle
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[oracle] [feature]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added a new event currently used only by the cx_Oracle dialect, `DialectEvents.setiputsizes()`.
    The event passes a dictionary of [`BindParameter`](../core/sqlelement.html#sqlalchemy.sql.expression.BindParameter
    "sqlalchemy.sql.expression.BindParameter") objects to DBAPI-specific type objects
    that will be passed, after conversion to parameter names, to the cx_Oracle `cursor.setinputsizes()`
    method. This allows both visibility into the setinputsizes process as well as
    the ability to alter the behavior of what datatypes are passed to this method.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Fine grained control over cx_Oracle data binding performance with setinputsizes](../dialects/oracle.html#cx-oracle-setinputsizes)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This change is also **backported** to: 1.2.9'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4290](https://www.sqlalchemy.org/trac/ticket/4290)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[oracle] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updated the parameters that can be sent to the cx_Oracle DBAPI to both allow
    for all current parameters as well as for future parameters not added yet. In
    addition, removed unused parameters that were deprecated in version 1.2, and additionally
    we are now defaulting “threaded” to False.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[cx_Oracle connect arguments modernized, deprecated parameters removed](migration_13.html#change-4369)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4369](https://www.sqlalchemy.org/trac/ticket/4369)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[oracle] [bug]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Oracle dialect will no longer use the NCHAR/NCLOB datatypes represent generic
    unicode strings or clob fields in conjunction with [`Unicode`](../core/type_basics.html#sqlalchemy.types.Unicode
    "sqlalchemy.types.Unicode") and [`UnicodeText`](../core/type_basics.html#sqlalchemy.types.UnicodeText
    "sqlalchemy.types.UnicodeText") unless the flag `use_nchar_for_unicode=True` is
    passed to [`create_engine()`](../core/engines.html#sqlalchemy.create_engine "sqlalchemy.create_engine")
    - this includes CREATE TABLE behavior as well as `setinputsizes()` for bound parameters.
    On the read side, automatic Unicode conversion under Python 2 has been added to
    CHAR/VARCHAR/CLOB result rows, to match the behavior of cx_Oracle under Python
    3\. In order to mitigate the performance hit under Python 2, SQLAlchemy’s very
    performant (when C extensions are built) native Unicode handlers are used under
    Python 2.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[National char datatypes de-emphasized for generic unicode, re-enabled with
    option](migration_13.html#change-4242)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4242](https://www.sqlalchemy.org/trac/ticket/4242)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: misc
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**[feature] [ext]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added new attribute [`Query.lazy_loaded_from`](../orm/queryguide/query.html#sqlalchemy.orm.Query.lazy_loaded_from
    "sqlalchemy.orm.Query.lazy_loaded_from") which is populated with an [`InstanceState`](../orm/internals.html#sqlalchemy.orm.InstanceState
    "sqlalchemy.orm.InstanceState") that is using this [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") in order to lazy load a relationship. The rationale for
    this is that it serves as a hint for the horizontal sharding feature to use, such
    that the identity token of the state can be used as the default identity token
    to use for the query within id_chooser().
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This change is also **backported** to: 1.2.9'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4243](https://www.sqlalchemy.org/trac/ticket/4243)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[feature] [ext]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added new feature [`BakedQuery.to_query()`](../orm/extensions/baked.html#sqlalchemy.ext.baked.BakedQuery.to_query
    "sqlalchemy.ext.baked.BakedQuery.to_query"), which allows for a clean way of using
    one [`BakedQuery`](../orm/extensions/baked.html#sqlalchemy.ext.baked.BakedQuery
    "sqlalchemy.ext.baked.BakedQuery") as a subquery inside of another [`BakedQuery`](../orm/extensions/baked.html#sqlalchemy.ext.baked.BakedQuery
    "sqlalchemy.ext.baked.BakedQuery") without needing to refer explicitly to a [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session").
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4318](https://www.sqlalchemy.org/trac/ticket/4318)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[feature] [ext]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [`AssociationProxy`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy
    "sqlalchemy.ext.associationproxy.AssociationProxy") now has standard column comparison
    operations such as [`ColumnOperators.like()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.like
    "sqlalchemy.sql.expression.ColumnOperators.like") and [`ColumnOperators.startswith()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.startswith
    "sqlalchemy.sql.expression.ColumnOperators.startswith") available when the target
    attribute is a plain column - the EXISTS expression that joins to the target table
    is rendered as usual, but the column expression is then use within the WHERE criteria
    of the EXISTS. Note that this alters the behavior of the `.contains()` method
    on the association proxy to make use of [`ColumnOperators.contains()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.contains
    "sqlalchemy.sql.expression.ColumnOperators.contains") when used on a column-based
    attribute.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[AssociationProxy now provides standard column operators for a column-oriented
    target](migration_13.html#change-4351)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4351](https://www.sqlalchemy.org/trac/ticket/4351)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[feature] [ext]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Added support for bulk [`Query.update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.update
    "sqlalchemy.orm.Query.update") and [`Query.delete()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.delete
    "sqlalchemy.orm.Query.delete") to the [`ShardedQuery`](../orm/extensions/horizontal_shard.html#sqlalchemy.ext.horizontal_shard.ShardedQuery
    "sqlalchemy.ext.horizontal_shard.ShardedQuery") class within the horizontal sharding
    extension. This also adds an additional expansion hook to the bulk update/delete
    methods `Query._execute_crud()`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Horizontal Sharding extension supports bulk update and delete methods](migration_13.html#change-4196)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4196](https://www.sqlalchemy.org/trac/ticket/4196)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[bug] [ext]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reworked [`AssociationProxy`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy
    "sqlalchemy.ext.associationproxy.AssociationProxy") to store state that’s specific
    to a parent class in a separate object, so that a single [`AssociationProxy`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy
    "sqlalchemy.ext.associationproxy.AssociationProxy") can serve for multiple parent
    classes, as is intrinsic to inheritance, without any ambiguity in the state returned
    by it. A new method [`AssociationProxy.for_class()`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy.for_class
    "sqlalchemy.ext.associationproxy.AssociationProxy.for_class") is added to allow
    inspection of class-specific state.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[AssociationProxy stores class-specific state on a per-class basis](migration_13.html#change-3423)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#3423](https://www.sqlalchemy.org/trac/ticket/3423)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[bug] [ext]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The long-standing behavior of the association proxy collection maintaining only
    a weak reference to the parent object is reverted; the proxy will now maintain
    a strong reference to the parent for as long as the proxy collection itself is
    also in memory, eliminating the “stale association proxy” error. This change is
    being made on an experimental basis to see if any use cases arise where it causes
    side effects.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[New Features and Improvements - Core](migration_13.html#change-4268)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4268](https://www.sqlalchemy.org/trac/ticket/4268)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**[bug] [ext]**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed multiple issues regarding de-association of scalar objects with the association
    proxy. `del` now works, and additionally a new flag [`AssociationProxy.cascade_scalar_deletes`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy.params.cascade_scalar_deletes
    "sqlalchemy.ext.associationproxy.AssociationProxy") is added, which when set to
    True indicates that setting a scalar attribute to `None` or deleting via `del`
    will also set the source association to `None`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Association proxy has new cascade_scalar_deletes flag](migration_13.html#change-4308)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'References: [#4308](https://www.sqlalchemy.org/trac/ticket/4308)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
