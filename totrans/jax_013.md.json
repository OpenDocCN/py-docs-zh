["```py\nimport jax\nimport jax.numpy as jnp\n\nexample_trees = [\n    [1, 'a', object()],\n    (1, (2, 3), ()),\n    [1, {'k1': 2, 'k2': (3, 4)}, 5],\n    {'a': 2, 'b': (2, 3)},\n    jnp.array([1, 2, 3]),\n]\n\n# Print how many leaves the pytrees have.\nfor pytree in example_trees:\n  # This `jax.tree.leaves()` method extracts the flattened leaves from the pytrees.\n  leaves = jax.tree.leaves(pytree)\n  print(f\"{repr(pytree):<45} has {len(leaves)} leaves: {leaves}\") \n```", "```py\n[1, 'a', <object object at 0x7f3d0048f950>]   has 3 leaves: [1, 'a', <object object at 0x7f3d0048f950>]\n(1, (2, 3), ())                               has 3 leaves: [1, 2, 3]\n[1, {'k1': 2, 'k2': (3, 4)}, 5]               has 5 leaves: [1, 2, 3, 4, 5]\n{'a': 2, 'b': (2, 3)}                         has 3 leaves: [2, 2, 3]\nArray([1, 2, 3], dtype=int32)                 has 1 leaves: [Array([1, 2, 3], dtype=int32)] \n```", "```py\nlist_of_lists = [\n    [1, 2, 3],\n    [1, 2],\n    [1, 2, 3, 4]\n]\n\njax.tree.map(lambda x: x*2, list_of_lists) \n```", "```py\n[[2, 4, 6], [2, 4], [2, 4, 6, 8]] \n```", "```py\nanother_list_of_lists = list_of_lists\njax.tree.map(lambda x, y: x+y, list_of_lists, another_list_of_lists) \n```", "```py\n[[2, 4, 6], [2, 4], [2, 4, 6, 8]] \n```", "```py\nimport numpy as np\n\ndef init_mlp_params(layer_widths):\n  params = []\n  for n_in, n_out in zip(layer_widths[:-1], layer_widths[1:]):\n    params.append(\n        dict(weights=np.random.normal(size=(n_in, n_out)) * np.sqrt(2/n_in),\n             biases=np.ones(shape=(n_out,))\n            )\n    )\n  return params\n\nparams = init_mlp_params([1, 128, 128, 1]) \n```", "```py\njax.tree.map(lambda x: x.shape, params) \n```", "```py\n[{'biases': (128,), 'weights': (1, 128)},\n {'biases': (128,), 'weights': (128, 128)},\n {'biases': (1,), 'weights': (128, 1)}] \n```", "```py\n# Define the forward pass.\ndef forward(params, x):\n  *hidden, last = params\n  for layer in hidden:\n    x = jax.nn.relu(x @ layer['weights'] + layer['biases'])\n  return x @ last['weights'] + last['biases']\n\n# Define the loss function.\ndef loss_fn(params, x, y):\n  return jnp.mean((forward(params, x) - y) ** 2)\n\n# Set the learning rate.\nLEARNING_RATE = 0.0001\n\n# Using the stochastic gradient descent, define the parameter update function.\n# Apply `@jax.jit` for JIT compilation (speed).\n@jax.jit\ndef update(params, x, y):\n  # Calculate the gradients with `jax.grad`.\n  grads = jax.grad(loss_fn)(params, x, y)\n  # Note that `grads` is a pytree with the same structure as `params`.\n  # `jax.grad` is one of many JAX functions that has\n  # built-in support for pytrees.\n  # This is useful - you can apply the SGD update using JAX pytree utilities.\n  return jax.tree.map(\n      lambda p, g: p - LEARNING_RATE * g, params, grads\n  ) \n```", "```py\nclass Special(object):\n  def __init__(self, x, y):\n    self.x = x\n    self.y = y\n\njax.tree.leaves([\n    Special(0, 1),\n    Special(2, 4),\n]) \n```", "```py\n[<__main__.Special at 0x7f3d005a23e0>, <__main__.Special at 0x7f3d005a1960>] \n```", "```py\njax.tree.map(lambda x: x + 1,\n  [\n    Special(0, 1),\n    Special(2, 4)\n  ]) \n```", "```py\nTypeError: unsupported operand type(s) for +: 'Special' and 'int' \n```", "```py\nfrom jax.tree_util import register_pytree_node\n\nclass RegisteredSpecial(Special):\n  def __repr__(self):\n    return \"RegisteredSpecial(x={}, y={})\".format(self.x, self.y)\n\ndef special_flatten(v):\n  \"\"\"Specifies a flattening recipe.\n\n Params:\n v: The value of the registered type to flatten.\n Returns:\n A pair of an iterable with the children to be flattened recursively,\n and some opaque auxiliary data to pass back to the unflattening recipe.\n The auxiliary data is stored in the treedef for use during unflattening.\n The auxiliary data could be used, for example, for dictionary keys.\n \"\"\"\n  children = (v.x, v.y)\n  aux_data = None\n  return (children, aux_data)\n\ndef special_unflatten(aux_data, children):\n  \"\"\"Specifies an unflattening recipe.\n\n Params:\n aux_data: The opaque data that was specified during flattening of the\n current tree definition.\n children: The unflattened children\n\n Returns:\n A reconstructed object of the registered type, using the specified\n children and auxiliary data.\n \"\"\"\n  return RegisteredSpecial(*children)\n\n# Global registration\nregister_pytree_node(\n    RegisteredSpecial,\n    special_flatten,    # Instruct JAX what are the children nodes.\n    special_unflatten   # Instruct JAX how to pack back into a `RegisteredSpecial`.\n) \n```", "```py\njax.tree.map(lambda x: x + 1,\n  [\n   RegisteredSpecial(0, 1),\n   RegisteredSpecial(2, 4),\n  ]) \n```", "```py\n[RegisteredSpecial(x=1, y=2), RegisteredSpecial(x=3, y=5)] \n```", "```py\nfrom typing import NamedTuple, Any\n\nclass MyOtherContainer(NamedTuple):\n  name: str\n  a: Any\n  b: Any\n  c: Any\n\n# NamedTuple subclasses are handled as pytree nodes, so\n# this will work out-of-the-box.\njax.tree.leaves([\n    MyOtherContainer('Alice', 1, 2, 3),\n    MyOtherContainer('Bob', 4, 5, 6)\n]) \n```", "```py\n['Alice', 1, 2, 3, 'Bob', 4, 5, 6] \n```", "```py\nvmap(f, in_axes=(a1, {\"k1\": a2, \"k2\": a3})) \n```", "```py\nvmap(f, in_axes=(None, {\"k1\": None, \"k2\": 0})) \n```", "```py\nvmap(f, in_axes=(None, 0))  # equivalent to (None, {\"k1\": 0, \"k2\": 0}) \n```", "```py\nvmap(f, in_axes=0)  # equivalent to (0, {\"k1\": 0, \"k2\": 0}) \n```", "```py\nimport collections\n\nATuple = collections.namedtuple(\"ATuple\", ('name'))\n\ntree = [1, {'k1': 2, 'k2': (3, 4)}, ATuple('foo')]\nflattened, _ = jax.tree_util.tree_flatten_with_path(tree)\n\nfor key_path, value in flattened:\n  print(f'Value of tree{jax.tree_util.keystr(key_path)}: {value}') \n```", "```py\nValue of tree[0]: 1\nValue of tree[1]['k1']: 2\nValue of tree[1]['k2'][0]: 3\nValue of tree[1]['k2'][1]: 4\nValue of tree[2].name: foo \n```", "```py\nfor key_path, _ in flattened:\n  print(f'Key path of tree{jax.tree_util.keystr(key_path)}: {repr(key_path)}') \n```", "```py\nKey path of tree[0]: (SequenceKey(idx=0),)\nKey path of tree[1]['k1']: (SequenceKey(idx=1), DictKey(key='k1'))\nKey path of tree[1]['k2'][0]: (SequenceKey(idx=1), DictKey(key='k2'), SequenceKey(idx=0))\nKey path of tree[1]['k2'][1]: (SequenceKey(idx=1), DictKey(key='k2'), SequenceKey(idx=1))\nKey path of tree[2].name: (SequenceKey(idx=2), GetAttrKey(name='name')) \n```", "```py\na_tree = [jnp.zeros((2, 3)), jnp.zeros((3, 4))]\n\n# Try to make another pytree with ones instead of zeros.\nshapes = jax.tree.map(lambda x: x.shape, a_tree)\njax.tree.map(jnp.ones, shapes) \n```", "```py\n[(Array([1., 1.], dtype=float32), Array([1., 1., 1.], dtype=float32)),\n (Array([1., 1., 1.], dtype=float32), Array([1., 1., 1., 1.], dtype=float32))] \n```", "```py\njax.tree.leaves([None, None, None]) \n```", "```py\n[] \n```", "```py\njax.tree.leaves([None, None, None], is_leaf=lambda x: x is None) \n```", "```py\n[None, None, None] \n```", "```py\nclass MyTree:\n  def __init__(self, a):\n    self.a = jnp.asarray(a)\n\nregister_pytree_node(MyTree, lambda tree: ((tree.a,), None),\n    lambda _, args: MyTree(*args))\n\ntree = MyTree(jnp.arange(5.0))\n\njax.vmap(lambda x: x)(tree)      # Error because object() is passed to `MyTree`. \n```", "```py\nTypeError: Cannot interpret '<object object at 0x7f3cce5742a0>' as a data type\n\nThe above exception was the direct cause of the following exception:\n\nTypeError: Cannot determine dtype of <object object at 0x7f3cce5742a0>\n\nDuring handling of the above exception, another exception occurred:\n\nTypeError: Value '<object object at 0x7f3cce5742a0>' with dtype object is not a valid JAX array type. Only arrays of numeric types are supported by JAX. \n```", "```py\njax.jacobian(lambda x: x)(tree)  # Error because MyTree(...) is passed to `MyTree`. \n```", "```py\n/home/docs/checkouts/readthedocs.org/user_builds/jax/envs/latest/lib/python3.10/site-packages/jax/_src/numpy/lax_numpy.py:3289: FutureWarning: None encountered in jnp.array(); this is currently treated as NaN. In the future this will result in an error.\n  return array(a, dtype=dtype, copy=bool(copy), order=order) \n```", "```py\nTypeError: Cannot interpret '<object object at 0x7f3cce574780>' as a data type\n\nThe above exception was the direct cause of the following exception:\n\nTypeError: Cannot determine dtype of <object object at 0x7f3cce574780>\n\nDuring handling of the above exception, another exception occurred:\n\nTypeError: Value '<object object at 0x7f3cce574780>' with dtype object is not a valid JAX array type. Only arrays of numeric types are supported by JAX. \n```", "```py\nclass MyTree:\n  def __init__(self, a):\n    if not (type(a) is object or a is None or isinstance(a, MyTree)):\n      a = jnp.asarray(a)\n    self.a = a \n```", "```py\ndef tree_unflatten(aux_data, children):\n  del aux_data  # Unused in this class.\n  obj = object.__new__(MyTree)\n  obj.a = a\n  return obj \n```", "```py\ndef tree_transpose(list_of_trees):\n  \"\"\"\n Converts a list of trees of identical structure into a single tree of lists.\n \"\"\"\n  return jax.tree.map(lambda *xs: list(xs), *list_of_trees)\n\n# Convert a dataset from row-major to column-major.\nepisode_steps = [dict(t=1, obs=3), dict(t=2, obs=4)]\ntree_transpose(episode_steps) \n```", "```py\n{'obs': [3, 4], 't': [1, 2]} \n```", "```py\njax.tree.transpose(\n  outer_treedef = jax.tree.structure([0 for e in episode_steps]),\n  inner_treedef = jax.tree.structure(episode_steps[0]),\n  pytree_to_transpose = episode_steps\n) \n```", "```py\n{'obs': [3, 4], 't': [1, 2]} \n```"]