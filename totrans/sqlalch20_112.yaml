- en: Microsoft SQL Server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.sqlalchemy.org/en/20/dialects/mssql.html](https://docs.sqlalchemy.org/en/20/dialects/mssql.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Support for the Microsoft SQL Server database.
  prefs: []
  type: TYPE_NORMAL
- en: The following table summarizes current support levels for database release versions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Supported Microsoft SQL Server versions**'
  prefs: []
  type: TYPE_NORMAL
- en: '| Support type | Versions |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| [Fully tested in CI](index.html#term-Fully-tested-in-CI) | 2017 |'
  prefs: []
  type: TYPE_TB
- en: '| [Normal support](index.html#term-Normal-support) | 2012+ |'
  prefs: []
  type: TYPE_TB
- en: '| [Best effort](index.html#term-Best-effort) | 2005+ |'
  prefs: []
  type: TYPE_TB
- en: DBAPI Support
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following dialect/DBAPI options are available. Please refer to individual
    DBAPI sections for connect information.
  prefs: []
  type: TYPE_NORMAL
- en: '[PyODBC](#module-sqlalchemy.dialects.mssql.pyodbc)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[pymssql](#module-sqlalchemy.dialects.mssql.pymssql)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[aioodbc](#module-sqlalchemy.dialects.mssql.aioodbc)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '## External Dialects'
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the above DBAPI layers with native SQLAlchemy support, there
    are third-party dialects for other DBAPI layers that are compatible with SQL Server.
    See the “External Dialects” list on the [Dialects](index.html) page.  ## Auto
    Increment Behavior / IDENTITY Columns'
  prefs: []
  type: TYPE_NORMAL
- en: 'SQL Server provides so-called “auto incrementing” behavior using the `IDENTITY`
    construct, which can be placed on any single integer column in a table. SQLAlchemy
    considers `IDENTITY` within its default “autoincrement” behavior for an integer
    primary key column, described at [`Column.autoincrement`](../core/metadata.html#sqlalchemy.schema.Column.params.autoincrement
    "sqlalchemy.schema.Column"). This means that by default, the first integer primary
    key column in a [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    will be considered to be the identity column - unless it is associated with a
    [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence "sqlalchemy.schema.Sequence")
    - and will generate DDL as such:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The above example will generate DDL as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'For the case where this default generation of `IDENTITY` is not desired, specify
    `False` for the [`Column.autoincrement`](../core/metadata.html#sqlalchemy.schema.Column.params.autoincrement
    "sqlalchemy.schema.Column") flag, on the first integer primary key column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'To add the `IDENTITY` keyword to a non-primary key column, specify `True` for
    the [`Column.autoincrement`](../core/metadata.html#sqlalchemy.schema.Column.params.autoincrement
    "sqlalchemy.schema.Column") flag on the desired [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") object, and ensure that [`Column.autoincrement`](../core/metadata.html#sqlalchemy.schema.Column.params.autoincrement
    "sqlalchemy.schema.Column") is set to `False` on any integer primary key column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Changed in version 1.4: Added [`Identity`](../core/defaults.html#sqlalchemy.schema.Identity
    "sqlalchemy.schema.Identity") construct in a [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") to specify the start and increment parameters of an
    IDENTITY. These replace the use of the [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence") object in order to specify these values.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Deprecated since version 1.4: The `mssql_identity_start` and `mssql_identity_increment`
    parameters to [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    are deprecated and should we replaced by an [`Identity`](../core/defaults.html#sqlalchemy.schema.Identity
    "sqlalchemy.schema.Identity") object. Specifying both ways of configuring an IDENTITY
    will result in a compile error. These options are also no longer returned as part
    of the `dialect_options` key in [`Inspector.get_columns()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_columns
    "sqlalchemy.engine.reflection.Inspector.get_columns"). Use the information in
    the `identity` key instead.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Deprecated since version 1.3: The use of [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence") to specify IDENTITY characteristics is deprecated
    and will be removed in a future release. Please use the [`Identity`](../core/defaults.html#sqlalchemy.schema.Identity
    "sqlalchemy.schema.Identity") object parameters [`Identity.start`](../core/defaults.html#sqlalchemy.schema.Identity.params.start
    "sqlalchemy.schema.Identity") and [`Identity.increment`](../core/defaults.html#sqlalchemy.schema.Identity.params.increment
    "sqlalchemy.schema.Identity").'
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.4: Removed the ability to use a [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence") object to modify IDENTITY characteristics. [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence") objects now only manipulate true T-SQL SEQUENCE
    types.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: There can only be one IDENTITY column on the table. When using `autoincrement=True`
    to enable the IDENTITY keyword, SQLAlchemy does not guard against multiple columns
    specifying the option simultaneously. The SQL Server database will instead reject
    the `CREATE TABLE` statement.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: An INSERT statement which attempts to provide a value for a column that is marked
    with IDENTITY will be rejected by SQL Server. In order for the value to be accepted,
    a session-level option “SET IDENTITY_INSERT” must be enabled. The SQLAlchemy SQL
    Server dialect will perform this operation automatically when using a core [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") construct; if the execution specifies a value
    for the IDENTITY column, the “IDENTITY_INSERT” option will be enabled for the
    span of that statement’s invocation.However, this scenario is not high performing
    and should not be relied upon for normal use. If a table doesn’t actually require
    IDENTITY behavior in its integer primary key column, the keyword should be disabled
    when creating the table by ensuring that `autoincrement=False` is set.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling “Start” and “Increment”
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Specific control over the “start” and “increment” values for the `IDENTITY`
    generator are provided using the [`Identity.start`](../core/defaults.html#sqlalchemy.schema.Identity.params.start
    "sqlalchemy.schema.Identity") and [`Identity.increment`](../core/defaults.html#sqlalchemy.schema.Identity.params.increment
    "sqlalchemy.schema.Identity") parameters passed to the [`Identity`](../core/defaults.html#sqlalchemy.schema.Identity
    "sqlalchemy.schema.Identity") object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The CREATE TABLE for the above [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") object would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The [`Identity`](../core/defaults.html#sqlalchemy.schema.Identity "sqlalchemy.schema.Identity")
    object supports many other parameter in addition to `start` and `increment`. These
    are not supported by SQL Server and will be ignored when generating the CREATE
    TABLE ddl.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.3.19: The [`Identity`](../core/defaults.html#sqlalchemy.schema.Identity
    "sqlalchemy.schema.Identity") object is now used to affect the `IDENTITY` generator
    for a [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    under SQL Server. Previously, the [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence") object was used. As SQL Server now supports real
    sequences as a separate construct, [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence") will be functional in the normal way starting from
    SQLAlchemy version 1.4.'
  prefs: []
  type: TYPE_NORMAL
- en: Using IDENTITY with Non-Integer numeric types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'SQL Server also allows `IDENTITY` to be used with `NUMERIC` columns. To implement
    this pattern smoothly in SQLAlchemy, the primary datatype of the column should
    remain as `Integer`, however the underlying implementation type deployed to the
    SQL Server database can be specified as `Numeric` using [`TypeEngine.with_variant()`](../core/type_api.html#sqlalchemy.types.TypeEngine.with_variant
    "sqlalchemy.types.TypeEngine.with_variant"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the above example, `Integer().with_variant()` provides clear usage information
    that accurately describes the intent of the code. The general restriction that
    `autoincrement` only applies to `Integer` is established at the metadata level
    and not at the per-dialect level.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using the above pattern, the primary key identifier that comes back from
    the insertion of a row, which is also the value that would be assigned to an ORM
    object such as `TestTable` above, will be an instance of `Decimal()` and not `int`
    when using SQL Server. The numeric return type of the [`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric
    "sqlalchemy.types.Numeric") type can be changed to return floats by passing False
    to [`Numeric.asdecimal`](../core/type_basics.html#sqlalchemy.types.Numeric.params.asdecimal
    "sqlalchemy.types.Numeric"). To normalize the return type of the above `Numeric(10,
    0)` to return Python ints (which also support “long” integer values in Python
    3), use [`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '### INSERT behavior'
  prefs: []
  type: TYPE_NORMAL
- en: Handling of the `IDENTITY` column at INSERT time involves two key techniques.
    The most common is being able to fetch the “last inserted value” for a given `IDENTITY`
    column, a process which SQLAlchemy performs implicitly in many cases, most importantly
    within the ORM.
  prefs: []
  type: TYPE_NORMAL
- en: 'The process for fetching this value has several variants:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the vast majority of cases, RETURNING is used in conjunction with INSERT
    statements on SQL Server in order to get newly generated primary key values:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As of SQLAlchemy 2.0, the [“Insert Many Values” Behavior for INSERT statements](../core/connections.html#engine-insertmanyvalues)
    feature is also used by default to optimize many-row INSERT statements; for SQL
    Server the feature takes place for both RETURNING and-non RETURNING INSERT statements.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Changed in version 2.0.10: The [“Insert Many Values” Behavior for INSERT statements](../core/connections.html#engine-insertmanyvalues)
    feature for SQL Server was temporarily disabled for SQLAlchemy version 2.0.9 due
    to issues with row ordering. As of 2.0.10 the feature is re-enabled, with special
    case handling for the unit of work’s requirement for RETURNING to be ordered.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'When RETURNING is not available or has been disabled via `implicit_returning=False`,
    either the `scope_identity()` function or the `@@identity` variable is used; behavior
    varies by backend:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'when using PyODBC, the phrase `; select scope_identity()` will be appended
    to the end of the INSERT statement; a second result set will be fetched in order
    to receive the value. Given a table as:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'an INSERT will look like:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Other dialects such as pymssql will call upon `SELECT scope_identity() AS lastrowid`
    subsequent to an INSERT statement. If the flag `use_scope_identity=False` is passed
    to [`create_engine()`](../core/engines.html#sqlalchemy.create_engine "sqlalchemy.create_engine"),
    the statement `SELECT @@identity AS lastrowid` is used instead.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A table that contains an `IDENTITY` column will prohibit an INSERT statement
    that refers to the identity column explicitly. The SQLAlchemy dialect will detect
    when an INSERT construct, created using a core [`insert()`](../core/dml.html#sqlalchemy.sql.expression.insert
    "sqlalchemy.sql.expression.insert") construct (not a plain string SQL), refers
    to the identity column, and in this case will emit `SET IDENTITY_INSERT ON` prior
    to the insert statement proceeding, and `SET IDENTITY_INSERT OFF` subsequent to
    the execution. Given this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The above column will be created with IDENTITY, however the INSERT statement
    we emit is specifying explicit values. In the echo output we can see how SQLAlchemy
    handles this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This is an auxiliary use case suitable for testing and bulk insert scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: SEQUENCE support
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence "sqlalchemy.schema.Sequence")
    object creates “real” sequences, i.e., `CREATE SEQUENCE`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: For integer primary key generation, SQL Server’s `IDENTITY` construct should
    generally be preferred vs. sequence.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: 'The default start value for T-SQL is `-2**63` instead of 1 as in most other
    SQL databases. Users should explicitly set the [`Sequence.start`](../core/defaults.html#sqlalchemy.schema.Sequence.params.start
    "sqlalchemy.schema.Sequence") to 1 if that’s the expected default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'New in version 1.4: added SQL Server support for [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence")'
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 2.0: The SQL Server dialect will no longer implicitly render
    “START WITH 1” for `CREATE SEQUENCE`, which was the behavior first implemented
    in version 1.4.'
  prefs: []
  type: TYPE_NORMAL
- en: MAX on VARCHAR / NVARCHAR
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SQL Server supports the special string “MAX” within the [`VARCHAR`](../core/type_basics.html#sqlalchemy.types.VARCHAR
    "sqlalchemy.types.VARCHAR") and [`NVARCHAR`](../core/type_basics.html#sqlalchemy.types.NVARCHAR
    "sqlalchemy.types.NVARCHAR") datatypes, to indicate “maximum length possible”.
    The dialect currently handles this as a length of “None” in the base type, rather
    than supplying a dialect-specific version of these types, so that a base type
    specified such as `VARCHAR(None)` can assume “unlengthed” behavior on more than
    one backend without using dialect-specific types.
  prefs: []
  type: TYPE_NORMAL
- en: 'To build a SQL Server VARCHAR or NVARCHAR with MAX length, use None:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Collation Support
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Character collations are supported by the base string types, specified by the
    string argument “collation”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'When such a column is associated with a [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table"), the CREATE TABLE statement for this column will yield:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: LIMIT/OFFSET Support
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MSSQL has added support for LIMIT / OFFSET as of SQL Server 2012, via the “OFFSET
    n ROWS” and “FETCH NEXT n ROWS” clauses. SQLAlchemy supports these syntaxes automatically
    if SQL Server 2012 or greater is detected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.4: support added for SQL Server “OFFSET n ROWS” and “FETCH
    NEXT n ROWS” syntax.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For statements that specify only LIMIT and no OFFSET, all versions of SQL Server
    support the TOP keyword. This syntax is used for all SQL Server versions when
    no OFFSET clause is present. A statement such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'will render similarly to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'For versions of SQL Server prior to SQL Server 2012, a statement that uses
    LIMIT and OFFSET, or just OFFSET alone, will be rendered using the `ROW_NUMBER()`
    window function. A statement such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'will render similarly to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Note that when using LIMIT and/or OFFSET, whether using the older or newer SQL
    Server syntaxes, the statement must have an ORDER BY as well, else a [`CompileError`](../core/exceptions.html#sqlalchemy.exc.CompileError
    "sqlalchemy.exc.CompileError") is raised.
  prefs: []
  type: TYPE_NORMAL
- en: '## DDL Comment Support'
  prefs: []
  type: TYPE_NORMAL
- en: Comment support, which includes DDL rendering for attributes such as [`Table.comment`](../core/metadata.html#sqlalchemy.schema.Table.params.comment
    "sqlalchemy.schema.Table") and [`Column.comment`](../core/metadata.html#sqlalchemy.schema.Column.params.comment
    "sqlalchemy.schema.Column"), as well as the ability to reflect these comments,
    is supported assuming a supported version of SQL Server is in use. If a non-supported
    version such as Azure Synapse is detected at first-connect time (based on the
    presence of the `fn_listextendedproperty` SQL function), comment support including
    rendering and table-comment reflection is disabled, as both features rely upon
    SQL Server stored procedures and functions that are not available on all backend
    types.
  prefs: []
  type: TYPE_NORMAL
- en: 'To force comment support to be on or off, bypassing autodetection, set the
    parameter `supports_comments` within [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'New in version 2.0: Added support for table and column comments for the SQL
    Server dialect, including DDL generation and reflection.  ## Transaction Isolation
    Level'
  prefs: []
  type: TYPE_NORMAL
- en: All SQL Server dialects support setting of transaction isolation level both
    via a dialect-specific parameter [`create_engine.isolation_level`](../core/engines.html#sqlalchemy.create_engine.params.isolation_level
    "sqlalchemy.create_engine") accepted by [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine"), as well as the [`Connection.execution_options.isolation_level`](../core/connections.html#sqlalchemy.engine.Connection.execution_options.params.isolation_level
    "sqlalchemy.engine.Connection.execution_options") argument as passed to [`Connection.execution_options()`](../core/connections.html#sqlalchemy.engine.Connection.execution_options
    "sqlalchemy.engine.Connection.execution_options"). This feature works by issuing
    the command `SET TRANSACTION ISOLATION LEVEL <level>` for each new connection.
  prefs: []
  type: TYPE_NORMAL
- en: 'To set isolation level using [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'To set using per-connection execution options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Valid values for `isolation_level` include:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AUTOCOMMIT` - pyodbc / pymssql-specific'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`READ COMMITTED`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`READ UNCOMMITTED`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`REPEATABLE READ`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SERIALIZABLE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SNAPSHOT` - specific to SQL Server'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are also more options for isolation level configurations, such as “sub-engine”
    objects linked to a main [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") which each apply different isolation level settings.
    See the discussion at [Setting Transaction Isolation Levels including DBAPI Autocommit](../core/connections.html#dbapi-autocommit)
    for background.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Setting Transaction Isolation Levels including DBAPI Autocommit](../core/connections.html#dbapi-autocommit)  ##
    Temporary Table / Resource Reset for Connection Pooling'
  prefs: []
  type: TYPE_NORMAL
- en: The [`QueuePool`](../core/pooling.html#sqlalchemy.pool.QueuePool "sqlalchemy.pool.QueuePool")
    connection pool implementation used by the SQLAlchemy [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") object includes [reset on return](../core/pooling.html#pool-reset-on-return)
    behavior that will invoke the DBAPI `.rollback()` method when connections are
    returned to the pool. While this rollback will clear out the immediate state used
    by the previous transaction, it does not cover a wider range of session-level
    state, including temporary tables as well as other server state such as prepared
    statement handles and statement caches. An undocumented SQL Server procedure known
    as `sp_reset_connection` is known to be a workaround for this issue which will
    reset most of the session state that builds up on a connection, including temporary
    tables.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install `sp_reset_connection` as the means of performing reset-on-return,
    the [`PoolEvents.reset()`](../core/events.html#sqlalchemy.events.PoolEvents.reset
    "sqlalchemy.events.PoolEvents.reset") event hook may be used, as demonstrated
    in the example below. The [`create_engine.pool_reset_on_return`](../core/engines.html#sqlalchemy.create_engine.params.pool_reset_on_return
    "sqlalchemy.create_engine") parameter is set to `None` so that the custom scheme
    can replace the default behavior completely. The custom hook implementation calls
    `.rollback()` in any case, as it’s usually important that the DBAPI’s own tracking
    of commit/rollback will remain consistent with the state of the transaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Changed in version 2.0.0b3: Added additional state arguments to the [`PoolEvents.reset()`](../core/events.html#sqlalchemy.events.PoolEvents.reset
    "sqlalchemy.events.PoolEvents.reset") event and additionally ensured the event
    is invoked for all “reset” occurrences, so that it’s appropriate as a place for
    custom “reset” handlers. Previous schemes which use the [`PoolEvents.checkin()`](../core/events.html#sqlalchemy.events.PoolEvents.checkin
    "sqlalchemy.events.PoolEvents.checkin") handler remain usable as well.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Reset On Return](../core/pooling.html#pool-reset-on-return) - in the [Connection
    Pooling](../core/pooling.html) documentation'
  prefs: []
  type: TYPE_NORMAL
- en: Nullability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'MSSQL has support for three levels of column nullability. The default nullability
    allows nulls and is explicit in the CREATE TABLE construct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'If `nullable=None` is specified then no specification is made. In other words
    the database’s configured default is used. This will render:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: If `nullable` is `True` or `False` then the column will be `NULL` or `NOT NULL`
    respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Date / Time Handling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: DATE and TIME are supported. Bind parameters are converted to datetime.datetime()
    objects as required by most MSSQL drivers, and results are processed from strings
    if needed. The DATE and TIME types are not available for MSSQL 2005 and previous
    - if a server version below 2008 is detected, DDL for these types will be issued
    as DATETIME.
  prefs: []
  type: TYPE_NORMAL
- en: '## Large Text/Binary Type Deprecation'
  prefs: []
  type: TYPE_NORMAL
- en: Per [SQL Server 2012/2014 Documentation](https://technet.microsoft.com/en-us/library/ms187993.aspx),
    the `NTEXT`, `TEXT` and `IMAGE` datatypes are to be removed from SQL Server in
    a future release. SQLAlchemy normally relates these types to the [`UnicodeText`](../core/type_basics.html#sqlalchemy.types.UnicodeText
    "sqlalchemy.types.UnicodeText"), [`TextClause`](../core/sqlelement.html#sqlalchemy.sql.expression.TextClause
    "sqlalchemy.sql.expression.TextClause") and [`LargeBinary`](../core/type_basics.html#sqlalchemy.types.LargeBinary
    "sqlalchemy.types.LargeBinary") datatypes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to accommodate this change, a new flag `deprecate_large_types` is
    added to the dialect, which will be automatically set based on detection of the
    server version in use, if not otherwise set by the user. The behavior of this
    flag is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: When this flag is `True`, the [`UnicodeText`](../core/type_basics.html#sqlalchemy.types.UnicodeText
    "sqlalchemy.types.UnicodeText"), [`TextClause`](../core/sqlelement.html#sqlalchemy.sql.expression.TextClause
    "sqlalchemy.sql.expression.TextClause") and [`LargeBinary`](../core/type_basics.html#sqlalchemy.types.LargeBinary
    "sqlalchemy.types.LargeBinary") datatypes, when used to render DDL, will render
    the types `NVARCHAR(max)`, `VARCHAR(max)`, and `VARBINARY(max)`, respectively.
    This is a new behavior as of the addition of this flag.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When this flag is `False`, the [`UnicodeText`](../core/type_basics.html#sqlalchemy.types.UnicodeText
    "sqlalchemy.types.UnicodeText"), [`TextClause`](../core/sqlelement.html#sqlalchemy.sql.expression.TextClause
    "sqlalchemy.sql.expression.TextClause") and [`LargeBinary`](../core/type_basics.html#sqlalchemy.types.LargeBinary
    "sqlalchemy.types.LargeBinary") datatypes, when used to render DDL, will render
    the types `NTEXT`, `TEXT`, and `IMAGE`, respectively. This is the long-standing
    behavior of these types.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The flag begins with the value `None`, before a database connection is established.
    If the dialect is used to render DDL without the flag being set, it is interpreted
    the same as `False`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On first connection, the dialect detects if SQL Server version 2012 or greater
    is in use; if the flag is still at `None`, it sets it to `True` or `False` based
    on whether 2012 or greater is detected.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The flag can be set to either `True` or `False` when the dialect is created,
    typically via [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine"):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Complete control over whether the “old” or “new” types are rendered is available
    in all SQLAlchemy versions by using the UPPERCASE type objects instead: [`NVARCHAR`](../core/type_basics.html#sqlalchemy.types.NVARCHAR
    "sqlalchemy.types.NVARCHAR"), [`VARCHAR`](../core/type_basics.html#sqlalchemy.types.VARCHAR
    "sqlalchemy.types.VARCHAR"), [`VARBINARY`](../core/type_basics.html#sqlalchemy.types.VARBINARY
    "sqlalchemy.types.VARBINARY"), [`TEXT`](../core/type_basics.html#sqlalchemy.types.TEXT
    "sqlalchemy.types.TEXT"), [`NTEXT`](#sqlalchemy.dialects.mssql.NTEXT "sqlalchemy.dialects.mssql.NTEXT"),
    [`IMAGE`](#sqlalchemy.dialects.mssql.IMAGE "sqlalchemy.dialects.mssql.IMAGE")
    will always remain fixed and always output exactly that type.  ## Multipart Schema
    Names'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'SQL Server schemas sometimes require multiple parts to their “schema” qualifier,
    that is, including the database name and owner name as separate tokens, such as
    `mydatabase.dbo.some_table`. These multipart names can be set at once using the
    [`Table.schema`](../core/metadata.html#sqlalchemy.schema.Table.params.schema "sqlalchemy.schema.Table")
    argument of [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'When performing operations such as table or component reflection, a schema
    argument that contains a dot will be split into separate “database” and “owner”
    components in order to correctly query the SQL Server information schema tables,
    as these two values are stored separately. Additionally, when rendering the schema
    name for DDL or SQL, the two components will be quoted separately for case sensitive
    names and other special characters. Given an argument as below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The above schema would be rendered as `[MyDataBase].dbo`, and also in reflection,
    would be reflected using “dbo” as the owner and “MyDataBase” as the database name.
  prefs: []
  type: TYPE_NORMAL
- en: 'To control how the schema name is broken into database / owner, specify brackets
    (which in SQL Server are quoting characters) in the name. Below, the “owner” will
    be considered as `MyDataBase.dbo` and the “database” will be None:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'To individually specify both database and owner name with special characters
    or embedded dots, use two sets of brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Changed in version 1.2: the SQL Server dialect now treats brackets as identifier
    delimiters splitting the schema into separate database and owner tokens, to allow
    dots within either name itself.  ## Legacy Schema Mode'
  prefs: []
  type: TYPE_NORMAL
- en: 'Very old versions of the MSSQL dialect introduced the behavior such that a
    schema-qualified table would be auto-aliased when used in a SELECT statement;
    given a table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'this legacy mode of rendering would assume that “customer_schema.account” would
    not be accepted by all parts of the SQL statement, as illustrated below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This mode of behavior is now off by default, as it appears to have served no
    purpose; however in the case that legacy applications rely upon it, it is available
    using the `legacy_schema_aliasing` argument to [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") as illustrated above.
  prefs: []
  type: TYPE_NORMAL
- en: 'Deprecated since version 1.4: The `legacy_schema_aliasing` flag is now deprecated
    and will be removed in a future release.  ## Clustered Index Support'
  prefs: []
  type: TYPE_NORMAL
- en: The MSSQL dialect supports clustered indexes (and primary keys) via the `mssql_clustered`
    option. This option is available to [`Index`](../core/constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index"), [`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint"). and [`PrimaryKeyConstraint`](../core/constraints.html#sqlalchemy.schema.PrimaryKeyConstraint
    "sqlalchemy.schema.PrimaryKeyConstraint"). For indexes this option can be combined
    with the `mssql_columnstore` one to create a clustered columnstore index.
  prefs: []
  type: TYPE_NORMAL
- en: 'To generate a clustered index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: which renders the index as `CREATE CLUSTERED INDEX my_index ON table (x)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To generate a clustered primary key use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'which will render the table, for example, as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, we can generate a clustered unique constraint using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'To explicitly request a non-clustered primary key (for example, when a separate
    clustered index is desired), use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'which will render the table, for example, as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Columnstore Index Support
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The MSSQL dialect supports columnstore indexes via the `mssql_columnstore` option.
    This option is available to [`Index`](../core/constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index"). It be combined with the `mssql_clustered` option to
    create a clustered columnstore index.
  prefs: []
  type: TYPE_NORMAL
- en: 'To generate a columnstore index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: which renders the index as `CREATE COLUMNSTORE INDEX my_index ON table (x)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To generate a clustered columnstore index provide no columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: the above renders the index as `CREATE CLUSTERED COLUMNSTORE INDEX my_index
    ON table`.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.18.
  prefs: []
  type: TYPE_NORMAL
- en: MSSQL-Specific Index Options
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to clustering, the MSSQL dialect supports other special options
    for [`Index`](../core/constraints.html#sqlalchemy.schema.Index "sqlalchemy.schema.Index").
  prefs: []
  type: TYPE_NORMAL
- en: INCLUDE
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `mssql_include` option renders INCLUDE(colname) for the given string names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: would render the index as `CREATE INDEX my_index ON table (x) INCLUDE (y)`
  prefs: []
  type: TYPE_NORMAL
- en: '### Filtered Indexes'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `mssql_where` option renders WHERE(condition) for the given string names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: would render the index as `CREATE INDEX my_index ON table (x) WHERE x > 10`.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.3.4.
  prefs: []
  type: TYPE_NORMAL
- en: Index ordering
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Index ordering is available via functional expressions, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: would render the index as `CREATE INDEX my_index ON table (x DESC)`
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Functional Indexes](../core/constraints.html#schema-indexes-functional)'
  prefs: []
  type: TYPE_NORMAL
- en: Compatibility Levels
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MSSQL supports the notion of setting compatibility levels at the database level.
    This allows, for instance, to run a database that is compatible with SQL2000 while
    running on a SQL2005 database server. `server_version_info` will always return
    the database server version information (in this case SQL2005) and not the compatibility
    level information. Because of this, if running under a backwards compatibility
    mode SQLAlchemy may attempt to use T-SQL statements that are unable to be parsed
    by the database server.
  prefs: []
  type: TYPE_NORMAL
- en: '## Triggers'
  prefs: []
  type: TYPE_NORMAL
- en: 'SQLAlchemy by default uses OUTPUT INSERTED to get at newly generated primary
    key values via IDENTITY columns or other server side defaults. MS-SQL does not
    allow the usage of OUTPUT INSERTED on tables that have triggers. To disable the
    usage of OUTPUT INSERTED on a per-table basis, specify `implicit_returning=False`
    for each [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    which has triggers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Declarative form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]  ## Rowcount Support / ORM Versioning'
  prefs: []
  type: TYPE_NORMAL
- en: The SQL Server drivers may have limited ability to return the number of rows
    updated from an UPDATE or DELETE statement.
  prefs: []
  type: TYPE_NORMAL
- en: As of this writing, the PyODBC driver is not able to return a rowcount when
    OUTPUT INSERTED is used. Previous versions of SQLAlchemy therefore had limitations
    for features such as the “ORM Versioning” feature that relies upon accurate rowcounts
    in order to match version numbers with matched rows.
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy 2.0 now retrieves the “rowcount” manually for these particular use
    cases based on counting the rows that arrived back within RETURNING; so while
    the driver still has this limitation, the ORM Versioning feature is no longer
    impacted by it. As of SQLAlchemy 2.0.5, ORM versioning has been fully re-enabled
    for the pyodbc driver.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 2.0.5: ORM versioning support is restored for the pyodbc
    driver. Previously, a warning would be emitted during ORM flush that versioning
    was not supported.'
  prefs: []
  type: TYPE_NORMAL
- en: Enabling Snapshot Isolation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'SQL Server has a default transaction isolation mode that locks entire tables,
    and causes even mildly concurrent applications to have long held locks and frequent
    deadlocks. Enabling snapshot isolation for the database as a whole is recommended
    for modern levels of concurrency support. This is accomplished via the following
    ALTER DATABASE commands executed at the SQL prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Background on SQL Server snapshot isolation is available at [https://msdn.microsoft.com/en-us/library/ms175095.aspx](https://msdn.microsoft.com/en-us/library/ms175095.aspx).
  prefs: []
  type: TYPE_NORMAL
- en: SQL Server SQL Constructs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '| Object Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| [try_cast](#sqlalchemy.dialects.mssql.try_cast)(expression, type_) | Produce
    a `TRY_CAST` expression for backends which support it; this is a `CAST` which
    returns NULL for un-castable conversions. |'
  prefs: []
  type: TYPE_TB
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Produce a `TRY_CAST` expression for backends which support it; this is a `CAST`
    which returns NULL for un-castable conversions.
  prefs: []
  type: TYPE_NORMAL
- en: In SQLAlchemy, this construct is supported **only** by the SQL Server dialect,
    and will raise a [`CompileError`](../core/exceptions.html#sqlalchemy.exc.CompileError
    "sqlalchemy.exc.CompileError") if used on other included backends. However, third
    party backends may also support this construct.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: As [`try_cast()`](../core/sqlelement.html#sqlalchemy.sql.expression.try_cast
    "sqlalchemy.sql.expression.try_cast") originates from the SQL Server dialect,
    it’s importable both from `sqlalchemy.` as well as from `sqlalchemy.dialects.mssql`.
  prefs: []
  type: TYPE_NORMAL
- en: '[`try_cast()`](../core/sqlelement.html#sqlalchemy.sql.expression.try_cast "sqlalchemy.sql.expression.try_cast")
    returns an instance of [`TryCast`](../core/sqlelement.html#sqlalchemy.sql.expression.TryCast
    "sqlalchemy.sql.expression.TryCast") and generally behaves similarly to the [`Cast`](../core/sqlelement.html#sqlalchemy.sql.expression.Cast
    "sqlalchemy.sql.expression.Cast") construct; at the SQL level, the difference
    between `CAST` and `TRY_CAST` is that `TRY_CAST` returns NULL for an un-castable
    expression, such as attempting to cast a string `"hi"` to an integer value.'
  prefs: []
  type: TYPE_NORMAL
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'The above would render on Microsoft SQL Server as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'New in version 2.0.14: [`try_cast()`](#sqlalchemy.dialects.mssql.try_cast "sqlalchemy.dialects.mssql.try_cast")
    has been generalized from the SQL Server dialect into a general use construct
    that may be supported by additional dialects.'
  prefs: []
  type: TYPE_NORMAL
- en: SQL Server Data Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As with all SQLAlchemy dialects, all UPPERCASE types that are known to be valid
    with SQL server are importable from the top level dialect, whether they originate
    from [`sqlalchemy.types`](../core/type_basics.html#module-sqlalchemy.types "sqlalchemy.types")
    or from the local dialect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Types which are specific to SQL Server, or have SQL Server-specific construction
    arguments, are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Object Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| [BIT](#sqlalchemy.dialects.mssql.BIT) | MSSQL BIT type. |'
  prefs: []
  type: TYPE_TB
- en: '| [DATETIME2](#sqlalchemy.dialects.mssql.DATETIME2) |  |'
  prefs: []
  type: TYPE_TB
- en: '| [DATETIMEOFFSET](#sqlalchemy.dialects.mssql.DATETIMEOFFSET) |  |'
  prefs: []
  type: TYPE_TB
- en: '| [DOUBLE_PRECISION](#sqlalchemy.dialects.mssql.DOUBLE_PRECISION) | the SQL
    Server DOUBLE PRECISION datatype. |'
  prefs: []
  type: TYPE_TB
- en: '| [IMAGE](#sqlalchemy.dialects.mssql.IMAGE) |  |'
  prefs: []
  type: TYPE_TB
- en: '| [JSON](#sqlalchemy.dialects.mssql.JSON) | MSSQL JSON type. |'
  prefs: []
  type: TYPE_TB
- en: '| [MONEY](#sqlalchemy.dialects.mssql.MONEY) |  |'
  prefs: []
  type: TYPE_TB
- en: '| [NTEXT](#sqlalchemy.dialects.mssql.NTEXT) | MSSQL NTEXT type, for variable-length
    unicode text up to 2^30 characters. |'
  prefs: []
  type: TYPE_TB
- en: '| [REAL](#sqlalchemy.dialects.mssql.REAL) | the SQL Server REAL datatype. |'
  prefs: []
  type: TYPE_TB
- en: '| [ROWVERSION](#sqlalchemy.dialects.mssql.ROWVERSION) | Implement the SQL Server
    ROWVERSION type. |'
  prefs: []
  type: TYPE_TB
- en: '| [SMALLDATETIME](#sqlalchemy.dialects.mssql.SMALLDATETIME) |  |'
  prefs: []
  type: TYPE_TB
- en: '| [SMALLMONEY](#sqlalchemy.dialects.mssql.SMALLMONEY) |  |'
  prefs: []
  type: TYPE_TB
- en: '| [SQL_VARIANT](#sqlalchemy.dialects.mssql.SQL_VARIANT) |  |'
  prefs: []
  type: TYPE_TB
- en: '| [TIME](#sqlalchemy.dialects.mssql.TIME) |  |'
  prefs: []
  type: TYPE_TB
- en: '| [TIMESTAMP](#sqlalchemy.dialects.mssql.TIMESTAMP) | Implement the SQL Server
    TIMESTAMP type. |'
  prefs: []
  type: TYPE_TB
- en: '| [TINYINT](#sqlalchemy.dialects.mssql.TINYINT) |  |'
  prefs: []
  type: TYPE_TB
- en: '| [UNIQUEIDENTIFIER](#sqlalchemy.dialects.mssql.UNIQUEIDENTIFIER) |  |'
  prefs: []
  type: TYPE_TB
- en: '| [XML](#sqlalchemy.dialects.mssql.XML) | MSSQL XML type. |'
  prefs: []
  type: TYPE_TB
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: MSSQL BIT type.
  prefs: []
  type: TYPE_NORMAL
- en: Both pyodbc and pymssql return values from BIT columns as Python <class ‘bool’>
    so just subclass Boolean.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.dialects.mssql.BIT.__init__)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.mssql.BIT`](#sqlalchemy.dialects.mssql.BIT "sqlalchemy.dialects.mssql.BIT")
    ([`sqlalchemy.types.Boolean`](../core/type_basics.html#sqlalchemy.types.Boolean
    "sqlalchemy.types.Boolean"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `sqlalchemy.types.Boolean.__init__` *method of* [`Boolean`](../core/type_basics.html#sqlalchemy.types.Boolean
    "sqlalchemy.types.Boolean")'
  prefs: []
  type: TYPE_NORMAL
- en: Construct a Boolean.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`create_constraint` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: defaults to False. If the boolean is generated as an int/smallint, also create
    a CHECK constraint on the table that ensures 1 or 0 as a value.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: it is strongly recommended that the CHECK constraint have an explicit name in
    order to support schema-management concerns. This can be established either by
    setting the [`Boolean.name`](../core/type_basics.html#sqlalchemy.types.Boolean.params.name
    "sqlalchemy.types.Boolean") parameter or by setting up an appropriate naming convention;
    see [Configuring Constraint Naming Conventions](../core/constraints.html#constraint-naming-conventions)
    for background.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Changed in version 1.4: - this flag now defaults to False, meaning no CHECK
    constraint is generated for a non-native enumerated type.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`name` – if a CHECK constraint is generated, specify the name of the constraint.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The SQL CHAR type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class `sqlalchemy.dialects.mssql.CHAR` ([`sqlalchemy.types.String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `sqlalchemy.types.String.__init__` *method of* [`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String")'
  prefs: []
  type: TYPE_NORMAL
- en: Create a string-holding type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`length` – optional, a length for the column for use in DDL and CAST expressions.
    May be safely omitted if no `CREATE TABLE` will be issued. Certain databases may
    require a `length` for use in DDL, and will raise an exception when the `CREATE
    TABLE` DDL is issued if a `VARCHAR` with no length is included. Whether the value
    is interpreted as bytes or characters is database specific.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`collation` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Optional, a column-level collation for use in DDL and CAST expressions. Renders
    using the COLLATE keyword supported by SQLite, MySQL, and PostgreSQL. E.g.:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In most cases, the [`Unicode`](../core/type_basics.html#sqlalchemy.types.Unicode
    "sqlalchemy.types.Unicode") or [`UnicodeText`](../core/type_basics.html#sqlalchemy.types.UnicodeText
    "sqlalchemy.types.UnicodeText") datatypes should be used for a [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") that expects to store non-ascii data. These datatypes
    will ensure that the correct types are used on the database.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.mssql.DATETIME2`](#sqlalchemy.dialects.mssql.DATETIME2
    "sqlalchemy.dialects.mssql.DATETIME2") (`sqlalchemy.dialects.mssql.base._DateTimeBase`,
    [`sqlalchemy.types.DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime
    "sqlalchemy.types.DateTime"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.mssql.DATETIMEOFFSET`](#sqlalchemy.dialects.mssql.DATETIMEOFFSET
    "sqlalchemy.dialects.mssql.DATETIMEOFFSET") (`sqlalchemy.dialects.mssql.base._DateTimeBase`,
    [`sqlalchemy.types.DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime
    "sqlalchemy.types.DateTime"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: the SQL Server DOUBLE PRECISION datatype.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.11.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.mssql.DOUBLE_PRECISION`](#sqlalchemy.dialects.mssql.DOUBLE_PRECISION
    "sqlalchemy.dialects.mssql.DOUBLE_PRECISION") ([`sqlalchemy.types.DOUBLE_PRECISION`](../core/type_basics.html#sqlalchemy.types.DOUBLE_PRECISION
    "sqlalchemy.types.DOUBLE_PRECISION"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.dialects.mssql.IMAGE.__init__)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.mssql.IMAGE`](#sqlalchemy.dialects.mssql.IMAGE "sqlalchemy.dialects.mssql.IMAGE")
    ([`sqlalchemy.types.LargeBinary`](../core/type_basics.html#sqlalchemy.types.LargeBinary
    "sqlalchemy.types.LargeBinary"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `sqlalchemy.types.LargeBinary.__init__` *method of* [`LargeBinary`](../core/type_basics.html#sqlalchemy.types.LargeBinary
    "sqlalchemy.types.LargeBinary")'
  prefs: []
  type: TYPE_NORMAL
- en: Construct a LargeBinary type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**length** – optional, a length for the column for use in DDL statements, for
    those binary types that accept a length, such as the MySQL BLOB type.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: MSSQL JSON type.
  prefs: []
  type: TYPE_NORMAL
- en: MSSQL supports JSON-formatted data as of SQL Server 2016.
  prefs: []
  type: TYPE_NORMAL
- en: The [`JSON`](#sqlalchemy.dialects.mssql.JSON "sqlalchemy.dialects.mssql.JSON")
    datatype at the DDL level will represent the datatype as `NVARCHAR(max)`, but
    provides for JSON-level comparison functions as well as Python coercion behavior.
  prefs: []
  type: TYPE_NORMAL
- en: '[`JSON`](#sqlalchemy.dialects.mssql.JSON "sqlalchemy.dialects.mssql.JSON")
    is used automatically whenever the base [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON") datatype is used against a SQL Server backend.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON")
    - main documentation for the generic cross-platform JSON datatype.'
  prefs: []
  type: TYPE_NORMAL
- en: The [`JSON`](#sqlalchemy.dialects.mssql.JSON "sqlalchemy.dialects.mssql.JSON")
    type supports persistence of JSON values as well as the core index operations
    provided by [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON")
    datatype, by adapting the operations to render the `JSON_VALUE` or `JSON_QUERY`
    functions at the database level.
  prefs: []
  type: TYPE_NORMAL
- en: The SQL Server [`JSON`](#sqlalchemy.dialects.mssql.JSON "sqlalchemy.dialects.mssql.JSON")
    type necessarily makes use of the `JSON_QUERY` and `JSON_VALUE` functions when
    querying for elements of a JSON object. These two functions have a major restriction
    in that they are **mutually exclusive** based on the type of object to be returned.
    The `JSON_QUERY` function **only** returns a JSON dictionary or list, but not
    an individual string, numeric, or boolean element; the `JSON_VALUE` function **only**
    returns an individual string, numeric, or boolean element. **both functions either
    return NULL or raise an error if they are not used against the correct expected
    value**.
  prefs: []
  type: TYPE_NORMAL
- en: 'To handle this awkward requirement, indexed access rules are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'When extracting a sub element from a JSON that is itself a JSON dictionary
    or list, the [`Comparator.as_json()`](../core/type_basics.html#sqlalchemy.types.JSON.Comparator.as_json
    "sqlalchemy.types.JSON.Comparator.as_json") accessor should be used:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When extracting a sub element from a JSON that is a plain boolean, string,
    integer, or float, use the appropriate method among [`Comparator.as_boolean()`](../core/type_basics.html#sqlalchemy.types.JSON.Comparator.as_boolean
    "sqlalchemy.types.JSON.Comparator.as_boolean"), [`Comparator.as_string()`](../core/type_basics.html#sqlalchemy.types.JSON.Comparator.as_string
    "sqlalchemy.types.JSON.Comparator.as_string"), [`Comparator.as_integer()`](../core/type_basics.html#sqlalchemy.types.JSON.Comparator.as_integer
    "sqlalchemy.types.JSON.Comparator.as_integer"), [`Comparator.as_float()`](../core/type_basics.html#sqlalchemy.types.JSON.Comparator.as_float
    "sqlalchemy.types.JSON.Comparator.as_float"):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: New in version 1.4.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.dialects.mssql.JSON.__init__)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.mssql.JSON`](#sqlalchemy.dialects.mssql.JSON "sqlalchemy.dialects.mssql.JSON")
    ([`sqlalchemy.types.JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `sqlalchemy.types.JSON.__init__` *method of* [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON")'
  prefs: []
  type: TYPE_NORMAL
- en: Construct a [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON")
    type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**none_as_null=False** –'
  prefs: []
  type: TYPE_NORMAL
- en: 'if True, persist the value `None` as a SQL NULL value, not the JSON encoding
    of `null`. Note that when this flag is False, the [`null()`](../core/sqlelement.html#sqlalchemy.sql.expression.null
    "sqlalchemy.sql.expression.null") construct can still be used to persist a NULL
    value, which may be passed directly as a parameter value that is specially interpreted
    by the [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON")
    type as SQL NULL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '[`JSON.none_as_null`](../core/type_basics.html#sqlalchemy.types.JSON.params.none_as_null
    "sqlalchemy.types.JSON") does **not** apply to the values passed to [`Column.default`](../core/metadata.html#sqlalchemy.schema.Column.params.default
    "sqlalchemy.schema.Column") and [`Column.server_default`](../core/metadata.html#sqlalchemy.schema.Column.params.server_default
    "sqlalchemy.schema.Column"); a value of `None` passed for these parameters means
    “no default present”.'
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, when used in SQL comparison expressions, the Python value `None`
    continues to refer to SQL null, and not JSON NULL. The [`JSON.none_as_null`](../core/type_basics.html#sqlalchemy.types.JSON.params.none_as_null
    "sqlalchemy.types.JSON") flag refers explicitly to the **persistence** of the
    value within an INSERT or UPDATE statement. The [`JSON.NULL`](../core/type_basics.html#sqlalchemy.types.JSON.NULL
    "sqlalchemy.types.JSON.NULL") value should be used for SQL expressions that wish
    to compare to JSON null.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`JSON.NULL`](../core/type_basics.html#sqlalchemy.types.JSON.NULL "sqlalchemy.types.JSON.NULL")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.mssql.MONEY`](#sqlalchemy.dialects.mssql.MONEY "sqlalchemy.dialects.mssql.MONEY")
    ([`sqlalchemy.types.TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: The SQL NCHAR type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class `sqlalchemy.dialects.mssql.NCHAR` ([`sqlalchemy.types.Unicode`](../core/type_basics.html#sqlalchemy.types.Unicode
    "sqlalchemy.types.Unicode"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `sqlalchemy.types.String.__init__` *method of* [`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String")'
  prefs: []
  type: TYPE_NORMAL
- en: Create a string-holding type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`length` – optional, a length for the column for use in DDL and CAST expressions.
    May be safely omitted if no `CREATE TABLE` will be issued. Certain databases may
    require a `length` for use in DDL, and will raise an exception when the `CREATE
    TABLE` DDL is issued if a `VARCHAR` with no length is included. Whether the value
    is interpreted as bytes or characters is database specific.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`collation` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Optional, a column-level collation for use in DDL and CAST expressions. Renders
    using the COLLATE keyword supported by SQLite, MySQL, and PostgreSQL. E.g.:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In most cases, the [`Unicode`](../core/type_basics.html#sqlalchemy.types.Unicode
    "sqlalchemy.types.Unicode") or [`UnicodeText`](../core/type_basics.html#sqlalchemy.types.UnicodeText
    "sqlalchemy.types.UnicodeText") datatypes should be used for a [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") that expects to store non-ascii data. These datatypes
    will ensure that the correct types are used on the database.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: MSSQL NTEXT type, for variable-length unicode text up to 2^30 characters.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.dialects.mssql.NTEXT.__init__)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.mssql.NTEXT`](#sqlalchemy.dialects.mssql.NTEXT "sqlalchemy.dialects.mssql.NTEXT")
    ([`sqlalchemy.types.UnicodeText`](../core/type_basics.html#sqlalchemy.types.UnicodeText
    "sqlalchemy.types.UnicodeText"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `sqlalchemy.types.String.__init__` *method of* [`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String")'
  prefs: []
  type: TYPE_NORMAL
- en: Create a string-holding type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`length` – optional, a length for the column for use in DDL and CAST expressions.
    May be safely omitted if no `CREATE TABLE` will be issued. Certain databases may
    require a `length` for use in DDL, and will raise an exception when the `CREATE
    TABLE` DDL is issued if a `VARCHAR` with no length is included. Whether the value
    is interpreted as bytes or characters is database specific.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`collation` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Optional, a column-level collation for use in DDL and CAST expressions. Renders
    using the COLLATE keyword supported by SQLite, MySQL, and PostgreSQL. E.g.:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In most cases, the [`Unicode`](../core/type_basics.html#sqlalchemy.types.Unicode
    "sqlalchemy.types.Unicode") or [`UnicodeText`](../core/type_basics.html#sqlalchemy.types.UnicodeText
    "sqlalchemy.types.UnicodeText") datatypes should be used for a [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") that expects to store non-ascii data. These datatypes
    will ensure that the correct types are used on the database.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: The SQL NVARCHAR type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class `sqlalchemy.dialects.mssql.NVARCHAR` ([`sqlalchemy.types.Unicode`](../core/type_basics.html#sqlalchemy.types.Unicode
    "sqlalchemy.types.Unicode"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `sqlalchemy.types.String.__init__` *method of* [`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String")'
  prefs: []
  type: TYPE_NORMAL
- en: Create a string-holding type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`length` – optional, a length for the column for use in DDL and CAST expressions.
    May be safely omitted if no `CREATE TABLE` will be issued. Certain databases may
    require a `length` for use in DDL, and will raise an exception when the `CREATE
    TABLE` DDL is issued if a `VARCHAR` with no length is included. Whether the value
    is interpreted as bytes or characters is database specific.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`collation` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Optional, a column-level collation for use in DDL and CAST expressions. Renders
    using the COLLATE keyword supported by SQLite, MySQL, and PostgreSQL. E.g.:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In most cases, the [`Unicode`](../core/type_basics.html#sqlalchemy.types.Unicode
    "sqlalchemy.types.Unicode") or [`UnicodeText`](../core/type_basics.html#sqlalchemy.types.UnicodeText
    "sqlalchemy.types.UnicodeText") datatypes should be used for a [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") that expects to store non-ascii data. These datatypes
    will ensure that the correct types are used on the database.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: the SQL Server REAL datatype.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.mssql.REAL`](#sqlalchemy.dialects.mssql.REAL "sqlalchemy.dialects.mssql.REAL")
    ([`sqlalchemy.types.REAL`](../core/type_basics.html#sqlalchemy.types.REAL "sqlalchemy.types.REAL"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Implement the SQL Server ROWVERSION type.
  prefs: []
  type: TYPE_NORMAL
- en: The ROWVERSION datatype is a SQL Server synonym for the TIMESTAMP datatype,
    however current SQL Server documentation suggests using ROWVERSION for new datatypes
    going forward.
  prefs: []
  type: TYPE_NORMAL
- en: The ROWVERSION datatype does **not** reflect (e.g. introspect) from the database
    as itself; the returned datatype will be [`TIMESTAMP`](#sqlalchemy.dialects.mssql.TIMESTAMP
    "sqlalchemy.dialects.mssql.TIMESTAMP").
  prefs: []
  type: TYPE_NORMAL
- en: This is a read-only datatype that does not support INSERT of values.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.2.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`TIMESTAMP`](#sqlalchemy.dialects.mssql.TIMESTAMP "sqlalchemy.dialects.mssql.TIMESTAMP")'
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.dialects.mssql.ROWVERSION.__init__)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.mssql.ROWVERSION`](#sqlalchemy.dialects.mssql.ROWVERSION
    "sqlalchemy.dialects.mssql.ROWVERSION") ([`sqlalchemy.dialects.mssql.base.TIMESTAMP`](#sqlalchemy.dialects.mssql.TIMESTAMP
    "sqlalchemy.dialects.mssql.base.TIMESTAMP"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `sqlalchemy.dialects.mssql.base.TIMESTAMP.__init__` *method
    of* [`TIMESTAMP`](#sqlalchemy.dialects.mssql.TIMESTAMP "sqlalchemy.dialects.mssql.base.TIMESTAMP")'
  prefs: []
  type: TYPE_NORMAL
- en: Construct a TIMESTAMP or ROWVERSION type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**convert_int** – if True, binary integer values will be converted to integers
    on read.'
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.2.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.dialects.mssql.SMALLDATETIME.__init__)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.mssql.SMALLDATETIME`](#sqlalchemy.dialects.mssql.SMALLDATETIME
    "sqlalchemy.dialects.mssql.SMALLDATETIME") (`sqlalchemy.dialects.mssql.base._DateTimeBase`,
    [`sqlalchemy.types.DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime
    "sqlalchemy.types.DateTime"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `sqlalchemy.types.DateTime.__init__` *method of* [`DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime
    "sqlalchemy.types.DateTime")'
  prefs: []
  type: TYPE_NORMAL
- en: Construct a new [`DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime
    "sqlalchemy.types.DateTime").
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**timezone** – boolean. Indicates that the datetime type should enable timezone
    support, if available on the **base date/time-holding type only**. It is recommended
    to make use of the [`TIMESTAMP`](../core/type_basics.html#sqlalchemy.types.TIMESTAMP
    "sqlalchemy.types.TIMESTAMP") datatype directly when using this flag, as some
    databases include separate generic date/time-holding types distinct from the timezone-capable
    TIMESTAMP datatype, such as Oracle.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.mssql.SMALLMONEY`](#sqlalchemy.dialects.mssql.SMALLMONEY
    "sqlalchemy.dialects.mssql.SMALLMONEY") ([`sqlalchemy.types.TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.mssql.SQL_VARIANT`](#sqlalchemy.dialects.mssql.SQL_VARIANT
    "sqlalchemy.dialects.mssql.SQL_VARIANT") ([`sqlalchemy.types.TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: The SQL TEXT type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class `sqlalchemy.dialects.mssql.TEXT` ([`sqlalchemy.types.Text`](../core/type_basics.html#sqlalchemy.types.Text
    "sqlalchemy.types.Text"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `sqlalchemy.types.String.__init__` *method of* [`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String")'
  prefs: []
  type: TYPE_NORMAL
- en: Create a string-holding type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`length` – optional, a length for the column for use in DDL and CAST expressions.
    May be safely omitted if no `CREATE TABLE` will be issued. Certain databases may
    require a `length` for use in DDL, and will raise an exception when the `CREATE
    TABLE` DDL is issued if a `VARCHAR` with no length is included. Whether the value
    is interpreted as bytes or characters is database specific.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`collation` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Optional, a column-level collation for use in DDL and CAST expressions. Renders
    using the COLLATE keyword supported by SQLite, MySQL, and PostgreSQL. E.g.:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In most cases, the [`Unicode`](../core/type_basics.html#sqlalchemy.types.Unicode
    "sqlalchemy.types.Unicode") or [`UnicodeText`](../core/type_basics.html#sqlalchemy.types.UnicodeText
    "sqlalchemy.types.UnicodeText") datatypes should be used for a [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") that expects to store non-ascii data. These datatypes
    will ensure that the correct types are used on the database.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.mssql.TIME`](#sqlalchemy.dialects.mssql.TIME "sqlalchemy.dialects.mssql.TIME")
    ([`sqlalchemy.types.TIME`](../core/type_basics.html#sqlalchemy.types.TIME "sqlalchemy.types.TIME"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Implement the SQL Server TIMESTAMP type.
  prefs: []
  type: TYPE_NORMAL
- en: Note this is **completely different** than the SQL Standard TIMESTAMP type,
    which is not supported by SQL Server. It is a read-only datatype that does not
    support INSERT of values.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.2.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`ROWVERSION`](#sqlalchemy.dialects.mssql.ROWVERSION "sqlalchemy.dialects.mssql.ROWVERSION")'
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.dialects.mssql.TIMESTAMP.__init__)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.mssql.TIMESTAMP`](#sqlalchemy.dialects.mssql.TIMESTAMP
    "sqlalchemy.dialects.mssql.TIMESTAMP") (`sqlalchemy.types._Binary`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Construct a TIMESTAMP or ROWVERSION type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**convert_int** – if True, binary integer values will be converted to integers
    on read.'
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.2.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.mssql.TINYINT`](#sqlalchemy.dialects.mssql.TINYINT
    "sqlalchemy.dialects.mssql.TINYINT") ([`sqlalchemy.types.Integer`](../core/type_basics.html#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.dialects.mssql.UNIQUEIDENTIFIER.__init__)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.mssql.UNIQUEIDENTIFIER`](#sqlalchemy.dialects.mssql.UNIQUEIDENTIFIER
    "sqlalchemy.dialects.mssql.UNIQUEIDENTIFIER") ([`sqlalchemy.types.Uuid`](../core/type_basics.html#sqlalchemy.types.Uuid
    "sqlalchemy.types.Uuid"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: Construct a [`UNIQUEIDENTIFIER`](#sqlalchemy.dialects.mssql.UNIQUEIDENTIFIER
    "sqlalchemy.dialects.mssql.UNIQUEIDENTIFIER") type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**as_uuid=True** –'
  prefs: []
  type: TYPE_NORMAL
- en: if True, values will be interpreted as Python uuid objects, converting to/from
    string via the DBAPI.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: The MSSQL VARBINARY type.
  prefs: []
  type: TYPE_NORMAL
- en: This type adds additional features to the core [`VARBINARY`](../core/type_basics.html#sqlalchemy.types.VARBINARY
    "sqlalchemy.types.VARBINARY") type, including “deprecate_large_types” mode where
    either `VARBINARY(max)` or IMAGE is rendered, as well as the SQL Server `FILESTREAM`
    option.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Large Text/Binary Type Deprecation](#mssql-large-type-deprecation)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class `sqlalchemy.dialects.mssql.VARBINARY` ([`sqlalchemy.types.VARBINARY`](../core/type_basics.html#sqlalchemy.types.VARBINARY
    "sqlalchemy.types.VARBINARY"), [`sqlalchemy.types.LargeBinary`](../core/type_basics.html#sqlalchemy.types.LargeBinary
    "sqlalchemy.types.LargeBinary"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: Construct a VARBINARY type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`length` – optional, a length for the column for use in DDL statements, for
    those binary types that accept a length, such as the MySQL BLOB type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`filestream=False` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: if True, renders the `FILESTREAM` keyword in the table definition. In this case
    `length` must be `None` or `'max'`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: New in version 1.4.31.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: The SQL VARCHAR type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class `sqlalchemy.dialects.mssql.VARCHAR` ([`sqlalchemy.types.String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `sqlalchemy.types.String.__init__` *method of* [`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String")'
  prefs: []
  type: TYPE_NORMAL
- en: Create a string-holding type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`length` – optional, a length for the column for use in DDL and CAST expressions.
    May be safely omitted if no `CREATE TABLE` will be issued. Certain databases may
    require a `length` for use in DDL, and will raise an exception when the `CREATE
    TABLE` DDL is issued if a `VARCHAR` with no length is included. Whether the value
    is interpreted as bytes or characters is database specific.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`collation` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Optional, a column-level collation for use in DDL and CAST expressions. Renders
    using the COLLATE keyword supported by SQLite, MySQL, and PostgreSQL. E.g.:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In most cases, the [`Unicode`](../core/type_basics.html#sqlalchemy.types.Unicode
    "sqlalchemy.types.Unicode") or [`UnicodeText`](../core/type_basics.html#sqlalchemy.types.UnicodeText
    "sqlalchemy.types.UnicodeText") datatypes should be used for a [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") that expects to store non-ascii data. These datatypes
    will ensure that the correct types are used on the database.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: MSSQL XML type.
  prefs: []
  type: TYPE_NORMAL
- en: This is a placeholder type for reflection purposes that does not include any
    Python-side datatype support. It also does not currently support additional arguments,
    such as “CONTENT”, “DOCUMENT”, “xml_schema_collection”.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.dialects.mssql.XML.__init__)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.mssql.XML`](#sqlalchemy.dialects.mssql.XML "sqlalchemy.dialects.mssql.XML")
    ([`sqlalchemy.types.Text`](../core/type_basics.html#sqlalchemy.types.Text "sqlalchemy.types.Text"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `sqlalchemy.types.String.__init__` *method of* [`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String")'
  prefs: []
  type: TYPE_NORMAL
- en: Create a string-holding type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`length` – optional, a length for the column for use in DDL and CAST expressions.
    May be safely omitted if no `CREATE TABLE` will be issued. Certain databases may
    require a `length` for use in DDL, and will raise an exception when the `CREATE
    TABLE` DDL is issued if a `VARCHAR` with no length is included. Whether the value
    is interpreted as bytes or characters is database specific.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`collation` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Optional, a column-level collation for use in DDL and CAST expressions. Renders
    using the COLLATE keyword supported by SQLite, MySQL, and PostgreSQL. E.g.:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In most cases, the [`Unicode`](../core/type_basics.html#sqlalchemy.types.Unicode
    "sqlalchemy.types.Unicode") or [`UnicodeText`](../core/type_basics.html#sqlalchemy.types.UnicodeText
    "sqlalchemy.types.UnicodeText") datatypes should be used for a [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") that expects to store non-ascii data. These datatypes
    will ensure that the correct types are used on the database.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '## PyODBC'
  prefs: []
  type: TYPE_NORMAL
- en: Support for the Microsoft SQL Server database via the PyODBC driver.
  prefs: []
  type: TYPE_NORMAL
- en: DBAPI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Documentation and download information (if applicable) for PyODBC is available
    at: [https://pypi.org/project/pyodbc/](https://pypi.org/project/pyodbc/)'
  prefs: []
  type: TYPE_NORMAL
- en: Connecting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Connect String:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: Connecting to PyODBC
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The URL here is to be translated to PyODBC connection strings, as detailed in
    [ConnectionStrings](https://code.google.com/p/pyodbc/wiki/ConnectionStrings).
  prefs: []
  type: TYPE_NORMAL
- en: DSN Connections
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A DSN connection in ODBC means that a pre-existing ODBC datasource is configured
    on the client machine. The application then specifies the name of this datasource,
    which encompasses details such as the specific ODBC driver in use as well as the
    network address of the database. Assuming a datasource is configured on the client,
    a basic DSN-based connection looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'Which above, will pass the following connection string to PyODBC:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: If the username and password are omitted, the DSN form will also add the `Trusted_Connection=yes`
    directive to the ODBC string.
  prefs: []
  type: TYPE_NORMAL
- en: Hostname Connections
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Hostname-based connections are also supported by pyodbc. These are often easier
    to use than a DSN and have the additional advantage that the specific database
    name to connect towards may be specified locally in the URL, rather than it being
    fixed as part of a datasource configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using a hostname connection, the driver name must also be specified in
    the query parameters of the URL. As these names usually have spaces in them, the
    name must be URL encoded which means using plus signs for spaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: The `driver` keyword is significant to the pyodbc dialect and must be specified
    in lowercase.
  prefs: []
  type: TYPE_NORMAL
- en: 'Any other names passed in the query string are passed through in the pyodbc
    connect string, such as `authentication`, `TrustServerCertificate`, etc. Multiple
    keyword arguments must be separated by an ampersand (`&`); these will be translated
    to semicolons when the pyodbc connect string is generated internally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'The equivalent URL can be constructed using [`URL`](../core/engines.html#sqlalchemy.engine.URL
    "sqlalchemy.engine.URL"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: Pass through exact Pyodbc string
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A PyODBC connection string can also be sent in pyodbc’s format directly, as
    specified in [the PyODBC documentation](https://github.com/mkleehammer/pyodbc/wiki/Connecting-to-databases),
    using the parameter `odbc_connect`. A [`URL`](../core/engines.html#sqlalchemy.engine.URL
    "sqlalchemy.engine.URL") object can help make this easier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '#### Connecting to databases with access tokens'
  prefs: []
  type: TYPE_NORMAL
- en: Some database servers are set up to only accept access tokens for login. For
    example, SQL Server allows the use of Azure Active Directory tokens to connect
    to databases. This requires creating a credential object using the `azure-identity`
    library. More information about the authentication step can be found in [Microsoft’s
    documentation](https://docs.microsoft.com/en-us/azure/developer/python/azure-sdk-authenticate?tabs=bash).
  prefs: []
  type: TYPE_NORMAL
- en: After getting an engine, the credentials need to be sent to `pyodbc.connect`
    each time a connection is requested. One way to do this is to set up an event
    listener on the engine that adds the credential token to the dialect’s connect
    call. This is discussed more generally in [Generating dynamic authentication tokens](../core/engines.html#engines-dynamic-tokens).
    For SQL Server in particular, this is passed as an ODBC connection attribute with
    a data structure [described by Microsoft](https://docs.microsoft.com/en-us/sql/connect/odbc/using-azure-active-directory#authenticating-with-an-access-token).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet will create an engine that connects to an Azure
    SQL database using Azure credentials:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Trusted_Connection` token is currently added by the SQLAlchemy pyodbc
    dialect when no username or password is present. This needs to be removed per
    Microsoft’s [documentation for Azure access tokens](https://docs.microsoft.com/en-us/sql/connect/odbc/using-azure-active-directory#authenticating-with-an-access-token),
    stating that a connection string when using an access token must not contain `UID`,
    `PWD`, `Authentication` or `Trusted_Connection` parameters.  #### Avoiding transaction-related
    exceptions on Azure Synapse Analytics'
  prefs: []
  type: TYPE_NORMAL
- en: Azure Synapse Analytics has a significant difference in its transaction handling
    compared to plain SQL Server; in some cases an error within a Synapse transaction
    can cause it to be arbitrarily terminated on the server side, which then causes
    the DBAPI `.rollback()` method (as well as `.commit()`) to fail. The issue prevents
    the usual DBAPI contract of allowing `.rollback()` to pass silently if no transaction
    is present as the driver does not expect this condition. The symptom of this failure
    is an exception with a message resembling ‘No corresponding transaction found.
    (111214)’ when attempting to emit a `.rollback()` after an operation had a failure
    of some kind.
  prefs: []
  type: TYPE_NORMAL
- en: 'This specific case can be handled by passing `ignore_no_transaction_on_rollback=True`
    to the SQL Server dialect via the [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: Using the above parameter, the dialect will catch `ProgrammingError` exceptions
    raised during `connection.rollback()` and emit a warning if the error message
    contains code `111214`, however will not raise an exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 1.4.40: Added the `ignore_no_transaction_on_rollback=True` parameter.'
  prefs: []
  type: TYPE_NORMAL
- en: Enable autocommit for Azure SQL Data Warehouse (DW) connections
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Azure SQL Data Warehouse does not support transactions, and that can cause
    problems with SQLAlchemy’s “autobegin” (and implicit commit/rollback) behavior.
    We can avoid these problems by enabling autocommit at both the pyodbc and engine
    levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: Avoiding sending large string parameters as TEXT/NTEXT
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: By default, for historical reasons, Microsoft’s ODBC drivers for SQL Server
    send long string parameters (greater than 4000 SBCS characters or 2000 Unicode
    characters) as TEXT/NTEXT values. TEXT and NTEXT have been deprecated for many
    years and are starting to cause compatibility issues with newer versions of SQL_Server/Azure.
    For example, see [this issue](https://github.com/mkleehammer/pyodbc/issues/835).
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting with ODBC Driver 18 for SQL Server we can override the legacy behavior
    and pass long strings as varchar(max)/nvarchar(max) using the `LongAsMax=Yes`
    connection string parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: Pyodbc Pooling / connection close behavior
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'PyODBC uses internal [pooling](https://github.com/mkleehammer/pyodbc/wiki/The-pyodbc-Module#pooling)
    by default, which means connections will be longer lived than they are within
    SQLAlchemy itself. As SQLAlchemy has its own pooling behavior, it is often preferable
    to disable this behavior. This behavior can only be disabled globally at the PyODBC
    module level, **before** any connections are made:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: If this variable is left at its default value of `True`, **the application will
    continue to maintain active database connections**, even when the SQLAlchemy engine
    itself fully discards a connection or if the engine is disposed.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[pooling](https://github.com/mkleehammer/pyodbc/wiki/The-pyodbc-Module#pooling)
    - in the PyODBC documentation.'
  prefs: []
  type: TYPE_NORMAL
- en: Driver / Unicode Support
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: PyODBC works best with Microsoft ODBC drivers, particularly in the area of Unicode
    support on both Python 2 and Python 3.
  prefs: []
  type: TYPE_NORMAL
- en: Using the FreeTDS ODBC drivers on Linux or OSX with PyODBC is **not** recommended;
    there have been historically many Unicode-related issues in this area, including
    before Microsoft offered ODBC drivers for Linux and OSX. Now that Microsoft offers
    drivers for all platforms, for PyODBC support these are recommended. FreeTDS remains
    relevant for non-ODBC drivers such as pymssql where it works very well.
  prefs: []
  type: TYPE_NORMAL
- en: Rowcount Support
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Previous limitations with the SQLAlchemy ORM’s “versioned rows” feature with
    Pyodbc have been resolved as of SQLAlchemy 2.0.5\. See the notes at [Rowcount
    Support / ORM Versioning](#mssql-rowcount-versioning).
  prefs: []
  type: TYPE_NORMAL
- en: '### Fast Executemany Mode'
  prefs: []
  type: TYPE_NORMAL
- en: 'The PyODBC driver includes support for a “fast executemany” mode of execution
    which greatly reduces round trips for a DBAPI `executemany()` call when using
    Microsoft ODBC drivers, for **limited size batches that fit in memory**. The feature
    is enabled by setting the attribute `.fast_executemany` on the DBAPI cursor when
    an executemany call is to be used. The SQLAlchemy PyODBC SQL Server dialect supports
    this parameter by passing the `fast_executemany` parameter to [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") , when using the **Microsoft ODBC driver only**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'Changed in version 2.0.9: - the `fast_executemany` parameter now has its intended
    effect of this PyODBC feature taking effect for all INSERT statements that are
    executed with multiple parameter sets, which don’t include RETURNING. Previously,
    SQLAlchemy 2.0’s [insertmanyvalues](../glossary.html#term-insertmanyvalues) feature
    would cause `fast_executemany` to not be used in most cases even if specified.'
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.3.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[fast executemany](https://github.com/mkleehammer/pyodbc/wiki/Features-beyond-the-DB-API#fast_executemany)
    - on github  ### Setinputsizes Support'
  prefs: []
  type: TYPE_NORMAL
- en: As of version 2.0, the pyodbc `cursor.setinputsizes()` method is used for all
    statement executions, except for `cursor.executemany()` calls when fast_executemany=True
    where it is not supported (assuming [insertmanyvalues](../core/connections.html#engine-insertmanyvalues)
    is kept enabled, “fastexecutemany” will not take place for INSERT statements in
    any case).
  prefs: []
  type: TYPE_NORMAL
- en: The use of `cursor.setinputsizes()` can be disabled by passing `use_setinputsizes=False`
    to [`create_engine()`](../core/engines.html#sqlalchemy.create_engine "sqlalchemy.create_engine").
  prefs: []
  type: TYPE_NORMAL
- en: When `use_setinputsizes` is left at its default of `True`, the specific per-type
    symbols passed to `cursor.setinputsizes()` can be programmatically customized
    using the [`DialectEvents.do_setinputsizes()`](../core/events.html#sqlalchemy.events.DialectEvents.do_setinputsizes
    "sqlalchemy.events.DialectEvents.do_setinputsizes") hook. See that method for
    usage examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 2.0: The mssql+pyodbc dialect now defaults to using `use_setinputsizes=True`
    for all statement executions with the exception of cursor.executemany() calls
    when fast_executemany=True. The behavior can be turned off by passing `use_setinputsizes=False`
    to [`create_engine()`](../core/engines.html#sqlalchemy.create_engine "sqlalchemy.create_engine").  ##
    pymssql'
  prefs: []
  type: TYPE_NORMAL
- en: Support for the Microsoft SQL Server database via the pymssql driver.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Connect String:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: pymssql is a Python module that provides a Python DBAPI interface around [FreeTDS](https://www.freetds.org/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 2.0.5: pymssql was restored to SQLAlchemy’s continuous integration
    testing  ## aioodbc'
  prefs: []
  type: TYPE_NORMAL
- en: Support for the Microsoft SQL Server database via the aioodbc driver.
  prefs: []
  type: TYPE_NORMAL
- en: DBAPI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Documentation and download information (if applicable) for aioodbc is available
    at: [https://pypi.org/project/aioodbc/](https://pypi.org/project/aioodbc/)'
  prefs: []
  type: TYPE_NORMAL
- en: Connecting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Connect String:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: Support for the SQL Server database in asyncio style, using the aioodbc driver
    which itself is a thread-wrapper around pyodbc.
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 2.0.23: Added the mssql+aioodbc dialect which builds on top
    of the pyodbc and general aio* dialect architecture.'
  prefs: []
  type: TYPE_NORMAL
- en: Using a special asyncio mediation layer, the aioodbc dialect is usable as the
    backend for the [SQLAlchemy asyncio](../orm/extensions/asyncio.html) extension
    package.
  prefs: []
  type: TYPE_NORMAL
- en: Most behaviors and caveats for this driver are the same as that of the pyodbc
    dialect used on SQL Server; see [PyODBC](#mssql-pyodbc) for general background.
  prefs: []
  type: TYPE_NORMAL
- en: 'This dialect should normally be used only with the [`create_async_engine()`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.create_async_engine
    "sqlalchemy.ext.asyncio.create_async_engine") engine creation function; connection
    styles are otherwise equivalent to those documented in the pyodbc section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: Support for the Microsoft SQL Server database.
  prefs: []
  type: TYPE_NORMAL
- en: The following table summarizes current support levels for database release versions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Supported Microsoft SQL Server versions**'
  prefs: []
  type: TYPE_NORMAL
- en: '| Support type | Versions |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| [Fully tested in CI](index.html#term-Fully-tested-in-CI) | 2017 |'
  prefs: []
  type: TYPE_TB
- en: '| [Normal support](index.html#term-Normal-support) | 2012+ |'
  prefs: []
  type: TYPE_TB
- en: '| [Best effort](index.html#term-Best-effort) | 2005+ |'
  prefs: []
  type: TYPE_TB
- en: DBAPI Support
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following dialect/DBAPI options are available. Please refer to individual
    DBAPI sections for connect information.
  prefs: []
  type: TYPE_NORMAL
- en: '[PyODBC](#module-sqlalchemy.dialects.mssql.pyodbc)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[pymssql](#module-sqlalchemy.dialects.mssql.pymssql)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[aioodbc](#module-sqlalchemy.dialects.mssql.aioodbc)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '## External Dialects'
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the above DBAPI layers with native SQLAlchemy support, there
    are third-party dialects for other DBAPI layers that are compatible with SQL Server.
    See the “External Dialects” list on the [Dialects](index.html) page.
  prefs: []
  type: TYPE_NORMAL
- en: '## Auto Increment Behavior / IDENTITY Columns'
  prefs: []
  type: TYPE_NORMAL
- en: 'SQL Server provides so-called “auto incrementing” behavior using the `IDENTITY`
    construct, which can be placed on any single integer column in a table. SQLAlchemy
    considers `IDENTITY` within its default “autoincrement” behavior for an integer
    primary key column, described at [`Column.autoincrement`](../core/metadata.html#sqlalchemy.schema.Column.params.autoincrement
    "sqlalchemy.schema.Column"). This means that by default, the first integer primary
    key column in a [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    will be considered to be the identity column - unless it is associated with a
    [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence "sqlalchemy.schema.Sequence")
    - and will generate DDL as such:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'The above example will generate DDL as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'For the case where this default generation of `IDENTITY` is not desired, specify
    `False` for the [`Column.autoincrement`](../core/metadata.html#sqlalchemy.schema.Column.params.autoincrement
    "sqlalchemy.schema.Column") flag, on the first integer primary key column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'To add the `IDENTITY` keyword to a non-primary key column, specify `True` for
    the [`Column.autoincrement`](../core/metadata.html#sqlalchemy.schema.Column.params.autoincrement
    "sqlalchemy.schema.Column") flag on the desired [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") object, and ensure that [`Column.autoincrement`](../core/metadata.html#sqlalchemy.schema.Column.params.autoincrement
    "sqlalchemy.schema.Column") is set to `False` on any integer primary key column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'Changed in version 1.4: Added [`Identity`](../core/defaults.html#sqlalchemy.schema.Identity
    "sqlalchemy.schema.Identity") construct in a [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") to specify the start and increment parameters of an
    IDENTITY. These replace the use of the [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence") object in order to specify these values.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Deprecated since version 1.4: The `mssql_identity_start` and `mssql_identity_increment`
    parameters to [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    are deprecated and should we replaced by an [`Identity`](../core/defaults.html#sqlalchemy.schema.Identity
    "sqlalchemy.schema.Identity") object. Specifying both ways of configuring an IDENTITY
    will result in a compile error. These options are also no longer returned as part
    of the `dialect_options` key in [`Inspector.get_columns()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_columns
    "sqlalchemy.engine.reflection.Inspector.get_columns"). Use the information in
    the `identity` key instead.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Deprecated since version 1.3: The use of [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence") to specify IDENTITY characteristics is deprecated
    and will be removed in a future release. Please use the [`Identity`](../core/defaults.html#sqlalchemy.schema.Identity
    "sqlalchemy.schema.Identity") object parameters [`Identity.start`](../core/defaults.html#sqlalchemy.schema.Identity.params.start
    "sqlalchemy.schema.Identity") and [`Identity.increment`](../core/defaults.html#sqlalchemy.schema.Identity.params.increment
    "sqlalchemy.schema.Identity").'
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.4: Removed the ability to use a [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence") object to modify IDENTITY characteristics. [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence") objects now only manipulate true T-SQL SEQUENCE
    types.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: There can only be one IDENTITY column on the table. When using `autoincrement=True`
    to enable the IDENTITY keyword, SQLAlchemy does not guard against multiple columns
    specifying the option simultaneously. The SQL Server database will instead reject
    the `CREATE TABLE` statement.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: An INSERT statement which attempts to provide a value for a column that is marked
    with IDENTITY will be rejected by SQL Server. In order for the value to be accepted,
    a session-level option “SET IDENTITY_INSERT” must be enabled. The SQLAlchemy SQL
    Server dialect will perform this operation automatically when using a core [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") construct; if the execution specifies a value
    for the IDENTITY column, the “IDENTITY_INSERT” option will be enabled for the
    span of that statement’s invocation.However, this scenario is not high performing
    and should not be relied upon for normal use. If a table doesn’t actually require
    IDENTITY behavior in its integer primary key column, the keyword should be disabled
    when creating the table by ensuring that `autoincrement=False` is set.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling “Start” and “Increment”
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Specific control over the “start” and “increment” values for the `IDENTITY`
    generator are provided using the [`Identity.start`](../core/defaults.html#sqlalchemy.schema.Identity.params.start
    "sqlalchemy.schema.Identity") and [`Identity.increment`](../core/defaults.html#sqlalchemy.schema.Identity.params.increment
    "sqlalchemy.schema.Identity") parameters passed to the [`Identity`](../core/defaults.html#sqlalchemy.schema.Identity
    "sqlalchemy.schema.Identity") object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'The CREATE TABLE for the above [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") object would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The [`Identity`](../core/defaults.html#sqlalchemy.schema.Identity "sqlalchemy.schema.Identity")
    object supports many other parameter in addition to `start` and `increment`. These
    are not supported by SQL Server and will be ignored when generating the CREATE
    TABLE ddl.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.3.19: The [`Identity`](../core/defaults.html#sqlalchemy.schema.Identity
    "sqlalchemy.schema.Identity") object is now used to affect the `IDENTITY` generator
    for a [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    under SQL Server. Previously, the [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence") object was used. As SQL Server now supports real
    sequences as a separate construct, [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence") will be functional in the normal way starting from
    SQLAlchemy version 1.4.'
  prefs: []
  type: TYPE_NORMAL
- en: Using IDENTITY with Non-Integer numeric types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'SQL Server also allows `IDENTITY` to be used with `NUMERIC` columns. To implement
    this pattern smoothly in SQLAlchemy, the primary datatype of the column should
    remain as `Integer`, however the underlying implementation type deployed to the
    SQL Server database can be specified as `Numeric` using [`TypeEngine.with_variant()`](../core/type_api.html#sqlalchemy.types.TypeEngine.with_variant
    "sqlalchemy.types.TypeEngine.with_variant"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: In the above example, `Integer().with_variant()` provides clear usage information
    that accurately describes the intent of the code. The general restriction that
    `autoincrement` only applies to `Integer` is established at the metadata level
    and not at the per-dialect level.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using the above pattern, the primary key identifier that comes back from
    the insertion of a row, which is also the value that would be assigned to an ORM
    object such as `TestTable` above, will be an instance of `Decimal()` and not `int`
    when using SQL Server. The numeric return type of the [`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric
    "sqlalchemy.types.Numeric") type can be changed to return floats by passing False
    to [`Numeric.asdecimal`](../core/type_basics.html#sqlalchemy.types.Numeric.params.asdecimal
    "sqlalchemy.types.Numeric"). To normalize the return type of the above `Numeric(10,
    0)` to return Python ints (which also support “long” integer values in Python
    3), use [`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: '### INSERT behavior'
  prefs: []
  type: TYPE_NORMAL
- en: Handling of the `IDENTITY` column at INSERT time involves two key techniques.
    The most common is being able to fetch the “last inserted value” for a given `IDENTITY`
    column, a process which SQLAlchemy performs implicitly in many cases, most importantly
    within the ORM.
  prefs: []
  type: TYPE_NORMAL
- en: 'The process for fetching this value has several variants:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the vast majority of cases, RETURNING is used in conjunction with INSERT
    statements on SQL Server in order to get newly generated primary key values:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As of SQLAlchemy 2.0, the [“Insert Many Values” Behavior for INSERT statements](../core/connections.html#engine-insertmanyvalues)
    feature is also used by default to optimize many-row INSERT statements; for SQL
    Server the feature takes place for both RETURNING and-non RETURNING INSERT statements.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Changed in version 2.0.10: The [“Insert Many Values” Behavior for INSERT statements](../core/connections.html#engine-insertmanyvalues)
    feature for SQL Server was temporarily disabled for SQLAlchemy version 2.0.9 due
    to issues with row ordering. As of 2.0.10 the feature is re-enabled, with special
    case handling for the unit of work’s requirement for RETURNING to be ordered.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'When RETURNING is not available or has been disabled via `implicit_returning=False`,
    either the `scope_identity()` function or the `@@identity` variable is used; behavior
    varies by backend:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'when using PyODBC, the phrase `; select scope_identity()` will be appended
    to the end of the INSERT statement; a second result set will be fetched in order
    to receive the value. Given a table as:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'an INSERT will look like:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Other dialects such as pymssql will call upon `SELECT scope_identity() AS lastrowid`
    subsequent to an INSERT statement. If the flag `use_scope_identity=False` is passed
    to [`create_engine()`](../core/engines.html#sqlalchemy.create_engine "sqlalchemy.create_engine"),
    the statement `SELECT @@identity AS lastrowid` is used instead.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A table that contains an `IDENTITY` column will prohibit an INSERT statement
    that refers to the identity column explicitly. The SQLAlchemy dialect will detect
    when an INSERT construct, created using a core [`insert()`](../core/dml.html#sqlalchemy.sql.expression.insert
    "sqlalchemy.sql.expression.insert") construct (not a plain string SQL), refers
    to the identity column, and in this case will emit `SET IDENTITY_INSERT ON` prior
    to the insert statement proceeding, and `SET IDENTITY_INSERT OFF` subsequent to
    the execution. Given this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'The above column will be created with IDENTITY, however the INSERT statement
    we emit is specifying explicit values. In the echo output we can see how SQLAlchemy
    handles this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: This is an auxiliary use case suitable for testing and bulk insert scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling “Start” and “Increment”
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Specific control over the “start” and “increment” values for the `IDENTITY`
    generator are provided using the [`Identity.start`](../core/defaults.html#sqlalchemy.schema.Identity.params.start
    "sqlalchemy.schema.Identity") and [`Identity.increment`](../core/defaults.html#sqlalchemy.schema.Identity.params.increment
    "sqlalchemy.schema.Identity") parameters passed to the [`Identity`](../core/defaults.html#sqlalchemy.schema.Identity
    "sqlalchemy.schema.Identity") object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: 'The CREATE TABLE for the above [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") object would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The [`Identity`](../core/defaults.html#sqlalchemy.schema.Identity "sqlalchemy.schema.Identity")
    object supports many other parameter in addition to `start` and `increment`. These
    are not supported by SQL Server and will be ignored when generating the CREATE
    TABLE ddl.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.3.19: The [`Identity`](../core/defaults.html#sqlalchemy.schema.Identity
    "sqlalchemy.schema.Identity") object is now used to affect the `IDENTITY` generator
    for a [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    under SQL Server. Previously, the [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence") object was used. As SQL Server now supports real
    sequences as a separate construct, [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence") will be functional in the normal way starting from
    SQLAlchemy version 1.4.'
  prefs: []
  type: TYPE_NORMAL
- en: Using IDENTITY with Non-Integer numeric types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'SQL Server also allows `IDENTITY` to be used with `NUMERIC` columns. To implement
    this pattern smoothly in SQLAlchemy, the primary datatype of the column should
    remain as `Integer`, however the underlying implementation type deployed to the
    SQL Server database can be specified as `Numeric` using [`TypeEngine.with_variant()`](../core/type_api.html#sqlalchemy.types.TypeEngine.with_variant
    "sqlalchemy.types.TypeEngine.with_variant"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: In the above example, `Integer().with_variant()` provides clear usage information
    that accurately describes the intent of the code. The general restriction that
    `autoincrement` only applies to `Integer` is established at the metadata level
    and not at the per-dialect level.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using the above pattern, the primary key identifier that comes back from
    the insertion of a row, which is also the value that would be assigned to an ORM
    object such as `TestTable` above, will be an instance of `Decimal()` and not `int`
    when using SQL Server. The numeric return type of the [`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric
    "sqlalchemy.types.Numeric") type can be changed to return floats by passing False
    to [`Numeric.asdecimal`](../core/type_basics.html#sqlalchemy.types.Numeric.params.asdecimal
    "sqlalchemy.types.Numeric"). To normalize the return type of the above `Numeric(10,
    0)` to return Python ints (which also support “long” integer values in Python
    3), use [`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: '### INSERT behavior'
  prefs: []
  type: TYPE_NORMAL
- en: Handling of the `IDENTITY` column at INSERT time involves two key techniques.
    The most common is being able to fetch the “last inserted value” for a given `IDENTITY`
    column, a process which SQLAlchemy performs implicitly in many cases, most importantly
    within the ORM.
  prefs: []
  type: TYPE_NORMAL
- en: 'The process for fetching this value has several variants:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the vast majority of cases, RETURNING is used in conjunction with INSERT
    statements on SQL Server in order to get newly generated primary key values:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As of SQLAlchemy 2.0, the [“Insert Many Values” Behavior for INSERT statements](../core/connections.html#engine-insertmanyvalues)
    feature is also used by default to optimize many-row INSERT statements; for SQL
    Server the feature takes place for both RETURNING and-non RETURNING INSERT statements.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Changed in version 2.0.10: The [“Insert Many Values” Behavior for INSERT statements](../core/connections.html#engine-insertmanyvalues)
    feature for SQL Server was temporarily disabled for SQLAlchemy version 2.0.9 due
    to issues with row ordering. As of 2.0.10 the feature is re-enabled, with special
    case handling for the unit of work’s requirement for RETURNING to be ordered.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'When RETURNING is not available or has been disabled via `implicit_returning=False`,
    either the `scope_identity()` function or the `@@identity` variable is used; behavior
    varies by backend:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'when using PyODBC, the phrase `; select scope_identity()` will be appended
    to the end of the INSERT statement; a second result set will be fetched in order
    to receive the value. Given a table as:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'an INSERT will look like:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Other dialects such as pymssql will call upon `SELECT scope_identity() AS lastrowid`
    subsequent to an INSERT statement. If the flag `use_scope_identity=False` is passed
    to [`create_engine()`](../core/engines.html#sqlalchemy.create_engine "sqlalchemy.create_engine"),
    the statement `SELECT @@identity AS lastrowid` is used instead.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A table that contains an `IDENTITY` column will prohibit an INSERT statement
    that refers to the identity column explicitly. The SQLAlchemy dialect will detect
    when an INSERT construct, created using a core [`insert()`](../core/dml.html#sqlalchemy.sql.expression.insert
    "sqlalchemy.sql.expression.insert") construct (not a plain string SQL), refers
    to the identity column, and in this case will emit `SET IDENTITY_INSERT ON` prior
    to the insert statement proceeding, and `SET IDENTITY_INSERT OFF` subsequent to
    the execution. Given this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: 'The above column will be created with IDENTITY, however the INSERT statement
    we emit is specifying explicit values. In the echo output we can see how SQLAlchemy
    handles this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: This is an auxiliary use case suitable for testing and bulk insert scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: SEQUENCE support
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence "sqlalchemy.schema.Sequence")
    object creates “real” sequences, i.e., `CREATE SEQUENCE`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: For integer primary key generation, SQL Server’s `IDENTITY` construct should
    generally be preferred vs. sequence.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: 'The default start value for T-SQL is `-2**63` instead of 1 as in most other
    SQL databases. Users should explicitly set the [`Sequence.start`](../core/defaults.html#sqlalchemy.schema.Sequence.params.start
    "sqlalchemy.schema.Sequence") to 1 if that’s the expected default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: 'New in version 1.4: added SQL Server support for [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence")'
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 2.0: The SQL Server dialect will no longer implicitly render
    “START WITH 1” for `CREATE SEQUENCE`, which was the behavior first implemented
    in version 1.4.'
  prefs: []
  type: TYPE_NORMAL
- en: MAX on VARCHAR / NVARCHAR
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SQL Server supports the special string “MAX” within the [`VARCHAR`](../core/type_basics.html#sqlalchemy.types.VARCHAR
    "sqlalchemy.types.VARCHAR") and [`NVARCHAR`](../core/type_basics.html#sqlalchemy.types.NVARCHAR
    "sqlalchemy.types.NVARCHAR") datatypes, to indicate “maximum length possible”.
    The dialect currently handles this as a length of “None” in the base type, rather
    than supplying a dialect-specific version of these types, so that a base type
    specified such as `VARCHAR(None)` can assume “unlengthed” behavior on more than
    one backend without using dialect-specific types.
  prefs: []
  type: TYPE_NORMAL
- en: 'To build a SQL Server VARCHAR or NVARCHAR with MAX length, use None:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: Collation Support
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Character collations are supported by the base string types, specified by the
    string argument “collation”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: 'When such a column is associated with a [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table"), the CREATE TABLE statement for this column will yield:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: LIMIT/OFFSET Support
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MSSQL has added support for LIMIT / OFFSET as of SQL Server 2012, via the “OFFSET
    n ROWS” and “FETCH NEXT n ROWS” clauses. SQLAlchemy supports these syntaxes automatically
    if SQL Server 2012 or greater is detected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.4: support added for SQL Server “OFFSET n ROWS” and “FETCH
    NEXT n ROWS” syntax.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For statements that specify only LIMIT and no OFFSET, all versions of SQL Server
    support the TOP keyword. This syntax is used for all SQL Server versions when
    no OFFSET clause is present. A statement such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: 'will render similarly to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: 'For versions of SQL Server prior to SQL Server 2012, a statement that uses
    LIMIT and OFFSET, or just OFFSET alone, will be rendered using the `ROW_NUMBER()`
    window function. A statement such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: 'will render similarly to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: Note that when using LIMIT and/or OFFSET, whether using the older or newer SQL
    Server syntaxes, the statement must have an ORDER BY as well, else a [`CompileError`](../core/exceptions.html#sqlalchemy.exc.CompileError
    "sqlalchemy.exc.CompileError") is raised.
  prefs: []
  type: TYPE_NORMAL
- en: '## DDL Comment Support'
  prefs: []
  type: TYPE_NORMAL
- en: Comment support, which includes DDL rendering for attributes such as [`Table.comment`](../core/metadata.html#sqlalchemy.schema.Table.params.comment
    "sqlalchemy.schema.Table") and [`Column.comment`](../core/metadata.html#sqlalchemy.schema.Column.params.comment
    "sqlalchemy.schema.Column"), as well as the ability to reflect these comments,
    is supported assuming a supported version of SQL Server is in use. If a non-supported
    version such as Azure Synapse is detected at first-connect time (based on the
    presence of the `fn_listextendedproperty` SQL function), comment support including
    rendering and table-comment reflection is disabled, as both features rely upon
    SQL Server stored procedures and functions that are not available on all backend
    types.
  prefs: []
  type: TYPE_NORMAL
- en: 'To force comment support to be on or off, bypassing autodetection, set the
    parameter `supports_comments` within [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: 'New in version 2.0: Added support for table and column comments for the SQL
    Server dialect, including DDL generation and reflection.'
  prefs: []
  type: TYPE_NORMAL
- en: '## Transaction Isolation Level'
  prefs: []
  type: TYPE_NORMAL
- en: All SQL Server dialects support setting of transaction isolation level both
    via a dialect-specific parameter [`create_engine.isolation_level`](../core/engines.html#sqlalchemy.create_engine.params.isolation_level
    "sqlalchemy.create_engine") accepted by [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine"), as well as the [`Connection.execution_options.isolation_level`](../core/connections.html#sqlalchemy.engine.Connection.execution_options.params.isolation_level
    "sqlalchemy.engine.Connection.execution_options") argument as passed to [`Connection.execution_options()`](../core/connections.html#sqlalchemy.engine.Connection.execution_options
    "sqlalchemy.engine.Connection.execution_options"). This feature works by issuing
    the command `SET TRANSACTION ISOLATION LEVEL <level>` for each new connection.
  prefs: []
  type: TYPE_NORMAL
- en: 'To set isolation level using [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: 'To set using per-connection execution options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: 'Valid values for `isolation_level` include:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AUTOCOMMIT` - pyodbc / pymssql-specific'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`READ COMMITTED`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`READ UNCOMMITTED`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`REPEATABLE READ`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SERIALIZABLE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SNAPSHOT` - specific to SQL Server'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are also more options for isolation level configurations, such as “sub-engine”
    objects linked to a main [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") which each apply different isolation level settings.
    See the discussion at [Setting Transaction Isolation Levels including DBAPI Autocommit](../core/connections.html#dbapi-autocommit)
    for background.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Setting Transaction Isolation Levels including DBAPI Autocommit](../core/connections.html#dbapi-autocommit)'
  prefs: []
  type: TYPE_NORMAL
- en: '## Temporary Table / Resource Reset for Connection Pooling'
  prefs: []
  type: TYPE_NORMAL
- en: The [`QueuePool`](../core/pooling.html#sqlalchemy.pool.QueuePool "sqlalchemy.pool.QueuePool")
    connection pool implementation used by the SQLAlchemy [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") object includes [reset on return](../core/pooling.html#pool-reset-on-return)
    behavior that will invoke the DBAPI `.rollback()` method when connections are
    returned to the pool. While this rollback will clear out the immediate state used
    by the previous transaction, it does not cover a wider range of session-level
    state, including temporary tables as well as other server state such as prepared
    statement handles and statement caches. An undocumented SQL Server procedure known
    as `sp_reset_connection` is known to be a workaround for this issue which will
    reset most of the session state that builds up on a connection, including temporary
    tables.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install `sp_reset_connection` as the means of performing reset-on-return,
    the [`PoolEvents.reset()`](../core/events.html#sqlalchemy.events.PoolEvents.reset
    "sqlalchemy.events.PoolEvents.reset") event hook may be used, as demonstrated
    in the example below. The [`create_engine.pool_reset_on_return`](../core/engines.html#sqlalchemy.create_engine.params.pool_reset_on_return
    "sqlalchemy.create_engine") parameter is set to `None` so that the custom scheme
    can replace the default behavior completely. The custom hook implementation calls
    `.rollback()` in any case, as it’s usually important that the DBAPI’s own tracking
    of commit/rollback will remain consistent with the state of the transaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: 'Changed in version 2.0.0b3: Added additional state arguments to the [`PoolEvents.reset()`](../core/events.html#sqlalchemy.events.PoolEvents.reset
    "sqlalchemy.events.PoolEvents.reset") event and additionally ensured the event
    is invoked for all “reset” occurrences, so that it’s appropriate as a place for
    custom “reset” handlers. Previous schemes which use the [`PoolEvents.checkin()`](../core/events.html#sqlalchemy.events.PoolEvents.checkin
    "sqlalchemy.events.PoolEvents.checkin") handler remain usable as well.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Reset On Return](../core/pooling.html#pool-reset-on-return) - in the [Connection
    Pooling](../core/pooling.html) documentation'
  prefs: []
  type: TYPE_NORMAL
- en: Nullability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'MSSQL has support for three levels of column nullability. The default nullability
    allows nulls and is explicit in the CREATE TABLE construct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: 'If `nullable=None` is specified then no specification is made. In other words
    the database’s configured default is used. This will render:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: If `nullable` is `True` or `False` then the column will be `NULL` or `NOT NULL`
    respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Date / Time Handling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: DATE and TIME are supported. Bind parameters are converted to datetime.datetime()
    objects as required by most MSSQL drivers, and results are processed from strings
    if needed. The DATE and TIME types are not available for MSSQL 2005 and previous
    - if a server version below 2008 is detected, DDL for these types will be issued
    as DATETIME.
  prefs: []
  type: TYPE_NORMAL
- en: '## Large Text/Binary Type Deprecation'
  prefs: []
  type: TYPE_NORMAL
- en: Per [SQL Server 2012/2014 Documentation](https://technet.microsoft.com/en-us/library/ms187993.aspx),
    the `NTEXT`, `TEXT` and `IMAGE` datatypes are to be removed from SQL Server in
    a future release. SQLAlchemy normally relates these types to the [`UnicodeText`](../core/type_basics.html#sqlalchemy.types.UnicodeText
    "sqlalchemy.types.UnicodeText"), [`TextClause`](../core/sqlelement.html#sqlalchemy.sql.expression.TextClause
    "sqlalchemy.sql.expression.TextClause") and [`LargeBinary`](../core/type_basics.html#sqlalchemy.types.LargeBinary
    "sqlalchemy.types.LargeBinary") datatypes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to accommodate this change, a new flag `deprecate_large_types` is
    added to the dialect, which will be automatically set based on detection of the
    server version in use, if not otherwise set by the user. The behavior of this
    flag is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: When this flag is `True`, the [`UnicodeText`](../core/type_basics.html#sqlalchemy.types.UnicodeText
    "sqlalchemy.types.UnicodeText"), [`TextClause`](../core/sqlelement.html#sqlalchemy.sql.expression.TextClause
    "sqlalchemy.sql.expression.TextClause") and [`LargeBinary`](../core/type_basics.html#sqlalchemy.types.LargeBinary
    "sqlalchemy.types.LargeBinary") datatypes, when used to render DDL, will render
    the types `NVARCHAR(max)`, `VARCHAR(max)`, and `VARBINARY(max)`, respectively.
    This is a new behavior as of the addition of this flag.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When this flag is `False`, the [`UnicodeText`](../core/type_basics.html#sqlalchemy.types.UnicodeText
    "sqlalchemy.types.UnicodeText"), [`TextClause`](../core/sqlelement.html#sqlalchemy.sql.expression.TextClause
    "sqlalchemy.sql.expression.TextClause") and [`LargeBinary`](../core/type_basics.html#sqlalchemy.types.LargeBinary
    "sqlalchemy.types.LargeBinary") datatypes, when used to render DDL, will render
    the types `NTEXT`, `TEXT`, and `IMAGE`, respectively. This is the long-standing
    behavior of these types.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The flag begins with the value `None`, before a database connection is established.
    If the dialect is used to render DDL without the flag being set, it is interpreted
    the same as `False`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On first connection, the dialect detects if SQL Server version 2012 or greater
    is in use; if the flag is still at `None`, it sets it to `True` or `False` based
    on whether 2012 or greater is detected.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The flag can be set to either `True` or `False` when the dialect is created,
    typically via [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine"):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Complete control over whether the “old” or “new” types are rendered is available
    in all SQLAlchemy versions by using the UPPERCASE type objects instead: [`NVARCHAR`](../core/type_basics.html#sqlalchemy.types.NVARCHAR
    "sqlalchemy.types.NVARCHAR"), [`VARCHAR`](../core/type_basics.html#sqlalchemy.types.VARCHAR
    "sqlalchemy.types.VARCHAR"), [`VARBINARY`](../core/type_basics.html#sqlalchemy.types.VARBINARY
    "sqlalchemy.types.VARBINARY"), [`TEXT`](../core/type_basics.html#sqlalchemy.types.TEXT
    "sqlalchemy.types.TEXT"), [`NTEXT`](#sqlalchemy.dialects.mssql.NTEXT "sqlalchemy.dialects.mssql.NTEXT"),
    [`IMAGE`](#sqlalchemy.dialects.mssql.IMAGE "sqlalchemy.dialects.mssql.IMAGE")
    will always remain fixed and always output exactly that type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '## Multipart Schema Names'
  prefs: []
  type: TYPE_NORMAL
- en: 'SQL Server schemas sometimes require multiple parts to their “schema” qualifier,
    that is, including the database name and owner name as separate tokens, such as
    `mydatabase.dbo.some_table`. These multipart names can be set at once using the
    [`Table.schema`](../core/metadata.html#sqlalchemy.schema.Table.params.schema "sqlalchemy.schema.Table")
    argument of [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: 'When performing operations such as table or component reflection, a schema
    argument that contains a dot will be split into separate “database” and “owner”
    components in order to correctly query the SQL Server information schema tables,
    as these two values are stored separately. Additionally, when rendering the schema
    name for DDL or SQL, the two components will be quoted separately for case sensitive
    names and other special characters. Given an argument as below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: The above schema would be rendered as `[MyDataBase].dbo`, and also in reflection,
    would be reflected using “dbo” as the owner and “MyDataBase” as the database name.
  prefs: []
  type: TYPE_NORMAL
- en: 'To control how the schema name is broken into database / owner, specify brackets
    (which in SQL Server are quoting characters) in the name. Below, the “owner” will
    be considered as `MyDataBase.dbo` and the “database” will be None:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: 'To individually specify both database and owner name with special characters
    or embedded dots, use two sets of brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: 'Changed in version 1.2: the SQL Server dialect now treats brackets as identifier
    delimiters splitting the schema into separate database and owner tokens, to allow
    dots within either name itself.'
  prefs: []
  type: TYPE_NORMAL
- en: '## Legacy Schema Mode'
  prefs: []
  type: TYPE_NORMAL
- en: 'Very old versions of the MSSQL dialect introduced the behavior such that a
    schema-qualified table would be auto-aliased when used in a SELECT statement;
    given a table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: 'this legacy mode of rendering would assume that “customer_schema.account” would
    not be accepted by all parts of the SQL statement, as illustrated below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: This mode of behavior is now off by default, as it appears to have served no
    purpose; however in the case that legacy applications rely upon it, it is available
    using the `legacy_schema_aliasing` argument to [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") as illustrated above.
  prefs: []
  type: TYPE_NORMAL
- en: 'Deprecated since version 1.4: The `legacy_schema_aliasing` flag is now deprecated
    and will be removed in a future release.'
  prefs: []
  type: TYPE_NORMAL
- en: '## Clustered Index Support'
  prefs: []
  type: TYPE_NORMAL
- en: The MSSQL dialect supports clustered indexes (and primary keys) via the `mssql_clustered`
    option. This option is available to [`Index`](../core/constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index"), [`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint"). and [`PrimaryKeyConstraint`](../core/constraints.html#sqlalchemy.schema.PrimaryKeyConstraint
    "sqlalchemy.schema.PrimaryKeyConstraint"). For indexes this option can be combined
    with the `mssql_columnstore` one to create a clustered columnstore index.
  prefs: []
  type: TYPE_NORMAL
- en: 'To generate a clustered index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: which renders the index as `CREATE CLUSTERED INDEX my_index ON table (x)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To generate a clustered primary key use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: 'which will render the table, for example, as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, we can generate a clustered unique constraint using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: 'To explicitly request a non-clustered primary key (for example, when a separate
    clustered index is desired), use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: 'which will render the table, for example, as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: Columnstore Index Support
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The MSSQL dialect supports columnstore indexes via the `mssql_columnstore` option.
    This option is available to [`Index`](../core/constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index"). It be combined with the `mssql_clustered` option to
    create a clustered columnstore index.
  prefs: []
  type: TYPE_NORMAL
- en: 'To generate a columnstore index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: which renders the index as `CREATE COLUMNSTORE INDEX my_index ON table (x)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To generate a clustered columnstore index provide no columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: the above renders the index as `CREATE CLUSTERED COLUMNSTORE INDEX my_index
    ON table`.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.18.
  prefs: []
  type: TYPE_NORMAL
- en: MSSQL-Specific Index Options
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to clustering, the MSSQL dialect supports other special options
    for [`Index`](../core/constraints.html#sqlalchemy.schema.Index "sqlalchemy.schema.Index").
  prefs: []
  type: TYPE_NORMAL
- en: INCLUDE
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `mssql_include` option renders INCLUDE(colname) for the given string names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: would render the index as `CREATE INDEX my_index ON table (x) INCLUDE (y)`
  prefs: []
  type: TYPE_NORMAL
- en: '### Filtered Indexes'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `mssql_where` option renders WHERE(condition) for the given string names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: would render the index as `CREATE INDEX my_index ON table (x) WHERE x > 10`.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.3.4.
  prefs: []
  type: TYPE_NORMAL
- en: Index ordering
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Index ordering is available via functional expressions, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: would render the index as `CREATE INDEX my_index ON table (x DESC)`
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Functional Indexes](../core/constraints.html#schema-indexes-functional)'
  prefs: []
  type: TYPE_NORMAL
- en: INCLUDE
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `mssql_include` option renders INCLUDE(colname) for the given string names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: would render the index as `CREATE INDEX my_index ON table (x) INCLUDE (y)`
  prefs: []
  type: TYPE_NORMAL
- en: '### Filtered Indexes'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `mssql_where` option renders WHERE(condition) for the given string names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: would render the index as `CREATE INDEX my_index ON table (x) WHERE x > 10`.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.3.4.
  prefs: []
  type: TYPE_NORMAL
- en: Index ordering
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Index ordering is available via functional expressions, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: would render the index as `CREATE INDEX my_index ON table (x DESC)`
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Functional Indexes](../core/constraints.html#schema-indexes-functional)'
  prefs: []
  type: TYPE_NORMAL
- en: Compatibility Levels
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MSSQL supports the notion of setting compatibility levels at the database level.
    This allows, for instance, to run a database that is compatible with SQL2000 while
    running on a SQL2005 database server. `server_version_info` will always return
    the database server version information (in this case SQL2005) and not the compatibility
    level information. Because of this, if running under a backwards compatibility
    mode SQLAlchemy may attempt to use T-SQL statements that are unable to be parsed
    by the database server.
  prefs: []
  type: TYPE_NORMAL
- en: '## Triggers'
  prefs: []
  type: TYPE_NORMAL
- en: 'SQLAlchemy by default uses OUTPUT INSERTED to get at newly generated primary
    key values via IDENTITY columns or other server side defaults. MS-SQL does not
    allow the usage of OUTPUT INSERTED on tables that have triggers. To disable the
    usage of OUTPUT INSERTED on a per-table basis, specify `implicit_returning=False`
    for each [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    which has triggers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: 'Declarative form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: '## Rowcount Support / ORM Versioning'
  prefs: []
  type: TYPE_NORMAL
- en: The SQL Server drivers may have limited ability to return the number of rows
    updated from an UPDATE or DELETE statement.
  prefs: []
  type: TYPE_NORMAL
- en: As of this writing, the PyODBC driver is not able to return a rowcount when
    OUTPUT INSERTED is used. Previous versions of SQLAlchemy therefore had limitations
    for features such as the “ORM Versioning” feature that relies upon accurate rowcounts
    in order to match version numbers with matched rows.
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy 2.0 now retrieves the “rowcount” manually for these particular use
    cases based on counting the rows that arrived back within RETURNING; so while
    the driver still has this limitation, the ORM Versioning feature is no longer
    impacted by it. As of SQLAlchemy 2.0.5, ORM versioning has been fully re-enabled
    for the pyodbc driver.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 2.0.5: ORM versioning support is restored for the pyodbc
    driver. Previously, a warning would be emitted during ORM flush that versioning
    was not supported.'
  prefs: []
  type: TYPE_NORMAL
- en: Enabling Snapshot Isolation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'SQL Server has a default transaction isolation mode that locks entire tables,
    and causes even mildly concurrent applications to have long held locks and frequent
    deadlocks. Enabling snapshot isolation for the database as a whole is recommended
    for modern levels of concurrency support. This is accomplished via the following
    ALTER DATABASE commands executed at the SQL prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: Background on SQL Server snapshot isolation is available at [https://msdn.microsoft.com/en-us/library/ms175095.aspx](https://msdn.microsoft.com/en-us/library/ms175095.aspx).
  prefs: []
  type: TYPE_NORMAL
- en: SQL Server SQL Constructs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '| Object Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| [try_cast](#sqlalchemy.dialects.mssql.try_cast)(expression, type_) | Produce
    a `TRY_CAST` expression for backends which support it; this is a `CAST` which
    returns NULL for un-castable conversions. |'
  prefs: []
  type: TYPE_TB
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: Produce a `TRY_CAST` expression for backends which support it; this is a `CAST`
    which returns NULL for un-castable conversions.
  prefs: []
  type: TYPE_NORMAL
- en: In SQLAlchemy, this construct is supported **only** by the SQL Server dialect,
    and will raise a [`CompileError`](../core/exceptions.html#sqlalchemy.exc.CompileError
    "sqlalchemy.exc.CompileError") if used on other included backends. However, third
    party backends may also support this construct.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: As [`try_cast()`](../core/sqlelement.html#sqlalchemy.sql.expression.try_cast
    "sqlalchemy.sql.expression.try_cast") originates from the SQL Server dialect,
    it’s importable both from `sqlalchemy.` as well as from `sqlalchemy.dialects.mssql`.
  prefs: []
  type: TYPE_NORMAL
- en: '[`try_cast()`](../core/sqlelement.html#sqlalchemy.sql.expression.try_cast "sqlalchemy.sql.expression.try_cast")
    returns an instance of [`TryCast`](../core/sqlelement.html#sqlalchemy.sql.expression.TryCast
    "sqlalchemy.sql.expression.TryCast") and generally behaves similarly to the [`Cast`](../core/sqlelement.html#sqlalchemy.sql.expression.Cast
    "sqlalchemy.sql.expression.Cast") construct; at the SQL level, the difference
    between `CAST` and `TRY_CAST` is that `TRY_CAST` returns NULL for an un-castable
    expression, such as attempting to cast a string `"hi"` to an integer value.'
  prefs: []
  type: TYPE_NORMAL
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: 'The above would render on Microsoft SQL Server as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: 'New in version 2.0.14: [`try_cast()`](#sqlalchemy.dialects.mssql.try_cast "sqlalchemy.dialects.mssql.try_cast")
    has been generalized from the SQL Server dialect into a general use construct
    that may be supported by additional dialects.'
  prefs: []
  type: TYPE_NORMAL
- en: SQL Server Data Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As with all SQLAlchemy dialects, all UPPERCASE types that are known to be valid
    with SQL server are importable from the top level dialect, whether they originate
    from [`sqlalchemy.types`](../core/type_basics.html#module-sqlalchemy.types "sqlalchemy.types")
    or from the local dialect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: 'Types which are specific to SQL Server, or have SQL Server-specific construction
    arguments, are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Object Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| [BIT](#sqlalchemy.dialects.mssql.BIT) | MSSQL BIT type. |'
  prefs: []
  type: TYPE_TB
- en: '| [DATETIME2](#sqlalchemy.dialects.mssql.DATETIME2) |  |'
  prefs: []
  type: TYPE_TB
- en: '| [DATETIMEOFFSET](#sqlalchemy.dialects.mssql.DATETIMEOFFSET) |  |'
  prefs: []
  type: TYPE_TB
- en: '| [DOUBLE_PRECISION](#sqlalchemy.dialects.mssql.DOUBLE_PRECISION) | the SQL
    Server DOUBLE PRECISION datatype. |'
  prefs: []
  type: TYPE_TB
- en: '| [IMAGE](#sqlalchemy.dialects.mssql.IMAGE) |  |'
  prefs: []
  type: TYPE_TB
- en: '| [JSON](#sqlalchemy.dialects.mssql.JSON) | MSSQL JSON type. |'
  prefs: []
  type: TYPE_TB
- en: '| [MONEY](#sqlalchemy.dialects.mssql.MONEY) |  |'
  prefs: []
  type: TYPE_TB
- en: '| [NTEXT](#sqlalchemy.dialects.mssql.NTEXT) | MSSQL NTEXT type, for variable-length
    unicode text up to 2^30 characters. |'
  prefs: []
  type: TYPE_TB
- en: '| [REAL](#sqlalchemy.dialects.mssql.REAL) | the SQL Server REAL datatype. |'
  prefs: []
  type: TYPE_TB
- en: '| [ROWVERSION](#sqlalchemy.dialects.mssql.ROWVERSION) | Implement the SQL Server
    ROWVERSION type. |'
  prefs: []
  type: TYPE_TB
- en: '| [SMALLDATETIME](#sqlalchemy.dialects.mssql.SMALLDATETIME) |  |'
  prefs: []
  type: TYPE_TB
- en: '| [SMALLMONEY](#sqlalchemy.dialects.mssql.SMALLMONEY) |  |'
  prefs: []
  type: TYPE_TB
- en: '| [SQL_VARIANT](#sqlalchemy.dialects.mssql.SQL_VARIANT) |  |'
  prefs: []
  type: TYPE_TB
- en: '| [TIME](#sqlalchemy.dialects.mssql.TIME) |  |'
  prefs: []
  type: TYPE_TB
- en: '| [TIMESTAMP](#sqlalchemy.dialects.mssql.TIMESTAMP) | Implement the SQL Server
    TIMESTAMP type. |'
  prefs: []
  type: TYPE_TB
- en: '| [TINYINT](#sqlalchemy.dialects.mssql.TINYINT) |  |'
  prefs: []
  type: TYPE_TB
- en: '| [UNIQUEIDENTIFIER](#sqlalchemy.dialects.mssql.UNIQUEIDENTIFIER) |  |'
  prefs: []
  type: TYPE_TB
- en: '| [XML](#sqlalchemy.dialects.mssql.XML) | MSSQL XML type. |'
  prefs: []
  type: TYPE_TB
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: MSSQL BIT type.
  prefs: []
  type: TYPE_NORMAL
- en: Both pyodbc and pymssql return values from BIT columns as Python <class ‘bool’>
    so just subclass Boolean.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.dialects.mssql.BIT.__init__)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.mssql.BIT`](#sqlalchemy.dialects.mssql.BIT "sqlalchemy.dialects.mssql.BIT")
    ([`sqlalchemy.types.Boolean`](../core/type_basics.html#sqlalchemy.types.Boolean
    "sqlalchemy.types.Boolean"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `sqlalchemy.types.Boolean.__init__` *method of* [`Boolean`](../core/type_basics.html#sqlalchemy.types.Boolean
    "sqlalchemy.types.Boolean")'
  prefs: []
  type: TYPE_NORMAL
- en: Construct a Boolean.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`create_constraint` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: defaults to False. If the boolean is generated as an int/smallint, also create
    a CHECK constraint on the table that ensures 1 or 0 as a value.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: it is strongly recommended that the CHECK constraint have an explicit name in
    order to support schema-management concerns. This can be established either by
    setting the [`Boolean.name`](../core/type_basics.html#sqlalchemy.types.Boolean.params.name
    "sqlalchemy.types.Boolean") parameter or by setting up an appropriate naming convention;
    see [Configuring Constraint Naming Conventions](../core/constraints.html#constraint-naming-conventions)
    for background.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Changed in version 1.4: - this flag now defaults to False, meaning no CHECK
    constraint is generated for a non-native enumerated type.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`name` – if a CHECK constraint is generated, specify the name of the constraint.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: The SQL CHAR type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class `sqlalchemy.dialects.mssql.CHAR` ([`sqlalchemy.types.String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `sqlalchemy.types.String.__init__` *method of* [`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String")'
  prefs: []
  type: TYPE_NORMAL
- en: Create a string-holding type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`length` – optional, a length for the column for use in DDL and CAST expressions.
    May be safely omitted if no `CREATE TABLE` will be issued. Certain databases may
    require a `length` for use in DDL, and will raise an exception when the `CREATE
    TABLE` DDL is issued if a `VARCHAR` with no length is included. Whether the value
    is interpreted as bytes or characters is database specific.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`collation` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Optional, a column-level collation for use in DDL and CAST expressions. Renders
    using the COLLATE keyword supported by SQLite, MySQL, and PostgreSQL. E.g.:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE187]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In most cases, the [`Unicode`](../core/type_basics.html#sqlalchemy.types.Unicode
    "sqlalchemy.types.Unicode") or [`UnicodeText`](../core/type_basics.html#sqlalchemy.types.UnicodeText
    "sqlalchemy.types.UnicodeText") datatypes should be used for a [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") that expects to store non-ascii data. These datatypes
    will ensure that the correct types are used on the database.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.mssql.DATETIME2`](#sqlalchemy.dialects.mssql.DATETIME2
    "sqlalchemy.dialects.mssql.DATETIME2") (`sqlalchemy.dialects.mssql.base._DateTimeBase`,
    [`sqlalchemy.types.DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime
    "sqlalchemy.types.DateTime"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.mssql.DATETIMEOFFSET`](#sqlalchemy.dialects.mssql.DATETIMEOFFSET
    "sqlalchemy.dialects.mssql.DATETIMEOFFSET") (`sqlalchemy.dialects.mssql.base._DateTimeBase`,
    [`sqlalchemy.types.DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime
    "sqlalchemy.types.DateTime"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: the SQL Server DOUBLE PRECISION datatype.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.11.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.mssql.DOUBLE_PRECISION`](#sqlalchemy.dialects.mssql.DOUBLE_PRECISION
    "sqlalchemy.dialects.mssql.DOUBLE_PRECISION") ([`sqlalchemy.types.DOUBLE_PRECISION`](../core/type_basics.html#sqlalchemy.types.DOUBLE_PRECISION
    "sqlalchemy.types.DOUBLE_PRECISION"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.dialects.mssql.IMAGE.__init__)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.mssql.IMAGE`](#sqlalchemy.dialects.mssql.IMAGE "sqlalchemy.dialects.mssql.IMAGE")
    ([`sqlalchemy.types.LargeBinary`](../core/type_basics.html#sqlalchemy.types.LargeBinary
    "sqlalchemy.types.LargeBinary"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `sqlalchemy.types.LargeBinary.__init__` *method of* [`LargeBinary`](../core/type_basics.html#sqlalchemy.types.LargeBinary
    "sqlalchemy.types.LargeBinary")'
  prefs: []
  type: TYPE_NORMAL
- en: Construct a LargeBinary type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**length** – optional, a length for the column for use in DDL statements, for
    those binary types that accept a length, such as the MySQL BLOB type.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: MSSQL JSON type.
  prefs: []
  type: TYPE_NORMAL
- en: MSSQL supports JSON-formatted data as of SQL Server 2016.
  prefs: []
  type: TYPE_NORMAL
- en: The [`JSON`](#sqlalchemy.dialects.mssql.JSON "sqlalchemy.dialects.mssql.JSON")
    datatype at the DDL level will represent the datatype as `NVARCHAR(max)`, but
    provides for JSON-level comparison functions as well as Python coercion behavior.
  prefs: []
  type: TYPE_NORMAL
- en: '[`JSON`](#sqlalchemy.dialects.mssql.JSON "sqlalchemy.dialects.mssql.JSON")
    is used automatically whenever the base [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON") datatype is used against a SQL Server backend.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON")
    - main documentation for the generic cross-platform JSON datatype.'
  prefs: []
  type: TYPE_NORMAL
- en: The [`JSON`](#sqlalchemy.dialects.mssql.JSON "sqlalchemy.dialects.mssql.JSON")
    type supports persistence of JSON values as well as the core index operations
    provided by [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON")
    datatype, by adapting the operations to render the `JSON_VALUE` or `JSON_QUERY`
    functions at the database level.
  prefs: []
  type: TYPE_NORMAL
- en: The SQL Server [`JSON`](#sqlalchemy.dialects.mssql.JSON "sqlalchemy.dialects.mssql.JSON")
    type necessarily makes use of the `JSON_QUERY` and `JSON_VALUE` functions when
    querying for elements of a JSON object. These two functions have a major restriction
    in that they are **mutually exclusive** based on the type of object to be returned.
    The `JSON_QUERY` function **only** returns a JSON dictionary or list, but not
    an individual string, numeric, or boolean element; the `JSON_VALUE` function **only**
    returns an individual string, numeric, or boolean element. **both functions either
    return NULL or raise an error if they are not used against the correct expected
    value**.
  prefs: []
  type: TYPE_NORMAL
- en: 'To handle this awkward requirement, indexed access rules are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'When extracting a sub element from a JSON that is itself a JSON dictionary
    or list, the [`Comparator.as_json()`](../core/type_basics.html#sqlalchemy.types.JSON.Comparator.as_json
    "sqlalchemy.types.JSON.Comparator.as_json") accessor should be used:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE194]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When extracting a sub element from a JSON that is a plain boolean, string,
    integer, or float, use the appropriate method among [`Comparator.as_boolean()`](../core/type_basics.html#sqlalchemy.types.JSON.Comparator.as_boolean
    "sqlalchemy.types.JSON.Comparator.as_boolean"), [`Comparator.as_string()`](../core/type_basics.html#sqlalchemy.types.JSON.Comparator.as_string
    "sqlalchemy.types.JSON.Comparator.as_string"), [`Comparator.as_integer()`](../core/type_basics.html#sqlalchemy.types.JSON.Comparator.as_integer
    "sqlalchemy.types.JSON.Comparator.as_integer"), [`Comparator.as_float()`](../core/type_basics.html#sqlalchemy.types.JSON.Comparator.as_float
    "sqlalchemy.types.JSON.Comparator.as_float"):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE195]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: New in version 1.4.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.dialects.mssql.JSON.__init__)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.mssql.JSON`](#sqlalchemy.dialects.mssql.JSON "sqlalchemy.dialects.mssql.JSON")
    ([`sqlalchemy.types.JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `sqlalchemy.types.JSON.__init__` *method of* [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON")'
  prefs: []
  type: TYPE_NORMAL
- en: Construct a [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON")
    type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**none_as_null=False** –'
  prefs: []
  type: TYPE_NORMAL
- en: 'if True, persist the value `None` as a SQL NULL value, not the JSON encoding
    of `null`. Note that when this flag is False, the [`null()`](../core/sqlelement.html#sqlalchemy.sql.expression.null
    "sqlalchemy.sql.expression.null") construct can still be used to persist a NULL
    value, which may be passed directly as a parameter value that is specially interpreted
    by the [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON")
    type as SQL NULL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '[`JSON.none_as_null`](../core/type_basics.html#sqlalchemy.types.JSON.params.none_as_null
    "sqlalchemy.types.JSON") does **not** apply to the values passed to [`Column.default`](../core/metadata.html#sqlalchemy.schema.Column.params.default
    "sqlalchemy.schema.Column") and [`Column.server_default`](../core/metadata.html#sqlalchemy.schema.Column.params.server_default
    "sqlalchemy.schema.Column"); a value of `None` passed for these parameters means
    “no default present”.'
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, when used in SQL comparison expressions, the Python value `None`
    continues to refer to SQL null, and not JSON NULL. The [`JSON.none_as_null`](../core/type_basics.html#sqlalchemy.types.JSON.params.none_as_null
    "sqlalchemy.types.JSON") flag refers explicitly to the **persistence** of the
    value within an INSERT or UPDATE statement. The [`JSON.NULL`](../core/type_basics.html#sqlalchemy.types.JSON.NULL
    "sqlalchemy.types.JSON.NULL") value should be used for SQL expressions that wish
    to compare to JSON null.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`JSON.NULL`](../core/type_basics.html#sqlalchemy.types.JSON.NULL "sqlalchemy.types.JSON.NULL")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.mssql.MONEY`](#sqlalchemy.dialects.mssql.MONEY "sqlalchemy.dialects.mssql.MONEY")
    ([`sqlalchemy.types.TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: The SQL NCHAR type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class `sqlalchemy.dialects.mssql.NCHAR` ([`sqlalchemy.types.Unicode`](../core/type_basics.html#sqlalchemy.types.Unicode
    "sqlalchemy.types.Unicode"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `sqlalchemy.types.String.__init__` *method of* [`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String")'
  prefs: []
  type: TYPE_NORMAL
- en: Create a string-holding type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`length` – optional, a length for the column for use in DDL and CAST expressions.
    May be safely omitted if no `CREATE TABLE` will be issued. Certain databases may
    require a `length` for use in DDL, and will raise an exception when the `CREATE
    TABLE` DDL is issued if a `VARCHAR` with no length is included. Whether the value
    is interpreted as bytes or characters is database specific.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`collation` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Optional, a column-level collation for use in DDL and CAST expressions. Renders
    using the COLLATE keyword supported by SQLite, MySQL, and PostgreSQL. E.g.:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE201]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In most cases, the [`Unicode`](../core/type_basics.html#sqlalchemy.types.Unicode
    "sqlalchemy.types.Unicode") or [`UnicodeText`](../core/type_basics.html#sqlalchemy.types.UnicodeText
    "sqlalchemy.types.UnicodeText") datatypes should be used for a [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") that expects to store non-ascii data. These datatypes
    will ensure that the correct types are used on the database.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: MSSQL NTEXT type, for variable-length unicode text up to 2^30 characters.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.dialects.mssql.NTEXT.__init__)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.mssql.NTEXT`](#sqlalchemy.dialects.mssql.NTEXT "sqlalchemy.dialects.mssql.NTEXT")
    ([`sqlalchemy.types.UnicodeText`](../core/type_basics.html#sqlalchemy.types.UnicodeText
    "sqlalchemy.types.UnicodeText"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `sqlalchemy.types.String.__init__` *method of* [`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String")'
  prefs: []
  type: TYPE_NORMAL
- en: Create a string-holding type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`length` – optional, a length for the column for use in DDL and CAST expressions.
    May be safely omitted if no `CREATE TABLE` will be issued. Certain databases may
    require a `length` for use in DDL, and will raise an exception when the `CREATE
    TABLE` DDL is issued if a `VARCHAR` with no length is included. Whether the value
    is interpreted as bytes or characters is database specific.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`collation` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Optional, a column-level collation for use in DDL and CAST expressions. Renders
    using the COLLATE keyword supported by SQLite, MySQL, and PostgreSQL. E.g.:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE204]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In most cases, the [`Unicode`](../core/type_basics.html#sqlalchemy.types.Unicode
    "sqlalchemy.types.Unicode") or [`UnicodeText`](../core/type_basics.html#sqlalchemy.types.UnicodeText
    "sqlalchemy.types.UnicodeText") datatypes should be used for a [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") that expects to store non-ascii data. These datatypes
    will ensure that the correct types are used on the database.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: The SQL NVARCHAR type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class `sqlalchemy.dialects.mssql.NVARCHAR` ([`sqlalchemy.types.Unicode`](../core/type_basics.html#sqlalchemy.types.Unicode
    "sqlalchemy.types.Unicode"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `sqlalchemy.types.String.__init__` *method of* [`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String")'
  prefs: []
  type: TYPE_NORMAL
- en: Create a string-holding type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`length` – optional, a length for the column for use in DDL and CAST expressions.
    May be safely omitted if no `CREATE TABLE` will be issued. Certain databases may
    require a `length` for use in DDL, and will raise an exception when the `CREATE
    TABLE` DDL is issued if a `VARCHAR` with no length is included. Whether the value
    is interpreted as bytes or characters is database specific.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`collation` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Optional, a column-level collation for use in DDL and CAST expressions. Renders
    using the COLLATE keyword supported by SQLite, MySQL, and PostgreSQL. E.g.:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE207]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In most cases, the [`Unicode`](../core/type_basics.html#sqlalchemy.types.Unicode
    "sqlalchemy.types.Unicode") or [`UnicodeText`](../core/type_basics.html#sqlalchemy.types.UnicodeText
    "sqlalchemy.types.UnicodeText") datatypes should be used for a [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") that expects to store non-ascii data. These datatypes
    will ensure that the correct types are used on the database.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: the SQL Server REAL datatype.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.mssql.REAL`](#sqlalchemy.dialects.mssql.REAL "sqlalchemy.dialects.mssql.REAL")
    ([`sqlalchemy.types.REAL`](../core/type_basics.html#sqlalchemy.types.REAL "sqlalchemy.types.REAL"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: Implement the SQL Server ROWVERSION type.
  prefs: []
  type: TYPE_NORMAL
- en: The ROWVERSION datatype is a SQL Server synonym for the TIMESTAMP datatype,
    however current SQL Server documentation suggests using ROWVERSION for new datatypes
    going forward.
  prefs: []
  type: TYPE_NORMAL
- en: The ROWVERSION datatype does **not** reflect (e.g. introspect) from the database
    as itself; the returned datatype will be [`TIMESTAMP`](#sqlalchemy.dialects.mssql.TIMESTAMP
    "sqlalchemy.dialects.mssql.TIMESTAMP").
  prefs: []
  type: TYPE_NORMAL
- en: This is a read-only datatype that does not support INSERT of values.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.2.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`TIMESTAMP`](#sqlalchemy.dialects.mssql.TIMESTAMP "sqlalchemy.dialects.mssql.TIMESTAMP")'
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.dialects.mssql.ROWVERSION.__init__)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.mssql.ROWVERSION`](#sqlalchemy.dialects.mssql.ROWVERSION
    "sqlalchemy.dialects.mssql.ROWVERSION") ([`sqlalchemy.dialects.mssql.base.TIMESTAMP`](#sqlalchemy.dialects.mssql.TIMESTAMP
    "sqlalchemy.dialects.mssql.base.TIMESTAMP"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `sqlalchemy.dialects.mssql.base.TIMESTAMP.__init__` *method
    of* [`TIMESTAMP`](#sqlalchemy.dialects.mssql.TIMESTAMP "sqlalchemy.dialects.mssql.base.TIMESTAMP")'
  prefs: []
  type: TYPE_NORMAL
- en: Construct a TIMESTAMP or ROWVERSION type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**convert_int** – if True, binary integer values will be converted to integers
    on read.'
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.2.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.dialects.mssql.SMALLDATETIME.__init__)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.mssql.SMALLDATETIME`](#sqlalchemy.dialects.mssql.SMALLDATETIME
    "sqlalchemy.dialects.mssql.SMALLDATETIME") (`sqlalchemy.dialects.mssql.base._DateTimeBase`,
    [`sqlalchemy.types.DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime
    "sqlalchemy.types.DateTime"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `sqlalchemy.types.DateTime.__init__` *method of* [`DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime
    "sqlalchemy.types.DateTime")'
  prefs: []
  type: TYPE_NORMAL
- en: Construct a new [`DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime
    "sqlalchemy.types.DateTime").
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**timezone** – boolean. Indicates that the datetime type should enable timezone
    support, if available on the **base date/time-holding type only**. It is recommended
    to make use of the [`TIMESTAMP`](../core/type_basics.html#sqlalchemy.types.TIMESTAMP
    "sqlalchemy.types.TIMESTAMP") datatype directly when using this flag, as some
    databases include separate generic date/time-holding types distinct from the timezone-capable
    TIMESTAMP datatype, such as Oracle.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.mssql.SMALLMONEY`](#sqlalchemy.dialects.mssql.SMALLMONEY
    "sqlalchemy.dialects.mssql.SMALLMONEY") ([`sqlalchemy.types.TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.mssql.SQL_VARIANT`](#sqlalchemy.dialects.mssql.SQL_VARIANT
    "sqlalchemy.dialects.mssql.SQL_VARIANT") ([`sqlalchemy.types.TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: The SQL TEXT type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class `sqlalchemy.dialects.mssql.TEXT` ([`sqlalchemy.types.Text`](../core/type_basics.html#sqlalchemy.types.Text
    "sqlalchemy.types.Text"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `sqlalchemy.types.String.__init__` *method of* [`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String")'
  prefs: []
  type: TYPE_NORMAL
- en: Create a string-holding type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`length` – optional, a length for the column for use in DDL and CAST expressions.
    May be safely omitted if no `CREATE TABLE` will be issued. Certain databases may
    require a `length` for use in DDL, and will raise an exception when the `CREATE
    TABLE` DDL is issued if a `VARCHAR` with no length is included. Whether the value
    is interpreted as bytes or characters is database specific.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`collation` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Optional, a column-level collation for use in DDL and CAST expressions. Renders
    using the COLLATE keyword supported by SQLite, MySQL, and PostgreSQL. E.g.:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE217]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In most cases, the [`Unicode`](../core/type_basics.html#sqlalchemy.types.Unicode
    "sqlalchemy.types.Unicode") or [`UnicodeText`](../core/type_basics.html#sqlalchemy.types.UnicodeText
    "sqlalchemy.types.UnicodeText") datatypes should be used for a [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") that expects to store non-ascii data. These datatypes
    will ensure that the correct types are used on the database.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.mssql.TIME`](#sqlalchemy.dialects.mssql.TIME "sqlalchemy.dialects.mssql.TIME")
    ([`sqlalchemy.types.TIME`](../core/type_basics.html#sqlalchemy.types.TIME "sqlalchemy.types.TIME"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: Implement the SQL Server TIMESTAMP type.
  prefs: []
  type: TYPE_NORMAL
- en: Note this is **completely different** than the SQL Standard TIMESTAMP type,
    which is not supported by SQL Server. It is a read-only datatype that does not
    support INSERT of values.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.2.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`ROWVERSION`](#sqlalchemy.dialects.mssql.ROWVERSION "sqlalchemy.dialects.mssql.ROWVERSION")'
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.dialects.mssql.TIMESTAMP.__init__)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.mssql.TIMESTAMP`](#sqlalchemy.dialects.mssql.TIMESTAMP
    "sqlalchemy.dialects.mssql.TIMESTAMP") (`sqlalchemy.types._Binary`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: Construct a TIMESTAMP or ROWVERSION type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**convert_int** – if True, binary integer values will be converted to integers
    on read.'
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.2.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.mssql.TINYINT`](#sqlalchemy.dialects.mssql.TINYINT
    "sqlalchemy.dialects.mssql.TINYINT") ([`sqlalchemy.types.Integer`](../core/type_basics.html#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.dialects.mssql.UNIQUEIDENTIFIER.__init__)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.mssql.UNIQUEIDENTIFIER`](#sqlalchemy.dialects.mssql.UNIQUEIDENTIFIER
    "sqlalchemy.dialects.mssql.UNIQUEIDENTIFIER") ([`sqlalchemy.types.Uuid`](../core/type_basics.html#sqlalchemy.types.Uuid
    "sqlalchemy.types.Uuid"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: Construct a [`UNIQUEIDENTIFIER`](#sqlalchemy.dialects.mssql.UNIQUEIDENTIFIER
    "sqlalchemy.dialects.mssql.UNIQUEIDENTIFIER") type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**as_uuid=True** –'
  prefs: []
  type: TYPE_NORMAL
- en: if True, values will be interpreted as Python uuid objects, converting to/from
    string via the DBAPI.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: The MSSQL VARBINARY type.
  prefs: []
  type: TYPE_NORMAL
- en: This type adds additional features to the core [`VARBINARY`](../core/type_basics.html#sqlalchemy.types.VARBINARY
    "sqlalchemy.types.VARBINARY") type, including “deprecate_large_types” mode where
    either `VARBINARY(max)` or IMAGE is rendered, as well as the SQL Server `FILESTREAM`
    option.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Large Text/Binary Type Deprecation](#mssql-large-type-deprecation)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class `sqlalchemy.dialects.mssql.VARBINARY` ([`sqlalchemy.types.VARBINARY`](../core/type_basics.html#sqlalchemy.types.VARBINARY
    "sqlalchemy.types.VARBINARY"), [`sqlalchemy.types.LargeBinary`](../core/type_basics.html#sqlalchemy.types.LargeBinary
    "sqlalchemy.types.LargeBinary"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE225]'
  prefs: []
  type: TYPE_PRE
- en: Construct a VARBINARY type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`length` – optional, a length for the column for use in DDL statements, for
    those binary types that accept a length, such as the MySQL BLOB type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`filestream=False` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: if True, renders the `FILESTREAM` keyword in the table definition. In this case
    `length` must be `None` or `'max'`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: New in version 1.4.31.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: The SQL VARCHAR type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class `sqlalchemy.dialects.mssql.VARCHAR` ([`sqlalchemy.types.String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE227]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `sqlalchemy.types.String.__init__` *method of* [`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String")'
  prefs: []
  type: TYPE_NORMAL
- en: Create a string-holding type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`length` – optional, a length for the column for use in DDL and CAST expressions.
    May be safely omitted if no `CREATE TABLE` will be issued. Certain databases may
    require a `length` for use in DDL, and will raise an exception when the `CREATE
    TABLE` DDL is issued if a `VARCHAR` with no length is included. Whether the value
    is interpreted as bytes or characters is database specific.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`collation` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Optional, a column-level collation for use in DDL and CAST expressions. Renders
    using the COLLATE keyword supported by SQLite, MySQL, and PostgreSQL. E.g.:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE228]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In most cases, the [`Unicode`](../core/type_basics.html#sqlalchemy.types.Unicode
    "sqlalchemy.types.Unicode") or [`UnicodeText`](../core/type_basics.html#sqlalchemy.types.UnicodeText
    "sqlalchemy.types.UnicodeText") datatypes should be used for a [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") that expects to store non-ascii data. These datatypes
    will ensure that the correct types are used on the database.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE229]'
  prefs: []
  type: TYPE_PRE
- en: MSSQL XML type.
  prefs: []
  type: TYPE_NORMAL
- en: This is a placeholder type for reflection purposes that does not include any
    Python-side datatype support. It also does not currently support additional arguments,
    such as “CONTENT”, “DOCUMENT”, “xml_schema_collection”.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.dialects.mssql.XML.__init__)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.mssql.XML`](#sqlalchemy.dialects.mssql.XML "sqlalchemy.dialects.mssql.XML")
    ([`sqlalchemy.types.Text`](../core/type_basics.html#sqlalchemy.types.Text "sqlalchemy.types.Text"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE230]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `sqlalchemy.types.String.__init__` *method of* [`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String")'
  prefs: []
  type: TYPE_NORMAL
- en: Create a string-holding type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`length` – optional, a length for the column for use in DDL and CAST expressions.
    May be safely omitted if no `CREATE TABLE` will be issued. Certain databases may
    require a `length` for use in DDL, and will raise an exception when the `CREATE
    TABLE` DDL is issued if a `VARCHAR` with no length is included. Whether the value
    is interpreted as bytes or characters is database specific.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`collation` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Optional, a column-level collation for use in DDL and CAST expressions. Renders
    using the COLLATE keyword supported by SQLite, MySQL, and PostgreSQL. E.g.:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE231]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In most cases, the [`Unicode`](../core/type_basics.html#sqlalchemy.types.Unicode
    "sqlalchemy.types.Unicode") or [`UnicodeText`](../core/type_basics.html#sqlalchemy.types.UnicodeText
    "sqlalchemy.types.UnicodeText") datatypes should be used for a [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") that expects to store non-ascii data. These datatypes
    will ensure that the correct types are used on the database.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '## PyODBC'
  prefs: []
  type: TYPE_NORMAL
- en: Support for the Microsoft SQL Server database via the PyODBC driver.
  prefs: []
  type: TYPE_NORMAL
- en: DBAPI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Documentation and download information (if applicable) for PyODBC is available
    at: [https://pypi.org/project/pyodbc/](https://pypi.org/project/pyodbc/)'
  prefs: []
  type: TYPE_NORMAL
- en: Connecting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Connect String:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE232]'
  prefs: []
  type: TYPE_PRE
- en: Connecting to PyODBC
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The URL here is to be translated to PyODBC connection strings, as detailed in
    [ConnectionStrings](https://code.google.com/p/pyodbc/wiki/ConnectionStrings).
  prefs: []
  type: TYPE_NORMAL
- en: DSN Connections
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A DSN connection in ODBC means that a pre-existing ODBC datasource is configured
    on the client machine. The application then specifies the name of this datasource,
    which encompasses details such as the specific ODBC driver in use as well as the
    network address of the database. Assuming a datasource is configured on the client,
    a basic DSN-based connection looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE233]'
  prefs: []
  type: TYPE_PRE
- en: 'Which above, will pass the following connection string to PyODBC:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE234]'
  prefs: []
  type: TYPE_PRE
- en: If the username and password are omitted, the DSN form will also add the `Trusted_Connection=yes`
    directive to the ODBC string.
  prefs: []
  type: TYPE_NORMAL
- en: Hostname Connections
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Hostname-based connections are also supported by pyodbc. These are often easier
    to use than a DSN and have the additional advantage that the specific database
    name to connect towards may be specified locally in the URL, rather than it being
    fixed as part of a datasource configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using a hostname connection, the driver name must also be specified in
    the query parameters of the URL. As these names usually have spaces in them, the
    name must be URL encoded which means using plus signs for spaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE235]'
  prefs: []
  type: TYPE_PRE
- en: The `driver` keyword is significant to the pyodbc dialect and must be specified
    in lowercase.
  prefs: []
  type: TYPE_NORMAL
- en: 'Any other names passed in the query string are passed through in the pyodbc
    connect string, such as `authentication`, `TrustServerCertificate`, etc. Multiple
    keyword arguments must be separated by an ampersand (`&`); these will be translated
    to semicolons when the pyodbc connect string is generated internally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE236]'
  prefs: []
  type: TYPE_PRE
- en: 'The equivalent URL can be constructed using [`URL`](../core/engines.html#sqlalchemy.engine.URL
    "sqlalchemy.engine.URL"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE237]'
  prefs: []
  type: TYPE_PRE
- en: Pass through exact Pyodbc string
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A PyODBC connection string can also be sent in pyodbc’s format directly, as
    specified in [the PyODBC documentation](https://github.com/mkleehammer/pyodbc/wiki/Connecting-to-databases),
    using the parameter `odbc_connect`. A [`URL`](../core/engines.html#sqlalchemy.engine.URL
    "sqlalchemy.engine.URL") object can help make this easier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE238]'
  prefs: []
  type: TYPE_PRE
- en: '#### Connecting to databases with access tokens'
  prefs: []
  type: TYPE_NORMAL
- en: Some database servers are set up to only accept access tokens for login. For
    example, SQL Server allows the use of Azure Active Directory tokens to connect
    to databases. This requires creating a credential object using the `azure-identity`
    library. More information about the authentication step can be found in [Microsoft’s
    documentation](https://docs.microsoft.com/en-us/azure/developer/python/azure-sdk-authenticate?tabs=bash).
  prefs: []
  type: TYPE_NORMAL
- en: After getting an engine, the credentials need to be sent to `pyodbc.connect`
    each time a connection is requested. One way to do this is to set up an event
    listener on the engine that adds the credential token to the dialect’s connect
    call. This is discussed more generally in [Generating dynamic authentication tokens](../core/engines.html#engines-dynamic-tokens).
    For SQL Server in particular, this is passed as an ODBC connection attribute with
    a data structure [described by Microsoft](https://docs.microsoft.com/en-us/sql/connect/odbc/using-azure-active-directory#authenticating-with-an-access-token).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet will create an engine that connects to an Azure
    SQL database using Azure credentials:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE239]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Trusted_Connection` token is currently added by the SQLAlchemy pyodbc
    dialect when no username or password is present. This needs to be removed per
    Microsoft’s [documentation for Azure access tokens](https://docs.microsoft.com/en-us/sql/connect/odbc/using-azure-active-directory#authenticating-with-an-access-token),
    stating that a connection string when using an access token must not contain `UID`,
    `PWD`, `Authentication` or `Trusted_Connection` parameters.  #### Avoiding transaction-related
    exceptions on Azure Synapse Analytics'
  prefs: []
  type: TYPE_NORMAL
- en: Azure Synapse Analytics has a significant difference in its transaction handling
    compared to plain SQL Server; in some cases an error within a Synapse transaction
    can cause it to be arbitrarily terminated on the server side, which then causes
    the DBAPI `.rollback()` method (as well as `.commit()`) to fail. The issue prevents
    the usual DBAPI contract of allowing `.rollback()` to pass silently if no transaction
    is present as the driver does not expect this condition. The symptom of this failure
    is an exception with a message resembling ‘No corresponding transaction found.
    (111214)’ when attempting to emit a `.rollback()` after an operation had a failure
    of some kind.
  prefs: []
  type: TYPE_NORMAL
- en: 'This specific case can be handled by passing `ignore_no_transaction_on_rollback=True`
    to the SQL Server dialect via the [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE240]'
  prefs: []
  type: TYPE_PRE
- en: Using the above parameter, the dialect will catch `ProgrammingError` exceptions
    raised during `connection.rollback()` and emit a warning if the error message
    contains code `111214`, however will not raise an exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 1.4.40: Added the `ignore_no_transaction_on_rollback=True` parameter.'
  prefs: []
  type: TYPE_NORMAL
- en: Enable autocommit for Azure SQL Data Warehouse (DW) connections
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Azure SQL Data Warehouse does not support transactions, and that can cause
    problems with SQLAlchemy’s “autobegin” (and implicit commit/rollback) behavior.
    We can avoid these problems by enabling autocommit at both the pyodbc and engine
    levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE241]'
  prefs: []
  type: TYPE_PRE
- en: Avoiding sending large string parameters as TEXT/NTEXT
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: By default, for historical reasons, Microsoft’s ODBC drivers for SQL Server
    send long string parameters (greater than 4000 SBCS characters or 2000 Unicode
    characters) as TEXT/NTEXT values. TEXT and NTEXT have been deprecated for many
    years and are starting to cause compatibility issues with newer versions of SQL_Server/Azure.
    For example, see [this issue](https://github.com/mkleehammer/pyodbc/issues/835).
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting with ODBC Driver 18 for SQL Server we can override the legacy behavior
    and pass long strings as varchar(max)/nvarchar(max) using the `LongAsMax=Yes`
    connection string parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE242]'
  prefs: []
  type: TYPE_PRE
- en: Pyodbc Pooling / connection close behavior
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'PyODBC uses internal [pooling](https://github.com/mkleehammer/pyodbc/wiki/The-pyodbc-Module#pooling)
    by default, which means connections will be longer lived than they are within
    SQLAlchemy itself. As SQLAlchemy has its own pooling behavior, it is often preferable
    to disable this behavior. This behavior can only be disabled globally at the PyODBC
    module level, **before** any connections are made:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE243]'
  prefs: []
  type: TYPE_PRE
- en: If this variable is left at its default value of `True`, **the application will
    continue to maintain active database connections**, even when the SQLAlchemy engine
    itself fully discards a connection or if the engine is disposed.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[pooling](https://github.com/mkleehammer/pyodbc/wiki/The-pyodbc-Module#pooling)
    - in the PyODBC documentation.'
  prefs: []
  type: TYPE_NORMAL
- en: Driver / Unicode Support
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: PyODBC works best with Microsoft ODBC drivers, particularly in the area of Unicode
    support on both Python 2 and Python 3.
  prefs: []
  type: TYPE_NORMAL
- en: Using the FreeTDS ODBC drivers on Linux or OSX with PyODBC is **not** recommended;
    there have been historically many Unicode-related issues in this area, including
    before Microsoft offered ODBC drivers for Linux and OSX. Now that Microsoft offers
    drivers for all platforms, for PyODBC support these are recommended. FreeTDS remains
    relevant for non-ODBC drivers such as pymssql where it works very well.
  prefs: []
  type: TYPE_NORMAL
- en: Rowcount Support
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Previous limitations with the SQLAlchemy ORM’s “versioned rows” feature with
    Pyodbc have been resolved as of SQLAlchemy 2.0.5\. See the notes at [Rowcount
    Support / ORM Versioning](#mssql-rowcount-versioning).
  prefs: []
  type: TYPE_NORMAL
- en: '### Fast Executemany Mode'
  prefs: []
  type: TYPE_NORMAL
- en: 'The PyODBC driver includes support for a “fast executemany” mode of execution
    which greatly reduces round trips for a DBAPI `executemany()` call when using
    Microsoft ODBC drivers, for **limited size batches that fit in memory**. The feature
    is enabled by setting the attribute `.fast_executemany` on the DBAPI cursor when
    an executemany call is to be used. The SQLAlchemy PyODBC SQL Server dialect supports
    this parameter by passing the `fast_executemany` parameter to [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") , when using the **Microsoft ODBC driver only**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE244]'
  prefs: []
  type: TYPE_PRE
- en: 'Changed in version 2.0.9: - the `fast_executemany` parameter now has its intended
    effect of this PyODBC feature taking effect for all INSERT statements that are
    executed with multiple parameter sets, which don’t include RETURNING. Previously,
    SQLAlchemy 2.0’s [insertmanyvalues](../glossary.html#term-insertmanyvalues) feature
    would cause `fast_executemany` to not be used in most cases even if specified.'
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.3.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[fast executemany](https://github.com/mkleehammer/pyodbc/wiki/Features-beyond-the-DB-API#fast_executemany)
    - on github  ### Setinputsizes Support'
  prefs: []
  type: TYPE_NORMAL
- en: As of version 2.0, the pyodbc `cursor.setinputsizes()` method is used for all
    statement executions, except for `cursor.executemany()` calls when fast_executemany=True
    where it is not supported (assuming [insertmanyvalues](../core/connections.html#engine-insertmanyvalues)
    is kept enabled, “fastexecutemany” will not take place for INSERT statements in
    any case).
  prefs: []
  type: TYPE_NORMAL
- en: The use of `cursor.setinputsizes()` can be disabled by passing `use_setinputsizes=False`
    to [`create_engine()`](../core/engines.html#sqlalchemy.create_engine "sqlalchemy.create_engine").
  prefs: []
  type: TYPE_NORMAL
- en: When `use_setinputsizes` is left at its default of `True`, the specific per-type
    symbols passed to `cursor.setinputsizes()` can be programmatically customized
    using the [`DialectEvents.do_setinputsizes()`](../core/events.html#sqlalchemy.events.DialectEvents.do_setinputsizes
    "sqlalchemy.events.DialectEvents.do_setinputsizes") hook. See that method for
    usage examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 2.0: The mssql+pyodbc dialect now defaults to using `use_setinputsizes=True`
    for all statement executions with the exception of cursor.executemany() calls
    when fast_executemany=True. The behavior can be turned off by passing `use_setinputsizes=False`
    to [`create_engine()`](../core/engines.html#sqlalchemy.create_engine "sqlalchemy.create_engine").'
  prefs: []
  type: TYPE_NORMAL
- en: DBAPI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Documentation and download information (if applicable) for PyODBC is available
    at: [https://pypi.org/project/pyodbc/](https://pypi.org/project/pyodbc/)'
  prefs: []
  type: TYPE_NORMAL
- en: Connecting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Connect String:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE245]'
  prefs: []
  type: TYPE_PRE
- en: Connecting to PyODBC
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The URL here is to be translated to PyODBC connection strings, as detailed in
    [ConnectionStrings](https://code.google.com/p/pyodbc/wiki/ConnectionStrings).
  prefs: []
  type: TYPE_NORMAL
- en: DSN Connections
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A DSN connection in ODBC means that a pre-existing ODBC datasource is configured
    on the client machine. The application then specifies the name of this datasource,
    which encompasses details such as the specific ODBC driver in use as well as the
    network address of the database. Assuming a datasource is configured on the client,
    a basic DSN-based connection looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE246]'
  prefs: []
  type: TYPE_PRE
- en: 'Which above, will pass the following connection string to PyODBC:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE247]'
  prefs: []
  type: TYPE_PRE
- en: If the username and password are omitted, the DSN form will also add the `Trusted_Connection=yes`
    directive to the ODBC string.
  prefs: []
  type: TYPE_NORMAL
- en: Hostname Connections
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Hostname-based connections are also supported by pyodbc. These are often easier
    to use than a DSN and have the additional advantage that the specific database
    name to connect towards may be specified locally in the URL, rather than it being
    fixed as part of a datasource configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using a hostname connection, the driver name must also be specified in
    the query parameters of the URL. As these names usually have spaces in them, the
    name must be URL encoded which means using plus signs for spaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE248]'
  prefs: []
  type: TYPE_PRE
- en: The `driver` keyword is significant to the pyodbc dialect and must be specified
    in lowercase.
  prefs: []
  type: TYPE_NORMAL
- en: 'Any other names passed in the query string are passed through in the pyodbc
    connect string, such as `authentication`, `TrustServerCertificate`, etc. Multiple
    keyword arguments must be separated by an ampersand (`&`); these will be translated
    to semicolons when the pyodbc connect string is generated internally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE249]'
  prefs: []
  type: TYPE_PRE
- en: 'The equivalent URL can be constructed using [`URL`](../core/engines.html#sqlalchemy.engine.URL
    "sqlalchemy.engine.URL"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE250]'
  prefs: []
  type: TYPE_PRE
- en: Pass through exact Pyodbc string
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A PyODBC connection string can also be sent in pyodbc’s format directly, as
    specified in [the PyODBC documentation](https://github.com/mkleehammer/pyodbc/wiki/Connecting-to-databases),
    using the parameter `odbc_connect`. A [`URL`](../core/engines.html#sqlalchemy.engine.URL
    "sqlalchemy.engine.URL") object can help make this easier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE251]'
  prefs: []
  type: TYPE_PRE
- en: '#### Connecting to databases with access tokens'
  prefs: []
  type: TYPE_NORMAL
- en: Some database servers are set up to only accept access tokens for login. For
    example, SQL Server allows the use of Azure Active Directory tokens to connect
    to databases. This requires creating a credential object using the `azure-identity`
    library. More information about the authentication step can be found in [Microsoft’s
    documentation](https://docs.microsoft.com/en-us/azure/developer/python/azure-sdk-authenticate?tabs=bash).
  prefs: []
  type: TYPE_NORMAL
- en: After getting an engine, the credentials need to be sent to `pyodbc.connect`
    each time a connection is requested. One way to do this is to set up an event
    listener on the engine that adds the credential token to the dialect’s connect
    call. This is discussed more generally in [Generating dynamic authentication tokens](../core/engines.html#engines-dynamic-tokens).
    For SQL Server in particular, this is passed as an ODBC connection attribute with
    a data structure [described by Microsoft](https://docs.microsoft.com/en-us/sql/connect/odbc/using-azure-active-directory#authenticating-with-an-access-token).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet will create an engine that connects to an Azure
    SQL database using Azure credentials:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE252]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Trusted_Connection` token is currently added by the SQLAlchemy pyodbc
    dialect when no username or password is present. This needs to be removed per
    Microsoft’s [documentation for Azure access tokens](https://docs.microsoft.com/en-us/sql/connect/odbc/using-azure-active-directory#authenticating-with-an-access-token),
    stating that a connection string when using an access token must not contain `UID`,
    `PWD`, `Authentication` or `Trusted_Connection` parameters.  #### Avoiding transaction-related
    exceptions on Azure Synapse Analytics'
  prefs: []
  type: TYPE_NORMAL
- en: Azure Synapse Analytics has a significant difference in its transaction handling
    compared to plain SQL Server; in some cases an error within a Synapse transaction
    can cause it to be arbitrarily terminated on the server side, which then causes
    the DBAPI `.rollback()` method (as well as `.commit()`) to fail. The issue prevents
    the usual DBAPI contract of allowing `.rollback()` to pass silently if no transaction
    is present as the driver does not expect this condition. The symptom of this failure
    is an exception with a message resembling ‘No corresponding transaction found.
    (111214)’ when attempting to emit a `.rollback()` after an operation had a failure
    of some kind.
  prefs: []
  type: TYPE_NORMAL
- en: 'This specific case can be handled by passing `ignore_no_transaction_on_rollback=True`
    to the SQL Server dialect via the [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE253]'
  prefs: []
  type: TYPE_PRE
- en: Using the above parameter, the dialect will catch `ProgrammingError` exceptions
    raised during `connection.rollback()` and emit a warning if the error message
    contains code `111214`, however will not raise an exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 1.4.40: Added the `ignore_no_transaction_on_rollback=True` parameter.'
  prefs: []
  type: TYPE_NORMAL
- en: Enable autocommit for Azure SQL Data Warehouse (DW) connections
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Azure SQL Data Warehouse does not support transactions, and that can cause
    problems with SQLAlchemy’s “autobegin” (and implicit commit/rollback) behavior.
    We can avoid these problems by enabling autocommit at both the pyodbc and engine
    levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE254]'
  prefs: []
  type: TYPE_PRE
- en: Avoiding sending large string parameters as TEXT/NTEXT
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: By default, for historical reasons, Microsoft’s ODBC drivers for SQL Server
    send long string parameters (greater than 4000 SBCS characters or 2000 Unicode
    characters) as TEXT/NTEXT values. TEXT and NTEXT have been deprecated for many
    years and are starting to cause compatibility issues with newer versions of SQL_Server/Azure.
    For example, see [this issue](https://github.com/mkleehammer/pyodbc/issues/835).
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting with ODBC Driver 18 for SQL Server we can override the legacy behavior
    and pass long strings as varchar(max)/nvarchar(max) using the `LongAsMax=Yes`
    connection string parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE255]'
  prefs: []
  type: TYPE_PRE
- en: DSN Connections
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A DSN connection in ODBC means that a pre-existing ODBC datasource is configured
    on the client machine. The application then specifies the name of this datasource,
    which encompasses details such as the specific ODBC driver in use as well as the
    network address of the database. Assuming a datasource is configured on the client,
    a basic DSN-based connection looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE256]'
  prefs: []
  type: TYPE_PRE
- en: 'Which above, will pass the following connection string to PyODBC:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE257]'
  prefs: []
  type: TYPE_PRE
- en: If the username and password are omitted, the DSN form will also add the `Trusted_Connection=yes`
    directive to the ODBC string.
  prefs: []
  type: TYPE_NORMAL
- en: Hostname Connections
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Hostname-based connections are also supported by pyodbc. These are often easier
    to use than a DSN and have the additional advantage that the specific database
    name to connect towards may be specified locally in the URL, rather than it being
    fixed as part of a datasource configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using a hostname connection, the driver name must also be specified in
    the query parameters of the URL. As these names usually have spaces in them, the
    name must be URL encoded which means using plus signs for spaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE258]'
  prefs: []
  type: TYPE_PRE
- en: The `driver` keyword is significant to the pyodbc dialect and must be specified
    in lowercase.
  prefs: []
  type: TYPE_NORMAL
- en: 'Any other names passed in the query string are passed through in the pyodbc
    connect string, such as `authentication`, `TrustServerCertificate`, etc. Multiple
    keyword arguments must be separated by an ampersand (`&`); these will be translated
    to semicolons when the pyodbc connect string is generated internally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE259]'
  prefs: []
  type: TYPE_PRE
- en: 'The equivalent URL can be constructed using [`URL`](../core/engines.html#sqlalchemy.engine.URL
    "sqlalchemy.engine.URL"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE260]'
  prefs: []
  type: TYPE_PRE
- en: Pass through exact Pyodbc string
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A PyODBC connection string can also be sent in pyodbc’s format directly, as
    specified in [the PyODBC documentation](https://github.com/mkleehammer/pyodbc/wiki/Connecting-to-databases),
    using the parameter `odbc_connect`. A [`URL`](../core/engines.html#sqlalchemy.engine.URL
    "sqlalchemy.engine.URL") object can help make this easier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE261]'
  prefs: []
  type: TYPE_PRE
- en: '#### Connecting to databases with access tokens'
  prefs: []
  type: TYPE_NORMAL
- en: Some database servers are set up to only accept access tokens for login. For
    example, SQL Server allows the use of Azure Active Directory tokens to connect
    to databases. This requires creating a credential object using the `azure-identity`
    library. More information about the authentication step can be found in [Microsoft’s
    documentation](https://docs.microsoft.com/en-us/azure/developer/python/azure-sdk-authenticate?tabs=bash).
  prefs: []
  type: TYPE_NORMAL
- en: After getting an engine, the credentials need to be sent to `pyodbc.connect`
    each time a connection is requested. One way to do this is to set up an event
    listener on the engine that adds the credential token to the dialect’s connect
    call. This is discussed more generally in [Generating dynamic authentication tokens](../core/engines.html#engines-dynamic-tokens).
    For SQL Server in particular, this is passed as an ODBC connection attribute with
    a data structure [described by Microsoft](https://docs.microsoft.com/en-us/sql/connect/odbc/using-azure-active-directory#authenticating-with-an-access-token).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet will create an engine that connects to an Azure
    SQL database using Azure credentials:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE262]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: The `Trusted_Connection` token is currently added by the SQLAlchemy pyodbc dialect
    when no username or password is present. This needs to be removed per Microsoft’s
    [documentation for Azure access tokens](https://docs.microsoft.com/en-us/sql/connect/odbc/using-azure-active-directory#authenticating-with-an-access-token),
    stating that a connection string when using an access token must not contain `UID`,
    `PWD`, `Authentication` or `Trusted_Connection` parameters.
  prefs: []
  type: TYPE_NORMAL
- en: '#### Avoiding transaction-related exceptions on Azure Synapse Analytics'
  prefs: []
  type: TYPE_NORMAL
- en: Azure Synapse Analytics has a significant difference in its transaction handling
    compared to plain SQL Server; in some cases an error within a Synapse transaction
    can cause it to be arbitrarily terminated on the server side, which then causes
    the DBAPI `.rollback()` method (as well as `.commit()`) to fail. The issue prevents
    the usual DBAPI contract of allowing `.rollback()` to pass silently if no transaction
    is present as the driver does not expect this condition. The symptom of this failure
    is an exception with a message resembling ‘No corresponding transaction found.
    (111214)’ when attempting to emit a `.rollback()` after an operation had a failure
    of some kind.
  prefs: []
  type: TYPE_NORMAL
- en: 'This specific case can be handled by passing `ignore_no_transaction_on_rollback=True`
    to the SQL Server dialect via the [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE263]'
  prefs: []
  type: TYPE_PRE
- en: Using the above parameter, the dialect will catch `ProgrammingError` exceptions
    raised during `connection.rollback()` and emit a warning if the error message
    contains code `111214`, however will not raise an exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 1.4.40: Added the `ignore_no_transaction_on_rollback=True` parameter.'
  prefs: []
  type: TYPE_NORMAL
- en: Enable autocommit for Azure SQL Data Warehouse (DW) connections
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Azure SQL Data Warehouse does not support transactions, and that can cause
    problems with SQLAlchemy’s “autobegin” (and implicit commit/rollback) behavior.
    We can avoid these problems by enabling autocommit at both the pyodbc and engine
    levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE264]'
  prefs: []
  type: TYPE_PRE
- en: Avoiding sending large string parameters as TEXT/NTEXT
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: By default, for historical reasons, Microsoft’s ODBC drivers for SQL Server
    send long string parameters (greater than 4000 SBCS characters or 2000 Unicode
    characters) as TEXT/NTEXT values. TEXT and NTEXT have been deprecated for many
    years and are starting to cause compatibility issues with newer versions of SQL_Server/Azure.
    For example, see [this issue](https://github.com/mkleehammer/pyodbc/issues/835).
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting with ODBC Driver 18 for SQL Server we can override the legacy behavior
    and pass long strings as varchar(max)/nvarchar(max) using the `LongAsMax=Yes`
    connection string parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE265]'
  prefs: []
  type: TYPE_PRE
- en: Pyodbc Pooling / connection close behavior
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'PyODBC uses internal [pooling](https://github.com/mkleehammer/pyodbc/wiki/The-pyodbc-Module#pooling)
    by default, which means connections will be longer lived than they are within
    SQLAlchemy itself. As SQLAlchemy has its own pooling behavior, it is often preferable
    to disable this behavior. This behavior can only be disabled globally at the PyODBC
    module level, **before** any connections are made:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE266]'
  prefs: []
  type: TYPE_PRE
- en: If this variable is left at its default value of `True`, **the application will
    continue to maintain active database connections**, even when the SQLAlchemy engine
    itself fully discards a connection or if the engine is disposed.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[pooling](https://github.com/mkleehammer/pyodbc/wiki/The-pyodbc-Module#pooling)
    - in the PyODBC documentation.'
  prefs: []
  type: TYPE_NORMAL
- en: Driver / Unicode Support
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: PyODBC works best with Microsoft ODBC drivers, particularly in the area of Unicode
    support on both Python 2 and Python 3.
  prefs: []
  type: TYPE_NORMAL
- en: Using the FreeTDS ODBC drivers on Linux or OSX with PyODBC is **not** recommended;
    there have been historically many Unicode-related issues in this area, including
    before Microsoft offered ODBC drivers for Linux and OSX. Now that Microsoft offers
    drivers for all platforms, for PyODBC support these are recommended. FreeTDS remains
    relevant for non-ODBC drivers such as pymssql where it works very well.
  prefs: []
  type: TYPE_NORMAL
- en: Rowcount Support
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Previous limitations with the SQLAlchemy ORM’s “versioned rows” feature with
    Pyodbc have been resolved as of SQLAlchemy 2.0.5\. See the notes at [Rowcount
    Support / ORM Versioning](#mssql-rowcount-versioning).
  prefs: []
  type: TYPE_NORMAL
- en: '### Fast Executemany Mode'
  prefs: []
  type: TYPE_NORMAL
- en: 'The PyODBC driver includes support for a “fast executemany” mode of execution
    which greatly reduces round trips for a DBAPI `executemany()` call when using
    Microsoft ODBC drivers, for **limited size batches that fit in memory**. The feature
    is enabled by setting the attribute `.fast_executemany` on the DBAPI cursor when
    an executemany call is to be used. The SQLAlchemy PyODBC SQL Server dialect supports
    this parameter by passing the `fast_executemany` parameter to [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") , when using the **Microsoft ODBC driver only**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE267]'
  prefs: []
  type: TYPE_PRE
- en: 'Changed in version 2.0.9: - the `fast_executemany` parameter now has its intended
    effect of this PyODBC feature taking effect for all INSERT statements that are
    executed with multiple parameter sets, which don’t include RETURNING. Previously,
    SQLAlchemy 2.0’s [insertmanyvalues](../glossary.html#term-insertmanyvalues) feature
    would cause `fast_executemany` to not be used in most cases even if specified.'
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.3.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[fast executemany](https://github.com/mkleehammer/pyodbc/wiki/Features-beyond-the-DB-API#fast_executemany)
    - on github'
  prefs: []
  type: TYPE_NORMAL
- en: '### Setinputsizes Support'
  prefs: []
  type: TYPE_NORMAL
- en: As of version 2.0, the pyodbc `cursor.setinputsizes()` method is used for all
    statement executions, except for `cursor.executemany()` calls when fast_executemany=True
    where it is not supported (assuming [insertmanyvalues](../core/connections.html#engine-insertmanyvalues)
    is kept enabled, “fastexecutemany” will not take place for INSERT statements in
    any case).
  prefs: []
  type: TYPE_NORMAL
- en: The use of `cursor.setinputsizes()` can be disabled by passing `use_setinputsizes=False`
    to [`create_engine()`](../core/engines.html#sqlalchemy.create_engine "sqlalchemy.create_engine").
  prefs: []
  type: TYPE_NORMAL
- en: When `use_setinputsizes` is left at its default of `True`, the specific per-type
    symbols passed to `cursor.setinputsizes()` can be programmatically customized
    using the [`DialectEvents.do_setinputsizes()`](../core/events.html#sqlalchemy.events.DialectEvents.do_setinputsizes
    "sqlalchemy.events.DialectEvents.do_setinputsizes") hook. See that method for
    usage examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 2.0: The mssql+pyodbc dialect now defaults to using `use_setinputsizes=True`
    for all statement executions with the exception of cursor.executemany() calls
    when fast_executemany=True. The behavior can be turned off by passing `use_setinputsizes=False`
    to [`create_engine()`](../core/engines.html#sqlalchemy.create_engine "sqlalchemy.create_engine").'
  prefs: []
  type: TYPE_NORMAL
- en: '## pymssql'
  prefs: []
  type: TYPE_NORMAL
- en: Support for the Microsoft SQL Server database via the pymssql driver.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Connect String:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE268]'
  prefs: []
  type: TYPE_PRE
- en: pymssql is a Python module that provides a Python DBAPI interface around [FreeTDS](https://www.freetds.org/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 2.0.5: pymssql was restored to SQLAlchemy’s continuous integration
    testing'
  prefs: []
  type: TYPE_NORMAL
- en: Connecting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Connect String:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE269]'
  prefs: []
  type: TYPE_PRE
- en: '## aioodbc'
  prefs: []
  type: TYPE_NORMAL
- en: Support for the Microsoft SQL Server database via the aioodbc driver.
  prefs: []
  type: TYPE_NORMAL
- en: DBAPI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Documentation and download information (if applicable) for aioodbc is available
    at: [https://pypi.org/project/aioodbc/](https://pypi.org/project/aioodbc/)'
  prefs: []
  type: TYPE_NORMAL
- en: Connecting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Connect String:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE270]'
  prefs: []
  type: TYPE_PRE
- en: Support for the SQL Server database in asyncio style, using the aioodbc driver
    which itself is a thread-wrapper around pyodbc.
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 2.0.23: Added the mssql+aioodbc dialect which builds on top
    of the pyodbc and general aio* dialect architecture.'
  prefs: []
  type: TYPE_NORMAL
- en: Using a special asyncio mediation layer, the aioodbc dialect is usable as the
    backend for the [SQLAlchemy asyncio](../orm/extensions/asyncio.html) extension
    package.
  prefs: []
  type: TYPE_NORMAL
- en: Most behaviors and caveats for this driver are the same as that of the pyodbc
    dialect used on SQL Server; see [PyODBC](#mssql-pyodbc) for general background.
  prefs: []
  type: TYPE_NORMAL
- en: 'This dialect should normally be used only with the [`create_async_engine()`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.create_async_engine
    "sqlalchemy.ext.asyncio.create_async_engine") engine creation function; connection
    styles are otherwise equivalent to those documented in the pyodbc section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE271]'
  prefs: []
  type: TYPE_PRE
- en: DBAPI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Documentation and download information (if applicable) for aioodbc is available
    at: [https://pypi.org/project/aioodbc/](https://pypi.org/project/aioodbc/)'
  prefs: []
  type: TYPE_NORMAL
- en: Connecting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Connect String:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE272]'
  prefs: []
  type: TYPE_PRE
