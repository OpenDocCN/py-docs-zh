["```py\nx86_64 aarch64 ppc64le amd64 win32\n```", "```py\npip install sqlalchemy[asyncio]\n```", "```py\n>>> import asyncio\n\n>>> from sqlalchemy import Column\n>>> from sqlalchemy import MetaData\n>>> from sqlalchemy import select\n>>> from sqlalchemy import String\n>>> from sqlalchemy import Table\n>>> from sqlalchemy.ext.asyncio import create_async_engine\n\n>>> meta = MetaData()\n>>> t1 = Table(\"t1\", meta, Column(\"name\", String(50), primary_key=True))\n\n>>> async def async_main() -> None:\n...     engine = create_async_engine(\"sqlite+aiosqlite://\", echo=True)\n...\n...     async with engine.begin() as conn:\n...         await conn.run_sync(meta.drop_all)\n...         await conn.run_sync(meta.create_all)\n...\n...         await conn.execute(\n...             t1.insert(), [{\"name\": \"some name 1\"}, {\"name\": \"some name 2\"}]\n...         )\n...\n...     async with engine.connect() as conn:\n...         # select a Result, which will be delivered with buffered\n...         # results\n...         result = await conn.execute(select(t1).where(t1.c.name == \"some name 1\"))\n...\n...         print(result.fetchall())\n...\n...     # for AsyncEngine created in function scope, close and\n...     # clean-up pooled connections\n...     await engine.dispose()\n\n>>> asyncio.run(async_main())\nBEGIN  (implicit)\n...\nCREATE  TABLE  t1  (\n  name  VARCHAR(50)  NOT  NULL,\n  PRIMARY  KEY  (name)\n)\n...\nINSERT  INTO  t1  (name)  VALUES  (?)\n[...]  [('some name 1',),  ('some name 2',)]\nCOMMIT\nBEGIN  (implicit)\nSELECT  t1.name\nFROM  t1\nWHERE  t1.name  =  ?\n[...]  ('some name 1',)\n[('some name 1',)]\nROLLBACK \n```", "```py\nasync with engine.connect() as conn:\n    async_result = await conn.stream(select(t1))\n\n    async for row in async_result:\n        print(\"row: %s\" % (row,))\n```", "```py\n>>> from __future__ import annotations\n\n>>> import asyncio\n>>> import datetime\n>>> from typing import List\n\n>>> from sqlalchemy import ForeignKey\n>>> from sqlalchemy import func\n>>> from sqlalchemy import select\n>>> from sqlalchemy.ext.asyncio import AsyncAttrs\n>>> from sqlalchemy.ext.asyncio import async_sessionmaker\n>>> from sqlalchemy.ext.asyncio import AsyncSession\n>>> from sqlalchemy.ext.asyncio import create_async_engine\n>>> from sqlalchemy.orm import DeclarativeBase\n>>> from sqlalchemy.orm import Mapped\n>>> from sqlalchemy.orm import mapped_column\n>>> from sqlalchemy.orm import relationship\n>>> from sqlalchemy.orm import selectinload\n\n>>> class Base(AsyncAttrs, DeclarativeBase):\n...     pass\n\n>>> class B(Base):\n...     __tablename__ = \"b\"\n...\n...     id: Mapped[int] = mapped_column(primary_key=True)\n...     a_id: Mapped[int] = mapped_column(ForeignKey(\"a.id\"))\n...     data: Mapped[str]\n\n>>> class A(Base):\n...     __tablename__ = \"a\"\n...\n...     id: Mapped[int] = mapped_column(primary_key=True)\n...     data: Mapped[str]\n...     create_date: Mapped[datetime.datetime] = mapped_column(server_default=func.now())\n...     bs: Mapped[List[B]] = relationship()\n\n>>> async def insert_objects(async_session: async_sessionmaker[AsyncSession]) -> None:\n...     async with async_session() as session:\n...         async with session.begin():\n...             session.add_all(\n...                 [\n...                     A(bs=[B(data=\"b1\"), B(data=\"b2\")], data=\"a1\"),\n...                     A(bs=[], data=\"a2\"),\n...                     A(bs=[B(data=\"b3\"), B(data=\"b4\")], data=\"a3\"),\n...                 ]\n...             )\n\n>>> async def select_and_update_objects(\n...     async_session: async_sessionmaker[AsyncSession],\n... ) -> None:\n...     async with async_session() as session:\n...         stmt = select(A).order_by(A.id).options(selectinload(A.bs))\n...\n...         result = await session.execute(stmt)\n...\n...         for a in result.scalars():\n...             print(a, a.data)\n...             print(f\"created at: {a.create_date}\")\n...             for b in a.bs:\n...                 print(b, b.data)\n...\n...         result = await session.execute(select(A).order_by(A.id).limit(1))\n...\n...         a1 = result.scalars().one()\n...\n...         a1.data = \"new data\"\n...\n...         await session.commit()\n...\n...         # access attribute subsequent to commit; this is what\n...         # expire_on_commit=False allows\n...         print(a1.data)\n...\n...         # alternatively, AsyncAttrs may be used to access any attribute\n...         # as an awaitable (new in 2.0.13)\n...         for b1 in await a1.awaitable_attrs.bs:\n...             print(b1, b1.data)\n\n>>> async def async_main() -> None:\n...     engine = create_async_engine(\"sqlite+aiosqlite://\", echo=True)\n...\n...     # async_sessionmaker: a factory for new AsyncSession objects.\n...     # expire_on_commit - don't expire objects after transaction commit\n...     async_session = async_sessionmaker(engine, expire_on_commit=False)\n...\n...     async with engine.begin() as conn:\n...         await conn.run_sync(Base.metadata.create_all)\n...\n...     await insert_objects(async_session)\n...     await select_and_update_objects(async_session)\n...\n...     # for AsyncEngine created in function scope, close and\n...     # clean-up pooled connections\n...     await engine.dispose()\n\n>>> asyncio.run(async_main())\nBEGIN  (implicit)\n...\nCREATE  TABLE  a  (\n  id  INTEGER  NOT  NULL,\n  data  VARCHAR  NOT  NULL,\n  create_date  DATETIME  DEFAULT  (CURRENT_TIMESTAMP)  NOT  NULL,\n  PRIMARY  KEY  (id)\n)\n...\nCREATE  TABLE  b  (\n  id  INTEGER  NOT  NULL,\n  a_id  INTEGER  NOT  NULL,\n  data  VARCHAR  NOT  NULL,\n  PRIMARY  KEY  (id),\n  FOREIGN  KEY(a_id)  REFERENCES  a  (id)\n)\n...\nCOMMIT\nBEGIN  (implicit)\nINSERT  INTO  a  (data)  VALUES  (?)  RETURNING  id,  create_date\n[...]  ('a1',)\n...\nINSERT  INTO  b  (a_id,  data)  VALUES  (?,  ?)  RETURNING  id\n[...]  (1,  'b2')\n...\nCOMMIT\nBEGIN  (implicit)\nSELECT  a.id,  a.data,  a.create_date\nFROM  a  ORDER  BY  a.id\n[...]  ()\nSELECT  b.a_id  AS  b_a_id,  b.id  AS  b_id,  b.data  AS  b_data\nFROM  b\nWHERE  b.a_id  IN  (?,  ?,  ?)\n[...]  (1,  2,  3)\n<A  object  at  ...>  a1\ncreated  at:  ...\n<B  object  at  ...>  b1\n<B  object  at  ...>  b2\n<A  object  at  ...>  a2\ncreated  at:  ...\n<A  object  at  ...>  a3\ncreated  at:  ...\n<B  object  at  ...>  b3\n<B  object  at  ...>  b4\nSELECT  a.id,  a.data,  a.create_date\nFROM  a  ORDER  BY  a.id\nLIMIT  ?  OFFSET  ?\n[...]  (1,  0)\nUPDATE  a  SET  data=?  WHERE  a.id  =  ?\n[...]  ('new data',  1)\nCOMMIT\nnew  data\n<B  object  at  ...>  b1\n<B  object  at  ...>  b2 \n```", "```py\n    from __future__ import annotations\n\n    from typing import List\n\n    from sqlalchemy.ext.asyncio import AsyncAttrs\n    from sqlalchemy.orm import DeclarativeBase\n    from sqlalchemy.orm import Mapped\n    from sqlalchemy.orm import relationship\n\n    class Base(AsyncAttrs, DeclarativeBase):\n        pass\n\n    class A(Base):\n        __tablename__ = \"a\"\n\n        # ... rest of mapping ...\n\n        bs: Mapped[List[B]] = relationship()\n\n    class B(Base):\n        __tablename__ = \"b\"\n\n        # ... rest of mapping ...\n    ```", "```py\n    a1 = (await session.scalars(select(A))).one()\n    for b1 in await a1.awaitable_attrs.bs:\n        print(b1)\n    ```", "```py\n    stmt = select(A).options(selectinload(A.bs))\n    ```", "```py\n    A(bs=[], data=\"a2\")\n    ```", "```py\n    # create AsyncSession with expire_on_commit=False\n    async_session = AsyncSession(engine, expire_on_commit=False)\n\n    # sessionmaker version\n    async_session = async_sessionmaker(engine, expire_on_commit=False)\n\n    async with async_session() as session:\n        result = await session.execute(select(A).order_by(A.id))\n\n        a1 = result.scalars().first()\n\n        # commit would normally expire all attributes\n        await session.commit()\n\n        # access attribute subsequent to commit; this is what\n        # expire_on_commit=False allows\n        print(a1.data)\n    ```", "```py\n    # assume a_obj is an A that has lazy loaded A.bs collection\n    a_obj = await async_session.get(A, [1])\n\n    # force the collection to load by naming it in attribute_names\n    await async_session.refresh(a_obj, [\"bs\"])\n\n    # collection is present\n    print(f\"bs collection: {a_obj.bs}\")\n    ```", "```py\n    user = await session.get(User, 42)\n    addresses = (await session.scalars(user.addresses.statement)).all()\n    stmt = user.addresses.statement.where(Address.email_address.startswith(\"patrick\"))\n    addresses_filter = (await session.scalars(stmt)).all()\n    ```", "```py\nimport asyncio\n\nfrom sqlalchemy import select\nfrom sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\n\ndef fetch_and_update_objects(session):\n  \"\"\"run traditional sync-style ORM code in a function that will be\n invoked within an awaitable.\n\n \"\"\"\n\n    # the session object here is a traditional ORM Session.\n    # all features are available here including legacy Query use.\n\n    stmt = select(A)\n\n    result = session.execute(stmt)\n    for a1 in result.scalars():\n        print(a1)\n\n        # lazy loads\n        for b1 in a1.bs:\n            print(b1)\n\n    # legacy Query use\n    a1 = session.query(A).order_by(A.id).first()\n\n    a1.data = \"new data\"\n\nasync def async_main():\n    engine = create_async_engine(\n        \"postgresql+asyncpg://scott:tiger@localhost/test\",\n        echo=True,\n    )\n    async with engine.begin() as conn:\n        await conn.run_sync(Base.metadata.drop_all)\n        await conn.run_sync(Base.metadata.create_all)\n\n    async with AsyncSession(engine) as session:\n        async with session.begin():\n            session.add_all(\n                [\n                    A(bs=[B(), B()], data=\"a1\"),\n                    A(bs=[B()], data=\"a2\"),\n                    A(bs=[B(), B()], data=\"a3\"),\n                ]\n            )\n\n        await session.run_sync(fetch_and_update_objects)\n\n        await session.commit()\n\n    # for AsyncEngine created in function scope, close and\n    # clean-up pooled connections\n    await engine.dispose()\n\nasyncio.run(async_main())\n```", "```py\n    import asyncio\n\n    from sqlalchemy import event\n    from sqlalchemy import text\n    from sqlalchemy.engine import Engine\n    from sqlalchemy.ext.asyncio import create_async_engine\n\n    engine = create_async_engine(\"postgresql+asyncpg://scott:tiger@localhost:5432/test\")\n\n    # connect event on instance of Engine\n    @event.listens_for(engine.sync_engine, \"connect\")\n    def my_on_connect(dbapi_con, connection_record):\n        print(\"New DBAPI connection:\", dbapi_con)\n        cursor = dbapi_con.cursor()\n\n        # sync style API use for adapted DBAPI connection / cursor\n        cursor.execute(\"select 'execute from event'\")\n        print(cursor.fetchone()[0])\n\n    # before_execute event on all Engine instances\n    @event.listens_for(Engine, \"before_execute\")\n    def my_before_execute(\n        conn,\n        clauseelement,\n        multiparams,\n        params,\n        execution_options,\n    ):\n        print(\"before execute!\")\n\n    async def go():\n        async with engine.connect() as conn:\n            await conn.execute(text(\"select 1\"))\n        await engine.dispose()\n\n    asyncio.run(go())\n    ```", "```py\n    New DBAPI connection: <AdaptedConnection <asyncpg.connection.Connection object at 0x7f33f9b16960>>\n    execute from event\n    before execute!\n    ```", "```py\n    import asyncio\n\n    from sqlalchemy import event\n    from sqlalchemy import text\n    from sqlalchemy.ext.asyncio import AsyncSession\n    from sqlalchemy.ext.asyncio import create_async_engine\n    from sqlalchemy.orm import Session\n\n    engine = create_async_engine(\"postgresql+asyncpg://scott:tiger@localhost:5432/test\")\n\n    session = AsyncSession(engine)\n\n    # before_commit event on instance of Session\n    @event.listens_for(session.sync_session, \"before_commit\")\n    def my_before_commit(session):\n        print(\"before commit!\")\n\n        # sync style API use on Session\n        connection = session.connection()\n\n        # sync style API use on Connection\n        result = connection.execute(text(\"select 'execute from event'\"))\n        print(result.first())\n\n    # after_commit event on all Session instances\n    @event.listens_for(Session, \"after_commit\")\n    def my_after_commit(session):\n        print(\"after commit!\")\n\n    async def go():\n        await session.execute(text(\"select 1\"))\n        await session.commit()\n\n        await session.close()\n        await engine.dispose()\n\n    asyncio.run(go())\n    ```", "```py\n    before commit!\n    execute from event\n    after commit!\n    ```", "```py\n    import asyncio\n\n    from sqlalchemy import event\n    from sqlalchemy.ext.asyncio import async_sessionmaker\n    from sqlalchemy.orm import sessionmaker\n\n    sync_maker = sessionmaker()\n    maker = async_sessionmaker(sync_session_class=sync_maker)\n\n    @event.listens_for(sync_maker, \"before_commit\")\n    def before_commit(session):\n        print(\"before commit\")\n\n    async def main():\n        async_session = maker()\n\n        await async_session.commit()\n\n    asyncio.run(main())\n    ```", "```py\n    before commit\n    ```", "```py\nfrom sqlalchemy import event\nfrom sqlalchemy.ext.asyncio import create_async_engine\n\nengine = create_async_engine(...)\n\n@event.listens_for(engine.sync_engine, \"connect\")\ndef register_custom_types(dbapi_connection, *args):\n    dbapi_connection.run_async(\n        lambda connection: connection.set_type_codec(\n            \"MyCustomType\",\n            encoder,\n            decoder,  # ...\n        )\n    )\n```", "```py\nfrom sqlalchemy.ext.asyncio import create_async_engine\nfrom sqlalchemy.pool import NullPool\n\nengine = create_async_engine(\n    \"postgresql+asyncpg://user:pass@host/dbname\",\n    poolclass=NullPool,\n)\n```", "```py\nfrom asyncio import current_task\n\nfrom sqlalchemy.ext.asyncio import (\n    async_scoped_session,\n    async_sessionmaker,\n)\n\nasync_session_factory = async_sessionmaker(\n    some_async_engine,\n    expire_on_commit=False,\n)\nAsyncScopedSession = async_scoped_session(\n    async_session_factory,\n    scopefunc=current_task,\n)\nsome_async_session = AsyncScopedSession()\n```", "```py\nasync def some_function(some_async_session, some_object):\n    # use the AsyncSession directly\n    some_async_session.add(some_object)\n\n    # use the AsyncSession via the context-local proxy\n    await AsyncScopedSession.commit()\n\n    # \"remove\" the current proxied AsyncSession for the local context\n    await AsyncScopedSession.remove()\n```", "```py\nimport asyncio\n\nfrom sqlalchemy import inspect\nfrom sqlalchemy.ext.asyncio import create_async_engine\n\nengine = create_async_engine(\"postgresql+asyncpg://scott:tiger@localhost/test\")\n\ndef use_inspector(conn):\n    inspector = inspect(conn)\n    # use the inspector\n    print(inspector.get_view_names())\n    # return any value to the caller\n    return inspector.get_table_names()\n\nasync def async_main():\n    async with engine.connect() as conn:\n        tables = await conn.run_sync(use_inspector)\n\nasyncio.run(async_main())\n```", "```py\nfunction sqlalchemy.ext.asyncio.create_async_engine(url: str | URL, **kw: Any) \u2192 AsyncEngine\n```", "```py\nfunction sqlalchemy.ext.asyncio.async_engine_from_config(configuration: Dict[str, Any], prefix: str = 'sqlalchemy.', **kwargs: Any) \u2192 AsyncEngine\n```", "```py\nfunction sqlalchemy.ext.asyncio.create_async_pool_from_url(url: str | URL, **kwargs: Any) \u2192 Pool\n```", "```py\nclass sqlalchemy.ext.asyncio.AsyncEngine\n```", "```py\nfrom sqlalchemy.ext.asyncio import create_async_engine\nengine = create_async_engine(\"postgresql+asyncpg://user:pass@host/dbname\")\n```", "```py\nmethod begin() \u2192 AsyncIterator[AsyncConnection]\n```", "```py\nasync with async_engine.begin() as conn:\n    await conn.execute(\n        text(\"insert into table (x, y, z) values (1, 2, 3)\")\n    )\n    await conn.execute(text(\"my_special_procedure(5)\"))\n```", "```py\nmethod clear_compiled_cache() \u2192 None\n```", "```py\nmethod connect() \u2192 AsyncConnection\n```", "```py\nasync with async_engine.connect() as conn:\n    result = await conn.execute(select(user_table))\n```", "```py\nattribute dialect\n```", "```py\nmethod async dispose(close: bool = True) \u2192 None\n```", "```py\nattribute driver\n```", "```py\nattribute echo\n```", "```py\nattribute engine\n```", "```py\nmethod execution_options(**opt: Any) \u2192 AsyncEngine\n```", "```py\nmethod get_execution_options() \u2192 _ExecuteOptions\n```", "```py\nattribute name\n```", "```py\nattribute pool\n```", "```py\nmethod async raw_connection() \u2192 PoolProxiedConnection\n```", "```py\nattribute sync_engine: Engine\n```", "```py\nmethod update_execution_options(**opt: Any) \u2192 None\n```", "```py\nattribute url\n```", "```py\nclass sqlalchemy.ext.asyncio.AsyncConnection\n```", "```py\nfrom sqlalchemy.ext.asyncio import create_async_engine\nengine = create_async_engine(\"postgresql+asyncpg://user:pass@host/dbname\")\n\nasync with engine.connect() as conn:\n    result = await conn.execute(select(table))\n```", "```py\nmethod async aclose() \u2192 None\n```", "```py\nmethod begin() \u2192 AsyncTransaction\n```", "```py\nmethod begin_nested() \u2192 AsyncTransaction\n```", "```py\nmethod async close() \u2192 None\n```", "```py\nattribute closed\n```", "```py\nmethod async commit() \u2192 None\n```", "```py\nattribute connection\n```", "```py\nattribute default_isolation_level\n```", "```py\nattribute dialect\n```", "```py\nmethod async exec_driver_sql(statement: str, parameters: _DBAPIAnyExecuteParams | None = None, execution_options: CoreExecuteOptionsParameter | None = None) \u2192 CursorResult[Any]\n```", "```py\nmethod async execute(statement: Executable, parameters: _CoreAnyExecuteParams | None = None, *, execution_options: CoreExecuteOptionsParameter | None = None) \u2192 CursorResult[Any]\n```", "```py\nmethod async execution_options(**opt: Any) \u2192 AsyncConnection\n```", "```py\nmethod get_nested_transaction() \u2192 AsyncTransaction | None\n```", "```py\nmethod async get_raw_connection() \u2192 PoolProxiedConnection\n```", "```py\nmethod get_transaction() \u2192 AsyncTransaction | None\n```", "```py\nmethod in_nested_transaction() \u2192 bool\n```", "```py\nmethod in_transaction() \u2192 bool\n```", "```py\nattribute info\n```", "```py\nmethod async invalidate(exception: BaseException | None = None) \u2192 None\n```", "```py\nattribute invalidated\n```", "```py\nmethod async rollback() \u2192 None\n```", "```py\nmethod async run_sync(fn: ~typing.Callable[[~typing.Concatenate[~sqlalchemy.engine.base.Connection, ~_P]], ~sqlalchemy.ext.asyncio.engine._T], *arg: ~typing.~_P, **kw: ~typing.~_P) \u2192 _T\n```", "```py\ndef do_something_with_core(conn: Connection, arg1: int, arg2: str) -> str:\n  '''A synchronous function that does not require awaiting\n\n :param conn: a Core SQLAlchemy Connection, used synchronously\n\n :return: an optional return value is supported\n\n '''\n    conn.execute(\n        some_table.insert().values(int_col=arg1, str_col=arg2)\n    )\n    return \"success\"\n\nasync def do_something_async(async_engine: AsyncEngine) -> None:\n  '''an async function that uses awaiting'''\n\n    async with async_engine.begin() as async_conn:\n        # run do_something_with_core() with a sync-style\n        # Connection, proxied into an awaitable\n        return_code = await async_conn.run_sync(do_something_with_core, 5, \"strval\")\n        print(return_code)\n```", "```py\n# run metadata.create_all(conn) with a sync-style Connection,\n# proxied into an awaitable\nwith async_engine.begin() as conn:\n    await conn.run_sync(metadata.create_all)\n```", "```py\nmethod async scalar(statement: Executable, parameters: _CoreSingleExecuteParams | None = None, *, execution_options: CoreExecuteOptionsParameter | None = None) \u2192 Any\n```", "```py\nmethod async scalars(statement: Executable, parameters: _CoreAnyExecuteParams | None = None, *, execution_options: CoreExecuteOptionsParameter | None = None) \u2192 ScalarResult[Any]\n```", "```py\nmethod async start(is_ctxmanager: bool = False) \u2192 AsyncConnection\n```", "```py\nmethod stream(statement: Executable, parameters: _CoreAnyExecuteParams | None = None, *, execution_options: CoreExecuteOptionsParameter | None = None) \u2192 AsyncIterator[AsyncResult[Any]]\n```", "```py\nresult = await conn.stream(stmt):\nasync for row in result:\n    print(f\"{row}\")\n```", "```py\nasync with conn.stream(stmt) as result:\n    async for row in result:\n        print(f\"{row}\")\n```", "```py\nmethod stream_scalars(statement: Executable, parameters: _CoreSingleExecuteParams | None = None, *, execution_options: CoreExecuteOptionsParameter | None = None) \u2192 AsyncIterator[AsyncScalarResult[Any]]\n```", "```py\nresult = await conn.stream_scalars(stmt)\nasync for scalar in result:\n    print(f\"{scalar}\")\n```", "```py\nasync with conn.stream_scalars(stmt) as result:\n    async for scalar in result:\n        print(f\"{scalar}\")\n```", "```py\nattribute sync_connection: Connection | None\n```", "```py\nattribute sync_engine: Engine\n```", "```py\nclass sqlalchemy.ext.asyncio.AsyncTransaction\n```", "```py\nmethod async close() \u2192 None\n```", "```py\nmethod async commit() \u2192 None\n```", "```py\nmethod async rollback() \u2192 None\n```", "```py\nmethod async start(is_ctxmanager: bool = False) \u2192 AsyncTransaction\n```", "```py\nclass sqlalchemy.ext.asyncio.AsyncResult\n```", "```py\nmethod async all() \u2192 Sequence[Row[_TP]]\n```", "```py\nmethod async close() \u2192 None\n```", "```py\nattribute closed\n```", "```py\nmethod columns(*col_expressions: _KeyIndexType) \u2192 Self\n```", "```py\nmethod async fetchall() \u2192 Sequence[Row[_TP]]\n```", "```py\nmethod async fetchmany(size: int | None = None) \u2192 Sequence[Row[_TP]]\n```", "```py\nmethod async fetchone() \u2192 Row[_TP] | None\n```", "```py\nmethod async first() \u2192 Row[_TP] | None\n```", "```py\nmethod async freeze() \u2192 FrozenResult[_TP]\n```", "```py\nmethod keys() \u2192 RMKeyView\n```", "```py\nmethod mappings() \u2192 AsyncMappingResult\n```", "```py\nmethod async one() \u2192 Row[_TP]\n```", "```py\nmethod async one_or_none() \u2192 Row[_TP] | None\n```", "```py\nmethod async partitions(size: int | None = None) \u2192 AsyncIterator[Sequence[Row[_TP]]]\n```", "```py\nasync def scroll_results(connection):\n    result = await connection.stream(select(users_table))\n\n    async for partition in result.partitions(100):\n        print(\"list of rows: %s\" % partition)\n```", "```py\nmethod async scalar() \u2192 Any\n```", "```py\nmethod async scalar_one() \u2192 Any\n```", "```py\nmethod async scalar_one_or_none() \u2192 Any | None\n```", "```py\nmethod scalars(index: _KeyIndexType = 0) \u2192 AsyncScalarResult[Any]\n```", "```py\nattribute t\n```", "```py\nmethod tuples() \u2192 AsyncTupleResult[_TP]\n```", "```py\nmethod unique(strategy: _UniqueFilterType | None = None) \u2192 Self\n```", "```py\nmethod yield_per(num: int) \u2192 Self\n```", "```py\nclass sqlalchemy.ext.asyncio.AsyncScalarResult\n```", "```py\nmethod async all() \u2192 Sequence[_R]\n```", "```py\nmethod async close() \u2192 None\n```", "```py\nattribute closed\n```", "```py\nmethod async fetchall() \u2192 Sequence[_R]\n```", "```py\nmethod async fetchmany(size: int | None = None) \u2192 Sequence[_R]\n```", "```py\nmethod async first() \u2192 _R | None\n```", "```py\nmethod async one() \u2192 _R\n```", "```py\nmethod async one_or_none() \u2192 _R | None\n```", "```py\nmethod async partitions(size: int | None = None) \u2192 AsyncIterator[Sequence[_R]]\n```", "```py\nmethod unique(strategy: _UniqueFilterType | None = None) \u2192 Self\n```", "```py\nmethod yield_per(num: int) \u2192 Self\n```", "```py\nclass sqlalchemy.ext.asyncio.AsyncMappingResult\n```", "```py\nmethod async all() \u2192 Sequence[RowMapping]\n```", "```py\nmethod async close() \u2192 None\n```", "```py\nattribute closed\n```", "```py\nmethod columns(*col_expressions: _KeyIndexType) \u2192 Self\n```", "```py\nmethod async fetchall() \u2192 Sequence[RowMapping]\n```", "```py\nmethod async fetchmany(size: int | None = None) \u2192 Sequence[RowMapping]\n```", "```py\nmethod async fetchone() \u2192 RowMapping | None\n```", "```py\nmethod async first() \u2192 RowMapping | None\n```", "```py\nmethod keys() \u2192 RMKeyView\n```", "```py\nmethod async one() \u2192 RowMapping\n```", "```py\nmethod async one_or_none() \u2192 RowMapping | None\n```", "```py\nmethod async partitions(size: int | None = None) \u2192 AsyncIterator[Sequence[RowMapping]]\n```", "```py\nmethod unique(strategy: _UniqueFilterType | None = None) \u2192 Self\n```", "```py\nmethod yield_per(num: int) \u2192 Self\n```", "```py\nclass sqlalchemy.ext.asyncio.AsyncTupleResult\n```", "```py\nfunction sqlalchemy.ext.asyncio.async_object_session(instance: object) \u2192 AsyncSession | None\n```", "```py\nfunction sqlalchemy.ext.asyncio.async_session(session: Session) \u2192 AsyncSession | None\n```", "```py\nfunction async sqlalchemy.ext.asyncio.close_all_sessions() \u2192 None\n```", "```py\nclass sqlalchemy.ext.asyncio.async_sessionmaker\n```", "```py\nfrom sqlalchemy.ext.asyncio import create_async_engine\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom sqlalchemy.ext.asyncio import async_sessionmaker\n\nasync def run_some_sql(async_session: async_sessionmaker[AsyncSession]) -> None:\n    async with async_session() as session:\n        session.add(SomeObject(data=\"object\"))\n        session.add(SomeOtherObject(name=\"other object\"))\n        await session.commit()\n\nasync def main() -> None:\n    # an AsyncEngine, which the AsyncSession will use for connection\n    # resources\n    engine = create_async_engine('postgresql+asyncpg://scott:tiger@localhost/')\n\n    # create a reusable factory for new AsyncSession instances\n    async_session = async_sessionmaker(engine)\n\n    await run_some_sql(async_session)\n\n    await engine.dispose()\n```", "```py\nmethod __call__(**local_kw: Any) \u2192 _AS\n```", "```py\nAsyncSession = async_sessionmaker(async_engine, expire_on_commit=False)\nsession = AsyncSession()  # invokes sessionmaker.__call__()\n```", "```py\nmethod __init__(bind: Optional[_AsyncSessionBind] = None, *, class_: Type[_AS] = <class 'sqlalchemy.ext.asyncio.session.AsyncSession'>, autoflush: bool = True, expire_on_commit: bool = True, info: Optional[_InfoType] = None, **kw: Any)\n```", "```py\nmethod begin() \u2192 _AsyncSessionContextManager[_AS]\n```", "```py\nasync def main():\n    Session = async_sessionmaker(some_engine)\n\n    async with Session.begin() as session:\n        session.add(some_object)\n\n    # commits transaction, closes session\n```", "```py\nmethod configure(**new_kw: Any) \u2192 None\n```", "```py\nAsyncSession = async_sessionmaker(some_engine)\n\nAsyncSession.configure(bind=create_async_engine('sqlite+aiosqlite://'))\n```", "```py\nclass sqlalchemy.ext.asyncio.async_scoped_session\n```", "```py\nmethod __call__(**kw: Any) \u2192 _AS\n```", "```py\nmethod __init__(session_factory: async_sessionmaker[_AS], scopefunc: Callable[[], Any])\n```", "```py\nmethod async aclose() \u2192 None\n```", "```py\nmethod add(instance: object, _warn: bool = True) \u2192 None\n```", "```py\nmethod add_all(instances: Iterable[object]) \u2192 None\n```", "```py\nattribute autoflush\n```", "```py\nmethod begin() \u2192 AsyncSessionTransaction\n```", "```py\nasync with async_session.begin():\n    # .. ORM transaction is begun\n```", "```py\nmethod begin_nested() \u2192 AsyncSessionTransaction\n```", "```py\nattribute bind\n```", "```py\nmethod async close() \u2192 None\n```", "```py\nasync classmethod close_all() \u2192 None\n```", "```py\nmethod async commit() \u2192 None\n```", "```py\nmethod configure(**kwargs: Any) \u2192 None\n```", "```py\nmethod async connection(bind_arguments: _BindArguments | None = None, execution_options: CoreExecuteOptionsParameter | None = None, **kw: Any) \u2192 AsyncConnection\n```", "```py\nmethod async delete(instance: object) \u2192 None\n```", "```py\nattribute deleted\n```", "```py\nattribute dirty\n```", "```py\nsome_mapped_object in session.dirty\n```", "```py\nmethod async execute(statement: Executable, params: _CoreAnyExecuteParams | None = None, *, execution_options: OrmExecuteOptionsParameter = {}, bind_arguments: _BindArguments | None = None, **kw: Any) \u2192 Result[Any]\n```", "```py\nmethod expire(instance: object, attribute_names: Iterable[str] | None = None) \u2192 None\n```", "```py\nmethod expire_all() \u2192 None\n```", "```py\nmethod expunge(instance: object) \u2192 None\n```", "```py\nmethod expunge_all() \u2192 None\n```", "```py\nmethod async flush(objects: Sequence[Any] | None = None) \u2192 None\n```", "```py\nmethod async get(entity: _EntityBindKey[_O], ident: _PKIdentityArgument, *, options: Sequence[ORMOption] | None = None, populate_existing: bool = False, with_for_update: ForUpdateParameter = None, identity_token: Any | None = None, execution_options: OrmExecuteOptionsParameter = {}) \u2192 _O | None\n```", "```py\nmethod get_bind(mapper: _EntityBindKey[_O] | None = None, clause: ClauseElement | None = None, bind: _SessionBind | None = None, **kw: Any) \u2192 Engine | Connection\n```", "```py\n# using example from \"Custom Vertical Partitioning\"\n\nimport random\n\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom sqlalchemy.ext.asyncio import create_async_engine\nfrom sqlalchemy.ext.asyncio import async_sessionmaker\nfrom sqlalchemy.orm import Session\n\n# construct async engines w/ async drivers\nengines = {\n    'leader':create_async_engine(\"sqlite+aiosqlite:///leader.db\"),\n    'other':create_async_engine(\"sqlite+aiosqlite:///other.db\"),\n    'follower1':create_async_engine(\"sqlite+aiosqlite:///follower1.db\"),\n    'follower2':create_async_engine(\"sqlite+aiosqlite:///follower2.db\"),\n}\n\nclass RoutingSession(Session):\n    def get_bind(self, mapper=None, clause=None, **kw):\n        # within get_bind(), return sync engines\n        if mapper and issubclass(mapper.class_, MyOtherClass):\n            return engines['other'].sync_engine\n        elif self._flushing or isinstance(clause, (Update, Delete)):\n            return engines['leader'].sync_engine\n        else:\n            return engines[\n                random.choice(['follower1','follower2'])\n            ].sync_engine\n\n# apply to AsyncSession using sync_session_class\nAsyncSessionMaker = async_sessionmaker(\n    sync_session_class=RoutingSession\n)\n```", "```py\nmethod async get_one(entity: _EntityBindKey[_O], ident: _PKIdentityArgument, *, options: Sequence[ORMOption] | None = None, populate_existing: bool = False, with_for_update: ForUpdateParameter = None, identity_token: Any | None = None, execution_options: OrmExecuteOptionsParameter = {}) \u2192 _O\n```", "```py\nclassmethod identity_key(class_: Type[Any] | None = None, ident: Any | Tuple[Any, ...] = None, *, instance: Any | None = None, row: Row[Any] | RowMapping | None = None, identity_token: Any | None = None) \u2192 _IdentityKeyType[Any]\n```", "```py\nattribute identity_map\n```", "```py\nattribute info\n```", "```py\nmethod async invalidate() \u2192 None\n```", "```py\nattribute is_active\n```", "```py\nmethod is_modified(instance: object, include_collections: bool = True) \u2192 bool\n```", "```py\nreturn session.is_modified(someobject)\n```", "```py\nmethod async merge(instance: _O, *, load: bool = True, options: Sequence[ORMOption] | None = None) \u2192 _O\n```", "```py\nattribute new\n```", "```py\nattribute no_autoflush\n```", "```py\nwith session.no_autoflush:\n\n    some_object = SomeClass()\n    session.add(some_object)\n    # won't autoflush\n    some_object.related_thing = session.query(SomeRelated).first()\n```", "```py\nclassmethod object_session(instance: object) \u2192 Session | None\n```", "```py\nmethod async refresh(instance: object, attribute_names: Iterable[str] | None = None, with_for_update: ForUpdateParameter = None) \u2192 None\n```", "```py\nmethod async remove() \u2192 None\n```", "```py\nmethod async reset() \u2192 None\n```", "```py\nmethod async rollback() \u2192 None\n```", "```py\nmethod async scalar(statement: Executable, params: _CoreAnyExecuteParams | None = None, *, execution_options: OrmExecuteOptionsParameter = {}, bind_arguments: _BindArguments | None = None, **kw: Any) \u2192 Any\n```", "```py\nmethod async scalars(statement: Executable, params: _CoreAnyExecuteParams | None = None, *, execution_options: OrmExecuteOptionsParameter = {}, bind_arguments: _BindArguments | None = None, **kw: Any) \u2192 ScalarResult[Any]\n```", "```py\nattribute session_factory: async_sessionmaker[_AS]\n```", "```py\nmethod async stream(statement: Executable, params: _CoreAnyExecuteParams | None = None, *, execution_options: OrmExecuteOptionsParameter = {}, bind_arguments: _BindArguments | None = None, **kw: Any) \u2192 AsyncResult[Any]\n```", "```py\nmethod async stream_scalars(statement: Executable, params: _CoreAnyExecuteParams | None = None, *, execution_options: OrmExecuteOptionsParameter = {}, bind_arguments: _BindArguments | None = None, **kw: Any) \u2192 AsyncScalarResult[Any]\n```", "```py\nclass sqlalchemy.ext.asyncio.AsyncAttrs\n```", "```py\nfrom __future__ import annotations\n\nfrom typing import List\n\nfrom sqlalchemy import ForeignKey\nfrom sqlalchemy import func\nfrom sqlalchemy.ext.asyncio import AsyncAttrs\nfrom sqlalchemy.orm import DeclarativeBase\nfrom sqlalchemy.orm import Mapped\nfrom sqlalchemy.orm import mapped_column\nfrom sqlalchemy.orm import relationship\n\nclass Base(AsyncAttrs, DeclarativeBase):\n    pass\n\nclass A(Base):\n    __tablename__ = \"a\"\n\n    id: Mapped[int] = mapped_column(primary_key=True)\n    data: Mapped[str]\n    bs: Mapped[List[B]] = relationship()\n\nclass B(Base):\n    __tablename__ = \"b\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    a_id: Mapped[int] = mapped_column(ForeignKey(\"a.id\"))\n    data: Mapped[str]\n```", "```py\na1 = (await async_session.scalars(select(A).where(A.id == 5))).one()\n\n# use the lazy loader on ``a1.bs`` via the ``.awaitable_attrs``\n# interface, so that it may be awaited\nfor b1 in await a1.awaitable_attrs.bs:\n    print(b1)\n```", "```py\nfor b1 in await async_session.run_sync(lambda sess: a1.bs):\n    print(b1)\n```", "```py\nattribute awaitable_attrs\n```", "```py\na1 = (await async_session.scalars(select(A).where(A.id == 5))).one()\n\nsome_attribute = await a1.awaitable_attrs.some_deferred_attribute\nsome_collection = await a1.awaitable_attrs.some_collection\n```", "```py\nclass sqlalchemy.ext.asyncio.AsyncSession\n```", "```py\nattribute sync_session_class: Type[Session] = <class 'sqlalchemy.orm.session.Session'>\n```", "```py\nmethod __init__(bind: _AsyncSessionBind | None = None, *, binds: Dict[_SessionBindKey, _AsyncSessionBind] | None = None, sync_session_class: Type[Session] | None = None, **kw: Any)\n```", "```py\nmethod async aclose() \u2192 None\n```", "```py\nmethod add(instance: object, _warn: bool = True) \u2192 None\n```", "```py\nmethod add_all(instances: Iterable[object]) \u2192 None\n```", "```py\nattribute autoflush\n```", "```py\nmethod begin() \u2192 AsyncSessionTransaction\n```", "```py\nasync with async_session.begin():\n    # .. ORM transaction is begun\n```", "```py\nmethod begin_nested() \u2192 AsyncSessionTransaction\n```", "```py\nmethod async close() \u2192 None\n```", "```py\nasync classmethod close_all() \u2192 None\n```", "```py\nmethod async commit() \u2192 None\n```", "```py\nmethod async connection(bind_arguments: _BindArguments | None = None, execution_options: CoreExecuteOptionsParameter | None = None, **kw: Any) \u2192 AsyncConnection\n```", "```py\nmethod async delete(instance: object) \u2192 None\n```", "```py\nattribute deleted\n```", "```py\nattribute dirty\n```", "```py\nsome_mapped_object in session.dirty\n```", "```py\nmethod async execute(statement: Executable, params: _CoreAnyExecuteParams | None = None, *, execution_options: OrmExecuteOptionsParameter = {}, bind_arguments: _BindArguments | None = None, **kw: Any) \u2192 Result[Any]\n```", "```py\nmethod expire(instance: object, attribute_names: Iterable[str] | None = None) \u2192 None\n```", "```py\nmethod expire_all() \u2192 None\n```", "```py\nmethod expunge(instance: object) \u2192 None\n```", "```py\nmethod expunge_all() \u2192 None\n```", "```py\nmethod async flush(objects: Sequence[Any] | None = None) \u2192 None\n```", "```py\nmethod async get(entity: _EntityBindKey[_O], ident: _PKIdentityArgument, *, options: Sequence[ORMOption] | None = None, populate_existing: bool = False, with_for_update: ForUpdateParameter = None, identity_token: Any | None = None, execution_options: OrmExecuteOptionsParameter = {}) \u2192 _O | None\n```", "```py\nmethod get_bind(mapper: _EntityBindKey[_O] | None = None, clause: ClauseElement | None = None, bind: _SessionBind | None = None, **kw: Any) \u2192 Engine | Connection\n```", "```py\n# using example from \"Custom Vertical Partitioning\"\n\nimport random\n\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom sqlalchemy.ext.asyncio import create_async_engine\nfrom sqlalchemy.ext.asyncio import async_sessionmaker\nfrom sqlalchemy.orm import Session\n\n# construct async engines w/ async drivers\nengines = {\n    'leader':create_async_engine(\"sqlite+aiosqlite:///leader.db\"),\n    'other':create_async_engine(\"sqlite+aiosqlite:///other.db\"),\n    'follower1':create_async_engine(\"sqlite+aiosqlite:///follower1.db\"),\n    'follower2':create_async_engine(\"sqlite+aiosqlite:///follower2.db\"),\n}\n\nclass RoutingSession(Session):\n    def get_bind(self, mapper=None, clause=None, **kw):\n        # within get_bind(), return sync engines\n        if mapper and issubclass(mapper.class_, MyOtherClass):\n            return engines['other'].sync_engine\n        elif self._flushing or isinstance(clause, (Update, Delete)):\n            return engines['leader'].sync_engine\n        else:\n            return engines[\n                random.choice(['follower1','follower2'])\n            ].sync_engine\n\n# apply to AsyncSession using sync_session_class\nAsyncSessionMaker = async_sessionmaker(\n    sync_session_class=RoutingSession\n)\n```", "```py\nmethod get_nested_transaction() \u2192 AsyncSessionTransaction | None\n```", "```py\nmethod async get_one(entity: _EntityBindKey[_O], ident: _PKIdentityArgument, *, options: Sequence[ORMOption] | None = None, populate_existing: bool = False, with_for_update: ForUpdateParameter = None, identity_token: Any | None = None, execution_options: OrmExecuteOptionsParameter = {}) \u2192 _O\n```", "```py\nmethod get_transaction() \u2192 AsyncSessionTransaction | None\n```", "```py\nclassmethod identity_key(class_: Type[Any] | None = None, ident: Any | Tuple[Any, ...] = None, *, instance: Any | None = None, row: Row[Any] | RowMapping | None = None, identity_token: Any | None = None) \u2192 _IdentityKeyType[Any]\n```", "```py\nattribute identity_map\n```", "```py\nmethod in_nested_transaction() \u2192 bool\n```", "```py\nmethod in_transaction() \u2192 bool\n```", "```py\nattribute info\n```", "```py\nmethod async invalidate() \u2192 None\n```", "```py\nattribute is_active\n```", "```py\nmethod is_modified(instance: object, include_collections: bool = True) \u2192 bool\n```", "```py\nreturn session.is_modified(someobject)\n```", "```py\nmethod async merge(instance: _O, *, load: bool = True, options: Sequence[ORMOption] | None = None) \u2192 _O\n```", "```py\nattribute new\n```", "```py\nattribute no_autoflush\n```", "```py\nwith session.no_autoflush:\n\n    some_object = SomeClass()\n    session.add(some_object)\n    # won't autoflush\n    some_object.related_thing = session.query(SomeRelated).first()\n```", "```py\nclassmethod object_session(instance: object) \u2192 Session | None\n```", "```py\nmethod async refresh(instance: object, attribute_names: Iterable[str] | None = None, with_for_update: ForUpdateParameter = None) \u2192 None\n```", "```py\nmethod async reset() \u2192 None\n```", "```py\nmethod async rollback() \u2192 None\n```", "```py\nmethod async run_sync(fn: ~typing.Callable[[~typing.Concatenate[~sqlalchemy.orm.session.Session, ~_P]], ~sqlalchemy.ext.asyncio.session._T], *arg: ~typing.~_P, **kw: ~typing.~_P) \u2192 _T\n```", "```py\ndef some_business_method(session: Session, param: str) -> str:\n  '''A synchronous function that does not require awaiting\n\n :param session: a SQLAlchemy Session, used synchronously\n\n :return: an optional return value is supported\n\n '''\n    session.add(MyObject(param=param))\n    session.flush()\n    return \"success\"\n\nasync def do_something_async(async_engine: AsyncEngine) -> None:\n  '''an async function that uses awaiting'''\n\n    with AsyncSession(async_engine) as async_session:\n        # run some_business_method() with a sync-style\n        # Session, proxied into an awaitable\n        return_code = await async_session.run_sync(some_business_method, param=\"param1\")\n        print(return_code)\n```", "```py\nmethod async scalar(statement: Executable, params: _CoreAnyExecuteParams | None = None, *, execution_options: OrmExecuteOptionsParameter = {}, bind_arguments: _BindArguments | None = None, **kw: Any) \u2192 Any\n```", "```py\nmethod async scalars(statement: Executable, params: _CoreAnyExecuteParams | None = None, *, execution_options: OrmExecuteOptionsParameter = {}, bind_arguments: _BindArguments | None = None, **kw: Any) \u2192 ScalarResult[Any]\n```", "```py\nmethod async stream(statement: Executable, params: _CoreAnyExecuteParams | None = None, *, execution_options: OrmExecuteOptionsParameter = {}, bind_arguments: _BindArguments | None = None, **kw: Any) \u2192 AsyncResult[Any]\n```", "```py\nmethod async stream_scalars(statement: Executable, params: _CoreAnyExecuteParams | None = None, *, execution_options: OrmExecuteOptionsParameter = {}, bind_arguments: _BindArguments | None = None, **kw: Any) \u2192 AsyncScalarResult[Any]\n```", "```py\nattribute sync_session: Session\n```", "```py\nclass sqlalchemy.ext.asyncio.AsyncSessionTransaction\n```", "```py\nmethod async commit() \u2192 None\n```", "```py\nmethod async rollback() \u2192 None\n```", "```py\nx86_64 aarch64 ppc64le amd64 win32\n```", "```py\npip install sqlalchemy[asyncio]\n```", "```py\n>>> import asyncio\n\n>>> from sqlalchemy import Column\n>>> from sqlalchemy import MetaData\n>>> from sqlalchemy import select\n>>> from sqlalchemy import String\n>>> from sqlalchemy import Table\n>>> from sqlalchemy.ext.asyncio import create_async_engine\n\n>>> meta = MetaData()\n>>> t1 = Table(\"t1\", meta, Column(\"name\", String(50), primary_key=True))\n\n>>> async def async_main() -> None:\n...     engine = create_async_engine(\"sqlite+aiosqlite://\", echo=True)\n...\n...     async with engine.begin() as conn:\n...         await conn.run_sync(meta.drop_all)\n...         await conn.run_sync(meta.create_all)\n...\n...         await conn.execute(\n...             t1.insert(), [{\"name\": \"some name 1\"}, {\"name\": \"some name 2\"}]\n...         )\n...\n...     async with engine.connect() as conn:\n...         # select a Result, which will be delivered with buffered\n...         # results\n...         result = await conn.execute(select(t1).where(t1.c.name == \"some name 1\"))\n...\n...         print(result.fetchall())\n...\n...     # for AsyncEngine created in function scope, close and\n...     # clean-up pooled connections\n...     await engine.dispose()\n\n>>> asyncio.run(async_main())\nBEGIN  (implicit)\n...\nCREATE  TABLE  t1  (\n  name  VARCHAR(50)  NOT  NULL,\n  PRIMARY  KEY  (name)\n)\n...\nINSERT  INTO  t1  (name)  VALUES  (?)\n[...]  [('some name 1',),  ('some name 2',)]\nCOMMIT\nBEGIN  (implicit)\nSELECT  t1.name\nFROM  t1\nWHERE  t1.name  =  ?\n[...]  ('some name 1',)\n[('some name 1',)]\nROLLBACK \n```", "```py\nasync with engine.connect() as conn:\n    async_result = await conn.stream(select(t1))\n\n    async for row in async_result:\n        print(\"row: %s\" % (row,))\n```", "```py\n>>> from __future__ import annotations\n\n>>> import asyncio\n>>> import datetime\n>>> from typing import List\n\n>>> from sqlalchemy import ForeignKey\n>>> from sqlalchemy import func\n>>> from sqlalchemy import select\n>>> from sqlalchemy.ext.asyncio import AsyncAttrs\n>>> from sqlalchemy.ext.asyncio import async_sessionmaker\n>>> from sqlalchemy.ext.asyncio import AsyncSession\n>>> from sqlalchemy.ext.asyncio import create_async_engine\n>>> from sqlalchemy.orm import DeclarativeBase\n>>> from sqlalchemy.orm import Mapped\n>>> from sqlalchemy.orm import mapped_column\n>>> from sqlalchemy.orm import relationship\n>>> from sqlalchemy.orm import selectinload\n\n>>> class Base(AsyncAttrs, DeclarativeBase):\n...     pass\n\n>>> class B(Base):\n...     __tablename__ = \"b\"\n...\n...     id: Mapped[int] = mapped_column(primary_key=True)\n...     a_id: Mapped[int] = mapped_column(ForeignKey(\"a.id\"))\n...     data: Mapped[str]\n\n>>> class A(Base):\n...     __tablename__ = \"a\"\n...\n...     id: Mapped[int] = mapped_column(primary_key=True)\n...     data: Mapped[str]\n...     create_date: Mapped[datetime.datetime] = mapped_column(server_default=func.now())\n...     bs: Mapped[List[B]] = relationship()\n\n>>> async def insert_objects(async_session: async_sessionmaker[AsyncSession]) -> None:\n...     async with async_session() as session:\n...         async with session.begin():\n...             session.add_all(\n...                 [\n...                     A(bs=[B(data=\"b1\"), B(data=\"b2\")], data=\"a1\"),\n...                     A(bs=[], data=\"a2\"),\n...                     A(bs=[B(data=\"b3\"), B(data=\"b4\")], data=\"a3\"),\n...                 ]\n...             )\n\n>>> async def select_and_update_objects(\n...     async_session: async_sessionmaker[AsyncSession],\n... ) -> None:\n...     async with async_session() as session:\n...         stmt = select(A).order_by(A.id).options(selectinload(A.bs))\n...\n...         result = await session.execute(stmt)\n...\n...         for a in result.scalars():\n...             print(a, a.data)\n...             print(f\"created at: {a.create_date}\")\n...             for b in a.bs:\n...                 print(b, b.data)\n...\n...         result = await session.execute(select(A).order_by(A.id).limit(1))\n...\n...         a1 = result.scalars().one()\n...\n...         a1.data = \"new data\"\n...\n...         await session.commit()\n...\n...         # access attribute subsequent to commit; this is what\n...         # expire_on_commit=False allows\n...         print(a1.data)\n...\n...         # alternatively, AsyncAttrs may be used to access any attribute\n...         # as an awaitable (new in 2.0.13)\n...         for b1 in await a1.awaitable_attrs.bs:\n...             print(b1, b1.data)\n\n>>> async def async_main() -> None:\n...     engine = create_async_engine(\"sqlite+aiosqlite://\", echo=True)\n...\n...     # async_sessionmaker: a factory for new AsyncSession objects.\n...     # expire_on_commit - don't expire objects after transaction commit\n...     async_session = async_sessionmaker(engine, expire_on_commit=False)\n...\n...     async with engine.begin() as conn:\n...         await conn.run_sync(Base.metadata.create_all)\n...\n...     await insert_objects(async_session)\n...     await select_and_update_objects(async_session)\n...\n...     # for AsyncEngine created in function scope, close and\n...     # clean-up pooled connections\n...     await engine.dispose()\n\n>>> asyncio.run(async_main())\nBEGIN  (implicit)\n...\nCREATE  TABLE  a  (\n  id  INTEGER  NOT  NULL,\n  data  VARCHAR  NOT  NULL,\n  create_date  DATETIME  DEFAULT  (CURRENT_TIMESTAMP)  NOT  NULL,\n  PRIMARY  KEY  (id)\n)\n...\nCREATE  TABLE  b  (\n  id  INTEGER  NOT  NULL,\n  a_id  INTEGER  NOT  NULL,\n  data  VARCHAR  NOT  NULL,\n  PRIMARY  KEY  (id),\n  FOREIGN  KEY(a_id)  REFERENCES  a  (id)\n)\n...\nCOMMIT\nBEGIN  (implicit)\nINSERT  INTO  a  (data)  VALUES  (?)  RETURNING  id,  create_date\n[...]  ('a1',)\n...\nINSERT  INTO  b  (a_id,  data)  VALUES  (?,  ?)  RETURNING  id\n[...]  (1,  'b2')\n...\nCOMMIT\nBEGIN  (implicit)\nSELECT  a.id,  a.data,  a.create_date\nFROM  a  ORDER  BY  a.id\n[...]  ()\nSELECT  b.a_id  AS  b_a_id,  b.id  AS  b_id,  b.data  AS  b_data\nFROM  b\nWHERE  b.a_id  IN  (?,  ?,  ?)\n[...]  (1,  2,  3)\n<A  object  at  ...>  a1\ncreated  at:  ...\n<B  object  at  ...>  b1\n<B  object  at  ...>  b2\n<A  object  at  ...>  a2\ncreated  at:  ...\n<A  object  at  ...>  a3\ncreated  at:  ...\n<B  object  at  ...>  b3\n<B  object  at  ...>  b4\nSELECT  a.id,  a.data,  a.create_date\nFROM  a  ORDER  BY  a.id\nLIMIT  ?  OFFSET  ?\n[...]  (1,  0)\nUPDATE  a  SET  data=?  WHERE  a.id  =  ?\n[...]  ('new data',  1)\nCOMMIT\nnew  data\n<B  object  at  ...>  b1\n<B  object  at  ...>  b2 \n```", "```py\n    from __future__ import annotations\n\n    from typing import List\n\n    from sqlalchemy.ext.asyncio import AsyncAttrs\n    from sqlalchemy.orm import DeclarativeBase\n    from sqlalchemy.orm import Mapped\n    from sqlalchemy.orm import relationship\n\n    class Base(AsyncAttrs, DeclarativeBase):\n        pass\n\n    class A(Base):\n        __tablename__ = \"a\"\n\n        # ... rest of mapping ...\n\n        bs: Mapped[List[B]] = relationship()\n\n    class B(Base):\n        __tablename__ = \"b\"\n\n        # ... rest of mapping ...\n    ```", "```py\n    a1 = (await session.scalars(select(A))).one()\n    for b1 in await a1.awaitable_attrs.bs:\n        print(b1)\n    ```", "```py\n    stmt = select(A).options(selectinload(A.bs))\n    ```", "```py\n    A(bs=[], data=\"a2\")\n    ```", "```py\n    # create AsyncSession with expire_on_commit=False\n    async_session = AsyncSession(engine, expire_on_commit=False)\n\n    # sessionmaker version\n    async_session = async_sessionmaker(engine, expire_on_commit=False)\n\n    async with async_session() as session:\n        result = await session.execute(select(A).order_by(A.id))\n\n        a1 = result.scalars().first()\n\n        # commit would normally expire all attributes\n        await session.commit()\n\n        # access attribute subsequent to commit; this is what\n        # expire_on_commit=False allows\n        print(a1.data)\n    ```", "```py\n    # assume a_obj is an A that has lazy loaded A.bs collection\n    a_obj = await async_session.get(A, [1])\n\n    # force the collection to load by naming it in attribute_names\n    await async_session.refresh(a_obj, [\"bs\"])\n\n    # collection is present\n    print(f\"bs collection: {a_obj.bs}\")\n    ```", "```py\n    user = await session.get(User, 42)\n    addresses = (await session.scalars(user.addresses.statement)).all()\n    stmt = user.addresses.statement.where(Address.email_address.startswith(\"patrick\"))\n    addresses_filter = (await session.scalars(stmt)).all()\n    ```", "```py\nimport asyncio\n\nfrom sqlalchemy import select\nfrom sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\n\ndef fetch_and_update_objects(session):\n  \"\"\"run traditional sync-style ORM code in a function that will be\n invoked within an awaitable.\n\n \"\"\"\n\n    # the session object here is a traditional ORM Session.\n    # all features are available here including legacy Query use.\n\n    stmt = select(A)\n\n    result = session.execute(stmt)\n    for a1 in result.scalars():\n        print(a1)\n\n        # lazy loads\n        for b1 in a1.bs:\n            print(b1)\n\n    # legacy Query use\n    a1 = session.query(A).order_by(A.id).first()\n\n    a1.data = \"new data\"\n\nasync def async_main():\n    engine = create_async_engine(\n        \"postgresql+asyncpg://scott:tiger@localhost/test\",\n        echo=True,\n    )\n    async with engine.begin() as conn:\n        await conn.run_sync(Base.metadata.drop_all)\n        await conn.run_sync(Base.metadata.create_all)\n\n    async with AsyncSession(engine) as session:\n        async with session.begin():\n            session.add_all(\n                [\n                    A(bs=[B(), B()], data=\"a1\"),\n                    A(bs=[B()], data=\"a2\"),\n                    A(bs=[B(), B()], data=\"a3\"),\n                ]\n            )\n\n        await session.run_sync(fetch_and_update_objects)\n\n        await session.commit()\n\n    # for AsyncEngine created in function scope, close and\n    # clean-up pooled connections\n    await engine.dispose()\n\nasyncio.run(async_main())\n```", "```py\n    from __future__ import annotations\n\n    from typing import List\n\n    from sqlalchemy.ext.asyncio import AsyncAttrs\n    from sqlalchemy.orm import DeclarativeBase\n    from sqlalchemy.orm import Mapped\n    from sqlalchemy.orm import relationship\n\n    class Base(AsyncAttrs, DeclarativeBase):\n        pass\n\n    class A(Base):\n        __tablename__ = \"a\"\n\n        # ... rest of mapping ...\n\n        bs: Mapped[List[B]] = relationship()\n\n    class B(Base):\n        __tablename__ = \"b\"\n\n        # ... rest of mapping ...\n    ```", "```py\n    a1 = (await session.scalars(select(A))).one()\n    for b1 in await a1.awaitable_attrs.bs:\n        print(b1)\n    ```", "```py\n    stmt = select(A).options(selectinload(A.bs))\n    ```", "```py\n    A(bs=[], data=\"a2\")\n    ```", "```py\n    # create AsyncSession with expire_on_commit=False\n    async_session = AsyncSession(engine, expire_on_commit=False)\n\n    # sessionmaker version\n    async_session = async_sessionmaker(engine, expire_on_commit=False)\n\n    async with async_session() as session:\n        result = await session.execute(select(A).order_by(A.id))\n\n        a1 = result.scalars().first()\n\n        # commit would normally expire all attributes\n        await session.commit()\n\n        # access attribute subsequent to commit; this is what\n        # expire_on_commit=False allows\n        print(a1.data)\n    ```", "```py\n    # assume a_obj is an A that has lazy loaded A.bs collection\n    a_obj = await async_session.get(A, [1])\n\n    # force the collection to load by naming it in attribute_names\n    await async_session.refresh(a_obj, [\"bs\"])\n\n    # collection is present\n    print(f\"bs collection: {a_obj.bs}\")\n    ```", "```py\n    user = await session.get(User, 42)\n    addresses = (await session.scalars(user.addresses.statement)).all()\n    stmt = user.addresses.statement.where(Address.email_address.startswith(\"patrick\"))\n    addresses_filter = (await session.scalars(stmt)).all()\n    ```", "```py\nimport asyncio\n\nfrom sqlalchemy import select\nfrom sqlalchemy.ext.asyncio import AsyncSession, create_async_engine\n\ndef fetch_and_update_objects(session):\n  \"\"\"run traditional sync-style ORM code in a function that will be\n invoked within an awaitable.\n\n \"\"\"\n\n    # the session object here is a traditional ORM Session.\n    # all features are available here including legacy Query use.\n\n    stmt = select(A)\n\n    result = session.execute(stmt)\n    for a1 in result.scalars():\n        print(a1)\n\n        # lazy loads\n        for b1 in a1.bs:\n            print(b1)\n\n    # legacy Query use\n    a1 = session.query(A).order_by(A.id).first()\n\n    a1.data = \"new data\"\n\nasync def async_main():\n    engine = create_async_engine(\n        \"postgresql+asyncpg://scott:tiger@localhost/test\",\n        echo=True,\n    )\n    async with engine.begin() as conn:\n        await conn.run_sync(Base.metadata.drop_all)\n        await conn.run_sync(Base.metadata.create_all)\n\n    async with AsyncSession(engine) as session:\n        async with session.begin():\n            session.add_all(\n                [\n                    A(bs=[B(), B()], data=\"a1\"),\n                    A(bs=[B()], data=\"a2\"),\n                    A(bs=[B(), B()], data=\"a3\"),\n                ]\n            )\n\n        await session.run_sync(fetch_and_update_objects)\n\n        await session.commit()\n\n    # for AsyncEngine created in function scope, close and\n    # clean-up pooled connections\n    await engine.dispose()\n\nasyncio.run(async_main())\n```", "```py\n    import asyncio\n\n    from sqlalchemy import event\n    from sqlalchemy import text\n    from sqlalchemy.engine import Engine\n    from sqlalchemy.ext.asyncio import create_async_engine\n\n    engine = create_async_engine(\"postgresql+asyncpg://scott:tiger@localhost:5432/test\")\n\n    # connect event on instance of Engine\n    @event.listens_for(engine.sync_engine, \"connect\")\n    def my_on_connect(dbapi_con, connection_record):\n        print(\"New DBAPI connection:\", dbapi_con)\n        cursor = dbapi_con.cursor()\n\n        # sync style API use for adapted DBAPI connection / cursor\n        cursor.execute(\"select 'execute from event'\")\n        print(cursor.fetchone()[0])\n\n    # before_execute event on all Engine instances\n    @event.listens_for(Engine, \"before_execute\")\n    def my_before_execute(\n        conn,\n        clauseelement,\n        multiparams,\n        params,\n        execution_options,\n    ):\n        print(\"before execute!\")\n\n    async def go():\n        async with engine.connect() as conn:\n            await conn.execute(text(\"select 1\"))\n        await engine.dispose()\n\n    asyncio.run(go())\n    ```", "```py\n    New DBAPI connection: <AdaptedConnection <asyncpg.connection.Connection object at 0x7f33f9b16960>>\n    execute from event\n    before execute!\n    ```", "```py\n    import asyncio\n\n    from sqlalchemy import event\n    from sqlalchemy import text\n    from sqlalchemy.ext.asyncio import AsyncSession\n    from sqlalchemy.ext.asyncio import create_async_engine\n    from sqlalchemy.orm import Session\n\n    engine = create_async_engine(\"postgresql+asyncpg://scott:tiger@localhost:5432/test\")\n\n    session = AsyncSession(engine)\n\n    # before_commit event on instance of Session\n    @event.listens_for(session.sync_session, \"before_commit\")\n    def my_before_commit(session):\n        print(\"before commit!\")\n\n        # sync style API use on Session\n        connection = session.connection()\n\n        # sync style API use on Connection\n        result = connection.execute(text(\"select 'execute from event'\"))\n        print(result.first())\n\n    # after_commit event on all Session instances\n    @event.listens_for(Session, \"after_commit\")\n    def my_after_commit(session):\n        print(\"after commit!\")\n\n    async def go():\n        await session.execute(text(\"select 1\"))\n        await session.commit()\n\n        await session.close()\n        await engine.dispose()\n\n    asyncio.run(go())\n    ```", "```py\n    before commit!\n    execute from event\n    after commit!\n    ```", "```py\n    import asyncio\n\n    from sqlalchemy import event\n    from sqlalchemy.ext.asyncio import async_sessionmaker\n    from sqlalchemy.orm import sessionmaker\n\n    sync_maker = sessionmaker()\n    maker = async_sessionmaker(sync_session_class=sync_maker)\n\n    @event.listens_for(sync_maker, \"before_commit\")\n    def before_commit(session):\n        print(\"before commit\")\n\n    async def main():\n        async_session = maker()\n\n        await async_session.commit()\n\n    asyncio.run(main())\n    ```", "```py\n    before commit\n    ```", "```py\nfrom sqlalchemy import event\nfrom sqlalchemy.ext.asyncio import create_async_engine\n\nengine = create_async_engine(...)\n\n@event.listens_for(engine.sync_engine, \"connect\")\ndef register_custom_types(dbapi_connection, *args):\n    dbapi_connection.run_async(\n        lambda connection: connection.set_type_codec(\n            \"MyCustomType\",\n            encoder,\n            decoder,  # ...\n        )\n    )\n```", "```py\n    import asyncio\n\n    from sqlalchemy import event\n    from sqlalchemy import text\n    from sqlalchemy.engine import Engine\n    from sqlalchemy.ext.asyncio import create_async_engine\n\n    engine = create_async_engine(\"postgresql+asyncpg://scott:tiger@localhost:5432/test\")\n\n    # connect event on instance of Engine\n    @event.listens_for(engine.sync_engine, \"connect\")\n    def my_on_connect(dbapi_con, connection_record):\n        print(\"New DBAPI connection:\", dbapi_con)\n        cursor = dbapi_con.cursor()\n\n        # sync style API use for adapted DBAPI connection / cursor\n        cursor.execute(\"select 'execute from event'\")\n        print(cursor.fetchone()[0])\n\n    # before_execute event on all Engine instances\n    @event.listens_for(Engine, \"before_execute\")\n    def my_before_execute(\n        conn,\n        clauseelement,\n        multiparams,\n        params,\n        execution_options,\n    ):\n        print(\"before execute!\")\n\n    async def go():\n        async with engine.connect() as conn:\n            await conn.execute(text(\"select 1\"))\n        await engine.dispose()\n\n    asyncio.run(go())\n    ```", "```py\n    New DBAPI connection: <AdaptedConnection <asyncpg.connection.Connection object at 0x7f33f9b16960>>\n    execute from event\n    before execute!\n    ```", "```py\n    import asyncio\n\n    from sqlalchemy import event\n    from sqlalchemy import text\n    from sqlalchemy.ext.asyncio import AsyncSession\n    from sqlalchemy.ext.asyncio import create_async_engine\n    from sqlalchemy.orm import Session\n\n    engine = create_async_engine(\"postgresql+asyncpg://scott:tiger@localhost:5432/test\")\n\n    session = AsyncSession(engine)\n\n    # before_commit event on instance of Session\n    @event.listens_for(session.sync_session, \"before_commit\")\n    def my_before_commit(session):\n        print(\"before commit!\")\n\n        # sync style API use on Session\n        connection = session.connection()\n\n        # sync style API use on Connection\n        result = connection.execute(text(\"select 'execute from event'\"))\n        print(result.first())\n\n    # after_commit event on all Session instances\n    @event.listens_for(Session, \"after_commit\")\n    def my_after_commit(session):\n        print(\"after commit!\")\n\n    async def go():\n        await session.execute(text(\"select 1\"))\n        await session.commit()\n\n        await session.close()\n        await engine.dispose()\n\n    asyncio.run(go())\n    ```", "```py\n    before commit!\n    execute from event\n    after commit!\n    ```", "```py\n    import asyncio\n\n    from sqlalchemy import event\n    from sqlalchemy.ext.asyncio import async_sessionmaker\n    from sqlalchemy.orm import sessionmaker\n\n    sync_maker = sessionmaker()\n    maker = async_sessionmaker(sync_session_class=sync_maker)\n\n    @event.listens_for(sync_maker, \"before_commit\")\n    def before_commit(session):\n        print(\"before commit\")\n\n    async def main():\n        async_session = maker()\n\n        await async_session.commit()\n\n    asyncio.run(main())\n    ```", "```py\n    before commit\n    ```", "```py\nfrom sqlalchemy import event\nfrom sqlalchemy.ext.asyncio import create_async_engine\n\nengine = create_async_engine(...)\n\n@event.listens_for(engine.sync_engine, \"connect\")\ndef register_custom_types(dbapi_connection, *args):\n    dbapi_connection.run_async(\n        lambda connection: connection.set_type_codec(\n            \"MyCustomType\",\n            encoder,\n            decoder,  # ...\n        )\n    )\n```", "```py\nfrom sqlalchemy.ext.asyncio import create_async_engine\nfrom sqlalchemy.pool import NullPool\n\nengine = create_async_engine(\n    \"postgresql+asyncpg://user:pass@host/dbname\",\n    poolclass=NullPool,\n)\n```", "```py\nfrom asyncio import current_task\n\nfrom sqlalchemy.ext.asyncio import (\n    async_scoped_session,\n    async_sessionmaker,\n)\n\nasync_session_factory = async_sessionmaker(\n    some_async_engine,\n    expire_on_commit=False,\n)\nAsyncScopedSession = async_scoped_session(\n    async_session_factory,\n    scopefunc=current_task,\n)\nsome_async_session = AsyncScopedSession()\n```", "```py\nasync def some_function(some_async_session, some_object):\n    # use the AsyncSession directly\n    some_async_session.add(some_object)\n\n    # use the AsyncSession via the context-local proxy\n    await AsyncScopedSession.commit()\n\n    # \"remove\" the current proxied AsyncSession for the local context\n    await AsyncScopedSession.remove()\n```", "```py\nimport asyncio\n\nfrom sqlalchemy import inspect\nfrom sqlalchemy.ext.asyncio import create_async_engine\n\nengine = create_async_engine(\"postgresql+asyncpg://scott:tiger@localhost/test\")\n\ndef use_inspector(conn):\n    inspector = inspect(conn)\n    # use the inspector\n    print(inspector.get_view_names())\n    # return any value to the caller\n    return inspector.get_table_names()\n\nasync def async_main():\n    async with engine.connect() as conn:\n        tables = await conn.run_sync(use_inspector)\n\nasyncio.run(async_main())\n```", "```py\nfunction sqlalchemy.ext.asyncio.create_async_engine(url: str | URL, **kw: Any) \u2192 AsyncEngine\n```", "```py\nfunction sqlalchemy.ext.asyncio.async_engine_from_config(configuration: Dict[str, Any], prefix: str = 'sqlalchemy.', **kwargs: Any) \u2192 AsyncEngine\n```", "```py\nfunction sqlalchemy.ext.asyncio.create_async_pool_from_url(url: str | URL, **kwargs: Any) \u2192 Pool\n```", "```py\nclass sqlalchemy.ext.asyncio.AsyncEngine\n```", "```py\nfrom sqlalchemy.ext.asyncio import create_async_engine\nengine = create_async_engine(\"postgresql+asyncpg://user:pass@host/dbname\")\n```", "```py\nmethod begin() \u2192 AsyncIterator[AsyncConnection]\n```", "```py\nasync with async_engine.begin() as conn:\n    await conn.execute(\n        text(\"insert into table (x, y, z) values (1, 2, 3)\")\n    )\n    await conn.execute(text(\"my_special_procedure(5)\"))\n```", "```py\nmethod clear_compiled_cache() \u2192 None\n```", "```py\nmethod connect() \u2192 AsyncConnection\n```", "```py\nasync with async_engine.connect() as conn:\n    result = await conn.execute(select(user_table))\n```", "```py\nattribute dialect\n```", "```py\nmethod async dispose(close: bool = True) \u2192 None\n```", "```py\nattribute driver\n```", "```py\nattribute echo\n```", "```py\nattribute engine\n```", "```py\nmethod execution_options(**opt: Any) \u2192 AsyncEngine\n```", "```py\nmethod get_execution_options() \u2192 _ExecuteOptions\n```", "```py\nattribute name\n```", "```py\nattribute pool\n```", "```py\nmethod async raw_connection() \u2192 PoolProxiedConnection\n```", "```py\nattribute sync_engine: Engine\n```", "```py\nmethod update_execution_options(**opt: Any) \u2192 None\n```", "```py\nattribute url\n```", "```py\nclass sqlalchemy.ext.asyncio.AsyncConnection\n```", "```py\nfrom sqlalchemy.ext.asyncio import create_async_engine\nengine = create_async_engine(\"postgresql+asyncpg://user:pass@host/dbname\")\n\nasync with engine.connect() as conn:\n    result = await conn.execute(select(table))\n```", "```py\nmethod async aclose() \u2192 None\n```", "```py\nmethod begin() \u2192 AsyncTransaction\n```", "```py\nmethod begin_nested() \u2192 AsyncTransaction\n```", "```py\nmethod async close() \u2192 None\n```", "```py\nattribute closed\n```", "```py\nmethod async commit() \u2192 None\n```", "```py\nattribute connection\n```", "```py\nattribute default_isolation_level\n```", "```py\nattribute dialect\n```", "```py\nmethod async exec_driver_sql(statement: str, parameters: _DBAPIAnyExecuteParams | None = None, execution_options: CoreExecuteOptionsParameter | None = None) \u2192 CursorResult[Any]\n```", "```py\nmethod async execute(statement: Executable, parameters: _CoreAnyExecuteParams | None = None, *, execution_options: CoreExecuteOptionsParameter | None = None) \u2192 CursorResult[Any]\n```", "```py\nmethod async execution_options(**opt: Any) \u2192 AsyncConnection\n```", "```py\nmethod get_nested_transaction() \u2192 AsyncTransaction | None\n```", "```py\nmethod async get_raw_connection() \u2192 PoolProxiedConnection\n```", "```py\nmethod get_transaction() \u2192 AsyncTransaction | None\n```", "```py\nmethod in_nested_transaction() \u2192 bool\n```", "```py\nmethod in_transaction() \u2192 bool\n```", "```py\nattribute info\n```", "```py\nmethod async invalidate(exception: BaseException | None = None) \u2192 None\n```", "```py\nattribute invalidated\n```", "```py\nmethod async rollback() \u2192 None\n```", "```py\nmethod async run_sync(fn: ~typing.Callable[[~typing.Concatenate[~sqlalchemy.engine.base.Connection, ~_P]], ~sqlalchemy.ext.asyncio.engine._T], *arg: ~typing.~_P, **kw: ~typing.~_P) \u2192 _T\n```", "```py\ndef do_something_with_core(conn: Connection, arg1: int, arg2: str) -> str:\n  '''A synchronous function that does not require awaiting\n\n :param conn: a Core SQLAlchemy Connection, used synchronously\n\n :return: an optional return value is supported\n\n '''\n    conn.execute(\n        some_table.insert().values(int_col=arg1, str_col=arg2)\n    )\n    return \"success\"\n\nasync def do_something_async(async_engine: AsyncEngine) -> None:\n  '''an async function that uses awaiting'''\n\n    async with async_engine.begin() as async_conn:\n        # run do_something_with_core() with a sync-style\n        # Connection, proxied into an awaitable\n        return_code = await async_conn.run_sync(do_something_with_core, 5, \"strval\")\n        print(return_code)\n```", "```py\n# run metadata.create_all(conn) with a sync-style Connection,\n# proxied into an awaitable\nwith async_engine.begin() as conn:\n    await conn.run_sync(metadata.create_all)\n```", "```py\nmethod async scalar(statement: Executable, parameters: _CoreSingleExecuteParams | None = None, *, execution_options: CoreExecuteOptionsParameter | None = None) \u2192 Any\n```", "```py\nmethod async scalars(statement: Executable, parameters: _CoreAnyExecuteParams | None = None, *, execution_options: CoreExecuteOptionsParameter | None = None) \u2192 ScalarResult[Any]\n```", "```py\nmethod async start(is_ctxmanager: bool = False) \u2192 AsyncConnection\n```", "```py\nmethod stream(statement: Executable, parameters: _CoreAnyExecuteParams | None = None, *, execution_options: CoreExecuteOptionsParameter | None = None) \u2192 AsyncIterator[AsyncResult[Any]]\n```", "```py\nresult = await conn.stream(stmt):\nasync for row in result:\n    print(f\"{row}\")\n```", "```py\nasync with conn.stream(stmt) as result:\n    async for row in result:\n        print(f\"{row}\")\n```", "```py\nmethod stream_scalars(statement: Executable, parameters: _CoreSingleExecuteParams | None = None, *, execution_options: CoreExecuteOptionsParameter | None = None) \u2192 AsyncIterator[AsyncScalarResult[Any]]\n```", "```py\nresult = await conn.stream_scalars(stmt)\nasync for scalar in result:\n    print(f\"{scalar}\")\n```", "```py\nasync with conn.stream_scalars(stmt) as result:\n    async for scalar in result:\n        print(f\"{scalar}\")\n```", "```py\nattribute sync_connection: Connection | None\n```", "```py\nattribute sync_engine: Engine\n```", "```py\nclass sqlalchemy.ext.asyncio.AsyncTransaction\n```", "```py\nmethod async close() \u2192 None\n```", "```py\nmethod async commit() \u2192 None\n```", "```py\nmethod async rollback() \u2192 None\n```", "```py\nmethod async start(is_ctxmanager: bool = False) \u2192 AsyncTransaction\n```", "```py\nclass sqlalchemy.ext.asyncio.AsyncResult\n```", "```py\nmethod async all() \u2192 Sequence[Row[_TP]]\n```", "```py\nmethod async close() \u2192 None\n```", "```py\nattribute closed\n```", "```py\nmethod columns(*col_expressions: _KeyIndexType) \u2192 Self\n```", "```py\nmethod async fetchall() \u2192 Sequence[Row[_TP]]\n```", "```py\nmethod async fetchmany(size: int | None = None) \u2192 Sequence[Row[_TP]]\n```", "```py\nmethod async fetchone() \u2192 Row[_TP] | None\n```", "```py\nmethod async first() \u2192 Row[_TP] | None\n```", "```py\nmethod async freeze() \u2192 FrozenResult[_TP]\n```", "```py\nmethod keys() \u2192 RMKeyView\n```", "```py\nmethod mappings() \u2192 AsyncMappingResult\n```", "```py\nmethod async one() \u2192 Row[_TP]\n```", "```py\nmethod async one_or_none() \u2192 Row[_TP] | None\n```", "```py\nmethod async partitions(size: int | None = None) \u2192 AsyncIterator[Sequence[Row[_TP]]]\n```", "```py\nasync def scroll_results(connection):\n    result = await connection.stream(select(users_table))\n\n    async for partition in result.partitions(100):\n        print(\"list of rows: %s\" % partition)\n```", "```py\nmethod async scalar() \u2192 Any\n```", "```py\nmethod async scalar_one() \u2192 Any\n```", "```py\nmethod async scalar_one_or_none() \u2192 Any | None\n```", "```py\nmethod scalars(index: _KeyIndexType = 0) \u2192 AsyncScalarResult[Any]\n```", "```py\nattribute t\n```", "```py\nmethod tuples() \u2192 AsyncTupleResult[_TP]\n```", "```py\nmethod unique(strategy: _UniqueFilterType | None = None) \u2192 Self\n```", "```py\nmethod yield_per(num: int) \u2192 Self\n```", "```py\nclass sqlalchemy.ext.asyncio.AsyncScalarResult\n```", "```py\nmethod async all() \u2192 Sequence[_R]\n```", "```py\nmethod async close() \u2192 None\n```", "```py\nattribute closed\n```", "```py\nmethod async fetchall() \u2192 Sequence[_R]\n```", "```py\nmethod async fetchmany(size: int | None = None) \u2192 Sequence[_R]\n```", "```py\nmethod async first() \u2192 _R | None\n```", "```py\nmethod async one() \u2192 _R\n```", "```py\nmethod async one_or_none() \u2192 _R | None\n```", "```py\nmethod async partitions(size: int | None = None) \u2192 AsyncIterator[Sequence[_R]]\n```", "```py\nmethod unique(strategy: _UniqueFilterType | None = None) \u2192 Self\n```", "```py\nmethod yield_per(num: int) \u2192 Self\n```", "```py\nclass sqlalchemy.ext.asyncio.AsyncMappingResult\n```", "```py\nmethod async all() \u2192 Sequence[RowMapping]\n```", "```py\nmethod async close() \u2192 None\n```", "```py\nattribute closed\n```", "```py\nmethod columns(*col_expressions: _KeyIndexType) \u2192 Self\n```", "```py\nmethod async fetchall() \u2192 Sequence[RowMapping]\n```", "```py\nmethod async fetchmany(size: int | None = None) \u2192 Sequence[RowMapping]\n```", "```py\nmethod async fetchone() \u2192 RowMapping | None\n```", "```py\nmethod async first() \u2192 RowMapping | None\n```", "```py\nmethod keys() \u2192 RMKeyView\n```", "```py\nmethod async one() \u2192 RowMapping\n```", "```py\nmethod async one_or_none() \u2192 RowMapping | None\n```", "```py\nmethod async partitions(size: int | None = None) \u2192 AsyncIterator[Sequence[RowMapping]]\n```", "```py\nmethod unique(strategy: _UniqueFilterType | None = None) \u2192 Self\n```", "```py\nmethod yield_per(num: int) \u2192 Self\n```", "```py\nclass sqlalchemy.ext.asyncio.AsyncTupleResult\n```", "```py\nfunction sqlalchemy.ext.asyncio.async_object_session(instance: object) \u2192 AsyncSession | None\n```", "```py\nfunction sqlalchemy.ext.asyncio.async_session(session: Session) \u2192 AsyncSession | None\n```", "```py\nfunction async sqlalchemy.ext.asyncio.close_all_sessions() \u2192 None\n```", "```py\nclass sqlalchemy.ext.asyncio.async_sessionmaker\n```", "```py\nfrom sqlalchemy.ext.asyncio import create_async_engine\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom sqlalchemy.ext.asyncio import async_sessionmaker\n\nasync def run_some_sql(async_session: async_sessionmaker[AsyncSession]) -> None:\n    async with async_session() as session:\n        session.add(SomeObject(data=\"object\"))\n        session.add(SomeOtherObject(name=\"other object\"))\n        await session.commit()\n\nasync def main() -> None:\n    # an AsyncEngine, which the AsyncSession will use for connection\n    # resources\n    engine = create_async_engine('postgresql+asyncpg://scott:tiger@localhost/')\n\n    # create a reusable factory for new AsyncSession instances\n    async_session = async_sessionmaker(engine)\n\n    await run_some_sql(async_session)\n\n    await engine.dispose()\n```", "```py\nmethod __call__(**local_kw: Any) \u2192 _AS\n```", "```py\nAsyncSession = async_sessionmaker(async_engine, expire_on_commit=False)\nsession = AsyncSession()  # invokes sessionmaker.__call__()\n```", "```py\nmethod __init__(bind: Optional[_AsyncSessionBind] = None, *, class_: Type[_AS] = <class 'sqlalchemy.ext.asyncio.session.AsyncSession'>, autoflush: bool = True, expire_on_commit: bool = True, info: Optional[_InfoType] = None, **kw: Any)\n```", "```py\nmethod begin() \u2192 _AsyncSessionContextManager[_AS]\n```", "```py\nasync def main():\n    Session = async_sessionmaker(some_engine)\n\n    async with Session.begin() as session:\n        session.add(some_object)\n\n    # commits transaction, closes session\n```", "```py\nmethod configure(**new_kw: Any) \u2192 None\n```", "```py\nAsyncSession = async_sessionmaker(some_engine)\n\nAsyncSession.configure(bind=create_async_engine('sqlite+aiosqlite://'))\n```", "```py\nclass sqlalchemy.ext.asyncio.async_scoped_session\n```", "```py\nmethod __call__(**kw: Any) \u2192 _AS\n```", "```py\nmethod __init__(session_factory: async_sessionmaker[_AS], scopefunc: Callable[[], Any])\n```", "```py\nmethod async aclose() \u2192 None\n```", "```py\nmethod add(instance: object, _warn: bool = True) \u2192 None\n```", "```py\nmethod add_all(instances: Iterable[object]) \u2192 None\n```", "```py\nattribute autoflush\n```", "```py\nmethod begin() \u2192 AsyncSessionTransaction\n```", "```py\nasync with async_session.begin():\n    # .. ORM transaction is begun\n```", "```py\nmethod begin_nested() \u2192 AsyncSessionTransaction\n```", "```py\nattribute bind\n```", "```py\nmethod async close() \u2192 None\n```", "```py\nasync classmethod close_all() \u2192 None\n```", "```py\nmethod async commit() \u2192 None\n```", "```py\nmethod configure(**kwargs: Any) \u2192 None\n```", "```py\nmethod async connection(bind_arguments: _BindArguments | None = None, execution_options: CoreExecuteOptionsParameter | None = None, **kw: Any) \u2192 AsyncConnection\n```", "```py\nmethod async delete(instance: object) \u2192 None\n```", "```py\nattribute deleted\n```", "```py\nattribute dirty\n```", "```py\nsome_mapped_object in session.dirty\n```", "```py\nmethod async execute(statement: Executable, params: _CoreAnyExecuteParams | None = None, *, execution_options: OrmExecuteOptionsParameter = {}, bind_arguments: _BindArguments | None = None, **kw: Any) \u2192 Result[Any]\n```", "```py\nmethod expire(instance: object, attribute_names: Iterable[str] | None = None) \u2192 None\n```", "```py\nmethod expire_all() \u2192 None\n```", "```py\nmethod expunge(instance: object) \u2192 None\n```", "```py\nmethod expunge_all() \u2192 None\n```", "```py\nmethod async flush(objects: Sequence[Any] | None = None) \u2192 None\n```", "```py\nmethod async get(entity: _EntityBindKey[_O], ident: _PKIdentityArgument, *, options: Sequence[ORMOption] | None = None, populate_existing: bool = False, with_for_update: ForUpdateParameter = None, identity_token: Any | None = None, execution_options: OrmExecuteOptionsParameter = {}) \u2192 _O | None\n```", "```py\nmethod get_bind(mapper: _EntityBindKey[_O] | None = None, clause: ClauseElement | None = None, bind: _SessionBind | None = None, **kw: Any) \u2192 Engine | Connection\n```", "```py\n# using example from \"Custom Vertical Partitioning\"\n\nimport random\n\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom sqlalchemy.ext.asyncio import create_async_engine\nfrom sqlalchemy.ext.asyncio import async_sessionmaker\nfrom sqlalchemy.orm import Session\n\n# construct async engines w/ async drivers\nengines = {\n    'leader':create_async_engine(\"sqlite+aiosqlite:///leader.db\"),\n    'other':create_async_engine(\"sqlite+aiosqlite:///other.db\"),\n    'follower1':create_async_engine(\"sqlite+aiosqlite:///follower1.db\"),\n    'follower2':create_async_engine(\"sqlite+aiosqlite:///follower2.db\"),\n}\n\nclass RoutingSession(Session):\n    def get_bind(self, mapper=None, clause=None, **kw):\n        # within get_bind(), return sync engines\n        if mapper and issubclass(mapper.class_, MyOtherClass):\n            return engines['other'].sync_engine\n        elif self._flushing or isinstance(clause, (Update, Delete)):\n            return engines['leader'].sync_engine\n        else:\n            return engines[\n                random.choice(['follower1','follower2'])\n            ].sync_engine\n\n# apply to AsyncSession using sync_session_class\nAsyncSessionMaker = async_sessionmaker(\n    sync_session_class=RoutingSession\n)\n```", "```py\nmethod async get_one(entity: _EntityBindKey[_O], ident: _PKIdentityArgument, *, options: Sequence[ORMOption] | None = None, populate_existing: bool = False, with_for_update: ForUpdateParameter = None, identity_token: Any | None = None, execution_options: OrmExecuteOptionsParameter = {}) \u2192 _O\n```", "```py\nclassmethod identity_key(class_: Type[Any] | None = None, ident: Any | Tuple[Any, ...] = None, *, instance: Any | None = None, row: Row[Any] | RowMapping | None = None, identity_token: Any | None = None) \u2192 _IdentityKeyType[Any]\n```", "```py\nattribute identity_map\n```", "```py\nattribute info\n```", "```py\nmethod async invalidate() \u2192 None\n```", "```py\nattribute is_active\n```", "```py\nmethod is_modified(instance: object, include_collections: bool = True) \u2192 bool\n```", "```py\nreturn session.is_modified(someobject)\n```", "```py\nmethod async merge(instance: _O, *, load: bool = True, options: Sequence[ORMOption] | None = None) \u2192 _O\n```", "```py\nattribute new\n```", "```py\nattribute no_autoflush\n```", "```py\nwith session.no_autoflush:\n\n    some_object = SomeClass()\n    session.add(some_object)\n    # won't autoflush\n    some_object.related_thing = session.query(SomeRelated).first()\n```", "```py\nclassmethod object_session(instance: object) \u2192 Session | None\n```", "```py\nmethod async refresh(instance: object, attribute_names: Iterable[str] | None = None, with_for_update: ForUpdateParameter = None) \u2192 None\n```", "```py\nmethod async remove() \u2192 None\n```", "```py\nmethod async reset() \u2192 None\n```", "```py\nmethod async rollback() \u2192 None\n```", "```py\nmethod async scalar(statement: Executable, params: _CoreAnyExecuteParams | None = None, *, execution_options: OrmExecuteOptionsParameter = {}, bind_arguments: _BindArguments | None = None, **kw: Any) \u2192 Any\n```", "```py\nmethod async scalars(statement: Executable, params: _CoreAnyExecuteParams | None = None, *, execution_options: OrmExecuteOptionsParameter = {}, bind_arguments: _BindArguments | None = None, **kw: Any) \u2192 ScalarResult[Any]\n```", "```py\nattribute session_factory: async_sessionmaker[_AS]\n```", "```py\nmethod async stream(statement: Executable, params: _CoreAnyExecuteParams | None = None, *, execution_options: OrmExecuteOptionsParameter = {}, bind_arguments: _BindArguments | None = None, **kw: Any) \u2192 AsyncResult[Any]\n```", "```py\nmethod async stream_scalars(statement: Executable, params: _CoreAnyExecuteParams | None = None, *, execution_options: OrmExecuteOptionsParameter = {}, bind_arguments: _BindArguments | None = None, **kw: Any) \u2192 AsyncScalarResult[Any]\n```", "```py\nclass sqlalchemy.ext.asyncio.AsyncAttrs\n```", "```py\nfrom __future__ import annotations\n\nfrom typing import List\n\nfrom sqlalchemy import ForeignKey\nfrom sqlalchemy import func\nfrom sqlalchemy.ext.asyncio import AsyncAttrs\nfrom sqlalchemy.orm import DeclarativeBase\nfrom sqlalchemy.orm import Mapped\nfrom sqlalchemy.orm import mapped_column\nfrom sqlalchemy.orm import relationship\n\nclass Base(AsyncAttrs, DeclarativeBase):\n    pass\n\nclass A(Base):\n    __tablename__ = \"a\"\n\n    id: Mapped[int] = mapped_column(primary_key=True)\n    data: Mapped[str]\n    bs: Mapped[List[B]] = relationship()\n\nclass B(Base):\n    __tablename__ = \"b\"\n    id: Mapped[int] = mapped_column(primary_key=True)\n    a_id: Mapped[int] = mapped_column(ForeignKey(\"a.id\"))\n    data: Mapped[str]\n```", "```py\na1 = (await async_session.scalars(select(A).where(A.id == 5))).one()\n\n# use the lazy loader on ``a1.bs`` via the ``.awaitable_attrs``\n# interface, so that it may be awaited\nfor b1 in await a1.awaitable_attrs.bs:\n    print(b1)\n```", "```py\nfor b1 in await async_session.run_sync(lambda sess: a1.bs):\n    print(b1)\n```", "```py\nattribute awaitable_attrs\n```", "```py\na1 = (await async_session.scalars(select(A).where(A.id == 5))).one()\n\nsome_attribute = await a1.awaitable_attrs.some_deferred_attribute\nsome_collection = await a1.awaitable_attrs.some_collection\n```", "```py\nclass sqlalchemy.ext.asyncio.AsyncSession\n```", "```py\nattribute sync_session_class: Type[Session] = <class 'sqlalchemy.orm.session.Session'>\n```", "```py\nmethod __init__(bind: _AsyncSessionBind | None = None, *, binds: Dict[_SessionBindKey, _AsyncSessionBind] | None = None, sync_session_class: Type[Session] | None = None, **kw: Any)\n```", "```py\nmethod async aclose() \u2192 None\n```", "```py\nmethod add(instance: object, _warn: bool = True) \u2192 None\n```", "```py\nmethod add_all(instances: Iterable[object]) \u2192 None\n```", "```py\nattribute autoflush\n```", "```py\nmethod begin() \u2192 AsyncSessionTransaction\n```", "```py\nasync with async_session.begin():\n    # .. ORM transaction is begun\n```", "```py\nmethod begin_nested() \u2192 AsyncSessionTransaction\n```", "```py\nmethod async close() \u2192 None\n```", "```py\nasync classmethod close_all() \u2192 None\n```", "```py\nmethod async commit() \u2192 None\n```", "```py\nmethod async connection(bind_arguments: _BindArguments | None = None, execution_options: CoreExecuteOptionsParameter | None = None, **kw: Any) \u2192 AsyncConnection\n```", "```py\nmethod async delete(instance: object) \u2192 None\n```", "```py\nattribute deleted\n```", "```py\nattribute dirty\n```", "```py\nsome_mapped_object in session.dirty\n```", "```py\nmethod async execute(statement: Executable, params: _CoreAnyExecuteParams | None = None, *, execution_options: OrmExecuteOptionsParameter = {}, bind_arguments: _BindArguments | None = None, **kw: Any) \u2192 Result[Any]\n```", "```py\nmethod expire(instance: object, attribute_names: Iterable[str] | None = None) \u2192 None\n```", "```py\nmethod expire_all() \u2192 None\n```", "```py\nmethod expunge(instance: object) \u2192 None\n```", "```py\nmethod expunge_all() \u2192 None\n```", "```py\nmethod async flush(objects: Sequence[Any] | None = None) \u2192 None\n```", "```py\nmethod async get(entity: _EntityBindKey[_O], ident: _PKIdentityArgument, *, options: Sequence[ORMOption] | None = None, populate_existing: bool = False, with_for_update: ForUpdateParameter = None, identity_token: Any | None = None, execution_options: OrmExecuteOptionsParameter = {}) \u2192 _O | None\n```", "```py\nmethod get_bind(mapper: _EntityBindKey[_O] | None = None, clause: ClauseElement | None = None, bind: _SessionBind | None = None, **kw: Any) \u2192 Engine | Connection\n```", "```py\n# using example from \"Custom Vertical Partitioning\"\n\nimport random\n\nfrom sqlalchemy.ext.asyncio import AsyncSession\nfrom sqlalchemy.ext.asyncio import create_async_engine\nfrom sqlalchemy.ext.asyncio import async_sessionmaker\nfrom sqlalchemy.orm import Session\n\n# construct async engines w/ async drivers\nengines = {\n    'leader':create_async_engine(\"sqlite+aiosqlite:///leader.db\"),\n    'other':create_async_engine(\"sqlite+aiosqlite:///other.db\"),\n    'follower1':create_async_engine(\"sqlite+aiosqlite:///follower1.db\"),\n    'follower2':create_async_engine(\"sqlite+aiosqlite:///follower2.db\"),\n}\n\nclass RoutingSession(Session):\n    def get_bind(self, mapper=None, clause=None, **kw):\n        # within get_bind(), return sync engines\n        if mapper and issubclass(mapper.class_, MyOtherClass):\n            return engines['other'].sync_engine\n        elif self._flushing or isinstance(clause, (Update, Delete)):\n            return engines['leader'].sync_engine\n        else:\n            return engines[\n                random.choice(['follower1','follower2'])\n            ].sync_engine\n\n# apply to AsyncSession using sync_session_class\nAsyncSessionMaker = async_sessionmaker(\n    sync_session_class=RoutingSession\n)\n```", "```py\nmethod get_nested_transaction() \u2192 AsyncSessionTransaction | None\n```", "```py\nmethod async get_one(entity: _EntityBindKey[_O], ident: _PKIdentityArgument, *, options: Sequence[ORMOption] | None = None, populate_existing: bool = False, with_for_update: ForUpdateParameter = None, identity_token: Any | None = None, execution_options: OrmExecuteOptionsParameter = {}) \u2192 _O\n```", "```py\nmethod get_transaction() \u2192 AsyncSessionTransaction | None\n```", "```py\nclassmethod identity_key(class_: Type[Any] | None = None, ident: Any | Tuple[Any, ...] = None, *, instance: Any | None = None, row: Row[Any] | RowMapping | None = None, identity_token: Any | None = None) \u2192 _IdentityKeyType[Any]\n```", "```py\nattribute identity_map\n```", "```py\nmethod in_nested_transaction() \u2192 bool\n```", "```py\nmethod in_transaction() \u2192 bool\n```", "```py\nattribute info\n```", "```py\nmethod async invalidate() \u2192 None\n```", "```py\nattribute is_active\n```", "```py\nmethod is_modified(instance: object, include_collections: bool = True) \u2192 bool\n```", "```py\nreturn session.is_modified(someobject)\n```", "```py\nmethod async merge(instance: _O, *, load: bool = True, options: Sequence[ORMOption] | None = None) \u2192 _O\n```", "```py\nattribute new\n```", "```py\nattribute no_autoflush\n```", "```py\nwith session.no_autoflush:\n\n    some_object = SomeClass()\n    session.add(some_object)\n    # won't autoflush\n    some_object.related_thing = session.query(SomeRelated).first()\n```", "```py\nclassmethod object_session(instance: object) \u2192 Session | None\n```", "```py\nmethod async refresh(instance: object, attribute_names: Iterable[str] | None = None, with_for_update: ForUpdateParameter = None) \u2192 None\n```", "```py\nmethod async reset() \u2192 None\n```", "```py\nmethod async rollback() \u2192 None\n```", "```py\nmethod async run_sync(fn: ~typing.Callable[[~typing.Concatenate[~sqlalchemy.orm.session.Session, ~_P]], ~sqlalchemy.ext.asyncio.session._T], *arg: ~typing.~_P, **kw: ~typing.~_P) \u2192 _T\n```", "```py\ndef some_business_method(session: Session, param: str) -> str:\n  '''A synchronous function that does not require awaiting\n\n :param session: a SQLAlchemy Session, used synchronously\n\n :return: an optional return value is supported\n\n '''\n    session.add(MyObject(param=param))\n    session.flush()\n    return \"success\"\n\nasync def do_something_async(async_engine: AsyncEngine) -> None:\n  '''an async function that uses awaiting'''\n\n    with AsyncSession(async_engine) as async_session:\n        # run some_business_method() with a sync-style\n        # Session, proxied into an awaitable\n        return_code = await async_session.run_sync(some_business_method, param=\"param1\")\n        print(return_code)\n```", "```py\nmethod async scalar(statement: Executable, params: _CoreAnyExecuteParams | None = None, *, execution_options: OrmExecuteOptionsParameter = {}, bind_arguments: _BindArguments | None = None, **kw: Any) \u2192 Any\n```", "```py\nmethod async scalars(statement: Executable, params: _CoreAnyExecuteParams | None = None, *, execution_options: OrmExecuteOptionsParameter = {}, bind_arguments: _BindArguments | None = None, **kw: Any) \u2192 ScalarResult[Any]\n```", "```py\nmethod async stream(statement: Executable, params: _CoreAnyExecuteParams | None = None, *, execution_options: OrmExecuteOptionsParameter = {}, bind_arguments: _BindArguments | None = None, **kw: Any) \u2192 AsyncResult[Any]\n```", "```py\nmethod async stream_scalars(statement: Executable, params: _CoreAnyExecuteParams | None = None, *, execution_options: OrmExecuteOptionsParameter = {}, bind_arguments: _BindArguments | None = None, **kw: Any) \u2192 AsyncScalarResult[Any]\n```", "```py\nattribute sync_session: Session\n```", "```py\nclass sqlalchemy.ext.asyncio.AsyncSessionTransaction\n```", "```py\nmethod async commit() \u2192 None\n```", "```py\nmethod async rollback() \u2192 None\n```"]