["```py\nfrom sqlalchemy.ext import baked\nfrom sqlalchemy import bindparam\n\nbakery = baked.bakery()\n\ndef search_for_user(session, username, email=None):\n    baked_query = bakery(lambda session: session.query(User))\n    baked_query += lambda q: q.filter(User.name == bindparam(\"username\"))\n\n    baked_query += lambda q: q.order_by(User.id)\n\n    if email:\n        baked_query += lambda q: q.filter(User.email == bindparam(\"email\"))\n\n    result = baked_query(session).params(username=username, email=email).all()\n\n    return result\n```", "```py\nclass HasFooBar(object):\n    foobar = Column(Integer)\n\n    @declared_attr\n    def foobar_prop(cls):\n        return column_property(\"foobar: \" + cls.foobar)\n\nclass SomeClass(HasFooBar, Base):\n    __tablename__ = \"some_table\"\n    id = Column(Integer, primary_key=True)\n```", "```py\nclass HasFooBar(object):\n    @declared_attr\n    def foobar(cls):\n        return Column(Integer)\n\n    @declared_attr\n    def foobar_prop(cls):\n        return column_property(\"foobar: \" + cls.foobar)\n\nclass SomeClass(HasFooBar, Base):\n    __tablename__ = \"some_table\"\n    id = Column(Integer, primary_key=True)\n```", "```py\nclass HasIdMixin(object):\n    @declared_attr.cascading\n    def id(cls):\n        if has_inherited_table(cls):\n            return Column(ForeignKey(\"myclass.id\"), primary_key=True)\n        else:\n            return Column(Integer, primary_key=True)\n\nclass MyClass(HasIdMixin, Base):\n    __tablename__ = \"myclass\"\n    # ...\n\nclass MySubClass(MyClass):\n  \"\"\" \"\"\"\n\n    # ...\n```", "```py\nfrom sqlalchemy import Column, Integer, ForeignKey\nfrom sqlalchemy.orm import relationship\nfrom sqlalchemy.ext.declarative import (\n    declarative_base,\n    declared_attr,\n    AbstractConcreteBase,\n)\n\nBase = declarative_base()\n\nclass Something(Base):\n    __tablename__ = \"something\"\n    id = Column(Integer, primary_key=True)\n\nclass Abstract(AbstractConcreteBase, Base):\n    id = Column(Integer, primary_key=True)\n\n    @declared_attr\n    def something_id(cls):\n        return Column(ForeignKey(Something.id))\n\n    @declared_attr\n    def something(cls):\n        return relationship(Something)\n\nclass Concrete(Abstract):\n    __tablename__ = \"cca\"\n    __mapper_args__ = {\"polymorphic_identity\": \"cca\", \"concrete\": True}\n```", "```py\nimport time\nfrom sqlalchemy import Integer, Column, create_engine, Table\nfrom sqlalchemy.orm import Session\nfrom sqlalchemy.ext.declarative import declarative_base\n\nBase = declarative_base()\n\nclass Foo(Base):\n    __table__ = Table(\n        \"foo\",\n        Base.metadata,\n        Column(\"id\", Integer, primary_key=True),\n        Column(\"a\", Integer(), nullable=False),\n        Column(\"b\", Integer(), nullable=False),\n        Column(\"c\", Integer(), nullable=False),\n    )\n\nengine = create_engine(\"mysql+mysqldb://scott:tiger@localhost/test\", echo=True)\n\nsess = Session(engine)\n\nnow = time.time()\n\n# avoid using all() so that we don't have the overhead of building\n# a large list of full objects in memory\nfor obj in sess.query(Foo).yield_per(100).limit(1000000):\n    pass\n\nprint(\"Total time: %d\" % (time.time() - now))\n```", "```py\nrows = sess.query(Foo.a, Foo.b, Foo.c).all()\n```", "```py\n-----------------\nsize=10 num=10000                 # few rows, lots of queries\nnamedtuple: 3.60302400589         # namedtuple falls over\nkeyedtuple: 0.255059957504        # KeyedTuple very fast\nlw keyed tuple: 0.582715034485    # lw keyed trails right on KeyedTuple\n-----------------\nsize=100 num=1000                 # <--- sweet spot\nnamedtuple: 0.365247011185\nkeyedtuple: 0.24896979332\nlw keyed tuple: 0.0889317989349   # lw keyed blows both away!\n-----------------\nsize=10000 num=100\nnamedtuple: 0.572599887848\nkeyedtuple: 2.54251694679\nlw keyed tuple: 0.613876104355\n-----------------\nsize=1000000 num=10               # few queries, lots of rows\nnamedtuple: 5.79669594765         # namedtuple very fast\nkeyedtuple: 28.856498003          # KeyedTuple falls over\nlw keyed tuple: 6.74346804619     # lw keyed trails right on namedtuple\n```", "```py\n# reported by heapy, summation of SQLAlchemy objects +\n# associated dicts + weakref-related objects with core of Nova imported:\n\n    Before: total count 26477 total bytes 7975712\n    After: total count 18181 total bytes 4236456\n\n# reported for the Python module space overall with the\n# core of Nova imported:\n\n    Before: Partition of a set of 355558 objects. Total size = 61661760 bytes.\n    After: Partition of a set of 346034 objects. Total size = 57808016 bytes.\n```", "```py\n    class MyClass(SomeMixin, Base):\n        __tablename__ = \"my_table\"\n        # ...\n\n    session = Session(binds={SomeMixin: some_engine})\n    ```", "```py\n    class BaseClass(Base):\n        __tablename__ = \"base\"\n\n        # ...\n\n    class ConcreteSubClass(BaseClass):\n        __tablename__ = \"concrete\"\n\n        # ...\n\n        __mapper_args__ = {\"concrete\": True}\n\n    session = Session(binds={base_table: some_engine, concrete_table: some_other_engine})\n    ```", "```py\n    session.query(User).count()\n    ```", "```py\n    session.query(User).filter(User.id == 15).update(\n        {\"name\": \"foob\"}, synchronize_session=\"fetch\"\n    )\n\n    session.query(User).filter(User.id == 15).delete(synchronize_session=\"fetch\")\n    ```", "```py\n    session.query(User.id, User.name).all()\n    ```", "```py\n    class User(Base):\n        ...\n\n        score = column_property(func.coalesce(self.tables.users.c.name, None))\n\n    session.query(func.max(User.score)).scalar()\n    ```", "```py\nclass SomeObject(Base):\n    # ...\n\n    @hybrid_property\n    def some_prop(self):\n        return self.value + 5\n\ninspect(SomeObject).all_orm_descriptors.some_prop.info[\"foo\"] = \"bar\"\n```", "```py\nclass A(Base):\n    __tablename__ = \"a\"\n\n    id = Column(Integer, primary_key=True)\n\nclass B(Base):\n    __tablename__ = \"b\"\n\n    id = Column(Integer, primary_key=True)\n    a_id = Column(ForeignKey(\"a.id\"))\n\nA.b = column_property(select([func.max(B.id)]).where(B.a_id == A.id).correlate(A))\n```", "```py\nprint(sess.query(A, a1).order_by(a1.b))\n```", "```py\nSELECT  a.id  AS  a_id,  (SELECT  max(b.id)  AS  max_1  FROM  b\nWHERE  b.a_id  =  a.id)  AS  anon_1,  a_1.id  AS  a_1_id,\n(SELECT  max(b.id)  AS  max_2\nFROM  b  WHERE  b.a_id  =  a_1.id)  AS  anon_2\nFROM  a,  a  AS  a_1  ORDER  BY  anon_1\n```", "```py\nSELECT  a.id  AS  a_id,  (SELECT  max(b.id)  AS  max_1\nFROM  b  WHERE  b.a_id  =  a.id)  AS  anon_1,  a_1.id  AS  a_1_id,\n(SELECT  max(b.id)  AS  max_2\nFROM  b  WHERE  b.a_id  =  a_1.id)  AS  anon_2\nFROM  a,  a  AS  a_1  ORDER  BY  anon_2\n```", "```py\nclass A(Base):\n    __tablename__ = \"a\"\n\n    id = Column(Integer, primary_key=True)\n    type = Column(String)\n\n    __mapper_args__ = {\"polymorphic_on\": type, \"with_polymorphic\": \"*\"}\n```", "```py\nSELECT  a.id  AS  a_id,  a.type  AS  a_type,  (SELECT  max(b.id)  AS  max_1\nFROM  b  WHERE  b.a_id  =  a.id)  AS  anon_1\nFROM  a  ORDER  BY  (SELECT  max(b.id)  AS  max_2\nFROM  b  WHERE  b.a_id  =  a.id)\n```", "```py\nSELECT  a.id  AS  a_id,  a.type  AS  a_type,  (SELECT  max(b.id)  AS  max_1\nFROM  b  WHERE  b.a_id  =  a.id)  AS  anon_1\nFROM  a  ORDER  BY  anon_1\n```", "```py\nsel = select([table]).limit(bindparam(\"mylimit\")).offset(bindparam(\"myoffset\"))\n```", "```py\n>>> result = connection.execute(stmt)\n>>> result.fetchone()\n(1, 'x')\n>>> result.fetchone()\nNone  # indicates no more rows\n>>> result.fetchone()\nexception: ResourceClosedError\n```", "```py\n>>> result = connection.execute(stmt)\n>>> result.fetchone()\n(1, 'x')\n>>> result.fetchone()\nNone  # indicates no more rows\n>>> result.fetchone()\nNone  # still None\n>>> result.fetchall()\n[]\n>>> result.close()\n>>> result.fetchone()\nexception: ResourceClosedError  # *now* it raises\n```", "```py\nmetadata = MetaData(naming_convention={\"ck\": \"ck_%(table_name)s_%(column_0_name)s\"})\n\nfoo = Table(\"foo\", metadata, Column(\"value\", Integer))\n\nCheckConstraint(foo.c.value > 5)\n```", "```py\nCREATE  TABLE  foo  (\n  value  INTEGER,\n  CONSTRAINT  ck_foo_value  CHECK  (value  >  5)\n)\n```", "```py\nfrom sqlalchemy import Table, Column, MetaData, Integer, UniqueConstraint\n\nm = MetaData()\n\nt = Table(\"t\", m, Column(\"a\", Integer), Column(\"b\", Integer))\n\nuq = UniqueConstraint(t.c.a, t.c.b)  # will auto-attach to Table\n\nassert uq in t.constraints\n```", "```py\nfrom sqlalchemy import Table, Column, MetaData, Integer, UniqueConstraint\n\nm = MetaData()\n\na = Column(\"a\", Integer)\nb = Column(\"b\", Integer)\n\nuq = UniqueConstraint(a, b)\n\nt = Table(\"t\", m, a, b)\n\nassert uq in t.constraints  # constraint auto-attached\n```", "```py\nfrom sqlalchemy import Table, Column, MetaData, Integer, UniqueConstraint\n\nm = MetaData()\n\na = Column(\"a\", Integer)\nb = Column(\"b\", Integer)\n\nuq = UniqueConstraint(a, \"b\")\n\nt = Table(\"t\", m, a, b)\n\n# constraint *not* auto-attached, as we do not have tracking\n# to locate when a name 'b' becomes available on the table\nassert uq not in t.constraints\n```", "```py\nfrom sqlalchemy import Table, Column, MetaData, Integer, UniqueConstraint\n\nm = MetaData()\n\na = Column(\"a\", Integer)\nb = Column(\"b\", Integer)\n\nt = Table(\"t\", m, a, b)\n\nuq = UniqueConstraint(a, \"b\")\n\n# constraint auto-attached normally as in older versions\nassert uq in t.constraints\n```", "```py\nfrom sqlalchemy import Table, Column, MetaData, Integer, select, func\n\nm = MetaData()\n\nt = Table(\n    \"t\", m, Column(\"x\", Integer), Column(\"y\", Integer, default=func.somefunction())\n)\n\nstmt = select([t.c.x])\nprint(t.insert().from_select([\"x\"], stmt))\n```", "```py\nINSERT  INTO  t  (x,  y)  SELECT  t.x,  somefunction()  AS  somefunction_1\nFROM  t\n```", "```py\nfrom sqlalchemy import Table, Column, MetaData, Text\nfrom sqlalchemy.schema import CreateTable\nfrom sqlalchemy.dialects.postgresql import ARRAY, array\nfrom sqlalchemy.dialects import postgresql\n\nmetadata = MetaData()\n\ntbl = Table(\n    \"derp\",\n    metadata,\n    Column(\"arr\", ARRAY(Text), server_default=array([\"foo\", \"bar\", \"baz\"])),\n)\n\nprint(CreateTable(tbl).compile(dialect=postgresql.dialect()))\n```", "```py\nCREATE  TABLE  derp  (\n  arr  TEXT[]  DEFAULT  ARRAY['foo',  'bar',  'baz']\n)\n```", "```py\nfrom sqlalchemy import create_engine, Unicode, select, cast\nimport random\nimport warnings\n\ne = create_engine(\"sqlite://\")\n\n# Use the \"once\" filter (which is also the default for Python\n# warnings).  Exactly ten of these warnings will\n# be emitted; beyond that, the Python warnings registry will accumulate\n# new values as dupes of one of the ten existing.\nwarnings.filterwarnings(\"once\")\n\nfor i in range(1000):\n    e.execute(\n        select([cast((\"foo_%d\" % random.randint(0, 1000000)).encode(\"ascii\"), Unicode)])\n    )\n```", "```py\n/path/lib/sqlalchemy/sql/sqltypes.py:186: SAWarning: Unicode type received\n  non-unicode bind param value 'foo_4852'. (this warning may be\n  suppressed after 10 occurrences)\n```", "```py\nclass User(Base):\n    __tablename__ = \"user\"\n\n    id = Column(Integer, primary_key=True)\n    name = Column(\"user_name\", String(50))\n```", "```py\nsession.query(User).update({\"user_name\": \"moonbeam\"})\n```", "```py\nsession.query(User).update({\"name\": \"moonbeam\"})\n```", "```py\nsession.query(User).update({User.name: \"moonbeam\"})\n```", "```py\nclass User(Base):\n    __tablename__ = \"user\"\n\n    id = Column(Integer, primary_key=True)\n    name = Column(\"user_name\", String(50))\n\n    @hybrid_property\n    def fullname(self):\n        return self.name\n\nsession.query(User).update({\"fullname\": \"moonbeam\"})\n```", "```py\nsession.query(Address).filter(Address.user == User(id=None))\n```", "```py\nSELECT  address.id  AS  address_id,  address.user_id  AS  address_user_id,\naddress.email_address  AS  address_email_address\nFROM  address  WHERE  ?  =  address.user_id\n(None,)\n```", "```py\nSELECT  address.id  AS  address_id,  address.user_id  AS  address_user_id,\naddress.email_address  AS  address_email_address\nFROM  address  WHERE  address.user_id  IS  NULL\n```", "```py\nSAWarning: Got None for value of column user.id; this is unsupported\nfor a relationship comparison and will not currently produce an\nIS comparison (but may in a future release)\n```", "```py\nclass A(Base):\n    __tablename__ = \"a\"\n    id = Column(Integer, primary_key=True)\n\nclass B(Base):\n    __tablename__ = \"b\"\n    id = Column(Integer, primary_key=True)\n    a_id = Column(ForeignKey(\"a.id\"))\n    a = relationship(\"A\")\n```", "```py\ns = Session(autoflush=False)\na1 = A(id=7)\ns.add(a1)\ns.commit()\n\na1.id = 10\n```", "```py\ns.query(B).filter(B.a == a1)\n```", "```py\nSELECT  b.id  AS  b_id,  b.a_id  AS  b_a_id\nFROM  b\nWHERE  ?  =  b.a_id\n(10,)\n```", "```py\ns.query(B).filter(B.a != a1)\n```", "```py\nSELECT  b.id  AS  b_id,  b.a_id  AS  b_a_id\nFROM  b\nWHERE  b.a_id  !=  ?  OR  b.a_id  IS  NULL\n(7,)\n```", "```py\nSELECT  b.id,  b.a_id\nFROM  b\nWHERE  b.a_id  !=  :a_id_1  OR  b.a_id  IS  NULL\n-- {u'a_id_1': symbol('NEVER_SET')}\n```", "```py\n>>> obj = Foo()\n```", "```py\n>>> obj.someattr\nNone\n```", "```py\n>>> inspect(obj).attrs.someattr.history\nHistory(added=(), unchanged=[None], deleted=())   # 0.9 and below\n```", "```py\n>>> obj = Foo()\n>>> obj.someattr = None\n>>> inspect(obj).attrs.someattr.history\nHistory(added=[None], unchanged=(), deleted=())  # all versions\n```", "```py\n>>> obj = Foo()\n>>> obj.someattr\nNone\n>>> inspect(obj).attrs.someattr.history\nHistory(added=(), unchanged=(), deleted=())  # 1.0\n>>> obj.someattr = None\n>>> inspect(obj).attrs.someattr.history\nHistory(added=[None], unchanged=(), deleted=())\n```", "```py\nclass A(Base):\n    __tablename__ = \"table_a\"\n\n    id = Column(Integer, primary_key=True)\n\nclass B(Base):\n    __tablename__ = \"table_b\"\n\n    id = Column(Integer, primary_key=True)\n    a_id = Column(ForeignKey(\"table_a.id\"))\n    a = relationship(A)\n```", "```py\na1 = A(id=1)\na2 = A(id=2)\nsession.add_all([a1, a2])\nsession.flush()\n\nb1 = B()\nb1.a = a1  # we expect a_id to be '1'; takes precedence in 0.9 and 1.0\n\nb2 = B()\nb2.a = None  # we expect a_id to be None; takes precedence only in 1.0\n\nb1.a_id = 2\nb2.a_id = 2\n\nsession.add_all([b1, b2])\nsession.commit()\n\nassert b1.a is a1  # passes in both 0.9 and 1.0\nassert b2.a is None  # passes in 1.0, in 0.9 it's a2\n```", "```py\nu1 = sess.query(User).first()\nsess.delete(u1)\n\nsess.flush()\n\nassert u1 not in sess\nassert inspect(u1).session is sess  # this is normal before commit\n\nsess.expunge(u1)\n\nassert u1 not in sess\nassert inspect(u1).session is None  # would fail\n```", "```py\nq = sess.query(Object).options(lazyload(\"*\")).yield_per(100)\n```", "```py\nq = sess.query(Object).enable_eagerloads(False).yield_per(100)\n```", "```py\nq = (\n    sess.query(Object)\n    .options(lazyload(\"*\"), joinedload(\"some_manytoone\"))\n    .yield_per(100)\n)\n```", "```py\nfrom sqlalchemy import Integer, Column, String, ForeignKey\nfrom sqlalchemy.orm import Session, relationship\nfrom sqlalchemy.ext.declarative import declarative_base\n\nBase = declarative_base()\n\nclass A(Base):\n    __tablename__ = \"a\"\n    id = Column(Integer, primary_key=True)\n    bs = relationship(\"B\")\n\nclass B(Base):\n    __tablename__ = \"b\"\n    id = Column(Integer, primary_key=True)\n    a_id = Column(ForeignKey(\"a.id\"))\n```", "```py\nprint(s.query(A).join(A.bs).join(A.bs))\n```", "```py\nSELECT  a.id  AS  a_id\nFROM  a  JOIN  b  ON  a.id  =  b.a_id\n```", "```py\ns.query(A).join(A.bs).filter(B.foo == \"bar\").reset_joinpoint().join(A.bs, B.cs).filter(\n    C.bar == \"bat\"\n)\n```", "```py\nSAWarning: Pathed join target A.bs has already been joined to; skipping\n```", "```py\nprint(s.query(A).join(B, B.a_id == A.id).join(B, B.a_id == A.id))\n```", "```py\nSELECT  a.id  AS  a_id\nFROM  a  JOIN  b  ON  b.a_id  =  a.id  JOIN  b  AS  b_1  ON  b_1.a_id  =  a.id\n```", "```py\nSELECT  a.id  AS  a_id\nFROM  a  JOIN  b  ON  b.a_id  =  a.id  JOIN  b  ON  b.a_id  =  a.id\n```", "```py\nfrom sqlalchemy import Integer, Column, String, ForeignKey\nfrom sqlalchemy.orm import Session, relationship\nfrom sqlalchemy.ext.declarative import declarative_base\n\nBase = declarative_base()\n\nclass A(Base):\n    __tablename__ = \"a\"\n\n    id = Column(Integer, primary_key=True)\n    type = Column(String)\n\n    __mapper_args__ = {\"polymorphic_on\": type, \"polymorphic_identity\": \"a\"}\n\nclass ASub1(A):\n    __mapper_args__ = {\"polymorphic_identity\": \"asub1\"}\n\nclass ASub2(A):\n    __mapper_args__ = {\"polymorphic_identity\": \"asub2\"}\n\nclass B(Base):\n    __tablename__ = \"b\"\n\n    id = Column(Integer, primary_key=True)\n\n    a_id = Column(Integer, ForeignKey(\"a.id\"))\n\n    a = relationship(\"A\", primaryjoin=\"B.a_id == A.id\", backref=\"b\")\n\ns = Session()\n\nprint(s.query(ASub1).join(B, ASub1.b).join(ASub2, B.a))\n\nprint(s.query(ASub1).join(B, ASub1.b).join(ASub2, ASub2.id == B.a_id))\n```", "```py\nSELECT  a.id  AS  a_id,  a.type  AS  a_type\nFROM  a  JOIN  b  ON  b.a_id  =  a.id  JOIN  a  ON  b.a_id  =  a.id  AND  a.type  IN  (:type_1)\nWHERE  a.type  IN  (:type_2)\n```", "```py\nSELECT  a.id  AS  a_id,  a.type  AS  a_type\nFROM  a  JOIN  b  ON  b.a_id  =  a.id  JOIN  a  AS  a_1\nON  a_1.id  =  b.a_id  AND  a_1.type  IN  (:type_1)\nWHERE  a_1.type  IN  (:type_2)\n```", "```py\nasub2_alias = aliased(ASub2)\n\nprint(s.query(ASub1).join(B, ASub1.b).join(asub2_alias, B.a.of_type(asub2_alias)))\n```", "```py\nfrom sqlalchemy.orm import Bundle\n\nclass DictBundle(Bundle):\n    def create_row_processor(self, query, procs, labels):\n  \"\"\"Override create_row_processor to return values as dictionaries\"\"\"\n\n        def proc(row, result):\n            return dict(zip(labels, (proc(row, result) for proc in procs)))\n\n        return proc\n```", "```py\nfrom sqlalchemy.orm import Bundle\n\nclass DictBundle(Bundle):\n    def create_row_processor(self, query, procs, labels):\n  \"\"\"Override create_row_processor to return values as dictionaries\"\"\"\n\n        def proc(row):\n            return dict(zip(labels, (proc(row) for proc in procs)))\n\n        return proc\n```", "```py\nquery(User).options(\n    joinedload(\"orders\", innerjoin=False).joinedload(\"items\", innerjoin=True)\n)\n```", "```py\nFROM users LEFT OUTER JOIN (orders JOIN items ON <onclause>) ON <onclause>\n```", "```py\nquery(User).options(\n    joinedload(\"orders\", innerjoin=False).joinedload(\"items\", innerjoin=\"unnested\")\n)\n```", "```py\nFROM users LEFT OUTER JOIN orders ON <onclause> LEFT OUTER JOIN items ON <onclause>\n```", "```py\nclass A(Base):\n    __tablename__ = \"a\"\n    id = Column(Integer, primary_key=True)\n    b = relationship(\"B\", uselist=False)\n\nclass B(Base):\n    __tablename__ = \"b\"\n    id = Column(Integer, primary_key=True)\n    a_id = Column(ForeignKey(\"a.id\"))\n\ns = Session()\nprint(s.query(A).options(joinedload(A.b)).limit(5))\n```", "```py\nSELECT  anon_1.a_id  AS  anon_1_a_id,  b_1.id  AS  b_1_id,  b_1.a_id  AS  b_1_a_id\nFROM  (SELECT  a.id  AS  a_id\nFROM  a  LIMIT  :param_1)  AS  anon_1\nLEFT  OUTER  JOIN  b  AS  b_1  ON  anon_1.a_id  =  b_1.a_id\n```", "```py\nSELECT  a.id  AS  a_id,  b_1.id  AS  b_1_id,  b_1.a_id  AS  b_1_a_id\nFROM  a  LEFT  OUTER  JOIN  b  AS  b_1  ON  a.id  =  b_1.a_id\nLIMIT  :param_1\n```", "```py\nclass Widget(Base):\n    __table__ = \"widget_table\"\n\nclass FooWidget(Widget):\n    pass\n```", "```py\nsess.query(FooWidget).from_self().all()\n```", "```py\nSELECT\n  anon_1.widgets_id  AS  anon_1_widgets_id,\n  anon_1.widgets_type  AS  anon_1_widgets_type\nFROM  (SELECT  widgets.id  AS  widgets_id,  widgets.type  AS  widgets_type,\nFROM  widgets)  AS  anon_1\nWHERE  anon_1.widgets_type  IN  (?)\n```", "```py\nSELECT\n  anon_1.widgets_id  AS  anon_1_widgets_id,\n  anon_1.widgets_type  AS  anon_1_widgets_type\nFROM  (SELECT  widgets.id  AS  widgets_id,  widgets.type  AS  widgets_type,\nFROM  widgets\nWHERE  widgets.type  IN  (?))  AS  anon_1\n```", "```py\nsess.query(FooWidget.id).count()\n```", "```py\nSELECT  count(*)  AS  count_1\nFROM  (SELECT  widgets.id  AS  widgets_id\nFROM  widgets\nWHERE  widgets.type  IN  (?))  AS  anon_1\n```", "```py\nclass Widget(Base):\n    __tablename__ = \"widget\"\n    id = Column(Integer, primary_key=True)\n    type = Column(String)\n    related_id = Column(ForeignKey(\"related.id\"))\n    related = relationship(\"Related\", backref=\"widget\")\n    __mapper_args__ = {\"polymorphic_on\": type}\n\nclass FooWidget(Widget):\n    __mapper_args__ = {\"polymorphic_identity\": \"foo\"}\n\nclass Related(Base):\n    __tablename__ = \"related\"\n    id = Column(Integer, primary_key=True)\n```", "```py\ns.query(Related).join(FooWidget, Related.widget).all()\n```", "```py\nSELECT  related.id  AS  related_id\nFROM  related  JOIN  widget  ON  related.id  =  widget.related_id  AND  widget.type  IN  (:type_1)\n```", "```py\n# ON clause will now render as\n# related.id = widget.related_id AND widget.type IN (:type_1)\ns.query(Related).join(FooWidget, FooWidget.related_id == Related.id).all()\n```", "```py\n# ON clause will now render as\n# related.id = widget.related_id AND widget.type IN (:type_1)\ns.query(Related).join(FooWidget).all()\n```", "```py\n# the argument sent to where() is a full SQL expression\nstmt = select([sometable]).where(\"somecolumn = 'value'\")\n```", "```py\n# This is a normal Core expression with a string argument -\n# we aren't talking about this!!\nstmt = select([sometable]).where(sometable.c.somecolumn == \"value\")\n```", "```py\nstmt = select([\"a\", \"b\"]).where(\"a = b\").select_from(\"sometable\")\n```", "```py\nSAWarning: Textual column expression 'a' should be explicitly declared\nwith text('a'), or use column('a') for more specificity\n(this warning may be suppressed after 10 occurrences)\n\nSAWarning: Textual column expression 'b' should be explicitly declared\nwith text('b'), or use column('b') for more specificity\n(this warning may be suppressed after 10 occurrences)\n\nSAWarning: Textual SQL expression 'a = b' should be explicitly declared\nas text('a = b') (this warning may be suppressed after 10 occurrences)\n\nSAWarning: Textual SQL FROM expression 'sometable' should be explicitly\ndeclared as text('sometable'), or use table('sometable') for more\nspecificity (this warning may be suppressed after 10 occurrences)\n```", "```py\nimport warnings\n\nwarnings.simplefilter(\"error\")  # all warnings raise an exception\n```", "```py\nfrom sqlalchemy import select, text\n\nstmt = (\n    select([text(\"a\"), text(\"b\")]).where(text(\"a = b\")).select_from(text(\"sometable\"))\n)\n```", "```py\nfrom sqlalchemy import select, text, column, table\n\nstmt = (\n    select([column(\"a\"), column(\"b\")])\n    .where(text(\"a = b\"))\n    .select_from(table(\"sometable\"))\n)\n```", "```py\nstmt = (\n    select([user.c.name, func.count(user.c.id).label(\"id_count\")])\n    .group_by(\"name\")\n    .order_by(\"id_count\")\n)\n```", "```py\nSELECT  users.name,  count(users.id)  AS  id_count\nFROM  users  GROUP  BY  users.name  ORDER  BY  id_count\n```", "```py\nstmt = select([user.c.name, func.count(user.c.id).label(\"id_count\")]).order_by(\n    \"some_label\"\n)\n```", "```py\nSAWarning: Can't resolve label reference 'some_label'; converting to\ntext() (this warning may be suppressed after 10 occurrences)\n```", "```py\nSELECT  users.name,  count(users.id)  AS  id_count\nFROM  users  ORDER  BY  some_label\n```", "```py\nstmt = select([users]).order_by(text(\"some special expression\"))\n```", "```py\nimport itertools\n\ncounter = itertools.count(1)\nt = Table(\n    \"my_table\",\n    metadata,\n    Column(\"id\", Integer, default=lambda: next(counter)),\n    Column(\"data\", String),\n)\n\nconn.execute(\n    t.insert().values(\n        [\n            {\"data\": \"d1\"},\n            {\"data\": \"d2\"},\n            {\"data\": \"d3\"},\n        ]\n    )\n)\n```", "```py\nINSERT  INTO  my_table  (id,  data)  VALUES  (?,  ?),  (?,  ?),  (?,  ?)\n(1,  'd1',  2,  'd2',  3,  'd3')\n```", "```py\nIncorrect number of bindings supplied. The current statement uses 6,\nand there are 4 supplied.\n[SQL: u'INSERT INTO my_table (id, data) VALUES (?, ?), (?, ?), (?, ?)']\n[parameters: (1, 'd1', 'd2', 'd3')]\n```", "```py\nINSERT  INTO  my_table  (id,  data)  VALUES  (:id,  :data_0),  (:id,  :data_1),  (:id,  :data_2)\n-- {u'data_2': 'd3', u'data_1': 'd2', u'data_0': 'd1', 'id': 1}\n```", "```py\nt = Table(\n    \"my_table\",\n    metadata,\n    Column(\"id\", Integer, primary_key=True),\n    Column(\"data\", String, server_default=\"some default\"),\n)\n\nconn.execute(\n    t.insert().values(\n        [\n            {\"data\": \"d1\"},\n            {\"data\": \"d2\"},\n            {},\n        ]\n    )\n)\n```", "```py\nsqlalchemy.exc.CompileError: INSERT value for column my_table.data is\nexplicitly rendered as a boundparameter in the VALUES clause; a\nPython-side value or SQL expression is required\n```", "```py\nINSERT  INTO  my_table  (data)  VALUES  (:data_0),  (:data_1),  (:data_0)\n-- {u'data_1': 'd2', u'data_0': 'd1'}\n```", "```py\nmy_table = Table(\"my_table\", metadata, autoload_with=some_engine)\n```", "```py\nselect([null(), null()])\n```", "```py\ntable = Table(\n    \"sometable\", metadata, Column(\"some_enum\", ENUM(\"a\", \"b\", \"c\", name=\"myenum\"))\n)\n\ntable.create(engine)  # will emit CREATE TYPE and CREATE TABLE\ntable.drop(engine)  # will emit DROP TABLE and DROP TYPE - new for 1.0\n```", "```py\nmy_enum = ENUM(\"a\", \"b\", \"c\", name=\"myenum\", metadata=metadata)\n\ntable = Table(\"sometable\", metadata, Column(\"some_enum\", my_enum))\n\n# will fail: ENUM 'my_enum' does not exist\ntable.create(engine)\n\n# will check for enum and emit CREATE TYPE\ntable.create(engine, checkfirst=True)\n\ntable.drop(engine)  # will emit DROP TABLE, *not* DROP TYPE\n\nmetadata.drop_all(engine)  # will emit DROP TYPE\n\nmetadata.create_all(engine)  # will emit CREATE TYPE\n```", "```py\nfrom sqlalchemy import inspect, create_engine\n\nengine = create_engine(\"postgresql+psycopg2://host/dbname\")\ninsp = inspect(engine)\nprint(insp.get_enums())\n```", "```py\nfrom sqlalchemy import *\n\nmetadata = MetaData()\nuser_tmp = Table(\n    \"user_tmp\",\n    metadata,\n    Column(\"id\", INT, primary_key=True),\n    Column(\"name\", VARCHAR(50)),\n    prefixes=[\"TEMPORARY\"],\n)\n\ne = create_engine(\"postgresql://scott:tiger@localhost/test\", echo=\"debug\")\nwith e.begin() as conn:\n    user_tmp.create(conn, checkfirst=True)\n\n    # checkfirst will succeed\n    user_tmp.create(conn, checkfirst=True)\n```", "```py\nfrom sqlalchemy import *\n\nmetadata = MetaData()\nuser_tmp = Table(\n    \"user_tmp\",\n    metadata,\n    Column(\"id\", INT, primary_key=True),\n    Column(\"name\", VARCHAR(50)),\n    prefixes=[\"TEMPORARY\"],\n)\n\ne = create_engine(\"postgresql://scott:tiger@localhost/test\", echo=\"debug\")\nwith e.begin() as conn:\n    user_tmp.create(conn, checkfirst=True)\n\n    m2 = MetaData()\n    user = Table(\n        \"user_tmp\",\n        m2,\n        Column(\"id\", INT, primary_key=True),\n        Column(\"name\", VARCHAR(50)),\n    )\n\n    # in 0.9, *will create* the new table, overwriting the old one.\n    # in 1.0, *will not create* the new table\n    user.create(conn, checkfirst=True)\n```", "```py\nfunc.count(1).filter(True)\n```", "```py\n>>> connection.execute(\n...     select(\n...         [\n...             matchtable.c.title.match(\"Agile Ruby Programming\").label(\"ruby\"),\n...             matchtable.c.title.match(\"Dive Python\").label(\"python\"),\n...             matchtable.c.title,\n...         ]\n...     ).order_by(matchtable.c.id)\n... )\n[\n (2.0, 0.0, 'Agile Web Development with Ruby On Rails'),\n (0.0, 2.0, 'Dive Into Python'),\n (2.0, 0.0, \"Programming Matz's Ruby\"),\n (0.0, 0.0, 'The Definitive Guide to Django'),\n (0.0, 1.0, 'Python in a Nutshell')\n]\n```", "```py\nengine = create_engine(\n    \"mssql+pyodbc://scott:tiger@myhost:port/databasename?driver=SQL+Server+Native+Client+10.0\"\n)\n```", "```py\nincluded_parts = (\n    select([part.c.sub_part, part.c.part, part.c.quantity])\n    .where(part.c.part == \"p1\")\n    .cte(name=\"included_parts\", recursive=True)\n    .suffix_with(\n        \"search depth first by part set ord1\",\n        \"cycle part set y_cycle to 1 default 0\",\n        dialect=\"oracle\",\n    )\n)\n```", "```py\nfrom sqlalchemy.ext import baked\nfrom sqlalchemy import bindparam\n\nbakery = baked.bakery()\n\ndef search_for_user(session, username, email=None):\n    baked_query = bakery(lambda session: session.query(User))\n    baked_query += lambda q: q.filter(User.name == bindparam(\"username\"))\n\n    baked_query += lambda q: q.order_by(User.id)\n\n    if email:\n        baked_query += lambda q: q.filter(User.email == bindparam(\"email\"))\n\n    result = baked_query(session).params(username=username, email=email).all()\n\n    return result\n```", "```py\nclass HasFooBar(object):\n    foobar = Column(Integer)\n\n    @declared_attr\n    def foobar_prop(cls):\n        return column_property(\"foobar: \" + cls.foobar)\n\nclass SomeClass(HasFooBar, Base):\n    __tablename__ = \"some_table\"\n    id = Column(Integer, primary_key=True)\n```", "```py\nclass HasFooBar(object):\n    @declared_attr\n    def foobar(cls):\n        return Column(Integer)\n\n    @declared_attr\n    def foobar_prop(cls):\n        return column_property(\"foobar: \" + cls.foobar)\n\nclass SomeClass(HasFooBar, Base):\n    __tablename__ = \"some_table\"\n    id = Column(Integer, primary_key=True)\n```", "```py\nclass HasIdMixin(object):\n    @declared_attr.cascading\n    def id(cls):\n        if has_inherited_table(cls):\n            return Column(ForeignKey(\"myclass.id\"), primary_key=True)\n        else:\n            return Column(Integer, primary_key=True)\n\nclass MyClass(HasIdMixin, Base):\n    __tablename__ = \"myclass\"\n    # ...\n\nclass MySubClass(MyClass):\n  \"\"\" \"\"\"\n\n    # ...\n```", "```py\nfrom sqlalchemy import Column, Integer, ForeignKey\nfrom sqlalchemy.orm import relationship\nfrom sqlalchemy.ext.declarative import (\n    declarative_base,\n    declared_attr,\n    AbstractConcreteBase,\n)\n\nBase = declarative_base()\n\nclass Something(Base):\n    __tablename__ = \"something\"\n    id = Column(Integer, primary_key=True)\n\nclass Abstract(AbstractConcreteBase, Base):\n    id = Column(Integer, primary_key=True)\n\n    @declared_attr\n    def something_id(cls):\n        return Column(ForeignKey(Something.id))\n\n    @declared_attr\n    def something(cls):\n        return relationship(Something)\n\nclass Concrete(Abstract):\n    __tablename__ = \"cca\"\n    __mapper_args__ = {\"polymorphic_identity\": \"cca\", \"concrete\": True}\n```", "```py\nimport time\nfrom sqlalchemy import Integer, Column, create_engine, Table\nfrom sqlalchemy.orm import Session\nfrom sqlalchemy.ext.declarative import declarative_base\n\nBase = declarative_base()\n\nclass Foo(Base):\n    __table__ = Table(\n        \"foo\",\n        Base.metadata,\n        Column(\"id\", Integer, primary_key=True),\n        Column(\"a\", Integer(), nullable=False),\n        Column(\"b\", Integer(), nullable=False),\n        Column(\"c\", Integer(), nullable=False),\n    )\n\nengine = create_engine(\"mysql+mysqldb://scott:tiger@localhost/test\", echo=True)\n\nsess = Session(engine)\n\nnow = time.time()\n\n# avoid using all() so that we don't have the overhead of building\n# a large list of full objects in memory\nfor obj in sess.query(Foo).yield_per(100).limit(1000000):\n    pass\n\nprint(\"Total time: %d\" % (time.time() - now))\n```", "```py\nrows = sess.query(Foo.a, Foo.b, Foo.c).all()\n```", "```py\n-----------------\nsize=10 num=10000                 # few rows, lots of queries\nnamedtuple: 3.60302400589         # namedtuple falls over\nkeyedtuple: 0.255059957504        # KeyedTuple very fast\nlw keyed tuple: 0.582715034485    # lw keyed trails right on KeyedTuple\n-----------------\nsize=100 num=1000                 # <--- sweet spot\nnamedtuple: 0.365247011185\nkeyedtuple: 0.24896979332\nlw keyed tuple: 0.0889317989349   # lw keyed blows both away!\n-----------------\nsize=10000 num=100\nnamedtuple: 0.572599887848\nkeyedtuple: 2.54251694679\nlw keyed tuple: 0.613876104355\n-----------------\nsize=1000000 num=10               # few queries, lots of rows\nnamedtuple: 5.79669594765         # namedtuple very fast\nkeyedtuple: 28.856498003          # KeyedTuple falls over\nlw keyed tuple: 6.74346804619     # lw keyed trails right on namedtuple\n```", "```py\n# reported by heapy, summation of SQLAlchemy objects +\n# associated dicts + weakref-related objects with core of Nova imported:\n\n    Before: total count 26477 total bytes 7975712\n    After: total count 18181 total bytes 4236456\n\n# reported for the Python module space overall with the\n# core of Nova imported:\n\n    Before: Partition of a set of 355558 objects. Total size = 61661760 bytes.\n    After: Partition of a set of 346034 objects. Total size = 57808016 bytes.\n```", "```py\n    class MyClass(SomeMixin, Base):\n        __tablename__ = \"my_table\"\n        # ...\n\n    session = Session(binds={SomeMixin: some_engine})\n    ```", "```py\n    class BaseClass(Base):\n        __tablename__ = \"base\"\n\n        # ...\n\n    class ConcreteSubClass(BaseClass):\n        __tablename__ = \"concrete\"\n\n        # ...\n\n        __mapper_args__ = {\"concrete\": True}\n\n    session = Session(binds={base_table: some_engine, concrete_table: some_other_engine})\n    ```", "```py\n    session.query(User).count()\n    ```", "```py\n    session.query(User).filter(User.id == 15).update(\n        {\"name\": \"foob\"}, synchronize_session=\"fetch\"\n    )\n\n    session.query(User).filter(User.id == 15).delete(synchronize_session=\"fetch\")\n    ```", "```py\n    session.query(User.id, User.name).all()\n    ```", "```py\n    class User(Base):\n        ...\n\n        score = column_property(func.coalesce(self.tables.users.c.name, None))\n\n    session.query(func.max(User.score)).scalar()\n    ```", "```py\nclass SomeObject(Base):\n    # ...\n\n    @hybrid_property\n    def some_prop(self):\n        return self.value + 5\n\ninspect(SomeObject).all_orm_descriptors.some_prop.info[\"foo\"] = \"bar\"\n```", "```py\nclass A(Base):\n    __tablename__ = \"a\"\n\n    id = Column(Integer, primary_key=True)\n\nclass B(Base):\n    __tablename__ = \"b\"\n\n    id = Column(Integer, primary_key=True)\n    a_id = Column(ForeignKey(\"a.id\"))\n\nA.b = column_property(select([func.max(B.id)]).where(B.a_id == A.id).correlate(A))\n```", "```py\nprint(sess.query(A, a1).order_by(a1.b))\n```", "```py\nSELECT  a.id  AS  a_id,  (SELECT  max(b.id)  AS  max_1  FROM  b\nWHERE  b.a_id  =  a.id)  AS  anon_1,  a_1.id  AS  a_1_id,\n(SELECT  max(b.id)  AS  max_2\nFROM  b  WHERE  b.a_id  =  a_1.id)  AS  anon_2\nFROM  a,  a  AS  a_1  ORDER  BY  anon_1\n```", "```py\nSELECT  a.id  AS  a_id,  (SELECT  max(b.id)  AS  max_1\nFROM  b  WHERE  b.a_id  =  a.id)  AS  anon_1,  a_1.id  AS  a_1_id,\n(SELECT  max(b.id)  AS  max_2\nFROM  b  WHERE  b.a_id  =  a_1.id)  AS  anon_2\nFROM  a,  a  AS  a_1  ORDER  BY  anon_2\n```", "```py\nclass A(Base):\n    __tablename__ = \"a\"\n\n    id = Column(Integer, primary_key=True)\n    type = Column(String)\n\n    __mapper_args__ = {\"polymorphic_on\": type, \"with_polymorphic\": \"*\"}\n```", "```py\nSELECT  a.id  AS  a_id,  a.type  AS  a_type,  (SELECT  max(b.id)  AS  max_1\nFROM  b  WHERE  b.a_id  =  a.id)  AS  anon_1\nFROM  a  ORDER  BY  (SELECT  max(b.id)  AS  max_2\nFROM  b  WHERE  b.a_id  =  a.id)\n```", "```py\nSELECT  a.id  AS  a_id,  a.type  AS  a_type,  (SELECT  max(b.id)  AS  max_1\nFROM  b  WHERE  b.a_id  =  a.id)  AS  anon_1\nFROM  a  ORDER  BY  anon_1\n```", "```py\nfrom sqlalchemy.ext import baked\nfrom sqlalchemy import bindparam\n\nbakery = baked.bakery()\n\ndef search_for_user(session, username, email=None):\n    baked_query = bakery(lambda session: session.query(User))\n    baked_query += lambda q: q.filter(User.name == bindparam(\"username\"))\n\n    baked_query += lambda q: q.order_by(User.id)\n\n    if email:\n        baked_query += lambda q: q.filter(User.email == bindparam(\"email\"))\n\n    result = baked_query(session).params(username=username, email=email).all()\n\n    return result\n```", "```py\nclass HasFooBar(object):\n    foobar = Column(Integer)\n\n    @declared_attr\n    def foobar_prop(cls):\n        return column_property(\"foobar: \" + cls.foobar)\n\nclass SomeClass(HasFooBar, Base):\n    __tablename__ = \"some_table\"\n    id = Column(Integer, primary_key=True)\n```", "```py\nclass HasFooBar(object):\n    @declared_attr\n    def foobar(cls):\n        return Column(Integer)\n\n    @declared_attr\n    def foobar_prop(cls):\n        return column_property(\"foobar: \" + cls.foobar)\n\nclass SomeClass(HasFooBar, Base):\n    __tablename__ = \"some_table\"\n    id = Column(Integer, primary_key=True)\n```", "```py\nclass HasIdMixin(object):\n    @declared_attr.cascading\n    def id(cls):\n        if has_inherited_table(cls):\n            return Column(ForeignKey(\"myclass.id\"), primary_key=True)\n        else:\n            return Column(Integer, primary_key=True)\n\nclass MyClass(HasIdMixin, Base):\n    __tablename__ = \"myclass\"\n    # ...\n\nclass MySubClass(MyClass):\n  \"\"\" \"\"\"\n\n    # ...\n```", "```py\nfrom sqlalchemy import Column, Integer, ForeignKey\nfrom sqlalchemy.orm import relationship\nfrom sqlalchemy.ext.declarative import (\n    declarative_base,\n    declared_attr,\n    AbstractConcreteBase,\n)\n\nBase = declarative_base()\n\nclass Something(Base):\n    __tablename__ = \"something\"\n    id = Column(Integer, primary_key=True)\n\nclass Abstract(AbstractConcreteBase, Base):\n    id = Column(Integer, primary_key=True)\n\n    @declared_attr\n    def something_id(cls):\n        return Column(ForeignKey(Something.id))\n\n    @declared_attr\n    def something(cls):\n        return relationship(Something)\n\nclass Concrete(Abstract):\n    __tablename__ = \"cca\"\n    __mapper_args__ = {\"polymorphic_identity\": \"cca\", \"concrete\": True}\n```", "```py\nimport time\nfrom sqlalchemy import Integer, Column, create_engine, Table\nfrom sqlalchemy.orm import Session\nfrom sqlalchemy.ext.declarative import declarative_base\n\nBase = declarative_base()\n\nclass Foo(Base):\n    __table__ = Table(\n        \"foo\",\n        Base.metadata,\n        Column(\"id\", Integer, primary_key=True),\n        Column(\"a\", Integer(), nullable=False),\n        Column(\"b\", Integer(), nullable=False),\n        Column(\"c\", Integer(), nullable=False),\n    )\n\nengine = create_engine(\"mysql+mysqldb://scott:tiger@localhost/test\", echo=True)\n\nsess = Session(engine)\n\nnow = time.time()\n\n# avoid using all() so that we don't have the overhead of building\n# a large list of full objects in memory\nfor obj in sess.query(Foo).yield_per(100).limit(1000000):\n    pass\n\nprint(\"Total time: %d\" % (time.time() - now))\n```", "```py\nrows = sess.query(Foo.a, Foo.b, Foo.c).all()\n```", "```py\n-----------------\nsize=10 num=10000                 # few rows, lots of queries\nnamedtuple: 3.60302400589         # namedtuple falls over\nkeyedtuple: 0.255059957504        # KeyedTuple very fast\nlw keyed tuple: 0.582715034485    # lw keyed trails right on KeyedTuple\n-----------------\nsize=100 num=1000                 # <--- sweet spot\nnamedtuple: 0.365247011185\nkeyedtuple: 0.24896979332\nlw keyed tuple: 0.0889317989349   # lw keyed blows both away!\n-----------------\nsize=10000 num=100\nnamedtuple: 0.572599887848\nkeyedtuple: 2.54251694679\nlw keyed tuple: 0.613876104355\n-----------------\nsize=1000000 num=10               # few queries, lots of rows\nnamedtuple: 5.79669594765         # namedtuple very fast\nkeyedtuple: 28.856498003          # KeyedTuple falls over\nlw keyed tuple: 6.74346804619     # lw keyed trails right on namedtuple\n```", "```py\n# reported by heapy, summation of SQLAlchemy objects +\n# associated dicts + weakref-related objects with core of Nova imported:\n\n    Before: total count 26477 total bytes 7975712\n    After: total count 18181 total bytes 4236456\n\n# reported for the Python module space overall with the\n# core of Nova imported:\n\n    Before: Partition of a set of 355558 objects. Total size = 61661760 bytes.\n    After: Partition of a set of 346034 objects. Total size = 57808016 bytes.\n```", "```py\n    class MyClass(SomeMixin, Base):\n        __tablename__ = \"my_table\"\n        # ...\n\n    session = Session(binds={SomeMixin: some_engine})\n    ```", "```py\n    class BaseClass(Base):\n        __tablename__ = \"base\"\n\n        # ...\n\n    class ConcreteSubClass(BaseClass):\n        __tablename__ = \"concrete\"\n\n        # ...\n\n        __mapper_args__ = {\"concrete\": True}\n\n    session = Session(binds={base_table: some_engine, concrete_table: some_other_engine})\n    ```", "```py\n    session.query(User).count()\n    ```", "```py\n    session.query(User).filter(User.id == 15).update(\n        {\"name\": \"foob\"}, synchronize_session=\"fetch\"\n    )\n\n    session.query(User).filter(User.id == 15).delete(synchronize_session=\"fetch\")\n    ```", "```py\n    session.query(User.id, User.name).all()\n    ```", "```py\n    class User(Base):\n        ...\n\n        score = column_property(func.coalesce(self.tables.users.c.name, None))\n\n    session.query(func.max(User.score)).scalar()\n    ```", "```py\nclass SomeObject(Base):\n    # ...\n\n    @hybrid_property\n    def some_prop(self):\n        return self.value + 5\n\ninspect(SomeObject).all_orm_descriptors.some_prop.info[\"foo\"] = \"bar\"\n```", "```py\nclass A(Base):\n    __tablename__ = \"a\"\n\n    id = Column(Integer, primary_key=True)\n\nclass B(Base):\n    __tablename__ = \"b\"\n\n    id = Column(Integer, primary_key=True)\n    a_id = Column(ForeignKey(\"a.id\"))\n\nA.b = column_property(select([func.max(B.id)]).where(B.a_id == A.id).correlate(A))\n```", "```py\nprint(sess.query(A, a1).order_by(a1.b))\n```", "```py\nSELECT  a.id  AS  a_id,  (SELECT  max(b.id)  AS  max_1  FROM  b\nWHERE  b.a_id  =  a.id)  AS  anon_1,  a_1.id  AS  a_1_id,\n(SELECT  max(b.id)  AS  max_2\nFROM  b  WHERE  b.a_id  =  a_1.id)  AS  anon_2\nFROM  a,  a  AS  a_1  ORDER  BY  anon_1\n```", "```py\nSELECT  a.id  AS  a_id,  (SELECT  max(b.id)  AS  max_1\nFROM  b  WHERE  b.a_id  =  a.id)  AS  anon_1,  a_1.id  AS  a_1_id,\n(SELECT  max(b.id)  AS  max_2\nFROM  b  WHERE  b.a_id  =  a_1.id)  AS  anon_2\nFROM  a,  a  AS  a_1  ORDER  BY  anon_2\n```", "```py\nclass A(Base):\n    __tablename__ = \"a\"\n\n    id = Column(Integer, primary_key=True)\n    type = Column(String)\n\n    __mapper_args__ = {\"polymorphic_on\": type, \"with_polymorphic\": \"*\"}\n```", "```py\nSELECT  a.id  AS  a_id,  a.type  AS  a_type,  (SELECT  max(b.id)  AS  max_1\nFROM  b  WHERE  b.a_id  =  a.id)  AS  anon_1\nFROM  a  ORDER  BY  (SELECT  max(b.id)  AS  max_2\nFROM  b  WHERE  b.a_id  =  a.id)\n```", "```py\nSELECT  a.id  AS  a_id,  a.type  AS  a_type,  (SELECT  max(b.id)  AS  max_1\nFROM  b  WHERE  b.a_id  =  a.id)  AS  anon_1\nFROM  a  ORDER  BY  anon_1\n```", "```py\nsel = select([table]).limit(bindparam(\"mylimit\")).offset(bindparam(\"myoffset\"))\n```", "```py\n>>> result = connection.execute(stmt)\n>>> result.fetchone()\n(1, 'x')\n>>> result.fetchone()\nNone  # indicates no more rows\n>>> result.fetchone()\nexception: ResourceClosedError\n```", "```py\n>>> result = connection.execute(stmt)\n>>> result.fetchone()\n(1, 'x')\n>>> result.fetchone()\nNone  # indicates no more rows\n>>> result.fetchone()\nNone  # still None\n>>> result.fetchall()\n[]\n>>> result.close()\n>>> result.fetchone()\nexception: ResourceClosedError  # *now* it raises\n```", "```py\nmetadata = MetaData(naming_convention={\"ck\": \"ck_%(table_name)s_%(column_0_name)s\"})\n\nfoo = Table(\"foo\", metadata, Column(\"value\", Integer))\n\nCheckConstraint(foo.c.value > 5)\n```", "```py\nCREATE  TABLE  foo  (\n  value  INTEGER,\n  CONSTRAINT  ck_foo_value  CHECK  (value  >  5)\n)\n```", "```py\nfrom sqlalchemy import Table, Column, MetaData, Integer, UniqueConstraint\n\nm = MetaData()\n\nt = Table(\"t\", m, Column(\"a\", Integer), Column(\"b\", Integer))\n\nuq = UniqueConstraint(t.c.a, t.c.b)  # will auto-attach to Table\n\nassert uq in t.constraints\n```", "```py\nfrom sqlalchemy import Table, Column, MetaData, Integer, UniqueConstraint\n\nm = MetaData()\n\na = Column(\"a\", Integer)\nb = Column(\"b\", Integer)\n\nuq = UniqueConstraint(a, b)\n\nt = Table(\"t\", m, a, b)\n\nassert uq in t.constraints  # constraint auto-attached\n```", "```py\nfrom sqlalchemy import Table, Column, MetaData, Integer, UniqueConstraint\n\nm = MetaData()\n\na = Column(\"a\", Integer)\nb = Column(\"b\", Integer)\n\nuq = UniqueConstraint(a, \"b\")\n\nt = Table(\"t\", m, a, b)\n\n# constraint *not* auto-attached, as we do not have tracking\n# to locate when a name 'b' becomes available on the table\nassert uq not in t.constraints\n```", "```py\nfrom sqlalchemy import Table, Column, MetaData, Integer, UniqueConstraint\n\nm = MetaData()\n\na = Column(\"a\", Integer)\nb = Column(\"b\", Integer)\n\nt = Table(\"t\", m, a, b)\n\nuq = UniqueConstraint(a, \"b\")\n\n# constraint auto-attached normally as in older versions\nassert uq in t.constraints\n```", "```py\nfrom sqlalchemy import Table, Column, MetaData, Integer, select, func\n\nm = MetaData()\n\nt = Table(\n    \"t\", m, Column(\"x\", Integer), Column(\"y\", Integer, default=func.somefunction())\n)\n\nstmt = select([t.c.x])\nprint(t.insert().from_select([\"x\"], stmt))\n```", "```py\nINSERT  INTO  t  (x,  y)  SELECT  t.x,  somefunction()  AS  somefunction_1\nFROM  t\n```", "```py\nfrom sqlalchemy import Table, Column, MetaData, Text\nfrom sqlalchemy.schema import CreateTable\nfrom sqlalchemy.dialects.postgresql import ARRAY, array\nfrom sqlalchemy.dialects import postgresql\n\nmetadata = MetaData()\n\ntbl = Table(\n    \"derp\",\n    metadata,\n    Column(\"arr\", ARRAY(Text), server_default=array([\"foo\", \"bar\", \"baz\"])),\n)\n\nprint(CreateTable(tbl).compile(dialect=postgresql.dialect()))\n```", "```py\nCREATE  TABLE  derp  (\n  arr  TEXT[]  DEFAULT  ARRAY['foo',  'bar',  'baz']\n)\n```", "```py\nfrom sqlalchemy import create_engine, Unicode, select, cast\nimport random\nimport warnings\n\ne = create_engine(\"sqlite://\")\n\n# Use the \"once\" filter (which is also the default for Python\n# warnings).  Exactly ten of these warnings will\n# be emitted; beyond that, the Python warnings registry will accumulate\n# new values as dupes of one of the ten existing.\nwarnings.filterwarnings(\"once\")\n\nfor i in range(1000):\n    e.execute(\n        select([cast((\"foo_%d\" % random.randint(0, 1000000)).encode(\"ascii\"), Unicode)])\n    )\n```", "```py\n/path/lib/sqlalchemy/sql/sqltypes.py:186: SAWarning: Unicode type received\n  non-unicode bind param value 'foo_4852'. (this warning may be\n  suppressed after 10 occurrences)\n```", "```py\nsel = select([table]).limit(bindparam(\"mylimit\")).offset(bindparam(\"myoffset\"))\n```", "```py\n>>> result = connection.execute(stmt)\n>>> result.fetchone()\n(1, 'x')\n>>> result.fetchone()\nNone  # indicates no more rows\n>>> result.fetchone()\nexception: ResourceClosedError\n```", "```py\n>>> result = connection.execute(stmt)\n>>> result.fetchone()\n(1, 'x')\n>>> result.fetchone()\nNone  # indicates no more rows\n>>> result.fetchone()\nNone  # still None\n>>> result.fetchall()\n[]\n>>> result.close()\n>>> result.fetchone()\nexception: ResourceClosedError  # *now* it raises\n```", "```py\nmetadata = MetaData(naming_convention={\"ck\": \"ck_%(table_name)s_%(column_0_name)s\"})\n\nfoo = Table(\"foo\", metadata, Column(\"value\", Integer))\n\nCheckConstraint(foo.c.value > 5)\n```", "```py\nCREATE  TABLE  foo  (\n  value  INTEGER,\n  CONSTRAINT  ck_foo_value  CHECK  (value  >  5)\n)\n```", "```py\nfrom sqlalchemy import Table, Column, MetaData, Integer, UniqueConstraint\n\nm = MetaData()\n\nt = Table(\"t\", m, Column(\"a\", Integer), Column(\"b\", Integer))\n\nuq = UniqueConstraint(t.c.a, t.c.b)  # will auto-attach to Table\n\nassert uq in t.constraints\n```", "```py\nfrom sqlalchemy import Table, Column, MetaData, Integer, UniqueConstraint\n\nm = MetaData()\n\na = Column(\"a\", Integer)\nb = Column(\"b\", Integer)\n\nuq = UniqueConstraint(a, b)\n\nt = Table(\"t\", m, a, b)\n\nassert uq in t.constraints  # constraint auto-attached\n```", "```py\nfrom sqlalchemy import Table, Column, MetaData, Integer, UniqueConstraint\n\nm = MetaData()\n\na = Column(\"a\", Integer)\nb = Column(\"b\", Integer)\n\nuq = UniqueConstraint(a, \"b\")\n\nt = Table(\"t\", m, a, b)\n\n# constraint *not* auto-attached, as we do not have tracking\n# to locate when a name 'b' becomes available on the table\nassert uq not in t.constraints\n```", "```py\nfrom sqlalchemy import Table, Column, MetaData, Integer, UniqueConstraint\n\nm = MetaData()\n\na = Column(\"a\", Integer)\nb = Column(\"b\", Integer)\n\nt = Table(\"t\", m, a, b)\n\nuq = UniqueConstraint(a, \"b\")\n\n# constraint auto-attached normally as in older versions\nassert uq in t.constraints\n```", "```py\nfrom sqlalchemy import Table, Column, MetaData, Integer, select, func\n\nm = MetaData()\n\nt = Table(\n    \"t\", m, Column(\"x\", Integer), Column(\"y\", Integer, default=func.somefunction())\n)\n\nstmt = select([t.c.x])\nprint(t.insert().from_select([\"x\"], stmt))\n```", "```py\nINSERT  INTO  t  (x,  y)  SELECT  t.x,  somefunction()  AS  somefunction_1\nFROM  t\n```", "```py\nfrom sqlalchemy import Table, Column, MetaData, Text\nfrom sqlalchemy.schema import CreateTable\nfrom sqlalchemy.dialects.postgresql import ARRAY, array\nfrom sqlalchemy.dialects import postgresql\n\nmetadata = MetaData()\n\ntbl = Table(\n    \"derp\",\n    metadata,\n    Column(\"arr\", ARRAY(Text), server_default=array([\"foo\", \"bar\", \"baz\"])),\n)\n\nprint(CreateTable(tbl).compile(dialect=postgresql.dialect()))\n```", "```py\nCREATE  TABLE  derp  (\n  arr  TEXT[]  DEFAULT  ARRAY['foo',  'bar',  'baz']\n)\n```", "```py\nfrom sqlalchemy import create_engine, Unicode, select, cast\nimport random\nimport warnings\n\ne = create_engine(\"sqlite://\")\n\n# Use the \"once\" filter (which is also the default for Python\n# warnings).  Exactly ten of these warnings will\n# be emitted; beyond that, the Python warnings registry will accumulate\n# new values as dupes of one of the ten existing.\nwarnings.filterwarnings(\"once\")\n\nfor i in range(1000):\n    e.execute(\n        select([cast((\"foo_%d\" % random.randint(0, 1000000)).encode(\"ascii\"), Unicode)])\n    )\n```", "```py\n/path/lib/sqlalchemy/sql/sqltypes.py:186: SAWarning: Unicode type received\n  non-unicode bind param value 'foo_4852'. (this warning may be\n  suppressed after 10 occurrences)\n```", "```py\nclass User(Base):\n    __tablename__ = \"user\"\n\n    id = Column(Integer, primary_key=True)\n    name = Column(\"user_name\", String(50))\n```", "```py\nsession.query(User).update({\"user_name\": \"moonbeam\"})\n```", "```py\nsession.query(User).update({\"name\": \"moonbeam\"})\n```", "```py\nsession.query(User).update({User.name: \"moonbeam\"})\n```", "```py\nclass User(Base):\n    __tablename__ = \"user\"\n\n    id = Column(Integer, primary_key=True)\n    name = Column(\"user_name\", String(50))\n\n    @hybrid_property\n    def fullname(self):\n        return self.name\n\nsession.query(User).update({\"fullname\": \"moonbeam\"})\n```", "```py\nsession.query(Address).filter(Address.user == User(id=None))\n```", "```py\nSELECT  address.id  AS  address_id,  address.user_id  AS  address_user_id,\naddress.email_address  AS  address_email_address\nFROM  address  WHERE  ?  =  address.user_id\n(None,)\n```", "```py\nSELECT  address.id  AS  address_id,  address.user_id  AS  address_user_id,\naddress.email_address  AS  address_email_address\nFROM  address  WHERE  address.user_id  IS  NULL\n```", "```py\nSAWarning: Got None for value of column user.id; this is unsupported\nfor a relationship comparison and will not currently produce an\nIS comparison (but may in a future release)\n```", "```py\nclass A(Base):\n    __tablename__ = \"a\"\n    id = Column(Integer, primary_key=True)\n\nclass B(Base):\n    __tablename__ = \"b\"\n    id = Column(Integer, primary_key=True)\n    a_id = Column(ForeignKey(\"a.id\"))\n    a = relationship(\"A\")\n```", "```py\ns = Session(autoflush=False)\na1 = A(id=7)\ns.add(a1)\ns.commit()\n\na1.id = 10\n```", "```py\ns.query(B).filter(B.a == a1)\n```", "```py\nSELECT  b.id  AS  b_id,  b.a_id  AS  b_a_id\nFROM  b\nWHERE  ?  =  b.a_id\n(10,)\n```", "```py\ns.query(B).filter(B.a != a1)\n```", "```py\nSELECT  b.id  AS  b_id,  b.a_id  AS  b_a_id\nFROM  b\nWHERE  b.a_id  !=  ?  OR  b.a_id  IS  NULL\n(7,)\n```", "```py\nSELECT  b.id,  b.a_id\nFROM  b\nWHERE  b.a_id  !=  :a_id_1  OR  b.a_id  IS  NULL\n-- {u'a_id_1': symbol('NEVER_SET')}\n```", "```py\n>>> obj = Foo()\n```", "```py\n>>> obj.someattr\nNone\n```", "```py\n>>> inspect(obj).attrs.someattr.history\nHistory(added=(), unchanged=[None], deleted=())   # 0.9 and below\n```", "```py\n>>> obj = Foo()\n>>> obj.someattr = None\n>>> inspect(obj).attrs.someattr.history\nHistory(added=[None], unchanged=(), deleted=())  # all versions\n```", "```py\n>>> obj = Foo()\n>>> obj.someattr\nNone\n>>> inspect(obj).attrs.someattr.history\nHistory(added=(), unchanged=(), deleted=())  # 1.0\n>>> obj.someattr = None\n>>> inspect(obj).attrs.someattr.history\nHistory(added=[None], unchanged=(), deleted=())\n```", "```py\nclass A(Base):\n    __tablename__ = \"table_a\"\n\n    id = Column(Integer, primary_key=True)\n\nclass B(Base):\n    __tablename__ = \"table_b\"\n\n    id = Column(Integer, primary_key=True)\n    a_id = Column(ForeignKey(\"table_a.id\"))\n    a = relationship(A)\n```", "```py\na1 = A(id=1)\na2 = A(id=2)\nsession.add_all([a1, a2])\nsession.flush()\n\nb1 = B()\nb1.a = a1  # we expect a_id to be '1'; takes precedence in 0.9 and 1.0\n\nb2 = B()\nb2.a = None  # we expect a_id to be None; takes precedence only in 1.0\n\nb1.a_id = 2\nb2.a_id = 2\n\nsession.add_all([b1, b2])\nsession.commit()\n\nassert b1.a is a1  # passes in both 0.9 and 1.0\nassert b2.a is None  # passes in 1.0, in 0.9 it's a2\n```", "```py\nu1 = sess.query(User).first()\nsess.delete(u1)\n\nsess.flush()\n\nassert u1 not in sess\nassert inspect(u1).session is sess  # this is normal before commit\n\nsess.expunge(u1)\n\nassert u1 not in sess\nassert inspect(u1).session is None  # would fail\n```", "```py\nq = sess.query(Object).options(lazyload(\"*\")).yield_per(100)\n```", "```py\nq = sess.query(Object).enable_eagerloads(False).yield_per(100)\n```", "```py\nq = (\n    sess.query(Object)\n    .options(lazyload(\"*\"), joinedload(\"some_manytoone\"))\n    .yield_per(100)\n)\n```", "```py\nfrom sqlalchemy import Integer, Column, String, ForeignKey\nfrom sqlalchemy.orm import Session, relationship\nfrom sqlalchemy.ext.declarative import declarative_base\n\nBase = declarative_base()\n\nclass A(Base):\n    __tablename__ = \"a\"\n    id = Column(Integer, primary_key=True)\n    bs = relationship(\"B\")\n\nclass B(Base):\n    __tablename__ = \"b\"\n    id = Column(Integer, primary_key=True)\n    a_id = Column(ForeignKey(\"a.id\"))\n```", "```py\nprint(s.query(A).join(A.bs).join(A.bs))\n```", "```py\nSELECT  a.id  AS  a_id\nFROM  a  JOIN  b  ON  a.id  =  b.a_id\n```", "```py\ns.query(A).join(A.bs).filter(B.foo == \"bar\").reset_joinpoint().join(A.bs, B.cs).filter(\n    C.bar == \"bat\"\n)\n```", "```py\nSAWarning: Pathed join target A.bs has already been joined to; skipping\n```", "```py\nprint(s.query(A).join(B, B.a_id == A.id).join(B, B.a_id == A.id))\n```", "```py\nSELECT  a.id  AS  a_id\nFROM  a  JOIN  b  ON  b.a_id  =  a.id  JOIN  b  AS  b_1  ON  b_1.a_id  =  a.id\n```", "```py\nSELECT  a.id  AS  a_id\nFROM  a  JOIN  b  ON  b.a_id  =  a.id  JOIN  b  ON  b.a_id  =  a.id\n```", "```py\nfrom sqlalchemy import Integer, Column, String, ForeignKey\nfrom sqlalchemy.orm import Session, relationship\nfrom sqlalchemy.ext.declarative import declarative_base\n\nBase = declarative_base()\n\nclass A(Base):\n    __tablename__ = \"a\"\n\n    id = Column(Integer, primary_key=True)\n    type = Column(String)\n\n    __mapper_args__ = {\"polymorphic_on\": type, \"polymorphic_identity\": \"a\"}\n\nclass ASub1(A):\n    __mapper_args__ = {\"polymorphic_identity\": \"asub1\"}\n\nclass ASub2(A):\n    __mapper_args__ = {\"polymorphic_identity\": \"asub2\"}\n\nclass B(Base):\n    __tablename__ = \"b\"\n\n    id = Column(Integer, primary_key=True)\n\n    a_id = Column(Integer, ForeignKey(\"a.id\"))\n\n    a = relationship(\"A\", primaryjoin=\"B.a_id == A.id\", backref=\"b\")\n\ns = Session()\n\nprint(s.query(ASub1).join(B, ASub1.b).join(ASub2, B.a))\n\nprint(s.query(ASub1).join(B, ASub1.b).join(ASub2, ASub2.id == B.a_id))\n```", "```py\nSELECT  a.id  AS  a_id,  a.type  AS  a_type\nFROM  a  JOIN  b  ON  b.a_id  =  a.id  JOIN  a  ON  b.a_id  =  a.id  AND  a.type  IN  (:type_1)\nWHERE  a.type  IN  (:type_2)\n```", "```py\nSELECT  a.id  AS  a_id,  a.type  AS  a_type\nFROM  a  JOIN  b  ON  b.a_id  =  a.id  JOIN  a  AS  a_1\nON  a_1.id  =  b.a_id  AND  a_1.type  IN  (:type_1)\nWHERE  a_1.type  IN  (:type_2)\n```", "```py\nasub2_alias = aliased(ASub2)\n\nprint(s.query(ASub1).join(B, ASub1.b).join(asub2_alias, B.a.of_type(asub2_alias)))\n```", "```py\nfrom sqlalchemy.orm import Bundle\n\nclass DictBundle(Bundle):\n    def create_row_processor(self, query, procs, labels):\n  \"\"\"Override create_row_processor to return values as dictionaries\"\"\"\n\n        def proc(row, result):\n            return dict(zip(labels, (proc(row, result) for proc in procs)))\n\n        return proc\n```", "```py\nfrom sqlalchemy.orm import Bundle\n\nclass DictBundle(Bundle):\n    def create_row_processor(self, query, procs, labels):\n  \"\"\"Override create_row_processor to return values as dictionaries\"\"\"\n\n        def proc(row):\n            return dict(zip(labels, (proc(row) for proc in procs)))\n\n        return proc\n```", "```py\nquery(User).options(\n    joinedload(\"orders\", innerjoin=False).joinedload(\"items\", innerjoin=True)\n)\n```", "```py\nFROM users LEFT OUTER JOIN (orders JOIN items ON <onclause>) ON <onclause>\n```", "```py\nquery(User).options(\n    joinedload(\"orders\", innerjoin=False).joinedload(\"items\", innerjoin=\"unnested\")\n)\n```", "```py\nFROM users LEFT OUTER JOIN orders ON <onclause> LEFT OUTER JOIN items ON <onclause>\n```", "```py\nclass A(Base):\n    __tablename__ = \"a\"\n    id = Column(Integer, primary_key=True)\n    b = relationship(\"B\", uselist=False)\n\nclass B(Base):\n    __tablename__ = \"b\"\n    id = Column(Integer, primary_key=True)\n    a_id = Column(ForeignKey(\"a.id\"))\n\ns = Session()\nprint(s.query(A).options(joinedload(A.b)).limit(5))\n```", "```py\nSELECT  anon_1.a_id  AS  anon_1_a_id,  b_1.id  AS  b_1_id,  b_1.a_id  AS  b_1_a_id\nFROM  (SELECT  a.id  AS  a_id\nFROM  a  LIMIT  :param_1)  AS  anon_1\nLEFT  OUTER  JOIN  b  AS  b_1  ON  anon_1.a_id  =  b_1.a_id\n```", "```py\nSELECT  a.id  AS  a_id,  b_1.id  AS  b_1_id,  b_1.a_id  AS  b_1_a_id\nFROM  a  LEFT  OUTER  JOIN  b  AS  b_1  ON  a.id  =  b_1.a_id\nLIMIT  :param_1\n```", "```py\nclass Widget(Base):\n    __table__ = \"widget_table\"\n\nclass FooWidget(Widget):\n    pass\n```", "```py\nsess.query(FooWidget).from_self().all()\n```", "```py\nSELECT\n  anon_1.widgets_id  AS  anon_1_widgets_id,\n  anon_1.widgets_type  AS  anon_1_widgets_type\nFROM  (SELECT  widgets.id  AS  widgets_id,  widgets.type  AS  widgets_type,\nFROM  widgets)  AS  anon_1\nWHERE  anon_1.widgets_type  IN  (?)\n```", "```py\nSELECT\n  anon_1.widgets_id  AS  anon_1_widgets_id,\n  anon_1.widgets_type  AS  anon_1_widgets_type\nFROM  (SELECT  widgets.id  AS  widgets_id,  widgets.type  AS  widgets_type,\nFROM  widgets\nWHERE  widgets.type  IN  (?))  AS  anon_1\n```", "```py\nsess.query(FooWidget.id).count()\n```", "```py\nSELECT  count(*)  AS  count_1\nFROM  (SELECT  widgets.id  AS  widgets_id\nFROM  widgets\nWHERE  widgets.type  IN  (?))  AS  anon_1\n```", "```py\nclass Widget(Base):\n    __tablename__ = \"widget\"\n    id = Column(Integer, primary_key=True)\n    type = Column(String)\n    related_id = Column(ForeignKey(\"related.id\"))\n    related = relationship(\"Related\", backref=\"widget\")\n    __mapper_args__ = {\"polymorphic_on\": type}\n\nclass FooWidget(Widget):\n    __mapper_args__ = {\"polymorphic_identity\": \"foo\"}\n\nclass Related(Base):\n    __tablename__ = \"related\"\n    id = Column(Integer, primary_key=True)\n```", "```py\ns.query(Related).join(FooWidget, Related.widget).all()\n```", "```py\nSELECT  related.id  AS  related_id\nFROM  related  JOIN  widget  ON  related.id  =  widget.related_id  AND  widget.type  IN  (:type_1)\n```", "```py\n# ON clause will now render as\n# related.id = widget.related_id AND widget.type IN (:type_1)\ns.query(Related).join(FooWidget, FooWidget.related_id == Related.id).all()\n```", "```py\n# ON clause will now render as\n# related.id = widget.related_id AND widget.type IN (:type_1)\ns.query(Related).join(FooWidget).all()\n```", "```py\nclass User(Base):\n    __tablename__ = \"user\"\n\n    id = Column(Integer, primary_key=True)\n    name = Column(\"user_name\", String(50))\n```", "```py\nsession.query(User).update({\"user_name\": \"moonbeam\"})\n```", "```py\nsession.query(User).update({\"name\": \"moonbeam\"})\n```", "```py\nsession.query(User).update({User.name: \"moonbeam\"})\n```", "```py\nclass User(Base):\n    __tablename__ = \"user\"\n\n    id = Column(Integer, primary_key=True)\n    name = Column(\"user_name\", String(50))\n\n    @hybrid_property\n    def fullname(self):\n        return self.name\n\nsession.query(User).update({\"fullname\": \"moonbeam\"})\n```", "```py\nsession.query(Address).filter(Address.user == User(id=None))\n```", "```py\nSELECT  address.id  AS  address_id,  address.user_id  AS  address_user_id,\naddress.email_address  AS  address_email_address\nFROM  address  WHERE  ?  =  address.user_id\n(None,)\n```", "```py\nSELECT  address.id  AS  address_id,  address.user_id  AS  address_user_id,\naddress.email_address  AS  address_email_address\nFROM  address  WHERE  address.user_id  IS  NULL\n```", "```py\nSAWarning: Got None for value of column user.id; this is unsupported\nfor a relationship comparison and will not currently produce an\nIS comparison (but may in a future release)\n```", "```py\nclass A(Base):\n    __tablename__ = \"a\"\n    id = Column(Integer, primary_key=True)\n\nclass B(Base):\n    __tablename__ = \"b\"\n    id = Column(Integer, primary_key=True)\n    a_id = Column(ForeignKey(\"a.id\"))\n    a = relationship(\"A\")\n```", "```py\ns = Session(autoflush=False)\na1 = A(id=7)\ns.add(a1)\ns.commit()\n\na1.id = 10\n```", "```py\ns.query(B).filter(B.a == a1)\n```", "```py\nSELECT  b.id  AS  b_id,  b.a_id  AS  b_a_id\nFROM  b\nWHERE  ?  =  b.a_id\n(10,)\n```", "```py\ns.query(B).filter(B.a != a1)\n```", "```py\nSELECT  b.id  AS  b_id,  b.a_id  AS  b_a_id\nFROM  b\nWHERE  b.a_id  !=  ?  OR  b.a_id  IS  NULL\n(7,)\n```", "```py\nSELECT  b.id,  b.a_id\nFROM  b\nWHERE  b.a_id  !=  :a_id_1  OR  b.a_id  IS  NULL\n-- {u'a_id_1': symbol('NEVER_SET')}\n```", "```py\n>>> obj = Foo()\n```", "```py\n>>> obj.someattr\nNone\n```", "```py\n>>> inspect(obj).attrs.someattr.history\nHistory(added=(), unchanged=[None], deleted=())   # 0.9 and below\n```", "```py\n>>> obj = Foo()\n>>> obj.someattr = None\n>>> inspect(obj).attrs.someattr.history\nHistory(added=[None], unchanged=(), deleted=())  # all versions\n```", "```py\n>>> obj = Foo()\n>>> obj.someattr\nNone\n>>> inspect(obj).attrs.someattr.history\nHistory(added=(), unchanged=(), deleted=())  # 1.0\n>>> obj.someattr = None\n>>> inspect(obj).attrs.someattr.history\nHistory(added=[None], unchanged=(), deleted=())\n```", "```py\nclass A(Base):\n    __tablename__ = \"table_a\"\n\n    id = Column(Integer, primary_key=True)\n\nclass B(Base):\n    __tablename__ = \"table_b\"\n\n    id = Column(Integer, primary_key=True)\n    a_id = Column(ForeignKey(\"table_a.id\"))\n    a = relationship(A)\n```", "```py\na1 = A(id=1)\na2 = A(id=2)\nsession.add_all([a1, a2])\nsession.flush()\n\nb1 = B()\nb1.a = a1  # we expect a_id to be '1'; takes precedence in 0.9 and 1.0\n\nb2 = B()\nb2.a = None  # we expect a_id to be None; takes precedence only in 1.0\n\nb1.a_id = 2\nb2.a_id = 2\n\nsession.add_all([b1, b2])\nsession.commit()\n\nassert b1.a is a1  # passes in both 0.9 and 1.0\nassert b2.a is None  # passes in 1.0, in 0.9 it's a2\n```", "```py\nu1 = sess.query(User).first()\nsess.delete(u1)\n\nsess.flush()\n\nassert u1 not in sess\nassert inspect(u1).session is sess  # this is normal before commit\n\nsess.expunge(u1)\n\nassert u1 not in sess\nassert inspect(u1).session is None  # would fail\n```", "```py\nq = sess.query(Object).options(lazyload(\"*\")).yield_per(100)\n```", "```py\nq = sess.query(Object).enable_eagerloads(False).yield_per(100)\n```", "```py\nq = (\n    sess.query(Object)\n    .options(lazyload(\"*\"), joinedload(\"some_manytoone\"))\n    .yield_per(100)\n)\n```", "```py\nfrom sqlalchemy import Integer, Column, String, ForeignKey\nfrom sqlalchemy.orm import Session, relationship\nfrom sqlalchemy.ext.declarative import declarative_base\n\nBase = declarative_base()\n\nclass A(Base):\n    __tablename__ = \"a\"\n    id = Column(Integer, primary_key=True)\n    bs = relationship(\"B\")\n\nclass B(Base):\n    __tablename__ = \"b\"\n    id = Column(Integer, primary_key=True)\n    a_id = Column(ForeignKey(\"a.id\"))\n```", "```py\nprint(s.query(A).join(A.bs).join(A.bs))\n```", "```py\nSELECT  a.id  AS  a_id\nFROM  a  JOIN  b  ON  a.id  =  b.a_id\n```", "```py\ns.query(A).join(A.bs).filter(B.foo == \"bar\").reset_joinpoint().join(A.bs, B.cs).filter(\n    C.bar == \"bat\"\n)\n```", "```py\nSAWarning: Pathed join target A.bs has already been joined to; skipping\n```", "```py\nprint(s.query(A).join(B, B.a_id == A.id).join(B, B.a_id == A.id))\n```", "```py\nSELECT  a.id  AS  a_id\nFROM  a  JOIN  b  ON  b.a_id  =  a.id  JOIN  b  AS  b_1  ON  b_1.a_id  =  a.id\n```", "```py\nSELECT  a.id  AS  a_id\nFROM  a  JOIN  b  ON  b.a_id  =  a.id  JOIN  b  ON  b.a_id  =  a.id\n```", "```py\nfrom sqlalchemy import Integer, Column, String, ForeignKey\nfrom sqlalchemy.orm import Session, relationship\nfrom sqlalchemy.ext.declarative import declarative_base\n\nBase = declarative_base()\n\nclass A(Base):\n    __tablename__ = \"a\"\n\n    id = Column(Integer, primary_key=True)\n    type = Column(String)\n\n    __mapper_args__ = {\"polymorphic_on\": type, \"polymorphic_identity\": \"a\"}\n\nclass ASub1(A):\n    __mapper_args__ = {\"polymorphic_identity\": \"asub1\"}\n\nclass ASub2(A):\n    __mapper_args__ = {\"polymorphic_identity\": \"asub2\"}\n\nclass B(Base):\n    __tablename__ = \"b\"\n\n    id = Column(Integer, primary_key=True)\n\n    a_id = Column(Integer, ForeignKey(\"a.id\"))\n\n    a = relationship(\"A\", primaryjoin=\"B.a_id == A.id\", backref=\"b\")\n\ns = Session()\n\nprint(s.query(ASub1).join(B, ASub1.b).join(ASub2, B.a))\n\nprint(s.query(ASub1).join(B, ASub1.b).join(ASub2, ASub2.id == B.a_id))\n```", "```py\nSELECT  a.id  AS  a_id,  a.type  AS  a_type\nFROM  a  JOIN  b  ON  b.a_id  =  a.id  JOIN  a  ON  b.a_id  =  a.id  AND  a.type  IN  (:type_1)\nWHERE  a.type  IN  (:type_2)\n```", "```py\nSELECT  a.id  AS  a_id,  a.type  AS  a_type\nFROM  a  JOIN  b  ON  b.a_id  =  a.id  JOIN  a  AS  a_1\nON  a_1.id  =  b.a_id  AND  a_1.type  IN  (:type_1)\nWHERE  a_1.type  IN  (:type_2)\n```", "```py\nasub2_alias = aliased(ASub2)\n\nprint(s.query(ASub1).join(B, ASub1.b).join(asub2_alias, B.a.of_type(asub2_alias)))\n```", "```py\nfrom sqlalchemy.orm import Bundle\n\nclass DictBundle(Bundle):\n    def create_row_processor(self, query, procs, labels):\n  \"\"\"Override create_row_processor to return values as dictionaries\"\"\"\n\n        def proc(row, result):\n            return dict(zip(labels, (proc(row, result) for proc in procs)))\n\n        return proc\n```", "```py\nfrom sqlalchemy.orm import Bundle\n\nclass DictBundle(Bundle):\n    def create_row_processor(self, query, procs, labels):\n  \"\"\"Override create_row_processor to return values as dictionaries\"\"\"\n\n        def proc(row):\n            return dict(zip(labels, (proc(row) for proc in procs)))\n\n        return proc\n```", "```py\nquery(User).options(\n    joinedload(\"orders\", innerjoin=False).joinedload(\"items\", innerjoin=True)\n)\n```", "```py\nFROM users LEFT OUTER JOIN (orders JOIN items ON <onclause>) ON <onclause>\n```", "```py\nquery(User).options(\n    joinedload(\"orders\", innerjoin=False).joinedload(\"items\", innerjoin=\"unnested\")\n)\n```", "```py\nFROM users LEFT OUTER JOIN orders ON <onclause> LEFT OUTER JOIN items ON <onclause>\n```", "```py\nclass A(Base):\n    __tablename__ = \"a\"\n    id = Column(Integer, primary_key=True)\n    b = relationship(\"B\", uselist=False)\n\nclass B(Base):\n    __tablename__ = \"b\"\n    id = Column(Integer, primary_key=True)\n    a_id = Column(ForeignKey(\"a.id\"))\n\ns = Session()\nprint(s.query(A).options(joinedload(A.b)).limit(5))\n```", "```py\nSELECT  anon_1.a_id  AS  anon_1_a_id,  b_1.id  AS  b_1_id,  b_1.a_id  AS  b_1_a_id\nFROM  (SELECT  a.id  AS  a_id\nFROM  a  LIMIT  :param_1)  AS  anon_1\nLEFT  OUTER  JOIN  b  AS  b_1  ON  anon_1.a_id  =  b_1.a_id\n```", "```py\nSELECT  a.id  AS  a_id,  b_1.id  AS  b_1_id,  b_1.a_id  AS  b_1_a_id\nFROM  a  LEFT  OUTER  JOIN  b  AS  b_1  ON  a.id  =  b_1.a_id\nLIMIT  :param_1\n```", "```py\nclass Widget(Base):\n    __table__ = \"widget_table\"\n\nclass FooWidget(Widget):\n    pass\n```", "```py\nsess.query(FooWidget).from_self().all()\n```", "```py\nSELECT\n  anon_1.widgets_id  AS  anon_1_widgets_id,\n  anon_1.widgets_type  AS  anon_1_widgets_type\nFROM  (SELECT  widgets.id  AS  widgets_id,  widgets.type  AS  widgets_type,\nFROM  widgets)  AS  anon_1\nWHERE  anon_1.widgets_type  IN  (?)\n```", "```py\nSELECT\n  anon_1.widgets_id  AS  anon_1_widgets_id,\n  anon_1.widgets_type  AS  anon_1_widgets_type\nFROM  (SELECT  widgets.id  AS  widgets_id,  widgets.type  AS  widgets_type,\nFROM  widgets\nWHERE  widgets.type  IN  (?))  AS  anon_1\n```", "```py\nsess.query(FooWidget.id).count()\n```", "```py\nSELECT  count(*)  AS  count_1\nFROM  (SELECT  widgets.id  AS  widgets_id\nFROM  widgets\nWHERE  widgets.type  IN  (?))  AS  anon_1\n```", "```py\nclass Widget(Base):\n    __tablename__ = \"widget\"\n    id = Column(Integer, primary_key=True)\n    type = Column(String)\n    related_id = Column(ForeignKey(\"related.id\"))\n    related = relationship(\"Related\", backref=\"widget\")\n    __mapper_args__ = {\"polymorphic_on\": type}\n\nclass FooWidget(Widget):\n    __mapper_args__ = {\"polymorphic_identity\": \"foo\"}\n\nclass Related(Base):\n    __tablename__ = \"related\"\n    id = Column(Integer, primary_key=True)\n```", "```py\ns.query(Related).join(FooWidget, Related.widget).all()\n```", "```py\nSELECT  related.id  AS  related_id\nFROM  related  JOIN  widget  ON  related.id  =  widget.related_id  AND  widget.type  IN  (:type_1)\n```", "```py\n# ON clause will now render as\n# related.id = widget.related_id AND widget.type IN (:type_1)\ns.query(Related).join(FooWidget, FooWidget.related_id == Related.id).all()\n```", "```py\n# ON clause will now render as\n# related.id = widget.related_id AND widget.type IN (:type_1)\ns.query(Related).join(FooWidget).all()\n```", "```py\n# the argument sent to where() is a full SQL expression\nstmt = select([sometable]).where(\"somecolumn = 'value'\")\n```", "```py\n# This is a normal Core expression with a string argument -\n# we aren't talking about this!!\nstmt = select([sometable]).where(sometable.c.somecolumn == \"value\")\n```", "```py\nstmt = select([\"a\", \"b\"]).where(\"a = b\").select_from(\"sometable\")\n```", "```py\nSAWarning: Textual column expression 'a' should be explicitly declared\nwith text('a'), or use column('a') for more specificity\n(this warning may be suppressed after 10 occurrences)\n\nSAWarning: Textual column expression 'b' should be explicitly declared\nwith text('b'), or use column('b') for more specificity\n(this warning may be suppressed after 10 occurrences)\n\nSAWarning: Textual SQL expression 'a = b' should be explicitly declared\nas text('a = b') (this warning may be suppressed after 10 occurrences)\n\nSAWarning: Textual SQL FROM expression 'sometable' should be explicitly\ndeclared as text('sometable'), or use table('sometable') for more\nspecificity (this warning may be suppressed after 10 occurrences)\n```", "```py\nimport warnings\n\nwarnings.simplefilter(\"error\")  # all warnings raise an exception\n```", "```py\nfrom sqlalchemy import select, text\n\nstmt = (\n    select([text(\"a\"), text(\"b\")]).where(text(\"a = b\")).select_from(text(\"sometable\"))\n)\n```", "```py\nfrom sqlalchemy import select, text, column, table\n\nstmt = (\n    select([column(\"a\"), column(\"b\")])\n    .where(text(\"a = b\"))\n    .select_from(table(\"sometable\"))\n)\n```", "```py\nstmt = (\n    select([user.c.name, func.count(user.c.id).label(\"id_count\")])\n    .group_by(\"name\")\n    .order_by(\"id_count\")\n)\n```", "```py\nSELECT  users.name,  count(users.id)  AS  id_count\nFROM  users  GROUP  BY  users.name  ORDER  BY  id_count\n```", "```py\nstmt = select([user.c.name, func.count(user.c.id).label(\"id_count\")]).order_by(\n    \"some_label\"\n)\n```", "```py\nSAWarning: Can't resolve label reference 'some_label'; converting to\ntext() (this warning may be suppressed after 10 occurrences)\n```", "```py\nSELECT  users.name,  count(users.id)  AS  id_count\nFROM  users  ORDER  BY  some_label\n```", "```py\nstmt = select([users]).order_by(text(\"some special expression\"))\n```", "```py\nimport itertools\n\ncounter = itertools.count(1)\nt = Table(\n    \"my_table\",\n    metadata,\n    Column(\"id\", Integer, default=lambda: next(counter)),\n    Column(\"data\", String),\n)\n\nconn.execute(\n    t.insert().values(\n        [\n            {\"data\": \"d1\"},\n            {\"data\": \"d2\"},\n            {\"data\": \"d3\"},\n        ]\n    )\n)\n```", "```py\nINSERT  INTO  my_table  (id,  data)  VALUES  (?,  ?),  (?,  ?),  (?,  ?)\n(1,  'd1',  2,  'd2',  3,  'd3')\n```", "```py\nIncorrect number of bindings supplied. The current statement uses 6,\nand there are 4 supplied.\n[SQL: u'INSERT INTO my_table (id, data) VALUES (?, ?), (?, ?), (?, ?)']\n[parameters: (1, 'd1', 'd2', 'd3')]\n```", "```py\nINSERT  INTO  my_table  (id,  data)  VALUES  (:id,  :data_0),  (:id,  :data_1),  (:id,  :data_2)\n-- {u'data_2': 'd3', u'data_1': 'd2', u'data_0': 'd1', 'id': 1}\n```", "```py\nt = Table(\n    \"my_table\",\n    metadata,\n    Column(\"id\", Integer, primary_key=True),\n    Column(\"data\", String, server_default=\"some default\"),\n)\n\nconn.execute(\n    t.insert().values(\n        [\n            {\"data\": \"d1\"},\n            {\"data\": \"d2\"},\n            {},\n        ]\n    )\n)\n```", "```py\nsqlalchemy.exc.CompileError: INSERT value for column my_table.data is\nexplicitly rendered as a boundparameter in the VALUES clause; a\nPython-side value or SQL expression is required\n```", "```py\nINSERT  INTO  my_table  (data)  VALUES  (:data_0),  (:data_1),  (:data_0)\n-- {u'data_1': 'd2', u'data_0': 'd1'}\n```", "```py\nmy_table = Table(\"my_table\", metadata, autoload_with=some_engine)\n```", "```py\nselect([null(), null()])\n```", "```py\n# the argument sent to where() is a full SQL expression\nstmt = select([sometable]).where(\"somecolumn = 'value'\")\n```", "```py\n# This is a normal Core expression with a string argument -\n# we aren't talking about this!!\nstmt = select([sometable]).where(sometable.c.somecolumn == \"value\")\n```", "```py\nstmt = select([\"a\", \"b\"]).where(\"a = b\").select_from(\"sometable\")\n```", "```py\nSAWarning: Textual column expression 'a' should be explicitly declared\nwith text('a'), or use column('a') for more specificity\n(this warning may be suppressed after 10 occurrences)\n\nSAWarning: Textual column expression 'b' should be explicitly declared\nwith text('b'), or use column('b') for more specificity\n(this warning may be suppressed after 10 occurrences)\n\nSAWarning: Textual SQL expression 'a = b' should be explicitly declared\nas text('a = b') (this warning may be suppressed after 10 occurrences)\n\nSAWarning: Textual SQL FROM expression 'sometable' should be explicitly\ndeclared as text('sometable'), or use table('sometable') for more\nspecificity (this warning may be suppressed after 10 occurrences)\n```", "```py\nimport warnings\n\nwarnings.simplefilter(\"error\")  # all warnings raise an exception\n```", "```py\nfrom sqlalchemy import select, text\n\nstmt = (\n    select([text(\"a\"), text(\"b\")]).where(text(\"a = b\")).select_from(text(\"sometable\"))\n)\n```", "```py\nfrom sqlalchemy import select, text, column, table\n\nstmt = (\n    select([column(\"a\"), column(\"b\")])\n    .where(text(\"a = b\"))\n    .select_from(table(\"sometable\"))\n)\n```", "```py\nstmt = (\n    select([user.c.name, func.count(user.c.id).label(\"id_count\")])\n    .group_by(\"name\")\n    .order_by(\"id_count\")\n)\n```", "```py\nSELECT  users.name,  count(users.id)  AS  id_count\nFROM  users  GROUP  BY  users.name  ORDER  BY  id_count\n```", "```py\nstmt = select([user.c.name, func.count(user.c.id).label(\"id_count\")]).order_by(\n    \"some_label\"\n)\n```", "```py\nSAWarning: Can't resolve label reference 'some_label'; converting to\ntext() (this warning may be suppressed after 10 occurrences)\n```", "```py\nSELECT  users.name,  count(users.id)  AS  id_count\nFROM  users  ORDER  BY  some_label\n```", "```py\nstmt = select([users]).order_by(text(\"some special expression\"))\n```", "```py\nstmt = (\n    select([user.c.name, func.count(user.c.id).label(\"id_count\")])\n    .group_by(\"name\")\n    .order_by(\"id_count\")\n)\n```", "```py\nSELECT  users.name,  count(users.id)  AS  id_count\nFROM  users  GROUP  BY  users.name  ORDER  BY  id_count\n```", "```py\nstmt = select([user.c.name, func.count(user.c.id).label(\"id_count\")]).order_by(\n    \"some_label\"\n)\n```", "```py\nSAWarning: Can't resolve label reference 'some_label'; converting to\ntext() (this warning may be suppressed after 10 occurrences)\n```", "```py\nSELECT  users.name,  count(users.id)  AS  id_count\nFROM  users  ORDER  BY  some_label\n```", "```py\nstmt = select([users]).order_by(text(\"some special expression\"))\n```", "```py\nimport itertools\n\ncounter = itertools.count(1)\nt = Table(\n    \"my_table\",\n    metadata,\n    Column(\"id\", Integer, default=lambda: next(counter)),\n    Column(\"data\", String),\n)\n\nconn.execute(\n    t.insert().values(\n        [\n            {\"data\": \"d1\"},\n            {\"data\": \"d2\"},\n            {\"data\": \"d3\"},\n        ]\n    )\n)\n```", "```py\nINSERT  INTO  my_table  (id,  data)  VALUES  (?,  ?),  (?,  ?),  (?,  ?)\n(1,  'd1',  2,  'd2',  3,  'd3')\n```", "```py\nIncorrect number of bindings supplied. The current statement uses 6,\nand there are 4 supplied.\n[SQL: u'INSERT INTO my_table (id, data) VALUES (?, ?), (?, ?), (?, ?)']\n[parameters: (1, 'd1', 'd2', 'd3')]\n```", "```py\nINSERT  INTO  my_table  (id,  data)  VALUES  (:id,  :data_0),  (:id,  :data_1),  (:id,  :data_2)\n-- {u'data_2': 'd3', u'data_1': 'd2', u'data_0': 'd1', 'id': 1}\n```", "```py\nt = Table(\n    \"my_table\",\n    metadata,\n    Column(\"id\", Integer, primary_key=True),\n    Column(\"data\", String, server_default=\"some default\"),\n)\n\nconn.execute(\n    t.insert().values(\n        [\n            {\"data\": \"d1\"},\n            {\"data\": \"d2\"},\n            {},\n        ]\n    )\n)\n```", "```py\nsqlalchemy.exc.CompileError: INSERT value for column my_table.data is\nexplicitly rendered as a boundparameter in the VALUES clause; a\nPython-side value or SQL expression is required\n```", "```py\nINSERT  INTO  my_table  (data)  VALUES  (:data_0),  (:data_1),  (:data_0)\n-- {u'data_1': 'd2', u'data_0': 'd1'}\n```", "```py\nmy_table = Table(\"my_table\", metadata, autoload_with=some_engine)\n```", "```py\nselect([null(), null()])\n```", "```py\ntable = Table(\n    \"sometable\", metadata, Column(\"some_enum\", ENUM(\"a\", \"b\", \"c\", name=\"myenum\"))\n)\n\ntable.create(engine)  # will emit CREATE TYPE and CREATE TABLE\ntable.drop(engine)  # will emit DROP TABLE and DROP TYPE - new for 1.0\n```", "```py\nmy_enum = ENUM(\"a\", \"b\", \"c\", name=\"myenum\", metadata=metadata)\n\ntable = Table(\"sometable\", metadata, Column(\"some_enum\", my_enum))\n\n# will fail: ENUM 'my_enum' does not exist\ntable.create(engine)\n\n# will check for enum and emit CREATE TYPE\ntable.create(engine, checkfirst=True)\n\ntable.drop(engine)  # will emit DROP TABLE, *not* DROP TYPE\n\nmetadata.drop_all(engine)  # will emit DROP TYPE\n\nmetadata.create_all(engine)  # will emit CREATE TYPE\n```", "```py\nfrom sqlalchemy import inspect, create_engine\n\nengine = create_engine(\"postgresql+psycopg2://host/dbname\")\ninsp = inspect(engine)\nprint(insp.get_enums())\n```", "```py\nfrom sqlalchemy import *\n\nmetadata = MetaData()\nuser_tmp = Table(\n    \"user_tmp\",\n    metadata,\n    Column(\"id\", INT, primary_key=True),\n    Column(\"name\", VARCHAR(50)),\n    prefixes=[\"TEMPORARY\"],\n)\n\ne = create_engine(\"postgresql://scott:tiger@localhost/test\", echo=\"debug\")\nwith e.begin() as conn:\n    user_tmp.create(conn, checkfirst=True)\n\n    # checkfirst will succeed\n    user_tmp.create(conn, checkfirst=True)\n```", "```py\nfrom sqlalchemy import *\n\nmetadata = MetaData()\nuser_tmp = Table(\n    \"user_tmp\",\n    metadata,\n    Column(\"id\", INT, primary_key=True),\n    Column(\"name\", VARCHAR(50)),\n    prefixes=[\"TEMPORARY\"],\n)\n\ne = create_engine(\"postgresql://scott:tiger@localhost/test\", echo=\"debug\")\nwith e.begin() as conn:\n    user_tmp.create(conn, checkfirst=True)\n\n    m2 = MetaData()\n    user = Table(\n        \"user_tmp\",\n        m2,\n        Column(\"id\", INT, primary_key=True),\n        Column(\"name\", VARCHAR(50)),\n    )\n\n    # in 0.9, *will create* the new table, overwriting the old one.\n    # in 1.0, *will not create* the new table\n    user.create(conn, checkfirst=True)\n```", "```py\nfunc.count(1).filter(True)\n```", "```py\ntable = Table(\n    \"sometable\", metadata, Column(\"some_enum\", ENUM(\"a\", \"b\", \"c\", name=\"myenum\"))\n)\n\ntable.create(engine)  # will emit CREATE TYPE and CREATE TABLE\ntable.drop(engine)  # will emit DROP TABLE and DROP TYPE - new for 1.0\n```", "```py\nmy_enum = ENUM(\"a\", \"b\", \"c\", name=\"myenum\", metadata=metadata)\n\ntable = Table(\"sometable\", metadata, Column(\"some_enum\", my_enum))\n\n# will fail: ENUM 'my_enum' does not exist\ntable.create(engine)\n\n# will check for enum and emit CREATE TYPE\ntable.create(engine, checkfirst=True)\n\ntable.drop(engine)  # will emit DROP TABLE, *not* DROP TYPE\n\nmetadata.drop_all(engine)  # will emit DROP TYPE\n\nmetadata.create_all(engine)  # will emit CREATE TYPE\n```", "```py\nfrom sqlalchemy import inspect, create_engine\n\nengine = create_engine(\"postgresql+psycopg2://host/dbname\")\ninsp = inspect(engine)\nprint(insp.get_enums())\n```", "```py\nfrom sqlalchemy import *\n\nmetadata = MetaData()\nuser_tmp = Table(\n    \"user_tmp\",\n    metadata,\n    Column(\"id\", INT, primary_key=True),\n    Column(\"name\", VARCHAR(50)),\n    prefixes=[\"TEMPORARY\"],\n)\n\ne = create_engine(\"postgresql://scott:tiger@localhost/test\", echo=\"debug\")\nwith e.begin() as conn:\n    user_tmp.create(conn, checkfirst=True)\n\n    # checkfirst will succeed\n    user_tmp.create(conn, checkfirst=True)\n```", "```py\nfrom sqlalchemy import *\n\nmetadata = MetaData()\nuser_tmp = Table(\n    \"user_tmp\",\n    metadata,\n    Column(\"id\", INT, primary_key=True),\n    Column(\"name\", VARCHAR(50)),\n    prefixes=[\"TEMPORARY\"],\n)\n\ne = create_engine(\"postgresql://scott:tiger@localhost/test\", echo=\"debug\")\nwith e.begin() as conn:\n    user_tmp.create(conn, checkfirst=True)\n\n    m2 = MetaData()\n    user = Table(\n        \"user_tmp\",\n        m2,\n        Column(\"id\", INT, primary_key=True),\n        Column(\"name\", VARCHAR(50)),\n    )\n\n    # in 0.9, *will create* the new table, overwriting the old one.\n    # in 1.0, *will not create* the new table\n    user.create(conn, checkfirst=True)\n```", "```py\nfunc.count(1).filter(True)\n```", "```py\n>>> connection.execute(\n...     select(\n...         [\n...             matchtable.c.title.match(\"Agile Ruby Programming\").label(\"ruby\"),\n...             matchtable.c.title.match(\"Dive Python\").label(\"python\"),\n...             matchtable.c.title,\n...         ]\n...     ).order_by(matchtable.c.id)\n... )\n[\n (2.0, 0.0, 'Agile Web Development with Ruby On Rails'),\n (0.0, 2.0, 'Dive Into Python'),\n (2.0, 0.0, \"Programming Matz's Ruby\"),\n (0.0, 0.0, 'The Definitive Guide to Django'),\n (0.0, 1.0, 'Python in a Nutshell')\n]\n```", "```py\n>>> connection.execute(\n...     select(\n...         [\n...             matchtable.c.title.match(\"Agile Ruby Programming\").label(\"ruby\"),\n...             matchtable.c.title.match(\"Dive Python\").label(\"python\"),\n...             matchtable.c.title,\n...         ]\n...     ).order_by(matchtable.c.id)\n... )\n[\n (2.0, 0.0, 'Agile Web Development with Ruby On Rails'),\n (0.0, 2.0, 'Dive Into Python'),\n (2.0, 0.0, \"Programming Matz's Ruby\"),\n (0.0, 0.0, 'The Definitive Guide to Django'),\n (0.0, 1.0, 'Python in a Nutshell')\n]\n```", "```py\nengine = create_engine(\n    \"mssql+pyodbc://scott:tiger@myhost:port/databasename?driver=SQL+Server+Native+Client+10.0\"\n)\n```", "```py\nengine = create_engine(\n    \"mssql+pyodbc://scott:tiger@myhost:port/databasename?driver=SQL+Server+Native+Client+10.0\"\n)\n```", "```py\nincluded_parts = (\n    select([part.c.sub_part, part.c.part, part.c.quantity])\n    .where(part.c.part == \"p1\")\n    .cte(name=\"included_parts\", recursive=True)\n    .suffix_with(\n        \"search depth first by part set ord1\",\n        \"cycle part set y_cycle to 1 default 0\",\n        dialect=\"oracle\",\n    )\n)\n```", "```py\nincluded_parts = (\n    select([part.c.sub_part, part.c.part, part.c.quantity])\n    .where(part.c.part == \"p1\")\n    .cte(name=\"included_parts\", recursive=True)\n    .suffix_with(\n        \"search depth first by part set ord1\",\n        \"cycle part set y_cycle to 1 default 0\",\n        dialect=\"oracle\",\n    )\n)\n```"]