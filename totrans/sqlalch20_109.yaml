- en: MySQL and MariaDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.sqlalchemy.org/en/20/dialects/mysql.html](https://docs.sqlalchemy.org/en/20/dialects/mysql.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Support for the MySQL / MariaDB database.
  prefs: []
  type: TYPE_NORMAL
- en: The following table summarizes current support levels for database release versions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Supported MySQL / MariaDB versions**'
  prefs: []
  type: TYPE_NORMAL
- en: '| Support type | Versions |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| [Fully tested in CI](index.html#term-Fully-tested-in-CI) | 5.6, 5.7, 8.0
    / 10.8, 10.9 |'
  prefs: []
  type: TYPE_TB
- en: '| [Normal support](index.html#term-Normal-support) | 5.6+ / 10+ |'
  prefs: []
  type: TYPE_TB
- en: '| [Best effort](index.html#term-Best-effort) | 5.0.2+ / 5.0.2+ |'
  prefs: []
  type: TYPE_TB
- en: DBAPI Support
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following dialect/DBAPI options are available. Please refer to individual
    DBAPI sections for connect information.
  prefs: []
  type: TYPE_NORMAL
- en: '[mysqlclient (maintained fork of MySQL-Python)](#module-sqlalchemy.dialects.mysql.mysqldb)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PyMySQL](#module-sqlalchemy.dialects.mysql.pymysql)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[MariaDB Connector/Python](#module-sqlalchemy.dialects.mysql.mariadbconnector)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[MySQL Connector/Python](#module-sqlalchemy.dialects.mysql.mysqlconnector)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[asyncmy](#module-sqlalchemy.dialects.mysql.asyncmy)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[aiomysql](#module-sqlalchemy.dialects.mysql.aiomysql)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[CyMySQL](#module-sqlalchemy.dialects.mysql.cymysql)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PyODBC](#module-sqlalchemy.dialects.mysql.pyodbc)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supported Versions and Features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SQLAlchemy supports MySQL starting with version 5.0.2 through modern releases,
    as well as all modern versions of MariaDB. See the official MySQL documentation
    for detailed information about features supported in any given server release.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.4: minimum MySQL version supported is now 5.0.2.'
  prefs: []
  type: TYPE_NORMAL
- en: MariaDB Support
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The MariaDB variant of MySQL retains fundamental compatibility with MySQL’s
    protocols however the development of these two products continues to diverge.
    Within the realm of SQLAlchemy, the two databases have a small number of syntactical
    and behavioral differences that SQLAlchemy accommodates automatically. To connect
    to a MariaDB database, no changes to the database URL are required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Upon first connect, the SQLAlchemy dialect employs a server version detection
    scheme that determines if the backing database reports as MariaDB. Based on this
    flag, the dialect can make different choices in those of areas where its behavior
    must be different.
  prefs: []
  type: TYPE_NORMAL
- en: '### MariaDB-Only Mode'
  prefs: []
  type: TYPE_NORMAL
- en: 'The dialect also supports an **optional** “MariaDB-only” mode of connection,
    which may be useful for the case where an application makes use of MariaDB-specific
    features and is not compatible with a MySQL database. To use this mode of operation,
    replace the “mysql” token in the above URL with “mariadb”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The above engine, upon first connect, will raise an error if the server version
    detection detects that the backing database is not MariaDB.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using an engine with `"mariadb"` as the dialect name, **all mysql-specific
    options that include the name “mysql” in them are now named with “mariadb”**.
    This means options like `mysql_engine` should be named `mariadb_engine`, etc.
    Both “mysql” and “mariadb” options can be used simultaneously for applications
    that use URLs with both “mysql” and “mariadb” dialects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Similar behavior will occur when the above structures are reflected, i.e. the
    “mariadb” prefix will be present in the option names when the database URL is
    based on the “mariadb” name.
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 1.4: Added “mariadb” dialect name supporting “MariaDB-only mode”
    for the MySQL dialect.  ## Connection Timeouts and Disconnects'
  prefs: []
  type: TYPE_NORMAL
- en: 'MySQL / MariaDB feature an automatic connection close behavior, for connections
    that have been idle for a fixed period of time, defaulting to eight hours. To
    circumvent having this issue, use the [`create_engine.pool_recycle`](../core/engines.html#sqlalchemy.create_engine.params.pool_recycle
    "sqlalchemy.create_engine") option which ensures that a connection will be discarded
    and replaced with a new one if it has been present in the pool for a fixed number
    of seconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: For more comprehensive disconnect detection of pooled connections, including
    accommodation of server restarts and network issues, a pre-ping approach may be
    employed. See [Dealing with Disconnects](../core/pooling.html#pool-disconnects)
    for current approaches.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Dealing with Disconnects](../core/pooling.html#pool-disconnects) - Background
    on several techniques for dealing with timed out connections as well as database
    restarts.  ## CREATE TABLE arguments including Storage Engines'
  prefs: []
  type: TYPE_NORMAL
- en: 'Both MySQL’s and MariaDB’s CREATE TABLE syntax includes a wide array of special
    options, including `ENGINE`, `CHARSET`, `MAX_ROWS`, `ROW_FORMAT`, `INSERT_METHOD`,
    and many more. To accommodate the rendering of these arguments, specify the form
    `mysql_argument_name="value"`. For example, to specify a table with `ENGINE` of
    `InnoDB`, `CHARSET` of `utf8mb4`, and `KEY_BLOCK_SIZE` of `1024`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'When supporting [MariaDB-Only Mode](#mysql-mariadb-only-mode) mode, similar
    keys against the “mariadb” prefix must be included as well. The values can of
    course vary independently so that different settings on MySQL vs. MariaDB may
    be maintained:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The MySQL / MariaDB dialects will normally transfer any keyword specified as
    `mysql_keyword_name` to be rendered as `KEYWORD_NAME` in the `CREATE TABLE` statement.
    A handful of these names will render with a space instead of an underscore; to
    support this, the MySQL dialect has awareness of these particular names, which
    include `DATA DIRECTORY` (e.g. `mysql_data_directory`), `CHARACTER SET` (e.g.
    `mysql_character_set`) and `INDEX DIRECTORY` (e.g. `mysql_index_directory`).
  prefs: []
  type: TYPE_NORMAL
- en: The most common argument is `mysql_engine`, which refers to the storage engine
    for the table. Historically, MySQL server installations would default to `MyISAM`
    for this value, although newer versions may be defaulting to `InnoDB`. The `InnoDB`
    engine is typically preferred for its support of transactions and foreign keys.
  prefs: []
  type: TYPE_NORMAL
- en: A [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    that is created in a MySQL / MariaDB database with a storage engine of `MyISAM`
    will be essentially non-transactional, meaning any INSERT/UPDATE/DELETE statement
    referring to this table will be invoked as autocommit. It also will have no support
    for foreign key constraints; while the `CREATE TABLE` statement accepts foreign
    key options, when using the `MyISAM` storage engine these arguments are discarded.
    Reflecting such a table will also produce no foreign key constraint information.
  prefs: []
  type: TYPE_NORMAL
- en: For fully atomic transactions as well as support for foreign key constraints,
    all participating `CREATE TABLE` statements must specify a transactional engine,
    which in the vast majority of cases is `InnoDB`.
  prefs: []
  type: TYPE_NORMAL
- en: Case Sensitivity and Table Reflection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Both MySQL and MariaDB have inconsistent support for case-sensitive identifier
    names, basing support on specific details of the underlying operating system.
    However, it has been observed that no matter what case sensitivity behavior is
    present, the names of tables in foreign key declarations are *always* received
    from the database as all-lower case, making it impossible to accurately reflect
    a schema where inter-related tables use mixed-case identifier names.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore it is strongly advised that table names be declared as all lower case
    both within SQLAlchemy as well as on the MySQL / MariaDB database itself, especially
    if database reflection features are to be used.
  prefs: []
  type: TYPE_NORMAL
- en: '## Transaction Isolation Level'
  prefs: []
  type: TYPE_NORMAL
- en: All MySQL / MariaDB dialects support setting of transaction isolation level
    both via a dialect-specific parameter [`create_engine.isolation_level`](../core/engines.html#sqlalchemy.create_engine.params.isolation_level
    "sqlalchemy.create_engine") accepted by [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine"), as well as the [`Connection.execution_options.isolation_level`](../core/connections.html#sqlalchemy.engine.Connection.execution_options.params.isolation_level
    "sqlalchemy.engine.Connection.execution_options") argument as passed to [`Connection.execution_options()`](../core/connections.html#sqlalchemy.engine.Connection.execution_options
    "sqlalchemy.engine.Connection.execution_options"). This feature works by issuing
    the command `SET SESSION TRANSACTION ISOLATION LEVEL <level>` for each new connection.
    For the special AUTOCOMMIT isolation level, DBAPI-specific techniques are used.
  prefs: []
  type: TYPE_NORMAL
- en: 'To set isolation level using [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'To set using per-connection execution options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Valid values for `isolation_level` include:'
  prefs: []
  type: TYPE_NORMAL
- en: '`READ COMMITTED`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`READ UNCOMMITTED`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`REPEATABLE READ`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SERIALIZABLE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AUTOCOMMIT`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The special `AUTOCOMMIT` value makes use of the various “autocommit” attributes
    provided by specific DBAPIs, and is currently supported by MySQLdb, MySQL-Client,
    MySQL-Connector Python, and PyMySQL. Using it, the database connection will return
    true for the value of `SELECT @@autocommit;`.
  prefs: []
  type: TYPE_NORMAL
- en: There are also more options for isolation level configurations, such as “sub-engine”
    objects linked to a main [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") which each apply different isolation level settings.
    See the discussion at [Setting Transaction Isolation Levels including DBAPI Autocommit](../core/connections.html#dbapi-autocommit)
    for background.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Setting Transaction Isolation Levels including DBAPI Autocommit](../core/connections.html#dbapi-autocommit)'
  prefs: []
  type: TYPE_NORMAL
- en: AUTO_INCREMENT Behavior
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When creating tables, SQLAlchemy will automatically set `AUTO_INCREMENT` on
    the first [`Integer`](../core/type_basics.html#sqlalchemy.types.Integer "sqlalchemy.types.Integer")
    primary key column which is not marked as a foreign key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'You can disable this behavior by passing `False` to the [`Column.autoincrement`](../core/metadata.html#sqlalchemy.schema.Column.params.autoincrement
    "sqlalchemy.schema.Column") argument of [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column"). This flag can also be used to enable auto-increment
    on a secondary column in a multi-column key for some storage engines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '## Server Side Cursors'
  prefs: []
  type: TYPE_NORMAL
- en: Server-side cursor support is available for the mysqlclient, PyMySQL, mariadbconnector
    dialects and may also be available in others. This makes use of either the “buffered=True/False”
    flag if available or by using a class such as `MySQLdb.cursors.SSCursor` or `pymysql.cursors.SSCursor`
    internally.
  prefs: []
  type: TYPE_NORMAL
- en: 'Server side cursors are enabled on a per-statement basis by using the [`Connection.execution_options.stream_results`](../core/connections.html#sqlalchemy.engine.Connection.execution_options.params.stream_results
    "sqlalchemy.engine.Connection.execution_options") connection execution option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note that some kinds of SQL statements may not be supported with server side
    cursors; generally, only SQL statements that return rows should be used with this
    option.
  prefs: []
  type: TYPE_NORMAL
- en: 'Deprecated since version 1.4: The dialect-level server_side_cursors flag is
    deprecated and will be removed in a future release. Please use the [`Connection.stream_results`](../core/connections.html#sqlalchemy.engine.Connection.params.stream_results
    "sqlalchemy.engine.Connection") execution option for unbuffered cursor support.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Using Server Side Cursors (a.k.a. stream results)](../core/connections.html#engine-stream-results)  ##
    Unicode'
  prefs: []
  type: TYPE_NORMAL
- en: Charset Selection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Most MySQL / MariaDB DBAPIs offer the option to set the client character set
    for a connection. This is typically delivered using the `charset` parameter in
    the URL, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This charset is the **client character set** for the connection. Some MySQL
    DBAPIs will default this to a value such as `latin1`, and some will make use of
    the `default-character-set` setting in the `my.cnf` file as well. Documentation
    for the DBAPI in use should be consulted for specific behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'The encoding used for Unicode has traditionally been `''utf8''`. However, for
    MySQL versions 5.5.3 and MariaDB 5.5 on forward, a new MySQL-specific encoding
    `''utf8mb4''` has been introduced, and as of MySQL 8.0 a warning is emitted by
    the server if plain `utf8` is specified within any server-side directives, replaced
    with `utf8mb3`. The rationale for this new encoding is due to the fact that MySQL’s
    legacy utf-8 encoding only supports codepoints up to three bytes instead of four.
    Therefore, when communicating with a MySQL or MariaDB database that includes codepoints
    more than three bytes in size, this new charset is preferred, if supported by
    both the database as well as the client DBAPI, as in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: All modern DBAPIs should support the `utf8mb4` charset.
  prefs: []
  type: TYPE_NORMAL
- en: In order to use `utf8mb4` encoding for a schema that was created with legacy
    `utf8`, changes to the MySQL/MariaDB schema and/or server configuration may be
    required.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[The utf8mb4 Character Set](https://dev.mysql.com/doc/refman/5.5/en/charset-unicode-utf8mb4.html)
    - in the MySQL documentation'
  prefs: []
  type: TYPE_NORMAL
- en: '### Dealing with Binary Data Warnings and Unicode'
  prefs: []
  type: TYPE_NORMAL
- en: 'MySQL versions 5.6, 5.7 and later (not MariaDB at the time of this writing)
    now emit a warning when attempting to pass binary data to the database, while
    a character set encoding is also in place, when the binary data itself is not
    valid for that encoding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This warning is due to the fact that the MySQL client library is attempting
    to interpret the binary string as a unicode object even if a datatype such as
    [`LargeBinary`](../core/type_basics.html#sqlalchemy.types.LargeBinary "sqlalchemy.types.LargeBinary")
    is in use. To resolve this, the SQL statement requires a binary “character set
    introducer” be present before any non-NULL value that renders like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'These character set introducers are provided by the DBAPI driver, assuming
    the use of mysqlclient or PyMySQL (both of which are recommended). Add the query
    string parameter `binary_prefix=true` to the URL to repair this warning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `binary_prefix` flag may or may not be supported by other MySQL drivers.
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy itself cannot render this `_binary` prefix reliably, as it does not
    work with the NULL value, which is valid to be sent as a bound parameter. As the
    MySQL driver renders parameters directly into the SQL string, it’s the most efficient
    place for this additional keyword to be passed.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Character set introducers](https://dev.mysql.com/doc/refman/5.7/en/charset-introducer.html)
    - on the MySQL website'
  prefs: []
  type: TYPE_NORMAL
- en: ANSI Quoting Style
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MySQL / MariaDB feature two varieties of identifier “quoting style”, one using
    backticks and the other using quotes, e.g. ``some_identifier`` vs. `"some_identifier"`.
    All MySQL dialects detect which version is in use by checking the value of [sql_mode](#mysql-sql-mode)
    when a connection is first established with a particular [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine"). This quoting style comes into play when rendering
    table and column names as well as when reflecting existing database structures.
    The detection is entirely automatic and no special configuration is needed to
    use either quoting style.
  prefs: []
  type: TYPE_NORMAL
- en: '## Changing the sql_mode'
  prefs: []
  type: TYPE_NORMAL
- en: MySQL supports operating in multiple [Server SQL Modes](https://dev.mysql.com/doc/refman/8.0/en/sql-mode.html)
    for both Servers and Clients. To change the `sql_mode` for a given application,
    a developer can leverage SQLAlchemy’s Events system.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, the event system is used to set the `sql_mode` on
    the `first_connect` and `connect` events:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In the example illustrated above, the “connect” event will invoke the “SET”
    statement on the connection at the moment a particular DBAPI connection is first
    created for a given Pool, before the connection is made available to the connection
    pool. Additionally, because the function was registered with `insert=True`, it
    will be prepended to the internal list of registered functions.
  prefs: []
  type: TYPE_NORMAL
- en: MySQL / MariaDB SQL Extensions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Many of the MySQL / MariaDB SQL extensions are handled through SQLAlchemy’s
    generic function and operator support:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: And of course any valid SQL statement can be executed as a string as well.
  prefs: []
  type: TYPE_NORMAL
- en: Some limited direct support for MySQL / MariaDB extensions to SQL is currently
    available.
  prefs: []
  type: TYPE_NORMAL
- en: 'INSERT..ON DUPLICATE KEY UPDATE: See [INSERT…ON DUPLICATE KEY UPDATE (Upsert)](#mysql-insert-on-duplicate-key-update)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'SELECT pragma, use [`Select.prefix_with()`](../core/selectable.html#sqlalchemy.sql.expression.Select.prefix_with
    "sqlalchemy.sql.expression.Select.prefix_with") and [`Query.prefix_with()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.prefix_with
    "sqlalchemy.orm.Query.prefix_with"):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'UPDATE with LIMIT:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'optimizer hints, use [`Select.prefix_with()`](../core/selectable.html#sqlalchemy.sql.expression.Select.prefix_with
    "sqlalchemy.sql.expression.Select.prefix_with") and [`Query.prefix_with()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.prefix_with
    "sqlalchemy.orm.Query.prefix_with"):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'index hints, use [`Select.with_hint()`](../core/selectable.html#sqlalchemy.sql.expression.Select.with_hint
    "sqlalchemy.sql.expression.Select.with_hint") and [`Query.with_hint()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.with_hint
    "sqlalchemy.orm.Query.with_hint"):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'MATCH operator support:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: INSERT/DELETE…RETURNING
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The MariaDB dialect supports 10.5+’s `INSERT..RETURNING` and `DELETE..RETURNING`
    (10.0+) syntaxes. `INSERT..RETURNING` may be used automatically in some cases
    in order to fetch newly generated identifiers in place of the traditional approach
    of using `cursor.lastrowid`, however `cursor.lastrowid` is currently still preferred
    for simple single-statement cases for its better performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'To specify an explicit `RETURNING` clause, use the `_UpdateBase.returning()`
    method on a per-statement basis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'New in version 2.0: Added support for MariaDB RETURNING'
  prefs: []
  type: TYPE_NORMAL
- en: '## INSERT…ON DUPLICATE KEY UPDATE (Upsert)'
  prefs: []
  type: TYPE_NORMAL
- en: MySQL / MariaDB allow “upserts” (update or insert) of rows into a table via
    the `ON DUPLICATE KEY UPDATE` clause of the `INSERT` statement. A candidate row
    will only be inserted if that row does not match an existing primary or unique
    key in the table; otherwise, an UPDATE will be performed. The statement allows
    for separate specification of the values to INSERT versus the values for UPDATE.
  prefs: []
  type: TYPE_NORMAL
- en: 'SQLAlchemy provides `ON DUPLICATE KEY UPDATE` support via the MySQL-specific
    [`insert()`](#sqlalchemy.dialects.mysql.insert "sqlalchemy.dialects.mysql.insert")
    function, which provides the generative method [`Insert.on_duplicate_key_update()`](#sqlalchemy.dialects.mysql.Insert.on_duplicate_key_update
    "sqlalchemy.dialects.mysql.Insert.on_duplicate_key_update"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Unlike PostgreSQL’s “ON CONFLICT” phrase, the “ON DUPLICATE KEY UPDATE” phrase
    will always match on any primary key or unique key, and will always perform an
    UPDATE if there’s a match; there are no options for it to raise an error or to
    skip performing an UPDATE.
  prefs: []
  type: TYPE_NORMAL
- en: '`ON DUPLICATE KEY UPDATE` is used to perform an update of the already existing
    row, using any combination of new values as well as values from the proposed insertion.
    These values are normally specified using keyword arguments passed to the [`Insert.on_duplicate_key_update()`](#sqlalchemy.dialects.mysql.Insert.on_duplicate_key_update
    "sqlalchemy.dialects.mysql.Insert.on_duplicate_key_update") given column key values
    (usually the name of the column, unless it specifies [`Column.key`](../core/metadata.html#sqlalchemy.schema.Column.params.key
    "sqlalchemy.schema.Column") ) as keys and literal or SQL expressions as values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In a manner similar to that of `UpdateBase.values()`, other parameter forms
    are accepted, including a single dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'as well as a list of 2-tuples, which will automatically provide a parameter-ordered
    UPDATE statement in a manner similar to that described at [Parameter Ordered Updates](../tutorial/data_update.html#tutorial-parameter-ordered-updates).
    Unlike the [`Update`](../core/dml.html#sqlalchemy.sql.expression.Update "sqlalchemy.sql.expression.Update")
    object, no special flag is needed to specify the intent since the argument form
    is this context is unambiguous:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Changed in version 1.3: support for parameter-ordered UPDATE clause within
    MySQL ON DUPLICATE KEY UPDATE'
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: The [`Insert.on_duplicate_key_update()`](#sqlalchemy.dialects.mysql.Insert.on_duplicate_key_update
    "sqlalchemy.dialects.mysql.Insert.on_duplicate_key_update") method does **not**
    take into account Python-side default UPDATE values or generation functions, e.g.
    e.g. those specified using [`Column.onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.onupdate
    "sqlalchemy.schema.Column"). These values will not be exercised for an ON DUPLICATE
    KEY style of UPDATE, unless they are manually specified explicitly in the parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to refer to the proposed insertion row, the special alias [`Insert.inserted`](#sqlalchemy.dialects.mysql.Insert.inserted
    "sqlalchemy.dialects.mysql.Insert.inserted") is available as an attribute on the
    [`Insert`](#sqlalchemy.dialects.mysql.Insert "sqlalchemy.dialects.mysql.Insert")
    object; this object is a [`ColumnCollection`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnCollection
    "sqlalchemy.sql.expression.ColumnCollection") which contains all columns of the
    target table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: When rendered, the “inserted” namespace will produce the expression `VALUES(<columnname>)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 1.2: Added support for MySQL ON DUPLICATE KEY UPDATE clause'
  prefs: []
  type: TYPE_NORMAL
- en: rowcount Support
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SQLAlchemy standardizes the DBAPI `cursor.rowcount` attribute to be the usual
    definition of “number of rows matched by an UPDATE or DELETE” statement. This
    is in contradiction to the default setting on most MySQL DBAPI drivers, which
    is “number of rows actually modified/deleted”. For this reason, the SQLAlchemy
    MySQL dialects always add the `constants.CLIENT.FOUND_ROWS` flag, or whatever
    is equivalent for the target dialect, upon connection. This setting is currently
    hardcoded.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`CursorResult.rowcount`](../core/connections.html#sqlalchemy.engine.CursorResult.rowcount
    "sqlalchemy.engine.CursorResult.rowcount")'
  prefs: []
  type: TYPE_NORMAL
- en: '## MySQL / MariaDB- Specific Index Options'
  prefs: []
  type: TYPE_NORMAL
- en: MySQL and MariaDB-specific extensions to the [`Index`](../core/constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index") construct are available.
  prefs: []
  type: TYPE_NORMAL
- en: Index Length
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'MySQL and MariaDB both provide an option to create index entries with a certain
    length, where “length” refers to the number of characters or bytes in each value
    which will become part of the index. SQLAlchemy provides this feature via the
    `mysql_length` and/or `mariadb_length` parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Prefix lengths are given in characters for nonbinary string types and in bytes
    for binary string types. The value passed to the keyword argument *must* be either
    an integer (and, thus, specify the same prefix length value for all columns of
    the index) or a dict in which keys are column names and values are prefix length
    values for corresponding columns. MySQL and MariaDB only allow a length for a
    column of an index if it is for a CHAR, VARCHAR, TEXT, BINARY, VARBINARY and BLOB.
  prefs: []
  type: TYPE_NORMAL
- en: Index Prefixes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'MySQL storage engines permit you to specify an index prefix when creating an
    index. SQLAlchemy provides this feature via the `mysql_prefix` parameter on [`Index`](../core/constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The value passed to the keyword argument will be simply passed through to the
    underlying CREATE INDEX, so it *must* be a valid index prefix for your MySQL storage
    engine.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[CREATE INDEX](https://dev.mysql.com/doc/refman/5.0/en/create-index.html) -
    MySQL documentation'
  prefs: []
  type: TYPE_NORMAL
- en: Index Types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Some MySQL storage engines permit you to specify an index type when creating
    an index or primary key constraint. SQLAlchemy provides this feature via the `mysql_using`
    parameter on [`Index`](../core/constraints.html#sqlalchemy.schema.Index "sqlalchemy.schema.Index"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'As well as the `mysql_using` parameter on [`PrimaryKeyConstraint`](../core/constraints.html#sqlalchemy.schema.PrimaryKeyConstraint
    "sqlalchemy.schema.PrimaryKeyConstraint"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The value passed to the keyword argument will be simply passed through to the
    underlying CREATE INDEX or PRIMARY KEY clause, so it *must* be a valid index type
    for your MySQL storage engine.
  prefs: []
  type: TYPE_NORMAL
- en: 'More information can be found at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://dev.mysql.com/doc/refman/5.0/en/create-index.html](https://dev.mysql.com/doc/refman/5.0/en/create-index.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://dev.mysql.com/doc/refman/5.0/en/create-table.html](https://dev.mysql.com/doc/refman/5.0/en/create-table.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Index Parsers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'CREATE FULLTEXT INDEX in MySQL also supports a “WITH PARSER” option. This is
    available using the keyword argument `mysql_with_parser`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'New in version 1.3.  ## MySQL / MariaDB Foreign Keys'
  prefs: []
  type: TYPE_NORMAL
- en: MySQL and MariaDB’s behavior regarding foreign keys has some important caveats.
  prefs: []
  type: TYPE_NORMAL
- en: Foreign Key Arguments to Avoid
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Neither MySQL nor MariaDB support the foreign key arguments “DEFERRABLE”, “INITIALLY”,
    or “MATCH”. Using the `deferrable` or `initially` keyword argument with [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") or [`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey") will have the effect of these keywords being rendered
    in a DDL expression, which will then raise an error on MySQL or MariaDB. In order
    to use these keywords on a foreign key while having them ignored on a MySQL /
    MariaDB backend, use a custom compile rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The “MATCH” keyword is in fact more insidious, and is explicitly disallowed
    by SQLAlchemy in conjunction with the MySQL or MariaDB backends. This argument
    is silently ignored by MySQL / MariaDB, but in addition has the effect of ON UPDATE
    and ON DELETE options also being ignored by the backend. Therefore MATCH should
    never be used with the MySQL / MariaDB backends; as is the case with DEFERRABLE
    and INITIALLY, custom compilation rules can be used to correct a ForeignKeyConstraint
    at DDL definition time.
  prefs: []
  type: TYPE_NORMAL
- en: Reflection of Foreign Key Constraints
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Not all MySQL / MariaDB storage engines support foreign keys. When using the
    very common `MyISAM` MySQL storage engine, the information loaded by table reflection
    will not include foreign keys. For these tables, you may supply a `ForeignKeyConstraint`
    at reflection time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[CREATE TABLE arguments including Storage Engines](#mysql-storage-engines)  ##
    MySQL / MariaDB Unique Constraints and Reflection'
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy supports both the [`Index`](../core/constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index") construct with the flag `unique=True`, indicating a
    UNIQUE index, as well as the [`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint") construct, representing a UNIQUE constraint.
    Both objects/syntaxes are supported by MySQL / MariaDB when emitting DDL to create
    these constraints. However, MySQL / MariaDB does not have a unique constraint
    construct that is separate from a unique index; that is, the “UNIQUE” constraint
    on MySQL / MariaDB is equivalent to creating a “UNIQUE INDEX”.
  prefs: []
  type: TYPE_NORMAL
- en: When reflecting these constructs, the [`Inspector.get_indexes()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_indexes
    "sqlalchemy.engine.reflection.Inspector.get_indexes") and the [`Inspector.get_unique_constraints()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_unique_constraints
    "sqlalchemy.engine.reflection.Inspector.get_unique_constraints") methods will
    **both** return an entry for a UNIQUE index in MySQL / MariaDB. However, when
    performing full table reflection using `Table(..., autoload_with=engine)`, the
    [`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint") construct is **not** part of the fully reflected
    [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    construct under any circumstances; this construct is always represented by a [`Index`](../core/constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index") with the `unique=True` setting present in the [`Table.indexes`](../core/metadata.html#sqlalchemy.schema.Table.indexes
    "sqlalchemy.schema.Table.indexes") collection.
  prefs: []
  type: TYPE_NORMAL
- en: TIMESTAMP / DATETIME issues
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '### Rendering ON UPDATE CURRENT TIMESTAMP for MySQL / MariaDB’s explicit_defaults_for_timestamp'
  prefs: []
  type: TYPE_NORMAL
- en: MySQL / MariaDB have historically expanded the DDL for the [`TIMESTAMP`](../core/type_basics.html#sqlalchemy.types.TIMESTAMP
    "sqlalchemy.types.TIMESTAMP") datatype into the phrase “TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    ON UPDATE CURRENT_TIMESTAMP”, which includes non-standard SQL that automatically
    updates the column with the current timestamp when an UPDATE occurs, eliminating
    the usual need to use a trigger in such a case where server-side update changes
    are desired.
  prefs: []
  type: TYPE_NORMAL
- en: MySQL 5.6 introduced a new flag [explicit_defaults_for_timestamp](https://dev.mysql.com/doc/refman/5.6/en/server-system-variables.html#sysvar_explicit_defaults_for_timestamp)
    which disables the above behavior, and in MySQL 8 this flag defaults to true,
    meaning in order to get a MySQL “on update timestamp” without changing this flag,
    the above DDL must be rendered explicitly. Additionally, the same DDL is valid
    for use of the `DATETIME` datatype as well.
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy’s MySQL dialect does not yet have an option to generate MySQL’s “ON
    UPDATE CURRENT_TIMESTAMP” clause, noting that this is not a general purpose “ON
    UPDATE” as there is no such syntax in standard SQL. SQLAlchemy’s [`Column.server_onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.server_onupdate
    "sqlalchemy.schema.Column") parameter is currently not related to this special
    MySQL behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'To generate this DDL, make use of the [`Column.server_default`](../core/metadata.html#sqlalchemy.schema.Column.params.server_default
    "sqlalchemy.schema.Column") parameter and pass a textual clause that also includes
    the ON UPDATE clause:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The same instructions apply to use of the [`DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime
    "sqlalchemy.types.DateTime") and [`DATETIME`](../core/type_basics.html#sqlalchemy.types.DATETIME
    "sqlalchemy.types.DATETIME") datatypes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Even though the [`Column.server_onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.server_onupdate
    "sqlalchemy.schema.Column") feature does not generate this DDL, it still may be
    desirable to signal to the ORM that this updated value should be fetched. This
    syntax looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]  ### TIMESTAMP Columns and NULL'
  prefs: []
  type: TYPE_NORMAL
- en: 'MySQL historically enforces that a column which specifies the TIMESTAMP datatype
    implicitly includes a default value of CURRENT_TIMESTAMP, even though this is
    not stated, and additionally sets the column as NOT NULL, the opposite behavior
    vs. that of all other datatypes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Above, we see that an INTEGER column defaults to NULL, unless it is specified
    with NOT NULL. But when the column is of type TIMESTAMP, an implicit default of
    CURRENT_TIMESTAMP is generated which also coerces the column to be a NOT NULL,
    even though we did not specify it as such.
  prefs: []
  type: TYPE_NORMAL
- en: This behavior of MySQL can be changed on the MySQL side using the [explicit_defaults_for_timestamp](https://dev.mysql.com/doc/refman/5.6/en/server-system-variables.html#sysvar_explicit_defaults_for_timestamp)
    configuration flag introduced in MySQL 5.6\. With this server setting enabled,
    TIMESTAMP columns behave like any other datatype on the MySQL side with regards
    to defaults and nullability.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, to accommodate the vast majority of MySQL databases that do not specify
    this new flag, SQLAlchemy emits the “NULL” specifier explicitly with any TIMESTAMP
    column that does not specify `nullable=False`. In order to accommodate newer databases
    that specify `explicit_defaults_for_timestamp`, SQLAlchemy also emits NOT NULL
    for TIMESTAMP columns that do specify `nullable=False`. The following example
    illustrates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: MySQL SQL Constructs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '| Object Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| [match](#sqlalchemy.dialects.mysql.match) | Produce a `MATCH (X, Y) AGAINST
    (''TEXT'')` clause. |'
  prefs: []
  type: TYPE_TB
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Produce a `MATCH (X, Y) AGAINST ('TEXT')` clause.
  prefs: []
  type: TYPE_NORMAL
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Would produce SQL resembling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The [`match()`](#sqlalchemy.dialects.mysql.match "sqlalchemy.dialects.mysql.match")
    function is a standalone version of the [`ColumnElement.match()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnElement.match
    "sqlalchemy.sql.expression.ColumnElement.match") method available on all SQL expressions,
    as when [`ColumnElement.match()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnElement.match
    "sqlalchemy.sql.expression.ColumnElement.match") is used, but allows to pass multiple
    columns
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`cols` – column expressions to match against'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`against` – expression to be compared towards'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`in_boolean_mode` – boolean, set “boolean mode” to true'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`in_natural_language_mode` – boolean , set “natural language” to true'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`with_query_expansion` – boolean, set “query expansion” to true'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New in version 1.4.19.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnElement.match()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnElement.match
    "sqlalchemy.sql.expression.ColumnElement.match")'
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[in_boolean_mode()](#sqlalchemy.dialects.mysql.match.in_boolean_mode), [in_natural_language_mode()](#sqlalchemy.dialects.mysql.match.in_natural_language_mode),
    [inherit_cache](#sqlalchemy.dialects.mysql.match.inherit_cache), [with_query_expansion()](#sqlalchemy.dialects.mysql.match.with_query_expansion)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.mysql.match`](#sqlalchemy.dialects.mysql.match "sqlalchemy.dialects.mysql.match")
    (`sqlalchemy.sql.expression.Generative`, [`sqlalchemy.sql.expression.BinaryExpression`](../core/sqlelement.html#sqlalchemy.sql.expression.BinaryExpression
    "sqlalchemy.sql.expression.BinaryExpression"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Apply the “IN BOOLEAN MODE” modifier to the MATCH expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: a new [`match`](#sqlalchemy.dialects.mysql.match "sqlalchemy.dialects.mysql.match")
    instance with modifications applied.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Apply the “IN NATURAL LANGUAGE MODE” modifier to the MATCH expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: a new [`match`](#sqlalchemy.dialects.mysql.match "sqlalchemy.dialects.mysql.match")
    instance with modifications applied.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Indicate if this [`HasCacheKey`](../core/foundation.html#sqlalchemy.sql.traversals.HasCacheKey
    "sqlalchemy.sql.traversals.HasCacheKey") instance should make use of the cache
    key generation scheme used by its immediate superclass.
  prefs: []
  type: TYPE_NORMAL
- en: The attribute defaults to `None`, which indicates that a construct has not yet
    taken into account whether or not its appropriate for it to participate in caching;
    this is functionally equivalent to setting the value to `False`, except that a
    warning is also emitted.
  prefs: []
  type: TYPE_NORMAL
- en: This flag can be set to `True` on a particular class, if the SQL that corresponds
    to the object does not change based on attributes which are local to this class,
    and not its superclass.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Enabling Caching Support for Custom Constructs](../core/compiler.html#compilerext-caching)
    - General guideslines for setting the [`HasCacheKey.inherit_cache`](../core/foundation.html#sqlalchemy.sql.traversals.HasCacheKey.inherit_cache
    "sqlalchemy.sql.traversals.HasCacheKey.inherit_cache") attribute for third-party
    or user defined SQL constructs.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Apply the “WITH QUERY EXPANSION” modifier to the MATCH expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: a new [`match`](#sqlalchemy.dialects.mysql.match "sqlalchemy.dialects.mysql.match")
    instance with modifications applied.
  prefs: []
  type: TYPE_NORMAL
- en: MySQL Data Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As with all SQLAlchemy dialects, all UPPERCASE types that are known to be valid
    with MySQL are importable from the top level dialect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Types which are specific to MySQL, or have MySQL-specific construction arguments,
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Object Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| [BIGINT](#sqlalchemy.dialects.mysql.BIGINT) | MySQL BIGINTEGER type. |'
  prefs: []
  type: TYPE_TB
- en: '| [BIT](#sqlalchemy.dialects.mysql.BIT) | MySQL BIT type. |'
  prefs: []
  type: TYPE_TB
- en: '| [CHAR](#sqlalchemy.dialects.mysql.CHAR) | MySQL CHAR type, for fixed-length
    character data. |'
  prefs: []
  type: TYPE_TB
- en: '| [DATETIME](#sqlalchemy.dialects.mysql.DATETIME) | MySQL DATETIME type. |'
  prefs: []
  type: TYPE_TB
- en: '| [DECIMAL](#sqlalchemy.dialects.mysql.DECIMAL) | MySQL DECIMAL type. |'
  prefs: []
  type: TYPE_TB
- en: '| [ENUM](#sqlalchemy.dialects.mysql.ENUM) | MySQL ENUM type. |'
  prefs: []
  type: TYPE_TB
- en: '| [FLOAT](#sqlalchemy.dialects.mysql.FLOAT) | MySQL FLOAT type. |'
  prefs: []
  type: TYPE_TB
- en: '| [INTEGER](#sqlalchemy.dialects.mysql.INTEGER) | MySQL INTEGER type. |'
  prefs: []
  type: TYPE_TB
- en: '| [JSON](#sqlalchemy.dialects.mysql.JSON) | MySQL JSON type. |'
  prefs: []
  type: TYPE_TB
- en: '| [LONGBLOB](#sqlalchemy.dialects.mysql.LONGBLOB) | MySQL LONGBLOB type, for
    binary data up to 2^32 bytes. |'
  prefs: []
  type: TYPE_TB
- en: '| [LONGTEXT](#sqlalchemy.dialects.mysql.LONGTEXT) | MySQL LONGTEXT type, for
    character storage encoded up to 2^32 bytes. |'
  prefs: []
  type: TYPE_TB
- en: '| [MEDIUMBLOB](#sqlalchemy.dialects.mysql.MEDIUMBLOB) | MySQL MEDIUMBLOB type,
    for binary data up to 2^24 bytes. |'
  prefs: []
  type: TYPE_TB
- en: '| [MEDIUMINT](#sqlalchemy.dialects.mysql.MEDIUMINT) | MySQL MEDIUMINTEGER type.
    |'
  prefs: []
  type: TYPE_TB
- en: '| [MEDIUMTEXT](#sqlalchemy.dialects.mysql.MEDIUMTEXT) | MySQL MEDIUMTEXT type,
    for character storage encoded up to 2^24 bytes. |'
  prefs: []
  type: TYPE_TB
- en: '| [NCHAR](#sqlalchemy.dialects.mysql.NCHAR) | MySQL NCHAR type. |'
  prefs: []
  type: TYPE_TB
- en: '| [NUMERIC](#sqlalchemy.dialects.mysql.NUMERIC) | MySQL NUMERIC type. |'
  prefs: []
  type: TYPE_TB
- en: '| [NVARCHAR](#sqlalchemy.dialects.mysql.NVARCHAR) | MySQL NVARCHAR type. |'
  prefs: []
  type: TYPE_TB
- en: '| [REAL](#sqlalchemy.dialects.mysql.REAL) | MySQL REAL type. |'
  prefs: []
  type: TYPE_TB
- en: '| [SET](#sqlalchemy.dialects.mysql.SET) | MySQL SET type. |'
  prefs: []
  type: TYPE_TB
- en: '| [SMALLINT](#sqlalchemy.dialects.mysql.SMALLINT) | MySQL SMALLINTEGER type.
    |'
  prefs: []
  type: TYPE_TB
- en: '| [TIME](#sqlalchemy.dialects.mysql.TIME) | MySQL TIME type. |'
  prefs: []
  type: TYPE_TB
- en: '| [TIMESTAMP](#sqlalchemy.dialects.mysql.TIMESTAMP) | MySQL TIMESTAMP type.
    |'
  prefs: []
  type: TYPE_TB
- en: '| [TINYBLOB](#sqlalchemy.dialects.mysql.TINYBLOB) | MySQL TINYBLOB type, for
    binary data up to 2^8 bytes. |'
  prefs: []
  type: TYPE_TB
- en: '| [TINYINT](#sqlalchemy.dialects.mysql.TINYINT) | MySQL TINYINT type. |'
  prefs: []
  type: TYPE_TB
- en: '| [TINYTEXT](#sqlalchemy.dialects.mysql.TINYTEXT) | MySQL TINYTEXT type, for
    character storage encoded up to 2^8 bytes. |'
  prefs: []
  type: TYPE_TB
- en: '| [VARCHAR](#sqlalchemy.dialects.mysql.VARCHAR) | MySQL VARCHAR type, for variable-length
    character data. |'
  prefs: []
  type: TYPE_TB
- en: '| [YEAR](#sqlalchemy.dialects.mysql.YEAR) | MySQL YEAR type, for single byte
    storage of years 1901-2155. |'
  prefs: []
  type: TYPE_TB
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: MySQL BIGINTEGER type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.dialects.mysql.BIGINT.__init__)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.mysql.BIGINT`](#sqlalchemy.dialects.mysql.BIGINT
    "sqlalchemy.dialects.mysql.BIGINT") (`sqlalchemy.dialects.mysql.types._IntegerType`,
    [`sqlalchemy.types.BIGINT`](../core/type_basics.html#sqlalchemy.types.BIGINT "sqlalchemy.types.BIGINT"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Construct a BIGINTEGER.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`display_width` – Optional, maximum display width for this number.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unsigned` – a boolean, optional.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`zerofill` – Optional. If true, values will be stored as strings left-padded
    with zeros. Note that this does not effect the values returned by the underlying
    database API, which continue to be numeric.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The SQL BINARY type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class `sqlalchemy.dialects.mysql.BINARY` (`sqlalchemy.types._Binary`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: MySQL BIT type.
  prefs: []
  type: TYPE_NORMAL
- en: This type is for MySQL 5.0.3 or greater for MyISAM, and 5.0.5 or greater for
    MyISAM, MEMORY, InnoDB and BDB. For older versions, use a MSTinyInteger() type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.dialects.mysql.BIT.__init__)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.mysql.BIT`](#sqlalchemy.dialects.mysql.BIT "sqlalchemy.dialects.mysql.BIT")
    ([`sqlalchemy.types.TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Construct a BIT.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**length** – Optional, number of bits.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The SQL BLOB type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class `sqlalchemy.dialects.mysql.BLOB` ([`sqlalchemy.types.LargeBinary`](../core/type_basics.html#sqlalchemy.types.LargeBinary
    "sqlalchemy.types.LargeBinary"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `sqlalchemy.types.LargeBinary.__init__` *method of* [`LargeBinary`](../core/type_basics.html#sqlalchemy.types.LargeBinary
    "sqlalchemy.types.LargeBinary")'
  prefs: []
  type: TYPE_NORMAL
- en: Construct a LargeBinary type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**length** – optional, a length for the column for use in DDL statements, for
    those binary types that accept a length, such as the MySQL BLOB type.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The SQL BOOLEAN type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class `sqlalchemy.dialects.mysql.BOOLEAN` ([`sqlalchemy.types.Boolean`](../core/type_basics.html#sqlalchemy.types.Boolean
    "sqlalchemy.types.Boolean"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `sqlalchemy.types.Boolean.__init__` *method of* [`Boolean`](../core/type_basics.html#sqlalchemy.types.Boolean
    "sqlalchemy.types.Boolean")'
  prefs: []
  type: TYPE_NORMAL
- en: Construct a Boolean.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`create_constraint` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: defaults to False. If the boolean is generated as an int/smallint, also create
    a CHECK constraint on the table that ensures 1 or 0 as a value.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: it is strongly recommended that the CHECK constraint have an explicit name in
    order to support schema-management concerns. This can be established either by
    setting the [`Boolean.name`](../core/type_basics.html#sqlalchemy.types.Boolean.params.name
    "sqlalchemy.types.Boolean") parameter or by setting up an appropriate naming convention;
    see [Configuring Constraint Naming Conventions](../core/constraints.html#constraint-naming-conventions)
    for background.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Changed in version 1.4: - this flag now defaults to False, meaning no CHECK
    constraint is generated for a non-native enumerated type.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`name` – if a CHECK constraint is generated, specify the name of the constraint.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: MySQL CHAR type, for fixed-length character data.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.dialects.mysql.CHAR.__init__)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.mysql.CHAR`](#sqlalchemy.dialects.mysql.CHAR "sqlalchemy.dialects.mysql.CHAR")
    (`sqlalchemy.dialects.mysql.types._StringType`, [`sqlalchemy.types.CHAR`](../core/type_basics.html#sqlalchemy.types.CHAR
    "sqlalchemy.types.CHAR"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Construct a CHAR.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`length` – Maximum data length, in characters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`binary` – Optional, use the default binary collation for the national character
    set. This does not affect the type of data stored, use a BINARY type for binary
    data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`collation` – Optional, request a particular collation. Must be compatible
    with the national character set.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: The SQL DATE type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class `sqlalchemy.dialects.mysql.DATE` ([`sqlalchemy.types.Date`](../core/type_basics.html#sqlalchemy.types.Date
    "sqlalchemy.types.Date"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: MySQL DATETIME type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.dialects.mysql.DATETIME.__init__)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.mysql.DATETIME`](#sqlalchemy.dialects.mysql.DATETIME
    "sqlalchemy.dialects.mysql.DATETIME") ([`sqlalchemy.types.DATETIME`](../core/type_basics.html#sqlalchemy.types.DATETIME
    "sqlalchemy.types.DATETIME"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Construct a MySQL DATETIME type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`timezone` – not used by the MySQL dialect.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fsp` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: fractional seconds precision value. MySQL 5.6.4 supports storage of fractional
    seconds; this parameter will be used when emitting DDL for the DATETIME type.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: DBAPI driver support for fractional seconds may be limited; current support
    includes MySQL Connector/Python.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: MySQL DECIMAL type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.dialects.mysql.DECIMAL.__init__)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.mysql.DECIMAL`](#sqlalchemy.dialects.mysql.DECIMAL
    "sqlalchemy.dialects.mysql.DECIMAL") (`sqlalchemy.dialects.mysql.types._NumericType`,
    [`sqlalchemy.types.DECIMAL`](../core/type_basics.html#sqlalchemy.types.DECIMAL
    "sqlalchemy.types.DECIMAL"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Construct a DECIMAL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`precision` – Total digits in this number. If scale and precision are both
    None, values are stored to limits allowed by the server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scale` – The number of digits after the decimal point.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unsigned` – a boolean, optional.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`zerofill` – Optional. If true, values will be stored as strings left-padded
    with zeros. Note that this does not effect the values returned by the underlying
    database API, which continue to be numeric.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: MySQL DOUBLE type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class `sqlalchemy.dialects.mysql.DOUBLE` (`sqlalchemy.dialects.mysql.types._FloatType`,
    [`sqlalchemy.types.DOUBLE`](../core/type_basics.html#sqlalchemy.types.DOUBLE "sqlalchemy.types.DOUBLE"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Construct a DOUBLE.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The [`DOUBLE`](../core/type_basics.html#sqlalchemy.types.DOUBLE "sqlalchemy.types.DOUBLE")
    type by default converts from float to Decimal, using a truncation that defaults
    to 10 digits. Specify either `scale=n` or `decimal_return_scale=n` in order to
    change this scale, or `asdecimal=False` to return values directly as Python floating
    points.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`precision` – Total digits in this number. If scale and precision are both
    None, values are stored to limits allowed by the server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scale` – The number of digits after the decimal point.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unsigned` – a boolean, optional.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`zerofill` – Optional. If true, values will be stored as strings left-padded
    with zeros. Note that this does not effect the values returned by the underlying
    database API, which continue to be numeric.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: MySQL ENUM type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.dialects.mysql.ENUM.__init__)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.mysql.ENUM`](#sqlalchemy.dialects.mysql.ENUM "sqlalchemy.dialects.mysql.ENUM")
    (`sqlalchemy.types.NativeForEmulated`, [`sqlalchemy.types.Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum"), `sqlalchemy.dialects.mysql.types._StringType`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Construct an ENUM.
  prefs: []
  type: TYPE_NORMAL
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`enums` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The range of valid values for this ENUM. Values in enums are not quoted, they
    will be escaped and surrounded by single quotes when generating the schema. This
    object may also be a PEP-435-compliant enumerated type.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`strict` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This flag has no effect.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Changed in version The: MySQL ENUM type as well as the base Enum type now validates
    all Python data values.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`charset` – Optional, a column-level character set for this string value. Takes
    precedence to ‘ascii’ or ‘unicode’ short-hand.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`collation` – Optional, a column-level collation for this string value. Takes
    precedence to ‘binary’ short-hand.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ascii` – Defaults to False: short-hand for the `latin1` character set, generates
    ASCII in schema.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unicode` – Defaults to False: short-hand for the `ucs2` character set, generates
    UNICODE in schema.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`binary` – Defaults to False: short-hand, pick the binary collation type that
    matches the column’s character set. Generates BINARY in schema. This does not
    affect the type of data stored, only the collation of character data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: MySQL FLOAT type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.dialects.mysql.FLOAT.__init__)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.mysql.FLOAT`](#sqlalchemy.dialects.mysql.FLOAT "sqlalchemy.dialects.mysql.FLOAT")
    (`sqlalchemy.dialects.mysql.types._FloatType`, [`sqlalchemy.types.FLOAT`](../core/type_basics.html#sqlalchemy.types.FLOAT
    "sqlalchemy.types.FLOAT"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Construct a FLOAT.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`precision` – Total digits in this number. If scale and precision are both
    None, values are stored to limits allowed by the server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scale` – The number of digits after the decimal point.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unsigned` – a boolean, optional.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`zerofill` – Optional. If true, values will be stored as strings left-padded
    with zeros. Note that this does not effect the values returned by the underlying
    database API, which continue to be numeric.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: MySQL INTEGER type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.dialects.mysql.INTEGER.__init__)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.mysql.INTEGER`](#sqlalchemy.dialects.mysql.INTEGER
    "sqlalchemy.dialects.mysql.INTEGER") (`sqlalchemy.dialects.mysql.types._IntegerType`,
    [`sqlalchemy.types.INTEGER`](../core/type_basics.html#sqlalchemy.types.INTEGER
    "sqlalchemy.types.INTEGER"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Construct an INTEGER.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`display_width` – Optional, maximum display width for this number.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unsigned` – a boolean, optional.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`zerofill` – Optional. If true, values will be stored as strings left-padded
    with zeros. Note that this does not effect the values returned by the underlying
    database API, which continue to be numeric.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: MySQL JSON type.
  prefs: []
  type: TYPE_NORMAL
- en: MySQL supports JSON as of version 5.7. MariaDB supports JSON (as an alias for
    LONGTEXT) as of version 10.2.
  prefs: []
  type: TYPE_NORMAL
- en: '[`JSON`](#sqlalchemy.dialects.mysql.JSON "sqlalchemy.dialects.mysql.JSON")
    is used automatically whenever the base [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON") datatype is used against a MySQL or MariaDB backend.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON")
    - main documentation for the generic cross-platform JSON datatype.'
  prefs: []
  type: TYPE_NORMAL
- en: The [`JSON`](#sqlalchemy.dialects.mysql.JSON "sqlalchemy.dialects.mysql.JSON")
    type supports persistence of JSON values as well as the core index operations
    provided by [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON")
    datatype, by adapting the operations to render the `JSON_EXTRACT` function at
    the database level.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.mysql.JSON`](#sqlalchemy.dialects.mysql.JSON "sqlalchemy.dialects.mysql.JSON")
    ([`sqlalchemy.types.JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: MySQL LONGBLOB type, for binary data up to 2^32 bytes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.mysql.LONGBLOB`](#sqlalchemy.dialects.mysql.LONGBLOB
    "sqlalchemy.dialects.mysql.LONGBLOB") (`sqlalchemy.types._Binary`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: MySQL LONGTEXT type, for character storage encoded up to 2^32 bytes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.dialects.mysql.LONGTEXT.__init__)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.mysql.LONGTEXT`](#sqlalchemy.dialects.mysql.LONGTEXT
    "sqlalchemy.dialects.mysql.LONGTEXT") (`sqlalchemy.dialects.mysql.types._StringType`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Construct a LONGTEXT.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`charset` – Optional, a column-level character set for this string value. Takes
    precedence to ‘ascii’ or ‘unicode’ short-hand.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`collation` – Optional, a column-level collation for this string value. Takes
    precedence to ‘binary’ short-hand.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ascii` – Defaults to False: short-hand for the `latin1` character set, generates
    ASCII in schema.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unicode` – Defaults to False: short-hand for the `ucs2` character set, generates
    UNICODE in schema.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`national` – Optional. If true, use the server’s configured national character
    set.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`binary` – Defaults to False: short-hand, pick the binary collation type that
    matches the column’s character set. Generates BINARY in schema. This does not
    affect the type of data stored, only the collation of character data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: MySQL MEDIUMBLOB type, for binary data up to 2^24 bytes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.mysql.MEDIUMBLOB`](#sqlalchemy.dialects.mysql.MEDIUMBLOB
    "sqlalchemy.dialects.mysql.MEDIUMBLOB") (`sqlalchemy.types._Binary`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: MySQL MEDIUMINTEGER type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.dialects.mysql.MEDIUMINT.__init__)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.mysql.MEDIUMINT`](#sqlalchemy.dialects.mysql.MEDIUMINT
    "sqlalchemy.dialects.mysql.MEDIUMINT") (`sqlalchemy.dialects.mysql.types._IntegerType`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Construct a MEDIUMINTEGER
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`display_width` – Optional, maximum display width for this number.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unsigned` – a boolean, optional.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`zerofill` – Optional. If true, values will be stored as strings left-padded
    with zeros. Note that this does not effect the values returned by the underlying
    database API, which continue to be numeric.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: MySQL MEDIUMTEXT type, for character storage encoded up to 2^24 bytes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.dialects.mysql.MEDIUMTEXT.__init__)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.mysql.MEDIUMTEXT`](#sqlalchemy.dialects.mysql.MEDIUMTEXT
    "sqlalchemy.dialects.mysql.MEDIUMTEXT") (`sqlalchemy.dialects.mysql.types._StringType`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Construct a MEDIUMTEXT.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`charset` – Optional, a column-level character set for this string value. Takes
    precedence to ‘ascii’ or ‘unicode’ short-hand.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`collation` – Optional, a column-level collation for this string value. Takes
    precedence to ‘binary’ short-hand.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ascii` – Defaults to False: short-hand for the `latin1` character set, generates
    ASCII in schema.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unicode` – Defaults to False: short-hand for the `ucs2` character set, generates
    UNICODE in schema.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`national` – Optional. If true, use the server’s configured national character
    set.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`binary` – Defaults to False: short-hand, pick the binary collation type that
    matches the column’s character set. Generates BINARY in schema. This does not
    affect the type of data stored, only the collation of character data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: MySQL NCHAR type.
  prefs: []
  type: TYPE_NORMAL
- en: For fixed-length character data in the server’s configured national character
    set.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.dialects.mysql.NCHAR.__init__)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.mysql.NCHAR`](#sqlalchemy.dialects.mysql.NCHAR "sqlalchemy.dialects.mysql.NCHAR")
    (`sqlalchemy.dialects.mysql.types._StringType`, [`sqlalchemy.types.NCHAR`](../core/type_basics.html#sqlalchemy.types.NCHAR
    "sqlalchemy.types.NCHAR"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Construct an NCHAR.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`length` – Maximum data length, in characters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`binary` – Optional, use the default binary collation for the national character
    set. This does not affect the type of data stored, use a BINARY type for binary
    data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`collation` – Optional, request a particular collation. Must be compatible
    with the national character set.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: MySQL NUMERIC type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.dialects.mysql.NUMERIC.__init__)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.mysql.NUMERIC`](#sqlalchemy.dialects.mysql.NUMERIC
    "sqlalchemy.dialects.mysql.NUMERIC") (`sqlalchemy.dialects.mysql.types._NumericType`,
    [`sqlalchemy.types.NUMERIC`](../core/type_basics.html#sqlalchemy.types.NUMERIC
    "sqlalchemy.types.NUMERIC"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: Construct a NUMERIC.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`precision` – Total digits in this number. If scale and precision are both
    None, values are stored to limits allowed by the server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scale` – The number of digits after the decimal point.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unsigned` – a boolean, optional.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`zerofill` – Optional. If true, values will be stored as strings left-padded
    with zeros. Note that this does not effect the values returned by the underlying
    database API, which continue to be numeric.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: MySQL NVARCHAR type.
  prefs: []
  type: TYPE_NORMAL
- en: For variable-length character data in the server’s configured national character
    set.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.dialects.mysql.NVARCHAR.__init__)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.mysql.NVARCHAR`](#sqlalchemy.dialects.mysql.NVARCHAR
    "sqlalchemy.dialects.mysql.NVARCHAR") (`sqlalchemy.dialects.mysql.types._StringType`,
    [`sqlalchemy.types.NVARCHAR`](../core/type_basics.html#sqlalchemy.types.NVARCHAR
    "sqlalchemy.types.NVARCHAR"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Construct an NVARCHAR.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`length` – Maximum data length, in characters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`binary` – Optional, use the default binary collation for the national character
    set. This does not affect the type of data stored, use a BINARY type for binary
    data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`collation` – Optional, request a particular collation. Must be compatible
    with the national character set.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: MySQL REAL type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.dialects.mysql.REAL.__init__)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.mysql.REAL`](#sqlalchemy.dialects.mysql.REAL "sqlalchemy.dialects.mysql.REAL")
    (`sqlalchemy.dialects.mysql.types._FloatType`, [`sqlalchemy.types.REAL`](../core/type_basics.html#sqlalchemy.types.REAL
    "sqlalchemy.types.REAL"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: Construct a REAL.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The [`REAL`](#sqlalchemy.dialects.mysql.REAL "sqlalchemy.dialects.mysql.REAL")
    type by default converts from float to Decimal, using a truncation that defaults
    to 10 digits. Specify either `scale=n` or `decimal_return_scale=n` in order to
    change this scale, or `asdecimal=False` to return values directly as Python floating
    points.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`precision` – Total digits in this number. If scale and precision are both
    None, values are stored to limits allowed by the server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scale` – The number of digits after the decimal point.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unsigned` – a boolean, optional.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`zerofill` – Optional. If true, values will be stored as strings left-padded
    with zeros. Note that this does not effect the values returned by the underlying
    database API, which continue to be numeric.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: MySQL SET type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.dialects.mysql.SET.__init__)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.mysql.SET`](#sqlalchemy.dialects.mysql.SET "sqlalchemy.dialects.mysql.SET")
    (`sqlalchemy.dialects.mysql.types._StringType`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: Construct a SET.
  prefs: []
  type: TYPE_NORMAL
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: The list of potential values is required in the case that this set will be used
    to generate DDL for a table, or if the [`SET.retrieve_as_bitwise`](#sqlalchemy.dialects.mysql.SET.params.retrieve_as_bitwise
    "sqlalchemy.dialects.mysql.SET") flag is set to True.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`values` – The range of valid values for this SET. The values are not quoted,
    they will be escaped and surrounded by single quotes when generating the schema.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`convert_unicode` – Same flag as that of [`String.convert_unicode`](../core/type_basics.html#sqlalchemy.types.String.params.convert_unicode
    "sqlalchemy.types.String").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`collation` – same as that of [`String.collation`](../core/type_basics.html#sqlalchemy.types.String.params.collation
    "sqlalchemy.types.String")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`charset` – same as that of [`VARCHAR.charset`](#sqlalchemy.dialects.mysql.VARCHAR.params.charset
    "sqlalchemy.dialects.mysql.VARCHAR").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ascii` – same as that of [`VARCHAR.ascii`](#sqlalchemy.dialects.mysql.VARCHAR.params.ascii
    "sqlalchemy.dialects.mysql.VARCHAR").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unicode` – same as that of [`VARCHAR.unicode`](#sqlalchemy.dialects.mysql.VARCHAR.params.unicode
    "sqlalchemy.dialects.mysql.VARCHAR").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`binary` – same as that of [`VARCHAR.binary`](#sqlalchemy.dialects.mysql.VARCHAR.params.binary
    "sqlalchemy.dialects.mysql.VARCHAR").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`retrieve_as_bitwise` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: if True, the data for the set type will be persisted and selected using an integer
    value, where a set is coerced into a bitwise mask for persistence. MySQL allows
    this mode which has the advantage of being able to store values unambiguously,
    such as the blank string `''`. The datatype will appear as the expression `col
    + 0` in a SELECT statement, so that the value is coerced into an integer value
    in result sets. This flag is required if one wishes to persist a set that can
    store the blank string `''` as a value.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: When using [`SET.retrieve_as_bitwise`](#sqlalchemy.dialects.mysql.SET.params.retrieve_as_bitwise
    "sqlalchemy.dialects.mysql.SET"), it is essential that the list of set values
    is expressed in the **exact same order** as exists on the MySQL database.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: MySQL SMALLINTEGER type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.dialects.mysql.SMALLINT.__init__)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.mysql.SMALLINT`](#sqlalchemy.dialects.mysql.SMALLINT
    "sqlalchemy.dialects.mysql.SMALLINT") (`sqlalchemy.dialects.mysql.types._IntegerType`,
    [`sqlalchemy.types.SMALLINT`](../core/type_basics.html#sqlalchemy.types.SMALLINT
    "sqlalchemy.types.SMALLINT"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: Construct a SMALLINTEGER.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`display_width` – Optional, maximum display width for this number.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unsigned` – a boolean, optional.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`zerofill` – Optional. If true, values will be stored as strings left-padded
    with zeros. Note that this does not effect the values returned by the underlying
    database API, which continue to be numeric.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: MySQL TEXT type, for character storage encoded up to 2^16 bytes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class `sqlalchemy.dialects.mysql.TEXT` (`sqlalchemy.dialects.mysql.types._StringType`,
    [`sqlalchemy.types.TEXT`](../core/type_basics.html#sqlalchemy.types.TEXT "sqlalchemy.types.TEXT"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: Construct a TEXT.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`length` – Optional, if provided the server may optimize storage by substituting
    the smallest TEXT type sufficient to store `length` bytes of characters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`charset` – Optional, a column-level character set for this string value. Takes
    precedence to ‘ascii’ or ‘unicode’ short-hand.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`collation` – Optional, a column-level collation for this string value. Takes
    precedence to ‘binary’ short-hand.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ascii` – Defaults to False: short-hand for the `latin1` character set, generates
    ASCII in schema.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unicode` – Defaults to False: short-hand for the `ucs2` character set, generates
    UNICODE in schema.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`national` – Optional. If true, use the server’s configured national character
    set.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`binary` – Defaults to False: short-hand, pick the binary collation type that
    matches the column’s character set. Generates BINARY in schema. This does not
    affect the type of data stored, only the collation of character data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: MySQL TIME type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.dialects.mysql.TIME.__init__)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.mysql.TIME`](#sqlalchemy.dialects.mysql.TIME "sqlalchemy.dialects.mysql.TIME")
    ([`sqlalchemy.types.TIME`](../core/type_basics.html#sqlalchemy.types.TIME "sqlalchemy.types.TIME"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: Construct a MySQL TIME type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`timezone` – not used by the MySQL dialect.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fsp` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: fractional seconds precision value. MySQL 5.6 supports storage of fractional
    seconds; this parameter will be used when emitting DDL for the TIME type.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: DBAPI driver support for fractional seconds may be limited; current support
    includes MySQL Connector/Python.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: MySQL TIMESTAMP type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.dialects.mysql.TIMESTAMP.__init__)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.mysql.TIMESTAMP`](#sqlalchemy.dialects.mysql.TIMESTAMP
    "sqlalchemy.dialects.mysql.TIMESTAMP") ([`sqlalchemy.types.TIMESTAMP`](../core/type_basics.html#sqlalchemy.types.TIMESTAMP
    "sqlalchemy.types.TIMESTAMP"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: Construct a MySQL TIMESTAMP type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`timezone` – not used by the MySQL dialect.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fsp` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: fractional seconds precision value. MySQL 5.6.4 supports storage of fractional
    seconds; this parameter will be used when emitting DDL for the TIMESTAMP type.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: DBAPI driver support for fractional seconds may be limited; current support
    includes MySQL Connector/Python.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: MySQL TINYBLOB type, for binary data up to 2^8 bytes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.mysql.TINYBLOB`](#sqlalchemy.dialects.mysql.TINYBLOB
    "sqlalchemy.dialects.mysql.TINYBLOB") (`sqlalchemy.types._Binary`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: MySQL TINYINT type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.dialects.mysql.TINYINT.__init__)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.mysql.TINYINT`](#sqlalchemy.dialects.mysql.TINYINT
    "sqlalchemy.dialects.mysql.TINYINT") (`sqlalchemy.dialects.mysql.types._IntegerType`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: Construct a TINYINT.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`display_width` – Optional, maximum display width for this number.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unsigned` – a boolean, optional.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`zerofill` – Optional. If true, values will be stored as strings left-padded
    with zeros. Note that this does not effect the values returned by the underlying
    database API, which continue to be numeric.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: MySQL TINYTEXT type, for character storage encoded up to 2^8 bytes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.dialects.mysql.TINYTEXT.__init__)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.mysql.TINYTEXT`](#sqlalchemy.dialects.mysql.TINYTEXT
    "sqlalchemy.dialects.mysql.TINYTEXT") (`sqlalchemy.dialects.mysql.types._StringType`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: Construct a TINYTEXT.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`charset` – Optional, a column-level character set for this string value. Takes
    precedence to ‘ascii’ or ‘unicode’ short-hand.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`collation` – Optional, a column-level collation for this string value. Takes
    precedence to ‘binary’ short-hand.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ascii` – Defaults to False: short-hand for the `latin1` character set, generates
    ASCII in schema.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unicode` – Defaults to False: short-hand for the `ucs2` character set, generates
    UNICODE in schema.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`national` – Optional. If true, use the server’s configured national character
    set.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`binary` – Defaults to False: short-hand, pick the binary collation type that
    matches the column’s character set. Generates BINARY in schema. This does not
    affect the type of data stored, only the collation of character data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: The SQL VARBINARY type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class `sqlalchemy.dialects.mysql.VARBINARY` (`sqlalchemy.types._Binary`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: MySQL VARCHAR type, for variable-length character data.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.dialects.mysql.VARCHAR.__init__)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.mysql.VARCHAR`](#sqlalchemy.dialects.mysql.VARCHAR
    "sqlalchemy.dialects.mysql.VARCHAR") (`sqlalchemy.dialects.mysql.types._StringType`,
    [`sqlalchemy.types.VARCHAR`](../core/type_basics.html#sqlalchemy.types.VARCHAR
    "sqlalchemy.types.VARCHAR"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: Construct a VARCHAR.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`charset` – Optional, a column-level character set for this string value. Takes
    precedence to ‘ascii’ or ‘unicode’ short-hand.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`collation` – Optional, a column-level collation for this string value. Takes
    precedence to ‘binary’ short-hand.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ascii` – Defaults to False: short-hand for the `latin1` character set, generates
    ASCII in schema.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unicode` – Defaults to False: short-hand for the `ucs2` character set, generates
    UNICODE in schema.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`national` – Optional. If true, use the server’s configured national character
    set.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`binary` – Defaults to False: short-hand, pick the binary collation type that
    matches the column’s character set. Generates BINARY in schema. This does not
    affect the type of data stored, only the collation of character data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: MySQL YEAR type, for single byte storage of years 1901-2155.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.mysql.YEAR`](#sqlalchemy.dialects.mysql.YEAR "sqlalchemy.dialects.mysql.YEAR")
    ([`sqlalchemy.types.TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine"))
  prefs: []
  type: TYPE_NORMAL
- en: MySQL DML Constructs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '| Object Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| [insert](#sqlalchemy.dialects.mysql.insert)(table) | Construct a MySQL/MariaDB-specific
    variant [`Insert`](#sqlalchemy.dialects.mysql.Insert "sqlalchemy.dialects.mysql.Insert")
    construct. |'
  prefs: []
  type: TYPE_TB
- en: '| [Insert](#sqlalchemy.dialects.mysql.Insert) | MySQL-specific implementation
    of INSERT. |'
  prefs: []
  type: TYPE_TB
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: Construct a MySQL/MariaDB-specific variant [`Insert`](#sqlalchemy.dialects.mysql.Insert
    "sqlalchemy.dialects.mysql.Insert") construct.
  prefs: []
  type: TYPE_NORMAL
- en: The [`sqlalchemy.dialects.mysql.insert()`](#sqlalchemy.dialects.mysql.insert
    "sqlalchemy.dialects.mysql.insert") function creates a [`sqlalchemy.dialects.mysql.Insert`](#sqlalchemy.dialects.mysql.Insert
    "sqlalchemy.dialects.mysql.Insert"). This class is based on the dialect-agnostic
    [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert "sqlalchemy.sql.expression.Insert")
    construct which may be constructed using the [`insert()`](../core/dml.html#sqlalchemy.sql.expression.insert
    "sqlalchemy.sql.expression.insert") function in SQLAlchemy Core.
  prefs: []
  type: TYPE_NORMAL
- en: The [`Insert`](#sqlalchemy.dialects.mysql.Insert "sqlalchemy.dialects.mysql.Insert")
    construct includes additional methods [`Insert.on_duplicate_key_update()`](#sqlalchemy.dialects.mysql.Insert.on_duplicate_key_update
    "sqlalchemy.dialects.mysql.Insert.on_duplicate_key_update").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: MySQL-specific implementation of INSERT.
  prefs: []
  type: TYPE_NORMAL
- en: Adds methods for MySQL-specific syntaxes such as ON DUPLICATE KEY UPDATE.
  prefs: []
  type: TYPE_NORMAL
- en: The [`Insert`](#sqlalchemy.dialects.mysql.Insert "sqlalchemy.dialects.mysql.Insert")
    object is created using the [`sqlalchemy.dialects.mysql.insert()`](#sqlalchemy.dialects.mysql.insert
    "sqlalchemy.dialects.mysql.insert") function.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.2.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[inherit_cache](#sqlalchemy.dialects.mysql.Insert.inherit_cache), [inserted](#sqlalchemy.dialects.mysql.Insert.inserted),
    [on_duplicate_key_update()](#sqlalchemy.dialects.mysql.Insert.on_duplicate_key_update)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.mysql.Insert`](#sqlalchemy.dialects.mysql.Insert
    "sqlalchemy.dialects.mysql.Insert") ([`sqlalchemy.sql.expression.Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: Indicate if this [`HasCacheKey`](../core/foundation.html#sqlalchemy.sql.traversals.HasCacheKey
    "sqlalchemy.sql.traversals.HasCacheKey") instance should make use of the cache
    key generation scheme used by its immediate superclass.
  prefs: []
  type: TYPE_NORMAL
- en: The attribute defaults to `None`, which indicates that a construct has not yet
    taken into account whether or not its appropriate for it to participate in caching;
    this is functionally equivalent to setting the value to `False`, except that a
    warning is also emitted.
  prefs: []
  type: TYPE_NORMAL
- en: This flag can be set to `True` on a particular class, if the SQL that corresponds
    to the object does not change based on attributes which are local to this class,
    and not its superclass.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Enabling Caching Support for Custom Constructs](../core/compiler.html#compilerext-caching)
    - General guideslines for setting the [`HasCacheKey.inherit_cache`](../core/foundation.html#sqlalchemy.sql.traversals.HasCacheKey.inherit_cache
    "sqlalchemy.sql.traversals.HasCacheKey.inherit_cache") attribute for third-party
    or user defined SQL constructs.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: Provide the “inserted” namespace for an ON DUPLICATE KEY UPDATE statement
  prefs: []
  type: TYPE_NORMAL
- en: MySQL’s ON DUPLICATE KEY UPDATE clause allows reference to the row that would
    be inserted, via a special function called `VALUES()`. This attribute provides
    all columns in this row to be referenceable such that they will render within
    a `VALUES()` function inside the ON DUPLICATE KEY UPDATE clause. The attribute
    is named `.inserted` so as not to conflict with the existing [`Insert.values()`](../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") method.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: The [`Insert.inserted`](#sqlalchemy.dialects.mysql.Insert.inserted "sqlalchemy.dialects.mysql.Insert.inserted")
    attribute is an instance of [`ColumnCollection`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnCollection
    "sqlalchemy.sql.expression.ColumnCollection"), which provides an interface the
    same as that of the [`Table.c`](../core/metadata.html#sqlalchemy.schema.Table.c
    "sqlalchemy.schema.Table.c") collection described at [Accessing Tables and Columns](../core/metadata.html#metadata-tables-and-columns).
    With this collection, ordinary names are accessible like attributes (e.g. `stmt.inserted.some_column`),
    but special names and dictionary method names should be accessed using indexed
    access, such as `stmt.inserted["column name"]` or `stmt.inserted["values"]`. See
    the docstring for [`ColumnCollection`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnCollection
    "sqlalchemy.sql.expression.ColumnCollection") for further examples.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[INSERT…ON DUPLICATE KEY UPDATE (Upsert)](#mysql-insert-on-duplicate-key-update)
    - example of how to use `Insert.inserted`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: Specifies the ON DUPLICATE KEY UPDATE clause.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '****kw** – Column keys linked to UPDATE values. The values may be any SQL expression
    or supported literal Python values.'
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: This dictionary does **not** take into account Python-specified default UPDATE
    values or generation functions, e.g. those specified using [`Column.onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.onupdate
    "sqlalchemy.schema.Column"). These values will not be exercised for an ON DUPLICATE
    KEY UPDATE style of UPDATE, unless values are manually specified here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '***args** –'
  prefs: []
  type: TYPE_NORMAL
- en: As an alternative to passing key/value parameters, a dictionary or list of 2-tuples
    can be passed as a single positional argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'Passing a single dictionary is equivalent to the keyword argument form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'Passing a list of 2-tuples indicates that the parameter assignments in the
    UPDATE clause should be ordered as sent, in a manner similar to that described
    for the [`Update`](../core/dml.html#sqlalchemy.sql.expression.Update "sqlalchemy.sql.expression.Update")
    construct overall in [Parameter Ordered Updates](../tutorial/data_update.html#tutorial-parameter-ordered-updates):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'Changed in version 1.3: parameters can be specified as a dictionary or list
    of 2-tuples; the latter form provides for parameter ordering.'
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.2.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[INSERT…ON DUPLICATE KEY UPDATE (Upsert)](#mysql-insert-on-duplicate-key-update)'
  prefs: []
  type: TYPE_NORMAL
- en: '## mysqlclient (fork of MySQL-Python)'
  prefs: []
  type: TYPE_NORMAL
- en: Support for the MySQL / MariaDB database via the mysqlclient (maintained fork
    of MySQL-Python) driver.
  prefs: []
  type: TYPE_NORMAL
- en: DBAPI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Documentation and download information (if applicable) for mysqlclient (maintained
    fork of MySQL-Python) is available at: [https://pypi.org/project/mysqlclient/](https://pypi.org/project/mysqlclient/)'
  prefs: []
  type: TYPE_NORMAL
- en: Connecting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Connect String:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: Driver Status
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The mysqlclient DBAPI is a maintained fork of the [MySQL-Python](https://sourceforge.net/projects/mysql-python)
    DBAPI that is no longer maintained. [mysqlclient](https://github.com/PyMySQL/mysqlclient-python)
    supports Python 2 and Python 3 and is very stable.
  prefs: []
  type: TYPE_NORMAL
- en: '### Unicode'
  prefs: []
  type: TYPE_NORMAL
- en: 'Please see [Unicode](#mysql-unicode) for current recommendations on unicode
    handling.  ### SSL Connections'
  prefs: []
  type: TYPE_NORMAL
- en: 'The mysqlclient and PyMySQL DBAPIs accept an additional dictionary under the
    key “ssl”, which may be specified using the [`create_engine.connect_args`](../core/engines.html#sqlalchemy.create_engine.params.connect_args
    "sqlalchemy.create_engine") dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'For convenience, the following keys may also be specified inline within the
    URL where they will be interpreted into the “ssl” dictionary automatically: “ssl_ca”,
    “ssl_cert”, “ssl_key”, “ssl_capath”, “ssl_cipher”, “ssl_check_hostname”. An example
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[SSL Connections](#pymysql-ssl) in the PyMySQL dialect'
  prefs: []
  type: TYPE_NORMAL
- en: Using MySQLdb with Google Cloud SQL
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Google Cloud SQL now recommends use of the MySQLdb dialect. Connect using a
    URL like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: Server Side Cursors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The mysqldb dialect supports server-side cursors. See [Server Side Cursors](#mysql-ss-cursors).  ##
    PyMySQL'
  prefs: []
  type: TYPE_NORMAL
- en: Support for the MySQL / MariaDB database via the PyMySQL driver.
  prefs: []
  type: TYPE_NORMAL
- en: DBAPI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Documentation and download information (if applicable) for PyMySQL is available
    at: [https://pymysql.readthedocs.io/](https://pymysql.readthedocs.io/)'
  prefs: []
  type: TYPE_NORMAL
- en: Connecting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Connect String:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: Unicode
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Please see [Unicode](#mysql-unicode) for current recommendations on unicode
    handling.
  prefs: []
  type: TYPE_NORMAL
- en: '### SSL Connections'
  prefs: []
  type: TYPE_NORMAL
- en: The PyMySQL DBAPI accepts the same SSL arguments as that of MySQLdb, described
    at [SSL Connections](#mysqldb-ssl). See that section for additional examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the server uses an automatically-generated certificate that is self-signed
    or does not match the host name (as seen from the client), it may also be necessary
    to indicate `ssl_check_hostname=false` in PyMySQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: MySQL-Python Compatibility
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The pymysql DBAPI is a pure Python port of the MySQL-python (MySQLdb) driver,
    and targets 100% compatibility. Most behavioral notes for MySQL-python apply to
    the pymysql driver as well.  ## MariaDB-Connector'
  prefs: []
  type: TYPE_NORMAL
- en: Support for the MySQL / MariaDB database via the MariaDB Connector/Python driver.
  prefs: []
  type: TYPE_NORMAL
- en: DBAPI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Documentation and download information (if applicable) for MariaDB Connector/Python
    is available at: [https://pypi.org/project/mariadb/](https://pypi.org/project/mariadb/)'
  prefs: []
  type: TYPE_NORMAL
- en: Connecting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Connect String:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: Driver Status
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: MariaDB Connector/Python enables Python programs to access MariaDB and MySQL
    databases using an API which is compliant with the Python DB API 2.0 (PEP-249).
    It is written in C and uses MariaDB Connector/C client library for client server
    communication.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the default driver for a `mariadb://` connection URI continues to
    be `mysqldb`. `mariadb+mariadbconnector://` is required to use this driver.  ##
    MySQL-Connector'
  prefs: []
  type: TYPE_NORMAL
- en: Support for the MySQL / MariaDB database via the MySQL Connector/Python driver.
  prefs: []
  type: TYPE_NORMAL
- en: DBAPI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Documentation and download information (if applicable) for MySQL Connector/Python
    is available at: [https://pypi.org/project/mysql-connector-python/](https://pypi.org/project/mysql-connector-python/)'
  prefs: []
  type: TYPE_NORMAL
- en: Connecting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Connect String:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The MySQL Connector/Python DBAPI has had many issues since its release, some
    of which may remain unresolved, and the mysqlconnector dialect is **not tested
    as part of SQLAlchemy’s continuous integration**. The recommended MySQL dialects
    are mysqlclient and PyMySQL.  ## asyncmy'
  prefs: []
  type: TYPE_NORMAL
- en: Support for the MySQL / MariaDB database via the asyncmy driver.
  prefs: []
  type: TYPE_NORMAL
- en: DBAPI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Documentation and download information (if applicable) for asyncmy is available
    at: [https://github.com/long2ice/asyncmy](https://github.com/long2ice/asyncmy)'
  prefs: []
  type: TYPE_NORMAL
- en: Connecting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Connect String:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: Using a special asyncio mediation layer, the asyncmy dialect is usable as the
    backend for the [SQLAlchemy asyncio](../orm/extensions/asyncio.html) extension
    package.
  prefs: []
  type: TYPE_NORMAL
- en: 'This dialect should normally be used only with the [`create_async_engine()`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.create_async_engine
    "sqlalchemy.ext.asyncio.create_async_engine") engine creation function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]  ## aiomysql'
  prefs: []
  type: TYPE_NORMAL
- en: Support for the MySQL / MariaDB database via the aiomysql driver.
  prefs: []
  type: TYPE_NORMAL
- en: DBAPI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Documentation and download information (if applicable) for aiomysql is available
    at: [https://github.com/aio-libs/aiomysql](https://github.com/aio-libs/aiomysql)'
  prefs: []
  type: TYPE_NORMAL
- en: Connecting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Connect String:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: The aiomysql dialect is SQLAlchemy’s second Python asyncio dialect.
  prefs: []
  type: TYPE_NORMAL
- en: Using a special asyncio mediation layer, the aiomysql dialect is usable as the
    backend for the [SQLAlchemy asyncio](../orm/extensions/asyncio.html) extension
    package.
  prefs: []
  type: TYPE_NORMAL
- en: 'This dialect should normally be used only with the [`create_async_engine()`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.create_async_engine
    "sqlalchemy.ext.asyncio.create_async_engine") engine creation function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]  ## cymysql'
  prefs: []
  type: TYPE_NORMAL
- en: Support for the MySQL / MariaDB database via the CyMySQL driver.
  prefs: []
  type: TYPE_NORMAL
- en: DBAPI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Documentation and download information (if applicable) for CyMySQL is available
    at: [https://github.com/nakagami/CyMySQL](https://github.com/nakagami/CyMySQL)'
  prefs: []
  type: TYPE_NORMAL
- en: Connecting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Connect String:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The CyMySQL dialect is **not tested as part of SQLAlchemy’s continuous integration**
    and may have unresolved issues. The recommended MySQL dialects are mysqlclient
    and PyMySQL.  ## pyodbc'
  prefs: []
  type: TYPE_NORMAL
- en: Support for the MySQL / MariaDB database via the PyODBC driver.
  prefs: []
  type: TYPE_NORMAL
- en: DBAPI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Documentation and download information (if applicable) for PyODBC is available
    at: [https://pypi.org/project/pyodbc/](https://pypi.org/project/pyodbc/)'
  prefs: []
  type: TYPE_NORMAL
- en: Connecting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Connect String:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The PyODBC for MySQL dialect is **not tested as part of SQLAlchemy’s continuous
    integration**. The recommended MySQL dialects are mysqlclient and PyMySQL. However,
    if you want to use the mysql+pyodbc dialect and require full support for `utf8mb4`
    characters (including supplementary characters like emoji) be sure to use a current
    release of MySQL Connector/ODBC and specify the “ANSI” (**not** “Unicode”) version
    of the driver in your DSN or connection string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pass through exact pyodbc connection string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: Support for the MySQL / MariaDB database.
  prefs: []
  type: TYPE_NORMAL
- en: The following table summarizes current support levels for database release versions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Supported MySQL / MariaDB versions**'
  prefs: []
  type: TYPE_NORMAL
- en: '| Support type | Versions |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| [Fully tested in CI](index.html#term-Fully-tested-in-CI) | 5.6, 5.7, 8.0
    / 10.8, 10.9 |'
  prefs: []
  type: TYPE_TB
- en: '| [Normal support](index.html#term-Normal-support) | 5.6+ / 10+ |'
  prefs: []
  type: TYPE_TB
- en: '| [Best effort](index.html#term-Best-effort) | 5.0.2+ / 5.0.2+ |'
  prefs: []
  type: TYPE_TB
- en: DBAPI Support
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following dialect/DBAPI options are available. Please refer to individual
    DBAPI sections for connect information.
  prefs: []
  type: TYPE_NORMAL
- en: '[mysqlclient (maintained fork of MySQL-Python)](#module-sqlalchemy.dialects.mysql.mysqldb)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PyMySQL](#module-sqlalchemy.dialects.mysql.pymysql)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[MariaDB Connector/Python](#module-sqlalchemy.dialects.mysql.mariadbconnector)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[MySQL Connector/Python](#module-sqlalchemy.dialects.mysql.mysqlconnector)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[asyncmy](#module-sqlalchemy.dialects.mysql.asyncmy)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[aiomysql](#module-sqlalchemy.dialects.mysql.aiomysql)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[CyMySQL](#module-sqlalchemy.dialects.mysql.cymysql)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PyODBC](#module-sqlalchemy.dialects.mysql.pyodbc)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supported Versions and Features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SQLAlchemy supports MySQL starting with version 5.0.2 through modern releases,
    as well as all modern versions of MariaDB. See the official MySQL documentation
    for detailed information about features supported in any given server release.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.4: minimum MySQL version supported is now 5.0.2.'
  prefs: []
  type: TYPE_NORMAL
- en: MariaDB Support
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The MariaDB variant of MySQL retains fundamental compatibility with MySQL’s
    protocols however the development of these two products continues to diverge.
    Within the realm of SQLAlchemy, the two databases have a small number of syntactical
    and behavioral differences that SQLAlchemy accommodates automatically. To connect
    to a MariaDB database, no changes to the database URL are required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: Upon first connect, the SQLAlchemy dialect employs a server version detection
    scheme that determines if the backing database reports as MariaDB. Based on this
    flag, the dialect can make different choices in those of areas where its behavior
    must be different.
  prefs: []
  type: TYPE_NORMAL
- en: '### MariaDB-Only Mode'
  prefs: []
  type: TYPE_NORMAL
- en: 'The dialect also supports an **optional** “MariaDB-only” mode of connection,
    which may be useful for the case where an application makes use of MariaDB-specific
    features and is not compatible with a MySQL database. To use this mode of operation,
    replace the “mysql” token in the above URL with “mariadb”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: The above engine, upon first connect, will raise an error if the server version
    detection detects that the backing database is not MariaDB.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using an engine with `"mariadb"` as the dialect name, **all mysql-specific
    options that include the name “mysql” in them are now named with “mariadb”**.
    This means options like `mysql_engine` should be named `mariadb_engine`, etc.
    Both “mysql” and “mariadb” options can be used simultaneously for applications
    that use URLs with both “mysql” and “mariadb” dialects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: Similar behavior will occur when the above structures are reflected, i.e. the
    “mariadb” prefix will be present in the option names when the database URL is
    based on the “mariadb” name.
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 1.4: Added “mariadb” dialect name supporting “MariaDB-only mode”
    for the MySQL dialect.'
  prefs: []
  type: TYPE_NORMAL
- en: MariaDB Support
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The MariaDB variant of MySQL retains fundamental compatibility with MySQL’s
    protocols however the development of these two products continues to diverge.
    Within the realm of SQLAlchemy, the two databases have a small number of syntactical
    and behavioral differences that SQLAlchemy accommodates automatically. To connect
    to a MariaDB database, no changes to the database URL are required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: Upon first connect, the SQLAlchemy dialect employs a server version detection
    scheme that determines if the backing database reports as MariaDB. Based on this
    flag, the dialect can make different choices in those of areas where its behavior
    must be different.
  prefs: []
  type: TYPE_NORMAL
- en: '### MariaDB-Only Mode'
  prefs: []
  type: TYPE_NORMAL
- en: 'The dialect also supports an **optional** “MariaDB-only” mode of connection,
    which may be useful for the case where an application makes use of MariaDB-specific
    features and is not compatible with a MySQL database. To use this mode of operation,
    replace the “mysql” token in the above URL with “mariadb”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: The above engine, upon first connect, will raise an error if the server version
    detection detects that the backing database is not MariaDB.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using an engine with `"mariadb"` as the dialect name, **all mysql-specific
    options that include the name “mysql” in them are now named with “mariadb”**.
    This means options like `mysql_engine` should be named `mariadb_engine`, etc.
    Both “mysql” and “mariadb” options can be used simultaneously for applications
    that use URLs with both “mysql” and “mariadb” dialects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: Similar behavior will occur when the above structures are reflected, i.e. the
    “mariadb” prefix will be present in the option names when the database URL is
    based on the “mariadb” name.
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 1.4: Added “mariadb” dialect name supporting “MariaDB-only mode”
    for the MySQL dialect.'
  prefs: []
  type: TYPE_NORMAL
- en: '## Connection Timeouts and Disconnects'
  prefs: []
  type: TYPE_NORMAL
- en: 'MySQL / MariaDB feature an automatic connection close behavior, for connections
    that have been idle for a fixed period of time, defaulting to eight hours. To
    circumvent having this issue, use the [`create_engine.pool_recycle`](../core/engines.html#sqlalchemy.create_engine.params.pool_recycle
    "sqlalchemy.create_engine") option which ensures that a connection will be discarded
    and replaced with a new one if it has been present in the pool for a fixed number
    of seconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: For more comprehensive disconnect detection of pooled connections, including
    accommodation of server restarts and network issues, a pre-ping approach may be
    employed. See [Dealing with Disconnects](../core/pooling.html#pool-disconnects)
    for current approaches.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Dealing with Disconnects](../core/pooling.html#pool-disconnects) - Background
    on several techniques for dealing with timed out connections as well as database
    restarts.'
  prefs: []
  type: TYPE_NORMAL
- en: '## CREATE TABLE arguments including Storage Engines'
  prefs: []
  type: TYPE_NORMAL
- en: 'Both MySQL’s and MariaDB’s CREATE TABLE syntax includes a wide array of special
    options, including `ENGINE`, `CHARSET`, `MAX_ROWS`, `ROW_FORMAT`, `INSERT_METHOD`,
    and many more. To accommodate the rendering of these arguments, specify the form
    `mysql_argument_name="value"`. For example, to specify a table with `ENGINE` of
    `InnoDB`, `CHARSET` of `utf8mb4`, and `KEY_BLOCK_SIZE` of `1024`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: 'When supporting [MariaDB-Only Mode](#mysql-mariadb-only-mode) mode, similar
    keys against the “mariadb” prefix must be included as well. The values can of
    course vary independently so that different settings on MySQL vs. MariaDB may
    be maintained:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: The MySQL / MariaDB dialects will normally transfer any keyword specified as
    `mysql_keyword_name` to be rendered as `KEYWORD_NAME` in the `CREATE TABLE` statement.
    A handful of these names will render with a space instead of an underscore; to
    support this, the MySQL dialect has awareness of these particular names, which
    include `DATA DIRECTORY` (e.g. `mysql_data_directory`), `CHARACTER SET` (e.g.
    `mysql_character_set`) and `INDEX DIRECTORY` (e.g. `mysql_index_directory`).
  prefs: []
  type: TYPE_NORMAL
- en: The most common argument is `mysql_engine`, which refers to the storage engine
    for the table. Historically, MySQL server installations would default to `MyISAM`
    for this value, although newer versions may be defaulting to `InnoDB`. The `InnoDB`
    engine is typically preferred for its support of transactions and foreign keys.
  prefs: []
  type: TYPE_NORMAL
- en: A [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    that is created in a MySQL / MariaDB database with a storage engine of `MyISAM`
    will be essentially non-transactional, meaning any INSERT/UPDATE/DELETE statement
    referring to this table will be invoked as autocommit. It also will have no support
    for foreign key constraints; while the `CREATE TABLE` statement accepts foreign
    key options, when using the `MyISAM` storage engine these arguments are discarded.
    Reflecting such a table will also produce no foreign key constraint information.
  prefs: []
  type: TYPE_NORMAL
- en: For fully atomic transactions as well as support for foreign key constraints,
    all participating `CREATE TABLE` statements must specify a transactional engine,
    which in the vast majority of cases is `InnoDB`.
  prefs: []
  type: TYPE_NORMAL
- en: Case Sensitivity and Table Reflection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Both MySQL and MariaDB have inconsistent support for case-sensitive identifier
    names, basing support on specific details of the underlying operating system.
    However, it has been observed that no matter what case sensitivity behavior is
    present, the names of tables in foreign key declarations are *always* received
    from the database as all-lower case, making it impossible to accurately reflect
    a schema where inter-related tables use mixed-case identifier names.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore it is strongly advised that table names be declared as all lower case
    both within SQLAlchemy as well as on the MySQL / MariaDB database itself, especially
    if database reflection features are to be used.
  prefs: []
  type: TYPE_NORMAL
- en: '## Transaction Isolation Level'
  prefs: []
  type: TYPE_NORMAL
- en: All MySQL / MariaDB dialects support setting of transaction isolation level
    both via a dialect-specific parameter [`create_engine.isolation_level`](../core/engines.html#sqlalchemy.create_engine.params.isolation_level
    "sqlalchemy.create_engine") accepted by [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine"), as well as the [`Connection.execution_options.isolation_level`](../core/connections.html#sqlalchemy.engine.Connection.execution_options.params.isolation_level
    "sqlalchemy.engine.Connection.execution_options") argument as passed to [`Connection.execution_options()`](../core/connections.html#sqlalchemy.engine.Connection.execution_options
    "sqlalchemy.engine.Connection.execution_options"). This feature works by issuing
    the command `SET SESSION TRANSACTION ISOLATION LEVEL <level>` for each new connection.
    For the special AUTOCOMMIT isolation level, DBAPI-specific techniques are used.
  prefs: []
  type: TYPE_NORMAL
- en: 'To set isolation level using [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: 'To set using per-connection execution options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: 'Valid values for `isolation_level` include:'
  prefs: []
  type: TYPE_NORMAL
- en: '`READ COMMITTED`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`READ UNCOMMITTED`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`REPEATABLE READ`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SERIALIZABLE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AUTOCOMMIT`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The special `AUTOCOMMIT` value makes use of the various “autocommit” attributes
    provided by specific DBAPIs, and is currently supported by MySQLdb, MySQL-Client,
    MySQL-Connector Python, and PyMySQL. Using it, the database connection will return
    true for the value of `SELECT @@autocommit;`.
  prefs: []
  type: TYPE_NORMAL
- en: There are also more options for isolation level configurations, such as “sub-engine”
    objects linked to a main [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") which each apply different isolation level settings.
    See the discussion at [Setting Transaction Isolation Levels including DBAPI Autocommit](../core/connections.html#dbapi-autocommit)
    for background.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Setting Transaction Isolation Levels including DBAPI Autocommit](../core/connections.html#dbapi-autocommit)'
  prefs: []
  type: TYPE_NORMAL
- en: AUTO_INCREMENT Behavior
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When creating tables, SQLAlchemy will automatically set `AUTO_INCREMENT` on
    the first [`Integer`](../core/type_basics.html#sqlalchemy.types.Integer "sqlalchemy.types.Integer")
    primary key column which is not marked as a foreign key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: 'You can disable this behavior by passing `False` to the [`Column.autoincrement`](../core/metadata.html#sqlalchemy.schema.Column.params.autoincrement
    "sqlalchemy.schema.Column") argument of [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column"). This flag can also be used to enable auto-increment
    on a secondary column in a multi-column key for some storage engines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: '## Server Side Cursors'
  prefs: []
  type: TYPE_NORMAL
- en: Server-side cursor support is available for the mysqlclient, PyMySQL, mariadbconnector
    dialects and may also be available in others. This makes use of either the “buffered=True/False”
    flag if available or by using a class such as `MySQLdb.cursors.SSCursor` or `pymysql.cursors.SSCursor`
    internally.
  prefs: []
  type: TYPE_NORMAL
- en: 'Server side cursors are enabled on a per-statement basis by using the [`Connection.execution_options.stream_results`](../core/connections.html#sqlalchemy.engine.Connection.execution_options.params.stream_results
    "sqlalchemy.engine.Connection.execution_options") connection execution option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: Note that some kinds of SQL statements may not be supported with server side
    cursors; generally, only SQL statements that return rows should be used with this
    option.
  prefs: []
  type: TYPE_NORMAL
- en: 'Deprecated since version 1.4: The dialect-level server_side_cursors flag is
    deprecated and will be removed in a future release. Please use the [`Connection.stream_results`](../core/connections.html#sqlalchemy.engine.Connection.params.stream_results
    "sqlalchemy.engine.Connection") execution option for unbuffered cursor support.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Using Server Side Cursors (a.k.a. stream results)](../core/connections.html#engine-stream-results)'
  prefs: []
  type: TYPE_NORMAL
- en: '## Unicode'
  prefs: []
  type: TYPE_NORMAL
- en: Charset Selection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Most MySQL / MariaDB DBAPIs offer the option to set the client character set
    for a connection. This is typically delivered using the `charset` parameter in
    the URL, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: This charset is the **client character set** for the connection. Some MySQL
    DBAPIs will default this to a value such as `latin1`, and some will make use of
    the `default-character-set` setting in the `my.cnf` file as well. Documentation
    for the DBAPI in use should be consulted for specific behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'The encoding used for Unicode has traditionally been `''utf8''`. However, for
    MySQL versions 5.5.3 and MariaDB 5.5 on forward, a new MySQL-specific encoding
    `''utf8mb4''` has been introduced, and as of MySQL 8.0 a warning is emitted by
    the server if plain `utf8` is specified within any server-side directives, replaced
    with `utf8mb3`. The rationale for this new encoding is due to the fact that MySQL’s
    legacy utf-8 encoding only supports codepoints up to three bytes instead of four.
    Therefore, when communicating with a MySQL or MariaDB database that includes codepoints
    more than three bytes in size, this new charset is preferred, if supported by
    both the database as well as the client DBAPI, as in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: All modern DBAPIs should support the `utf8mb4` charset.
  prefs: []
  type: TYPE_NORMAL
- en: In order to use `utf8mb4` encoding for a schema that was created with legacy
    `utf8`, changes to the MySQL/MariaDB schema and/or server configuration may be
    required.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[The utf8mb4 Character Set](https://dev.mysql.com/doc/refman/5.5/en/charset-unicode-utf8mb4.html)
    - in the MySQL documentation'
  prefs: []
  type: TYPE_NORMAL
- en: '### Dealing with Binary Data Warnings and Unicode'
  prefs: []
  type: TYPE_NORMAL
- en: 'MySQL versions 5.6, 5.7 and later (not MariaDB at the time of this writing)
    now emit a warning when attempting to pass binary data to the database, while
    a character set encoding is also in place, when the binary data itself is not
    valid for that encoding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: 'This warning is due to the fact that the MySQL client library is attempting
    to interpret the binary string as a unicode object even if a datatype such as
    [`LargeBinary`](../core/type_basics.html#sqlalchemy.types.LargeBinary "sqlalchemy.types.LargeBinary")
    is in use. To resolve this, the SQL statement requires a binary “character set
    introducer” be present before any non-NULL value that renders like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: 'These character set introducers are provided by the DBAPI driver, assuming
    the use of mysqlclient or PyMySQL (both of which are recommended). Add the query
    string parameter `binary_prefix=true` to the URL to repair this warning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: The `binary_prefix` flag may or may not be supported by other MySQL drivers.
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy itself cannot render this `_binary` prefix reliably, as it does not
    work with the NULL value, which is valid to be sent as a bound parameter. As the
    MySQL driver renders parameters directly into the SQL string, it’s the most efficient
    place for this additional keyword to be passed.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Character set introducers](https://dev.mysql.com/doc/refman/5.7/en/charset-introducer.html)
    - on the MySQL website'
  prefs: []
  type: TYPE_NORMAL
- en: Charset Selection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Most MySQL / MariaDB DBAPIs offer the option to set the client character set
    for a connection. This is typically delivered using the `charset` parameter in
    the URL, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: This charset is the **client character set** for the connection. Some MySQL
    DBAPIs will default this to a value such as `latin1`, and some will make use of
    the `default-character-set` setting in the `my.cnf` file as well. Documentation
    for the DBAPI in use should be consulted for specific behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'The encoding used for Unicode has traditionally been `''utf8''`. However, for
    MySQL versions 5.5.3 and MariaDB 5.5 on forward, a new MySQL-specific encoding
    `''utf8mb4''` has been introduced, and as of MySQL 8.0 a warning is emitted by
    the server if plain `utf8` is specified within any server-side directives, replaced
    with `utf8mb3`. The rationale for this new encoding is due to the fact that MySQL’s
    legacy utf-8 encoding only supports codepoints up to three bytes instead of four.
    Therefore, when communicating with a MySQL or MariaDB database that includes codepoints
    more than three bytes in size, this new charset is preferred, if supported by
    both the database as well as the client DBAPI, as in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: All modern DBAPIs should support the `utf8mb4` charset.
  prefs: []
  type: TYPE_NORMAL
- en: In order to use `utf8mb4` encoding for a schema that was created with legacy
    `utf8`, changes to the MySQL/MariaDB schema and/or server configuration may be
    required.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[The utf8mb4 Character Set](https://dev.mysql.com/doc/refman/5.5/en/charset-unicode-utf8mb4.html)
    - in the MySQL documentation'
  prefs: []
  type: TYPE_NORMAL
- en: '### Dealing with Binary Data Warnings and Unicode'
  prefs: []
  type: TYPE_NORMAL
- en: 'MySQL versions 5.6, 5.7 and later (not MariaDB at the time of this writing)
    now emit a warning when attempting to pass binary data to the database, while
    a character set encoding is also in place, when the binary data itself is not
    valid for that encoding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: 'This warning is due to the fact that the MySQL client library is attempting
    to interpret the binary string as a unicode object even if a datatype such as
    [`LargeBinary`](../core/type_basics.html#sqlalchemy.types.LargeBinary "sqlalchemy.types.LargeBinary")
    is in use. To resolve this, the SQL statement requires a binary “character set
    introducer” be present before any non-NULL value that renders like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: 'These character set introducers are provided by the DBAPI driver, assuming
    the use of mysqlclient or PyMySQL (both of which are recommended). Add the query
    string parameter `binary_prefix=true` to the URL to repair this warning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: The `binary_prefix` flag may or may not be supported by other MySQL drivers.
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy itself cannot render this `_binary` prefix reliably, as it does not
    work with the NULL value, which is valid to be sent as a bound parameter. As the
    MySQL driver renders parameters directly into the SQL string, it’s the most efficient
    place for this additional keyword to be passed.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Character set introducers](https://dev.mysql.com/doc/refman/5.7/en/charset-introducer.html)
    - on the MySQL website'
  prefs: []
  type: TYPE_NORMAL
- en: ANSI Quoting Style
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MySQL / MariaDB feature two varieties of identifier “quoting style”, one using
    backticks and the other using quotes, e.g. ``some_identifier`` vs. `"some_identifier"`.
    All MySQL dialects detect which version is in use by checking the value of [sql_mode](#mysql-sql-mode)
    when a connection is first established with a particular [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine"). This quoting style comes into play when rendering
    table and column names as well as when reflecting existing database structures.
    The detection is entirely automatic and no special configuration is needed to
    use either quoting style.
  prefs: []
  type: TYPE_NORMAL
- en: '## Changing the sql_mode'
  prefs: []
  type: TYPE_NORMAL
- en: MySQL supports operating in multiple [Server SQL Modes](https://dev.mysql.com/doc/refman/8.0/en/sql-mode.html)
    for both Servers and Clients. To change the `sql_mode` for a given application,
    a developer can leverage SQLAlchemy’s Events system.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, the event system is used to set the `sql_mode` on
    the `first_connect` and `connect` events:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: In the example illustrated above, the “connect” event will invoke the “SET”
    statement on the connection at the moment a particular DBAPI connection is first
    created for a given Pool, before the connection is made available to the connection
    pool. Additionally, because the function was registered with `insert=True`, it
    will be prepended to the internal list of registered functions.
  prefs: []
  type: TYPE_NORMAL
- en: MySQL / MariaDB SQL Extensions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Many of the MySQL / MariaDB SQL extensions are handled through SQLAlchemy’s
    generic function and operator support:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: And of course any valid SQL statement can be executed as a string as well.
  prefs: []
  type: TYPE_NORMAL
- en: Some limited direct support for MySQL / MariaDB extensions to SQL is currently
    available.
  prefs: []
  type: TYPE_NORMAL
- en: 'INSERT..ON DUPLICATE KEY UPDATE: See [INSERT…ON DUPLICATE KEY UPDATE (Upsert)](#mysql-insert-on-duplicate-key-update)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'SELECT pragma, use [`Select.prefix_with()`](../core/selectable.html#sqlalchemy.sql.expression.Select.prefix_with
    "sqlalchemy.sql.expression.Select.prefix_with") and [`Query.prefix_with()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.prefix_with
    "sqlalchemy.orm.Query.prefix_with"):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'UPDATE with LIMIT:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'optimizer hints, use [`Select.prefix_with()`](../core/selectable.html#sqlalchemy.sql.expression.Select.prefix_with
    "sqlalchemy.sql.expression.Select.prefix_with") and [`Query.prefix_with()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.prefix_with
    "sqlalchemy.orm.Query.prefix_with"):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'index hints, use [`Select.with_hint()`](../core/selectable.html#sqlalchemy.sql.expression.Select.with_hint
    "sqlalchemy.sql.expression.Select.with_hint") and [`Query.with_hint()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.with_hint
    "sqlalchemy.orm.Query.with_hint"):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'MATCH operator support:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: INSERT/DELETE…RETURNING
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The MariaDB dialect supports 10.5+’s `INSERT..RETURNING` and `DELETE..RETURNING`
    (10.0+) syntaxes. `INSERT..RETURNING` may be used automatically in some cases
    in order to fetch newly generated identifiers in place of the traditional approach
    of using `cursor.lastrowid`, however `cursor.lastrowid` is currently still preferred
    for simple single-statement cases for its better performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'To specify an explicit `RETURNING` clause, use the `_UpdateBase.returning()`
    method on a per-statement basis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: 'New in version 2.0: Added support for MariaDB RETURNING'
  prefs: []
  type: TYPE_NORMAL
- en: '## INSERT…ON DUPLICATE KEY UPDATE (Upsert)'
  prefs: []
  type: TYPE_NORMAL
- en: MySQL / MariaDB allow “upserts” (update or insert) of rows into a table via
    the `ON DUPLICATE KEY UPDATE` clause of the `INSERT` statement. A candidate row
    will only be inserted if that row does not match an existing primary or unique
    key in the table; otherwise, an UPDATE will be performed. The statement allows
    for separate specification of the values to INSERT versus the values for UPDATE.
  prefs: []
  type: TYPE_NORMAL
- en: 'SQLAlchemy provides `ON DUPLICATE KEY UPDATE` support via the MySQL-specific
    [`insert()`](#sqlalchemy.dialects.mysql.insert "sqlalchemy.dialects.mysql.insert")
    function, which provides the generative method [`Insert.on_duplicate_key_update()`](#sqlalchemy.dialects.mysql.Insert.on_duplicate_key_update
    "sqlalchemy.dialects.mysql.Insert.on_duplicate_key_update"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: Unlike PostgreSQL’s “ON CONFLICT” phrase, the “ON DUPLICATE KEY UPDATE” phrase
    will always match on any primary key or unique key, and will always perform an
    UPDATE if there’s a match; there are no options for it to raise an error or to
    skip performing an UPDATE.
  prefs: []
  type: TYPE_NORMAL
- en: '`ON DUPLICATE KEY UPDATE` is used to perform an update of the already existing
    row, using any combination of new values as well as values from the proposed insertion.
    These values are normally specified using keyword arguments passed to the [`Insert.on_duplicate_key_update()`](#sqlalchemy.dialects.mysql.Insert.on_duplicate_key_update
    "sqlalchemy.dialects.mysql.Insert.on_duplicate_key_update") given column key values
    (usually the name of the column, unless it specifies [`Column.key`](../core/metadata.html#sqlalchemy.schema.Column.params.key
    "sqlalchemy.schema.Column") ) as keys and literal or SQL expressions as values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: 'In a manner similar to that of `UpdateBase.values()`, other parameter forms
    are accepted, including a single dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: 'as well as a list of 2-tuples, which will automatically provide a parameter-ordered
    UPDATE statement in a manner similar to that described at [Parameter Ordered Updates](../tutorial/data_update.html#tutorial-parameter-ordered-updates).
    Unlike the [`Update`](../core/dml.html#sqlalchemy.sql.expression.Update "sqlalchemy.sql.expression.Update")
    object, no special flag is needed to specify the intent since the argument form
    is this context is unambiguous:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: 'Changed in version 1.3: support for parameter-ordered UPDATE clause within
    MySQL ON DUPLICATE KEY UPDATE'
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: The [`Insert.on_duplicate_key_update()`](#sqlalchemy.dialects.mysql.Insert.on_duplicate_key_update
    "sqlalchemy.dialects.mysql.Insert.on_duplicate_key_update") method does **not**
    take into account Python-side default UPDATE values or generation functions, e.g.
    e.g. those specified using [`Column.onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.onupdate
    "sqlalchemy.schema.Column"). These values will not be exercised for an ON DUPLICATE
    KEY style of UPDATE, unless they are manually specified explicitly in the parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to refer to the proposed insertion row, the special alias [`Insert.inserted`](#sqlalchemy.dialects.mysql.Insert.inserted
    "sqlalchemy.dialects.mysql.Insert.inserted") is available as an attribute on the
    [`Insert`](#sqlalchemy.dialects.mysql.Insert "sqlalchemy.dialects.mysql.Insert")
    object; this object is a [`ColumnCollection`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnCollection
    "sqlalchemy.sql.expression.ColumnCollection") which contains all columns of the
    target table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: When rendered, the “inserted” namespace will produce the expression `VALUES(<columnname>)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 1.2: Added support for MySQL ON DUPLICATE KEY UPDATE clause'
  prefs: []
  type: TYPE_NORMAL
- en: rowcount Support
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SQLAlchemy standardizes the DBAPI `cursor.rowcount` attribute to be the usual
    definition of “number of rows matched by an UPDATE or DELETE” statement. This
    is in contradiction to the default setting on most MySQL DBAPI drivers, which
    is “number of rows actually modified/deleted”. For this reason, the SQLAlchemy
    MySQL dialects always add the `constants.CLIENT.FOUND_ROWS` flag, or whatever
    is equivalent for the target dialect, upon connection. This setting is currently
    hardcoded.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`CursorResult.rowcount`](../core/connections.html#sqlalchemy.engine.CursorResult.rowcount
    "sqlalchemy.engine.CursorResult.rowcount")'
  prefs: []
  type: TYPE_NORMAL
- en: '## MySQL / MariaDB- Specific Index Options'
  prefs: []
  type: TYPE_NORMAL
- en: MySQL and MariaDB-specific extensions to the [`Index`](../core/constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index") construct are available.
  prefs: []
  type: TYPE_NORMAL
- en: Index Length
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'MySQL and MariaDB both provide an option to create index entries with a certain
    length, where “length” refers to the number of characters or bytes in each value
    which will become part of the index. SQLAlchemy provides this feature via the
    `mysql_length` and/or `mariadb_length` parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: Prefix lengths are given in characters for nonbinary string types and in bytes
    for binary string types. The value passed to the keyword argument *must* be either
    an integer (and, thus, specify the same prefix length value for all columns of
    the index) or a dict in which keys are column names and values are prefix length
    values for corresponding columns. MySQL and MariaDB only allow a length for a
    column of an index if it is for a CHAR, VARCHAR, TEXT, BINARY, VARBINARY and BLOB.
  prefs: []
  type: TYPE_NORMAL
- en: Index Prefixes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'MySQL storage engines permit you to specify an index prefix when creating an
    index. SQLAlchemy provides this feature via the `mysql_prefix` parameter on [`Index`](../core/constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: The value passed to the keyword argument will be simply passed through to the
    underlying CREATE INDEX, so it *must* be a valid index prefix for your MySQL storage
    engine.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[CREATE INDEX](https://dev.mysql.com/doc/refman/5.0/en/create-index.html) -
    MySQL documentation'
  prefs: []
  type: TYPE_NORMAL
- en: Index Types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Some MySQL storage engines permit you to specify an index type when creating
    an index or primary key constraint. SQLAlchemy provides this feature via the `mysql_using`
    parameter on [`Index`](../core/constraints.html#sqlalchemy.schema.Index "sqlalchemy.schema.Index"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: 'As well as the `mysql_using` parameter on [`PrimaryKeyConstraint`](../core/constraints.html#sqlalchemy.schema.PrimaryKeyConstraint
    "sqlalchemy.schema.PrimaryKeyConstraint"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: The value passed to the keyword argument will be simply passed through to the
    underlying CREATE INDEX or PRIMARY KEY clause, so it *must* be a valid index type
    for your MySQL storage engine.
  prefs: []
  type: TYPE_NORMAL
- en: 'More information can be found at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://dev.mysql.com/doc/refman/5.0/en/create-index.html](https://dev.mysql.com/doc/refman/5.0/en/create-index.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://dev.mysql.com/doc/refman/5.0/en/create-table.html](https://dev.mysql.com/doc/refman/5.0/en/create-table.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Index Parsers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'CREATE FULLTEXT INDEX in MySQL also supports a “WITH PARSER” option. This is
    available using the keyword argument `mysql_with_parser`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: New in version 1.3.
  prefs: []
  type: TYPE_NORMAL
- en: Index Length
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'MySQL and MariaDB both provide an option to create index entries with a certain
    length, where “length” refers to the number of characters or bytes in each value
    which will become part of the index. SQLAlchemy provides this feature via the
    `mysql_length` and/or `mariadb_length` parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: Prefix lengths are given in characters for nonbinary string types and in bytes
    for binary string types. The value passed to the keyword argument *must* be either
    an integer (and, thus, specify the same prefix length value for all columns of
    the index) or a dict in which keys are column names and values are prefix length
    values for corresponding columns. MySQL and MariaDB only allow a length for a
    column of an index if it is for a CHAR, VARCHAR, TEXT, BINARY, VARBINARY and BLOB.
  prefs: []
  type: TYPE_NORMAL
- en: Index Prefixes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'MySQL storage engines permit you to specify an index prefix when creating an
    index. SQLAlchemy provides this feature via the `mysql_prefix` parameter on [`Index`](../core/constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: The value passed to the keyword argument will be simply passed through to the
    underlying CREATE INDEX, so it *must* be a valid index prefix for your MySQL storage
    engine.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[CREATE INDEX](https://dev.mysql.com/doc/refman/5.0/en/create-index.html) -
    MySQL documentation'
  prefs: []
  type: TYPE_NORMAL
- en: Index Types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Some MySQL storage engines permit you to specify an index type when creating
    an index or primary key constraint. SQLAlchemy provides this feature via the `mysql_using`
    parameter on [`Index`](../core/constraints.html#sqlalchemy.schema.Index "sqlalchemy.schema.Index"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: 'As well as the `mysql_using` parameter on [`PrimaryKeyConstraint`](../core/constraints.html#sqlalchemy.schema.PrimaryKeyConstraint
    "sqlalchemy.schema.PrimaryKeyConstraint"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: The value passed to the keyword argument will be simply passed through to the
    underlying CREATE INDEX or PRIMARY KEY clause, so it *must* be a valid index type
    for your MySQL storage engine.
  prefs: []
  type: TYPE_NORMAL
- en: 'More information can be found at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://dev.mysql.com/doc/refman/5.0/en/create-index.html](https://dev.mysql.com/doc/refman/5.0/en/create-index.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://dev.mysql.com/doc/refman/5.0/en/create-table.html](https://dev.mysql.com/doc/refman/5.0/en/create-table.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Index Parsers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'CREATE FULLTEXT INDEX in MySQL also supports a “WITH PARSER” option. This is
    available using the keyword argument `mysql_with_parser`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: New in version 1.3.
  prefs: []
  type: TYPE_NORMAL
- en: '## MySQL / MariaDB Foreign Keys'
  prefs: []
  type: TYPE_NORMAL
- en: MySQL and MariaDB’s behavior regarding foreign keys has some important caveats.
  prefs: []
  type: TYPE_NORMAL
- en: Foreign Key Arguments to Avoid
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Neither MySQL nor MariaDB support the foreign key arguments “DEFERRABLE”, “INITIALLY”,
    or “MATCH”. Using the `deferrable` or `initially` keyword argument with [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") or [`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey") will have the effect of these keywords being rendered
    in a DDL expression, which will then raise an error on MySQL or MariaDB. In order
    to use these keywords on a foreign key while having them ignored on a MySQL /
    MariaDB backend, use a custom compile rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: The “MATCH” keyword is in fact more insidious, and is explicitly disallowed
    by SQLAlchemy in conjunction with the MySQL or MariaDB backends. This argument
    is silently ignored by MySQL / MariaDB, but in addition has the effect of ON UPDATE
    and ON DELETE options also being ignored by the backend. Therefore MATCH should
    never be used with the MySQL / MariaDB backends; as is the case with DEFERRABLE
    and INITIALLY, custom compilation rules can be used to correct a ForeignKeyConstraint
    at DDL definition time.
  prefs: []
  type: TYPE_NORMAL
- en: Reflection of Foreign Key Constraints
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Not all MySQL / MariaDB storage engines support foreign keys. When using the
    very common `MyISAM` MySQL storage engine, the information loaded by table reflection
    will not include foreign keys. For these tables, you may supply a `ForeignKeyConstraint`
    at reflection time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[CREATE TABLE arguments including Storage Engines](#mysql-storage-engines)'
  prefs: []
  type: TYPE_NORMAL
- en: Foreign Key Arguments to Avoid
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Neither MySQL nor MariaDB support the foreign key arguments “DEFERRABLE”, “INITIALLY”,
    or “MATCH”. Using the `deferrable` or `initially` keyword argument with [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") or [`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey") will have the effect of these keywords being rendered
    in a DDL expression, which will then raise an error on MySQL or MariaDB. In order
    to use these keywords on a foreign key while having them ignored on a MySQL /
    MariaDB backend, use a custom compile rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: The “MATCH” keyword is in fact more insidious, and is explicitly disallowed
    by SQLAlchemy in conjunction with the MySQL or MariaDB backends. This argument
    is silently ignored by MySQL / MariaDB, but in addition has the effect of ON UPDATE
    and ON DELETE options also being ignored by the backend. Therefore MATCH should
    never be used with the MySQL / MariaDB backends; as is the case with DEFERRABLE
    and INITIALLY, custom compilation rules can be used to correct a ForeignKeyConstraint
    at DDL definition time.
  prefs: []
  type: TYPE_NORMAL
- en: Reflection of Foreign Key Constraints
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Not all MySQL / MariaDB storage engines support foreign keys. When using the
    very common `MyISAM` MySQL storage engine, the information loaded by table reflection
    will not include foreign keys. For these tables, you may supply a `ForeignKeyConstraint`
    at reflection time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[CREATE TABLE arguments including Storage Engines](#mysql-storage-engines)'
  prefs: []
  type: TYPE_NORMAL
- en: '## MySQL / MariaDB Unique Constraints and Reflection'
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy supports both the [`Index`](../core/constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index") construct with the flag `unique=True`, indicating a
    UNIQUE index, as well as the [`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint") construct, representing a UNIQUE constraint.
    Both objects/syntaxes are supported by MySQL / MariaDB when emitting DDL to create
    these constraints. However, MySQL / MariaDB does not have a unique constraint
    construct that is separate from a unique index; that is, the “UNIQUE” constraint
    on MySQL / MariaDB is equivalent to creating a “UNIQUE INDEX”.
  prefs: []
  type: TYPE_NORMAL
- en: When reflecting these constructs, the [`Inspector.get_indexes()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_indexes
    "sqlalchemy.engine.reflection.Inspector.get_indexes") and the [`Inspector.get_unique_constraints()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_unique_constraints
    "sqlalchemy.engine.reflection.Inspector.get_unique_constraints") methods will
    **both** return an entry for a UNIQUE index in MySQL / MariaDB. However, when
    performing full table reflection using `Table(..., autoload_with=engine)`, the
    [`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint") construct is **not** part of the fully reflected
    [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    construct under any circumstances; this construct is always represented by a [`Index`](../core/constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index") with the `unique=True` setting present in the [`Table.indexes`](../core/metadata.html#sqlalchemy.schema.Table.indexes
    "sqlalchemy.schema.Table.indexes") collection.
  prefs: []
  type: TYPE_NORMAL
- en: TIMESTAMP / DATETIME issues
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '### Rendering ON UPDATE CURRENT TIMESTAMP for MySQL / MariaDB’s explicit_defaults_for_timestamp'
  prefs: []
  type: TYPE_NORMAL
- en: MySQL / MariaDB have historically expanded the DDL for the [`TIMESTAMP`](../core/type_basics.html#sqlalchemy.types.TIMESTAMP
    "sqlalchemy.types.TIMESTAMP") datatype into the phrase “TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    ON UPDATE CURRENT_TIMESTAMP”, which includes non-standard SQL that automatically
    updates the column with the current timestamp when an UPDATE occurs, eliminating
    the usual need to use a trigger in such a case where server-side update changes
    are desired.
  prefs: []
  type: TYPE_NORMAL
- en: MySQL 5.6 introduced a new flag [explicit_defaults_for_timestamp](https://dev.mysql.com/doc/refman/5.6/en/server-system-variables.html#sysvar_explicit_defaults_for_timestamp)
    which disables the above behavior, and in MySQL 8 this flag defaults to true,
    meaning in order to get a MySQL “on update timestamp” without changing this flag,
    the above DDL must be rendered explicitly. Additionally, the same DDL is valid
    for use of the `DATETIME` datatype as well.
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy’s MySQL dialect does not yet have an option to generate MySQL’s “ON
    UPDATE CURRENT_TIMESTAMP” clause, noting that this is not a general purpose “ON
    UPDATE” as there is no such syntax in standard SQL. SQLAlchemy’s [`Column.server_onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.server_onupdate
    "sqlalchemy.schema.Column") parameter is currently not related to this special
    MySQL behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'To generate this DDL, make use of the [`Column.server_default`](../core/metadata.html#sqlalchemy.schema.Column.params.server_default
    "sqlalchemy.schema.Column") parameter and pass a textual clause that also includes
    the ON UPDATE clause:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: 'The same instructions apply to use of the [`DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime
    "sqlalchemy.types.DateTime") and [`DATETIME`](../core/type_basics.html#sqlalchemy.types.DATETIME
    "sqlalchemy.types.DATETIME") datatypes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: 'Even though the [`Column.server_onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.server_onupdate
    "sqlalchemy.schema.Column") feature does not generate this DDL, it still may be
    desirable to signal to the ORM that this updated value should be fetched. This
    syntax looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]  ### TIMESTAMP Columns and NULL'
  prefs: []
  type: TYPE_NORMAL
- en: 'MySQL historically enforces that a column which specifies the TIMESTAMP datatype
    implicitly includes a default value of CURRENT_TIMESTAMP, even though this is
    not stated, and additionally sets the column as NOT NULL, the opposite behavior
    vs. that of all other datatypes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: Above, we see that an INTEGER column defaults to NULL, unless it is specified
    with NOT NULL. But when the column is of type TIMESTAMP, an implicit default of
    CURRENT_TIMESTAMP is generated which also coerces the column to be a NOT NULL,
    even though we did not specify it as such.
  prefs: []
  type: TYPE_NORMAL
- en: This behavior of MySQL can be changed on the MySQL side using the [explicit_defaults_for_timestamp](https://dev.mysql.com/doc/refman/5.6/en/server-system-variables.html#sysvar_explicit_defaults_for_timestamp)
    configuration flag introduced in MySQL 5.6\. With this server setting enabled,
    TIMESTAMP columns behave like any other datatype on the MySQL side with regards
    to defaults and nullability.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, to accommodate the vast majority of MySQL databases that do not specify
    this new flag, SQLAlchemy emits the “NULL” specifier explicitly with any TIMESTAMP
    column that does not specify `nullable=False`. In order to accommodate newer databases
    that specify `explicit_defaults_for_timestamp`, SQLAlchemy also emits NOT NULL
    for TIMESTAMP columns that do specify `nullable=False`. The following example
    illustrates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: 'output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]  ### Rendering ON UPDATE CURRENT TIMESTAMP for MySQL / MariaDB’s explicit_defaults_for_timestamp'
  prefs: []
  type: TYPE_NORMAL
- en: MySQL / MariaDB have historically expanded the DDL for the [`TIMESTAMP`](../core/type_basics.html#sqlalchemy.types.TIMESTAMP
    "sqlalchemy.types.TIMESTAMP") datatype into the phrase “TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    ON UPDATE CURRENT_TIMESTAMP”, which includes non-standard SQL that automatically
    updates the column with the current timestamp when an UPDATE occurs, eliminating
    the usual need to use a trigger in such a case where server-side update changes
    are desired.
  prefs: []
  type: TYPE_NORMAL
- en: MySQL 5.6 introduced a new flag [explicit_defaults_for_timestamp](https://dev.mysql.com/doc/refman/5.6/en/server-system-variables.html#sysvar_explicit_defaults_for_timestamp)
    which disables the above behavior, and in MySQL 8 this flag defaults to true,
    meaning in order to get a MySQL “on update timestamp” without changing this flag,
    the above DDL must be rendered explicitly. Additionally, the same DDL is valid
    for use of the `DATETIME` datatype as well.
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy’s MySQL dialect does not yet have an option to generate MySQL’s “ON
    UPDATE CURRENT_TIMESTAMP” clause, noting that this is not a general purpose “ON
    UPDATE” as there is no such syntax in standard SQL. SQLAlchemy’s [`Column.server_onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.server_onupdate
    "sqlalchemy.schema.Column") parameter is currently not related to this special
    MySQL behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'To generate this DDL, make use of the [`Column.server_default`](../core/metadata.html#sqlalchemy.schema.Column.params.server_default
    "sqlalchemy.schema.Column") parameter and pass a textual clause that also includes
    the ON UPDATE clause:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: 'The same instructions apply to use of the [`DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime
    "sqlalchemy.types.DateTime") and [`DATETIME`](../core/type_basics.html#sqlalchemy.types.DATETIME
    "sqlalchemy.types.DATETIME") datatypes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: 'Even though the [`Column.server_onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.server_onupdate
    "sqlalchemy.schema.Column") feature does not generate this DDL, it still may be
    desirable to signal to the ORM that this updated value should be fetched. This
    syntax looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: '### TIMESTAMP Columns and NULL'
  prefs: []
  type: TYPE_NORMAL
- en: 'MySQL historically enforces that a column which specifies the TIMESTAMP datatype
    implicitly includes a default value of CURRENT_TIMESTAMP, even though this is
    not stated, and additionally sets the column as NOT NULL, the opposite behavior
    vs. that of all other datatypes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: Above, we see that an INTEGER column defaults to NULL, unless it is specified
    with NOT NULL. But when the column is of type TIMESTAMP, an implicit default of
    CURRENT_TIMESTAMP is generated which also coerces the column to be a NOT NULL,
    even though we did not specify it as such.
  prefs: []
  type: TYPE_NORMAL
- en: This behavior of MySQL can be changed on the MySQL side using the [explicit_defaults_for_timestamp](https://dev.mysql.com/doc/refman/5.6/en/server-system-variables.html#sysvar_explicit_defaults_for_timestamp)
    configuration flag introduced in MySQL 5.6\. With this server setting enabled,
    TIMESTAMP columns behave like any other datatype on the MySQL side with regards
    to defaults and nullability.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, to accommodate the vast majority of MySQL databases that do not specify
    this new flag, SQLAlchemy emits the “NULL” specifier explicitly with any TIMESTAMP
    column that does not specify `nullable=False`. In order to accommodate newer databases
    that specify `explicit_defaults_for_timestamp`, SQLAlchemy also emits NOT NULL
    for TIMESTAMP columns that do specify `nullable=False`. The following example
    illustrates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: 'output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: MySQL SQL Constructs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '| Object Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| [match](#sqlalchemy.dialects.mysql.match) | Produce a `MATCH (X, Y) AGAINST
    (''TEXT'')` clause. |'
  prefs: []
  type: TYPE_TB
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: Produce a `MATCH (X, Y) AGAINST ('TEXT')` clause.
  prefs: []
  type: TYPE_NORMAL
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: 'Would produce SQL resembling:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: The [`match()`](#sqlalchemy.dialects.mysql.match "sqlalchemy.dialects.mysql.match")
    function is a standalone version of the [`ColumnElement.match()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnElement.match
    "sqlalchemy.sql.expression.ColumnElement.match") method available on all SQL expressions,
    as when [`ColumnElement.match()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnElement.match
    "sqlalchemy.sql.expression.ColumnElement.match") is used, but allows to pass multiple
    columns
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`cols` – column expressions to match against'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`against` – expression to be compared towards'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`in_boolean_mode` – boolean, set “boolean mode” to true'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`in_natural_language_mode` – boolean , set “natural language” to true'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`with_query_expansion` – boolean, set “query expansion” to true'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New in version 1.4.19.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnElement.match()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnElement.match
    "sqlalchemy.sql.expression.ColumnElement.match")'
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[in_boolean_mode()](#sqlalchemy.dialects.mysql.match.in_boolean_mode), [in_natural_language_mode()](#sqlalchemy.dialects.mysql.match.in_natural_language_mode),
    [inherit_cache](#sqlalchemy.dialects.mysql.match.inherit_cache), [with_query_expansion()](#sqlalchemy.dialects.mysql.match.with_query_expansion)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.mysql.match`](#sqlalchemy.dialects.mysql.match "sqlalchemy.dialects.mysql.match")
    (`sqlalchemy.sql.expression.Generative`, [`sqlalchemy.sql.expression.BinaryExpression`](../core/sqlelement.html#sqlalchemy.sql.expression.BinaryExpression
    "sqlalchemy.sql.expression.BinaryExpression"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: Apply the “IN BOOLEAN MODE” modifier to the MATCH expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: a new [`match`](#sqlalchemy.dialects.mysql.match "sqlalchemy.dialects.mysql.match")
    instance with modifications applied.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: Apply the “IN NATURAL LANGUAGE MODE” modifier to the MATCH expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: a new [`match`](#sqlalchemy.dialects.mysql.match "sqlalchemy.dialects.mysql.match")
    instance with modifications applied.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: Indicate if this [`HasCacheKey`](../core/foundation.html#sqlalchemy.sql.traversals.HasCacheKey
    "sqlalchemy.sql.traversals.HasCacheKey") instance should make use of the cache
    key generation scheme used by its immediate superclass.
  prefs: []
  type: TYPE_NORMAL
- en: The attribute defaults to `None`, which indicates that a construct has not yet
    taken into account whether or not its appropriate for it to participate in caching;
    this is functionally equivalent to setting the value to `False`, except that a
    warning is also emitted.
  prefs: []
  type: TYPE_NORMAL
- en: This flag can be set to `True` on a particular class, if the SQL that corresponds
    to the object does not change based on attributes which are local to this class,
    and not its superclass.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Enabling Caching Support for Custom Constructs](../core/compiler.html#compilerext-caching)
    - General guideslines for setting the [`HasCacheKey.inherit_cache`](../core/foundation.html#sqlalchemy.sql.traversals.HasCacheKey.inherit_cache
    "sqlalchemy.sql.traversals.HasCacheKey.inherit_cache") attribute for third-party
    or user defined SQL constructs.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: Apply the “WITH QUERY EXPANSION” modifier to the MATCH expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: a new [`match`](#sqlalchemy.dialects.mysql.match "sqlalchemy.dialects.mysql.match")
    instance with modifications applied.
  prefs: []
  type: TYPE_NORMAL
- en: MySQL Data Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As with all SQLAlchemy dialects, all UPPERCASE types that are known to be valid
    with MySQL are importable from the top level dialect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: 'Types which are specific to MySQL, or have MySQL-specific construction arguments,
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Object Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| [BIGINT](#sqlalchemy.dialects.mysql.BIGINT) | MySQL BIGINTEGER type. |'
  prefs: []
  type: TYPE_TB
- en: '| [BIT](#sqlalchemy.dialects.mysql.BIT) | MySQL BIT type. |'
  prefs: []
  type: TYPE_TB
- en: '| [CHAR](#sqlalchemy.dialects.mysql.CHAR) | MySQL CHAR type, for fixed-length
    character data. |'
  prefs: []
  type: TYPE_TB
- en: '| [DATETIME](#sqlalchemy.dialects.mysql.DATETIME) | MySQL DATETIME type. |'
  prefs: []
  type: TYPE_TB
- en: '| [DECIMAL](#sqlalchemy.dialects.mysql.DECIMAL) | MySQL DECIMAL type. |'
  prefs: []
  type: TYPE_TB
- en: '| [ENUM](#sqlalchemy.dialects.mysql.ENUM) | MySQL ENUM type. |'
  prefs: []
  type: TYPE_TB
- en: '| [FLOAT](#sqlalchemy.dialects.mysql.FLOAT) | MySQL FLOAT type. |'
  prefs: []
  type: TYPE_TB
- en: '| [INTEGER](#sqlalchemy.dialects.mysql.INTEGER) | MySQL INTEGER type. |'
  prefs: []
  type: TYPE_TB
- en: '| [JSON](#sqlalchemy.dialects.mysql.JSON) | MySQL JSON type. |'
  prefs: []
  type: TYPE_TB
- en: '| [LONGBLOB](#sqlalchemy.dialects.mysql.LONGBLOB) | MySQL LONGBLOB type, for
    binary data up to 2^32 bytes. |'
  prefs: []
  type: TYPE_TB
- en: '| [LONGTEXT](#sqlalchemy.dialects.mysql.LONGTEXT) | MySQL LONGTEXT type, for
    character storage encoded up to 2^32 bytes. |'
  prefs: []
  type: TYPE_TB
- en: '| [MEDIUMBLOB](#sqlalchemy.dialects.mysql.MEDIUMBLOB) | MySQL MEDIUMBLOB type,
    for binary data up to 2^24 bytes. |'
  prefs: []
  type: TYPE_TB
- en: '| [MEDIUMINT](#sqlalchemy.dialects.mysql.MEDIUMINT) | MySQL MEDIUMINTEGER type.
    |'
  prefs: []
  type: TYPE_TB
- en: '| [MEDIUMTEXT](#sqlalchemy.dialects.mysql.MEDIUMTEXT) | MySQL MEDIUMTEXT type,
    for character storage encoded up to 2^24 bytes. |'
  prefs: []
  type: TYPE_TB
- en: '| [NCHAR](#sqlalchemy.dialects.mysql.NCHAR) | MySQL NCHAR type. |'
  prefs: []
  type: TYPE_TB
- en: '| [NUMERIC](#sqlalchemy.dialects.mysql.NUMERIC) | MySQL NUMERIC type. |'
  prefs: []
  type: TYPE_TB
- en: '| [NVARCHAR](#sqlalchemy.dialects.mysql.NVARCHAR) | MySQL NVARCHAR type. |'
  prefs: []
  type: TYPE_TB
- en: '| [REAL](#sqlalchemy.dialects.mysql.REAL) | MySQL REAL type. |'
  prefs: []
  type: TYPE_TB
- en: '| [SET](#sqlalchemy.dialects.mysql.SET) | MySQL SET type. |'
  prefs: []
  type: TYPE_TB
- en: '| [SMALLINT](#sqlalchemy.dialects.mysql.SMALLINT) | MySQL SMALLINTEGER type.
    |'
  prefs: []
  type: TYPE_TB
- en: '| [TIME](#sqlalchemy.dialects.mysql.TIME) | MySQL TIME type. |'
  prefs: []
  type: TYPE_TB
- en: '| [TIMESTAMP](#sqlalchemy.dialects.mysql.TIMESTAMP) | MySQL TIMESTAMP type.
    |'
  prefs: []
  type: TYPE_TB
- en: '| [TINYBLOB](#sqlalchemy.dialects.mysql.TINYBLOB) | MySQL TINYBLOB type, for
    binary data up to 2^8 bytes. |'
  prefs: []
  type: TYPE_TB
- en: '| [TINYINT](#sqlalchemy.dialects.mysql.TINYINT) | MySQL TINYINT type. |'
  prefs: []
  type: TYPE_TB
- en: '| [TINYTEXT](#sqlalchemy.dialects.mysql.TINYTEXT) | MySQL TINYTEXT type, for
    character storage encoded up to 2^8 bytes. |'
  prefs: []
  type: TYPE_TB
- en: '| [VARCHAR](#sqlalchemy.dialects.mysql.VARCHAR) | MySQL VARCHAR type, for variable-length
    character data. |'
  prefs: []
  type: TYPE_TB
- en: '| [YEAR](#sqlalchemy.dialects.mysql.YEAR) | MySQL YEAR type, for single byte
    storage of years 1901-2155. |'
  prefs: []
  type: TYPE_TB
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: MySQL BIGINTEGER type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.dialects.mysql.BIGINT.__init__)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.mysql.BIGINT`](#sqlalchemy.dialects.mysql.BIGINT
    "sqlalchemy.dialects.mysql.BIGINT") (`sqlalchemy.dialects.mysql.types._IntegerType`,
    [`sqlalchemy.types.BIGINT`](../core/type_basics.html#sqlalchemy.types.BIGINT "sqlalchemy.types.BIGINT"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: Construct a BIGINTEGER.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`display_width` – Optional, maximum display width for this number.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unsigned` – a boolean, optional.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`zerofill` – Optional. If true, values will be stored as strings left-padded
    with zeros. Note that this does not effect the values returned by the underlying
    database API, which continue to be numeric.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: The SQL BINARY type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class `sqlalchemy.dialects.mysql.BINARY` (`sqlalchemy.types._Binary`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: MySQL BIT type.
  prefs: []
  type: TYPE_NORMAL
- en: This type is for MySQL 5.0.3 or greater for MyISAM, and 5.0.5 or greater for
    MyISAM, MEMORY, InnoDB and BDB. For older versions, use a MSTinyInteger() type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.dialects.mysql.BIT.__init__)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.mysql.BIT`](#sqlalchemy.dialects.mysql.BIT "sqlalchemy.dialects.mysql.BIT")
    ([`sqlalchemy.types.TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: Construct a BIT.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**length** – Optional, number of bits.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: The SQL BLOB type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class `sqlalchemy.dialects.mysql.BLOB` ([`sqlalchemy.types.LargeBinary`](../core/type_basics.html#sqlalchemy.types.LargeBinary
    "sqlalchemy.types.LargeBinary"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `sqlalchemy.types.LargeBinary.__init__` *method of* [`LargeBinary`](../core/type_basics.html#sqlalchemy.types.LargeBinary
    "sqlalchemy.types.LargeBinary")'
  prefs: []
  type: TYPE_NORMAL
- en: Construct a LargeBinary type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**length** – optional, a length for the column for use in DDL statements, for
    those binary types that accept a length, such as the MySQL BLOB type.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: The SQL BOOLEAN type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class `sqlalchemy.dialects.mysql.BOOLEAN` ([`sqlalchemy.types.Boolean`](../core/type_basics.html#sqlalchemy.types.Boolean
    "sqlalchemy.types.Boolean"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `sqlalchemy.types.Boolean.__init__` *method of* [`Boolean`](../core/type_basics.html#sqlalchemy.types.Boolean
    "sqlalchemy.types.Boolean")'
  prefs: []
  type: TYPE_NORMAL
- en: Construct a Boolean.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`create_constraint` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: defaults to False. If the boolean is generated as an int/smallint, also create
    a CHECK constraint on the table that ensures 1 or 0 as a value.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: it is strongly recommended that the CHECK constraint have an explicit name in
    order to support schema-management concerns. This can be established either by
    setting the [`Boolean.name`](../core/type_basics.html#sqlalchemy.types.Boolean.params.name
    "sqlalchemy.types.Boolean") parameter or by setting up an appropriate naming convention;
    see [Configuring Constraint Naming Conventions](../core/constraints.html#constraint-naming-conventions)
    for background.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Changed in version 1.4: - this flag now defaults to False, meaning no CHECK
    constraint is generated for a non-native enumerated type.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`name` – if a CHECK constraint is generated, specify the name of the constraint.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: MySQL CHAR type, for fixed-length character data.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.dialects.mysql.CHAR.__init__)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.mysql.CHAR`](#sqlalchemy.dialects.mysql.CHAR "sqlalchemy.dialects.mysql.CHAR")
    (`sqlalchemy.dialects.mysql.types._StringType`, [`sqlalchemy.types.CHAR`](../core/type_basics.html#sqlalchemy.types.CHAR
    "sqlalchemy.types.CHAR"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: Construct a CHAR.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`length` – Maximum data length, in characters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`binary` – Optional, use the default binary collation for the national character
    set. This does not affect the type of data stored, use a BINARY type for binary
    data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`collation` – Optional, request a particular collation. Must be compatible
    with the national character set.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: The SQL DATE type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class `sqlalchemy.dialects.mysql.DATE` ([`sqlalchemy.types.Date`](../core/type_basics.html#sqlalchemy.types.Date
    "sqlalchemy.types.Date"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: MySQL DATETIME type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.dialects.mysql.DATETIME.__init__)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.mysql.DATETIME`](#sqlalchemy.dialects.mysql.DATETIME
    "sqlalchemy.dialects.mysql.DATETIME") ([`sqlalchemy.types.DATETIME`](../core/type_basics.html#sqlalchemy.types.DATETIME
    "sqlalchemy.types.DATETIME"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: Construct a MySQL DATETIME type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`timezone` – not used by the MySQL dialect.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fsp` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: fractional seconds precision value. MySQL 5.6.4 supports storage of fractional
    seconds; this parameter will be used when emitting DDL for the DATETIME type.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: DBAPI driver support for fractional seconds may be limited; current support
    includes MySQL Connector/Python.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: MySQL DECIMAL type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.dialects.mysql.DECIMAL.__init__)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.mysql.DECIMAL`](#sqlalchemy.dialects.mysql.DECIMAL
    "sqlalchemy.dialects.mysql.DECIMAL") (`sqlalchemy.dialects.mysql.types._NumericType`,
    [`sqlalchemy.types.DECIMAL`](../core/type_basics.html#sqlalchemy.types.DECIMAL
    "sqlalchemy.types.DECIMAL"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: Construct a DECIMAL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`precision` – Total digits in this number. If scale and precision are both
    None, values are stored to limits allowed by the server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scale` – The number of digits after the decimal point.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unsigned` – a boolean, optional.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`zerofill` – Optional. If true, values will be stored as strings left-padded
    with zeros. Note that this does not effect the values returned by the underlying
    database API, which continue to be numeric.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: MySQL DOUBLE type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class `sqlalchemy.dialects.mysql.DOUBLE` (`sqlalchemy.dialects.mysql.types._FloatType`,
    [`sqlalchemy.types.DOUBLE`](../core/type_basics.html#sqlalchemy.types.DOUBLE "sqlalchemy.types.DOUBLE"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: Construct a DOUBLE.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The [`DOUBLE`](../core/type_basics.html#sqlalchemy.types.DOUBLE "sqlalchemy.types.DOUBLE")
    type by default converts from float to Decimal, using a truncation that defaults
    to 10 digits. Specify either `scale=n` or `decimal_return_scale=n` in order to
    change this scale, or `asdecimal=False` to return values directly as Python floating
    points.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`precision` – Total digits in this number. If scale and precision are both
    None, values are stored to limits allowed by the server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scale` – The number of digits after the decimal point.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unsigned` – a boolean, optional.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`zerofill` – Optional. If true, values will be stored as strings left-padded
    with zeros. Note that this does not effect the values returned by the underlying
    database API, which continue to be numeric.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: MySQL ENUM type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.dialects.mysql.ENUM.__init__)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.mysql.ENUM`](#sqlalchemy.dialects.mysql.ENUM "sqlalchemy.dialects.mysql.ENUM")
    (`sqlalchemy.types.NativeForEmulated`, [`sqlalchemy.types.Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum"), `sqlalchemy.dialects.mysql.types._StringType`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: Construct an ENUM.
  prefs: []
  type: TYPE_NORMAL
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE225]'
  prefs: []
  type: TYPE_PRE
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`enums` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The range of valid values for this ENUM. Values in enums are not quoted, they
    will be escaped and surrounded by single quotes when generating the schema. This
    object may also be a PEP-435-compliant enumerated type.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`strict` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This flag has no effect.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Changed in version The: MySQL ENUM type as well as the base Enum type now validates
    all Python data values.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`charset` – Optional, a column-level character set for this string value. Takes
    precedence to ‘ascii’ or ‘unicode’ short-hand.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`collation` – Optional, a column-level collation for this string value. Takes
    precedence to ‘binary’ short-hand.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ascii` – Defaults to False: short-hand for the `latin1` character set, generates
    ASCII in schema.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unicode` – Defaults to False: short-hand for the `ucs2` character set, generates
    UNICODE in schema.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`binary` – Defaults to False: short-hand, pick the binary collation type that
    matches the column’s character set. Generates BINARY in schema. This does not
    affect the type of data stored, only the collation of character data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: MySQL FLOAT type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.dialects.mysql.FLOAT.__init__)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.mysql.FLOAT`](#sqlalchemy.dialects.mysql.FLOAT "sqlalchemy.dialects.mysql.FLOAT")
    (`sqlalchemy.dialects.mysql.types._FloatType`, [`sqlalchemy.types.FLOAT`](../core/type_basics.html#sqlalchemy.types.FLOAT
    "sqlalchemy.types.FLOAT"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE227]'
  prefs: []
  type: TYPE_PRE
- en: Construct a FLOAT.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`precision` – Total digits in this number. If scale and precision are both
    None, values are stored to limits allowed by the server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scale` – The number of digits after the decimal point.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unsigned` – a boolean, optional.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`zerofill` – Optional. If true, values will be stored as strings left-padded
    with zeros. Note that this does not effect the values returned by the underlying
    database API, which continue to be numeric.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE228]'
  prefs: []
  type: TYPE_PRE
- en: MySQL INTEGER type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.dialects.mysql.INTEGER.__init__)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.mysql.INTEGER`](#sqlalchemy.dialects.mysql.INTEGER
    "sqlalchemy.dialects.mysql.INTEGER") (`sqlalchemy.dialects.mysql.types._IntegerType`,
    [`sqlalchemy.types.INTEGER`](../core/type_basics.html#sqlalchemy.types.INTEGER
    "sqlalchemy.types.INTEGER"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE229]'
  prefs: []
  type: TYPE_PRE
- en: Construct an INTEGER.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`display_width` – Optional, maximum display width for this number.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unsigned` – a boolean, optional.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`zerofill` – Optional. If true, values will be stored as strings left-padded
    with zeros. Note that this does not effect the values returned by the underlying
    database API, which continue to be numeric.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE230]'
  prefs: []
  type: TYPE_PRE
- en: MySQL JSON type.
  prefs: []
  type: TYPE_NORMAL
- en: MySQL supports JSON as of version 5.7. MariaDB supports JSON (as an alias for
    LONGTEXT) as of version 10.2.
  prefs: []
  type: TYPE_NORMAL
- en: '[`JSON`](#sqlalchemy.dialects.mysql.JSON "sqlalchemy.dialects.mysql.JSON")
    is used automatically whenever the base [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON") datatype is used against a MySQL or MariaDB backend.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON")
    - main documentation for the generic cross-platform JSON datatype.'
  prefs: []
  type: TYPE_NORMAL
- en: The [`JSON`](#sqlalchemy.dialects.mysql.JSON "sqlalchemy.dialects.mysql.JSON")
    type supports persistence of JSON values as well as the core index operations
    provided by [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON")
    datatype, by adapting the operations to render the `JSON_EXTRACT` function at
    the database level.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.mysql.JSON`](#sqlalchemy.dialects.mysql.JSON "sqlalchemy.dialects.mysql.JSON")
    ([`sqlalchemy.types.JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE231]'
  prefs: []
  type: TYPE_PRE
- en: MySQL LONGBLOB type, for binary data up to 2^32 bytes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.mysql.LONGBLOB`](#sqlalchemy.dialects.mysql.LONGBLOB
    "sqlalchemy.dialects.mysql.LONGBLOB") (`sqlalchemy.types._Binary`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE232]'
  prefs: []
  type: TYPE_PRE
- en: MySQL LONGTEXT type, for character storage encoded up to 2^32 bytes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.dialects.mysql.LONGTEXT.__init__)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.mysql.LONGTEXT`](#sqlalchemy.dialects.mysql.LONGTEXT
    "sqlalchemy.dialects.mysql.LONGTEXT") (`sqlalchemy.dialects.mysql.types._StringType`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE233]'
  prefs: []
  type: TYPE_PRE
- en: Construct a LONGTEXT.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`charset` – Optional, a column-level character set for this string value. Takes
    precedence to ‘ascii’ or ‘unicode’ short-hand.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`collation` – Optional, a column-level collation for this string value. Takes
    precedence to ‘binary’ short-hand.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ascii` – Defaults to False: short-hand for the `latin1` character set, generates
    ASCII in schema.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unicode` – Defaults to False: short-hand for the `ucs2` character set, generates
    UNICODE in schema.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`national` – Optional. If true, use the server’s configured national character
    set.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`binary` – Defaults to False: short-hand, pick the binary collation type that
    matches the column’s character set. Generates BINARY in schema. This does not
    affect the type of data stored, only the collation of character data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE234]'
  prefs: []
  type: TYPE_PRE
- en: MySQL MEDIUMBLOB type, for binary data up to 2^24 bytes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.mysql.MEDIUMBLOB`](#sqlalchemy.dialects.mysql.MEDIUMBLOB
    "sqlalchemy.dialects.mysql.MEDIUMBLOB") (`sqlalchemy.types._Binary`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE235]'
  prefs: []
  type: TYPE_PRE
- en: MySQL MEDIUMINTEGER type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.dialects.mysql.MEDIUMINT.__init__)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.mysql.MEDIUMINT`](#sqlalchemy.dialects.mysql.MEDIUMINT
    "sqlalchemy.dialects.mysql.MEDIUMINT") (`sqlalchemy.dialects.mysql.types._IntegerType`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE236]'
  prefs: []
  type: TYPE_PRE
- en: Construct a MEDIUMINTEGER
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`display_width` – Optional, maximum display width for this number.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unsigned` – a boolean, optional.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`zerofill` – Optional. If true, values will be stored as strings left-padded
    with zeros. Note that this does not effect the values returned by the underlying
    database API, which continue to be numeric.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE237]'
  prefs: []
  type: TYPE_PRE
- en: MySQL MEDIUMTEXT type, for character storage encoded up to 2^24 bytes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.dialects.mysql.MEDIUMTEXT.__init__)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.mysql.MEDIUMTEXT`](#sqlalchemy.dialects.mysql.MEDIUMTEXT
    "sqlalchemy.dialects.mysql.MEDIUMTEXT") (`sqlalchemy.dialects.mysql.types._StringType`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE238]'
  prefs: []
  type: TYPE_PRE
- en: Construct a MEDIUMTEXT.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`charset` – Optional, a column-level character set for this string value. Takes
    precedence to ‘ascii’ or ‘unicode’ short-hand.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`collation` – Optional, a column-level collation for this string value. Takes
    precedence to ‘binary’ short-hand.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ascii` – Defaults to False: short-hand for the `latin1` character set, generates
    ASCII in schema.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unicode` – Defaults to False: short-hand for the `ucs2` character set, generates
    UNICODE in schema.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`national` – Optional. If true, use the server’s configured national character
    set.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`binary` – Defaults to False: short-hand, pick the binary collation type that
    matches the column’s character set. Generates BINARY in schema. This does not
    affect the type of data stored, only the collation of character data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE239]'
  prefs: []
  type: TYPE_PRE
- en: MySQL NCHAR type.
  prefs: []
  type: TYPE_NORMAL
- en: For fixed-length character data in the server’s configured national character
    set.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.dialects.mysql.NCHAR.__init__)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.mysql.NCHAR`](#sqlalchemy.dialects.mysql.NCHAR "sqlalchemy.dialects.mysql.NCHAR")
    (`sqlalchemy.dialects.mysql.types._StringType`, [`sqlalchemy.types.NCHAR`](../core/type_basics.html#sqlalchemy.types.NCHAR
    "sqlalchemy.types.NCHAR"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE240]'
  prefs: []
  type: TYPE_PRE
- en: Construct an NCHAR.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`length` – Maximum data length, in characters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`binary` – Optional, use the default binary collation for the national character
    set. This does not affect the type of data stored, use a BINARY type for binary
    data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`collation` – Optional, request a particular collation. Must be compatible
    with the national character set.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE241]'
  prefs: []
  type: TYPE_PRE
- en: MySQL NUMERIC type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.dialects.mysql.NUMERIC.__init__)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.mysql.NUMERIC`](#sqlalchemy.dialects.mysql.NUMERIC
    "sqlalchemy.dialects.mysql.NUMERIC") (`sqlalchemy.dialects.mysql.types._NumericType`,
    [`sqlalchemy.types.NUMERIC`](../core/type_basics.html#sqlalchemy.types.NUMERIC
    "sqlalchemy.types.NUMERIC"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE242]'
  prefs: []
  type: TYPE_PRE
- en: Construct a NUMERIC.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`precision` – Total digits in this number. If scale and precision are both
    None, values are stored to limits allowed by the server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scale` – The number of digits after the decimal point.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unsigned` – a boolean, optional.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`zerofill` – Optional. If true, values will be stored as strings left-padded
    with zeros. Note that this does not effect the values returned by the underlying
    database API, which continue to be numeric.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE243]'
  prefs: []
  type: TYPE_PRE
- en: MySQL NVARCHAR type.
  prefs: []
  type: TYPE_NORMAL
- en: For variable-length character data in the server’s configured national character
    set.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.dialects.mysql.NVARCHAR.__init__)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.mysql.NVARCHAR`](#sqlalchemy.dialects.mysql.NVARCHAR
    "sqlalchemy.dialects.mysql.NVARCHAR") (`sqlalchemy.dialects.mysql.types._StringType`,
    [`sqlalchemy.types.NVARCHAR`](../core/type_basics.html#sqlalchemy.types.NVARCHAR
    "sqlalchemy.types.NVARCHAR"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE244]'
  prefs: []
  type: TYPE_PRE
- en: Construct an NVARCHAR.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`length` – Maximum data length, in characters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`binary` – Optional, use the default binary collation for the national character
    set. This does not affect the type of data stored, use a BINARY type for binary
    data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`collation` – Optional, request a particular collation. Must be compatible
    with the national character set.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE245]'
  prefs: []
  type: TYPE_PRE
- en: MySQL REAL type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.dialects.mysql.REAL.__init__)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.mysql.REAL`](#sqlalchemy.dialects.mysql.REAL "sqlalchemy.dialects.mysql.REAL")
    (`sqlalchemy.dialects.mysql.types._FloatType`, [`sqlalchemy.types.REAL`](../core/type_basics.html#sqlalchemy.types.REAL
    "sqlalchemy.types.REAL"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE246]'
  prefs: []
  type: TYPE_PRE
- en: Construct a REAL.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The [`REAL`](#sqlalchemy.dialects.mysql.REAL "sqlalchemy.dialects.mysql.REAL")
    type by default converts from float to Decimal, using a truncation that defaults
    to 10 digits. Specify either `scale=n` or `decimal_return_scale=n` in order to
    change this scale, or `asdecimal=False` to return values directly as Python floating
    points.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`precision` – Total digits in this number. If scale and precision are both
    None, values are stored to limits allowed by the server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scale` – The number of digits after the decimal point.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unsigned` – a boolean, optional.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`zerofill` – Optional. If true, values will be stored as strings left-padded
    with zeros. Note that this does not effect the values returned by the underlying
    database API, which continue to be numeric.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE247]'
  prefs: []
  type: TYPE_PRE
- en: MySQL SET type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.dialects.mysql.SET.__init__)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.mysql.SET`](#sqlalchemy.dialects.mysql.SET "sqlalchemy.dialects.mysql.SET")
    (`sqlalchemy.dialects.mysql.types._StringType`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE248]'
  prefs: []
  type: TYPE_PRE
- en: Construct a SET.
  prefs: []
  type: TYPE_NORMAL
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE249]'
  prefs: []
  type: TYPE_PRE
- en: The list of potential values is required in the case that this set will be used
    to generate DDL for a table, or if the [`SET.retrieve_as_bitwise`](#sqlalchemy.dialects.mysql.SET.params.retrieve_as_bitwise
    "sqlalchemy.dialects.mysql.SET") flag is set to True.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`values` – The range of valid values for this SET. The values are not quoted,
    they will be escaped and surrounded by single quotes when generating the schema.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`convert_unicode` – Same flag as that of [`String.convert_unicode`](../core/type_basics.html#sqlalchemy.types.String.params.convert_unicode
    "sqlalchemy.types.String").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`collation` – same as that of [`String.collation`](../core/type_basics.html#sqlalchemy.types.String.params.collation
    "sqlalchemy.types.String")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`charset` – same as that of [`VARCHAR.charset`](#sqlalchemy.dialects.mysql.VARCHAR.params.charset
    "sqlalchemy.dialects.mysql.VARCHAR").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ascii` – same as that of [`VARCHAR.ascii`](#sqlalchemy.dialects.mysql.VARCHAR.params.ascii
    "sqlalchemy.dialects.mysql.VARCHAR").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unicode` – same as that of [`VARCHAR.unicode`](#sqlalchemy.dialects.mysql.VARCHAR.params.unicode
    "sqlalchemy.dialects.mysql.VARCHAR").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`binary` – same as that of [`VARCHAR.binary`](#sqlalchemy.dialects.mysql.VARCHAR.params.binary
    "sqlalchemy.dialects.mysql.VARCHAR").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`retrieve_as_bitwise` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: if True, the data for the set type will be persisted and selected using an integer
    value, where a set is coerced into a bitwise mask for persistence. MySQL allows
    this mode which has the advantage of being able to store values unambiguously,
    such as the blank string `''`. The datatype will appear as the expression `col
    + 0` in a SELECT statement, so that the value is coerced into an integer value
    in result sets. This flag is required if one wishes to persist a set that can
    store the blank string `''` as a value.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: When using [`SET.retrieve_as_bitwise`](#sqlalchemy.dialects.mysql.SET.params.retrieve_as_bitwise
    "sqlalchemy.dialects.mysql.SET"), it is essential that the list of set values
    is expressed in the **exact same order** as exists on the MySQL database.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE250]'
  prefs: []
  type: TYPE_PRE
- en: MySQL SMALLINTEGER type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.dialects.mysql.SMALLINT.__init__)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.mysql.SMALLINT`](#sqlalchemy.dialects.mysql.SMALLINT
    "sqlalchemy.dialects.mysql.SMALLINT") (`sqlalchemy.dialects.mysql.types._IntegerType`,
    [`sqlalchemy.types.SMALLINT`](../core/type_basics.html#sqlalchemy.types.SMALLINT
    "sqlalchemy.types.SMALLINT"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE251]'
  prefs: []
  type: TYPE_PRE
- en: Construct a SMALLINTEGER.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`display_width` – Optional, maximum display width for this number.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unsigned` – a boolean, optional.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`zerofill` – Optional. If true, values will be stored as strings left-padded
    with zeros. Note that this does not effect the values returned by the underlying
    database API, which continue to be numeric.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE252]'
  prefs: []
  type: TYPE_PRE
- en: MySQL TEXT type, for character storage encoded up to 2^16 bytes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class `sqlalchemy.dialects.mysql.TEXT` (`sqlalchemy.dialects.mysql.types._StringType`,
    [`sqlalchemy.types.TEXT`](../core/type_basics.html#sqlalchemy.types.TEXT "sqlalchemy.types.TEXT"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE253]'
  prefs: []
  type: TYPE_PRE
- en: Construct a TEXT.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`length` – Optional, if provided the server may optimize storage by substituting
    the smallest TEXT type sufficient to store `length` bytes of characters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`charset` – Optional, a column-level character set for this string value. Takes
    precedence to ‘ascii’ or ‘unicode’ short-hand.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`collation` – Optional, a column-level collation for this string value. Takes
    precedence to ‘binary’ short-hand.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ascii` – Defaults to False: short-hand for the `latin1` character set, generates
    ASCII in schema.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unicode` – Defaults to False: short-hand for the `ucs2` character set, generates
    UNICODE in schema.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`national` – Optional. If true, use the server’s configured national character
    set.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`binary` – Defaults to False: short-hand, pick the binary collation type that
    matches the column’s character set. Generates BINARY in schema. This does not
    affect the type of data stored, only the collation of character data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE254]'
  prefs: []
  type: TYPE_PRE
- en: MySQL TIME type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.dialects.mysql.TIME.__init__)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.mysql.TIME`](#sqlalchemy.dialects.mysql.TIME "sqlalchemy.dialects.mysql.TIME")
    ([`sqlalchemy.types.TIME`](../core/type_basics.html#sqlalchemy.types.TIME "sqlalchemy.types.TIME"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE255]'
  prefs: []
  type: TYPE_PRE
- en: Construct a MySQL TIME type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`timezone` – not used by the MySQL dialect.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fsp` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: fractional seconds precision value. MySQL 5.6 supports storage of fractional
    seconds; this parameter will be used when emitting DDL for the TIME type.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: DBAPI driver support for fractional seconds may be limited; current support
    includes MySQL Connector/Python.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE256]'
  prefs: []
  type: TYPE_PRE
- en: MySQL TIMESTAMP type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.dialects.mysql.TIMESTAMP.__init__)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.mysql.TIMESTAMP`](#sqlalchemy.dialects.mysql.TIMESTAMP
    "sqlalchemy.dialects.mysql.TIMESTAMP") ([`sqlalchemy.types.TIMESTAMP`](../core/type_basics.html#sqlalchemy.types.TIMESTAMP
    "sqlalchemy.types.TIMESTAMP"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE257]'
  prefs: []
  type: TYPE_PRE
- en: Construct a MySQL TIMESTAMP type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`timezone` – not used by the MySQL dialect.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fsp` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: fractional seconds precision value. MySQL 5.6.4 supports storage of fractional
    seconds; this parameter will be used when emitting DDL for the TIMESTAMP type.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: DBAPI driver support for fractional seconds may be limited; current support
    includes MySQL Connector/Python.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE258]'
  prefs: []
  type: TYPE_PRE
- en: MySQL TINYBLOB type, for binary data up to 2^8 bytes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.mysql.TINYBLOB`](#sqlalchemy.dialects.mysql.TINYBLOB
    "sqlalchemy.dialects.mysql.TINYBLOB") (`sqlalchemy.types._Binary`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE259]'
  prefs: []
  type: TYPE_PRE
- en: MySQL TINYINT type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.dialects.mysql.TINYINT.__init__)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.mysql.TINYINT`](#sqlalchemy.dialects.mysql.TINYINT
    "sqlalchemy.dialects.mysql.TINYINT") (`sqlalchemy.dialects.mysql.types._IntegerType`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE260]'
  prefs: []
  type: TYPE_PRE
- en: Construct a TINYINT.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`display_width` – Optional, maximum display width for this number.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unsigned` – a boolean, optional.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`zerofill` – Optional. If true, values will be stored as strings left-padded
    with zeros. Note that this does not effect the values returned by the underlying
    database API, which continue to be numeric.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE261]'
  prefs: []
  type: TYPE_PRE
- en: MySQL TINYTEXT type, for character storage encoded up to 2^8 bytes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.dialects.mysql.TINYTEXT.__init__)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.mysql.TINYTEXT`](#sqlalchemy.dialects.mysql.TINYTEXT
    "sqlalchemy.dialects.mysql.TINYTEXT") (`sqlalchemy.dialects.mysql.types._StringType`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE262]'
  prefs: []
  type: TYPE_PRE
- en: Construct a TINYTEXT.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`charset` – Optional, a column-level character set for this string value. Takes
    precedence to ‘ascii’ or ‘unicode’ short-hand.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`collation` – Optional, a column-level collation for this string value. Takes
    precedence to ‘binary’ short-hand.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ascii` – Defaults to False: short-hand for the `latin1` character set, generates
    ASCII in schema.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unicode` – Defaults to False: short-hand for the `ucs2` character set, generates
    UNICODE in schema.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`national` – Optional. If true, use the server’s configured national character
    set.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`binary` – Defaults to False: short-hand, pick the binary collation type that
    matches the column’s character set. Generates BINARY in schema. This does not
    affect the type of data stored, only the collation of character data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE263]'
  prefs: []
  type: TYPE_PRE
- en: The SQL VARBINARY type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class `sqlalchemy.dialects.mysql.VARBINARY` (`sqlalchemy.types._Binary`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE264]'
  prefs: []
  type: TYPE_PRE
- en: MySQL VARCHAR type, for variable-length character data.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.dialects.mysql.VARCHAR.__init__)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.mysql.VARCHAR`](#sqlalchemy.dialects.mysql.VARCHAR
    "sqlalchemy.dialects.mysql.VARCHAR") (`sqlalchemy.dialects.mysql.types._StringType`,
    [`sqlalchemy.types.VARCHAR`](../core/type_basics.html#sqlalchemy.types.VARCHAR
    "sqlalchemy.types.VARCHAR"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE265]'
  prefs: []
  type: TYPE_PRE
- en: Construct a VARCHAR.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`charset` – Optional, a column-level character set for this string value. Takes
    precedence to ‘ascii’ or ‘unicode’ short-hand.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`collation` – Optional, a column-level collation for this string value. Takes
    precedence to ‘binary’ short-hand.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ascii` – Defaults to False: short-hand for the `latin1` character set, generates
    ASCII in schema.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unicode` – Defaults to False: short-hand for the `ucs2` character set, generates
    UNICODE in schema.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`national` – Optional. If true, use the server’s configured national character
    set.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`binary` – Defaults to False: short-hand, pick the binary collation type that
    matches the column’s character set. Generates BINARY in schema. This does not
    affect the type of data stored, only the collation of character data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE266]'
  prefs: []
  type: TYPE_PRE
- en: MySQL YEAR type, for single byte storage of years 1901-2155.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.mysql.YEAR`](#sqlalchemy.dialects.mysql.YEAR "sqlalchemy.dialects.mysql.YEAR")
    ([`sqlalchemy.types.TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine"))
  prefs: []
  type: TYPE_NORMAL
- en: MySQL DML Constructs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '| Object Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| [insert](#sqlalchemy.dialects.mysql.insert)(table) | Construct a MySQL/MariaDB-specific
    variant [`Insert`](#sqlalchemy.dialects.mysql.Insert "sqlalchemy.dialects.mysql.Insert")
    construct. |'
  prefs: []
  type: TYPE_TB
- en: '| [Insert](#sqlalchemy.dialects.mysql.Insert) | MySQL-specific implementation
    of INSERT. |'
  prefs: []
  type: TYPE_TB
- en: '[PRE267]'
  prefs: []
  type: TYPE_PRE
- en: Construct a MySQL/MariaDB-specific variant [`Insert`](#sqlalchemy.dialects.mysql.Insert
    "sqlalchemy.dialects.mysql.Insert") construct.
  prefs: []
  type: TYPE_NORMAL
- en: The [`sqlalchemy.dialects.mysql.insert()`](#sqlalchemy.dialects.mysql.insert
    "sqlalchemy.dialects.mysql.insert") function creates a [`sqlalchemy.dialects.mysql.Insert`](#sqlalchemy.dialects.mysql.Insert
    "sqlalchemy.dialects.mysql.Insert"). This class is based on the dialect-agnostic
    [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert "sqlalchemy.sql.expression.Insert")
    construct which may be constructed using the [`insert()`](../core/dml.html#sqlalchemy.sql.expression.insert
    "sqlalchemy.sql.expression.insert") function in SQLAlchemy Core.
  prefs: []
  type: TYPE_NORMAL
- en: The [`Insert`](#sqlalchemy.dialects.mysql.Insert "sqlalchemy.dialects.mysql.Insert")
    construct includes additional methods [`Insert.on_duplicate_key_update()`](#sqlalchemy.dialects.mysql.Insert.on_duplicate_key_update
    "sqlalchemy.dialects.mysql.Insert.on_duplicate_key_update").
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE268]'
  prefs: []
  type: TYPE_PRE
- en: MySQL-specific implementation of INSERT.
  prefs: []
  type: TYPE_NORMAL
- en: Adds methods for MySQL-specific syntaxes such as ON DUPLICATE KEY UPDATE.
  prefs: []
  type: TYPE_NORMAL
- en: The [`Insert`](#sqlalchemy.dialects.mysql.Insert "sqlalchemy.dialects.mysql.Insert")
    object is created using the [`sqlalchemy.dialects.mysql.insert()`](#sqlalchemy.dialects.mysql.insert
    "sqlalchemy.dialects.mysql.insert") function.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.2.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[inherit_cache](#sqlalchemy.dialects.mysql.Insert.inherit_cache), [inserted](#sqlalchemy.dialects.mysql.Insert.inserted),
    [on_duplicate_key_update()](#sqlalchemy.dialects.mysql.Insert.on_duplicate_key_update)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.dialects.mysql.Insert`](#sqlalchemy.dialects.mysql.Insert
    "sqlalchemy.dialects.mysql.Insert") ([`sqlalchemy.sql.expression.Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE269]'
  prefs: []
  type: TYPE_PRE
- en: Indicate if this [`HasCacheKey`](../core/foundation.html#sqlalchemy.sql.traversals.HasCacheKey
    "sqlalchemy.sql.traversals.HasCacheKey") instance should make use of the cache
    key generation scheme used by its immediate superclass.
  prefs: []
  type: TYPE_NORMAL
- en: The attribute defaults to `None`, which indicates that a construct has not yet
    taken into account whether or not its appropriate for it to participate in caching;
    this is functionally equivalent to setting the value to `False`, except that a
    warning is also emitted.
  prefs: []
  type: TYPE_NORMAL
- en: This flag can be set to `True` on a particular class, if the SQL that corresponds
    to the object does not change based on attributes which are local to this class,
    and not its superclass.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Enabling Caching Support for Custom Constructs](../core/compiler.html#compilerext-caching)
    - General guideslines for setting the [`HasCacheKey.inherit_cache`](../core/foundation.html#sqlalchemy.sql.traversals.HasCacheKey.inherit_cache
    "sqlalchemy.sql.traversals.HasCacheKey.inherit_cache") attribute for third-party
    or user defined SQL constructs.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE270]'
  prefs: []
  type: TYPE_PRE
- en: Provide the “inserted” namespace for an ON DUPLICATE KEY UPDATE statement
  prefs: []
  type: TYPE_NORMAL
- en: MySQL’s ON DUPLICATE KEY UPDATE clause allows reference to the row that would
    be inserted, via a special function called `VALUES()`. This attribute provides
    all columns in this row to be referenceable such that they will render within
    a `VALUES()` function inside the ON DUPLICATE KEY UPDATE clause. The attribute
    is named `.inserted` so as not to conflict with the existing [`Insert.values()`](../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") method.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: The [`Insert.inserted`](#sqlalchemy.dialects.mysql.Insert.inserted "sqlalchemy.dialects.mysql.Insert.inserted")
    attribute is an instance of [`ColumnCollection`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnCollection
    "sqlalchemy.sql.expression.ColumnCollection"), which provides an interface the
    same as that of the [`Table.c`](../core/metadata.html#sqlalchemy.schema.Table.c
    "sqlalchemy.schema.Table.c") collection described at [Accessing Tables and Columns](../core/metadata.html#metadata-tables-and-columns).
    With this collection, ordinary names are accessible like attributes (e.g. `stmt.inserted.some_column`),
    but special names and dictionary method names should be accessed using indexed
    access, such as `stmt.inserted["column name"]` or `stmt.inserted["values"]`. See
    the docstring for [`ColumnCollection`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnCollection
    "sqlalchemy.sql.expression.ColumnCollection") for further examples.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[INSERT…ON DUPLICATE KEY UPDATE (Upsert)](#mysql-insert-on-duplicate-key-update)
    - example of how to use `Insert.inserted`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE271]'
  prefs: []
  type: TYPE_PRE
- en: Specifies the ON DUPLICATE KEY UPDATE clause.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '****kw** – Column keys linked to UPDATE values. The values may be any SQL expression
    or supported literal Python values.'
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: This dictionary does **not** take into account Python-specified default UPDATE
    values or generation functions, e.g. those specified using [`Column.onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.onupdate
    "sqlalchemy.schema.Column"). These values will not be exercised for an ON DUPLICATE
    KEY UPDATE style of UPDATE, unless values are manually specified here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '***args** –'
  prefs: []
  type: TYPE_NORMAL
- en: As an alternative to passing key/value parameters, a dictionary or list of 2-tuples
    can be passed as a single positional argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'Passing a single dictionary is equivalent to the keyword argument form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE272]'
  prefs: []
  type: TYPE_PRE
- en: 'Passing a list of 2-tuples indicates that the parameter assignments in the
    UPDATE clause should be ordered as sent, in a manner similar to that described
    for the [`Update`](../core/dml.html#sqlalchemy.sql.expression.Update "sqlalchemy.sql.expression.Update")
    construct overall in [Parameter Ordered Updates](../tutorial/data_update.html#tutorial-parameter-ordered-updates):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE273]'
  prefs: []
  type: TYPE_PRE
- en: 'Changed in version 1.3: parameters can be specified as a dictionary or list
    of 2-tuples; the latter form provides for parameter ordering.'
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.2.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[INSERT…ON DUPLICATE KEY UPDATE (Upsert)](#mysql-insert-on-duplicate-key-update)'
  prefs: []
  type: TYPE_NORMAL
- en: '## mysqlclient (fork of MySQL-Python)'
  prefs: []
  type: TYPE_NORMAL
- en: Support for the MySQL / MariaDB database via the mysqlclient (maintained fork
    of MySQL-Python) driver.
  prefs: []
  type: TYPE_NORMAL
- en: DBAPI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Documentation and download information (if applicable) for mysqlclient (maintained
    fork of MySQL-Python) is available at: [https://pypi.org/project/mysqlclient/](https://pypi.org/project/mysqlclient/)'
  prefs: []
  type: TYPE_NORMAL
- en: Connecting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Connect String:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE274]'
  prefs: []
  type: TYPE_PRE
- en: Driver Status
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The mysqlclient DBAPI is a maintained fork of the [MySQL-Python](https://sourceforge.net/projects/mysql-python)
    DBAPI that is no longer maintained. [mysqlclient](https://github.com/PyMySQL/mysqlclient-python)
    supports Python 2 and Python 3 and is very stable.
  prefs: []
  type: TYPE_NORMAL
- en: '### Unicode'
  prefs: []
  type: TYPE_NORMAL
- en: 'Please see [Unicode](#mysql-unicode) for current recommendations on unicode
    handling.  ### SSL Connections'
  prefs: []
  type: TYPE_NORMAL
- en: 'The mysqlclient and PyMySQL DBAPIs accept an additional dictionary under the
    key “ssl”, which may be specified using the [`create_engine.connect_args`](../core/engines.html#sqlalchemy.create_engine.params.connect_args
    "sqlalchemy.create_engine") dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE275]'
  prefs: []
  type: TYPE_PRE
- en: 'For convenience, the following keys may also be specified inline within the
    URL where they will be interpreted into the “ssl” dictionary automatically: “ssl_ca”,
    “ssl_cert”, “ssl_key”, “ssl_capath”, “ssl_cipher”, “ssl_check_hostname”. An example
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE276]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[SSL Connections](#pymysql-ssl) in the PyMySQL dialect'
  prefs: []
  type: TYPE_NORMAL
- en: Using MySQLdb with Google Cloud SQL
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Google Cloud SQL now recommends use of the MySQLdb dialect. Connect using a
    URL like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE277]'
  prefs: []
  type: TYPE_PRE
- en: Server Side Cursors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The mysqldb dialect supports server-side cursors. See [Server Side Cursors](#mysql-ss-cursors).
  prefs: []
  type: TYPE_NORMAL
- en: DBAPI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Documentation and download information (if applicable) for mysqlclient (maintained
    fork of MySQL-Python) is available at: [https://pypi.org/project/mysqlclient/](https://pypi.org/project/mysqlclient/)'
  prefs: []
  type: TYPE_NORMAL
- en: Connecting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Connect String:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE278]'
  prefs: []
  type: TYPE_PRE
- en: Driver Status
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The mysqlclient DBAPI is a maintained fork of the [MySQL-Python](https://sourceforge.net/projects/mysql-python)
    DBAPI that is no longer maintained. [mysqlclient](https://github.com/PyMySQL/mysqlclient-python)
    supports Python 2 and Python 3 and is very stable.
  prefs: []
  type: TYPE_NORMAL
- en: '### Unicode'
  prefs: []
  type: TYPE_NORMAL
- en: Please see [Unicode](#mysql-unicode) for current recommendations on unicode
    handling.
  prefs: []
  type: TYPE_NORMAL
- en: '### SSL Connections'
  prefs: []
  type: TYPE_NORMAL
- en: 'The mysqlclient and PyMySQL DBAPIs accept an additional dictionary under the
    key “ssl”, which may be specified using the [`create_engine.connect_args`](../core/engines.html#sqlalchemy.create_engine.params.connect_args
    "sqlalchemy.create_engine") dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE279]'
  prefs: []
  type: TYPE_PRE
- en: 'For convenience, the following keys may also be specified inline within the
    URL where they will be interpreted into the “ssl” dictionary automatically: “ssl_ca”,
    “ssl_cert”, “ssl_key”, “ssl_capath”, “ssl_cipher”, “ssl_check_hostname”. An example
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE280]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[SSL Connections](#pymysql-ssl) in the PyMySQL dialect'
  prefs: []
  type: TYPE_NORMAL
- en: Using MySQLdb with Google Cloud SQL
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Google Cloud SQL now recommends use of the MySQLdb dialect. Connect using a
    URL like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE281]'
  prefs: []
  type: TYPE_PRE
- en: Server Side Cursors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The mysqldb dialect supports server-side cursors. See [Server Side Cursors](#mysql-ss-cursors).
  prefs: []
  type: TYPE_NORMAL
- en: '## PyMySQL'
  prefs: []
  type: TYPE_NORMAL
- en: Support for the MySQL / MariaDB database via the PyMySQL driver.
  prefs: []
  type: TYPE_NORMAL
- en: DBAPI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Documentation and download information (if applicable) for PyMySQL is available
    at: [https://pymysql.readthedocs.io/](https://pymysql.readthedocs.io/)'
  prefs: []
  type: TYPE_NORMAL
- en: Connecting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Connect String:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE282]'
  prefs: []
  type: TYPE_PRE
- en: Unicode
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Please see [Unicode](#mysql-unicode) for current recommendations on unicode
    handling.
  prefs: []
  type: TYPE_NORMAL
- en: '### SSL Connections'
  prefs: []
  type: TYPE_NORMAL
- en: The PyMySQL DBAPI accepts the same SSL arguments as that of MySQLdb, described
    at [SSL Connections](#mysqldb-ssl). See that section for additional examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the server uses an automatically-generated certificate that is self-signed
    or does not match the host name (as seen from the client), it may also be necessary
    to indicate `ssl_check_hostname=false` in PyMySQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE283]'
  prefs: []
  type: TYPE_PRE
- en: MySQL-Python Compatibility
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The pymysql DBAPI is a pure Python port of the MySQL-python (MySQLdb) driver,
    and targets 100% compatibility. Most behavioral notes for MySQL-python apply to
    the pymysql driver as well.
  prefs: []
  type: TYPE_NORMAL
- en: DBAPI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Documentation and download information (if applicable) for PyMySQL is available
    at: [https://pymysql.readthedocs.io/](https://pymysql.readthedocs.io/)'
  prefs: []
  type: TYPE_NORMAL
- en: Connecting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Connect String:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE284]'
  prefs: []
  type: TYPE_PRE
- en: Unicode
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Please see [Unicode](#mysql-unicode) for current recommendations on unicode
    handling.
  prefs: []
  type: TYPE_NORMAL
- en: '### SSL Connections'
  prefs: []
  type: TYPE_NORMAL
- en: The PyMySQL DBAPI accepts the same SSL arguments as that of MySQLdb, described
    at [SSL Connections](#mysqldb-ssl). See that section for additional examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the server uses an automatically-generated certificate that is self-signed
    or does not match the host name (as seen from the client), it may also be necessary
    to indicate `ssl_check_hostname=false` in PyMySQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE285]'
  prefs: []
  type: TYPE_PRE
- en: MySQL-Python Compatibility
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The pymysql DBAPI is a pure Python port of the MySQL-python (MySQLdb) driver,
    and targets 100% compatibility. Most behavioral notes for MySQL-python apply to
    the pymysql driver as well.
  prefs: []
  type: TYPE_NORMAL
- en: '## MariaDB-Connector'
  prefs: []
  type: TYPE_NORMAL
- en: Support for the MySQL / MariaDB database via the MariaDB Connector/Python driver.
  prefs: []
  type: TYPE_NORMAL
- en: DBAPI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Documentation and download information (if applicable) for MariaDB Connector/Python
    is available at: [https://pypi.org/project/mariadb/](https://pypi.org/project/mariadb/)'
  prefs: []
  type: TYPE_NORMAL
- en: Connecting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Connect String:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE286]'
  prefs: []
  type: TYPE_PRE
- en: Driver Status
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: MariaDB Connector/Python enables Python programs to access MariaDB and MySQL
    databases using an API which is compliant with the Python DB API 2.0 (PEP-249).
    It is written in C and uses MariaDB Connector/C client library for client server
    communication.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the default driver for a `mariadb://` connection URI continues to
    be `mysqldb`. `mariadb+mariadbconnector://` is required to use this driver.
  prefs: []
  type: TYPE_NORMAL
- en: DBAPI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Documentation and download information (if applicable) for MariaDB Connector/Python
    is available at: [https://pypi.org/project/mariadb/](https://pypi.org/project/mariadb/)'
  prefs: []
  type: TYPE_NORMAL
- en: Connecting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Connect String:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE287]'
  prefs: []
  type: TYPE_PRE
- en: Driver Status
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: MariaDB Connector/Python enables Python programs to access MariaDB and MySQL
    databases using an API which is compliant with the Python DB API 2.0 (PEP-249).
    It is written in C and uses MariaDB Connector/C client library for client server
    communication.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the default driver for a `mariadb://` connection URI continues to
    be `mysqldb`. `mariadb+mariadbconnector://` is required to use this driver.
  prefs: []
  type: TYPE_NORMAL
- en: '## MySQL-Connector'
  prefs: []
  type: TYPE_NORMAL
- en: Support for the MySQL / MariaDB database via the MySQL Connector/Python driver.
  prefs: []
  type: TYPE_NORMAL
- en: DBAPI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Documentation and download information (if applicable) for MySQL Connector/Python
    is available at: [https://pypi.org/project/mysql-connector-python/](https://pypi.org/project/mysql-connector-python/)'
  prefs: []
  type: TYPE_NORMAL
- en: Connecting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Connect String:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE288]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The MySQL Connector/Python DBAPI has had many issues since its release, some
    of which may remain unresolved, and the mysqlconnector dialect is **not tested
    as part of SQLAlchemy’s continuous integration**. The recommended MySQL dialects
    are mysqlclient and PyMySQL.
  prefs: []
  type: TYPE_NORMAL
- en: DBAPI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Documentation and download information (if applicable) for MySQL Connector/Python
    is available at: [https://pypi.org/project/mysql-connector-python/](https://pypi.org/project/mysql-connector-python/)'
  prefs: []
  type: TYPE_NORMAL
- en: Connecting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Connect String:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE289]'
  prefs: []
  type: TYPE_PRE
- en: '## asyncmy'
  prefs: []
  type: TYPE_NORMAL
- en: Support for the MySQL / MariaDB database via the asyncmy driver.
  prefs: []
  type: TYPE_NORMAL
- en: DBAPI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Documentation and download information (if applicable) for asyncmy is available
    at: [https://github.com/long2ice/asyncmy](https://github.com/long2ice/asyncmy)'
  prefs: []
  type: TYPE_NORMAL
- en: Connecting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Connect String:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE290]'
  prefs: []
  type: TYPE_PRE
- en: Using a special asyncio mediation layer, the asyncmy dialect is usable as the
    backend for the [SQLAlchemy asyncio](../orm/extensions/asyncio.html) extension
    package.
  prefs: []
  type: TYPE_NORMAL
- en: 'This dialect should normally be used only with the [`create_async_engine()`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.create_async_engine
    "sqlalchemy.ext.asyncio.create_async_engine") engine creation function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE291]'
  prefs: []
  type: TYPE_PRE
- en: DBAPI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Documentation and download information (if applicable) for asyncmy is available
    at: [https://github.com/long2ice/asyncmy](https://github.com/long2ice/asyncmy)'
  prefs: []
  type: TYPE_NORMAL
- en: Connecting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Connect String:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE292]'
  prefs: []
  type: TYPE_PRE
- en: '## aiomysql'
  prefs: []
  type: TYPE_NORMAL
- en: Support for the MySQL / MariaDB database via the aiomysql driver.
  prefs: []
  type: TYPE_NORMAL
- en: DBAPI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Documentation and download information (if applicable) for aiomysql is available
    at: [https://github.com/aio-libs/aiomysql](https://github.com/aio-libs/aiomysql)'
  prefs: []
  type: TYPE_NORMAL
- en: Connecting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Connect String:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE293]'
  prefs: []
  type: TYPE_PRE
- en: The aiomysql dialect is SQLAlchemy’s second Python asyncio dialect.
  prefs: []
  type: TYPE_NORMAL
- en: Using a special asyncio mediation layer, the aiomysql dialect is usable as the
    backend for the [SQLAlchemy asyncio](../orm/extensions/asyncio.html) extension
    package.
  prefs: []
  type: TYPE_NORMAL
- en: 'This dialect should normally be used only with the [`create_async_engine()`](../orm/extensions/asyncio.html#sqlalchemy.ext.asyncio.create_async_engine
    "sqlalchemy.ext.asyncio.create_async_engine") engine creation function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE294]'
  prefs: []
  type: TYPE_PRE
- en: DBAPI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Documentation and download information (if applicable) for aiomysql is available
    at: [https://github.com/aio-libs/aiomysql](https://github.com/aio-libs/aiomysql)'
  prefs: []
  type: TYPE_NORMAL
- en: Connecting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Connect String:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE295]'
  prefs: []
  type: TYPE_PRE
- en: '## cymysql'
  prefs: []
  type: TYPE_NORMAL
- en: Support for the MySQL / MariaDB database via the CyMySQL driver.
  prefs: []
  type: TYPE_NORMAL
- en: DBAPI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Documentation and download information (if applicable) for CyMySQL is available
    at: [https://github.com/nakagami/CyMySQL](https://github.com/nakagami/CyMySQL)'
  prefs: []
  type: TYPE_NORMAL
- en: Connecting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Connect String:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE296]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The CyMySQL dialect is **not tested as part of SQLAlchemy’s continuous integration**
    and may have unresolved issues. The recommended MySQL dialects are mysqlclient
    and PyMySQL.
  prefs: []
  type: TYPE_NORMAL
- en: DBAPI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Documentation and download information (if applicable) for CyMySQL is available
    at: [https://github.com/nakagami/CyMySQL](https://github.com/nakagami/CyMySQL)'
  prefs: []
  type: TYPE_NORMAL
- en: Connecting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Connect String:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE297]'
  prefs: []
  type: TYPE_PRE
- en: '## pyodbc'
  prefs: []
  type: TYPE_NORMAL
- en: Support for the MySQL / MariaDB database via the PyODBC driver.
  prefs: []
  type: TYPE_NORMAL
- en: DBAPI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Documentation and download information (if applicable) for PyODBC is available
    at: [https://pypi.org/project/pyodbc/](https://pypi.org/project/pyodbc/)'
  prefs: []
  type: TYPE_NORMAL
- en: Connecting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Connect String:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE298]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The PyODBC for MySQL dialect is **not tested as part of SQLAlchemy’s continuous
    integration**. The recommended MySQL dialects are mysqlclient and PyMySQL. However,
    if you want to use the mysql+pyodbc dialect and require full support for `utf8mb4`
    characters (including supplementary characters like emoji) be sure to use a current
    release of MySQL Connector/ODBC and specify the “ANSI” (**not** “Unicode”) version
    of the driver in your DSN or connection string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pass through exact pyodbc connection string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE299]'
  prefs: []
  type: TYPE_PRE
- en: DBAPI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Documentation and download information (if applicable) for PyODBC is available
    at: [https://pypi.org/project/pyodbc/](https://pypi.org/project/pyodbc/)'
  prefs: []
  type: TYPE_NORMAL
- en: Connecting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Connect String:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE300]'
  prefs: []
  type: TYPE_PRE
