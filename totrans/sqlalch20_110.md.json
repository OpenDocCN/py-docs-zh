["```py\nTable('sometable', metadata,\n        Column('id', Integer, primary_key=True),\n        sqlite_autoincrement=True)\n```", "```py\ntable = Table(\n    \"my_table\", metadata,\n    Column(\"id\", BigInteger().with_variant(Integer, \"sqlite\"), primary_key=True)\n)\n```", "```py\nfrom sqlalchemy import BigInteger\nfrom sqlalchemy.ext.compiler import compiles\n\nclass SLBigInteger(BigInteger):\n    pass\n\n@compiles(SLBigInteger, 'sqlite')\ndef bi_c(element, compiler, **kw):\n    return \"INTEGER\"\n\n@compiles(SLBigInteger)\ndef bi_c(element, compiler, **kw):\n    return compiler.visit_BIGINT(element, **kw)\n\ntable = Table(\n    \"my_table\", metadata,\n    Column(\"id\", SLBigInteger(), primary_key=True)\n)\n```", "```py\n# INSERT..RETURNING\nresult = connection.execute(\n    table.insert().\n    values(name='foo').\n    returning(table.c.col1, table.c.col2)\n)\nprint(result.all())\n\n# UPDATE..RETURNING\nresult = connection.execute(\n    table.update().\n    where(table.c.name=='foo').\n    values(name='bar').\n    returning(table.c.col1, table.c.col2)\n)\nprint(result.all())\n\n# DELETE..RETURNING\nresult = connection.execute(\n    table.delete().\n    where(table.c.name=='foo').\n    returning(table.c.col1, table.c.col2)\n)\nprint(result.all())\n```", "```py\nfrom sqlalchemy.engine import Engine\nfrom sqlalchemy import event\n\n@event.listens_for(Engine, \"connect\")\ndef set_sqlite_pragma(dbapi_connection, connection_record):\n    cursor = dbapi_connection.cursor()\n    cursor.execute(\"PRAGMA foreign_keys=ON\")\n    cursor.close()\n```", "```py\nsome_table = Table(\n    'some_table', metadata,\n    Column('id', Integer, primary_key=True),\n    Column('data', Integer),\n    UniqueConstraint('id', 'data', sqlite_on_conflict='IGNORE')\n)\n```", "```py\nCREATE TABLE some_table (\n    id INTEGER NOT NULL,\n    data INTEGER,\n    PRIMARY KEY (id),\n    UNIQUE (id, data) ON CONFLICT IGNORE\n)\n```", "```py\nsome_table = Table(\n    'some_table', metadata,\n    Column('id', Integer, primary_key=True),\n    Column('data', Integer, unique=True,\n           sqlite_on_conflict_unique='IGNORE')\n)\n```", "```py\nCREATE TABLE some_table (\n    id INTEGER NOT NULL,\n    data INTEGER,\n    PRIMARY KEY (id),\n    UNIQUE (data) ON CONFLICT IGNORE\n)\n```", "```py\nsome_table = Table(\n    'some_table', metadata,\n    Column('id', Integer, primary_key=True),\n    Column('data', Integer, nullable=False,\n           sqlite_on_conflict_not_null='FAIL')\n)\n```", "```py\nCREATE TABLE some_table (\n    id INTEGER NOT NULL,\n    data INTEGER NOT NULL ON CONFLICT FAIL,\n    PRIMARY KEY (id)\n)\n```", "```py\nsome_table = Table(\n    'some_table', metadata,\n    Column('id', Integer, primary_key=True,\n           sqlite_on_conflict_primary_key='FAIL')\n)\n```", "```py\nCREATE TABLE some_table (\n    id INTEGER NOT NULL,\n    PRIMARY KEY (id) ON CONFLICT FAIL\n)\n```", "```py\n>>> from sqlalchemy.dialects.sqlite import insert\n\n>>> insert_stmt = insert(my_table).values(\n...     id='some_existing_id',\n...     data='inserted value')\n\n>>> do_update_stmt = insert_stmt.on_conflict_do_update(\n...     index_elements=['id'],\n...     set_=dict(data='updated value')\n... )\n\n>>> print(do_update_stmt)\nINSERT  INTO  my_table  (id,  data)  VALUES  (?,  ?)\nON  CONFLICT  (id)  DO  UPDATE  SET  data  =  ?\n>>> do_nothing_stmt = insert_stmt.on_conflict_do_nothing(\n...     index_elements=['id']\n... )\n\n>>> print(do_nothing_stmt)\nINSERT  INTO  my_table  (id,  data)  VALUES  (?,  ?)\nON  CONFLICT  (id)  DO  NOTHING \n```", "```py\n    >>> stmt = insert(my_table).values(user_email='a@b.com', data='inserted data')\n\n    >>> do_update_stmt = stmt.on_conflict_do_update(\n    ...     index_elements=[my_table.c.user_email],\n    ...     index_where=my_table.c.user_email.like('%@gmail.com'),\n    ...     set_=dict(data=stmt.excluded.data)\n    ...     )\n\n    >>> print(do_update_stmt)\n    INSERT  INTO  my_table  (data,  user_email)  VALUES  (?,  ?)\n    ON  CONFLICT  (user_email)\n    WHERE  user_email  LIKE  '%@gmail.com'\n    DO  UPDATE  SET  data  =  excluded.data \n    ```", "```py\n>>> stmt = insert(my_table).values(id='some_id', data='inserted value')\n\n>>> do_update_stmt = stmt.on_conflict_do_update(\n...     index_elements=['id'],\n...     set_=dict(data='updated value')\n... )\n\n>>> print(do_update_stmt)\nINSERT  INTO  my_table  (id,  data)  VALUES  (?,  ?)\nON  CONFLICT  (id)  DO  UPDATE  SET  data  =  ? \n```", "```py\n>>> stmt = insert(my_table).values(\n...     id='some_id',\n...     data='inserted value',\n...     author='jlh'\n... )\n\n>>> do_update_stmt = stmt.on_conflict_do_update(\n...     index_elements=['id'],\n...     set_=dict(data='updated value', author=stmt.excluded.author)\n... )\n\n>>> print(do_update_stmt)\nINSERT  INTO  my_table  (id,  data,  author)  VALUES  (?,  ?,  ?)\nON  CONFLICT  (id)  DO  UPDATE  SET  data  =  ?,  author  =  excluded.author \n```", "```py\n>>> stmt = insert(my_table).values(\n...     id='some_id',\n...     data='inserted value',\n...     author='jlh'\n... )\n\n>>> on_update_stmt = stmt.on_conflict_do_update(\n...     index_elements=['id'],\n...     set_=dict(data='updated value', author=stmt.excluded.author),\n...     where=(my_table.c.status == 2)\n... )\n>>> print(on_update_stmt)\nINSERT  INTO  my_table  (id,  data,  author)  VALUES  (?,  ?,  ?)\nON  CONFLICT  (id)  DO  UPDATE  SET  data  =  ?,  author  =  excluded.author\nWHERE  my_table.status  =  ? \n```", "```py\n>>> stmt = insert(my_table).values(id='some_id', data='inserted value')\n>>> stmt = stmt.on_conflict_do_nothing(index_elements=['id'])\n>>> print(stmt)\nINSERT  INTO  my_table  (id,  data)  VALUES  (?,  ?)  ON  CONFLICT  (id)  DO  NOTHING \n```", "```py\n>>> stmt = insert(my_table).values(id='some_id', data='inserted value')\n>>> stmt = stmt.on_conflict_do_nothing()\n>>> print(stmt)\nINSERT  INTO  my_table  (id,  data)  VALUES  (?,  ?)  ON  CONFLICT  DO  NOTHING \n```", "```py\ntbl = Table('testtbl', m, Column('data', Integer))\nidx = Index('test_idx1', tbl.c.data,\n            sqlite_where=and_(tbl.c.data > 5, tbl.c.data < 10))\n```", "```py\nCREATE INDEX test_idx1 ON testtbl (data)\nWHERE data > 5 AND data < 10\n```", "```py\nimport sqlite3\n\nassert sqlite3.sqlite_version_info < (3, 10, 0), \"bug is fixed in this version\"\n\nconn = sqlite3.connect(\":memory:\")\ncursor = conn.cursor()\n\ncursor.execute(\"create table x (a integer, b integer)\")\ncursor.execute(\"insert into x (a, b) values (1, 1)\")\ncursor.execute(\"insert into x (a, b) values (2, 2)\")\n\ncursor.execute(\"select x.a, x.b from x\")\nassert [c[0] for c in cursor.description] == ['a', 'b']\n\ncursor.execute('''\n select x.a, x.b from x where a=1\n union\n select x.a, x.b from x where a=2\n''')\nassert [c[0] for c in cursor.description] == ['a', 'b'], \\\n    [c[0] for c in cursor.description]\n```", "```py\nTraceback (most recent call last):\n  File \"test.py\", line 19, in <module>\n    [c[0] for c in cursor.description]\nAssertionError: ['x.a', 'x.b']\n```", "```py\nfrom sqlalchemy import create_engine\n\neng = create_engine(\"sqlite://\")\nconn = eng.connect()\n\nconn.exec_driver_sql(\"create table x (a integer, b integer)\")\nconn.exec_driver_sql(\"insert into x (a, b) values (1, 1)\")\nconn.exec_driver_sql(\"insert into x (a, b) values (2, 2)\")\n\nresult = conn.exec_driver_sql(\"select x.a, x.b from x\")\nassert result.keys() == [\"a\", \"b\"]\n\nresult = conn.exec_driver_sql('''\n select x.a, x.b from x where a=1\n union\n select x.a, x.b from x where a=2\n''')\nassert result.keys() == [\"a\", \"b\"]\n```", "```py\n>>> row = result.first()\n>>> row[\"a\"]\n1\n>>> row[\"x.a\"]\n1\n>>> row[\"b\"]\n1\n>>> row[\"x.b\"]\n1\n```", "```py\nresult = conn.execution_options(sqlite_raw_colnames=True).exec_driver_sql('''\n select x.a, x.b from x where a=1\n union\n select x.a, x.b from x where a=2\n''')\nassert result.keys() == [\"x.a\", \"x.b\"]\n```", "```py\nengine = create_engine(\"sqlite://\", execution_options={\"sqlite_raw_colnames\": True})\n```", "```py\n    Table(\"some_table\", metadata, ..., sqlite_with_rowid=False)\n    ```", "```py\nfrom sqlalchemy.dialects.sqlite import (\n    BLOB,\n    BOOLEAN,\n    CHAR,\n    DATE,\n    DATETIME,\n    DECIMAL,\n    FLOAT,\n    INTEGER,\n    NUMERIC,\n    JSON,\n    SMALLINT,\n    TEXT,\n    TIME,\n    TIMESTAMP,\n    VARCHAR,\n)\n```", "```py\nclass sqlalchemy.dialects.sqlite.DATETIME\n```", "```py\n\"%(year)04d-%(month)02d-%(day)02d  %(hour)02d:%(minute)02d:%(second)02d.%(microsecond)06d\"\n```", "```py\n2021-03-15 12:05:57.105542\n```", "```py\nimport re\nfrom sqlalchemy.dialects.sqlite import DATETIME\n\ndt = DATETIME(storage_format=\"%(year)04d/%(month)02d/%(day)02d \"\n                             \"%(hour)02d:%(minute)02d:%(second)02d\",\n              regexp=r\"(\\d+)/(\\d+)/(\\d+) (\\d+)-(\\d+)-(\\d+)\"\n)\n```", "```py\nclass sqlalchemy.dialects.sqlite.DATE\n```", "```py\n\"%(year)04d-%(month)02d-%(day)02d\"\n```", "```py\n2011-03-15\n```", "```py\nimport re\nfrom sqlalchemy.dialects.sqlite import DATE\n\nd = DATE(\n        storage_format=\"%(month)02d/%(day)02d/%(year)04d\",\n        regexp=re.compile(\"(?P<month>\\d+)/(?P<day>\\d+)/(?P<year>\\d+)\")\n    )\n```", "```py\nclass sqlalchemy.dialects.sqlite.JSON\n```", "```py\nmethod __init__(none_as_null: bool = False)\n```", "```py\nfrom sqlalchemy import null\nconn.execute(table.insert(), {\"data\": null()})\n```", "```py\nclass sqlalchemy.dialects.sqlite.TIME\n```", "```py\n\"%(hour)02d:%(minute)02d:%(second)02d.%(microsecond)06d\"\n```", "```py\n12:05:57.10558\n```", "```py\nimport re\nfrom sqlalchemy.dialects.sqlite import TIME\n\nt = TIME(storage_format=\"%(hour)02d-%(minute)02d-\"\n                        \"%(second)02d-%(microsecond)06d\",\n         regexp=re.compile(\"(\\d+)-(\\d+)-(\\d+)-(?:-(\\d+))?\")\n)\n```", "```py\nfunction sqlalchemy.dialects.sqlite.insert(table: _DMLTableArgument) \u2192 Insert\n```", "```py\nclass sqlalchemy.dialects.sqlite.Insert\n```", "```py\nattribute excluded\n```", "```py\nattribute inherit_cache: bool | None = False\n```", "```py\nmethod on_conflict_do_nothing(index_elements: _OnConflictIndexElementsT = None, index_where: _OnConflictIndexWhereT = None) \u2192 Self\n```", "```py\nmethod on_conflict_do_update(index_elements: _OnConflictIndexElementsT = None, index_where: _OnConflictIndexWhereT = None, set_: _OnConflictSetT = None, where: _OnConflictWhereT = None) \u2192 Self\n```", "```py\nsqlite+pysqlite:///file_path\n```", "```py\ndriver://user:pass@host/database\n```", "```py\n# relative path\ne = create_engine('sqlite:///path/to/database.db')\n```", "```py\n# absolute path\ne = create_engine('sqlite:////path/to/database.db')\n```", "```py\n# absolute path on Windows\ne = create_engine('sqlite:///C:\\\\path\\\\to\\\\database.db')\n```", "```py\n# in-memory database\ne = create_engine('sqlite://:memory:')\n# also in-memory database\ne2 = create_engine('sqlite://')\n```", "```py\ne = create_engine(\"sqlite:///file:path/to/database?mode=ro&uri=true\")\n```", "```py\ne = create_engine(\n    \"sqlite:///file:path/to/database?\"\n    \"check_same_thread=true&timeout=10&mode=ro&nolock=1&uri=true\"\n)\n```", "```py\nsqlite3.connect(\n    \"file:path/to/database?mode=ro&nolock=1\",\n    check_same_thread=True, timeout=10, uri=True\n)\n```", "```py\ndef regexp(a, b):\n    return re.search(a, b) is not None\n\nsqlite_connection.create_function(\n    \"regexp\", 2, regexp,\n)\n```", "```py\nengine = create_engine('sqlite://',\n    connect_args={'detect_types':\n        sqlite3.PARSE_DECLTYPES|sqlite3.PARSE_COLNAMES},\n    native_datetime=True\n)\n```", "```py\nfrom sqlalchemy import NullPool\nengine = create_engine(\"sqlite:///myfile.db\", poolclass=NullPool)\n```", "```py\nfrom sqlalchemy.pool import StaticPool\nengine = create_engine('sqlite://',\n                    connect_args={'check_same_thread':False},\n                    poolclass=StaticPool)\n```", "```py\n# maintain the same connection per thread\nfrom sqlalchemy.pool import SingletonThreadPool\nengine = create_engine('sqlite:///mydb.db',\n                    poolclass=SingletonThreadPool)\n\n# maintain the same connection across all threads\nfrom sqlalchemy.pool import StaticPool\nengine = create_engine('sqlite:///mydb.db',\n                    poolclass=StaticPool)\n```", "```py\nfrom sqlalchemy import String\nfrom sqlalchemy import TypeDecorator\n\nclass MixedBinary(TypeDecorator):\n    impl = String\n    cache_ok = True\n\n    def process_result_value(self, value, dialect):\n        if isinstance(value, str):\n            value = bytes(value, 'utf-8')\n        elif value is not None:\n            value = bytes(value)\n\n        return value\n```", "```py\nfrom sqlalchemy import create_engine, event\n\nengine = create_engine(\"sqlite:///myfile.db\")\n\n@event.listens_for(engine, \"connect\")\ndef do_connect(dbapi_connection, connection_record):\n    # disable pysqlite's emitting of the BEGIN statement entirely.\n    # also stops it from emitting COMMIT before any DDL.\n    dbapi_connection.isolation_level = None\n\n@event.listens_for(engine, \"begin\")\ndef do_begin(conn):\n    # emit our own BEGIN\n    conn.exec_driver_sql(\"BEGIN\")\n```", "```py\n@event.listens_for(engine, \"begin\")\ndef do_begin(conn):\n    conn.exec_driver_sql(\"BEGIN EXCLUSIVE\")\n```", "```py\nfrom sqlalchemy import create_engine\nfrom sqlalchemy import event\nfrom sqlalchemy import text\n\ndef udf():\n    return \"udf-ok\"\n\nengine = create_engine(\"sqlite:///./db_file\")\n\n@event.listens_for(engine, \"connect\")\ndef connect(conn, rec):\n    conn.create_function(\"udf\", 0, udf)\n\nfor i in range(5):\n    with engine.connect() as conn:\n        print(conn.scalar(text(\"SELECT UDF()\")))\n```", "```py\nsqlite+aiosqlite:///file_path\n```", "```py\nfrom sqlalchemy.ext.asyncio import create_async_engine\nengine = create_async_engine(\"sqlite+aiosqlite:///filename\")\n```", "```py\nfrom sqlalchemy import create_engine, event\nfrom sqlalchemy.ext.asyncio import create_async_engine\n\nengine = create_async_engine(\"sqlite+aiosqlite:///myfile.db\")\n\n@event.listens_for(engine.sync_engine, \"connect\")\ndef do_connect(dbapi_connection, connection_record):\n    # disable aiosqlite's emitting of the BEGIN statement entirely.\n    # also stops it from emitting COMMIT before any DDL.\n    dbapi_connection.isolation_level = None\n\n@event.listens_for(engine.sync_engine, \"begin\")\ndef do_begin(conn):\n    # emit our own BEGIN\n    conn.exec_driver_sql(\"BEGIN\")\n```", "```py\nsqlite+pysqlcipher://:passphrase@/file_path[?kdf_iter=<iter>]\n```", "```py\nimport sqlcipher_compatible_driver\n\nfrom sqlalchemy import create_engine\n\ne = create_engine(\n    \"sqlite+pysqlcipher://:password@/dbname.db\",\n    module=sqlcipher_compatible_driver\n)\n```", "```py\ne = create_engine('sqlite+pysqlcipher://:testing@/foo.db')\n```", "```py\ne = create_engine('sqlite+pysqlcipher://:testing@//path/to/foo.db')\n```", "```py\ne = create_engine('sqlite+pysqlcipher://:testing@/foo.db?cipher=aes-256-cfb&kdf_iter=64000')\n```", "```py\nTable('sometable', metadata,\n        Column('id', Integer, primary_key=True),\n        sqlite_autoincrement=True)\n```", "```py\ntable = Table(\n    \"my_table\", metadata,\n    Column(\"id\", BigInteger().with_variant(Integer, \"sqlite\"), primary_key=True)\n)\n```", "```py\nfrom sqlalchemy import BigInteger\nfrom sqlalchemy.ext.compiler import compiles\n\nclass SLBigInteger(BigInteger):\n    pass\n\n@compiles(SLBigInteger, 'sqlite')\ndef bi_c(element, compiler, **kw):\n    return \"INTEGER\"\n\n@compiles(SLBigInteger)\ndef bi_c(element, compiler, **kw):\n    return compiler.visit_BIGINT(element, **kw)\n\ntable = Table(\n    \"my_table\", metadata,\n    Column(\"id\", SLBigInteger(), primary_key=True)\n)\n```", "```py\nTable('sometable', metadata,\n        Column('id', Integer, primary_key=True),\n        sqlite_autoincrement=True)\n```", "```py\ntable = Table(\n    \"my_table\", metadata,\n    Column(\"id\", BigInteger().with_variant(Integer, \"sqlite\"), primary_key=True)\n)\n```", "```py\nfrom sqlalchemy import BigInteger\nfrom sqlalchemy.ext.compiler import compiles\n\nclass SLBigInteger(BigInteger):\n    pass\n\n@compiles(SLBigInteger, 'sqlite')\ndef bi_c(element, compiler, **kw):\n    return \"INTEGER\"\n\n@compiles(SLBigInteger)\ndef bi_c(element, compiler, **kw):\n    return compiler.visit_BIGINT(element, **kw)\n\ntable = Table(\n    \"my_table\", metadata,\n    Column(\"id\", SLBigInteger(), primary_key=True)\n)\n```", "```py\n# INSERT..RETURNING\nresult = connection.execute(\n    table.insert().\n    values(name='foo').\n    returning(table.c.col1, table.c.col2)\n)\nprint(result.all())\n\n# UPDATE..RETURNING\nresult = connection.execute(\n    table.update().\n    where(table.c.name=='foo').\n    values(name='bar').\n    returning(table.c.col1, table.c.col2)\n)\nprint(result.all())\n\n# DELETE..RETURNING\nresult = connection.execute(\n    table.delete().\n    where(table.c.name=='foo').\n    returning(table.c.col1, table.c.col2)\n)\nprint(result.all())\n```", "```py\nfrom sqlalchemy.engine import Engine\nfrom sqlalchemy import event\n\n@event.listens_for(Engine, \"connect\")\ndef set_sqlite_pragma(dbapi_connection, connection_record):\n    cursor = dbapi_connection.cursor()\n    cursor.execute(\"PRAGMA foreign_keys=ON\")\n    cursor.close()\n```", "```py\nsome_table = Table(\n    'some_table', metadata,\n    Column('id', Integer, primary_key=True),\n    Column('data', Integer),\n    UniqueConstraint('id', 'data', sqlite_on_conflict='IGNORE')\n)\n```", "```py\nCREATE TABLE some_table (\n    id INTEGER NOT NULL,\n    data INTEGER,\n    PRIMARY KEY (id),\n    UNIQUE (id, data) ON CONFLICT IGNORE\n)\n```", "```py\nsome_table = Table(\n    'some_table', metadata,\n    Column('id', Integer, primary_key=True),\n    Column('data', Integer, unique=True,\n           sqlite_on_conflict_unique='IGNORE')\n)\n```", "```py\nCREATE TABLE some_table (\n    id INTEGER NOT NULL,\n    data INTEGER,\n    PRIMARY KEY (id),\n    UNIQUE (data) ON CONFLICT IGNORE\n)\n```", "```py\nsome_table = Table(\n    'some_table', metadata,\n    Column('id', Integer, primary_key=True),\n    Column('data', Integer, nullable=False,\n           sqlite_on_conflict_not_null='FAIL')\n)\n```", "```py\nCREATE TABLE some_table (\n    id INTEGER NOT NULL,\n    data INTEGER NOT NULL ON CONFLICT FAIL,\n    PRIMARY KEY (id)\n)\n```", "```py\nsome_table = Table(\n    'some_table', metadata,\n    Column('id', Integer, primary_key=True,\n           sqlite_on_conflict_primary_key='FAIL')\n)\n```", "```py\nCREATE TABLE some_table (\n    id INTEGER NOT NULL,\n    PRIMARY KEY (id) ON CONFLICT FAIL\n)\n```", "```py\n>>> from sqlalchemy.dialects.sqlite import insert\n\n>>> insert_stmt = insert(my_table).values(\n...     id='some_existing_id',\n...     data='inserted value')\n\n>>> do_update_stmt = insert_stmt.on_conflict_do_update(\n...     index_elements=['id'],\n...     set_=dict(data='updated value')\n... )\n\n>>> print(do_update_stmt)\nINSERT  INTO  my_table  (id,  data)  VALUES  (?,  ?)\nON  CONFLICT  (id)  DO  UPDATE  SET  data  =  ?\n>>> do_nothing_stmt = insert_stmt.on_conflict_do_nothing(\n...     index_elements=['id']\n... )\n\n>>> print(do_nothing_stmt)\nINSERT  INTO  my_table  (id,  data)  VALUES  (?,  ?)\nON  CONFLICT  (id)  DO  NOTHING \n```", "```py\n    >>> stmt = insert(my_table).values(user_email='a@b.com', data='inserted data')\n\n    >>> do_update_stmt = stmt.on_conflict_do_update(\n    ...     index_elements=[my_table.c.user_email],\n    ...     index_where=my_table.c.user_email.like('%@gmail.com'),\n    ...     set_=dict(data=stmt.excluded.data)\n    ...     )\n\n    >>> print(do_update_stmt)\n    INSERT  INTO  my_table  (data,  user_email)  VALUES  (?,  ?)\n    ON  CONFLICT  (user_email)\n    WHERE  user_email  LIKE  '%@gmail.com'\n    DO  UPDATE  SET  data  =  excluded.data \n    ```", "```py\n>>> stmt = insert(my_table).values(id='some_id', data='inserted value')\n\n>>> do_update_stmt = stmt.on_conflict_do_update(\n...     index_elements=['id'],\n...     set_=dict(data='updated value')\n... )\n\n>>> print(do_update_stmt)\nINSERT  INTO  my_table  (id,  data)  VALUES  (?,  ?)\nON  CONFLICT  (id)  DO  UPDATE  SET  data  =  ? \n```", "```py\n>>> stmt = insert(my_table).values(\n...     id='some_id',\n...     data='inserted value',\n...     author='jlh'\n... )\n\n>>> do_update_stmt = stmt.on_conflict_do_update(\n...     index_elements=['id'],\n...     set_=dict(data='updated value', author=stmt.excluded.author)\n... )\n\n>>> print(do_update_stmt)\nINSERT  INTO  my_table  (id,  data,  author)  VALUES  (?,  ?,  ?)\nON  CONFLICT  (id)  DO  UPDATE  SET  data  =  ?,  author  =  excluded.author \n```", "```py\n>>> stmt = insert(my_table).values(\n...     id='some_id',\n...     data='inserted value',\n...     author='jlh'\n... )\n\n>>> on_update_stmt = stmt.on_conflict_do_update(\n...     index_elements=['id'],\n...     set_=dict(data='updated value', author=stmt.excluded.author),\n...     where=(my_table.c.status == 2)\n... )\n>>> print(on_update_stmt)\nINSERT  INTO  my_table  (id,  data,  author)  VALUES  (?,  ?,  ?)\nON  CONFLICT  (id)  DO  UPDATE  SET  data  =  ?,  author  =  excluded.author\nWHERE  my_table.status  =  ? \n```", "```py\n>>> stmt = insert(my_table).values(id='some_id', data='inserted value')\n>>> stmt = stmt.on_conflict_do_nothing(index_elements=['id'])\n>>> print(stmt)\nINSERT  INTO  my_table  (id,  data)  VALUES  (?,  ?)  ON  CONFLICT  (id)  DO  NOTHING \n```", "```py\n>>> stmt = insert(my_table).values(id='some_id', data='inserted value')\n>>> stmt = stmt.on_conflict_do_nothing()\n>>> print(stmt)\nINSERT  INTO  my_table  (id,  data)  VALUES  (?,  ?)  ON  CONFLICT  DO  NOTHING \n```", "```py\n    >>> stmt = insert(my_table).values(user_email='a@b.com', data='inserted data')\n\n    >>> do_update_stmt = stmt.on_conflict_do_update(\n    ...     index_elements=[my_table.c.user_email],\n    ...     index_where=my_table.c.user_email.like('%@gmail.com'),\n    ...     set_=dict(data=stmt.excluded.data)\n    ...     )\n\n    >>> print(do_update_stmt)\n    INSERT  INTO  my_table  (data,  user_email)  VALUES  (?,  ?)\n    ON  CONFLICT  (user_email)\n    WHERE  user_email  LIKE  '%@gmail.com'\n    DO  UPDATE  SET  data  =  excluded.data \n    ```", "```py\n>>> stmt = insert(my_table).values(id='some_id', data='inserted value')\n\n>>> do_update_stmt = stmt.on_conflict_do_update(\n...     index_elements=['id'],\n...     set_=dict(data='updated value')\n... )\n\n>>> print(do_update_stmt)\nINSERT  INTO  my_table  (id,  data)  VALUES  (?,  ?)\nON  CONFLICT  (id)  DO  UPDATE  SET  data  =  ? \n```", "```py\n>>> stmt = insert(my_table).values(\n...     id='some_id',\n...     data='inserted value',\n...     author='jlh'\n... )\n\n>>> do_update_stmt = stmt.on_conflict_do_update(\n...     index_elements=['id'],\n...     set_=dict(data='updated value', author=stmt.excluded.author)\n... )\n\n>>> print(do_update_stmt)\nINSERT  INTO  my_table  (id,  data,  author)  VALUES  (?,  ?,  ?)\nON  CONFLICT  (id)  DO  UPDATE  SET  data  =  ?,  author  =  excluded.author \n```", "```py\n>>> stmt = insert(my_table).values(\n...     id='some_id',\n...     data='inserted value',\n...     author='jlh'\n... )\n\n>>> on_update_stmt = stmt.on_conflict_do_update(\n...     index_elements=['id'],\n...     set_=dict(data='updated value', author=stmt.excluded.author),\n...     where=(my_table.c.status == 2)\n... )\n>>> print(on_update_stmt)\nINSERT  INTO  my_table  (id,  data,  author)  VALUES  (?,  ?,  ?)\nON  CONFLICT  (id)  DO  UPDATE  SET  data  =  ?,  author  =  excluded.author\nWHERE  my_table.status  =  ? \n```", "```py\n>>> stmt = insert(my_table).values(id='some_id', data='inserted value')\n>>> stmt = stmt.on_conflict_do_nothing(index_elements=['id'])\n>>> print(stmt)\nINSERT  INTO  my_table  (id,  data)  VALUES  (?,  ?)  ON  CONFLICT  (id)  DO  NOTHING \n```", "```py\n>>> stmt = insert(my_table).values(id='some_id', data='inserted value')\n>>> stmt = stmt.on_conflict_do_nothing()\n>>> print(stmt)\nINSERT  INTO  my_table  (id,  data)  VALUES  (?,  ?)  ON  CONFLICT  DO  NOTHING \n```", "```py\ntbl = Table('testtbl', m, Column('data', Integer))\nidx = Index('test_idx1', tbl.c.data,\n            sqlite_where=and_(tbl.c.data > 5, tbl.c.data < 10))\n```", "```py\nCREATE INDEX test_idx1 ON testtbl (data)\nWHERE data > 5 AND data < 10\n```", "```py\nimport sqlite3\n\nassert sqlite3.sqlite_version_info < (3, 10, 0), \"bug is fixed in this version\"\n\nconn = sqlite3.connect(\":memory:\")\ncursor = conn.cursor()\n\ncursor.execute(\"create table x (a integer, b integer)\")\ncursor.execute(\"insert into x (a, b) values (1, 1)\")\ncursor.execute(\"insert into x (a, b) values (2, 2)\")\n\ncursor.execute(\"select x.a, x.b from x\")\nassert [c[0] for c in cursor.description] == ['a', 'b']\n\ncursor.execute('''\n select x.a, x.b from x where a=1\n union\n select x.a, x.b from x where a=2\n''')\nassert [c[0] for c in cursor.description] == ['a', 'b'], \\\n    [c[0] for c in cursor.description]\n```", "```py\nTraceback (most recent call last):\n  File \"test.py\", line 19, in <module>\n    [c[0] for c in cursor.description]\nAssertionError: ['x.a', 'x.b']\n```", "```py\nfrom sqlalchemy import create_engine\n\neng = create_engine(\"sqlite://\")\nconn = eng.connect()\n\nconn.exec_driver_sql(\"create table x (a integer, b integer)\")\nconn.exec_driver_sql(\"insert into x (a, b) values (1, 1)\")\nconn.exec_driver_sql(\"insert into x (a, b) values (2, 2)\")\n\nresult = conn.exec_driver_sql(\"select x.a, x.b from x\")\nassert result.keys() == [\"a\", \"b\"]\n\nresult = conn.exec_driver_sql('''\n select x.a, x.b from x where a=1\n union\n select x.a, x.b from x where a=2\n''')\nassert result.keys() == [\"a\", \"b\"]\n```", "```py\n>>> row = result.first()\n>>> row[\"a\"]\n1\n>>> row[\"x.a\"]\n1\n>>> row[\"b\"]\n1\n>>> row[\"x.b\"]\n1\n```", "```py\nresult = conn.execution_options(sqlite_raw_colnames=True).exec_driver_sql('''\n select x.a, x.b from x where a=1\n union\n select x.a, x.b from x where a=2\n''')\nassert result.keys() == [\"x.a\", \"x.b\"]\n```", "```py\nengine = create_engine(\"sqlite://\", execution_options={\"sqlite_raw_colnames\": True})\n```", "```py\n    Table(\"some_table\", metadata, ..., sqlite_with_rowid=False)\n    ```", "```py\nfrom sqlalchemy.dialects.sqlite import (\n    BLOB,\n    BOOLEAN,\n    CHAR,\n    DATE,\n    DATETIME,\n    DECIMAL,\n    FLOAT,\n    INTEGER,\n    NUMERIC,\n    JSON,\n    SMALLINT,\n    TEXT,\n    TIME,\n    TIMESTAMP,\n    VARCHAR,\n)\n```", "```py\nclass sqlalchemy.dialects.sqlite.DATETIME\n```", "```py\n\"%(year)04d-%(month)02d-%(day)02d  %(hour)02d:%(minute)02d:%(second)02d.%(microsecond)06d\"\n```", "```py\n2021-03-15 12:05:57.105542\n```", "```py\nimport re\nfrom sqlalchemy.dialects.sqlite import DATETIME\n\ndt = DATETIME(storage_format=\"%(year)04d/%(month)02d/%(day)02d \"\n                             \"%(hour)02d:%(minute)02d:%(second)02d\",\n              regexp=r\"(\\d+)/(\\d+)/(\\d+) (\\d+)-(\\d+)-(\\d+)\"\n)\n```", "```py\nclass sqlalchemy.dialects.sqlite.DATE\n```", "```py\n\"%(year)04d-%(month)02d-%(day)02d\"\n```", "```py\n2011-03-15\n```", "```py\nimport re\nfrom sqlalchemy.dialects.sqlite import DATE\n\nd = DATE(\n        storage_format=\"%(month)02d/%(day)02d/%(year)04d\",\n        regexp=re.compile(\"(?P<month>\\d+)/(?P<day>\\d+)/(?P<year>\\d+)\")\n    )\n```", "```py\nclass sqlalchemy.dialects.sqlite.JSON\n```", "```py\nmethod __init__(none_as_null: bool = False)\n```", "```py\nfrom sqlalchemy import null\nconn.execute(table.insert(), {\"data\": null()})\n```", "```py\nclass sqlalchemy.dialects.sqlite.TIME\n```", "```py\n\"%(hour)02d:%(minute)02d:%(second)02d.%(microsecond)06d\"\n```", "```py\n12:05:57.10558\n```", "```py\nimport re\nfrom sqlalchemy.dialects.sqlite import TIME\n\nt = TIME(storage_format=\"%(hour)02d-%(minute)02d-\"\n                        \"%(second)02d-%(microsecond)06d\",\n         regexp=re.compile(\"(\\d+)-(\\d+)-(\\d+)-(?:-(\\d+))?\")\n)\n```", "```py\nfunction sqlalchemy.dialects.sqlite.insert(table: _DMLTableArgument) \u2192 Insert\n```", "```py\nclass sqlalchemy.dialects.sqlite.Insert\n```", "```py\nattribute excluded\n```", "```py\nattribute inherit_cache: bool | None = False\n```", "```py\nmethod on_conflict_do_nothing(index_elements: _OnConflictIndexElementsT = None, index_where: _OnConflictIndexWhereT = None) \u2192 Self\n```", "```py\nmethod on_conflict_do_update(index_elements: _OnConflictIndexElementsT = None, index_where: _OnConflictIndexWhereT = None, set_: _OnConflictSetT = None, where: _OnConflictWhereT = None) \u2192 Self\n```", "```py\nsqlite+pysqlite:///file_path\n```", "```py\ndriver://user:pass@host/database\n```", "```py\n# relative path\ne = create_engine('sqlite:///path/to/database.db')\n```", "```py\n# absolute path\ne = create_engine('sqlite:////path/to/database.db')\n```", "```py\n# absolute path on Windows\ne = create_engine('sqlite:///C:\\\\path\\\\to\\\\database.db')\n```", "```py\n# in-memory database\ne = create_engine('sqlite://:memory:')\n# also in-memory database\ne2 = create_engine('sqlite://')\n```", "```py\ne = create_engine(\"sqlite:///file:path/to/database?mode=ro&uri=true\")\n```", "```py\ne = create_engine(\n    \"sqlite:///file:path/to/database?\"\n    \"check_same_thread=true&timeout=10&mode=ro&nolock=1&uri=true\"\n)\n```", "```py\nsqlite3.connect(\n    \"file:path/to/database?mode=ro&nolock=1\",\n    check_same_thread=True, timeout=10, uri=True\n)\n```", "```py\ndef regexp(a, b):\n    return re.search(a, b) is not None\n\nsqlite_connection.create_function(\n    \"regexp\", 2, regexp,\n)\n```", "```py\nengine = create_engine('sqlite://',\n    connect_args={'detect_types':\n        sqlite3.PARSE_DECLTYPES|sqlite3.PARSE_COLNAMES},\n    native_datetime=True\n)\n```", "```py\nfrom sqlalchemy import NullPool\nengine = create_engine(\"sqlite:///myfile.db\", poolclass=NullPool)\n```", "```py\nfrom sqlalchemy.pool import StaticPool\nengine = create_engine('sqlite://',\n                    connect_args={'check_same_thread':False},\n                    poolclass=StaticPool)\n```", "```py\n# maintain the same connection per thread\nfrom sqlalchemy.pool import SingletonThreadPool\nengine = create_engine('sqlite:///mydb.db',\n                    poolclass=SingletonThreadPool)\n\n# maintain the same connection across all threads\nfrom sqlalchemy.pool import StaticPool\nengine = create_engine('sqlite:///mydb.db',\n                    poolclass=StaticPool)\n```", "```py\nfrom sqlalchemy import String\nfrom sqlalchemy import TypeDecorator\n\nclass MixedBinary(TypeDecorator):\n    impl = String\n    cache_ok = True\n\n    def process_result_value(self, value, dialect):\n        if isinstance(value, str):\n            value = bytes(value, 'utf-8')\n        elif value is not None:\n            value = bytes(value)\n\n        return value\n```", "```py\nfrom sqlalchemy import create_engine, event\n\nengine = create_engine(\"sqlite:///myfile.db\")\n\n@event.listens_for(engine, \"connect\")\ndef do_connect(dbapi_connection, connection_record):\n    # disable pysqlite's emitting of the BEGIN statement entirely.\n    # also stops it from emitting COMMIT before any DDL.\n    dbapi_connection.isolation_level = None\n\n@event.listens_for(engine, \"begin\")\ndef do_begin(conn):\n    # emit our own BEGIN\n    conn.exec_driver_sql(\"BEGIN\")\n```", "```py\n@event.listens_for(engine, \"begin\")\ndef do_begin(conn):\n    conn.exec_driver_sql(\"BEGIN EXCLUSIVE\")\n```", "```py\nfrom sqlalchemy import create_engine\nfrom sqlalchemy import event\nfrom sqlalchemy import text\n\ndef udf():\n    return \"udf-ok\"\n\nengine = create_engine(\"sqlite:///./db_file\")\n\n@event.listens_for(engine, \"connect\")\ndef connect(conn, rec):\n    conn.create_function(\"udf\", 0, udf)\n\nfor i in range(5):\n    with engine.connect() as conn:\n        print(conn.scalar(text(\"SELECT UDF()\")))\n```", "```py\nsqlite+pysqlite:///file_path\n```", "```py\ndriver://user:pass@host/database\n```", "```py\n# relative path\ne = create_engine('sqlite:///path/to/database.db')\n```", "```py\n# absolute path\ne = create_engine('sqlite:////path/to/database.db')\n```", "```py\n# absolute path on Windows\ne = create_engine('sqlite:///C:\\\\path\\\\to\\\\database.db')\n```", "```py\n# in-memory database\ne = create_engine('sqlite://:memory:')\n# also in-memory database\ne2 = create_engine('sqlite://')\n```", "```py\ne = create_engine(\"sqlite:///file:path/to/database?mode=ro&uri=true\")\n```", "```py\ne = create_engine(\n    \"sqlite:///file:path/to/database?\"\n    \"check_same_thread=true&timeout=10&mode=ro&nolock=1&uri=true\"\n)\n```", "```py\nsqlite3.connect(\n    \"file:path/to/database?mode=ro&nolock=1\",\n    check_same_thread=True, timeout=10, uri=True\n)\n```", "```py\ne = create_engine(\"sqlite:///file:path/to/database?mode=ro&uri=true\")\n```", "```py\ne = create_engine(\n    \"sqlite:///file:path/to/database?\"\n    \"check_same_thread=true&timeout=10&mode=ro&nolock=1&uri=true\"\n)\n```", "```py\nsqlite3.connect(\n    \"file:path/to/database?mode=ro&nolock=1\",\n    check_same_thread=True, timeout=10, uri=True\n)\n```", "```py\ndef regexp(a, b):\n    return re.search(a, b) is not None\n\nsqlite_connection.create_function(\n    \"regexp\", 2, regexp,\n)\n```", "```py\nengine = create_engine('sqlite://',\n    connect_args={'detect_types':\n        sqlite3.PARSE_DECLTYPES|sqlite3.PARSE_COLNAMES},\n    native_datetime=True\n)\n```", "```py\nfrom sqlalchemy import NullPool\nengine = create_engine(\"sqlite:///myfile.db\", poolclass=NullPool)\n```", "```py\nfrom sqlalchemy.pool import StaticPool\nengine = create_engine('sqlite://',\n                    connect_args={'check_same_thread':False},\n                    poolclass=StaticPool)\n```", "```py\n# maintain the same connection per thread\nfrom sqlalchemy.pool import SingletonThreadPool\nengine = create_engine('sqlite:///mydb.db',\n                    poolclass=SingletonThreadPool)\n\n# maintain the same connection across all threads\nfrom sqlalchemy.pool import StaticPool\nengine = create_engine('sqlite:///mydb.db',\n                    poolclass=StaticPool)\n```", "```py\nfrom sqlalchemy import NullPool\nengine = create_engine(\"sqlite:///myfile.db\", poolclass=NullPool)\n```", "```py\nfrom sqlalchemy.pool import StaticPool\nengine = create_engine('sqlite://',\n                    connect_args={'check_same_thread':False},\n                    poolclass=StaticPool)\n```", "```py\n# maintain the same connection per thread\nfrom sqlalchemy.pool import SingletonThreadPool\nengine = create_engine('sqlite:///mydb.db',\n                    poolclass=SingletonThreadPool)\n\n# maintain the same connection across all threads\nfrom sqlalchemy.pool import StaticPool\nengine = create_engine('sqlite:///mydb.db',\n                    poolclass=StaticPool)\n```", "```py\nfrom sqlalchemy import String\nfrom sqlalchemy import TypeDecorator\n\nclass MixedBinary(TypeDecorator):\n    impl = String\n    cache_ok = True\n\n    def process_result_value(self, value, dialect):\n        if isinstance(value, str):\n            value = bytes(value, 'utf-8')\n        elif value is not None:\n            value = bytes(value)\n\n        return value\n```", "```py\nfrom sqlalchemy import create_engine, event\n\nengine = create_engine(\"sqlite:///myfile.db\")\n\n@event.listens_for(engine, \"connect\")\ndef do_connect(dbapi_connection, connection_record):\n    # disable pysqlite's emitting of the BEGIN statement entirely.\n    # also stops it from emitting COMMIT before any DDL.\n    dbapi_connection.isolation_level = None\n\n@event.listens_for(engine, \"begin\")\ndef do_begin(conn):\n    # emit our own BEGIN\n    conn.exec_driver_sql(\"BEGIN\")\n```", "```py\n@event.listens_for(engine, \"begin\")\ndef do_begin(conn):\n    conn.exec_driver_sql(\"BEGIN EXCLUSIVE\")\n```", "```py\nfrom sqlalchemy import create_engine\nfrom sqlalchemy import event\nfrom sqlalchemy import text\n\ndef udf():\n    return \"udf-ok\"\n\nengine = create_engine(\"sqlite:///./db_file\")\n\n@event.listens_for(engine, \"connect\")\ndef connect(conn, rec):\n    conn.create_function(\"udf\", 0, udf)\n\nfor i in range(5):\n    with engine.connect() as conn:\n        print(conn.scalar(text(\"SELECT UDF()\")))\n```", "```py\nsqlite+aiosqlite:///file_path\n```", "```py\nfrom sqlalchemy.ext.asyncio import create_async_engine\nengine = create_async_engine(\"sqlite+aiosqlite:///filename\")\n```", "```py\nfrom sqlalchemy import create_engine, event\nfrom sqlalchemy.ext.asyncio import create_async_engine\n\nengine = create_async_engine(\"sqlite+aiosqlite:///myfile.db\")\n\n@event.listens_for(engine.sync_engine, \"connect\")\ndef do_connect(dbapi_connection, connection_record):\n    # disable aiosqlite's emitting of the BEGIN statement entirely.\n    # also stops it from emitting COMMIT before any DDL.\n    dbapi_connection.isolation_level = None\n\n@event.listens_for(engine.sync_engine, \"begin\")\ndef do_begin(conn):\n    # emit our own BEGIN\n    conn.exec_driver_sql(\"BEGIN\")\n```", "```py\nsqlite+aiosqlite:///file_path\n```", "```py\nfrom sqlalchemy import create_engine, event\nfrom sqlalchemy.ext.asyncio import create_async_engine\n\nengine = create_async_engine(\"sqlite+aiosqlite:///myfile.db\")\n\n@event.listens_for(engine.sync_engine, \"connect\")\ndef do_connect(dbapi_connection, connection_record):\n    # disable aiosqlite's emitting of the BEGIN statement entirely.\n    # also stops it from emitting COMMIT before any DDL.\n    dbapi_connection.isolation_level = None\n\n@event.listens_for(engine.sync_engine, \"begin\")\ndef do_begin(conn):\n    # emit our own BEGIN\n    conn.exec_driver_sql(\"BEGIN\")\n```", "```py\nsqlite+pysqlcipher://:passphrase@/file_path[?kdf_iter=<iter>]\n```", "```py\nimport sqlcipher_compatible_driver\n\nfrom sqlalchemy import create_engine\n\ne = create_engine(\n    \"sqlite+pysqlcipher://:password@/dbname.db\",\n    module=sqlcipher_compatible_driver\n)\n```", "```py\ne = create_engine('sqlite+pysqlcipher://:testing@/foo.db')\n```", "```py\ne = create_engine('sqlite+pysqlcipher://:testing@//path/to/foo.db')\n```", "```py\ne = create_engine('sqlite+pysqlcipher://:testing@/foo.db?cipher=aes-256-cfb&kdf_iter=64000')\n```", "```py\nsqlite+pysqlcipher://:passphrase@/file_path[?kdf_iter=<iter>]\n```", "```py\nimport sqlcipher_compatible_driver\n\nfrom sqlalchemy import create_engine\n\ne = create_engine(\n    \"sqlite+pysqlcipher://:password@/dbname.db\",\n    module=sqlcipher_compatible_driver\n)\n```", "```py\ne = create_engine('sqlite+pysqlcipher://:testing@/foo.db')\n```", "```py\ne = create_engine('sqlite+pysqlcipher://:testing@//path/to/foo.db')\n```", "```py\ne = create_engine('sqlite+pysqlcipher://:testing@/foo.db?cipher=aes-256-cfb&kdf_iter=64000')\n```"]