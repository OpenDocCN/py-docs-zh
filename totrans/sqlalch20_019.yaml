- en: Table Configuration with Declarative
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.sqlalchemy.org/en/20/orm/declarative_tables.html](https://docs.sqlalchemy.org/en/20/orm/declarative_tables.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: As introduced at [Declarative Mapping](mapping_styles.html#orm-declarative-mapping),
    the Declarative style includes the ability to generate a mapped [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") object at the same time, or to accommodate a [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") or other [`FromClause`](../core/selectable.html#sqlalchemy.sql.expression.FromClause
    "sqlalchemy.sql.expression.FromClause") object directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following examples assume a declarative base class as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: All of the examples that follow illustrate a class inheriting from the above
    `Base`. The decorator style introduced at [Declarative Mapping using a Decorator
    (no declarative base)](declarative_styles.html#orm-declarative-decorator) is fully
    supported with all the following examples as well, as are legacy forms of Declarative
    Base including base classes generated by [`declarative_base()`](mapping_api.html#sqlalchemy.orm.declarative_base
    "sqlalchemy.orm.declarative_base").
  prefs: []
  type: TYPE_NORMAL
- en: '## Declarative Table with `mapped_column()`'
  prefs: []
  type: TYPE_NORMAL
- en: 'When using Declarative, the body of the class to be mapped in most cases includes
    an attribute `__tablename__` that indicates the string name of a [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") that should be generated along with the mapping. The
    [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    construct, which features additional ORM-specific configuration capabilities not
    present in the plain [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") class, is then used within the class body to indicate
    columns in the table. The example below illustrates the most basic use of this
    construct within a Declarative mapping:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Above, [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    constructs are placed inline within the class definition as class level attributes.
    At the point at which the class is declared, the Declarative mapping process will
    generate a new [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    object against the [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") collection associated with the Declarative `Base`;
    each instance of [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") will then be used to generate a [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") object during this process, which will become part
    of the [`Table.columns`](../core/metadata.html#sqlalchemy.schema.Table.columns
    "sqlalchemy.schema.Table.columns") collection of this [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") object.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the above example, Declarative will build a [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") construct that is equivalent to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: When the `User` class above is mapped, this [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") object can be accessed directly via the `__table__`
    attribute; this is described further at [Accessing Table and Metadata](#orm-declarative-metadata).
  prefs: []
  type: TYPE_NORMAL
- en: The [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    construct accepts all arguments that are accepted by the [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") construct, as well as additional ORM-specific arguments.
    The [`mapped_column.__name`](mapping_api.html#sqlalchemy.orm.mapped_column.params.__name
    "sqlalchemy.orm.mapped_column") field, indicating the name of the database column,
    is typically omitted, as the Declarative process will make use of the attribute
    name given to the construct and assign this as the name of the column (in the
    above example, this refers to the names `id`, `name`, `fullname`, `nickname`).
    Assigning an alternate [`mapped_column.__name`](mapping_api.html#sqlalchemy.orm.mapped_column.params.__name
    "sqlalchemy.orm.mapped_column") is valid as well, where the resulting [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") will use the given name in SQL and DDL statements,
    while the `User` mapped class will continue to allow access to the attribute using
    the attribute name given, independent of the name given to the column itself (more
    on this at [Naming Declarative Mapped Columns Explicitly](#mapper-column-distinct-names)).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: The [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    construct is **only valid within a Declarative class mapping**. When constructing
    a [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    object using Core as well as when using [imperative table](#orm-imperative-table-configuration)
    configuration, the [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    construct is still required in order to indicate the presence of a database column.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Mapping Table Columns](mapping_columns.html) - contains additional notes on
    affecting how [`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper "sqlalchemy.orm.Mapper")
    interprets incoming [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects.'
  prefs: []
  type: TYPE_NORMAL
- en: '### Using Annotated Declarative Table (Type Annotated Forms for `mapped_column()`)'
  prefs: []
  type: TYPE_NORMAL
- en: The [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    construct is capable of deriving its column-configuration information from [**PEP
    484**](https://peps.python.org/pep-0484/) type annotations associated with the
    attribute as declared in the Declarative mapped class. These type annotations,
    if used, **must** be present within a special SQLAlchemy type called [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped"), which is a [generic](https://peps.python.org/pep-0484/#generics)
    type that then indicates a specific Python type within it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Below illustrates the mapping from the previous section, adding the use of
    [`Mapped`](internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Above, when Declarative processes each class attribute, each [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") will derive additional arguments from the corresponding
    [`Mapped`](internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped") type
    annotation on the left side, if present. Additionally, Declarative will generate
    an empty [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    directive implicitly, whenever a [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") type annotation is encountered that does not have a value
    assigned to the attribute (this form is inspired by the similar style used in
    Python [dataclasses](https://docs.python.org/3/library/dataclasses.html)); this
    [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    construct proceeds to derive its configuration from the [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") annotation present.
  prefs: []
  type: TYPE_NORMAL
- en: '#### `mapped_column()` derives the datatype and nullability from the `Mapped`
    annotation'
  prefs: []
  type: TYPE_NORMAL
- en: 'The two qualities that [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") derives from the [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") annotation are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**datatype** - the Python type given inside [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped"), as contained within the `typing.Optional` construct
    if present, is associated with a [`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") subclass such as [`Integer`](../core/type_basics.html#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer"), [`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String"), [`DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime
    "sqlalchemy.types.DateTime"), or [`Uuid`](../core/type_basics.html#sqlalchemy.types.Uuid
    "sqlalchemy.types.Uuid"), to name a few common types.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The datatype is determined based on a dictionary of Python type to SQLAlchemy
    datatype. This dictionary is completely customizable, as detailed in the next
    section [Customizing the Type Map](#orm-declarative-mapped-column-type-map). The
    default type map is implemented as in the code example below:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If the [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    construct indicates an explicit type as passed to the [`mapped_column.__type`](mapping_api.html#sqlalchemy.orm.mapped_column.params.__type
    "sqlalchemy.orm.mapped_column") argument, then the given Python type is disregarded.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**nullability** - The [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct will indicate its [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") as `NULL` or `NOT NULL` first and foremost by the
    presence of the [`mapped_column.nullable`](mapping_api.html#sqlalchemy.orm.mapped_column.params.nullable
    "sqlalchemy.orm.mapped_column") parameter, passed either as `True` or `False`.
    Additionally , if the [`mapped_column.primary_key`](mapping_api.html#sqlalchemy.orm.mapped_column.params.primary_key
    "sqlalchemy.orm.mapped_column") parameter is present and set to `True`, that will
    also imply that the column should be `NOT NULL`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the absence of **both** of these parameters, the presence of `typing.Optional[]`
    within the [`Mapped`](internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped")
    type annotation will be used to determine nullability, where `typing.Optional[]`
    means `NULL`, and the absence of `typing.Optional[]` means `NOT NULL`. If there
    is no `Mapped[]` annotation present at all, and there is no [`mapped_column.nullable`](mapping_api.html#sqlalchemy.orm.mapped_column.params.nullable
    "sqlalchemy.orm.mapped_column") or [`mapped_column.primary_key`](mapping_api.html#sqlalchemy.orm.mapped_column.params.primary_key
    "sqlalchemy.orm.mapped_column") parameter, then SQLAlchemy’s usual default for
    [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    of `NULL` is used.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the example below, the `id` and `data` columns will be `NOT NULL`, and the
    `additional_info` column will be `NULL`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'It is also perfectly valid to have a [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") whose nullability is **different** from what would
    be implied by the annotation. For example, an ORM mapped attribute may be annotated
    as allowing `None` within Python code that works with the object as it is first
    being created and populated, however the value will ultimately be written to a
    database column that is `NOT NULL`. The [`mapped_column.nullable`](mapping_api.html#sqlalchemy.orm.mapped_column.params.nullable
    "sqlalchemy.orm.mapped_column") parameter, when present, will always take precedence:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Similarly, a non-None attribute that’s written to a database column that for
    whatever reason needs to be NULL at the schema level, [`mapped_column.nullable`](mapping_api.html#sqlalchemy.orm.mapped_column.params.nullable
    "sqlalchemy.orm.mapped_column") may be set to `True`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]  #### Customizing the Type Map'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The mapping of Python types to SQLAlchemy [`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") types described in the previous section defaults
    to a hardcoded dictionary present in the `sqlalchemy.sql.sqltypes` module. However,
    the [`registry`](mapping_api.html#sqlalchemy.orm.registry "sqlalchemy.orm.registry")
    object that coordinates the Declarative mapping process will first consult a local,
    user defined dictionary of types which may be passed as the [`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry") parameter when constructing the [`registry`](mapping_api.html#sqlalchemy.orm.registry
    "sqlalchemy.orm.registry"), which may be associated with the [`DeclarativeBase`](mapping_api.html#sqlalchemy.orm.DeclarativeBase
    "sqlalchemy.orm.DeclarativeBase") superclass when first used.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, if we wish to make use of the [`BIGINT`](../core/type_basics.html#sqlalchemy.types.BIGINT
    "sqlalchemy.types.BIGINT") datatype for `int`, the [`TIMESTAMP`](../core/type_basics.html#sqlalchemy.types.TIMESTAMP
    "sqlalchemy.types.TIMESTAMP") datatype with `timezone=True` for `datetime.datetime`,
    and then only on Microsoft SQL Server we’d like to use [`NVARCHAR`](../core/type_basics.html#sqlalchemy.types.NVARCHAR
    "sqlalchemy.types.NVARCHAR") datatype when Python `str` is used, the registry
    and Declarative base could be configured as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Below illustrates the CREATE TABLE statement generated for the above mapping,
    first on the Microsoft SQL Server backend, illustrating the `NVARCHAR` datatype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Then on the PostgreSQL backend, illustrating `TIMESTAMP WITH TIME ZONE`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'By making use of methods such as [`TypeEngine.with_variant()`](../core/type_api.html#sqlalchemy.types.TypeEngine.with_variant
    "sqlalchemy.types.TypeEngine.with_variant"), we’re able to build up a type map
    that’s customized to what we need for different backends, while still being able
    to use succinct annotation-only [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") configurations. There are two more levels of Python-type
    configurability available beyond this, described in the next two sections.  ####
    Mapping Multiple Type Configurations to Python Types'
  prefs: []
  type: TYPE_NORMAL
- en: As individual Python types may be associated with [`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") configurations of any variety by using the [`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry") parameter, an additional capability is the ability
    to associate a single Python type with different variants of a SQL type based
    on additional type qualifiers. One typical example of this is mapping the Python
    `str` datatype to `VARCHAR` SQL types of different lengths. Another is mapping
    different varieties of `decimal.Decimal` to differently sized `NUMERIC` columns.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python’s typing system provides a great way to add additional metadata to a
    Python type which is by using the [**PEP 593**](https://peps.python.org/pep-0593/)
    `Annotated` generic type, which allows additional information to be bundled along
    with a Python type. The [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct will correctly interpret an `Annotated`
    object by identity when resolving it in the [`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry"), as in the example below where we declare two variants
    of [`String`](../core/type_basics.html#sqlalchemy.types.String "sqlalchemy.types.String")
    and [`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric "sqlalchemy.types.Numeric"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The Python type passed to the `Annotated` container, in the above example the
    `str` and `Decimal` types, is important only for the benefit of typing tools;
    as far as the [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct is concerned, it will only need perform
    a lookup of each type object in the [`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry") dictionary without actually looking inside of the `Annotated`
    object, at least in this particular context. Similarly, the arguments passed to
    `Annotated` beyond the underlying Python type itself are also not important, it’s
    only that at least one argument must be present for the `Annotated` construct
    to be valid. We can then use these augmented types directly in our mapping where
    they will be matched to the more specific type constructions, as in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'a CREATE TABLE for the above mapping will illustrate the different variants
    of `VARCHAR` and `NUMERIC` we’ve configured, and looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'While variety in linking `Annotated` types to different SQL types grants us
    a wide degree of flexibility, the next section illustrates a second way in which
    `Annotated` may be used with Declarative that is even more open ended.  #### Mapping
    Whole Column Declarations to Python Types'
  prefs: []
  type: TYPE_NORMAL
- en: The previous section illustrated using [**PEP 593**](https://peps.python.org/pep-0593/)
    `Annotated` type instances as keys within the [`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry") dictionary. In this form, the [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct does not actually look inside the `Annotated`
    object itself, it’s instead used only as a dictionary key. However, Declarative
    also has the ability to extract an entire pre-established [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct from an `Annotated` object directly.
    Using this form, we can define not only different varieties of SQL datatypes linked
    to Python types without using the [`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry") dictionary, we can also set up any number of arguments
    such as nullability, column defaults, and constraints in a reusable fashion.
  prefs: []
  type: TYPE_NORMAL
- en: A set of ORM models will usually have some kind of primary key style that is
    common to all mapped classes. There also may be common column configurations such
    as timestamps with defaults and other fields of pre-established sizes and configurations.
    We can compose these configurations into [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") instances that we then bundle directly into instances
    of `Annotated`, which are then re-used in any number of class declarations. Declarative
    will unpack an `Annotated` object when provided in this manner, skipping over
    any other directives that don’t apply to SQLAlchemy and searching only for SQLAlchemy
    ORM constructs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The example below illustrates a variety of pre-configured field types used
    in this way, where we define `intpk` that represents an [`Integer`](../core/type_basics.html#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer") primary key column, `timestamp` that represents a
    [`DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime "sqlalchemy.types.DateTime")
    type which will use `CURRENT_TIMESTAMP` as a DDL level column default, and `required_name`
    which is a [`String`](../core/type_basics.html#sqlalchemy.types.String "sqlalchemy.types.String")
    of length 30 that’s `NOT NULL`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The above `Annotated` objects can then be used directly within [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped"), where the pre-configured [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") constructs will be extracted and copied to a new
    instance that will be specific to each attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '`CREATE TABLE` for our above mapping looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'When using `Annotated` types in this way, the configuration of the type may
    also be affected on a per-attribute basis. For the types in the above example
    that feature explicit use of [`mapped_column.nullable`](mapping_api.html#sqlalchemy.orm.mapped_column.params.nullable
    "sqlalchemy.orm.mapped_column"), we can apply the `Optional[]` generic modifier
    to any of our types so that the field is optional or not at the Python level,
    which will be independent of the `NULL` / `NOT NULL` setting that takes place
    in the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    construct is also reconciled with an explicitly passed [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct, whose arguments will take precedence
    over those of the `Annotated` construct. Below we add a [`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey") constraint to our integer primary key and also
    use an alternate server default for the `created_at` column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The CREATE TABLE statement illustrates these per-attribute settings, adding
    a `FOREIGN KEY` constraint as well as substituting `UTC_TIMESTAMP` for `CURRENT_TIMESTAMP`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The feature of [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") just described, where a fully constructed set
    of column arguments may be indicated using [**PEP 593**](https://peps.python.org/pep-0593/)
    `Annotated` objects that contain a “template” [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") object to be copied into the attribute, is currently
    not implemented for other ORM constructs such as [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") and [`composite()`](composites.html#sqlalchemy.orm.composite
    "sqlalchemy.orm.composite"). While this functionality is in theory possible, for
    the moment attempting to use `Annotated` to indicate further arguments for [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") and similar will raise a `NotImplementedError`
    exception at runtime, but may be implemented in future releases.  #### Using Python
    `Enum` or pep-586 `Literal` types in the type map'
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 2.0.0b4: - Added `Enum` support'
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 2.0.1: - Added `Literal` support'
  prefs: []
  type: TYPE_NORMAL
- en: 'User-defined Python types which derive from the Python built-in `enum.Enum`
    as well as the `typing.Literal` class are automatically linked to the SQLAlchemy
    [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.types.Enum")
    datatype when used in an ORM declarative mapping. The example below uses a custom
    `enum.Enum` within the `Mapped[]` constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In the above example, the mapped attribute `SomeClass.status` will be linked
    to a [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    with the datatype of `Enum(Status)`. We can see this for example in the CREATE
    TABLE output for the PostgreSQL database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In a similar way, `typing.Literal` may be used instead, using a `typing.Literal`
    that consists of all strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The entries used in [`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry") link the base `enum.Enum` Python type as well as the
    `typing.Literal` type to the SQLAlchemy [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum") SQL type, using a special form which indicates to the
    [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.types.Enum")
    datatype that it should automatically configure itself against an arbitrary enumerated
    type. This configuration, which is implicit by default, would be indicated explicitly
    as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The resolution logic within Declarative is able to resolve subclasses of `enum.Enum`
    as well as instances of `typing.Literal` to match the `enum.Enum` or `typing.Literal`
    entry in the [`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry") dictionary. The [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum") SQL type then knows how to produce a configured version
    of itself with the appropriate settings, including default string length. If a
    `typing.Literal` that does not consist of only string values is passed, an informative
    error is raised.
  prefs: []
  type: TYPE_NORMAL
- en: Native Enums and Naming
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The [`Enum.native_enum`](../core/type_basics.html#sqlalchemy.types.Enum.params.native_enum
    "sqlalchemy.sql.sqltypes.Enum") parameter refers to if the [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.sql.sqltypes.Enum") datatype should create a so-called “native” enum,
    which on MySQL/MariaDB is the `ENUM` datatype and on PostgreSQL is a new `TYPE`
    object created by `CREATE TYPE`, or a “non-native” enum, which means that `VARCHAR`
    will be used to create the datatype. For backends other than MySQL/MariaDB or
    PostgreSQL, `VARCHAR` is used in all cases (third party dialects may have their
    own behaviors).
  prefs: []
  type: TYPE_NORMAL
- en: 'Because PostgreSQL’s `CREATE TYPE` requires that there’s an explicit name for
    the type to be created, special fallback logic exists when working with implicitly
    generated [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.sql.sqltypes.Enum")
    without specifying an explicit [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.sql.sqltypes.Enum") datatype within a mapping:'
  prefs: []
  type: TYPE_NORMAL
- en: If the [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.sql.sqltypes.Enum")
    is linked to an `enum.Enum` object, the [`Enum.native_enum`](../core/type_basics.html#sqlalchemy.types.Enum.params.native_enum
    "sqlalchemy.sql.sqltypes.Enum") parameter defaults to `True` and the name of the
    enum will be taken from the name of the `enum.Enum` datatype. The PostgreSQL backend
    will assume `CREATE TYPE` with this name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.sql.sqltypes.Enum")
    is linked to a `typing.Literal` object, the [`Enum.native_enum`](../core/type_basics.html#sqlalchemy.types.Enum.params.native_enum
    "sqlalchemy.sql.sqltypes.Enum") parameter defaults to `False`; no name is generated
    and `VARCHAR` is assumed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To use `typing.Literal` with a PostgreSQL `CREATE TYPE` type, an explicit [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.sql.sqltypes.Enum") must be used, either within the type map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Or alternatively within [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Altering the Configuration of the Default Enum
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In order to modify the fixed configuration of the `Enum` datatype that’s generated
    implicitly, specify new entries in the [`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry"), indicating additional arguments. For example, to use
    “non native enumerations” unconditionally, the [`Enum.native_enum`](../core/type_basics.html#sqlalchemy.types.Enum.params.native_enum
    "sqlalchemy.types.Enum") parameter may be set to False for all types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Changed in version 2.0.1: Implemented support for overriding parameters such
    as [`Enum.native_enum`](../core/type_basics.html#sqlalchemy.types.Enum.params.native_enum
    "sqlalchemy.types.Enum") within the [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum") datatype when establishing the [`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry"). Previously, this functionality was not working.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To use a specific configuration for a specific `enum.Enum` subtype, such as
    setting the string length to 50 when using the example `Status` datatype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'By default [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.types.Enum")
    that are automatically generated are not associated with the `MetaData` instance
    used by the `Base`, so if the metadata defines a schema it will not be automatically
    associated with the enum. To automatically associate the enum with the schema
    in the metadata or table they belong to the [`Enum.inherit_schema`](../core/type_basics.html#sqlalchemy.types.Enum.params.inherit_schema
    "sqlalchemy.types.Enum") can be set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Linking Specific `enum.Enum` or `typing.Literal` to other datatypes
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The above examples feature the use of an [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum") that is automatically configuring itself to the arguments
    / attributes present on an `enum.Enum` or `typing.Literal` type object. For use
    cases where specific kinds of `enum.Enum` or `typing.Literal` should be linked
    to other types, these specific types may be placed in the type map also. In the
    example below, an entry for `Literal[]` that contains non-string types is linked
    to the [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON")
    datatype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In the above configuration, the `my_literal` datatype will resolve to a [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON") instance. Other `Literal` variants will continue to resolve
    to [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.types.Enum")
    datatypes.
  prefs: []
  type: TYPE_NORMAL
- en: Dataclass features in `mapped_column()`
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    construct integrates with SQLAlchemy’s “native dataclasses” feature, discussed
    at [Declarative Dataclass Mapping](dataclasses.html#orm-declarative-native-dataclasses).
    See that section for current background on additional directives supported by
    [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column").  ###
    Accessing Table and Metadata'
  prefs: []
  type: TYPE_NORMAL
- en: 'A declaratively mapped class will always include an attribute called `__table__`;
    when the above configuration using `__tablename__` is complete, the declarative
    process makes the [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    available via the `__table__` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The above table is ultimately the same one that corresponds to the [`Mapper.local_table`](mapping_api.html#sqlalchemy.orm.Mapper.local_table
    "sqlalchemy.orm.Mapper.local_table") attribute, which we can see through the [runtime
    inspection system](../core/inspection.html):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData "sqlalchemy.schema.MetaData")
    collection associated with both the declarative [`registry`](mapping_api.html#sqlalchemy.orm.registry
    "sqlalchemy.orm.registry") as well as the base class is frequently necessary in
    order to run DDL operations such as CREATE, as well as in use with migration tools
    such as Alembic. This object is available via the `.metadata` attribute of [`registry`](mapping_api.html#sqlalchemy.orm.registry
    "sqlalchemy.orm.registry") as well as the declarative base class. Below, for a
    small script we may wish to emit a CREATE for all tables against a SQLite database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]  ### Declarative Table Configuration'
  prefs: []
  type: TYPE_NORMAL
- en: When using Declarative Table configuration with the `__tablename__` declarative
    class attribute, additional arguments to be supplied to the [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") constructor should be provided using the `__table_args__`
    declarative class attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'This attribute accommodates both positional as well as keyword arguments that
    are normally sent to the [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") constructor. The attribute can be specified in one
    of two forms. One is as a dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The other, a tuple, where each argument is positional (usually constraints):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Keyword arguments can be specified with the above form by specifying the last
    argument as a dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'A class may also specify the `__table_args__` declarative attribute, as well
    as the `__tablename__` attribute, in a dynamic style using the [`declared_attr()`](mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr") method decorator. See [Composing Mapped Hierarchies
    with Mixins](declarative_mixins.html) for background.  ### Explicit Schema Name
    with Declarative Table'
  prefs: []
  type: TYPE_NORMAL
- en: 'The schema name for a [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") as documented at [Specifying the Schema Name](../core/metadata.html#schema-table-schema-name)
    is applied to an individual [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") using the [`Table.schema`](../core/metadata.html#sqlalchemy.schema.Table.params.schema
    "sqlalchemy.schema.Table") argument. When using Declarative tables, this option
    is passed like any other to the `__table_args__` dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The schema name can also be applied to all [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects globally by using the [`MetaData.schema`](../core/metadata.html#sqlalchemy.schema.MetaData.params.schema
    "sqlalchemy.schema.MetaData") parameter documented at [Specifying a Default Schema
    Name with MetaData](../core/metadata.html#schema-metadata-schema-name). The [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") object may be constructed separately and associated
    with a [`DeclarativeBase`](mapping_api.html#sqlalchemy.orm.DeclarativeBase "sqlalchemy.orm.DeclarativeBase")
    subclass by assigning to the `metadata` attribute directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Specifying the Schema Name](../core/metadata.html#schema-table-schema-name)
    - in the [Describing Databases with MetaData](../core/metadata.html) documentation.  ###
    Setting Load and Persistence Options for Declarative Mapped Columns'
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    construct accepts additional ORM-specific arguments that affect how the generated
    [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    is mapped, affecting its load and persistence-time behavior. Options that are
    commonly used include:'
  prefs: []
  type: TYPE_NORMAL
- en: '**deferred column loading** - The [`mapped_column.deferred`](mapping_api.html#sqlalchemy.orm.mapped_column.params.deferred
    "sqlalchemy.orm.mapped_column") boolean establishes the [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") using [deferred column loading](queryguide/columns.html#orm-queryguide-column-deferral)
    by default. In the example below, the `User.bio` column will not be loaded by
    default, but only when accessed:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Limiting which Columns Load with Column Deferral](queryguide/columns.html#orm-queryguide-column-deferral)
    - full description of deferred column loading'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**active history** - The [`mapped_column.active_history`](mapping_api.html#sqlalchemy.orm.mapped_column.params.active_history
    "sqlalchemy.orm.mapped_column") ensures that upon change of value for the attribute,
    the previous value will have been loaded and made part of the [`AttributeState.history`](internals.html#sqlalchemy.orm.AttributeState.history
    "sqlalchemy.orm.AttributeState.history") collection when inspecting the history
    of the attribute. This may incur additional SQL statements:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: See the docstring for [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") for a list of supported parameters.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Applying Load, Persistence and Mapping Options for Imperative Table Columns](#orm-imperative-table-column-options)
    - describes using [`column_property()`](mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property") and [`deferred()`](queryguide/columns.html#sqlalchemy.orm.deferred
    "sqlalchemy.orm.deferred") for use with Imperative Table configuration  ### Naming
    Declarative Mapped Columns Explicitly'
  prefs: []
  type: TYPE_NORMAL
- en: 'All of the examples thus far feature the [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct linked to an ORM mapped attribute, where
    the Python attribute name given to the [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") is also that of the column as we see in CREATE
    TABLE statements as well as queries. The name for a column as expressed in SQL
    may be indicated by passing the string positional argument [`mapped_column.__name`](mapping_api.html#sqlalchemy.orm.mapped_column.params.__name
    "sqlalchemy.orm.mapped_column") as the first positional argument. In the example
    below, the `User` class is mapped with alternate names given to the columns themselves:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Where above `User.id` resolves to a column named `user_id` and `User.name`
    resolves to a column named `user_name`. We may write a [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") statement using our Python attribute names
    and will see the SQL names generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Alternate Attribute Names for Mapping Table Columns](#orm-imperative-table-column-naming)
    - applies to Imperative Table  ### Appending additional columns to an existing
    Declarative mapped class'
  prefs: []
  type: TYPE_NORMAL
- en: A declarative table configuration allows the addition of new [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects to an existing mapping after the [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") metadata has already been generated.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a declarative class that is declared using a declarative base class, the
    underlying metaclass `DeclarativeMeta` includes a `__setattr__()` method that
    will intercept additional [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") or Core [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects and add them to both the [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") using [`Table.append_column()`](../core/metadata.html#sqlalchemy.schema.Table.append_column
    "sqlalchemy.schema.Table.append_column") as well as to the existing [`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper") using [`Mapper.add_property()`](mapping_api.html#sqlalchemy.orm.Mapper.add_property
    "sqlalchemy.orm.Mapper.add_property"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Using core [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: All arguments are supported including an alternate name, such as `MyClass.some_new_column
    = mapped_column("some_name", String)`. However, the SQL type must be passed to
    the [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    or [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    object explicitly, as in the above examples where the [`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String") type is passed. There’s no capability for the [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") annotation type to take part in the operation.
  prefs: []
  type: TYPE_NORMAL
- en: Additional [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    objects may also be added to a mapping in the specific circumstance of using single
    table inheritance, where additional columns are present on mapped subclasses that
    have no [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    of their own. This is illustrated in the section [Single Table Inheritance](inheritance.html#single-inheritance).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Adding Relationships to Mapped Classes After Declaration](basic_relationships.html#orm-declarative-table-adding-relationship)
    - similar examples for [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Assignment of mapped properties to an already mapped class will only function
    correctly if the “declarative base” class is used, meaning the user-defined subclass
    of [`DeclarativeBase`](mapping_api.html#sqlalchemy.orm.DeclarativeBase "sqlalchemy.orm.DeclarativeBase")
    or the dynamically generated class returned by [`declarative_base()`](mapping_api.html#sqlalchemy.orm.declarative_base
    "sqlalchemy.orm.declarative_base") or [`registry.generate_base()`](mapping_api.html#sqlalchemy.orm.registry.generate_base
    "sqlalchemy.orm.registry.generate_base"). This “base” class includes a Python
    metaclass which implements a special `__setattr__()` method that intercepts these
    operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Runtime assignment of class-mapped attributes to a mapped class will **not**
    work if the class is mapped using decorators like [`registry.mapped()`](mapping_api.html#sqlalchemy.orm.registry.mapped
    "sqlalchemy.orm.registry.mapped") or imperative functions like [`registry.map_imperatively()`](mapping_api.html#sqlalchemy.orm.registry.map_imperatively
    "sqlalchemy.orm.registry.map_imperatively").  ## Declarative with Imperative Table
    (a.k.a. Hybrid Declarative)'
  prefs: []
  type: TYPE_NORMAL
- en: Declarative mappings may also be provided with a pre-existing [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") object, or otherwise a [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") or other arbitrary [`FromClause`](../core/selectable.html#sqlalchemy.sql.expression.FromClause
    "sqlalchemy.sql.expression.FromClause") construct (such as a [`Join`](../core/selectable.html#sqlalchemy.sql.expression.Join
    "sqlalchemy.sql.expression.Join") or [`Subquery`](../core/selectable.html#sqlalchemy.sql.expression.Subquery
    "sqlalchemy.sql.expression.Subquery")) that is constructed separately.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is referred to as a “hybrid declarative” mapping, as the class is mapped
    using the declarative style for everything involving the mapper configuration,
    however the mapped [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    object is produced separately and passed to the declarative process directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Above, a [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    object is constructed using the approach described at [Describing Databases with
    MetaData](../core/metadata.html#metadata-describing). It can then be applied directly
    to a class that is declaratively mapped. The `__tablename__` and `__table_args__`
    declarative class attributes are not used in this form. The above configuration
    is often more readable as an inline definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'A natural effect of the above style is that the `__table__` attribute is itself
    defined within the class definition block. As such it may be immediately referenced
    within subsequent attributes, such as the example below which illustrates referring
    to the `type` column in a polymorphic mapper configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The “imperative table” form is also used when a non-[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") construct, such as a [`Join`](../core/selectable.html#sqlalchemy.sql.expression.Join
    "sqlalchemy.sql.expression.Join") or [`Subquery`](../core/selectable.html#sqlalchemy.sql.expression.Subquery
    "sqlalchemy.sql.expression.Subquery") object, is to be mapped. An example below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: For background on mapping to non-[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") constructs see the sections [Mapping a Class against
    Multiple Tables](nonstandard_mappings.html#orm-mapping-joins) and [Mapping a Class
    against Arbitrary Subqueries](nonstandard_mappings.html#orm-mapping-arbitrary-subqueries).
  prefs: []
  type: TYPE_NORMAL
- en: The “imperative table” form is of particular use when the class itself is using
    an alternative form of attribute declaration, such as Python dataclasses. See
    the section [Applying ORM Mappings to an existing dataclass (legacy dataclass
    use)](dataclasses.html#orm-declarative-dataclasses) for detail.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Describing Databases with MetaData](../core/metadata.html#metadata-describing)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Applying ORM Mappings to an existing dataclass (legacy dataclass use)](dataclasses.html#orm-declarative-dataclasses)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Alternate Attribute Names for Mapping Table Columns'
  prefs: []
  type: TYPE_NORMAL
- en: The section [Naming Declarative Mapped Columns Explicitly](#orm-declarative-table-column-naming)
    illustrated how to use [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") to provide a specific name for the generated [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") object separate from the attribute name under which
    it is mapped.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using Imperative Table configuration, we already have [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects present. To map these to alternate names we
    may assign the [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    to the desired attributes directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The `User` mapping above will refer to the `"user_id"` and `"user_name"` columns
    via the `User.id` and `User.name` attributes, in the same way as demonstrated
    at [Naming Declarative Mapped Columns Explicitly](#orm-declarative-table-column-naming).
  prefs: []
  type: TYPE_NORMAL
- en: 'One caveat to the above mapping is that the direct inline link to [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") will not be typed correctly when using [**PEP 484**](https://peps.python.org/pep-0484/)
    typing tools. A strategy to resolve this is to apply the [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects within the [`column_property()`](mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property") function; while the [`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper") already generates this property object for its internal
    use automatically, by naming it in the class declaration, typing tools will be
    able to match the attribute to the [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Naming Declarative Mapped Columns Explicitly](#orm-declarative-table-column-naming)
    - applies to Declarative Table  ### Applying Load, Persistence and Mapping Options
    for Imperative Table Columns'
  prefs: []
  type: TYPE_NORMAL
- en: 'The section [Setting Load and Persistence Options for Declarative Mapped Columns](#orm-declarative-column-options)
    reviewed how to set load and persistence options when using the [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct with Declarative Table configuration.
    When using Imperative Table configuration, we already have existing [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects that are mapped. In order to map these [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects along with additional parameters that are
    specific to the ORM mapping, we may use the [`column_property()`](mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property") and [`deferred()`](queryguide/columns.html#sqlalchemy.orm.deferred
    "sqlalchemy.orm.deferred") constructs in order to associate additional parameters
    with the column. Options include:'
  prefs: []
  type: TYPE_NORMAL
- en: '**deferred column loading** - The [`deferred()`](queryguide/columns.html#sqlalchemy.orm.deferred
    "sqlalchemy.orm.deferred") function is shorthand for invoking [`column_property()`](mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property") with the [`column_property.deferred`](mapping_api.html#sqlalchemy.orm.column_property.params.deferred
    "sqlalchemy.orm.column_property") parameter set to `True`; this construct establishes
    the [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    using [deferred column loading](queryguide/columns.html#orm-queryguide-column-deferral)
    by default. In the example below, the `User.bio` column will not be loaded by
    default, but only when accessed:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[Limiting which Columns Load with Column Deferral](queryguide/columns.html#orm-queryguide-column-deferral)
    - full description of deferred column loading'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**active history** - The [`column_property.active_history`](mapping_api.html#sqlalchemy.orm.column_property.params.active_history
    "sqlalchemy.orm.column_property") ensures that upon change of value for the attribute,
    the previous value will have been loaded and made part of the [`AttributeState.history`](internals.html#sqlalchemy.orm.AttributeState.history
    "sqlalchemy.orm.AttributeState.history") collection when inspecting the history
    of the attribute. This may incur additional SQL statements:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`column_property()`](mapping_api.html#sqlalchemy.orm.column_property "sqlalchemy.orm.column_property")
    construct is also important for cases where classes are mapped to alternative
    FROM clauses such as joins and selects. More background on these cases is at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Mapping a Class against Multiple Tables](nonstandard_mappings.html#maptojoin)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[SQL Expressions as Mapped Attributes](mapped_sql_expr.html#mapper-sql-expressions)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For Declarative Table configuration with [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column"), most options are available directly; see the
    section [Setting Load and Persistence Options for Declarative Mapped Columns](#orm-declarative-column-options)
    for examples.  ## Mapping Declaratively with Reflected Tables'
  prefs: []
  type: TYPE_NORMAL
- en: There are several patterns available which provide for producing mapped classes
    against a series of [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    objects that were introspected from the database, using the reflection process
    described at [Reflecting Database Objects](../core/reflection.html#metadata-reflection).
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple way to map a class to a table reflected from the database is to use
    a declarative hybrid mapping, passing the [`Table.autoload_with`](../core/metadata.html#sqlalchemy.schema.Table.params.autoload_with
    "sqlalchemy.schema.Table") parameter to the constructor for [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'A variant on the above pattern that scales for many tables is to use the [`MetaData.reflect()`](../core/metadata.html#sqlalchemy.schema.MetaData.reflect
    "sqlalchemy.schema.MetaData.reflect") method to reflect a full set of [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects at once, then refer to them from the [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: One caveat to the approach of using `__table__` is that the mapped classes cannot
    be declared until the tables have been reflected, which requires the database
    connectivity source to be present while the application classes are being declared;
    it’s typical that classes are declared as the modules of an application are being
    imported, but database connectivity isn’t available until the application starts
    running code so that it can consume configuration information and create an engine.
    There are currently two approaches to working around this, described in the next
    two sections.
  prefs: []
  type: TYPE_NORMAL
- en: '### Using DeferredReflection'
  prefs: []
  type: TYPE_NORMAL
- en: 'To accommodate the use case of declaring mapped classes where reflection of
    table metadata can occur afterwards, a simple extension called the [`DeferredReflection`](extensions/declarative/index.html#sqlalchemy.ext.declarative.DeferredReflection
    "sqlalchemy.ext.declarative.DeferredReflection") mixin is available, which alters
    the declarative mapping process to be delayed until a special class-level [`DeferredReflection.prepare()`](extensions/declarative/index.html#sqlalchemy.ext.declarative.DeferredReflection.prepare
    "sqlalchemy.ext.declarative.DeferredReflection.prepare") method is called, which
    will perform the reflection process against a target database, and will integrate
    the results with the declarative table mapping process, that is, classes which
    use the `__tablename__` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Above, we create a mixin class `Reflected` that will serve as a base for classes
    in our declarative hierarchy that should become mapped when the `Reflected.prepare`
    method is called. The above mapping is not complete until we do so, given an [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The purpose of the `Reflected` class is to define the scope at which classes
    should be reflectively mapped. The plugin will search among the subclass tree
    of the target against which `.prepare()` is called and reflect all tables which
    are named by declared classes; tables in the target database that are not part
    of mappings and are not related to the target tables via foreign key constraint
    will not be reflected.
  prefs: []
  type: TYPE_NORMAL
- en: Using Automap
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A more automated solution to mapping against an existing database where table
    reflection is to be used is to use the [Automap](extensions/automap.html) extension.
    This extension will generate entire mapped classes from a database schema, including
    relationships between classes based on observed foreign key constraints. While
    it includes hooks for customization, such as hooks that allow custom class naming
    and relationship naming schemes, automap is oriented towards an expedient zero-configuration
    style of working. If an application wishes to have a fully explicit model that
    makes use of table reflection, the [DeferredReflection](#orm-declarative-reflected-deferred-reflection)
    class may be preferable for its less automated approach.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Automap](extensions/automap.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Automating Column Naming Schemes from Reflected Tables'
  prefs: []
  type: TYPE_NORMAL
- en: When using any of the previous reflection techniques, we have the option to
    change the naming scheme by which columns are mapped. The [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") object includes a parameter [`Column.key`](../core/metadata.html#sqlalchemy.schema.Column.params.key
    "sqlalchemy.schema.Column") which is a string name that determines under what
    name this [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    will be present in the [`Table.c`](../core/metadata.html#sqlalchemy.schema.Table.c
    "sqlalchemy.schema.Table.c") collection, independently of the SQL name of the
    column. This key is also used by [`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper") as the attribute name under which the [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") will be mapped, if not supplied through other means
    such as that illustrated at [Alternate Attribute Names for Mapping Table Columns](#orm-imperative-table-column-naming).
  prefs: []
  type: TYPE_NORMAL
- en: When working with table reflection, we can intercept the parameters that will
    be used for [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    as they are received using the [`DDLEvents.column_reflect()`](../core/events.html#sqlalchemy.events.DDLEvents.column_reflect
    "sqlalchemy.events.DDLEvents.column_reflect") event and apply whatever changes
    we need, including the `.key` attribute but also things like datatypes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The event hook is most easily associated with the [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") object that’s in use as illustrated below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'With the above event, the reflection of [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects will be intercepted with our event that adds
    a new “.key” element, such as in a mapping as below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The approach also works with both the [`DeferredReflection`](extensions/declarative/index.html#sqlalchemy.ext.declarative.DeferredReflection
    "sqlalchemy.ext.declarative.DeferredReflection") base class as well as with the
    [Automap](extensions/automap.html) extension. For automap specifically, see the
    section [Intercepting Column Definitions](extensions/automap.html#automap-intercepting-columns)
    for background.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Mapping Declaratively with Reflected Tables](#orm-declarative-reflected)'
  prefs: []
  type: TYPE_NORMAL
- en: '[`DDLEvents.column_reflect()`](../core/events.html#sqlalchemy.events.DDLEvents.column_reflect
    "sqlalchemy.events.DDLEvents.column_reflect")'
  prefs: []
  type: TYPE_NORMAL
- en: '[Intercepting Column Definitions](extensions/automap.html#automap-intercepting-columns)
    - in the [Automap](extensions/automap.html) documentation  ### Mapping to an Explicit
    Set of Primary Key Columns'
  prefs: []
  type: TYPE_NORMAL
- en: The [`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper "sqlalchemy.orm.Mapper")
    construct in order to successfully map a table always requires that at least one
    column be identified as the “primary key” for that selectable. This is so that
    when an ORM object is loaded or persisted, it can be placed in the [identity map](../glossary.html#term-identity-map)
    with an appropriate [identity key](../glossary.html#term-identity-key).
  prefs: []
  type: TYPE_NORMAL
- en: In those cases where the a reflected table to be mapped does not include a primary
    key constraint, as well as in the general case for [mapping against arbitrary
    selectables](nonstandard_mappings.html#orm-mapping-arbitrary-subqueries) where
    primary key columns might not be present, the [`Mapper.primary_key`](mapping_api.html#sqlalchemy.orm.Mapper.params.primary_key
    "sqlalchemy.orm.Mapper") parameter is provided so that any set of columns may
    be configured as the “primary key” for the table, as far as ORM mapping is concerned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given the following example of an Imperative Table mapping against an existing
    [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    object where the table does not have any declared primary key (as may occur in
    reflection scenarios), we may map such a table as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Above, the `group_users` table is an association table of some kind with string
    columns `user_id` and `group_id`, but no primary key is set up; instead, there
    is only a [`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint") establishing that the two columns represent
    a unique key. The [`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper "sqlalchemy.orm.Mapper")
    does not automatically inspect unique constraints for primary keys; instead, we
    make use of the [`Mapper.primary_key`](mapping_api.html#sqlalchemy.orm.Mapper.params.primary_key
    "sqlalchemy.orm.Mapper") parameter, passing a collection of `[group_users.c.user_id,
    group_users.c.group_id]`, indicating that these two columns should be used in
    order to construct the identity key for instances of the `GroupUsers` class.  ###
    Mapping a Subset of Table Columns'
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes table reflection may provide a [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") with many columns that are not important for our needs
    and may be safely ignored. For such a table that has lots of columns that don’t
    need to be referenced in the application, the [`Mapper.include_properties`](mapping_api.html#sqlalchemy.orm.Mapper.params.include_properties
    "sqlalchemy.orm.Mapper") or [`Mapper.exclude_properties`](mapping_api.html#sqlalchemy.orm.Mapper.params.exclude_properties
    "sqlalchemy.orm.Mapper") parameters can indicate a subset of columns to be mapped,
    where other columns from the target [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") will not be considered by the ORM in any way. Example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: In the above example, the `User` class will map to the `user_table` table, only
    including the `user_id` and `user_name` columns - the rest are not referenced.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: will map the `Address` class to the `address_table` table, including all columns
    present except `street`, `city`, `state`, and `zip`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As indicated in the two examples, columns may be referenced either by string
    name or by referring to the [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") object directly. Referring to the object directly
    may be useful for explicitness as well as to resolve ambiguities when mapping
    to multi-table constructs that might have repeated names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: When columns are not included in a mapping, these columns will not be referenced
    in any SELECT statements emitted when executing [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") or legacy [`Query`](queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") objects, nor will there be any mapped attribute on the
    mapped class which represents the column; assigning an attribute of that name
    will have no effect beyond that of a normal Python attribute assignment.
  prefs: []
  type: TYPE_NORMAL
- en: However, it is important to note that **schema level column defaults WILL still
    be in effect** for those [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects that include them, even though they may be
    excluded from the ORM mapping.
  prefs: []
  type: TYPE_NORMAL
- en: '“Schema level column defaults” refers to the defaults described at [Column
    INSERT/UPDATE Defaults](../core/defaults.html#metadata-defaults) including those
    configured by the [`Column.default`](../core/metadata.html#sqlalchemy.schema.Column.params.default
    "sqlalchemy.schema.Column"), [`Column.onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.onupdate
    "sqlalchemy.schema.Column"), [`Column.server_default`](../core/metadata.html#sqlalchemy.schema.Column.params.server_default
    "sqlalchemy.schema.Column") and [`Column.server_onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.server_onupdate
    "sqlalchemy.schema.Column") parameters. These constructs continue to have normal
    effects because in the case of [`Column.default`](../core/metadata.html#sqlalchemy.schema.Column.params.default
    "sqlalchemy.schema.Column") and [`Column.onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.onupdate
    "sqlalchemy.schema.Column"), the [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") object is still present on the underlying [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table"), thus allowing the default functions to take place
    when the ORM emits an INSERT or UPDATE, and in the case of [`Column.server_default`](../core/metadata.html#sqlalchemy.schema.Column.params.server_default
    "sqlalchemy.schema.Column") and [`Column.server_onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.server_onupdate
    "sqlalchemy.schema.Column"), the relational database itself emits these defaults
    as a server side behavior.  ## Declarative Table with `mapped_column()`'
  prefs: []
  type: TYPE_NORMAL
- en: 'When using Declarative, the body of the class to be mapped in most cases includes
    an attribute `__tablename__` that indicates the string name of a [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") that should be generated along with the mapping. The
    [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    construct, which features additional ORM-specific configuration capabilities not
    present in the plain [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") class, is then used within the class body to indicate
    columns in the table. The example below illustrates the most basic use of this
    construct within a Declarative mapping:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Above, [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    constructs are placed inline within the class definition as class level attributes.
    At the point at which the class is declared, the Declarative mapping process will
    generate a new [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    object against the [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") collection associated with the Declarative `Base`;
    each instance of [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") will then be used to generate a [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") object during this process, which will become part
    of the [`Table.columns`](../core/metadata.html#sqlalchemy.schema.Table.columns
    "sqlalchemy.schema.Table.columns") collection of this [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") object.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the above example, Declarative will build a [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") construct that is equivalent to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: When the `User` class above is mapped, this [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") object can be accessed directly via the `__table__`
    attribute; this is described further at [Accessing Table and Metadata](#orm-declarative-metadata).
  prefs: []
  type: TYPE_NORMAL
- en: The [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    construct accepts all arguments that are accepted by the [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") construct, as well as additional ORM-specific arguments.
    The [`mapped_column.__name`](mapping_api.html#sqlalchemy.orm.mapped_column.params.__name
    "sqlalchemy.orm.mapped_column") field, indicating the name of the database column,
    is typically omitted, as the Declarative process will make use of the attribute
    name given to the construct and assign this as the name of the column (in the
    above example, this refers to the names `id`, `name`, `fullname`, `nickname`).
    Assigning an alternate [`mapped_column.__name`](mapping_api.html#sqlalchemy.orm.mapped_column.params.__name
    "sqlalchemy.orm.mapped_column") is valid as well, where the resulting [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") will use the given name in SQL and DDL statements,
    while the `User` mapped class will continue to allow access to the attribute using
    the attribute name given, independent of the name given to the column itself (more
    on this at [Naming Declarative Mapped Columns Explicitly](#mapper-column-distinct-names)).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: The [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    construct is **only valid within a Declarative class mapping**. When constructing
    a [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    object using Core as well as when using [imperative table](#orm-imperative-table-configuration)
    configuration, the [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    construct is still required in order to indicate the presence of a database column.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Mapping Table Columns](mapping_columns.html) - contains additional notes on
    affecting how [`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper "sqlalchemy.orm.Mapper")
    interprets incoming [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects.'
  prefs: []
  type: TYPE_NORMAL
- en: '### Using Annotated Declarative Table (Type Annotated Forms for `mapped_column()`)'
  prefs: []
  type: TYPE_NORMAL
- en: The [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    construct is capable of deriving its column-configuration information from [**PEP
    484**](https://peps.python.org/pep-0484/) type annotations associated with the
    attribute as declared in the Declarative mapped class. These type annotations,
    if used, **must** be present within a special SQLAlchemy type called [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped"), which is a [generic](https://peps.python.org/pep-0484/#generics)
    type that then indicates a specific Python type within it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Below illustrates the mapping from the previous section, adding the use of
    [`Mapped`](internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Above, when Declarative processes each class attribute, each [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") will derive additional arguments from the corresponding
    [`Mapped`](internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped") type
    annotation on the left side, if present. Additionally, Declarative will generate
    an empty [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    directive implicitly, whenever a [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") type annotation is encountered that does not have a value
    assigned to the attribute (this form is inspired by the similar style used in
    Python [dataclasses](https://docs.python.org/3/library/dataclasses.html)); this
    [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    construct proceeds to derive its configuration from the [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") annotation present.
  prefs: []
  type: TYPE_NORMAL
- en: '#### `mapped_column()` derives the datatype and nullability from the `Mapped`
    annotation'
  prefs: []
  type: TYPE_NORMAL
- en: 'The two qualities that [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") derives from the [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") annotation are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**datatype** - the Python type given inside [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped"), as contained within the `typing.Optional` construct
    if present, is associated with a [`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") subclass such as [`Integer`](../core/type_basics.html#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer"), [`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String"), [`DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime
    "sqlalchemy.types.DateTime"), or [`Uuid`](../core/type_basics.html#sqlalchemy.types.Uuid
    "sqlalchemy.types.Uuid"), to name a few common types.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The datatype is determined based on a dictionary of Python type to SQLAlchemy
    datatype. This dictionary is completely customizable, as detailed in the next
    section [Customizing the Type Map](#orm-declarative-mapped-column-type-map). The
    default type map is implemented as in the code example below:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If the [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    construct indicates an explicit type as passed to the [`mapped_column.__type`](mapping_api.html#sqlalchemy.orm.mapped_column.params.__type
    "sqlalchemy.orm.mapped_column") argument, then the given Python type is disregarded.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**nullability** - The [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct will indicate its [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") as `NULL` or `NOT NULL` first and foremost by the
    presence of the [`mapped_column.nullable`](mapping_api.html#sqlalchemy.orm.mapped_column.params.nullable
    "sqlalchemy.orm.mapped_column") parameter, passed either as `True` or `False`.
    Additionally , if the [`mapped_column.primary_key`](mapping_api.html#sqlalchemy.orm.mapped_column.params.primary_key
    "sqlalchemy.orm.mapped_column") parameter is present and set to `True`, that will
    also imply that the column should be `NOT NULL`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the absence of **both** of these parameters, the presence of `typing.Optional[]`
    within the [`Mapped`](internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped")
    type annotation will be used to determine nullability, where `typing.Optional[]`
    means `NULL`, and the absence of `typing.Optional[]` means `NOT NULL`. If there
    is no `Mapped[]` annotation present at all, and there is no [`mapped_column.nullable`](mapping_api.html#sqlalchemy.orm.mapped_column.params.nullable
    "sqlalchemy.orm.mapped_column") or [`mapped_column.primary_key`](mapping_api.html#sqlalchemy.orm.mapped_column.params.primary_key
    "sqlalchemy.orm.mapped_column") parameter, then SQLAlchemy’s usual default for
    [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    of `NULL` is used.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the example below, the `id` and `data` columns will be `NOT NULL`, and the
    `additional_info` column will be `NULL`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'It is also perfectly valid to have a [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") whose nullability is **different** from what would
    be implied by the annotation. For example, an ORM mapped attribute may be annotated
    as allowing `None` within Python code that works with the object as it is first
    being created and populated, however the value will ultimately be written to a
    database column that is `NOT NULL`. The [`mapped_column.nullable`](mapping_api.html#sqlalchemy.orm.mapped_column.params.nullable
    "sqlalchemy.orm.mapped_column") parameter, when present, will always take precedence:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Similarly, a non-None attribute that’s written to a database column that for
    whatever reason needs to be NULL at the schema level, [`mapped_column.nullable`](mapping_api.html#sqlalchemy.orm.mapped_column.params.nullable
    "sqlalchemy.orm.mapped_column") may be set to `True`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE68]  #### Customizing the Type Map'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The mapping of Python types to SQLAlchemy [`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") types described in the previous section defaults
    to a hardcoded dictionary present in the `sqlalchemy.sql.sqltypes` module. However,
    the [`registry`](mapping_api.html#sqlalchemy.orm.registry "sqlalchemy.orm.registry")
    object that coordinates the Declarative mapping process will first consult a local,
    user defined dictionary of types which may be passed as the [`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry") parameter when constructing the [`registry`](mapping_api.html#sqlalchemy.orm.registry
    "sqlalchemy.orm.registry"), which may be associated with the [`DeclarativeBase`](mapping_api.html#sqlalchemy.orm.DeclarativeBase
    "sqlalchemy.orm.DeclarativeBase") superclass when first used.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, if we wish to make use of the [`BIGINT`](../core/type_basics.html#sqlalchemy.types.BIGINT
    "sqlalchemy.types.BIGINT") datatype for `int`, the [`TIMESTAMP`](../core/type_basics.html#sqlalchemy.types.TIMESTAMP
    "sqlalchemy.types.TIMESTAMP") datatype with `timezone=True` for `datetime.datetime`,
    and then only on Microsoft SQL Server we’d like to use [`NVARCHAR`](../core/type_basics.html#sqlalchemy.types.NVARCHAR
    "sqlalchemy.types.NVARCHAR") datatype when Python `str` is used, the registry
    and Declarative base could be configured as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Below illustrates the CREATE TABLE statement generated for the above mapping,
    first on the Microsoft SQL Server backend, illustrating the `NVARCHAR` datatype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Then on the PostgreSQL backend, illustrating `TIMESTAMP WITH TIME ZONE`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'By making use of methods such as [`TypeEngine.with_variant()`](../core/type_api.html#sqlalchemy.types.TypeEngine.with_variant
    "sqlalchemy.types.TypeEngine.with_variant"), we’re able to build up a type map
    that’s customized to what we need for different backends, while still being able
    to use succinct annotation-only [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") configurations. There are two more levels of Python-type
    configurability available beyond this, described in the next two sections.  ####
    Mapping Multiple Type Configurations to Python Types'
  prefs: []
  type: TYPE_NORMAL
- en: As individual Python types may be associated with [`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") configurations of any variety by using the [`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry") parameter, an additional capability is the ability
    to associate a single Python type with different variants of a SQL type based
    on additional type qualifiers. One typical example of this is mapping the Python
    `str` datatype to `VARCHAR` SQL types of different lengths. Another is mapping
    different varieties of `decimal.Decimal` to differently sized `NUMERIC` columns.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python’s typing system provides a great way to add additional metadata to a
    Python type which is by using the [**PEP 593**](https://peps.python.org/pep-0593/)
    `Annotated` generic type, which allows additional information to be bundled along
    with a Python type. The [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct will correctly interpret an `Annotated`
    object by identity when resolving it in the [`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry"), as in the example below where we declare two variants
    of [`String`](../core/type_basics.html#sqlalchemy.types.String "sqlalchemy.types.String")
    and [`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric "sqlalchemy.types.Numeric"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'The Python type passed to the `Annotated` container, in the above example the
    `str` and `Decimal` types, is important only for the benefit of typing tools;
    as far as the [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct is concerned, it will only need perform
    a lookup of each type object in the [`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry") dictionary without actually looking inside of the `Annotated`
    object, at least in this particular context. Similarly, the arguments passed to
    `Annotated` beyond the underlying Python type itself are also not important, it’s
    only that at least one argument must be present for the `Annotated` construct
    to be valid. We can then use these augmented types directly in our mapping where
    they will be matched to the more specific type constructions, as in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'a CREATE TABLE for the above mapping will illustrate the different variants
    of `VARCHAR` and `NUMERIC` we’ve configured, and looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'While variety in linking `Annotated` types to different SQL types grants us
    a wide degree of flexibility, the next section illustrates a second way in which
    `Annotated` may be used with Declarative that is even more open ended.  #### Mapping
    Whole Column Declarations to Python Types'
  prefs: []
  type: TYPE_NORMAL
- en: The previous section illustrated using [**PEP 593**](https://peps.python.org/pep-0593/)
    `Annotated` type instances as keys within the [`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry") dictionary. In this form, the [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct does not actually look inside the `Annotated`
    object itself, it’s instead used only as a dictionary key. However, Declarative
    also has the ability to extract an entire pre-established [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct from an `Annotated` object directly.
    Using this form, we can define not only different varieties of SQL datatypes linked
    to Python types without using the [`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry") dictionary, we can also set up any number of arguments
    such as nullability, column defaults, and constraints in a reusable fashion.
  prefs: []
  type: TYPE_NORMAL
- en: A set of ORM models will usually have some kind of primary key style that is
    common to all mapped classes. There also may be common column configurations such
    as timestamps with defaults and other fields of pre-established sizes and configurations.
    We can compose these configurations into [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") instances that we then bundle directly into instances
    of `Annotated`, which are then re-used in any number of class declarations. Declarative
    will unpack an `Annotated` object when provided in this manner, skipping over
    any other directives that don’t apply to SQLAlchemy and searching only for SQLAlchemy
    ORM constructs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The example below illustrates a variety of pre-configured field types used
    in this way, where we define `intpk` that represents an [`Integer`](../core/type_basics.html#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer") primary key column, `timestamp` that represents a
    [`DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime "sqlalchemy.types.DateTime")
    type which will use `CURRENT_TIMESTAMP` as a DDL level column default, and `required_name`
    which is a [`String`](../core/type_basics.html#sqlalchemy.types.String "sqlalchemy.types.String")
    of length 30 that’s `NOT NULL`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'The above `Annotated` objects can then be used directly within [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped"), where the pre-configured [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") constructs will be extracted and copied to a new
    instance that will be specific to each attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '`CREATE TABLE` for our above mapping looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'When using `Annotated` types in this way, the configuration of the type may
    also be affected on a per-attribute basis. For the types in the above example
    that feature explicit use of [`mapped_column.nullable`](mapping_api.html#sqlalchemy.orm.mapped_column.params.nullable
    "sqlalchemy.orm.mapped_column"), we can apply the `Optional[]` generic modifier
    to any of our types so that the field is optional or not at the Python level,
    which will be independent of the `NULL` / `NOT NULL` setting that takes place
    in the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'The [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    construct is also reconciled with an explicitly passed [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct, whose arguments will take precedence
    over those of the `Annotated` construct. Below we add a [`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey") constraint to our integer primary key and also
    use an alternate server default for the `created_at` column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'The CREATE TABLE statement illustrates these per-attribute settings, adding
    a `FOREIGN KEY` constraint as well as substituting `UTC_TIMESTAMP` for `CURRENT_TIMESTAMP`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The feature of [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") just described, where a fully constructed set
    of column arguments may be indicated using [**PEP 593**](https://peps.python.org/pep-0593/)
    `Annotated` objects that contain a “template” [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") object to be copied into the attribute, is currently
    not implemented for other ORM constructs such as [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") and [`composite()`](composites.html#sqlalchemy.orm.composite
    "sqlalchemy.orm.composite"). While this functionality is in theory possible, for
    the moment attempting to use `Annotated` to indicate further arguments for [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") and similar will raise a `NotImplementedError`
    exception at runtime, but may be implemented in future releases.  #### Using Python
    `Enum` or pep-586 `Literal` types in the type map'
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 2.0.0b4: - Added `Enum` support'
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 2.0.1: - Added `Literal` support'
  prefs: []
  type: TYPE_NORMAL
- en: 'User-defined Python types which derive from the Python built-in `enum.Enum`
    as well as the `typing.Literal` class are automatically linked to the SQLAlchemy
    [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.types.Enum")
    datatype when used in an ORM declarative mapping. The example below uses a custom
    `enum.Enum` within the `Mapped[]` constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'In the above example, the mapped attribute `SomeClass.status` will be linked
    to a [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    with the datatype of `Enum(Status)`. We can see this for example in the CREATE
    TABLE output for the PostgreSQL database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'In a similar way, `typing.Literal` may be used instead, using a `typing.Literal`
    that consists of all strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'The entries used in [`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry") link the base `enum.Enum` Python type as well as the
    `typing.Literal` type to the SQLAlchemy [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum") SQL type, using a special form which indicates to the
    [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.types.Enum")
    datatype that it should automatically configure itself against an arbitrary enumerated
    type. This configuration, which is implicit by default, would be indicated explicitly
    as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: The resolution logic within Declarative is able to resolve subclasses of `enum.Enum`
    as well as instances of `typing.Literal` to match the `enum.Enum` or `typing.Literal`
    entry in the [`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry") dictionary. The [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum") SQL type then knows how to produce a configured version
    of itself with the appropriate settings, including default string length. If a
    `typing.Literal` that does not consist of only string values is passed, an informative
    error is raised.
  prefs: []
  type: TYPE_NORMAL
- en: Native Enums and Naming
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The [`Enum.native_enum`](../core/type_basics.html#sqlalchemy.types.Enum.params.native_enum
    "sqlalchemy.sql.sqltypes.Enum") parameter refers to if the [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.sql.sqltypes.Enum") datatype should create a so-called “native” enum,
    which on MySQL/MariaDB is the `ENUM` datatype and on PostgreSQL is a new `TYPE`
    object created by `CREATE TYPE`, or a “non-native” enum, which means that `VARCHAR`
    will be used to create the datatype. For backends other than MySQL/MariaDB or
    PostgreSQL, `VARCHAR` is used in all cases (third party dialects may have their
    own behaviors).
  prefs: []
  type: TYPE_NORMAL
- en: 'Because PostgreSQL’s `CREATE TYPE` requires that there’s an explicit name for
    the type to be created, special fallback logic exists when working with implicitly
    generated [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.sql.sqltypes.Enum")
    without specifying an explicit [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.sql.sqltypes.Enum") datatype within a mapping:'
  prefs: []
  type: TYPE_NORMAL
- en: If the [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.sql.sqltypes.Enum")
    is linked to an `enum.Enum` object, the [`Enum.native_enum`](../core/type_basics.html#sqlalchemy.types.Enum.params.native_enum
    "sqlalchemy.sql.sqltypes.Enum") parameter defaults to `True` and the name of the
    enum will be taken from the name of the `enum.Enum` datatype. The PostgreSQL backend
    will assume `CREATE TYPE` with this name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.sql.sqltypes.Enum")
    is linked to a `typing.Literal` object, the [`Enum.native_enum`](../core/type_basics.html#sqlalchemy.types.Enum.params.native_enum
    "sqlalchemy.sql.sqltypes.Enum") parameter defaults to `False`; no name is generated
    and `VARCHAR` is assumed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To use `typing.Literal` with a PostgreSQL `CREATE TYPE` type, an explicit [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.sql.sqltypes.Enum") must be used, either within the type map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Or alternatively within [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Altering the Configuration of the Default Enum
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In order to modify the fixed configuration of the `Enum` datatype that’s generated
    implicitly, specify new entries in the [`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry"), indicating additional arguments. For example, to use
    “non native enumerations” unconditionally, the [`Enum.native_enum`](../core/type_basics.html#sqlalchemy.types.Enum.params.native_enum
    "sqlalchemy.types.Enum") parameter may be set to False for all types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Changed in version 2.0.1: Implemented support for overriding parameters such
    as [`Enum.native_enum`](../core/type_basics.html#sqlalchemy.types.Enum.params.native_enum
    "sqlalchemy.types.Enum") within the [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum") datatype when establishing the [`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry"). Previously, this functionality was not working.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To use a specific configuration for a specific `enum.Enum` subtype, such as
    setting the string length to 50 when using the example `Status` datatype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'By default [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.types.Enum")
    that are automatically generated are not associated with the `MetaData` instance
    used by the `Base`, so if the metadata defines a schema it will not be automatically
    associated with the enum. To automatically associate the enum with the schema
    in the metadata or table they belong to the [`Enum.inherit_schema`](../core/type_basics.html#sqlalchemy.types.Enum.params.inherit_schema
    "sqlalchemy.types.Enum") can be set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Linking Specific `enum.Enum` or `typing.Literal` to other datatypes
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The above examples feature the use of an [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum") that is automatically configuring itself to the arguments
    / attributes present on an `enum.Enum` or `typing.Literal` type object. For use
    cases where specific kinds of `enum.Enum` or `typing.Literal` should be linked
    to other types, these specific types may be placed in the type map also. In the
    example below, an entry for `Literal[]` that contains non-string types is linked
    to the [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON")
    datatype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: In the above configuration, the `my_literal` datatype will resolve to a [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON") instance. Other `Literal` variants will continue to resolve
    to [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.types.Enum")
    datatypes.
  prefs: []
  type: TYPE_NORMAL
- en: Dataclass features in `mapped_column()`
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    construct integrates with SQLAlchemy’s “native dataclasses” feature, discussed
    at [Declarative Dataclass Mapping](dataclasses.html#orm-declarative-native-dataclasses).
    See that section for current background on additional directives supported by
    [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column").  ###
    Accessing Table and Metadata'
  prefs: []
  type: TYPE_NORMAL
- en: 'A declaratively mapped class will always include an attribute called `__table__`;
    when the above configuration using `__tablename__` is complete, the declarative
    process makes the [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    available via the `__table__` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'The above table is ultimately the same one that corresponds to the [`Mapper.local_table`](mapping_api.html#sqlalchemy.orm.Mapper.local_table
    "sqlalchemy.orm.Mapper.local_table") attribute, which we can see through the [runtime
    inspection system](../core/inspection.html):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'The [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData "sqlalchemy.schema.MetaData")
    collection associated with both the declarative [`registry`](mapping_api.html#sqlalchemy.orm.registry
    "sqlalchemy.orm.registry") as well as the base class is frequently necessary in
    order to run DDL operations such as CREATE, as well as in use with migration tools
    such as Alembic. This object is available via the `.metadata` attribute of [`registry`](mapping_api.html#sqlalchemy.orm.registry
    "sqlalchemy.orm.registry") as well as the declarative base class. Below, for a
    small script we may wish to emit a CREATE for all tables against a SQLite database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]  ### Declarative Table Configuration'
  prefs: []
  type: TYPE_NORMAL
- en: When using Declarative Table configuration with the `__tablename__` declarative
    class attribute, additional arguments to be supplied to the [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") constructor should be provided using the `__table_args__`
    declarative class attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'This attribute accommodates both positional as well as keyword arguments that
    are normally sent to the [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") constructor. The attribute can be specified in one
    of two forms. One is as a dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'The other, a tuple, where each argument is positional (usually constraints):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Keyword arguments can be specified with the above form by specifying the last
    argument as a dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'A class may also specify the `__table_args__` declarative attribute, as well
    as the `__tablename__` attribute, in a dynamic style using the [`declared_attr()`](mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr") method decorator. See [Composing Mapped Hierarchies
    with Mixins](declarative_mixins.html) for background.  ### Explicit Schema Name
    with Declarative Table'
  prefs: []
  type: TYPE_NORMAL
- en: 'The schema name for a [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") as documented at [Specifying the Schema Name](../core/metadata.html#schema-table-schema-name)
    is applied to an individual [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") using the [`Table.schema`](../core/metadata.html#sqlalchemy.schema.Table.params.schema
    "sqlalchemy.schema.Table") argument. When using Declarative tables, this option
    is passed like any other to the `__table_args__` dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'The schema name can also be applied to all [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects globally by using the [`MetaData.schema`](../core/metadata.html#sqlalchemy.schema.MetaData.params.schema
    "sqlalchemy.schema.MetaData") parameter documented at [Specifying a Default Schema
    Name with MetaData](../core/metadata.html#schema-metadata-schema-name). The [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") object may be constructed separately and associated
    with a [`DeclarativeBase`](mapping_api.html#sqlalchemy.orm.DeclarativeBase "sqlalchemy.orm.DeclarativeBase")
    subclass by assigning to the `metadata` attribute directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Specifying the Schema Name](../core/metadata.html#schema-table-schema-name)
    - in the [Describing Databases with MetaData](../core/metadata.html) documentation.  ###
    Setting Load and Persistence Options for Declarative Mapped Columns'
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    construct accepts additional ORM-specific arguments that affect how the generated
    [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    is mapped, affecting its load and persistence-time behavior. Options that are
    commonly used include:'
  prefs: []
  type: TYPE_NORMAL
- en: '**deferred column loading** - The [`mapped_column.deferred`](mapping_api.html#sqlalchemy.orm.mapped_column.params.deferred
    "sqlalchemy.orm.mapped_column") boolean establishes the [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") using [deferred column loading](queryguide/columns.html#orm-queryguide-column-deferral)
    by default. In the example below, the `User.bio` column will not be loaded by
    default, but only when accessed:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Limiting which Columns Load with Column Deferral](queryguide/columns.html#orm-queryguide-column-deferral)
    - full description of deferred column loading'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**active history** - The [`mapped_column.active_history`](mapping_api.html#sqlalchemy.orm.mapped_column.params.active_history
    "sqlalchemy.orm.mapped_column") ensures that upon change of value for the attribute,
    the previous value will have been loaded and made part of the [`AttributeState.history`](internals.html#sqlalchemy.orm.AttributeState.history
    "sqlalchemy.orm.AttributeState.history") collection when inspecting the history
    of the attribute. This may incur additional SQL statements:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: See the docstring for [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") for a list of supported parameters.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Applying Load, Persistence and Mapping Options for Imperative Table Columns](#orm-imperative-table-column-options)
    - describes using [`column_property()`](mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property") and [`deferred()`](queryguide/columns.html#sqlalchemy.orm.deferred
    "sqlalchemy.orm.deferred") for use with Imperative Table configuration  ### Naming
    Declarative Mapped Columns Explicitly'
  prefs: []
  type: TYPE_NORMAL
- en: 'All of the examples thus far feature the [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct linked to an ORM mapped attribute, where
    the Python attribute name given to the [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") is also that of the column as we see in CREATE
    TABLE statements as well as queries. The name for a column as expressed in SQL
    may be indicated by passing the string positional argument [`mapped_column.__name`](mapping_api.html#sqlalchemy.orm.mapped_column.params.__name
    "sqlalchemy.orm.mapped_column") as the first positional argument. In the example
    below, the `User` class is mapped with alternate names given to the columns themselves:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'Where above `User.id` resolves to a column named `user_id` and `User.name`
    resolves to a column named `user_name`. We may write a [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") statement using our Python attribute names
    and will see the SQL names generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Alternate Attribute Names for Mapping Table Columns](#orm-imperative-table-column-naming)
    - applies to Imperative Table  ### Appending additional columns to an existing
    Declarative mapped class'
  prefs: []
  type: TYPE_NORMAL
- en: A declarative table configuration allows the addition of new [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects to an existing mapping after the [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") metadata has already been generated.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a declarative class that is declared using a declarative base class, the
    underlying metaclass `DeclarativeMeta` includes a `__setattr__()` method that
    will intercept additional [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") or Core [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects and add them to both the [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") using [`Table.append_column()`](../core/metadata.html#sqlalchemy.schema.Table.append_column
    "sqlalchemy.schema.Table.append_column") as well as to the existing [`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper") using [`Mapper.add_property()`](mapping_api.html#sqlalchemy.orm.Mapper.add_property
    "sqlalchemy.orm.Mapper.add_property"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'Using core [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: All arguments are supported including an alternate name, such as `MyClass.some_new_column
    = mapped_column("some_name", String)`. However, the SQL type must be passed to
    the [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    or [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    object explicitly, as in the above examples where the [`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String") type is passed. There’s no capability for the [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") annotation type to take part in the operation.
  prefs: []
  type: TYPE_NORMAL
- en: Additional [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    objects may also be added to a mapping in the specific circumstance of using single
    table inheritance, where additional columns are present on mapped subclasses that
    have no [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    of their own. This is illustrated in the section [Single Table Inheritance](inheritance.html#single-inheritance).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Adding Relationships to Mapped Classes After Declaration](basic_relationships.html#orm-declarative-table-adding-relationship)
    - similar examples for [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Assignment of mapped properties to an already mapped class will only function
    correctly if the “declarative base” class is used, meaning the user-defined subclass
    of [`DeclarativeBase`](mapping_api.html#sqlalchemy.orm.DeclarativeBase "sqlalchemy.orm.DeclarativeBase")
    or the dynamically generated class returned by [`declarative_base()`](mapping_api.html#sqlalchemy.orm.declarative_base
    "sqlalchemy.orm.declarative_base") or [`registry.generate_base()`](mapping_api.html#sqlalchemy.orm.registry.generate_base
    "sqlalchemy.orm.registry.generate_base"). This “base” class includes a Python
    metaclass which implements a special `__setattr__()` method that intercepts these
    operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Runtime assignment of class-mapped attributes to a mapped class will **not**
    work if the class is mapped using decorators like [`registry.mapped()`](mapping_api.html#sqlalchemy.orm.registry.mapped
    "sqlalchemy.orm.registry.mapped") or imperative functions like [`registry.map_imperatively()`](mapping_api.html#sqlalchemy.orm.registry.map_imperatively
    "sqlalchemy.orm.registry.map_imperatively").  ### Using Annotated Declarative
    Table (Type Annotated Forms for `mapped_column()`)'
  prefs: []
  type: TYPE_NORMAL
- en: The [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    construct is capable of deriving its column-configuration information from [**PEP
    484**](https://peps.python.org/pep-0484/) type annotations associated with the
    attribute as declared in the Declarative mapped class. These type annotations,
    if used, **must** be present within a special SQLAlchemy type called [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped"), which is a [generic](https://peps.python.org/pep-0484/#generics)
    type that then indicates a specific Python type within it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Below illustrates the mapping from the previous section, adding the use of
    [`Mapped`](internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: Above, when Declarative processes each class attribute, each [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") will derive additional arguments from the corresponding
    [`Mapped`](internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped") type
    annotation on the left side, if present. Additionally, Declarative will generate
    an empty [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    directive implicitly, whenever a [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") type annotation is encountered that does not have a value
    assigned to the attribute (this form is inspired by the similar style used in
    Python [dataclasses](https://docs.python.org/3/library/dataclasses.html)); this
    [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    construct proceeds to derive its configuration from the [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") annotation present.
  prefs: []
  type: TYPE_NORMAL
- en: '#### `mapped_column()` derives the datatype and nullability from the `Mapped`
    annotation'
  prefs: []
  type: TYPE_NORMAL
- en: 'The two qualities that [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") derives from the [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") annotation are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**datatype** - the Python type given inside [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped"), as contained within the `typing.Optional` construct
    if present, is associated with a [`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") subclass such as [`Integer`](../core/type_basics.html#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer"), [`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String"), [`DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime
    "sqlalchemy.types.DateTime"), or [`Uuid`](../core/type_basics.html#sqlalchemy.types.Uuid
    "sqlalchemy.types.Uuid"), to name a few common types.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The datatype is determined based on a dictionary of Python type to SQLAlchemy
    datatype. This dictionary is completely customizable, as detailed in the next
    section [Customizing the Type Map](#orm-declarative-mapped-column-type-map). The
    default type map is implemented as in the code example below:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If the [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    construct indicates an explicit type as passed to the [`mapped_column.__type`](mapping_api.html#sqlalchemy.orm.mapped_column.params.__type
    "sqlalchemy.orm.mapped_column") argument, then the given Python type is disregarded.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**nullability** - The [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct will indicate its [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") as `NULL` or `NOT NULL` first and foremost by the
    presence of the [`mapped_column.nullable`](mapping_api.html#sqlalchemy.orm.mapped_column.params.nullable
    "sqlalchemy.orm.mapped_column") parameter, passed either as `True` or `False`.
    Additionally , if the [`mapped_column.primary_key`](mapping_api.html#sqlalchemy.orm.mapped_column.params.primary_key
    "sqlalchemy.orm.mapped_column") parameter is present and set to `True`, that will
    also imply that the column should be `NOT NULL`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the absence of **both** of these parameters, the presence of `typing.Optional[]`
    within the [`Mapped`](internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped")
    type annotation will be used to determine nullability, where `typing.Optional[]`
    means `NULL`, and the absence of `typing.Optional[]` means `NOT NULL`. If there
    is no `Mapped[]` annotation present at all, and there is no [`mapped_column.nullable`](mapping_api.html#sqlalchemy.orm.mapped_column.params.nullable
    "sqlalchemy.orm.mapped_column") or [`mapped_column.primary_key`](mapping_api.html#sqlalchemy.orm.mapped_column.params.primary_key
    "sqlalchemy.orm.mapped_column") parameter, then SQLAlchemy’s usual default for
    [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    of `NULL` is used.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the example below, the `id` and `data` columns will be `NOT NULL`, and the
    `additional_info` column will be `NULL`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'It is also perfectly valid to have a [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") whose nullability is **different** from what would
    be implied by the annotation. For example, an ORM mapped attribute may be annotated
    as allowing `None` within Python code that works with the object as it is first
    being created and populated, however the value will ultimately be written to a
    database column that is `NOT NULL`. The [`mapped_column.nullable`](mapping_api.html#sqlalchemy.orm.mapped_column.params.nullable
    "sqlalchemy.orm.mapped_column") parameter, when present, will always take precedence:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Similarly, a non-None attribute that’s written to a database column that for
    whatever reason needs to be NULL at the schema level, [`mapped_column.nullable`](mapping_api.html#sqlalchemy.orm.mapped_column.params.nullable
    "sqlalchemy.orm.mapped_column") may be set to `True`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE109]  #### Customizing the Type Map'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The mapping of Python types to SQLAlchemy [`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") types described in the previous section defaults
    to a hardcoded dictionary present in the `sqlalchemy.sql.sqltypes` module. However,
    the [`registry`](mapping_api.html#sqlalchemy.orm.registry "sqlalchemy.orm.registry")
    object that coordinates the Declarative mapping process will first consult a local,
    user defined dictionary of types which may be passed as the [`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry") parameter when constructing the [`registry`](mapping_api.html#sqlalchemy.orm.registry
    "sqlalchemy.orm.registry"), which may be associated with the [`DeclarativeBase`](mapping_api.html#sqlalchemy.orm.DeclarativeBase
    "sqlalchemy.orm.DeclarativeBase") superclass when first used.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, if we wish to make use of the [`BIGINT`](../core/type_basics.html#sqlalchemy.types.BIGINT
    "sqlalchemy.types.BIGINT") datatype for `int`, the [`TIMESTAMP`](../core/type_basics.html#sqlalchemy.types.TIMESTAMP
    "sqlalchemy.types.TIMESTAMP") datatype with `timezone=True` for `datetime.datetime`,
    and then only on Microsoft SQL Server we’d like to use [`NVARCHAR`](../core/type_basics.html#sqlalchemy.types.NVARCHAR
    "sqlalchemy.types.NVARCHAR") datatype when Python `str` is used, the registry
    and Declarative base could be configured as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'Below illustrates the CREATE TABLE statement generated for the above mapping,
    first on the Microsoft SQL Server backend, illustrating the `NVARCHAR` datatype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'Then on the PostgreSQL backend, illustrating `TIMESTAMP WITH TIME ZONE`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'By making use of methods such as [`TypeEngine.with_variant()`](../core/type_api.html#sqlalchemy.types.TypeEngine.with_variant
    "sqlalchemy.types.TypeEngine.with_variant"), we’re able to build up a type map
    that’s customized to what we need for different backends, while still being able
    to use succinct annotation-only [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") configurations. There are two more levels of Python-type
    configurability available beyond this, described in the next two sections.  ####
    Mapping Multiple Type Configurations to Python Types'
  prefs: []
  type: TYPE_NORMAL
- en: As individual Python types may be associated with [`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") configurations of any variety by using the [`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry") parameter, an additional capability is the ability
    to associate a single Python type with different variants of a SQL type based
    on additional type qualifiers. One typical example of this is mapping the Python
    `str` datatype to `VARCHAR` SQL types of different lengths. Another is mapping
    different varieties of `decimal.Decimal` to differently sized `NUMERIC` columns.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python’s typing system provides a great way to add additional metadata to a
    Python type which is by using the [**PEP 593**](https://peps.python.org/pep-0593/)
    `Annotated` generic type, which allows additional information to be bundled along
    with a Python type. The [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct will correctly interpret an `Annotated`
    object by identity when resolving it in the [`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry"), as in the example below where we declare two variants
    of [`String`](../core/type_basics.html#sqlalchemy.types.String "sqlalchemy.types.String")
    and [`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric "sqlalchemy.types.Numeric"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'The Python type passed to the `Annotated` container, in the above example the
    `str` and `Decimal` types, is important only for the benefit of typing tools;
    as far as the [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct is concerned, it will only need perform
    a lookup of each type object in the [`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry") dictionary without actually looking inside of the `Annotated`
    object, at least in this particular context. Similarly, the arguments passed to
    `Annotated` beyond the underlying Python type itself are also not important, it’s
    only that at least one argument must be present for the `Annotated` construct
    to be valid. We can then use these augmented types directly in our mapping where
    they will be matched to the more specific type constructions, as in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'a CREATE TABLE for the above mapping will illustrate the different variants
    of `VARCHAR` and `NUMERIC` we’ve configured, and looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'While variety in linking `Annotated` types to different SQL types grants us
    a wide degree of flexibility, the next section illustrates a second way in which
    `Annotated` may be used with Declarative that is even more open ended.  #### Mapping
    Whole Column Declarations to Python Types'
  prefs: []
  type: TYPE_NORMAL
- en: The previous section illustrated using [**PEP 593**](https://peps.python.org/pep-0593/)
    `Annotated` type instances as keys within the [`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry") dictionary. In this form, the [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct does not actually look inside the `Annotated`
    object itself, it’s instead used only as a dictionary key. However, Declarative
    also has the ability to extract an entire pre-established [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct from an `Annotated` object directly.
    Using this form, we can define not only different varieties of SQL datatypes linked
    to Python types without using the [`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry") dictionary, we can also set up any number of arguments
    such as nullability, column defaults, and constraints in a reusable fashion.
  prefs: []
  type: TYPE_NORMAL
- en: A set of ORM models will usually have some kind of primary key style that is
    common to all mapped classes. There also may be common column configurations such
    as timestamps with defaults and other fields of pre-established sizes and configurations.
    We can compose these configurations into [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") instances that we then bundle directly into instances
    of `Annotated`, which are then re-used in any number of class declarations. Declarative
    will unpack an `Annotated` object when provided in this manner, skipping over
    any other directives that don’t apply to SQLAlchemy and searching only for SQLAlchemy
    ORM constructs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The example below illustrates a variety of pre-configured field types used
    in this way, where we define `intpk` that represents an [`Integer`](../core/type_basics.html#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer") primary key column, `timestamp` that represents a
    [`DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime "sqlalchemy.types.DateTime")
    type which will use `CURRENT_TIMESTAMP` as a DDL level column default, and `required_name`
    which is a [`String`](../core/type_basics.html#sqlalchemy.types.String "sqlalchemy.types.String")
    of length 30 that’s `NOT NULL`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'The above `Annotated` objects can then be used directly within [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped"), where the pre-configured [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") constructs will be extracted and copied to a new
    instance that will be specific to each attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: '`CREATE TABLE` for our above mapping looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: 'When using `Annotated` types in this way, the configuration of the type may
    also be affected on a per-attribute basis. For the types in the above example
    that feature explicit use of [`mapped_column.nullable`](mapping_api.html#sqlalchemy.orm.mapped_column.params.nullable
    "sqlalchemy.orm.mapped_column"), we can apply the `Optional[]` generic modifier
    to any of our types so that the field is optional or not at the Python level,
    which will be independent of the `NULL` / `NOT NULL` setting that takes place
    in the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'The [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    construct is also reconciled with an explicitly passed [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct, whose arguments will take precedence
    over those of the `Annotated` construct. Below we add a [`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey") constraint to our integer primary key and also
    use an alternate server default for the `created_at` column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'The CREATE TABLE statement illustrates these per-attribute settings, adding
    a `FOREIGN KEY` constraint as well as substituting `UTC_TIMESTAMP` for `CURRENT_TIMESTAMP`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The feature of [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") just described, where a fully constructed set
    of column arguments may be indicated using [**PEP 593**](https://peps.python.org/pep-0593/)
    `Annotated` objects that contain a “template” [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") object to be copied into the attribute, is currently
    not implemented for other ORM constructs such as [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") and [`composite()`](composites.html#sqlalchemy.orm.composite
    "sqlalchemy.orm.composite"). While this functionality is in theory possible, for
    the moment attempting to use `Annotated` to indicate further arguments for [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") and similar will raise a `NotImplementedError`
    exception at runtime, but may be implemented in future releases.  #### Using Python
    `Enum` or pep-586 `Literal` types in the type map'
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 2.0.0b4: - Added `Enum` support'
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 2.0.1: - Added `Literal` support'
  prefs: []
  type: TYPE_NORMAL
- en: 'User-defined Python types which derive from the Python built-in `enum.Enum`
    as well as the `typing.Literal` class are automatically linked to the SQLAlchemy
    [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.types.Enum")
    datatype when used in an ORM declarative mapping. The example below uses a custom
    `enum.Enum` within the `Mapped[]` constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'In the above example, the mapped attribute `SomeClass.status` will be linked
    to a [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    with the datatype of `Enum(Status)`. We can see this for example in the CREATE
    TABLE output for the PostgreSQL database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'In a similar way, `typing.Literal` may be used instead, using a `typing.Literal`
    that consists of all strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'The entries used in [`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry") link the base `enum.Enum` Python type as well as the
    `typing.Literal` type to the SQLAlchemy [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum") SQL type, using a special form which indicates to the
    [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.types.Enum")
    datatype that it should automatically configure itself against an arbitrary enumerated
    type. This configuration, which is implicit by default, would be indicated explicitly
    as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: The resolution logic within Declarative is able to resolve subclasses of `enum.Enum`
    as well as instances of `typing.Literal` to match the `enum.Enum` or `typing.Literal`
    entry in the [`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry") dictionary. The [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum") SQL type then knows how to produce a configured version
    of itself with the appropriate settings, including default string length. If a
    `typing.Literal` that does not consist of only string values is passed, an informative
    error is raised.
  prefs: []
  type: TYPE_NORMAL
- en: Native Enums and Naming
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The [`Enum.native_enum`](../core/type_basics.html#sqlalchemy.types.Enum.params.native_enum
    "sqlalchemy.sql.sqltypes.Enum") parameter refers to if the [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.sql.sqltypes.Enum") datatype should create a so-called “native” enum,
    which on MySQL/MariaDB is the `ENUM` datatype and on PostgreSQL is a new `TYPE`
    object created by `CREATE TYPE`, or a “non-native” enum, which means that `VARCHAR`
    will be used to create the datatype. For backends other than MySQL/MariaDB or
    PostgreSQL, `VARCHAR` is used in all cases (third party dialects may have their
    own behaviors).
  prefs: []
  type: TYPE_NORMAL
- en: 'Because PostgreSQL’s `CREATE TYPE` requires that there’s an explicit name for
    the type to be created, special fallback logic exists when working with implicitly
    generated [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.sql.sqltypes.Enum")
    without specifying an explicit [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.sql.sqltypes.Enum") datatype within a mapping:'
  prefs: []
  type: TYPE_NORMAL
- en: If the [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.sql.sqltypes.Enum")
    is linked to an `enum.Enum` object, the [`Enum.native_enum`](../core/type_basics.html#sqlalchemy.types.Enum.params.native_enum
    "sqlalchemy.sql.sqltypes.Enum") parameter defaults to `True` and the name of the
    enum will be taken from the name of the `enum.Enum` datatype. The PostgreSQL backend
    will assume `CREATE TYPE` with this name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.sql.sqltypes.Enum")
    is linked to a `typing.Literal` object, the [`Enum.native_enum`](../core/type_basics.html#sqlalchemy.types.Enum.params.native_enum
    "sqlalchemy.sql.sqltypes.Enum") parameter defaults to `False`; no name is generated
    and `VARCHAR` is assumed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To use `typing.Literal` with a PostgreSQL `CREATE TYPE` type, an explicit [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.sql.sqltypes.Enum") must be used, either within the type map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 'Or alternatively within [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: Altering the Configuration of the Default Enum
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In order to modify the fixed configuration of the `Enum` datatype that’s generated
    implicitly, specify new entries in the [`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry"), indicating additional arguments. For example, to use
    “non native enumerations” unconditionally, the [`Enum.native_enum`](../core/type_basics.html#sqlalchemy.types.Enum.params.native_enum
    "sqlalchemy.types.Enum") parameter may be set to False for all types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'Changed in version 2.0.1: Implemented support for overriding parameters such
    as [`Enum.native_enum`](../core/type_basics.html#sqlalchemy.types.Enum.params.native_enum
    "sqlalchemy.types.Enum") within the [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum") datatype when establishing the [`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry"). Previously, this functionality was not working.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To use a specific configuration for a specific `enum.Enum` subtype, such as
    setting the string length to 50 when using the example `Status` datatype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'By default [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.types.Enum")
    that are automatically generated are not associated with the `MetaData` instance
    used by the `Base`, so if the metadata defines a schema it will not be automatically
    associated with the enum. To automatically associate the enum with the schema
    in the metadata or table they belong to the [`Enum.inherit_schema`](../core/type_basics.html#sqlalchemy.types.Enum.params.inherit_schema
    "sqlalchemy.types.Enum") can be set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: Linking Specific `enum.Enum` or `typing.Literal` to other datatypes
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The above examples feature the use of an [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum") that is automatically configuring itself to the arguments
    / attributes present on an `enum.Enum` or `typing.Literal` type object. For use
    cases where specific kinds of `enum.Enum` or `typing.Literal` should be linked
    to other types, these specific types may be placed in the type map also. In the
    example below, an entry for `Literal[]` that contains non-string types is linked
    to the [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON")
    datatype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: In the above configuration, the `my_literal` datatype will resolve to a [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON") instance. Other `Literal` variants will continue to resolve
    to [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.types.Enum")
    datatypes.
  prefs: []
  type: TYPE_NORMAL
- en: Dataclass features in `mapped_column()`
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    construct integrates with SQLAlchemy’s “native dataclasses” feature, discussed
    at [Declarative Dataclass Mapping](dataclasses.html#orm-declarative-native-dataclasses).
    See that section for current background on additional directives supported by
    [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column").
  prefs: []
  type: TYPE_NORMAL
- en: '#### `mapped_column()` derives the datatype and nullability from the `Mapped`
    annotation'
  prefs: []
  type: TYPE_NORMAL
- en: 'The two qualities that [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") derives from the [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") annotation are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**datatype** - the Python type given inside [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped"), as contained within the `typing.Optional` construct
    if present, is associated with a [`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") subclass such as [`Integer`](../core/type_basics.html#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer"), [`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String"), [`DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime
    "sqlalchemy.types.DateTime"), or [`Uuid`](../core/type_basics.html#sqlalchemy.types.Uuid
    "sqlalchemy.types.Uuid"), to name a few common types.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The datatype is determined based on a dictionary of Python type to SQLAlchemy
    datatype. This dictionary is completely customizable, as detailed in the next
    section [Customizing the Type Map](#orm-declarative-mapped-column-type-map). The
    default type map is implemented as in the code example below:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If the [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    construct indicates an explicit type as passed to the [`mapped_column.__type`](mapping_api.html#sqlalchemy.orm.mapped_column.params.__type
    "sqlalchemy.orm.mapped_column") argument, then the given Python type is disregarded.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**nullability** - The [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct will indicate its [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") as `NULL` or `NOT NULL` first and foremost by the
    presence of the [`mapped_column.nullable`](mapping_api.html#sqlalchemy.orm.mapped_column.params.nullable
    "sqlalchemy.orm.mapped_column") parameter, passed either as `True` or `False`.
    Additionally , if the [`mapped_column.primary_key`](mapping_api.html#sqlalchemy.orm.mapped_column.params.primary_key
    "sqlalchemy.orm.mapped_column") parameter is present and set to `True`, that will
    also imply that the column should be `NOT NULL`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the absence of **both** of these parameters, the presence of `typing.Optional[]`
    within the [`Mapped`](internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped")
    type annotation will be used to determine nullability, where `typing.Optional[]`
    means `NULL`, and the absence of `typing.Optional[]` means `NOT NULL`. If there
    is no `Mapped[]` annotation present at all, and there is no [`mapped_column.nullable`](mapping_api.html#sqlalchemy.orm.mapped_column.params.nullable
    "sqlalchemy.orm.mapped_column") or [`mapped_column.primary_key`](mapping_api.html#sqlalchemy.orm.mapped_column.params.primary_key
    "sqlalchemy.orm.mapped_column") parameter, then SQLAlchemy’s usual default for
    [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    of `NULL` is used.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the example below, the `id` and `data` columns will be `NOT NULL`, and the
    `additional_info` column will be `NULL`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'It is also perfectly valid to have a [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") whose nullability is **different** from what would
    be implied by the annotation. For example, an ORM mapped attribute may be annotated
    as allowing `None` within Python code that works with the object as it is first
    being created and populated, however the value will ultimately be written to a
    database column that is `NOT NULL`. The [`mapped_column.nullable`](mapping_api.html#sqlalchemy.orm.mapped_column.params.nullable
    "sqlalchemy.orm.mapped_column") parameter, when present, will always take precedence:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Similarly, a non-None attribute that’s written to a database column that for
    whatever reason needs to be NULL at the schema level, [`mapped_column.nullable`](mapping_api.html#sqlalchemy.orm.mapped_column.params.nullable
    "sqlalchemy.orm.mapped_column") may be set to `True`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '#### Customizing the Type Map'
  prefs: []
  type: TYPE_NORMAL
- en: The mapping of Python types to SQLAlchemy [`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") types described in the previous section defaults
    to a hardcoded dictionary present in the `sqlalchemy.sql.sqltypes` module. However,
    the [`registry`](mapping_api.html#sqlalchemy.orm.registry "sqlalchemy.orm.registry")
    object that coordinates the Declarative mapping process will first consult a local,
    user defined dictionary of types which may be passed as the [`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry") parameter when constructing the [`registry`](mapping_api.html#sqlalchemy.orm.registry
    "sqlalchemy.orm.registry"), which may be associated with the [`DeclarativeBase`](mapping_api.html#sqlalchemy.orm.DeclarativeBase
    "sqlalchemy.orm.DeclarativeBase") superclass when first used.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, if we wish to make use of the [`BIGINT`](../core/type_basics.html#sqlalchemy.types.BIGINT
    "sqlalchemy.types.BIGINT") datatype for `int`, the [`TIMESTAMP`](../core/type_basics.html#sqlalchemy.types.TIMESTAMP
    "sqlalchemy.types.TIMESTAMP") datatype with `timezone=True` for `datetime.datetime`,
    and then only on Microsoft SQL Server we’d like to use [`NVARCHAR`](../core/type_basics.html#sqlalchemy.types.NVARCHAR
    "sqlalchemy.types.NVARCHAR") datatype when Python `str` is used, the registry
    and Declarative base could be configured as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: 'Below illustrates the CREATE TABLE statement generated for the above mapping,
    first on the Microsoft SQL Server backend, illustrating the `NVARCHAR` datatype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: 'Then on the PostgreSQL backend, illustrating `TIMESTAMP WITH TIME ZONE`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: By making use of methods such as [`TypeEngine.with_variant()`](../core/type_api.html#sqlalchemy.types.TypeEngine.with_variant
    "sqlalchemy.types.TypeEngine.with_variant"), we’re able to build up a type map
    that’s customized to what we need for different backends, while still being able
    to use succinct annotation-only [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") configurations. There are two more levels of Python-type
    configurability available beyond this, described in the next two sections.
  prefs: []
  type: TYPE_NORMAL
- en: '#### Mapping Multiple Type Configurations to Python Types'
  prefs: []
  type: TYPE_NORMAL
- en: As individual Python types may be associated with [`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") configurations of any variety by using the [`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry") parameter, an additional capability is the ability
    to associate a single Python type with different variants of a SQL type based
    on additional type qualifiers. One typical example of this is mapping the Python
    `str` datatype to `VARCHAR` SQL types of different lengths. Another is mapping
    different varieties of `decimal.Decimal` to differently sized `NUMERIC` columns.
  prefs: []
  type: TYPE_NORMAL
- en: 'Python’s typing system provides a great way to add additional metadata to a
    Python type which is by using the [**PEP 593**](https://peps.python.org/pep-0593/)
    `Annotated` generic type, which allows additional information to be bundled along
    with a Python type. The [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct will correctly interpret an `Annotated`
    object by identity when resolving it in the [`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry"), as in the example below where we declare two variants
    of [`String`](../core/type_basics.html#sqlalchemy.types.String "sqlalchemy.types.String")
    and [`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric "sqlalchemy.types.Numeric"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: 'The Python type passed to the `Annotated` container, in the above example the
    `str` and `Decimal` types, is important only for the benefit of typing tools;
    as far as the [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct is concerned, it will only need perform
    a lookup of each type object in the [`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry") dictionary without actually looking inside of the `Annotated`
    object, at least in this particular context. Similarly, the arguments passed to
    `Annotated` beyond the underlying Python type itself are also not important, it’s
    only that at least one argument must be present for the `Annotated` construct
    to be valid. We can then use these augmented types directly in our mapping where
    they will be matched to the more specific type constructions, as in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: 'a CREATE TABLE for the above mapping will illustrate the different variants
    of `VARCHAR` and `NUMERIC` we’ve configured, and looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: While variety in linking `Annotated` types to different SQL types grants us
    a wide degree of flexibility, the next section illustrates a second way in which
    `Annotated` may be used with Declarative that is even more open ended.
  prefs: []
  type: TYPE_NORMAL
- en: '#### Mapping Whole Column Declarations to Python Types'
  prefs: []
  type: TYPE_NORMAL
- en: The previous section illustrated using [**PEP 593**](https://peps.python.org/pep-0593/)
    `Annotated` type instances as keys within the [`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry") dictionary. In this form, the [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct does not actually look inside the `Annotated`
    object itself, it’s instead used only as a dictionary key. However, Declarative
    also has the ability to extract an entire pre-established [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct from an `Annotated` object directly.
    Using this form, we can define not only different varieties of SQL datatypes linked
    to Python types without using the [`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry") dictionary, we can also set up any number of arguments
    such as nullability, column defaults, and constraints in a reusable fashion.
  prefs: []
  type: TYPE_NORMAL
- en: A set of ORM models will usually have some kind of primary key style that is
    common to all mapped classes. There also may be common column configurations such
    as timestamps with defaults and other fields of pre-established sizes and configurations.
    We can compose these configurations into [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") instances that we then bundle directly into instances
    of `Annotated`, which are then re-used in any number of class declarations. Declarative
    will unpack an `Annotated` object when provided in this manner, skipping over
    any other directives that don’t apply to SQLAlchemy and searching only for SQLAlchemy
    ORM constructs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The example below illustrates a variety of pre-configured field types used
    in this way, where we define `intpk` that represents an [`Integer`](../core/type_basics.html#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer") primary key column, `timestamp` that represents a
    [`DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime "sqlalchemy.types.DateTime")
    type which will use `CURRENT_TIMESTAMP` as a DDL level column default, and `required_name`
    which is a [`String`](../core/type_basics.html#sqlalchemy.types.String "sqlalchemy.types.String")
    of length 30 that’s `NOT NULL`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: 'The above `Annotated` objects can then be used directly within [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped"), where the pre-configured [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") constructs will be extracted and copied to a new
    instance that will be specific to each attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: '`CREATE TABLE` for our above mapping looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: 'When using `Annotated` types in this way, the configuration of the type may
    also be affected on a per-attribute basis. For the types in the above example
    that feature explicit use of [`mapped_column.nullable`](mapping_api.html#sqlalchemy.orm.mapped_column.params.nullable
    "sqlalchemy.orm.mapped_column"), we can apply the `Optional[]` generic modifier
    to any of our types so that the field is optional or not at the Python level,
    which will be independent of the `NULL` / `NOT NULL` setting that takes place
    in the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: 'The [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    construct is also reconciled with an explicitly passed [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct, whose arguments will take precedence
    over those of the `Annotated` construct. Below we add a [`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey") constraint to our integer primary key and also
    use an alternate server default for the `created_at` column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: 'The CREATE TABLE statement illustrates these per-attribute settings, adding
    a `FOREIGN KEY` constraint as well as substituting `UTC_TIMESTAMP` for `CURRENT_TIMESTAMP`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The feature of [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") just described, where a fully constructed set
    of column arguments may be indicated using [**PEP 593**](https://peps.python.org/pep-0593/)
    `Annotated` objects that contain a “template” [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") object to be copied into the attribute, is currently
    not implemented for other ORM constructs such as [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") and [`composite()`](composites.html#sqlalchemy.orm.composite
    "sqlalchemy.orm.composite"). While this functionality is in theory possible, for
    the moment attempting to use `Annotated` to indicate further arguments for [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") and similar will raise a `NotImplementedError`
    exception at runtime, but may be implemented in future releases.
  prefs: []
  type: TYPE_NORMAL
- en: '#### Using Python `Enum` or pep-586 `Literal` types in the type map'
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 2.0.0b4: - Added `Enum` support'
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 2.0.1: - Added `Literal` support'
  prefs: []
  type: TYPE_NORMAL
- en: 'User-defined Python types which derive from the Python built-in `enum.Enum`
    as well as the `typing.Literal` class are automatically linked to the SQLAlchemy
    [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.types.Enum")
    datatype when used in an ORM declarative mapping. The example below uses a custom
    `enum.Enum` within the `Mapped[]` constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: 'In the above example, the mapped attribute `SomeClass.status` will be linked
    to a [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    with the datatype of `Enum(Status)`. We can see this for example in the CREATE
    TABLE output for the PostgreSQL database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: 'In a similar way, `typing.Literal` may be used instead, using a `typing.Literal`
    that consists of all strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: 'The entries used in [`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry") link the base `enum.Enum` Python type as well as the
    `typing.Literal` type to the SQLAlchemy [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum") SQL type, using a special form which indicates to the
    [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.types.Enum")
    datatype that it should automatically configure itself against an arbitrary enumerated
    type. This configuration, which is implicit by default, would be indicated explicitly
    as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: The resolution logic within Declarative is able to resolve subclasses of `enum.Enum`
    as well as instances of `typing.Literal` to match the `enum.Enum` or `typing.Literal`
    entry in the [`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry") dictionary. The [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum") SQL type then knows how to produce a configured version
    of itself with the appropriate settings, including default string length. If a
    `typing.Literal` that does not consist of only string values is passed, an informative
    error is raised.
  prefs: []
  type: TYPE_NORMAL
- en: Native Enums and Naming
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The [`Enum.native_enum`](../core/type_basics.html#sqlalchemy.types.Enum.params.native_enum
    "sqlalchemy.sql.sqltypes.Enum") parameter refers to if the [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.sql.sqltypes.Enum") datatype should create a so-called “native” enum,
    which on MySQL/MariaDB is the `ENUM` datatype and on PostgreSQL is a new `TYPE`
    object created by `CREATE TYPE`, or a “non-native” enum, which means that `VARCHAR`
    will be used to create the datatype. For backends other than MySQL/MariaDB or
    PostgreSQL, `VARCHAR` is used in all cases (third party dialects may have their
    own behaviors).
  prefs: []
  type: TYPE_NORMAL
- en: 'Because PostgreSQL’s `CREATE TYPE` requires that there’s an explicit name for
    the type to be created, special fallback logic exists when working with implicitly
    generated [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.sql.sqltypes.Enum")
    without specifying an explicit [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.sql.sqltypes.Enum") datatype within a mapping:'
  prefs: []
  type: TYPE_NORMAL
- en: If the [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.sql.sqltypes.Enum")
    is linked to an `enum.Enum` object, the [`Enum.native_enum`](../core/type_basics.html#sqlalchemy.types.Enum.params.native_enum
    "sqlalchemy.sql.sqltypes.Enum") parameter defaults to `True` and the name of the
    enum will be taken from the name of the `enum.Enum` datatype. The PostgreSQL backend
    will assume `CREATE TYPE` with this name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.sql.sqltypes.Enum")
    is linked to a `typing.Literal` object, the [`Enum.native_enum`](../core/type_basics.html#sqlalchemy.types.Enum.params.native_enum
    "sqlalchemy.sql.sqltypes.Enum") parameter defaults to `False`; no name is generated
    and `VARCHAR` is assumed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To use `typing.Literal` with a PostgreSQL `CREATE TYPE` type, an explicit [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.sql.sqltypes.Enum") must be used, either within the type map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: 'Or alternatively within [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: Altering the Configuration of the Default Enum
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In order to modify the fixed configuration of the `Enum` datatype that’s generated
    implicitly, specify new entries in the [`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry"), indicating additional arguments. For example, to use
    “non native enumerations” unconditionally, the [`Enum.native_enum`](../core/type_basics.html#sqlalchemy.types.Enum.params.native_enum
    "sqlalchemy.types.Enum") parameter may be set to False for all types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: 'Changed in version 2.0.1: Implemented support for overriding parameters such
    as [`Enum.native_enum`](../core/type_basics.html#sqlalchemy.types.Enum.params.native_enum
    "sqlalchemy.types.Enum") within the [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum") datatype when establishing the [`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry"). Previously, this functionality was not working.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To use a specific configuration for a specific `enum.Enum` subtype, such as
    setting the string length to 50 when using the example `Status` datatype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: 'By default [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.types.Enum")
    that are automatically generated are not associated with the `MetaData` instance
    used by the `Base`, so if the metadata defines a schema it will not be automatically
    associated with the enum. To automatically associate the enum with the schema
    in the metadata or table they belong to the [`Enum.inherit_schema`](../core/type_basics.html#sqlalchemy.types.Enum.params.inherit_schema
    "sqlalchemy.types.Enum") can be set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: Linking Specific `enum.Enum` or `typing.Literal` to other datatypes
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The above examples feature the use of an [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum") that is automatically configuring itself to the arguments
    / attributes present on an `enum.Enum` or `typing.Literal` type object. For use
    cases where specific kinds of `enum.Enum` or `typing.Literal` should be linked
    to other types, these specific types may be placed in the type map also. In the
    example below, an entry for `Literal[]` that contains non-string types is linked
    to the [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON")
    datatype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: In the above configuration, the `my_literal` datatype will resolve to a [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON") instance. Other `Literal` variants will continue to resolve
    to [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.types.Enum")
    datatypes.
  prefs: []
  type: TYPE_NORMAL
- en: Native Enums and Naming
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: The [`Enum.native_enum`](../core/type_basics.html#sqlalchemy.types.Enum.params.native_enum
    "sqlalchemy.sql.sqltypes.Enum") parameter refers to if the [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.sql.sqltypes.Enum") datatype should create a so-called “native” enum,
    which on MySQL/MariaDB is the `ENUM` datatype and on PostgreSQL is a new `TYPE`
    object created by `CREATE TYPE`, or a “non-native” enum, which means that `VARCHAR`
    will be used to create the datatype. For backends other than MySQL/MariaDB or
    PostgreSQL, `VARCHAR` is used in all cases (third party dialects may have their
    own behaviors).
  prefs: []
  type: TYPE_NORMAL
- en: 'Because PostgreSQL’s `CREATE TYPE` requires that there’s an explicit name for
    the type to be created, special fallback logic exists when working with implicitly
    generated [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.sql.sqltypes.Enum")
    without specifying an explicit [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.sql.sqltypes.Enum") datatype within a mapping:'
  prefs: []
  type: TYPE_NORMAL
- en: If the [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.sql.sqltypes.Enum")
    is linked to an `enum.Enum` object, the [`Enum.native_enum`](../core/type_basics.html#sqlalchemy.types.Enum.params.native_enum
    "sqlalchemy.sql.sqltypes.Enum") parameter defaults to `True` and the name of the
    enum will be taken from the name of the `enum.Enum` datatype. The PostgreSQL backend
    will assume `CREATE TYPE` with this name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.sql.sqltypes.Enum")
    is linked to a `typing.Literal` object, the [`Enum.native_enum`](../core/type_basics.html#sqlalchemy.types.Enum.params.native_enum
    "sqlalchemy.sql.sqltypes.Enum") parameter defaults to `False`; no name is generated
    and `VARCHAR` is assumed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To use `typing.Literal` with a PostgreSQL `CREATE TYPE` type, an explicit [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.sql.sqltypes.Enum") must be used, either within the type map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: 'Or alternatively within [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: Altering the Configuration of the Default Enum
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'In order to modify the fixed configuration of the `Enum` datatype that’s generated
    implicitly, specify new entries in the [`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry"), indicating additional arguments. For example, to use
    “non native enumerations” unconditionally, the [`Enum.native_enum`](../core/type_basics.html#sqlalchemy.types.Enum.params.native_enum
    "sqlalchemy.types.Enum") parameter may be set to False for all types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: 'Changed in version 2.0.1: Implemented support for overriding parameters such
    as [`Enum.native_enum`](../core/type_basics.html#sqlalchemy.types.Enum.params.native_enum
    "sqlalchemy.types.Enum") within the [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum") datatype when establishing the [`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry"). Previously, this functionality was not working.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To use a specific configuration for a specific `enum.Enum` subtype, such as
    setting the string length to 50 when using the example `Status` datatype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: 'By default [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.types.Enum")
    that are automatically generated are not associated with the `MetaData` instance
    used by the `Base`, so if the metadata defines a schema it will not be automatically
    associated with the enum. To automatically associate the enum with the schema
    in the metadata or table they belong to the [`Enum.inherit_schema`](../core/type_basics.html#sqlalchemy.types.Enum.params.inherit_schema
    "sqlalchemy.types.Enum") can be set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: Linking Specific `enum.Enum` or `typing.Literal` to other datatypes
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The above examples feature the use of an [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum") that is automatically configuring itself to the arguments
    / attributes present on an `enum.Enum` or `typing.Literal` type object. For use
    cases where specific kinds of `enum.Enum` or `typing.Literal` should be linked
    to other types, these specific types may be placed in the type map also. In the
    example below, an entry for `Literal[]` that contains non-string types is linked
    to the [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON")
    datatype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: In the above configuration, the `my_literal` datatype will resolve to a [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON") instance. Other `Literal` variants will continue to resolve
    to [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.types.Enum")
    datatypes.
  prefs: []
  type: TYPE_NORMAL
- en: Dataclass features in `mapped_column()`
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    construct integrates with SQLAlchemy’s “native dataclasses” feature, discussed
    at [Declarative Dataclass Mapping](dataclasses.html#orm-declarative-native-dataclasses).
    See that section for current background on additional directives supported by
    [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column").
  prefs: []
  type: TYPE_NORMAL
- en: '### Accessing Table and Metadata'
  prefs: []
  type: TYPE_NORMAL
- en: 'A declaratively mapped class will always include an attribute called `__table__`;
    when the above configuration using `__tablename__` is complete, the declarative
    process makes the [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    available via the `__table__` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: 'The above table is ultimately the same one that corresponds to the [`Mapper.local_table`](mapping_api.html#sqlalchemy.orm.Mapper.local_table
    "sqlalchemy.orm.Mapper.local_table") attribute, which we can see through the [runtime
    inspection system](../core/inspection.html):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: 'The [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData "sqlalchemy.schema.MetaData")
    collection associated with both the declarative [`registry`](mapping_api.html#sqlalchemy.orm.registry
    "sqlalchemy.orm.registry") as well as the base class is frequently necessary in
    order to run DDL operations such as CREATE, as well as in use with migration tools
    such as Alembic. This object is available via the `.metadata` attribute of [`registry`](mapping_api.html#sqlalchemy.orm.registry
    "sqlalchemy.orm.registry") as well as the declarative base class. Below, for a
    small script we may wish to emit a CREATE for all tables against a SQLite database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: '### Declarative Table Configuration'
  prefs: []
  type: TYPE_NORMAL
- en: When using Declarative Table configuration with the `__tablename__` declarative
    class attribute, additional arguments to be supplied to the [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") constructor should be provided using the `__table_args__`
    declarative class attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'This attribute accommodates both positional as well as keyword arguments that
    are normally sent to the [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") constructor. The attribute can be specified in one
    of two forms. One is as a dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: 'The other, a tuple, where each argument is positional (usually constraints):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: 'Keyword arguments can be specified with the above form by specifying the last
    argument as a dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: A class may also specify the `__table_args__` declarative attribute, as well
    as the `__tablename__` attribute, in a dynamic style using the [`declared_attr()`](mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr") method decorator. See [Composing Mapped Hierarchies
    with Mixins](declarative_mixins.html) for background.
  prefs: []
  type: TYPE_NORMAL
- en: '### Explicit Schema Name with Declarative Table'
  prefs: []
  type: TYPE_NORMAL
- en: 'The schema name for a [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") as documented at [Specifying the Schema Name](../core/metadata.html#schema-table-schema-name)
    is applied to an individual [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") using the [`Table.schema`](../core/metadata.html#sqlalchemy.schema.Table.params.schema
    "sqlalchemy.schema.Table") argument. When using Declarative tables, this option
    is passed like any other to the `__table_args__` dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: 'The schema name can also be applied to all [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects globally by using the [`MetaData.schema`](../core/metadata.html#sqlalchemy.schema.MetaData.params.schema
    "sqlalchemy.schema.MetaData") parameter documented at [Specifying a Default Schema
    Name with MetaData](../core/metadata.html#schema-metadata-schema-name). The [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") object may be constructed separately and associated
    with a [`DeclarativeBase`](mapping_api.html#sqlalchemy.orm.DeclarativeBase "sqlalchemy.orm.DeclarativeBase")
    subclass by assigning to the `metadata` attribute directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Specifying the Schema Name](../core/metadata.html#schema-table-schema-name)
    - in the [Describing Databases with MetaData](../core/metadata.html) documentation.'
  prefs: []
  type: TYPE_NORMAL
- en: '### Setting Load and Persistence Options for Declarative Mapped Columns'
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    construct accepts additional ORM-specific arguments that affect how the generated
    [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    is mapped, affecting its load and persistence-time behavior. Options that are
    commonly used include:'
  prefs: []
  type: TYPE_NORMAL
- en: '**deferred column loading** - The [`mapped_column.deferred`](mapping_api.html#sqlalchemy.orm.mapped_column.params.deferred
    "sqlalchemy.orm.mapped_column") boolean establishes the [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") using [deferred column loading](queryguide/columns.html#orm-queryguide-column-deferral)
    by default. In the example below, the `User.bio` column will not be loaded by
    default, but only when accessed:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[Limiting which Columns Load with Column Deferral](queryguide/columns.html#orm-queryguide-column-deferral)
    - full description of deferred column loading'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**active history** - The [`mapped_column.active_history`](mapping_api.html#sqlalchemy.orm.mapped_column.params.active_history
    "sqlalchemy.orm.mapped_column") ensures that upon change of value for the attribute,
    the previous value will have been loaded and made part of the [`AttributeState.history`](internals.html#sqlalchemy.orm.AttributeState.history
    "sqlalchemy.orm.AttributeState.history") collection when inspecting the history
    of the attribute. This may incur additional SQL statements:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: See the docstring for [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") for a list of supported parameters.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Applying Load, Persistence and Mapping Options for Imperative Table Columns](#orm-imperative-table-column-options)
    - describes using [`column_property()`](mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property") and [`deferred()`](queryguide/columns.html#sqlalchemy.orm.deferred
    "sqlalchemy.orm.deferred") for use with Imperative Table configuration'
  prefs: []
  type: TYPE_NORMAL
- en: '### Naming Declarative Mapped Columns Explicitly'
  prefs: []
  type: TYPE_NORMAL
- en: 'All of the examples thus far feature the [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct linked to an ORM mapped attribute, where
    the Python attribute name given to the [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") is also that of the column as we see in CREATE
    TABLE statements as well as queries. The name for a column as expressed in SQL
    may be indicated by passing the string positional argument [`mapped_column.__name`](mapping_api.html#sqlalchemy.orm.mapped_column.params.__name
    "sqlalchemy.orm.mapped_column") as the first positional argument. In the example
    below, the `User` class is mapped with alternate names given to the columns themselves:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: 'Where above `User.id` resolves to a column named `user_id` and `User.name`
    resolves to a column named `user_name`. We may write a [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") statement using our Python attribute names
    and will see the SQL names generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Alternate Attribute Names for Mapping Table Columns](#orm-imperative-table-column-naming)
    - applies to Imperative Table'
  prefs: []
  type: TYPE_NORMAL
- en: '### Appending additional columns to an existing Declarative mapped class'
  prefs: []
  type: TYPE_NORMAL
- en: A declarative table configuration allows the addition of new [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects to an existing mapping after the [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") metadata has already been generated.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a declarative class that is declared using a declarative base class, the
    underlying metaclass `DeclarativeMeta` includes a `__setattr__()` method that
    will intercept additional [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") or Core [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects and add them to both the [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") using [`Table.append_column()`](../core/metadata.html#sqlalchemy.schema.Table.append_column
    "sqlalchemy.schema.Table.append_column") as well as to the existing [`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper") using [`Mapper.add_property()`](mapping_api.html#sqlalchemy.orm.Mapper.add_property
    "sqlalchemy.orm.Mapper.add_property"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: 'Using core [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: All arguments are supported including an alternate name, such as `MyClass.some_new_column
    = mapped_column("some_name", String)`. However, the SQL type must be passed to
    the [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    or [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    object explicitly, as in the above examples where the [`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String") type is passed. There’s no capability for the [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") annotation type to take part in the operation.
  prefs: []
  type: TYPE_NORMAL
- en: Additional [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    objects may also be added to a mapping in the specific circumstance of using single
    table inheritance, where additional columns are present on mapped subclasses that
    have no [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    of their own. This is illustrated in the section [Single Table Inheritance](inheritance.html#single-inheritance).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Adding Relationships to Mapped Classes After Declaration](basic_relationships.html#orm-declarative-table-adding-relationship)
    - similar examples for [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Assignment of mapped properties to an already mapped class will only function
    correctly if the “declarative base” class is used, meaning the user-defined subclass
    of [`DeclarativeBase`](mapping_api.html#sqlalchemy.orm.DeclarativeBase "sqlalchemy.orm.DeclarativeBase")
    or the dynamically generated class returned by [`declarative_base()`](mapping_api.html#sqlalchemy.orm.declarative_base
    "sqlalchemy.orm.declarative_base") or [`registry.generate_base()`](mapping_api.html#sqlalchemy.orm.registry.generate_base
    "sqlalchemy.orm.registry.generate_base"). This “base” class includes a Python
    metaclass which implements a special `__setattr__()` method that intercepts these
    operations.
  prefs: []
  type: TYPE_NORMAL
- en: Runtime assignment of class-mapped attributes to a mapped class will **not**
    work if the class is mapped using decorators like [`registry.mapped()`](mapping_api.html#sqlalchemy.orm.registry.mapped
    "sqlalchemy.orm.registry.mapped") or imperative functions like [`registry.map_imperatively()`](mapping_api.html#sqlalchemy.orm.registry.map_imperatively
    "sqlalchemy.orm.registry.map_imperatively").
  prefs: []
  type: TYPE_NORMAL
- en: '## Declarative with Imperative Table (a.k.a. Hybrid Declarative)'
  prefs: []
  type: TYPE_NORMAL
- en: Declarative mappings may also be provided with a pre-existing [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") object, or otherwise a [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") or other arbitrary [`FromClause`](../core/selectable.html#sqlalchemy.sql.expression.FromClause
    "sqlalchemy.sql.expression.FromClause") construct (such as a [`Join`](../core/selectable.html#sqlalchemy.sql.expression.Join
    "sqlalchemy.sql.expression.Join") or [`Subquery`](../core/selectable.html#sqlalchemy.sql.expression.Subquery
    "sqlalchemy.sql.expression.Subquery")) that is constructed separately.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is referred to as a “hybrid declarative” mapping, as the class is mapped
    using the declarative style for everything involving the mapper configuration,
    however the mapped [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    object is produced separately and passed to the declarative process directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: 'Above, a [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    object is constructed using the approach described at [Describing Databases with
    MetaData](../core/metadata.html#metadata-describing). It can then be applied directly
    to a class that is declaratively mapped. The `__tablename__` and `__table_args__`
    declarative class attributes are not used in this form. The above configuration
    is often more readable as an inline definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: 'A natural effect of the above style is that the `__table__` attribute is itself
    defined within the class definition block. As such it may be immediately referenced
    within subsequent attributes, such as the example below which illustrates referring
    to the `type` column in a polymorphic mapper configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: 'The “imperative table” form is also used when a non-[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") construct, such as a [`Join`](../core/selectable.html#sqlalchemy.sql.expression.Join
    "sqlalchemy.sql.expression.Join") or [`Subquery`](../core/selectable.html#sqlalchemy.sql.expression.Subquery
    "sqlalchemy.sql.expression.Subquery") object, is to be mapped. An example below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: For background on mapping to non-[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") constructs see the sections [Mapping a Class against
    Multiple Tables](nonstandard_mappings.html#orm-mapping-joins) and [Mapping a Class
    against Arbitrary Subqueries](nonstandard_mappings.html#orm-mapping-arbitrary-subqueries).
  prefs: []
  type: TYPE_NORMAL
- en: The “imperative table” form is of particular use when the class itself is using
    an alternative form of attribute declaration, such as Python dataclasses. See
    the section [Applying ORM Mappings to an existing dataclass (legacy dataclass
    use)](dataclasses.html#orm-declarative-dataclasses) for detail.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Describing Databases with MetaData](../core/metadata.html#metadata-describing)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Applying ORM Mappings to an existing dataclass (legacy dataclass use)](dataclasses.html#orm-declarative-dataclasses)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Alternate Attribute Names for Mapping Table Columns'
  prefs: []
  type: TYPE_NORMAL
- en: The section [Naming Declarative Mapped Columns Explicitly](#orm-declarative-table-column-naming)
    illustrated how to use [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") to provide a specific name for the generated [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") object separate from the attribute name under which
    it is mapped.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using Imperative Table configuration, we already have [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects present. To map these to alternate names we
    may assign the [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    to the desired attributes directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: The `User` mapping above will refer to the `"user_id"` and `"user_name"` columns
    via the `User.id` and `User.name` attributes, in the same way as demonstrated
    at [Naming Declarative Mapped Columns Explicitly](#orm-declarative-table-column-naming).
  prefs: []
  type: TYPE_NORMAL
- en: 'One caveat to the above mapping is that the direct inline link to [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") will not be typed correctly when using [**PEP 484**](https://peps.python.org/pep-0484/)
    typing tools. A strategy to resolve this is to apply the [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects within the [`column_property()`](mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property") function; while the [`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper") already generates this property object for its internal
    use automatically, by naming it in the class declaration, typing tools will be
    able to match the attribute to the [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Naming Declarative Mapped Columns Explicitly](#orm-declarative-table-column-naming)
    - applies to Declarative Table  ### Applying Load, Persistence and Mapping Options
    for Imperative Table Columns'
  prefs: []
  type: TYPE_NORMAL
- en: 'The section [Setting Load and Persistence Options for Declarative Mapped Columns](#orm-declarative-column-options)
    reviewed how to set load and persistence options when using the [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct with Declarative Table configuration.
    When using Imperative Table configuration, we already have existing [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects that are mapped. In order to map these [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects along with additional parameters that are
    specific to the ORM mapping, we may use the [`column_property()`](mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property") and [`deferred()`](queryguide/columns.html#sqlalchemy.orm.deferred
    "sqlalchemy.orm.deferred") constructs in order to associate additional parameters
    with the column. Options include:'
  prefs: []
  type: TYPE_NORMAL
- en: '**deferred column loading** - The [`deferred()`](queryguide/columns.html#sqlalchemy.orm.deferred
    "sqlalchemy.orm.deferred") function is shorthand for invoking [`column_property()`](mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property") with the [`column_property.deferred`](mapping_api.html#sqlalchemy.orm.column_property.params.deferred
    "sqlalchemy.orm.column_property") parameter set to `True`; this construct establishes
    the [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    using [deferred column loading](queryguide/columns.html#orm-queryguide-column-deferral)
    by default. In the example below, the `User.bio` column will not be loaded by
    default, but only when accessed:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[Limiting which Columns Load with Column Deferral](queryguide/columns.html#orm-queryguide-column-deferral)
    - full description of deferred column loading'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**active history** - The [`column_property.active_history`](mapping_api.html#sqlalchemy.orm.column_property.params.active_history
    "sqlalchemy.orm.column_property") ensures that upon change of value for the attribute,
    the previous value will have been loaded and made part of the [`AttributeState.history`](internals.html#sqlalchemy.orm.AttributeState.history
    "sqlalchemy.orm.AttributeState.history") collection when inspecting the history
    of the attribute. This may incur additional SQL statements:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`column_property()`](mapping_api.html#sqlalchemy.orm.column_property "sqlalchemy.orm.column_property")
    construct is also important for cases where classes are mapped to alternative
    FROM clauses such as joins and selects. More background on these cases is at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Mapping a Class against Multiple Tables](nonstandard_mappings.html#maptojoin)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[SQL Expressions as Mapped Attributes](mapped_sql_expr.html#mapper-sql-expressions)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For Declarative Table configuration with [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column"), most options are available directly; see the
    section [Setting Load and Persistence Options for Declarative Mapped Columns](#orm-declarative-column-options)
    for examples.  ### Alternate Attribute Names for Mapping Table Columns'
  prefs: []
  type: TYPE_NORMAL
- en: The section [Naming Declarative Mapped Columns Explicitly](#orm-declarative-table-column-naming)
    illustrated how to use [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") to provide a specific name for the generated [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") object separate from the attribute name under which
    it is mapped.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using Imperative Table configuration, we already have [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects present. To map these to alternate names we
    may assign the [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    to the desired attributes directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: The `User` mapping above will refer to the `"user_id"` and `"user_name"` columns
    via the `User.id` and `User.name` attributes, in the same way as demonstrated
    at [Naming Declarative Mapped Columns Explicitly](#orm-declarative-table-column-naming).
  prefs: []
  type: TYPE_NORMAL
- en: 'One caveat to the above mapping is that the direct inline link to [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") will not be typed correctly when using [**PEP 484**](https://peps.python.org/pep-0484/)
    typing tools. A strategy to resolve this is to apply the [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects within the [`column_property()`](mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property") function; while the [`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper") already generates this property object for its internal
    use automatically, by naming it in the class declaration, typing tools will be
    able to match the attribute to the [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") annotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Naming Declarative Mapped Columns Explicitly](#orm-declarative-table-column-naming)
    - applies to Declarative Table'
  prefs: []
  type: TYPE_NORMAL
- en: '### Applying Load, Persistence and Mapping Options for Imperative Table Columns'
  prefs: []
  type: TYPE_NORMAL
- en: 'The section [Setting Load and Persistence Options for Declarative Mapped Columns](#orm-declarative-column-options)
    reviewed how to set load and persistence options when using the [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct with Declarative Table configuration.
    When using Imperative Table configuration, we already have existing [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects that are mapped. In order to map these [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects along with additional parameters that are
    specific to the ORM mapping, we may use the [`column_property()`](mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property") and [`deferred()`](queryguide/columns.html#sqlalchemy.orm.deferred
    "sqlalchemy.orm.deferred") constructs in order to associate additional parameters
    with the column. Options include:'
  prefs: []
  type: TYPE_NORMAL
- en: '**deferred column loading** - The [`deferred()`](queryguide/columns.html#sqlalchemy.orm.deferred
    "sqlalchemy.orm.deferred") function is shorthand for invoking [`column_property()`](mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property") with the [`column_property.deferred`](mapping_api.html#sqlalchemy.orm.column_property.params.deferred
    "sqlalchemy.orm.column_property") parameter set to `True`; this construct establishes
    the [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    using [deferred column loading](queryguide/columns.html#orm-queryguide-column-deferral)
    by default. In the example below, the `User.bio` column will not be loaded by
    default, but only when accessed:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE188]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[Limiting which Columns Load with Column Deferral](queryguide/columns.html#orm-queryguide-column-deferral)
    - full description of deferred column loading'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**active history** - The [`column_property.active_history`](mapping_api.html#sqlalchemy.orm.column_property.params.active_history
    "sqlalchemy.orm.column_property") ensures that upon change of value for the attribute,
    the previous value will have been loaded and made part of the [`AttributeState.history`](internals.html#sqlalchemy.orm.AttributeState.history
    "sqlalchemy.orm.AttributeState.history") collection when inspecting the history
    of the attribute. This may incur additional SQL statements:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE189]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`column_property()`](mapping_api.html#sqlalchemy.orm.column_property "sqlalchemy.orm.column_property")
    construct is also important for cases where classes are mapped to alternative
    FROM clauses such as joins and selects. More background on these cases is at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Mapping a Class against Multiple Tables](nonstandard_mappings.html#maptojoin)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[SQL Expressions as Mapped Attributes](mapped_sql_expr.html#mapper-sql-expressions)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For Declarative Table configuration with [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column"), most options are available directly; see the
    section [Setting Load and Persistence Options for Declarative Mapped Columns](#orm-declarative-column-options)
    for examples.
  prefs: []
  type: TYPE_NORMAL
- en: '## Mapping Declaratively with Reflected Tables'
  prefs: []
  type: TYPE_NORMAL
- en: There are several patterns available which provide for producing mapped classes
    against a series of [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    objects that were introspected from the database, using the reflection process
    described at [Reflecting Database Objects](../core/reflection.html#metadata-reflection).
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple way to map a class to a table reflected from the database is to use
    a declarative hybrid mapping, passing the [`Table.autoload_with`](../core/metadata.html#sqlalchemy.schema.Table.params.autoload_with
    "sqlalchemy.schema.Table") parameter to the constructor for [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: 'A variant on the above pattern that scales for many tables is to use the [`MetaData.reflect()`](../core/metadata.html#sqlalchemy.schema.MetaData.reflect
    "sqlalchemy.schema.MetaData.reflect") method to reflect a full set of [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects at once, then refer to them from the [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: One caveat to the approach of using `__table__` is that the mapped classes cannot
    be declared until the tables have been reflected, which requires the database
    connectivity source to be present while the application classes are being declared;
    it’s typical that classes are declared as the modules of an application are being
    imported, but database connectivity isn’t available until the application starts
    running code so that it can consume configuration information and create an engine.
    There are currently two approaches to working around this, described in the next
    two sections.
  prefs: []
  type: TYPE_NORMAL
- en: '### Using DeferredReflection'
  prefs: []
  type: TYPE_NORMAL
- en: 'To accommodate the use case of declaring mapped classes where reflection of
    table metadata can occur afterwards, a simple extension called the [`DeferredReflection`](extensions/declarative/index.html#sqlalchemy.ext.declarative.DeferredReflection
    "sqlalchemy.ext.declarative.DeferredReflection") mixin is available, which alters
    the declarative mapping process to be delayed until a special class-level [`DeferredReflection.prepare()`](extensions/declarative/index.html#sqlalchemy.ext.declarative.DeferredReflection.prepare
    "sqlalchemy.ext.declarative.DeferredReflection.prepare") method is called, which
    will perform the reflection process against a target database, and will integrate
    the results with the declarative table mapping process, that is, classes which
    use the `__tablename__` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: 'Above, we create a mixin class `Reflected` that will serve as a base for classes
    in our declarative hierarchy that should become mapped when the `Reflected.prepare`
    method is called. The above mapping is not complete until we do so, given an [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: The purpose of the `Reflected` class is to define the scope at which classes
    should be reflectively mapped. The plugin will search among the subclass tree
    of the target against which `.prepare()` is called and reflect all tables which
    are named by declared classes; tables in the target database that are not part
    of mappings and are not related to the target tables via foreign key constraint
    will not be reflected.
  prefs: []
  type: TYPE_NORMAL
- en: Using Automap
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A more automated solution to mapping against an existing database where table
    reflection is to be used is to use the [Automap](extensions/automap.html) extension.
    This extension will generate entire mapped classes from a database schema, including
    relationships between classes based on observed foreign key constraints. While
    it includes hooks for customization, such as hooks that allow custom class naming
    and relationship naming schemes, automap is oriented towards an expedient zero-configuration
    style of working. If an application wishes to have a fully explicit model that
    makes use of table reflection, the [DeferredReflection](#orm-declarative-reflected-deferred-reflection)
    class may be preferable for its less automated approach.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Automap](extensions/automap.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Automating Column Naming Schemes from Reflected Tables'
  prefs: []
  type: TYPE_NORMAL
- en: When using any of the previous reflection techniques, we have the option to
    change the naming scheme by which columns are mapped. The [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") object includes a parameter [`Column.key`](../core/metadata.html#sqlalchemy.schema.Column.params.key
    "sqlalchemy.schema.Column") which is a string name that determines under what
    name this [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    will be present in the [`Table.c`](../core/metadata.html#sqlalchemy.schema.Table.c
    "sqlalchemy.schema.Table.c") collection, independently of the SQL name of the
    column. This key is also used by [`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper") as the attribute name under which the [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") will be mapped, if not supplied through other means
    such as that illustrated at [Alternate Attribute Names for Mapping Table Columns](#orm-imperative-table-column-naming).
  prefs: []
  type: TYPE_NORMAL
- en: When working with table reflection, we can intercept the parameters that will
    be used for [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    as they are received using the [`DDLEvents.column_reflect()`](../core/events.html#sqlalchemy.events.DDLEvents.column_reflect
    "sqlalchemy.events.DDLEvents.column_reflect") event and apply whatever changes
    we need, including the `.key` attribute but also things like datatypes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The event hook is most easily associated with the [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") object that’s in use as illustrated below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: 'With the above event, the reflection of [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects will be intercepted with our event that adds
    a new “.key” element, such as in a mapping as below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: The approach also works with both the [`DeferredReflection`](extensions/declarative/index.html#sqlalchemy.ext.declarative.DeferredReflection
    "sqlalchemy.ext.declarative.DeferredReflection") base class as well as with the
    [Automap](extensions/automap.html) extension. For automap specifically, see the
    section [Intercepting Column Definitions](extensions/automap.html#automap-intercepting-columns)
    for background.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Mapping Declaratively with Reflected Tables](#orm-declarative-reflected)'
  prefs: []
  type: TYPE_NORMAL
- en: '[`DDLEvents.column_reflect()`](../core/events.html#sqlalchemy.events.DDLEvents.column_reflect
    "sqlalchemy.events.DDLEvents.column_reflect")'
  prefs: []
  type: TYPE_NORMAL
- en: '[Intercepting Column Definitions](extensions/automap.html#automap-intercepting-columns)
    - in the [Automap](extensions/automap.html) documentation  ### Mapping to an Explicit
    Set of Primary Key Columns'
  prefs: []
  type: TYPE_NORMAL
- en: The [`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper "sqlalchemy.orm.Mapper")
    construct in order to successfully map a table always requires that at least one
    column be identified as the “primary key” for that selectable. This is so that
    when an ORM object is loaded or persisted, it can be placed in the [identity map](../glossary.html#term-identity-map)
    with an appropriate [identity key](../glossary.html#term-identity-key).
  prefs: []
  type: TYPE_NORMAL
- en: In those cases where the a reflected table to be mapped does not include a primary
    key constraint, as well as in the general case for [mapping against arbitrary
    selectables](nonstandard_mappings.html#orm-mapping-arbitrary-subqueries) where
    primary key columns might not be present, the [`Mapper.primary_key`](mapping_api.html#sqlalchemy.orm.Mapper.params.primary_key
    "sqlalchemy.orm.Mapper") parameter is provided so that any set of columns may
    be configured as the “primary key” for the table, as far as ORM mapping is concerned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given the following example of an Imperative Table mapping against an existing
    [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    object where the table does not have any declared primary key (as may occur in
    reflection scenarios), we may map such a table as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: 'Above, the `group_users` table is an association table of some kind with string
    columns `user_id` and `group_id`, but no primary key is set up; instead, there
    is only a [`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint") establishing that the two columns represent
    a unique key. The [`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper "sqlalchemy.orm.Mapper")
    does not automatically inspect unique constraints for primary keys; instead, we
    make use of the [`Mapper.primary_key`](mapping_api.html#sqlalchemy.orm.Mapper.params.primary_key
    "sqlalchemy.orm.Mapper") parameter, passing a collection of `[group_users.c.user_id,
    group_users.c.group_id]`, indicating that these two columns should be used in
    order to construct the identity key for instances of the `GroupUsers` class.  ###
    Mapping a Subset of Table Columns'
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes table reflection may provide a [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") with many columns that are not important for our needs
    and may be safely ignored. For such a table that has lots of columns that don’t
    need to be referenced in the application, the [`Mapper.include_properties`](mapping_api.html#sqlalchemy.orm.Mapper.params.include_properties
    "sqlalchemy.orm.Mapper") or [`Mapper.exclude_properties`](mapping_api.html#sqlalchemy.orm.Mapper.params.exclude_properties
    "sqlalchemy.orm.Mapper") parameters can indicate a subset of columns to be mapped,
    where other columns from the target [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") will not be considered by the ORM in any way. Example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: In the above example, the `User` class will map to the `user_table` table, only
    including the `user_id` and `user_name` columns - the rest are not referenced.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: will map the `Address` class to the `address_table` table, including all columns
    present except `street`, `city`, `state`, and `zip`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As indicated in the two examples, columns may be referenced either by string
    name or by referring to the [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") object directly. Referring to the object directly
    may be useful for explicitness as well as to resolve ambiguities when mapping
    to multi-table constructs that might have repeated names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: When columns are not included in a mapping, these columns will not be referenced
    in any SELECT statements emitted when executing [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") or legacy [`Query`](queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") objects, nor will there be any mapped attribute on the
    mapped class which represents the column; assigning an attribute of that name
    will have no effect beyond that of a normal Python attribute assignment.
  prefs: []
  type: TYPE_NORMAL
- en: However, it is important to note that **schema level column defaults WILL still
    be in effect** for those [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects that include them, even though they may be
    excluded from the ORM mapping.
  prefs: []
  type: TYPE_NORMAL
- en: '“Schema level column defaults” refers to the defaults described at [Column
    INSERT/UPDATE Defaults](../core/defaults.html#metadata-defaults) including those
    configured by the [`Column.default`](../core/metadata.html#sqlalchemy.schema.Column.params.default
    "sqlalchemy.schema.Column"), [`Column.onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.onupdate
    "sqlalchemy.schema.Column"), [`Column.server_default`](../core/metadata.html#sqlalchemy.schema.Column.params.server_default
    "sqlalchemy.schema.Column") and [`Column.server_onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.server_onupdate
    "sqlalchemy.schema.Column") parameters. These constructs continue to have normal
    effects because in the case of [`Column.default`](../core/metadata.html#sqlalchemy.schema.Column.params.default
    "sqlalchemy.schema.Column") and [`Column.onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.onupdate
    "sqlalchemy.schema.Column"), the [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") object is still present on the underlying [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table"), thus allowing the default functions to take place
    when the ORM emits an INSERT or UPDATE, and in the case of [`Column.server_default`](../core/metadata.html#sqlalchemy.schema.Column.params.server_default
    "sqlalchemy.schema.Column") and [`Column.server_onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.server_onupdate
    "sqlalchemy.schema.Column"), the relational database itself emits these defaults
    as a server side behavior.  ### Using DeferredReflection'
  prefs: []
  type: TYPE_NORMAL
- en: 'To accommodate the use case of declaring mapped classes where reflection of
    table metadata can occur afterwards, a simple extension called the [`DeferredReflection`](extensions/declarative/index.html#sqlalchemy.ext.declarative.DeferredReflection
    "sqlalchemy.ext.declarative.DeferredReflection") mixin is available, which alters
    the declarative mapping process to be delayed until a special class-level [`DeferredReflection.prepare()`](extensions/declarative/index.html#sqlalchemy.ext.declarative.DeferredReflection.prepare
    "sqlalchemy.ext.declarative.DeferredReflection.prepare") method is called, which
    will perform the reflection process against a target database, and will integrate
    the results with the declarative table mapping process, that is, classes which
    use the `__tablename__` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: 'Above, we create a mixin class `Reflected` that will serve as a base for classes
    in our declarative hierarchy that should become mapped when the `Reflected.prepare`
    method is called. The above mapping is not complete until we do so, given an [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: The purpose of the `Reflected` class is to define the scope at which classes
    should be reflectively mapped. The plugin will search among the subclass tree
    of the target against which `.prepare()` is called and reflect all tables which
    are named by declared classes; tables in the target database that are not part
    of mappings and are not related to the target tables via foreign key constraint
    will not be reflected.
  prefs: []
  type: TYPE_NORMAL
- en: Using Automap
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A more automated solution to mapping against an existing database where table
    reflection is to be used is to use the [Automap](extensions/automap.html) extension.
    This extension will generate entire mapped classes from a database schema, including
    relationships between classes based on observed foreign key constraints. While
    it includes hooks for customization, such as hooks that allow custom class naming
    and relationship naming schemes, automap is oriented towards an expedient zero-configuration
    style of working. If an application wishes to have a fully explicit model that
    makes use of table reflection, the [DeferredReflection](#orm-declarative-reflected-deferred-reflection)
    class may be preferable for its less automated approach.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Automap](extensions/automap.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Automating Column Naming Schemes from Reflected Tables'
  prefs: []
  type: TYPE_NORMAL
- en: When using any of the previous reflection techniques, we have the option to
    change the naming scheme by which columns are mapped. The [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") object includes a parameter [`Column.key`](../core/metadata.html#sqlalchemy.schema.Column.params.key
    "sqlalchemy.schema.Column") which is a string name that determines under what
    name this [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    will be present in the [`Table.c`](../core/metadata.html#sqlalchemy.schema.Table.c
    "sqlalchemy.schema.Table.c") collection, independently of the SQL name of the
    column. This key is also used by [`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper") as the attribute name under which the [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") will be mapped, if not supplied through other means
    such as that illustrated at [Alternate Attribute Names for Mapping Table Columns](#orm-imperative-table-column-naming).
  prefs: []
  type: TYPE_NORMAL
- en: When working with table reflection, we can intercept the parameters that will
    be used for [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    as they are received using the [`DDLEvents.column_reflect()`](../core/events.html#sqlalchemy.events.DDLEvents.column_reflect
    "sqlalchemy.events.DDLEvents.column_reflect") event and apply whatever changes
    we need, including the `.key` attribute but also things like datatypes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The event hook is most easily associated with the [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") object that’s in use as illustrated below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: 'With the above event, the reflection of [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects will be intercepted with our event that adds
    a new “.key” element, such as in a mapping as below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: The approach also works with both the [`DeferredReflection`](extensions/declarative/index.html#sqlalchemy.ext.declarative.DeferredReflection
    "sqlalchemy.ext.declarative.DeferredReflection") base class as well as with the
    [Automap](extensions/automap.html) extension. For automap specifically, see the
    section [Intercepting Column Definitions](extensions/automap.html#automap-intercepting-columns)
    for background.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Mapping Declaratively with Reflected Tables](#orm-declarative-reflected)'
  prefs: []
  type: TYPE_NORMAL
- en: '[`DDLEvents.column_reflect()`](../core/events.html#sqlalchemy.events.DDLEvents.column_reflect
    "sqlalchemy.events.DDLEvents.column_reflect")'
  prefs: []
  type: TYPE_NORMAL
- en: '[Intercepting Column Definitions](extensions/automap.html#automap-intercepting-columns)
    - in the [Automap](extensions/automap.html) documentation'
  prefs: []
  type: TYPE_NORMAL
- en: '### Mapping to an Explicit Set of Primary Key Columns'
  prefs: []
  type: TYPE_NORMAL
- en: The [`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper "sqlalchemy.orm.Mapper")
    construct in order to successfully map a table always requires that at least one
    column be identified as the “primary key” for that selectable. This is so that
    when an ORM object is loaded or persisted, it can be placed in the [identity map](../glossary.html#term-identity-map)
    with an appropriate [identity key](../glossary.html#term-identity-key).
  prefs: []
  type: TYPE_NORMAL
- en: In those cases where the a reflected table to be mapped does not include a primary
    key constraint, as well as in the general case for [mapping against arbitrary
    selectables](nonstandard_mappings.html#orm-mapping-arbitrary-subqueries) where
    primary key columns might not be present, the [`Mapper.primary_key`](mapping_api.html#sqlalchemy.orm.Mapper.params.primary_key
    "sqlalchemy.orm.Mapper") parameter is provided so that any set of columns may
    be configured as the “primary key” for the table, as far as ORM mapping is concerned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given the following example of an Imperative Table mapping against an existing
    [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    object where the table does not have any declared primary key (as may occur in
    reflection scenarios), we may map such a table as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: Above, the `group_users` table is an association table of some kind with string
    columns `user_id` and `group_id`, but no primary key is set up; instead, there
    is only a [`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint") establishing that the two columns represent
    a unique key. The [`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper "sqlalchemy.orm.Mapper")
    does not automatically inspect unique constraints for primary keys; instead, we
    make use of the [`Mapper.primary_key`](mapping_api.html#sqlalchemy.orm.Mapper.params.primary_key
    "sqlalchemy.orm.Mapper") parameter, passing a collection of `[group_users.c.user_id,
    group_users.c.group_id]`, indicating that these two columns should be used in
    order to construct the identity key for instances of the `GroupUsers` class.
  prefs: []
  type: TYPE_NORMAL
- en: '### Mapping a Subset of Table Columns'
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes table reflection may provide a [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") with many columns that are not important for our needs
    and may be safely ignored. For such a table that has lots of columns that don’t
    need to be referenced in the application, the [`Mapper.include_properties`](mapping_api.html#sqlalchemy.orm.Mapper.params.include_properties
    "sqlalchemy.orm.Mapper") or [`Mapper.exclude_properties`](mapping_api.html#sqlalchemy.orm.Mapper.params.exclude_properties
    "sqlalchemy.orm.Mapper") parameters can indicate a subset of columns to be mapped,
    where other columns from the target [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") will not be considered by the ORM in any way. Example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: In the above example, the `User` class will map to the `user_table` table, only
    including the `user_id` and `user_name` columns - the rest are not referenced.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: will map the `Address` class to the `address_table` table, including all columns
    present except `street`, `city`, `state`, and `zip`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As indicated in the two examples, columns may be referenced either by string
    name or by referring to the [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") object directly. Referring to the object directly
    may be useful for explicitness as well as to resolve ambiguities when mapping
    to multi-table constructs that might have repeated names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: When columns are not included in a mapping, these columns will not be referenced
    in any SELECT statements emitted when executing [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") or legacy [`Query`](queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") objects, nor will there be any mapped attribute on the
    mapped class which represents the column; assigning an attribute of that name
    will have no effect beyond that of a normal Python attribute assignment.
  prefs: []
  type: TYPE_NORMAL
- en: However, it is important to note that **schema level column defaults WILL still
    be in effect** for those [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects that include them, even though they may be
    excluded from the ORM mapping.
  prefs: []
  type: TYPE_NORMAL
- en: “Schema level column defaults” refers to the defaults described at [Column INSERT/UPDATE
    Defaults](../core/defaults.html#metadata-defaults) including those configured
    by the [`Column.default`](../core/metadata.html#sqlalchemy.schema.Column.params.default
    "sqlalchemy.schema.Column"), [`Column.onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.onupdate
    "sqlalchemy.schema.Column"), [`Column.server_default`](../core/metadata.html#sqlalchemy.schema.Column.params.server_default
    "sqlalchemy.schema.Column") and [`Column.server_onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.server_onupdate
    "sqlalchemy.schema.Column") parameters. These constructs continue to have normal
    effects because in the case of [`Column.default`](../core/metadata.html#sqlalchemy.schema.Column.params.default
    "sqlalchemy.schema.Column") and [`Column.onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.onupdate
    "sqlalchemy.schema.Column"), the [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") object is still present on the underlying [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table"), thus allowing the default functions to take place
    when the ORM emits an INSERT or UPDATE, and in the case of [`Column.server_default`](../core/metadata.html#sqlalchemy.schema.Column.params.server_default
    "sqlalchemy.schema.Column") and [`Column.server_onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.server_onupdate
    "sqlalchemy.schema.Column"), the relational database itself emits these defaults
    as a server side behavior.
  prefs: []
  type: TYPE_NORMAL
