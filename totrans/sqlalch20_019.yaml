- en: Table Configuration with Declarative
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用声明性进行表格配置
- en: 原文：[https://docs.sqlalchemy.org/en/20/orm/declarative_tables.html](https://docs.sqlalchemy.org/en/20/orm/declarative_tables.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://docs.sqlalchemy.org/en/20/orm/declarative_tables.html](https://docs.sqlalchemy.org/en/20/orm/declarative_tables.html)
- en: As introduced at [Declarative Mapping](mapping_styles.html#orm-declarative-mapping),
    the Declarative style includes the ability to generate a mapped [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") object at the same time, or to accommodate a [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") or other [`FromClause`](../core/selectable.html#sqlalchemy.sql.expression.FromClause
    "sqlalchemy.sql.expression.FromClause") object directly.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [声明性映射](mapping_styles.html#orm-declarative-mapping) 中所介绍的，声明性样式包括生成一个映射的
    [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    对象的能力，或者直接适应一个 [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    或其他 [`FromClause`](../core/selectable.html#sqlalchemy.sql.expression.FromClause
    "sqlalchemy.sql.expression.FromClause") 对象。
- en: 'The following examples assume a declarative base class as:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例假定有一个声明性基类如下：
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: All of the examples that follow illustrate a class inheriting from the above
    `Base`. The decorator style introduced at [Declarative Mapping using a Decorator
    (no declarative base)](declarative_styles.html#orm-declarative-decorator) is fully
    supported with all the following examples as well, as are legacy forms of Declarative
    Base including base classes generated by [`declarative_base()`](mapping_api.html#sqlalchemy.orm.declarative_base
    "sqlalchemy.orm.declarative_base").
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的所有示例都演示了从上述 `Base` 继承的类。在 [使用装饰器的声明性映射（无声明性基类）](declarative_styles.html#orm-declarative-decorator)
    中介绍的装饰器样式以及通过 [`declarative_base()`](mapping_api.html#sqlalchemy.orm.declarative_base
    "sqlalchemy.orm.declarative_base") 生成的基类的遗留形式都得到了全面支持。
- en: '## Declarative Table with `mapped_column()`'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '## 使用 `mapped_column()` 的声明性表格'
- en: 'When using Declarative, the body of the class to be mapped in most cases includes
    an attribute `__tablename__` that indicates the string name of a [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") that should be generated along with the mapping. The
    [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    construct, which features additional ORM-specific configuration capabilities not
    present in the plain [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") class, is then used within the class body to indicate
    columns in the table. The example below illustrates the most basic use of this
    construct within a Declarative mapping:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用声明性时，大多数情况下要映射的类的主体包括一个名为 `__tablename__` 的属性，该属性指示应与映射一起生成的 [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") 的字符串名称。然后在类主体中使用 [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") 构造，该构造具有额外的 ORM 特定配置功能，在普通的 [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") 类中不存在，以指示表中的列。下面的示例说明了在声明性映射中使用此构造的最基本用法：
- en: '[PRE1]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Above, [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    constructs are placed inline within the class definition as class level attributes.
    At the point at which the class is declared, the Declarative mapping process will
    generate a new [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    object against the [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") collection associated with the Declarative `Base`;
    each instance of [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") will then be used to generate a [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") object during this process, which will become part
    of the [`Table.columns`](../core/metadata.html#sqlalchemy.schema.Table.columns
    "sqlalchemy.schema.Table.columns") collection of this [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") object.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    构造函数被放置在类定义中作为类级别属性。在声明类的时候，声明性映射过程将根据与声明性 `Base` 关联的 [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") 集合生成一个新的 [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") 对象；然后，每个 [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") 的实例将在此过程中用于生成一个 [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") 对象，该对象将成为此 [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") 对象的 [`Table.columns`](../core/metadata.html#sqlalchemy.schema.Table.columns
    "sqlalchemy.schema.Table.columns") 集合的一部分。
- en: 'In the above example, Declarative will build a [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") construct that is equivalent to the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，声明性将构建一个等同于以下内容的 [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") 结构：
- en: '[PRE2]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: When the `User` class above is mapped, this [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") object can be accessed directly via the `__table__`
    attribute; this is described further at [Accessing Table and Metadata](#orm-declarative-metadata).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的 `User` 类被映射之后，可以通过 `__table__` 属性直接访问这个 [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") 对象；详细内容请参阅 [访问表和元数据](#orm-declarative-metadata)。
- en: The [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    construct accepts all arguments that are accepted by the [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") construct, as well as additional ORM-specific arguments.
    The [`mapped_column.__name`](mapping_api.html#sqlalchemy.orm.mapped_column.params.__name
    "sqlalchemy.orm.mapped_column") field, indicating the name of the database column,
    is typically omitted, as the Declarative process will make use of the attribute
    name given to the construct and assign this as the name of the column (in the
    above example, this refers to the names `id`, `name`, `fullname`, `nickname`).
    Assigning an alternate [`mapped_column.__name`](mapping_api.html#sqlalchemy.orm.mapped_column.params.__name
    "sqlalchemy.orm.mapped_column") is valid as well, where the resulting [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") will use the given name in SQL and DDL statements,
    while the `User` mapped class will continue to allow access to the attribute using
    the attribute name given, independent of the name given to the column itself (more
    on this at [Naming Declarative Mapped Columns Explicitly](#mapper-column-distinct-names)).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    构造函数接受所有被 [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    构造函数接受的参数，以及额外的 ORM 特定参数。通常会省略 [`mapped_column.__name`](mapping_api.html#sqlalchemy.orm.mapped_column.params.__name
    "sqlalchemy.orm.mapped_column") 字段，指示数据库列的名称，因为声明性过程将使用给定构造函数的属性名称，并将其分配为列的名称（在上面的示例中，这指的是
    `id`、`name`、`fullname`、`nickname` 的名称）。也可以分配一个替代的 [`mapped_column.__name`](mapping_api.html#sqlalchemy.orm.mapped_column.params.__name
    "sqlalchemy.orm.mapped_column")，在这种情况下，生成的 [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") 将在 SQL 和 DDL 语句中使用给定的名称，而 `User` 映射类将继续允许使用给定的属性名称访问属性，而不管列本身的名称如何（更多内容请参阅
    [明确命名声明式映射列](#mapper-column-distinct-names)）。'
- en: Tip
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: The [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    construct is **only valid within a Declarative class mapping**. When constructing
    a [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    object using Core as well as when using [imperative table](#orm-imperative-table-configuration)
    configuration, the [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    construct is still required in order to indicate the presence of a database column.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    结构**仅在Declarative类映射内有效**。 在使用Core构造[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")对象以及在使用[imperative table](#orm-imperative-table-configuration)配置时，仍然需要[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")结构以指示数据库列的存在。'
- en: See also
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Mapping Table Columns](mapping_columns.html) - contains additional notes on
    affecting how [`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper "sqlalchemy.orm.Mapper")
    interprets incoming [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '[映射表列](mapping_columns.html) - 包含有关影响[`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper")解释传入的[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")对象的附加说明。'
- en: '### Using Annotated Declarative Table (Type Annotated Forms for `mapped_column()`)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '### 使用带注释的声明表（`mapped_column()`的类型注释形式）'
- en: The [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    construct is capable of deriving its column-configuration information from [**PEP
    484**](https://peps.python.org/pep-0484/) type annotations associated with the
    attribute as declared in the Declarative mapped class. These type annotations,
    if used, **must** be present within a special SQLAlchemy type called [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped"), which is a [generic](https://peps.python.org/pep-0484/#generics)
    type that then indicates a specific Python type within it.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    结构能够从与Declarative映射类中声明的属性相关联的[**PEP 484**](https://peps.python.org/pep-0484/)类型注释中派生其列配置信息。
    如果使用了这些类型注释，则**必须**存在于称为[`Mapped`](internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped")的特殊SQLAlchemy类型中，该类型然后表示其中的特定Python类型。'
- en: 'Below illustrates the mapping from the previous section, adding the use of
    [`Mapped`](internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped"):'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 以下说明了从前一节开始的映射，增加了对[`Mapped`](internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped")的使用：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Above, when Declarative processes each class attribute, each [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") will derive additional arguments from the corresponding
    [`Mapped`](internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped") type
    annotation on the left side, if present. Additionally, Declarative will generate
    an empty [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    directive implicitly, whenever a [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") type annotation is encountered that does not have a value
    assigned to the attribute (this form is inspired by the similar style used in
    Python [dataclasses](https://docs.python.org/3/library/dataclasses.html)); this
    [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    construct proceeds to derive its configuration from the [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") annotation present.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述情况下，当Declarative处理每个类属性时，如果存在，每个[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")将从左侧相应的[`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped")类型注释派生出其他参数。 此外，当遇到没有分配给属性的[`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped")类型注释时（这种形式受到了Python [dataclasses](https://docs.python.org/3/library/dataclasses.html)中使用的类似样式的启发）Declarative将隐式生成一个空的[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")指令；此[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")结构继续从存在的[`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped")注释派生其配置。
- en: '#### `mapped_column()` derives the datatype and nullability from the `Mapped`
    annotation'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '#### `mapped_column()`从`Mapped`注释中派生出数据类型和可空性。'
- en: 'The two qualities that [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") derives from the [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") annotation are:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    从 [`Mapped`](internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped") 注解中派生的两个特性是：'
- en: '**datatype** - the Python type given inside [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped"), as contained within the `typing.Optional` construct
    if present, is associated with a [`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") subclass such as [`Integer`](../core/type_basics.html#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer"), [`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String"), [`DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime
    "sqlalchemy.types.DateTime"), or [`Uuid`](../core/type_basics.html#sqlalchemy.types.Uuid
    "sqlalchemy.types.Uuid"), to name a few common types.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**datatype** - 在 [`Mapped`](internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped")
    中给定的 Python 类型，如果存在于 `typing.Optional` 结构中，则与 [`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") 的子类相关联，例如 [`Integer`](../core/type_basics.html#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer")、[`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String")、[`DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime
    "sqlalchemy.types.DateTime") 或 [`Uuid`](../core/type_basics.html#sqlalchemy.types.Uuid
    "sqlalchemy.types.Uuid") 等常见类型。'
- en: 'The datatype is determined based on a dictionary of Python type to SQLAlchemy
    datatype. This dictionary is completely customizable, as detailed in the next
    section [Customizing the Type Map](#orm-declarative-mapped-column-type-map). The
    default type map is implemented as in the code example below:'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 数据类型是基于 Python 类型到 SQLAlchemy 数据类型的字典确定的。这个字典是完全可定制的，如下一节 [自定义类型映射](#orm-declarative-mapped-column-type-map)
    中详细说明。默认类型映射的实现如下面的代码示例所示：
- en: '[PRE4]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If the [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    construct indicates an explicit type as passed to the [`mapped_column.__type`](mapping_api.html#sqlalchemy.orm.mapped_column.params.__type
    "sqlalchemy.orm.mapped_column") argument, then the given Python type is disregarded.
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果 [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    构造指示传递给 [`mapped_column.__type`](mapping_api.html#sqlalchemy.orm.mapped_column.params.__type
    "sqlalchemy.orm.mapped_column") 参数的显式类型，则给定的 Python 类型将被忽略。
- en: '**nullability** - The [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct will indicate its [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") as `NULL` or `NOT NULL` first and foremost by the
    presence of the [`mapped_column.nullable`](mapping_api.html#sqlalchemy.orm.mapped_column.params.nullable
    "sqlalchemy.orm.mapped_column") parameter, passed either as `True` or `False`.
    Additionally , if the [`mapped_column.primary_key`](mapping_api.html#sqlalchemy.orm.mapped_column.params.primary_key
    "sqlalchemy.orm.mapped_column") parameter is present and set to `True`, that will
    also imply that the column should be `NOT NULL`.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**nullability** - [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") 构造将首先通过 [`mapped_column.nullable`](mapping_api.html#sqlalchemy.orm.mapped_column.params.nullable
    "sqlalchemy.orm.mapped_column") 参数的存在与设置为 `True` 或 `False` 来指示其 [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") 为 `NULL` 或 `NOT NULL`。此外，如果 [`mapped_column.primary_key`](mapping_api.html#sqlalchemy.orm.mapped_column.params.primary_key
    "sqlalchemy.orm.mapped_column") 参数存在并设置为 `True`，那也意味着该列应为 `NOT NULL`。'
- en: In the absence of **both** of these parameters, the presence of `typing.Optional[]`
    within the [`Mapped`](internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped")
    type annotation will be used to determine nullability, where `typing.Optional[]`
    means `NULL`, and the absence of `typing.Optional[]` means `NOT NULL`. If there
    is no `Mapped[]` annotation present at all, and there is no [`mapped_column.nullable`](mapping_api.html#sqlalchemy.orm.mapped_column.params.nullable
    "sqlalchemy.orm.mapped_column") or [`mapped_column.primary_key`](mapping_api.html#sqlalchemy.orm.mapped_column.params.primary_key
    "sqlalchemy.orm.mapped_column") parameter, then SQLAlchemy’s usual default for
    [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    of `NULL` is used.
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在**两者**参数均不存在的情况下，[`Mapped`](internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped")类型注释中存在`typing.Optional[]`将用于确定可空性，其中`typing.Optional[]`表示`NULL`，而没有`typing.Optional[]`则表示`NOT
    NULL`。如果根本没有`Mapped[]`注释，并且没有[`mapped_column.nullable`](mapping_api.html#sqlalchemy.orm.mapped_column.params.nullable
    "sqlalchemy.orm.mapped_column")或[`mapped_column.primary_key`](mapping_api.html#sqlalchemy.orm.mapped_column.params.primary_key
    "sqlalchemy.orm.mapped_column")参数，则SQLAlchemy对于[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")的通常默认值`NULL`将被使用。
- en: 'In the example below, the `id` and `data` columns will be `NOT NULL`, and the
    `additional_info` column will be `NULL`:'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在下面的示例中，`id`和`data`列将是`NOT NULL`，而`additional_info`列将是`NULL`：
- en: '[PRE5]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'It is also perfectly valid to have a [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") whose nullability is **different** from what would
    be implied by the annotation. For example, an ORM mapped attribute may be annotated
    as allowing `None` within Python code that works with the object as it is first
    being created and populated, however the value will ultimately be written to a
    database column that is `NOT NULL`. The [`mapped_column.nullable`](mapping_api.html#sqlalchemy.orm.mapped_column.params.nullable
    "sqlalchemy.orm.mapped_column") parameter, when present, will always take precedence:'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 也完全可以有一个其可空性与注释所暗示的不同的[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")。例如，ORM映射的属性可以在创建和填充对象时被注释为允许在Python代码中使用`None`，但是该值最终将被写入一个`NOT
    NULL`的数据库列。当存在时，[`mapped_column.nullable`](mapping_api.html#sqlalchemy.orm.mapped_column.params.nullable
    "sqlalchemy.orm.mapped_column")参数始终优先：
- en: '[PRE6]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Similarly, a non-None attribute that’s written to a database column that for
    whatever reason needs to be NULL at the schema level, [`mapped_column.nullable`](mapping_api.html#sqlalchemy.orm.mapped_column.params.nullable
    "sqlalchemy.orm.mapped_column") may be set to `True`:'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 类似地，写入数据库列的非`None`属性，由于某种原因需要在模式级别为NULL，[`mapped_column.nullable`](mapping_api.html#sqlalchemy.orm.mapped_column.params.nullable
    "sqlalchemy.orm.mapped_column")可以设置为`True`：
- en: '[PRE7]  #### Customizing the Type Map'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[PRE7]  #### 自定义类型映射'
- en: The mapping of Python types to SQLAlchemy [`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") types described in the previous section defaults
    to a hardcoded dictionary present in the `sqlalchemy.sql.sqltypes` module. However,
    the [`registry`](mapping_api.html#sqlalchemy.orm.registry "sqlalchemy.orm.registry")
    object that coordinates the Declarative mapping process will first consult a local,
    user defined dictionary of types which may be passed as the [`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry") parameter when constructing the [`registry`](mapping_api.html#sqlalchemy.orm.registry
    "sqlalchemy.orm.registry"), which may be associated with the [`DeclarativeBase`](mapping_api.html#sqlalchemy.orm.DeclarativeBase
    "sqlalchemy.orm.DeclarativeBase") superclass when first used.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节中描述的 Python 类型到 SQLAlchemy [`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") 类型的映射默认为硬编码的字典，位于`sqlalchemy.sql.sqltypes`模块中。然而，协调声明映射过程的[`registry`](mapping_api.html#sqlalchemy.orm.registry
    "sqlalchemy.orm.registry")对象将首先查阅本地用户定义的类型字典，该字典可以在构造[`registry`](mapping_api.html#sqlalchemy.orm.registry
    "sqlalchemy.orm.registry")时作为参数[`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry")传递，并且在首次使用时可以与[`DeclarativeBase`](mapping_api.html#sqlalchemy.orm.DeclarativeBase
    "sqlalchemy.orm.DeclarativeBase")超类相关联。
- en: 'As an example, if we wish to make use of the [`BIGINT`](../core/type_basics.html#sqlalchemy.types.BIGINT
    "sqlalchemy.types.BIGINT") datatype for `int`, the [`TIMESTAMP`](../core/type_basics.html#sqlalchemy.types.TIMESTAMP
    "sqlalchemy.types.TIMESTAMP") datatype with `timezone=True` for `datetime.datetime`,
    and then only on Microsoft SQL Server we’d like to use [`NVARCHAR`](../core/type_basics.html#sqlalchemy.types.NVARCHAR
    "sqlalchemy.types.NVARCHAR") datatype when Python `str` is used, the registry
    and Declarative base could be configured as:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们希望使用[`BIGINT`](../core/type_basics.html#sqlalchemy.types.BIGINT "sqlalchemy.types.BIGINT")数据类型来表示`int`，带有`timezone=True`的[`TIMESTAMP`](../core/type_basics.html#sqlalchemy.types.TIMESTAMP
    "sqlalchemy.types.TIMESTAMP")数据类型表示`datetime.datetime`，然后仅在Microsoft SQL Server上使用[`NVARCHAR`](../core/type_basics.html#sqlalchemy.types.NVARCHAR
    "sqlalchemy.types.NVARCHAR")数据类型表示Python的`str`，则注册表和Declarative base可以配置为：
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Below illustrates the CREATE TABLE statement generated for the above mapping,
    first on the Microsoft SQL Server backend, illustrating the `NVARCHAR` datatype:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 下面说明了为上述映射生成的CREATE TABLE语句，首先是在Microsoft SQL Server后端，说明了`NVARCHAR`数据类型：
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then on the PostgreSQL backend, illustrating `TIMESTAMP WITH TIME ZONE`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在PostgreSQL后端，说明了`TIMESTAMP WITH TIME ZONE`：
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'By making use of methods such as [`TypeEngine.with_variant()`](../core/type_api.html#sqlalchemy.types.TypeEngine.with_variant
    "sqlalchemy.types.TypeEngine.with_variant"), we’re able to build up a type map
    that’s customized to what we need for different backends, while still being able
    to use succinct annotation-only [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") configurations. There are two more levels of Python-type
    configurability available beyond this, described in the next two sections.  ####
    Mapping Multiple Type Configurations to Python Types'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 通过利用诸如[`TypeEngine.with_variant()`](../core/type_api.html#sqlalchemy.types.TypeEngine.with_variant
    "sqlalchemy.types.TypeEngine.with_variant")之类的方法，我们能够建立一个类型映射，该映射根据不同的后端定制我们所需的内容，同时仍然能够使用简洁的仅注释的[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")配置。除此之外，还有两个级别的Python类型可配置性，分别在下面的两个章节中描述。####
    将多种类型配置映射到Python类型
- en: As individual Python types may be associated with [`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") configurations of any variety by using the [`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry") parameter, an additional capability is the ability
    to associate a single Python type with different variants of a SQL type based
    on additional type qualifiers. One typical example of this is mapping the Python
    `str` datatype to `VARCHAR` SQL types of different lengths. Another is mapping
    different varieties of `decimal.Decimal` to differently sized `NUMERIC` columns.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 由于个别Python类型可能与任何类型的[`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine")配置相关联，通过使用[`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry")参数，额外的能力是能够将单个Python类型与基于额外类型限定符的SQL类型的不同变体相关联。其中一个典型示例是将Python的`str`数据类型映射到不同长度的`VARCHAR`
    SQL类型。另一个是将不同种类的`decimal.Decimal`映射到不同大小的`NUMERIC`列。
- en: 'Python’s typing system provides a great way to add additional metadata to a
    Python type which is by using the [**PEP 593**](https://peps.python.org/pep-0593/)
    `Annotated` generic type, which allows additional information to be bundled along
    with a Python type. The [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct will correctly interpret an `Annotated`
    object by identity when resolving it in the [`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry"), as in the example below where we declare two variants
    of [`String`](../core/type_basics.html#sqlalchemy.types.String "sqlalchemy.types.String")
    and [`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric "sqlalchemy.types.Numeric"):'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Python的类型系统提供了一种很好的方法来为Python类型添加额外的元数据，即使用[**PEP 593**](https://peps.python.org/pep-0593/)
    `Annotated`泛型类型，它允许将额外的信息与Python类型捆绑在一起。[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") 构造将正确解释`Annotated`对象的身份，当在[`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry")中解析它时，就像下面的示例中声明两个变体[`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String")和[`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric
    "sqlalchemy.types.Numeric")一样：
- en: '[PRE11]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The Python type passed to the `Annotated` container, in the above example the
    `str` and `Decimal` types, is important only for the benefit of typing tools;
    as far as the [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct is concerned, it will only need perform
    a lookup of each type object in the [`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry") dictionary without actually looking inside of the `Annotated`
    object, at least in this particular context. Similarly, the arguments passed to
    `Annotated` beyond the underlying Python type itself are also not important, it’s
    only that at least one argument must be present for the `Annotated` construct
    to be valid. We can then use these augmented types directly in our mapping where
    they will be matched to the more specific type constructions, as in the following
    example:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给`Annotated`容器的Python类型，在上述示例中为`str`和`Decimal`类型，仅对于类型工具的好处而重要；就[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")构造而言，它只需要在[`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry")字典中查找每个类型对象，而不实际查看`Annotated`对象的内部，至少在这个特定的上下文中是如此。类似地，传递给`Annotated`的参数超出了基础Python类型本身也不重要，只是`Annotated`构造必须存在至少一个参数才有效。然后，我们可以直接在映射中使用这些增强型类型，它们将与更具体的类型构造相匹配，如以下示例所示：
- en: '[PRE12]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'a CREATE TABLE for the above mapping will illustrate the different variants
    of `VARCHAR` and `NUMERIC` we’ve configured, and looks like:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 上述映射的CREATE TABLE将说明我们配置的不同变体的`VARCHAR`和`NUMERIC`，如下所示：
- en: '[PRE13]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'While variety in linking `Annotated` types to different SQL types grants us
    a wide degree of flexibility, the next section illustrates a second way in which
    `Annotated` may be used with Declarative that is even more open ended.  #### Mapping
    Whole Column Declarations to Python Types'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管将`Annotated`类型与不同的SQL类型进行链接提供了广泛的灵活性，但下一节说明了`Annotated`可能与声明性一起使用的第二种方式，这种方式更加开放。####
    将整个列声明映射到Python类型
- en: The previous section illustrated using [**PEP 593**](https://peps.python.org/pep-0593/)
    `Annotated` type instances as keys within the [`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry") dictionary. In this form, the [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct does not actually look inside the `Annotated`
    object itself, it’s instead used only as a dictionary key. However, Declarative
    also has the ability to extract an entire pre-established [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct from an `Annotated` object directly.
    Using this form, we can define not only different varieties of SQL datatypes linked
    to Python types without using the [`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry") dictionary, we can also set up any number of arguments
    such as nullability, column defaults, and constraints in a reusable fashion.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 前一节说明了使用[**PEP 593**](https://peps.python.org/pep-0593/) `Annotated`类型实例作为[`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry")字典中的键。在这种形式中，[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")构造实际上不会查看`Annotated`对象本身，而是仅用作字典键。然而，声明性还具有直接从`Annotated`对象中提取整个预先建立的[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")构造的能力。使用这种形式，我们不仅可以定义与Python类型链接的不同种类的SQL数据类型，而无需使用[`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry")字典，还可以以可重用的方式设置任意数量的参数，例如可为空性、列默认值和约束。
- en: A set of ORM models will usually have some kind of primary key style that is
    common to all mapped classes. There also may be common column configurations such
    as timestamps with defaults and other fields of pre-established sizes and configurations.
    We can compose these configurations into [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") instances that we then bundle directly into instances
    of `Annotated`, which are then re-used in any number of class declarations. Declarative
    will unpack an `Annotated` object when provided in this manner, skipping over
    any other directives that don’t apply to SQLAlchemy and searching only for SQLAlchemy
    ORM constructs.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 一组ORM模型通常会具有一种对所有映射类都通用的主键风格。还可能存在一些常见的列配置，例如带有默认值的时间戳和其他预先设置大小和配置的字段。我们可以将这些配置组合成[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")实例，然后直接将其捆绑到`Annotated`实例中，然后在任意数量的类声明中重复使用。当以这种方式提供`Annotated`对象时，Declarative将解包该对象，跳过不适用于SQLAlchemy的任何其他指令，并仅搜索SQLAlchemy
    ORM构造。
- en: 'The example below illustrates a variety of pre-configured field types used
    in this way, where we define `intpk` that represents an [`Integer`](../core/type_basics.html#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer") primary key column, `timestamp` that represents a
    [`DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime "sqlalchemy.types.DateTime")
    type which will use `CURRENT_TIMESTAMP` as a DDL level column default, and `required_name`
    which is a [`String`](../core/type_basics.html#sqlalchemy.types.String "sqlalchemy.types.String")
    of length 30 that’s `NOT NULL`:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的示例说明了以这种方式使用的各种预配置字段类型，其中我们定义了代表[`Integer`](../core/type_basics.html#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer")主键列的`intpk`，代表将使用`CURRENT_TIMESTAMP`作为DDL级别列默认值的[`DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime
    "sqlalchemy.types.DateTime")类型的`timestamp`，以及`required_name`，它是一个长度为30的[`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String")，不可为空：
- en: '[PRE14]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The above `Annotated` objects can then be used directly within [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped"), where the pre-configured [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") constructs will be extracted and copied to a new
    instance that will be specific to each attribute:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 上述的`Annotated`对象然后可以直接在[`Mapped`](internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped")中使用，在那里，预配置的[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")构造将被提取并复制到一个新实例中，该实例将特定于每个属性：
- en: '[PRE15]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '`CREATE TABLE` for our above mapping looks like:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们上面的映射的`CREATE TABLE`看起来像这样：
- en: '[PRE16]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'When using `Annotated` types in this way, the configuration of the type may
    also be affected on a per-attribute basis. For the types in the above example
    that feature explicit use of [`mapped_column.nullable`](mapping_api.html#sqlalchemy.orm.mapped_column.params.nullable
    "sqlalchemy.orm.mapped_column"), we can apply the `Optional[]` generic modifier
    to any of our types so that the field is optional or not at the Python level,
    which will be independent of the `NULL` / `NOT NULL` setting that takes place
    in the database:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当以这种方式使用`Annotated`类型时，类型的配置也可能会受到每个属性的影响。对于上面示例中明确使用了[`mapped_column.nullable`](mapping_api.html#sqlalchemy.orm.mapped_column.params.nullable
    "sqlalchemy.orm.mapped_column")的类型，我们可以将`Optional[]`泛型修饰符应用于我们的任何类型，以使字段在Python级别是可选的或不可选的，这将独立于在数据库中发生的`NULL`
    / `NOT NULL`设置：
- en: '[PRE17]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    construct is also reconciled with an explicitly passed [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct, whose arguments will take precedence
    over those of the `Annotated` construct. Below we add a [`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey") constraint to our integer primary key and also
    use an alternate server default for the `created_at` column:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")构造也与显式传递的[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")构造进行了调和，其参数将优先于`Annotated`构造的参数。下面我们向整数主键添加了一个[`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey")约束，并且还为`created_at`列使用了一个替代的服务器默认值：'
- en: '[PRE18]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The CREATE TABLE statement illustrates these per-attribute settings, adding
    a `FOREIGN KEY` constraint as well as substituting `UTC_TIMESTAMP` for `CURRENT_TIMESTAMP`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 创建表语句说明了这些属性设置，添加了一个`FOREIGN KEY`约束，并将`UTC_TIMESTAMP`替换为`CURRENT_TIMESTAMP`：
- en: '[PRE19]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The feature of [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") just described, where a fully constructed set
    of column arguments may be indicated using [**PEP 593**](https://peps.python.org/pep-0593/)
    `Annotated` objects that contain a “template” [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") object to be copied into the attribute, is currently
    not implemented for other ORM constructs such as [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") and [`composite()`](composites.html#sqlalchemy.orm.composite
    "sqlalchemy.orm.composite"). While this functionality is in theory possible, for
    the moment attempting to use `Annotated` to indicate further arguments for [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") and similar will raise a `NotImplementedError`
    exception at runtime, but may be implemented in future releases.  #### Using Python
    `Enum` or pep-586 `Literal` types in the type map'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 刚刚描述的[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")功能，其中可以使用包含“模板”[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")对象的[**PEP 593**](https://peps.python.org/pep-0593/)
    `Annotated`对象来指示完全构建的列参数集，目前尚未实现用于其他 ORM 构造，如[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")和[`composite()`](composites.html#sqlalchemy.orm.composite
    "sqlalchemy.orm.composite")。虽然这种功能在理论上是可能的，但目前尝试使用`Annotated`来指示[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")等的进一步参数将在运行时引发`NotImplementedError`异常，但可能会在未来的版本中实现。####
    在类型映射中使用 Python `Enum` 或 pep-586 `Literal` 类型
- en: 'New in version 2.0.0b4: - Added `Enum` support'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 新版本 2.0.0b4 中新增：- 添加了`Enum`支持
- en: 'New in version 2.0.1: - Added `Literal` support'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 新版本 2.0.1 中新增：- 添加了`Literal`支持
- en: 'User-defined Python types which derive from the Python built-in `enum.Enum`
    as well as the `typing.Literal` class are automatically linked to the SQLAlchemy
    [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.types.Enum")
    datatype when used in an ORM declarative mapping. The example below uses a custom
    `enum.Enum` within the `Mapped[]` constructor:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 用户定义的 Python 类型，这些类型派生自 Python 内置的`enum.Enum`以及`typing.Literal`类，在 ORM 声明映射中使用时会自动链接到
    SQLAlchemy [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.types.Enum")
    数据类型。下面的示例在`Mapped[]`构造函数中使用了自定义的`enum.Enum`：
- en: '[PRE20]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In the above example, the mapped attribute `SomeClass.status` will be linked
    to a [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    with the datatype of `Enum(Status)`. We can see this for example in the CREATE
    TABLE output for the PostgreSQL database:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，映射属性`SomeClass.status`将链接到一个[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")，其数据类型为`Enum(Status)`。我们可以在 PostgreSQL 数据库的 CREATE
    TABLE 输出中看到这一点：
- en: '[PRE21]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In a similar way, `typing.Literal` may be used instead, using a `typing.Literal`
    that consists of all strings:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，可以使用`typing.Literal`，使用由所有字符串组成的`typing.Literal`：
- en: '[PRE22]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The entries used in [`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry") link the base `enum.Enum` Python type as well as the
    `typing.Literal` type to the SQLAlchemy [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum") SQL type, using a special form which indicates to the
    [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.types.Enum")
    datatype that it should automatically configure itself against an arbitrary enumerated
    type. This configuration, which is implicit by default, would be indicated explicitly
    as:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在[`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry")中使用的条目将基本的`enum.Enum` Python 类型以及`typing.Literal`类型链接到
    SQLAlchemy [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.types.Enum")
    SQL 类型，使用一种特殊形式，该形式指示[`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.types.Enum")数据类型应自动针对任意枚举类型进行配置。这种默认情况下隐式的配置将被明确指示为：
- en: '[PRE23]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The resolution logic within Declarative is able to resolve subclasses of `enum.Enum`
    as well as instances of `typing.Literal` to match the `enum.Enum` or `typing.Literal`
    entry in the [`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry") dictionary. The [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum") SQL type then knows how to produce a configured version
    of itself with the appropriate settings, including default string length. If a
    `typing.Literal` that does not consist of only string values is passed, an informative
    error is raised.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Declarative 内部的解析逻辑能够将`enum.Enum`的子类以及`typing.Literal`的实例解析为与[`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry")字典中的`enum.Enum`或`typing.Literal`条目匹配的类型注释。然后，[`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum") SQL 类型知道如何生成具有适当设置的已配置版本，包括默认字符串长度。如果传递的 `typing.Literal`
    不仅包含字符串值，则会引发具有信息的错误。
- en: Native Enums and Naming
  id: totrans-80
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 本机枚举和命名
- en: The [`Enum.native_enum`](../core/type_basics.html#sqlalchemy.types.Enum.params.native_enum
    "sqlalchemy.sql.sqltypes.Enum") parameter refers to if the [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.sql.sqltypes.Enum") datatype should create a so-called “native” enum,
    which on MySQL/MariaDB is the `ENUM` datatype and on PostgreSQL is a new `TYPE`
    object created by `CREATE TYPE`, or a “non-native” enum, which means that `VARCHAR`
    will be used to create the datatype. For backends other than MySQL/MariaDB or
    PostgreSQL, `VARCHAR` is used in all cases (third party dialects may have their
    own behaviors).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Enum.native_enum`](../core/type_basics.html#sqlalchemy.types.Enum.params.native_enum
    "sqlalchemy.sql.sqltypes.Enum")参数指的是[`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.sql.sqltypes.Enum")数据类型是否应创建所谓的“本机”枚举，这在 MySQL/MariaDB 上是 `ENUM` 数据类型，在
    PostgreSQL 上是由 `CREATE TYPE` 创建的新 `TYPE` 对象，或者是“非本机”枚举，这意味着将使用`VARCHAR`来创建数据类型。对于除
    MySQL/MariaDB 或 PostgreSQL 外的后端，`VARCHAR` 在所有情况下都被使用（第三方方言可能有自己的行为）。'
- en: 'Because PostgreSQL’s `CREATE TYPE` requires that there’s an explicit name for
    the type to be created, special fallback logic exists when working with implicitly
    generated [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.sql.sqltypes.Enum")
    without specifying an explicit [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.sql.sqltypes.Enum") datatype within a mapping:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 PostgreSQL 的 `CREATE TYPE` 要求为要创建的类型指定一个显式名称，所以当使用隐式生成的[`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.sql.sqltypes.Enum")时，如果没有在映射中指定显式的 [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.sql.sqltypes.Enum") 数据类型，就会存在特殊的回退逻辑：
- en: If the [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.sql.sqltypes.Enum")
    is linked to an `enum.Enum` object, the [`Enum.native_enum`](../core/type_basics.html#sqlalchemy.types.Enum.params.native_enum
    "sqlalchemy.sql.sqltypes.Enum") parameter defaults to `True` and the name of the
    enum will be taken from the name of the `enum.Enum` datatype. The PostgreSQL backend
    will assume `CREATE TYPE` with this name.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果[`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.sql.sqltypes.Enum")链接到`enum.Enum`对象，则[`Enum.native_enum`](../core/type_basics.html#sqlalchemy.types.Enum.params.native_enum
    "sqlalchemy.sql.sqltypes.Enum")参数默认为`True`，并且枚举的名称将从`enum.Enum`数据类型的名称中获取。PostgreSQL
    后端将假设使用此名称创建 `CREATE TYPE`。
- en: If the [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.sql.sqltypes.Enum")
    is linked to a `typing.Literal` object, the [`Enum.native_enum`](../core/type_basics.html#sqlalchemy.types.Enum.params.native_enum
    "sqlalchemy.sql.sqltypes.Enum") parameter defaults to `False`; no name is generated
    and `VARCHAR` is assumed.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果[`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.sql.sqltypes.Enum")链接到`typing.Literal`对象，则[`Enum.native_enum`](../core/type_basics.html#sqlalchemy.types.Enum.params.native_enum
    "sqlalchemy.sql.sqltypes.Enum")参数默认为`False`；不会生成名称，并且假设为`VARCHAR`。
- en: 'To use `typing.Literal` with a PostgreSQL `CREATE TYPE` type, an explicit [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.sql.sqltypes.Enum") must be used, either within the type map:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 PostgreSQL 的 `CREATE TYPE` 类型中使用 `typing.Literal`，必须使用显式的[`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.sql.sqltypes.Enum")，可以在类型映射中：
- en: '[PRE24]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Or alternatively within [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column"):'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 或者在[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")内部：
- en: '[PRE25]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Altering the Configuration of the Default Enum
  id: totrans-89
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 修改默认枚举的配置
- en: 'In order to modify the fixed configuration of the `Enum` datatype that’s generated
    implicitly, specify new entries in the [`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry"), indicating additional arguments. For example, to use
    “non native enumerations” unconditionally, the [`Enum.native_enum`](../core/type_basics.html#sqlalchemy.types.Enum.params.native_enum
    "sqlalchemy.types.Enum") parameter may be set to False for all types:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 为了修改隐式生成的`Enum`数据类型的固定配置，请在[`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry")中指定新条目，表示附加参数。例如，要无条件使用“非本地枚举”，可以为所有类型将[`Enum.native_enum`](../core/type_basics.html#sqlalchemy.types.Enum.params.native_enum
    "sqlalchemy.types.Enum")参数设置为False：
- en: '[PRE26]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Changed in version 2.0.1: Implemented support for overriding parameters such
    as [`Enum.native_enum`](../core/type_basics.html#sqlalchemy.types.Enum.params.native_enum
    "sqlalchemy.types.Enum") within the [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum") datatype when establishing the [`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry"). Previously, this functionality was not working.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 自2.0.1版本更改：在建立[`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry")时，实现了对[`Enum.native_enum`](../core/type_basics.html#sqlalchemy.types.Enum.params.native_enum
    "sqlalchemy.types.Enum")等参数进行覆盖的支持。以前，此功能未能正常工作。
- en: 'To use a specific configuration for a specific `enum.Enum` subtype, such as
    setting the string length to 50 when using the example `Status` datatype:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要为特定的`enum.Enum`子类型使用特定的配置，例如在使用示例`Status`数据类型时将字符串长度设置为50：
- en: '[PRE27]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'By default [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.types.Enum")
    that are automatically generated are not associated with the `MetaData` instance
    used by the `Base`, so if the metadata defines a schema it will not be automatically
    associated with the enum. To automatically associate the enum with the schema
    in the metadata or table they belong to the [`Enum.inherit_schema`](../core/type_basics.html#sqlalchemy.types.Enum.params.inherit_schema
    "sqlalchemy.types.Enum") can be set:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，自动生成的[`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.types.Enum")不与`Base`使用的`MetaData`实例关联，因此如果元数据定义了模式，则不会自动与枚举关联。要自动将枚举与元数据或其所属的表的模式关联起来，可以设置[`Enum.inherit_schema`](../core/type_basics.html#sqlalchemy.types.Enum.params.inherit_schema
    "sqlalchemy.types.Enum")：
- en: '[PRE28]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Linking Specific `enum.Enum` or `typing.Literal` to other datatypes
  id: totrans-97
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 将特定的`enum.Enum`或`typing.Literal`链接到其他数据类型
- en: 'The above examples feature the use of an [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum") that is automatically configuring itself to the arguments
    / attributes present on an `enum.Enum` or `typing.Literal` type object. For use
    cases where specific kinds of `enum.Enum` or `typing.Literal` should be linked
    to other types, these specific types may be placed in the type map also. In the
    example below, an entry for `Literal[]` that contains non-string types is linked
    to the [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON")
    datatype:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例演示了使用自动配置自身到`enum.Enum`或`typing.Literal`类型对象上的参数/属性的[`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum")。对于特定种类的`enum.Enum`或`typing.Literal`应链接到其他类型的用例，这些特定类型也可以放置在类型映射中。在下面的示例中，包含非字符串类型的`Literal[]`条目与[`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON")数据类型相关联：
- en: '[PRE29]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In the above configuration, the `my_literal` datatype will resolve to a [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON") instance. Other `Literal` variants will continue to resolve
    to [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.types.Enum")
    datatypes.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述配置中，`my_literal`数据类型将解析为一个[`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON")实例。其他`Literal`变体将继续解析为[`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum")数据类型。
- en: Dataclass features in `mapped_column()`
  id: totrans-101
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`mapped_column()`中的数据类功能'
- en: 'The [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    construct integrates with SQLAlchemy’s “native dataclasses” feature, discussed
    at [Declarative Dataclass Mapping](dataclasses.html#orm-declarative-native-dataclasses).
    See that section for current background on additional directives supported by
    [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column").  ###
    Accessing Table and Metadata'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")构造与SQLAlchemy的“原生数据类”功能集成，详见[声明性数据类映射](dataclasses.html#orm-declarative-native-dataclasses)。查看该部分以获取关于[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")支持的其他指令的当前背景。  ### 访问表和元数据'
- en: 'A declaratively mapped class will always include an attribute called `__table__`;
    when the above configuration using `__tablename__` is complete, the declarative
    process makes the [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    available via the `__table__` attribute:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 声明性映射类将始终包括一个名为`__table__`的属性；当使用上述使用`__tablename__`的配置完成时，声明过程会通过`__table__`属性使[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")可用：
- en: '[PRE30]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The above table is ultimately the same one that corresponds to the [`Mapper.local_table`](mapping_api.html#sqlalchemy.orm.Mapper.local_table
    "sqlalchemy.orm.Mapper.local_table") attribute, which we can see through the [runtime
    inspection system](../core/inspection.html):'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 上述表格最终与[`Mapper.local_table`](mapping_api.html#sqlalchemy.orm.Mapper.local_table
    "sqlalchemy.orm.Mapper.local_table")属性相对应，我们可以通过[运行时检查系统](../core/inspection.html)看到它：
- en: '[PRE31]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData "sqlalchemy.schema.MetaData")
    collection associated with both the declarative [`registry`](mapping_api.html#sqlalchemy.orm.registry
    "sqlalchemy.orm.registry") as well as the base class is frequently necessary in
    order to run DDL operations such as CREATE, as well as in use with migration tools
    such as Alembic. This object is available via the `.metadata` attribute of [`registry`](mapping_api.html#sqlalchemy.orm.registry
    "sqlalchemy.orm.registry") as well as the declarative base class. Below, for a
    small script we may wish to emit a CREATE for all tables against a SQLite database:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 与声明性[`registry`](mapping_api.html#sqlalchemy.orm.registry "sqlalchemy.orm.registry")以及基类关联的[`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData")集合通常是必要的，以便运行DDL操作，如CREATE，以及与迁移工具（例如Alembic）一起使用。此对象可通过[`registry`](mapping_api.html#sqlalchemy.orm.registry
    "sqlalchemy.orm.registry")以及声明性基类的`.metadata`属性获得。下面，对于一个小脚本，我们可能希望针对SQLite数据库发出所有表的CREATE：
- en: '[PRE32]  ### Declarative Table Configuration'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE32]  ### 声明性表配置'
- en: When using Declarative Table configuration with the `__tablename__` declarative
    class attribute, additional arguments to be supplied to the [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") constructor should be provided using the `__table_args__`
    declarative class attribute.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 使用带有`__tablename__`声明类属性的声明性表配置时，应使用`__table_args__`声明类属性提供要提供给[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")构造函数的附加参数。
- en: 'This attribute accommodates both positional as well as keyword arguments that
    are normally sent to the [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") constructor. The attribute can be specified in one
    of two forms. One is as a dictionary:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 此属性既支持位置参数，也支持通常发送到[`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")构造函数的关键字参数。该属性可以用两种形式指定。一种是作为一个字典：
- en: '[PRE33]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The other, a tuple, where each argument is positional (usually constraints):'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个是一个元组，其中每个参数都是位置参数（通常是约束条件）：
- en: '[PRE34]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Keyword arguments can be specified with the above form by specifying the last
    argument as a dictionary:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字参数可以通过在上述形式中将最后一个参数指定为字典来指定：
- en: '[PRE35]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'A class may also specify the `__table_args__` declarative attribute, as well
    as the `__tablename__` attribute, in a dynamic style using the [`declared_attr()`](mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr") method decorator. See [Composing Mapped Hierarchies
    with Mixins](declarative_mixins.html) for background.  ### Explicit Schema Name
    with Declarative Table'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '类还可以使用[`declared_attr()`](mapping_api.html#sqlalchemy.orm.declared_attr "sqlalchemy.orm.declared_attr")方法装饰器以动态方式指定`__table_args__`声明属性，以及`__tablename__`属性。有关背景，请参阅[使用混合组合映射层次结构](declarative_mixins.html)。  ###
    声明性表的显式架构名称'
- en: 'The schema name for a [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") as documented at [Specifying the Schema Name](../core/metadata.html#schema-table-schema-name)
    is applied to an individual [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") using the [`Table.schema`](../core/metadata.html#sqlalchemy.schema.Table.params.schema
    "sqlalchemy.schema.Table") argument. When using Declarative tables, this option
    is passed like any other to the `__table_args__` dictionary:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    的模式名称，请参阅 [指定模式名称](../core/metadata.html#schema-table-schema-name)，将模式名称应用于单个
    [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    使用 [`Table.schema`](../core/metadata.html#sqlalchemy.schema.Table.params.schema
    "sqlalchemy.schema.Table") 参数。在使用声明性表时，此选项像其他任何选项一样传递给 `__table_args__` 字典：
- en: '[PRE36]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The schema name can also be applied to all [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects globally by using the [`MetaData.schema`](../core/metadata.html#sqlalchemy.schema.MetaData.params.schema
    "sqlalchemy.schema.MetaData") parameter documented at [Specifying a Default Schema
    Name with MetaData](../core/metadata.html#schema-metadata-schema-name). The [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") object may be constructed separately and associated
    with a [`DeclarativeBase`](mapping_api.html#sqlalchemy.orm.DeclarativeBase "sqlalchemy.orm.DeclarativeBase")
    subclass by assigning to the `metadata` attribute directly:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 模式名称也可以通过在 [指定默认模式名称与 MetaData](../core/metadata.html#schema-metadata-schema-name)
    中使用的 [`MetaData.schema`](../core/metadata.html#sqlalchemy.schema.MetaData.params.schema
    "sqlalchemy.schema.MetaData") 参数应用于全局所有 [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") 对象。 [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") 对象可以单独构造，并通过直接赋值给 `metadata` 属性与 [`DeclarativeBase`](mapping_api.html#sqlalchemy.orm.DeclarativeBase
    "sqlalchemy.orm.DeclarativeBase") 子类关联起来：
- en: '[PRE37]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: See also
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Specifying the Schema Name](../core/metadata.html#schema-table-schema-name)
    - in the [Describing Databases with MetaData](../core/metadata.html) documentation.  ###
    Setting Load and Persistence Options for Declarative Mapped Columns'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '[指定模式名称](../core/metadata.html#schema-table-schema-name) - 在 [使用 MetaData 描述数据库](../core/metadata.html)
    文档中。  ### 设置声明性映射列的加载和持久化选项'
- en: 'The [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    construct accepts additional ORM-specific arguments that affect how the generated
    [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    is mapped, affecting its load and persistence-time behavior. Options that are
    commonly used include:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    构造函数接受其他影响生成的 [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    映射的 ORM 特定参数，影响其加载和持久化行为。常用的选项包括：'
- en: '**deferred column loading** - The [`mapped_column.deferred`](mapping_api.html#sqlalchemy.orm.mapped_column.params.deferred
    "sqlalchemy.orm.mapped_column") boolean establishes the [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") using [deferred column loading](queryguide/columns.html#orm-queryguide-column-deferral)
    by default. In the example below, the `User.bio` column will not be loaded by
    default, but only when accessed:'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**延迟列加载** - [`mapped_column.deferred`](mapping_api.html#sqlalchemy.orm.mapped_column.params.deferred
    "sqlalchemy.orm.mapped_column") 布尔值默认情况下建立 [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") 使用 [延迟列加载](queryguide/columns.html#orm-queryguide-column-deferral)。在下面的示例中，`User.bio`
    列不会默认加载，而是在访问时加载：'
- en: '[PRE38]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: See also
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Limiting which Columns Load with Column Deferral](queryguide/columns.html#orm-queryguide-column-deferral)
    - full description of deferred column loading'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[限制列的加载方式与列延迟](queryguide/columns.html#orm-queryguide-column-deferral) - 延迟列加载的完整描述'
- en: '**active history** - The [`mapped_column.active_history`](mapping_api.html#sqlalchemy.orm.mapped_column.params.active_history
    "sqlalchemy.orm.mapped_column") ensures that upon change of value for the attribute,
    the previous value will have been loaded and made part of the [`AttributeState.history`](internals.html#sqlalchemy.orm.AttributeState.history
    "sqlalchemy.orm.AttributeState.history") collection when inspecting the history
    of the attribute. This may incur additional SQL statements:'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**活动历史** - [`mapped_column.active_history`](mapping_api.html#sqlalchemy.orm.mapped_column.params.active_history
    "sqlalchemy.orm.mapped_column") 确保在更改属性的值时，先前的值将已加载并作为属性历史的一部分放入 [`AttributeState.history`](internals.html#sqlalchemy.orm.AttributeState.history
    "sqlalchemy.orm.AttributeState.history") 集合中，当检查属性的历史时，可能会产生额外的 SQL 语句：'
- en: '[PRE39]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: See the docstring for [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") for a list of supported parameters.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅 [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    的文档字符串以获取支持的参数列表。
- en: See also
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Applying Load, Persistence and Mapping Options for Imperative Table Columns](#orm-imperative-table-column-options)
    - describes using [`column_property()`](mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property") and [`deferred()`](queryguide/columns.html#sqlalchemy.orm.deferred
    "sqlalchemy.orm.deferred") for use with Imperative Table configuration  ### Naming
    Declarative Mapped Columns Explicitly'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '[对声明式表列应用加载、持久化和映射选项](#orm-imperative-table-column-options) - 描述了在 Imperative
    Table 配置中使用 [`column_property()`](mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property") 和 [`deferred()`](queryguide/columns.html#sqlalchemy.orm.deferred
    "sqlalchemy.orm.deferred") 的方法  ### 显式命名声明式映射列'
- en: 'All of the examples thus far feature the [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct linked to an ORM mapped attribute, where
    the Python attribute name given to the [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") is also that of the column as we see in CREATE
    TABLE statements as well as queries. The name for a column as expressed in SQL
    may be indicated by passing the string positional argument [`mapped_column.__name`](mapping_api.html#sqlalchemy.orm.mapped_column.params.__name
    "sqlalchemy.orm.mapped_column") as the first positional argument. In the example
    below, the `User` class is mapped with alternate names given to the columns themselves:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，所有的示例都是使用了 [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") 构造与一个 ORM 映射的属性关联起来，其中给定给 [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") 的 Python 属性名称也是 CREATE TABLE 语句以及查询中所见的列的名称。在
    SQL 中表示列名可以通过将字符串位置参数 [`mapped_column.__name`](mapping_api.html#sqlalchemy.orm.mapped_column.params.__name
    "sqlalchemy.orm.mapped_column") 作为第一个位置参数来指定。在下面的示例中，`User` 类被映射到了列本身的备用名称：
- en: '[PRE40]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Where above `User.id` resolves to a column named `user_id` and `User.name`
    resolves to a column named `user_name`. We may write a [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") statement using our Python attribute names
    and will see the SQL names generated:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '`User.id` 对应的是一个名为 `user_id` 的列，而 `User.name` 对应的是一个名为 `user_name` 的列。我们可以使用我们的
    Python 属性名称编写一个 [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") 语句，使用的是我们的 Python 属性名称，我们将看到生成的 SQL 名称：'
- en: '[PRE41]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: See also
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Alternate Attribute Names for Mapping Table Columns](#orm-imperative-table-column-naming)
    - applies to Imperative Table  ### Appending additional columns to an existing
    Declarative mapped class'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '[映射表列的备用属性名称](#orm-imperative-table-column-naming) - 适用于声明式表  ### 向现有的声明式映射类添加附加列'
- en: A declarative table configuration allows the addition of new [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects to an existing mapping after the [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") metadata has already been generated.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 声明式表配置允许在已经生成了 [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    元数据之后，向现有映射中添加新的 [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    对象。
- en: 'For a declarative class that is declared using a declarative base class, the
    underlying metaclass `DeclarativeMeta` includes a `__setattr__()` method that
    will intercept additional [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") or Core [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects and add them to both the [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") using [`Table.append_column()`](../core/metadata.html#sqlalchemy.schema.Table.append_column
    "sqlalchemy.schema.Table.append_column") as well as to the existing [`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper") using [`Mapper.add_property()`](mapping_api.html#sqlalchemy.orm.Mapper.add_property
    "sqlalchemy.orm.Mapper.add_property"):'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 对于使用声明式基类声明的声明式类，底层元类`DeclarativeMeta`包括一个`__setattr__()`方法，该方法将拦截额外的[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")或Core [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")对象，并将它们添加到[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")和现有的[`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper")中，分别使用[`Table.append_column()`](../core/metadata.html#sqlalchemy.schema.Table.append_column
    "sqlalchemy.schema.Table.append_column")和[`Mapper.add_property()`](mapping_api.html#sqlalchemy.orm.Mapper.add_property
    "sqlalchemy.orm.Mapper.add_property")：
- en: '[PRE42]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Using core [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column"):'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 使用核心[`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")：
- en: '[PRE43]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: All arguments are supported including an alternate name, such as `MyClass.some_new_column
    = mapped_column("some_name", String)`. However, the SQL type must be passed to
    the [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    or [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    object explicitly, as in the above examples where the [`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String") type is passed. There’s no capability for the [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") annotation type to take part in the operation.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 支持所有参数，包括备用名称，例如`MyClass.some_new_column = mapped_column("some_name", String)`。但是，必须显式传递SQL类型给[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")或[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")对象，就像上面的例子中传递[`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String")类型一样。[`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped")注解类型无法参与此操作。
- en: Additional [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    objects may also be added to a mapping in the specific circumstance of using single
    table inheritance, where additional columns are present on mapped subclasses that
    have no [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    of their own. This is illustrated in the section [Single Table Inheritance](inheritance.html#single-inheritance).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用单表继承的特定情况下，也可以向映射添加额外的[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")对象，在这种情况下，映射的子类上存在额外的列，但它们没有自己的[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")。这在[单表继承](inheritance.html#single-inheritance)部分有所说明。
- en: See also
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Adding Relationships to Mapped Classes After Declaration](basic_relationships.html#orm-declarative-table-adding-relationship)
    - similar examples for [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '[在声明后向映射类添加关系](basic_relationships.html#orm-declarative-table-adding-relationship)
    - 类似的例子可以参考[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")'
- en: Note
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Assignment of mapped properties to an already mapped class will only function
    correctly if the “declarative base” class is used, meaning the user-defined subclass
    of [`DeclarativeBase`](mapping_api.html#sqlalchemy.orm.DeclarativeBase "sqlalchemy.orm.DeclarativeBase")
    or the dynamically generated class returned by [`declarative_base()`](mapping_api.html#sqlalchemy.orm.declarative_base
    "sqlalchemy.orm.declarative_base") or [`registry.generate_base()`](mapping_api.html#sqlalchemy.orm.registry.generate_base
    "sqlalchemy.orm.registry.generate_base"). This “base” class includes a Python
    metaclass which implements a special `__setattr__()` method that intercepts these
    operations.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 将映射属性分配给已经映射的类，只有在使用“声明性基类”，即用户定义的[`DeclarativeBase`](mapping_api.html#sqlalchemy.orm.DeclarativeBase
    "sqlalchemy.orm.DeclarativeBase")的子类，或者由[`declarative_base()`](mapping_api.html#sqlalchemy.orm.declarative_base
    "sqlalchemy.orm.declarative_base")或者[`registry.generate_base()`](mapping_api.html#sqlalchemy.orm.registry.generate_base
    "sqlalchemy.orm.registry.generate_base")返回的动态生成的类时，才能正确运行。这个“基类”包括一个Python元类，它实现了一个特殊的`__setattr__()`方法来拦截这些操作。
- en: 'Runtime assignment of class-mapped attributes to a mapped class will **not**
    work if the class is mapped using decorators like [`registry.mapped()`](mapping_api.html#sqlalchemy.orm.registry.mapped
    "sqlalchemy.orm.registry.mapped") or imperative functions like [`registry.map_imperatively()`](mapping_api.html#sqlalchemy.orm.registry.map_imperatively
    "sqlalchemy.orm.registry.map_imperatively").  ## Declarative with Imperative Table
    (a.k.a. Hybrid Declarative)'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类映射属性对映射类进行运行时分配，如果使用装饰器，如[`registry.mapped()`](mapping_api.html#sqlalchemy.orm.registry.mapped
    "sqlalchemy.orm.registry.mapped")或者像[`registry.map_imperatively()`](mapping_api.html#sqlalchemy.orm.registry.map_imperatively
    "sqlalchemy.orm.registry.map_imperatively")这样的命令式函数进行类映射，则**无法**正常工作。## 声明式与命令式表格（又名混合声明式）
- en: Declarative mappings may also be provided with a pre-existing [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") object, or otherwise a [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") or other arbitrary [`FromClause`](../core/selectable.html#sqlalchemy.sql.expression.FromClause
    "sqlalchemy.sql.expression.FromClause") construct (such as a [`Join`](../core/selectable.html#sqlalchemy.sql.expression.Join
    "sqlalchemy.sql.expression.Join") or [`Subquery`](../core/selectable.html#sqlalchemy.sql.expression.Subquery
    "sqlalchemy.sql.expression.Subquery")) that is constructed separately.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 声明式映射也可以使用预先存在的[`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")对象，或者其他任意的[`FromClause`](../core/selectable.html#sqlalchemy.sql.expression.FromClause
    "sqlalchemy.sql.expression.FromClause")构造（例如[`Join`](../core/selectable.html#sqlalchemy.sql.expression.Join
    "sqlalchemy.sql.expression.Join")或[`Subquery`](../core/selectable.html#sqlalchemy.sql.expression.Subquery
    "sqlalchemy.sql.expression.Subquery")），它是单独构造的。
- en: 'This is referred to as a “hybrid declarative” mapping, as the class is mapped
    using the declarative style for everything involving the mapper configuration,
    however the mapped [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    object is produced separately and passed to the declarative process directly:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这被称为“混合声明式”映射，因为类使用声明式风格进行所有涉及映射器配置的操作，然而映射的[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")对象是单独生成的，并直接传递给声明性流程：
- en: '[PRE44]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Above, a [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    object is constructed using the approach described at [Describing Databases with
    MetaData](../core/metadata.html#metadata-describing). It can then be applied directly
    to a class that is declaratively mapped. The `__tablename__` and `__table_args__`
    declarative class attributes are not used in this form. The above configuration
    is often more readable as an inline definition:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，使用在[用 MetaData 描述数据库](../core/metadata.html#metadata-describing)中描述的方法构造了一个[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")对象。然后可以直接将其应用于声明性映射的类。在这种形式中，不使用`__tablename__`和`__table_args__`声明性类属性。上述配置通常更易读，作为内联定义：
- en: '[PRE45]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'A natural effect of the above style is that the `__table__` attribute is itself
    defined within the class definition block. As such it may be immediately referenced
    within subsequent attributes, such as the example below which illustrates referring
    to the `type` column in a polymorphic mapper configuration:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 上述风格的自然结果是`__table__`属性本身在类定义块中被定义。因此，它可以立即在后续属性中被引用，例如下面的例子，说明在多态映射器配置中引用`type`列：
- en: '[PRE46]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The “imperative table” form is also used when a non-[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") construct, such as a [`Join`](../core/selectable.html#sqlalchemy.sql.expression.Join
    "sqlalchemy.sql.expression.Join") or [`Subquery`](../core/selectable.html#sqlalchemy.sql.expression.Subquery
    "sqlalchemy.sql.expression.Subquery") object, is to be mapped. An example below:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 当要映射非[`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")构造时，例如[`Join`](../core/selectable.html#sqlalchemy.sql.expression.Join
    "sqlalchemy.sql.expression.Join")或[`Subquery`](../core/selectable.html#sqlalchemy.sql.expression.Subquery
    "sqlalchemy.sql.expression.Subquery")对象时，也使用“命令式表”形式。以下是一个示例：
- en: '[PRE47]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: For background on mapping to non-[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") constructs see the sections [Mapping a Class against
    Multiple Tables](nonstandard_mappings.html#orm-mapping-joins) and [Mapping a Class
    against Arbitrary Subqueries](nonstandard_mappings.html#orm-mapping-arbitrary-subqueries).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 有关映射到非[`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")构造的背景，请参阅[将类映射到多个表](nonstandard_mappings.html#orm-mapping-joins)和[将类映射到任意子查询](nonstandard_mappings.html#orm-mapping-arbitrary-subqueries)一节。
- en: The “imperative table” form is of particular use when the class itself is using
    an alternative form of attribute declaration, such as Python dataclasses. See
    the section [Applying ORM Mappings to an existing dataclass (legacy dataclass
    use)](dataclasses.html#orm-declarative-dataclasses) for detail.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当类本身使用替代形式的属性声明时，例如 Python 数据类时，“命令式表”形式特别有用。详见[将 ORM 映射应用于现有数据类（传统数据类用法）](dataclasses.html#orm-declarative-dataclasses)一节。
- en: See also
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[Describing Databases with MetaData](../core/metadata.html#metadata-describing)'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用 MetaData 描述数据库](../core/metadata.html#metadata-describing)'
- en: '[Applying ORM Mappings to an existing dataclass (legacy dataclass use)](dataclasses.html#orm-declarative-dataclasses)'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '[将 ORM 映射应用于现有数据类（传统数据类用法）](dataclasses.html#orm-declarative-dataclasses)'
- en: '### Alternate Attribute Names for Mapping Table Columns'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '### 映射表列的替代属性名称'
- en: The section [Naming Declarative Mapped Columns Explicitly](#orm-declarative-table-column-naming)
    illustrated how to use [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") to provide a specific name for the generated [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") object separate from the attribute name under which
    it is mapped.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '[显式命名声明式映射的列](#orm-declarative-table-column-naming)一节说明了如何使用[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")为生成的[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")对象提供一个特定名称，与其映射的属性名称分开。'
- en: 'When using Imperative Table configuration, we already have [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects present. To map these to alternate names we
    may assign the [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    to the desired attributes directly:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用命令式表配置时，我们已经有[`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")对象存在。为了将它们映射到替代名称，我们可以直接将[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")分配给所需的属性：
- en: '[PRE48]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The `User` mapping above will refer to the `"user_id"` and `"user_name"` columns
    via the `User.id` and `User.name` attributes, in the same way as demonstrated
    at [Naming Declarative Mapped Columns Explicitly](#orm-declarative-table-column-naming).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的`User`映射将通过`User.id`和`User.name`属性引用`"user_id"`和`"user_name"`列，方式与[显式命名声明式映射的列](#orm-declarative-table-column-naming)一节所示相同。
- en: 'One caveat to the above mapping is that the direct inline link to [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") will not be typed correctly when using [**PEP 484**](https://peps.python.org/pep-0484/)
    typing tools. A strategy to resolve this is to apply the [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects within the [`column_property()`](mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property") function; while the [`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper") already generates this property object for its internal
    use automatically, by naming it in the class declaration, typing tools will be
    able to match the attribute to the [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") annotation:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 对上述映射的一个注意事项是，当使用 [**PEP 484**](https://peps.python.org/pep-0484/) 类型工具时，对 [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") 的直接内联链接将不会被正确类型化。解决此问题的一种策略是在 [`column_property()`](mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property") 函数中应用 [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") 对象；虽然 [`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper") 已经自动为其内部使用生成了此属性对象，但通过在类声明中命名它，类型工具将能够将属性与 [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") 注释匹配起来：
- en: '[PRE49]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: See also
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅
- en: '[Naming Declarative Mapped Columns Explicitly](#orm-declarative-table-column-naming)
    - applies to Declarative Table  ### Applying Load, Persistence and Mapping Options
    for Imperative Table Columns'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '[显式命名声明式映射列](#orm-declarative-table-column-naming) - 适用于声明式表  ### 对命令式表列应用加载、持久化和映射选项'
- en: 'The section [Setting Load and Persistence Options for Declarative Mapped Columns](#orm-declarative-column-options)
    reviewed how to set load and persistence options when using the [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct with Declarative Table configuration.
    When using Imperative Table configuration, we already have existing [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects that are mapped. In order to map these [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects along with additional parameters that are
    specific to the ORM mapping, we may use the [`column_property()`](mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property") and [`deferred()`](queryguide/columns.html#sqlalchemy.orm.deferred
    "sqlalchemy.orm.deferred") constructs in order to associate additional parameters
    with the column. Options include:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在[为声明式映射列设置加载和持久化选项](#orm-declarative-column-options)一节中，讲述了如何在使用声明式表配置时设置加载和持久化选项时，使用
    [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    构造。在使用命令式表配置时，我们已经有了现有的与之映射的 [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") 对象。为了映射这些与额外参数一起的 [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") 对象，这些参数特定于 ORM 映射，我们可以使用 [`column_property()`](mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property") 和 [`deferred()`](queryguide/columns.html#sqlalchemy.orm.deferred
    "sqlalchemy.orm.deferred") 构造以将额外参数与列关联起来。选项包括：
- en: '**deferred column loading** - The [`deferred()`](queryguide/columns.html#sqlalchemy.orm.deferred
    "sqlalchemy.orm.deferred") function is shorthand for invoking [`column_property()`](mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property") with the [`column_property.deferred`](mapping_api.html#sqlalchemy.orm.column_property.params.deferred
    "sqlalchemy.orm.column_property") parameter set to `True`; this construct establishes
    the [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    using [deferred column loading](queryguide/columns.html#orm-queryguide-column-deferral)
    by default. In the example below, the `User.bio` column will not be loaded by
    default, but only when accessed:'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**推迟加载列** - [`deferred()`](queryguide/columns.html#sqlalchemy.orm.deferred
    "sqlalchemy.orm.deferred") 函数是使用 [`column_property.deferred`](mapping_api.html#sqlalchemy.orm.column_property.params.deferred
    "sqlalchemy.orm.column_property") 参数设置为 `True` 调用 [`column_property()`](mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property") 的速记方式；此构造默认使用 [推迟加载列](queryguide/columns.html#orm-queryguide-column-deferral)
    来建立 [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")。在下面的示例中，`User.bio`
    列将不会默认加载，而只在访问时加载：'
- en: '[PRE50]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: See also
  id: totrans-177
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 请参阅
- en: ''
  id: totrans-178
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[Limiting which Columns Load with Column Deferral](queryguide/columns.html#orm-queryguide-column-deferral)
    - full description of deferred column loading'
  id: totrans-179
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[限制加载列与列推迟加载](queryguide/columns.html#orm-queryguide-column-deferral) - 推迟列加载的完整描述'
- en: '**active history** - The [`column_property.active_history`](mapping_api.html#sqlalchemy.orm.column_property.params.active_history
    "sqlalchemy.orm.column_property") ensures that upon change of value for the attribute,
    the previous value will have been loaded and made part of the [`AttributeState.history`](internals.html#sqlalchemy.orm.AttributeState.history
    "sqlalchemy.orm.AttributeState.history") collection when inspecting the history
    of the attribute. This may incur additional SQL statements:'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**活动历史** - [`column_property.active_history`](mapping_api.html#sqlalchemy.orm.column_property.params.active_history
    "sqlalchemy.orm.column_property") 确保在属性值更改时，之前的值将已加载并成为检查属性历史时的[`AttributeState.history`](internals.html#sqlalchemy.orm.AttributeState.history
    "sqlalchemy.orm.AttributeState.history")集合的一部分。这可能会产生额外的SQL语句：'
- en: '[PRE51]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: See also
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'The [`column_property()`](mapping_api.html#sqlalchemy.orm.column_property "sqlalchemy.orm.column_property")
    construct is also important for cases where classes are mapped to alternative
    FROM clauses such as joins and selects. More background on these cases is at:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '[`column_property()`](mapping_api.html#sqlalchemy.orm.column_property "sqlalchemy.orm.column_property")
    构造对于类被映射到替代的FROM子句（例如连接和选择）的情况也很重要。有关这些情况的更多背景信息请参阅：'
- en: '[Mapping a Class against Multiple Tables](nonstandard_mappings.html#maptojoin)'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[将类映射到多个表](nonstandard_mappings.html#maptojoin)'
- en: '[SQL Expressions as Mapped Attributes](mapped_sql_expr.html#mapper-sql-expressions)'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SQL表达式作为映射属性](mapped_sql_expr.html#mapper-sql-expressions)'
- en: 'For Declarative Table configuration with [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column"), most options are available directly; see the
    section [Setting Load and Persistence Options for Declarative Mapped Columns](#orm-declarative-column-options)
    for examples.  ## Mapping Declaratively with Reflected Tables'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '对于使用[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")进行声明式表配置，大多数选项都是直接可用的；请参阅[设置声明式映射列的加载和持久化选项](#orm-declarative-column-options)一节的示例。  ##
    使用反射表声明式映射'
- en: There are several patterns available which provide for producing mapped classes
    against a series of [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    objects that were introspected from the database, using the reflection process
    described at [Reflecting Database Objects](../core/reflection.html#metadata-reflection).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种可用的模式，用于根据从数据库反射的一系列[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")对象生成映射类，使用的是在[反映数据库对象](../core/reflection.html#metadata-reflection)中描述的反射过程。
- en: 'A simple way to map a class to a table reflected from the database is to use
    a declarative hybrid mapping, passing the [`Table.autoload_with`](../core/metadata.html#sqlalchemy.schema.Table.params.autoload_with
    "sqlalchemy.schema.Table") parameter to the constructor for [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table"):'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 从数据库反射到表的简单方法是使用声明式混合映射，将[`Table.autoload_with`](../core/metadata.html#sqlalchemy.schema.Table.params.autoload_with
    "sqlalchemy.schema.Table")参数传递给[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")的构造函数：
- en: '[PRE52]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'A variant on the above pattern that scales for many tables is to use the [`MetaData.reflect()`](../core/metadata.html#sqlalchemy.schema.MetaData.reflect
    "sqlalchemy.schema.MetaData.reflect") method to reflect a full set of [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects at once, then refer to them from the [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData"):'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 上述模式的变体适用于许多表的情况，可以使用[`MetaData.reflect()`](../core/metadata.html#sqlalchemy.schema.MetaData.reflect
    "sqlalchemy.schema.MetaData.reflect")方法一次反射完整的[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")对象集合，然后从[`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData")中引用它们：
- en: '[PRE53]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: One caveat to the approach of using `__table__` is that the mapped classes cannot
    be declared until the tables have been reflected, which requires the database
    connectivity source to be present while the application classes are being declared;
    it’s typical that classes are declared as the modules of an application are being
    imported, but database connectivity isn’t available until the application starts
    running code so that it can consume configuration information and create an engine.
    There are currently two approaches to working around this, described in the next
    two sections.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `__table__` 方法的一个注意事项是，映射的类不能声明，直到表被反射，这需要数据库连接源在声明应用程序类时存在；典型情况下，类是在应用程序模块被导入时声明的，但是数据库连接直到应用程序开始运行代码时才可用，以便它可以使用配置信息并创建引擎。目前有两种解决此问题的方法，描述在下面的两个部分中。
- en: '### Using DeferredReflection'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '### 使用 DeferredReflection'
- en: 'To accommodate the use case of declaring mapped classes where reflection of
    table metadata can occur afterwards, a simple extension called the [`DeferredReflection`](extensions/declarative/index.html#sqlalchemy.ext.declarative.DeferredReflection
    "sqlalchemy.ext.declarative.DeferredReflection") mixin is available, which alters
    the declarative mapping process to be delayed until a special class-level [`DeferredReflection.prepare()`](extensions/declarative/index.html#sqlalchemy.ext.declarative.DeferredReflection.prepare
    "sqlalchemy.ext.declarative.DeferredReflection.prepare") method is called, which
    will perform the reflection process against a target database, and will integrate
    the results with the declarative table mapping process, that is, classes which
    use the `__tablename__` attribute:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 为了适应声明映射类的用例，可以稍后对表元数据进行反射的情况，提供了一个简单的扩展，称为 [`DeferredReflection`](extensions/declarative/index.html#sqlalchemy.ext.declarative.DeferredReflection
    "sqlalchemy.ext.declarative.DeferredReflection") mixin，它改变了声明映射过程，延迟到特殊的类级 [`DeferredReflection.prepare()`](extensions/declarative/index.html#sqlalchemy.ext.declarative.DeferredReflection.prepare
    "sqlalchemy.ext.declarative.DeferredReflection.prepare") 方法被调用，该方法将根据目标数据库执行反射过程，并将结果与声明表映射过程集成，即使用
    `__tablename__` 属性的类：
- en: '[PRE54]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Above, we create a mixin class `Reflected` that will serve as a base for classes
    in our declarative hierarchy that should become mapped when the `Reflected.prepare`
    method is called. The above mapping is not complete until we do so, given an [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine"):'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，我们创建了一个名为 `Reflected` 的混合类，该类将作为声明性层次结构中的类的基础，当调用 `Reflected.prepare`
    方法时应该被映射。在进行此映射之前，以上映射是不完整的，给定一个 [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine")：
- en: '[PRE55]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The purpose of the `Reflected` class is to define the scope at which classes
    should be reflectively mapped. The plugin will search among the subclass tree
    of the target against which `.prepare()` is called and reflect all tables which
    are named by declared classes; tables in the target database that are not part
    of mappings and are not related to the target tables via foreign key constraint
    will not be reflected.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`Reflected` 类的目的是定义类应该被反射映射的范围。插件将在调用 `.prepare()` 的目标的子类树中搜索，并反射所有由声明类命名的表；目标数据库中不属于映射的表，且不通过外键约束与目标表相关的表将不会被反射。'
- en: Using Automap
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用自动映射
- en: A more automated solution to mapping against an existing database where table
    reflection is to be used is to use the [Automap](extensions/automap.html) extension.
    This extension will generate entire mapped classes from a database schema, including
    relationships between classes based on observed foreign key constraints. While
    it includes hooks for customization, such as hooks that allow custom class naming
    and relationship naming schemes, automap is oriented towards an expedient zero-configuration
    style of working. If an application wishes to have a fully explicit model that
    makes use of table reflection, the [DeferredReflection](#orm-declarative-reflected-deferred-reflection)
    class may be preferable for its less automated approach.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更自动化的解决方案是使用 [自动映射](extensions/automap.html) 扩展来映射现有数据库，其中使用表反射。该扩展将从数据库模式生成整个映射的类，包括基于观察到的外键约束的类之间的关系。虽然它包含用于定制的挂钩，例如允许自定义类命名和关系命名方案的挂钩，但自动映射是面向迅速零配置的工作风格。如果应用程序希望具有完全明确的模型，并使用表反射，那么
    [DeferredReflection](#orm-declarative-reflected-deferred-reflection) 类可能更可取，因为它的方法较少自动化。
- en: See also
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Automap](extensions/automap.html)'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '[自动映射](extensions/automap.html)'
- en: '### Automating Column Naming Schemes from Reflected Tables'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '### 自动从反射表中命名列方案'
- en: When using any of the previous reflection techniques, we have the option to
    change the naming scheme by which columns are mapped. The [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") object includes a parameter [`Column.key`](../core/metadata.html#sqlalchemy.schema.Column.params.key
    "sqlalchemy.schema.Column") which is a string name that determines under what
    name this [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    will be present in the [`Table.c`](../core/metadata.html#sqlalchemy.schema.Table.c
    "sqlalchemy.schema.Table.c") collection, independently of the SQL name of the
    column. This key is also used by [`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper") as the attribute name under which the [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") will be mapped, if not supplied through other means
    such as that illustrated at [Alternate Attribute Names for Mapping Table Columns](#orm-imperative-table-column-naming).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用任何以前的反射技术时，我们有选择通过列映射的命名方案。 [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") 对象包括一个参数 [`Column.key`](../core/metadata.html#sqlalchemy.schema.Column.params.key
    "sqlalchemy.schema.Column")，它是一个字符串名称，确定此 [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") 将以何种名称独立于列的 SQL 名称出现在 [`Table.c`](../core/metadata.html#sqlalchemy.schema.Table.c
    "sqlalchemy.schema.Table.c") 集合中。如果未通过其他方式提供，例如在 [映射表列的备用属性名称](#orm-imperative-table-column-naming)
    中说明的那样，此键也将由 [`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper "sqlalchemy.orm.Mapper")
    用作将 [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    映射到的属性名称。
- en: When working with table reflection, we can intercept the parameters that will
    be used for [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    as they are received using the [`DDLEvents.column_reflect()`](../core/events.html#sqlalchemy.events.DDLEvents.column_reflect
    "sqlalchemy.events.DDLEvents.column_reflect") event and apply whatever changes
    we need, including the `.key` attribute but also things like datatypes.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用表反射时，我们可以拦截将作为参数接收到的 [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") 的参数，并应用我们需要的任何更改，包括 `.key` 属性，以及诸如数据类型之类的内容。
- en: 'The event hook is most easily associated with the [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") object that’s in use as illustrated below:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 事件挂钩最容易与正在使用的 [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") 对象相关联，如下所示：
- en: '[PRE56]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'With the above event, the reflection of [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects will be intercepted with our event that adds
    a new “.key” element, such as in a mapping as below:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 有了上述事件，[`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    对象的反射将被我们添加新的“.key”元素的事件拦截，例如在下面的映射中：
- en: '[PRE57]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The approach also works with both the [`DeferredReflection`](extensions/declarative/index.html#sqlalchemy.ext.declarative.DeferredReflection
    "sqlalchemy.ext.declarative.DeferredReflection") base class as well as with the
    [Automap](extensions/automap.html) extension. For automap specifically, see the
    section [Intercepting Column Definitions](extensions/automap.html#automap-intercepting-columns)
    for background.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法也适用于 [`DeferredReflection`](extensions/declarative/index.html#sqlalchemy.ext.declarative.DeferredReflection
    "sqlalchemy.ext.declarative.DeferredReflection") 基类以及 [Automap](extensions/automap.html)
    扩展。特别是对于 automap，请参阅部分 [拦截列定义](extensions/automap.html#automap-intercepting-columns)
    以了解背景信息。
- en: See also
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Mapping Declaratively with Reflected Tables](#orm-declarative-reflected)'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用反射表声明式映射](#orm-declarative-reflected)'
- en: '[`DDLEvents.column_reflect()`](../core/events.html#sqlalchemy.events.DDLEvents.column_reflect
    "sqlalchemy.events.DDLEvents.column_reflect")'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '[`DDLEvents.column_reflect()`](../core/events.html#sqlalchemy.events.DDLEvents.column_reflect
    "sqlalchemy.events.DDLEvents.column_reflect")'
- en: '[Intercepting Column Definitions](extensions/automap.html#automap-intercepting-columns)
    - in the [Automap](extensions/automap.html) documentation  ### Mapping to an Explicit
    Set of Primary Key Columns'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '[拦截列定义](extensions/automap.html#automap-intercepting-columns) - 在 [Automap](extensions/automap.html)
    文档中  ### 映射到明确的主键列集'
- en: The [`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper "sqlalchemy.orm.Mapper")
    construct in order to successfully map a table always requires that at least one
    column be identified as the “primary key” for that selectable. This is so that
    when an ORM object is loaded or persisted, it can be placed in the [identity map](../glossary.html#term-identity-map)
    with an appropriate [identity key](../glossary.html#term-identity-key).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 为了成功映射一个表，[`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper "sqlalchemy.orm.Mapper")
    构造始终要求至少标识一个列为该可选择项的“主键”。这样，当加载或持久化 ORM 对象时，它可以被放置在具有适当 [标识键](../glossary.html#term-identity-key)
    的[标识映射](../glossary.html#term-identity-map)中。
- en: In those cases where the a reflected table to be mapped does not include a primary
    key constraint, as well as in the general case for [mapping against arbitrary
    selectables](nonstandard_mappings.html#orm-mapping-arbitrary-subqueries) where
    primary key columns might not be present, the [`Mapper.primary_key`](mapping_api.html#sqlalchemy.orm.Mapper.params.primary_key
    "sqlalchemy.orm.Mapper") parameter is provided so that any set of columns may
    be configured as the “primary key” for the table, as far as ORM mapping is concerned.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在那些被映射的反射表不包含主键约束的情况下，以及在[针对任意可选择项进行映射](nonstandard_mappings.html#orm-mapping-arbitrary-subqueries)的一般情况下，可能不存在主键列的情况下，提供了
    [`Mapper.primary_key`](mapping_api.html#sqlalchemy.orm.Mapper.params.primary_key
    "sqlalchemy.orm.Mapper") 参数，以便可以将任何一组列配置为表的“主键”，就 ORM 映射而言。
- en: 'Given the following example of an Imperative Table mapping against an existing
    [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    object where the table does not have any declared primary key (as may occur in
    reflection scenarios), we may map such a table as in the following example:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个针对现有 [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    对象进行命令式表映射的示例，其中该表没有声明的主键（可能在反射情景中出现），我们可以将这样的表映射如下示例所示：
- en: '[PRE58]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Above, the `group_users` table is an association table of some kind with string
    columns `user_id` and `group_id`, but no primary key is set up; instead, there
    is only a [`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint") establishing that the two columns represent
    a unique key. The [`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper "sqlalchemy.orm.Mapper")
    does not automatically inspect unique constraints for primary keys; instead, we
    make use of the [`Mapper.primary_key`](mapping_api.html#sqlalchemy.orm.Mapper.params.primary_key
    "sqlalchemy.orm.Mapper") parameter, passing a collection of `[group_users.c.user_id,
    group_users.c.group_id]`, indicating that these two columns should be used in
    order to construct the identity key for instances of the `GroupUsers` class.  ###
    Mapping a Subset of Table Columns'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 上文中，`group_users` 表是一种关联表，具有字符串列 `user_id` 和 `group_id`，但未设置主键；相反，只建立了一个 [`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint") 来确保这两列表示唯一键。[`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper") 不会自动检查唯一约束以用作主键；而是我们利用 [`Mapper.primary_key`](mapping_api.html#sqlalchemy.orm.Mapper.params.primary_key
    "sqlalchemy.orm.Mapper") 参数，传递了一个 `[group_users.c.user_id, group_users.c.group_id]`
    的集合，指示应使用这两列来构建 `GroupUsers` 类实例的标识键。### 映射表列的子集
- en: 'Sometimes table reflection may provide a [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") with many columns that are not important for our needs
    and may be safely ignored. For such a table that has lots of columns that don’t
    need to be referenced in the application, the [`Mapper.include_properties`](mapping_api.html#sqlalchemy.orm.Mapper.params.include_properties
    "sqlalchemy.orm.Mapper") or [`Mapper.exclude_properties`](mapping_api.html#sqlalchemy.orm.Mapper.params.exclude_properties
    "sqlalchemy.orm.Mapper") parameters can indicate a subset of columns to be mapped,
    where other columns from the target [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") will not be considered by the ORM in any way. Example:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，表反射可能会提供一个 [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")，其中包含许多对我们的需求不重要且可以安全忽略的列。对于这样一个具有许多不需要在应用程序中引用的列的表，[`Mapper.include_properties`](mapping_api.html#sqlalchemy.orm.Mapper.params.include_properties
    "sqlalchemy.orm.Mapper") 或 [`Mapper.exclude_properties`](mapping_api.html#sqlalchemy.orm.Mapper.params.exclude_properties
    "sqlalchemy.orm.Mapper") 参数可以指示要映射的列的子集，其中目标 [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") 中的其他列不会以任何方式被 ORM 考虑。示例：
- en: '[PRE59]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: In the above example, the `User` class will map to the `user_table` table, only
    including the `user_id` and `user_name` columns - the rest are not referenced.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，`User` 类将映射到 `user_table` 表，只包括 `user_id` 和 `user_name` 列 - 其余列不被引用。
- en: 'Similarly:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地：
- en: '[PRE60]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: will map the `Address` class to the `address_table` table, including all columns
    present except `street`, `city`, `state`, and `zip`.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `Address` 类映射到 `address_table` 表，包括除了 `street`、`city`、`state` 和 `zip` 之外的所有列。
- en: 'As indicated in the two examples, columns may be referenced either by string
    name or by referring to the [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") object directly. Referring to the object directly
    may be useful for explicitness as well as to resolve ambiguities when mapping
    to multi-table constructs that might have repeated names:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如两个示例所示，列可以通过字符串名称或直接引用 [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") 对象来引用。直接引用对象可能对明确性和解决映射到具有重复名称的多表构造时的歧义很有用：
- en: '[PRE61]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: When columns are not included in a mapping, these columns will not be referenced
    in any SELECT statements emitted when executing [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") or legacy [`Query`](queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") objects, nor will there be any mapped attribute on the
    mapped class which represents the column; assigning an attribute of that name
    will have no effect beyond that of a normal Python attribute assignment.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 当列未包含在映射中时，在执行 [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") 或传统的 [`Query`](queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") 对象时，这些列不会被引用在任何SELECT语句中，映射类中也不会有任何代表该列的映射属性；给定该名称的属性赋值将不会产生除普通Python属性赋值以外的效果。
- en: However, it is important to note that **schema level column defaults WILL still
    be in effect** for those [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects that include them, even though they may be
    excluded from the ORM mapping.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，重要的是要注意，**模式级别的列默认值仍然会生效**，对于那些包含这些默认值的 [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") 对象，即使它们被排除在ORM映射之外。
- en: '“Schema level column defaults” refers to the defaults described at [Column
    INSERT/UPDATE Defaults](../core/defaults.html#metadata-defaults) including those
    configured by the [`Column.default`](../core/metadata.html#sqlalchemy.schema.Column.params.default
    "sqlalchemy.schema.Column"), [`Column.onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.onupdate
    "sqlalchemy.schema.Column"), [`Column.server_default`](../core/metadata.html#sqlalchemy.schema.Column.params.server_default
    "sqlalchemy.schema.Column") and [`Column.server_onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.server_onupdate
    "sqlalchemy.schema.Column") parameters. These constructs continue to have normal
    effects because in the case of [`Column.default`](../core/metadata.html#sqlalchemy.schema.Column.params.default
    "sqlalchemy.schema.Column") and [`Column.onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.onupdate
    "sqlalchemy.schema.Column"), the [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") object is still present on the underlying [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table"), thus allowing the default functions to take place
    when the ORM emits an INSERT or UPDATE, and in the case of [`Column.server_default`](../core/metadata.html#sqlalchemy.schema.Column.params.server_default
    "sqlalchemy.schema.Column") and [`Column.server_onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.server_onupdate
    "sqlalchemy.schema.Column"), the relational database itself emits these defaults
    as a server side behavior.  ## Declarative Table with `mapped_column()`'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: “模式级列默认值”指的是在[列插入/更新默认值](../core/defaults.html#metadata-defaults)中描述的默认值，包括通过[`Column.default`](../core/metadata.html#sqlalchemy.schema.Column.params.default
    "sqlalchemy.schema.Column")、[`Column.onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.onupdate
    "sqlalchemy.schema.Column")、[`Column.server_default`](../core/metadata.html#sqlalchemy.schema.Column.params.server_default
    "sqlalchemy.schema.Column")和[`Column.server_onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.server_onupdate
    "sqlalchemy.schema.Column")参数配置的那些。这些构造仍然具有正常的效果，因为在[`Column.default`](../core/metadata.html#sqlalchemy.schema.Column.params.default
    "sqlalchemy.schema.Column")和[`Column.onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.onupdate
    "sqlalchemy.schema.Column")的情况下，[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")对象仍然存在于底层的[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")上，因此当ORM发出INSERT或UPDATE时，允许默认函数发生作用，并且在[`Column.server_default`](../core/metadata.html#sqlalchemy.schema.Column.params.server_default
    "sqlalchemy.schema.Column")和[`Column.server_onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.server_onupdate
    "sqlalchemy.schema.Column")的情况下，关系数据库本身会作为服务器端行为发出这些默认值。## 带有`mapped_column()`的声明性表格
- en: 'When using Declarative, the body of the class to be mapped in most cases includes
    an attribute `__tablename__` that indicates the string name of a [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") that should be generated along with the mapping. The
    [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    construct, which features additional ORM-specific configuration capabilities not
    present in the plain [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") class, is then used within the class body to indicate
    columns in the table. The example below illustrates the most basic use of this
    construct within a Declarative mapping:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用声明性时，要映射的类的主体在大多数情况下包括一个`__tablename__`属性，该属性指示应与映射一起生成的[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")的字符串名称。然后，在类主体中使用了[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")构造，该构造具有额外的ORM特定配置功能，这些功能不在普通的[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")类中存在，以指示表中的列。下面的示例说明了在声明性映射中使用此构造的最基本用法：
- en: '[PRE62]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Above, [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    constructs are placed inline within the class definition as class level attributes.
    At the point at which the class is declared, the Declarative mapping process will
    generate a new [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    object against the [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") collection associated with the Declarative `Base`;
    each instance of [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") will then be used to generate a [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") object during this process, which will become part
    of the [`Table.columns`](../core/metadata.html#sqlalchemy.schema.Table.columns
    "sqlalchemy.schema.Table.columns") collection of this [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") object.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")构造作为类级别属性内联放置在类定义中。在声明类时，声明性映射过程将针对与声明性`Base`相关联的[`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData")集合生成一个新的[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")对象；然后每个[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")的实例将用于在此过程中生成一个[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")对象，该对象将成为此[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")对象的[`Table.columns`](../core/metadata.html#sqlalchemy.schema.Table.columns
    "sqlalchemy.schema.Table.columns")集合的一部分。
- en: 'In the above example, Declarative will build a [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") construct that is equivalent to the following:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，声明性将构建一个等效于以下内容的[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")构造：
- en: '[PRE63]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: When the `User` class above is mapped, this [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") object can be accessed directly via the `__table__`
    attribute; this is described further at [Accessing Table and Metadata](#orm-declarative-metadata).
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 当上面的`User`类被映射时，可以直接通过`__table__`属性访问此[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")对象；这在[访问表和元数据](#orm-declarative-metadata)中进一步描述。
- en: The [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    construct accepts all arguments that are accepted by the [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") construct, as well as additional ORM-specific arguments.
    The [`mapped_column.__name`](mapping_api.html#sqlalchemy.orm.mapped_column.params.__name
    "sqlalchemy.orm.mapped_column") field, indicating the name of the database column,
    is typically omitted, as the Declarative process will make use of the attribute
    name given to the construct and assign this as the name of the column (in the
    above example, this refers to the names `id`, `name`, `fullname`, `nickname`).
    Assigning an alternate [`mapped_column.__name`](mapping_api.html#sqlalchemy.orm.mapped_column.params.__name
    "sqlalchemy.orm.mapped_column") is valid as well, where the resulting [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") will use the given name in SQL and DDL statements,
    while the `User` mapped class will continue to allow access to the attribute using
    the attribute name given, independent of the name given to the column itself (more
    on this at [Naming Declarative Mapped Columns Explicitly](#mapper-column-distinct-names)).
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")构造接受[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")构造接受的所有参数，以及额外的ORM特定参数。通常省略了[`mapped_column.__name`](mapping_api.html#sqlalchemy.orm.mapped_column.params.__name
    "sqlalchemy.orm.mapped_column")字段，该字段指示数据库列的名称，因为声明性过程将使用赋予构造的属性名称，并将其分配为列的名称（在上面的示例中，这指的是名称`id`、`name`、`fullname`、`nickname`）。分配替代的[`mapped_column.__name`](mapping_api.html#sqlalchemy.orm.mapped_column.params.__name
    "sqlalchemy.orm.mapped_column")也是有效的，在这种情况下，生成的[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")将在SQL和DDL语句中使用给定的名称，而`User`映射类将继续允许使用给定的属性名称访问属性，独立于列本身的名称（有关此处更多信息，请参阅[显式命名声明性映射列](#mapper-column-distinct-names)）。'
- en: Tip
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: The [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    construct is **only valid within a Declarative class mapping**. When constructing
    a [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    object using Core as well as when using [imperative table](#orm-imperative-table-configuration)
    configuration, the [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    construct is still required in order to indicate the presence of a database column.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    构造仅在声明式类映射内有效。在使用 Core 构造 [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") 对象以及使用[命令式表](#orm-imperative-table-configuration)配置时，仍然需要
    [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    构造来指示数据库列的存在。'
- en: See also
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 参见
- en: '[Mapping Table Columns](mapping_columns.html) - contains additional notes on
    affecting how [`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper "sqlalchemy.orm.Mapper")
    interprets incoming [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '[映射表列](mapping_columns.html) - 包含了关于影响 [`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper") 解释传入的 [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") 对象的附加说明。'
- en: '### Using Annotated Declarative Table (Type Annotated Forms for `mapped_column()`)'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '### 使用带注释的声明式表（`mapped_column()`的类型注释形式）'
- en: The [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    construct is capable of deriving its column-configuration information from [**PEP
    484**](https://peps.python.org/pep-0484/) type annotations associated with the
    attribute as declared in the Declarative mapped class. These type annotations,
    if used, **must** be present within a special SQLAlchemy type called [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped"), which is a [generic](https://peps.python.org/pep-0484/#generics)
    type that then indicates a specific Python type within it.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    构造能够从与声明式映射类中声明的属性关联的 [**PEP 484**](https://peps.python.org/pep-0484/) 类型注释中导出其列配置信息。如果使用了这些类型注释，则**必须**存在于一个称为[`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped")的特殊 SQLAlchemy 类型中，这是一个[泛型](https://peps.python.org/pep-0484/#generics)类型，然后在其中指示一个特定的
    Python 类型。'
- en: 'Below illustrates the mapping from the previous section, adding the use of
    [`Mapped`](internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped"):'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 下面说明了从前一节映射的映射，增加了使用 [`Mapped`](internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped")
    的情况：
- en: '[PRE64]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Above, when Declarative processes each class attribute, each [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") will derive additional arguments from the corresponding
    [`Mapped`](internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped") type
    annotation on the left side, if present. Additionally, Declarative will generate
    an empty [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    directive implicitly, whenever a [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") type annotation is encountered that does not have a value
    assigned to the attribute (this form is inspired by the similar style used in
    Python [dataclasses](https://docs.python.org/3/library/dataclasses.html)); this
    [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    construct proceeds to derive its configuration from the [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") annotation present.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面，当声明式处理每个类属性时，如果存在的话，每个 [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") 将从左侧对应的 [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") 类型注释派生出额外的参数。此外，当遇到一个没有为属性分配值的 [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") 类型注释时（此形式受到 Python [dataclasses](https://docs.python.org/3/library/dataclasses.html)
    中使用的相似风格的启发），声明式将隐式地生成一个空的 [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") 指令；此 [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") 构造随后从存在的 [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") 注解中派生其配置。
- en: '#### `mapped_column()` derives the datatype and nullability from the `Mapped`
    annotation'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '#### `mapped_column()` 从 `Mapped` 注解中派生数据类型和可空性'
- en: 'The two qualities that [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") derives from the [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") annotation are:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    从 [`Mapped`](internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped") 注释中派生的两个特性是：'
- en: '**datatype** - the Python type given inside [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped"), as contained within the `typing.Optional` construct
    if present, is associated with a [`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") subclass such as [`Integer`](../core/type_basics.html#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer"), [`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String"), [`DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime
    "sqlalchemy.types.DateTime"), or [`Uuid`](../core/type_basics.html#sqlalchemy.types.Uuid
    "sqlalchemy.types.Uuid"), to name a few common types.'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据类型** - 在 [`Mapped`](internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped")
    中给出的 Python 类型，如果存在 `typing.Optional` 构造，则与 [`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") 的子类关联，例如 [`Integer`](../core/type_basics.html#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer")、[`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String")、[`DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime
    "sqlalchemy.types.DateTime") 或 [`Uuid`](../core/type_basics.html#sqlalchemy.types.Uuid
    "sqlalchemy.types.Uuid") 等常见类型。'
- en: 'The datatype is determined based on a dictionary of Python type to SQLAlchemy
    datatype. This dictionary is completely customizable, as detailed in the next
    section [Customizing the Type Map](#orm-declarative-mapped-column-type-map). The
    default type map is implemented as in the code example below:'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 数据类型是根据 Python 类型到 SQLAlchemy 数据类型的字典确定的。这个字典是完全可定制的，如下一节[自定义类型映射](#orm-declarative-mapped-column-type-map)中所详细描述的。默认类型映射实现如下面的代码示例所示：
- en: '[PRE65]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: If the [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    construct indicates an explicit type as passed to the [`mapped_column.__type`](mapping_api.html#sqlalchemy.orm.mapped_column.params.__type
    "sqlalchemy.orm.mapped_column") argument, then the given Python type is disregarded.
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果 [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    构造指示了作为参数传递给 [`mapped_column.__type`](mapping_api.html#sqlalchemy.orm.mapped_column.params.__type
    "sqlalchemy.orm.mapped_column") 的显式类型，则给定的 Python 类型将被忽略。
- en: '**nullability** - The [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct will indicate its [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") as `NULL` or `NOT NULL` first and foremost by the
    presence of the [`mapped_column.nullable`](mapping_api.html#sqlalchemy.orm.mapped_column.params.nullable
    "sqlalchemy.orm.mapped_column") parameter, passed either as `True` or `False`.
    Additionally , if the [`mapped_column.primary_key`](mapping_api.html#sqlalchemy.orm.mapped_column.params.primary_key
    "sqlalchemy.orm.mapped_column") parameter is present and set to `True`, that will
    also imply that the column should be `NOT NULL`.'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可空性** - [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") 构造将通过存在的 [`mapped_column.nullable`](mapping_api.html#sqlalchemy.orm.mapped_column.params.nullable
    "sqlalchemy.orm.mapped_column") 参数首先和主要指示其 [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") 是否为 `NULL` 或 `NOT NULL`，可以传递为 `True` 或 `False`。此外，如果存在并且将
    [`mapped_column.primary_key`](mapping_api.html#sqlalchemy.orm.mapped_column.params.primary_key
    "sqlalchemy.orm.mapped_column") 参数设置为 `True`，那么这也将意味着该列应为 `NOT NULL`。'
- en: In the absence of **both** of these parameters, the presence of `typing.Optional[]`
    within the [`Mapped`](internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped")
    type annotation will be used to determine nullability, where `typing.Optional[]`
    means `NULL`, and the absence of `typing.Optional[]` means `NOT NULL`. If there
    is no `Mapped[]` annotation present at all, and there is no [`mapped_column.nullable`](mapping_api.html#sqlalchemy.orm.mapped_column.params.nullable
    "sqlalchemy.orm.mapped_column") or [`mapped_column.primary_key`](mapping_api.html#sqlalchemy.orm.mapped_column.params.primary_key
    "sqlalchemy.orm.mapped_column") parameter, then SQLAlchemy’s usual default for
    [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    of `NULL` is used.
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果这两个参数都不存在，那么 [`Mapped`](internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped")
    类型注释中的 `typing.Optional[]` 的存在将用于确定可空性，其中 `typing.Optional[]` 表示 `NULL`，而不存在 `typing.Optional[]`
    则表示 `NOT NULL`。如果根本没有存在 `Mapped[]` 注释，并且也没有 [`mapped_column.nullable`](mapping_api.html#sqlalchemy.orm.mapped_column.params.nullable
    "sqlalchemy.orm.mapped_column") 或 [`mapped_column.primary_key`](mapping_api.html#sqlalchemy.orm.mapped_column.params.primary_key
    "sqlalchemy.orm.mapped_column") 参数，则SQLAlchemy在 [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") 的默认值 `NULL` 被使用。
- en: 'In the example below, the `id` and `data` columns will be `NOT NULL`, and the
    `additional_info` column will be `NULL`:'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在下面的示例中，`id` 和 `data` 列将是 `NOT NULL`，而 `additional_info` 列将是 `NULL`：
- en: '[PRE66]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'It is also perfectly valid to have a [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") whose nullability is **different** from what would
    be implied by the annotation. For example, an ORM mapped attribute may be annotated
    as allowing `None` within Python code that works with the object as it is first
    being created and populated, however the value will ultimately be written to a
    database column that is `NOT NULL`. The [`mapped_column.nullable`](mapping_api.html#sqlalchemy.orm.mapped_column.params.nullable
    "sqlalchemy.orm.mapped_column") parameter, when present, will always take precedence:'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一个 [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    也可以存在，其空值属性与注释所暗示的不同。例如，ORM映射属性在Python代码中被注释为允许 `None`，该代码在对象首次创建和填充时使用，但最终的值将写入一个
    `NOT NULL` 的数据库列。当存在 [`mapped_column.nullable`](mapping_api.html#sqlalchemy.orm.mapped_column.params.nullable
    "sqlalchemy.orm.mapped_column") 参数时，该参数始终优先：
- en: '[PRE67]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Similarly, a non-None attribute that’s written to a database column that for
    whatever reason needs to be NULL at the schema level, [`mapped_column.nullable`](mapping_api.html#sqlalchemy.orm.mapped_column.params.nullable
    "sqlalchemy.orm.mapped_column") may be set to `True`:'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 同样，写入数据库列的非 `None` 属性，如果出于某种原因需要在架构级别为 `NULL`，则可以将 [`mapped_column.nullable`](mapping_api.html#sqlalchemy.orm.mapped_column.params.nullable
    "sqlalchemy.orm.mapped_column") 设置为 `True`：
- en: '[PRE68]  #### Customizing the Type Map'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[PRE68]  #### 自定义类型映射'
- en: The mapping of Python types to SQLAlchemy [`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") types described in the previous section defaults
    to a hardcoded dictionary present in the `sqlalchemy.sql.sqltypes` module. However,
    the [`registry`](mapping_api.html#sqlalchemy.orm.registry "sqlalchemy.orm.registry")
    object that coordinates the Declarative mapping process will first consult a local,
    user defined dictionary of types which may be passed as the [`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry") parameter when constructing the [`registry`](mapping_api.html#sqlalchemy.orm.registry
    "sqlalchemy.orm.registry"), which may be associated with the [`DeclarativeBase`](mapping_api.html#sqlalchemy.orm.DeclarativeBase
    "sqlalchemy.orm.DeclarativeBase") superclass when first used.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节描述的Python类型到SQLAlchemy [`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") 类型的映射中，默认为 `sqlalchemy.sql.sqltypes` 模块中的硬编码字典。然而，协调Declarative映射过程的
    [`registry`](mapping_api.html#sqlalchemy.orm.registry "sqlalchemy.orm.registry")
    对象首先将会查看一个本地的、用户定义的类型字典，该字典可以在构造 [`registry`](mapping_api.html#sqlalchemy.orm.registry
    "sqlalchemy.orm.registry") 时作为 [`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry") 参数传递，该参数可以与首次使用时与 [`DeclarativeBase`](mapping_api.html#sqlalchemy.orm.DeclarativeBase
    "sqlalchemy.orm.DeclarativeBase") 超类相关联。
- en: 'As an example, if we wish to make use of the [`BIGINT`](../core/type_basics.html#sqlalchemy.types.BIGINT
    "sqlalchemy.types.BIGINT") datatype for `int`, the [`TIMESTAMP`](../core/type_basics.html#sqlalchemy.types.TIMESTAMP
    "sqlalchemy.types.TIMESTAMP") datatype with `timezone=True` for `datetime.datetime`,
    and then only on Microsoft SQL Server we’d like to use [`NVARCHAR`](../core/type_basics.html#sqlalchemy.types.NVARCHAR
    "sqlalchemy.types.NVARCHAR") datatype when Python `str` is used, the registry
    and Declarative base could be configured as:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 举例来说，如果我们希望对`int`使用[`BIGINT`](../core/type_basics.html#sqlalchemy.types.BIGINT
    "sqlalchemy.types.BIGINT")数据类型，对`datetime.datetime`使用带有`timezone=True`的[`TIMESTAMP`](../core/type_basics.html#sqlalchemy.types.TIMESTAMP
    "sqlalchemy.types.TIMESTAMP")数据类型，然后只在Microsoft SQL Server上当Python `str`被使用时我们希望使用[`NVARCHAR`](../core/type_basics.html#sqlalchemy.types.NVARCHAR
    "sqlalchemy.types.NVARCHAR")数据类型，那么注册表和声明基础可以配置为：
- en: '[PRE69]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Below illustrates the CREATE TABLE statement generated for the above mapping,
    first on the Microsoft SQL Server backend, illustrating the `NVARCHAR` datatype:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 下面说明了为上述映射生成的`CREATE TABLE`语句，在Microsoft SQL Server后端首先展示了`NVARCHAR`数据类型：
- en: '[PRE70]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Then on the PostgreSQL backend, illustrating `TIMESTAMP WITH TIME ZONE`:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在PostgreSQL后端，展示了`TIMESTAMP WITH TIME ZONE`：
- en: '[PRE71]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'By making use of methods such as [`TypeEngine.with_variant()`](../core/type_api.html#sqlalchemy.types.TypeEngine.with_variant
    "sqlalchemy.types.TypeEngine.with_variant"), we’re able to build up a type map
    that’s customized to what we need for different backends, while still being able
    to use succinct annotation-only [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") configurations. There are two more levels of Python-type
    configurability available beyond this, described in the next two sections.  ####
    Mapping Multiple Type Configurations to Python Types'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用诸如[`TypeEngine.with_variant()`](../core/type_api.html#sqlalchemy.types.TypeEngine.with_variant
    "sqlalchemy.types.TypeEngine.with_variant")之类的方法，我们能够构建一个针对不同后端定制的类型映射，同时仍然能够使用简洁的注解方式配置[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")。除此之外，还有两个级别的Python类型可配置性，将在接下来的两个部分中描述。#### 将多个类型配置映射到Python类型
- en: As individual Python types may be associated with [`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") configurations of any variety by using the [`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry") parameter, an additional capability is the ability
    to associate a single Python type with different variants of a SQL type based
    on additional type qualifiers. One typical example of this is mapping the Python
    `str` datatype to `VARCHAR` SQL types of different lengths. Another is mapping
    different varieties of `decimal.Decimal` to differently sized `NUMERIC` columns.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 由于个别Python类型可以通过使用[`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry")参数与任何类型的[`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine")配置相关联，另一个功能是根据附加类型限定符将单个Python类型与SQL类型的不同变体关联起来的能力。其中一个典型示例是将Python
    `str`数据类型映射到不同长度的`VARCHAR` SQL类型。另一个示例是将不同种类的`decimal.Decimal`映射到不同大小的`NUMERIC`列。
- en: 'Python’s typing system provides a great way to add additional metadata to a
    Python type which is by using the [**PEP 593**](https://peps.python.org/pep-0593/)
    `Annotated` generic type, which allows additional information to be bundled along
    with a Python type. The [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct will correctly interpret an `Annotated`
    object by identity when resolving it in the [`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry"), as in the example below where we declare two variants
    of [`String`](../core/type_basics.html#sqlalchemy.types.String "sqlalchemy.types.String")
    and [`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric "sqlalchemy.types.Numeric"):'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: Python的类型系统提供了一种很好的方式来为Python类型添加附加元数据，即使用[**PEP 593**](https://peps.python.org/pep-0593/)
    `Annotated`泛型类型，它允许将附加信息与Python类型捆绑在一起。当在[`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry")中解析时，[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")构造将正确地识别`Annotated`对象的标识，就像下面的示例中声明两个[`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String")和[`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric
    "sqlalchemy.types.Numeric")变体时一样：
- en: '[PRE72]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The Python type passed to the `Annotated` container, in the above example the
    `str` and `Decimal` types, is important only for the benefit of typing tools;
    as far as the [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct is concerned, it will only need perform
    a lookup of each type object in the [`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry") dictionary without actually looking inside of the `Annotated`
    object, at least in this particular context. Similarly, the arguments passed to
    `Annotated` beyond the underlying Python type itself are also not important, it’s
    only that at least one argument must be present for the `Annotated` construct
    to be valid. We can then use these augmented types directly in our mapping where
    they will be matched to the more specific type constructions, as in the following
    example:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给`Annotated`容器的 Python 类型，在上面的示例中是`str`和`Decimal`类型，仅对于类型工具的好处是重要的；就[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")结构而言，它只需要在[`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry")字典中查找每个类型对象，而不实际查看`Annotated`对象的内部，至少在这种特定上下文中是如此。类似地，传递给`Annotated`的除了底层
    Python 类型之外的参数也不重要，只是至少必须存在一个参数才能使`Annotated`构造有效。然后，我们可以直接在我们的映射中使用这些增强型类型，它们将与更具体的类型构造匹配，就像以下示例中所示：
- en: '[PRE73]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'a CREATE TABLE for the above mapping will illustrate the different variants
    of `VARCHAR` and `NUMERIC` we’ve configured, and looks like:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 上述映射的 CREATE TABLE 将说明我们配置的不同变体的`VARCHAR`和`NUMERIC`，并且如下所示：
- en: '[PRE74]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'While variety in linking `Annotated` types to different SQL types grants us
    a wide degree of flexibility, the next section illustrates a second way in which
    `Annotated` may be used with Declarative that is even more open ended.  #### Mapping
    Whole Column Declarations to Python Types'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然将`Annotated`类型与不同的 SQL 类型进行链接的多样性为我们提供了广泛的灵活性，但下一节将说明另一种使用 `Annotated` 与声明式的方式，这种方式甚至更加开放。####
    将整个列声明映射到 Python 类型
- en: The previous section illustrated using [**PEP 593**](https://peps.python.org/pep-0593/)
    `Annotated` type instances as keys within the [`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry") dictionary. In this form, the [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct does not actually look inside the `Annotated`
    object itself, it’s instead used only as a dictionary key. However, Declarative
    also has the ability to extract an entire pre-established [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct from an `Annotated` object directly.
    Using this form, we can define not only different varieties of SQL datatypes linked
    to Python types without using the [`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry") dictionary, we can also set up any number of arguments
    such as nullability, column defaults, and constraints in a reusable fashion.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 上一节详细介绍了如何使用[**PEP 593**](https://peps.python.org/pep-0593/)中的`Annotated`类型实例作为[`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry")字典中的键。在这种形式下，[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")结构实际上并不查看`Annotated`对象本身，而是仅用作字典键。然而，声明式还具有直接从`Annotated`对象中提取整个预先建立的[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")结构的能力。使用这种形式，我们不仅可以定义与 Python 类型链接的不同类型的 SQL 数据类型，而无需使用[`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry")字典，还可以以可重用的方式设置任意数量的参数，例如可空性、列默认值和约束。
- en: A set of ORM models will usually have some kind of primary key style that is
    common to all mapped classes. There also may be common column configurations such
    as timestamps with defaults and other fields of pre-established sizes and configurations.
    We can compose these configurations into [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") instances that we then bundle directly into instances
    of `Annotated`, which are then re-used in any number of class declarations. Declarative
    will unpack an `Annotated` object when provided in this manner, skipping over
    any other directives that don’t apply to SQLAlchemy and searching only for SQLAlchemy
    ORM constructs.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 一组 ORM 模型通常会有一种对所有映射类都通用的主键样式。还可能有常见的列配置，例如具有默认值的时间戳和其他预先设置大小和配置的字段。我们可以将这些配置组合成[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")实例，然后直接捆绑到`Annotated`的实例中，然后在任意数量的类声明中重复使用。当以这种方式提供`Annotated`对象时，Declarative
    将解开一个`Annotated`对象，跳过任何不适用于 SQLAlchemy 的其他指令，并仅搜索 SQLAlchemy ORM 构造。
- en: 'The example below illustrates a variety of pre-configured field types used
    in this way, where we define `intpk` that represents an [`Integer`](../core/type_basics.html#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer") primary key column, `timestamp` that represents a
    [`DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime "sqlalchemy.types.DateTime")
    type which will use `CURRENT_TIMESTAMP` as a DDL level column default, and `required_name`
    which is a [`String`](../core/type_basics.html#sqlalchemy.types.String "sqlalchemy.types.String")
    of length 30 that’s `NOT NULL`:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的示例说明了以这种方式使用的各种预配置字段类型，我们在这里定义了`intpk`，表示一个[`Integer`](../core/type_basics.html#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer")主键列，`timestamp`表示一个[`DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime
    "sqlalchemy.types.DateTime")类型，它将使用`CURRENT_TIMESTAMP`作为 DDL 级别列默认值，并且 `required_name`
    是一个长度为 30 的[`String`](../core/type_basics.html#sqlalchemy.types.String "sqlalchemy.types.String")，它是
    `NOT NULL` 的：
- en: '[PRE75]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The above `Annotated` objects can then be used directly within [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped"), where the pre-configured [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") constructs will be extracted and copied to a new
    instance that will be specific to each attribute:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 上述的`Annotated`对象可以直接在[`Mapped`](internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped")内使用，在这里，预先配置的[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")构造将被提取并复制到一个新的实例中，该实例将针对每个属性具体化：
- en: '[PRE76]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '`CREATE TABLE` for our above mapping looks like:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们上面映射的`CREATE TABLE`看起来像：
- en: '[PRE77]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'When using `Annotated` types in this way, the configuration of the type may
    also be affected on a per-attribute basis. For the types in the above example
    that feature explicit use of [`mapped_column.nullable`](mapping_api.html#sqlalchemy.orm.mapped_column.params.nullable
    "sqlalchemy.orm.mapped_column"), we can apply the `Optional[]` generic modifier
    to any of our types so that the field is optional or not at the Python level,
    which will be independent of the `NULL` / `NOT NULL` setting that takes place
    in the database:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 当以这种方式使用`Annotated`类型时，类型的配置也可能会受到每个属性的影响。对于上面示例中显式使用[`mapped_column.nullable`](mapping_api.html#sqlalchemy.orm.mapped_column.params.nullable
    "sqlalchemy.orm.mapped_column")的类型，我们可以对任何类型应用`Optional[]`通用修饰符，以使该字段在 Python
    级别是可选的还是不可选的，这将独立于在数据库中发生的`NULL` / `NOT NULL`设置：
- en: '[PRE78]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    construct is also reconciled with an explicitly passed [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct, whose arguments will take precedence
    over those of the `Annotated` construct. Below we add a [`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey") constraint to our integer primary key and also
    use an alternate server default for the `created_at` column:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")构造也与显式传递的[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")构造相调和，其参数将优先于`Annotated`构造的参数。下面我们给我们的整数主键添加了一个[`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey")约束，并且还为`created_at`列使用了一个备用服务器默认值：'
- en: '[PRE79]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'The CREATE TABLE statement illustrates these per-attribute settings, adding
    a `FOREIGN KEY` constraint as well as substituting `UTC_TIMESTAMP` for `CURRENT_TIMESTAMP`:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '`CREATE TABLE`语句说明了这些每个属性的设置，除此之外，还添加了一个`FOREIGN KEY`约束，并将`UTC_TIMESTAMP`替换为`CURRENT_TIMESTAMP`：'
- en: '[PRE80]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Note
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The feature of [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") just described, where a fully constructed set
    of column arguments may be indicated using [**PEP 593**](https://peps.python.org/pep-0593/)
    `Annotated` objects that contain a “template” [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") object to be copied into the attribute, is currently
    not implemented for other ORM constructs such as [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") and [`composite()`](composites.html#sqlalchemy.orm.composite
    "sqlalchemy.orm.composite"). While this functionality is in theory possible, for
    the moment attempting to use `Annotated` to indicate further arguments for [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") and similar will raise a `NotImplementedError`
    exception at runtime, but may be implemented in future releases.  #### Using Python
    `Enum` or pep-586 `Literal` types in the type map'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '刚才描述的 [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    功能，其中可以使用 [**PEP 593**](https://peps.python.org/pep-0593/) 的 `Annotated` 对象指示一组完整构造的列参数，该对象包含一个“模板”
    [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    对象，将被复制到属性中，目前尚未针对其他 ORM 构造（例如 [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") 和 [`composite()`](composites.html#sqlalchemy.orm.composite
    "sqlalchemy.orm.composite")）实现。虽然这种功能理论上是可能的，但目前尝试使用 `Annotated` 来指示对 [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") 等的进一步参数将在运行时引发 `NotImplementedError` 异常，但可能会在未来的版本中实现。  ####
    在类型映射中使用 Python `Enum` 或 pep-586 `Literal` 类型'
- en: 'New in version 2.0.0b4: - Added `Enum` support'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 新版本 2.0.0b4 中新增：- 添加了 `Enum` 支持
- en: 'New in version 2.0.1: - Added `Literal` support'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 新版本 2.0.1 中新增：- 添加了 `Literal` 支持
- en: 'User-defined Python types which derive from the Python built-in `enum.Enum`
    as well as the `typing.Literal` class are automatically linked to the SQLAlchemy
    [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.types.Enum")
    datatype when used in an ORM declarative mapping. The example below uses a custom
    `enum.Enum` within the `Mapped[]` constructor:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 当在 ORM 声明映射中使用时，用户定义的 Python 类型，其派生自 Python 内置的 `enum.Enum` 类以及 `typing.Literal`
    类，将自动链接到 SQLAlchemy [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.types.Enum")
    数据类型。下面的示例在 `Mapped[]` 构造函数中使用了自定义的 `enum.Enum`：
- en: '[PRE81]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'In the above example, the mapped attribute `SomeClass.status` will be linked
    to a [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    with the datatype of `Enum(Status)`. We can see this for example in the CREATE
    TABLE output for the PostgreSQL database:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，映射属性 `SomeClass.status` 将链接到一个 [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")，其数据类型为 `Enum(Status)`。我们可以在 PostgreSQL 数据库的 CREATE
    TABLE 输出中看到这一点：
- en: '[PRE82]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'In a similar way, `typing.Literal` may be used instead, using a `typing.Literal`
    that consists of all strings:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，也可以使用 `typing.Literal`，其中包含了所有字符串：
- en: '[PRE83]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'The entries used in [`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry") link the base `enum.Enum` Python type as well as the
    `typing.Literal` type to the SQLAlchemy [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum") SQL type, using a special form which indicates to the
    [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.types.Enum")
    datatype that it should automatically configure itself against an arbitrary enumerated
    type. This configuration, which is implicit by default, would be indicated explicitly
    as:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry") 中使用的条目将基本的 `enum.Enum` Python 类型以及 `typing.Literal`
    类型链接到 SQLAlchemy [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.types.Enum")
    SQL 类型，使用的是一种特殊的形式，指示 [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum") 数据类型应自动配置自己以适应任意枚举类型。默认情况下，这种配置是隐式的，但可以显式指示如下：
- en: '[PRE84]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: The resolution logic within Declarative is able to resolve subclasses of `enum.Enum`
    as well as instances of `typing.Literal` to match the `enum.Enum` or `typing.Literal`
    entry in the [`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry") dictionary. The [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum") SQL type then knows how to produce a configured version
    of itself with the appropriate settings, including default string length. If a
    `typing.Literal` that does not consist of only string values is passed, an informative
    error is raised.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Declarative 内部的解析逻辑能够解析 `enum.Enum` 的子类以及 `typing.Literal` 的实例，以匹配 [`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry") 字典中的 `enum.Enum` 或 `typing.Literal` 条目。然后，[`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum") SQL 类型知道如何生成具有适当设置的配置版本，包括默认字符串长度。如果传递了不仅由字符串值组成的 `typing.Literal`，则会引发详细的错误。
- en: Native Enums and Naming
  id: totrans-304
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 本地枚举和命名
- en: The [`Enum.native_enum`](../core/type_basics.html#sqlalchemy.types.Enum.params.native_enum
    "sqlalchemy.sql.sqltypes.Enum") parameter refers to if the [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.sql.sqltypes.Enum") datatype should create a so-called “native” enum,
    which on MySQL/MariaDB is the `ENUM` datatype and on PostgreSQL is a new `TYPE`
    object created by `CREATE TYPE`, or a “non-native” enum, which means that `VARCHAR`
    will be used to create the datatype. For backends other than MySQL/MariaDB or
    PostgreSQL, `VARCHAR` is used in all cases (third party dialects may have their
    own behaviors).
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Enum.native_enum`](../core/type_basics.html#sqlalchemy.types.Enum.params.native_enum
    "sqlalchemy.sql.sqltypes.Enum") 参数指的是 [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.sql.sqltypes.Enum") 数据类型是否应该创建所谓的“本机”枚举，在 MySQL/MariaDB 上是 `ENUM`
    数据类型，在 PostgreSQL 上是通过 `CREATE TYPE` 创建的新 `TYPE` 对象，或者“非本机”枚举，这意味着将使用 `VARCHAR`
    创建数据类型。对于除 MySQL/MariaDB 或 PostgreSQL 之外的后端，无论如何都使用 `VARCHAR`（第三方方言可能具有自己的行为）。'
- en: 'Because PostgreSQL’s `CREATE TYPE` requires that there’s an explicit name for
    the type to be created, special fallback logic exists when working with implicitly
    generated [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.sql.sqltypes.Enum")
    without specifying an explicit [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.sql.sqltypes.Enum") datatype within a mapping:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 PostgreSQL 的 `CREATE TYPE` 要求必须为要创建的类型指定显式名称，所以在使用隐式生成的 [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.sql.sqltypes.Enum") 而没有在映射中指定显式的 [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.sql.sqltypes.Enum") 数据类型时存在特殊的回退逻辑：
- en: If the [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.sql.sqltypes.Enum")
    is linked to an `enum.Enum` object, the [`Enum.native_enum`](../core/type_basics.html#sqlalchemy.types.Enum.params.native_enum
    "sqlalchemy.sql.sqltypes.Enum") parameter defaults to `True` and the name of the
    enum will be taken from the name of the `enum.Enum` datatype. The PostgreSQL backend
    will assume `CREATE TYPE` with this name.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.sql.sqltypes.Enum")
    链接到 `enum.Enum` 对象，则 [`Enum.native_enum`](../core/type_basics.html#sqlalchemy.types.Enum.params.native_enum
    "sqlalchemy.sql.sqltypes.Enum") 参数默认为 `True`，枚举的名称将从 `enum.Enum` 数据类型的名称中取。PostgreSQL
    后端将假定使用此名称创建 `CREATE TYPE`。
- en: If the [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.sql.sqltypes.Enum")
    is linked to a `typing.Literal` object, the [`Enum.native_enum`](../core/type_basics.html#sqlalchemy.types.Enum.params.native_enum
    "sqlalchemy.sql.sqltypes.Enum") parameter defaults to `False`; no name is generated
    and `VARCHAR` is assumed.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.sql.sqltypes.Enum")
    链接到 `typing.Literal` 对象，则 [`Enum.native_enum`](../core/type_basics.html#sqlalchemy.types.Enum.params.native_enum
    "sqlalchemy.sql.sqltypes.Enum") 参数默认为 `False`；不生成名称，并且假定为 `VARCHAR`。
- en: 'To use `typing.Literal` with a PostgreSQL `CREATE TYPE` type, an explicit [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.sql.sqltypes.Enum") must be used, either within the type map:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 PostgreSQL 的 `CREATE TYPE` 类型中使用 `typing.Literal`，必须使用显式的 [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.sql.sqltypes.Enum")，可以在类型映射中：
- en: '[PRE85]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Or alternatively within [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column"):'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 或者在 [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    中另外使用：
- en: '[PRE86]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Altering the Configuration of the Default Enum
  id: totrans-313
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 修改默认枚举的配置
- en: 'In order to modify the fixed configuration of the `Enum` datatype that’s generated
    implicitly, specify new entries in the [`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry"), indicating additional arguments. For example, to use
    “non native enumerations” unconditionally, the [`Enum.native_enum`](../core/type_basics.html#sqlalchemy.types.Enum.params.native_enum
    "sqlalchemy.types.Enum") parameter may be set to False for all types:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 为了修改隐式生成的`Enum`数据类型的固定配置，可以在[`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry")中指定新条目，指示附加参数。例如，要无条件使用“非原生枚举”，可以为所有类型设置[`Enum.native_enum`](../core/type_basics.html#sqlalchemy.types.Enum.params.native_enum
    "sqlalchemy.types.Enum")参数为False：
- en: '[PRE87]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Changed in version 2.0.1: Implemented support for overriding parameters such
    as [`Enum.native_enum`](../core/type_basics.html#sqlalchemy.types.Enum.params.native_enum
    "sqlalchemy.types.Enum") within the [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum") datatype when establishing the [`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry"). Previously, this functionality was not working.'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在2.0.1版本中更改：在建立[`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.types.Enum")数据类型时，实现了覆盖参数（如[`Enum.native_enum`](../core/type_basics.html#sqlalchemy.types.Enum.params.native_enum
    "sqlalchemy.types.Enum")）的支持在[`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry")中。先前，此功能无效。
- en: 'To use a specific configuration for a specific `enum.Enum` subtype, such as
    setting the string length to 50 when using the example `Status` datatype:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 要为特定的`enum.Enum`子类型使用特定的配置，例如在使用示例`Status`数据类型时将字符串长度设置为50：
- en: '[PRE88]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'By default [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.types.Enum")
    that are automatically generated are not associated with the `MetaData` instance
    used by the `Base`, so if the metadata defines a schema it will not be automatically
    associated with the enum. To automatically associate the enum with the schema
    in the metadata or table they belong to the [`Enum.inherit_schema`](../core/type_basics.html#sqlalchemy.types.Enum.params.inherit_schema
    "sqlalchemy.types.Enum") can be set:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，自动生成的[`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.types.Enum")不与`Base`使用的`MetaData`实例关联，因此，如果元数据定义了模式，它将不会自动与枚举关联。要自动将枚举与元数据中的模式或表关联起来，可以设置[`Enum.inherit_schema`](../core/type_basics.html#sqlalchemy.types.Enum.params.inherit_schema
    "sqlalchemy.types.Enum")：
- en: '[PRE89]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Linking Specific `enum.Enum` or `typing.Literal` to other datatypes
  id: totrans-321
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 将特定的`enum.Enum`或`typing.Literal`链接到其他数据类型
- en: 'The above examples feature the use of an [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum") that is automatically configuring itself to the arguments
    / attributes present on an `enum.Enum` or `typing.Literal` type object. For use
    cases where specific kinds of `enum.Enum` or `typing.Literal` should be linked
    to other types, these specific types may be placed in the type map also. In the
    example below, an entry for `Literal[]` that contains non-string types is linked
    to the [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON")
    datatype:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例展示了自动配置自身到`enum.Enum`或`typing.Literal`类型对象的[`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum")的使用。对于特定种类的`enum.Enum`或`typing.Literal`应链接到其他类型的用例，也可以将这些特定类型放置在类型映射中。在下面的示例中，一个包含非字符串类型的`Literal[]`条目链接到了[`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON")数据类型：
- en: '[PRE90]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: In the above configuration, the `my_literal` datatype will resolve to a [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON") instance. Other `Literal` variants will continue to resolve
    to [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.types.Enum")
    datatypes.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述配置中，`my_literal`数据类型将解析为一个[`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON")实例。其他`Literal`变体将继续解析为[`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum")数据类型。
- en: Dataclass features in `mapped_column()`
  id: totrans-325
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在`mapped_column()`中的Dataclass特性
- en: 'The [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    construct integrates with SQLAlchemy’s “native dataclasses” feature, discussed
    at [Declarative Dataclass Mapping](dataclasses.html#orm-declarative-native-dataclasses).
    See that section for current background on additional directives supported by
    [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column").  ###
    Accessing Table and Metadata'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")结构与SQLAlchemy的“本地数据类”功能集成，该功能在[声明性数据类映射](dataclasses.html#orm-declarative-native-dataclasses)中讨论。有关[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")支持的其他指令的当前背景，请参阅该部分。 ### 访问表和元数据'
- en: 'A declaratively mapped class will always include an attribute called `__table__`;
    when the above configuration using `__tablename__` is complete, the declarative
    process makes the [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    available via the `__table__` attribute:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 一个声明性映射的类始终会包含一个名为`__table__`的属性；当上述配置使用`__tablename__`完成时，声明性过程通过`__table__`属性使[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")可用：
- en: '[PRE91]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'The above table is ultimately the same one that corresponds to the [`Mapper.local_table`](mapping_api.html#sqlalchemy.orm.Mapper.local_table
    "sqlalchemy.orm.Mapper.local_table") attribute, which we can see through the [runtime
    inspection system](../core/inspection.html):'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 上述表最终是与[`Mapper.local_table`](mapping_api.html#sqlalchemy.orm.Mapper.local_table
    "sqlalchemy.orm.Mapper.local_table")属性相对应的表，我们可以通过[运行时检查系统](../core/inspection.html)看到这一点：
- en: '[PRE92]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'The [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData "sqlalchemy.schema.MetaData")
    collection associated with both the declarative [`registry`](mapping_api.html#sqlalchemy.orm.registry
    "sqlalchemy.orm.registry") as well as the base class is frequently necessary in
    order to run DDL operations such as CREATE, as well as in use with migration tools
    such as Alembic. This object is available via the `.metadata` attribute of [`registry`](mapping_api.html#sqlalchemy.orm.registry
    "sqlalchemy.orm.registry") as well as the declarative base class. Below, for a
    small script we may wish to emit a CREATE for all tables against a SQLite database:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 与声明性[`registry`](mapping_api.html#sqlalchemy.orm.registry "sqlalchemy.orm.registry")以及基类关联的[`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData")集合通常是运行DDL操作（例如CREATE）以及与诸如Alembic之类的迁移工具一起使用的必要对象。此对象可通过[`registry`](mapping_api.html#sqlalchemy.orm.registry
    "sqlalchemy.orm.registry")以及声明性基类的`.metadata`属性获得。下面，对于一个小脚本，我们可能希望针对SQLite数据库发出所有表的CREATE：
- en: '[PRE93]  ### Declarative Table Configuration'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE93]  ### 声明性表配置'
- en: When using Declarative Table configuration with the `__tablename__` declarative
    class attribute, additional arguments to be supplied to the [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") constructor should be provided using the `__table_args__`
    declarative class attribute.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`__tablename__`声明性类属性进行声明性表配置时，应使用`__table_args__`声明性类属性提供额外的参数供[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")构造函数使用。
- en: 'This attribute accommodates both positional as well as keyword arguments that
    are normally sent to the [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") constructor. The attribute can be specified in one
    of two forms. One is as a dictionary:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 此属性可容纳通常发送到[`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")构造函数的位置参数和关键字参数。该属性可以以两种形式之一指定。一种是作为字典：
- en: '[PRE94]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'The other, a tuple, where each argument is positional (usually constraints):'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种是元组，其中每个参数是位置参数（通常是约束）：
- en: '[PRE95]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Keyword arguments can be specified with the above form by specifying the last
    argument as a dictionary:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将最后一个参数指定为字典，可以使用上述形式指定关键字参数：
- en: '[PRE96]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'A class may also specify the `__table_args__` declarative attribute, as well
    as the `__tablename__` attribute, in a dynamic style using the [`declared_attr()`](mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr") method decorator. See [Composing Mapped Hierarchies
    with Mixins](declarative_mixins.html) for background.  ### Explicit Schema Name
    with Declarative Table'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '类还可以使用[`declared_attr()`](mapping_api.html#sqlalchemy.orm.declared_attr "sqlalchemy.orm.declared_attr")方法装饰器以动态方式指定`__table_args__`声明属性和`__tablename__`属性。有关背景，请参见[使用
    Mixin 构建映射层级](declarative_mixins.html) ### 使用声明性表的显式模式名称'
- en: 'The schema name for a [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") as documented at [Specifying the Schema Name](../core/metadata.html#schema-table-schema-name)
    is applied to an individual [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") using the [`Table.schema`](../core/metadata.html#sqlalchemy.schema.Table.params.schema
    "sqlalchemy.schema.Table") argument. When using Declarative tables, this option
    is passed like any other to the `__table_args__` dictionary:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 如文档中所述，[`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")的模式名称应用于单个[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")，使用[`Table.schema`](../core/metadata.html#sqlalchemy.schema.Table.params.schema
    "sqlalchemy.schema.Table")参数。在使用声明式表时，此选项像任何其他选项一样传递给`__table_args__`字典：
- en: '[PRE97]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'The schema name can also be applied to all [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects globally by using the [`MetaData.schema`](../core/metadata.html#sqlalchemy.schema.MetaData.params.schema
    "sqlalchemy.schema.MetaData") parameter documented at [Specifying a Default Schema
    Name with MetaData](../core/metadata.html#schema-metadata-schema-name). The [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") object may be constructed separately and associated
    with a [`DeclarativeBase`](mapping_api.html#sqlalchemy.orm.DeclarativeBase "sqlalchemy.orm.DeclarativeBase")
    subclass by assigning to the `metadata` attribute directly:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 模式名称也可以通过使用文档化的[`MetaData.schema`](../core/metadata.html#sqlalchemy.schema.MetaData.params.schema
    "sqlalchemy.schema.MetaData")参数全局应用于所有[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")对象。[`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData")对象可以单独构建，并通过直接赋值给`metadata`属性与[`DeclarativeBase`](mapping_api.html#sqlalchemy.orm.DeclarativeBase
    "sqlalchemy.orm.DeclarativeBase")子类关联：
- en: '[PRE98]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: See also
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[Specifying the Schema Name](../core/metadata.html#schema-table-schema-name)
    - in the [Describing Databases with MetaData](../core/metadata.html) documentation.  ###
    Setting Load and Persistence Options for Declarative Mapped Columns'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '[指定模式名称](../core/metadata.html#schema-table-schema-name) - 在[使用 MetaData 描述数据库](../core/metadata.html)文档中。###
    设置声明式映射列的加载和持久化选项'
- en: 'The [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    construct accepts additional ORM-specific arguments that affect how the generated
    [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    is mapped, affecting its load and persistence-time behavior. Options that are
    commonly used include:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    构造函数接受额外的与ORM相关的参数，影响生成的[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")的映射方式，影响其加载和持久化行为。常用的选项包括：'
- en: '**deferred column loading** - The [`mapped_column.deferred`](mapping_api.html#sqlalchemy.orm.mapped_column.params.deferred
    "sqlalchemy.orm.mapped_column") boolean establishes the [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") using [deferred column loading](queryguide/columns.html#orm-queryguide-column-deferral)
    by default. In the example below, the `User.bio` column will not be loaded by
    default, but only when accessed:'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**延迟列加载** - [`mapped_column.deferred`](mapping_api.html#sqlalchemy.orm.mapped_column.params.deferred
    "sqlalchemy.orm.mapped_column") 布尔值默认使用[延迟列加载](queryguide/columns.html#orm-queryguide-column-deferral)来建立[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")。在下面的示例中，`User.bio`列默认不会被加载，只有在访问时才会加载：'
- en: '[PRE99]'
  id: totrans-349
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: See also
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[Limiting which Columns Load with Column Deferral](queryguide/columns.html#orm-queryguide-column-deferral)
    - full description of deferred column loading'
  id: totrans-351
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[限制哪些列与列延迟加载](queryguide/columns.html#orm-queryguide-column-deferral) - 延迟列加载的完整描述'
- en: '**active history** - The [`mapped_column.active_history`](mapping_api.html#sqlalchemy.orm.mapped_column.params.active_history
    "sqlalchemy.orm.mapped_column") ensures that upon change of value for the attribute,
    the previous value will have been loaded and made part of the [`AttributeState.history`](internals.html#sqlalchemy.orm.AttributeState.history
    "sqlalchemy.orm.AttributeState.history") collection when inspecting the history
    of the attribute. This may incur additional SQL statements:'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**活动历史** - [`mapped_column.active_history`](mapping_api.html#sqlalchemy.orm.mapped_column.params.active_history
    "sqlalchemy.orm.mapped_column") 确保在属性值更改时，先前的值已被加载，并在检查属性历史时成为[`AttributeState.history`](internals.html#sqlalchemy.orm.AttributeState.history
    "sqlalchemy.orm.AttributeState.history")集合的一部分。这可能会导致额外的SQL语句：'
- en: '[PRE100]'
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: See the docstring for [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") for a list of supported parameters.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 参见[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")的文档字符串以获取支持的参数列表。
- en: See also
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[Applying Load, Persistence and Mapping Options for Imperative Table Columns](#orm-imperative-table-column-options)
    - describes using [`column_property()`](mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property") and [`deferred()`](queryguide/columns.html#sqlalchemy.orm.deferred
    "sqlalchemy.orm.deferred") for use with Imperative Table configuration  ### Naming
    Declarative Mapped Columns Explicitly'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '[应用于命令式表列的加载、持久化和映射选项](#orm-imperative-table-column-options) - 描述了使用[`column_property()`](mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property")和[`deferred()`](queryguide/columns.html#sqlalchemy.orm.deferred
    "sqlalchemy.orm.deferred")与命令式表配置一起使用  ### 明确命名声明式映射列'
- en: 'All of the examples thus far feature the [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct linked to an ORM mapped attribute, where
    the Python attribute name given to the [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") is also that of the column as we see in CREATE
    TABLE statements as well as queries. The name for a column as expressed in SQL
    may be indicated by passing the string positional argument [`mapped_column.__name`](mapping_api.html#sqlalchemy.orm.mapped_column.params.__name
    "sqlalchemy.orm.mapped_column") as the first positional argument. In the example
    below, the `User` class is mapped with alternate names given to the columns themselves:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，所有的例子都以ORM映射属性链接到[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")构造为特色，其中Python属性名称赋予了[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")，正如我们在CREATE TABLE语句和查询中看到的那样。在SQL中表示列的名称可以通过将字符串位置参数[`mapped_column.__name`](mapping_api.html#sqlalchemy.orm.mapped_column.params.__name
    "sqlalchemy.orm.mapped_column")传递为第一个位置参数来指示。在下面的示例中，`User`类被映射到了给定列的备用名称：
- en: '[PRE101]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Where above `User.id` resolves to a column named `user_id` and `User.name`
    resolves to a column named `user_name`. We may write a [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") statement using our Python attribute names
    and will see the SQL names generated:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述例子中，`User.id`解析为名为`user_id`的列，而`User.name`解析为名为`user_name`的列。我们可以使用Python属性名称编写一个[`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select")语句，然后会看到生成的SQL名称：
- en: '[PRE102]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: See also
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[Alternate Attribute Names for Mapping Table Columns](#orm-imperative-table-column-naming)
    - applies to Imperative Table  ### Appending additional columns to an existing
    Declarative mapped class'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '[映射表列的备用属性名称](#orm-imperative-table-column-naming) - 适用于命令式表  ### 向现有声明式映射类追加额外的列'
- en: A declarative table configuration allows the addition of new [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects to an existing mapping after the [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") metadata has already been generated.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 声明式表配置允许在已生成[`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")元数据之后向现有映射添加新的[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")对象。
- en: 'For a declarative class that is declared using a declarative base class, the
    underlying metaclass `DeclarativeMeta` includes a `__setattr__()` method that
    will intercept additional [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") or Core [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects and add them to both the [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") using [`Table.append_column()`](../core/metadata.html#sqlalchemy.schema.Table.append_column
    "sqlalchemy.schema.Table.append_column") as well as to the existing [`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper") using [`Mapper.add_property()`](mapping_api.html#sqlalchemy.orm.Mapper.add_property
    "sqlalchemy.orm.Mapper.add_property"):'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 对于使用声明基类声明的声明类，底层元类`DeclarativeMeta`包括一个`__setattr__()`方法，将拦截附加的[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")或核心[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")对象，并将它们添加到[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")使用[`Table.append_column()`](../core/metadata.html#sqlalchemy.schema.Table.append_column
    "sqlalchemy.schema.Table.append_column")以及现有的[`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper")使用[`Mapper.add_property()`](mapping_api.html#sqlalchemy.orm.Mapper.add_property
    "sqlalchemy.orm.Mapper.add_property")：
- en: '[PRE103]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Using core [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column"):'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 使用核心[`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")：
- en: '[PRE104]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: All arguments are supported including an alternate name, such as `MyClass.some_new_column
    = mapped_column("some_name", String)`. However, the SQL type must be passed to
    the [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    or [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    object explicitly, as in the above examples where the [`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String") type is passed. There’s no capability for the [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") annotation type to take part in the operation.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 所有参数都受支持，包括替代名称，例如`MyClass.some_new_column = mapped_column("some_name", String)`。然而，SQL
    类型必须显式地传递给[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")或[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")对象，就像上面的示例中传递了[`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String")类型一样。[`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped")注释类型无法参与操作。
- en: Additional [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    objects may also be added to a mapping in the specific circumstance of using single
    table inheritance, where additional columns are present on mapped subclasses that
    have no [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    of their own. This is illustrated in the section [Single Table Inheritance](inheritance.html#single-inheritance).
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用单表继承的特定情况下，还可以向映射添加其他[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")对象，在此情况下，映射的子类上存在其他列，这些列没有自己的[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")。这在[单表继承](inheritance.html#single-inheritance)部分进行了说明。
- en: See also
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Adding Relationships to Mapped Classes After Declaration](basic_relationships.html#orm-declarative-table-adding-relationship)
    - similar examples for [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '[在声明后向映射类添加关系](basic_relationships.html#orm-declarative-table-adding-relationship)
    - [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")的类似示例'
- en: Note
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Assignment of mapped properties to an already mapped class will only function
    correctly if the “declarative base” class is used, meaning the user-defined subclass
    of [`DeclarativeBase`](mapping_api.html#sqlalchemy.orm.DeclarativeBase "sqlalchemy.orm.DeclarativeBase")
    or the dynamically generated class returned by [`declarative_base()`](mapping_api.html#sqlalchemy.orm.declarative_base
    "sqlalchemy.orm.declarative_base") or [`registry.generate_base()`](mapping_api.html#sqlalchemy.orm.registry.generate_base
    "sqlalchemy.orm.registry.generate_base"). This “base” class includes a Python
    metaclass which implements a special `__setattr__()` method that intercepts these
    operations.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 将映射属性分配给已映射类只有在使用“声明基类”时才能正常运行，这意味着用户定义的[`DeclarativeBase`](mapping_api.html#sqlalchemy.orm.DeclarativeBase
    "sqlalchemy.orm.DeclarativeBase")子类或由[`declarative_base()`](mapping_api.html#sqlalchemy.orm.declarative_base
    "sqlalchemy.orm.declarative_base")或[`registry.generate_base()`](mapping_api.html#sqlalchemy.orm.registry.generate_base
    "sqlalchemy.orm.registry.generate_base")返回的动态生成类。这个“基类”包括一个实现特殊`__setattr__()`方法的Python元类，用于拦截这些操作。
- en: 'Runtime assignment of class-mapped attributes to a mapped class will **not**
    work if the class is mapped using decorators like [`registry.mapped()`](mapping_api.html#sqlalchemy.orm.registry.mapped
    "sqlalchemy.orm.registry.mapped") or imperative functions like [`registry.map_imperatively()`](mapping_api.html#sqlalchemy.orm.registry.map_imperatively
    "sqlalchemy.orm.registry.map_imperatively").  ### Using Annotated Declarative
    Table (Type Annotated Forms for `mapped_column()`)'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 将类映射属性运行时分配给映射类，如果使用装饰器（[`registry.mapped()`](mapping_api.html#sqlalchemy.orm.registry.mapped
    "sqlalchemy.orm.registry.mapped")）或命令式函数（[`registry.map_imperatively()`](mapping_api.html#sqlalchemy.orm.registry.map_imperatively
    "sqlalchemy.orm.registry.map_imperatively")）来映射类，则**不会**起作用。### 使用注释声明表（`mapped_column()`的类型注释形式）
- en: The [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    construct is capable of deriving its column-configuration information from [**PEP
    484**](https://peps.python.org/pep-0484/) type annotations associated with the
    attribute as declared in the Declarative mapped class. These type annotations,
    if used, **must** be present within a special SQLAlchemy type called [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped"), which is a [generic](https://peps.python.org/pep-0484/#generics)
    type that then indicates a specific Python type within it.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")构造能够从声明式映射类中声明的与属性关联的[**PEP
    484**](https://peps.python.org/pep-0484/)类型注释中派生其列配置信息。如果使用了这些类型注释，则**必须**存在于一个名为[`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped")的特殊SQLAlchemy类型中，这是一个[泛型](https://peps.python.org/pep-0484/#generics)类型，然后在其中���示一个特定的Python类型。'
- en: 'Below illustrates the mapping from the previous section, adding the use of
    [`Mapped`](internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped"):'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 下面说明了前一节的映射，添加了对[`Mapped`](internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped")的使用：
- en: '[PRE105]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: Above, when Declarative processes each class attribute, each [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") will derive additional arguments from the corresponding
    [`Mapped`](internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped") type
    annotation on the left side, if present. Additionally, Declarative will generate
    an empty [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    directive implicitly, whenever a [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") type annotation is encountered that does not have a value
    assigned to the attribute (this form is inspired by the similar style used in
    Python [dataclasses](https://docs.python.org/3/library/dataclasses.html)); this
    [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    construct proceeds to derive its configuration from the [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") annotation present.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述情况下，当声明式处理每个类属性时，如果存在的话，每个[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")将从左侧对应的[`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped")类型注释中派生出额外的参数。此外，当遇到没有为属性分配值的[`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped")类型注释时（这种形式受到Python [dataclasses](https://docs.python.org/3/library/dataclasses.html)中使用的类似风格的启发），声明式将隐式生成一个空的[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")指令；这个[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")构造将从存在的[`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped")注释中派生其配置。
- en: '#### `mapped_column()` derives the datatype and nullability from the `Mapped`
    annotation'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '#### `mapped_column()` 从 `Mapped` 注释中派生数据类型和可空性'
- en: 'The two qualities that [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") derives from the [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") annotation are:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    从 [`Mapped`](internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped") 注释派生的两个特点是：'
- en: '**datatype** - the Python type given inside [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped"), as contained within the `typing.Optional` construct
    if present, is associated with a [`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") subclass such as [`Integer`](../core/type_basics.html#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer"), [`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String"), [`DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime
    "sqlalchemy.types.DateTime"), or [`Uuid`](../core/type_basics.html#sqlalchemy.types.Uuid
    "sqlalchemy.types.Uuid"), to name a few common types.'
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**datatype** - 给定在 [`Mapped`](internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped")
    中的 Python 类型，如果存在，则与 [`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") 的子类相关联，例如 [`Integer`](../core/type_basics.html#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer")、[`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String")、[`DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime
    "sqlalchemy.types.DateTime") 或 [`Uuid`](../core/type_basics.html#sqlalchemy.types.Uuid
    "sqlalchemy.types.Uuid")，等等常见类型。'
- en: 'The datatype is determined based on a dictionary of Python type to SQLAlchemy
    datatype. This dictionary is completely customizable, as detailed in the next
    section [Customizing the Type Map](#orm-declarative-mapped-column-type-map). The
    default type map is implemented as in the code example below:'
  id: totrans-382
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 数据类型是基于 Python 类型到 SQLAlchemy 数据类型的字典确定的。如下一节 [自定义类型映射](#orm-declarative-mapped-column-type-map)
    中详细说明的那样，该字典是完全可定制的。默认类型映射的实现如下面的代码示例所示：
- en: '[PRE106]'
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: If the [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    construct indicates an explicit type as passed to the [`mapped_column.__type`](mapping_api.html#sqlalchemy.orm.mapped_column.params.__type
    "sqlalchemy.orm.mapped_column") argument, then the given Python type is disregarded.
  id: totrans-384
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果 [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    构造指示明确的类型，作为传递给 [`mapped_column.__type`](mapping_api.html#sqlalchemy.orm.mapped_column.params.__type
    "sqlalchemy.orm.mapped_column") 参数，则给定的 Python 类型将被忽略。
- en: '**nullability** - The [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct will indicate its [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") as `NULL` or `NOT NULL` first and foremost by the
    presence of the [`mapped_column.nullable`](mapping_api.html#sqlalchemy.orm.mapped_column.params.nullable
    "sqlalchemy.orm.mapped_column") parameter, passed either as `True` or `False`.
    Additionally , if the [`mapped_column.primary_key`](mapping_api.html#sqlalchemy.orm.mapped_column.params.primary_key
    "sqlalchemy.orm.mapped_column") parameter is present and set to `True`, that will
    also imply that the column should be `NOT NULL`.'
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可空性** - [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") 构造将首先通过 [`mapped_column.nullable`](mapping_api.html#sqlalchemy.orm.mapped_column.params.nullable
    "sqlalchemy.orm.mapped_column") 参数的存在与否来指示其 [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") 是 `NULL` 还是 `NOT NULL`，可以传递为 `True` 或 `False`。此外，如果存在
    [`mapped_column.primary_key`](mapping_api.html#sqlalchemy.orm.mapped_column.params.primary_key
    "sqlalchemy.orm.mapped_column") 参数并设置为 `True`，那么这也将意味着该列应该是 `NOT NULL`。'
- en: In the absence of **both** of these parameters, the presence of `typing.Optional[]`
    within the [`Mapped`](internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped")
    type annotation will be used to determine nullability, where `typing.Optional[]`
    means `NULL`, and the absence of `typing.Optional[]` means `NOT NULL`. If there
    is no `Mapped[]` annotation present at all, and there is no [`mapped_column.nullable`](mapping_api.html#sqlalchemy.orm.mapped_column.params.nullable
    "sqlalchemy.orm.mapped_column") or [`mapped_column.primary_key`](mapping_api.html#sqlalchemy.orm.mapped_column.params.primary_key
    "sqlalchemy.orm.mapped_column") parameter, then SQLAlchemy’s usual default for
    [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    of `NULL` is used.
  id: totrans-386
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果这两个参数都不存在，则在[`Mapped`](internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped")类型注释中存在`typing.Optional[]`将用于确定可为空性，其中`typing.Optional[]`表示`NULL`，而没有`typing.Optional[]`表示`NOT
    NULL`。如果根本没有`Mapped[]`注释，并且没有[`mapped_column.nullable`](mapping_api.html#sqlalchemy.orm.mapped_column.params.nullable
    "sqlalchemy.orm.mapped_column")或[`mapped_column.primary_key`](mapping_api.html#sqlalchemy.orm.mapped_column.params.primary_key
    "sqlalchemy.orm.mapped_column")参数，则使用SQLAlchemy对[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")的通常默认值`NULL`。
- en: 'In the example below, the `id` and `data` columns will be `NOT NULL`, and the
    `additional_info` column will be `NULL`:'
  id: totrans-387
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在下面的示例中，`id`和`data`列将是`NOT NULL`，而`additional_info`列将是`NULL`：
- en: '[PRE107]'
  id: totrans-388
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'It is also perfectly valid to have a [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") whose nullability is **different** from what would
    be implied by the annotation. For example, an ORM mapped attribute may be annotated
    as allowing `None` within Python code that works with the object as it is first
    being created and populated, however the value will ultimately be written to a
    database column that is `NOT NULL`. The [`mapped_column.nullable`](mapping_api.html#sqlalchemy.orm.mapped_column.params.nullable
    "sqlalchemy.orm.mapped_column") parameter, when present, will always take precedence:'
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从注释中可以推断出的[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")的可为null性与注释所暗示的可为null性不同是完全有效的。例如，在使用对象进行首次创建和填充的Python代码中，ORM映射的属性可能被注释为允许`None`，但最终该值将被写入到一个`NOT
    NULL`的数据库列中。当存在时，[`mapped_column.nullable`](mapping_api.html#sqlalchemy.orm.mapped_column.params.nullable
    "sqlalchemy.orm.mapped_column")参数将始终优先考虑：
- en: '[PRE108]'
  id: totrans-390
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Similarly, a non-None attribute that’s written to a database column that for
    whatever reason needs to be NULL at the schema level, [`mapped_column.nullable`](mapping_api.html#sqlalchemy.orm.mapped_column.params.nullable
    "sqlalchemy.orm.mapped_column") may be set to `True`:'
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 类似地，需要在模式级别为某些原因需要为NULL的数据库列写入的非None属性，可以将[`mapped_column.nullable`](mapping_api.html#sqlalchemy.orm.mapped_column.params.nullable
    "sqlalchemy.orm.mapped_column")设置为`True`：
- en: '[PRE109]  #### Customizing the Type Map'
  id: totrans-392
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[PRE109]  #### 自定义类型映射'
- en: The mapping of Python types to SQLAlchemy [`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") types described in the previous section defaults
    to a hardcoded dictionary present in the `sqlalchemy.sql.sqltypes` module. However,
    the [`registry`](mapping_api.html#sqlalchemy.orm.registry "sqlalchemy.orm.registry")
    object that coordinates the Declarative mapping process will first consult a local,
    user defined dictionary of types which may be passed as the [`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry") parameter when constructing the [`registry`](mapping_api.html#sqlalchemy.orm.registry
    "sqlalchemy.orm.registry"), which may be associated with the [`DeclarativeBase`](mapping_api.html#sqlalchemy.orm.DeclarativeBase
    "sqlalchemy.orm.DeclarativeBase") superclass when first used.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一节描述的Python类型到SQLAlchemy [`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine")类型的映射默认为硬编码字典，位于`sqlalchemy.sql.sqltypes`模块中。然而，协调Declarative映射过程的[`registry`](mapping_api.html#sqlalchemy.orm.registry
    "sqlalchemy.orm.registry")对象将首先查询一个本地的、用户定义的类型字典，该字典可以在构造[`registry`](mapping_api.html#sqlalchemy.orm.registry
    "sqlalchemy.orm.registry")时作为[`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry")参数传递，并且在首次使用时可能与[`DeclarativeBase`](mapping_api.html#sqlalchemy.orm.DeclarativeBase
    "sqlalchemy.orm.DeclarativeBase")超类相关联。
- en: 'As an example, if we wish to make use of the [`BIGINT`](../core/type_basics.html#sqlalchemy.types.BIGINT
    "sqlalchemy.types.BIGINT") datatype for `int`, the [`TIMESTAMP`](../core/type_basics.html#sqlalchemy.types.TIMESTAMP
    "sqlalchemy.types.TIMESTAMP") datatype with `timezone=True` for `datetime.datetime`,
    and then only on Microsoft SQL Server we’d like to use [`NVARCHAR`](../core/type_basics.html#sqlalchemy.types.NVARCHAR
    "sqlalchemy.types.NVARCHAR") datatype when Python `str` is used, the registry
    and Declarative base could be configured as:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个示例，如果我们希望使用[`BIGINT`](../core/type_basics.html#sqlalchemy.types.BIGINT "sqlalchemy.types.BIGINT")数据类型代表`int`，在`datetime.datetime`上使用带有`timezone=True`的[`TIMESTAMP`](../core/type_basics.html#sqlalchemy.types.TIMESTAMP
    "sqlalchemy.types.TIMESTAMP")数据类型，并且仅在 Microsoft SQL Server 上使用[`NVARCHAR`](../core/type_basics.html#sqlalchemy.types.NVARCHAR
    "sqlalchemy.types.NVARCHAR")数据类型时，Python `str` 被使用，那么注册表和 Declarative base 可以被配置为：
- en: '[PRE110]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Below illustrates the CREATE TABLE statement generated for the above mapping,
    first on the Microsoft SQL Server backend, illustrating the `NVARCHAR` datatype:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 下面演示了针对上述映射生成的 CREATE TABLE 语句，首先在 Microsoft SQL Server 后端上，说明了 `NVARCHAR` 数据类型：
- en: '[PRE111]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Then on the PostgreSQL backend, illustrating `TIMESTAMP WITH TIME ZONE`:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 接着在 PostgreSQL 后端上，说明 `TIMESTAMP WITH TIME ZONE`：
- en: '[PRE112]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'By making use of methods such as [`TypeEngine.with_variant()`](../core/type_api.html#sqlalchemy.types.TypeEngine.with_variant
    "sqlalchemy.types.TypeEngine.with_variant"), we’re able to build up a type map
    that’s customized to what we need for different backends, while still being able
    to use succinct annotation-only [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") configurations. There are two more levels of Python-type
    configurability available beyond this, described in the next two sections.  ####
    Mapping Multiple Type Configurations to Python Types'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: '通过使用[`TypeEngine.with_variant()`](../core/type_api.html#sqlalchemy.types.TypeEngine.with_variant
    "sqlalchemy.types.TypeEngine.with_variant")等方法，我们能够构建一个针对不同后端的定制类型映射，同时仍然能够使用简洁的基于注释的
    [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    配置。在此之上还有两个级别的 Python 类型可配置性可用，将在接下来的两个部分中描述。  #### 将多个类型配置映射到 Python 类型'
- en: As individual Python types may be associated with [`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") configurations of any variety by using the [`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry") parameter, an additional capability is the ability
    to associate a single Python type with different variants of a SQL type based
    on additional type qualifiers. One typical example of this is mapping the Python
    `str` datatype to `VARCHAR` SQL types of different lengths. Another is mapping
    different varieties of `decimal.Decimal` to differently sized `NUMERIC` columns.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 由于个别 Python 类型可以通过使用[`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry")参数与任何类型的`TypeEngine`配置相关联，因此另一个能力是能够将单个 Python 类型与基于额外类型限定符的
    SQL 类型的不同变体相关联。其中一个典型的例子是将 Python `str` 数据类型映射到不同长度的 `VARCHAR` SQL 类型。另一个例子是将不同种类的
    `decimal.Decimal` 映射到不同大小的 `NUMERIC` 列。
- en: 'Python’s typing system provides a great way to add additional metadata to a
    Python type which is by using the [**PEP 593**](https://peps.python.org/pep-0593/)
    `Annotated` generic type, which allows additional information to be bundled along
    with a Python type. The [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct will correctly interpret an `Annotated`
    object by identity when resolving it in the [`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry"), as in the example below where we declare two variants
    of [`String`](../core/type_basics.html#sqlalchemy.types.String "sqlalchemy.types.String")
    and [`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric "sqlalchemy.types.Numeric"):'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: Python 的类型系统提供了一种很好的方法，可以为 Python 类型添加附加的元数据，即使用[**PEP 593**](https://peps.python.org/pep-0593/)
    `Annotated` 泛型类型，它允许将附加信息捆绑到 Python 类型上。[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") 构造将正确地解释 `Annotated` 对象的身份，当在[`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry")中解析它时，就像下面的示例中我们声明 [`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String") 和 [`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric
    "sqlalchemy.types.Numeric") 的两个变体一样：
- en: '[PRE113]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'The Python type passed to the `Annotated` container, in the above example the
    `str` and `Decimal` types, is important only for the benefit of typing tools;
    as far as the [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct is concerned, it will only need perform
    a lookup of each type object in the [`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry") dictionary without actually looking inside of the `Annotated`
    object, at least in this particular context. Similarly, the arguments passed to
    `Annotated` beyond the underlying Python type itself are also not important, it’s
    only that at least one argument must be present for the `Annotated` construct
    to be valid. We can then use these augmented types directly in our mapping where
    they will be matched to the more specific type constructions, as in the following
    example:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 传递给 `Annotated` 容器的 Python 类型，在上面的示例中是 `str` 和 `Decimal` 类型，仅对于类型工具而言是重要的；就
    [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    构造而言，它只需要在 [`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry") 字典中查找每个类型对象，而不实际查看 `Annotated` 对象的内部，至少在这种特定上下文中是如此。同样，传递给
    `Annotated` 的参数除了底层的 Python 类型本身之外也并不重要，只是至少必须存在一个参数才能使 `Annotated` 构造有效。然后我们可以直接在我们的映射中使用这些增强型类型，它们将与更具体的类型构造匹配，就像以下示例中一样：
- en: '[PRE114]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'a CREATE TABLE for the above mapping will illustrate the different variants
    of `VARCHAR` and `NUMERIC` we’ve configured, and looks like:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 上述映射的 CREATE TABLE 将演示我们配置的不同变体的 `VARCHAR` 和 `NUMERIC`，并且看起来如下：
- en: '[PRE115]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'While variety in linking `Annotated` types to different SQL types grants us
    a wide degree of flexibility, the next section illustrates a second way in which
    `Annotated` may be used with Declarative that is even more open ended.  #### Mapping
    Whole Column Declarations to Python Types'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `Annotated` 类型与不同的 SQL 类型进行链接的多样性赋予了我们广泛的灵活性，下一节将演示 `Annotated` 的第二种更加开放的用法。####
    将整个列声明映射到 Python 类型
- en: The previous section illustrated using [**PEP 593**](https://peps.python.org/pep-0593/)
    `Annotated` type instances as keys within the [`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry") dictionary. In this form, the [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct does not actually look inside the `Annotated`
    object itself, it’s instead used only as a dictionary key. However, Declarative
    also has the ability to extract an entire pre-established [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct from an `Annotated` object directly.
    Using this form, we can define not only different varieties of SQL datatypes linked
    to Python types without using the [`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry") dictionary, we can also set up any number of arguments
    such as nullability, column defaults, and constraints in a reusable fashion.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 前一节演示了使用 [**PEP 593**](https://peps.python.org/pep-0593/) `Annotated` 类型实例作为[`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry") 字典中的键。在这种形式中，[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") 构造实际上并不查看 `Annotated` 对象本身，它只被用作字典键。然而，Declarative
    还具有直接从 `Annotated` 对象中提取整个预先建立的 [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") 构造的能力。使用这种形式，我们不仅可以定义不同种类的 SQL 数据类型与 Python 类型的链接，而且可以以可重用的方式设置任意数量的参数，例如可为空性、列默认值和约束。
- en: A set of ORM models will usually have some kind of primary key style that is
    common to all mapped classes. There also may be common column configurations such
    as timestamps with defaults and other fields of pre-established sizes and configurations.
    We can compose these configurations into [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") instances that we then bundle directly into instances
    of `Annotated`, which are then re-used in any number of class declarations. Declarative
    will unpack an `Annotated` object when provided in this manner, skipping over
    any other directives that don’t apply to SQLAlchemy and searching only for SQLAlchemy
    ORM constructs.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 一组ORM模型通常会有一种对所有映射类都通用的主键样式。还可能有一些常见的列配置，例如带有默认值的时间戳和其他预先设定大小和配置的字段。我们可以将这些配置组合成[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")实例，然后直接捆绑到`Annotated`的实例中，然后在任意数量的类声明中重新使用它们。当以这种方式提供时，声明式将解开一个`Annotated`对象，跳过任何不适用于SQLAlchemy的其他指令，仅搜索SQLAlchemy
    ORM构造。
- en: 'The example below illustrates a variety of pre-configured field types used
    in this way, where we define `intpk` that represents an [`Integer`](../core/type_basics.html#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer") primary key column, `timestamp` that represents a
    [`DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime "sqlalchemy.types.DateTime")
    type which will use `CURRENT_TIMESTAMP` as a DDL level column default, and `required_name`
    which is a [`String`](../core/type_basics.html#sqlalchemy.types.String "sqlalchemy.types.String")
    of length 30 that’s `NOT NULL`:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的示例演示了以这种方式使用的各种预配置字段类型，我们在其中定义了`intpk`表示一个[`Integer`](../core/type_basics.html#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer")主键列，`timestamp`表示一个[`DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime
    "sqlalchemy.types.DateTime")类型，它将使用`CURRENT_TIMESTAMP`作为DDL级别列默认值，并且`required_name`是一个长度为30的[`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String")，`NOT NULL`：
- en: '[PRE116]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'The above `Annotated` objects can then be used directly within [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped"), where the pre-configured [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") constructs will be extracted and copied to a new
    instance that will be specific to each attribute:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 上述的`Annotated`对象然后可以直接在[`Mapped`](internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped")中使用，在那里预先配置的[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")构造将被提取并复制到一个新实例中，该实例将针对每个属性具体化：
- en: '[PRE117]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '`CREATE TABLE` for our above mapping looks like:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 我们上面映射的`CREATE TABLE`如下所示：
- en: '[PRE118]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'When using `Annotated` types in this way, the configuration of the type may
    also be affected on a per-attribute basis. For the types in the above example
    that feature explicit use of [`mapped_column.nullable`](mapping_api.html#sqlalchemy.orm.mapped_column.params.nullable
    "sqlalchemy.orm.mapped_column"), we can apply the `Optional[]` generic modifier
    to any of our types so that the field is optional or not at the Python level,
    which will be independent of the `NULL` / `NOT NULL` setting that takes place
    in the database:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 当以这种方式使用`Annotated`类型时，类型的配置也可能会受到每个属性的影响。对于上面示例中显式使用[`mapped_column.nullable`](mapping_api.html#sqlalchemy.orm.mapped_column.params.nullable
    "sqlalchemy.orm.mapped_column")的类型，我们可以将`Optional[]`泛型修饰符应用于我们的任何类型，以便该字段在Python级别上是可选的或非可选的，这将独立于数据库中发生的`NULL`
    / `NOT NULL`设置：
- en: '[PRE119]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'The [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    construct is also reconciled with an explicitly passed [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct, whose arguments will take precedence
    over those of the `Annotated` construct. Below we add a [`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey") constraint to our integer primary key and also
    use an alternate server default for the `created_at` column:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")构造也与显式传递的[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")构造协调，其参数将优先于`Annotated`构造的参数。下面我们向整数主键添加一个[`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey")约束，并为`created_at`列使用另一个替代的服务器默认值：'
- en: '[PRE120]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'The CREATE TABLE statement illustrates these per-attribute settings, adding
    a `FOREIGN KEY` constraint as well as substituting `UTC_TIMESTAMP` for `CURRENT_TIMESTAMP`:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '`CREATE TABLE`语句说明了这些每个属性的设置，还添加了一个`FOREIGN KEY`约束，并将`UTC_TIMESTAMP`替换为`CURRENT_TIMESTAMP`：'
- en: '[PRE121]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: Note
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The feature of [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") just described, where a fully constructed set
    of column arguments may be indicated using [**PEP 593**](https://peps.python.org/pep-0593/)
    `Annotated` objects that contain a “template” [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") object to be copied into the attribute, is currently
    not implemented for other ORM constructs such as [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") and [`composite()`](composites.html#sqlalchemy.orm.composite
    "sqlalchemy.orm.composite"). While this functionality is in theory possible, for
    the moment attempting to use `Annotated` to indicate further arguments for [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") and similar will raise a `NotImplementedError`
    exception at runtime, but may be implemented in future releases.  #### Using Python
    `Enum` or pep-586 `Literal` types in the type map'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '刚刚描述的[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")特性，可以使用[**PEP
    593**](https://peps.python.org/pep-0593/)中包含一个“模板”[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")对象的`Annotated`对象来指示一组完整构造的列参数，这些参数将被复制到属性中，目前还没有实现到其他ORM构造中，例如[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")和[`composite()`](composites.html#sqlalchemy.orm.composite
    "sqlalchemy.orm.composite")。虽然理论上可以实现这个功能，但当前尝试使用`Annotated`来指示对[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")和类似方法的更多参数将在运行时引发`NotImplementedError`异常，但可能在未来版本中实现。  ####
    在类型映射中使用Python `Enum`或pep-586 `Literal`类型'
- en: 'New in version 2.0.0b4: - Added `Enum` support'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 在2.0.0b4版本中新增：- 添加了`Enum`支持
- en: 'New in version 2.0.1: - Added `Literal` support'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 在2.0.1版本中新增：- 添加了`Literal`支持
- en: 'User-defined Python types which derive from the Python built-in `enum.Enum`
    as well as the `typing.Literal` class are automatically linked to the SQLAlchemy
    [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.types.Enum")
    datatype when used in an ORM declarative mapping. The example below uses a custom
    `enum.Enum` within the `Mapped[]` constructor:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 当在ORM声明式映射中使用时，从Python内置的`enum.Enum`以及`typing.Literal`类派生的用户定义的Python类型将自动链接到SQLAlchemy的[`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum")数据类型。下面的示例在`Mapped[]`构造函数中使用了自定义的`enum.Enum`：
- en: '[PRE122]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'In the above example, the mapped attribute `SomeClass.status` will be linked
    to a [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    with the datatype of `Enum(Status)`. We can see this for example in the CREATE
    TABLE output for the PostgreSQL database:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，映射属性`SomeClass.status`将链接到一个具有`Enum(Status)`数据类型的[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")。我们可以在PostgreSQL数据库的CREATE TABLE输出中看到这一点：
- en: '[PRE123]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'In a similar way, `typing.Literal` may be used instead, using a `typing.Literal`
    that consists of all strings:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，可以使用`typing.Literal`，使用一个由所有字符串组成的`typing.Literal`：
- en: '[PRE124]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'The entries used in [`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry") link the base `enum.Enum` Python type as well as the
    `typing.Literal` type to the SQLAlchemy [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum") SQL type, using a special form which indicates to the
    [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.types.Enum")
    datatype that it should automatically configure itself against an arbitrary enumerated
    type. This configuration, which is implicit by default, would be indicated explicitly
    as:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 在[`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry")中使用的条目将基本的`enum.Enum` Python类型以及`typing.Literal`类型链接到SQLAlchemy的[`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum") SQL类型，使用一种特殊形式，指示[`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum")数据类型应自动配置自己以适应任意枚举类型。这个默认情况下隐含的配置将明确表示为：
- en: '[PRE125]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: The resolution logic within Declarative is able to resolve subclasses of `enum.Enum`
    as well as instances of `typing.Literal` to match the `enum.Enum` or `typing.Literal`
    entry in the [`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry") dictionary. The [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum") SQL type then knows how to produce a configured version
    of itself with the appropriate settings, including default string length. If a
    `typing.Literal` that does not consist of only string values is passed, an informative
    error is raised.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明式中的解析逻辑能够解析 `enum.Enum` 的子类以及 `typing.Literal` 的实例，以匹配 [`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry") 字典中的 `enum.Enum` 或 `typing.Literal` 条目。然后，[`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum") SQL 类型知道如何生成一个带有适当设置的配置版本，包括默认字符串长度。如果传递的 `typing.Literal`
    不仅包含字符串值，则会引发一个信息性错误。
- en: Native Enums and Naming
  id: totrans-436
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 本地枚举和命名
- en: The [`Enum.native_enum`](../core/type_basics.html#sqlalchemy.types.Enum.params.native_enum
    "sqlalchemy.sql.sqltypes.Enum") parameter refers to if the [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.sql.sqltypes.Enum") datatype should create a so-called “native” enum,
    which on MySQL/MariaDB is the `ENUM` datatype and on PostgreSQL is a new `TYPE`
    object created by `CREATE TYPE`, or a “non-native” enum, which means that `VARCHAR`
    will be used to create the datatype. For backends other than MySQL/MariaDB or
    PostgreSQL, `VARCHAR` is used in all cases (third party dialects may have their
    own behaviors).
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Enum.native_enum`](../core/type_basics.html#sqlalchemy.types.Enum.params.native_enum
    "sqlalchemy.sql.sqltypes.Enum") 参数是指 [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.sql.sqltypes.Enum") 数据类型是否应创建所谓的“本地”枚举，在 MySQL/MariaDB 上是 `ENUM` 数据类型，在
    PostgreSQL 上是由 `CREATE TYPE` 创建的新 `TYPE` 对象，或者是“非本地”枚举，这意味着将使用 `VARCHAR` 来创建数据类型。对于除
    MySQL/MariaDB 或 PostgreSQL 外的后端，无论何种情况都使用 `VARCHAR`（第三方方言可能有其自己的行为）。'
- en: 'Because PostgreSQL’s `CREATE TYPE` requires that there’s an explicit name for
    the type to be created, special fallback logic exists when working with implicitly
    generated [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.sql.sqltypes.Enum")
    without specifying an explicit [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.sql.sqltypes.Enum") datatype within a mapping:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 PostgreSQL 的 `CREATE TYPE` 要求为要创建的类型有一个显式的名称，所以在处理隐式生成的 [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.sql.sqltypes.Enum") 而没有在映射中指定显式的 [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.sql.sqltypes.Enum") 数据类型时，存在特殊的回退逻辑：
- en: If the [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.sql.sqltypes.Enum")
    is linked to an `enum.Enum` object, the [`Enum.native_enum`](../core/type_basics.html#sqlalchemy.types.Enum.params.native_enum
    "sqlalchemy.sql.sqltypes.Enum") parameter defaults to `True` and the name of the
    enum will be taken from the name of the `enum.Enum` datatype. The PostgreSQL backend
    will assume `CREATE TYPE` with this name.
  id: totrans-439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.sql.sqltypes.Enum")
    被链接到一个 `enum.Enum` 对象，那么 [`Enum.native_enum`](../core/type_basics.html#sqlalchemy.types.Enum.params.native_enum
    "sqlalchemy.sql.sqltypes.Enum") 参数默认为 `True`，并且枚举的名称将从 `enum.Enum` 数据类型的名称中获取。在
    PostgreSQL 后端，将假定使用此名称创建 `CREATE TYPE`。
- en: If the [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.sql.sqltypes.Enum")
    is linked to a `typing.Literal` object, the [`Enum.native_enum`](../core/type_basics.html#sqlalchemy.types.Enum.params.native_enum
    "sqlalchemy.sql.sqltypes.Enum") parameter defaults to `False`; no name is generated
    and `VARCHAR` is assumed.
  id: totrans-440
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.sql.sqltypes.Enum")
    被链接到一个 `typing.Literal` 对象，则 [`Enum.native_enum`](../core/type_basics.html#sqlalchemy.types.Enum.params.native_enum
    "sqlalchemy.sql.sqltypes.Enum") 参数默认为 `False`；不生成名称，并假定为 `VARCHAR`。
- en: 'To use `typing.Literal` with a PostgreSQL `CREATE TYPE` type, an explicit [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.sql.sqltypes.Enum") must be used, either within the type map:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 PostgreSQL `CREATE TYPE` 类型中使用 `typing.Literal`，必须使用显式的 [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.sql.sqltypes.Enum")，可以在类型映射中使用：
- en: '[PRE126]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'Or alternatively within [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column"):'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 或者也可以在 [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    中使用：
- en: '[PRE127]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: Altering the Configuration of the Default Enum
  id: totrans-445
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 更改默认枚举的配置
- en: 'In order to modify the fixed configuration of the `Enum` datatype that’s generated
    implicitly, specify new entries in the [`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry"), indicating additional arguments. For example, to use
    “non native enumerations” unconditionally, the [`Enum.native_enum`](../core/type_basics.html#sqlalchemy.types.Enum.params.native_enum
    "sqlalchemy.types.Enum") parameter may be set to False for all types:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 要修改隐式生成的`Enum`数据类型的固定配置，需在[`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry")中指定新条目，表示额外的参数。例如，要无条件使用“非本地枚举”，可以为所有类型设置[`Enum.native_enum`](../core/type_basics.html#sqlalchemy.types.Enum.params.native_enum
    "sqlalchemy.types.Enum")参数为False：
- en: '[PRE128]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'Changed in version 2.0.1: Implemented support for overriding parameters such
    as [`Enum.native_enum`](../core/type_basics.html#sqlalchemy.types.Enum.params.native_enum
    "sqlalchemy.types.Enum") within the [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum") datatype when establishing the [`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry"). Previously, this functionality was not working.'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 在2.0.1版本中更改：实现了在建立[`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry")时覆盖参数（如[`Enum.native_enum`](../core/type_basics.html#sqlalchemy.types.Enum.params.native_enum
    "sqlalchemy.types.Enum")）的支持。先前，此功能不起作用。
- en: 'To use a specific configuration for a specific `enum.Enum` subtype, such as
    setting the string length to 50 when using the example `Status` datatype:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 要为特定的`enum.Enum`子类型使用特定配置，例如在使用示例`Status`数据类型时将字符串长度设置为50：
- en: '[PRE129]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'By default [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.types.Enum")
    that are automatically generated are not associated with the `MetaData` instance
    used by the `Base`, so if the metadata defines a schema it will not be automatically
    associated with the enum. To automatically associate the enum with the schema
    in the metadata or table they belong to the [`Enum.inherit_schema`](../core/type_basics.html#sqlalchemy.types.Enum.params.inherit_schema
    "sqlalchemy.types.Enum") can be set:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，自动生成的[`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.types.Enum")不与`Base`使用的`MetaData`实例关联，因此如果元数据定义了模式，它将不会自动与枚举关联。要自动将枚举与元数据中的模式或表关联起来，可以设置[`Enum.inherit_schema`](../core/type_basics.html#sqlalchemy.types.Enum.params.inherit_schema
    "sqlalchemy.types.Enum")：
- en: '[PRE130]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: Linking Specific `enum.Enum` or `typing.Literal` to other datatypes
  id: totrans-453
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 将特定的`enum.Enum`或`typing.Literal`链接到其他数据类型
- en: 'The above examples feature the use of an [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum") that is automatically configuring itself to the arguments
    / attributes present on an `enum.Enum` or `typing.Literal` type object. For use
    cases where specific kinds of `enum.Enum` or `typing.Literal` should be linked
    to other types, these specific types may be placed in the type map also. In the
    example below, an entry for `Literal[]` that contains non-string types is linked
    to the [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON")
    datatype:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例展示了一个自动配置自身到`enum.Enum`或`typing.Literal`类型对象上存在的参数/属性的[`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum")的使用。对于特定种类的`enum.Enum`或`typing.Literal`应链接到其他类型的用例，这些特定类型也可以放置在类型映射中。在下面的示例中，一个包含非字符串类型的`Literal[]`条目链接到[`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON")数据类型：
- en: '[PRE131]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: In the above configuration, the `my_literal` datatype will resolve to a [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON") instance. Other `Literal` variants will continue to resolve
    to [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.types.Enum")
    datatypes.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述配置中，`my_literal`数据类型将解析为一个[`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON")实例。其他`Literal`变体将继续解析为[`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum")数据类型。
- en: Dataclass features in `mapped_column()`
  id: totrans-457
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`mapped_column()`中的数据类特性'
- en: The [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    construct integrates with SQLAlchemy’s “native dataclasses” feature, discussed
    at [Declarative Dataclass Mapping](dataclasses.html#orm-declarative-native-dataclasses).
    See that section for current background on additional directives supported by
    [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column").
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: '[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    构造与 SQLAlchemy 的“原生数据类”功能集成，详见 [声明性数据类映射](dataclasses.html#orm-declarative-native-dataclasses)。请参阅该部分了解
    [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    支持的额外指令的当前背景。'
- en: '#### `mapped_column()` derives the datatype and nullability from the `Mapped`
    annotation'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: '#### `mapped_column()` 从 `Mapped` 注释中派生数据类型和可空性'
- en: 'The two qualities that [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") derives from the [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") annotation are:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: '[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    从 [`Mapped`](internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped") 注释中派生的两个特性是：'
- en: '**datatype** - the Python type given inside [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped"), as contained within the `typing.Optional` construct
    if present, is associated with a [`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") subclass such as [`Integer`](../core/type_basics.html#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer"), [`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String"), [`DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime
    "sqlalchemy.types.DateTime"), or [`Uuid`](../core/type_basics.html#sqlalchemy.types.Uuid
    "sqlalchemy.types.Uuid"), to name a few common types.'
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据类型** - 在 [`Mapped`](internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped")
    中给出的 Python 类型，如果存在，则与 [`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") 的子类关联，例如 [`Integer`](../core/type_basics.html#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer")、[`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String")、[`DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime
    "sqlalchemy.types.DateTime") 或 [`Uuid`](../core/type_basics.html#sqlalchemy.types.Uuid
    "sqlalchemy.types.Uuid") 等常见类型。'
- en: 'The datatype is determined based on a dictionary of Python type to SQLAlchemy
    datatype. This dictionary is completely customizable, as detailed in the next
    section [Customizing the Type Map](#orm-declarative-mapped-column-type-map). The
    default type map is implemented as in the code example below:'
  id: totrans-462
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 数据类型是基于 Python 类型到 SQLAlchemy 数据类型的字典确定的。这个字典是完全可定制的，如下一节 [自定义类型映射](#orm-declarative-mapped-column-type-map)
    中所述。默认的类型映射实现如下面的代码示例所示：
- en: '[PRE132]'
  id: totrans-463
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE132]'
- en: If the [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    construct indicates an explicit type as passed to the [`mapped_column.__type`](mapping_api.html#sqlalchemy.orm.mapped_column.params.__type
    "sqlalchemy.orm.mapped_column") argument, then the given Python type is disregarded.
  id: totrans-464
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果 [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    构造指示明确的类型，如传递给 [`mapped_column.__type`](mapping_api.html#sqlalchemy.orm.mapped_column.params.__type
    "sqlalchemy.orm.mapped_column") 参数，则给定的 Python 类型将被忽略。
- en: '**nullability** - The [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct will indicate its [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") as `NULL` or `NOT NULL` first and foremost by the
    presence of the [`mapped_column.nullable`](mapping_api.html#sqlalchemy.orm.mapped_column.params.nullable
    "sqlalchemy.orm.mapped_column") parameter, passed either as `True` or `False`.
    Additionally , if the [`mapped_column.primary_key`](mapping_api.html#sqlalchemy.orm.mapped_column.params.primary_key
    "sqlalchemy.orm.mapped_column") parameter is present and set to `True`, that will
    also imply that the column should be `NOT NULL`.'
  id: totrans-465
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可空性** - [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") 构造将通过 [`mapped_column.nullable`](mapping_api.html#sqlalchemy.orm.mapped_column.params.nullable
    "sqlalchemy.orm.mapped_column") 参数的存在来首先指示其 [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") 为 `NULL` 或 `NOT NULL`，该参数传递为 `True` 或 `False`。此外，如果
    [`mapped_column.primary_key`](mapping_api.html#sqlalchemy.orm.mapped_column.params.primary_key
    "sqlalchemy.orm.mapped_column") 参数存在并设置为 `True`，那么也会暗示该列应该是 `NOT NULL`。'
- en: In the absence of **both** of these parameters, the presence of `typing.Optional[]`
    within the [`Mapped`](internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped")
    type annotation will be used to determine nullability, where `typing.Optional[]`
    means `NULL`, and the absence of `typing.Optional[]` means `NOT NULL`. If there
    is no `Mapped[]` annotation present at all, and there is no [`mapped_column.nullable`](mapping_api.html#sqlalchemy.orm.mapped_column.params.nullable
    "sqlalchemy.orm.mapped_column") or [`mapped_column.primary_key`](mapping_api.html#sqlalchemy.orm.mapped_column.params.primary_key
    "sqlalchemy.orm.mapped_column") parameter, then SQLAlchemy’s usual default for
    [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    of `NULL` is used.
  id: totrans-466
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在**这两个**参数都不存在的情况下，[`Mapped`](internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped")类型注释中的`typing.Optional[]`的存在将用于确定空值性，其中`typing.Optional[]`表示`NULL`，而`typing.Optional[]`的缺失表示`NOT
    NULL`。如果根本没有`Mapped[]`注释存在，并且没有[`mapped_column.nullable`](mapping_api.html#sqlalchemy.orm.mapped_column.params.nullable
    "sqlalchemy.orm.mapped_column")或[`mapped_column.primary_key`](mapping_api.html#sqlalchemy.orm.mapped_column.params.primary_key
    "sqlalchemy.orm.mapped_column")参数，则SQLAlchemy对于`Column`的通常默认值为`NULL`。
- en: 'In the example below, the `id` and `data` columns will be `NOT NULL`, and the
    `additional_info` column will be `NULL`:'
  id: totrans-467
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在下面的示例中，`id`和`data`列将是`NOT NULL`，而`additional_info`列将是`NULL`：
- en: '[PRE133]'
  id: totrans-468
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'It is also perfectly valid to have a [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") whose nullability is **different** from what would
    be implied by the annotation. For example, an ORM mapped attribute may be annotated
    as allowing `None` within Python code that works with the object as it is first
    being created and populated, however the value will ultimately be written to a
    database column that is `NOT NULL`. The [`mapped_column.nullable`](mapping_api.html#sqlalchemy.orm.mapped_column.params.nullable
    "sqlalchemy.orm.mapped_column") parameter, when present, will always take precedence:'
  id: totrans-469
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 具有[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")的空值属性与注释所暗示的**不同**是完全有效的。例如，一个ORM映射的属性可能在Python代码中被注释为允许`None`，这段代码在对象首次创建和填充时使用，然而最终该值将被写入一个`NOT
    NULL`的数据库列。当存在[`mapped_column.nullable`](mapping_api.html#sqlalchemy.orm.mapped_column.params.nullable
    "sqlalchemy.orm.mapped_column")参数时，该参数将始终优先考虑：
- en: '[PRE134]'
  id: totrans-470
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'Similarly, a non-None attribute that’s written to a database column that for
    whatever reason needs to be NULL at the schema level, [`mapped_column.nullable`](mapping_api.html#sqlalchemy.orm.mapped_column.params.nullable
    "sqlalchemy.orm.mapped_column") may be set to `True`:'
  id: totrans-471
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 同样，一个非空属性写入到一个数据库列，由于某种原因需要在模式级别为NULL，[`mapped_column.nullable`](mapping_api.html#sqlalchemy.orm.mapped_column.params.nullable
    "sqlalchemy.orm.mapped_column")可以设置为`True`：
- en: '[PRE135]'
  id: totrans-472
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '#### Customizing the Type Map'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 自定义类型映射'
- en: The mapping of Python types to SQLAlchemy [`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") types described in the previous section defaults
    to a hardcoded dictionary present in the `sqlalchemy.sql.sqltypes` module. However,
    the [`registry`](mapping_api.html#sqlalchemy.orm.registry "sqlalchemy.orm.registry")
    object that coordinates the Declarative mapping process will first consult a local,
    user defined dictionary of types which may be passed as the [`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry") parameter when constructing the [`registry`](mapping_api.html#sqlalchemy.orm.registry
    "sqlalchemy.orm.registry"), which may be associated with the [`DeclarativeBase`](mapping_api.html#sqlalchemy.orm.DeclarativeBase
    "sqlalchemy.orm.DeclarativeBase") superclass when first used.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: Python类型到SQLAlchemy [`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine")类型的映射在前一节中描述的默认为`sqlalchemy.sql.sqltypes`模块中的硬编码字典。然而，协调Declarative映射过程的[`registry`](mapping_api.html#sqlalchemy.orm.registry
    "sqlalchemy.orm.registry")对象将首先查阅一个本地的、用户定义的类型字典，该字典可以在构建[`registry`](mapping_api.html#sqlalchemy.orm.registry
    "sqlalchemy.orm.registry")时作为[`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry")参数传递，当首次使用时可能与[`DeclarativeBase`](mapping_api.html#sqlalchemy.orm.DeclarativeBase
    "sqlalchemy.orm.DeclarativeBase")超类相关联。
- en: 'As an example, if we wish to make use of the [`BIGINT`](../core/type_basics.html#sqlalchemy.types.BIGINT
    "sqlalchemy.types.BIGINT") datatype for `int`, the [`TIMESTAMP`](../core/type_basics.html#sqlalchemy.types.TIMESTAMP
    "sqlalchemy.types.TIMESTAMP") datatype with `timezone=True` for `datetime.datetime`,
    and then only on Microsoft SQL Server we’d like to use [`NVARCHAR`](../core/type_basics.html#sqlalchemy.types.NVARCHAR
    "sqlalchemy.types.NVARCHAR") datatype when Python `str` is used, the registry
    and Declarative base could be configured as:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 举例来说，如果我们希望使用[`BIGINT`](../core/type_basics.html#sqlalchemy.types.BIGINT "sqlalchemy.types.BIGINT")数据类型来表示`int`，使用带有`timezone=True`的[`TIMESTAMP`](../core/type_basics.html#sqlalchemy.types.TIMESTAMP
    "sqlalchemy.types.TIMESTAMP")数据类型来表示`datetime.datetime`，然后仅在Microsoft SQL Server上使用[`NVARCHAR`](../core/type_basics.html#sqlalchemy.types.NVARCHAR
    "sqlalchemy.types.NVARCHAR")数据类型来表示Python的`str`，则可以配置注册表和Declarative基类如下：
- en: '[PRE136]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'Below illustrates the CREATE TABLE statement generated for the above mapping,
    first on the Microsoft SQL Server backend, illustrating the `NVARCHAR` datatype:'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 下面展示了为上述映射生成的CREATE TABLE语句，在Microsoft SQL Server后端首先展示了`NVARCHAR`数据类型：
- en: '[PRE137]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'Then on the PostgreSQL backend, illustrating `TIMESTAMP WITH TIME ZONE`:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在PostgreSQL后端，展示了`TIMESTAMP WITH TIME ZONE`：
- en: '[PRE138]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: By making use of methods such as [`TypeEngine.with_variant()`](../core/type_api.html#sqlalchemy.types.TypeEngine.with_variant
    "sqlalchemy.types.TypeEngine.with_variant"), we’re able to build up a type map
    that’s customized to what we need for different backends, while still being able
    to use succinct annotation-only [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") configurations. There are two more levels of Python-type
    configurability available beyond this, described in the next two sections.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用诸如[`TypeEngine.with_variant()`](../core/type_api.html#sqlalchemy.types.TypeEngine.with_variant
    "sqlalchemy.types.TypeEngine.with_variant")之类的方法，我们能够构建一个针对不同后端定制的类型映射，同时仍然能够使用简洁的仅注释的[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")配置。在此之上还有两个级别的Python类型可配置性，将在接下来的两个部分中描述。
- en: '#### Mapping Multiple Type Configurations to Python Types'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 将多种类型配置映射到Python类型'
- en: As individual Python types may be associated with [`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") configurations of any variety by using the [`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry") parameter, an additional capability is the ability
    to associate a single Python type with different variants of a SQL type based
    on additional type qualifiers. One typical example of this is mapping the Python
    `str` datatype to `VARCHAR` SQL types of different lengths. Another is mapping
    different varieties of `decimal.Decimal` to differently sized `NUMERIC` columns.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 由于个别Python类型可以通过使用[`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine")配置的任何类型与[`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry")参数相关联，另一个功能是能够将单个Python类型与基于附加类型限定符的SQL类型的不同变体关联起来。一个典型的例子是将Python的`str`数据类型映射到不同长度的`VARCHAR`
    SQL类型。另一个是将不同种类的`decimal.Decimal`映射到不同大小的`NUMERIC`列。
- en: 'Python’s typing system provides a great way to add additional metadata to a
    Python type which is by using the [**PEP 593**](https://peps.python.org/pep-0593/)
    `Annotated` generic type, which allows additional information to be bundled along
    with a Python type. The [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct will correctly interpret an `Annotated`
    object by identity when resolving it in the [`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry"), as in the example below where we declare two variants
    of [`String`](../core/type_basics.html#sqlalchemy.types.String "sqlalchemy.types.String")
    and [`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric "sqlalchemy.types.Numeric"):'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: Python的类型系统提供了一种很好的方式来为Python类型添加额外的元数据，即使用[**PEP 593**](https://peps.python.org/pep-0593/)
    `Annotated`泛型类型，它允许将附加信息与Python类型捆绑在一起。[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")构造将正确解释`Annotated`对象的身份，当在[`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry")中解析它时，就像下面的示例中声明两个[`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String")和[`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric
    "sqlalchemy.types.Numeric")变体一样：
- en: '[PRE139]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'The Python type passed to the `Annotated` container, in the above example the
    `str` and `Decimal` types, is important only for the benefit of typing tools;
    as far as the [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct is concerned, it will only need perform
    a lookup of each type object in the [`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry") dictionary without actually looking inside of the `Annotated`
    object, at least in this particular context. Similarly, the arguments passed to
    `Annotated` beyond the underlying Python type itself are also not important, it’s
    only that at least one argument must be present for the `Annotated` construct
    to be valid. We can then use these augmented types directly in our mapping where
    they will be matched to the more specific type constructions, as in the following
    example:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述示例中传递给`Annotated`容器的Python类型，例如`str`和`Decimal`类型，仅对于类型工具的好处是重要的；就[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")构造而言，在这个特定的上下文中，它只需要在[`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry")字典中查找每个类型对象，而不实际查看`Annotated`对象的内部。类似地，传递给`Annotated`的参数超出底层Python类型本身也不重要，只是必须至少存在一个参数，以使`Annotated`构造有效。然后，我们可以直接在我们的映射中使用这些增强类型，它们将与更具体的类型构造相匹配，就像以下示例中一样：
- en: '[PRE140]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'a CREATE TABLE for the above mapping will illustrate the different variants
    of `VARCHAR` and `NUMERIC` we’ve configured, and looks like:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 上述映射的CREATE TABLE将说明我们配置的不同变体的`VARCHAR`和`NUMERIC`，并且看起来像是：
- en: '[PRE141]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: While variety in linking `Annotated` types to different SQL types grants us
    a wide degree of flexibility, the next section illustrates a second way in which
    `Annotated` may be used with Declarative that is even more open ended.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然将`Annotated`类型与不同的SQL类型链接的多样性为我们提供了广泛的灵活性，但下一节说明了一种使用`Annotated`与Declarative结合使用的第二种更加开放的方式。
- en: '#### Mapping Whole Column Declarations to Python Types'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 将整个列声明映射到Python类型'
- en: The previous section illustrated using [**PEP 593**](https://peps.python.org/pep-0593/)
    `Annotated` type instances as keys within the [`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry") dictionary. In this form, the [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct does not actually look inside the `Annotated`
    object itself, it’s instead used only as a dictionary key. However, Declarative
    also has the ability to extract an entire pre-established [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct from an `Annotated` object directly.
    Using this form, we can define not only different varieties of SQL datatypes linked
    to Python types without using the [`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry") dictionary, we can also set up any number of arguments
    such as nullability, column defaults, and constraints in a reusable fashion.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的章节说明了使用[**PEP 593**](https://peps.python.org/pep-0593/) `Annotated`类型实例作为[`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry")字典中的键。在这种形式中，[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")构造实际上并不查看`Annotated`对象本身，而是仅用作字典键。然而，Declarative还具有直接从`Annotated`对象中提取整个预先建立的[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")构造的能力。使用这种形式，我们不仅可以定义与Python类型相关联的不同种类的SQL数据类型，而且还可以以可重用的方式设置任意数量的参数，例如可为空性、列默认值和约束。
- en: A set of ORM models will usually have some kind of primary key style that is
    common to all mapped classes. There also may be common column configurations such
    as timestamps with defaults and other fields of pre-established sizes and configurations.
    We can compose these configurations into [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") instances that we then bundle directly into instances
    of `Annotated`, which are then re-used in any number of class declarations. Declarative
    will unpack an `Annotated` object when provided in this manner, skipping over
    any other directives that don’t apply to SQLAlchemy and searching only for SQLAlchemy
    ORM constructs.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 一组ORM模型通常会有一种对所有映射类都通用的主键样式。还可能有常见的列配置，例如具有默认值的时间戳和其他预先确定大小和配置的字段。我们可以将这些配置组合成[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")实例，然后直接捆绑到`Annotated`的实例中，然后在任意数量的类声明中重复使用。当以这种方式提供时，声明性将解开`Annotated`对象，跳过任何不适用于SQLAlchemy的其他指令，并仅搜索SQLAlchemy
    ORM构造。
- en: 'The example below illustrates a variety of pre-configured field types used
    in this way, where we define `intpk` that represents an [`Integer`](../core/type_basics.html#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer") primary key column, `timestamp` that represents a
    [`DateTime`](../core/type_basics.html#sqlalchemy.types.DateTime "sqlalchemy.types.DateTime")
    type which will use `CURRENT_TIMESTAMP` as a DDL level column default, and `required_name`
    which is a [`String`](../core/type_basics.html#sqlalchemy.types.String "sqlalchemy.types.String")
    of length 30 that’s `NOT NULL`:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的示例说明了以这种方式使用的各种预配置字段类型，其中我们定义了`intpk`代表一个[`整型`](../core/type_basics.html#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer")主键列，`timestamp`代表一个[`日期时间`](../core/type_basics.html#sqlalchemy.types.DateTime
    "sqlalchemy.types.DateTime")类型，它将使用`CURRENT_TIMESTAMP`作为DDL级别的列默认值，并且`required_name`是一个长度为30的[`字符串`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String")，它是`NOT NULL`的：
- en: '[PRE142]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'The above `Annotated` objects can then be used directly within [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped"), where the pre-configured [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") constructs will be extracted and copied to a new
    instance that will be specific to each attribute:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 上述的`Annotated`对象然后可以直接在[`Mapped`](internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped")中使用，预配置的[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")构造将被提取并复制到一个新实例中，该实例将针对每个属性具体：
- en: '[PRE143]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '`CREATE TABLE` for our above mapping looks like:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 我们上面的映射的`CREATE TABLE`如下所示：
- en: '[PRE144]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'When using `Annotated` types in this way, the configuration of the type may
    also be affected on a per-attribute basis. For the types in the above example
    that feature explicit use of [`mapped_column.nullable`](mapping_api.html#sqlalchemy.orm.mapped_column.params.nullable
    "sqlalchemy.orm.mapped_column"), we can apply the `Optional[]` generic modifier
    to any of our types so that the field is optional or not at the Python level,
    which will be independent of the `NULL` / `NOT NULL` setting that takes place
    in the database:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 当以这种方式使用`Annotated`类型时，类型的配置也可能会受到每个属性基础的影响。对于上面示例中显式使用了[`mapped_column.nullable`](mapping_api.html#sqlalchemy.orm.mapped_column.params.nullable
    "sqlalchemy.orm.mapped_column")的类型，我们可以对我们的任何类型应用`Optional[]`泛型修饰符，以便在Python级别该字段是可选的还是不可选的，这将独立于数据库中发生的`NULL`
    / `NOT NULL`设置：
- en: '[PRE145]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'The [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    construct is also reconciled with an explicitly passed [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct, whose arguments will take precedence
    over those of the `Annotated` construct. Below we add a [`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey") constraint to our integer primary key and also
    use an alternate server default for the `created_at` column:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: '[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")构造还与显式传递的[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")构造协调一致，其参数将优先于`Annotated`构造的参数。下面我们向我们的整型主键添加了一个[`外键`](../core/constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey")约束，并且还为`created_at`列使用了备用服务器默认值：'
- en: '[PRE146]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'The CREATE TABLE statement illustrates these per-attribute settings, adding
    a `FOREIGN KEY` constraint as well as substituting `UTC_TIMESTAMP` for `CURRENT_TIMESTAMP`:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: '`CREATE TABLE`语句说明了这些每个属性的设置，添加了`FOREIGN KEY`约束，并且将`UTC_TIMESTAMP`替换为`CURRENT_TIMESTAMP`：'
- en: '[PRE147]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: Note
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The feature of [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") just described, where a fully constructed set
    of column arguments may be indicated using [**PEP 593**](https://peps.python.org/pep-0593/)
    `Annotated` objects that contain a “template” [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") object to be copied into the attribute, is currently
    not implemented for other ORM constructs such as [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") and [`composite()`](composites.html#sqlalchemy.orm.composite
    "sqlalchemy.orm.composite"). While this functionality is in theory possible, for
    the moment attempting to use `Annotated` to indicate further arguments for [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") and similar will raise a `NotImplementedError`
    exception at runtime, but may be implemented in future releases.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 刚刚描述的 [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    特性，其中可以使用 [**PEP 593**](https://peps.python.org/pep-0593/) `Annotated` 对象指示一组完全构造的列参数，这些列参数包含一个“模板”
    [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    对象，将被复制到属性中，目前尚未实现为其他 ORM 构造（如 [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") 和 [`composite()`](composites.html#sqlalchemy.orm.composite
    "sqlalchemy.orm.composite")）。虽然理论上可能存在这种功能，但目前尝试使用 `Annotated` 来指示 [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") 等的进一步参数将在运行时引发 `NotImplementedError` 异常，但可能会在将来的版本中实现。
- en: '#### Using Python `Enum` or pep-586 `Literal` types in the type map'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 在类型映射中使用 Python `Enum` 或 pep-586 `Literal` 类型'
- en: 'New in version 2.0.0b4: - Added `Enum` support'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 新版本 2.0.0b4 中新增：- 添加了 `Enum` 支持
- en: 'New in version 2.0.1: - Added `Literal` support'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 新版本 2.0.1 中新增：- 添加了 `Literal` 支持
- en: 'User-defined Python types which derive from the Python built-in `enum.Enum`
    as well as the `typing.Literal` class are automatically linked to the SQLAlchemy
    [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.types.Enum")
    datatype when used in an ORM declarative mapping. The example below uses a custom
    `enum.Enum` within the `Mapped[]` constructor:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 当在 ORM 声明性映射中使用用户定义的 Python 类型时，这些类型派生自 Python 内置的 `enum.Enum` 类以及 `typing.Literal`
    类时，它们会自动链接到 SQLAlchemy [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum") 数据类型。下面的示例在 `Mapped[]` 构造函数中使用了自定义的 `enum.Enum`：
- en: '[PRE148]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'In the above example, the mapped attribute `SomeClass.status` will be linked
    to a [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    with the datatype of `Enum(Status)`. We can see this for example in the CREATE
    TABLE output for the PostgreSQL database:'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，映射的属性 `SomeClass.status` 将链接到一个 [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")，其数据类型为 `Enum(Status)`。我们可以在 PostgreSQL 数据库的 CREATE
    TABLE 输出中看到这一点：
- en: '[PRE149]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'In a similar way, `typing.Literal` may be used instead, using a `typing.Literal`
    that consists of all strings:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，也可以使用 `typing.Literal`，使用包含所有字符串的 `typing.Literal`：
- en: '[PRE150]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'The entries used in [`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry") link the base `enum.Enum` Python type as well as the
    `typing.Literal` type to the SQLAlchemy [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum") SQL type, using a special form which indicates to the
    [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.types.Enum")
    datatype that it should automatically configure itself against an arbitrary enumerated
    type. This configuration, which is implicit by default, would be indicated explicitly
    as:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry") 中使用的条目将基本的 `enum.Enum` Python 类型以及 `typing.Literal`
    类型链接到 SQLAlchemy [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.types.Enum")
    SQL 类型，使用特殊形式来指示 [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.types.Enum")
    数据类型应自动配置自己以针对任意枚举类型。默认情况下，此配置是隐式的，但可以显式指示为：
- en: '[PRE151]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: The resolution logic within Declarative is able to resolve subclasses of `enum.Enum`
    as well as instances of `typing.Literal` to match the `enum.Enum` or `typing.Literal`
    entry in the [`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry") dictionary. The [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum") SQL type then knows how to produce a configured version
    of itself with the appropriate settings, including default string length. If a
    `typing.Literal` that does not consist of only string values is passed, an informative
    error is raised.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Declarative 内部的解析逻辑能够解析`enum.Enum`的子类以及`typing.Literal`的实例，以匹配[`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry")字典中的`enum.Enum`或`typing.Literal`条目。然后，[`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum") SQL类型知道如何生成具有适当设置的已配置版本，包括默认字符串长度。如果传递的`typing.Literal`不仅由字符串值组成，则会引发信息性错误。
- en: Native Enums and Naming
  id: totrans-520
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 本地枚举和命名
- en: The [`Enum.native_enum`](../core/type_basics.html#sqlalchemy.types.Enum.params.native_enum
    "sqlalchemy.sql.sqltypes.Enum") parameter refers to if the [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.sql.sqltypes.Enum") datatype should create a so-called “native” enum,
    which on MySQL/MariaDB is the `ENUM` datatype and on PostgreSQL is a new `TYPE`
    object created by `CREATE TYPE`, or a “non-native” enum, which means that `VARCHAR`
    will be used to create the datatype. For backends other than MySQL/MariaDB or
    PostgreSQL, `VARCHAR` is used in all cases (third party dialects may have their
    own behaviors).
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Enum.native_enum`](../core/type_basics.html#sqlalchemy.types.Enum.params.native_enum
    "sqlalchemy.sql.sqltypes.Enum")参数是指[`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.sql.sqltypes.Enum")数据类型是否应创建所谓的“本地”枚举，在 MySQL/MariaDB 上是`ENUM`数据类型，在
    PostgreSQL 上是通过`CREATE TYPE`创建的新`TYPE`对象，或者是“非本地”枚举，这意味着将使用`VARCHAR`创建数据类型。对于
    MySQL/MariaDB 或 PostgreSQL 以外的后端，在所有情况下都使用`VARCHAR`（第三方方言可能具有自己的行为）。'
- en: 'Because PostgreSQL’s `CREATE TYPE` requires that there’s an explicit name for
    the type to be created, special fallback logic exists when working with implicitly
    generated [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.sql.sqltypes.Enum")
    without specifying an explicit [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.sql.sqltypes.Enum") datatype within a mapping:'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 PostgreSQL 的`CREATE TYPE`要求为要创建的类型指定显式名称，所以在处理未显式指定显式[`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.sql.sqltypes.Enum")数据类型的情况下，特殊的后备逻辑存在于隐式生成的[`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.sql.sqltypes.Enum")时：
- en: If the [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.sql.sqltypes.Enum")
    is linked to an `enum.Enum` object, the [`Enum.native_enum`](../core/type_basics.html#sqlalchemy.types.Enum.params.native_enum
    "sqlalchemy.sql.sqltypes.Enum") parameter defaults to `True` and the name of the
    enum will be taken from the name of the `enum.Enum` datatype. The PostgreSQL backend
    will assume `CREATE TYPE` with this name.
  id: totrans-523
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果[`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.sql.sqltypes.Enum")链接到一个`enum.Enum`对象，则[`Enum.native_enum`](../core/type_basics.html#sqlalchemy.types.Enum.params.native_enum
    "sqlalchemy.sql.sqltypes.Enum")参数默认为`True`，并且枚举的名称将取自`enum.Enum`数据类型的名称。 PostgreSQL后端将假定使用此名称创建`CREATE
    TYPE`。
- en: If the [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.sql.sqltypes.Enum")
    is linked to a `typing.Literal` object, the [`Enum.native_enum`](../core/type_basics.html#sqlalchemy.types.Enum.params.native_enum
    "sqlalchemy.sql.sqltypes.Enum") parameter defaults to `False`; no name is generated
    and `VARCHAR` is assumed.
  id: totrans-524
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果[`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.sql.sqltypes.Enum")链接到一个`typing.Literal`对象，则[`Enum.native_enum`](../core/type_basics.html#sqlalchemy.types.Enum.params.native_enum
    "sqlalchemy.sql.sqltypes.Enum")参数默认为`False`；不会生成名称，并且假定为`VARCHAR`。
- en: 'To use `typing.Literal` with a PostgreSQL `CREATE TYPE` type, an explicit [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.sql.sqltypes.Enum") must be used, either within the type map:'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 PostgreSQL 的`CREATE TYPE`类型中使用`typing.Literal`，必须使用显式的[`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.sql.sqltypes.Enum")，要么在类型映射中：
- en: '[PRE152]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'Or alternatively within [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column"):'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 或者在 [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    内部：
- en: '[PRE153]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: Altering the Configuration of the Default Enum
  id: totrans-529
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 修改默认枚举的配置
- en: 'In order to modify the fixed configuration of the `Enum` datatype that’s generated
    implicitly, specify new entries in the [`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry"), indicating additional arguments. For example, to use
    “non native enumerations” unconditionally, the [`Enum.native_enum`](../core/type_basics.html#sqlalchemy.types.Enum.params.native_enum
    "sqlalchemy.types.Enum") parameter may be set to False for all types:'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 为了修改隐式生成的`Enum`数据类型的固定配置，指定在[`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry")中添加新条目，表示额外参数。例如，要无条件使用“非原生枚举”，可以为所有类型设置[`Enum.native_enum`](../core/type_basics.html#sqlalchemy.types.Enum.params.native_enum
    "sqlalchemy.types.Enum")参数为False：
- en: '[PRE154]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: 'Changed in version 2.0.1: Implemented support for overriding parameters such
    as [`Enum.native_enum`](../core/type_basics.html#sqlalchemy.types.Enum.params.native_enum
    "sqlalchemy.types.Enum") within the [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum") datatype when establishing the [`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry"). Previously, this functionality was not working.'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 从2.0.1版本开始更改：实现了在建立[`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry")时覆盖参数的支持，例如[`Enum.native_enum`](../core/type_basics.html#sqlalchemy.types.Enum.params.native_enum
    "sqlalchemy.types.Enum")参数。以前，此功能未能正常工作。
- en: 'To use a specific configuration for a specific `enum.Enum` subtype, such as
    setting the string length to 50 when using the example `Status` datatype:'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 要为特定的`enum.Enum`子类型使用特定的配置，例如在使用示例`Status`数据类型时将字符串长度设置为50：
- en: '[PRE155]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: 'By default [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.types.Enum")
    that are automatically generated are not associated with the `MetaData` instance
    used by the `Base`, so if the metadata defines a schema it will not be automatically
    associated with the enum. To automatically associate the enum with the schema
    in the metadata or table they belong to the [`Enum.inherit_schema`](../core/type_basics.html#sqlalchemy.types.Enum.params.inherit_schema
    "sqlalchemy.types.Enum") can be set:'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，自动生成的[`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.types.Enum")不与由`Base`使用的`MetaData`实例关联，因此，如果元数据定义了模式，它将不会自动与枚举关联。要将枚举自动与元数据或表中的模式关联起来，可以设置[`Enum.inherit_schema`](../core/type_basics.html#sqlalchemy.types.Enum.params.inherit_schema
    "sqlalchemy.types.Enum")：
- en: '[PRE156]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: Linking Specific `enum.Enum` or `typing.Literal` to other datatypes
  id: totrans-537
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 将特定的`enum.Enum`或`typing.Literal`链接到其他数据类型
- en: 'The above examples feature the use of an [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum") that is automatically configuring itself to the arguments
    / attributes present on an `enum.Enum` or `typing.Literal` type object. For use
    cases where specific kinds of `enum.Enum` or `typing.Literal` should be linked
    to other types, these specific types may be placed in the type map also. In the
    example below, an entry for `Literal[]` that contains non-string types is linked
    to the [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON")
    datatype:'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 以上示例展示了一个[`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.types.Enum")自动配置自身到一个`enum.Enum`或`typing.Literal`类型对象上存在的参数/属性的情况。对于应用场景，特定类型的`enum.Enum`或`typing.Literal`应链接到其他类型的情况，这些特定类型也可以放置在类型映射中。在下面的示例中，一个包含非字符串类型的`Literal[]`条目被链接到[`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON")数据类型：
- en: '[PRE157]'
  id: totrans-539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: In the above configuration, the `my_literal` datatype will resolve to a [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON") instance. Other `Literal` variants will continue to resolve
    to [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.types.Enum")
    datatypes.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述配置中，`my_literal`数据类型将解析为一个[`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON")实例。其他`Literal`变体将继续解析为[`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum")数据类型。
- en: Native Enums and Naming
  id: totrans-541
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 原生枚举和命名
- en: The [`Enum.native_enum`](../core/type_basics.html#sqlalchemy.types.Enum.params.native_enum
    "sqlalchemy.sql.sqltypes.Enum") parameter refers to if the [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.sql.sqltypes.Enum") datatype should create a so-called “native” enum,
    which on MySQL/MariaDB is the `ENUM` datatype and on PostgreSQL is a new `TYPE`
    object created by `CREATE TYPE`, or a “non-native” enum, which means that `VARCHAR`
    will be used to create the datatype. For backends other than MySQL/MariaDB or
    PostgreSQL, `VARCHAR` is used in all cases (third party dialects may have their
    own behaviors).
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Enum.native_enum`](../core/type_basics.html#sqlalchemy.types.Enum.params.native_enum
    "sqlalchemy.sql.sqltypes.Enum") 参数指的是 [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.sql.sqltypes.Enum") 数据类型是否应该创建所谓的“本地”枚举，在 MySQL/MariaDB 中是 `ENUM`
    数据类型，在 PostgreSQL 中是由 `CREATE TYPE` 创建的新 `TYPE` 对象，或者是“非本地”枚举，这意味着将使用 `VARCHAR`
    来创建数据类型。对于不是 MySQL/MariaDB 或 PostgreSQL 的后端，`VARCHAR` 在所有情况下都会被使用（第三方方言可能具有自己的行为）。'
- en: 'Because PostgreSQL’s `CREATE TYPE` requires that there’s an explicit name for
    the type to be created, special fallback logic exists when working with implicitly
    generated [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.sql.sqltypes.Enum")
    without specifying an explicit [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.sql.sqltypes.Enum") datatype within a mapping:'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 PostgreSQL 的 `CREATE TYPE` 要求有一个明确的类型名称要被创建，所以在使用隐式生成的 [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.sql.sqltypes.Enum") 时，当没有指定显式的 [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.sql.sqltypes.Enum") 数据类型时，存在特殊的回退逻辑：
- en: If the [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.sql.sqltypes.Enum")
    is linked to an `enum.Enum` object, the [`Enum.native_enum`](../core/type_basics.html#sqlalchemy.types.Enum.params.native_enum
    "sqlalchemy.sql.sqltypes.Enum") parameter defaults to `True` and the name of the
    enum will be taken from the name of the `enum.Enum` datatype. The PostgreSQL backend
    will assume `CREATE TYPE` with this name.
  id: totrans-544
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.sql.sqltypes.Enum")
    与 `enum.Enum` 对象关联，则 [`Enum.native_enum`](../core/type_basics.html#sqlalchemy.types.Enum.params.native_enum
    "sqlalchemy.sql.sqltypes.Enum") 参数默认为 `True`，并且枚举的名称将从 `enum.Enum` 数据类型的名称中获取。PostgreSQL
    后端将假定使用此名称创建 `CREATE TYPE`。
- en: If the [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.sql.sqltypes.Enum")
    is linked to a `typing.Literal` object, the [`Enum.native_enum`](../core/type_basics.html#sqlalchemy.types.Enum.params.native_enum
    "sqlalchemy.sql.sqltypes.Enum") parameter defaults to `False`; no name is generated
    and `VARCHAR` is assumed.
  id: totrans-545
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果 [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.sql.sqltypes.Enum")
    与 `typing.Literal` 对象关联，则 [`Enum.native_enum`](../core/type_basics.html#sqlalchemy.types.Enum.params.native_enum
    "sqlalchemy.sql.sqltypes.Enum") 参数默认为 `False`；不会生成名称，假定为 `VARCHAR`。
- en: 'To use `typing.Literal` with a PostgreSQL `CREATE TYPE` type, an explicit [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.sql.sqltypes.Enum") must be used, either within the type map:'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 PostgreSQL 的 `CREATE TYPE` 类型中使用 `typing.Literal`，必须使用显式的 [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.sql.sqltypes.Enum")，要么在类型映射中：
- en: '[PRE158]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'Or alternatively within [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column"):'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 或者在 [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    中：
- en: '[PRE159]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: Altering the Configuration of the Default Enum
  id: totrans-550
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 修改默认枚举的配置
- en: 'In order to modify the fixed configuration of the `Enum` datatype that’s generated
    implicitly, specify new entries in the [`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry"), indicating additional arguments. For example, to use
    “non native enumerations” unconditionally, the [`Enum.native_enum`](../core/type_basics.html#sqlalchemy.types.Enum.params.native_enum
    "sqlalchemy.types.Enum") parameter may be set to False for all types:'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 为了修改隐式生成的 `Enum` 数据类型的固定配置，可以在 [`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry") 中指定新的条目，指示额外的参数。例如，要无条件地使用“非本地枚举”，可以为所有类型将 [`Enum.native_enum`](../core/type_basics.html#sqlalchemy.types.Enum.params.native_enum
    "sqlalchemy.types.Enum") 参数设置为 False：
- en: '[PRE160]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'Changed in version 2.0.1: Implemented support for overriding parameters such
    as [`Enum.native_enum`](../core/type_basics.html#sqlalchemy.types.Enum.params.native_enum
    "sqlalchemy.types.Enum") within the [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum") datatype when establishing the [`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry"). Previously, this functionality was not working.'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 在 2.0.1 版本中更改：实现了在建立 [`registry.type_annotation_map`](mapping_api.html#sqlalchemy.orm.registry.params.type_annotation_map
    "sqlalchemy.orm.registry") 时重写参数的支持，例如 [`Enum.native_enum`](../core/type_basics.html#sqlalchemy.types.Enum.params.native_enum
    "sqlalchemy.types.Enum") 中的参数。之前，此功能未正常工作。
- en: 'To use a specific configuration for a specific `enum.Enum` subtype, such as
    setting the string length to 50 when using the example `Status` datatype:'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 若要针对特定的 `enum.Enum` 子类型使用特定配置，例如在使用示例 `Status` 数据类型时将字符串长度设置为 50：
- en: '[PRE161]'
  id: totrans-555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: 'By default [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.types.Enum")
    that are automatically generated are not associated with the `MetaData` instance
    used by the `Base`, so if the metadata defines a schema it will not be automatically
    associated with the enum. To automatically associate the enum with the schema
    in the metadata or table they belong to the [`Enum.inherit_schema`](../core/type_basics.html#sqlalchemy.types.Enum.params.inherit_schema
    "sqlalchemy.types.Enum") can be set:'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，自动生成的 [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.types.Enum")
    与 `Base` 使用的 `MetaData` 实例不关联，因此如果元数据定义了模式，则不会自动将其与枚举关联起来。要将枚举自动关联到元数据或表中的模式，可以设置
    [`Enum.inherit_schema`](../core/type_basics.html#sqlalchemy.types.Enum.params.inherit_schema
    "sqlalchemy.types.Enum")：
- en: '[PRE162]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: Linking Specific `enum.Enum` or `typing.Literal` to other datatypes
  id: totrans-558
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 将特定的 `enum.Enum` 或 `typing.Literal` 链接到其他数据类型
- en: 'The above examples feature the use of an [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum") that is automatically configuring itself to the arguments
    / attributes present on an `enum.Enum` or `typing.Literal` type object. For use
    cases where specific kinds of `enum.Enum` or `typing.Literal` should be linked
    to other types, these specific types may be placed in the type map also. In the
    example below, an entry for `Literal[]` that contains non-string types is linked
    to the [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON")
    datatype:'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例展示了自动将 [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.types.Enum")
    配置到 `enum.Enum` 或 `typing.Literal` 类型对象上的用法。对于应该与其他类型链接的特定种类的 `enum.Enum` 或 `typing.Literal`
    的用例，也可以将这些特定类型放入类型映射中。在下面的示例中，包含非字符串类型的 `Literal[]` 条目被链接到 [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON") 数据类型：
- en: '[PRE163]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: In the above configuration, the `my_literal` datatype will resolve to a [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON") instance. Other `Literal` variants will continue to resolve
    to [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.types.Enum")
    datatypes.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述配置中，`my_literal` 数据类型将解析为 [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON") 实例。其他 `Literal` 变体将继续解析为 [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum") 数据类型。
- en: Dataclass features in `mapped_column()`
  id: totrans-562
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`mapped_column()` 中的数据类特性'
- en: The [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    construct integrates with SQLAlchemy’s “native dataclasses” feature, discussed
    at [Declarative Dataclass Mapping](dataclasses.html#orm-declarative-native-dataclasses).
    See that section for current background on additional directives supported by
    [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column").
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: '[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    构造与 SQLAlchemy 的“原生数据类”功能集成，该功能在[声明式数据类映射](dataclasses.html#orm-declarative-native-dataclasses)中讨论。请参阅该部分了解关于
    [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    支持的其他指令的当前背景。'
- en: '### Accessing Table and Metadata'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: '### 访问表和元数据'
- en: 'A declaratively mapped class will always include an attribute called `__table__`;
    when the above configuration using `__tablename__` is complete, the declarative
    process makes the [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    available via the `__table__` attribute:'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 声明式映射的类将始终包括一个名为 `__table__` 的属性；当使用 `__tablename__` 进行上述配置时，声明过程通过 `__table__`
    属性使 [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    可用：
- en: '[PRE164]'
  id: totrans-566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: 'The above table is ultimately the same one that corresponds to the [`Mapper.local_table`](mapping_api.html#sqlalchemy.orm.Mapper.local_table
    "sqlalchemy.orm.Mapper.local_table") attribute, which we can see through the [runtime
    inspection system](../core/inspection.html):'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 上述表最终与[`Mapper.local_table`](mapping_api.html#sqlalchemy.orm.Mapper.local_table
    "sqlalchemy.orm.Mapper.local_table")属性相同，我们可以通过[运行时检查系统](../core/inspection.html)来查看它：
- en: '[PRE165]'
  id: totrans-568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: 'The [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData "sqlalchemy.schema.MetaData")
    collection associated with both the declarative [`registry`](mapping_api.html#sqlalchemy.orm.registry
    "sqlalchemy.orm.registry") as well as the base class is frequently necessary in
    order to run DDL operations such as CREATE, as well as in use with migration tools
    such as Alembic. This object is available via the `.metadata` attribute of [`registry`](mapping_api.html#sqlalchemy.orm.registry
    "sqlalchemy.orm.registry") as well as the declarative base class. Below, for a
    small script we may wish to emit a CREATE for all tables against a SQLite database:'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 与声明式[`registry`](mapping_api.html#sqlalchemy.orm.registry "sqlalchemy.orm.registry")以及基类关联的[`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData")集合通常是必要的，以便执行诸如CREATE之类的DDL操作，以及与诸如Alembic之类的迁移工具一起使用。该对象可通过[`registry`](mapping_api.html#sqlalchemy.orm.registry
    "sqlalchemy.orm.registry")以及声明式基类的`.metadata`属性获得。下面，对于一个小脚本，我们可能希望针对SQLite数据库发出所有表的CREATE：
- en: '[PRE166]'
  id: totrans-570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: '### Declarative Table Configuration'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: '### 声明式表配置'
- en: When using Declarative Table configuration with the `__tablename__` declarative
    class attribute, additional arguments to be supplied to the [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") constructor should be provided using the `__table_args__`
    declarative class attribute.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用具有`__tablename__`声明类属性的声明式表配置时，应该使用`__table_args__`声明类属性提供额外的参数供[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")构造函数使用。
- en: 'This attribute accommodates both positional as well as keyword arguments that
    are normally sent to the [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") constructor. The attribute can be specified in one
    of two forms. One is as a dictionary:'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 此属性同时适用于通常发送到[`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")构造函数的位置参数和关键字参数。该属性可以以两种形式之一指定。一种是作为字典：
- en: '[PRE167]'
  id: totrans-574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: 'The other, a tuple, where each argument is positional (usually constraints):'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种是元组，其中每个参数都是位置参数（通常是约束）：
- en: '[PRE168]'
  id: totrans-576
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: 'Keyword arguments can be specified with the above form by specifying the last
    argument as a dictionary:'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字参数可以通过指定最后一个参数为字典的形式来指定：
- en: '[PRE169]'
  id: totrans-578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: A class may also specify the `__table_args__` declarative attribute, as well
    as the `__tablename__` attribute, in a dynamic style using the [`declared_attr()`](mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr") method decorator. See [Composing Mapped Hierarchies
    with Mixins](declarative_mixins.html) for background.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 类还可以使用[`declared_attr()`](mapping_api.html#sqlalchemy.orm.declared_attr "sqlalchemy.orm.declared_attr")方法装饰器以动态方式指定`__table_args__`声明属性以及`__tablename__`属性。有关背景信息，请参阅[使用混合组合映射层次结构](declarative_mixins.html)。
- en: '### Explicit Schema Name with Declarative Table'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: '### 使用声明式表的显式模式名称'
- en: 'The schema name for a [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") as documented at [Specifying the Schema Name](../core/metadata.html#schema-table-schema-name)
    is applied to an individual [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") using the [`Table.schema`](../core/metadata.html#sqlalchemy.schema.Table.params.schema
    "sqlalchemy.schema.Table") argument. When using Declarative tables, this option
    is passed like any other to the `__table_args__` dictionary:'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 如[指定模式名称](../core/metadata.html#schema-table-schema-name)文档化的[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")的模式名称应用于单个[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")，使用[`Table.schema`](../core/metadata.html#sqlalchemy.schema.Table.params.schema
    "sqlalchemy.schema.Table")参数。在使用声明式表时，此选项像任何其他选项一样传递到`__table_args__`字典中：
- en: '[PRE170]'
  id: totrans-582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: 'The schema name can also be applied to all [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects globally by using the [`MetaData.schema`](../core/metadata.html#sqlalchemy.schema.MetaData.params.schema
    "sqlalchemy.schema.MetaData") parameter documented at [Specifying a Default Schema
    Name with MetaData](../core/metadata.html#schema-metadata-schema-name). The [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") object may be constructed separately and associated
    with a [`DeclarativeBase`](mapping_api.html#sqlalchemy.orm.DeclarativeBase "sqlalchemy.orm.DeclarativeBase")
    subclass by assigning to the `metadata` attribute directly:'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 模式名称也可以通过在[指定MetaData的默认模式名称](../core/metadata.html#schema-metadata-schema-name)文档中记录的[`MetaData.schema`](../core/metadata.html#sqlalchemy.schema.MetaData.params.schema
    "sqlalchemy.schema.MetaData")参数全局应用于所有[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")对象。[`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData")对象可以单独构造，并通过直接赋值给`metadata`属性与[`DeclarativeBase`](mapping_api.html#sqlalchemy.orm.DeclarativeBase
    "sqlalchemy.orm.DeclarativeBase")子类关联：
- en: '[PRE171]'
  id: totrans-584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: See also
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Specifying the Schema Name](../core/metadata.html#schema-table-schema-name)
    - in the [Describing Databases with MetaData](../core/metadata.html) documentation.'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: '[指定模式名称](../core/metadata.html#schema-table-schema-name) - 在[使用MetaData描述数据库](../core/metadata.html)文档中。'
- en: '### Setting Load and Persistence Options for Declarative Mapped Columns'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: '### 为声明式映射列设置加载和持久化选项'
- en: 'The [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    construct accepts additional ORM-specific arguments that affect how the generated
    [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    is mapped, affecting its load and persistence-time behavior. Options that are
    commonly used include:'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: '[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")构造接受影响生成的[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")映射的额外ORM特定参数，影响其加载和持久化行为。常用选项包括：'
- en: '**deferred column loading** - The [`mapped_column.deferred`](mapping_api.html#sqlalchemy.orm.mapped_column.params.deferred
    "sqlalchemy.orm.mapped_column") boolean establishes the [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") using [deferred column loading](queryguide/columns.html#orm-queryguide-column-deferral)
    by default. In the example below, the `User.bio` column will not be loaded by
    default, but only when accessed:'
  id: totrans-589
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**延迟列加载** - [`mapped_column.deferred`](mapping_api.html#sqlalchemy.orm.mapped_column.params.deferred
    "sqlalchemy.orm.mapped_column")布尔值默认使用[延迟列加载](queryguide/columns.html#orm-queryguide-column-deferral)来建立[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")。在下面的示例中，`User.bio`列默认不会被加载，只有在访问时才会加载：'
- en: '[PRE172]'
  id: totrans-590
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE172]'
- en: See also
  id: totrans-591
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Limiting which Columns Load with Column Deferral](queryguide/columns.html#orm-queryguide-column-deferral)
    - full description of deferred column loading'
  id: totrans-592
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[限制哪些列使用列延迟加载](queryguide/columns.html#orm-queryguide-column-deferral) - 延迟列加载的完整描述'
- en: '**active history** - The [`mapped_column.active_history`](mapping_api.html#sqlalchemy.orm.mapped_column.params.active_history
    "sqlalchemy.orm.mapped_column") ensures that upon change of value for the attribute,
    the previous value will have been loaded and made part of the [`AttributeState.history`](internals.html#sqlalchemy.orm.AttributeState.history
    "sqlalchemy.orm.AttributeState.history") collection when inspecting the history
    of the attribute. This may incur additional SQL statements:'
  id: totrans-593
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**活动历史** - [`mapped_column.active_history`](mapping_api.html#sqlalchemy.orm.mapped_column.params.active_history
    "sqlalchemy.orm.mapped_column")确保在属性值更改时，之前的值已加载并作为[`AttributeState.history`](internals.html#sqlalchemy.orm.AttributeState.history
    "sqlalchemy.orm.AttributeState.history")集合的一部分。检查属性的历史记录时，可能会产生额外的SQL语句：'
- en: '[PRE173]'
  id: totrans-594
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE173]'
- en: See the docstring for [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") for a list of supported parameters.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 查看[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")的文档字符串，以获取支持的参数列表。
- en: See also
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Applying Load, Persistence and Mapping Options for Imperative Table Columns](#orm-imperative-table-column-options)
    - describes using [`column_property()`](mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property") and [`deferred()`](queryguide/columns.html#sqlalchemy.orm.deferred
    "sqlalchemy.orm.deferred") for use with Imperative Table configuration'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: '[为命令式表列应用加载、持久化和映射选项](#orm-imperative-table-column-options) - 描述了与命令式表配置一起使用[`column_property()`](mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property")和[`deferred()`](queryguide/columns.html#sqlalchemy.orm.deferred
    "sqlalchemy.orm.deferred")的用法'
- en: '### Naming Declarative Mapped Columns Explicitly'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: '### 显式命名声明式映射列'
- en: 'All of the examples thus far feature the [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct linked to an ORM mapped attribute, where
    the Python attribute name given to the [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") is also that of the column as we see in CREATE
    TABLE statements as well as queries. The name for a column as expressed in SQL
    may be indicated by passing the string positional argument [`mapped_column.__name`](mapping_api.html#sqlalchemy.orm.mapped_column.params.__name
    "sqlalchemy.orm.mapped_column") as the first positional argument. In the example
    below, the `User` class is mapped with alternate names given to the columns themselves:'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 所有到目前为止的示例都是与ORM映射属性相关的[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")构造相关联的，其中给定给[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")的Python属性名称也是我们在CREATE TABLE语句以及查询中看到的列的名称。在SQL中表达的列名称可以通过将字符串位置参数[`mapped_column.__name`](mapping_api.html#sqlalchemy.orm.mapped_column.params.__name
    "sqlalchemy.orm.mapped_column")作为第一个位置参数传递来指示。在下面的示例中，`User`类与给定给列本身的备用名称进行了映射：
- en: '[PRE174]'
  id: totrans-600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: 'Where above `User.id` resolves to a column named `user_id` and `User.name`
    resolves to a column named `user_name`. We may write a [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") statement using our Python attribute names
    and will see the SQL names generated:'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，`User.id`解析为一个名为`user_id`的列，`User.name`解析为一个名为`user_name`的列。我们可以使用我们的Python属性名称编写一个[`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select")语句，并将看到生成的SQL名称：
- en: '[PRE175]'
  id: totrans-602
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: See also
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Alternate Attribute Names for Mapping Table Columns](#orm-imperative-table-column-naming)
    - applies to Imperative Table'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: '[映射表列的备用属性名称](#orm-imperative-table-column-naming) - 适用于命令式表'
- en: '### Appending additional columns to an existing Declarative mapped class'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: '### 将额外的列附加到现有的声明式映射类'
- en: A declarative table configuration allows the addition of new [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects to an existing mapping after the [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") metadata has already been generated.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 在现有的映射生成[`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")元数据之后，声明性表配置允许向其添加新的[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")对象。
- en: 'For a declarative class that is declared using a declarative base class, the
    underlying metaclass `DeclarativeMeta` includes a `__setattr__()` method that
    will intercept additional [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") or Core [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects and add them to both the [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") using [`Table.append_column()`](../core/metadata.html#sqlalchemy.schema.Table.append_column
    "sqlalchemy.schema.Table.append_column") as well as to the existing [`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper") using [`Mapper.add_property()`](mapping_api.html#sqlalchemy.orm.Mapper.add_property
    "sqlalchemy.orm.Mapper.add_property"):'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 对于使用声明性基类声明的声明性类，底层元类`DeclarativeMeta`包括一个`__setattr__()`方法，该方法将拦截额外的[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")或Core [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")对象，并将它们添加到使用[`Table.append_column()`](../core/metadata.html#sqlalchemy.schema.Table.append_column
    "sqlalchemy.schema.Table.append_column")的[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")以及到现有的[`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper")中使用[`Mapper.add_property()`](mapping_api.html#sqlalchemy.orm.Mapper.add_property
    "sqlalchemy.orm.Mapper.add_property")：
- en: '[PRE176]'
  id: totrans-608
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: 'Using core [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column"):'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 使用核心[`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")：
- en: '[PRE177]'
  id: totrans-610
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: All arguments are supported including an alternate name, such as `MyClass.some_new_column
    = mapped_column("some_name", String)`. However, the SQL type must be passed to
    the [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    or [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    object explicitly, as in the above examples where the [`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String") type is passed. There’s no capability for the [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") annotation type to take part in the operation.
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 所有参数都受支持，包括备用名称，例如 `MyClass.some_new_column = mapped_column("some_name", String)`。但是，SQL类型必须明确地传递给
    [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    或 [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    对象，就像上面的示例中传递 [`String`](../core/type_basics.html#sqlalchemy.types.String "sqlalchemy.types.String")
    类型一样。[`Mapped`](internals.html#sqlalchemy.orm.Mapped "sqlalchemy.orm.Mapped")
    注释类型无法参与操作。
- en: Additional [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    objects may also be added to a mapping in the specific circumstance of using single
    table inheritance, where additional columns are present on mapped subclasses that
    have no [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    of their own. This is illustrated in the section [Single Table Inheritance](inheritance.html#single-inheritance).
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用单表继承的特定情况下，还可以将其他 [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") 对象添加到映射中，其中在映射的子类上存在其他列，这些列没有自己的 [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")。这在 [单表继承](inheritance.html#single-inheritance) 部分有说明。
- en: See also
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[Adding Relationships to Mapped Classes After Declaration](basic_relationships.html#orm-declarative-table-adding-relationship)
    - similar examples for [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: '[在声明后向映射类添加关系](basic_relationships.html#orm-declarative-table-adding-relationship)
    - [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")
    的类似示例'
- en: Note
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 注
- en: Assignment of mapped properties to an already mapped class will only function
    correctly if the “declarative base” class is used, meaning the user-defined subclass
    of [`DeclarativeBase`](mapping_api.html#sqlalchemy.orm.DeclarativeBase "sqlalchemy.orm.DeclarativeBase")
    or the dynamically generated class returned by [`declarative_base()`](mapping_api.html#sqlalchemy.orm.declarative_base
    "sqlalchemy.orm.declarative_base") or [`registry.generate_base()`](mapping_api.html#sqlalchemy.orm.registry.generate_base
    "sqlalchemy.orm.registry.generate_base"). This “base” class includes a Python
    metaclass which implements a special `__setattr__()` method that intercepts these
    operations.
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 对已映射类进行映射属性的赋值仅在使用“声明基类”类时才能正常工作，这意味着使用用户定义的 [`DeclarativeBase`](mapping_api.html#sqlalchemy.orm.DeclarativeBase
    "sqlalchemy.orm.DeclarativeBase") 子类或 [`declarative_base()`](mapping_api.html#sqlalchemy.orm.declarative_base
    "sqlalchemy.orm.declarative_base") 或 [`registry.generate_base()`](mapping_api.html#sqlalchemy.orm.registry.generate_base
    "sqlalchemy.orm.registry.generate_base") 返回的动态生成类。这个“基”类包括一个Python元类，它实现了一个特殊的
    `__setattr__()` 方法，拦截这些操作。
- en: Runtime assignment of class-mapped attributes to a mapped class will **not**
    work if the class is mapped using decorators like [`registry.mapped()`](mapping_api.html#sqlalchemy.orm.registry.mapped
    "sqlalchemy.orm.registry.mapped") or imperative functions like [`registry.map_imperatively()`](mapping_api.html#sqlalchemy.orm.registry.map_imperatively
    "sqlalchemy.orm.registry.map_imperatively").
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 如果类使用诸如 [`registry.mapped()`](mapping_api.html#sqlalchemy.orm.registry.mapped
    "sqlalchemy.orm.registry.mapped") 或命令式函数诸如 [`registry.map_imperatively()`](mapping_api.html#sqlalchemy.orm.registry.map_imperatively
    "sqlalchemy.orm.registry.map_imperatively") 的装饰器进行映射，则将类映射到映射类的类映射属性的运行时赋值 **不会**
    生效。
- en: '## Declarative with Imperative Table (a.k.a. Hybrid Declarative)'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: '## 声明式与命令式表（又名混合声明式）'
- en: Declarative mappings may also be provided with a pre-existing [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") object, or otherwise a [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") or other arbitrary [`FromClause`](../core/selectable.html#sqlalchemy.sql.expression.FromClause
    "sqlalchemy.sql.expression.FromClause") construct (such as a [`Join`](../core/selectable.html#sqlalchemy.sql.expression.Join
    "sqlalchemy.sql.expression.Join") or [`Subquery`](../core/selectable.html#sqlalchemy.sql.expression.Subquery
    "sqlalchemy.sql.expression.Subquery")) that is constructed separately.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以为声明式映射提供预先存在的[`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")对象，或者其他任意[`FromClause`](../core/selectable.html#sqlalchemy.sql.expression.FromClause
    "sqlalchemy.sql.expression.FromClause")构造（例如[`Join`](../core/selectable.html#sqlalchemy.sql.expression.Join
    "sqlalchemy.sql.expression.Join")或[`Subquery`](../core/selectable.html#sqlalchemy.sql.expression.Subquery
    "sqlalchemy.sql.expression.Subquery")）单独构造。
- en: 'This is referred to as a “hybrid declarative” mapping, as the class is mapped
    using the declarative style for everything involving the mapper configuration,
    however the mapped [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    object is produced separately and passed to the declarative process directly:'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 这被称为“混合声明式”映射，因为类使用声明式样式进行映射配置的所有内容，但映射的[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")对象是单独生成的，并直接传递给声明过程：
- en: '[PRE178]'
  id: totrans-621
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: 'Above, a [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    object is constructed using the approach described at [Describing Databases with
    MetaData](../core/metadata.html#metadata-describing). It can then be applied directly
    to a class that is declaratively mapped. The `__tablename__` and `__table_args__`
    declarative class attributes are not used in this form. The above configuration
    is often more readable as an inline definition:'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述内容中，使用了一种通过[用 MetaData 描述数据库](../core/metadata.html#metadata-describing)的方法构建了一个[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")对象。然后可以直接将其应用于声明式映射的类。在此形式中不使用`__tablename__`和`__table_args__`声明式类属性。以上配置通常更易读，可作为内联定义：
- en: '[PRE179]'
  id: totrans-623
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: 'A natural effect of the above style is that the `__table__` attribute is itself
    defined within the class definition block. As such it may be immediately referenced
    within subsequent attributes, such as the example below which illustrates referring
    to the `type` column in a polymorphic mapper configuration:'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 上述样式的一个自然效果是，`__table__`属性本身在类定义块内定义。因此，它可以立即在后续属性中引用，例如下面的示例，演示了在多态映射配置中引用`type`列：
- en: '[PRE180]'
  id: totrans-625
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: 'The “imperative table” form is also used when a non-[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") construct, such as a [`Join`](../core/selectable.html#sqlalchemy.sql.expression.Join
    "sqlalchemy.sql.expression.Join") or [`Subquery`](../core/selectable.html#sqlalchemy.sql.expression.Subquery
    "sqlalchemy.sql.expression.Subquery") object, is to be mapped. An example below:'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 当要映射非[`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")构造时，也使用“命令式表格”形式，例如[`Join`](../core/selectable.html#sqlalchemy.sql.expression.Join
    "sqlalchemy.sql.expression.Join")或[`Subquery`](../core/selectable.html#sqlalchemy.sql.expression.Subquery
    "sqlalchemy.sql.expression.Subquery")对象。以下是一个示例：
- en: '[PRE181]'
  id: totrans-627
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: For background on mapping to non-[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") constructs see the sections [Mapping a Class against
    Multiple Tables](nonstandard_mappings.html#orm-mapping-joins) and [Mapping a Class
    against Arbitrary Subqueries](nonstandard_mappings.html#orm-mapping-arbitrary-subqueries).
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 关于映射到非[`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")构造的背景信息，请参阅[将类映射到多个表](nonstandard_mappings.html#orm-mapping-joins)和[将类映射到任意子查询](nonstandard_mappings.html#orm-mapping-arbitrary-subqueries)部分。
- en: The “imperative table” form is of particular use when the class itself is using
    an alternative form of attribute declaration, such as Python dataclasses. See
    the section [Applying ORM Mappings to an existing dataclass (legacy dataclass
    use)](dataclasses.html#orm-declarative-dataclasses) for detail.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 当类本身使用另一种属性声明形式（例如 Python 数据类）时，“命令式表格”形式尤其有用。详情请参见[将 ORM 映射应用于现有数据类（传统数据类用法）](dataclasses.html#orm-declarative-dataclasses)部分。
- en: See also
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅
- en: '[Describing Databases with MetaData](../core/metadata.html#metadata-describing)'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: '[用 MetaData 描述数据库](../core/metadata.html#metadata-describing)'
- en: '[Applying ORM Mappings to an existing dataclass (legacy dataclass use)](dataclasses.html#orm-declarative-dataclasses)'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: '[将ORM映射应用于现有数据类（传统数据类使用）](dataclasses.html#orm-declarative-dataclasses)'
- en: '### Alternate Attribute Names for Mapping Table Columns'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: '### 映射表列的备用属性名称'
- en: The section [Naming Declarative Mapped Columns Explicitly](#orm-declarative-table-column-naming)
    illustrated how to use [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") to provide a specific name for the generated [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") object separate from the attribute name under which
    it is mapped.
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: '[明确命名声明式映射列](#orm-declarative-table-column-naming)说明了如何使用[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")为生成的[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")对象提供一个与其映射的属性名称不同的特定名称。'
- en: 'When using Imperative Table configuration, we already have [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects present. To map these to alternate names we
    may assign the [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    to the desired attributes directly:'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用命令式表配置时，我们已经有[`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")对象存在。要将这些映射到备用名称，我们可以直接将[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")分配给所需的属性：
- en: '[PRE182]'
  id: totrans-636
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: The `User` mapping above will refer to the `"user_id"` and `"user_name"` columns
    via the `User.id` and `User.name` attributes, in the same way as demonstrated
    at [Naming Declarative Mapped Columns Explicitly](#orm-declarative-table-column-naming).
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的`User`映射将通过`User.id`和`User.name`属性引用`"user_id"`和`"user_name"`列，就像在[Naming
    Declarative Mapped Columns Explicitly](#orm-declarative-table-column-naming)中演示的那样。
- en: 'One caveat to the above mapping is that the direct inline link to [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") will not be typed correctly when using [**PEP 484**](https://peps.python.org/pep-0484/)
    typing tools. A strategy to resolve this is to apply the [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects within the [`column_property()`](mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property") function; while the [`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper") already generates this property object for its internal
    use automatically, by naming it in the class declaration, typing tools will be
    able to match the attribute to the [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") annotation:'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 以上映射的一个注意事项是，当使用[**PEP 484**](https://peps.python.org/pep-0484/)类型工具时，对[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")的直接内联链接将无法正确键入。解决此问题的一种策略是在[`column_property()`](mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property")函数内应用[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")对象；虽然[`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper")已经自动生成了此属性对象供其内部使用，但通过在类声明中命名它，类型工具将能够将属性与[`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped")注释匹配起来：
- en: '[PRE183]'
  id: totrans-639
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: See also
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Naming Declarative Mapped Columns Explicitly](#orm-declarative-table-column-naming)
    - applies to Declarative Table  ### Applying Load, Persistence and Mapping Options
    for Imperative Table Columns'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: '[明确命名声明式映射列](#orm-declarative-table-column-naming) - 适用于声明式表  ### 将加载、持久化和映射选项应用于命令式表列'
- en: 'The section [Setting Load and Persistence Options for Declarative Mapped Columns](#orm-declarative-column-options)
    reviewed how to set load and persistence options when using the [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct with Declarative Table configuration.
    When using Imperative Table configuration, we already have existing [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects that are mapped. In order to map these [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects along with additional parameters that are
    specific to the ORM mapping, we may use the [`column_property()`](mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property") and [`deferred()`](queryguide/columns.html#sqlalchemy.orm.deferred
    "sqlalchemy.orm.deferred") constructs in order to associate additional parameters
    with the column. Options include:'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column) 构造与 Declarative
    Table 配置时，本节回顾了如何设置加载和持久性选项。在使用 Imperative Table 配置时，我们已经有现有的 [`Column`](../core/metadata.html#sqlalchemy.schema.Column)
    对象被映射。为了将这些 [`Column`](../core/metadata.html#sqlalchemy.schema.Column) 对象与 ORM
    映射特定的附加参数一起映射，我们可以使用 [`column_property()`](mapping_api.html#sqlalchemy.orm.column_property)
    和 [`deferred()`](queryguide/columns.html#sqlalchemy.orm.deferred) 构造来将附加参数与列关联起来。选项包括：
- en: '**deferred column loading** - The [`deferred()`](queryguide/columns.html#sqlalchemy.orm.deferred
    "sqlalchemy.orm.deferred") function is shorthand for invoking [`column_property()`](mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property") with the [`column_property.deferred`](mapping_api.html#sqlalchemy.orm.column_property.params.deferred
    "sqlalchemy.orm.column_property") parameter set to `True`; this construct establishes
    the [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    using [deferred column loading](queryguide/columns.html#orm-queryguide-column-deferral)
    by default. In the example below, the `User.bio` column will not be loaded by
    default, but only when accessed:'
  id: totrans-643
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**延迟列加载** - [`deferred()`](queryguide/columns.html#sqlalchemy.orm.deferred)
    函数是使用 [`column_property()`](mapping_api.html#sqlalchemy.orm.column_property) 与
    [`column_property.deferred`](mapping_api.html#sqlalchemy.orm.column_property.params.deferred)
    参数设置为 `True` 的简写；这个构造默认使用 [延迟列加载](queryguide/columns.html#orm-queryguide-column-deferral)。在下面的示例中，`User.bio`
    列默认不会被加载，只有在访问时才会加载：'
- en: '[PRE184]'
  id: totrans-644
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE184]'
- en: See also
  id: totrans-645
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 请参阅
- en: ''
  id: totrans-646
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[Limiting which Columns Load with Column Deferral](queryguide/columns.html#orm-queryguide-column-deferral)
    - full description of deferred column loading'
  id: totrans-647
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[限制哪些列与列延迟加载](queryguide/columns.html#orm-queryguide-column-deferral) - 延迟列加载的完整描述'
- en: '**active history** - The [`column_property.active_history`](mapping_api.html#sqlalchemy.orm.column_property.params.active_history
    "sqlalchemy.orm.column_property") ensures that upon change of value for the attribute,
    the previous value will have been loaded and made part of the [`AttributeState.history`](internals.html#sqlalchemy.orm.AttributeState.history
    "sqlalchemy.orm.AttributeState.history") collection when inspecting the history
    of the attribute. This may incur additional SQL statements:'
  id: totrans-648
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**活动历史** - [`column_property.active_history`](mapping_api.html#sqlalchemy.orm.column_property)
    确保在属性值更改时，之前的值将被加载并作为 [`AttributeState.history`](internals.html#sqlalchemy.orm.AttributeState.history)
    集合的一部分，当检查属性历史时。这可能会产生额外的 SQL 语句：'
- en: '[PRE185]'
  id: totrans-649
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE185]'
- en: See also
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅
- en: 'The [`column_property()`](mapping_api.html#sqlalchemy.orm.column_property "sqlalchemy.orm.column_property")
    construct is also important for cases where classes are mapped to alternative
    FROM clauses such as joins and selects. More background on these cases is at:'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: '[`column_property()`](mapping_api.html#sqlalchemy.orm.column_property) 构造在类被映射到其他
    FROM 子句（如连接和选择）的情况下也很重要。关于这些情况的更多背景信息在：'
- en: '[Mapping a Class against Multiple Tables](nonstandard_mappings.html#maptojoin)'
  id: totrans-652
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[将类映射到多个表](nonstandard_mappings.html#maptojoin)'
- en: '[SQL Expressions as Mapped Attributes](mapped_sql_expr.html#mapper-sql-expressions)'
  id: totrans-653
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SQL 表达式作为映射属性](mapped_sql_expr.html#mapper-sql-expressions)'
- en: 'For Declarative Table configuration with [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column"), most options are available directly; see the
    section [Setting Load and Persistence Options for Declarative Mapped Columns](#orm-declarative-column-options)
    for examples.  ### Alternate Attribute Names for Mapping Table Columns'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: '对于使用[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")进行声明式表配置的情况，大多数选项都可以直接使用；请参阅[为声明式映射列设置加载和持久性选项](#orm-declarative-column-options)部分的示例。  ###
    映射表列的备用属性名称'
- en: The section [Naming Declarative Mapped Columns Explicitly](#orm-declarative-table-column-naming)
    illustrated how to use [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") to provide a specific name for the generated [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") object separate from the attribute name under which
    it is mapped.
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: '[命名声明式映射列](#orm-declarative-table-column-naming) 部分演示了如何使用[`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column")为生成的[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")对象提供一个与其映射的属性名称分离的特定名称。'
- en: 'When using Imperative Table configuration, we already have [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects present. To map these to alternate names we
    may assign the [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    to the desired attributes directly:'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用命令式表配置时，我们已经有了[`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")对象。要将这些映射到备用名称，我们可以直接将[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")分配给所需的属性：
- en: '[PRE186]'
  id: totrans-657
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: The `User` mapping above will refer to the `"user_id"` and `"user_name"` columns
    via the `User.id` and `User.name` attributes, in the same way as demonstrated
    at [Naming Declarative Mapped Columns Explicitly](#orm-declarative-table-column-naming).
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 上述`User`映射将通过`User.id`和`User.name`属性引用`"user_id"`和`"user_name"`列，方式与[Naming
    Declarative Mapped Columns Explicitly](#orm-declarative-table-column-naming)中演示的相同。
- en: 'One caveat to the above mapping is that the direct inline link to [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") will not be typed correctly when using [**PEP 484**](https://peps.python.org/pep-0484/)
    typing tools. A strategy to resolve this is to apply the [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects within the [`column_property()`](mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property") function; while the [`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper") already generates this property object for its internal
    use automatically, by naming it in the class declaration, typing tools will be
    able to match the attribute to the [`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") annotation:'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 上述映射的一个警告是，使用[**PEP 484**](https://peps.python.org/pep-0484/)类型工具时，直接内联到[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")的链接将不会正确类型化。解决此问题的策略是在[`column_property()`](mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property")函数中应用[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")对象；虽然[`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper")已经自动生成了用于内部使用的此属性对象，通过在类声明中命名它，类型工具将能够将属性与[`Mapped`](internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped")注释匹配：
- en: '[PRE187]'
  id: totrans-660
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: See also
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Naming Declarative Mapped Columns Explicitly](#orm-declarative-table-column-naming)
    - applies to Declarative Table'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: '[命名声明式映射列](#orm-declarative-table-column-naming) - 适用于声明式表'
- en: '### Applying Load, Persistence and Mapping Options for Imperative Table Columns'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: '### 为命令式表列应用加载、持久性和映射选项'
- en: 'The section [Setting Load and Persistence Options for Declarative Mapped Columns](#orm-declarative-column-options)
    reviewed how to set load and persistence options when using the [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") construct with Declarative Table configuration.
    When using Imperative Table configuration, we already have existing [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects that are mapped. In order to map these [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects along with additional parameters that are
    specific to the ORM mapping, we may use the [`column_property()`](mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property") and [`deferred()`](queryguide/columns.html#sqlalchemy.orm.deferred
    "sqlalchemy.orm.deferred") constructs in order to associate additional parameters
    with the column. Options include:'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 在[设置声明性映射列的加载和持久化选项](#orm-declarative-column-options)一节中，我们讨论了在使用声明性表配置时如何设置加载和持久化选项。当使用命令式表配置时，我们已经有了现有的[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")对象进行映射。为了将这些[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")对象与与ORM映射相关的其他参数一起映射，我们可以使用[`column_property()`](mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property")和[`deferred()`](queryguide/columns.html#sqlalchemy.orm.deferred
    "sqlalchemy.orm.deferred")构造来将其他参数与列相关联。选项包括：
- en: '**deferred column loading** - The [`deferred()`](queryguide/columns.html#sqlalchemy.orm.deferred
    "sqlalchemy.orm.deferred") function is shorthand for invoking [`column_property()`](mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property") with the [`column_property.deferred`](mapping_api.html#sqlalchemy.orm.column_property.params.deferred
    "sqlalchemy.orm.column_property") parameter set to `True`; this construct establishes
    the [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    using [deferred column loading](queryguide/columns.html#orm-queryguide-column-deferral)
    by default. In the example below, the `User.bio` column will not be loaded by
    default, but only when accessed:'
  id: totrans-665
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**延迟列加载** - [`deferred()`](queryguide/columns.html#sqlalchemy.orm.deferred
    "sqlalchemy.orm.deferred")函数是调用具有[`column_property.deferred`](mapping_api.html#sqlalchemy.orm.column_property.params.deferred
    "sqlalchemy.orm.column_property")参数设置为`True`的[`column_property()`](mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property")的速记方式；此构造默认情况下使用[延迟列加载](queryguide/columns.html#orm-queryguide-column-deferral)来建立[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")。在下面的示例中，`User.bio`列不会默认加载，而是在访问时加载：'
- en: '[PRE188]'
  id: totrans-666
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE188]'
- en: See also
  id: totrans-667
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 另请参阅
- en: ''
  id: totrans-668
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[Limiting which Columns Load with Column Deferral](queryguide/columns.html#orm-queryguide-column-deferral)
    - full description of deferred column loading'
  id: totrans-669
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '[限制加载列的范围与列延迟加载](queryguide/columns.html#orm-queryguide-column-deferral) -
    列延迟加载的完整说明'
- en: '**active history** - The [`column_property.active_history`](mapping_api.html#sqlalchemy.orm.column_property.params.active_history
    "sqlalchemy.orm.column_property") ensures that upon change of value for the attribute,
    the previous value will have been loaded and made part of the [`AttributeState.history`](internals.html#sqlalchemy.orm.AttributeState.history
    "sqlalchemy.orm.AttributeState.history") collection when inspecting the history
    of the attribute. This may incur additional SQL statements:'
  id: totrans-670
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**活跃历史** - [`column_property.active_history`](mapping_api.html#sqlalchemy.orm.column_property.params.active_history
    "sqlalchemy.orm.column_property")确保在属性值更改时，先前的值将已加载并作为[`AttributeState.history`](internals.html#sqlalchemy.orm.AttributeState.history
    "sqlalchemy.orm.AttributeState.history")集合的一部分，以便在检查属性历史时。这可能会引起额外的SQL语句：'
- en: '[PRE189]'
  id: totrans-671
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE189]'
- en: See also
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'The [`column_property()`](mapping_api.html#sqlalchemy.orm.column_property "sqlalchemy.orm.column_property")
    construct is also important for cases where classes are mapped to alternative
    FROM clauses such as joins and selects. More background on these cases is at:'
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: '[`column_property()`](mapping_api.html#sqlalchemy.orm.column_property "sqlalchemy.orm.column_property")构造在将类映射到替代FROM子句（如连接和选择）的情况下也很重要。有关这些情况的更多背景信息，请参阅：'
- en: '[Mapping a Class against Multiple Tables](nonstandard_mappings.html#maptojoin)'
  id: totrans-674
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[将类映射到多个表](nonstandard_mappings.html#maptojoin)'
- en: '[SQL Expressions as Mapped Attributes](mapped_sql_expr.html#mapper-sql-expressions)'
  id: totrans-675
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[SQL表达式作为映射属性](mapped_sql_expr.html#mapper-sql-expressions)'
- en: For Declarative Table configuration with [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column"), most options are available directly; see the
    section [Setting Load and Persistence Options for Declarative Mapped Columns](#orm-declarative-column-options)
    for examples.
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 对于具有 [`mapped_column()`](mapping_api.html#sqlalchemy.orm.mapped_column "sqlalchemy.orm.mapped_column")
    的声明式表配置，大多数选项都是直接可用的；参见 [为声明式映射列设置加载和持久性选项](#orm-declarative-column-options) 部分中的示例。
- en: '## Mapping Declaratively with Reflected Tables'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: '## 使用反射表声明性地映射'
- en: There are several patterns available which provide for producing mapped classes
    against a series of [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    objects that were introspected from the database, using the reflection process
    described at [Reflecting Database Objects](../core/reflection.html#metadata-reflection).
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种可用的模式，可以根据从数据库中内省的一系列 [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") 对象生成映射的类，使用在 [反射数据库对象](../core/reflection.html#metadata-reflection)
    中描述的反射过程。
- en: 'A simple way to map a class to a table reflected from the database is to use
    a declarative hybrid mapping, passing the [`Table.autoload_with`](../core/metadata.html#sqlalchemy.schema.Table.params.autoload_with
    "sqlalchemy.schema.Table") parameter to the constructor for [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table"):'
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 从数据库中反映一个表并将类映射到它的简单方法是使用声明式混合映射，将 [`Table.autoload_with`](../core/metadata.html#sqlalchemy.schema.Table.params.autoload_with
    "sqlalchemy.schema.Table") 参数传递给 [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") 的构造函数：
- en: '[PRE190]'
  id: totrans-680
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: 'A variant on the above pattern that scales for many tables is to use the [`MetaData.reflect()`](../core/metadata.html#sqlalchemy.schema.MetaData.reflect
    "sqlalchemy.schema.MetaData.reflect") method to reflect a full set of [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects at once, then refer to them from the [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData"):'
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 以上模式的一个变种，可以针对许多表扩展，即使用 [`MetaData.reflect()`](../core/metadata.html#sqlalchemy.schema.MetaData.reflect
    "sqlalchemy.schema.MetaData.reflect") 方法一次反射一组完整的 [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") 对象，然后从 [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") 中引用它们：
- en: '[PRE191]'
  id: totrans-682
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: One caveat to the approach of using `__table__` is that the mapped classes cannot
    be declared until the tables have been reflected, which requires the database
    connectivity source to be present while the application classes are being declared;
    it’s typical that classes are declared as the modules of an application are being
    imported, but database connectivity isn’t available until the application starts
    running code so that it can consume configuration information and create an engine.
    There are currently two approaches to working around this, described in the next
    two sections.
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `__table__` 方法的一个注意事项是，映射的类不能在表被反射之前声明，这需要数据库连接源在声明应用程序类时存在；通常情况下，类是在应用程序模块被导入时声明的，但是数据库连接在应用程序启动运行代码时才可用，以便它可以使用配置信息并创建引擎。目前有两种方法可以解决这个问题，分别在接下来的两个部分中描述。
- en: '### Using DeferredReflection'
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: '### 使用 DeferredReflection'
- en: 'To accommodate the use case of declaring mapped classes where reflection of
    table metadata can occur afterwards, a simple extension called the [`DeferredReflection`](extensions/declarative/index.html#sqlalchemy.ext.declarative.DeferredReflection
    "sqlalchemy.ext.declarative.DeferredReflection") mixin is available, which alters
    the declarative mapping process to be delayed until a special class-level [`DeferredReflection.prepare()`](extensions/declarative/index.html#sqlalchemy.ext.declarative.DeferredReflection.prepare
    "sqlalchemy.ext.declarative.DeferredReflection.prepare") method is called, which
    will perform the reflection process against a target database, and will integrate
    the results with the declarative table mapping process, that is, classes which
    use the `__tablename__` attribute:'
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 为了适应在反射表元数据之后声明映射类的用例，有一个简单的扩展称为 [`DeferredReflection`](extensions/declarative/index.html#sqlalchemy.ext.declarative.DeferredReflection
    "sqlalchemy.ext.declarative.DeferredReflection") mixin 可用，它改变了声明性映射过程，延迟直到调用一个特殊的类级
    [`DeferredReflection.prepare()`](extensions/declarative/index.html#sqlalchemy.ext.declarative.DeferredReflection.prepare
    "sqlalchemy.ext.declarative.DeferredReflection.prepare") 方法，该方法将针对目标数据库执行反射过程，并将结果与声明性表映射过程集成，也就是说，使用
    `__tablename__` 属性的类：
- en: '[PRE192]'
  id: totrans-686
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: 'Above, we create a mixin class `Reflected` that will serve as a base for classes
    in our declarative hierarchy that should become mapped when the `Reflected.prepare`
    method is called. The above mapping is not complete until we do so, given an [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine"):'
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面，我们创建了一个混合类`Reflected`，它将作为我们的声明性层次结构中的类的基类，在调用`Reflected.prepare`方法时应该成为映射。在我们这样做之前，上述映射是不完整的，给定一个[`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine")：
- en: '[PRE193]'
  id: totrans-688
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: The purpose of the `Reflected` class is to define the scope at which classes
    should be reflectively mapped. The plugin will search among the subclass tree
    of the target against which `.prepare()` is called and reflect all tables which
    are named by declared classes; tables in the target database that are not part
    of mappings and are not related to the target tables via foreign key constraint
    will not be reflected.
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: '`Reflected` 类的目的是定义应该在哪个范围内进行反射映射。插件将在调用`.prepare()`的目标的子类树中搜索，并反射所有由声明的类命名的表；不是映射的目标数据库中的表，也不是通过外键约束与目标表相关联的表将不被反射。'
- en: Using Automap
  id: totrans-690
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Automap
- en: A more automated solution to mapping against an existing database where table
    reflection is to be used is to use the [Automap](extensions/automap.html) extension.
    This extension will generate entire mapped classes from a database schema, including
    relationships between classes based on observed foreign key constraints. While
    it includes hooks for customization, such as hooks that allow custom class naming
    and relationship naming schemes, automap is oriented towards an expedient zero-configuration
    style of working. If an application wishes to have a fully explicit model that
    makes use of table reflection, the [DeferredReflection](#orm-declarative-reflected-deferred-reflection)
    class may be preferable for its less automated approach.
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 对于映射到现有数据库并使用表反射的自动化解决方案是使用 [Automap](extensions/automap.html) 扩展。此扩展将从数据库模式生成完整的映射类，包括根据观察到的外键约束之间的关系的类。虽然它包括用于定制的钩子，例如允许自定义类命名和关系命名方案的钩子，但
    automap 面向的是一种迅速的零配置工作风格。如果应用程序希望拥有一个完全明确的模型，该模型利用了表反射，那么 [DeferredReflection](#orm-declarative-reflected-deferred-reflection)
    类可能更可取，因为它的自动化程度较低。
- en: See also
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[Automap](extensions/automap.html)'
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: '[Automap](extensions/automap.html)'
- en: '### Automating Column Naming Schemes from Reflected Tables'
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: '### 从反射表自动化列命名方案'
- en: When using any of the previous reflection techniques, we have the option to
    change the naming scheme by which columns are mapped. The [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") object includes a parameter [`Column.key`](../core/metadata.html#sqlalchemy.schema.Column.params.key
    "sqlalchemy.schema.Column") which is a string name that determines under what
    name this [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    will be present in the [`Table.c`](../core/metadata.html#sqlalchemy.schema.Table.c
    "sqlalchemy.schema.Table.c") collection, independently of the SQL name of the
    column. This key is also used by [`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper") as the attribute name under which the [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") will be mapped, if not supplied through other means
    such as that illustrated at [Alternate Attribute Names for Mapping Table Columns](#orm-imperative-table-column-naming).
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用任何前述的反射技术时，我们可以选择更改映射列的命名方案。[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") 对象包括一个参数[`Column.key`](../core/metadata.html#sqlalchemy.schema.Column.params.key
    "sqlalchemy.schema.Column")，它是一个字符串名称，确定这个 [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") 在 [`Table.c`](../core/metadata.html#sqlalchemy.schema.Table.c
    "sqlalchemy.schema.Table.c") 集合中的名称，在不考虑列的 SQL 名称的情况下。如果没有通过其他手段提供，如在 [映射表列的备用属性名称](#orm-imperative-table-column-naming)
    中所示，此键也被 [`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper "sqlalchemy.orm.Mapper")
    用作将 [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    映射到的属性名称。
- en: When working with table reflection, we can intercept the parameters that will
    be used for [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    as they are received using the [`DDLEvents.column_reflect()`](../core/events.html#sqlalchemy.events.DDLEvents.column_reflect
    "sqlalchemy.events.DDLEvents.column_reflect") event and apply whatever changes
    we need, including the `.key` attribute but also things like datatypes.
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用表反射时，我们可以拦截 [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    将要使用的参数，使用 [`DDLEvents.column_reflect()`](../core/events.html#sqlalchemy.events.DDLEvents.column_reflect
    "sqlalchemy.events.DDLEvents.column_reflect") 事件接收它们，并应用我们需要的任何更改，包括 `.key` 属性以及数据类型等。
- en: 'The event hook is most easily associated with the [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") object that’s in use as illustrated below:'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 事件钩子最容易与正在使用的 [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") 对象相关联，如下所示：
- en: '[PRE194]'
  id: totrans-698
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: 'With the above event, the reflection of [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects will be intercepted with our event that adds
    a new “.key” element, such as in a mapping as below:'
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上述事件，[`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    对象的反射将被我们的事件拦截，该事件添加了一个新的“.key”元素，如下面的映射所示：
- en: '[PRE195]'
  id: totrans-700
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: The approach also works with both the [`DeferredReflection`](extensions/declarative/index.html#sqlalchemy.ext.declarative.DeferredReflection
    "sqlalchemy.ext.declarative.DeferredReflection") base class as well as with the
    [Automap](extensions/automap.html) extension. For automap specifically, see the
    section [Intercepting Column Definitions](extensions/automap.html#automap-intercepting-columns)
    for background.
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法还适用于 [`DeferredReflection`](extensions/declarative/index.html#sqlalchemy.ext.declarative.DeferredReflection
    "sqlalchemy.ext.declarative.DeferredReflection") 基类以及 [Automap](extensions/automap.html)
    扩展。对于 automap，特别是请参阅 [Intercepting Column Definitions](extensions/automap.html#automap-intercepting-columns)
    部分了解背景信息。
- en: See also
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Mapping Declaratively with Reflected Tables](#orm-declarative-reflected)'
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用反射表声明式映射](#orm-declarative-reflected)'
- en: '[`DDLEvents.column_reflect()`](../core/events.html#sqlalchemy.events.DDLEvents.column_reflect
    "sqlalchemy.events.DDLEvents.column_reflect")'
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: '[`DDLEvents.column_reflect()`](../core/events.html#sqlalchemy.events.DDLEvents.column_reflect
    "sqlalchemy.events.DDLEvents.column_reflect")'
- en: '[Intercepting Column Definitions](extensions/automap.html#automap-intercepting-columns)
    - in the [Automap](extensions/automap.html) documentation  ### Mapping to an Explicit
    Set of Primary Key Columns'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: '[拦截列定义](extensions/automap.html#automap-intercepting-columns) - 在 [Automap](extensions/automap.html)
    文档中  ### 映射到一组显式主键列'
- en: The [`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper "sqlalchemy.orm.Mapper")
    construct in order to successfully map a table always requires that at least one
    column be identified as the “primary key” for that selectable. This is so that
    when an ORM object is loaded or persisted, it can be placed in the [identity map](../glossary.html#term-identity-map)
    with an appropriate [identity key](../glossary.html#term-identity-key).
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 为了成功映射一个表，[`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper "sqlalchemy.orm.Mapper")
    结构始终要求至少有一个列被标识为该可选择内容的“主键”。这样，当加载或持久化 ORM 对象时，它可以被放置在[标识映射](../glossary.html#term-identity-map)中，并具有适当的[标识键](../glossary.html#term-identity-key)。
- en: In those cases where the a reflected table to be mapped does not include a primary
    key constraint, as well as in the general case for [mapping against arbitrary
    selectables](nonstandard_mappings.html#orm-mapping-arbitrary-subqueries) where
    primary key columns might not be present, the [`Mapper.primary_key`](mapping_api.html#sqlalchemy.orm.Mapper.params.primary_key
    "sqlalchemy.orm.Mapper") parameter is provided so that any set of columns may
    be configured as the “primary key” for the table, as far as ORM mapping is concerned.
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 在需要映射的反射表不包含主键约束的情况下，以及在[映射对任意可选择内容的情况下](nonstandard_mappings.html#orm-mapping-arbitrary-subqueries)，主键列可能不存在的一般情况下，提供了
    [`Mapper.primary_key`](mapping_api.html#sqlalchemy.orm.Mapper.params.primary_key
    "sqlalchemy.orm.Mapper") 参数，以便将任何一组列配置为表的“主键”，就 ORM 映射而言。
- en: 'Given the following example of an Imperative Table mapping against an existing
    [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    object where the table does not have any declared primary key (as may occur in
    reflection scenarios), we may map such a table as in the following example:'
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 给定以下 Imperative Table 映射的示例，针对一个现有的 [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") 对象，该表没有声明任何主键（这可能在反射场景中发生），我们可以像以下示例那样映射这样的表：
- en: '[PRE196]'
  id: totrans-709
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: 'Above, the `group_users` table is an association table of some kind with string
    columns `user_id` and `group_id`, but no primary key is set up; instead, there
    is only a [`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint") establishing that the two columns represent
    a unique key. The [`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper "sqlalchemy.orm.Mapper")
    does not automatically inspect unique constraints for primary keys; instead, we
    make use of the [`Mapper.primary_key`](mapping_api.html#sqlalchemy.orm.Mapper.params.primary_key
    "sqlalchemy.orm.Mapper") parameter, passing a collection of `[group_users.c.user_id,
    group_users.c.group_id]`, indicating that these two columns should be used in
    order to construct the identity key for instances of the `GroupUsers` class.  ###
    Mapping a Subset of Table Columns'
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，`group_users`表是某种类型的关联表，具有字符串列`user_id`和`group_id`，但没有设置主键；相反，只有一个[`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint") 建立了这两列表示唯一键的约束。[`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper") 不会自动检查主键的唯一约束；相反，我们利用[`Mapper.primary_key`](mapping_api.html#sqlalchemy.orm.Mapper.params.primary_key
    "sqlalchemy.orm.Mapper") 参数，传递一个集合`[group_users.c.user_id, group_users.c.group_id]`，表示这两列应该用于构造`GroupUsers`类的实例的标识键。###
    映射表列的子集
- en: 'Sometimes table reflection may provide a [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") with many columns that are not important for our needs
    and may be safely ignored. For such a table that has lots of columns that don’t
    need to be referenced in the application, the [`Mapper.include_properties`](mapping_api.html#sqlalchemy.orm.Mapper.params.include_properties
    "sqlalchemy.orm.Mapper") or [`Mapper.exclude_properties`](mapping_api.html#sqlalchemy.orm.Mapper.params.exclude_properties
    "sqlalchemy.orm.Mapper") parameters can indicate a subset of columns to be mapped,
    where other columns from the target [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") will not be considered by the ORM in any way. Example:'
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，表反射可能会提供一个[`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")，其中有许多对我们的需求不重要且可以安全忽略的列。对于这样一个表，其中有许多列不需要在应用程序中引用，[`Mapper.include_properties`](mapping_api.html#sqlalchemy.orm.Mapper.params.include_properties
    "sqlalchemy.orm.Mapper") 或 [`Mapper.exclude_properties`](mapping_api.html#sqlalchemy.orm.Mapper.params.exclude_properties
    "sqlalchemy.orm.Mapper") 参数可以指示要映射的列的子集，其中来自目标[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") 的其他列不会被 ORM 以任何方式考虑。例如：
- en: '[PRE197]'
  id: totrans-712
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: In the above example, the `User` class will map to the `user_table` table, only
    including the `user_id` and `user_name` columns - the rest are not referenced.
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，`User`类将映射到`user_table`表，只包括`user_id`和`user_name`列 - 其余列不会被引用。
- en: 'Similarly:'
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地：
- en: '[PRE198]'
  id: totrans-715
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: will map the `Address` class to the `address_table` table, including all columns
    present except `street`, `city`, `state`, and `zip`.
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 将`Address`类映射到`address_table`表，包括除了`street`、`city`、`state`和`zip`之外的所有列。
- en: 'As indicated in the two examples, columns may be referenced either by string
    name or by referring to the [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") object directly. Referring to the object directly
    may be useful for explicitness as well as to resolve ambiguities when mapping
    to multi-table constructs that might have repeated names:'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 如两个示例所示，列可以通过字符串名称或直接引用[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")对象来引用。直接引用对象可能对明确性有用，也可用于解决映射到可能具有重复名称的多表构造时的歧义：
- en: '[PRE199]'
  id: totrans-718
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: When columns are not included in a mapping, these columns will not be referenced
    in any SELECT statements emitted when executing [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") or legacy [`Query`](queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") objects, nor will there be any mapped attribute on the
    mapped class which represents the column; assigning an attribute of that name
    will have no effect beyond that of a normal Python attribute assignment.
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 当列未包含在映射中时，在执行[`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") 或传统的 [`Query`](queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") 对象时，这些列将不会在任何 SELECT 语句中引用，映射类中也不会有任何表示该列的映射属性；将其名称分配为属性将不会产生其他效果，仅仅与普通的
    Python 属性赋值相同。
- en: However, it is important to note that **schema level column defaults WILL still
    be in effect** for those [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects that include them, even though they may be
    excluded from the ORM mapping.
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，需要注意的是**模式级列默认值仍然有效**，对于那些包括它们的[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")对象，即使它们可能被排除在ORM映射之外。
- en: '“Schema level column defaults” refers to the defaults described at [Column
    INSERT/UPDATE Defaults](../core/defaults.html#metadata-defaults) including those
    configured by the [`Column.default`](../core/metadata.html#sqlalchemy.schema.Column.params.default
    "sqlalchemy.schema.Column"), [`Column.onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.onupdate
    "sqlalchemy.schema.Column"), [`Column.server_default`](../core/metadata.html#sqlalchemy.schema.Column.params.server_default
    "sqlalchemy.schema.Column") and [`Column.server_onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.server_onupdate
    "sqlalchemy.schema.Column") parameters. These constructs continue to have normal
    effects because in the case of [`Column.default`](../core/metadata.html#sqlalchemy.schema.Column.params.default
    "sqlalchemy.schema.Column") and [`Column.onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.onupdate
    "sqlalchemy.schema.Column"), the [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") object is still present on the underlying [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table"), thus allowing the default functions to take place
    when the ORM emits an INSERT or UPDATE, and in the case of [`Column.server_default`](../core/metadata.html#sqlalchemy.schema.Column.params.server_default
    "sqlalchemy.schema.Column") and [`Column.server_onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.server_onupdate
    "sqlalchemy.schema.Column"), the relational database itself emits these defaults
    as a server side behavior.  ### Using DeferredReflection'
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: “模式级列默认值”指的是在[列插入/更新默认值](../core/defaults.html#metadata-defaults)中描述的默认值，包括由[`Column.default`](../core/metadata.html#sqlalchemy.schema.Column.params.default
    "sqlalchemy.schema.Column")、[`Column.onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.onupdate
    "sqlalchemy.schema.Column")、[`Column.server_default`](../core/metadata.html#sqlalchemy.schema.Column.params.server_default
    "sqlalchemy.schema.Column")和[`Column.server_onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.server_onupdate
    "sqlalchemy.schema.Column")参数配置的默认值。这些结构继续具有正常的效果，因为在[`Column.default`](../core/metadata.html#sqlalchemy.schema.Column.params.default
    "sqlalchemy.schema.Column")和[`Column.onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.onupdate
    "sqlalchemy.schema.Column")的情况下，[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")对象仍然存在于底层的[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")上，因此当ORM发出INSERT或UPDATE时，可以发生默认函数，并且在[`Column.server_default`](../core/metadata.html#sqlalchemy.schema.Column.params.server_default
    "sqlalchemy.schema.Column")和[`Column.server_onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.server_onupdate
    "sqlalchemy.schema.Column")的情况下，关系数据库本身会作为服务器端行为发出这些默认值。### 使用DeferredReflection
- en: 'To accommodate the use case of declaring mapped classes where reflection of
    table metadata can occur afterwards, a simple extension called the [`DeferredReflection`](extensions/declarative/index.html#sqlalchemy.ext.declarative.DeferredReflection
    "sqlalchemy.ext.declarative.DeferredReflection") mixin is available, which alters
    the declarative mapping process to be delayed until a special class-level [`DeferredReflection.prepare()`](extensions/declarative/index.html#sqlalchemy.ext.declarative.DeferredReflection.prepare
    "sqlalchemy.ext.declarative.DeferredReflection.prepare") method is called, which
    will perform the reflection process against a target database, and will integrate
    the results with the declarative table mapping process, that is, classes which
    use the `__tablename__` attribute:'
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 为了适应声明映射类的用例，在此之后可以发生表元数据的反射，提供了一个简单的扩展叫做[`DeferredReflection`](extensions/declarative/index.html#sqlalchemy.ext.declarative.DeferredReflection
    "sqlalchemy.ext.declarative.DeferredReflection") mixin，它修改了声明性映射过程，延迟到调用一个特殊的类级[`DeferredReflection.prepare()`](extensions/declarative/index.html#sqlalchemy.ext.declarative.DeferredReflection.prepare
    "sqlalchemy.ext.declarative.DeferredReflection.prepare")方法，该方法将执行对目标数据库的反射过程，并将结果与声明性表映射过程集成，即使用`__tablename__`属性的类：
- en: '[PRE200]'
  id: totrans-723
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: 'Above, we create a mixin class `Reflected` that will serve as a base for classes
    in our declarative hierarchy that should become mapped when the `Reflected.prepare`
    method is called. The above mapping is not complete until we do so, given an [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine"):'
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面，我们创建了一个名为 `Reflected` 的混合类，它将作为我们声明性层次结构中的类的基类，当调用 `Reflected.prepare` 方法时，这些类应该成为映射。在我们这样做之前，上述映射是不完整的，给定一个
    [`Engine`](../core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")：
- en: '[PRE201]'
  id: totrans-725
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: The purpose of the `Reflected` class is to define the scope at which classes
    should be reflectively mapped. The plugin will search among the subclass tree
    of the target against which `.prepare()` is called and reflect all tables which
    are named by declared classes; tables in the target database that are not part
    of mappings and are not related to the target tables via foreign key constraint
    will not be reflected.
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: '`Reflected` 类的目的是定义应在其中反射映射类的范围。插件将针对调用 `.prepare()` 的目标的子类树中搜索，并反射所有由声明类命名的表；不属于映射的目标数据库中的表，也不通过外键约束与目标表相关联的表将不被反射。'
- en: Using Automap
  id: totrans-727
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用自动映射
- en: A more automated solution to mapping against an existing database where table
    reflection is to be used is to use the [Automap](extensions/automap.html) extension.
    This extension will generate entire mapped classes from a database schema, including
    relationships between classes based on observed foreign key constraints. While
    it includes hooks for customization, such as hooks that allow custom class naming
    and relationship naming schemes, automap is oriented towards an expedient zero-configuration
    style of working. If an application wishes to have a fully explicit model that
    makes use of table reflection, the [DeferredReflection](#orm-declarative-reflected-deferred-reflection)
    class may be preferable for its less automated approach.
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: 映射到现有数据库并使用表反射的更自动化的解决方案是使用 [自动映射](extensions/automap.html) 扩展。该扩展将从数据库架构中生成完整的映射类，包括基于观察到的外键约束的类之间的关系。虽然它包括用于自定义的钩子，例如允许自定义类命名和关系命名方案的钩子，但自动映射是面向一种便捷的零配置工作风格。如果应用程序希望拥有完全明确的模型，该模型利用表反射，则可能更喜欢
    [延迟反射](#orm-declarative-reflected-deferred-reflection) 类，因为它的方法较不自动化。
- en: See also
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Automap](extensions/automap.html)'
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: '[自动映射](extensions/automap.html)'
- en: '### Automating Column Naming Schemes from Reflected Tables'
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: '### 从反射表自动命名列方案'
- en: When using any of the previous reflection techniques, we have the option to
    change the naming scheme by which columns are mapped. The [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") object includes a parameter [`Column.key`](../core/metadata.html#sqlalchemy.schema.Column.params.key
    "sqlalchemy.schema.Column") which is a string name that determines under what
    name this [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    will be present in the [`Table.c`](../core/metadata.html#sqlalchemy.schema.Table.c
    "sqlalchemy.schema.Table.c") collection, independently of the SQL name of the
    column. This key is also used by [`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper") as the attribute name under which the [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") will be mapped, if not supplied through other means
    such as that illustrated at [Alternate Attribute Names for Mapping Table Columns](#orm-imperative-table-column-naming).
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用任何先前的反射技术时，我们可以选择更改列映射的命名方案。[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") 对象包括一个参数 [`Column.key`](../core/metadata.html#sqlalchemy.schema.Column.params.key
    "sqlalchemy.schema.Column")，它是一个字符串名称，确定了这个 [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") 将以什么名称出现在 [`Table.c`](../core/metadata.html#sqlalchemy.schema.Table.c
    "sqlalchemy.schema.Table.c") 集合中，与列的 SQL 名称无关。如果没有通过其他方式提供，比如在 [用于映射表列的替代属性名称](#orm-imperative-table-column-naming)
    中所示的方式，该键也将被 [`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper "sqlalchemy.orm.Mapper")
    用作属性名称，该属性将被映射到 [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")。
- en: When working with table reflection, we can intercept the parameters that will
    be used for [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    as they are received using the [`DDLEvents.column_reflect()`](../core/events.html#sqlalchemy.events.DDLEvents.column_reflect
    "sqlalchemy.events.DDLEvents.column_reflect") event and apply whatever changes
    we need, including the `.key` attribute but also things like datatypes.
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用表反射时，我们可以拦截将用于[`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")的参数，因为它们是使用[`DDLEvents.column_reflect()`](../core/events.html#sqlalchemy.events.DDLEvents.column_reflect
    "sqlalchemy.events.DDLEvents.column_reflect")事件接收的，并应用我们需要的任何更改，包括`.key`属性，以及诸如数据类型之类的内容。
- en: 'The event hook is most easily associated with the [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") object that’s in use as illustrated below:'
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: 事件挂钩最容易与正在使用的[`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData "sqlalchemy.schema.MetaData")对象相关联，如下所示：
- en: '[PRE202]'
  id: totrans-735
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: 'With the above event, the reflection of [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects will be intercepted with our event that adds
    a new “.key” element, such as in a mapping as below:'
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: 有了上述事件，[`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")对象的反射将被我们的事件拦截，该事件添加了一个新的“.key”元素，例如在下面的映射中：
- en: '[PRE203]'
  id: totrans-737
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: The approach also works with both the [`DeferredReflection`](extensions/declarative/index.html#sqlalchemy.ext.declarative.DeferredReflection
    "sqlalchemy.ext.declarative.DeferredReflection") base class as well as with the
    [Automap](extensions/automap.html) extension. For automap specifically, see the
    section [Intercepting Column Definitions](extensions/automap.html#automap-intercepting-columns)
    for background.
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法还适用于[`DeferredReflection`](extensions/declarative/index.html#sqlalchemy.ext.declarative.DeferredReflection
    "sqlalchemy.ext.declarative.DeferredReflection")基类以及[Automap](extensions/automap.html)扩展。对于自动映射，具体请参阅背景信息的[拦截列定义](extensions/automap.html#automap-intercepting-columns)部分。
- en: See also
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 另见
- en: '[Mapping Declaratively with Reflected Tables](#orm-declarative-reflected)'
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用反射表声明式映射](#orm-declarative-reflected)'
- en: '[`DDLEvents.column_reflect()`](../core/events.html#sqlalchemy.events.DDLEvents.column_reflect
    "sqlalchemy.events.DDLEvents.column_reflect")'
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: '[`DDLEvents.column_reflect()`](../core/events.html#sqlalchemy.events.DDLEvents.column_reflect
    "sqlalchemy.events.DDLEvents.column_reflect")'
- en: '[Intercepting Column Definitions](extensions/automap.html#automap-intercepting-columns)
    - in the [Automap](extensions/automap.html) documentation'
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: '[拦截列定义](extensions/automap.html#automap-intercepting-columns) - 在 [Automap](extensions/automap.html)
    文档中'
- en: '### Mapping to an Explicit Set of Primary Key Columns'
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: '### 映射到显式主键列集合'
- en: The [`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper "sqlalchemy.orm.Mapper")
    construct in order to successfully map a table always requires that at least one
    column be identified as the “primary key” for that selectable. This is so that
    when an ORM object is loaded or persisted, it can be placed in the [identity map](../glossary.html#term-identity-map)
    with an appropriate [identity key](../glossary.html#term-identity-key).
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 为了成功映射表，[`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper "sqlalchemy.orm.Mapper")
    构造始终要求至少有一个列被标识为该可选择的“主键”。这样，当加载或持久化 ORM 对象时，它可以被放置在[身份映射](../glossary.html#term-identity-map)中，具有适当的[身份键](../glossary.html#term-identity-key)。
- en: In those cases where the a reflected table to be mapped does not include a primary
    key constraint, as well as in the general case for [mapping against arbitrary
    selectables](nonstandard_mappings.html#orm-mapping-arbitrary-subqueries) where
    primary key columns might not be present, the [`Mapper.primary_key`](mapping_api.html#sqlalchemy.orm.Mapper.params.primary_key
    "sqlalchemy.orm.Mapper") parameter is provided so that any set of columns may
    be configured as the “primary key” for the table, as far as ORM mapping is concerned.
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 在那些要映射的反射表中不包括主键约束的情况下，以及在[映射到任意选择项](nonstandard_mappings.html#orm-mapping-arbitrary-subqueries)的一般情况下，其中可能不存在主键列的情况下，提供了
    [`Mapper.primary_key`](mapping_api.html#sqlalchemy.orm.Mapper.params.primary_key
    "sqlalchemy.orm.Mapper") 参数，以便任何一组列可以被配置为表的“主键”，就 ORM 映射而言。
- en: 'Given the following example of an Imperative Table mapping against an existing
    [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    object where the table does not have any declared primary key (as may occur in
    reflection scenarios), we may map such a table as in the following example:'
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 给出了一个关于现有 [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    对象的命令式表映射的示例，在该表中没有声明任何主键（在反射场景中可能会发生），我们可以将这样的表映射为以下示例中的方式：
- en: '[PRE204]'
  id: totrans-747
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: Above, the `group_users` table is an association table of some kind with string
    columns `user_id` and `group_id`, but no primary key is set up; instead, there
    is only a [`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint") establishing that the two columns represent
    a unique key. The [`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper "sqlalchemy.orm.Mapper")
    does not automatically inspect unique constraints for primary keys; instead, we
    make use of the [`Mapper.primary_key`](mapping_api.html#sqlalchemy.orm.Mapper.params.primary_key
    "sqlalchemy.orm.Mapper") parameter, passing a collection of `[group_users.c.user_id,
    group_users.c.group_id]`, indicating that these two columns should be used in
    order to construct the identity key for instances of the `GroupUsers` class.
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 上述的 `group_users` 表是某种关联表，具有字符串列 `user_id` 和 `group_id`，但没有设置主键；相反，只有一个 [`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint") 建立了这两列代表唯一键的关系。[`Mapper`](mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper") 不会自动检查唯一约束以获取主键；而是我们利用 [`Mapper.primary_key`](mapping_api.html#sqlalchemy.orm.Mapper.params.primary_key
    "sqlalchemy.orm.Mapper") 参数，传递一个集合 `[group_users.c.user_id, group_users.c.group_id]`，表示这两列应该用于构建
    `GroupUsers` 类的标识键。
- en: '### Mapping a Subset of Table Columns'
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: '### 映射表列的子集'
- en: 'Sometimes table reflection may provide a [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") with many columns that are not important for our needs
    and may be safely ignored. For such a table that has lots of columns that don’t
    need to be referenced in the application, the [`Mapper.include_properties`](mapping_api.html#sqlalchemy.orm.Mapper.params.include_properties
    "sqlalchemy.orm.Mapper") or [`Mapper.exclude_properties`](mapping_api.html#sqlalchemy.orm.Mapper.params.exclude_properties
    "sqlalchemy.orm.Mapper") parameters can indicate a subset of columns to be mapped,
    where other columns from the target [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") will not be considered by the ORM in any way. Example:'
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，表反射可能提供具有许多对我们的需求不重要且可以安全忽略的列的 [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")。对于这样一个具有许多不需要在应用程序中引用的列的表，[`Mapper.include_properties`](mapping_api.html#sqlalchemy.orm.Mapper.params.include_properties
    "sqlalchemy.orm.Mapper") 或 [`Mapper.exclude_properties`](mapping_api.html#sqlalchemy.orm.Mapper.params.exclude_properties
    "sqlalchemy.orm.Mapper") 参数可以指示要映射的列的子集，其中来自目标 [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") 的其他列将不会以任何方式被 ORM 考虑。示例：
- en: '[PRE205]'
  id: totrans-751
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: In the above example, the `User` class will map to the `user_table` table, only
    including the `user_id` and `user_name` columns - the rest are not referenced.
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述示例中，`User` 类将映射到 `user_table` 表，只包括 `user_id` 和 `user_name` 列 - 其余列不会被引用。
- en: 'Similarly:'
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地：
- en: '[PRE206]'
  id: totrans-754
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: will map the `Address` class to the `address_table` table, including all columns
    present except `street`, `city`, `state`, and `zip`.
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `Address` 类映射到 `address_table` 表，包括除 `street`、`city`、`state` 和 `zip` 之外的所有列。
- en: 'As indicated in the two examples, columns may be referenced either by string
    name or by referring to the [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") object directly. Referring to the object directly
    may be useful for explicitness as well as to resolve ambiguities when mapping
    to multi-table constructs that might have repeated names:'
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 如两个示例所示，列可以通过字符串名称或直接引用 [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") 对象来引用。直接引用对象可能有助于明确以及解决映射到可能具有重复名称的多表结构时的歧义：
- en: '[PRE207]'
  id: totrans-757
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: When columns are not included in a mapping, these columns will not be referenced
    in any SELECT statements emitted when executing [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") or legacy [`Query`](queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") objects, nor will there be any mapped attribute on the
    mapped class which represents the column; assigning an attribute of that name
    will have no effect beyond that of a normal Python attribute assignment.
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: 当列没有包含在映射中时，在执行 [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") 或传统的 [`Query`](queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") 对象时，这些列将不会被引用到任何 SELECT 语句中，并且映射类上不会有任何代表该列的映射属性；给定该名称的属性赋值将不会产生任何效果，仅仅是普通的
    Python 属性赋值。
- en: However, it is important to note that **schema level column defaults WILL still
    be in effect** for those [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects that include them, even though they may be
    excluded from the ORM mapping.
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，需要注意的是**模式级列默认值仍然会生效**于那些包含它们的[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")对象，即使它们可能被排除在ORM映射之外。
- en: “Schema level column defaults” refers to the defaults described at [Column INSERT/UPDATE
    Defaults](../core/defaults.html#metadata-defaults) including those configured
    by the [`Column.default`](../core/metadata.html#sqlalchemy.schema.Column.params.default
    "sqlalchemy.schema.Column"), [`Column.onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.onupdate
    "sqlalchemy.schema.Column"), [`Column.server_default`](../core/metadata.html#sqlalchemy.schema.Column.params.server_default
    "sqlalchemy.schema.Column") and [`Column.server_onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.server_onupdate
    "sqlalchemy.schema.Column") parameters. These constructs continue to have normal
    effects because in the case of [`Column.default`](../core/metadata.html#sqlalchemy.schema.Column.params.default
    "sqlalchemy.schema.Column") and [`Column.onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.onupdate
    "sqlalchemy.schema.Column"), the [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") object is still present on the underlying [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table"), thus allowing the default functions to take place
    when the ORM emits an INSERT or UPDATE, and in the case of [`Column.server_default`](../core/metadata.html#sqlalchemy.schema.Column.params.server_default
    "sqlalchemy.schema.Column") and [`Column.server_onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.server_onupdate
    "sqlalchemy.schema.Column"), the relational database itself emits these defaults
    as a server side behavior.
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: “模式级列默认值”指的是在[列插入/更新默认值](../core/defaults.html#metadata-defaults)中描述的默认值，包括由[`Column.default`](../core/metadata.html#sqlalchemy.schema.Column.params.default
    "sqlalchemy.schema.Column")、[`Column.onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.onupdate
    "sqlalchemy.schema.Column")、[`Column.server_default`](../core/metadata.html#sqlalchemy.schema.Column.params.server_default
    "sqlalchemy.schema.Column")和[`Column.server_onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.server_onupdate
    "sqlalchemy.schema.Column")参数配置的默认值。这些构造继续具有正常的效果，因为在[`Column.default`](../core/metadata.html#sqlalchemy.schema.Column.params.default
    "sqlalchemy.schema.Column")和[`Column.onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.onupdate
    "sqlalchemy.schema.Column")的情况下，[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")对象仍然存在于底层的[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")上，因此在ORM发出INSERT或UPDATE时允许默认函数发生作用，而在[`Column.server_default`](../core/metadata.html#sqlalchemy.schema.Column.params.server_default
    "sqlalchemy.schema.Column")和[`Column.server_onupdate`](../core/metadata.html#sqlalchemy.schema.Column.params.server_onupdate
    "sqlalchemy.schema.Column")的情况下，关系数据库本身将这些默认值作为服务器端行为发出。
