- en: 🔪 JAX - The Sharp Bits 🔪
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 🔪 JAX - 锋利的部分 🔪
- en: 原文：[`jax.readthedocs.io/en/latest/notebooks/Common_Gotchas_in_JAX.html`](https://jax.readthedocs.io/en/latest/notebooks/Common_Gotchas_in_JAX.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[`jax.readthedocs.io/en/latest/notebooks/Common_Gotchas_in_JAX.html`](https://jax.readthedocs.io/en/latest/notebooks/Common_Gotchas_in_JAX.html)
- en: '![Open in Colab](https://colab.research.google.com/github/google/jax/blob/main/docs/notebooks/Common_Gotchas_in_JAX.ipynb)
    ![Open in Kaggle](https://kaggle.com/kernels/welcome?src=https://github.com/google/jax/blob/main/docs/notebooks/Common_Gotchas_in_JAX.ipynb)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![在 Colab 中打开](https://colab.research.google.com/github/google/jax/blob/main/docs/notebooks/Common_Gotchas_in_JAX.ipynb)
    ![在 Kaggle 中打开](https://kaggle.com/kernels/welcome?src=https://github.com/google/jax/blob/main/docs/notebooks/Common_Gotchas_in_JAX.ipynb)'
- en: '*levskaya@ mattjj@*'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*levskaya@ mattjj@*'
- en: When walking about the countryside of Italy, the people will not hesitate to
    tell you that **JAX** has [*“una anima di pura programmazione funzionale”*](https://www.sscardapane.it/iaml-backup/jax-intro/).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在意大利乡间漫步时，人们会毫不犹豫地告诉您，**JAX** 具有 [*“una anima di pura programmazione funzionale”*](https://www.sscardapane.it/iaml-backup/jax-intro/)。
- en: '**JAX** is a language for **expressing** and **composing** **transformations**
    of numerical programs. **JAX** is also able to **compile** numerical programs
    for CPU or accelerators (GPU/TPU). JAX works great for many numerical and scientific
    programs, but **only if they are written with certain constraints** that we describe
    below.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '**JAX** 是一种用于表达和组合数值程序转换的语言。**JAX** 还能够为 CPU 或加速器（GPU/TPU）**编译**数值程序。对于许多数值和科学程序，JAX
    表现出色，但前提是它们必须按照我们下面描述的某些约束条件编写。'
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 🔪 Pure functions
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 🔪 纯函数
- en: 'JAX transformation and compilation are designed to work only on Python functions
    that are functionally pure: all the input data is passed through the function
    parameters, all the results are output through the function results. A pure function
    will always return the same result if invoked with the same inputs.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: JAX 的转换和编译设计仅适用于函数式纯的 Python 函数：所有输入数据通过函数参数传递，所有结果通过函数结果输出。纯函数如果以相同的输入调用，将始终返回相同的结果。
- en: Here are some examples of functions that are not functionally pure for which
    JAX behaves differently than the Python interpreter. Note that these behaviors
    are not guaranteed by the JAX system; the proper way to use JAX is to use it only
    on functionally pure Python functions.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些函数示例，这些函数不是函数式纯的，因此 JAX 的行为与 Python 解释器不同。请注意，这些行为并不由 JAX 系统保证；正确使用 JAX
    的方法是仅在函数式纯 Python 函数上使用它。
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'A Python function can be functionally pure even if it actually uses stateful
    objects internally, as long as it does not read or write external state:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 即使一个 Python 函数在内部实际上使用了有状态的对象，只要它不读取或写入外部状态，它就可以是函数式纯的：
- en: '[PRE7]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: It is not recommended to use iterators in any JAX function you want to `jit`
    or in any control-flow primitive. The reason is that an iterator is a python object
    which introduces state to retrieve the next element. Therefore, it is incompatible
    with JAX functional programming model. In the code below, there are some examples
    of incorrect attempts to use iterators with JAX. Most of them return an error,
    but some give unexpected results.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 不建议在希望`jit`的任何 JAX 函数中使用迭代器或任何控制流原语。原因是迭代器是一个引入状态以检索下一个元素的 Python 对象。因此，它与 JAX
    的函数式编程模型不兼容。在下面的代码中，有一些尝试在 JAX 中使用迭代器的错误示例。其中大多数会返回错误，但有些会给出意外的结果。
- en: '[PRE9]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 🔪 In-Place Updates
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 🔪 原地更新
- en: 'In Numpy you’re used to doing this:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Numpy 中，您习惯于执行以下操作：
- en: '[PRE11]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If we try to update a JAX device array in-place, however, we get an **error**!
    (☉_☉)
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们尝试在 JAX 设备数组上就地更新，我们会收到**错误**！(☉_☉)
- en: '[PRE13]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Allowing mutation of variables in-place makes program analysis and transformation
    difficult. JAX requires that programs are pure functions.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 允许变量在原地变异会使程序分析和转换变得困难。JAX 要求程序是纯函数。
- en: Instead, JAX offers a *functional* array update using the [`.at` property on
    JAX arrays](https://jax.readthedocs.io/en/latest/_autosummary/jax.numpy.ndarray.at.html#jax.numpy.ndarray.at).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，JAX 提供了对 JAX 数组上的 [`.at` 属性进行函数式数组更新](https://jax.readthedocs.io/en/latest/_autosummary/jax.numpy.ndarray.at.html#jax.numpy.ndarray.at)。
- en: ️⚠️ inside `jit`’d code and `lax.while_loop` or `lax.fori_loop` the **size**
    of slices can’t be functions of argument *values* but only functions of argument
    *shapes* – the slice start indices have no such restriction. See the below **Control
    Flow** Section for more information on this limitation.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: ️⚠️ 在 `jit` 的代码中和 `lax.while_loop` 或 `lax.fori_loop` 中，**切片的大小**不能是参数 *值* 的函数，而只能是参数
    *形状* 的函数 — 切片的起始索引没有此类限制。有关此限制的更多信息，请参阅下面的 **控制流** 部分。
- en: 'Array updates: `x.at[idx].set(y)`'
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数组更新：`x.at[idx].set(y)`
- en: 'For example, the update above can be written as:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，上述更新可以写成：
- en: '[PRE17]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: JAX’s array update functions, unlike their NumPy versions, operate out-of-place.
    That is, the updated array is returned as a new array and the original array is
    not modified by the update.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: JAX的数组更新函数与其NumPy版本不同，是在**原地**外执行的。也就是说，更新后的数组作为新数组返回，原始数组不会被更新修改。
- en: '[PRE19]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: However, inside **jit**-compiled code, if the **input value** `x` of `x.at[idx].set(y)`
    is not reused, the compiler will optimize the array update to occur *in-place*.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在**jit**编译的代码内部，如果`x.at[idx].set(y)`的**输入值** `x` 没有被重用，编译器会优化数组更新以进行*原地*操作。
- en: Array updates with other operations
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用其他操作的数组更新
- en: 'Indexed array updates are not limited simply to overwriting values. For example,
    we can perform indexed addition as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 索引数组更新不仅限于覆盖值。例如，我们可以进行索引加法如下：
- en: '[PRE21]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: For more details on indexed array updates, see the [documentation for the `.at`
    property](https://jax.readthedocs.io/en/latest/_autosummary/jax.numpy.ndarray.at.html#jax.numpy.ndarray.at).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 有关索引数组更新的更多详细信息，请参阅[`.at`属性的文档](https://jax.readthedocs.io/en/latest/_autosummary/jax.numpy.ndarray.at.html#jax.numpy.ndarray.at)。
- en: 🔪 Out-of-Bounds Indexing
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 🔪 超出边界索引
- en: 'In Numpy, you are used to errors being thrown when you index an array outside
    of its bounds, like this:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在NumPy中，当您索引数组超出其边界时，通常会抛出错误，例如：
- en: '[PRE23]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'However, raising an error from code running on an accelerator can be difficult
    or impossible. Therefore, JAX must choose some non-error behavior for out of bounds
    indexing (akin to how invalid floating point arithmetic results in `NaN`). When
    the indexing operation is an array index update (e.g. `index_add` or `scatter`-like
    primitives), updates at out-of-bounds indices will be skipped; when the operation
    is an array index retrieval (e.g. NumPy indexing or `gather`-like primitives)
    the index is clamped to the bounds of the array since **something** must be returned.
    For example, the last value of the array will be returned from this indexing operation:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在加速器上运行的代码中引发错误可能会很困难或不可能。因此，JAX必须为超出边界的索引选择一些非错误行为（类似于无效的浮点算术结果为`NaN`的情况）。当索引操作是数组索引更新时（例如`index_add`或类似的原语），将跳过超出边界的索引；当操作是数组索引检索时（例如NumPy索引或类似的原语），索引将夹紧到数组的边界，因为必须返回**某些内容**。例如，数组的最后一个值将从此索引操作中返回：
- en: '[PRE25]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If you would like finer-grained control over the behavior for out-of-bound
    indices, you can use the optional parameters of [`ndarray.at`](https://jax.readthedocs.io/en/latest/_autosummary/jax.numpy.ndarray.at.html);
    for example:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望对超出边界索引的行为有更精细的控制，可以使用[`ndarray.at`](https://jax.readthedocs.io/en/latest/_autosummary/jax.numpy.ndarray.at.html)的可选参数；例如：
- en: '[PRE27]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note that due to this behavior for index retrieval, functions like `jnp.nanargmin`
    and `jnp.nanargmax` return -1 for slices consisting of NaNs whereas Numpy would
    throw an error.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 注意由于这种索引检索行为，像`jnp.nanargmin`和`jnp.nanargmax`这样的函数在由NaN组成的切片中返回-1，而NumPy会抛出错误。
- en: Note also that, as the two behaviors described above are not inverses of each
    other, reverse-mode automatic differentiation (which turns index updates into
    index retrievals and vice versa) [will not preserve the semantics of out of bounds
    indexing](https://github.com/google/jax/issues/5760). Thus it may be a good idea
    to think of out-of-bounds indexing in JAX as a case of [undefined behavior](https://en.wikipedia.org/wiki/Undefined_behavior).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 还请注意，由于上述两种行为不是互为反操作，反向模式自动微分（将索引更新转换为索引检索及其反之）[将不会保留超出边界索引的语义](https://github.com/google/jax/issues/5760)。因此，将JAX中的超出边界索引视为[未定义行为](https://en.wikipedia.org/wiki/Undefined_behavior)可能是个好主意。
- en: '🔪 Non-array inputs: NumPy vs. JAX'
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 🔪 非数组输入：NumPy vs. JAX
- en: 'NumPy is generally happy accepting Python lists or tuples as inputs to its
    API functions:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: NumPy通常可以接受Python列表或元组作为其API函数的输入：
- en: '[PRE31]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'JAX departs from this, generally returning a helpful error:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: JAX在这方面有所不同，通常会返回有用的错误：
- en: '[PRE33]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This is a deliberate design choice, because passing lists or tuples to traced
    functions can lead to silent performance degradation that might otherwise be difficult
    to detect.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个有意的设计选择，因为向追踪函数传递列表或元组可能导致性能下降，而这种性能下降可能很难检测到。
- en: 'For example, consider the following permissive version of `jnp.sum` that allows
    list inputs:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，请考虑允许列表输入的`jnp.sum`的以下宽松版本：
- en: '[PRE35]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The output is what we would expect, but this hides potential performance issues
    under the hood. In JAX’s tracing and JIT compilation model, each element in a
    Python list or tuple is treated as a separate JAX variable, and individually processed
    and pushed to device. This can be seen in the jaxpr for the `permissive_sum` function
    above:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 输出与预期相符，但这隐藏了底层的潜在性能问题。在JAX的追踪和JIT编译模型中，Python列表或元组中的每个元素都被视为单独的JAX变量，并分别处理和推送到设备。这可以在上面的`permissive_sum`函数的jaxpr中看到：
- en: '[PRE37]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Each entry of the list is handled as a separate input, resulting in a tracing
    & compilation overhead that grows linearly with the size of the list. To prevent
    surprises like this, JAX avoids implicit conversions of lists and tuples to arrays.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 列表的每个条目都作为单独的输入处理，导致追踪和编译开销随列表大小线性增长。为了避免这样的意外，JAX避免将列表和元组隐式转换为数组。
- en: 'If you would like to pass a tuple or list to a JAX function, you can do so
    by first explicitly converting it to an array:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望将元组或列表传递给JAX函数，可以首先显式地将其转换为数组：
- en: '[PRE39]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 🔪 Random Numbers
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 🔪 随机数
- en: '*If all scientific papers whose results are in doubt because of bad `rand()`s
    were to disappear from library shelves, there would be a gap on each shelf about
    as big as your fist.* - Numerical Recipes'
  id: totrans-80
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*如果所有因糟糕的`rand()`而存疑的科学论文都从图书馆书架上消失，每个书架上会有一个拳头大小的空白。* - Numerical Recipes'
- en: RNGs and State
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: RNG和状态
- en: 'You’re used to *stateful* pseudorandom number generators (PRNGs) from numpy
    and other libraries, which helpfully hide a lot of details under the hood to give
    you a ready fountain of pseudorandomness:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 您习惯于从numpy和其他库中使用*有状态的*伪随机数生成器（PRNG），这些库在幕后巧妙地隐藏了许多细节，为您提供了伪随机性的丰富源泉：
- en: '[PRE41]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Underneath the hood, numpy uses the [Mersenne Twister](https://en.wikipedia.org/wiki/Mersenne_Twister)
    PRNG to power its pseudorandom functions. The PRNG has a period of \(2^{19937}-1\)
    and at any point can be described by **624 32-bit unsigned ints** and a **position**
    indicating how much of this “entropy” has been used up.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在底层，numpy使用[Mersenne Twister](https://en.wikipedia.org/wiki/Mersenne_Twister)
    PRNG来驱动其伪随机函数。该PRNG具有\(2^{19937}-1\)的周期，并且在任何时候可以由**624个32位无符号整数**和一个表示已使用的“熵”量的**位置**来描述。
- en: '[PRE43]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This pseudorandom state vector is automagically updated behind the scenes every
    time a random number is needed, “consuming” 2 of the uint32s in the Mersenne twister
    state vector:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这个伪随机状态向量在每次需要随机数时都会在幕后自动更新，“消耗”Mersenne Twister状态向量中的2个uint32：
- en: '[PRE44]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The problem with magic PRNG state is that it’s hard to reason about how it’s
    being used and updated across different threads, processes, and devices, and it’s
    *very easy* to screw up when the details of entropy production and consumption
    are hidden from the end user.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 魔法PRNG状态的问题在于很难推断它在不同线程、进程和设备中的使用和更新方式，并且在熵的生成和消耗细节对最终用户隐藏时，*非常容易*出错。
- en: The Mersenne Twister PRNG is also known to have a [number](https://cs.stackexchange.com/a/53475)
    of problems, it has a large 2.5kB state size, which leads to problematic [initialization
    issues](https://dl.acm.org/citation.cfm?id=1276928). It [fails](http://www.pcg-random.org/pdf/toms-oneill-pcg-family-v1.02.pdf)
    modern BigCrush tests, and is generally slow.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Mersenne Twister PRNG也被认为存在[一些问题](https://cs.stackexchange.com/a/53475)，它具有较大的2.5kB状态大小，导致初始化问题[很多](https://dl.acm.org/citation.cfm?id=1276928)。它在现代的BigCrush测试中[失败](http://www.pcg-random.org/pdf/toms-oneill-pcg-family-v1.02.pdf)，并且通常速度较慢。
- en: JAX PRNG
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JAX PRNG
- en: JAX instead implements an *explicit* PRNG where entropy production and consumption
    are handled by explicitly passing and iterating PRNG state. JAX uses a modern
    [Threefry counter-based PRNG](https://github.com/google/jax/blob/main/docs/jep/263-prng.md)
    that’s **splittable**. That is, its design allows us to **fork** the PRNG state
    into new PRNGs for use with parallel stochastic generation.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，JAX实现了一个*显式的*PRNG，其中熵的生成和消耗通过显式传递和迭代PRNG状态来处理。JAX使用一种现代化的[Threefry基于计数器的PRNG](https://github.com/google/jax/blob/main/docs/jep/263-prng.md)，它是**可分裂**的。也就是说，其设计允许我们将PRNG状态分叉成新的PRNG，以用于并行随机生成。
- en: 'The random state is described by a special array element that we call a **key**:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 随机状态由一个我们称之为**密钥**的特殊数组元素描述：
- en: '[PRE45]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: JAX’s random functions produce pseudorandom numbers from the PRNG state, but
    **do not** change the state!
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: JAX的随机函数从PRNG状态生成伪随机数，但**不会**改变状态！
- en: 'Reusing the same state will cause **sadness** and **monotony**, depriving the
    end user of **lifegiving chaos**:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 复用相同的状态会导致**悲伤**和**单调**，剥夺最终用户**生命力的混乱**：
- en: '[PRE47]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Instead, we **split** the PRNG to get usable **subkeys** every time we need
    a new pseudorandom number:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们**分割**PRNG以在每次需要新的伪随机数时获得可用的**子密钥**：
- en: '[PRE49]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We propagate the **key** and make new **subkeys** whenever we need a new random
    number:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传播**密钥**并在需要新的随机数时生成新的**子密钥**：
- en: '[PRE51]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'We can generate more than one **subkey** at a time:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以同时生成多个**子密钥**：
- en: '[PRE53]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 🔪 Control Flow
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 🔪 控制流
- en: ✔ python control_flow + autodiff ✔
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ✔ python控制流 + 自动微分 ✔
- en: If you just want to apply `grad` to your python functions, you can use regular
    python control-flow constructs with no problems, as if you were using [Autograd](https://github.com/hips/autograd)
    (or Pytorch or TF Eager).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您只想将`grad`应用于您的Python函数，可以使用常规的Python控制流结构，没有问题，就像使用[Autograd](https://github.com/hips/autograd)（或Pytorch或TF
    Eager）一样。
- en: '[PRE55]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: python control flow + JIT
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: python控制流 + JIT
- en: Using control flow with `jit` is more complicated, and by default it has more
    constraints.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`jit`进行控制流更为复杂，默认情况下具有更多约束。
- en: 'This works:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这个可以工作：
- en: '[PRE57]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'So does this:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这样也可以：
- en: '[PRE59]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'But this doesn’t, at least by default:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 但默认情况下，这样不行：
- en: '[PRE61]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '**What gives!?**'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**怎么回事！？**'
- en: When we `jit`-compile a function, we usually want to compile a version of the
    function that works for many different argument values, so that we can cache and
    reuse the compiled code. That way we don’t have to re-compile on each function
    evaluation.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们`jit`编译一个函数时，通常希望编译一个适用于许多不同参数值的函数版本，以便我们可以缓存和重复使用编译代码。这样我们就不必在每次函数评估时重新编译。
- en: For example, if we evaluate an `@jit` function on the array `jnp.array([1.,
    2., 3.], jnp.float32)`, we might want to compile code that we can reuse to evaluate
    the function on `jnp.array([4., 5., 6.], jnp.float32)` to save on compile time.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们在数组`jnp.array([1., 2., 3.], jnp.float32)`上评估`@jit`函数，我们可能希望编译代码，以便我们可以重复使用它来在`jnp.array([4.,
    5., 6.], jnp.float32)`上评估函数，从而节省编译时间。
- en: To get a view of your Python code that is valid for many different argument
    values, JAX traces it on *abstract values* that represent sets of possible inputs.
    There are [multiple different levels of abstraction](https://github.com/google/jax/blob/main/jax/_src/abstract_arrays.py),
    and different transformations use different abstraction levels.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看适用于许多不同参数值的Python代码视图，JAX会跟踪*抽象值*，这些抽象值表示可能输入集合的集合。有关不同的转换使用不同的抽象级别，详见[多个不同的抽象级别](https://github.com/google/jax/blob/main/jax/_src/abstract_arrays.py)。
- en: By default, `jit` traces your code on the `ShapedArray` abstraction level, where
    each abstract value represents the set of all array values with a fixed shape
    and dtype. For example, if we trace using the abstract value `ShapedArray((3,),
    jnp.float32)`, we get a view of the function that can be reused for any concrete
    value in the corresponding set of arrays. That means we can save on compile time.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`jit`会在`ShapedArray`抽象级别上跟踪您的代码，其中每个抽象值表示具有固定形状和dtype的所有数组值的集合。例如，如果我们使用抽象值`ShapedArray((3,),
    jnp.float32)`进行跟踪，我们会得到可以重复使用于相应数组集合中的任何具体值的函数视图。这意味着我们可以节省编译时间。
- en: 'But there’s a tradeoff here: if we trace a Python function on a `ShapedArray((),
    jnp.float32)` that isn’t committed to a specific concrete value, when we hit a
    line like `if x < 3`, the expression `x < 3` evaluates to an abstract `ShapedArray((),
    jnp.bool_)` that represents the set `{True, False}`. When Python attempts to coerce
    that to a concrete `True` or `False`, we get an error: we don’t know which branch
    to take, and can’t continue tracing! The tradeoff is that with higher levels of
    abstraction we gain a more general view of the Python code (and thus save on re-compilations),
    but we require more constraints on the Python code to complete the trace.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 但这里有一个权衡：如果我们在`ShapedArray((), jnp.float32)`上跟踪Python函数，它不专注于具体值，当我们遇到像`if x
    < 3`这样的行时，表达式`x < 3`会评估为表示集合`{True, False}`的抽象`ShapedArray((), jnp.bool_)`。当Python尝试将其强制转换为具体的`True`或`False`时，我们会收到错误：我们不知道应该选择哪个分支，无法继续跟踪！权衡是，使用更高级别的抽象，我们获得Python代码的更一般视图（因此节省重新编译的时间），但我们需要更多约束来完成跟踪。
- en: 'The good news is that you can control this tradeoff yourself. By having `jit`
    trace on more refined abstract values, you can relax the traceability constraints.
    For example, using the `static_argnums` argument to `jit`, we can specify to trace
    on concrete values of some arguments. Here’s that example function again:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，您可以自行控制这种权衡。通过启用`jit`对更精细的抽象值进行跟踪，您可以放宽跟踪约束。例如，使用`jit`的`static_argnums`参数，我们可以指定在某些参数的具体值上进行跟踪。下面是这个例子函数：
- en: '[PRE63]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Here’s another example, this time involving a loop:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是另一个例子，这次涉及循环：
- en: '[PRE65]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: In effect, the loop gets statically unrolled. JAX can also trace at *higher*
    levels of abstraction, like `Unshaped`, but that’s not currently the default for
    any transformation
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，循环被静态展开。JAX 也可以在更高的抽象级别进行追踪，比如 `Unshaped`，但目前对于任何变换来说这都不是默认的。
- en: ️⚠️ **functions with argument-**value** dependent shapes**
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: ️⚠️ **具有参数-值相关形状的函数**
- en: 'These control-flow issues also come up in a more subtle way: numerical functions
    we want to **jit** can’t specialize the shapes of internal arrays on argument
    *values* (specializing on argument **shapes** is ok). As a trivial example, let’s
    make a function whose output happens to depend on the input variable `length`.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这些控制流问题也以更微妙的方式出现：我们希望 **jit** 的数值函数不能根据参数 *值* 来特化内部数组的形状（在参数 **形状** 上特化是可以的）。举个简单的例子，让我们创建一个函数，其输出恰好依赖于输入变量
    `length`。
- en: '[PRE67]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '`static_argnums` can be handy if `length` in our example rarely changes, but
    it would be disastrous if it changed a lot!'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在我们的示例中 `length` 很少更改，那么 `static_argnums` 就会很方便，但如果它经常更改，那将是灾难性的！
- en: 'Lastly, if your function has global side-effects, JAX’s tracer can cause weird
    things to happen. A common gotcha is trying to print arrays inside **jit**’d functions:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果您的函数具有全局副作用，JAX 的追踪器可能会导致一些奇怪的事情发生。一个常见的坑是尝试在 **jit** 函数中打印数组：
- en: '[PRE73]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Structured control flow primitives
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结构化控制流原语
- en: 'There are more options for control flow in JAX. Say you want to avoid re-compilations
    but still want to use control flow that’s traceable, and that avoids un-rolling
    large loops. Then you can use these 4 structured control flow primitives:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: JAX 中有更多控制流选项。假设您想避免重新编译但仍想使用可追踪的控制流，并避免展开大循环。那么您可以使用这四个结构化的控制流原语：
- en: '`lax.cond` *differentiable*'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lax.cond` *可微分*'
- en: '`lax.while_loop` **fwd-mode-differentiable**'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lax.while_loop` **前向模式可微分**'
- en: '`lax.fori_loop` **fwd-mode-differentiable** in general; **fwd and rev-mode
    differentiable** if endpoints are static.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lax.fori_loop` **前向模式可微分**；如果端点是静态的，则**前向和反向模式均可微分**。'
- en: '`lax.scan` *differentiable*'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lax.scan` *可微分*'
- en: '`cond`'
  id: totrans-157
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`cond`'
- en: 'python equivalent:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: python 等效：
- en: '[PRE76]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '`jax.lax` provides two other functions that allow branching on dynamic predicates:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`jax.lax` 还提供了另外两个函数，允许根据动态谓词进行分支：'
- en: '[`lax.select`](https://jax.readthedocs.io/en/latest/_autosummary/jax.lax.select.html)
    is like a batched version of `lax.cond`, with the choices expressed as pre-computed
    arrays rather than as functions.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`lax.select`](https://jax.readthedocs.io/en/latest/_autosummary/jax.lax.select.html)
    类似于 `lax.cond` 的批处理版本，选择项表达为预先计算的数组而不是函数。'
- en: '[`lax.switch`](https://jax.readthedocs.io/en/latest/_autosummary/jax.lax.switch.html)
    is like `lax.cond`, but allows switching between any number of callable choices.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`lax.switch`](https://jax.readthedocs.io/en/latest/_autosummary/jax.lax.switch.html)
    类似于 `lax.cond`，但允许在任意数量的可调用选项之间进行切换。'
- en: 'In addition, `jax.numpy` provides several numpy-style interfaces to these functions:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，`jax.numpy` 提供了几个 numpy 风格的接口：
- en: '[`jnp.where`](https://jax.readthedocs.io/en/latest/_autosummary/jax.numpy.where.html)
    with three arguments is the numpy-style wrapper of `lax.select`.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`jnp.where`](https://jax.readthedocs.io/en/latest/_autosummary/jax.numpy.where.html)
    的三个参数是 `lax.select` 的 numpy 风格封装。'
- en: '[`jnp.piecewise`](https://jax.readthedocs.io/en/latest/_autosummary/jax.numpy.piecewise.html)
    is a numpy-style wrapper of `lax.switch`, but switches on a list of boolean conditions
    rather than a single scalar index.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`jnp.piecewise`](https://jax.readthedocs.io/en/latest/_autosummary/jax.numpy.piecewise.html)
    是 `lax.switch` 的 numpy 风格封装，但是根据一系列布尔条件而不是单个标量索引进行切换。'
- en: '[`jnp.select`](https://jax.readthedocs.io/en/latest/_autosummary/jax.numpy.select.html)
    has an API similar to `jnp.piecewise`, but the choices are given as pre-computed
    arrays rather than as functions. It is implemented in terms of multiple calls
    to `lax.select`.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`jnp.select`](https://jax.readthedocs.io/en/latest/_autosummary/jax.numpy.select.html)
    的 API 类似于 `jnp.piecewise`，但选择项是作为预先计算的数组而不是函数给出的。它是基于多次调用 `lax.select` 实现的。'
- en: '`while_loop`'
  id: totrans-169
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`while_loop`'
- en: 'python equivalent:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: python 等效：
- en: '[PRE79]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '`fori_loop`'
  id: totrans-174
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`fori_loop`'
- en: 'python equivalent:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: python 等效：
- en: '[PRE82]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Summary
  id: totrans-179
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 总结
- en: \[\begin{split} \begin{array} {r|rr} \hline \ \textrm{construct} & \textrm{jit}
    & \textrm{grad} \\ \hline \ \textrm{if} & ❌ & ✔ \\ \textrm{for} & ✔* & ✔\\ \textrm{while}
    & ✔* & ✔\\ \textrm{lax.cond} & ✔ & ✔\\ \textrm{lax.while_loop} & ✔ & \textrm{fwd}\\
    \textrm{lax.fori_loop} & ✔ & \textrm{fwd}\\ \textrm{lax.scan} & ✔ & ✔\\ \hline
    \end{array} \end{split}\]
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: \[\begin{split} \begin{array} {r|rr} \hline \ \textrm{构造} & \textrm{jit} & \textrm{grad}
    \\ \hline \ \textrm{if} & ❌ & ✔ \\ \textrm{for} & ✔* & ✔\\ \textrm{while} & ✔*
    & ✔\\ \textrm{lax.cond} & ✔ & ✔\\ \textrm{lax.while_loop} & ✔ & \textrm{前向}\\
    \textrm{lax.fori_loop} & ✔ & \textrm{前向}\\ \textrm{lax.scan} & ✔ & ✔\\ \hline
    \end{array} \end{split}\]
- en: \(\ast\) = argument-**value**-independent loop condition - unrolls the loop
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: \(\ast\) = 参数-**值**-独立循环条件 - 展开循环
- en: 🔪 Dynamic Shapes
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 🔪 动态形状
- en: 'JAX code used within transforms like `jax.jit`, `jax.vmap`, `jax.grad`, etc.
    requires all output arrays and intermediate arrays to have static shape: that
    is, the shape cannot depend on values within other arrays.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在像`jax.jit`、`jax.vmap`、`jax.grad`等变换中使用的JAX代码要求所有输出数组和中间数组具有静态形状：即形状不能依赖于其他数组中的值。
- en: 'For example, if you were implementing your own version of `jnp.nansum`, you
    might start with something like this:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您正在实现自己的版本`jnp.nansum`，您可能会从以下内容开始：
- en: '[PRE85]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Outside JIT and other transforms, this works as expected:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在JIT和其他转换之外，这可以正常工作：
- en: '[PRE86]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'If you attempt to apply `jax.jit` or another transform to this function, it
    will error:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果尝试将`jax.jit`或另一个转换应用于此函数，则会报错：
- en: '[PRE88]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'The problem is that the size of `x_without_nans` is dependent on the values
    within `x`, which is another way of saying its size is *dynamic*. Often in JAX
    it is possible to work-around the need for dynamically-sized arrays via other
    means. For example, here it is possible to use the three-argument form of `jnp.where`
    to replace the NaN values with zeros, thus computing the same result while avoiding
    dynamic shapes:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于`x_without_nans`的大小取决于`x`中的值，这另一种方式说它的大小是*动态*的。通常在JAX中，可以通过其他方式绕过对动态大小数组的需求。例如，在这里可以使用`jnp.where`的三参数形式，将NaN值替换为零，从而计算出相同的结果，同时避免动态形状：
- en: '[PRE90]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Similar tricks can be played in other situations where dynamically-shaped arrays
    occur.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他情况下，类似的技巧可以发挥作用，其中动态形状数组出现。
- en: 🔪 NaNs
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 🔪 NaNs
- en: Debugging NaNs
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调试NaNs
- en: 'If you want to trace where NaNs are occurring in your functions or gradients,
    you can turn on the NaN-checker by:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要追踪你的函数或梯度中出现NaN的位置，可以通过以下方式打开NaN检查器：
- en: setting the `JAX_DEBUG_NANS=True` environment variable;
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置`JAX_DEBUG_NANS=True`环境变量；
- en: adding `jax.config.update("jax_debug_nans", True)` near the top of your main
    file;
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的主文件顶部添加`jax.config.update("jax_debug_nans", True)`；
- en: adding `jax.config.parse_flags_with_absl()` to your main file, then set the
    option using a command-line flag like `--jax_debug_nans=True`;
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在你的主文件中添加`jax.config.parse_flags_with_absl()`，然后使用命令行标志设置选项，如`--jax_debug_nans=True`；
- en: This will cause computations to error-out immediately on production of a NaN.
    Switching this option on adds a nan check to every floating point type value produced
    by XLA. That means values are pulled back to the host and checked as ndarrays
    for every primitive operation not under an `@jit`. For code under an `@jit`, the
    output of every `@jit` function is checked and if a nan is present it will re-run
    the function in de-optimized op-by-op mode, effectively removing one level of
    `@jit` at a time.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致NaN产生时立即终止计算。打开此选项会在由XLA产生的每个浮点类型值上添加NaN检查。这意味着对于不在`@jit`下的每个基元操作，值将被拉回主机并作为ndarrays进行检查。对于在`@jit`下的代码，将检查每个`@jit`函数的输出，如果存在NaN，则将以逐个操作的去优化模式重新运行函数，有效地一次移除一个`@jit`级别。
- en: There could be tricky situations that arise, like nans that only occur under
    a `@jit` but don’t get produced in de-optimized mode. In that case you’ll see
    a warning message print out but your code will continue to execute.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会出现棘手的情况，比如只在`@jit`下出现的NaN，但在去优化模式下却不会产生。在这种情况下，你会看到警告消息打印出来，但你的代码将继续执行。
- en: 'If the nans are being produced in the backward pass of a gradient evaluation,
    when an exception is raised several frames up in the stack trace you will be in
    the backward_pass function, which is essentially a simple jaxpr interpreter that
    walks the sequence of primitive operations in reverse. In the example below, we
    started an ipython repl with the command line `env JAX_DEBUG_NANS=True ipython`,
    then ran this:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在梯度评估的反向传递中产生NaNs，当在堆栈跟踪中引发异常时，您将位于backward_pass函数中，这本质上是一个简单的jaxpr解释器，以反向遍历原始操作序列。在下面的示例中，我们使用命令行`env
    JAX_DEBUG_NANS=True ipython`启动了一个ipython repl，然后运行了以下命令：
- en: '[PRE92]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: The nan generated was caught. By running `%debug`, we can get a post-mortem
    debugger. This also works with functions under `@jit`, as the example below shows.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 捕获到生成的NaN。通过运行`%debug`，我们可以获得后期调试器。正如下面的示例所示，这也适用于在`@jit`下的函数。
- en: '[PRE93]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: When this code sees a nan in the output of an `@jit` function, it calls into
    the de-optimized code, so we still get a clear stack trace. And we can run a post-mortem
    debugger with `%debug` to inspect all the values to figure out the error.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 当此代码在 `@jit` 函数的输出中看到 NaN 时，它调用去优化的代码，因此我们仍然可以获得清晰的堆栈跟踪。我们可以使用 `%debug` 运行事后调试器来检查所有值，以找出错误。
- en: ⚠️ You shouldn’t have the NaN-checker on if you’re not debugging, as it can
    introduce lots of device-host round-trips and performance regressions!
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: ⚠️ 如果您不是在调试，就不应该开启 NaN 检查器，因为它可能会导致大量设备主机往返和性能回归！
- en: ⚠️ The NaN-checker doesn’t work with `pmap`. To debug nans in `pmap` code, one
    thing to try is replacing `pmap` with `vmap`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: ⚠️ NaN 检查器在 `pmap` 中不起作用。要调试 `pmap` 代码中的 NaN，可以尝试用 `vmap` 替换 `pmap`。
- en: 🔪 Double (64bit) precision
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 🔪 双精度（64位）
- en: At the moment, JAX by default enforces single-precision numbers to mitigate
    the Numpy API’s tendency to aggressively promote operands to `double`. This is
    the desired behavior for many machine-learning applications, but it may catch
    you by surprise!
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，默认情况下，JAX 强制使用单精度数字，以减少 Numpy API 将操作数过度提升为 `double` 的倾向。这是许多机器学习应用程序的期望行为，但可能会让您感到意外！
- en: '[PRE94]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: To use double-precision numbers, you need to set the `jax_enable_x64` configuration
    variable **at startup**.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用双精度数，您需要在启动时设置 `jax_enable_x64` 配置变量**。
- en: 'There are a few ways to do this:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以做到这一点：
- en: You can enable 64-bit mode by setting the environment variable `JAX_ENABLE_X64=True`.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以通过设置环境变量 `JAX_ENABLE_X64=True` 来启用 64 位模式。
- en: 'You can manually set the `jax_enable_x64` configuration flag at startup:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以在启动时手动设置 `jax_enable_x64` 配置标志：
- en: '[PRE97]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: You can parse command-line flags with `absl.app.run(main)`
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以使用 `absl.app.run(main)` 解析命令行标志
- en: '[PRE98]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: If you want JAX to run absl parsing for you, i.e. you don’t want to do `absl.app.run(main)`,
    you can instead use
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您希望 JAX 为您运行 absl 解析，即您不想执行 `absl.app.run(main)`，您可以改用
- en: '[PRE99]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Note that #2-#4 work for *any* of JAX’s configuration options.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，#2-#4 适用于*任何* JAX 的配置选项。
- en: 'We can then confirm that `x64` mode is enabled:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以确认已启用 `x64` 模式：
- en: '[PRE100]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Caveats
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: ⚠️ XLA doesn’t support 64-bit convolutions on all backends!
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: ⚠️ XLA 不支持所有后端的 64 位卷积！
- en: 🔪 Miscellaneous Divergences from NumPy
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 🔪 NumPy 中的各种分歧
- en: While `jax.numpy` makes every attempt to replicate the behavior of numpy’s API,
    there do exist corner cases where the behaviors differ. Many such cases are discussed
    in detail in the sections above; here we list several other known places where
    the APIs diverge.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `jax.numpy` 尽力复制 numpy API 的行为，但确实存在一些边界情况，其行为有所不同。许多这样的情况在前面的部分中有详细讨论；这里我们列出了几个已知的其他
    API 分歧处。
- en: For binary operations, JAX’s type promotion rules differ somewhat from those
    used by NumPy. See [Type Promotion Semantics](https://jax.readthedocs.io/en/latest/type_promotion.html)
    for more details.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于二进制操作，JAX 的类型提升规则与 NumPy 略有不同。有关更多详细信息，请参阅[类型提升语义](https://jax.readthedocs.io/en/latest/type_promotion.html)。
- en: When performing unsafe type casts (i.e. casts in which the target dtype cannot
    represent the input value), JAX’s behavior may be backend dependent, and in general
    may diverge from NumPy’s behavior. Numpy allows control over the result in these
    scenarios via the `casting` argument (see [`np.ndarray.astype`](https://numpy.org/devdocs/reference/generated/numpy.ndarray.astype.html));
    JAX does not provide any such configuration, instead directly inheriting the behavior
    of [XLA:ConvertElementType](https://www.tensorflow.org/xla/operation_semantics#convertelementtype).
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在执行不安全类型转换（即目标 dtype 不能表示输入值的转换）时，JAX 的行为可能依赖于后端，并且通常可能与 NumPy 的行为不同。NumPy 允许通过
    `casting` 参数（参见[`np.ndarray.astype`](https://numpy.org/devdocs/reference/generated/numpy.ndarray.astype.html)）控制这些情况下的结果；JAX
    不提供任何此类配置，而是直接继承[XLA:ConvertElementType](https://www.tensorflow.org/xla/operation_semantics#convertelementtype)的行为。
- en: 'Here is an example of an unsafe cast with differing results between NumPy and
    JAX:'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是一个示例，显示了在 NumPy 和 JAX 之间存在不同结果的不安全转换：
- en: '[PRE103]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: This sort of mismatch would typically arise when casting extreme values from
    floating to integer types or vice versa.
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这种不匹配通常在将浮点值转换为整数类型或反之时出现极端情况。
- en: Fin.
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 结束。
- en: If something’s not covered here that has caused you weeping and gnashing of
    teeth, please let us know and we’ll extend these introductory *advisos*!
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这里没有涉及到您曾经因之而哭泣和咬牙切齿的问题，请告知我们，我们将扩展这些介绍性*建议*！
