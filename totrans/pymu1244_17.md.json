["```py\n\"\"\"\nDemonstrate the use of multiprocessing with PyMuPDF.\n\nDepending on the  number of CPUs, the document is divided in page ranges.\nEach range is then worked on by one process.\nThe type of work would typically be text extraction or page rendering. Each\nprocess must know where to put its results, because this processing pattern\ndoes not include inter-process communication or data sharing.\n\nCompared to sequential processing, speed improvements in range of 100% (ie.\ntwice as fast) or better can be expected.\n\"\"\"\nfrom __future__ import print_function, division\nimport sys\nimport os\nimport time\nfrom multiprocessing import Pool, cpu_count\nimport pymupdf\n\n# choose a version specific timer function (bytes == str in Python 2)\nmytime = time.clock if str is bytes else time.perf_counter\n\ndef render_page(vector):\n  \"\"\"Render a page range of a document.\n\n Notes:\n The PyMuPDF document cannot be part of the argument, because that\n cannot be pickled. So we are being passed in just its filename.\n This is no performance issue, because we are a separate process and\n need to open the document anyway.\n Any page-specific function can be processed here - rendering is just\n an example - text extraction might be another.\n The work must however be self-contained: no inter-process communication\n or synchronization is possible with this design.\n Care must also be taken with which parameters are contained in the\n argument, because it will be passed in via pickling by the Pool class.\n So any large objects will increase the overall duration.\n Args:\n vector: a list containing required parameters.\n \"\"\"\n    # recreate the arguments\n    idx = vector[0]  # this is the segment number we have to process\n    cpu = vector[1]  # number of CPUs\n    filename = vector[2]  # document filename\n    mat = vector[3]  # the matrix for rendering\n    doc = pymupdf.open(filename)  # open the document\n    num_pages = doc.page_count  # get number of pages\n\n    # pages per segment: make sure that cpu * seg_size >= num_pages!\n    seg_size = int(num_pages / cpu + 1)\n    seg_from = idx * seg_size  # our first page number\n    seg_to = min(seg_from + seg_size, num_pages)  # last page number\n\n    for i in range(seg_from, seg_to):  # work through our page segment\n        page = doc[i]\n        # page.get_text(\"rawdict\")  # use any page-related type of work here, eg\n        pix = page.get_pixmap(alpha=False, matrix=mat)\n        # store away the result somewhere ...\n        # pix.save(\"p-%i.png\" % i)\n    print(\"Processed page numbers %i through %i\" % (seg_from, seg_to - 1))\n\nif __name__ == \"__main__\":\n    t0 = mytime()  # start a timer\n    filename = sys.argv[1]\n    mat = pymupdf.Matrix(0.2, 0.2)  # the rendering matrix: scale down to 20%\n    cpu = cpu_count()\n\n    # make vectors of arguments for the processes\n    vectors = [(i, cpu, filename, mat) for i in range(cpu)]\n    print(\"Starting %i processes for '%s'.\" % (cpu, filename))\n\n    pool = Pool()  # make pool of 'cpu_count()' processes\n    pool.map(render_page, vectors, 1)  # start processes passing each a vector\n\n    t1 = mytime()  # stop the timer\n    print(\"Total time %g seconds\" % round(t1 - t0, 2)) \n```", "```py\n\"\"\"\nCreated on 2019-05-01\n\n@author: yinkaisheng@live.com\n@copyright: 2019 yinkaisheng@live.com\n@license: GNU AFFERO GPL 3.0\n\nDemonstrate the use of multiprocessing with PyMuPDF\n-----------------------------------------------------\nThis example shows some more advanced use of multiprocessing.\nThe main process show a Qt GUI and establishes a 2-way communication with\nanother process, which accesses a supported document.\n\"\"\"\nimport os\nimport sys\nimport time\nimport multiprocessing as mp\nimport queue\nimport pymupdf\n\n''' PyQt and PySide namespace unifier shim\n https://www.pythonguis.com/faq/pyqt6-vs-pyside6/\n simple \"if 'PyQt6' in sys.modules:\" test fails for me, so the more complex pkgutil use\n overkill for most people who might have one or the other, why both?\n'''\n\nfrom pkgutil import iter_modules\n\ndef module_exists(module_name):\n    return module_name in (name for loader, name, ispkg in iter_modules())\n\nif  module_exists(\"PyQt6\"):\n    # PyQt6\n    from PyQt6 import QtGui, QtWidgets, QtCore\n    from PyQt6.QtCore import pyqtSignal as Signal, pyqtSlot as Slot\n    wrapper = \"PyQt6\"\n\nelif module_exists(\"PySide6\"):\n    # PySide6\n    from PySide6 import QtGui, QtWidgets, QtCore\n    from PySide6.QtCore import Signal, Slot\n    wrapper = \"PySide6\"\n\nmy_timer = time.clock if str is bytes else time.perf_counter\n\nclass DocForm(QtWidgets.QWidget):\n    def __init__(self):\n        super().__init__()\n        self.process = None\n        self.queNum = mp.Queue()\n        self.queDoc = mp.Queue()\n        self.page_count = 0\n        self.curPageNum = 0\n        self.lastDir = \"\"\n        self.timerSend = QtCore.QTimer(self)\n        self.timerSend.timeout.connect(self.onTimerSendPageNum)\n        self.timerGet = QtCore.QTimer(self)\n        self.timerGet.timeout.connect(self.onTimerGetPage)\n        self.timerWaiting = QtCore.QTimer(self)\n        self.timerWaiting.timeout.connect(self.onTimerWaiting)\n        self.initUI()\n\n    def initUI(self):\n        vbox = QtWidgets.QVBoxLayout()\n        self.setLayout(vbox)\n\n        hbox = QtWidgets.QHBoxLayout()\n        self.btnOpen = QtWidgets.QPushButton(\"OpenDocument\", self)\n        self.btnOpen.clicked.connect(self.openDoc)\n        hbox.addWidget(self.btnOpen)\n\n        self.btnPlay = QtWidgets.QPushButton(\"PlayDocument\", self)\n        self.btnPlay.clicked.connect(self.playDoc)\n        hbox.addWidget(self.btnPlay)\n\n        self.btnStop = QtWidgets.QPushButton(\"Stop\", self)\n        self.btnStop.clicked.connect(self.stopPlay)\n        hbox.addWidget(self.btnStop)\n\n        self.label = QtWidgets.QLabel(\"0/0\", self)\n        self.label.setFont(QtGui.QFont(\"Verdana\", 20))\n        hbox.addWidget(self.label)\n\n        vbox.addLayout(hbox)\n\n        self.labelImg = QtWidgets.QLabel(\"Document\", self)\n        sizePolicy = QtWidgets.QSizePolicy(\n            QtWidgets.QSizePolicy.Policy.Preferred, QtWidgets.QSizePolicy.Policy.Expanding\n        )\n        self.labelImg.setSizePolicy(sizePolicy)\n        vbox.addWidget(self.labelImg)\n\n        self.setGeometry(100, 100, 400, 600)\n        self.setWindowTitle(\"PyMuPDF Document Player\")\n        self.show()\n\n    def openDoc(self):\n        path, _ = QtWidgets.QFileDialog.getOpenFileName(\n            self,\n            \"Open Document\",\n            self.lastDir,\n            \"All Supported Files (*.pdf;*.epub;*.xps;*.oxps;*.cbz;*.fb2);;PDF Files (*.pdf);;EPUB Files (*.epub);;XPS Files (*.xps);;OpenXPS Files (*.oxps);;CBZ Files (*.cbz);;FB2 Files (*.fb2)\",\n            #options=QtWidgets.QFileDialog.Options(),\n        )\n        if path:\n            self.lastDir, self.file = os.path.split(path)\n            if self.process:\n                self.queNum.put(-1)  # use -1 to notify the process to exit\n            self.timerSend.stop()\n            self.curPageNum = 0\n            self.page_count = 0\n            self.process = mp.Process(\n                target=openDocInProcess, args=(path, self.queNum, self.queDoc)\n            )\n            self.process.start()\n            self.timerGet.start(40)\n            self.label.setText(\"0/0\")\n            self.queNum.put(0)\n            self.startTime = time.perf_counter()\n            self.timerWaiting.start(40)\n\n    def playDoc(self):\n        self.timerSend.start(500)\n\n    def stopPlay(self):\n        self.timerSend.stop()\n\n    def onTimerSendPageNum(self):\n        if self.curPageNum < self.page_count - 1:\n            self.queNum.put(self.curPageNum + 1)\n        else:\n            self.timerSend.stop()\n\n    def onTimerGetPage(self):\n        try:\n            ret = self.queDoc.get(False)\n            if isinstance(ret, int):\n                self.timerWaiting.stop()\n                self.page_count = ret\n                self.label.setText(\"{}/{}\".format(self.curPageNum + 1, self.page_count))\n            else:  # tuple, pixmap info\n                num, samples, width, height, stride, alpha = ret\n                self.curPageNum = num\n                self.label.setText(\"{}/{}\".format(self.curPageNum + 1, self.page_count))\n                fmt = (\n                    QtGui.QImage.Format.Format_RGBA8888\n                    if alpha\n                    else QtGui.QImage.Format.Format_RGB888\n                )\n                qimg = QtGui.QImage(samples, width, height, stride, fmt)\n                self.labelImg.setPixmap(QtGui.QPixmap.fromImage(qimg))\n        except queue.Empty as ex:\n            pass\n\n    def onTimerWaiting(self):\n        self.labelImg.setText(\n            'Loading \"{}\", {:.2f}s'.format(\n                self.file, time.perf_counter() - self.startTime\n            )\n        )\n\n    def closeEvent(self, event):\n        self.queNum.put(-1)\n        event.accept()\n\ndef openDocInProcess(path, queNum, quePageInfo):\n    start = my_timer()\n    doc = pymupdf.open(path)\n    end = my_timer()\n    quePageInfo.put(doc.page_count)\n    while True:\n        num = queNum.get()\n        if num < 0:\n            break\n        page = doc.load_page(num)\n        pix = page.get_pixmap()\n        quePageInfo.put(\n            (num, pix.samples, pix.width, pix.height, pix.stride, pix.alpha)\n        )\n    doc.close()\n    print(\"process exit\")\n\nif __name__ == \"__main__\":\n    app = QtWidgets.QApplication(sys.argv)\n    form = DocForm()\n    sys.exit(app.exec()) \n```"]