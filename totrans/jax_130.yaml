- en: jax.tree_util module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[`jax.readthedocs.io/en/latest/jax.tree_util.html`](https://jax.readthedocs.io/en/latest/jax.tree_util.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Utilities for working with tree-like container data structures.
  prefs: []
  type: TYPE_NORMAL
- en: This module provides a small set of utility functions for working with tree-like
    data structures, such as nested tuples, lists, and dicts. We call these structures
    pytrees. They are trees in that they are defined recursively (any non-pytree is
    a pytree, i.e. a leaf, and any pytree of pytrees is a pytree) and can be operated
    on recursively (object identity equivalence is not preserved by mapping operations,
    and the structures cannot contain reference cycles).
  prefs: []
  type: TYPE_NORMAL
- en: The set of Python types that are considered pytree nodes (e.g. that can be mapped
    over, rather than treated as leaves) is extensible. There is a single module-level
    registry of types, and class hierarchy is ignored. By registering a new pytree
    node type, that type in effect becomes transparent to the utility functions in
    this file.
  prefs: []
  type: TYPE_NORMAL
- en: The primary purpose of this module is to enable the interoperability between
    user defined data structures and JAX transformations (e.g. jit). This is not meant
    to be a general purpose tree-like data structure handling library.
  prefs: []
  type: TYPE_NORMAL
- en: See the JAX pytrees note for examples.
  prefs: []
  type: TYPE_NORMAL
- en: List of Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '| `Partial`(func, *args, **kw) | A version of functools.partial that works
    in pytrees. |'
  prefs: []
  type: TYPE_TB
- en: '| `all_leaves`(iterable[, is_leaf]) | Tests whether all elements in the given
    iterable are all leaves. |'
  prefs: []
  type: TYPE_TB
- en: '| `build_tree`(treedef, xs) | Build a treedef from a nested iterable structure
    |'
  prefs: []
  type: TYPE_TB
- en: '| `register_dataclass`(nodetype, data_fields, ...) | Extends the set of types
    that are considered internal nodes in pytrees. |'
  prefs: []
  type: TYPE_TB
- en: '| `register_pytree_node`(nodetype, flatten_func, ...) | Extends the set of
    types that are considered internal nodes in pytrees. |'
  prefs: []
  type: TYPE_TB
- en: '| `register_pytree_node_class`(cls) | Extends the set of types that are considered
    internal nodes in pytrees. |'
  prefs: []
  type: TYPE_TB
- en: '| `register_pytree_with_keys`(nodetype, ...[, ...]) | Extends the set of types
    that are considered internal nodes in pytrees. |'
  prefs: []
  type: TYPE_TB
- en: '| `register_pytree_with_keys_class`(cls) | Extends the set of types that are
    considered internal nodes in pytrees. |'
  prefs: []
  type: TYPE_TB
- en: '| `register_static`(cls) | Registers cls as a pytree with no leaves. |'
  prefs: []
  type: TYPE_TB
- en: '| `tree_flatten_with_path`(tree[, is_leaf]) | Flattens a pytree like `tree_flatten`,
    but also returns each leaf''s key path. |'
  prefs: []
  type: TYPE_TB
- en: '| `tree_leaves_with_path`(tree[, is_leaf]) | Gets the leaves of a pytree like
    `tree_leaves` and returns each leaf''s key path. |'
  prefs: []
  type: TYPE_TB
- en: '| `tree_map_with_path`(f, tree, *rest[, is_leaf]) | Maps a multi-input function
    over pytree key path and args to produce a new pytree. |'
  prefs: []
  type: TYPE_TB
- en: '| `treedef_children`(treedef) | Return a list of treedefs for immediate children
    |'
  prefs: []
  type: TYPE_TB
- en: '| `treedef_is_leaf`(treedef) | Return True if the treedef represents a leaf.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `treedef_tuple`(treedefs) | Makes a tuple treedef from an iterable of child
    treedefs. |'
  prefs: []
  type: TYPE_TB
- en: '| `keystr`(keys) | Helper to pretty-print a tuple of keys. |'
  prefs: []
  type: TYPE_TB
- en: Legacy APIs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: These APIs are now accessed via `jax.tree`.
  prefs: []
  type: TYPE_NORMAL
- en: '| `tree_all`(tree, *[, is_leaf]) | Alias of `jax.tree.all()`. |'
  prefs: []
  type: TYPE_TB
- en: '| `tree_flatten`(tree[, is_leaf]) | Alias of `jax.tree.flatten()`. |'
  prefs: []
  type: TYPE_TB
- en: '| `tree_leaves`(tree[, is_leaf]) | Alias of `jax.tree.leaves()`. |'
  prefs: []
  type: TYPE_TB
- en: '| `tree_map`(f, tree, *rest[, is_leaf]) | Alias of `jax.tree.map()`. |'
  prefs: []
  type: TYPE_TB
- en: '| `tree_reduce`(function, tree[, initializer, ...]) | Alias of `jax.tree.reduce()`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `tree_structure`(tree[, is_leaf]) | Alias of `jax.tree.structure()`. |'
  prefs: []
  type: TYPE_TB
- en: '| `tree_transpose`(outer_treedef, inner_treedef, ...) | Alias of `jax.tree.transpose()`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `tree_unflatten`(treedef, leaves) | Alias of `jax.tree.unflatten()`. |'
  prefs: []
  type: TYPE_TB
