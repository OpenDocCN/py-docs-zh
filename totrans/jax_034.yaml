- en: Shape polymorphism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[`jax.readthedocs.io/en/latest/export/shape_poly.html`](https://jax.readthedocs.io/en/latest/export/shape_poly.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'When JAX is used in JIT mode, a function will be traced, lowered to StableHLO,
    and compiled for each combination of input types and shapes. After exporting a
    function and deserializing it on another system we don’t have the Python sources
    available anymore, so we cannot re-trace and re-lower it. **Shape polymorphism**
    is a feature of JAX export to allow some exported functions to be used for a whole
    family of input shapes. These functions are traced and lowered once, during exporting,
    and `Exported` object contains the information needed to be able to compile and
    execute the function on many concrete input shapes. We do this by specifying shapes
    that contain dimension variables (symbolic shapes) when exporting, as in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note that such functions are still re-compiled on demand for each concrete input
    shapes they are invoked on. Only the tracing and the lowering are saved.
  prefs: []
  type: TYPE_NORMAL
- en: The `jax.export.symbolic_shape()` is used in the above example to parse a string
    representation of a symbolic shape into dimension expressions objects (of type
    `_DimExpr`) that are usable in place of integer constants to construct shapes.
    The dimension expression objects overload most integer operators, so you can use
    them as you’d use integer constants in most cases. See Computing with dimension
    variables for more details.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, we provide the `jax.export.symbolic_args_specs()` that can be
    used to construct pytrees of `jax.ShapeDtypeStruct` objects based on a polymorphic
    shape specification:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note how the polymorphic shape specification `"a, ..."` contains the placeholder
    `...` to be filled from the concrete shapes of the concrete shapes of the arguments
    `(x, y)`. The placeholder `...` stands for 0 or more dimensions, while the placeholder
    `_` stands for one dimension. The `jax.export.symbolic_args_specs()` supports
    pytrees of arguments, which are used to fill-in the dtypes and any placeholders.
    The function will construct a pytree of argument specifications (`jax.ShapeDtypeStruct`)
    matching the structure of the arguments passed to it. The polymorphic shapes specification
    can be a pytree prefix in cases where one specification should apply to multiple
    arguments, as in the above example. See [how optional parameters are matched to
    arguments](https://jax.readthedocs.io/en/latest/pytrees.html#applying-optional-parameters-to-pytrees).
  prefs: []
  type: TYPE_NORMAL
- en: 'A few examples of shape specifications:'
  prefs: []
  type: TYPE_NORMAL
- en: '`("(b, _, _)", None)` can be used for a function with two arguments, the first
    being a 3D array with a batch leading dimension that should be symbolic. The other
    dimensions for the first argument and the shape of the second argument are specialized
    based on the actual arguments. Note that the same specification would work if
    the first argument is a pytree of 3D arrays, all with the same leading dimension
    but possibly with different trailing dimensions. The value `None` for the second
    arugment means that the argument is not symbolic. Equivalently, one can use `...`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`("(batch, ...)", "(batch,)")` specifies that the two arguments have matching
    leading dimensions, the first argument has rank at least 1, and the second has
    rank 1.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Correctness of shape polymorphism
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We want to trust that the exported program produces the same results as the
    original JAX program when compiled and executed for any applicable concrete shapes.
    More precisely:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For any JAX function `f` and any argument specification `arg_spec` containing
    a symbolic shape, and any concrete argument `arg` whose shape matches `arg_spec`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If the JAX native execution succeeds on the concrete argument: `res = f(arg)`,'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'and if the exporting succeeds with symbolic shapes: `exp = export.export(f)(arg_spec)`,'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'then compiling and running the export will succeed with the same result: `res
    == exp.call(arg)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is crucial to understand that `f(arg)` has the freedom to re-invoke the JAX
    tracing machinery, and in fact it does so for each distinct concrete `arg` shape,
    while the execution of `exp.call(arg)` cannot use JAX tracing anymore (this execution
    may happen in an environment where the source code of `f` is not available).
  prefs: []
  type: TYPE_NORMAL
- en: Ensuring this form of correctness is hard, and in the hardest cases exporting
    fails. The rest of this chapter describes how to handle these failures.
  prefs: []
  type: TYPE_NORMAL
- en: '## Computing with dimension variables'
  prefs: []
  type: TYPE_NORMAL
- en: JAX keeps track of the shapes of all intermediate results. When those shapes
    depend on dimension variables JAX computes them as symbolic dimension expressions
    involving dimension variables. Dimension variables stand for integer values greater
    or equal to 1. The symbolic expressions can represent the result of applying arithmetic
    operators (add, sub, mul, floordiv, mod, including the NumPy variants `np.sum`,
    `np.prod`, etc.) **on dimension expressions and integers** (`int`, `np.int`, or
    anything convertible by `operator.index`). These symbolic dimensions can then
    be used in shape-parameters of JAX primitives and APIs, e.g., in `jnp.reshape`,
    `jnp.arange`, slicing indices, etc.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in the following code to flatten a 2D array, the computation `x.shape[0]
    * x.shape[1]` computes the symbolic dimension `4 * b` as the new shape:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: It is possible to convert dimension expressions explicitly to JAX arrays, with
    `jnp.array(x.shape[0])` or even `jnp.array(x.shape)`. The result of these operations
    can be used as regular JAX arrays, bug cannot be used anymore as dimensions in
    shapes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'When a symbolic dimension is used in arithmetic operations with **non-integers**,
    e.g., `float`, `np.float`, `np.ndarray`, or JAX arrays, it is automatically converted
    to a JAX array using `jnp.array`. For example, in the function below all occurrences
    of `x.shape[0]` are converted implicitly to `jnp.array(x.shape[0])` because they
    are involved in operations with non-integer scalars or with JAX arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Another typical example is when computing averages (observe how `x.shape[0]`
    is automatically turned into a JAX array):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Errors in presence of shape polymorphism
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Most JAX code assumes that the shapes of JAX arrays are tuples of integers,
    but with shape polymorphism some dimensions may be symbolic expressions. This
    can lead to a number of errors. For example, we can have the usual JAX shape check
    errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We can fix the above matmul example by specifying that the argument has shape
    `(v, v)`.
  prefs: []
  type: TYPE_NORMAL
- en: Comparison of symbolic dimensions is partially supported
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Inside JAX there are a number of equality and inequality comparisons involving
    shapes, e.g., for doing shape checking or even for choosing the implementation
    for some primitives. Comparisons are supported as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'equality is supported with a caveat: if the two symbolic dimensions denote
    the same value under all valuations for dimension variables, then equality evaluates
    to `True`, e.g., for `b + b == 2*b`; otherwise the equality evaluates to `False`.
    See below for a discussion of important consequences of this behavior.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: disequality is always the negation of equality.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: inequality is partially supported, in a similar way as partial equality. However,
    in this case we take into consideration that dimension variables range over strictly
    positive integers. E.g., `b >= 1`, `b >= 0`, `2 * a + b >= 3` are `True`, while
    `b >= 2`, `a >= b`, `a - b >= 0` are inconclusive and result in an exception.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In cases where a comparison operation cannot be resolve to a boolean, we raise
    `InconclusiveDimensionOperation`. E.g.,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If you do get a `InconclusiveDimensionOperation`, you can try several strategies:'
  prefs: []
  type: TYPE_NORMAL
- en: If your code uses the built-in `max` or `min`, or the `np.max` or `np.min` then
    you can replace those with `core.max_dim` and `core.min_dim`, which have the effect
    of delaying the inequality comparison to the compilation time, when shapes become
    known.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Try to rewrite conditionals using `core.max_dim` and `core.min_dim`, e.g., instead
    of `d if d > 0 else 0` you can write `core.max_dim(d, 0)`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Try to rewrite the code to be less dependent on the fact that dimensions should
    be integers, and rely on the fact that symbolic dimensions duck-type as integers
    for most arithmetic operations. E.g., instead of `int(d) + 5` write `d + 5`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specify symbolic constraints, as explained below.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User-specified symbolic constraints
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'By default, JAX assumes that all dimension variables range over values greater-or-equal
    to 1, and it tries to derive other simple inequalities from that, e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '`a + 2 >= 3`,'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`a * 2 >= 1`,'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`a + b + c >= 3`,'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`a // 4 >= 0`, `a**2 >= 1`, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can avoid some inequality comparison failures if you change the symbolic
    shape specifications to add **implicit** constraints for dimension sizes. E.g.,
  prefs: []
  type: TYPE_NORMAL
- en: You can use `2*b` for a dimension to constrain it to be even and greater or
    equal to 2.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use `b + 15` for a dimension to constrain it to be at least 16\. E.g.,
    the following code would fail without the `+ 15` part, because JAX will want to
    verify that slice sizes are at most as large as the axis size.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Such implicit symbolic constraints are used for deciding comparisons and are
    checked at compile time, as explained below.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also specify **explicit** symbolic constraints:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The constraints form a conjunction together with the implicit constraints.
    You can specify `>=`, `<=`, and `==` constraints. At the moment, JAX has limited
    support for reasoning with symbolic constraints:'
  prefs: []
  type: TYPE_NORMAL
- en: You get the most from constraints of the form of a variable being greater-or-equal
    or less-or-equal to a constant. For example, from the constraints that `a >= 16`
    and `b >= 8` we can infer that `a + 2*b >= 32`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You get limited power when the constraint involves more complex expressions,
    e.g., from `a >= b + 8` we can infer that `a - b >= 8` but not that `a >= 9`.
    We may improve somewhat this area in the future.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Equality constraints are treated as normalization rules. E.g., `floordiv(a,
    b) = c` works by replacing all occurences of the left-hand-side with the right-hand-side.
    You can only have equality constraints where the left-hand-side is a multiplication
    of factors, e.g, `a * b`, or `4 * a`, or `floordiv(a, b)`. Thus, the left-hand-side
    cannot contain addition or subtraction at the top-level.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The symbolic constraints can also help to work around the limitations in the
    JAX reasoning mechanisms. For example, in the code below JAX will attempt to prove
    that the slice size `x.shape[0] % 3`, which is the symbolic expression `mod(b,
    3)`, is less or equal to the axis size, which is `b`. This happens to be true
    for all strictly positive values of `b`, but it is not something JAX’s symbolic
    comparison rules can prove. Hence the following code raises an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'One option here would be to restrict the code to work only on axis sizes that
    are multiple of `3` (by replacing `b` with `3*b` in the shape). Then, JAX would
    be able to simplify the modulo operation `mod(3*b, 3)` to `0`. Another option
    is to add a symbolic constraint with the exact inconclusive inequality that JAX
    is attempting to prove:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Just like the implicit constraints, the explicit symbolic constraints are checked
    at compile time, using the same mechanism as explained below.
  prefs: []
  type: TYPE_NORMAL
- en: Symbolic dimension scopes
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The symbolic constraints are stored in αn `jax.export.SymbolicScope` object,
    which is created implicitly for each call to `jax.export.symbolic_shapes()`. You
    must be careful to not mix symbolic expressions that use different scopes. For
    example, the following code will fail because `a1` and `a2` use different scopes
    (created by different invocations of `jax.export.symbolic_shape()`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The symbolic expressions that originate from a single call to `jax.export.symbolic_shape()`
    share a scope and can be mixed up in arithmetic operations. The result would also
    share the same scope.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can re-use scopes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also create scopes explicitly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: JAX tracing uses caches keyed partially by shapes, and symbolic shapes that
    are printed identically will be considered distinct if they use different scopes.
  prefs: []
  type: TYPE_NORMAL
- en: Caveat for equality comparisons
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The equality comparison returns `False` for `b + 1 == b` or `b == 0` (in which
    case it is certain that the dimensions are different for all values of the dimension
    variables), but also for `b == 1` and for `a == b`. This is unsound, and we ought
    to raise `core.InconclusiveDimensionOperation` because under some valuations the
    result should be `True` and under other valuations it should be `False`. We choose
    to make equality total thus allowing unsoundness because otherwise we may get
    spurious errors in presence of hash collisions when hashing dimension expressions
    or objects that include them (shapes, `core.AbstractValue`, `core.Jaxpr`). Besides
    the hashing errors, a partial semantics of equality leads to errors for the following
    expressions `b == a or b == b` or `b in [a, b]` even though the error is avoided
    if we change the order of the comparisons.
  prefs: []
  type: TYPE_NORMAL
- en: 'Code of the form `if x.shape[0] != 1: raise NiceErrorMessage` is sound even
    with this treatment of equality, but code of the form `if x.shape[0] != 1: return
    1` is unsound.'
  prefs: []
  type: TYPE_NORMAL
- en: Dimension variables must be solvable from the input shapes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Currently, the only way to pass the values of dimension variables when an exported
    object is invoked is indirectly through the shapes of the array arguments. E.g.,
    the value of `b` can be inferred at the call site from the shape of the first
    argument of type `f32[b]`. This works well for most use cases, and it mirrors
    the calling convention of JIT functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes you may want to export a function parameterized by an integer values
    that determines some shapes in the program. For example, we may want to export
    the function `my_top_k` defined below, parameterized by the value of `k`, which
    determined the shape of the result. The following attempt will lead to an error
    since the dimension variable `k` cannot be derived from the shape of the input
    `x: i32[4, 10]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the future, we may add an additional mechanism to pass the values of dimension
    variables, besides implicitly through the input shapes. Meanwhile, the workaround
    for the above use case is to replace the function parameter `k` with an array
    of shape `(0, k)`, so that `k` can be derived from the input shape of an array.
    The first dimension is 0 to ensure that the whole array is empty and there is
    no performance penalty when we call the exported function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Another situation when you may get an error is when some dimension variables
    do appear in the input shapes, but in a non-linear expression that JAX cannot
    currently solve:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Shape assertion errors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: JAX assumes that dimension variables range over strictly positive integers,
    and this assumption is checked when the code is compiled for concrete input shapes.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, given the symbolic input shape `(b, b, 2*d)`, JAX will generate
    code to check the following assertions when invoked with actual argument `arg`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`arg.shape[0] >= 1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`arg.shape[1] == arg.shape[0]`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`arg.shape[2] % 2 == 0`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`arg.shape[2] // 2 >= 1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, here is the error we get when we call the exported on an argument
    of shape `(3, 3, 5)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: These errors arise in a pre-processing step before the compilation.
  prefs: []
  type: TYPE_NORMAL
- en: Division of symbolic dimensions is partially supported
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: JAX will attempt to simplify division and modulo operations, e.g., `(a * b +
    a) // (b + 1) == a` and `6*a + 4 % 3 == 1`. In particular, JAX will handle the
    cases when either (a) there is no remainder, or (b) the divisor is a constant
    in which case there may be a constant remainder.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the code below results in a division error when trying to compute
    the inferred dimension for a `reshape` operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the following will succeed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
