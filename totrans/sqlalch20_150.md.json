["```py\n    session.query(User.name, func.count(Address.id).label(\"numaddresses\")).join(\n        Address\n    ).group_by(User.name)\n    ```", "```py\n    for row in (\n        session.query(User.name, func.count(Address.id).label(\"numaddresses\"))\n        .join(Address)\n        .group_by(User.name)\n    ):\n        print(\"name\", row.name, \"number\", row.numaddresses)\n    ```", "```py\n    subq = (\n        session.query(Keyword.id.label(\"keyword_id\"))\n        .filter(Keyword.name.in_([\"beans\", \"carrots\"]))\n        .subquery()\n    )\n    recipes = session.query(Recipe).filter(\n        exists()\n        .where(Recipe.id == recipe_keywords.c.recipe_id)\n        .where(recipe_keywords.c.keyword_id == subq.c.keyword_id)\n    )\n    ```", "```py\n    Friend = aliased(Person)\n    session.query(Person, Friend).join((Friend, Person.friends)).all()\n    ```", "```py\n    table = class_mapper(someclass).mapped_table\n    ```", "```py\n    for col in table.c:\n        print(col)\n    ```", "```py\n    table.c.somecolumn\n    ```", "```py\n    mapper(\n        User,\n        users,\n        properties={\"addresses\": relation(Address, order_by=addresses.c.id)},\n        order_by=users.c.id,\n    )\n    ```", "```py\n    \"keywords\": relation(\n        Keyword,\n        secondary=item_keywords,\n        order_by=keywords.c.name,\n        backref=backref(\"items\", order_by=items.c.id),\n    )\n    ```", "```py\n    class MyClass(MyDeclarativeBase):\n        ...\n        \"addresses\": relation(\"Address\", order_by=\"Address.id\")\n    ```", "```py\n    class AdaptOldConvertMethods(object):\n      \"\"\"A mixin which adapts 0.3-style convert_bind_param and\n     convert_result_value methods\n\n     \"\"\"\n\n        def bind_processor(self, dialect):\n            def convert(value):\n                return self.convert_bind_param(value, dialect)\n\n            return convert\n\n        def result_processor(self, dialect):\n            def convert(value):\n                return self.convert_result_value(value, dialect)\n\n            return convert\n\n        def convert_result_value(self, value, dialect):\n            return value\n\n        def convert_bind_param(self, value, dialect):\n            return value\n    ```", "```py\n    class MyType(AdaptOldConvertMethods, TypeEngine): ...\n    ```", "```py\n    dt = datetime.datetime(2008, 6, 27, 12, 0, 0, 125)  # 125 usec\n\n    # old way\n    \"2008-06-27 12:00:00.125\"\n\n    # new way\n    \"2008-06-27 12:00:00.000125\"\n    ```", "```py\n    UPDATE  mytable  SET  somedatecol  =\n      substr(somedatecol,  0,  19)  ||  '.'  ||  substr((substr(somedatecol,  21,  -1)  /  1000000),  3,  -1);\n    ```", "```py\n    from sqlalchemy.databases.sqlite import DateTimeMixin\n\n    DateTimeMixin.__legacy_microseconds__ = True\n    ```", "```py\n    query.options(eagerload_all(User.orders, Order.items, Item.keywords))\n    ```", "```py\n    query.join(\"orders\", \"items\")\n    query.join(User.orders, Order.items)\n    ```", "```py\n    x = session.query(SomeClass).populate_existing().get(7)\n    ```", "```py\n    class MyQuery(Query):\n        def get(self, ident): ...\n\n    session = sessionmaker(query_cls=MyQuery)()\n\n    ad1 = session.query(Address).get(1)\n    ```", "```py\n    from sqlalchemy.orm import aliased\n\n    address_alias = aliased(Address)\n    print(session.query(User, address_alias).join((address_alias, User.addresses)).all())\n    ```", "```py\n    session.query(User.name, func.count(Address.id).label(\"numaddresses\")).join(\n        Address\n    ).group_by(User.name)\n    ```", "```py\n    for row in (\n        session.query(User.name, func.count(Address.id).label(\"numaddresses\"))\n        .join(Address)\n        .group_by(User.name)\n    ):\n        print(\"name\", row.name, \"number\", row.numaddresses)\n    ```", "```py\n    subq = (\n        session.query(Keyword.id.label(\"keyword_id\"))\n        .filter(Keyword.name.in_([\"beans\", \"carrots\"]))\n        .subquery()\n    )\n    recipes = session.query(Recipe).filter(\n        exists()\n        .where(Recipe.id == recipe_keywords.c.recipe_id)\n        .where(recipe_keywords.c.keyword_id == subq.c.keyword_id)\n    )\n    ```", "```py\n    Friend = aliased(Person)\n    session.query(Person, Friend).join((Friend, Person.friends)).all()\n    ```", "```py\n    table = class_mapper(someclass).mapped_table\n    ```", "```py\n    for col in table.c:\n        print(col)\n    ```", "```py\n    table.c.somecolumn\n    ```", "```py\n    mapper(\n        User,\n        users,\n        properties={\"addresses\": relation(Address, order_by=addresses.c.id)},\n        order_by=users.c.id,\n    )\n    ```", "```py\n    \"keywords\": relation(\n        Keyword,\n        secondary=item_keywords,\n        order_by=keywords.c.name,\n        backref=backref(\"items\", order_by=items.c.id),\n    )\n    ```", "```py\n    class MyClass(MyDeclarativeBase):\n        ...\n        \"addresses\": relation(\"Address\", order_by=\"Address.id\")\n    ```", "```py\n    class AdaptOldConvertMethods(object):\n      \"\"\"A mixin which adapts 0.3-style convert_bind_param and\n     convert_result_value methods\n\n     \"\"\"\n\n        def bind_processor(self, dialect):\n            def convert(value):\n                return self.convert_bind_param(value, dialect)\n\n            return convert\n\n        def result_processor(self, dialect):\n            def convert(value):\n                return self.convert_result_value(value, dialect)\n\n            return convert\n\n        def convert_result_value(self, value, dialect):\n            return value\n\n        def convert_bind_param(self, value, dialect):\n            return value\n    ```", "```py\n    class MyType(AdaptOldConvertMethods, TypeEngine): ...\n    ```", "```py\n    dt = datetime.datetime(2008, 6, 27, 12, 0, 0, 125)  # 125 usec\n\n    # old way\n    \"2008-06-27 12:00:00.125\"\n\n    # new way\n    \"2008-06-27 12:00:00.000125\"\n    ```", "```py\n    UPDATE  mytable  SET  somedatecol  =\n      substr(somedatecol,  0,  19)  ||  '.'  ||  substr((substr(somedatecol,  21,  -1)  /  1000000),  3,  -1);\n    ```", "```py\n    from sqlalchemy.databases.sqlite import DateTimeMixin\n\n    DateTimeMixin.__legacy_microseconds__ = True\n    ```", "```py\n    query.options(eagerload_all(User.orders, Order.items, Item.keywords))\n    ```", "```py\n    query.join(\"orders\", \"items\")\n    query.join(User.orders, Order.items)\n    ```", "```py\n    x = session.query(SomeClass).populate_existing().get(7)\n    ```", "```py\n    class MyQuery(Query):\n        def get(self, ident): ...\n\n    session = sessionmaker(query_cls=MyQuery)()\n\n    ad1 = session.query(Address).get(1)\n    ```", "```py\n    from sqlalchemy.orm import aliased\n\n    address_alias = aliased(Address)\n    print(session.query(User, address_alias).join((address_alias, User.addresses)).all())\n    ```"]