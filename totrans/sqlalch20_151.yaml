- en: What’s new in SQLAlchemy 0.4?
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SQLAlchemy 0.4 有什么新东西？
- en: 原文：[https://docs.sqlalchemy.org/en/20/changelog/migration_04.html](https://docs.sqlalchemy.org/en/20/changelog/migration_04.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://docs.sqlalchemy.org/en/20/changelog/migration_04.html](https://docs.sqlalchemy.org/en/20/changelog/migration_04.html)
- en: About this Document
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 关于本文档
- en: This document describes changes between SQLAlchemy version 0.3, last released
    October 14, 2007, and SQLAlchemy version 0.4, last released October 12, 2008.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本文档描述了 SQLAlchemy 版本 0.3（2007 年 10 月 14 日最后发布）与 SQLAlchemy 版本 0.4（2008 年 10
    月 12 日最后发布）之间的变化。
- en: 'Document date: March 21, 2008'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 文档日期：2008 年 3 月 21 日
- en: First Things First
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 先说最重要的事情
- en: 'If you’re using any ORM features, make sure you import from `sqlalchemy.orm`:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用了任何 ORM 特性，请确保从 `sqlalchemy.orm` 中导入：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Secondly, anywhere you used to say `engine=`, `connectable=`, `bind_to=`, `something.engine`,
    `metadata.connect()`, use `bind`:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，您曾经在任何地方使用 `engine=`，`connectable=`，`bind_to=`，`something.engine`，`metadata.connect()`，现在使用
    `bind`：
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Got those ? Good! You’re now (95%) 0.4 compatible. If you’re using 0.3.10, you
    can make these changes immediately; they’ll work there too.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 明白了吗？好！你现在（95%）兼容了 0.4 版本。如果你在使用 0.3.10，你可以立即做出这些更改；它们也会在那里起作用。
- en: Module Imports
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块导入
- en: In 0.3, “`from sqlalchemy import *`” would import all of sqlalchemy’s sub-modules
    into your namespace. Version 0.4 no longer imports sub-modules into the namespace.
    This may mean you need to add extra imports into your code.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在 0.3 版本中，“`from sqlalchemy import *`”会将所有 sqlalchemy 的子模块导入到您的命名空间中。版本 0.4
    不再将子模块导入到命名空间中。这可能意味着您需要在您的代码中添加额外的导入。
- en: 'In 0.3, this code worked:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在 0.3 版本中，这段代码可以工作：
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In 0.4, one must do:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在 0.4 版本中，必须这样做：
- en: '[PRE3]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Object Relational Mapping
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象关系映射
- en: Querying
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查询
- en: New Query API
  id: totrans-19
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 新的查询 API
- en: Query is standardized on the generative interface (old interface is still there,
    just deprecated). While most of the generative interface is available in 0.3,
    the 0.4 Query has the inner guts to match the generative outside, and has a lot
    more tricks. All result narrowing is via `filter()` and `filter_by()`, limiting/offset
    is either through array slices or `limit()`/`offset()`, joining is via `join()`
    and `outerjoin()` (or more manually, through `select_from()` as well as manually-formed
    criteria).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 查询已标准化为生成接口（旧接口仍然存在，只是已弃用）。虽然大多数生成接口在 0.3 版本中都可用，但 0.4 版本的查询具有与生成外部相匹配的内部实质，而且有更多的技巧。所有结果的缩小都通过`filter()`和`filter_by()`进行，限制/偏移要么通过数组切片，要么通过`limit()`/`offset()`进行，连接是通过`join()`和`outerjoin()`（或者更手动地，通过`select_from()`以及手动形成的条件）。
- en: To avoid deprecation warnings, you must make some changes to your 03 code
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免弃用警告，您必须对您的 03 代码进行一些更改
- en: User.query.get_by( **kwargs )
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: User.query.get_by( **kwargs )
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: User.query.select_by( **kwargs )
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: User.query.select_by( **kwargs )
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: User.query.select()
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: User.query.select()
- en: '[PRE6]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: New Property-Based Expression Constructs
  id: totrans-28
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 新的基于属性的表达式构造
- en: 'By far the most palpable difference within the ORM is that you can now construct
    your query criterion using class-based attributes directly. The “.c.” prefix is
    no longer needed when working with mapped classes:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ORM 中最明显的区别是，您现在可以直接使用基于类的属性构造您的查询条件。在使用映射类时，不再需要“`.c.`”前缀：
- en: '[PRE7]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'While simple column-based comparisons are no big deal, the class attributes
    have some new “higher level” constructs available, including what was previously
    only available in `filter_by()`:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然简单的基于列的比较不是什么大问题，但类属性有一些新的“更高级”的构造可用，包括以前只在 `filter_by()` 中可用的内容：
- en: '[PRE8]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `Column` collection remains available on mapped classes in the `.c` attribute.
    Note that property-based expressions are only available with mapped properties
    of mapped classes. `.c` is still used to access columns in regular tables and
    selectable objects produced from SQL Expressions.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 映射类上的`.c`属性中仍然可用 `Column` 集合。请注意，基于属性的表达式仅在映射类的映射属性中可用。`.c`仍然用于访问常规表中的列和从 SQL
    表达式产生的可选择对象中的列。
- en: Automatic Join Aliasing
  id: totrans-34
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 自动连接别名
- en: 'We’ve had join() and outerjoin() for a while now:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有了 join() 和 outerjoin() 一段时间了：
- en: '[PRE9]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now you can alias them:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以给它们起别名了：
- en: '[PRE10]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The above will create two joins from orders->items using aliases. the `filter()`
    call subsequent to each will adjust its table criterion to that of the alias.
    To get at the `Item` objects, use `add_entity()` and target each join with an
    `id`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 以上代码将创建两个别名从 orders->items 的连接。每个连接后的`filter()`调用将其表条件调整为别名的条件。要获取`Item`对象，请使用`add_entity()`，并使用`id`目标每个连接：
- en: '[PRE11]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Returns tuples in the form: `(Order, Item, Item)`.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的元组形式为：`（Order，Item，Item）`。
- en: Self-referential Queries
  id: totrans-42
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 自引用查询
- en: 'So query.join() can make aliases now. What does that give us ? Self-referential
    queries ! Joins can be done without any `Alias` objects:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，query.join() 现在可以创建别名。这给了我们什么？自引用查询！可以在没有任何 `Alias` 对象的情况下进行连接：
- en: '[PRE12]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To add criterion for each table along the way in an aliased join, you can use
    `from_joinpoint` to keep joining against the same line of aliases:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 要为沿途每个表添加条件在别名连接中，您可以使用 `from_joinpoint` 继续针对相同别名行进行连接：
- en: '[PRE13]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`query.populate_existing()`'
  id: totrans-47
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`query.populate_existing()`'
- en: 'The eager version of `query.load()` (or `session.refresh()`). Every instance
    loaded from the query, including all eagerly loaded items, get refreshed immediately
    if already present in the session:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`query.load()` 的贪婪版本（或 `session.refresh()`）。从查询加载的每个实例，包括所有贪婪加载的项目，如果已经存在于会话中，则立即刷新：'
- en: '[PRE14]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Relations
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关系
- en: SQL Clauses Embedded in Updates/Inserts
  id: totrans-51
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 嵌入在更新/插入中的 SQL 子句
- en: 'For inline execution of SQL clauses, embedded right in the UPDATE or INSERT,
    during a `flush()`:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 用于内联执行 SQL 子句，直接嵌入在 `flush()` 期间的 UPDATE 或 INSERT 中：
- en: '[PRE15]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The column-attribute is set up with a deferred loader after the operation, so
    that it issues the SQL to load the new value when you next access.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在操作之后，列属性设置为延迟加载器，以便在下次访问时发出加载新值的 SQL。
- en: Self-referential and Cyclical Eager Loading
  id: totrans-55
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 自引用和循环贪婪加载
- en: 'Since our alias-fu has improved, `relation()` can join along the same table
    *any number of times*; you tell it how deep you want to go. Lets show the self-referential
    `TreeNode` more clearly:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的别名技术已经改进，`relation()` 可以沿着相同的表进行任意次数的连接；您告诉它您想要深入多深。让我们更清楚地展示自引用的 `TreeNode`：
- en: '[PRE16]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'So what happens when we say:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 那么当我们说：
- en: '[PRE17]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '? A join along aliases, three levels deep off the parent:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '? 沿着别名进行连接，从父级开始深入三级：'
- en: '[PRE18]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Notice the nice clean alias names too. The joining doesn’t care if it’s against
    the same immediate table or some other object which then cycles back to the beginning.
    Any kind of chain of eager loads can cycle back onto itself when `join_depth`
    is specified. When not present, eager loading automatically stops when it hits
    a cycle.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这些漂亮干净的别名。连接不在乎是针对同一个立即表还是一些其他对象，然后再循环回开始。当指定了 `join_depth` 时，任何类型的贪婪加载链都可以在自身上循环。当不存在时，贪婪加载在遇到循环时会自动停止。
- en: Composite Types
  id: totrans-63
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 复合类型
- en: 'This is one from the Hibernate camp. Composite Types let you define a custom
    datatype that is composed of more than one column (or one column, if you wanted).
    Lets define a new type, `Point`. Stores an x/y coordinate:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这是来自 Hibernate 阵营的一个例子。复合类型允许您定义一个由多个列（或一个列，如果您愿意的话）组成的自定义数据类型。让我们定义一个新类型，`Point`。存储一个
    x/y 坐标：
- en: '[PRE19]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The way the `Point` object is defined is specific to a custom type; constructor
    takes a list of arguments, and the `__composite_values__()` method produces a
    sequence of those arguments. The order will match up to our mapper, as we’ll see
    in a moment.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`Point` 对象的定义方式是特定于自定义类型的；构造函数接受一个参数列表，并且 `__composite_values__()` 方法生成这些参数的序列。顺序将与我们的映射器匹配，我们马上就会看到。'
- en: 'Let’s create a table of vertices storing two points per row:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个存储每行两个点的顶点表：
- en: '[PRE20]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then, map it ! We’ll create a `Vertex` object which stores two `Point` objects:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，映射它！我们将创建一个存储两个 `Point` 对象的 `Vertex` 对象：
- en: '[PRE21]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Once you’ve set up your composite type, it’s usable just like any other type:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置了您的复合类型，它就可以像任何其他类型一样使用：
- en: '[PRE22]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If you’d like to define the way the mapped attributes generate SQL clauses
    when used in expressions, create your own `sqlalchemy.orm.PropComparator` subclass,
    defining any of the common operators (like `__eq__()`, `__le__()`, etc.), and
    send it in to `composite()`. Composite types work as primary keys too, and are
    usable in `query.get()`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想定义映射属性在表达式中生成 SQL 子句的方式，请创建自己的 `sqlalchemy.orm.PropComparator` 子类，定义任何常见操作符（如
    `__eq__()`，`__le__()` 等），并将其发送到 `composite()`。复合类型也可以作为主键，并且可以在 `query.get()`
    中使用：
- en: '[PRE23]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '`dynamic_loader()` relations'
  id: totrans-75
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`dynamic_loader()` 关系'
- en: A `relation()` that returns a live `Query` object for all read operations. Write
    operations are limited to just `append()` and `remove()`, changes to the collection
    are not visible until the session is flushed. This feature is particularly handy
    with an “autoflushing” session which will flush before each query.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 一个返回所有读操作的实时 `Query` 对象的 `relation()`。写操作仅限于 `append()` 和 `remove()`，对集合的更改在会话刷新之前不可见。此功能在“自动刷新”会话中特别方便，该会话会在每次查询之前刷新。
- en: '[PRE24]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'New Options: `undefer_group()`, `eagerload_all()`'
  id: totrans-78
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 新选项：`undefer_group()`，`eagerload_all()`
- en: 'A couple of query options which are handy. `undefer_group()` marks a whole
    group of “deferred” columns as undeferred:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 一些方便的查询选项。`undefer_group()`将整个“延迟”列组标记为未延迟：
- en: '[PRE25]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'and `eagerload_all()` sets a chain of attributes to be eager in one pass:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`eagerload_all()`设置一系列属性为一次性急切加载：'
- en: '[PRE26]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: New Collection API
  id: totrans-83
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 新的集合API
- en: Collections are no longer proxied by an {{{InstrumentedList}}} proxy, and access
    to members, methods and attributes is direct. Decorators now intercept objects
    entering and leaving the collection, and it is now possible to easily write a
    custom collection class that manages its own membership. Flexible decorators also
    replace the named method interface of custom collections in 0.3, allowing any
    class to be easily adapted to use as a collection container.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 集合不再由{{{InstrumentedList}}}代理代理，对成员、方法和属性的访问是直接的。装饰器现在拦截进入和离开集合的对象，并且现在可以轻松编写一个自定义集合类来管理自己的成员。灵活的装饰器还取代了0.3中自定义集合的命名方法接口，允许任何类轻松适应用作集合容器。
- en: 'Dictionary-based collections are now much easier to use and fully `dict`-like.
    Changing `__iter__` is no longer needed for `dict``s, and new built-in ``dict`
    types cover many needs:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 基于字典的集合现在更容易使用，完全类似于`dict`。不再需要更改`__iter__`以用于`dict`，新的内置`dict`类型涵盖了许多需求：
- en: '[PRE27]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Existing 0.3 `dict`-like and freeform object derived collection classes will
    need to be updated for the new API. In most cases this is simply a matter of adding
    a couple decorators to the class definition.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现有的0.3类似`dict`和自由形式对象派生的集合类需要更新以适应新的API。在大多数情况下，这只是在类定义中添加一些装饰器的问题。
- en: Mapped Relations from External Tables/Subqueries
  id: totrans-88
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 从外部表/子查询映射的关系
- en: 'This feature quietly appeared in 0.3 but has been improved in 0.4 thanks to
    better ability to convert subqueries against a table into subqueries against an
    alias of that table; this is key for eager loading, aliased joins in queries,
    etc. It reduces the need to create mappers against select statements when you
    just need to add some extra columns or subqueries:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这个功能在0.3中悄悄出现，但在0.4中得到改进，这要归功于更好地能够将针对表的子查询转换为该表的别名的子查询；这对于急切加载、查询中的别名连接等非常重要。当您只需要添加一些额外列或子查询时，它减少了对选择语句创建映射器的需求：
- en: '[PRE28]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'a typical query looks like:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的查询如下：
- en: '[PRE29]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Horizontal Scaling (Sharding) API
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 水平扩展（分片）API
- en: '[browser:/sqlalchemy/trunk/examples/sharding/attribute_shard .py]'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '[browser:/sqlalchemy/trunk/examples/sharding/attribute_shard .py]'
- en: Sessions
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 会话
- en: New Session Create Paradigm; SessionContext, assignmapper Deprecated
  id: totrans-96
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 新的会话创建范式；SessionContext，assignmapper已弃用
- en: That’s right, the whole shebang is being replaced with two configurational functions.
    Using both will produce the most 0.1-ish feel we’ve had since 0.1 (i.e., the least
    amount of typing).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，整个事情都被两个配置函数替换了。同时使用两者将产生自0.1以来最接近的感觉（即，输入最少）。
- en: 'Configure your own `Session` class right where you define your `engine` (or
    anywhere):'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义`engine`（或任何地方）的地方配置自己的`Session`类：
- en: '[PRE30]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'If you need to post-configure your Session, say with an engine, add it later
    with `configure()`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要后配置您的会话，比如使用引擎，稍后使用`configure()`添加：
- en: '[PRE31]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'All the behaviors of `SessionContext` and the `query` and `__init__` methods
    of `assignmapper` are moved into the new `scoped_session()` function, which is
    compatible with both `sessionmaker` as well as `create_session()`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 所有`SessionContext`的行为以及`assignmapper`的`query`和`__init__`方法都移动到新的`scoped_session()`函数中，该函数与`sessionmaker`和`create_session()`兼容：
- en: '[PRE32]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: When using a thread-local `Session`, the returned class has all of `Session's`
    interface implemented as classmethods, and “assignmapper“‘s functionality is available
    using the `mapper` classmethod. Just like the old `objectstore` days….
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 使用线程本地`Session`时，返回的类已实现了所有`Session`的接口作为类方法，并且使用`mapper`类方法可以使用“assignmapper”的功能。就像旧的`objectstore`时代一样...。
- en: '[PRE33]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Sessions are again Weak Referencing By Default
  id: totrans-106
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 会话再次默认使用弱引用
- en: The weak_identity_map flag is now set to `True` by default on Session. Instances
    which are externally deferenced and fall out of scope are removed from the session
    automatically. However, items which have “dirty” changes present will remain strongly
    referenced until those changes are flushed at which case the object reverts to
    being weakly referenced (this works for ‘mutable’ types, like picklable attributes,
    as well). Setting weak_identity_map to `False` restores the old strong-referencing
    behavior for those of you using the session like a cache.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，在 Session 上将 weak_identity_map 标志设置为 `True`。外部解除引用并超出范围的实例将自动从会话中移除。但是，具有“脏”更改的项目将保持强引用，直到这些更改被刷新，此时对象将恢复为弱引用（这适用于像可选属性这样的‘可变’类型）。将
    weak_identity_map 设置为 `False` 将为那些像缓存一样使用会话的人恢复旧的强引用行为。
- en: Auto-Transactional Sessions
  id: totrans-108
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 自动事务会话
- en: As you might have noticed above, we are calling `commit()` on `Session`. The
    flag `transactional=True` means the `Session` is always in a transaction, `commit()`
    persists permanently.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能已经注意到的，我们在 `Session` 上调用了 `commit()`。标志 `transactional=True` 意味着 `Session`
    总是处于事务中，`commit()` 永久保存。
- en: Auto-Flushing Sessions
  id: totrans-110
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 自动刷新会话
- en: 'Also, `autoflush=True` means the `Session` will `flush()` before each `query`
    as well as when you call `flush()` or `commit()`. So now this will work:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`autoflush=True` 意味着 `Session` 在每次 `query` 之前都会执行 `flush()`，以及在调用 `flush()`
    或 `commit()` 时。所以现在这将起作用：
- en: '[PRE34]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Transactional methods moved onto sessions
  id: totrans-113
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 事务方法转移到了会话中
- en: '`commit()` and `rollback()`, as well as `begin()` are now directly on `Session`.
    No more need to use `SessionTransaction` for anything (it remains in the background).'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`commit()` 和 `rollback()`，以及 `begin()` 现在直接在 `Session` 上。不再需要为任何事情使用 `SessionTransaction`（它仍然在后台运行）。'
- en: '[PRE35]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Sharing a `Session` with an enclosing engine-level (i.e. non-ORM) transaction
    is easy:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 与封闭引擎级（即非ORM）事务共享 `Session` 很容易：
- en: '[PRE36]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Nested Session Transactions with SAVEPOINT
  id: totrans-118
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 带有 SAVEPOINT 的嵌套会话事务
- en: 'Available at the Engine and ORM level. ORM docs so far:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在引擎和ORM级别可用。迄今为止的ORM文档：
- en: '[https://www.sqlalchemy.org/docs/04/session.html#unitofwork_managing](https://www.sqlalchemy.org/docs/04/session.html#unitofwork_managing)'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.sqlalchemy.org/docs/04/session.html#unitofwork_managing](https://www.sqlalchemy.org/docs/04/session.html#unitofwork_managing)'
- en: Two-Phase Commit Sessions
  id: totrans-121
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 两阶段提交会话
- en: 'Available at the Engine and ORM level. ORM docs so far:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在引擎和ORM级别可用。迄今为止的ORM文档：
- en: '[https://www.sqlalchemy.org/docs/04/session.html#unitofwork_managing](https://www.sqlalchemy.org/docs/04/session.html#unitofwork_managing)'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.sqlalchemy.org/docs/04/session.html#unitofwork_managing](https://www.sqlalchemy.org/docs/04/session.html#unitofwork_managing)'
- en: Inheritance
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 继承
- en: Polymorphic Inheritance with No Joins or Unions
  id: totrans-125
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 无连接或联合的多态继承
- en: 'New docs for inheritance: [https://www.sqlalchemy.org/docs/04](https://www.sqlalchemy.org/docs/04)
    /mappers.html#advdatamapping_mapper_inheritance_joined'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 继承的新文档：[https://www.sqlalchemy.org/docs/04](https://www.sqlalchemy.org/docs/04)
    /mappers.html#advdatamapping_mapper_inheritance_joined
- en: Better Polymorphic Behavior with `get()`
  id: totrans-127
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 `get()` 时更好的多态行为
- en: All classes within a joined-table inheritance hierarchy get an `_instance_key`
    using the base class, i.e. `(BaseClass, (1, ), None)`. That way when you call
    `get()` a `Query` against the base class, it can locate subclass instances in
    the current identity map without querying the database.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 加入表继承层次结构中的所有类都使用基类获得 `_instance_key`，即 `(BaseClass, (1, ), None)`。这样，当您针对基类调用
    `get()` 时，它可以在当前标识映射中定位子类实例，而无需查询数据库。
- en: Types
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类型
- en: Custom Subclasses of `sqlalchemy.types.TypeDecorator`
  id: totrans-130
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`sqlalchemy.types.TypeDecorator` 的自定义子类'
- en: There is a [New API](https://www.sqlalchemy.org/docs/04/types.html#types_custom)
    for subclassing a TypeDecorator. Using the 0.3 API causes compilation errors in
    some cases.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个[新API](https://www.sqlalchemy.org/docs/04/types.html#types_custom)用于子类化 TypeDecorator。在某些情况下，使用
    0.3 API 会导致编译错误。
- en: SQL Expressions
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SQL 表达式
- en: All New, Deterministic Label/Alias Generation
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 全新的、确定性的标签/别名生成
- en: 'All the “anonymous” labels and aliases use a simple <name>_<number> format
    now. SQL is much easier to read and is compatible with plan optimizer caches.
    Just check out some of the examples in the tutorials: [https://www.sqlalchemy.org/docs/04/ormtutorial.html](https://www.sqlalchemy.org/docs/04/ormtutorial.html)
    [https://www.sqlalchemy.org/docs/04/sqlexpression.html](https://www.sqlalchemy.org/docs/04/sqlexpression.html)'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 所有“匿名”标签和别名现在都使用简单的 <name>_<number> 格式。SQL 更容易阅读，并且与计划优化器缓存兼容。只需查看一些教程中的示例：[https://www.sqlalchemy.org/docs/04/ormtutorial.html](https://www.sqlalchemy.org/docs/04/ormtutorial.html)
    [https://www.sqlalchemy.org/docs/04/sqlexpression.html](https://www.sqlalchemy.org/docs/04/sqlexpression.html)
- en: Generative select() Constructs
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生成式 select() 构造
- en: This is definitely the way to go with `select()`. See htt p://www.sqlalchemy.org/docs/04/sqlexpression.html#sql_transf
    orm .
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这绝对是使用`select()`的方法。请参阅 htt p://www.sqlalchemy.org/docs/04/sqlexpression.html#sql_transf
    orm 。
- en: New Operator System
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 新的运算符系统
- en: 'SQL operators and more or less every SQL keyword there is are now abstracted
    into the compiler layer. They now act intelligently and are type/backend aware,
    see: [https://www.sqlalchemy.org/docs/04/sqlexpression.html#sql_operators](https://www.sqlalchemy.org/docs/04/sqlexpression.html#sql_operators)'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: SQL运算符和几乎每个SQL关键字现在都被抽象为编译器层。它们现在表现智能，并且具有类型/后端感知性，参见：[https://www.sqlalchemy.org/docs/04/sqlexpression.html#sql_operators](https://www.sqlalchemy.org/docs/04/sqlexpression.html#sql_operators)
- en: All `type` Keyword Arguments Renamed to `type_`
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 所有`type`关键字参数重命名为`type_`
- en: 'Just like it says:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 就像它说的那样：
- en: '[PRE37]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: in_ Function Changed to Accept Sequence or Selectable
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`in_`函数更改为接受序列或可选择的'
- en: The in_ function now takes a sequence of values or a selectable as its sole
    argument. The previous API of passing in values as positional arguments still
    works, but is now deprecated. This means that
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`in_`函数现在接受一个值序列或可选择的可选参数。仍然可以使用以前将值作为位置参数传递的API，但现在已被弃用。这意味着'
- en: '[PRE38]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: should be changed to
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 应更改为
- en: '[PRE39]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Schema and Reflection
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模式和反射
- en: '`MetaData`, `BoundMetaData`, `DynamicMetaData`…'
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`MetaData`、`BoundMetaData`、`DynamicMetaData`…'
- en: 'In the 0.3.x series, `BoundMetaData` and `DynamicMetaData` were deprecated
    in favor of `MetaData` and `ThreadLocalMetaData`. The older names have been removed
    in 0.4\. Updating is simple:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在0.3.x系列中，`BoundMetaData`和`DynamicMetaData`已被弃用，取而代之的是`MetaData`和`ThreadLocalMetaData`。旧名称已在0.4版本中移除。更新很简单：
- en: '[PRE40]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The seldom-used `name` parameter to `MetaData` types has been removed. The `ThreadLocalMetaData`
    constructor now takes no arguments. Both types can now be bound to an `Engine`
    or a single `Connection`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 很少使用的`name`参数已从`MetaData`类型中删除。`ThreadLocalMetaData`构造函数现在不再接受参数。这两种类型现在都可以绑定到一个`Engine`或一个单独的`Connection`。
- en: One Step Multi-Table Reflection
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一步多表反射
- en: 'You can now load table definitions and automatically create `Table` objects
    from an entire database or schema in one pass:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以加载表定义，并在一个步骤中自动创建整个数据库或模式的`Table`对象：
- en: '[PRE41]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '`MetaData` also gains a `.reflect()` method enabling finer control over the
    loading process, including specification of a subset of available tables to load.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`MetaData`还增加了一个`.reflect()`方法，可以更精细地控制加载过程，包括指定要加载的可用表的子集。'
- en: SQL Execution
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SQL执行
- en: '`engine`, `connectable`, and `bind_to` are all now `bind`'
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`engine`、`connectable`和`bind_to`现在都是`bind`'
- en: '`Transactions`, `NestedTransactions` and `TwoPhaseTransactions`'
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`Transactions`、`NestedTransactions`和`TwoPhaseTransactions`'
- en: Connection Pool Events
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接池事件
- en: The connection pool now fires events when new DB-API connections are created,
    checked out and checked back into the pool. You can use these to execute session-scoped
    SQL setup statements on fresh connections, for example.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 连接池现在在创建新的DB-API连接、检出和检入池时触发事件。您可以使用这些事件在新连接上执行会话范围的SQL设置语句，例如。
- en: Oracle Engine Fixed
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修复了Oracle Engine
- en: In 0.3.11, there were bugs in the Oracle Engine on how Primary Keys are handled.
    These bugs could cause programs that worked fine with other engines, such as sqlite,
    to fail when using the Oracle Engine. In 0.4, the Oracle Engine has been reworked,
    fixing these Primary Key problems.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在0.3.11版本中，Oracle Engine在处理主键时存在错误。这些错误可能导致在使用Oracle Engine时，其他引擎（如sqlite）正常工作的程序失败。在0.4版本中，Oracle
    Engine已经重新设计，修复了这些主键问题。
- en: Out Parameters for Oracle
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Oracle的输出参数
- en: '[PRE42]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Connection-bound `MetaData`, `Sessions`
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接绑定的`MetaData`、`Sessions`
- en: '`MetaData` and `Session` can be explicitly bound to a connection:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`MetaData`和`Session`可以显式绑定到连接：'
- en: '[PRE43]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Faster, More Foolproof `ResultProxy` Objects
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更快、更可靠的`ResultProxy`对象
- en: First Things First
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 首要事项
- en: 'If you’re using any ORM features, make sure you import from `sqlalchemy.orm`:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用任何ORM功能，请确保从`sqlalchemy.orm`导入：
- en: '[PRE44]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Secondly, anywhere you used to say `engine=`, `connectable=`, `bind_to=`, `something.engine`,
    `metadata.connect()`, use `bind`:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，无论您以前使用`engine=`、`connectable=`、`bind_to=`、`something.engine`、`metadata.connect()`，现在都使用`bind`：
- en: '[PRE45]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Got those ? Good! You’re now (95%) 0.4 compatible. If you’re using 0.3.10, you
    can make these changes immediately; they’ll work there too.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 明白了吗？很好！您现在（95%）兼容0.4版本。如果您正在使用0.3.10版本，您可以立即进行这些更改；它们也适用于那里。
- en: Module Imports
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块导入
- en: In 0.3, “`from sqlalchemy import *`” would import all of sqlalchemy’s sub-modules
    into your namespace. Version 0.4 no longer imports sub-modules into the namespace.
    This may mean you need to add extra imports into your code.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在 0.3 版本中，“`from sqlalchemy import *`” 将所有 sqlalchemy 的子模块导入到您的命名空间中。0.4 版本不再将子模块导入到命名空间中。这可能意味着您需要在代码中添加额外的导入。
- en: 'In 0.3, this code worked:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在 0.3 版本中，这段代码有效：
- en: '[PRE46]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'In 0.4, one must do:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在 0.4 版本中，必须执行：
- en: '[PRE47]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Object Relational Mapping
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象关系映射
- en: Querying
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查询
- en: New Query API
  id: totrans-183
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 新的查询 API
- en: Query is standardized on the generative interface (old interface is still there,
    just deprecated). While most of the generative interface is available in 0.3,
    the 0.4 Query has the inner guts to match the generative outside, and has a lot
    more tricks. All result narrowing is via `filter()` and `filter_by()`, limiting/offset
    is either through array slices or `limit()`/`offset()`, joining is via `join()`
    and `outerjoin()` (or more manually, through `select_from()` as well as manually-formed
    criteria).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 查询标准化为生成式接口（旧接口仍然存在，只是已弃用）。虽然大部分生成式接口在 0.3 版本中可用，但 0.4 版本的 Query 具有与生成式外部匹配的内部实现，并且有更多技巧。所有结果缩小都通过
    `filter()` 和 `filter_by()` 进行，限制/偏移要么通过数组切片要么通过 `limit()`/`offset()` 进行，连接通过 `join()`
    和 `outerjoin()` 进行（或者更手动地，通过 `select_from()` 以及手动形成的条件）。
- en: To avoid deprecation warnings, you must make some changes to your 03 code
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免弃用警告，您必须对您的 03 代码进行一些更改
- en: User.query.get_by( **kwargs )
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: User.query.get_by( **kwargs )
- en: '[PRE48]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: User.query.select_by( **kwargs )
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: User.query.select_by( **kwargs )
- en: '[PRE49]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: User.query.select()
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: User.query.select()
- en: '[PRE50]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: New Property-Based Expression Constructs
  id: totrans-192
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 新的基于属性的表达式构造
- en: 'By far the most palpable difference within the ORM is that you can now construct
    your query criterion using class-based attributes directly. The “.c.” prefix is
    no longer needed when working with mapped classes:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ORM 中最明显的区别是，现在您可以直接使用基于类的属性构建查询条件。在处理映射类时不再需要“`.c.`”前缀：
- en: '[PRE51]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'While simple column-based comparisons are no big deal, the class attributes
    have some new “higher level” constructs available, including what was previously
    only available in `filter_by()`:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然简单的基于列的比较不是什么大问题，但类属性具有一些新的“更高级”构造可用，包括以前仅在 `filter_by()` 中可用的内容：
- en: '[PRE52]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The `Column` collection remains available on mapped classes in the `.c` attribute.
    Note that property-based expressions are only available with mapped properties
    of mapped classes. `.c` is still used to access columns in regular tables and
    selectable objects produced from SQL Expressions.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`Column` 集合仍然可以在 `.c` 属性中的映射类中使用。请注意，基于属性的表达式仅适用于映射类的映射属性。`.c` 仍然用于访问常规表中的列以及从
    SQL 表达式生成的可选择对象。'
- en: Automatic Join Aliasing
  id: totrans-198
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 自动连接别名
- en: 'We’ve had join() and outerjoin() for a while now:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有了 join() 和 outerjoin() 一段时间了：
- en: '[PRE53]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Now you can alias them:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以为它们创建别名：
- en: '[PRE54]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The above will create two joins from orders->items using aliases. the `filter()`
    call subsequent to each will adjust its table criterion to that of the alias.
    To get at the `Item` objects, use `add_entity()` and target each join with an
    `id`:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 以上将使用别名从 orders->items 创建两个连接。每个连接后续的 `filter()` 调用将调整其表条件以符合别名。要访问 `Item` 对象，请使用
    `add_entity()` 并将每个连接的 `id` 作为目标：
- en: '[PRE55]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Returns tuples in the form: `(Order, Item, Item)`.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 返回元组形式：`(Order, Item, Item)`。
- en: Self-referential Queries
  id: totrans-206
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 自引用查询
- en: 'So query.join() can make aliases now. What does that give us ? Self-referential
    queries ! Joins can be done without any `Alias` objects:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 因此 query.join() 现在可以创建别名。这给我们带来了什么？自引用查询！可以在没有任何 `Alias` 对象的情况下进行连接：
- en: '[PRE56]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'To add criterion for each table along the way in an aliased join, you can use
    `from_joinpoint` to keep joining against the same line of aliases:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 要为每个表添加条件，可以使用 `from_joinpoint` 在别名连接中保持针对相同别名行的连接：
- en: '[PRE57]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '`query.populate_existing()`'
  id: totrans-211
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`query.populate_existing()`'
- en: 'The eager version of `query.load()` (or `session.refresh()`). Every instance
    loaded from the query, including all eagerly loaded items, get refreshed immediately
    if already present in the session:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`query.load()` 的贪婪版本（或 `session.refresh()`）。从查询加载的每个实例，包括所有贪婪加载的项目，如果已经存在于会话中，则立即刷新：'
- en: '[PRE58]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Relations
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关系
- en: SQL Clauses Embedded in Updates/Inserts
  id: totrans-215
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 嵌入在更新/插入中的 SQL 子句
- en: 'For inline execution of SQL clauses, embedded right in the UPDATE or INSERT,
    during a `flush()`:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 对于内联执行 SQL 子句，嵌入在 `flush()` 中的 UPDATE 或 INSERT 中：
- en: '[PRE59]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The column-attribute is set up with a deferred loader after the operation, so
    that it issues the SQL to load the new value when you next access.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在操作后，列属性设置为延迟加载器，因此当您下次访问时，它会发出 SQL 来加载新值。
- en: Self-referential and Cyclical Eager Loading
  id: totrans-219
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 自引用和循环贪婪加载
- en: 'Since our alias-fu has improved, `relation()` can join along the same table
    *any number of times*; you tell it how deep you want to go. Lets show the self-referential
    `TreeNode` more clearly:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的别名技术已经改进，`relation()`可以沿着相同的表*任意次数*连接；你告诉它你想要多深。让我们更清楚地展示自引用的`TreeNode`：
- en: '[PRE60]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'So what happens when we say:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 那么当我们说：
- en: '[PRE61]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '? A join along aliases, three levels deep off the parent:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '? 通过别名连接，从父级开始深入三级：'
- en: '[PRE62]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Notice the nice clean alias names too. The joining doesn’t care if it’s against
    the same immediate table or some other object which then cycles back to the beginning.
    Any kind of chain of eager loads can cycle back onto itself when `join_depth`
    is specified. When not present, eager loading automatically stops when it hits
    a cycle.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 注意漂亮干净的别名名称。连接不在乎是否针对同一个直接表或一些其他对象，然后循环回开始。当指定`join_depth`时，任何类型的链式急切加载可以循环回自身。当不存在时，急切加载在遇到循环时会自动停止。
- en: Composite Types
  id: totrans-227
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 复合类型
- en: 'This is one from the Hibernate camp. Composite Types let you define a custom
    datatype that is composed of more than one column (or one column, if you wanted).
    Lets define a new type, `Point`. Stores an x/y coordinate:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这是来自Hibernate阵营的一个。复合类型让你定义一个由多个列（或一个列，如果你愿意）组成的自定义数据类型。让我们定义一个新类型，`Point`。存储一个x/y坐标：
- en: '[PRE63]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The way the `Point` object is defined is specific to a custom type; constructor
    takes a list of arguments, and the `__composite_values__()` method produces a
    sequence of those arguments. The order will match up to our mapper, as we’ll see
    in a moment.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`Point`对象的定义方式是特定于自定义类型的；构造函数接受一个参数列表，`__composite_values__()`方法生成这些参数的序列。顺序将与我们的映射器匹配，我们马上就会看到。'
- en: 'Let’s create a table of vertices storing two points per row:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个存储每行两个点的顶点表：
- en: '[PRE64]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Then, map it ! We’ll create a `Vertex` object which stores two `Point` objects:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，映射它！我们将创建一个存储两个`Point`对象的`Vertex`对象：
- en: '[PRE65]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Once you’ve set up your composite type, it’s usable just like any other type:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置了复合类型，它就可以像任何其他类型一样使用：
- en: '[PRE66]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'If you’d like to define the way the mapped attributes generate SQL clauses
    when used in expressions, create your own `sqlalchemy.orm.PropComparator` subclass,
    defining any of the common operators (like `__eq__()`, `__le__()`, etc.), and
    send it in to `composite()`. Composite types work as primary keys too, and are
    usable in `query.get()`:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想定义映射属性在表达式中生成SQL子句的方式，创建自己的`sqlalchemy.orm.PropComparator`子类，定义任何常见操作符（如`__eq__()`，`__le__()`等），并将其发送到`composite()`。复合类型也可以作为主键，并且可用于`query.get()`：
- en: '[PRE67]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '`dynamic_loader()` relations'
  id: totrans-239
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`dynamic_loader()`关系'
- en: A `relation()` that returns a live `Query` object for all read operations. Write
    operations are limited to just `append()` and `remove()`, changes to the collection
    are not visible until the session is flushed. This feature is particularly handy
    with an “autoflushing” session which will flush before each query.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 一个返回所有读操作的实时`Query`对象的`relation()`。写操作仅限于`append()`和`remove()`，对集合的更改在会话刷新之前不可见。这个特性在“自动刷新”会话中特别方便，它会在每次查询之前刷新。
- en: '[PRE68]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'New Options: `undefer_group()`, `eagerload_all()`'
  id: totrans-242
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 新选项：`undefer_group()`，`eagerload_all()`
- en: 'A couple of query options which are handy. `undefer_group()` marks a whole
    group of “deferred” columns as undeferred:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 一些方便的查询选项。`undefer_group()`将整个“延迟”列组标记为未延迟：
- en: '[PRE69]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'and `eagerload_all()` sets a chain of attributes to be eager in one pass:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`eagerload_all()`设置一系列属性在一次遍历中急切加载：'
- en: '[PRE70]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: New Collection API
  id: totrans-247
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 新的集合API
- en: Collections are no longer proxied by an {{{InstrumentedList}}} proxy, and access
    to members, methods and attributes is direct. Decorators now intercept objects
    entering and leaving the collection, and it is now possible to easily write a
    custom collection class that manages its own membership. Flexible decorators also
    replace the named method interface of custom collections in 0.3, allowing any
    class to be easily adapted to use as a collection container.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 集合不再由{{{InstrumentedList}}}代理进行代理，对成员、方法和属性的访问是直接的。装饰器现在拦截进入和离开集合的对象，现在可以轻松编写一个自定义集合类来管理自己的成员。灵活的装饰器还取代了0.3版本中自定义集合的命名方法接口，允许任何类轻松适应用作集合容器。
- en: 'Dictionary-based collections are now much easier to use and fully `dict`-like.
    Changing `__iter__` is no longer needed for `dict``s, and new built-in ``dict`
    types cover many needs:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 基于字典的集合现在更容易使用，完全类似于`dict`。不再需要更改`dict`的`__iter__`，新的内置`dict`类型涵盖了许多需求：
- en: '[PRE71]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Existing 0.3 `dict`-like and freeform object derived collection classes will
    need to be updated for the new API. In most cases this is simply a matter of adding
    a couple decorators to the class definition.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 现有的 0.3 版本的类似 `dict` 和自由形式对象派生的集合类需要更新到新的API。在大多数情况下，这只是在类定义中添加几个装饰器的问题。
- en: Mapped Relations from External Tables/Subqueries
  id: totrans-252
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 从外部表/子查询映射关系
- en: 'This feature quietly appeared in 0.3 but has been improved in 0.4 thanks to
    better ability to convert subqueries against a table into subqueries against an
    alias of that table; this is key for eager loading, aliased joins in queries,
    etc. It reduces the need to create mappers against select statements when you
    just need to add some extra columns or subqueries:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这个功能在0.3版本中悄然出现，但在0.4版本中得到改进，这要归功于更好地将针对表的子查询转换为针对该表的别名的能力；这对于急加载、查询中的别名连接等非常重要。这减少了在只需要添加一些额外列或子查询时对选择语句创建映射器的需求：
- en: '[PRE72]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'a typical query looks like:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的查询如下：
- en: '[PRE73]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Horizontal Scaling (Sharding) API
  id: totrans-257
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 水平扩展（分片）API
- en: '[browser:/sqlalchemy/trunk/examples/sharding/attribute_shard .py]'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '[browser:/sqlalchemy/trunk/examples/sharding/attribute_shard .py]'
- en: Sessions
  id: totrans-259
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 会话
- en: New Session Create Paradigm; SessionContext, assignmapper Deprecated
  id: totrans-260
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 新的会话创建范式；SessionContext，assignmapper 已弃用
- en: That’s right, the whole shebang is being replaced with two configurational functions.
    Using both will produce the most 0.1-ish feel we’ve had since 0.1 (i.e., the least
    amount of typing).
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，整个事情都被两个配置函数替换了。同时使用两者将产生自0.1版本以来最接近0.1版本的感觉（即，输入最少）。
- en: 'Configure your own `Session` class right where you define your `engine` (or
    anywhere):'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义引擎（或任何地方）的地方配置您自己的 `Session` 类��
- en: '[PRE74]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'If you need to post-configure your Session, say with an engine, add it later
    with `configure()`:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要在之后使用 `configure()` 来后置配置您的会话，比如添加引擎：
- en: '[PRE75]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'All the behaviors of `SessionContext` and the `query` and `__init__` methods
    of `assignmapper` are moved into the new `scoped_session()` function, which is
    compatible with both `sessionmaker` as well as `create_session()`:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '`SessionContext` 的所有行为以及 `assignmapper` 的 `query` 和 `__init__` 方法都移动到了新的 `scoped_session()`
    函数中，该函数与 `sessionmaker` 和 `create_session()` 兼容：'
- en: '[PRE76]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: When using a thread-local `Session`, the returned class has all of `Session's`
    interface implemented as classmethods, and “assignmapper“‘s functionality is available
    using the `mapper` classmethod. Just like the old `objectstore` days….
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用线程本地的 `Session` 时，返回的类已经实现了所有 `Session` 的接口作为类方法，并且可以使用 `mapper` 类方法来使用 “assignmapper”
    的功能。就像旧的 `objectstore` 时代一样……。
- en: '[PRE77]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Sessions are again Weak Referencing By Default
  id: totrans-270
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 会话再次默认为弱引用
- en: The weak_identity_map flag is now set to `True` by default on Session. Instances
    which are externally deferenced and fall out of scope are removed from the session
    automatically. However, items which have “dirty” changes present will remain strongly
    referenced until those changes are flushed at which case the object reverts to
    being weakly referenced (this works for ‘mutable’ types, like picklable attributes,
    as well). Setting weak_identity_map to `False` restores the old strong-referencing
    behavior for those of you using the session like a cache.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: weak_identity_map 标志现在默认设置为 `True` 在 Session 上。外部解除引用并且超出范围的实例会自动从会话中移除。但是，具有“脏”更改的项目将保持强引用，直到这些更改被刷新，此时对象将恢复为弱引用（这适用于像可选属性这样的“可变”类型）。将
    weak_identity_map 设置为 `False` 将为那些像缓存一样使用会话的人恢复旧的强引用行为。
- en: Auto-Transactional Sessions
  id: totrans-272
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 自动事务会话
- en: As you might have noticed above, we are calling `commit()` on `Session`. The
    flag `transactional=True` means the `Session` is always in a transaction, `commit()`
    persists permanently.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在上面所注意到的，我们在 `Session` 上调用 `commit()`。标志 `transactional=True` 意味着 `Session`
    总是处于事务中，`commit()` 永久持久化。
- en: Auto-Flushing Sessions
  id: totrans-274
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 自动刷新会话
- en: 'Also, `autoflush=True` means the `Session` will `flush()` before each `query`
    as well as when you call `flush()` or `commit()`. So now this will work:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`autoflush=True` 意味着 `Session` 将在每次 `query` 之前刷新，以及在调用 `flush()` 或 `commit()`
    时。所以现在这将起作用：
- en: '[PRE78]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Transactional methods moved onto sessions
  id: totrans-277
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 事务方法移动到会话上
- en: '`commit()` and `rollback()`, as well as `begin()` are now directly on `Session`.
    No more need to use `SessionTransaction` for anything (it remains in the background).'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '`commit()` 和 `rollback()`，以及 `begin()` 现在直接在 `Session` 上。不再需要为任何事情使用 `SessionTransaction`（它仍然在后台运行）。'
- en: '[PRE79]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Sharing a `Session` with an enclosing engine-level (i.e. non-ORM) transaction
    is easy:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 与封闭的引擎级（即非ORM）事务共享 `Session` 很容易：
- en: '[PRE80]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Nested Session Transactions with SAVEPOINT
  id: totrans-282
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 SAVEPOINT 的嵌套会话事务
- en: 'Available at the Engine and ORM level. ORM docs so far:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在引擎和ORM级别可用。迄今为止的ORM文档：
- en: '[https://www.sqlalchemy.org/docs/04/session.html#unitofwork_managing](https://www.sqlalchemy.org/docs/04/session.html#unitofwork_managing)'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.sqlalchemy.org/docs/04/session.html#unitofwork_managing](https://www.sqlalchemy.org/docs/04/session.html#unitofwork_managing)'
- en: Two-Phase Commit Sessions
  id: totrans-285
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 两阶段提交会话
- en: 'Available at the Engine and ORM level. ORM docs so far:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在引擎和ORM级别可用。迄今为止的ORM文档：
- en: '[https://www.sqlalchemy.org/docs/04/session.html#unitofwork_managing](https://www.sqlalchemy.org/docs/04/session.html#unitofwork_managing)'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.sqlalchemy.org/docs/04/session.html#unitofwork_managing](https://www.sqlalchemy.org/docs/04/session.html#unitofwork_managing)'
- en: Inheritance
  id: totrans-288
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 继承
- en: Polymorphic Inheritance with No Joins or Unions
  id: totrans-289
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 无联接或联合的多态继承
- en: 'New docs for inheritance: [https://www.sqlalchemy.org/docs/04](https://www.sqlalchemy.org/docs/04)
    /mappers.html#advdatamapping_mapper_inheritance_joined'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 继承的新文档：[https://www.sqlalchemy.org/docs/04](https://www.sqlalchemy.org/docs/04)
    /mappers.html#advdatamapping_mapper_inheritance_joined
- en: Better Polymorphic Behavior with `get()`
  id: totrans-291
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用`get()`实现更好的多态行为
- en: All classes within a joined-table inheritance hierarchy get an `_instance_key`
    using the base class, i.e. `(BaseClass, (1, ), None)`. That way when you call
    `get()` a `Query` against the base class, it can locate subclass instances in
    the current identity map without querying the database.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在联接表继承层次结构中，所有类都使用基类获得`_instance_key`，即`(BaseClass, (1, ), None)`。这样，当您针对基类调用`get()`时，它可以在当前标识映射中定位子类实例，而无需查询数据库。
- en: Types
  id: totrans-293
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类型
- en: Custom Subclasses of `sqlalchemy.types.TypeDecorator`
  id: totrans-294
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 自定义`sqlalchemy.types.TypeDecorator`的子类
- en: There is a [New API](https://www.sqlalchemy.org/docs/04/types.html#types_custom)
    for subclassing a TypeDecorator. Using the 0.3 API causes compilation errors in
    some cases.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个[新的API](https://www.sqlalchemy.org/docs/04/types.html#types_custom)用于子类化TypeDecorator。在某些情况下，使用0.3
    API会导致编译错误。
- en: Querying
  id: totrans-296
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查询
- en: New Query API
  id: totrans-297
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 新的查询API
- en: Query is standardized on the generative interface (old interface is still there,
    just deprecated). While most of the generative interface is available in 0.3,
    the 0.4 Query has the inner guts to match the generative outside, and has a lot
    more tricks. All result narrowing is via `filter()` and `filter_by()`, limiting/offset
    is either through array slices or `limit()`/`offset()`, joining is via `join()`
    and `outerjoin()` (or more manually, through `select_from()` as well as manually-formed
    criteria).
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 查询标准化为生成式接口（旧接口仍然存在，只是已弃用）。虽然大部分生成式接口在0.3中可用，但0.4查询具有与生成式外部匹配的内部实现，并且有更多技巧。所有结果缩小都通过`filter()`和`filter_by()`进行，限制/偏移要么通过数组切片要么通过`limit()`/`offset()`进行，连接通过`join()`和`outerjoin()`进行（或更手动地，通过`select_from()`以及手动形成的条件）。
- en: To avoid deprecation warnings, you must make some changes to your 03 code
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 为避免弃用警告，您必须对您的03代码进行一些更改
- en: User.query.get_by( **kwargs )
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: User.query.get_by( **kwargs )
- en: '[PRE81]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: User.query.select_by( **kwargs )
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: User.query.select_by( **kwargs )
- en: '[PRE82]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: User.query.select()
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: User.query.select()
- en: '[PRE83]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: New Property-Based Expression Constructs
  id: totrans-306
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 新的基于属性的表达式构造
- en: 'By far the most palpable difference within the ORM is that you can now construct
    your query criterion using class-based attributes directly. The “.c.” prefix is
    no longer needed when working with mapped classes:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在ORM中最明显的区别是，现在你可以直接使用基于类的属性构建查询条件。在使用映射类时不再需要“.c.”前缀：
- en: '[PRE84]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'While simple column-based comparisons are no big deal, the class attributes
    have some new “higher level” constructs available, including what was previously
    only available in `filter_by()`:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然简单的基于列的比较不是什么大问题，但类属性有一些新的“更高级”的构造可用，包括以前仅在`filter_by()`中可用的内容：
- en: '[PRE85]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: The `Column` collection remains available on mapped classes in the `.c` attribute.
    Note that property-based expressions are only available with mapped properties
    of mapped classes. `.c` is still used to access columns in regular tables and
    selectable objects produced from SQL Expressions.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '`Column`集合仍然可以在映射类的`.c`属性中使用。请注意，基于属性的表达式仅适用于映射类的映射属性。在正常表和从SQL表达式生成的可选择对象中，仍然使用`.c`来访问列。'
- en: Automatic Join Aliasing
  id: totrans-312
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 自动连接别名
- en: 'We’ve had join() and outerjoin() for a while now:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经有了join()和outerjoin()：
- en: '[PRE86]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Now you can alias them:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以给它们起别名：
- en: '[PRE87]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'The above will create two joins from orders->items using aliases. the `filter()`
    call subsequent to each will adjust its table criterion to that of the alias.
    To get at the `Item` objects, use `add_entity()` and target each join with an
    `id`:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 上述将从orders->items创建两个连接，使用别名。每个连接后续的`filter()`调用将调整其表条件为别名的条件。要获取`Item`对象，请使用`add_entity()`并将每个连接的`id`作为目标：
- en: '[PRE88]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Returns tuples in the form: `(Order, Item, Item)`.'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 返回形式为的元组：`（Order，Item，Item）`。
- en: Self-referential Queries
  id: totrans-320
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 自引用查询
- en: 'So query.join() can make aliases now. What does that give us ? Self-referential
    queries ! Joins can be done without any `Alias` objects:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，query.join()现在可以创建别名。那给了我们什么？自引用查询！连接可以在没有任何`Alias`对象的情况下完成：
- en: '[PRE89]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'To add criterion for each table along the way in an aliased join, you can use
    `from_joinpoint` to keep joining against the same line of aliases:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 要为沿途的每个表添加条件以进行别名连接，您可以使用`from_joinpoint`来继续针对相同行别名进行连接：
- en: '[PRE90]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '`query.populate_existing()`'
  id: totrans-325
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`query.populate_existing()`'
- en: 'The eager version of `query.load()` (or `session.refresh()`). Every instance
    loaded from the query, including all eagerly loaded items, get refreshed immediately
    if already present in the session:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '`query.load()`（或`session.refresh()`）的急切版本。如果查询中加载的每个实例，包括所有急切加载的项，已经存在于会话中，则立即刷新它们：'
- en: '[PRE91]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: New Query API
  id: totrans-328
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 新的查询API
- en: Query is standardized on the generative interface (old interface is still there,
    just deprecated). While most of the generative interface is available in 0.3,
    the 0.4 Query has the inner guts to match the generative outside, and has a lot
    more tricks. All result narrowing is via `filter()` and `filter_by()`, limiting/offset
    is either through array slices or `limit()`/`offset()`, joining is via `join()`
    and `outerjoin()` (or more manually, through `select_from()` as well as manually-formed
    criteria).
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 查询标准化为生成接口（旧接口仍在，只是已弃用）。虽然大多数生成接口在0.3中可用，但0.4版本的查询具有匹配生成外部的内部要领，并且有更多技巧。所有结果缩小都通过`filter()`和`filter_by()`进行，限制/偏移要么通过数组切片，要么通过`limit()`/`offset()`进行，连接是通过`join()`和`outerjoin()`进行的（或者更手动地，通过`select_from()`以及手动形成的条件）。
- en: To avoid deprecation warnings, you must make some changes to your 03 code
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免弃用警告，您必须对您的03代码进行一些更改
- en: User.query.get_by( **kwargs )
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: User.query.get_by(**kwargs)
- en: '[PRE92]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: User.query.select_by( **kwargs )
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: User.query.select_by(**kwargs)
- en: '[PRE93]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: User.query.select()
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: User.query.select()
- en: '[PRE94]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: New Property-Based Expression Constructs
  id: totrans-337
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 新的基于属性的表达式构造
- en: 'By far the most palpable difference within the ORM is that you can now construct
    your query criterion using class-based attributes directly. The “.c.” prefix is
    no longer needed when working with mapped classes:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在ORM中最明显的区别是，现在您可以直接使用基于类的属性构造查询条件。当使用映射类时，不再需要“ .c.”前缀：
- en: '[PRE95]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'While simple column-based comparisons are no big deal, the class attributes
    have some new “higher level” constructs available, including what was previously
    only available in `filter_by()`:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然简单的基于列的比较不是什么大不了的事，但类属性具有一些新的“更高级别”的构造可用，包括以前仅在`filter_by()`中可用的内容：
- en: '[PRE96]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: The `Column` collection remains available on mapped classes in the `.c` attribute.
    Note that property-based expressions are only available with mapped properties
    of mapped classes. `.c` is still used to access columns in regular tables and
    selectable objects produced from SQL Expressions.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '`.c`属性上的`Column`集合仍然可用于映射类中。请注意，基于属性的表达式仅适用于映射类的映射属性。`.c`仍然用于访问常规表中的列以及从SQL表达式生成的可选择对象。'
- en: Automatic Join Aliasing
  id: totrans-343
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 自动连接别名
- en: 'We’ve had join() and outerjoin() for a while now:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有了一段时间的join()和outerjoin()：
- en: '[PRE97]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Now you can alias them:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以给它们取别名：
- en: '[PRE98]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'The above will create two joins from orders->items using aliases. the `filter()`
    call subsequent to each will adjust its table criterion to that of the alias.
    To get at the `Item` objects, use `add_entity()` and target each join with an
    `id`:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 以上将使用别名从订单->项目创建两个连接。每个之后的`filter()`调用将其表条件调整为别名的条件。要访问`Item`对象，请使用`add_entity()`并将每个连接目标化为`id`：
- en: '[PRE99]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Returns tuples in the form: `(Order, Item, Item)`.'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 返回形式为的元组：`（Order，Item，Item）`。
- en: Self-referential Queries
  id: totrans-351
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 自引用查询
- en: 'So query.join() can make aliases now. What does that give us ? Self-referential
    queries ! Joins can be done without any `Alias` objects:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，query.join()现在可以创建别名。那给了我们什么？自引用查询！连接可以在没有任何`Alias`对象的情况下完成：
- en: '[PRE100]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'To add criterion for each table along the way in an aliased join, you can use
    `from_joinpoint` to keep joining against the same line of aliases:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 要为沿途的每个表添加条件以进行别名连接，您可以使用`from_joinpoint`来继续针对相同行别名进行连接：
- en: '[PRE101]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '`query.populate_existing()`'
  id: totrans-356
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`query.populate_existing()`'
- en: 'The eager version of `query.load()` (or `session.refresh()`). Every instance
    loaded from the query, including all eagerly loaded items, get refreshed immediately
    if already present in the session:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '`query.load()`（或`session.refresh()`）的急切版本。如果查询中加载的每个实例，包括所有急切加载的项，已经存在于会话中，则立即刷新它们：'
- en: '[PRE102]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Relations
  id: totrans-359
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关系
- en: SQL Clauses Embedded in Updates/Inserts
  id: totrans-360
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 嵌入在更新/插入中的SQL子句
- en: 'For inline execution of SQL clauses, embedded right in the UPDATE or INSERT,
    during a `flush()`:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 对于内联执行SQL子句，嵌入在`flush()`期间的UPDATE或INSERT中：
- en: '[PRE103]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: The column-attribute is set up with a deferred loader after the operation, so
    that it issues the SQL to load the new value when you next access.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 操作后使用延迟加载器设置列属性，以便在下次访问时发出加载新值的SQL。
- en: Self-referential and Cyclical Eager Loading
  id: totrans-364
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 自引用和循环急加载
- en: 'Since our alias-fu has improved, `relation()` can join along the same table
    *any number of times*; you tell it how deep you want to go. Lets show the self-referential
    `TreeNode` more clearly:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的别名技术已经提高，`relation()`可以在同一张表上*任意次*进行连接；您告诉它您想要深入多少层。让我们更清楚地展示自引用的`TreeNode`：
- en: '[PRE104]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'So what happens when we say:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们说：
- en: '[PRE105]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '? A join along aliases, three levels deep off the parent:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '? 通过别名进行连接，从父级深入三层：'
- en: '[PRE106]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Notice the nice clean alias names too. The joining doesn’t care if it’s against
    the same immediate table or some other object which then cycles back to the beginning.
    Any kind of chain of eager loads can cycle back onto itself when `join_depth`
    is specified. When not present, eager loading automatically stops when it hits
    a cycle.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 注意漂亮干净的别名名称。连接不在乎是否针对同一立即表或一些其他对象，然后循环回开始。当指定`join_depth`时，任何类型的急加载链都可以循环回自身。当不存在时，急加载在遇到循环时会自动停止。
- en: Composite Types
  id: totrans-372
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 复合类型
- en: 'This is one from the Hibernate camp. Composite Types let you define a custom
    datatype that is composed of more than one column (or one column, if you wanted).
    Lets define a new type, `Point`. Stores an x/y coordinate:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 这是来自Hibernate阵营的一个例子。复合类型允许您定义一个由多个列（或一个列，如果您愿意）组成的自定义数据类型。让我们定义一个新类型，`Point`。存储一个x/y坐标：
- en: '[PRE107]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: The way the `Point` object is defined is specific to a custom type; constructor
    takes a list of arguments, and the `__composite_values__()` method produces a
    sequence of those arguments. The order will match up to our mapper, as we’ll see
    in a moment.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '`Point`对象的定义方式是特定于自定义类型的；构造函数接受参数列表，并且`__composite_values__()`方法生成这些参数的序列。顺序将与我们的映射器匹配，我们马上就会看到。'
- en: 'Let’s create a table of vertices storing two points per row:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个存储每行两个点的顶点表：
- en: '[PRE108]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Then, map it ! We’ll create a `Vertex` object which stores two `Point` objects:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，映射它！我们将创建一个存储两个`Point`对象的`Vertex`对象：
- en: '[PRE109]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Once you’ve set up your composite type, it’s usable just like any other type:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置了您的复合类型，它就可以像任何其他类型一样使用：
- en: '[PRE110]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'If you’d like to define the way the mapped attributes generate SQL clauses
    when used in expressions, create your own `sqlalchemy.orm.PropComparator` subclass,
    defining any of the common operators (like `__eq__()`, `__le__()`, etc.), and
    send it in to `composite()`. Composite types work as primary keys too, and are
    usable in `query.get()`:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想定义映射属性在表达式中生成SQL子句的方式，请创建自己的`sqlalchemy.orm.PropComparator`子类，定义任何常见操作符（如`__eq__()`，`__le__()`等），并将其发送到`composite()`。复合类型也可以作为主键，并且可在`query.get()`中使用：
- en: '[PRE111]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '`dynamic_loader()` relations'
  id: totrans-384
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`dynamic_loader()`关系'
- en: A `relation()` that returns a live `Query` object for all read operations. Write
    operations are limited to just `append()` and `remove()`, changes to the collection
    are not visible until the session is flushed. This feature is particularly handy
    with an “autoflushing” session which will flush before each query.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 一个返回所有读操作的实时`Query`对象的`relation()`。写操作仅限于`append()`和`remove()`，对集合的更改在会话刷新之前不可见。此功能在“自动刷新”会话中特别方便，该会话会在每次查询之前刷新。
- en: '[PRE112]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'New Options: `undefer_group()`, `eagerload_all()`'
  id: totrans-387
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 新选项：`undefer_group()`，`eagerload_all()`
- en: 'A couple of query options which are handy. `undefer_group()` marks a whole
    group of “deferred” columns as undeferred:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 一些方便的查询选项。`undefer_group()`将整个“延迟”列组标记为未延迟：
- en: '[PRE113]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'and `eagerload_all()` sets a chain of attributes to be eager in one pass:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 和`eagerload_all()`设置一系列属性在一次遍历中急加载：
- en: '[PRE114]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: New Collection API
  id: totrans-392
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 新的集合 API
- en: Collections are no longer proxied by an {{{InstrumentedList}}} proxy, and access
    to members, methods and attributes is direct. Decorators now intercept objects
    entering and leaving the collection, and it is now possible to easily write a
    custom collection class that manages its own membership. Flexible decorators also
    replace the named method interface of custom collections in 0.3, allowing any
    class to be easily adapted to use as a collection container.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 集合不再由 {{{InstrumentedList}}} 代理进行代理，并且对成员、方法和属性的访问是直接的。装饰器现在拦截进入和离开集合的对象，并且现在可以轻松地编写一个自定义集合类来管理自己的成员。灵活的装饰器还取代了0.3版本中自定义集合的命名方法接口，允许任何类轻松地适应用作集合容器。
- en: 'Dictionary-based collections are now much easier to use and fully `dict`-like.
    Changing `__iter__` is no longer needed for `dict``s, and new built-in ``dict`
    types cover many needs:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 基于字典的集合现在更易于使用，并且完全类似于`dict`。对`dict`来说，不再需要更改`__iter__`，新的内置`dict`类型涵盖了许多需求：
- en: '[PRE115]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: Existing 0.3 `dict`-like and freeform object derived collection classes will
    need to be updated for the new API. In most cases this is simply a matter of adding
    a couple decorators to the class definition.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 现有的0.3版本类似`dict`和自由对象衍生的集合类将需要更新到新的 API。在大多数情况下，这只是在类定义中添加几个装饰器的问题。
- en: Mapped Relations from External Tables/Subqueries
  id: totrans-397
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 来自外部表/子查询的映射关系
- en: 'This feature quietly appeared in 0.3 but has been improved in 0.4 thanks to
    better ability to convert subqueries against a table into subqueries against an
    alias of that table; this is key for eager loading, aliased joins in queries,
    etc. It reduces the need to create mappers against select statements when you
    just need to add some extra columns or subqueries:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 该功能在0.3版本中悄悄出现，但由于更好地能够将针对表的子查询转换为针对该表的别名的子查询而得到改进，在0.4版本中得到改进；这对于贪婪加载、查询中的别名连接等非常重要。它减少了在只需要添加一些额外列或子查询时创建针对选择语句的映射器的需求：
- en: '[PRE116]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'a typical query looks like:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的查询看起来像：
- en: '[PRE117]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: SQL Clauses Embedded in Updates/Inserts
  id: totrans-402
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 更新/插入中嵌入的 SQL 子句
- en: 'For inline execution of SQL clauses, embedded right in the UPDATE or INSERT,
    during a `flush()`:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 对于嵌入在`flush()`期间的 UPDATE 或 INSERT 中的 SQL 子句的内联执行：
- en: '[PRE118]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: The column-attribute is set up with a deferred loader after the operation, so
    that it issues the SQL to load the new value when you next access.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 在操作后设置了延迟加载器的列属性，以便在下次访问时发出加载新值的 SQL。
- en: Self-referential and Cyclical Eager Loading
  id: totrans-406
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 自引用和循环贪婪加载
- en: 'Since our alias-fu has improved, `relation()` can join along the same table
    *any number of times*; you tell it how deep you want to go. Lets show the self-referential
    `TreeNode` more clearly:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的别名技术已经提高，`relation()`可以沿着同一张表*任意次数*进行连接；您告诉它您想要多深。让我们更清楚地展示自引用的`TreeNode`：
- en: '[PRE119]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'So what happens when we say:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，当我们说：
- en: '[PRE120]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '? A join along aliases, three levels deep off the parent:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '? 在父级的别名上三级深度的连接：'
- en: '[PRE121]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: Notice the nice clean alias names too. The joining doesn’t care if it’s against
    the same immediate table or some other object which then cycles back to the beginning.
    Any kind of chain of eager loads can cycle back onto itself when `join_depth`
    is specified. When not present, eager loading automatically stops when it hits
    a cycle.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这些漂亮干净的别名。连接不在乎它是针对同一即时表还是针对某个其他对象，然后又回到开头。当指定了`join_depth`时，任何类型的贪婪加载都可以在自身上循环回来。当不存在时，贪婪加载在碰到循环时会自动停止。
- en: Composite Types
  id: totrans-414
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 复合类型
- en: 'This is one from the Hibernate camp. Composite Types let you define a custom
    datatype that is composed of more than one column (or one column, if you wanted).
    Lets define a new type, `Point`. Stores an x/y coordinate:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 Hibernate 阵营中的一个特点。复合类型允许您定义一个由多个列（或一个列，如果您想要的话）组成的自定义数据类型。让我们定义一个新类型，`Point`。存储一个
    x/y 坐标：
- en: '[PRE122]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: The way the `Point` object is defined is specific to a custom type; constructor
    takes a list of arguments, and the `__composite_values__()` method produces a
    sequence of those arguments. The order will match up to our mapper, as we’ll see
    in a moment.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '`Point` 对象的定义方式是特定于自定义类型的；构造函数接受一个参数列表，并且`__composite_values__()`方法生成这些参数的序列。稍后我们将看到，顺序将与我们的映射器相匹配。'
- en: 'Let’s create a table of vertices storing two points per row:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个存储每行两个点的顶点表：
- en: '[PRE123]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'Then, map it ! We’ll create a `Vertex` object which stores two `Point` objects:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，映射它！我们将创建一个存储两个`Point`对象的`Vertex`对象：
- en: '[PRE124]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'Once you’ve set up your composite type, it’s usable just like any other type:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置了复合类型，它就可以像任何其他类型一样使用：
- en: '[PRE125]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'If you’d like to define the way the mapped attributes generate SQL clauses
    when used in expressions, create your own `sqlalchemy.orm.PropComparator` subclass,
    defining any of the common operators (like `__eq__()`, `__le__()`, etc.), and
    send it in to `composite()`. Composite types work as primary keys too, and are
    usable in `query.get()`:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要定义映射属性在表达式中生成 SQL 子句的方式，请创建自己的 `sqlalchemy.orm.PropComparator` 子类，定义任何常见操作符（如
    `__eq__()`，`__le__()` 等），并将其发送到 `composite()`。组合类型也可以作为主键，并且可在 `query.get()` 中使用：
- en: '[PRE126]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '`dynamic_loader()` relations'
  id: totrans-426
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`dynamic_loader()` 关系'
- en: A `relation()` that returns a live `Query` object for all read operations. Write
    operations are limited to just `append()` and `remove()`, changes to the collection
    are not visible until the session is flushed. This feature is particularly handy
    with an “autoflushing” session which will flush before each query.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: '`relation()` 返回一个用于所有读取操作的实时 `Query` 对象。写操作仅限于 `append()` 和 `remove()`，对集合的更改在会话刷新之前不可见。这个特性在“自动刷新”会话中特别方便，在每次查询之前都会刷新。'
- en: '[PRE127]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'New Options: `undefer_group()`, `eagerload_all()`'
  id: totrans-429
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 新选项：`undefer_group()`，`eagerload_all()`
- en: 'A couple of query options which are handy. `undefer_group()` marks a whole
    group of “deferred” columns as undeferred:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 一些方便的查询选项。`undefer_group()` 将整个“延迟”列组标记为未延迟：
- en: '[PRE128]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'and `eagerload_all()` sets a chain of attributes to be eager in one pass:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 和 `eagerload_all()` 一次性设置一系列属性为急加载：
- en: '[PRE129]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: New Collection API
  id: totrans-434
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 新的集合 API
- en: Collections are no longer proxied by an {{{InstrumentedList}}} proxy, and access
    to members, methods and attributes is direct. Decorators now intercept objects
    entering and leaving the collection, and it is now possible to easily write a
    custom collection class that manages its own membership. Flexible decorators also
    replace the named method interface of custom collections in 0.3, allowing any
    class to be easily adapted to use as a collection container.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 集合不再由 `InstrumentedList` 代理代理，并且对成员、方法和属性的访问是直接的。装饰器现在拦截进入和离开集合的对象，并且现在可以轻松编写一个自定义的集合类来管理其自己的成员资格。灵活的装饰器也替代了
    0.3 版本中自定义集合的命名方法接口，允许任何类容易地被调整为用作集合容器。
- en: 'Dictionary-based collections are now much easier to use and fully `dict`-like.
    Changing `__iter__` is no longer needed for `dict``s, and new built-in ``dict`
    types cover many needs:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 基于字典的集合现在更易于使用，并完全类似于 `dict`。不再需要更改 `__iter__` 来使用 `dict`，并且新的内置 `dict` 类型满足了许多需求：
- en: '[PRE130]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: Existing 0.3 `dict`-like and freeform object derived collection classes will
    need to be updated for the new API. In most cases this is simply a matter of adding
    a couple decorators to the class definition.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 现有的 0.3 版本类似于 `dict` 和自由形式对象派生的集合类需要更新到新的 API。在大多数情况下，这只是简单地向类定义中添加几个装饰器。
- en: Mapped Relations from External Tables/Subqueries
  id: totrans-439
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 来自外部表/子查询的映射关系
- en: 'This feature quietly appeared in 0.3 but has been improved in 0.4 thanks to
    better ability to convert subqueries against a table into subqueries against an
    alias of that table; this is key for eager loading, aliased joins in queries,
    etc. It reduces the need to create mappers against select statements when you
    just need to add some extra columns or subqueries:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特性在 0.3 中悄然出现，但在 0.4 中得到了改进，这要归功于更好地将针对表的子查询转换为针对该表的别名的子查询的能力；这对于急加载、查询中的别名连接等非常重要。它减少了在只需要添加一些额外列或子查询时创建针对选择语句的映射器的必要性：
- en: '[PRE131]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'a typical query looks like:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的查询看起来像这样：
- en: '[PRE132]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: Horizontal Scaling (Sharding) API
  id: totrans-444
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 水平扩展（分片）API
- en: '[browser:/sqlalchemy/trunk/examples/sharding/attribute_shard .py]'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: '[browser:/sqlalchemy/trunk/examples/sharding/attribute_shard .py]'
- en: Sessions
  id: totrans-446
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 会话
- en: New Session Create Paradigm; SessionContext, assignmapper Deprecated
  id: totrans-447
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 新的会话创建范例；SessionContext，assignmapper 弃用
- en: That’s right, the whole shebang is being replaced with two configurational functions.
    Using both will produce the most 0.1-ish feel we’ve had since 0.1 (i.e., the least
    amount of typing).
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，整个流程正在用两个配置函数替换。同时使用两者将产生自 0.1 版以来最接近 0.1 版感觉的体验（即，输入最少）。
- en: 'Configure your own `Session` class right where you define your `engine` (or
    anywhere):'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义您的 `engine`（或任何位置）的地方配置您自己的 `Session` 类：
- en: '[PRE133]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'If you need to post-configure your Session, say with an engine, add it later
    with `configure()`:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要在会话后配置您的会话，比如说使用引擎，请稍后使用 `configure()` 添加：
- en: '[PRE134]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'All the behaviors of `SessionContext` and the `query` and `__init__` methods
    of `assignmapper` are moved into the new `scoped_session()` function, which is
    compatible with both `sessionmaker` as well as `create_session()`:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 所有`SessionContext`的行为以及`assignmapper`的`query`和`__init__`方法都移至新的`scoped_session()`函数中，该函数与`sessionmaker`和`create_session()`兼容：
- en: '[PRE135]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: When using a thread-local `Session`, the returned class has all of `Session's`
    interface implemented as classmethods, and “assignmapper“‘s functionality is available
    using the `mapper` classmethod. Just like the old `objectstore` days….
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用线程本地`Session`时，返回的类已实现了所有`Session`的接口作为类方法，并且可以使用`mapper`类方法来使用“assignmapper”的功能。就像旧的`objectstore`时代一样……。
- en: '[PRE136]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: Sessions are again Weak Referencing By Default
  id: totrans-457
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 会话再次默认使用弱引用
- en: The weak_identity_map flag is now set to `True` by default on Session. Instances
    which are externally deferenced and fall out of scope are removed from the session
    automatically. However, items which have “dirty” changes present will remain strongly
    referenced until those changes are flushed at which case the object reverts to
    being weakly referenced (this works for ‘mutable’ types, like picklable attributes,
    as well). Setting weak_identity_map to `False` restores the old strong-referencing
    behavior for those of you using the session like a cache.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: '`weak_identity_map`标志现在默认设置为`True`在`Session`上。外部解除引用并超出范围的实例将自动从会话中移除。但是，具有“脏”更改的项目将保持强引用，直到这些更改被刷新，此时对象将恢复为弱引用（这适用于“可变”类型，如可选属性）。将`weak_identity_map`设置为`False`将为那些像缓存一样使用会话的人恢复旧的强引用行为。'
- en: Auto-Transactional Sessions
  id: totrans-459
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 自动事务会话
- en: As you might have noticed above, we are calling `commit()` on `Session`. The
    flag `transactional=True` means the `Session` is always in a transaction, `commit()`
    persists permanently.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能已经注意到的，我们在`Session`上调用`commit()`。标志`transactional=True`意味着`Session`始终处于事务中，`commit()`会永久保存。
- en: Auto-Flushing Sessions
  id: totrans-461
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 自动刷新会话
- en: 'Also, `autoflush=True` means the `Session` will `flush()` before each `query`
    as well as when you call `flush()` or `commit()`. So now this will work:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`autoflush=True`意味着`Session`将在每次`query`之前`flush()`，以及在调用`flush()`或`commit()`时。因此，现在这将起作用：
- en: '[PRE137]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: Transactional methods moved onto sessions
  id: totrans-464
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 事务方法移至会话
- en: '`commit()` and `rollback()`, as well as `begin()` are now directly on `Session`.
    No more need to use `SessionTransaction` for anything (it remains in the background).'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: '`commit()`和`rollback()`，以及`begin()`现在直接在`Session`上。不再需要为任何事情使用`SessionTransaction`（它仍然在后台运行）。'
- en: '[PRE138]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'Sharing a `Session` with an enclosing engine-level (i.e. non-ORM) transaction
    is easy:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 与包含引擎级（即非ORM）事务共享`Session`很容易：
- en: '[PRE139]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: Nested Session Transactions with SAVEPOINT
  id: totrans-469
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用SAVEPOINT的嵌套会话事务
- en: 'Available at the Engine and ORM level. ORM docs so far:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 在引擎和ORM级别可用。迄今为止的ORM文档：
- en: '[https://www.sqlalchemy.org/docs/04/session.html#unitofwork_managing](https://www.sqlalchemy.org/docs/04/session.html#unitofwork_managing)'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.sqlalchemy.org/docs/04/session.html#unitofwork_managing](https://www.sqlalchemy.org/docs/04/session.html#unitofwork_managing)'
- en: Two-Phase Commit Sessions
  id: totrans-472
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 两阶段提交会话
- en: 'Available at the Engine and ORM level. ORM docs so far:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 在引擎和ORM级别可用。迄今为止的ORM文档：
- en: '[https://www.sqlalchemy.org/docs/04/session.html#unitofwork_managing](https://www.sqlalchemy.org/docs/04/session.html#unitofwork_managing)'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.sqlalchemy.org/docs/04/session.html#unitofwork_managing](https://www.sqlalchemy.org/docs/04/session.html#unitofwork_managing)'
- en: New Session Create Paradigm; SessionContext, assignmapper Deprecated
  id: totrans-475
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 新的会话创建范式；SessionContext，assignmapper已弃用
- en: That’s right, the whole shebang is being replaced with two configurational functions.
    Using both will produce the most 0.1-ish feel we’ve had since 0.1 (i.e., the least
    amount of typing).
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，整个设置正在被两个配置函数替换。同时使用两者将产生自0.1版本以来最接近0.1版本的感觉（即，键入的数量最少）。
- en: 'Configure your own `Session` class right where you define your `engine` (or
    anywhere):'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义您的`engine`（或任何地方）时配置自己的`Session`类：
- en: '[PRE140]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'If you need to post-configure your Session, say with an engine, add it later
    with `configure()`:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要对会话进行后期配置，比如添加引擎，请稍后使用`configure()`进行添加：
- en: '[PRE141]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'All the behaviors of `SessionContext` and the `query` and `__init__` methods
    of `assignmapper` are moved into the new `scoped_session()` function, which is
    compatible with both `sessionmaker` as well as `create_session()`:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 所有`SessionContext`的行为以及`assignmapper`的`query`和`__init__`方法都移至新的`scoped_session()`函数中，该函数与`sessionmaker`和`create_session()`兼容：
- en: '[PRE142]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: When using a thread-local `Session`, the returned class has all of `Session's`
    interface implemented as classmethods, and “assignmapper“‘s functionality is available
    using the `mapper` classmethod. Just like the old `objectstore` days….
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 使用线程本地 `Session` 时，返回的类实现了所有 `Session` 的接口作为类方法，并且可以使用 `mapper` 类方法来使用 “assignmapper”
    的功能。就像旧的 `objectstore` 时代一样……。
- en: '[PRE143]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: Sessions are again Weak Referencing By Default
  id: totrans-485
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 会话再次默认为弱引用
- en: The weak_identity_map flag is now set to `True` by default on Session. Instances
    which are externally deferenced and fall out of scope are removed from the session
    automatically. However, items which have “dirty” changes present will remain strongly
    referenced until those changes are flushed at which case the object reverts to
    being weakly referenced (this works for ‘mutable’ types, like picklable attributes,
    as well). Setting weak_identity_map to `False` restores the old strong-referencing
    behavior for those of you using the session like a cache.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: weak_identity_map 标志现在默认设置为 `True` 在 Session 上。外部解除引用并超出范围的实例会自动从会话中移除。但是，具有“脏”更改的项目将保持强引用，直到这些更改被刷新，此时对象将恢复为弱引用（这适用于‘可变’类型，如可选属性）。将
    weak_identity_map 设置为 `False` 可以为那些像缓存一样使用会话的人恢复旧的强引用行为。
- en: Auto-Transactional Sessions
  id: totrans-487
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 自动事务会话
- en: As you might have noticed above, we are calling `commit()` on `Session`. The
    flag `transactional=True` means the `Session` is always in a transaction, `commit()`
    persists permanently.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能已经注意到的，我们在 `Session` 上调用 `commit()`。标志 `transactional=True` 意味着 `Session`
    总是处于事务中，`commit()` 永久保存。
- en: Auto-Flushing Sessions
  id: totrans-489
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 自动刷新会话
- en: 'Also, `autoflush=True` means the `Session` will `flush()` before each `query`
    as well as when you call `flush()` or `commit()`. So now this will work:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`autoflush=True` 意味着 `Session` 在每次 `query` 之前都会执行 `flush()`，以及在调用 `flush()`
    或 `commit()` 时也会执行。所以现在这将起作用：
- en: '[PRE144]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: Transactional methods moved onto sessions
  id: totrans-492
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 事务方法移至会话
- en: '`commit()` and `rollback()`, as well as `begin()` are now directly on `Session`.
    No more need to use `SessionTransaction` for anything (it remains in the background).'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: '`commit()` 和 `rollback()`，以及 `begin()` 现在直接在 `Session` 上。不再需要为任何事情使用 `SessionTransaction`（它仍然在后台运行）。'
- en: '[PRE145]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'Sharing a `Session` with an enclosing engine-level (i.e. non-ORM) transaction
    is easy:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 与封闭的引擎级（即非 ORM）事务共享 `Session` 很容易：
- en: '[PRE146]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: Nested Session Transactions with SAVEPOINT
  id: totrans-497
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 SAVEPOINT 的嵌套会话事务
- en: 'Available at the Engine and ORM level. ORM docs so far:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 在引擎和 ORM 层面都可用。迄今为止的 ORM 文档：
- en: '[https://www.sqlalchemy.org/docs/04/session.html#unitofwork_managing](https://www.sqlalchemy.org/docs/04/session.html#unitofwork_managing)'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.sqlalchemy.org/docs/04/session.html#unitofwork_managing](https://www.sqlalchemy.org/docs/04/session.html#unitofwork_managing)'
- en: Two-Phase Commit Sessions
  id: totrans-500
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 两阶段提交会话
- en: 'Available at the Engine and ORM level. ORM docs so far:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 在引擎和 ORM 层面都可用。迄今为止的 ORM 文档：
- en: '[https://www.sqlalchemy.org/docs/04/session.html#unitofwork_managing](https://www.sqlalchemy.org/docs/04/session.html#unitofwork_managing)'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.sqlalchemy.org/docs/04/session.html#unitofwork_managing](https://www.sqlalchemy.org/docs/04/session.html#unitofwork_managing)'
- en: Inheritance
  id: totrans-503
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 继承
- en: Polymorphic Inheritance with No Joins or Unions
  id: totrans-504
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 无连接或联合的多态继承
- en: 'New docs for inheritance: [https://www.sqlalchemy.org/docs/04](https://www.sqlalchemy.org/docs/04)
    /mappers.html#advdatamapping_mapper_inheritance_joined'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 继承的新文档：[https://www.sqlalchemy.org/docs/04](https://www.sqlalchemy.org/docs/04)
    /mappers.html#advdatamapping_mapper_inheritance_joined
- en: Better Polymorphic Behavior with `get()`
  id: totrans-506
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 `get()` 时更好的多态行为
- en: All classes within a joined-table inheritance hierarchy get an `_instance_key`
    using the base class, i.e. `(BaseClass, (1, ), None)`. That way when you call
    `get()` a `Query` against the base class, it can locate subclass instances in
    the current identity map without querying the database.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 在加入表继承层次结构中，所有类都使用基类获得 `_instance_key`，即 `(BaseClass, (1, ), None)`。这样，当您对基类进行
    `get()` 查询时，它可以在当前标识映射中定位子类实例，而无需查询数据库。
- en: Polymorphic Inheritance with No Joins or Unions
  id: totrans-508
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 无连接或联合的多态继承
- en: 'New docs for inheritance: [https://www.sqlalchemy.org/docs/04](https://www.sqlalchemy.org/docs/04)
    /mappers.html#advdatamapping_mapper_inheritance_joined'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 继承的新文档：[https://www.sqlalchemy.org/docs/04](https://www.sqlalchemy.org/docs/04)
    /mappers.html#advdatamapping_mapper_inheritance_joined
- en: Better Polymorphic Behavior with `get()`
  id: totrans-510
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 `get()` 时更好的多态行为
- en: All classes within a joined-table inheritance hierarchy get an `_instance_key`
    using the base class, i.e. `(BaseClass, (1, ), None)`. That way when you call
    `get()` a `Query` against the base class, it can locate subclass instances in
    the current identity map without querying the database.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 在连接表继承层次结构中，所有类都使用基类获取`_instance_key`，即`(BaseClass, (1, ), None)`。这样当你对基类调用`get()`时，它可以在当前标识映射中定位子类实例，而无需查询数据库。
- en: Types
  id: totrans-512
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类型
- en: Custom Subclasses of `sqlalchemy.types.TypeDecorator`
  id: totrans-513
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`sqlalchemy.types.TypeDecorator`的自定义子类'
- en: There is a [New API](https://www.sqlalchemy.org/docs/04/types.html#types_custom)
    for subclassing a TypeDecorator. Using the 0.3 API causes compilation errors in
    some cases.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个[新API](https://www.sqlalchemy.org/docs/04/types.html#types_custom)用于子类化TypeDecorator。在某些情况下使用0.3
    API会导致编译错误。
- en: Custom Subclasses of `sqlalchemy.types.TypeDecorator`
  id: totrans-515
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`sqlalchemy.types.TypeDecorator`的自定义子类'
- en: There is a [New API](https://www.sqlalchemy.org/docs/04/types.html#types_custom)
    for subclassing a TypeDecorator. Using the 0.3 API causes compilation errors in
    some cases.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个[新API](https://www.sqlalchemy.org/docs/04/types.html#types_custom)用于子类化TypeDecorator。在某些情况下使用0.3
    API会导致编译错误。
- en: SQL Expressions
  id: totrans-517
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SQL表达式
- en: All New, Deterministic Label/Alias Generation
  id: totrans-518
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 所有新的、确定性的标签/别名生成
- en: 'All the “anonymous” labels and aliases use a simple <name>_<number> format
    now. SQL is much easier to read and is compatible with plan optimizer caches.
    Just check out some of the examples in the tutorials: [https://www.sqlalchemy.org/docs/04/ormtutorial.html](https://www.sqlalchemy.org/docs/04/ormtutorial.html)
    [https://www.sqlalchemy.org/docs/04/sqlexpression.html](https://www.sqlalchemy.org/docs/04/sqlexpression.html)'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 所有“匿名”标签和别名现在都使用简单的`<name>_<number>`格式。SQL更容易阅读，并且与计划优化器缓存兼容。只需查看一些教程中的示例：[https://www.sqlalchemy.org/docs/04/ormtutorial.html](https://www.sqlalchemy.org/docs/04/ormtutorial.html)
    [https://www.sqlalchemy.org/docs/04/sqlexpression.html](https://www.sqlalchemy.org/docs/04/sqlexpression.html)
- en: Generative select() Constructs
  id: totrans-520
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生成式`select()`构造
- en: This is definitely the way to go with `select()`. See htt p://www.sqlalchemy.org/docs/04/sqlexpression.html#sql_transf
    orm .
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 这绝对是使用`select()`的正确方法。查看 [htt p://www.sqlalchemy.org/docs/04/sqlexpression.html#sql_transf
    orm](htt p://www.sqlalchemy.org/docs/04/sqlexpression.html#sql_transf orm)。
- en: New Operator System
  id: totrans-522
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 新操作系统
- en: 'SQL operators and more or less every SQL keyword there is are now abstracted
    into the compiler layer. They now act intelligently and are type/backend aware,
    see: [https://www.sqlalchemy.org/docs/04/sqlexpression.html#sql_operators](https://www.sqlalchemy.org/docs/04/sqlexpression.html#sql_operators)'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: SQL运算符和几乎每个SQL关键字现在都被抽象为编译器层。它们现在具有智能行为，并且具有类型/后端感知能力，请参阅：[https://www.sqlalchemy.org/docs/04/sqlexpression.html#sql_operators](https://www.sqlalchemy.org/docs/04/sqlexpression.html#sql_operators)
- en: All `type` Keyword Arguments Renamed to `type_`
  id: totrans-524
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 所有`type`关键字参数重命名为`type_`
- en: 'Just like it says:'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 就像它所说的：
- en: '[PRE147]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: in_ Function Changed to Accept Sequence or Selectable
  id: totrans-527
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`in_`函数更改为接受序列或可选择项'
- en: The in_ function now takes a sequence of values or a selectable as its sole
    argument. The previous API of passing in values as positional arguments still
    works, but is now deprecated. This means that
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: '`in_`函数现在以其唯一参数接受值序列或可选择的。以前的API仍然支持传递值作为位置参数，但现在已过时。这意味着'
- en: '[PRE148]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: should be changed to
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 应更改为
- en: '[PRE149]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: All New, Deterministic Label/Alias Generation
  id: totrans-532
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 所有新的、确定性的标签/别名生成
- en: 'All the “anonymous” labels and aliases use a simple <name>_<number> format
    now. SQL is much easier to read and is compatible with plan optimizer caches.
    Just check out some of the examples in the tutorials: [https://www.sqlalchemy.org/docs/04/ormtutorial.html](https://www.sqlalchemy.org/docs/04/ormtutorial.html)
    [https://www.sqlalchemy.org/docs/04/sqlexpression.html](https://www.sqlalchemy.org/docs/04/sqlexpression.html)'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 所有“匿名”标签和别名现在都使用简单的`<name>_<number>`格式。SQL更容易阅读，并且与计划优化器缓存兼容。只需查看一些教程中的示例：[https://www.sqlalchemy.org/docs/04/ormtutorial.html](https://www.sqlalchemy.org/docs/04/ormtutorial.html)
    [https://www.sqlalchemy.org/docs/04/sqlexpression.html](https://www.sqlalchemy.org/docs/04/sqlexpression.html)
- en: Generative select() Constructs
  id: totrans-534
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生成式`select()`构造
- en: This is definitely the way to go with `select()`. See htt p://www.sqlalchemy.org/docs/04/sqlexpression.html#sql_transf
    orm .
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 这绝对是使用`select()`的正确方法。查看 [htt p://www.sqlalchemy.org/docs/04/sqlexpression.html#sql_transf
    orm](htt p://www.sqlalchemy.org/docs/04/sqlexpression.html#sql_transf orm)。
- en: New Operator System
  id: totrans-536
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 新操作系统
- en: 'SQL operators and more or less every SQL keyword there is are now abstracted
    into the compiler layer. They now act intelligently and are type/backend aware,
    see: [https://www.sqlalchemy.org/docs/04/sqlexpression.html#sql_operators](https://www.sqlalchemy.org/docs/04/sqlexpression.html#sql_operators)'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: SQL 操作符以及几乎每个 SQL 关键字都现在抽象成了编译器层。它们现在具有智能行为，并且具有类型/后端感知性，请参阅：[https://www.sqlalchemy.org/docs/04/sqlexpression.html#sql_operators](https://www.sqlalchemy.org/docs/04/sqlexpression.html#sql_operators)
- en: All `type` Keyword Arguments Renamed to `type_`
  id: totrans-538
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 所有 `type` 关键字参数重命名为 `type_`
- en: 'Just like it says:'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 就像它说的那样：
- en: '[PRE150]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: in_ Function Changed to Accept Sequence or Selectable
  id: totrans-541
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`in_` 函数更改为接受序列或可选择项'
- en: The in_ function now takes a sequence of values or a selectable as its sole
    argument. The previous API of passing in values as positional arguments still
    works, but is now deprecated. This means that
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: '`in_` 函数现在接受一个值序列或可选择项作为其唯一参数。之前的传递值作为位置参数的 API 仍然有效，但现在已被弃用。这意味着'
- en: '[PRE151]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: should be changed to
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 应更改为
- en: '[PRE152]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: Schema and Reflection
  id: totrans-546
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模式和反射
- en: '`MetaData`, `BoundMetaData`, `DynamicMetaData`…'
  id: totrans-547
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`MetaData`、`BoundMetaData`、`DynamicMetaData`…'
- en: 'In the 0.3.x series, `BoundMetaData` and `DynamicMetaData` were deprecated
    in favor of `MetaData` and `ThreadLocalMetaData`. The older names have been removed
    in 0.4\. Updating is simple:'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 在 0.3.x 系列中，`BoundMetaData` 和 `DynamicMetaData` 已被弃用，而不是 `MetaData` 和 `ThreadLocalMetaData`。旧名称已在
    0.4 版本中移除。更新很简单：
- en: '[PRE153]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: The seldom-used `name` parameter to `MetaData` types has been removed. The `ThreadLocalMetaData`
    constructor now takes no arguments. Both types can now be bound to an `Engine`
    or a single `Connection`.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: '`MetaData` 类型中不常用的 `name` 参数已被移除。`ThreadLocalMetaData` 构造函数现在不接受任何参数。这两种类型现在可以绑定到一个
    `Engine` 或单个 `Connection`。'
- en: One Step Multi-Table Reflection
  id: totrans-551
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一步多表反射
- en: 'You can now load table definitions and automatically create `Table` objects
    from an entire database or schema in one pass:'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以在一次通行中从整个数据库或模式加载表定义并自动创建 `Table` 对象：
- en: '[PRE154]'
  id: totrans-553
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '`MetaData` also gains a `.reflect()` method enabling finer control over the
    loading process, including specification of a subset of available tables to load.'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: '`MetaData` 还增加了一个 `.reflect()` 方法，可以更精细地控制加载过程，包括指定要加载的可用表的子集。'
- en: '`MetaData`, `BoundMetaData`, `DynamicMetaData`…'
  id: totrans-555
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`MetaData`、`BoundMetaData`、`DynamicMetaData`…'
- en: 'In the 0.3.x series, `BoundMetaData` and `DynamicMetaData` were deprecated
    in favor of `MetaData` and `ThreadLocalMetaData`. The older names have been removed
    in 0.4\. Updating is simple:'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 在 0.3.x 系列中，`BoundMetaData` 和 `DynamicMetaData` 已被弃用，而不是 `MetaData` 和 `ThreadLocalMetaData`。旧名称已在
    0.4 版本中移除。更新很简单：
- en: '[PRE155]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: The seldom-used `name` parameter to `MetaData` types has been removed. The `ThreadLocalMetaData`
    constructor now takes no arguments. Both types can now be bound to an `Engine`
    or a single `Connection`.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: '`MetaData` 类型中不常用的 `name` 参数已经被移除。`ThreadLocalMetaData` 构造函数现在不接受任何参数。这两种类型现在可以绑定到一个
    `Engine` 或单个 `Connection`。'
- en: One Step Multi-Table Reflection
  id: totrans-559
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一步多表反射
- en: 'You can now load table definitions and automatically create `Table` objects
    from an entire database or schema in one pass:'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您可以在一次通行中从整个数据库或模式加载表定义并自动创建 `Table` 对象：
- en: '[PRE156]'
  id: totrans-561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: '`MetaData` also gains a `.reflect()` method enabling finer control over the
    loading process, including specification of a subset of available tables to load.'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: '`MetaData` 还增加了一个 `.reflect()` 方法，可以更精细地控制加载过程，包括指定要加载的可用表的子集。'
- en: SQL Execution
  id: totrans-563
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SQL 执行
- en: '`engine`, `connectable`, and `bind_to` are all now `bind`'
  id: totrans-564
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`engine`、`connectable` 和 `bind_to` 现在都是 `bind`'
- en: '`Transactions`, `NestedTransactions` and `TwoPhaseTransactions`'
  id: totrans-565
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`Transactions`、`NestedTransactions` 和 `TwoPhaseTransactions`'
- en: Connection Pool Events
  id: totrans-566
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接池事件
- en: The connection pool now fires events when new DB-API connections are created,
    checked out and checked back into the pool. You can use these to execute session-scoped
    SQL setup statements on fresh connections, for example.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 当新的 DB-API 连接被创建、检出和重新放回到池中时，连接池现在会触发事件。您可以使用这些事件在新连接上执行会话范围的 SQL 设置语句，例如。
- en: Oracle Engine Fixed
  id: totrans-568
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Oracle Engine 修复
- en: In 0.3.11, there were bugs in the Oracle Engine on how Primary Keys are handled.
    These bugs could cause programs that worked fine with other engines, such as sqlite,
    to fail when using the Oracle Engine. In 0.4, the Oracle Engine has been reworked,
    fixing these Primary Key problems.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 在 0.3.11 版本中，Oracle Engine 处理主键的方式存在 bug。这些 bug 可能导致在使用 Oracle Engine 时，那些在其他引擎（如
    sqlite）上运行良好的程序失败。在 0.4 版本中，Oracle Engine 已经重做，修复了这些主键问题。
- en: Out Parameters for Oracle
  id: totrans-570
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Oracle 的输出参数
- en: '[PRE157]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: Connection-bound `MetaData`, `Sessions`
  id: totrans-572
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接绑定的 `MetaData`、`Sessions`
- en: '`MetaData` and `Session` can be explicitly bound to a connection:'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: '`MetaData` 和 `Session` 可以明确绑定到一个连接：'
- en: '[PRE158]'
  id: totrans-574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: Faster, More Foolproof `ResultProxy` Objects
  id: totrans-575
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更快、更可靠的 `ResultProxy` 对象
- en: '`engine`, `connectable`, and `bind_to` are all now `bind`'
  id: totrans-576
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`engine`，`connectable` 和 `bind_to` 现在都改为 `bind`'
- en: '`Transactions`, `NestedTransactions` and `TwoPhaseTransactions`'
  id: totrans-577
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`Transactions`，`NestedTransactions` 和 `TwoPhaseTransactions`'
- en: Connection Pool Events
  id: totrans-578
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接池事件
- en: The connection pool now fires events when new DB-API connections are created,
    checked out and checked back into the pool. You can use these to execute session-scoped
    SQL setup statements on fresh connections, for example.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 现在连接池在创建新的 DB-API 连接、检出和检入连接池时会触发事件。您可以利用这些事件在新连接上执行会话范围的 SQL 设置语句，例如。
- en: Oracle Engine Fixed
  id: totrans-580
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Oracle 引擎已修复
- en: In 0.3.11, there were bugs in the Oracle Engine on how Primary Keys are handled.
    These bugs could cause programs that worked fine with other engines, such as sqlite,
    to fail when using the Oracle Engine. In 0.4, the Oracle Engine has been reworked,
    fixing these Primary Key problems.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 在 0.3.11 版本中，Oracle 引擎在处理主键时存在 bug。这些 bug 可能导致在使用 Oracle 引擎时，那些在其他引擎（如 sqlite）上正常运行的程序失败。在
    0.4 版本中，Oracle 引擎已经重新设计，修复了这些主键问题。
- en: Out Parameters for Oracle
  id: totrans-582
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用于 Oracle 的输出参数
- en: '[PRE159]'
  id: totrans-583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: Connection-bound `MetaData`, `Sessions`
  id: totrans-584
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接绑定的 `MetaData`，`Sessions`
- en: '`MetaData` and `Session` can be explicitly bound to a connection:'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: '`MetaData` 和 `Session` 可以显式绑定到连接：'
- en: '[PRE160]'
  id: totrans-586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: Faster, More Foolproof `ResultProxy` Objects
  id: totrans-587
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更快、更可靠的 `ResultProxy` 对象
