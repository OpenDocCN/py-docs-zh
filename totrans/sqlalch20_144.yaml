- en: What’s New in SQLAlchemy 1.1?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.sqlalchemy.org/en/20/changelog/migration_11.html](https://docs.sqlalchemy.org/en/20/changelog/migration_11.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: About this Document
  prefs: []
  type: TYPE_NORMAL
- en: This document describes changes between SQLAlchemy version 1.0 and SQLAlchemy
    version 1.1.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This guide introduces what’s new in SQLAlchemy version 1.1, and also documents
    changes which affect users migrating their applications from the 1.0 series of
    SQLAlchemy to 1.1.
  prefs: []
  type: TYPE_NORMAL
- en: Please carefully review the sections on behavioral changes for potentially backwards-incompatible
    changes in behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Platform / Installer Changes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Setuptools is now required for install
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: SQLAlchemy’s `setup.py` file has for many years supported operation both with
    Setuptools installed and without; supporting a “fallback” mode that uses straight
    Distutils. As a Setuptools-less Python environment is now unheard of, and in order
    to support the featureset of Setuptools more fully, in particular to support py.test’s
    integration with it as well as things like “extras”, `setup.py` now depends on
    Setuptools fully.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Installation Guide](../intro.html#installation)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#3489](https://www.sqlalchemy.org/trac/ticket/3489)'
  prefs: []
  type: TYPE_NORMAL
- en: Enabling / Disabling C Extension builds is only via environment variable
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The C Extensions build by default during install as long as it is possible.
    To disable C extension builds, the `DISABLE_SQLALCHEMY_CEXT` environment variable
    was made available as of SQLAlchemy 0.8.6 / 0.9.4\. The previous approach of using
    the `--without-cextensions` argument has been removed, as it relies on deprecated
    features of setuptools.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Building the Cython Extensions](../intro.html#c-extensions)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#3500](https://www.sqlalchemy.org/trac/ticket/3500)'
  prefs: []
  type: TYPE_NORMAL
- en: New Features and Improvements - ORM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '### New Session lifecycle events'
  prefs: []
  type: TYPE_NORMAL
- en: The [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    has long supported events that allow some degree of tracking of state changes
    to objects, including [`SessionEvents.before_attach()`](../orm/events.html#sqlalchemy.orm.SessionEvents.before_attach
    "sqlalchemy.orm.SessionEvents.before_attach"), [`SessionEvents.after_attach()`](../orm/events.html#sqlalchemy.orm.SessionEvents.after_attach
    "sqlalchemy.orm.SessionEvents.after_attach"), and [`SessionEvents.before_flush()`](../orm/events.html#sqlalchemy.orm.SessionEvents.before_flush
    "sqlalchemy.orm.SessionEvents.before_flush"). The Session documentation also documents
    major object states at [Quickie Intro to Object States](../orm/session_state_management.html#session-object-states).
    However, there has never been system of tracking objects specifically as they
    pass through these transitions. Additionally, the status of “deleted” objects
    has historically been murky as the objects act somewhere between the “persistent”
    and “detached” states.
  prefs: []
  type: TYPE_NORMAL
- en: To clean up this area and allow the realm of session state transition to be
    fully transparent, a new series of events have been added that are intended to
    cover every possible way that an object might transition between states, and additionally
    the “deleted” status has been given its own official state name within the realm
    of session object states.
  prefs: []
  type: TYPE_NORMAL
- en: New State Transition Events
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Transitions between all states of an object such as [persistent](../glossary.html#term-persistent),
    [pending](../glossary.html#term-pending) and others can now be intercepted in
    terms of a session-level event intended to cover a specific transition. Transitions
    as objects move into a [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), move out of a [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), and even all the transitions which occur when the transaction
    is rolled back using [`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") are explicitly present in the interface of
    [`SessionEvents`](../orm/events.html#sqlalchemy.orm.SessionEvents "sqlalchemy.orm.SessionEvents").
  prefs: []
  type: TYPE_NORMAL
- en: In total, there are **ten new events**. A summary of these events is in a newly
    written documentation section [Object Lifecycle Events](../orm/session_events.html#session-lifecycle-events).
  prefs: []
  type: TYPE_NORMAL
- en: New Object State “deleted” is added, deleted objects no longer “persistent”
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The [persistent](../glossary.html#term-persistent) state of an object in the
    [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    has always been documented as an object that has a valid database identity; however
    in the case of objects that were deleted within a flush, they have always been
    in a grey area where they are not really “detached” from the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") yet, because they can still be restored within a rollback,
    but are not really “persistent” because their database identity has been deleted
    and they aren’t present in the identity map.
  prefs: []
  type: TYPE_NORMAL
- en: To resolve this grey area given the new events, a new object state [deleted](../glossary.html#term-deleted)
    is introduced. This state exists between the “persistent” and “detached” states.
    An object that is marked for deletion via [`Session.delete()`](../orm/session_api.html#sqlalchemy.orm.Session.delete
    "sqlalchemy.orm.Session.delete") remains in the “persistent” state until a flush
    proceeds; at that point, it is removed from the identity map, moves to the “deleted”
    state, and the [`SessionEvents.persistent_to_deleted()`](../orm/events.html#sqlalchemy.orm.SessionEvents.persistent_to_deleted
    "sqlalchemy.orm.SessionEvents.persistent_to_deleted") hook is invoked. If the
    [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    object’s transaction is rolled back, the object is restored as persistent; the
    [`SessionEvents.deleted_to_persistent()`](../orm/events.html#sqlalchemy.orm.SessionEvents.deleted_to_persistent
    "sqlalchemy.orm.SessionEvents.deleted_to_persistent") transition is called. Otherwise
    if the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    object’s transaction is committed, the [`SessionEvents.deleted_to_detached()`](../orm/events.html#sqlalchemy.orm.SessionEvents.deleted_to_detached
    "sqlalchemy.orm.SessionEvents.deleted_to_detached") transition is invoked.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, the [`InstanceState.persistent`](../orm/internals.html#sqlalchemy.orm.InstanceState.persistent
    "sqlalchemy.orm.InstanceState.persistent") accessor **no longer returns True**
    for an object that is in the new “deleted” state; instead, the [`InstanceState.deleted`](../orm/internals.html#sqlalchemy.orm.InstanceState.deleted
    "sqlalchemy.orm.InstanceState.deleted") accessor has been enhanced to reliably
    report on this new state. When the object is detached, the [`InstanceState.deleted`](../orm/internals.html#sqlalchemy.orm.InstanceState.deleted
    "sqlalchemy.orm.InstanceState.deleted") returns False and the [`InstanceState.detached`](../orm/internals.html#sqlalchemy.orm.InstanceState.detached
    "sqlalchemy.orm.InstanceState.detached") accessor is True instead. To determine
    if an object was deleted either in the current transaction or in a previous transaction,
    use the [`InstanceState.was_deleted`](../orm/internals.html#sqlalchemy.orm.InstanceState.was_deleted
    "sqlalchemy.orm.InstanceState.was_deleted") accessor.
  prefs: []
  type: TYPE_NORMAL
- en: Strong Identity Map is Deprecated
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: One of the inspirations for the new series of transition events was to enable
    leak-proof tracking of objects as they move in and out of the identity map, so
    that a “strong reference” may be maintained mirroring the object moving in and
    out of this map. With this new capability, there is no longer any need for the
    [`Session.weak_identity_map`](../orm/session_api.html#sqlalchemy.orm.Session.params.weak_identity_map
    "sqlalchemy.orm.Session") parameter and the corresponding `StrongIdentityMap`
    object. This option has remained in SQLAlchemy for many years as the “strong-referencing”
    behavior used to be the only behavior available, and many applications were written
    to assume this behavior. It has long been recommended that strong-reference tracking
    of objects not be an intrinsic job of the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") and instead be an application-level construct built
    as needed by the application; the new event model allows even the exact behavior
    of the strong identity map to be replicated. See [Session Referencing Behavior](../orm/session_state_management.html#session-referencing-behavior)
    for a new recipe illustrating how to replace the strong identity map.
  prefs: []
  type: TYPE_NORMAL
- en: '[#2677](https://www.sqlalchemy.org/trac/ticket/2677)  ### New init_scalar()
    event intercepts default values at ORM level'
  prefs: []
  type: TYPE_NORMAL
- en: 'The ORM produces a value of `None` when an attribute that has not been set
    is first accessed, for a non-persistent object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'There’s a use case for this in-Python value to correspond to that of a Core-generated
    default value, even before the object is persisted. To suit this use case a new
    event [`AttributeEvents.init_scalar()`](../orm/events.html#sqlalchemy.orm.AttributeEvents.init_scalar
    "sqlalchemy.orm.AttributeEvents.init_scalar") is added. The new example `active_column_defaults.py`
    at [Attribute Instrumentation](../orm/examples.html#examples-instrumentation)
    illustrates a sample use, so the effect can instead be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[#1311](https://www.sqlalchemy.org/trac/ticket/1311)  ### Changes regarding
    “unhashable” types, impacts deduping of ORM rows'
  prefs: []
  type: TYPE_NORMAL
- en: The [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    object has a well-known behavior of “deduping” returned rows that contain at least
    one ORM-mapped entity (e.g., a full mapped object, as opposed to individual column
    values). The primary purpose of this is so that the handling of entities works
    smoothly in conjunction with the identity map, including to accommodate for the
    duplicate entities normally represented within joined eager loading, as well as
    when joins are used for the purposes of filtering on additional columns.
  prefs: []
  type: TYPE_NORMAL
- en: This deduplication relies upon the hashability of the elements within the row.
    With the introduction of PostgreSQL’s special types like [`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY"), [`HSTORE`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.HSTORE
    "sqlalchemy.dialects.postgresql.HSTORE") and [`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON
    "sqlalchemy.dialects.postgresql.JSON"), the experience of types within rows being
    unhashable and encountering problems here is more prevalent than it was previously.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, SQLAlchemy has since version 0.8 included a flag on datatypes that
    are noted as “unhashable”, however this flag was not used consistently on built
    in types. As described in [ARRAY and JSON types now correctly specify “unhashable”](#change-3499-postgresql),
    this flag is now set consistently for all of PostgreSQL’s “structural” types.
  prefs: []
  type: TYPE_NORMAL
- en: The “unhashable” flag is also set on the [`NullType`](../core/type_api.html#sqlalchemy.types.NullType
    "sqlalchemy.types.NullType") type, as [`NullType`](../core/type_api.html#sqlalchemy.types.NullType
    "sqlalchemy.types.NullType") is used to refer to any expression of unknown type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since [`NullType`](../core/type_api.html#sqlalchemy.types.NullType "sqlalchemy.types.NullType")
    is applied to most usages of `func`, as `func` doesn’t actually know anything
    about the function names given in most cases, **using func() will often disable
    row deduping unless explicit typing is applied**. The following examples illustrate
    `func.substr()` applied to a string expression, and `func.date()` applied to a
    datetime expression; both examples will return duplicate rows due to the joined
    eager load unless explicit typing is applied:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The above examples, in order to retain deduping, should be specified as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Additionally, the treatment of a so-called “unhashable” type is slightly different
    than its been in previous releases; internally we are using the `id()` function
    to get a “hash value” from these structures, just as we would any ordinary mapped
    object. This replaces the previous approach which applied a counter to the object.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3499](https://www.sqlalchemy.org/trac/ticket/3499)  ### Specific checks added
    for passing mapped classes, instances as SQL literals'
  prefs: []
  type: TYPE_NORMAL
- en: 'The typing system now has specific checks for passing of SQLAlchemy “inspectable”
    objects in contexts where they would otherwise be handled as literal values. Any
    SQLAlchemy built-in object that is legal to pass as a SQL value (which is not
    already a [`ClauseElement`](../core/foundation.html#sqlalchemy.sql.expression.ClauseElement
    "sqlalchemy.sql.expression.ClauseElement") instance) includes a method `__clause_element__()`
    which provides a valid SQL expression for that object. For SQLAlchemy objects
    that don’t provide this, such as mapped classes, mappers, and mapped instances,
    a more informative error message is emitted rather than allowing the DBAPI to
    receive the object and fail later. An example is illustrated below, where a string-based
    attribute `User.name` is compared to a full instance of `User()`, rather than
    against a string value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The exception is now immediate when the comparison is made between `User.name
    == some_user`. Previously, a comparison like the above would produce a SQL expression
    that would only fail once resolved into a DBAPI execution call; the mapped `User`
    object would ultimately become a bound parameter that would be rejected by the
    DBAPI.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that in the above example, the expression fails because `User.name` is
    a string-based (e.g. column oriented) attribute. The change does *not* impact
    the usual case of comparing a many-to-one relationship attribute to an object,
    which is handled distinctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[#3321](https://www.sqlalchemy.org/trac/ticket/3321)  ### New Indexable ORM
    extension'
  prefs: []
  type: TYPE_NORMAL
- en: 'The [Indexable](../orm/extensions/indexable.html) extension is an extension
    to the hybrid attribute feature which allows the construction of attributes which
    refer to specific elements of an “indexable” data type, such as an array or JSON
    field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Above, the `name` attribute will read/write the field `"name"` from the JSON
    column `data`, after initializing it to an empty dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The extension also triggers a change event when the attribute is modified, so
    that there’s no need to use [`MutableDict`](../orm/extensions/mutable.html#sqlalchemy.ext.mutable.MutableDict
    "sqlalchemy.ext.mutable.MutableDict") in order to track this change.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Indexable](../orm/extensions/indexable.html)  ### New options allowing explicit
    persistence of NULL over a default'
  prefs: []
  type: TYPE_NORMAL
- en: Related to the new JSON-NULL support added to PostgreSQL as part of [JSON “null”
    is inserted as expected with ORM operations, omitted when not present](#change-3514),
    the base [`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine "sqlalchemy.types.TypeEngine")
    class now supports a method [`TypeEngine.evaluates_none()`](../core/type_api.html#sqlalchemy.types.TypeEngine.evaluates_none
    "sqlalchemy.types.TypeEngine.evaluates_none") which allows a positive set of the
    `None` value on an attribute to be persisted as NULL, rather than omitting the
    column from the INSERT statement, which has the effect of using the column-level
    default. This allows a mapper-level configuration of the existing object-level
    technique of assigning [`null()`](../core/sqlelement.html#sqlalchemy.sql.expression.null
    "sqlalchemy.sql.expression.null") to the attribute.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Forcing NULL on a column with a default](../orm/persistence_techniques.html#session-forcing-null)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#3250](https://www.sqlalchemy.org/trac/ticket/3250)  ### Further Fixes to
    single-table inheritance querying'
  prefs: []
  type: TYPE_NORMAL
- en: 'Continuing from 1.0’s [Change to single-table-inheritance criteria when using
    from_self(), count()](migration_10.html#migration-3177), the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") should no longer inappropriately add the “single inheritance”
    criteria when the query is against a subquery expression such as an exists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Produces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The IN clause on the inside is appropriate, in order to limit to FooWidget objects,
    however previously the IN clause would also be generated a second time on the
    outside of the subquery.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3582](https://www.sqlalchemy.org/trac/ticket/3582)  ### Improved Session
    state when a SAVEPOINT is cancelled by the database'
  prefs: []
  type: TYPE_NORMAL
- en: 'A common case with MySQL is that a SAVEPOINT is cancelled when a deadlock occurs
    within the transaction. The [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") has been modified to deal with this failure mode slightly
    more gracefully, such that the outer, non-savepoint transaction still remains
    usable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This issue is a continuation of [#2696](https://www.sqlalchemy.org/trac/ticket/2696)
    where we emit a warning so that the original error can be seen when running on
    Python 2, even though the SAVEPOINT exception takes precedence. On Python 3, exceptions
    are chained so both failures are reported individually.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3680](https://www.sqlalchemy.org/trac/ticket/3680)  ### Erroneous “new instance
    X conflicts with persistent instance Y” flush errors fixed'
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") method is responsible for removing objects
    that were INSERTed into the database, e.g. moved from pending to persistent, within
    that now rolled-back transaction. Objects that make this state change are tracked
    in a weak-referencing collection, and if an object is garbage collected from that
    collection, the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    no longer worries about it (it would otherwise not scale for operations that insert
    many new objects within a transaction). However, an issue arises if the application
    re-loads that same garbage-collected row within the transaction, before the rollback
    occurs; if a strong reference to this object remains into the next transaction,
    the fact that this object was not inserted and should be removed would be lost,
    and the flush would incorrectly raise an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The above program would raise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The bug is that when the above exception is raised, the unit of work is operating
    upon the original object assuming it’s a live row, when in fact the object is
    expired and upon testing reveals that it’s gone. The fix tests this condition
    now, so in the SQL log we see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Above, the unit of work now does a SELECT for the row we’re about to report
    as a conflict for, sees that it doesn’t exist, and proceeds normally. The expense
    of this SELECT is only incurred in the case when we would have erroneously raised
    an exception in any case.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3677](https://www.sqlalchemy.org/trac/ticket/3677)  ### passive_deletes feature
    for joined-inheritance mappings'
  prefs: []
  type: TYPE_NORMAL
- en: 'A joined-table inheritance mapping may now allow a DELETE to proceed as a result
    of [`Session.delete()`](../orm/session_api.html#sqlalchemy.orm.Session.delete
    "sqlalchemy.orm.Session.delete"), which only emits DELETE for the base table,
    and not the subclass table, allowing configured ON DELETE CASCADE to take place
    for the configured foreign keys. This is configured using the `mapper.passive_deletes`
    option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'With the above mapping, the `mapper.passive_deletes` option is configured on
    the base mapper; it takes effect for all non-base mappers that are descendants
    of the mapper with the option set. A DELETE for an object of type `B` no longer
    needs to retrieve the primary key value of `b_table_id` if unloaded, nor does
    it need to emit a DELETE statement for the table itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Will emit SQL as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As always, the target database must have foreign key support with ON DELETE
    CASCADE enabled.
  prefs: []
  type: TYPE_NORMAL
- en: '[#2349](https://www.sqlalchemy.org/trac/ticket/2349)  ### Same-named backrefs
    will not raise an error when applied to concrete inheritance subclasses'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following mapping has always been possible without issue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Above, even though class `A` and class `A1` have a relationship named `b`, no
    conflict warning or error occurs because class `A1` is marked as “concrete”.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if the relationships were configured the other way, an error would
    occur:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The fix enhances the backref feature so that an error is not emitted, as well
    as an additional check within the mapper logic to bypass warning for an attribute
    being replaced.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3630](https://www.sqlalchemy.org/trac/ticket/3630)  ### Same-named relationships
    on inheriting mappers no longer warn'
  prefs: []
  type: TYPE_NORMAL
- en: 'When creating two mappers in an inheritance scenario, placing a relationship
    on both with the same name would emit the warning “relationship ‘<name>’ on mapper
    <name> supersedes the same relationship on inherited mapper ‘<name>’; this can
    cause dependency issues during flush”. An example is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This warning dates back to the 0.4 series in 2007 and is based on a version
    of the unit of work code that has since been entirely rewritten. Currently, there
    is no known issue with the same-named relationships being placed on a base class
    and a descendant class, so the warning is lifted. However, note that this use
    case is likely not prevalent in real world use due to the warning. While rudimentary
    test support is added for this use case, it is possible that some new issue with
    this pattern may be identified.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.1.0b3.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3749](https://www.sqlalchemy.org/trac/ticket/3749)  ### Hybrid properties
    and methods now propagate the docstring as well as .info'
  prefs: []
  type: TYPE_NORMAL
- en: 'A hybrid method or property will now reflect the `__doc__` value present in
    the original docstring:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The above value of `A.some_name.__doc__` is now honored:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'However, to accomplish this, the mechanics of hybrid properties necessarily
    becomes more complex. Previously, the class-level accessor for a hybrid would
    be a simple pass-through, that is, this test would succeed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'With the change, the expression returned by `A.some_name` is wrapped inside
    of its own `QueryableAttribute` wrapper:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: A lot of testing went into making sure this wrapper works correctly, including
    for elaborate schemes like that of the [Custom Value Object](https://techspot.zzzeek.org/2011/10/21/hybrids-and-value-agnostic-types/)
    recipe, however we’ll be looking to see that no other regressions occur for users.
  prefs: []
  type: TYPE_NORMAL
- en: 'As part of this change, the `hybrid_property.info` collection is now also propagated
    from the hybrid descriptor itself, rather than from the underlying expression.
    That is, accessing `A.some_name.info` now returns the same dictionary that you’d
    get from `inspect(A).all_orm_descriptors[''some_name''].info`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Note that this `.info` dictionary is **separate** from that of a mapped attribute
    which the hybrid descriptor may be proxying directly; this is a behavioral change
    from 1.0\. The wrapper will still proxy other useful attributes of a mirrored
    attribute such as `QueryableAttribute.property` and `QueryableAttribute.class_`.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3653](https://www.sqlalchemy.org/trac/ticket/3653)  ### Session.merge resolves
    pending conflicts the same as persistent'
  prefs: []
  type: TYPE_NORMAL
- en: The [`Session.merge()`](../orm/session_api.html#sqlalchemy.orm.Session.merge
    "sqlalchemy.orm.Session.merge") method will now track the identities of objects
    given within a graph to maintain primary key uniqueness before emitting an INSERT.
    When duplicate objects of the same identity are encountered, non-primary-key attributes
    are **overwritten** as the objects are encountered, which is essentially non-deterministic.
    This behavior matches that of how persistent objects, that is objects that are
    already located in the database via primary key, are already treated, so this
    behavior is more internally consistent.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Above, we merge a `User` object with three new `Order` objects, each referring
    to a distinct `Address` object, however each is given the same primary key. The
    current behavior of [`Session.merge()`](../orm/session_api.html#sqlalchemy.orm.Session.merge
    "sqlalchemy.orm.Session.merge") is to look in the identity map for this `Address`
    object, and use that as the target. If the object is present, meaning that the
    database already has a row for `Address` with primary key “1”, we can see that
    the `email_address` field of the `Address` will be overwritten three times, in
    this case with the values a, b and finally c.
  prefs: []
  type: TYPE_NORMAL
- en: However, if the `Address` row for primary key “1” were not present, [`Session.merge()`](../orm/session_api.html#sqlalchemy.orm.Session.merge
    "sqlalchemy.orm.Session.merge") would instead create three separate `Address`
    instances, and we’d then get a primary key conflict upon INSERT. The new behavior
    is that the proposed primary key for these `Address` objects are tracked in a
    separate dictionary so that we merge the state of the three proposed `Address`
    objects onto one `Address` object to be inserted.
  prefs: []
  type: TYPE_NORMAL
- en: It may have been preferable if the original case emitted some kind of warning
    that conflicting data were present in a single merge-tree, however the non-deterministic
    merging of values has been the behavior for many years for the persistent case;
    it now matches for the pending case. A feature that warns for conflicting values
    could still be feasible for both cases but would add considerable performance
    overhead as each column value would have to be compared during the merge.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3601](https://www.sqlalchemy.org/trac/ticket/3601)  ### Fix involving many-to-one
    object moves with user-initiated foreign key manipulations'
  prefs: []
  type: TYPE_NORMAL
- en: 'A bug has been fixed involving the mechanics of replacing a many-to-one reference
    to an object with another object. During the attribute operation, the location
    of the object that was previously referred to now makes use of the database-committed
    foreign key value, rather than the current foreign key value. The main effect
    of the fix is that a backref event towards a collection will fire off more accurately
    when a many-to-one change is made, even if the foreign key attribute was manually
    moved to the new value beforehand. Assume a mapping of the classes `Parent` and
    `SomeClass`, where `SomeClass.parent` refers to `Parent` and `Parent.items` refers
    to the collection of `SomeClass` objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Above, we’ve made a pending object `some_object`, manipulated its foreign key
    towards `Parent` to refer to it, *then* we actually set up the relationship. Before
    the bug fix, the backref would not have fired off:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The fix now is that when we seek to locate the previous value of `some_object.parent`,
    we disregard the parent id that’s been manually set, and we look for the database-committed
    value. In this case, it’s None because the object is pending, so the event system
    logs `some_object.parent` as a net change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: While it is discouraged to manipulate foreign key attributes that are managed
    by relationships, there is limited support for this use case. Applications that
    manipulate foreign keys in order to allow loads to proceed will often make use
    of the [`Session.enable_relationship_loading()`](../orm/session_api.html#sqlalchemy.orm.Session.enable_relationship_loading
    "sqlalchemy.orm.Session.enable_relationship_loading") and `RelationshipProperty.load_on_pending`
    features, which cause relationships to emit lazy loads based on in-memory foreign
    key values that aren’t persisted. Whether or not these features are in use, this
    behavioral improvement will now be apparent.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3708](https://www.sqlalchemy.org/trac/ticket/3708)  ### Improvements to the
    Query.correlate method with polymorphic entities'
  prefs: []
  type: TYPE_NORMAL
- en: 'In recent SQLAlchemy versions, the SQL generated by many forms of “polymorphic”
    queries has a more “flat” form than it used to, where a JOIN of several tables
    is no longer bundled into a subquery unconditionally. To accommodate this, the
    [`Query.correlate()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.correlate
    "sqlalchemy.orm.Query.correlate") method now extracts the individual tables from
    such a polymorphic selectable and ensures that all are part of the “correlate”
    for the subquery. Assuming the `Person/Manager/Engineer->Company` setup from the
    mapping documentation, using with_polymorphic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The above query now produces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Before the fix, the call to `correlate(Person)` would inadvertently attempt
    to correlate to the join of `Person`, `Engineer` and `Manager` as a single unit,
    so `Person` wouldn’t be correlated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Using correlated subqueries against polymorphic mappings still has some unpolished
    edges. If for example `Person` is polymorphically linked to a so-called “concrete
    polymorphic union” query, the above subquery may not correctly refer to this subquery.
    In all cases, a way to refer to the “polymorphic” entity fully is to create an
    [`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased "sqlalchemy.orm.aliased")
    object from it first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The [`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased "sqlalchemy.orm.aliased")
    construct guarantees that the “polymorphic selectable” is wrapped in a subquery.
    By referring to it explicitly in the correlated subquery, the polymorphic form
    is correctly used.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3662](https://www.sqlalchemy.org/trac/ticket/3662)  ### Stringify of Query
    will consult the Session for the correct dialect'
  prefs: []
  type: TYPE_NORMAL
- en: Calling `str()` on a [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object will consult the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") for the correct “bind” to use, in order to render the
    SQL that would be passed to the database. In particular this allows a [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") that refers to dialect-specific SQL constructs to be renderable,
    assuming the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    is associated with an appropriate [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"). Previously, this behavior would only take effect if
    the [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData "sqlalchemy.schema.MetaData")
    to which the mappings were associated were itself bound to the target [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine").
  prefs: []
  type: TYPE_NORMAL
- en: If neither the underlying [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") nor the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") are associated with any bound [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine"), then the fallback to the “default” dialect is used
    to generate the SQL string.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[“Friendly” stringification of Core SQL constructs without a dialect](#change-3631)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#3081](https://www.sqlalchemy.org/trac/ticket/3081)  ### Joined eager loading
    where the same entity is present multiple times in one row'
  prefs: []
  type: TYPE_NORMAL
- en: 'A fix has been made to the case has been made whereby an attribute will be
    loaded via joined eager loading, even if the entity was already loaded from the
    row on a different “path” that doesn’t include the attribute. This is a deep use
    case that’s hard to reproduce, but the general idea is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The above query emits SQL like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the `c` table is selected from twice; once in the context of
    `A.b.c -> c_alias_1` and another in the context of `A.c -> c_alias_2`. Also, we
    can see that it is quite possible that the `C` identity for a single row is the
    **same** for both `c_alias_1` and `c_alias_2`, meaning two sets of columns in
    one row result in only one new object being added to the identity map.
  prefs: []
  type: TYPE_NORMAL
- en: The query options above only call for the attribute `C.d` to be loaded in the
    context of `c_alias_1`, and not `c_alias_2`. So whether or not the final `C` object
    we get in the identity map has the `C.d` attribute loaded depends on how the mappings
    are traversed, which while not completely random, is essentially non-deterministic.
    The fix is that even if the loader for `c_alias_1` is processed after that of
    `c_alias_2` for a single row where they both refer to the same identity, the `C.d`
    element will still be loaded. Previously, the loader did not seek to modify the
    load of an entity that was already loaded via a different path. The loader that
    reaches the entity first has always been non-deterministic, so this fix may be
    detectable as a behavioral change in some situations and not others.
  prefs: []
  type: TYPE_NORMAL
- en: The fix includes tests for two variants of the “multiple paths to one entity”
    case, and the fix should hopefully cover all other scenarios of this nature.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3431](https://www.sqlalchemy.org/trac/ticket/3431)'
  prefs: []
  type: TYPE_NORMAL
- en: New MutableList and MutableSet helpers added to the mutation tracking extension
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: New helper classes [`MutableList`](../orm/extensions/mutable.html#sqlalchemy.ext.mutable.MutableList
    "sqlalchemy.ext.mutable.MutableList") and [`MutableSet`](../orm/extensions/mutable.html#sqlalchemy.ext.mutable.MutableSet
    "sqlalchemy.ext.mutable.MutableSet") have been added to the [Mutation Tracking](../orm/extensions/mutable.html)
    extension, to complement the existing [`MutableDict`](../orm/extensions/mutable.html#sqlalchemy.ext.mutable.MutableDict
    "sqlalchemy.ext.mutable.MutableDict") helper.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3297](https://www.sqlalchemy.org/trac/ticket/3297)'
  prefs: []
  type: TYPE_NORMAL
- en: '### New “raise” / “raise_on_sql” loader strategies'
  prefs: []
  type: TYPE_NORMAL
- en: 'To assist with the use case of preventing unwanted lazy loads from occurring
    after a series of objects are loaded, the new “lazy=’raise’” and “lazy=’raise_on_sql’”
    strategies and corresponding loader option [`raiseload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.raiseload
    "sqlalchemy.orm.raiseload") may be applied to a relationship attribute which will
    cause it to raise `InvalidRequestError` when a non-eagerly-loaded attribute is
    accessed for read. The two variants test for either a lazy load of any variety,
    including those that would only return None or retrieve from the identity map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Or a lazy load only where SQL would be emitted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[#3512](https://www.sqlalchemy.org/trac/ticket/3512)  ### Mapper.order_by is
    deprecated'
  prefs: []
  type: TYPE_NORMAL
- en: This old parameter from the very first versions of SQLAlchemy was part of the
    original design of the ORM which featured the [`Mapper`](../orm/mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper") object as a public-facing query structure. This role
    has long since been replaced by the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object, where we use [`Query.order_by()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.order_by
    "sqlalchemy.orm.Query.order_by") to indicate the ordering of results in a way
    that works consistently for any combination of SELECT statements, entities and
    SQL expressions. There are many areas in which [`Mapper.order_by`](../orm/mapping_api.html#sqlalchemy.orm.Mapper.params.order_by
    "sqlalchemy.orm.Mapper") doesn’t work as expected (or what would be expected is
    not clear), such as when queries are combined into unions; these cases are not
    supported.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3394](https://www.sqlalchemy.org/trac/ticket/3394)'
  prefs: []
  type: TYPE_NORMAL
- en: New Features and Improvements - Core
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '### Engines now invalidate connections, run error handlers for BaseException'
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 1.1: this change is a late add to the 1.1 series just prior
    to 1.1 final, and is not present in the 1.1 beta releases.'
  prefs: []
  type: TYPE_NORMAL
- en: The Python `BaseException` class is below that of `Exception` but is the identifiable
    base for system-level exceptions such as `KeyboardInterrupt`, `SystemExit`, and
    notably the `GreenletExit` exception that’s used by eventlet and gevent. This
    exception class is now intercepted by the exception- handling routines of [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection"), and includes handling by the `ConnectionEvents.handle_error()`
    event. The [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") is now **invalidated** by default in the case
    of a system level exception that is not a subclass of `Exception`, as it is assumed
    an operation was interrupted and the connection may be in an unusable state. The
    MySQL drivers are most targeted by this change however the change is across all
    DBAPIs.
  prefs: []
  type: TYPE_NORMAL
- en: Note that upon invalidation, the immediate DBAPI connection used by [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") is disposed, and the [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection"), if still being used subsequent to the exception
    raise, will use a new DBAPI connection for subsequent operations upon next use;
    however, the state of any transaction in progress is lost and the appropriate
    `.rollback()` method must be called if applicable before this re-use can proceed.
  prefs: []
  type: TYPE_NORMAL
- en: In order to identify this change, it was straightforward to demonstrate a pymysql
    or mysqlclient / MySQL-Python connection moving into a corrupted state when these
    exceptions occur in the middle of the connection doing its work; the connection
    would then be returned to the connection pool where subsequent uses would fail,
    or even before returning to the pool would cause secondary failures in context
    managers that call `.rollback()` upon the exception catch. The behavior here is
    expected to reduce the incidence of the MySQL error “commands out of sync”, as
    well as the `ResourceClosedError` which can occur when the MySQL driver fails
    to report `cursor.description` correctly, when running under greenlet conditions
    where greenlets are killed, or where `KeyboardInterrupt` exceptions are handled
    without exiting the program entirely.
  prefs: []
  type: TYPE_NORMAL
- en: The behavior is distinct from the usual auto-invalidation feature, in that it
    does not assume that the backend database itself has been shut down or restarted;
    it does not recycle the entire connection pool as is the case for usual DBAPI
    disconnect exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: 'This change should be a net improvement for all users with the exception of
    **any application that currently intercepts ``KeyboardInterrupt`` or ``GreenletExit``
    and wishes to continue working within the same transaction**. Such an operation
    is theoretically possible with other DBAPIs that do not appear to be impacted
    by `KeyboardInterrupt` such as psycopg2\. For these DBAPIs, the following workaround
    will disable the connection from being recycled for specific exceptions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[#3803](https://www.sqlalchemy.org/trac/ticket/3803)  ### CTE Support for INSERT,
    UPDATE, DELETE'
  prefs: []
  type: TYPE_NORMAL
- en: One of the most widely requested features is support for common table expressions
    (CTE) that work with INSERT, UPDATE, DELETE, and is now implemented. An INSERT/UPDATE/DELETE
    can both draw from a WITH clause that’s stated at the top of the SQL, as well
    as can be used as a CTE itself in the context of a larger statement.
  prefs: []
  type: TYPE_NORMAL
- en: As part of this change, an INSERT from SELECT that includes a CTE will now render
    the CTE at the top of the entire statement, rather than nested in the SELECT statement
    as was the case in 1.0.
  prefs: []
  type: TYPE_NORMAL
- en: 'Below is an example that renders UPDATE, INSERT and SELECT all in one statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[#2551](https://www.sqlalchemy.org/trac/ticket/2551)  ### Support for RANGE
    and ROWS specification within window functions'
  prefs: []
  type: TYPE_NORMAL
- en: 'New [`over.range_`](../core/sqlelement.html#sqlalchemy.sql.expression.over.params.range_
    "sqlalchemy.sql.expression.over") and [`over.rows`](../core/sqlelement.html#sqlalchemy.sql.expression.over.params.rows
    "sqlalchemy.sql.expression.over") parameters allow RANGE and ROWS expressions
    for window functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[`over.range_`](../core/sqlelement.html#sqlalchemy.sql.expression.over.params.range_
    "sqlalchemy.sql.expression.over") and [`over.rows`](../core/sqlelement.html#sqlalchemy.sql.expression.over.params.rows
    "sqlalchemy.sql.expression.over") are specified as 2-tuples and indicate negative
    and positive values for specific ranges, 0 for “CURRENT ROW”, and None for UNBOUNDED.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Using Window Functions](../tutorial/data_select.html#tutorial-window-functions)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#3049](https://www.sqlalchemy.org/trac/ticket/3049)  ### Support for the SQL
    LATERAL keyword'
  prefs: []
  type: TYPE_NORMAL
- en: 'The LATERAL keyword is currently known to only be supported by PostgreSQL 9.3
    and greater, however as it is part of the SQL standard support for this keyword
    is added to Core. The implementation of [`Select.lateral()`](../core/selectable.html#sqlalchemy.sql.expression.Select.lateral
    "sqlalchemy.sql.expression.Select.lateral") employs special logic beyond just
    rendering the LATERAL keyword to allow for correlation of tables that are derived
    from the same FROM clause as the selectable, e.g. lateral correlation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[LATERAL correlation](../tutorial/data_select.html#tutorial-lateral-correlation)'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Lateral`](../core/selectable.html#sqlalchemy.sql.expression.Lateral "sqlalchemy.sql.expression.Lateral")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Select.lateral()`](../core/selectable.html#sqlalchemy.sql.expression.Select.lateral
    "sqlalchemy.sql.expression.Select.lateral")'
  prefs: []
  type: TYPE_NORMAL
- en: '[#2857](https://www.sqlalchemy.org/trac/ticket/2857)  ### Support for TABLESAMPLE'
  prefs: []
  type: TYPE_NORMAL
- en: 'The SQL standard TABLESAMPLE can be rendered using the [`FromClause.tablesample()`](../core/selectable.html#sqlalchemy.sql.expression.FromClause.tablesample
    "sqlalchemy.sql.expression.FromClause.tablesample") method, which returns a [`TableSample`](../core/selectable.html#sqlalchemy.sql.expression.TableSample
    "sqlalchemy.sql.expression.TableSample") construct similar to an alias:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Assuming `people` with a column `people_id`, the above statement would render
    as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[#3718](https://www.sqlalchemy.org/trac/ticket/3718)  ### The `.autoincrement`
    directive is no longer implicitly enabled for a composite primary key column'
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy has always had the convenience feature of enabling the backend database’s
    “autoincrement” feature for a single-column integer primary key; by “autoincrement”
    we mean that the database column will include whatever DDL directives the database
    provides in order to indicate an auto-incrementing integer identifier, such as
    the SERIAL keyword on PostgreSQL or AUTO_INCREMENT on MySQL, and additionally
    that the dialect will receive these generated values from the execution of a [`Table.insert()`](../core/metadata.html#sqlalchemy.schema.Table.insert
    "sqlalchemy.schema.Table.insert") construct using techniques appropriate to that
    backend.
  prefs: []
  type: TYPE_NORMAL
- en: 'What’s changed is that this feature no longer turns on automatically for a
    *composite* primary key; previously, a table definition such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Would have “autoincrement” semantics applied to the `''x''` column, only because
    it’s first in the list of primary key columns. In order to disable this, one would
    have to turn off `autoincrement` on all columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'With the new behavior, the composite primary key will not have autoincrement
    semantics unless a column is marked explicitly with `autoincrement=True`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to anticipate some potential backwards-incompatible scenarios, the
    [`Table.insert()`](../core/metadata.html#sqlalchemy.schema.Table.insert "sqlalchemy.schema.Table.insert")
    construct will perform more thorough checks for missing primary key values on
    composite primary key columns that don’t have autoincrement set up; given a table
    such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'An INSERT emitted with no values for this table will produce this warning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'For a column that is receiving primary key values from a server-side default
    or something less common such as a trigger, the presence of a value generator
    can be indicated using [`FetchedValue`](../core/defaults.html#sqlalchemy.schema.FetchedValue
    "sqlalchemy.schema.FetchedValue"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'For the very unlikely case where a composite primary key is actually intended
    to store NULL in one or more of its columns (only supported on SQLite and MySQL),
    specify the column with `nullable=True`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: In a related change, the `autoincrement` flag may be set to True on a column
    that has a client-side or server-side default. This typically will not have much
    impact on the behavior of the column during an INSERT.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[No more generation of an implicit KEY for composite primary key w/ AUTO_INCREMENT](#change-mysql-3216)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#3216](https://www.sqlalchemy.org/trac/ticket/3216)  ### Support for IS DISTINCT
    FROM and IS NOT DISTINCT FROM'
  prefs: []
  type: TYPE_NORMAL
- en: 'New operators [`ColumnOperators.is_distinct_from()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.is_distinct_from
    "sqlalchemy.sql.expression.ColumnOperators.is_distinct_from") and [`ColumnOperators.isnot_distinct_from()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.isnot_distinct_from
    "sqlalchemy.sql.expression.ColumnOperators.isnot_distinct_from") allow the IS
    DISTINCT FROM and IS NOT DISTINCT FROM sql operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Handling is provided for NULL, True and False:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'For SQLite, which doesn’t have this operator, “IS” / “IS NOT” is rendered,
    which on SQLite works for NULL unlike other backends:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]  ### Core and ORM support for FULL OUTER JOIN'
  prefs: []
  type: TYPE_NORMAL
- en: 'The new flag [`FromClause.outerjoin.full`](../core/selectable.html#sqlalchemy.sql.expression.FromClause.outerjoin.params.full
    "sqlalchemy.sql.expression.FromClause.outerjoin"), available at the Core and ORM
    level, instructs the compiler to render `FULL OUTER JOIN` where it would normally
    render `LEFT OUTER JOIN`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The flag also works at the ORM level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[#1957](https://www.sqlalchemy.org/trac/ticket/1957)  ### ResultSet column
    matching enhancements; positional column setup for textual SQL'
  prefs: []
  type: TYPE_NORMAL
- en: A series of improvements were made to the `ResultProxy` system in the 1.0 series
    as part of [#918](https://www.sqlalchemy.org/trac/ticket/918), which reorganizes
    the internals to match cursor-bound result columns with table/ORM metadata positionally,
    rather than by matching names, for compiled SQL constructs that contain full information
    about the result rows to be returned. This allows a dramatic savings on Python
    overhead as well as much greater accuracy in linking ORM and Core SQL expressions
    to result rows. In 1.1, this reorganization has been taken further internally,
    and also has been made available to pure-text SQL constructs via the use of the
    recently added [`TextClause.columns()`](../core/sqlelement.html#sqlalchemy.sql.expression.TextClause.columns
    "sqlalchemy.sql.expression.TextClause.columns") method.
  prefs: []
  type: TYPE_NORMAL
- en: TextAsFrom.columns() now works positionally
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The [`TextClause.columns()`](../core/sqlelement.html#sqlalchemy.sql.expression.TextClause.columns
    "sqlalchemy.sql.expression.TextClause.columns") method, added in 0.9, accepts
    column-based arguments positionally; in 1.1, when all columns are passed positionally,
    the correlation of these columns to the ultimate result set is also performed
    positionally. The key advantage here is that textual SQL can now be linked to
    an ORM- level result set without the need to deal with ambiguous or duplicate
    column names, or with having to match labeling schemes to ORM-level labeling schemes.
    All that’s needed now is the same ordering of columns within the textual SQL and
    the column arguments passed to [`TextClause.columns()`](../core/sqlelement.html#sqlalchemy.sql.expression.TextClause.columns
    "sqlalchemy.sql.expression.TextClause.columns"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Above, the textual SQL contains the column “id” three times, which would normally
    be ambiguous. Using the new feature, we can apply the mapped columns from the
    `User` and `Address` class directly, even linking the `Address.user_id` column
    to the `users.id` column in textual SQL for fun, and the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object will receive rows that are correctly targetable
    as needed, including for an eager load.
  prefs: []
  type: TYPE_NORMAL
- en: This change is **backwards incompatible** with code that passes the columns
    to the method with a different ordering than is present in the textual statement.
    It is hoped that this impact will be low due to the fact that this method has
    always been documented illustrating the columns being passed in the same order
    as that of the textual SQL statement, as would seem intuitive, even though the
    internals weren’t checking for this. The method itself was only added as of 0.9
    in any case and may not yet have widespread use. Notes on exactly how to handle
    this behavioral change for applications using it are at [TextClause.columns()
    will match columns positionally, not by name, when passed positionally](#behavior-change-3501).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Selecting with Textual Column Expressions](../tutorial/data_select.html#tutorial-select-arbitrary-text)'
  prefs: []
  type: TYPE_NORMAL
- en: '[TextClause.columns() will match columns positionally, not by name, when passed
    positionally](#behavior-change-3501) - backwards compatibility remarks'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Positional matching is trusted over name-based matching for Core/ORM SQL constructs
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Another aspect of this change is that the rules for matching columns have also
    been modified to rely upon “positional” matching more fully for compiled SQL constructs
    as well. Given a statement like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The above statement will compile to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'In 1.0, the above statement when executed would be matched to its original
    compiled construct using positional matching, however because the statement contains
    the `''user_id''` label duplicated, the “ambiguous column” rule would still get
    involved and prevent the columns from being fetched from a row. As of 1.1, the
    “ambiguous column” rule does not affect an exact match from a column construct
    to the SQL column, which is what the ORM uses to fetch columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Much less likely to get an “ambiguous column” error message
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As part of this change, the wording of the error message `Ambiguous column name
    '<name>' in result set! try 'use_labels' option on select statement.` has been
    dialed back; as this message should now be extremely rare when using the ORM or
    Core compiled SQL constructs, it merely states `Ambiguous column name '<name>'
    in result set column descriptions`, and only when a result column is retrieved
    using the string name that is actually ambiguous, e.g. `row['user_id']` in the
    above example. It also now refers to the actual ambiguous name from the rendered
    SQL statement itself, rather than indicating the key or name that was local to
    the construct being used for the fetch.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3501](https://www.sqlalchemy.org/trac/ticket/3501)  ### Support for Python’s
    native `enum` type and compatible forms'
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.types.Enum")
    type can now be constructed using any PEP-435 compliant enumerated type. When
    using this mode, input values and return values are the actual enumerated objects,
    not the string/integer/etc values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The `Enum.enums` collection is now a list instead of a tuple
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As part of the changes to [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum"), the `Enum.enums` collection of elements is now a list
    instead of a tuple. This because lists are appropriate for variable length sequences
    of homogeneous items where the position of the element is not semantically significant.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3292](https://www.sqlalchemy.org/trac/ticket/3292)  ### Negative integer
    indexes accommodated by Core result rows'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `RowProxy` object now accommodates single negative integer indexes like
    a regular Python sequence, both in the pure Python and C-extension version. Previously,
    negative values would only work in slices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]  ### The `Enum` type now does in-Python validation of values'
  prefs: []
  type: TYPE_NORMAL
- en: 'To accommodate for Python native enumerated objects, as well as for edge cases
    such as that of where a non-native ENUM type is used within an ARRAY and a CHECK
    constraint is infeasible, the [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum") datatype now adds in-Python validation of input values
    when the [`Enum.validate_strings`](../core/type_basics.html#sqlalchemy.types.Enum.params.validate_strings
    "sqlalchemy.types.Enum") flag is used (1.1.0b2):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: This validation is turned off by default as there are already use cases identified
    where users don’t want such validation (such as string comparisons). For non-string
    types, it necessarily takes place in all cases. The check also occurs unconditionally
    on the result-handling side as well, when values coming from the database are
    returned.
  prefs: []
  type: TYPE_NORMAL
- en: This validation is in addition to the existing behavior of creating a CHECK
    constraint when a non-native enumerated type is used. The creation of this CHECK
    constraint can now be disabled using the new [`Enum.create_constraint`](../core/type_basics.html#sqlalchemy.types.Enum.params.create_constraint
    "sqlalchemy.types.Enum") flag.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3095](https://www.sqlalchemy.org/trac/ticket/3095)  ### Non-native boolean
    integer values coerced to zero/one/None in all cases'
  prefs: []
  type: TYPE_NORMAL
- en: The [`Boolean`](../core/type_basics.html#sqlalchemy.types.Boolean "sqlalchemy.types.Boolean")
    datatype coerces Python booleans to integer values for backends that don’t have
    a native boolean type, such as SQLite and MySQL. On these backends, a CHECK constraint
    is normally set up which ensures the values in the database are in fact one of
    these two values. However, MySQL ignores CHECK constraints, the constraint is
    optional, and an existing database might not have this constraint. The [`Boolean`](../core/type_basics.html#sqlalchemy.types.Boolean
    "sqlalchemy.types.Boolean") datatype has been repaired such that an incoming Python-side
    value that is already an integer value is coerced to zero or one, not just passed
    as-is; additionally, the C-extension version of the int-to-boolean processor for
    results now uses the same Python boolean interpretation of the value, rather than
    asserting an exact one or zero value. This is now consistent with the pure-Python
    int-to-boolean processor and is more forgiving of existing data already within
    the database. Values of None/NULL are as before retained as None/NULL.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: this change had an unintended side effect that the interpretation of non- integer
    values, such as strings, also changed in behavior such that the string value `"0"`
    would be interpreted as “true”, but only on backends that don’t have a native
    boolean datatype - on “native boolean” backends like PostgreSQL, the string value
    `"0"` is passed directly to the driver and is interpreted as “false”. This is
    an inconsistency that did not occur with the previous implementation. It should
    be noted that passing strings or any other value outside of `None`, `True`, `False`,
    `1`, `0` to the [`Boolean`](../core/type_basics.html#sqlalchemy.types.Boolean
    "sqlalchemy.types.Boolean") datatype is **not supported** and version 1.2 will
    raise an error for this scenario (or possibly just emit a warning, TBD). See also
    [#4102](https://www.sqlalchemy.org/trac/ticket/4102).
  prefs: []
  type: TYPE_NORMAL
- en: '[#3730](https://www.sqlalchemy.org/trac/ticket/3730)  ### Large parameter and
    row values are now truncated in logging and exception displays'
  prefs: []
  type: TYPE_NORMAL
- en: 'A large value present as a bound parameter for a SQL statement, as well as
    a large value present in a result row, will now be truncated during display within
    logging, exception reporting, as well as `repr()` of the row itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[#2837](https://www.sqlalchemy.org/trac/ticket/2837)  ### JSON support added
    to Core'
  prefs: []
  type: TYPE_NORMAL
- en: As MySQL now has a JSON datatype in addition to the PostgreSQL JSON datatype,
    the core now gains a [`sqlalchemy.types.JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON") datatype that is the basis for both of these. Using this
    type allows access to the “getitem” operator as well as the “getpath” operator
    in a way that is agnostic across PostgreSQL and MySQL.
  prefs: []
  type: TYPE_NORMAL
- en: The new datatype also has a series of improvements to the handling of NULL values
    as well as expression handling.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[MySQL JSON Support](#change-3547)'
  prefs: []
  type: TYPE_NORMAL
- en: '[`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON "sqlalchemy.dialects.postgresql.JSON")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`JSON`](../dialects/mysql.html#sqlalchemy.dialects.mysql.JSON "sqlalchemy.dialects.mysql.JSON")'
  prefs: []
  type: TYPE_NORMAL
- en: '[#3619](https://www.sqlalchemy.org/trac/ticket/3619)'
  prefs: []
  type: TYPE_NORMAL
- en: '#### JSON “null” is inserted as expected with ORM operations, omitted when
    not present'
  prefs: []
  type: TYPE_NORMAL
- en: The [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON")
    type and its descendant types [`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON
    "sqlalchemy.dialects.postgresql.JSON") and [`JSON`](../dialects/mysql.html#sqlalchemy.dialects.mysql.JSON
    "sqlalchemy.dialects.mysql.JSON") have a flag [`JSON.none_as_null`](../core/type_basics.html#sqlalchemy.types.JSON.params.none_as_null
    "sqlalchemy.types.JSON") which when set to True indicates that the Python value
    `None` should translate into a SQL NULL rather than a JSON NULL value. This flag
    defaults to False, which means that the Python value `None` should result in a
    JSON NULL value.
  prefs: []
  type: TYPE_NORMAL
- en: 'This logic would fail, and is now corrected, in the following circumstances:'
  prefs: []
  type: TYPE_NORMAL
- en: '1\. When the column also contained a default or server_default value, a positive
    value of `None` on the mapped attribute that expects to persist JSON “null” would
    still result in the column-level default being triggered, replacing the `None`
    value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '2\. When the column *did not* contain a default or server_default value, a
    missing value on a JSON column configured with none_as_null=False would still
    render JSON NULL rather than falling back to not inserting any value, behaving
    inconsistently vs. all other datatypes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: This is a behavioral change that is backwards incompatible for an application
    that was relying upon this to default a missing value as JSON null. This essentially
    establishes that a **missing value is distinguished from a present value of None**.
    See [JSON Columns will not insert JSON NULL if no value is supplied and no default
    is established](#behavior-change-3514) for further detail.
  prefs: []
  type: TYPE_NORMAL
- en: '3\. When the [`Session.bulk_insert_mappings()`](../orm/session_api.html#sqlalchemy.orm.Session.bulk_insert_mappings
    "sqlalchemy.orm.Session.bulk_insert_mappings") method were used, `None` would
    be ignored in all cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: The [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON")
    type now implements the [`TypeEngine.should_evaluate_none`](../core/type_api.html#sqlalchemy.types.TypeEngine.should_evaluate_none
    "sqlalchemy.types.TypeEngine.should_evaluate_none") flag, indicating that `None`
    should not be ignored here; it is configured automatically based on the value
    of [`JSON.none_as_null`](../core/type_basics.html#sqlalchemy.types.JSON.params.none_as_null
    "sqlalchemy.types.JSON"). Thanks to [#3061](https://www.sqlalchemy.org/trac/ticket/3061),
    we can differentiate when the value `None` is actively set by the user versus
    when it was never set at all.
  prefs: []
  type: TYPE_NORMAL
- en: The feature applies as well to the new base [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON") type and its descendant types.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3514](https://www.sqlalchemy.org/trac/ticket/3514)  #### New JSON.NULL Constant
    Added'
  prefs: []
  type: TYPE_NORMAL
- en: 'To ensure that an application can always have full control at the value level
    of whether a [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON"),
    [`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON "sqlalchemy.dialects.postgresql.JSON"),
    [`JSON`](../dialects/mysql.html#sqlalchemy.dialects.mysql.JSON "sqlalchemy.dialects.mysql.JSON"),
    or [`JSONB`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSONB
    "sqlalchemy.dialects.postgresql.JSONB") column should receive a SQL NULL or JSON
    `"null"` value, the constant [`JSON.NULL`](../core/type_basics.html#sqlalchemy.types.JSON.NULL
    "sqlalchemy.types.JSON.NULL") has been added, which in conjunction with [`null()`](../core/sqlelement.html#sqlalchemy.sql.expression.null
    "sqlalchemy.sql.expression.null") can be used to determine fully between SQL NULL
    and JSON `"null"`, regardless of what [`JSON.none_as_null`](../core/type_basics.html#sqlalchemy.types.JSON.params.none_as_null
    "sqlalchemy.types.JSON") is set to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: The feature applies as well to the new base [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON") type and its descendant types.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3514](https://www.sqlalchemy.org/trac/ticket/3514)  ### Array support added
    to Core; new ANY and ALL operators'
  prefs: []
  type: TYPE_NORMAL
- en: Along with the enhancements made to the PostgreSQL [`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY") type described in [Correct SQL Types are
    Established from Indexed Access of ARRAY, JSON, HSTORE](#change-3503), the base
    class of [`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY") itself has been moved to Core in a new
    class [`ARRAY`](../core/type_basics.html#sqlalchemy.types.ARRAY "sqlalchemy.types.ARRAY").
  prefs: []
  type: TYPE_NORMAL
- en: 'Arrays are part of the SQL standard, as are several array-oriented functions
    such as `array_agg()` and `unnest()`. In support of these constructs for not just
    PostgreSQL but also potentially for other array-capable backends in the future
    such as DB2, the majority of array logic for SQL expressions is now in Core. The
    [`ARRAY`](../core/type_basics.html#sqlalchemy.types.ARRAY "sqlalchemy.types.ARRAY")
    type still **only works on PostgreSQL**, however it can be used directly, supporting
    special array use cases such as indexed access, as well as support for the ANY
    and ALL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'In support of ANY and ALL, the [`ARRAY`](../core/type_basics.html#sqlalchemy.types.ARRAY
    "sqlalchemy.types.ARRAY") type retains the same [`Comparator.any()`](../core/type_basics.html#sqlalchemy.types.ARRAY.Comparator.any
    "sqlalchemy.types.ARRAY.Comparator.any") and [`Comparator.all()`](../core/type_basics.html#sqlalchemy.types.ARRAY.Comparator.all
    "sqlalchemy.types.ARRAY.Comparator.all") methods from the PostgreSQL type, but
    also exports these operations to new standalone operator functions [`any_()`](../core/sqlelement.html#sqlalchemy.sql.expression.any_
    "sqlalchemy.sql.expression.any_") and [`all_()`](../core/sqlelement.html#sqlalchemy.sql.expression.all_
    "sqlalchemy.sql.expression.all_"). These two functions work in more of the traditional
    SQL way, allowing a right-side expression form such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: For the PostgreSQL-specific operators “contains”, “contained_by”, and “overlaps”,
    one should continue to use the [`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY") type directly, which provides all functionality
    of the [`ARRAY`](../core/type_basics.html#sqlalchemy.types.ARRAY "sqlalchemy.types.ARRAY")
    type as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`any_()`](../core/sqlelement.html#sqlalchemy.sql.expression.any_ "sqlalchemy.sql.expression.any_")
    and [`all_()`](../core/sqlelement.html#sqlalchemy.sql.expression.all_ "sqlalchemy.sql.expression.all_")
    operators are open-ended at the Core level, however their interpretation by backend
    databases is limited. On the PostgreSQL backend, the two operators **only accept
    array values**. Whereas on the MySQL backend, they **only accept subquery values**.
    On MySQL, one can use an expression such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[#3516](https://www.sqlalchemy.org/trac/ticket/3516)  ### New Function features,
    “WITHIN GROUP”, array_agg and set aggregate functions'
  prefs: []
  type: TYPE_NORMAL
- en: 'With the new [`ARRAY`](../core/type_basics.html#sqlalchemy.types.ARRAY "sqlalchemy.types.ARRAY")
    type we can also implement a pre-typed function for the `array_agg()` SQL function
    that returns an array, which is now available using [`array_agg`](../core/functions.html#sqlalchemy.sql.functions.array_agg
    "sqlalchemy.sql.functions.array_agg"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'A PostgreSQL element for an aggregate ORDER BY is also added via [`aggregate_order_by`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.aggregate_order_by
    "sqlalchemy.dialects.postgresql.aggregate_order_by"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Producing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'The PG dialect itself also provides an [`array_agg()`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.array_agg
    "sqlalchemy.dialects.postgresql.array_agg") wrapper to ensure the [`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY") type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, functions like `percentile_cont()`, `percentile_disc()`, `rank()`,
    `dense_rank()` and others that require an ordering via `WITHIN GROUP (ORDER BY
    <expr>)` are now available via the [`FunctionElement.within_group()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.within_group
    "sqlalchemy.sql.functions.FunctionElement.within_group") modifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'The above statement would produce SQL similar to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Placeholders with correct return types are now provided for these functions,
    and include [`percentile_cont`](../core/functions.html#sqlalchemy.sql.functions.percentile_cont
    "sqlalchemy.sql.functions.percentile_cont"), [`percentile_disc`](../core/functions.html#sqlalchemy.sql.functions.percentile_disc
    "sqlalchemy.sql.functions.percentile_disc"), [`rank`](../core/functions.html#sqlalchemy.sql.functions.rank
    "sqlalchemy.sql.functions.rank"), [`dense_rank`](../core/functions.html#sqlalchemy.sql.functions.dense_rank
    "sqlalchemy.sql.functions.dense_rank"), [`mode`](../core/functions.html#sqlalchemy.sql.functions.mode
    "sqlalchemy.sql.functions.mode"), [`percent_rank`](../core/functions.html#sqlalchemy.sql.functions.percent_rank
    "sqlalchemy.sql.functions.percent_rank"), and [`cume_dist`](../core/functions.html#sqlalchemy.sql.functions.cume_dist
    "sqlalchemy.sql.functions.cume_dist").
  prefs: []
  type: TYPE_NORMAL
- en: '[#3132](https://www.sqlalchemy.org/trac/ticket/3132) [#1370](https://www.sqlalchemy.org/trac/ticket/1370)  ###
    TypeDecorator now works with Enum, Boolean, “schema” types automatically'
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`SchemaType`](../core/type_basics.html#sqlalchemy.types.SchemaType "sqlalchemy.types.SchemaType")
    types include types such as [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum") and [`Boolean`](../core/type_basics.html#sqlalchemy.types.Boolean
    "sqlalchemy.types.Boolean") which, in addition to corresponding to a database
    type, also generate either a CHECK constraint or in the case of PostgreSQL ENUM
    a new CREATE TYPE statement, will now work automatically with [`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") recipes. Previously, a [`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") for an [`ENUM`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ENUM
    "sqlalchemy.dialects.postgresql.ENUM") had to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'The [`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") now propagates those additional events so it
    can be done like any other type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[#2919](https://www.sqlalchemy.org/trac/ticket/2919)  ### Multi-Tenancy Schema
    Translation for Table objects'
  prefs: []
  type: TYPE_NORMAL
- en: To support the use case of an application that uses the same set of [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects in many schemas, such as schema-per-user, a
    new execution option [`Connection.execution_options.schema_translate_map`](../core/connections.html#sqlalchemy.engine.Connection.execution_options.params.schema_translate_map
    "sqlalchemy.engine.Connection.execution_options") is added. Using this mapping,
    a set of [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    objects can be made on a per-connection basis to refer to any set of schemas instead
    of the [`Table.schema`](../core/metadata.html#sqlalchemy.schema.Table.params.schema
    "sqlalchemy.schema.Table") to which they were assigned. The translation works
    for DDL and SQL generation, as well as with the ORM.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if the `User` class were assigned the schema “per_user”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'On each request, the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") can be set up to refer to a different schema each time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Translation of Schema Names](../core/connections.html#schema-translating)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#2685](https://www.sqlalchemy.org/trac/ticket/2685)  ### “Friendly” stringification
    of Core SQL constructs without a dialect'
  prefs: []
  type: TYPE_NORMAL
- en: 'Calling `str()` on a Core SQL construct will now produce a string in more cases
    than before, supporting various SQL constructs not normally present in default
    SQL such as RETURNING, array indexes, and non-standard datatypes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: The `str()` function now calls upon an entirely separate dialect / compiler
    intended just for plain string printing without a specific dialect set up, so
    as more “just show me a string!” cases come up, these can be added to this dialect/compiler
    without impacting behaviors on real dialects.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Stringify of Query will consult the Session for the correct dialect](#change-3081)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#3631](https://www.sqlalchemy.org/trac/ticket/3631)  ### The type_coerce function
    is now a persistent SQL element'
  prefs: []
  type: TYPE_NORMAL
- en: The [`type_coerce()`](../core/sqlelement.html#sqlalchemy.sql.expression.type_coerce
    "sqlalchemy.sql.expression.type_coerce") function previously would return an object
    either of type [`BindParameter`](../core/sqlelement.html#sqlalchemy.sql.expression.BindParameter
    "sqlalchemy.sql.expression.BindParameter") or [`Label`](../core/sqlelement.html#sqlalchemy.sql.expression.Label
    "sqlalchemy.sql.expression.Label"), depending on the input. An effect this would
    have was that in the case where expression transformations were used, such as
    the conversion of an element from a [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") to a [`BindParameter`](../core/sqlelement.html#sqlalchemy.sql.expression.BindParameter
    "sqlalchemy.sql.expression.BindParameter") that’s critical to ORM-level lazy loading,
    the type coercion information would not be used since it would have been lost
    already.
  prefs: []
  type: TYPE_NORMAL
- en: To improve this behavior, the function now returns a persistent [`TypeCoerce`](../core/sqlelement.html#sqlalchemy.sql.expression.TypeCoerce
    "sqlalchemy.sql.expression.TypeCoerce") container around the given expression,
    which itself remains unaffected; this construct is evaluated explicitly by the
    SQL compiler. This allows for the coercion of the inner expression to be maintained
    no matter how the statement is modified, including if the contained element is
    replaced with a different one, as is common within the ORM’s lazy loading feature.
  prefs: []
  type: TYPE_NORMAL
- en: 'The test case illustrating the effect makes use of a heterogeneous primaryjoin
    condition in conjunction with custom types and lazy loading. Given a custom type
    that applies a CAST as a “bind expression”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, a mapping where we are equating a string “id” column on one table to
    an integer “id” column on the other:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Above, in the [`relationship.primaryjoin`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.primaryjoin
    "sqlalchemy.orm.relationship") expression, we are using [`type_coerce()`](../core/sqlelement.html#sqlalchemy.sql.expression.type_coerce
    "sqlalchemy.sql.expression.type_coerce") to handle bound parameters passed via
    lazyloading as integers, since we already know these will come from our `StringAsInt`
    type which maintains the value as an integer in Python. We are then using [`cast()`](../core/sqlelement.html#sqlalchemy.sql.expression.cast
    "sqlalchemy.sql.expression.cast") so that as a SQL expression, the VARCHAR “id”
    column will be CAST to an integer for a regular non- converted join as with [`Query.join()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join") or [`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload"). That is, a joinedload of `.pets` looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Without the CAST in the ON clause of the join, strongly-typed databases such
    as PostgreSQL will refuse to implicitly compare the integer and fail.
  prefs: []
  type: TYPE_NORMAL
- en: 'The lazyload case of `.pets` relies upon replacing the `Person.id` column at
    load time with a bound parameter, which receives a Python-loaded value. This replacement
    is specifically where the intent of our [`type_coerce()`](../core/sqlelement.html#sqlalchemy.sql.expression.type_coerce
    "sqlalchemy.sql.expression.type_coerce") function would be lost. Prior to the
    change, this lazy load comes out as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Where above, we see that our in-Python value of `5` is CAST first to a VARCHAR,
    then back to an INTEGER in SQL; a double CAST which works, but is nevertheless
    not what we asked for.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the change, the [`type_coerce()`](../core/sqlelement.html#sqlalchemy.sql.expression.type_coerce
    "sqlalchemy.sql.expression.type_coerce") function maintains a wrapper even after
    the column is swapped out for a bound parameter, and the query now looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Where our outer CAST that’s in our primaryjoin still takes effect, but the needless
    CAST that’s in part of the `StringAsInt` custom type is removed as intended by
    the [`type_coerce()`](../core/sqlelement.html#sqlalchemy.sql.expression.type_coerce
    "sqlalchemy.sql.expression.type_coerce") function.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3531](https://www.sqlalchemy.org/trac/ticket/3531)'
  prefs: []
  type: TYPE_NORMAL
- en: Key Behavioral Changes - ORM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '### JSON Columns will not insert JSON NULL if no value is supplied and no default
    is established'
  prefs: []
  type: TYPE_NORMAL
- en: 'As detailed in [JSON “null” is inserted as expected with ORM operations, omitted
    when not present](#change-3514), [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON") will not render a JSON “null” value if the value is missing
    entirely. To prevent SQL NULL, a default should be set up. Given the following
    mapping:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'The following flush operation will fail with an integrity error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'If the default for the column should be JSON NULL, set this on the Column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, ensure the value is present on the object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that setting `None` for the default is the same as omitting it entirely;
    the [`JSON.none_as_null`](../core/type_basics.html#sqlalchemy.types.JSON.params.none_as_null
    "sqlalchemy.types.JSON") flag does not impact the value of `None` passed to [`Column.default`](../core/metadata.html#sqlalchemy.schema.Column.params.default
    "sqlalchemy.schema.Column") or [`Column.server_default`](../core/metadata.html#sqlalchemy.schema.Column.params.server_default
    "sqlalchemy.schema.Column"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[JSON “null” is inserted as expected with ORM operations, omitted when not
    present](#change-3514)  ### Columns no longer added redundantly with DISTINCT
    + ORDER BY'
  prefs: []
  type: TYPE_NORMAL
- en: 'A query such as the following will now augment only those columns that are
    missing from the SELECT list, without duplicates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Produces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'Previously, it would produce:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: Where above, the `user.name` column is added unnecessarily. The results would
    not be affected, as the additional columns are not included in the result in any
    case, but the columns are unnecessary.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, when the PostgreSQL DISTINCT ON format is used by passing expressions
    to [`Query.distinct()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.distinct
    "sqlalchemy.orm.Query.distinct"), the above “column adding” logic is disabled
    entirely.
  prefs: []
  type: TYPE_NORMAL
- en: When the query is being bundled into a subquery for the purposes of joined eager
    loading, the “augment column list” rules are necessarily more aggressive so that
    the ORDER BY can still be satisfied, so this case remains unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3641](https://www.sqlalchemy.org/trac/ticket/3641)  ### Same-named @validates
    decorators will now raise an exception'
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`validates()`](../orm/mapped_attributes.html#sqlalchemy.orm.validates
    "sqlalchemy.orm.validates") decorator is only intended to be created once per
    class for a particular attribute name. Creating more than one now raises an error,
    whereas previously it would silently pick only the last defined validator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Will raise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '[#3776](https://www.sqlalchemy.org/trac/ticket/3776)'
  prefs: []
  type: TYPE_NORMAL
- en: Key Behavioral Changes - Core
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '### TextClause.columns() will match columns positionally, not by name, when
    passed positionally'
  prefs: []
  type: TYPE_NORMAL
- en: The new behavior of the [`TextClause.columns()`](../core/sqlelement.html#sqlalchemy.sql.expression.TextClause.columns
    "sqlalchemy.sql.expression.TextClause.columns") method, which itself was recently
    added as of the 0.9 series, is that when columns are passed positionally without
    any additional keyword arguments, they are linked to the ultimate result set columns
    positionally, and no longer on name. It is hoped that the impact of this change
    will be low due to the fact that the method has always been documented illustrating
    the columns being passed in the same order as that of the textual SQL statement,
    as would seem intuitive, even though the internals weren’t checking for this.
  prefs: []
  type: TYPE_NORMAL
- en: An application that is using this method by passing [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects to it positionally must ensure that the position
    of those [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    objects matches the position in which these columns are stated in the textual
    SQL.
  prefs: []
  type: TYPE_NORMAL
- en: 'E.g., code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'Would no longer work as expected; the order of the columns given is now significant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'Possibly more likely, a statement that worked like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: is now slightly risky, as the “*” specification will generally deliver columns
    in the order in which they are present in the table itself. If the structure of
    the table changes due to schema changes, this ordering may no longer be the same.
    Therefore when using [`TextClause.columns()`](../core/sqlelement.html#sqlalchemy.sql.expression.TextClause.columns
    "sqlalchemy.sql.expression.TextClause.columns"), it’s advised to list out the
    desired columns explicitly in the textual SQL, though it’s no longer necessary
    to worry about the names themselves in the textual SQL.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[ResultSet column matching enhancements; positional column setup for textual
    SQL](#change-3501)  ### String server_default now literal quoted'
  prefs: []
  type: TYPE_NORMAL
- en: 'A server default passed to [`Column.server_default`](../core/metadata.html#sqlalchemy.schema.Column.params.server_default
    "sqlalchemy.schema.Column") as a plain Python string that has quotes embedded
    is now passed through the literal quoting system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: Previously the quote would render directly. This change may be backwards incompatible
    for applications with such a use case who were working around the issue.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3809](https://www.sqlalchemy.org/trac/ticket/3809)  ### A UNION or similar
    of SELECTs with LIMIT/OFFSET/ORDER BY now parenthesizes the embedded selects'
  prefs: []
  type: TYPE_NORMAL
- en: 'An issue that, like others, was long driven by SQLite’s lack of capabilities
    has now been enhanced to work on all supporting backends. We refer to a query
    that is a UNION of SELECT statements that themselves contain row-limiting or ordering
    features which include LIMIT, OFFSET, and/or ORDER BY:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'The above query requires parenthesis within each sub-select in order to group
    the sub-results correctly. Production of the above statement in SQLAlchemy Core
    looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: Previously, the above construct would not produce parenthesization for the inner
    SELECT statements, producing a query that fails on all backends.
  prefs: []
  type: TYPE_NORMAL
- en: The above formats will **continue to fail on SQLite**; additionally, the format
    that includes ORDER BY but no LIMIT/SELECT will **continue to fail on Oracle**.
    This is not a backwards-incompatible change, because the queries fail without
    the parentheses as well; with the fix, the queries at least work on all other
    databases.
  prefs: []
  type: TYPE_NORMAL
- en: 'In all cases, in order to produce a UNION of limited SELECT statements that
    also works on SQLite and in all cases on Oracle, the subqueries must be a SELECT
    of an ALIAS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'This workaround works on all SQLAlchemy versions. In the ORM, it looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: The behavior here has many parallels to the “join rewriting” behavior introduced
    in SQLAlchemy 0.9 in [Many JOIN and LEFT OUTER JOIN expressions will no longer
    be wrapped in (SELECT * FROM ..) AS ANON_1](migration_09.html#feature-joins-09);
    however in this case we have opted not to add new rewriting behavior to accommodate
    this case for SQLite. The existing rewriting behavior is very complicated already,
    and the case of UNIONs with parenthesized SELECT statements is much less common
    than the “right-nested-join” use case of that feature.
  prefs: []
  type: TYPE_NORMAL
- en: '[#2528](https://www.sqlalchemy.org/trac/ticket/2528)'
  prefs: []
  type: TYPE_NORMAL
- en: Dialect Improvements and Changes - PostgreSQL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '### Support for INSERT..ON CONFLICT (DO UPDATE | DO NOTHING)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ON CONFLICT` clause of `INSERT` added to PostgreSQL as of version 9.5
    is now supported using a PostgreSQL-specific version of the [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") object, via `sqlalchemy.dialects.postgresql.dml.insert()`.
    This [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert "sqlalchemy.sql.expression.Insert")
    subclass adds two new methods `Insert.on_conflict_do_update()` and `Insert.on_conflict_do_nothing()`
    which implement the full syntax supported by PostgreSQL 9.5 in this area:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'The above will render:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[INSERT…ON CONFLICT (Upsert)](../dialects/postgresql.html#postgresql-insert-on-conflict)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#3529](https://www.sqlalchemy.org/trac/ticket/3529)  ### ARRAY and JSON types
    now correctly specify “unhashable”'
  prefs: []
  type: TYPE_NORMAL
- en: As described in [Changes regarding “unhashable” types, impacts deduping of ORM
    rows](#change-3499), the ORM relies upon being able to produce a hash function
    for column values when a query’s selected entities mixes full ORM entities with
    column expressions. The `hashable=False` flag is now correctly set on all of PG’s
    “data structure” types, including [`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY") and [`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON
    "sqlalchemy.dialects.postgresql.JSON"). The [`JSONB`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSONB
    "sqlalchemy.dialects.postgresql.JSONB") and [`HSTORE`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.HSTORE
    "sqlalchemy.dialects.postgresql.HSTORE") types already included this flag. For
    [`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY "sqlalchemy.dialects.postgresql.ARRAY"),
    this is conditional based on the [`ARRAY.as_tuple`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY.params.as_tuple
    "sqlalchemy.dialects.postgresql.ARRAY") flag, however it should no longer be necessary
    to set this flag in order to have an array value present in a composed ORM row.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Changes regarding “unhashable” types, impacts deduping of ORM rows](#change-3499)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Correct SQL Types are Established from Indexed Access of ARRAY, JSON, HSTORE](#change-3503)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#3499](https://www.sqlalchemy.org/trac/ticket/3499)  ### Correct SQL Types
    are Established from Indexed Access of ARRAY, JSON, HSTORE'
  prefs: []
  type: TYPE_NORMAL
- en: For all three of [`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY"), [`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON
    "sqlalchemy.dialects.postgresql.JSON") and [`HSTORE`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.HSTORE
    "sqlalchemy.dialects.postgresql.HSTORE"), the SQL type assigned to the expression
    returned by indexed access, e.g. `col[someindex]`, should be correct in all cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'This includes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The SQL type assigned to indexed access of an [`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY") takes into account the number of dimensions
    configured. An [`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY") with three dimensions will return a SQL
    expression with a type of [`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY") of one less dimension. Given a column
    with type `ARRAY(Integer, dimensions=3)`, we can now perform this expression:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Previously, the indexed access to `col[5]` would return an expression of type
    [`Integer`](../core/type_basics.html#sqlalchemy.types.Integer "sqlalchemy.types.Integer")
    where we could no longer perform indexed access for the remaining dimensions,
    unless we used [`cast()`](../core/sqlelement.html#sqlalchemy.sql.expression.cast
    "sqlalchemy.sql.expression.cast") or [`type_coerce()`](../core/sqlelement.html#sqlalchemy.sql.expression.type_coerce
    "sqlalchemy.sql.expression.type_coerce").
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The [`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON
    "sqlalchemy.dialects.postgresql.JSON") and [`JSONB`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSONB
    "sqlalchemy.dialects.postgresql.JSONB") types now mirror what PostgreSQL itself
    does for indexed access. This means that all indexed access for a [`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON
    "sqlalchemy.dialects.postgresql.JSON") or [`JSONB`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSONB
    "sqlalchemy.dialects.postgresql.JSONB") type returns an expression that itself
    is *always* [`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON
    "sqlalchemy.dialects.postgresql.JSON") or [`JSONB`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSONB
    "sqlalchemy.dialects.postgresql.JSONB") itself, unless the [`Comparator.astext`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON.Comparator.astext
    "sqlalchemy.dialects.postgresql.JSON.Comparator.astext") modifier is used. This
    means that whether the indexed access of the JSON structure ultimately refers
    to a string, list, number, or other JSON structure, PostgreSQL always considers
    it to be JSON itself unless it is explicitly cast differently. Like the [`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY") type, this means that it is now straightforward
    to produce JSON expressions with multiple levels of indexed access:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The “textual” type that is returned by indexed access of [`HSTORE`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.HSTORE
    "sqlalchemy.dialects.postgresql.HSTORE") as well as the “textual” type that is
    returned by indexed access of [`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON
    "sqlalchemy.dialects.postgresql.JSON") and [`JSONB`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSONB
    "sqlalchemy.dialects.postgresql.JSONB") in conjunction with the [`Comparator.astext`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON.Comparator.astext
    "sqlalchemy.dialects.postgresql.JSON.Comparator.astext") modifier is now configurable;
    it defaults to [`TextClause`](../core/sqlelement.html#sqlalchemy.sql.expression.TextClause
    "sqlalchemy.sql.expression.TextClause") in both cases but can be set to a user-defined
    type using the [`JSON.astext_type`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON.params.astext_type
    "sqlalchemy.dialects.postgresql.JSON") or [`HSTORE.text_type`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.HSTORE.params.text_type
    "sqlalchemy.dialects.postgresql.HSTORE") parameters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[The JSON cast() operation now requires .astext is called explicitly](#change-3503-cast)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#3499](https://www.sqlalchemy.org/trac/ticket/3499) [#3487](https://www.sqlalchemy.org/trac/ticket/3487)  ###
    The JSON cast() operation now requires `.astext` is called explicitly'
  prefs: []
  type: TYPE_NORMAL
- en: As part of the changes in [Correct SQL Types are Established from Indexed Access
    of ARRAY, JSON, HSTORE](#change-3503), the workings of the [`ColumnElement.cast()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnElement.cast
    "sqlalchemy.sql.expression.ColumnElement.cast") operator on [`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON
    "sqlalchemy.dialects.postgresql.JSON") and [`JSONB`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSONB
    "sqlalchemy.dialects.postgresql.JSONB") no longer implicitly invoke the [`Comparator.astext`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON.Comparator.astext
    "sqlalchemy.dialects.postgresql.JSON.Comparator.astext") modifier; PostgreSQL’s
    JSON/JSONB types support CAST operations to each other without the “astext” aspect.
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that in most cases, an application that was doing this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'Will now need to change to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]  ### ARRAY with ENUM will now emit CREATE TYPE for the ENUM'
  prefs: []
  type: TYPE_NORMAL
- en: 'A table definition like the following will now emit CREATE TYPE as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'emits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '[#2729](https://www.sqlalchemy.org/trac/ticket/2729)'
  prefs: []
  type: TYPE_NORMAL
- en: Check constraints now reflect
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The PostgreSQL dialect now supports reflection of CHECK constraints both within
    the method [`Inspector.get_check_constraints()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_check_constraints
    "sqlalchemy.engine.reflection.Inspector.get_check_constraints") as well as within
    [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    reflection within the [`Table.constraints`](../core/metadata.html#sqlalchemy.schema.Table.constraints
    "sqlalchemy.schema.Table.constraints") collection.
  prefs: []
  type: TYPE_NORMAL
- en: “Plain” and “Materialized” views can be inspected separately
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The new argument `PGInspector.get_view_names.include` allows specification
    of which sub-types of views should be returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: '[#3588](https://www.sqlalchemy.org/trac/ticket/3588)'
  prefs: []
  type: TYPE_NORMAL
- en: Added tablespace option to Index
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The [`Index`](../core/constraints.html#sqlalchemy.schema.Index "sqlalchemy.schema.Index")
    object now accepts the argument `postgresql_tablespace` in order to specify TABLESPACE,
    the same way as accepted by the [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") object.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Index Storage Parameters](../dialects/postgresql.html#postgresql-index-storage)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#3720](https://www.sqlalchemy.org/trac/ticket/3720)'
  prefs: []
  type: TYPE_NORMAL
- en: Support for PyGreSQL
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The [PyGreSQL](https://pypi.org/project/PyGreSQL) DBAPI is now supported.
  prefs: []
  type: TYPE_NORMAL
- en: The “postgres” module is removed
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `sqlalchemy.dialects.postgres` module, long deprecated, is removed; this
    has emitted a warning for many years and projects should be calling upon `sqlalchemy.dialects.postgresql`.
    Engine URLs of the form `postgres://` will still continue to function, however.
  prefs: []
  type: TYPE_NORMAL
- en: Support for FOR UPDATE SKIP LOCKED / FOR NO KEY UPDATE / FOR KEY SHARE
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The new parameters [`GenerativeSelect.with_for_update.skip_locked`](../core/selectable.html#sqlalchemy.sql.expression.GenerativeSelect.with_for_update.params.skip_locked
    "sqlalchemy.sql.expression.GenerativeSelect.with_for_update") and [`GenerativeSelect.with_for_update.key_share`](../core/selectable.html#sqlalchemy.sql.expression.GenerativeSelect.with_for_update.params.key_share
    "sqlalchemy.sql.expression.GenerativeSelect.with_for_update") in both Core and
    ORM apply a modification to a “SELECT…FOR UPDATE” or “SELECT…FOR SHARE” query
    on the PostgreSQL backend:'
  prefs: []
  type: TYPE_NORMAL
- en: 'SELECT FOR NO KEY UPDATE:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'SELECT FOR UPDATE SKIP LOCKED:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'SELECT FOR KEY SHARE:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Dialect Improvements and Changes - MySQL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '### MySQL JSON Support'
  prefs: []
  type: TYPE_NORMAL
- en: A new type [`JSON`](../dialects/mysql.html#sqlalchemy.dialects.mysql.JSON "sqlalchemy.dialects.mysql.JSON")
    is added to the MySQL dialect supporting the JSON type newly added to MySQL 5.7\.
    This type provides both persistence of JSON as well as rudimentary indexed-access
    using the `JSON_EXTRACT` function internally. An indexable JSON column that works
    across MySQL and PostgreSQL can be achieved by using the [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON") datatype common to both MySQL and PostgreSQL.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[JSON support added to Core](#change-3619)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#3547](https://www.sqlalchemy.org/trac/ticket/3547)  ### Added support for
    AUTOCOMMIT “isolation level”'
  prefs: []
  type: TYPE_NORMAL
- en: 'The MySQL dialect now accepts the value “AUTOCOMMIT” for the [`create_engine.isolation_level`](../core/engines.html#sqlalchemy.create_engine.params.isolation_level
    "sqlalchemy.create_engine") and [`Connection.execution_options.isolation_level`](../core/connections.html#sqlalchemy.engine.Connection.execution_options.params.isolation_level
    "sqlalchemy.engine.Connection.execution_options") parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: The isolation level makes use of the various “autocommit” attributes provided
    by most MySQL DBAPIs.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3332](https://www.sqlalchemy.org/trac/ticket/3332)  ### No more generation
    of an implicit KEY for composite primary key w/ AUTO_INCREMENT'
  prefs: []
  type: TYPE_NORMAL
- en: 'The MySQL dialect had the behavior such that if a composite primary key on
    an InnoDB table featured AUTO_INCREMENT on one of its columns which was not the
    first column, e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'DDL such as the following would be generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: Note the above “KEY” with an auto-generated name; this is a change that found
    its way into the dialect many years ago in response to the issue that the AUTO_INCREMENT
    would otherwise fail on InnoDB without this additional KEY.
  prefs: []
  type: TYPE_NORMAL
- en: 'This workaround has been removed and replaced with the much better system of
    just stating the AUTO_INCREMENT column *first* within the primary key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'To maintain explicit control of the ordering of primary key columns, use the
    [`PrimaryKeyConstraint`](../core/constraints.html#sqlalchemy.schema.PrimaryKeyConstraint
    "sqlalchemy.schema.PrimaryKeyConstraint") construct explicitly (1.1.0b2) (along
    with a KEY for the autoincrement column as required by MySQL), e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'Along with the change [The .autoincrement directive is no longer implicitly
    enabled for a composite primary key column](#change-3216), composite primary keys
    with or without auto increment are now easier to specify; [`Column.autoincrement`](../core/metadata.html#sqlalchemy.schema.Column.params.autoincrement
    "sqlalchemy.schema.Column") now defaults to the value `"auto"` and the `autoincrement=False`
    directives are no longer needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: Dialect Improvements and Changes - SQLite
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '### Right-nested join workaround lifted for SQLite version 3.7.16'
  prefs: []
  type: TYPE_NORMAL
- en: In version 0.9, the feature introduced by [Many JOIN and LEFT OUTER JOIN expressions
    will no longer be wrapped in (SELECT * FROM ..) AS ANON_1](migration_09.html#feature-joins-09)
    went through lots of effort to support rewriting of joins on SQLite to always
    use subqueries in order to achieve a “right-nested-join” effect, as SQLite has
    not supported this syntax for many years. Ironically, the version of SQLite noted
    in that migration note, 3.7.15.2, was the *last* version of SQLite to actually
    have this limitation! The next release was 3.7.16 and support for right nested
    joins was quietly added. In 1.1, the work to identify the specific SQLite version
    and source commit where this change was made was done (SQLite’s changelog refers
    to it with the cryptic phrase “Enhance the query optimizer to exploit transitive
    join constraints” without linking to any issue number, change number, or further
    explanation), and the workarounds present in this change are now lifted for SQLite
    when the DBAPI reports that version 3.7.16 or greater is in effect.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3634](https://www.sqlalchemy.org/trac/ticket/3634)  ### Dotted column names
    workaround lifted for SQLite version 3.10.0'
  prefs: []
  type: TYPE_NORMAL
- en: The SQLite dialect has long had a workaround for an issue where the database
    driver does not report the correct column names for some SQL result sets, in particular
    when UNION is used. The workaround is detailed at [Dotted Column Names](../dialects/sqlite.html#sqlite-dotted-column-names),
    and requires that SQLAlchemy assume that any column name with a dot in it is actually
    a `tablename.columnname` combination delivered via this buggy behavior, with an
    option to turn it off via the `sqlite_raw_colnames` execution option.
  prefs: []
  type: TYPE_NORMAL
- en: As of SQLite version 3.10.0, the bug in UNION and other queries has been fixed;
    like the change described in [Right-nested join workaround lifted for SQLite version
    3.7.16](#change-3634), SQLite’s changelog only identifies it cryptically as “Added
    the colUsed field to sqlite3_index_info for use by the sqlite3_module.xBestIndex
    method”, however SQLAlchemy’s translation of these dotted column names is no longer
    required with this version, so is turned off when version 3.10.0 or greater is
    detected.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, the SQLAlchemy `ResultProxy` as of the 1.0 series relies much less
    on column names in result sets when delivering results for Core and ORM SQL constructs,
    so the importance of this issue was already lessened in any case.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3633](https://www.sqlalchemy.org/trac/ticket/3633)  ### Improved Support
    for Remote Schemas'
  prefs: []
  type: TYPE_NORMAL
- en: 'The SQLite dialect now implements [`Inspector.get_schema_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_schema_names
    "sqlalchemy.engine.reflection.Inspector.get_schema_names") and additionally has
    improved support for tables and indexes that are created and reflected from a
    remote schema, which in SQLite is a database that is assigned a name via the `ATTACH`
    statement; previously, the``CREATE INDEX`` DDL didn’t work correctly for a schema-bound
    table and the [`Inspector.get_foreign_keys()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_foreign_keys
    "sqlalchemy.engine.reflection.Inspector.get_foreign_keys") method will now indicate
    the given schema in the results. Cross-schema foreign keys aren’t supported.  ###
    Reflection of the name of PRIMARY KEY constraints'
  prefs: []
  type: TYPE_NORMAL
- en: The SQLite backend now takes advantage of the “sqlite_master” view of SQLite
    in order to extract the name of the primary key constraint of a table from the
    original DDL, in the same way that is achieved for foreign key constraints in
    recent SQLAlchemy versions.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3629](https://www.sqlalchemy.org/trac/ticket/3629)'
  prefs: []
  type: TYPE_NORMAL
- en: Check constraints now reflect
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The SQLite dialect now supports reflection of CHECK constraints both within
    the method [`Inspector.get_check_constraints()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_check_constraints
    "sqlalchemy.engine.reflection.Inspector.get_check_constraints") as well as within
    [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    reflection within the [`Table.constraints`](../core/metadata.html#sqlalchemy.schema.Table.constraints
    "sqlalchemy.schema.Table.constraints") collection.
  prefs: []
  type: TYPE_NORMAL
- en: ON DELETE and ON UPDATE foreign key phrases now reflect
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The [`Inspector`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector
    "sqlalchemy.engine.reflection.Inspector") will now include ON DELETE and ON UPDATE
    phrases from foreign key constraints on the SQLite dialect, and the [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") object as reflected as part of a [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") will also indicate these phrases.
  prefs: []
  type: TYPE_NORMAL
- en: Dialect Improvements and Changes - SQL Server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '### Added transaction isolation level support for SQL Server'
  prefs: []
  type: TYPE_NORMAL
- en: 'All SQL Server dialects support transaction isolation level settings via the
    [`create_engine.isolation_level`](../core/engines.html#sqlalchemy.create_engine.params.isolation_level
    "sqlalchemy.create_engine") and [`Connection.execution_options.isolation_level`](../core/connections.html#sqlalchemy.engine.Connection.execution_options.params.isolation_level
    "sqlalchemy.engine.Connection.execution_options") parameters. The four standard
    levels are supported as well as `SNAPSHOT`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Transaction Isolation Level](../dialects/mssql.html#mssql-isolation-level)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#3534](https://www.sqlalchemy.org/trac/ticket/3534)  ### String / varlength
    types no longer represent “max” explicitly on reflection'
  prefs: []
  type: TYPE_NORMAL
- en: 'When reflecting a type such as [`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String"), [`TextClause`](../core/sqlelement.html#sqlalchemy.sql.expression.TextClause
    "sqlalchemy.sql.expression.TextClause"), etc. which includes a length, an “un-lengthed”
    type under SQL Server would copy the “length” parameter as the value `"max"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'The “length” parameter in the base types is expected to be an integer value
    or None only; None indicates unbounded length which the SQL Server dialect interprets
    as “max”. The fix then is so that these lengths come out as None, so that the
    type objects work in non-SQL Server contexts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: Applications which may have been relying on a direct comparison of the “length”
    value to the string “max” should consider the value of `None` to mean the same
    thing.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3504](https://www.sqlalchemy.org/trac/ticket/3504)'
  prefs: []
  type: TYPE_NORMAL
- en: Support for “non clustered” on primary key to allow clustered elsewhere
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `mssql_clustered` flag available on [`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint"), [`PrimaryKeyConstraint`](../core/constraints.html#sqlalchemy.schema.PrimaryKeyConstraint
    "sqlalchemy.schema.PrimaryKeyConstraint"), [`Index`](../core/constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index") now defaults to `None`, and can be set to False which
    will render the NONCLUSTERED keyword in particular for a primary key, allowing
    a different index to be used as “clustered”.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Clustered Index Support](../dialects/mssql.html#mssql-indexes)'
  prefs: []
  type: TYPE_NORMAL
- en: '### The legacy_schema_aliasing flag is now set to False'
  prefs: []
  type: TYPE_NORMAL
- en: 'SQLAlchemy 1.0.5 introduced the `legacy_schema_aliasing` flag to the MSSQL
    dialect, allowing so-called “legacy mode” aliasing to be turned off. This aliasing
    attempts to turn schema-qualified tables into aliases; given a table such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'The legacy mode of behavior will attempt to turn a schema-qualified table name
    into an alias:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: However, this aliasing has been shown to be unnecessary and in many cases produces
    incorrect SQL.
  prefs: []
  type: TYPE_NORMAL
- en: In SQLAlchemy 1.1, the `legacy_schema_aliasing` flag now defaults to False,
    disabling this mode of behavior and allowing the MSSQL dialect to behave normally
    with schema-qualified tables. For applications which may rely on this behavior,
    set the flag back to True.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3434](https://www.sqlalchemy.org/trac/ticket/3434)'
  prefs: []
  type: TYPE_NORMAL
- en: Dialect Improvements and Changes - Oracle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Support for SKIP LOCKED
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The new parameter [`GenerativeSelect.with_for_update.skip_locked`](../core/selectable.html#sqlalchemy.sql.expression.GenerativeSelect.with_for_update.params.skip_locked
    "sqlalchemy.sql.expression.GenerativeSelect.with_for_update") in both Core and
    ORM will generate the “SKIP LOCKED” suffix for a “SELECT…FOR UPDATE” or “SELECT..
    FOR SHARE” query.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This guide introduces what’s new in SQLAlchemy version 1.1, and also documents
    changes which affect users migrating their applications from the 1.0 series of
    SQLAlchemy to 1.1.
  prefs: []
  type: TYPE_NORMAL
- en: Please carefully review the sections on behavioral changes for potentially backwards-incompatible
    changes in behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Platform / Installer Changes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Setuptools is now required for install
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: SQLAlchemy’s `setup.py` file has for many years supported operation both with
    Setuptools installed and without; supporting a “fallback” mode that uses straight
    Distutils. As a Setuptools-less Python environment is now unheard of, and in order
    to support the featureset of Setuptools more fully, in particular to support py.test’s
    integration with it as well as things like “extras”, `setup.py` now depends on
    Setuptools fully.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Installation Guide](../intro.html#installation)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#3489](https://www.sqlalchemy.org/trac/ticket/3489)'
  prefs: []
  type: TYPE_NORMAL
- en: Enabling / Disabling C Extension builds is only via environment variable
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The C Extensions build by default during install as long as it is possible.
    To disable C extension builds, the `DISABLE_SQLALCHEMY_CEXT` environment variable
    was made available as of SQLAlchemy 0.8.6 / 0.9.4\. The previous approach of using
    the `--without-cextensions` argument has been removed, as it relies on deprecated
    features of setuptools.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Building the Cython Extensions](../intro.html#c-extensions)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#3500](https://www.sqlalchemy.org/trac/ticket/3500)'
  prefs: []
  type: TYPE_NORMAL
- en: Setuptools is now required for install
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: SQLAlchemy’s `setup.py` file has for many years supported operation both with
    Setuptools installed and without; supporting a “fallback” mode that uses straight
    Distutils. As a Setuptools-less Python environment is now unheard of, and in order
    to support the featureset of Setuptools more fully, in particular to support py.test’s
    integration with it as well as things like “extras”, `setup.py` now depends on
    Setuptools fully.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Installation Guide](../intro.html#installation)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#3489](https://www.sqlalchemy.org/trac/ticket/3489)'
  prefs: []
  type: TYPE_NORMAL
- en: Enabling / Disabling C Extension builds is only via environment variable
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The C Extensions build by default during install as long as it is possible.
    To disable C extension builds, the `DISABLE_SQLALCHEMY_CEXT` environment variable
    was made available as of SQLAlchemy 0.8.6 / 0.9.4\. The previous approach of using
    the `--without-cextensions` argument has been removed, as it relies on deprecated
    features of setuptools.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Building the Cython Extensions](../intro.html#c-extensions)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#3500](https://www.sqlalchemy.org/trac/ticket/3500)'
  prefs: []
  type: TYPE_NORMAL
- en: New Features and Improvements - ORM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '### New Session lifecycle events'
  prefs: []
  type: TYPE_NORMAL
- en: The [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    has long supported events that allow some degree of tracking of state changes
    to objects, including [`SessionEvents.before_attach()`](../orm/events.html#sqlalchemy.orm.SessionEvents.before_attach
    "sqlalchemy.orm.SessionEvents.before_attach"), [`SessionEvents.after_attach()`](../orm/events.html#sqlalchemy.orm.SessionEvents.after_attach
    "sqlalchemy.orm.SessionEvents.after_attach"), and [`SessionEvents.before_flush()`](../orm/events.html#sqlalchemy.orm.SessionEvents.before_flush
    "sqlalchemy.orm.SessionEvents.before_flush"). The Session documentation also documents
    major object states at [Quickie Intro to Object States](../orm/session_state_management.html#session-object-states).
    However, there has never been system of tracking objects specifically as they
    pass through these transitions. Additionally, the status of “deleted” objects
    has historically been murky as the objects act somewhere between the “persistent”
    and “detached” states.
  prefs: []
  type: TYPE_NORMAL
- en: To clean up this area and allow the realm of session state transition to be
    fully transparent, a new series of events have been added that are intended to
    cover every possible way that an object might transition between states, and additionally
    the “deleted” status has been given its own official state name within the realm
    of session object states.
  prefs: []
  type: TYPE_NORMAL
- en: New State Transition Events
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Transitions between all states of an object such as [persistent](../glossary.html#term-persistent),
    [pending](../glossary.html#term-pending) and others can now be intercepted in
    terms of a session-level event intended to cover a specific transition. Transitions
    as objects move into a [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), move out of a [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), and even all the transitions which occur when the transaction
    is rolled back using [`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") are explicitly present in the interface of
    [`SessionEvents`](../orm/events.html#sqlalchemy.orm.SessionEvents "sqlalchemy.orm.SessionEvents").
  prefs: []
  type: TYPE_NORMAL
- en: In total, there are **ten new events**. A summary of these events is in a newly
    written documentation section [Object Lifecycle Events](../orm/session_events.html#session-lifecycle-events).
  prefs: []
  type: TYPE_NORMAL
- en: New Object State “deleted” is added, deleted objects no longer “persistent”
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The [persistent](../glossary.html#term-persistent) state of an object in the
    [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    has always been documented as an object that has a valid database identity; however
    in the case of objects that were deleted within a flush, they have always been
    in a grey area where they are not really “detached” from the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") yet, because they can still be restored within a rollback,
    but are not really “persistent” because their database identity has been deleted
    and they aren’t present in the identity map.
  prefs: []
  type: TYPE_NORMAL
- en: To resolve this grey area given the new events, a new object state [deleted](../glossary.html#term-deleted)
    is introduced. This state exists between the “persistent” and “detached” states.
    An object that is marked for deletion via [`Session.delete()`](../orm/session_api.html#sqlalchemy.orm.Session.delete
    "sqlalchemy.orm.Session.delete") remains in the “persistent” state until a flush
    proceeds; at that point, it is removed from the identity map, moves to the “deleted”
    state, and the [`SessionEvents.persistent_to_deleted()`](../orm/events.html#sqlalchemy.orm.SessionEvents.persistent_to_deleted
    "sqlalchemy.orm.SessionEvents.persistent_to_deleted") hook is invoked. If the
    [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    object’s transaction is rolled back, the object is restored as persistent; the
    [`SessionEvents.deleted_to_persistent()`](../orm/events.html#sqlalchemy.orm.SessionEvents.deleted_to_persistent
    "sqlalchemy.orm.SessionEvents.deleted_to_persistent") transition is called. Otherwise
    if the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    object’s transaction is committed, the [`SessionEvents.deleted_to_detached()`](../orm/events.html#sqlalchemy.orm.SessionEvents.deleted_to_detached
    "sqlalchemy.orm.SessionEvents.deleted_to_detached") transition is invoked.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, the [`InstanceState.persistent`](../orm/internals.html#sqlalchemy.orm.InstanceState.persistent
    "sqlalchemy.orm.InstanceState.persistent") accessor **no longer returns True**
    for an object that is in the new “deleted” state; instead, the [`InstanceState.deleted`](../orm/internals.html#sqlalchemy.orm.InstanceState.deleted
    "sqlalchemy.orm.InstanceState.deleted") accessor has been enhanced to reliably
    report on this new state. When the object is detached, the [`InstanceState.deleted`](../orm/internals.html#sqlalchemy.orm.InstanceState.deleted
    "sqlalchemy.orm.InstanceState.deleted") returns False and the [`InstanceState.detached`](../orm/internals.html#sqlalchemy.orm.InstanceState.detached
    "sqlalchemy.orm.InstanceState.detached") accessor is True instead. To determine
    if an object was deleted either in the current transaction or in a previous transaction,
    use the [`InstanceState.was_deleted`](../orm/internals.html#sqlalchemy.orm.InstanceState.was_deleted
    "sqlalchemy.orm.InstanceState.was_deleted") accessor.
  prefs: []
  type: TYPE_NORMAL
- en: Strong Identity Map is Deprecated
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: One of the inspirations for the new series of transition events was to enable
    leak-proof tracking of objects as they move in and out of the identity map, so
    that a “strong reference” may be maintained mirroring the object moving in and
    out of this map. With this new capability, there is no longer any need for the
    [`Session.weak_identity_map`](../orm/session_api.html#sqlalchemy.orm.Session.params.weak_identity_map
    "sqlalchemy.orm.Session") parameter and the corresponding `StrongIdentityMap`
    object. This option has remained in SQLAlchemy for many years as the “strong-referencing”
    behavior used to be the only behavior available, and many applications were written
    to assume this behavior. It has long been recommended that strong-reference tracking
    of objects not be an intrinsic job of the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") and instead be an application-level construct built
    as needed by the application; the new event model allows even the exact behavior
    of the strong identity map to be replicated. See [Session Referencing Behavior](../orm/session_state_management.html#session-referencing-behavior)
    for a new recipe illustrating how to replace the strong identity map.
  prefs: []
  type: TYPE_NORMAL
- en: '[#2677](https://www.sqlalchemy.org/trac/ticket/2677)  ### New init_scalar()
    event intercepts default values at ORM level'
  prefs: []
  type: TYPE_NORMAL
- en: 'The ORM produces a value of `None` when an attribute that has not been set
    is first accessed, for a non-persistent object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'There’s a use case for this in-Python value to correspond to that of a Core-generated
    default value, even before the object is persisted. To suit this use case a new
    event [`AttributeEvents.init_scalar()`](../orm/events.html#sqlalchemy.orm.AttributeEvents.init_scalar
    "sqlalchemy.orm.AttributeEvents.init_scalar") is added. The new example `active_column_defaults.py`
    at [Attribute Instrumentation](../orm/examples.html#examples-instrumentation)
    illustrates a sample use, so the effect can instead be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: '[#1311](https://www.sqlalchemy.org/trac/ticket/1311)  ### Changes regarding
    “unhashable” types, impacts deduping of ORM rows'
  prefs: []
  type: TYPE_NORMAL
- en: The [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    object has a well-known behavior of “deduping” returned rows that contain at least
    one ORM-mapped entity (e.g., a full mapped object, as opposed to individual column
    values). The primary purpose of this is so that the handling of entities works
    smoothly in conjunction with the identity map, including to accommodate for the
    duplicate entities normally represented within joined eager loading, as well as
    when joins are used for the purposes of filtering on additional columns.
  prefs: []
  type: TYPE_NORMAL
- en: This deduplication relies upon the hashability of the elements within the row.
    With the introduction of PostgreSQL’s special types like [`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY"), [`HSTORE`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.HSTORE
    "sqlalchemy.dialects.postgresql.HSTORE") and [`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON
    "sqlalchemy.dialects.postgresql.JSON"), the experience of types within rows being
    unhashable and encountering problems here is more prevalent than it was previously.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, SQLAlchemy has since version 0.8 included a flag on datatypes that
    are noted as “unhashable”, however this flag was not used consistently on built
    in types. As described in [ARRAY and JSON types now correctly specify “unhashable”](#change-3499-postgresql),
    this flag is now set consistently for all of PostgreSQL’s “structural” types.
  prefs: []
  type: TYPE_NORMAL
- en: The “unhashable” flag is also set on the [`NullType`](../core/type_api.html#sqlalchemy.types.NullType
    "sqlalchemy.types.NullType") type, as [`NullType`](../core/type_api.html#sqlalchemy.types.NullType
    "sqlalchemy.types.NullType") is used to refer to any expression of unknown type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since [`NullType`](../core/type_api.html#sqlalchemy.types.NullType "sqlalchemy.types.NullType")
    is applied to most usages of `func`, as `func` doesn’t actually know anything
    about the function names given in most cases, **using func() will often disable
    row deduping unless explicit typing is applied**. The following examples illustrate
    `func.substr()` applied to a string expression, and `func.date()` applied to a
    datetime expression; both examples will return duplicate rows due to the joined
    eager load unless explicit typing is applied:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'The above examples, in order to retain deduping, should be specified as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: Additionally, the treatment of a so-called “unhashable” type is slightly different
    than its been in previous releases; internally we are using the `id()` function
    to get a “hash value” from these structures, just as we would any ordinary mapped
    object. This replaces the previous approach which applied a counter to the object.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3499](https://www.sqlalchemy.org/trac/ticket/3499)  ### Specific checks added
    for passing mapped classes, instances as SQL literals'
  prefs: []
  type: TYPE_NORMAL
- en: 'The typing system now has specific checks for passing of SQLAlchemy “inspectable”
    objects in contexts where they would otherwise be handled as literal values. Any
    SQLAlchemy built-in object that is legal to pass as a SQL value (which is not
    already a [`ClauseElement`](../core/foundation.html#sqlalchemy.sql.expression.ClauseElement
    "sqlalchemy.sql.expression.ClauseElement") instance) includes a method `__clause_element__()`
    which provides a valid SQL expression for that object. For SQLAlchemy objects
    that don’t provide this, such as mapped classes, mappers, and mapped instances,
    a more informative error message is emitted rather than allowing the DBAPI to
    receive the object and fail later. An example is illustrated below, where a string-based
    attribute `User.name` is compared to a full instance of `User()`, rather than
    against a string value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: The exception is now immediate when the comparison is made between `User.name
    == some_user`. Previously, a comparison like the above would produce a SQL expression
    that would only fail once resolved into a DBAPI execution call; the mapped `User`
    object would ultimately become a bound parameter that would be rejected by the
    DBAPI.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that in the above example, the expression fails because `User.name` is
    a string-based (e.g. column oriented) attribute. The change does *not* impact
    the usual case of comparing a many-to-one relationship attribute to an object,
    which is handled distinctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: '[#3321](https://www.sqlalchemy.org/trac/ticket/3321)  ### New Indexable ORM
    extension'
  prefs: []
  type: TYPE_NORMAL
- en: 'The [Indexable](../orm/extensions/indexable.html) extension is an extension
    to the hybrid attribute feature which allows the construction of attributes which
    refer to specific elements of an “indexable” data type, such as an array or JSON
    field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: 'Above, the `name` attribute will read/write the field `"name"` from the JSON
    column `data`, after initializing it to an empty dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: The extension also triggers a change event when the attribute is modified, so
    that there’s no need to use [`MutableDict`](../orm/extensions/mutable.html#sqlalchemy.ext.mutable.MutableDict
    "sqlalchemy.ext.mutable.MutableDict") in order to track this change.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Indexable](../orm/extensions/indexable.html)  ### New options allowing explicit
    persistence of NULL over a default'
  prefs: []
  type: TYPE_NORMAL
- en: Related to the new JSON-NULL support added to PostgreSQL as part of [JSON “null”
    is inserted as expected with ORM operations, omitted when not present](#change-3514),
    the base [`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine "sqlalchemy.types.TypeEngine")
    class now supports a method [`TypeEngine.evaluates_none()`](../core/type_api.html#sqlalchemy.types.TypeEngine.evaluates_none
    "sqlalchemy.types.TypeEngine.evaluates_none") which allows a positive set of the
    `None` value on an attribute to be persisted as NULL, rather than omitting the
    column from the INSERT statement, which has the effect of using the column-level
    default. This allows a mapper-level configuration of the existing object-level
    technique of assigning [`null()`](../core/sqlelement.html#sqlalchemy.sql.expression.null
    "sqlalchemy.sql.expression.null") to the attribute.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Forcing NULL on a column with a default](../orm/persistence_techniques.html#session-forcing-null)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#3250](https://www.sqlalchemy.org/trac/ticket/3250)  ### Further Fixes to
    single-table inheritance querying'
  prefs: []
  type: TYPE_NORMAL
- en: 'Continuing from 1.0’s [Change to single-table-inheritance criteria when using
    from_self(), count()](migration_10.html#migration-3177), the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") should no longer inappropriately add the “single inheritance”
    criteria when the query is against a subquery expression such as an exists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: 'Produces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: The IN clause on the inside is appropriate, in order to limit to FooWidget objects,
    however previously the IN clause would also be generated a second time on the
    outside of the subquery.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3582](https://www.sqlalchemy.org/trac/ticket/3582)  ### Improved Session
    state when a SAVEPOINT is cancelled by the database'
  prefs: []
  type: TYPE_NORMAL
- en: 'A common case with MySQL is that a SAVEPOINT is cancelled when a deadlock occurs
    within the transaction. The [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") has been modified to deal with this failure mode slightly
    more gracefully, such that the outer, non-savepoint transaction still remains
    usable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: This issue is a continuation of [#2696](https://www.sqlalchemy.org/trac/ticket/2696)
    where we emit a warning so that the original error can be seen when running on
    Python 2, even though the SAVEPOINT exception takes precedence. On Python 3, exceptions
    are chained so both failures are reported individually.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3680](https://www.sqlalchemy.org/trac/ticket/3680)  ### Erroneous “new instance
    X conflicts with persistent instance Y” flush errors fixed'
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") method is responsible for removing objects
    that were INSERTed into the database, e.g. moved from pending to persistent, within
    that now rolled-back transaction. Objects that make this state change are tracked
    in a weak-referencing collection, and if an object is garbage collected from that
    collection, the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    no longer worries about it (it would otherwise not scale for operations that insert
    many new objects within a transaction). However, an issue arises if the application
    re-loads that same garbage-collected row within the transaction, before the rollback
    occurs; if a strong reference to this object remains into the next transaction,
    the fact that this object was not inserted and should be removed would be lost,
    and the flush would incorrectly raise an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: 'The above program would raise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: 'The bug is that when the above exception is raised, the unit of work is operating
    upon the original object assuming it’s a live row, when in fact the object is
    expired and upon testing reveals that it’s gone. The fix tests this condition
    now, so in the SQL log we see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: Above, the unit of work now does a SELECT for the row we’re about to report
    as a conflict for, sees that it doesn’t exist, and proceeds normally. The expense
    of this SELECT is only incurred in the case when we would have erroneously raised
    an exception in any case.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3677](https://www.sqlalchemy.org/trac/ticket/3677)  ### passive_deletes feature
    for joined-inheritance mappings'
  prefs: []
  type: TYPE_NORMAL
- en: 'A joined-table inheritance mapping may now allow a DELETE to proceed as a result
    of [`Session.delete()`](../orm/session_api.html#sqlalchemy.orm.Session.delete
    "sqlalchemy.orm.Session.delete"), which only emits DELETE for the base table,
    and not the subclass table, allowing configured ON DELETE CASCADE to take place
    for the configured foreign keys. This is configured using the `mapper.passive_deletes`
    option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: 'With the above mapping, the `mapper.passive_deletes` option is configured on
    the base mapper; it takes effect for all non-base mappers that are descendants
    of the mapper with the option set. A DELETE for an object of type `B` no longer
    needs to retrieve the primary key value of `b_table_id` if unloaded, nor does
    it need to emit a DELETE statement for the table itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: 'Will emit SQL as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: As always, the target database must have foreign key support with ON DELETE
    CASCADE enabled.
  prefs: []
  type: TYPE_NORMAL
- en: '[#2349](https://www.sqlalchemy.org/trac/ticket/2349)  ### Same-named backrefs
    will not raise an error when applied to concrete inheritance subclasses'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following mapping has always been possible without issue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: Above, even though class `A` and class `A1` have a relationship named `b`, no
    conflict warning or error occurs because class `A1` is marked as “concrete”.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if the relationships were configured the other way, an error would
    occur:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: The fix enhances the backref feature so that an error is not emitted, as well
    as an additional check within the mapper logic to bypass warning for an attribute
    being replaced.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3630](https://www.sqlalchemy.org/trac/ticket/3630)  ### Same-named relationships
    on inheriting mappers no longer warn'
  prefs: []
  type: TYPE_NORMAL
- en: 'When creating two mappers in an inheritance scenario, placing a relationship
    on both with the same name would emit the warning “relationship ‘<name>’ on mapper
    <name> supersedes the same relationship on inherited mapper ‘<name>’; this can
    cause dependency issues during flush”. An example is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: This warning dates back to the 0.4 series in 2007 and is based on a version
    of the unit of work code that has since been entirely rewritten. Currently, there
    is no known issue with the same-named relationships being placed on a base class
    and a descendant class, so the warning is lifted. However, note that this use
    case is likely not prevalent in real world use due to the warning. While rudimentary
    test support is added for this use case, it is possible that some new issue with
    this pattern may be identified.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.1.0b3.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3749](https://www.sqlalchemy.org/trac/ticket/3749)  ### Hybrid properties
    and methods now propagate the docstring as well as .info'
  prefs: []
  type: TYPE_NORMAL
- en: 'A hybrid method or property will now reflect the `__doc__` value present in
    the original docstring:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: 'The above value of `A.some_name.__doc__` is now honored:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: 'However, to accomplish this, the mechanics of hybrid properties necessarily
    becomes more complex. Previously, the class-level accessor for a hybrid would
    be a simple pass-through, that is, this test would succeed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: 'With the change, the expression returned by `A.some_name` is wrapped inside
    of its own `QueryableAttribute` wrapper:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: A lot of testing went into making sure this wrapper works correctly, including
    for elaborate schemes like that of the [Custom Value Object](https://techspot.zzzeek.org/2011/10/21/hybrids-and-value-agnostic-types/)
    recipe, however we’ll be looking to see that no other regressions occur for users.
  prefs: []
  type: TYPE_NORMAL
- en: 'As part of this change, the `hybrid_property.info` collection is now also propagated
    from the hybrid descriptor itself, rather than from the underlying expression.
    That is, accessing `A.some_name.info` now returns the same dictionary that you’d
    get from `inspect(A).all_orm_descriptors[''some_name''].info`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: Note that this `.info` dictionary is **separate** from that of a mapped attribute
    which the hybrid descriptor may be proxying directly; this is a behavioral change
    from 1.0\. The wrapper will still proxy other useful attributes of a mirrored
    attribute such as `QueryableAttribute.property` and `QueryableAttribute.class_`.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3653](https://www.sqlalchemy.org/trac/ticket/3653)  ### Session.merge resolves
    pending conflicts the same as persistent'
  prefs: []
  type: TYPE_NORMAL
- en: The [`Session.merge()`](../orm/session_api.html#sqlalchemy.orm.Session.merge
    "sqlalchemy.orm.Session.merge") method will now track the identities of objects
    given within a graph to maintain primary key uniqueness before emitting an INSERT.
    When duplicate objects of the same identity are encountered, non-primary-key attributes
    are **overwritten** as the objects are encountered, which is essentially non-deterministic.
    This behavior matches that of how persistent objects, that is objects that are
    already located in the database via primary key, are already treated, so this
    behavior is more internally consistent.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: Above, we merge a `User` object with three new `Order` objects, each referring
    to a distinct `Address` object, however each is given the same primary key. The
    current behavior of [`Session.merge()`](../orm/session_api.html#sqlalchemy.orm.Session.merge
    "sqlalchemy.orm.Session.merge") is to look in the identity map for this `Address`
    object, and use that as the target. If the object is present, meaning that the
    database already has a row for `Address` with primary key “1”, we can see that
    the `email_address` field of the `Address` will be overwritten three times, in
    this case with the values a, b and finally c.
  prefs: []
  type: TYPE_NORMAL
- en: However, if the `Address` row for primary key “1” were not present, [`Session.merge()`](../orm/session_api.html#sqlalchemy.orm.Session.merge
    "sqlalchemy.orm.Session.merge") would instead create three separate `Address`
    instances, and we’d then get a primary key conflict upon INSERT. The new behavior
    is that the proposed primary key for these `Address` objects are tracked in a
    separate dictionary so that we merge the state of the three proposed `Address`
    objects onto one `Address` object to be inserted.
  prefs: []
  type: TYPE_NORMAL
- en: It may have been preferable if the original case emitted some kind of warning
    that conflicting data were present in a single merge-tree, however the non-deterministic
    merging of values has been the behavior for many years for the persistent case;
    it now matches for the pending case. A feature that warns for conflicting values
    could still be feasible for both cases but would add considerable performance
    overhead as each column value would have to be compared during the merge.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3601](https://www.sqlalchemy.org/trac/ticket/3601)  ### Fix involving many-to-one
    object moves with user-initiated foreign key manipulations'
  prefs: []
  type: TYPE_NORMAL
- en: 'A bug has been fixed involving the mechanics of replacing a many-to-one reference
    to an object with another object. During the attribute operation, the location
    of the object that was previously referred to now makes use of the database-committed
    foreign key value, rather than the current foreign key value. The main effect
    of the fix is that a backref event towards a collection will fire off more accurately
    when a many-to-one change is made, even if the foreign key attribute was manually
    moved to the new value beforehand. Assume a mapping of the classes `Parent` and
    `SomeClass`, where `SomeClass.parent` refers to `Parent` and `Parent.items` refers
    to the collection of `SomeClass` objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: 'Above, we’ve made a pending object `some_object`, manipulated its foreign key
    towards `Parent` to refer to it, *then* we actually set up the relationship. Before
    the bug fix, the backref would not have fired off:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: 'The fix now is that when we seek to locate the previous value of `some_object.parent`,
    we disregard the parent id that’s been manually set, and we look for the database-committed
    value. In this case, it’s None because the object is pending, so the event system
    logs `some_object.parent` as a net change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: While it is discouraged to manipulate foreign key attributes that are managed
    by relationships, there is limited support for this use case. Applications that
    manipulate foreign keys in order to allow loads to proceed will often make use
    of the [`Session.enable_relationship_loading()`](../orm/session_api.html#sqlalchemy.orm.Session.enable_relationship_loading
    "sqlalchemy.orm.Session.enable_relationship_loading") and `RelationshipProperty.load_on_pending`
    features, which cause relationships to emit lazy loads based on in-memory foreign
    key values that aren’t persisted. Whether or not these features are in use, this
    behavioral improvement will now be apparent.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3708](https://www.sqlalchemy.org/trac/ticket/3708)  ### Improvements to the
    Query.correlate method with polymorphic entities'
  prefs: []
  type: TYPE_NORMAL
- en: 'In recent SQLAlchemy versions, the SQL generated by many forms of “polymorphic”
    queries has a more “flat” form than it used to, where a JOIN of several tables
    is no longer bundled into a subquery unconditionally. To accommodate this, the
    [`Query.correlate()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.correlate
    "sqlalchemy.orm.Query.correlate") method now extracts the individual tables from
    such a polymorphic selectable and ensures that all are part of the “correlate”
    for the subquery. Assuming the `Person/Manager/Engineer->Company` setup from the
    mapping documentation, using with_polymorphic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: 'The above query now produces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: 'Before the fix, the call to `correlate(Person)` would inadvertently attempt
    to correlate to the join of `Person`, `Engineer` and `Manager` as a single unit,
    so `Person` wouldn’t be correlated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: 'Using correlated subqueries against polymorphic mappings still has some unpolished
    edges. If for example `Person` is polymorphically linked to a so-called “concrete
    polymorphic union” query, the above subquery may not correctly refer to this subquery.
    In all cases, a way to refer to the “polymorphic” entity fully is to create an
    [`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased "sqlalchemy.orm.aliased")
    object from it first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: The [`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased "sqlalchemy.orm.aliased")
    construct guarantees that the “polymorphic selectable” is wrapped in a subquery.
    By referring to it explicitly in the correlated subquery, the polymorphic form
    is correctly used.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3662](https://www.sqlalchemy.org/trac/ticket/3662)  ### Stringify of Query
    will consult the Session for the correct dialect'
  prefs: []
  type: TYPE_NORMAL
- en: Calling `str()` on a [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object will consult the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") for the correct “bind” to use, in order to render the
    SQL that would be passed to the database. In particular this allows a [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") that refers to dialect-specific SQL constructs to be renderable,
    assuming the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    is associated with an appropriate [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"). Previously, this behavior would only take effect if
    the [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData "sqlalchemy.schema.MetaData")
    to which the mappings were associated were itself bound to the target [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine").
  prefs: []
  type: TYPE_NORMAL
- en: If neither the underlying [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") nor the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") are associated with any bound [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine"), then the fallback to the “default” dialect is used
    to generate the SQL string.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[“Friendly” stringification of Core SQL constructs without a dialect](#change-3631)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#3081](https://www.sqlalchemy.org/trac/ticket/3081)  ### Joined eager loading
    where the same entity is present multiple times in one row'
  prefs: []
  type: TYPE_NORMAL
- en: 'A fix has been made to the case has been made whereby an attribute will be
    loaded via joined eager loading, even if the entity was already loaded from the
    row on a different “path” that doesn’t include the attribute. This is a deep use
    case that’s hard to reproduce, but the general idea is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: 'The above query emits SQL like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the `c` table is selected from twice; once in the context of
    `A.b.c -> c_alias_1` and another in the context of `A.c -> c_alias_2`. Also, we
    can see that it is quite possible that the `C` identity for a single row is the
    **same** for both `c_alias_1` and `c_alias_2`, meaning two sets of columns in
    one row result in only one new object being added to the identity map.
  prefs: []
  type: TYPE_NORMAL
- en: The query options above only call for the attribute `C.d` to be loaded in the
    context of `c_alias_1`, and not `c_alias_2`. So whether or not the final `C` object
    we get in the identity map has the `C.d` attribute loaded depends on how the mappings
    are traversed, which while not completely random, is essentially non-deterministic.
    The fix is that even if the loader for `c_alias_1` is processed after that of
    `c_alias_2` for a single row where they both refer to the same identity, the `C.d`
    element will still be loaded. Previously, the loader did not seek to modify the
    load of an entity that was already loaded via a different path. The loader that
    reaches the entity first has always been non-deterministic, so this fix may be
    detectable as a behavioral change in some situations and not others.
  prefs: []
  type: TYPE_NORMAL
- en: The fix includes tests for two variants of the “multiple paths to one entity”
    case, and the fix should hopefully cover all other scenarios of this nature.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3431](https://www.sqlalchemy.org/trac/ticket/3431)'
  prefs: []
  type: TYPE_NORMAL
- en: New MutableList and MutableSet helpers added to the mutation tracking extension
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: New helper classes [`MutableList`](../orm/extensions/mutable.html#sqlalchemy.ext.mutable.MutableList
    "sqlalchemy.ext.mutable.MutableList") and [`MutableSet`](../orm/extensions/mutable.html#sqlalchemy.ext.mutable.MutableSet
    "sqlalchemy.ext.mutable.MutableSet") have been added to the [Mutation Tracking](../orm/extensions/mutable.html)
    extension, to complement the existing [`MutableDict`](../orm/extensions/mutable.html#sqlalchemy.ext.mutable.MutableDict
    "sqlalchemy.ext.mutable.MutableDict") helper.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3297](https://www.sqlalchemy.org/trac/ticket/3297)'
  prefs: []
  type: TYPE_NORMAL
- en: '### New “raise” / “raise_on_sql” loader strategies'
  prefs: []
  type: TYPE_NORMAL
- en: 'To assist with the use case of preventing unwanted lazy loads from occurring
    after a series of objects are loaded, the new “lazy=’raise’” and “lazy=’raise_on_sql’”
    strategies and corresponding loader option [`raiseload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.raiseload
    "sqlalchemy.orm.raiseload") may be applied to a relationship attribute which will
    cause it to raise `InvalidRequestError` when a non-eagerly-loaded attribute is
    accessed for read. The two variants test for either a lazy load of any variety,
    including those that would only return None or retrieve from the identity map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: 'Or a lazy load only where SQL would be emitted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: '[#3512](https://www.sqlalchemy.org/trac/ticket/3512)  ### Mapper.order_by is
    deprecated'
  prefs: []
  type: TYPE_NORMAL
- en: This old parameter from the very first versions of SQLAlchemy was part of the
    original design of the ORM which featured the [`Mapper`](../orm/mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper") object as a public-facing query structure. This role
    has long since been replaced by the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object, where we use [`Query.order_by()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.order_by
    "sqlalchemy.orm.Query.order_by") to indicate the ordering of results in a way
    that works consistently for any combination of SELECT statements, entities and
    SQL expressions. There are many areas in which [`Mapper.order_by`](../orm/mapping_api.html#sqlalchemy.orm.Mapper.params.order_by
    "sqlalchemy.orm.Mapper") doesn’t work as expected (or what would be expected is
    not clear), such as when queries are combined into unions; these cases are not
    supported.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3394](https://www.sqlalchemy.org/trac/ticket/3394)  ### New Session lifecycle
    events'
  prefs: []
  type: TYPE_NORMAL
- en: The [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    has long supported events that allow some degree of tracking of state changes
    to objects, including [`SessionEvents.before_attach()`](../orm/events.html#sqlalchemy.orm.SessionEvents.before_attach
    "sqlalchemy.orm.SessionEvents.before_attach"), [`SessionEvents.after_attach()`](../orm/events.html#sqlalchemy.orm.SessionEvents.after_attach
    "sqlalchemy.orm.SessionEvents.after_attach"), and [`SessionEvents.before_flush()`](../orm/events.html#sqlalchemy.orm.SessionEvents.before_flush
    "sqlalchemy.orm.SessionEvents.before_flush"). The Session documentation also documents
    major object states at [Quickie Intro to Object States](../orm/session_state_management.html#session-object-states).
    However, there has never been system of tracking objects specifically as they
    pass through these transitions. Additionally, the status of “deleted” objects
    has historically been murky as the objects act somewhere between the “persistent”
    and “detached” states.
  prefs: []
  type: TYPE_NORMAL
- en: To clean up this area and allow the realm of session state transition to be
    fully transparent, a new series of events have been added that are intended to
    cover every possible way that an object might transition between states, and additionally
    the “deleted” status has been given its own official state name within the realm
    of session object states.
  prefs: []
  type: TYPE_NORMAL
- en: New State Transition Events
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Transitions between all states of an object such as [persistent](../glossary.html#term-persistent),
    [pending](../glossary.html#term-pending) and others can now be intercepted in
    terms of a session-level event intended to cover a specific transition. Transitions
    as objects move into a [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), move out of a [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), and even all the transitions which occur when the transaction
    is rolled back using [`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") are explicitly present in the interface of
    [`SessionEvents`](../orm/events.html#sqlalchemy.orm.SessionEvents "sqlalchemy.orm.SessionEvents").
  prefs: []
  type: TYPE_NORMAL
- en: In total, there are **ten new events**. A summary of these events is in a newly
    written documentation section [Object Lifecycle Events](../orm/session_events.html#session-lifecycle-events).
  prefs: []
  type: TYPE_NORMAL
- en: New Object State “deleted” is added, deleted objects no longer “persistent”
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The [persistent](../glossary.html#term-persistent) state of an object in the
    [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    has always been documented as an object that has a valid database identity; however
    in the case of objects that were deleted within a flush, they have always been
    in a grey area where they are not really “detached” from the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") yet, because they can still be restored within a rollback,
    but are not really “persistent” because their database identity has been deleted
    and they aren’t present in the identity map.
  prefs: []
  type: TYPE_NORMAL
- en: To resolve this grey area given the new events, a new object state [deleted](../glossary.html#term-deleted)
    is introduced. This state exists between the “persistent” and “detached” states.
    An object that is marked for deletion via [`Session.delete()`](../orm/session_api.html#sqlalchemy.orm.Session.delete
    "sqlalchemy.orm.Session.delete") remains in the “persistent” state until a flush
    proceeds; at that point, it is removed from the identity map, moves to the “deleted”
    state, and the [`SessionEvents.persistent_to_deleted()`](../orm/events.html#sqlalchemy.orm.SessionEvents.persistent_to_deleted
    "sqlalchemy.orm.SessionEvents.persistent_to_deleted") hook is invoked. If the
    [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    object’s transaction is rolled back, the object is restored as persistent; the
    [`SessionEvents.deleted_to_persistent()`](../orm/events.html#sqlalchemy.orm.SessionEvents.deleted_to_persistent
    "sqlalchemy.orm.SessionEvents.deleted_to_persistent") transition is called. Otherwise
    if the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    object’s transaction is committed, the [`SessionEvents.deleted_to_detached()`](../orm/events.html#sqlalchemy.orm.SessionEvents.deleted_to_detached
    "sqlalchemy.orm.SessionEvents.deleted_to_detached") transition is invoked.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, the [`InstanceState.persistent`](../orm/internals.html#sqlalchemy.orm.InstanceState.persistent
    "sqlalchemy.orm.InstanceState.persistent") accessor **no longer returns True**
    for an object that is in the new “deleted” state; instead, the [`InstanceState.deleted`](../orm/internals.html#sqlalchemy.orm.InstanceState.deleted
    "sqlalchemy.orm.InstanceState.deleted") accessor has been enhanced to reliably
    report on this new state. When the object is detached, the [`InstanceState.deleted`](../orm/internals.html#sqlalchemy.orm.InstanceState.deleted
    "sqlalchemy.orm.InstanceState.deleted") returns False and the [`InstanceState.detached`](../orm/internals.html#sqlalchemy.orm.InstanceState.detached
    "sqlalchemy.orm.InstanceState.detached") accessor is True instead. To determine
    if an object was deleted either in the current transaction or in a previous transaction,
    use the [`InstanceState.was_deleted`](../orm/internals.html#sqlalchemy.orm.InstanceState.was_deleted
    "sqlalchemy.orm.InstanceState.was_deleted") accessor.
  prefs: []
  type: TYPE_NORMAL
- en: Strong Identity Map is Deprecated
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: One of the inspirations for the new series of transition events was to enable
    leak-proof tracking of objects as they move in and out of the identity map, so
    that a “strong reference” may be maintained mirroring the object moving in and
    out of this map. With this new capability, there is no longer any need for the
    [`Session.weak_identity_map`](../orm/session_api.html#sqlalchemy.orm.Session.params.weak_identity_map
    "sqlalchemy.orm.Session") parameter and the corresponding `StrongIdentityMap`
    object. This option has remained in SQLAlchemy for many years as the “strong-referencing”
    behavior used to be the only behavior available, and many applications were written
    to assume this behavior. It has long been recommended that strong-reference tracking
    of objects not be an intrinsic job of the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") and instead be an application-level construct built
    as needed by the application; the new event model allows even the exact behavior
    of the strong identity map to be replicated. See [Session Referencing Behavior](../orm/session_state_management.html#session-referencing-behavior)
    for a new recipe illustrating how to replace the strong identity map.
  prefs: []
  type: TYPE_NORMAL
- en: '[#2677](https://www.sqlalchemy.org/trac/ticket/2677)'
  prefs: []
  type: TYPE_NORMAL
- en: New State Transition Events
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Transitions between all states of an object such as [persistent](../glossary.html#term-persistent),
    [pending](../glossary.html#term-pending) and others can now be intercepted in
    terms of a session-level event intended to cover a specific transition. Transitions
    as objects move into a [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), move out of a [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), and even all the transitions which occur when the transaction
    is rolled back using [`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") are explicitly present in the interface of
    [`SessionEvents`](../orm/events.html#sqlalchemy.orm.SessionEvents "sqlalchemy.orm.SessionEvents").
  prefs: []
  type: TYPE_NORMAL
- en: In total, there are **ten new events**. A summary of these events is in a newly
    written documentation section [Object Lifecycle Events](../orm/session_events.html#session-lifecycle-events).
  prefs: []
  type: TYPE_NORMAL
- en: New Object State “deleted” is added, deleted objects no longer “persistent”
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The [persistent](../glossary.html#term-persistent) state of an object in the
    [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    has always been documented as an object that has a valid database identity; however
    in the case of objects that were deleted within a flush, they have always been
    in a grey area where they are not really “detached” from the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") yet, because they can still be restored within a rollback,
    but are not really “persistent” because their database identity has been deleted
    and they aren’t present in the identity map.
  prefs: []
  type: TYPE_NORMAL
- en: To resolve this grey area given the new events, a new object state [deleted](../glossary.html#term-deleted)
    is introduced. This state exists between the “persistent” and “detached” states.
    An object that is marked for deletion via [`Session.delete()`](../orm/session_api.html#sqlalchemy.orm.Session.delete
    "sqlalchemy.orm.Session.delete") remains in the “persistent” state until a flush
    proceeds; at that point, it is removed from the identity map, moves to the “deleted”
    state, and the [`SessionEvents.persistent_to_deleted()`](../orm/events.html#sqlalchemy.orm.SessionEvents.persistent_to_deleted
    "sqlalchemy.orm.SessionEvents.persistent_to_deleted") hook is invoked. If the
    [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    object’s transaction is rolled back, the object is restored as persistent; the
    [`SessionEvents.deleted_to_persistent()`](../orm/events.html#sqlalchemy.orm.SessionEvents.deleted_to_persistent
    "sqlalchemy.orm.SessionEvents.deleted_to_persistent") transition is called. Otherwise
    if the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    object’s transaction is committed, the [`SessionEvents.deleted_to_detached()`](../orm/events.html#sqlalchemy.orm.SessionEvents.deleted_to_detached
    "sqlalchemy.orm.SessionEvents.deleted_to_detached") transition is invoked.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, the [`InstanceState.persistent`](../orm/internals.html#sqlalchemy.orm.InstanceState.persistent
    "sqlalchemy.orm.InstanceState.persistent") accessor **no longer returns True**
    for an object that is in the new “deleted” state; instead, the [`InstanceState.deleted`](../orm/internals.html#sqlalchemy.orm.InstanceState.deleted
    "sqlalchemy.orm.InstanceState.deleted") accessor has been enhanced to reliably
    report on this new state. When the object is detached, the [`InstanceState.deleted`](../orm/internals.html#sqlalchemy.orm.InstanceState.deleted
    "sqlalchemy.orm.InstanceState.deleted") returns False and the [`InstanceState.detached`](../orm/internals.html#sqlalchemy.orm.InstanceState.detached
    "sqlalchemy.orm.InstanceState.detached") accessor is True instead. To determine
    if an object was deleted either in the current transaction or in a previous transaction,
    use the [`InstanceState.was_deleted`](../orm/internals.html#sqlalchemy.orm.InstanceState.was_deleted
    "sqlalchemy.orm.InstanceState.was_deleted") accessor.
  prefs: []
  type: TYPE_NORMAL
- en: Strong Identity Map is Deprecated
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: One of the inspirations for the new series of transition events was to enable
    leak-proof tracking of objects as they move in and out of the identity map, so
    that a “strong reference” may be maintained mirroring the object moving in and
    out of this map. With this new capability, there is no longer any need for the
    [`Session.weak_identity_map`](../orm/session_api.html#sqlalchemy.orm.Session.params.weak_identity_map
    "sqlalchemy.orm.Session") parameter and the corresponding `StrongIdentityMap`
    object. This option has remained in SQLAlchemy for many years as the “strong-referencing”
    behavior used to be the only behavior available, and many applications were written
    to assume this behavior. It has long been recommended that strong-reference tracking
    of objects not be an intrinsic job of the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") and instead be an application-level construct built
    as needed by the application; the new event model allows even the exact behavior
    of the strong identity map to be replicated. See [Session Referencing Behavior](../orm/session_state_management.html#session-referencing-behavior)
    for a new recipe illustrating how to replace the strong identity map.
  prefs: []
  type: TYPE_NORMAL
- en: '[#2677](https://www.sqlalchemy.org/trac/ticket/2677)'
  prefs: []
  type: TYPE_NORMAL
- en: '### New init_scalar() event intercepts default values at ORM level'
  prefs: []
  type: TYPE_NORMAL
- en: 'The ORM produces a value of `None` when an attribute that has not been set
    is first accessed, for a non-persistent object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: 'There’s a use case for this in-Python value to correspond to that of a Core-generated
    default value, even before the object is persisted. To suit this use case a new
    event [`AttributeEvents.init_scalar()`](../orm/events.html#sqlalchemy.orm.AttributeEvents.init_scalar
    "sqlalchemy.orm.AttributeEvents.init_scalar") is added. The new example `active_column_defaults.py`
    at [Attribute Instrumentation](../orm/examples.html#examples-instrumentation)
    illustrates a sample use, so the effect can instead be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: '[#1311](https://www.sqlalchemy.org/trac/ticket/1311)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Changes regarding “unhashable” types, impacts deduping of ORM rows'
  prefs: []
  type: TYPE_NORMAL
- en: The [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    object has a well-known behavior of “deduping” returned rows that contain at least
    one ORM-mapped entity (e.g., a full mapped object, as opposed to individual column
    values). The primary purpose of this is so that the handling of entities works
    smoothly in conjunction with the identity map, including to accommodate for the
    duplicate entities normally represented within joined eager loading, as well as
    when joins are used for the purposes of filtering on additional columns.
  prefs: []
  type: TYPE_NORMAL
- en: This deduplication relies upon the hashability of the elements within the row.
    With the introduction of PostgreSQL’s special types like [`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY"), [`HSTORE`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.HSTORE
    "sqlalchemy.dialects.postgresql.HSTORE") and [`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON
    "sqlalchemy.dialects.postgresql.JSON"), the experience of types within rows being
    unhashable and encountering problems here is more prevalent than it was previously.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, SQLAlchemy has since version 0.8 included a flag on datatypes that
    are noted as “unhashable”, however this flag was not used consistently on built
    in types. As described in [ARRAY and JSON types now correctly specify “unhashable”](#change-3499-postgresql),
    this flag is now set consistently for all of PostgreSQL’s “structural” types.
  prefs: []
  type: TYPE_NORMAL
- en: The “unhashable” flag is also set on the [`NullType`](../core/type_api.html#sqlalchemy.types.NullType
    "sqlalchemy.types.NullType") type, as [`NullType`](../core/type_api.html#sqlalchemy.types.NullType
    "sqlalchemy.types.NullType") is used to refer to any expression of unknown type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since [`NullType`](../core/type_api.html#sqlalchemy.types.NullType "sqlalchemy.types.NullType")
    is applied to most usages of `func`, as `func` doesn’t actually know anything
    about the function names given in most cases, **using func() will often disable
    row deduping unless explicit typing is applied**. The following examples illustrate
    `func.substr()` applied to a string expression, and `func.date()` applied to a
    datetime expression; both examples will return duplicate rows due to the joined
    eager load unless explicit typing is applied:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: 'The above examples, in order to retain deduping, should be specified as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: Additionally, the treatment of a so-called “unhashable” type is slightly different
    than its been in previous releases; internally we are using the `id()` function
    to get a “hash value” from these structures, just as we would any ordinary mapped
    object. This replaces the previous approach which applied a counter to the object.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3499](https://www.sqlalchemy.org/trac/ticket/3499)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Specific checks added for passing mapped classes, instances as SQL literals'
  prefs: []
  type: TYPE_NORMAL
- en: 'The typing system now has specific checks for passing of SQLAlchemy “inspectable”
    objects in contexts where they would otherwise be handled as literal values. Any
    SQLAlchemy built-in object that is legal to pass as a SQL value (which is not
    already a [`ClauseElement`](../core/foundation.html#sqlalchemy.sql.expression.ClauseElement
    "sqlalchemy.sql.expression.ClauseElement") instance) includes a method `__clause_element__()`
    which provides a valid SQL expression for that object. For SQLAlchemy objects
    that don’t provide this, such as mapped classes, mappers, and mapped instances,
    a more informative error message is emitted rather than allowing the DBAPI to
    receive the object and fail later. An example is illustrated below, where a string-based
    attribute `User.name` is compared to a full instance of `User()`, rather than
    against a string value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: The exception is now immediate when the comparison is made between `User.name
    == some_user`. Previously, a comparison like the above would produce a SQL expression
    that would only fail once resolved into a DBAPI execution call; the mapped `User`
    object would ultimately become a bound parameter that would be rejected by the
    DBAPI.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that in the above example, the expression fails because `User.name` is
    a string-based (e.g. column oriented) attribute. The change does *not* impact
    the usual case of comparing a many-to-one relationship attribute to an object,
    which is handled distinctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: '[#3321](https://www.sqlalchemy.org/trac/ticket/3321)'
  prefs: []
  type: TYPE_NORMAL
- en: '### New Indexable ORM extension'
  prefs: []
  type: TYPE_NORMAL
- en: 'The [Indexable](../orm/extensions/indexable.html) extension is an extension
    to the hybrid attribute feature which allows the construction of attributes which
    refer to specific elements of an “indexable” data type, such as an array or JSON
    field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: 'Above, the `name` attribute will read/write the field `"name"` from the JSON
    column `data`, after initializing it to an empty dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: The extension also triggers a change event when the attribute is modified, so
    that there’s no need to use [`MutableDict`](../orm/extensions/mutable.html#sqlalchemy.ext.mutable.MutableDict
    "sqlalchemy.ext.mutable.MutableDict") in order to track this change.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Indexable](../orm/extensions/indexable.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '### New options allowing explicit persistence of NULL over a default'
  prefs: []
  type: TYPE_NORMAL
- en: Related to the new JSON-NULL support added to PostgreSQL as part of [JSON “null”
    is inserted as expected with ORM operations, omitted when not present](#change-3514),
    the base [`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine "sqlalchemy.types.TypeEngine")
    class now supports a method [`TypeEngine.evaluates_none()`](../core/type_api.html#sqlalchemy.types.TypeEngine.evaluates_none
    "sqlalchemy.types.TypeEngine.evaluates_none") which allows a positive set of the
    `None` value on an attribute to be persisted as NULL, rather than omitting the
    column from the INSERT statement, which has the effect of using the column-level
    default. This allows a mapper-level configuration of the existing object-level
    technique of assigning [`null()`](../core/sqlelement.html#sqlalchemy.sql.expression.null
    "sqlalchemy.sql.expression.null") to the attribute.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Forcing NULL on a column with a default](../orm/persistence_techniques.html#session-forcing-null)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#3250](https://www.sqlalchemy.org/trac/ticket/3250)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Further Fixes to single-table inheritance querying'
  prefs: []
  type: TYPE_NORMAL
- en: 'Continuing from 1.0’s [Change to single-table-inheritance criteria when using
    from_self(), count()](migration_10.html#migration-3177), the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") should no longer inappropriately add the “single inheritance”
    criteria when the query is against a subquery expression such as an exists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: 'Produces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: The IN clause on the inside is appropriate, in order to limit to FooWidget objects,
    however previously the IN clause would also be generated a second time on the
    outside of the subquery.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3582](https://www.sqlalchemy.org/trac/ticket/3582)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Improved Session state when a SAVEPOINT is cancelled by the database'
  prefs: []
  type: TYPE_NORMAL
- en: 'A common case with MySQL is that a SAVEPOINT is cancelled when a deadlock occurs
    within the transaction. The [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") has been modified to deal with this failure mode slightly
    more gracefully, such that the outer, non-savepoint transaction still remains
    usable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: This issue is a continuation of [#2696](https://www.sqlalchemy.org/trac/ticket/2696)
    where we emit a warning so that the original error can be seen when running on
    Python 2, even though the SAVEPOINT exception takes precedence. On Python 3, exceptions
    are chained so both failures are reported individually.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3680](https://www.sqlalchemy.org/trac/ticket/3680)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Erroneous “new instance X conflicts with persistent instance Y” flush errors
    fixed'
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") method is responsible for removing objects
    that were INSERTed into the database, e.g. moved from pending to persistent, within
    that now rolled-back transaction. Objects that make this state change are tracked
    in a weak-referencing collection, and if an object is garbage collected from that
    collection, the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    no longer worries about it (it would otherwise not scale for operations that insert
    many new objects within a transaction). However, an issue arises if the application
    re-loads that same garbage-collected row within the transaction, before the rollback
    occurs; if a strong reference to this object remains into the next transaction,
    the fact that this object was not inserted and should be removed would be lost,
    and the flush would incorrectly raise an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: 'The above program would raise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: 'The bug is that when the above exception is raised, the unit of work is operating
    upon the original object assuming it’s a live row, when in fact the object is
    expired and upon testing reveals that it’s gone. The fix tests this condition
    now, so in the SQL log we see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: Above, the unit of work now does a SELECT for the row we’re about to report
    as a conflict for, sees that it doesn’t exist, and proceeds normally. The expense
    of this SELECT is only incurred in the case when we would have erroneously raised
    an exception in any case.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3677](https://www.sqlalchemy.org/trac/ticket/3677)'
  prefs: []
  type: TYPE_NORMAL
- en: '### passive_deletes feature for joined-inheritance mappings'
  prefs: []
  type: TYPE_NORMAL
- en: 'A joined-table inheritance mapping may now allow a DELETE to proceed as a result
    of [`Session.delete()`](../orm/session_api.html#sqlalchemy.orm.Session.delete
    "sqlalchemy.orm.Session.delete"), which only emits DELETE for the base table,
    and not the subclass table, allowing configured ON DELETE CASCADE to take place
    for the configured foreign keys. This is configured using the `mapper.passive_deletes`
    option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: 'With the above mapping, the `mapper.passive_deletes` option is configured on
    the base mapper; it takes effect for all non-base mappers that are descendants
    of the mapper with the option set. A DELETE for an object of type `B` no longer
    needs to retrieve the primary key value of `b_table_id` if unloaded, nor does
    it need to emit a DELETE statement for the table itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: 'Will emit SQL as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: As always, the target database must have foreign key support with ON DELETE
    CASCADE enabled.
  prefs: []
  type: TYPE_NORMAL
- en: '[#2349](https://www.sqlalchemy.org/trac/ticket/2349)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Same-named backrefs will not raise an error when applied to concrete inheritance
    subclasses'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following mapping has always been possible without issue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: Above, even though class `A` and class `A1` have a relationship named `b`, no
    conflict warning or error occurs because class `A1` is marked as “concrete”.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if the relationships were configured the other way, an error would
    occur:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: The fix enhances the backref feature so that an error is not emitted, as well
    as an additional check within the mapper logic to bypass warning for an attribute
    being replaced.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3630](https://www.sqlalchemy.org/trac/ticket/3630)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Same-named relationships on inheriting mappers no longer warn'
  prefs: []
  type: TYPE_NORMAL
- en: 'When creating two mappers in an inheritance scenario, placing a relationship
    on both with the same name would emit the warning “relationship ‘<name>’ on mapper
    <name> supersedes the same relationship on inherited mapper ‘<name>’; this can
    cause dependency issues during flush”. An example is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: This warning dates back to the 0.4 series in 2007 and is based on a version
    of the unit of work code that has since been entirely rewritten. Currently, there
    is no known issue with the same-named relationships being placed on a base class
    and a descendant class, so the warning is lifted. However, note that this use
    case is likely not prevalent in real world use due to the warning. While rudimentary
    test support is added for this use case, it is possible that some new issue with
    this pattern may be identified.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.1.0b3.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3749](https://www.sqlalchemy.org/trac/ticket/3749)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Hybrid properties and methods now propagate the docstring as well as .info'
  prefs: []
  type: TYPE_NORMAL
- en: 'A hybrid method or property will now reflect the `__doc__` value present in
    the original docstring:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: 'The above value of `A.some_name.__doc__` is now honored:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: 'However, to accomplish this, the mechanics of hybrid properties necessarily
    becomes more complex. Previously, the class-level accessor for a hybrid would
    be a simple pass-through, that is, this test would succeed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: 'With the change, the expression returned by `A.some_name` is wrapped inside
    of its own `QueryableAttribute` wrapper:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: A lot of testing went into making sure this wrapper works correctly, including
    for elaborate schemes like that of the [Custom Value Object](https://techspot.zzzeek.org/2011/10/21/hybrids-and-value-agnostic-types/)
    recipe, however we’ll be looking to see that no other regressions occur for users.
  prefs: []
  type: TYPE_NORMAL
- en: 'As part of this change, the `hybrid_property.info` collection is now also propagated
    from the hybrid descriptor itself, rather than from the underlying expression.
    That is, accessing `A.some_name.info` now returns the same dictionary that you’d
    get from `inspect(A).all_orm_descriptors[''some_name''].info`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: Note that this `.info` dictionary is **separate** from that of a mapped attribute
    which the hybrid descriptor may be proxying directly; this is a behavioral change
    from 1.0\. The wrapper will still proxy other useful attributes of a mirrored
    attribute such as `QueryableAttribute.property` and `QueryableAttribute.class_`.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3653](https://www.sqlalchemy.org/trac/ticket/3653)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Session.merge resolves pending conflicts the same as persistent'
  prefs: []
  type: TYPE_NORMAL
- en: The [`Session.merge()`](../orm/session_api.html#sqlalchemy.orm.Session.merge
    "sqlalchemy.orm.Session.merge") method will now track the identities of objects
    given within a graph to maintain primary key uniqueness before emitting an INSERT.
    When duplicate objects of the same identity are encountered, non-primary-key attributes
    are **overwritten** as the objects are encountered, which is essentially non-deterministic.
    This behavior matches that of how persistent objects, that is objects that are
    already located in the database via primary key, are already treated, so this
    behavior is more internally consistent.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: Above, we merge a `User` object with three new `Order` objects, each referring
    to a distinct `Address` object, however each is given the same primary key. The
    current behavior of [`Session.merge()`](../orm/session_api.html#sqlalchemy.orm.Session.merge
    "sqlalchemy.orm.Session.merge") is to look in the identity map for this `Address`
    object, and use that as the target. If the object is present, meaning that the
    database already has a row for `Address` with primary key “1”, we can see that
    the `email_address` field of the `Address` will be overwritten three times, in
    this case with the values a, b and finally c.
  prefs: []
  type: TYPE_NORMAL
- en: However, if the `Address` row for primary key “1” were not present, [`Session.merge()`](../orm/session_api.html#sqlalchemy.orm.Session.merge
    "sqlalchemy.orm.Session.merge") would instead create three separate `Address`
    instances, and we’d then get a primary key conflict upon INSERT. The new behavior
    is that the proposed primary key for these `Address` objects are tracked in a
    separate dictionary so that we merge the state of the three proposed `Address`
    objects onto one `Address` object to be inserted.
  prefs: []
  type: TYPE_NORMAL
- en: It may have been preferable if the original case emitted some kind of warning
    that conflicting data were present in a single merge-tree, however the non-deterministic
    merging of values has been the behavior for many years for the persistent case;
    it now matches for the pending case. A feature that warns for conflicting values
    could still be feasible for both cases but would add considerable performance
    overhead as each column value would have to be compared during the merge.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3601](https://www.sqlalchemy.org/trac/ticket/3601)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Fix involving many-to-one object moves with user-initiated foreign key
    manipulations'
  prefs: []
  type: TYPE_NORMAL
- en: 'A bug has been fixed involving the mechanics of replacing a many-to-one reference
    to an object with another object. During the attribute operation, the location
    of the object that was previously referred to now makes use of the database-committed
    foreign key value, rather than the current foreign key value. The main effect
    of the fix is that a backref event towards a collection will fire off more accurately
    when a many-to-one change is made, even if the foreign key attribute was manually
    moved to the new value beforehand. Assume a mapping of the classes `Parent` and
    `SomeClass`, where `SomeClass.parent` refers to `Parent` and `Parent.items` refers
    to the collection of `SomeClass` objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: 'Above, we’ve made a pending object `some_object`, manipulated its foreign key
    towards `Parent` to refer to it, *then* we actually set up the relationship. Before
    the bug fix, the backref would not have fired off:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: 'The fix now is that when we seek to locate the previous value of `some_object.parent`,
    we disregard the parent id that’s been manually set, and we look for the database-committed
    value. In this case, it’s None because the object is pending, so the event system
    logs `some_object.parent` as a net change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: While it is discouraged to manipulate foreign key attributes that are managed
    by relationships, there is limited support for this use case. Applications that
    manipulate foreign keys in order to allow loads to proceed will often make use
    of the [`Session.enable_relationship_loading()`](../orm/session_api.html#sqlalchemy.orm.Session.enable_relationship_loading
    "sqlalchemy.orm.Session.enable_relationship_loading") and `RelationshipProperty.load_on_pending`
    features, which cause relationships to emit lazy loads based on in-memory foreign
    key values that aren’t persisted. Whether or not these features are in use, this
    behavioral improvement will now be apparent.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3708](https://www.sqlalchemy.org/trac/ticket/3708)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Improvements to the Query.correlate method with polymorphic entities'
  prefs: []
  type: TYPE_NORMAL
- en: 'In recent SQLAlchemy versions, the SQL generated by many forms of “polymorphic”
    queries has a more “flat” form than it used to, where a JOIN of several tables
    is no longer bundled into a subquery unconditionally. To accommodate this, the
    [`Query.correlate()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.correlate
    "sqlalchemy.orm.Query.correlate") method now extracts the individual tables from
    such a polymorphic selectable and ensures that all are part of the “correlate”
    for the subquery. Assuming the `Person/Manager/Engineer->Company` setup from the
    mapping documentation, using with_polymorphic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: 'The above query now produces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: 'Before the fix, the call to `correlate(Person)` would inadvertently attempt
    to correlate to the join of `Person`, `Engineer` and `Manager` as a single unit,
    so `Person` wouldn’t be correlated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: 'Using correlated subqueries against polymorphic mappings still has some unpolished
    edges. If for example `Person` is polymorphically linked to a so-called “concrete
    polymorphic union” query, the above subquery may not correctly refer to this subquery.
    In all cases, a way to refer to the “polymorphic” entity fully is to create an
    [`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased "sqlalchemy.orm.aliased")
    object from it first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: The [`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased "sqlalchemy.orm.aliased")
    construct guarantees that the “polymorphic selectable” is wrapped in a subquery.
    By referring to it explicitly in the correlated subquery, the polymorphic form
    is correctly used.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3662](https://www.sqlalchemy.org/trac/ticket/3662)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Stringify of Query will consult the Session for the correct dialect'
  prefs: []
  type: TYPE_NORMAL
- en: Calling `str()` on a [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object will consult the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") for the correct “bind” to use, in order to render the
    SQL that would be passed to the database. In particular this allows a [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") that refers to dialect-specific SQL constructs to be renderable,
    assuming the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    is associated with an appropriate [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"). Previously, this behavior would only take effect if
    the [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData "sqlalchemy.schema.MetaData")
    to which the mappings were associated were itself bound to the target [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine").
  prefs: []
  type: TYPE_NORMAL
- en: If neither the underlying [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") nor the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") are associated with any bound [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine"), then the fallback to the “default” dialect is used
    to generate the SQL string.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[“Friendly” stringification of Core SQL constructs without a dialect](#change-3631)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#3081](https://www.sqlalchemy.org/trac/ticket/3081)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Joined eager loading where the same entity is present multiple times in
    one row'
  prefs: []
  type: TYPE_NORMAL
- en: 'A fix has been made to the case has been made whereby an attribute will be
    loaded via joined eager loading, even if the entity was already loaded from the
    row on a different “path” that doesn’t include the attribute. This is a deep use
    case that’s hard to reproduce, but the general idea is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: 'The above query emits SQL like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the `c` table is selected from twice; once in the context of
    `A.b.c -> c_alias_1` and another in the context of `A.c -> c_alias_2`. Also, we
    can see that it is quite possible that the `C` identity for a single row is the
    **same** for both `c_alias_1` and `c_alias_2`, meaning two sets of columns in
    one row result in only one new object being added to the identity map.
  prefs: []
  type: TYPE_NORMAL
- en: The query options above only call for the attribute `C.d` to be loaded in the
    context of `c_alias_1`, and not `c_alias_2`. So whether or not the final `C` object
    we get in the identity map has the `C.d` attribute loaded depends on how the mappings
    are traversed, which while not completely random, is essentially non-deterministic.
    The fix is that even if the loader for `c_alias_1` is processed after that of
    `c_alias_2` for a single row where they both refer to the same identity, the `C.d`
    element will still be loaded. Previously, the loader did not seek to modify the
    load of an entity that was already loaded via a different path. The loader that
    reaches the entity first has always been non-deterministic, so this fix may be
    detectable as a behavioral change in some situations and not others.
  prefs: []
  type: TYPE_NORMAL
- en: The fix includes tests for two variants of the “multiple paths to one entity”
    case, and the fix should hopefully cover all other scenarios of this nature.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3431](https://www.sqlalchemy.org/trac/ticket/3431)'
  prefs: []
  type: TYPE_NORMAL
- en: New MutableList and MutableSet helpers added to the mutation tracking extension
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: New helper classes [`MutableList`](../orm/extensions/mutable.html#sqlalchemy.ext.mutable.MutableList
    "sqlalchemy.ext.mutable.MutableList") and [`MutableSet`](../orm/extensions/mutable.html#sqlalchemy.ext.mutable.MutableSet
    "sqlalchemy.ext.mutable.MutableSet") have been added to the [Mutation Tracking](../orm/extensions/mutable.html)
    extension, to complement the existing [`MutableDict`](../orm/extensions/mutable.html#sqlalchemy.ext.mutable.MutableDict
    "sqlalchemy.ext.mutable.MutableDict") helper.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3297](https://www.sqlalchemy.org/trac/ticket/3297)'
  prefs: []
  type: TYPE_NORMAL
- en: '### New “raise” / “raise_on_sql” loader strategies'
  prefs: []
  type: TYPE_NORMAL
- en: 'To assist with the use case of preventing unwanted lazy loads from occurring
    after a series of objects are loaded, the new “lazy=’raise’” and “lazy=’raise_on_sql’”
    strategies and corresponding loader option [`raiseload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.raiseload
    "sqlalchemy.orm.raiseload") may be applied to a relationship attribute which will
    cause it to raise `InvalidRequestError` when a non-eagerly-loaded attribute is
    accessed for read. The two variants test for either a lazy load of any variety,
    including those that would only return None or retrieve from the identity map:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: 'Or a lazy load only where SQL would be emitted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: '[#3512](https://www.sqlalchemy.org/trac/ticket/3512)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Mapper.order_by is deprecated'
  prefs: []
  type: TYPE_NORMAL
- en: This old parameter from the very first versions of SQLAlchemy was part of the
    original design of the ORM which featured the [`Mapper`](../orm/mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper") object as a public-facing query structure. This role
    has long since been replaced by the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object, where we use [`Query.order_by()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.order_by
    "sqlalchemy.orm.Query.order_by") to indicate the ordering of results in a way
    that works consistently for any combination of SELECT statements, entities and
    SQL expressions. There are many areas in which [`Mapper.order_by`](../orm/mapping_api.html#sqlalchemy.orm.Mapper.params.order_by
    "sqlalchemy.orm.Mapper") doesn’t work as expected (or what would be expected is
    not clear), such as when queries are combined into unions; these cases are not
    supported.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3394](https://www.sqlalchemy.org/trac/ticket/3394)'
  prefs: []
  type: TYPE_NORMAL
- en: New Features and Improvements - Core
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '### Engines now invalidate connections, run error handlers for BaseException'
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 1.1: this change is a late add to the 1.1 series just prior
    to 1.1 final, and is not present in the 1.1 beta releases.'
  prefs: []
  type: TYPE_NORMAL
- en: The Python `BaseException` class is below that of `Exception` but is the identifiable
    base for system-level exceptions such as `KeyboardInterrupt`, `SystemExit`, and
    notably the `GreenletExit` exception that’s used by eventlet and gevent. This
    exception class is now intercepted by the exception- handling routines of [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection"), and includes handling by the `ConnectionEvents.handle_error()`
    event. The [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") is now **invalidated** by default in the case
    of a system level exception that is not a subclass of `Exception`, as it is assumed
    an operation was interrupted and the connection may be in an unusable state. The
    MySQL drivers are most targeted by this change however the change is across all
    DBAPIs.
  prefs: []
  type: TYPE_NORMAL
- en: Note that upon invalidation, the immediate DBAPI connection used by [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") is disposed, and the [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection"), if still being used subsequent to the exception
    raise, will use a new DBAPI connection for subsequent operations upon next use;
    however, the state of any transaction in progress is lost and the appropriate
    `.rollback()` method must be called if applicable before this re-use can proceed.
  prefs: []
  type: TYPE_NORMAL
- en: In order to identify this change, it was straightforward to demonstrate a pymysql
    or mysqlclient / MySQL-Python connection moving into a corrupted state when these
    exceptions occur in the middle of the connection doing its work; the connection
    would then be returned to the connection pool where subsequent uses would fail,
    or even before returning to the pool would cause secondary failures in context
    managers that call `.rollback()` upon the exception catch. The behavior here is
    expected to reduce the incidence of the MySQL error “commands out of sync”, as
    well as the `ResourceClosedError` which can occur when the MySQL driver fails
    to report `cursor.description` correctly, when running under greenlet conditions
    where greenlets are killed, or where `KeyboardInterrupt` exceptions are handled
    without exiting the program entirely.
  prefs: []
  type: TYPE_NORMAL
- en: The behavior is distinct from the usual auto-invalidation feature, in that it
    does not assume that the backend database itself has been shut down or restarted;
    it does not recycle the entire connection pool as is the case for usual DBAPI
    disconnect exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: 'This change should be a net improvement for all users with the exception of
    **any application that currently intercepts ``KeyboardInterrupt`` or ``GreenletExit``
    and wishes to continue working within the same transaction**. Such an operation
    is theoretically possible with other DBAPIs that do not appear to be impacted
    by `KeyboardInterrupt` such as psycopg2\. For these DBAPIs, the following workaround
    will disable the connection from being recycled for specific exceptions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: '[#3803](https://www.sqlalchemy.org/trac/ticket/3803)  ### CTE Support for INSERT,
    UPDATE, DELETE'
  prefs: []
  type: TYPE_NORMAL
- en: One of the most widely requested features is support for common table expressions
    (CTE) that work with INSERT, UPDATE, DELETE, and is now implemented. An INSERT/UPDATE/DELETE
    can both draw from a WITH clause that’s stated at the top of the SQL, as well
    as can be used as a CTE itself in the context of a larger statement.
  prefs: []
  type: TYPE_NORMAL
- en: As part of this change, an INSERT from SELECT that includes a CTE will now render
    the CTE at the top of the entire statement, rather than nested in the SELECT statement
    as was the case in 1.0.
  prefs: []
  type: TYPE_NORMAL
- en: 'Below is an example that renders UPDATE, INSERT and SELECT all in one statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: '[#2551](https://www.sqlalchemy.org/trac/ticket/2551)  ### Support for RANGE
    and ROWS specification within window functions'
  prefs: []
  type: TYPE_NORMAL
- en: 'New [`over.range_`](../core/sqlelement.html#sqlalchemy.sql.expression.over.params.range_
    "sqlalchemy.sql.expression.over") and [`over.rows`](../core/sqlelement.html#sqlalchemy.sql.expression.over.params.rows
    "sqlalchemy.sql.expression.over") parameters allow RANGE and ROWS expressions
    for window functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: '[`over.range_`](../core/sqlelement.html#sqlalchemy.sql.expression.over.params.range_
    "sqlalchemy.sql.expression.over") and [`over.rows`](../core/sqlelement.html#sqlalchemy.sql.expression.over.params.rows
    "sqlalchemy.sql.expression.over") are specified as 2-tuples and indicate negative
    and positive values for specific ranges, 0 for “CURRENT ROW”, and None for UNBOUNDED.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Using Window Functions](../tutorial/data_select.html#tutorial-window-functions)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#3049](https://www.sqlalchemy.org/trac/ticket/3049)  ### Support for the SQL
    LATERAL keyword'
  prefs: []
  type: TYPE_NORMAL
- en: 'The LATERAL keyword is currently known to only be supported by PostgreSQL 9.3
    and greater, however as it is part of the SQL standard support for this keyword
    is added to Core. The implementation of [`Select.lateral()`](../core/selectable.html#sqlalchemy.sql.expression.Select.lateral
    "sqlalchemy.sql.expression.Select.lateral") employs special logic beyond just
    rendering the LATERAL keyword to allow for correlation of tables that are derived
    from the same FROM clause as the selectable, e.g. lateral correlation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[LATERAL correlation](../tutorial/data_select.html#tutorial-lateral-correlation)'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Lateral`](../core/selectable.html#sqlalchemy.sql.expression.Lateral "sqlalchemy.sql.expression.Lateral")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Select.lateral()`](../core/selectable.html#sqlalchemy.sql.expression.Select.lateral
    "sqlalchemy.sql.expression.Select.lateral")'
  prefs: []
  type: TYPE_NORMAL
- en: '[#2857](https://www.sqlalchemy.org/trac/ticket/2857)  ### Support for TABLESAMPLE'
  prefs: []
  type: TYPE_NORMAL
- en: 'The SQL standard TABLESAMPLE can be rendered using the [`FromClause.tablesample()`](../core/selectable.html#sqlalchemy.sql.expression.FromClause.tablesample
    "sqlalchemy.sql.expression.FromClause.tablesample") method, which returns a [`TableSample`](../core/selectable.html#sqlalchemy.sql.expression.TableSample
    "sqlalchemy.sql.expression.TableSample") construct similar to an alias:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: 'Assuming `people` with a column `people_id`, the above statement would render
    as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: '[#3718](https://www.sqlalchemy.org/trac/ticket/3718)  ### The `.autoincrement`
    directive is no longer implicitly enabled for a composite primary key column'
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy has always had the convenience feature of enabling the backend database’s
    “autoincrement” feature for a single-column integer primary key; by “autoincrement”
    we mean that the database column will include whatever DDL directives the database
    provides in order to indicate an auto-incrementing integer identifier, such as
    the SERIAL keyword on PostgreSQL or AUTO_INCREMENT on MySQL, and additionally
    that the dialect will receive these generated values from the execution of a [`Table.insert()`](../core/metadata.html#sqlalchemy.schema.Table.insert
    "sqlalchemy.schema.Table.insert") construct using techniques appropriate to that
    backend.
  prefs: []
  type: TYPE_NORMAL
- en: 'What’s changed is that this feature no longer turns on automatically for a
    *composite* primary key; previously, a table definition such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: 'Would have “autoincrement” semantics applied to the `''x''` column, only because
    it’s first in the list of primary key columns. In order to disable this, one would
    have to turn off `autoincrement` on all columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: 'With the new behavior, the composite primary key will not have autoincrement
    semantics unless a column is marked explicitly with `autoincrement=True`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to anticipate some potential backwards-incompatible scenarios, the
    [`Table.insert()`](../core/metadata.html#sqlalchemy.schema.Table.insert "sqlalchemy.schema.Table.insert")
    construct will perform more thorough checks for missing primary key values on
    composite primary key columns that don’t have autoincrement set up; given a table
    such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: 'An INSERT emitted with no values for this table will produce this warning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: 'For a column that is receiving primary key values from a server-side default
    or something less common such as a trigger, the presence of a value generator
    can be indicated using [`FetchedValue`](../core/defaults.html#sqlalchemy.schema.FetchedValue
    "sqlalchemy.schema.FetchedValue"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: 'For the very unlikely case where a composite primary key is actually intended
    to store NULL in one or more of its columns (only supported on SQLite and MySQL),
    specify the column with `nullable=True`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: In a related change, the `autoincrement` flag may be set to True on a column
    that has a client-side or server-side default. This typically will not have much
    impact on the behavior of the column during an INSERT.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[No more generation of an implicit KEY for composite primary key w/ AUTO_INCREMENT](#change-mysql-3216)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#3216](https://www.sqlalchemy.org/trac/ticket/3216)  ### Support for IS DISTINCT
    FROM and IS NOT DISTINCT FROM'
  prefs: []
  type: TYPE_NORMAL
- en: 'New operators [`ColumnOperators.is_distinct_from()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.is_distinct_from
    "sqlalchemy.sql.expression.ColumnOperators.is_distinct_from") and [`ColumnOperators.isnot_distinct_from()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.isnot_distinct_from
    "sqlalchemy.sql.expression.ColumnOperators.isnot_distinct_from") allow the IS
    DISTINCT FROM and IS NOT DISTINCT FROM sql operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: 'Handling is provided for NULL, True and False:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: 'For SQLite, which doesn’t have this operator, “IS” / “IS NOT” is rendered,
    which on SQLite works for NULL unlike other backends:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE216]  ### Core and ORM support for FULL OUTER JOIN'
  prefs: []
  type: TYPE_NORMAL
- en: 'The new flag [`FromClause.outerjoin.full`](../core/selectable.html#sqlalchemy.sql.expression.FromClause.outerjoin.params.full
    "sqlalchemy.sql.expression.FromClause.outerjoin"), available at the Core and ORM
    level, instructs the compiler to render `FULL OUTER JOIN` where it would normally
    render `LEFT OUTER JOIN`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: 'The flag also works at the ORM level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: '[#1957](https://www.sqlalchemy.org/trac/ticket/1957)  ### ResultSet column
    matching enhancements; positional column setup for textual SQL'
  prefs: []
  type: TYPE_NORMAL
- en: A series of improvements were made to the `ResultProxy` system in the 1.0 series
    as part of [#918](https://www.sqlalchemy.org/trac/ticket/918), which reorganizes
    the internals to match cursor-bound result columns with table/ORM metadata positionally,
    rather than by matching names, for compiled SQL constructs that contain full information
    about the result rows to be returned. This allows a dramatic savings on Python
    overhead as well as much greater accuracy in linking ORM and Core SQL expressions
    to result rows. In 1.1, this reorganization has been taken further internally,
    and also has been made available to pure-text SQL constructs via the use of the
    recently added [`TextClause.columns()`](../core/sqlelement.html#sqlalchemy.sql.expression.TextClause.columns
    "sqlalchemy.sql.expression.TextClause.columns") method.
  prefs: []
  type: TYPE_NORMAL
- en: TextAsFrom.columns() now works positionally
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The [`TextClause.columns()`](../core/sqlelement.html#sqlalchemy.sql.expression.TextClause.columns
    "sqlalchemy.sql.expression.TextClause.columns") method, added in 0.9, accepts
    column-based arguments positionally; in 1.1, when all columns are passed positionally,
    the correlation of these columns to the ultimate result set is also performed
    positionally. The key advantage here is that textual SQL can now be linked to
    an ORM- level result set without the need to deal with ambiguous or duplicate
    column names, or with having to match labeling schemes to ORM-level labeling schemes.
    All that’s needed now is the same ordering of columns within the textual SQL and
    the column arguments passed to [`TextClause.columns()`](../core/sqlelement.html#sqlalchemy.sql.expression.TextClause.columns
    "sqlalchemy.sql.expression.TextClause.columns"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: Above, the textual SQL contains the column “id” three times, which would normally
    be ambiguous. Using the new feature, we can apply the mapped columns from the
    `User` and `Address` class directly, even linking the `Address.user_id` column
    to the `users.id` column in textual SQL for fun, and the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object will receive rows that are correctly targetable
    as needed, including for an eager load.
  prefs: []
  type: TYPE_NORMAL
- en: This change is **backwards incompatible** with code that passes the columns
    to the method with a different ordering than is present in the textual statement.
    It is hoped that this impact will be low due to the fact that this method has
    always been documented illustrating the columns being passed in the same order
    as that of the textual SQL statement, as would seem intuitive, even though the
    internals weren’t checking for this. The method itself was only added as of 0.9
    in any case and may not yet have widespread use. Notes on exactly how to handle
    this behavioral change for applications using it are at [TextClause.columns()
    will match columns positionally, not by name, when passed positionally](#behavior-change-3501).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Selecting with Textual Column Expressions](../tutorial/data_select.html#tutorial-select-arbitrary-text)'
  prefs: []
  type: TYPE_NORMAL
- en: '[TextClause.columns() will match columns positionally, not by name, when passed
    positionally](#behavior-change-3501) - backwards compatibility remarks'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Positional matching is trusted over name-based matching for Core/ORM SQL constructs
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Another aspect of this change is that the rules for matching columns have also
    been modified to rely upon “positional” matching more fully for compiled SQL constructs
    as well. Given a statement like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: 'The above statement will compile to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: 'In 1.0, the above statement when executed would be matched to its original
    compiled construct using positional matching, however because the statement contains
    the `''user_id''` label duplicated, the “ambiguous column” rule would still get
    involved and prevent the columns from being fetched from a row. As of 1.1, the
    “ambiguous column” rule does not affect an exact match from a column construct
    to the SQL column, which is what the ORM uses to fetch columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: Much less likely to get an “ambiguous column” error message
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As part of this change, the wording of the error message `Ambiguous column name
    '<name>' in result set! try 'use_labels' option on select statement.` has been
    dialed back; as this message should now be extremely rare when using the ORM or
    Core compiled SQL constructs, it merely states `Ambiguous column name '<name>'
    in result set column descriptions`, and only when a result column is retrieved
    using the string name that is actually ambiguous, e.g. `row['user_id']` in the
    above example. It also now refers to the actual ambiguous name from the rendered
    SQL statement itself, rather than indicating the key or name that was local to
    the construct being used for the fetch.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3501](https://www.sqlalchemy.org/trac/ticket/3501)  ### Support for Python’s
    native `enum` type and compatible forms'
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.types.Enum")
    type can now be constructed using any PEP-435 compliant enumerated type. When
    using this mode, input values and return values are the actual enumerated objects,
    not the string/integer/etc values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: The `Enum.enums` collection is now a list instead of a tuple
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As part of the changes to [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum"), the `Enum.enums` collection of elements is now a list
    instead of a tuple. This because lists are appropriate for variable length sequences
    of homogeneous items where the position of the element is not semantically significant.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3292](https://www.sqlalchemy.org/trac/ticket/3292)  ### Negative integer
    indexes accommodated by Core result rows'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `RowProxy` object now accommodates single negative integer indexes like
    a regular Python sequence, both in the pure Python and C-extension version. Previously,
    negative values would only work in slices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE224]  ### The `Enum` type now does in-Python validation of values'
  prefs: []
  type: TYPE_NORMAL
- en: 'To accommodate for Python native enumerated objects, as well as for edge cases
    such as that of where a non-native ENUM type is used within an ARRAY and a CHECK
    constraint is infeasible, the [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum") datatype now adds in-Python validation of input values
    when the [`Enum.validate_strings`](../core/type_basics.html#sqlalchemy.types.Enum.params.validate_strings
    "sqlalchemy.types.Enum") flag is used (1.1.0b2):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE225]'
  prefs: []
  type: TYPE_PRE
- en: This validation is turned off by default as there are already use cases identified
    where users don’t want such validation (such as string comparisons). For non-string
    types, it necessarily takes place in all cases. The check also occurs unconditionally
    on the result-handling side as well, when values coming from the database are
    returned.
  prefs: []
  type: TYPE_NORMAL
- en: This validation is in addition to the existing behavior of creating a CHECK
    constraint when a non-native enumerated type is used. The creation of this CHECK
    constraint can now be disabled using the new [`Enum.create_constraint`](../core/type_basics.html#sqlalchemy.types.Enum.params.create_constraint
    "sqlalchemy.types.Enum") flag.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3095](https://www.sqlalchemy.org/trac/ticket/3095)  ### Non-native boolean
    integer values coerced to zero/one/None in all cases'
  prefs: []
  type: TYPE_NORMAL
- en: The [`Boolean`](../core/type_basics.html#sqlalchemy.types.Boolean "sqlalchemy.types.Boolean")
    datatype coerces Python booleans to integer values for backends that don’t have
    a native boolean type, such as SQLite and MySQL. On these backends, a CHECK constraint
    is normally set up which ensures the values in the database are in fact one of
    these two values. However, MySQL ignores CHECK constraints, the constraint is
    optional, and an existing database might not have this constraint. The [`Boolean`](../core/type_basics.html#sqlalchemy.types.Boolean
    "sqlalchemy.types.Boolean") datatype has been repaired such that an incoming Python-side
    value that is already an integer value is coerced to zero or one, not just passed
    as-is; additionally, the C-extension version of the int-to-boolean processor for
    results now uses the same Python boolean interpretation of the value, rather than
    asserting an exact one or zero value. This is now consistent with the pure-Python
    int-to-boolean processor and is more forgiving of existing data already within
    the database. Values of None/NULL are as before retained as None/NULL.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: this change had an unintended side effect that the interpretation of non- integer
    values, such as strings, also changed in behavior such that the string value `"0"`
    would be interpreted as “true”, but only on backends that don’t have a native
    boolean datatype - on “native boolean” backends like PostgreSQL, the string value
    `"0"` is passed directly to the driver and is interpreted as “false”. This is
    an inconsistency that did not occur with the previous implementation. It should
    be noted that passing strings or any other value outside of `None`, `True`, `False`,
    `1`, `0` to the [`Boolean`](../core/type_basics.html#sqlalchemy.types.Boolean
    "sqlalchemy.types.Boolean") datatype is **not supported** and version 1.2 will
    raise an error for this scenario (or possibly just emit a warning, TBD). See also
    [#4102](https://www.sqlalchemy.org/trac/ticket/4102).
  prefs: []
  type: TYPE_NORMAL
- en: '[#3730](https://www.sqlalchemy.org/trac/ticket/3730)  ### Large parameter and
    row values are now truncated in logging and exception displays'
  prefs: []
  type: TYPE_NORMAL
- en: 'A large value present as a bound parameter for a SQL statement, as well as
    a large value present in a result row, will now be truncated during display within
    logging, exception reporting, as well as `repr()` of the row itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: '[#2837](https://www.sqlalchemy.org/trac/ticket/2837)  ### JSON support added
    to Core'
  prefs: []
  type: TYPE_NORMAL
- en: As MySQL now has a JSON datatype in addition to the PostgreSQL JSON datatype,
    the core now gains a [`sqlalchemy.types.JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON") datatype that is the basis for both of these. Using this
    type allows access to the “getitem” operator as well as the “getpath” operator
    in a way that is agnostic across PostgreSQL and MySQL.
  prefs: []
  type: TYPE_NORMAL
- en: The new datatype also has a series of improvements to the handling of NULL values
    as well as expression handling.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[MySQL JSON Support](#change-3547)'
  prefs: []
  type: TYPE_NORMAL
- en: '[`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON "sqlalchemy.dialects.postgresql.JSON")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`JSON`](../dialects/mysql.html#sqlalchemy.dialects.mysql.JSON "sqlalchemy.dialects.mysql.JSON")'
  prefs: []
  type: TYPE_NORMAL
- en: '[#3619](https://www.sqlalchemy.org/trac/ticket/3619)'
  prefs: []
  type: TYPE_NORMAL
- en: '#### JSON “null” is inserted as expected with ORM operations, omitted when
    not present'
  prefs: []
  type: TYPE_NORMAL
- en: The [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON")
    type and its descendant types [`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON
    "sqlalchemy.dialects.postgresql.JSON") and [`JSON`](../dialects/mysql.html#sqlalchemy.dialects.mysql.JSON
    "sqlalchemy.dialects.mysql.JSON") have a flag [`JSON.none_as_null`](../core/type_basics.html#sqlalchemy.types.JSON.params.none_as_null
    "sqlalchemy.types.JSON") which when set to True indicates that the Python value
    `None` should translate into a SQL NULL rather than a JSON NULL value. This flag
    defaults to False, which means that the Python value `None` should result in a
    JSON NULL value.
  prefs: []
  type: TYPE_NORMAL
- en: 'This logic would fail, and is now corrected, in the following circumstances:'
  prefs: []
  type: TYPE_NORMAL
- en: '1\. When the column also contained a default or server_default value, a positive
    value of `None` on the mapped attribute that expects to persist JSON “null” would
    still result in the column-level default being triggered, replacing the `None`
    value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE227]'
  prefs: []
  type: TYPE_PRE
- en: '2\. When the column *did not* contain a default or server_default value, a
    missing value on a JSON column configured with none_as_null=False would still
    render JSON NULL rather than falling back to not inserting any value, behaving
    inconsistently vs. all other datatypes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE228]'
  prefs: []
  type: TYPE_PRE
- en: This is a behavioral change that is backwards incompatible for an application
    that was relying upon this to default a missing value as JSON null. This essentially
    establishes that a **missing value is distinguished from a present value of None**.
    See [JSON Columns will not insert JSON NULL if no value is supplied and no default
    is established](#behavior-change-3514) for further detail.
  prefs: []
  type: TYPE_NORMAL
- en: '3\. When the [`Session.bulk_insert_mappings()`](../orm/session_api.html#sqlalchemy.orm.Session.bulk_insert_mappings
    "sqlalchemy.orm.Session.bulk_insert_mappings") method were used, `None` would
    be ignored in all cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE229]'
  prefs: []
  type: TYPE_PRE
- en: The [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON")
    type now implements the [`TypeEngine.should_evaluate_none`](../core/type_api.html#sqlalchemy.types.TypeEngine.should_evaluate_none
    "sqlalchemy.types.TypeEngine.should_evaluate_none") flag, indicating that `None`
    should not be ignored here; it is configured automatically based on the value
    of [`JSON.none_as_null`](../core/type_basics.html#sqlalchemy.types.JSON.params.none_as_null
    "sqlalchemy.types.JSON"). Thanks to [#3061](https://www.sqlalchemy.org/trac/ticket/3061),
    we can differentiate when the value `None` is actively set by the user versus
    when it was never set at all.
  prefs: []
  type: TYPE_NORMAL
- en: The feature applies as well to the new base [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON") type and its descendant types.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3514](https://www.sqlalchemy.org/trac/ticket/3514)  #### New JSON.NULL Constant
    Added'
  prefs: []
  type: TYPE_NORMAL
- en: 'To ensure that an application can always have full control at the value level
    of whether a [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON"),
    [`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON "sqlalchemy.dialects.postgresql.JSON"),
    [`JSON`](../dialects/mysql.html#sqlalchemy.dialects.mysql.JSON "sqlalchemy.dialects.mysql.JSON"),
    or [`JSONB`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSONB
    "sqlalchemy.dialects.postgresql.JSONB") column should receive a SQL NULL or JSON
    `"null"` value, the constant [`JSON.NULL`](../core/type_basics.html#sqlalchemy.types.JSON.NULL
    "sqlalchemy.types.JSON.NULL") has been added, which in conjunction with [`null()`](../core/sqlelement.html#sqlalchemy.sql.expression.null
    "sqlalchemy.sql.expression.null") can be used to determine fully between SQL NULL
    and JSON `"null"`, regardless of what [`JSON.none_as_null`](../core/type_basics.html#sqlalchemy.types.JSON.params.none_as_null
    "sqlalchemy.types.JSON") is set to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE230]'
  prefs: []
  type: TYPE_PRE
- en: The feature applies as well to the new base [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON") type and its descendant types.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3514](https://www.sqlalchemy.org/trac/ticket/3514)  ### Array support added
    to Core; new ANY and ALL operators'
  prefs: []
  type: TYPE_NORMAL
- en: Along with the enhancements made to the PostgreSQL [`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY") type described in [Correct SQL Types are
    Established from Indexed Access of ARRAY, JSON, HSTORE](#change-3503), the base
    class of [`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY") itself has been moved to Core in a new
    class [`ARRAY`](../core/type_basics.html#sqlalchemy.types.ARRAY "sqlalchemy.types.ARRAY").
  prefs: []
  type: TYPE_NORMAL
- en: 'Arrays are part of the SQL standard, as are several array-oriented functions
    such as `array_agg()` and `unnest()`. In support of these constructs for not just
    PostgreSQL but also potentially for other array-capable backends in the future
    such as DB2, the majority of array logic for SQL expressions is now in Core. The
    [`ARRAY`](../core/type_basics.html#sqlalchemy.types.ARRAY "sqlalchemy.types.ARRAY")
    type still **only works on PostgreSQL**, however it can be used directly, supporting
    special array use cases such as indexed access, as well as support for the ANY
    and ALL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE231]'
  prefs: []
  type: TYPE_PRE
- en: 'In support of ANY and ALL, the [`ARRAY`](../core/type_basics.html#sqlalchemy.types.ARRAY
    "sqlalchemy.types.ARRAY") type retains the same [`Comparator.any()`](../core/type_basics.html#sqlalchemy.types.ARRAY.Comparator.any
    "sqlalchemy.types.ARRAY.Comparator.any") and [`Comparator.all()`](../core/type_basics.html#sqlalchemy.types.ARRAY.Comparator.all
    "sqlalchemy.types.ARRAY.Comparator.all") methods from the PostgreSQL type, but
    also exports these operations to new standalone operator functions [`any_()`](../core/sqlelement.html#sqlalchemy.sql.expression.any_
    "sqlalchemy.sql.expression.any_") and [`all_()`](../core/sqlelement.html#sqlalchemy.sql.expression.all_
    "sqlalchemy.sql.expression.all_"). These two functions work in more of the traditional
    SQL way, allowing a right-side expression form such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE232]'
  prefs: []
  type: TYPE_PRE
- en: For the PostgreSQL-specific operators “contains”, “contained_by”, and “overlaps”,
    one should continue to use the [`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY") type directly, which provides all functionality
    of the [`ARRAY`](../core/type_basics.html#sqlalchemy.types.ARRAY "sqlalchemy.types.ARRAY")
    type as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`any_()`](../core/sqlelement.html#sqlalchemy.sql.expression.any_ "sqlalchemy.sql.expression.any_")
    and [`all_()`](../core/sqlelement.html#sqlalchemy.sql.expression.all_ "sqlalchemy.sql.expression.all_")
    operators are open-ended at the Core level, however their interpretation by backend
    databases is limited. On the PostgreSQL backend, the two operators **only accept
    array values**. Whereas on the MySQL backend, they **only accept subquery values**.
    On MySQL, one can use an expression such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE233]'
  prefs: []
  type: TYPE_PRE
- en: '[#3516](https://www.sqlalchemy.org/trac/ticket/3516)  ### New Function features,
    “WITHIN GROUP”, array_agg and set aggregate functions'
  prefs: []
  type: TYPE_NORMAL
- en: 'With the new [`ARRAY`](../core/type_basics.html#sqlalchemy.types.ARRAY "sqlalchemy.types.ARRAY")
    type we can also implement a pre-typed function for the `array_agg()` SQL function
    that returns an array, which is now available using [`array_agg`](../core/functions.html#sqlalchemy.sql.functions.array_agg
    "sqlalchemy.sql.functions.array_agg"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE234]'
  prefs: []
  type: TYPE_PRE
- en: 'A PostgreSQL element for an aggregate ORDER BY is also added via [`aggregate_order_by`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.aggregate_order_by
    "sqlalchemy.dialects.postgresql.aggregate_order_by"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE235]'
  prefs: []
  type: TYPE_PRE
- en: 'Producing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE236]'
  prefs: []
  type: TYPE_PRE
- en: 'The PG dialect itself also provides an [`array_agg()`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.array_agg
    "sqlalchemy.dialects.postgresql.array_agg") wrapper to ensure the [`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY") type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE237]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, functions like `percentile_cont()`, `percentile_disc()`, `rank()`,
    `dense_rank()` and others that require an ordering via `WITHIN GROUP (ORDER BY
    <expr>)` are now available via the [`FunctionElement.within_group()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.within_group
    "sqlalchemy.sql.functions.FunctionElement.within_group") modifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE238]'
  prefs: []
  type: TYPE_PRE
- en: 'The above statement would produce SQL similar to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE239]'
  prefs: []
  type: TYPE_PRE
- en: Placeholders with correct return types are now provided for these functions,
    and include [`percentile_cont`](../core/functions.html#sqlalchemy.sql.functions.percentile_cont
    "sqlalchemy.sql.functions.percentile_cont"), [`percentile_disc`](../core/functions.html#sqlalchemy.sql.functions.percentile_disc
    "sqlalchemy.sql.functions.percentile_disc"), [`rank`](../core/functions.html#sqlalchemy.sql.functions.rank
    "sqlalchemy.sql.functions.rank"), [`dense_rank`](../core/functions.html#sqlalchemy.sql.functions.dense_rank
    "sqlalchemy.sql.functions.dense_rank"), [`mode`](../core/functions.html#sqlalchemy.sql.functions.mode
    "sqlalchemy.sql.functions.mode"), [`percent_rank`](../core/functions.html#sqlalchemy.sql.functions.percent_rank
    "sqlalchemy.sql.functions.percent_rank"), and [`cume_dist`](../core/functions.html#sqlalchemy.sql.functions.cume_dist
    "sqlalchemy.sql.functions.cume_dist").
  prefs: []
  type: TYPE_NORMAL
- en: '[#3132](https://www.sqlalchemy.org/trac/ticket/3132) [#1370](https://www.sqlalchemy.org/trac/ticket/1370)  ###
    TypeDecorator now works with Enum, Boolean, “schema” types automatically'
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`SchemaType`](../core/type_basics.html#sqlalchemy.types.SchemaType "sqlalchemy.types.SchemaType")
    types include types such as [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum") and [`Boolean`](../core/type_basics.html#sqlalchemy.types.Boolean
    "sqlalchemy.types.Boolean") which, in addition to corresponding to a database
    type, also generate either a CHECK constraint or in the case of PostgreSQL ENUM
    a new CREATE TYPE statement, will now work automatically with [`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") recipes. Previously, a [`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") for an [`ENUM`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ENUM
    "sqlalchemy.dialects.postgresql.ENUM") had to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE240]'
  prefs: []
  type: TYPE_PRE
- en: 'The [`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") now propagates those additional events so it
    can be done like any other type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE241]'
  prefs: []
  type: TYPE_PRE
- en: '[#2919](https://www.sqlalchemy.org/trac/ticket/2919)  ### Multi-Tenancy Schema
    Translation for Table objects'
  prefs: []
  type: TYPE_NORMAL
- en: To support the use case of an application that uses the same set of [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects in many schemas, such as schema-per-user, a
    new execution option [`Connection.execution_options.schema_translate_map`](../core/connections.html#sqlalchemy.engine.Connection.execution_options.params.schema_translate_map
    "sqlalchemy.engine.Connection.execution_options") is added. Using this mapping,
    a set of [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    objects can be made on a per-connection basis to refer to any set of schemas instead
    of the [`Table.schema`](../core/metadata.html#sqlalchemy.schema.Table.params.schema
    "sqlalchemy.schema.Table") to which they were assigned. The translation works
    for DDL and SQL generation, as well as with the ORM.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if the `User` class were assigned the schema “per_user”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE242]'
  prefs: []
  type: TYPE_PRE
- en: 'On each request, the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") can be set up to refer to a different schema each time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE243]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Translation of Schema Names](../core/connections.html#schema-translating)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#2685](https://www.sqlalchemy.org/trac/ticket/2685)  ### “Friendly” stringification
    of Core SQL constructs without a dialect'
  prefs: []
  type: TYPE_NORMAL
- en: 'Calling `str()` on a Core SQL construct will now produce a string in more cases
    than before, supporting various SQL constructs not normally present in default
    SQL such as RETURNING, array indexes, and non-standard datatypes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE244]'
  prefs: []
  type: TYPE_PRE
- en: The `str()` function now calls upon an entirely separate dialect / compiler
    intended just for plain string printing without a specific dialect set up, so
    as more “just show me a string!” cases come up, these can be added to this dialect/compiler
    without impacting behaviors on real dialects.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Stringify of Query will consult the Session for the correct dialect](#change-3081)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#3631](https://www.sqlalchemy.org/trac/ticket/3631)  ### The type_coerce function
    is now a persistent SQL element'
  prefs: []
  type: TYPE_NORMAL
- en: The [`type_coerce()`](../core/sqlelement.html#sqlalchemy.sql.expression.type_coerce
    "sqlalchemy.sql.expression.type_coerce") function previously would return an object
    either of type [`BindParameter`](../core/sqlelement.html#sqlalchemy.sql.expression.BindParameter
    "sqlalchemy.sql.expression.BindParameter") or [`Label`](../core/sqlelement.html#sqlalchemy.sql.expression.Label
    "sqlalchemy.sql.expression.Label"), depending on the input. An effect this would
    have was that in the case where expression transformations were used, such as
    the conversion of an element from a [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") to a [`BindParameter`](../core/sqlelement.html#sqlalchemy.sql.expression.BindParameter
    "sqlalchemy.sql.expression.BindParameter") that’s critical to ORM-level lazy loading,
    the type coercion information would not be used since it would have been lost
    already.
  prefs: []
  type: TYPE_NORMAL
- en: To improve this behavior, the function now returns a persistent [`TypeCoerce`](../core/sqlelement.html#sqlalchemy.sql.expression.TypeCoerce
    "sqlalchemy.sql.expression.TypeCoerce") container around the given expression,
    which itself remains unaffected; this construct is evaluated explicitly by the
    SQL compiler. This allows for the coercion of the inner expression to be maintained
    no matter how the statement is modified, including if the contained element is
    replaced with a different one, as is common within the ORM’s lazy loading feature.
  prefs: []
  type: TYPE_NORMAL
- en: 'The test case illustrating the effect makes use of a heterogeneous primaryjoin
    condition in conjunction with custom types and lazy loading. Given a custom type
    that applies a CAST as a “bind expression”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE245]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, a mapping where we are equating a string “id” column on one table to
    an integer “id” column on the other:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE246]'
  prefs: []
  type: TYPE_PRE
- en: 'Above, in the [`relationship.primaryjoin`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.primaryjoin
    "sqlalchemy.orm.relationship") expression, we are using [`type_coerce()`](../core/sqlelement.html#sqlalchemy.sql.expression.type_coerce
    "sqlalchemy.sql.expression.type_coerce") to handle bound parameters passed via
    lazyloading as integers, since we already know these will come from our `StringAsInt`
    type which maintains the value as an integer in Python. We are then using [`cast()`](../core/sqlelement.html#sqlalchemy.sql.expression.cast
    "sqlalchemy.sql.expression.cast") so that as a SQL expression, the VARCHAR “id”
    column will be CAST to an integer for a regular non- converted join as with [`Query.join()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join") or [`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload"). That is, a joinedload of `.pets` looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE247]'
  prefs: []
  type: TYPE_PRE
- en: Without the CAST in the ON clause of the join, strongly-typed databases such
    as PostgreSQL will refuse to implicitly compare the integer and fail.
  prefs: []
  type: TYPE_NORMAL
- en: 'The lazyload case of `.pets` relies upon replacing the `Person.id` column at
    load time with a bound parameter, which receives a Python-loaded value. This replacement
    is specifically where the intent of our [`type_coerce()`](../core/sqlelement.html#sqlalchemy.sql.expression.type_coerce
    "sqlalchemy.sql.expression.type_coerce") function would be lost. Prior to the
    change, this lazy load comes out as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE248]'
  prefs: []
  type: TYPE_PRE
- en: Where above, we see that our in-Python value of `5` is CAST first to a VARCHAR,
    then back to an INTEGER in SQL; a double CAST which works, but is nevertheless
    not what we asked for.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the change, the [`type_coerce()`](../core/sqlelement.html#sqlalchemy.sql.expression.type_coerce
    "sqlalchemy.sql.expression.type_coerce") function maintains a wrapper even after
    the column is swapped out for a bound parameter, and the query now looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE249]'
  prefs: []
  type: TYPE_PRE
- en: Where our outer CAST that’s in our primaryjoin still takes effect, but the needless
    CAST that’s in part of the `StringAsInt` custom type is removed as intended by
    the [`type_coerce()`](../core/sqlelement.html#sqlalchemy.sql.expression.type_coerce
    "sqlalchemy.sql.expression.type_coerce") function.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3531](https://www.sqlalchemy.org/trac/ticket/3531)  ### Engines now invalidate
    connections, run error handlers for BaseException'
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 1.1: this change is a late add to the 1.1 series just prior
    to 1.1 final, and is not present in the 1.1 beta releases.'
  prefs: []
  type: TYPE_NORMAL
- en: The Python `BaseException` class is below that of `Exception` but is the identifiable
    base for system-level exceptions such as `KeyboardInterrupt`, `SystemExit`, and
    notably the `GreenletExit` exception that’s used by eventlet and gevent. This
    exception class is now intercepted by the exception- handling routines of [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection"), and includes handling by the `ConnectionEvents.handle_error()`
    event. The [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") is now **invalidated** by default in the case
    of a system level exception that is not a subclass of `Exception`, as it is assumed
    an operation was interrupted and the connection may be in an unusable state. The
    MySQL drivers are most targeted by this change however the change is across all
    DBAPIs.
  prefs: []
  type: TYPE_NORMAL
- en: Note that upon invalidation, the immediate DBAPI connection used by [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") is disposed, and the [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection"), if still being used subsequent to the exception
    raise, will use a new DBAPI connection for subsequent operations upon next use;
    however, the state of any transaction in progress is lost and the appropriate
    `.rollback()` method must be called if applicable before this re-use can proceed.
  prefs: []
  type: TYPE_NORMAL
- en: In order to identify this change, it was straightforward to demonstrate a pymysql
    or mysqlclient / MySQL-Python connection moving into a corrupted state when these
    exceptions occur in the middle of the connection doing its work; the connection
    would then be returned to the connection pool where subsequent uses would fail,
    or even before returning to the pool would cause secondary failures in context
    managers that call `.rollback()` upon the exception catch. The behavior here is
    expected to reduce the incidence of the MySQL error “commands out of sync”, as
    well as the `ResourceClosedError` which can occur when the MySQL driver fails
    to report `cursor.description` correctly, when running under greenlet conditions
    where greenlets are killed, or where `KeyboardInterrupt` exceptions are handled
    without exiting the program entirely.
  prefs: []
  type: TYPE_NORMAL
- en: The behavior is distinct from the usual auto-invalidation feature, in that it
    does not assume that the backend database itself has been shut down or restarted;
    it does not recycle the entire connection pool as is the case for usual DBAPI
    disconnect exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: 'This change should be a net improvement for all users with the exception of
    **any application that currently intercepts ``KeyboardInterrupt`` or ``GreenletExit``
    and wishes to continue working within the same transaction**. Such an operation
    is theoretically possible with other DBAPIs that do not appear to be impacted
    by `KeyboardInterrupt` such as psycopg2\. For these DBAPIs, the following workaround
    will disable the connection from being recycled for specific exceptions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE250]'
  prefs: []
  type: TYPE_PRE
- en: '[#3803](https://www.sqlalchemy.org/trac/ticket/3803)'
  prefs: []
  type: TYPE_NORMAL
- en: '### CTE Support for INSERT, UPDATE, DELETE'
  prefs: []
  type: TYPE_NORMAL
- en: One of the most widely requested features is support for common table expressions
    (CTE) that work with INSERT, UPDATE, DELETE, and is now implemented. An INSERT/UPDATE/DELETE
    can both draw from a WITH clause that’s stated at the top of the SQL, as well
    as can be used as a CTE itself in the context of a larger statement.
  prefs: []
  type: TYPE_NORMAL
- en: As part of this change, an INSERT from SELECT that includes a CTE will now render
    the CTE at the top of the entire statement, rather than nested in the SELECT statement
    as was the case in 1.0.
  prefs: []
  type: TYPE_NORMAL
- en: 'Below is an example that renders UPDATE, INSERT and SELECT all in one statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE251]'
  prefs: []
  type: TYPE_PRE
- en: '[#2551](https://www.sqlalchemy.org/trac/ticket/2551)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Support for RANGE and ROWS specification within window functions'
  prefs: []
  type: TYPE_NORMAL
- en: 'New [`over.range_`](../core/sqlelement.html#sqlalchemy.sql.expression.over.params.range_
    "sqlalchemy.sql.expression.over") and [`over.rows`](../core/sqlelement.html#sqlalchemy.sql.expression.over.params.rows
    "sqlalchemy.sql.expression.over") parameters allow RANGE and ROWS expressions
    for window functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE252]'
  prefs: []
  type: TYPE_PRE
- en: '[`over.range_`](../core/sqlelement.html#sqlalchemy.sql.expression.over.params.range_
    "sqlalchemy.sql.expression.over") and [`over.rows`](../core/sqlelement.html#sqlalchemy.sql.expression.over.params.rows
    "sqlalchemy.sql.expression.over") are specified as 2-tuples and indicate negative
    and positive values for specific ranges, 0 for “CURRENT ROW”, and None for UNBOUNDED.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Using Window Functions](../tutorial/data_select.html#tutorial-window-functions)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#3049](https://www.sqlalchemy.org/trac/ticket/3049)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Support for the SQL LATERAL keyword'
  prefs: []
  type: TYPE_NORMAL
- en: 'The LATERAL keyword is currently known to only be supported by PostgreSQL 9.3
    and greater, however as it is part of the SQL standard support for this keyword
    is added to Core. The implementation of [`Select.lateral()`](../core/selectable.html#sqlalchemy.sql.expression.Select.lateral
    "sqlalchemy.sql.expression.Select.lateral") employs special logic beyond just
    rendering the LATERAL keyword to allow for correlation of tables that are derived
    from the same FROM clause as the selectable, e.g. lateral correlation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE253]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[LATERAL correlation](../tutorial/data_select.html#tutorial-lateral-correlation)'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Lateral`](../core/selectable.html#sqlalchemy.sql.expression.Lateral "sqlalchemy.sql.expression.Lateral")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Select.lateral()`](../core/selectable.html#sqlalchemy.sql.expression.Select.lateral
    "sqlalchemy.sql.expression.Select.lateral")'
  prefs: []
  type: TYPE_NORMAL
- en: '[#2857](https://www.sqlalchemy.org/trac/ticket/2857)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Support for TABLESAMPLE'
  prefs: []
  type: TYPE_NORMAL
- en: 'The SQL standard TABLESAMPLE can be rendered using the [`FromClause.tablesample()`](../core/selectable.html#sqlalchemy.sql.expression.FromClause.tablesample
    "sqlalchemy.sql.expression.FromClause.tablesample") method, which returns a [`TableSample`](../core/selectable.html#sqlalchemy.sql.expression.TableSample
    "sqlalchemy.sql.expression.TableSample") construct similar to an alias:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE254]'
  prefs: []
  type: TYPE_PRE
- en: 'Assuming `people` with a column `people_id`, the above statement would render
    as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE255]'
  prefs: []
  type: TYPE_PRE
- en: '[#3718](https://www.sqlalchemy.org/trac/ticket/3718)'
  prefs: []
  type: TYPE_NORMAL
- en: '### The `.autoincrement` directive is no longer implicitly enabled for a composite
    primary key column'
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy has always had the convenience feature of enabling the backend database’s
    “autoincrement” feature for a single-column integer primary key; by “autoincrement”
    we mean that the database column will include whatever DDL directives the database
    provides in order to indicate an auto-incrementing integer identifier, such as
    the SERIAL keyword on PostgreSQL or AUTO_INCREMENT on MySQL, and additionally
    that the dialect will receive these generated values from the execution of a [`Table.insert()`](../core/metadata.html#sqlalchemy.schema.Table.insert
    "sqlalchemy.schema.Table.insert") construct using techniques appropriate to that
    backend.
  prefs: []
  type: TYPE_NORMAL
- en: 'What’s changed is that this feature no longer turns on automatically for a
    *composite* primary key; previously, a table definition such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE256]'
  prefs: []
  type: TYPE_PRE
- en: 'Would have “autoincrement” semantics applied to the `''x''` column, only because
    it’s first in the list of primary key columns. In order to disable this, one would
    have to turn off `autoincrement` on all columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE257]'
  prefs: []
  type: TYPE_PRE
- en: 'With the new behavior, the composite primary key will not have autoincrement
    semantics unless a column is marked explicitly with `autoincrement=True`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE258]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to anticipate some potential backwards-incompatible scenarios, the
    [`Table.insert()`](../core/metadata.html#sqlalchemy.schema.Table.insert "sqlalchemy.schema.Table.insert")
    construct will perform more thorough checks for missing primary key values on
    composite primary key columns that don’t have autoincrement set up; given a table
    such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE259]'
  prefs: []
  type: TYPE_PRE
- en: 'An INSERT emitted with no values for this table will produce this warning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE260]'
  prefs: []
  type: TYPE_PRE
- en: 'For a column that is receiving primary key values from a server-side default
    or something less common such as a trigger, the presence of a value generator
    can be indicated using [`FetchedValue`](../core/defaults.html#sqlalchemy.schema.FetchedValue
    "sqlalchemy.schema.FetchedValue"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE261]'
  prefs: []
  type: TYPE_PRE
- en: 'For the very unlikely case where a composite primary key is actually intended
    to store NULL in one or more of its columns (only supported on SQLite and MySQL),
    specify the column with `nullable=True`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE262]'
  prefs: []
  type: TYPE_PRE
- en: In a related change, the `autoincrement` flag may be set to True on a column
    that has a client-side or server-side default. This typically will not have much
    impact on the behavior of the column during an INSERT.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[No more generation of an implicit KEY for composite primary key w/ AUTO_INCREMENT](#change-mysql-3216)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#3216](https://www.sqlalchemy.org/trac/ticket/3216)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Support for IS DISTINCT FROM and IS NOT DISTINCT FROM'
  prefs: []
  type: TYPE_NORMAL
- en: 'New operators [`ColumnOperators.is_distinct_from()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.is_distinct_from
    "sqlalchemy.sql.expression.ColumnOperators.is_distinct_from") and [`ColumnOperators.isnot_distinct_from()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.isnot_distinct_from
    "sqlalchemy.sql.expression.ColumnOperators.isnot_distinct_from") allow the IS
    DISTINCT FROM and IS NOT DISTINCT FROM sql operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE263]'
  prefs: []
  type: TYPE_PRE
- en: 'Handling is provided for NULL, True and False:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE264]'
  prefs: []
  type: TYPE_PRE
- en: 'For SQLite, which doesn’t have this operator, “IS” / “IS NOT” is rendered,
    which on SQLite works for NULL unlike other backends:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE265]'
  prefs: []
  type: TYPE_PRE
- en: '### Core and ORM support for FULL OUTER JOIN'
  prefs: []
  type: TYPE_NORMAL
- en: 'The new flag [`FromClause.outerjoin.full`](../core/selectable.html#sqlalchemy.sql.expression.FromClause.outerjoin.params.full
    "sqlalchemy.sql.expression.FromClause.outerjoin"), available at the Core and ORM
    level, instructs the compiler to render `FULL OUTER JOIN` where it would normally
    render `LEFT OUTER JOIN`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE266]'
  prefs: []
  type: TYPE_PRE
- en: 'The flag also works at the ORM level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE267]'
  prefs: []
  type: TYPE_PRE
- en: '[#1957](https://www.sqlalchemy.org/trac/ticket/1957)'
  prefs: []
  type: TYPE_NORMAL
- en: '### ResultSet column matching enhancements; positional column setup for textual
    SQL'
  prefs: []
  type: TYPE_NORMAL
- en: A series of improvements were made to the `ResultProxy` system in the 1.0 series
    as part of [#918](https://www.sqlalchemy.org/trac/ticket/918), which reorganizes
    the internals to match cursor-bound result columns with table/ORM metadata positionally,
    rather than by matching names, for compiled SQL constructs that contain full information
    about the result rows to be returned. This allows a dramatic savings on Python
    overhead as well as much greater accuracy in linking ORM and Core SQL expressions
    to result rows. In 1.1, this reorganization has been taken further internally,
    and also has been made available to pure-text SQL constructs via the use of the
    recently added [`TextClause.columns()`](../core/sqlelement.html#sqlalchemy.sql.expression.TextClause.columns
    "sqlalchemy.sql.expression.TextClause.columns") method.
  prefs: []
  type: TYPE_NORMAL
- en: TextAsFrom.columns() now works positionally
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The [`TextClause.columns()`](../core/sqlelement.html#sqlalchemy.sql.expression.TextClause.columns
    "sqlalchemy.sql.expression.TextClause.columns") method, added in 0.9, accepts
    column-based arguments positionally; in 1.1, when all columns are passed positionally,
    the correlation of these columns to the ultimate result set is also performed
    positionally. The key advantage here is that textual SQL can now be linked to
    an ORM- level result set without the need to deal with ambiguous or duplicate
    column names, or with having to match labeling schemes to ORM-level labeling schemes.
    All that’s needed now is the same ordering of columns within the textual SQL and
    the column arguments passed to [`TextClause.columns()`](../core/sqlelement.html#sqlalchemy.sql.expression.TextClause.columns
    "sqlalchemy.sql.expression.TextClause.columns"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE268]'
  prefs: []
  type: TYPE_PRE
- en: Above, the textual SQL contains the column “id” three times, which would normally
    be ambiguous. Using the new feature, we can apply the mapped columns from the
    `User` and `Address` class directly, even linking the `Address.user_id` column
    to the `users.id` column in textual SQL for fun, and the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object will receive rows that are correctly targetable
    as needed, including for an eager load.
  prefs: []
  type: TYPE_NORMAL
- en: This change is **backwards incompatible** with code that passes the columns
    to the method with a different ordering than is present in the textual statement.
    It is hoped that this impact will be low due to the fact that this method has
    always been documented illustrating the columns being passed in the same order
    as that of the textual SQL statement, as would seem intuitive, even though the
    internals weren’t checking for this. The method itself was only added as of 0.9
    in any case and may not yet have widespread use. Notes on exactly how to handle
    this behavioral change for applications using it are at [TextClause.columns()
    will match columns positionally, not by name, when passed positionally](#behavior-change-3501).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Selecting with Textual Column Expressions](../tutorial/data_select.html#tutorial-select-arbitrary-text)'
  prefs: []
  type: TYPE_NORMAL
- en: '[TextClause.columns() will match columns positionally, not by name, when passed
    positionally](#behavior-change-3501) - backwards compatibility remarks'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Positional matching is trusted over name-based matching for Core/ORM SQL constructs
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Another aspect of this change is that the rules for matching columns have also
    been modified to rely upon “positional” matching more fully for compiled SQL constructs
    as well. Given a statement like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE269]'
  prefs: []
  type: TYPE_PRE
- en: 'The above statement will compile to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE270]'
  prefs: []
  type: TYPE_PRE
- en: 'In 1.0, the above statement when executed would be matched to its original
    compiled construct using positional matching, however because the statement contains
    the `''user_id''` label duplicated, the “ambiguous column” rule would still get
    involved and prevent the columns from being fetched from a row. As of 1.1, the
    “ambiguous column” rule does not affect an exact match from a column construct
    to the SQL column, which is what the ORM uses to fetch columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE271]'
  prefs: []
  type: TYPE_PRE
- en: Much less likely to get an “ambiguous column” error message
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As part of this change, the wording of the error message `Ambiguous column name
    '<name>' in result set! try 'use_labels' option on select statement.` has been
    dialed back; as this message should now be extremely rare when using the ORM or
    Core compiled SQL constructs, it merely states `Ambiguous column name '<name>'
    in result set column descriptions`, and only when a result column is retrieved
    using the string name that is actually ambiguous, e.g. `row['user_id']` in the
    above example. It also now refers to the actual ambiguous name from the rendered
    SQL statement itself, rather than indicating the key or name that was local to
    the construct being used for the fetch.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3501](https://www.sqlalchemy.org/trac/ticket/3501)'
  prefs: []
  type: TYPE_NORMAL
- en: TextAsFrom.columns() now works positionally
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The [`TextClause.columns()`](../core/sqlelement.html#sqlalchemy.sql.expression.TextClause.columns
    "sqlalchemy.sql.expression.TextClause.columns") method, added in 0.9, accepts
    column-based arguments positionally; in 1.1, when all columns are passed positionally,
    the correlation of these columns to the ultimate result set is also performed
    positionally. The key advantage here is that textual SQL can now be linked to
    an ORM- level result set without the need to deal with ambiguous or duplicate
    column names, or with having to match labeling schemes to ORM-level labeling schemes.
    All that’s needed now is the same ordering of columns within the textual SQL and
    the column arguments passed to [`TextClause.columns()`](../core/sqlelement.html#sqlalchemy.sql.expression.TextClause.columns
    "sqlalchemy.sql.expression.TextClause.columns"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE272]'
  prefs: []
  type: TYPE_PRE
- en: Above, the textual SQL contains the column “id” three times, which would normally
    be ambiguous. Using the new feature, we can apply the mapped columns from the
    `User` and `Address` class directly, even linking the `Address.user_id` column
    to the `users.id` column in textual SQL for fun, and the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object will receive rows that are correctly targetable
    as needed, including for an eager load.
  prefs: []
  type: TYPE_NORMAL
- en: This change is **backwards incompatible** with code that passes the columns
    to the method with a different ordering than is present in the textual statement.
    It is hoped that this impact will be low due to the fact that this method has
    always been documented illustrating the columns being passed in the same order
    as that of the textual SQL statement, as would seem intuitive, even though the
    internals weren’t checking for this. The method itself was only added as of 0.9
    in any case and may not yet have widespread use. Notes on exactly how to handle
    this behavioral change for applications using it are at [TextClause.columns()
    will match columns positionally, not by name, when passed positionally](#behavior-change-3501).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Selecting with Textual Column Expressions](../tutorial/data_select.html#tutorial-select-arbitrary-text)'
  prefs: []
  type: TYPE_NORMAL
- en: '[TextClause.columns() will match columns positionally, not by name, when passed
    positionally](#behavior-change-3501) - backwards compatibility remarks'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Positional matching is trusted over name-based matching for Core/ORM SQL constructs
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Another aspect of this change is that the rules for matching columns have also
    been modified to rely upon “positional” matching more fully for compiled SQL constructs
    as well. Given a statement like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE273]'
  prefs: []
  type: TYPE_PRE
- en: 'The above statement will compile to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE274]'
  prefs: []
  type: TYPE_PRE
- en: 'In 1.0, the above statement when executed would be matched to its original
    compiled construct using positional matching, however because the statement contains
    the `''user_id''` label duplicated, the “ambiguous column” rule would still get
    involved and prevent the columns from being fetched from a row. As of 1.1, the
    “ambiguous column” rule does not affect an exact match from a column construct
    to the SQL column, which is what the ORM uses to fetch columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE275]'
  prefs: []
  type: TYPE_PRE
- en: Much less likely to get an “ambiguous column” error message
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As part of this change, the wording of the error message `Ambiguous column name
    '<name>' in result set! try 'use_labels' option on select statement.` has been
    dialed back; as this message should now be extremely rare when using the ORM or
    Core compiled SQL constructs, it merely states `Ambiguous column name '<name>'
    in result set column descriptions`, and only when a result column is retrieved
    using the string name that is actually ambiguous, e.g. `row['user_id']` in the
    above example. It also now refers to the actual ambiguous name from the rendered
    SQL statement itself, rather than indicating the key or name that was local to
    the construct being used for the fetch.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3501](https://www.sqlalchemy.org/trac/ticket/3501)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Support for Python’s native `enum` type and compatible forms'
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum "sqlalchemy.types.Enum")
    type can now be constructed using any PEP-435 compliant enumerated type. When
    using this mode, input values and return values are the actual enumerated objects,
    not the string/integer/etc values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE276]'
  prefs: []
  type: TYPE_PRE
- en: The `Enum.enums` collection is now a list instead of a tuple
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As part of the changes to [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum"), the `Enum.enums` collection of elements is now a list
    instead of a tuple. This because lists are appropriate for variable length sequences
    of homogeneous items where the position of the element is not semantically significant.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3292](https://www.sqlalchemy.org/trac/ticket/3292)'
  prefs: []
  type: TYPE_NORMAL
- en: The `Enum.enums` collection is now a list instead of a tuple
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As part of the changes to [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum"), the `Enum.enums` collection of elements is now a list
    instead of a tuple. This because lists are appropriate for variable length sequences
    of homogeneous items where the position of the element is not semantically significant.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3292](https://www.sqlalchemy.org/trac/ticket/3292)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Negative integer indexes accommodated by Core result rows'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `RowProxy` object now accommodates single negative integer indexes like
    a regular Python sequence, both in the pure Python and C-extension version. Previously,
    negative values would only work in slices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE277]'
  prefs: []
  type: TYPE_PRE
- en: '### The `Enum` type now does in-Python validation of values'
  prefs: []
  type: TYPE_NORMAL
- en: 'To accommodate for Python native enumerated objects, as well as for edge cases
    such as that of where a non-native ENUM type is used within an ARRAY and a CHECK
    constraint is infeasible, the [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum") datatype now adds in-Python validation of input values
    when the [`Enum.validate_strings`](../core/type_basics.html#sqlalchemy.types.Enum.params.validate_strings
    "sqlalchemy.types.Enum") flag is used (1.1.0b2):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE278]'
  prefs: []
  type: TYPE_PRE
- en: This validation is turned off by default as there are already use cases identified
    where users don’t want such validation (such as string comparisons). For non-string
    types, it necessarily takes place in all cases. The check also occurs unconditionally
    on the result-handling side as well, when values coming from the database are
    returned.
  prefs: []
  type: TYPE_NORMAL
- en: This validation is in addition to the existing behavior of creating a CHECK
    constraint when a non-native enumerated type is used. The creation of this CHECK
    constraint can now be disabled using the new [`Enum.create_constraint`](../core/type_basics.html#sqlalchemy.types.Enum.params.create_constraint
    "sqlalchemy.types.Enum") flag.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3095](https://www.sqlalchemy.org/trac/ticket/3095)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Non-native boolean integer values coerced to zero/one/None in all cases'
  prefs: []
  type: TYPE_NORMAL
- en: The [`Boolean`](../core/type_basics.html#sqlalchemy.types.Boolean "sqlalchemy.types.Boolean")
    datatype coerces Python booleans to integer values for backends that don’t have
    a native boolean type, such as SQLite and MySQL. On these backends, a CHECK constraint
    is normally set up which ensures the values in the database are in fact one of
    these two values. However, MySQL ignores CHECK constraints, the constraint is
    optional, and an existing database might not have this constraint. The [`Boolean`](../core/type_basics.html#sqlalchemy.types.Boolean
    "sqlalchemy.types.Boolean") datatype has been repaired such that an incoming Python-side
    value that is already an integer value is coerced to zero or one, not just passed
    as-is; additionally, the C-extension version of the int-to-boolean processor for
    results now uses the same Python boolean interpretation of the value, rather than
    asserting an exact one or zero value. This is now consistent with the pure-Python
    int-to-boolean processor and is more forgiving of existing data already within
    the database. Values of None/NULL are as before retained as None/NULL.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: this change had an unintended side effect that the interpretation of non- integer
    values, such as strings, also changed in behavior such that the string value `"0"`
    would be interpreted as “true”, but only on backends that don’t have a native
    boolean datatype - on “native boolean” backends like PostgreSQL, the string value
    `"0"` is passed directly to the driver and is interpreted as “false”. This is
    an inconsistency that did not occur with the previous implementation. It should
    be noted that passing strings or any other value outside of `None`, `True`, `False`,
    `1`, `0` to the [`Boolean`](../core/type_basics.html#sqlalchemy.types.Boolean
    "sqlalchemy.types.Boolean") datatype is **not supported** and version 1.2 will
    raise an error for this scenario (or possibly just emit a warning, TBD). See also
    [#4102](https://www.sqlalchemy.org/trac/ticket/4102).
  prefs: []
  type: TYPE_NORMAL
- en: '[#3730](https://www.sqlalchemy.org/trac/ticket/3730)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Large parameter and row values are now truncated in logging and exception
    displays'
  prefs: []
  type: TYPE_NORMAL
- en: 'A large value present as a bound parameter for a SQL statement, as well as
    a large value present in a result row, will now be truncated during display within
    logging, exception reporting, as well as `repr()` of the row itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE279]'
  prefs: []
  type: TYPE_PRE
- en: '[#2837](https://www.sqlalchemy.org/trac/ticket/2837)'
  prefs: []
  type: TYPE_NORMAL
- en: '### JSON support added to Core'
  prefs: []
  type: TYPE_NORMAL
- en: As MySQL now has a JSON datatype in addition to the PostgreSQL JSON datatype,
    the core now gains a [`sqlalchemy.types.JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON") datatype that is the basis for both of these. Using this
    type allows access to the “getitem” operator as well as the “getpath” operator
    in a way that is agnostic across PostgreSQL and MySQL.
  prefs: []
  type: TYPE_NORMAL
- en: The new datatype also has a series of improvements to the handling of NULL values
    as well as expression handling.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[MySQL JSON Support](#change-3547)'
  prefs: []
  type: TYPE_NORMAL
- en: '[`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON "sqlalchemy.dialects.postgresql.JSON")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`JSON`](../dialects/mysql.html#sqlalchemy.dialects.mysql.JSON "sqlalchemy.dialects.mysql.JSON")'
  prefs: []
  type: TYPE_NORMAL
- en: '[#3619](https://www.sqlalchemy.org/trac/ticket/3619)'
  prefs: []
  type: TYPE_NORMAL
- en: '#### JSON “null” is inserted as expected with ORM operations, omitted when
    not present'
  prefs: []
  type: TYPE_NORMAL
- en: The [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON")
    type and its descendant types [`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON
    "sqlalchemy.dialects.postgresql.JSON") and [`JSON`](../dialects/mysql.html#sqlalchemy.dialects.mysql.JSON
    "sqlalchemy.dialects.mysql.JSON") have a flag [`JSON.none_as_null`](../core/type_basics.html#sqlalchemy.types.JSON.params.none_as_null
    "sqlalchemy.types.JSON") which when set to True indicates that the Python value
    `None` should translate into a SQL NULL rather than a JSON NULL value. This flag
    defaults to False, which means that the Python value `None` should result in a
    JSON NULL value.
  prefs: []
  type: TYPE_NORMAL
- en: 'This logic would fail, and is now corrected, in the following circumstances:'
  prefs: []
  type: TYPE_NORMAL
- en: '1\. When the column also contained a default or server_default value, a positive
    value of `None` on the mapped attribute that expects to persist JSON “null” would
    still result in the column-level default being triggered, replacing the `None`
    value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE280]'
  prefs: []
  type: TYPE_PRE
- en: '2\. When the column *did not* contain a default or server_default value, a
    missing value on a JSON column configured with none_as_null=False would still
    render JSON NULL rather than falling back to not inserting any value, behaving
    inconsistently vs. all other datatypes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE281]'
  prefs: []
  type: TYPE_PRE
- en: This is a behavioral change that is backwards incompatible for an application
    that was relying upon this to default a missing value as JSON null. This essentially
    establishes that a **missing value is distinguished from a present value of None**.
    See [JSON Columns will not insert JSON NULL if no value is supplied and no default
    is established](#behavior-change-3514) for further detail.
  prefs: []
  type: TYPE_NORMAL
- en: '3\. When the [`Session.bulk_insert_mappings()`](../orm/session_api.html#sqlalchemy.orm.Session.bulk_insert_mappings
    "sqlalchemy.orm.Session.bulk_insert_mappings") method were used, `None` would
    be ignored in all cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE282]'
  prefs: []
  type: TYPE_PRE
- en: The [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON")
    type now implements the [`TypeEngine.should_evaluate_none`](../core/type_api.html#sqlalchemy.types.TypeEngine.should_evaluate_none
    "sqlalchemy.types.TypeEngine.should_evaluate_none") flag, indicating that `None`
    should not be ignored here; it is configured automatically based on the value
    of [`JSON.none_as_null`](../core/type_basics.html#sqlalchemy.types.JSON.params.none_as_null
    "sqlalchemy.types.JSON"). Thanks to [#3061](https://www.sqlalchemy.org/trac/ticket/3061),
    we can differentiate when the value `None` is actively set by the user versus
    when it was never set at all.
  prefs: []
  type: TYPE_NORMAL
- en: The feature applies as well to the new base [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON") type and its descendant types.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3514](https://www.sqlalchemy.org/trac/ticket/3514)  #### New JSON.NULL Constant
    Added'
  prefs: []
  type: TYPE_NORMAL
- en: 'To ensure that an application can always have full control at the value level
    of whether a [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON"),
    [`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON "sqlalchemy.dialects.postgresql.JSON"),
    [`JSON`](../dialects/mysql.html#sqlalchemy.dialects.mysql.JSON "sqlalchemy.dialects.mysql.JSON"),
    or [`JSONB`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSONB
    "sqlalchemy.dialects.postgresql.JSONB") column should receive a SQL NULL or JSON
    `"null"` value, the constant [`JSON.NULL`](../core/type_basics.html#sqlalchemy.types.JSON.NULL
    "sqlalchemy.types.JSON.NULL") has been added, which in conjunction with [`null()`](../core/sqlelement.html#sqlalchemy.sql.expression.null
    "sqlalchemy.sql.expression.null") can be used to determine fully between SQL NULL
    and JSON `"null"`, regardless of what [`JSON.none_as_null`](../core/type_basics.html#sqlalchemy.types.JSON.params.none_as_null
    "sqlalchemy.types.JSON") is set to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE283]'
  prefs: []
  type: TYPE_PRE
- en: The feature applies as well to the new base [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON") type and its descendant types.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3514](https://www.sqlalchemy.org/trac/ticket/3514)  #### JSON “null” is inserted
    as expected with ORM operations, omitted when not present'
  prefs: []
  type: TYPE_NORMAL
- en: The [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON")
    type and its descendant types [`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON
    "sqlalchemy.dialects.postgresql.JSON") and [`JSON`](../dialects/mysql.html#sqlalchemy.dialects.mysql.JSON
    "sqlalchemy.dialects.mysql.JSON") have a flag [`JSON.none_as_null`](../core/type_basics.html#sqlalchemy.types.JSON.params.none_as_null
    "sqlalchemy.types.JSON") which when set to True indicates that the Python value
    `None` should translate into a SQL NULL rather than a JSON NULL value. This flag
    defaults to False, which means that the Python value `None` should result in a
    JSON NULL value.
  prefs: []
  type: TYPE_NORMAL
- en: 'This logic would fail, and is now corrected, in the following circumstances:'
  prefs: []
  type: TYPE_NORMAL
- en: '1\. When the column also contained a default or server_default value, a positive
    value of `None` on the mapped attribute that expects to persist JSON “null” would
    still result in the column-level default being triggered, replacing the `None`
    value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE284]'
  prefs: []
  type: TYPE_PRE
- en: '2\. When the column *did not* contain a default or server_default value, a
    missing value on a JSON column configured with none_as_null=False would still
    render JSON NULL rather than falling back to not inserting any value, behaving
    inconsistently vs. all other datatypes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE285]'
  prefs: []
  type: TYPE_PRE
- en: This is a behavioral change that is backwards incompatible for an application
    that was relying upon this to default a missing value as JSON null. This essentially
    establishes that a **missing value is distinguished from a present value of None**.
    See [JSON Columns will not insert JSON NULL if no value is supplied and no default
    is established](#behavior-change-3514) for further detail.
  prefs: []
  type: TYPE_NORMAL
- en: '3\. When the [`Session.bulk_insert_mappings()`](../orm/session_api.html#sqlalchemy.orm.Session.bulk_insert_mappings
    "sqlalchemy.orm.Session.bulk_insert_mappings") method were used, `None` would
    be ignored in all cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE286]'
  prefs: []
  type: TYPE_PRE
- en: The [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON")
    type now implements the [`TypeEngine.should_evaluate_none`](../core/type_api.html#sqlalchemy.types.TypeEngine.should_evaluate_none
    "sqlalchemy.types.TypeEngine.should_evaluate_none") flag, indicating that `None`
    should not be ignored here; it is configured automatically based on the value
    of [`JSON.none_as_null`](../core/type_basics.html#sqlalchemy.types.JSON.params.none_as_null
    "sqlalchemy.types.JSON"). Thanks to [#3061](https://www.sqlalchemy.org/trac/ticket/3061),
    we can differentiate when the value `None` is actively set by the user versus
    when it was never set at all.
  prefs: []
  type: TYPE_NORMAL
- en: The feature applies as well to the new base [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON") type and its descendant types.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3514](https://www.sqlalchemy.org/trac/ticket/3514)'
  prefs: []
  type: TYPE_NORMAL
- en: '#### New JSON.NULL Constant Added'
  prefs: []
  type: TYPE_NORMAL
- en: 'To ensure that an application can always have full control at the value level
    of whether a [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON"),
    [`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON "sqlalchemy.dialects.postgresql.JSON"),
    [`JSON`](../dialects/mysql.html#sqlalchemy.dialects.mysql.JSON "sqlalchemy.dialects.mysql.JSON"),
    or [`JSONB`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSONB
    "sqlalchemy.dialects.postgresql.JSONB") column should receive a SQL NULL or JSON
    `"null"` value, the constant [`JSON.NULL`](../core/type_basics.html#sqlalchemy.types.JSON.NULL
    "sqlalchemy.types.JSON.NULL") has been added, which in conjunction with [`null()`](../core/sqlelement.html#sqlalchemy.sql.expression.null
    "sqlalchemy.sql.expression.null") can be used to determine fully between SQL NULL
    and JSON `"null"`, regardless of what [`JSON.none_as_null`](../core/type_basics.html#sqlalchemy.types.JSON.params.none_as_null
    "sqlalchemy.types.JSON") is set to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE287]'
  prefs: []
  type: TYPE_PRE
- en: The feature applies as well to the new base [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON") type and its descendant types.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3514](https://www.sqlalchemy.org/trac/ticket/3514)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Array support added to Core; new ANY and ALL operators'
  prefs: []
  type: TYPE_NORMAL
- en: Along with the enhancements made to the PostgreSQL [`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY") type described in [Correct SQL Types are
    Established from Indexed Access of ARRAY, JSON, HSTORE](#change-3503), the base
    class of [`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY") itself has been moved to Core in a new
    class [`ARRAY`](../core/type_basics.html#sqlalchemy.types.ARRAY "sqlalchemy.types.ARRAY").
  prefs: []
  type: TYPE_NORMAL
- en: 'Arrays are part of the SQL standard, as are several array-oriented functions
    such as `array_agg()` and `unnest()`. In support of these constructs for not just
    PostgreSQL but also potentially for other array-capable backends in the future
    such as DB2, the majority of array logic for SQL expressions is now in Core. The
    [`ARRAY`](../core/type_basics.html#sqlalchemy.types.ARRAY "sqlalchemy.types.ARRAY")
    type still **only works on PostgreSQL**, however it can be used directly, supporting
    special array use cases such as indexed access, as well as support for the ANY
    and ALL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE288]'
  prefs: []
  type: TYPE_PRE
- en: 'In support of ANY and ALL, the [`ARRAY`](../core/type_basics.html#sqlalchemy.types.ARRAY
    "sqlalchemy.types.ARRAY") type retains the same [`Comparator.any()`](../core/type_basics.html#sqlalchemy.types.ARRAY.Comparator.any
    "sqlalchemy.types.ARRAY.Comparator.any") and [`Comparator.all()`](../core/type_basics.html#sqlalchemy.types.ARRAY.Comparator.all
    "sqlalchemy.types.ARRAY.Comparator.all") methods from the PostgreSQL type, but
    also exports these operations to new standalone operator functions [`any_()`](../core/sqlelement.html#sqlalchemy.sql.expression.any_
    "sqlalchemy.sql.expression.any_") and [`all_()`](../core/sqlelement.html#sqlalchemy.sql.expression.all_
    "sqlalchemy.sql.expression.all_"). These two functions work in more of the traditional
    SQL way, allowing a right-side expression form such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE289]'
  prefs: []
  type: TYPE_PRE
- en: For the PostgreSQL-specific operators “contains”, “contained_by”, and “overlaps”,
    one should continue to use the [`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY") type directly, which provides all functionality
    of the [`ARRAY`](../core/type_basics.html#sqlalchemy.types.ARRAY "sqlalchemy.types.ARRAY")
    type as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`any_()`](../core/sqlelement.html#sqlalchemy.sql.expression.any_ "sqlalchemy.sql.expression.any_")
    and [`all_()`](../core/sqlelement.html#sqlalchemy.sql.expression.all_ "sqlalchemy.sql.expression.all_")
    operators are open-ended at the Core level, however their interpretation by backend
    databases is limited. On the PostgreSQL backend, the two operators **only accept
    array values**. Whereas on the MySQL backend, they **only accept subquery values**.
    On MySQL, one can use an expression such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE290]'
  prefs: []
  type: TYPE_PRE
- en: '[#3516](https://www.sqlalchemy.org/trac/ticket/3516)'
  prefs: []
  type: TYPE_NORMAL
- en: '### New Function features, “WITHIN GROUP”, array_agg and set aggregate functions'
  prefs: []
  type: TYPE_NORMAL
- en: 'With the new [`ARRAY`](../core/type_basics.html#sqlalchemy.types.ARRAY "sqlalchemy.types.ARRAY")
    type we can also implement a pre-typed function for the `array_agg()` SQL function
    that returns an array, which is now available using [`array_agg`](../core/functions.html#sqlalchemy.sql.functions.array_agg
    "sqlalchemy.sql.functions.array_agg"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE291]'
  prefs: []
  type: TYPE_PRE
- en: 'A PostgreSQL element for an aggregate ORDER BY is also added via [`aggregate_order_by`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.aggregate_order_by
    "sqlalchemy.dialects.postgresql.aggregate_order_by"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE292]'
  prefs: []
  type: TYPE_PRE
- en: 'Producing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE293]'
  prefs: []
  type: TYPE_PRE
- en: 'The PG dialect itself also provides an [`array_agg()`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.array_agg
    "sqlalchemy.dialects.postgresql.array_agg") wrapper to ensure the [`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY") type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE294]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, functions like `percentile_cont()`, `percentile_disc()`, `rank()`,
    `dense_rank()` and others that require an ordering via `WITHIN GROUP (ORDER BY
    <expr>)` are now available via the [`FunctionElement.within_group()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.within_group
    "sqlalchemy.sql.functions.FunctionElement.within_group") modifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE295]'
  prefs: []
  type: TYPE_PRE
- en: 'The above statement would produce SQL similar to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE296]'
  prefs: []
  type: TYPE_PRE
- en: Placeholders with correct return types are now provided for these functions,
    and include [`percentile_cont`](../core/functions.html#sqlalchemy.sql.functions.percentile_cont
    "sqlalchemy.sql.functions.percentile_cont"), [`percentile_disc`](../core/functions.html#sqlalchemy.sql.functions.percentile_disc
    "sqlalchemy.sql.functions.percentile_disc"), [`rank`](../core/functions.html#sqlalchemy.sql.functions.rank
    "sqlalchemy.sql.functions.rank"), [`dense_rank`](../core/functions.html#sqlalchemy.sql.functions.dense_rank
    "sqlalchemy.sql.functions.dense_rank"), [`mode`](../core/functions.html#sqlalchemy.sql.functions.mode
    "sqlalchemy.sql.functions.mode"), [`percent_rank`](../core/functions.html#sqlalchemy.sql.functions.percent_rank
    "sqlalchemy.sql.functions.percent_rank"), and [`cume_dist`](../core/functions.html#sqlalchemy.sql.functions.cume_dist
    "sqlalchemy.sql.functions.cume_dist").
  prefs: []
  type: TYPE_NORMAL
- en: '[#3132](https://www.sqlalchemy.org/trac/ticket/3132) [#1370](https://www.sqlalchemy.org/trac/ticket/1370)'
  prefs: []
  type: TYPE_NORMAL
- en: '### TypeDecorator now works with Enum, Boolean, “schema” types automatically'
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`SchemaType`](../core/type_basics.html#sqlalchemy.types.SchemaType "sqlalchemy.types.SchemaType")
    types include types such as [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum") and [`Boolean`](../core/type_basics.html#sqlalchemy.types.Boolean
    "sqlalchemy.types.Boolean") which, in addition to corresponding to a database
    type, also generate either a CHECK constraint or in the case of PostgreSQL ENUM
    a new CREATE TYPE statement, will now work automatically with [`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") recipes. Previously, a [`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") for an [`ENUM`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ENUM
    "sqlalchemy.dialects.postgresql.ENUM") had to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE297]'
  prefs: []
  type: TYPE_PRE
- en: 'The [`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") now propagates those additional events so it
    can be done like any other type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE298]'
  prefs: []
  type: TYPE_PRE
- en: '[#2919](https://www.sqlalchemy.org/trac/ticket/2919)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Multi-Tenancy Schema Translation for Table objects'
  prefs: []
  type: TYPE_NORMAL
- en: To support the use case of an application that uses the same set of [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects in many schemas, such as schema-per-user, a
    new execution option [`Connection.execution_options.schema_translate_map`](../core/connections.html#sqlalchemy.engine.Connection.execution_options.params.schema_translate_map
    "sqlalchemy.engine.Connection.execution_options") is added. Using this mapping,
    a set of [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    objects can be made on a per-connection basis to refer to any set of schemas instead
    of the [`Table.schema`](../core/metadata.html#sqlalchemy.schema.Table.params.schema
    "sqlalchemy.schema.Table") to which they were assigned. The translation works
    for DDL and SQL generation, as well as with the ORM.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if the `User` class were assigned the schema “per_user”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE299]'
  prefs: []
  type: TYPE_PRE
- en: 'On each request, the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") can be set up to refer to a different schema each time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE300]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Translation of Schema Names](../core/connections.html#schema-translating)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#2685](https://www.sqlalchemy.org/trac/ticket/2685)'
  prefs: []
  type: TYPE_NORMAL
- en: '### “Friendly” stringification of Core SQL constructs without a dialect'
  prefs: []
  type: TYPE_NORMAL
- en: 'Calling `str()` on a Core SQL construct will now produce a string in more cases
    than before, supporting various SQL constructs not normally present in default
    SQL such as RETURNING, array indexes, and non-standard datatypes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE301]'
  prefs: []
  type: TYPE_PRE
- en: The `str()` function now calls upon an entirely separate dialect / compiler
    intended just for plain string printing without a specific dialect set up, so
    as more “just show me a string!” cases come up, these can be added to this dialect/compiler
    without impacting behaviors on real dialects.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Stringify of Query will consult the Session for the correct dialect](#change-3081)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#3631](https://www.sqlalchemy.org/trac/ticket/3631)'
  prefs: []
  type: TYPE_NORMAL
- en: '### The type_coerce function is now a persistent SQL element'
  prefs: []
  type: TYPE_NORMAL
- en: The [`type_coerce()`](../core/sqlelement.html#sqlalchemy.sql.expression.type_coerce
    "sqlalchemy.sql.expression.type_coerce") function previously would return an object
    either of type [`BindParameter`](../core/sqlelement.html#sqlalchemy.sql.expression.BindParameter
    "sqlalchemy.sql.expression.BindParameter") or [`Label`](../core/sqlelement.html#sqlalchemy.sql.expression.Label
    "sqlalchemy.sql.expression.Label"), depending on the input. An effect this would
    have was that in the case where expression transformations were used, such as
    the conversion of an element from a [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") to a [`BindParameter`](../core/sqlelement.html#sqlalchemy.sql.expression.BindParameter
    "sqlalchemy.sql.expression.BindParameter") that’s critical to ORM-level lazy loading,
    the type coercion information would not be used since it would have been lost
    already.
  prefs: []
  type: TYPE_NORMAL
- en: To improve this behavior, the function now returns a persistent [`TypeCoerce`](../core/sqlelement.html#sqlalchemy.sql.expression.TypeCoerce
    "sqlalchemy.sql.expression.TypeCoerce") container around the given expression,
    which itself remains unaffected; this construct is evaluated explicitly by the
    SQL compiler. This allows for the coercion of the inner expression to be maintained
    no matter how the statement is modified, including if the contained element is
    replaced with a different one, as is common within the ORM’s lazy loading feature.
  prefs: []
  type: TYPE_NORMAL
- en: 'The test case illustrating the effect makes use of a heterogeneous primaryjoin
    condition in conjunction with custom types and lazy loading. Given a custom type
    that applies a CAST as a “bind expression”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE302]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, a mapping where we are equating a string “id” column on one table to
    an integer “id” column on the other:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE303]'
  prefs: []
  type: TYPE_PRE
- en: 'Above, in the [`relationship.primaryjoin`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.primaryjoin
    "sqlalchemy.orm.relationship") expression, we are using [`type_coerce()`](../core/sqlelement.html#sqlalchemy.sql.expression.type_coerce
    "sqlalchemy.sql.expression.type_coerce") to handle bound parameters passed via
    lazyloading as integers, since we already know these will come from our `StringAsInt`
    type which maintains the value as an integer in Python. We are then using [`cast()`](../core/sqlelement.html#sqlalchemy.sql.expression.cast
    "sqlalchemy.sql.expression.cast") so that as a SQL expression, the VARCHAR “id”
    column will be CAST to an integer for a regular non- converted join as with [`Query.join()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join") or [`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload"). That is, a joinedload of `.pets` looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE304]'
  prefs: []
  type: TYPE_PRE
- en: Without the CAST in the ON clause of the join, strongly-typed databases such
    as PostgreSQL will refuse to implicitly compare the integer and fail.
  prefs: []
  type: TYPE_NORMAL
- en: 'The lazyload case of `.pets` relies upon replacing the `Person.id` column at
    load time with a bound parameter, which receives a Python-loaded value. This replacement
    is specifically where the intent of our [`type_coerce()`](../core/sqlelement.html#sqlalchemy.sql.expression.type_coerce
    "sqlalchemy.sql.expression.type_coerce") function would be lost. Prior to the
    change, this lazy load comes out as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE305]'
  prefs: []
  type: TYPE_PRE
- en: Where above, we see that our in-Python value of `5` is CAST first to a VARCHAR,
    then back to an INTEGER in SQL; a double CAST which works, but is nevertheless
    not what we asked for.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the change, the [`type_coerce()`](../core/sqlelement.html#sqlalchemy.sql.expression.type_coerce
    "sqlalchemy.sql.expression.type_coerce") function maintains a wrapper even after
    the column is swapped out for a bound parameter, and the query now looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE306]'
  prefs: []
  type: TYPE_PRE
- en: Where our outer CAST that’s in our primaryjoin still takes effect, but the needless
    CAST that’s in part of the `StringAsInt` custom type is removed as intended by
    the [`type_coerce()`](../core/sqlelement.html#sqlalchemy.sql.expression.type_coerce
    "sqlalchemy.sql.expression.type_coerce") function.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3531](https://www.sqlalchemy.org/trac/ticket/3531)'
  prefs: []
  type: TYPE_NORMAL
- en: Key Behavioral Changes - ORM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '### JSON Columns will not insert JSON NULL if no value is supplied and no default
    is established'
  prefs: []
  type: TYPE_NORMAL
- en: 'As detailed in [JSON “null” is inserted as expected with ORM operations, omitted
    when not present](#change-3514), [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON") will not render a JSON “null” value if the value is missing
    entirely. To prevent SQL NULL, a default should be set up. Given the following
    mapping:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE307]'
  prefs: []
  type: TYPE_PRE
- en: 'The following flush operation will fail with an integrity error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE308]'
  prefs: []
  type: TYPE_PRE
- en: 'If the default for the column should be JSON NULL, set this on the Column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE309]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, ensure the value is present on the object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE310]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that setting `None` for the default is the same as omitting it entirely;
    the [`JSON.none_as_null`](../core/type_basics.html#sqlalchemy.types.JSON.params.none_as_null
    "sqlalchemy.types.JSON") flag does not impact the value of `None` passed to [`Column.default`](../core/metadata.html#sqlalchemy.schema.Column.params.default
    "sqlalchemy.schema.Column") or [`Column.server_default`](../core/metadata.html#sqlalchemy.schema.Column.params.server_default
    "sqlalchemy.schema.Column"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE311]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[JSON “null” is inserted as expected with ORM operations, omitted when not
    present](#change-3514)  ### Columns no longer added redundantly with DISTINCT
    + ORDER BY'
  prefs: []
  type: TYPE_NORMAL
- en: 'A query such as the following will now augment only those columns that are
    missing from the SELECT list, without duplicates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE312]'
  prefs: []
  type: TYPE_PRE
- en: 'Produces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE313]'
  prefs: []
  type: TYPE_PRE
- en: 'Previously, it would produce:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE314]'
  prefs: []
  type: TYPE_PRE
- en: Where above, the `user.name` column is added unnecessarily. The results would
    not be affected, as the additional columns are not included in the result in any
    case, but the columns are unnecessary.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, when the PostgreSQL DISTINCT ON format is used by passing expressions
    to [`Query.distinct()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.distinct
    "sqlalchemy.orm.Query.distinct"), the above “column adding” logic is disabled
    entirely.
  prefs: []
  type: TYPE_NORMAL
- en: When the query is being bundled into a subquery for the purposes of joined eager
    loading, the “augment column list” rules are necessarily more aggressive so that
    the ORDER BY can still be satisfied, so this case remains unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3641](https://www.sqlalchemy.org/trac/ticket/3641)  ### Same-named @validates
    decorators will now raise an exception'
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`validates()`](../orm/mapped_attributes.html#sqlalchemy.orm.validates
    "sqlalchemy.orm.validates") decorator is only intended to be created once per
    class for a particular attribute name. Creating more than one now raises an error,
    whereas previously it would silently pick only the last defined validator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE315]'
  prefs: []
  type: TYPE_PRE
- en: 'Will raise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE316]'
  prefs: []
  type: TYPE_PRE
- en: '[#3776](https://www.sqlalchemy.org/trac/ticket/3776)  ### JSON Columns will
    not insert JSON NULL if no value is supplied and no default is established'
  prefs: []
  type: TYPE_NORMAL
- en: 'As detailed in [JSON “null” is inserted as expected with ORM operations, omitted
    when not present](#change-3514), [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON") will not render a JSON “null” value if the value is missing
    entirely. To prevent SQL NULL, a default should be set up. Given the following
    mapping:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE317]'
  prefs: []
  type: TYPE_PRE
- en: 'The following flush operation will fail with an integrity error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE318]'
  prefs: []
  type: TYPE_PRE
- en: 'If the default for the column should be JSON NULL, set this on the Column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE319]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, ensure the value is present on the object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE320]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that setting `None` for the default is the same as omitting it entirely;
    the [`JSON.none_as_null`](../core/type_basics.html#sqlalchemy.types.JSON.params.none_as_null
    "sqlalchemy.types.JSON") flag does not impact the value of `None` passed to [`Column.default`](../core/metadata.html#sqlalchemy.schema.Column.params.default
    "sqlalchemy.schema.Column") or [`Column.server_default`](../core/metadata.html#sqlalchemy.schema.Column.params.server_default
    "sqlalchemy.schema.Column"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE321]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[JSON “null” is inserted as expected with ORM operations, omitted when not
    present](#change-3514)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Columns no longer added redundantly with DISTINCT + ORDER BY'
  prefs: []
  type: TYPE_NORMAL
- en: 'A query such as the following will now augment only those columns that are
    missing from the SELECT list, without duplicates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE322]'
  prefs: []
  type: TYPE_PRE
- en: 'Produces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE323]'
  prefs: []
  type: TYPE_PRE
- en: 'Previously, it would produce:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE324]'
  prefs: []
  type: TYPE_PRE
- en: Where above, the `user.name` column is added unnecessarily. The results would
    not be affected, as the additional columns are not included in the result in any
    case, but the columns are unnecessary.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, when the PostgreSQL DISTINCT ON format is used by passing expressions
    to [`Query.distinct()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.distinct
    "sqlalchemy.orm.Query.distinct"), the above “column adding” logic is disabled
    entirely.
  prefs: []
  type: TYPE_NORMAL
- en: When the query is being bundled into a subquery for the purposes of joined eager
    loading, the “augment column list” rules are necessarily more aggressive so that
    the ORDER BY can still be satisfied, so this case remains unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3641](https://www.sqlalchemy.org/trac/ticket/3641)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Same-named @validates decorators will now raise an exception'
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`validates()`](../orm/mapped_attributes.html#sqlalchemy.orm.validates
    "sqlalchemy.orm.validates") decorator is only intended to be created once per
    class for a particular attribute name. Creating more than one now raises an error,
    whereas previously it would silently pick only the last defined validator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE325]'
  prefs: []
  type: TYPE_PRE
- en: 'Will raise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE326]'
  prefs: []
  type: TYPE_PRE
- en: '[#3776](https://www.sqlalchemy.org/trac/ticket/3776)'
  prefs: []
  type: TYPE_NORMAL
- en: Key Behavioral Changes - Core
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '### TextClause.columns() will match columns positionally, not by name, when
    passed positionally'
  prefs: []
  type: TYPE_NORMAL
- en: The new behavior of the [`TextClause.columns()`](../core/sqlelement.html#sqlalchemy.sql.expression.TextClause.columns
    "sqlalchemy.sql.expression.TextClause.columns") method, which itself was recently
    added as of the 0.9 series, is that when columns are passed positionally without
    any additional keyword arguments, they are linked to the ultimate result set columns
    positionally, and no longer on name. It is hoped that the impact of this change
    will be low due to the fact that the method has always been documented illustrating
    the columns being passed in the same order as that of the textual SQL statement,
    as would seem intuitive, even though the internals weren’t checking for this.
  prefs: []
  type: TYPE_NORMAL
- en: An application that is using this method by passing [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects to it positionally must ensure that the position
    of those [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    objects matches the position in which these columns are stated in the textual
    SQL.
  prefs: []
  type: TYPE_NORMAL
- en: 'E.g., code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE327]'
  prefs: []
  type: TYPE_PRE
- en: 'Would no longer work as expected; the order of the columns given is now significant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE328]'
  prefs: []
  type: TYPE_PRE
- en: 'Possibly more likely, a statement that worked like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE329]'
  prefs: []
  type: TYPE_PRE
- en: is now slightly risky, as the “*” specification will generally deliver columns
    in the order in which they are present in the table itself. If the structure of
    the table changes due to schema changes, this ordering may no longer be the same.
    Therefore when using [`TextClause.columns()`](../core/sqlelement.html#sqlalchemy.sql.expression.TextClause.columns
    "sqlalchemy.sql.expression.TextClause.columns"), it’s advised to list out the
    desired columns explicitly in the textual SQL, though it’s no longer necessary
    to worry about the names themselves in the textual SQL.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[ResultSet column matching enhancements; positional column setup for textual
    SQL](#change-3501)  ### String server_default now literal quoted'
  prefs: []
  type: TYPE_NORMAL
- en: 'A server default passed to [`Column.server_default`](../core/metadata.html#sqlalchemy.schema.Column.params.server_default
    "sqlalchemy.schema.Column") as a plain Python string that has quotes embedded
    is now passed through the literal quoting system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE330]'
  prefs: []
  type: TYPE_PRE
- en: Previously the quote would render directly. This change may be backwards incompatible
    for applications with such a use case who were working around the issue.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3809](https://www.sqlalchemy.org/trac/ticket/3809)  ### A UNION or similar
    of SELECTs with LIMIT/OFFSET/ORDER BY now parenthesizes the embedded selects'
  prefs: []
  type: TYPE_NORMAL
- en: 'An issue that, like others, was long driven by SQLite’s lack of capabilities
    has now been enhanced to work on all supporting backends. We refer to a query
    that is a UNION of SELECT statements that themselves contain row-limiting or ordering
    features which include LIMIT, OFFSET, and/or ORDER BY:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE331]'
  prefs: []
  type: TYPE_PRE
- en: 'The above query requires parenthesis within each sub-select in order to group
    the sub-results correctly. Production of the above statement in SQLAlchemy Core
    looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE332]'
  prefs: []
  type: TYPE_PRE
- en: Previously, the above construct would not produce parenthesization for the inner
    SELECT statements, producing a query that fails on all backends.
  prefs: []
  type: TYPE_NORMAL
- en: The above formats will **continue to fail on SQLite**; additionally, the format
    that includes ORDER BY but no LIMIT/SELECT will **continue to fail on Oracle**.
    This is not a backwards-incompatible change, because the queries fail without
    the parentheses as well; with the fix, the queries at least work on all other
    databases.
  prefs: []
  type: TYPE_NORMAL
- en: 'In all cases, in order to produce a UNION of limited SELECT statements that
    also works on SQLite and in all cases on Oracle, the subqueries must be a SELECT
    of an ALIAS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE333]'
  prefs: []
  type: TYPE_PRE
- en: 'This workaround works on all SQLAlchemy versions. In the ORM, it looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE334]'
  prefs: []
  type: TYPE_PRE
- en: The behavior here has many parallels to the “join rewriting” behavior introduced
    in SQLAlchemy 0.9 in [Many JOIN and LEFT OUTER JOIN expressions will no longer
    be wrapped in (SELECT * FROM ..) AS ANON_1](migration_09.html#feature-joins-09);
    however in this case we have opted not to add new rewriting behavior to accommodate
    this case for SQLite. The existing rewriting behavior is very complicated already,
    and the case of UNIONs with parenthesized SELECT statements is much less common
    than the “right-nested-join” use case of that feature.
  prefs: []
  type: TYPE_NORMAL
- en: '[#2528](https://www.sqlalchemy.org/trac/ticket/2528)  ### TextClause.columns()
    will match columns positionally, not by name, when passed positionally'
  prefs: []
  type: TYPE_NORMAL
- en: The new behavior of the [`TextClause.columns()`](../core/sqlelement.html#sqlalchemy.sql.expression.TextClause.columns
    "sqlalchemy.sql.expression.TextClause.columns") method, which itself was recently
    added as of the 0.9 series, is that when columns are passed positionally without
    any additional keyword arguments, they are linked to the ultimate result set columns
    positionally, and no longer on name. It is hoped that the impact of this change
    will be low due to the fact that the method has always been documented illustrating
    the columns being passed in the same order as that of the textual SQL statement,
    as would seem intuitive, even though the internals weren’t checking for this.
  prefs: []
  type: TYPE_NORMAL
- en: An application that is using this method by passing [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects to it positionally must ensure that the position
    of those [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    objects matches the position in which these columns are stated in the textual
    SQL.
  prefs: []
  type: TYPE_NORMAL
- en: 'E.g., code like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE335]'
  prefs: []
  type: TYPE_PRE
- en: 'Would no longer work as expected; the order of the columns given is now significant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE336]'
  prefs: []
  type: TYPE_PRE
- en: 'Possibly more likely, a statement that worked like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE337]'
  prefs: []
  type: TYPE_PRE
- en: is now slightly risky, as the “*” specification will generally deliver columns
    in the order in which they are present in the table itself. If the structure of
    the table changes due to schema changes, this ordering may no longer be the same.
    Therefore when using [`TextClause.columns()`](../core/sqlelement.html#sqlalchemy.sql.expression.TextClause.columns
    "sqlalchemy.sql.expression.TextClause.columns"), it’s advised to list out the
    desired columns explicitly in the textual SQL, though it’s no longer necessary
    to worry about the names themselves in the textual SQL.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[ResultSet column matching enhancements; positional column setup for textual
    SQL](#change-3501)'
  prefs: []
  type: TYPE_NORMAL
- en: '### String server_default now literal quoted'
  prefs: []
  type: TYPE_NORMAL
- en: 'A server default passed to [`Column.server_default`](../core/metadata.html#sqlalchemy.schema.Column.params.server_default
    "sqlalchemy.schema.Column") as a plain Python string that has quotes embedded
    is now passed through the literal quoting system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE338]'
  prefs: []
  type: TYPE_PRE
- en: Previously the quote would render directly. This change may be backwards incompatible
    for applications with such a use case who were working around the issue.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3809](https://www.sqlalchemy.org/trac/ticket/3809)'
  prefs: []
  type: TYPE_NORMAL
- en: '### A UNION or similar of SELECTs with LIMIT/OFFSET/ORDER BY now parenthesizes
    the embedded selects'
  prefs: []
  type: TYPE_NORMAL
- en: 'An issue that, like others, was long driven by SQLite’s lack of capabilities
    has now been enhanced to work on all supporting backends. We refer to a query
    that is a UNION of SELECT statements that themselves contain row-limiting or ordering
    features which include LIMIT, OFFSET, and/or ORDER BY:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE339]'
  prefs: []
  type: TYPE_PRE
- en: 'The above query requires parenthesis within each sub-select in order to group
    the sub-results correctly. Production of the above statement in SQLAlchemy Core
    looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE340]'
  prefs: []
  type: TYPE_PRE
- en: Previously, the above construct would not produce parenthesization for the inner
    SELECT statements, producing a query that fails on all backends.
  prefs: []
  type: TYPE_NORMAL
- en: The above formats will **continue to fail on SQLite**; additionally, the format
    that includes ORDER BY but no LIMIT/SELECT will **continue to fail on Oracle**.
    This is not a backwards-incompatible change, because the queries fail without
    the parentheses as well; with the fix, the queries at least work on all other
    databases.
  prefs: []
  type: TYPE_NORMAL
- en: 'In all cases, in order to produce a UNION of limited SELECT statements that
    also works on SQLite and in all cases on Oracle, the subqueries must be a SELECT
    of an ALIAS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE341]'
  prefs: []
  type: TYPE_PRE
- en: 'This workaround works on all SQLAlchemy versions. In the ORM, it looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE342]'
  prefs: []
  type: TYPE_PRE
- en: The behavior here has many parallels to the “join rewriting” behavior introduced
    in SQLAlchemy 0.9 in [Many JOIN and LEFT OUTER JOIN expressions will no longer
    be wrapped in (SELECT * FROM ..) AS ANON_1](migration_09.html#feature-joins-09);
    however in this case we have opted not to add new rewriting behavior to accommodate
    this case for SQLite. The existing rewriting behavior is very complicated already,
    and the case of UNIONs with parenthesized SELECT statements is much less common
    than the “right-nested-join” use case of that feature.
  prefs: []
  type: TYPE_NORMAL
- en: '[#2528](https://www.sqlalchemy.org/trac/ticket/2528)'
  prefs: []
  type: TYPE_NORMAL
- en: Dialect Improvements and Changes - PostgreSQL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '### Support for INSERT..ON CONFLICT (DO UPDATE | DO NOTHING)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ON CONFLICT` clause of `INSERT` added to PostgreSQL as of version 9.5
    is now supported using a PostgreSQL-specific version of the [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") object, via `sqlalchemy.dialects.postgresql.dml.insert()`.
    This [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert "sqlalchemy.sql.expression.Insert")
    subclass adds two new methods `Insert.on_conflict_do_update()` and `Insert.on_conflict_do_nothing()`
    which implement the full syntax supported by PostgreSQL 9.5 in this area:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE343]'
  prefs: []
  type: TYPE_PRE
- en: 'The above will render:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE344]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[INSERT…ON CONFLICT (Upsert)](../dialects/postgresql.html#postgresql-insert-on-conflict)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#3529](https://www.sqlalchemy.org/trac/ticket/3529)  ### ARRAY and JSON types
    now correctly specify “unhashable”'
  prefs: []
  type: TYPE_NORMAL
- en: As described in [Changes regarding “unhashable” types, impacts deduping of ORM
    rows](#change-3499), the ORM relies upon being able to produce a hash function
    for column values when a query’s selected entities mixes full ORM entities with
    column expressions. The `hashable=False` flag is now correctly set on all of PG’s
    “data structure” types, including [`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY") and [`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON
    "sqlalchemy.dialects.postgresql.JSON"). The [`JSONB`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSONB
    "sqlalchemy.dialects.postgresql.JSONB") and [`HSTORE`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.HSTORE
    "sqlalchemy.dialects.postgresql.HSTORE") types already included this flag. For
    [`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY "sqlalchemy.dialects.postgresql.ARRAY"),
    this is conditional based on the [`ARRAY.as_tuple`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY.params.as_tuple
    "sqlalchemy.dialects.postgresql.ARRAY") flag, however it should no longer be necessary
    to set this flag in order to have an array value present in a composed ORM row.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Changes regarding “unhashable” types, impacts deduping of ORM rows](#change-3499)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Correct SQL Types are Established from Indexed Access of ARRAY, JSON, HSTORE](#change-3503)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#3499](https://www.sqlalchemy.org/trac/ticket/3499)  ### Correct SQL Types
    are Established from Indexed Access of ARRAY, JSON, HSTORE'
  prefs: []
  type: TYPE_NORMAL
- en: For all three of [`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY"), [`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON
    "sqlalchemy.dialects.postgresql.JSON") and [`HSTORE`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.HSTORE
    "sqlalchemy.dialects.postgresql.HSTORE"), the SQL type assigned to the expression
    returned by indexed access, e.g. `col[someindex]`, should be correct in all cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'This includes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The SQL type assigned to indexed access of an [`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY") takes into account the number of dimensions
    configured. An [`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY") with three dimensions will return a SQL
    expression with a type of [`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY") of one less dimension. Given a column
    with type `ARRAY(Integer, dimensions=3)`, we can now perform this expression:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE345]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Previously, the indexed access to `col[5]` would return an expression of type
    [`Integer`](../core/type_basics.html#sqlalchemy.types.Integer "sqlalchemy.types.Integer")
    where we could no longer perform indexed access for the remaining dimensions,
    unless we used [`cast()`](../core/sqlelement.html#sqlalchemy.sql.expression.cast
    "sqlalchemy.sql.expression.cast") or [`type_coerce()`](../core/sqlelement.html#sqlalchemy.sql.expression.type_coerce
    "sqlalchemy.sql.expression.type_coerce").
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The [`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON
    "sqlalchemy.dialects.postgresql.JSON") and [`JSONB`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSONB
    "sqlalchemy.dialects.postgresql.JSONB") types now mirror what PostgreSQL itself
    does for indexed access. This means that all indexed access for a [`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON
    "sqlalchemy.dialects.postgresql.JSON") or [`JSONB`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSONB
    "sqlalchemy.dialects.postgresql.JSONB") type returns an expression that itself
    is *always* [`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON
    "sqlalchemy.dialects.postgresql.JSON") or [`JSONB`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSONB
    "sqlalchemy.dialects.postgresql.JSONB") itself, unless the [`Comparator.astext`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON.Comparator.astext
    "sqlalchemy.dialects.postgresql.JSON.Comparator.astext") modifier is used. This
    means that whether the indexed access of the JSON structure ultimately refers
    to a string, list, number, or other JSON structure, PostgreSQL always considers
    it to be JSON itself unless it is explicitly cast differently. Like the [`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY") type, this means that it is now straightforward
    to produce JSON expressions with multiple levels of indexed access:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE346]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The “textual” type that is returned by indexed access of [`HSTORE`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.HSTORE
    "sqlalchemy.dialects.postgresql.HSTORE") as well as the “textual” type that is
    returned by indexed access of [`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON
    "sqlalchemy.dialects.postgresql.JSON") and [`JSONB`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSONB
    "sqlalchemy.dialects.postgresql.JSONB") in conjunction with the [`Comparator.astext`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON.Comparator.astext
    "sqlalchemy.dialects.postgresql.JSON.Comparator.astext") modifier is now configurable;
    it defaults to [`TextClause`](../core/sqlelement.html#sqlalchemy.sql.expression.TextClause
    "sqlalchemy.sql.expression.TextClause") in both cases but can be set to a user-defined
    type using the [`JSON.astext_type`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON.params.astext_type
    "sqlalchemy.dialects.postgresql.JSON") or [`HSTORE.text_type`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.HSTORE.params.text_type
    "sqlalchemy.dialects.postgresql.HSTORE") parameters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[The JSON cast() operation now requires .astext is called explicitly](#change-3503-cast)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#3499](https://www.sqlalchemy.org/trac/ticket/3499) [#3487](https://www.sqlalchemy.org/trac/ticket/3487)  ###
    The JSON cast() operation now requires `.astext` is called explicitly'
  prefs: []
  type: TYPE_NORMAL
- en: As part of the changes in [Correct SQL Types are Established from Indexed Access
    of ARRAY, JSON, HSTORE](#change-3503), the workings of the [`ColumnElement.cast()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnElement.cast
    "sqlalchemy.sql.expression.ColumnElement.cast") operator on [`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON
    "sqlalchemy.dialects.postgresql.JSON") and [`JSONB`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSONB
    "sqlalchemy.dialects.postgresql.JSONB") no longer implicitly invoke the [`Comparator.astext`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON.Comparator.astext
    "sqlalchemy.dialects.postgresql.JSON.Comparator.astext") modifier; PostgreSQL’s
    JSON/JSONB types support CAST operations to each other without the “astext” aspect.
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that in most cases, an application that was doing this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE347]'
  prefs: []
  type: TYPE_PRE
- en: 'Will now need to change to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE348]  ### ARRAY with ENUM will now emit CREATE TYPE for the ENUM'
  prefs: []
  type: TYPE_NORMAL
- en: 'A table definition like the following will now emit CREATE TYPE as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE349]'
  prefs: []
  type: TYPE_PRE
- en: 'emits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE350]'
  prefs: []
  type: TYPE_PRE
- en: '[#2729](https://www.sqlalchemy.org/trac/ticket/2729)'
  prefs: []
  type: TYPE_NORMAL
- en: Check constraints now reflect
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The PostgreSQL dialect now supports reflection of CHECK constraints both within
    the method [`Inspector.get_check_constraints()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_check_constraints
    "sqlalchemy.engine.reflection.Inspector.get_check_constraints") as well as within
    [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    reflection within the [`Table.constraints`](../core/metadata.html#sqlalchemy.schema.Table.constraints
    "sqlalchemy.schema.Table.constraints") collection.
  prefs: []
  type: TYPE_NORMAL
- en: “Plain” and “Materialized” views can be inspected separately
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The new argument `PGInspector.get_view_names.include` allows specification
    of which sub-types of views should be returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE351]'
  prefs: []
  type: TYPE_PRE
- en: '[#3588](https://www.sqlalchemy.org/trac/ticket/3588)'
  prefs: []
  type: TYPE_NORMAL
- en: Added tablespace option to Index
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The [`Index`](../core/constraints.html#sqlalchemy.schema.Index "sqlalchemy.schema.Index")
    object now accepts the argument `postgresql_tablespace` in order to specify TABLESPACE,
    the same way as accepted by the [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") object.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Index Storage Parameters](../dialects/postgresql.html#postgresql-index-storage)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#3720](https://www.sqlalchemy.org/trac/ticket/3720)'
  prefs: []
  type: TYPE_NORMAL
- en: Support for PyGreSQL
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The [PyGreSQL](https://pypi.org/project/PyGreSQL) DBAPI is now supported.
  prefs: []
  type: TYPE_NORMAL
- en: The “postgres” module is removed
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `sqlalchemy.dialects.postgres` module, long deprecated, is removed; this
    has emitted a warning for many years and projects should be calling upon `sqlalchemy.dialects.postgresql`.
    Engine URLs of the form `postgres://` will still continue to function, however.
  prefs: []
  type: TYPE_NORMAL
- en: Support for FOR UPDATE SKIP LOCKED / FOR NO KEY UPDATE / FOR KEY SHARE
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The new parameters [`GenerativeSelect.with_for_update.skip_locked`](../core/selectable.html#sqlalchemy.sql.expression.GenerativeSelect.with_for_update.params.skip_locked
    "sqlalchemy.sql.expression.GenerativeSelect.with_for_update") and [`GenerativeSelect.with_for_update.key_share`](../core/selectable.html#sqlalchemy.sql.expression.GenerativeSelect.with_for_update.params.key_share
    "sqlalchemy.sql.expression.GenerativeSelect.with_for_update") in both Core and
    ORM apply a modification to a “SELECT…FOR UPDATE” or “SELECT…FOR SHARE” query
    on the PostgreSQL backend:'
  prefs: []
  type: TYPE_NORMAL
- en: 'SELECT FOR NO KEY UPDATE:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE352]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'SELECT FOR UPDATE SKIP LOCKED:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE353]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'SELECT FOR KEY SHARE:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE354]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '### Support for INSERT..ON CONFLICT (DO UPDATE | DO NOTHING)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ON CONFLICT` clause of `INSERT` added to PostgreSQL as of version 9.5
    is now supported using a PostgreSQL-specific version of the [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") object, via `sqlalchemy.dialects.postgresql.dml.insert()`.
    This [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert "sqlalchemy.sql.expression.Insert")
    subclass adds two new methods `Insert.on_conflict_do_update()` and `Insert.on_conflict_do_nothing()`
    which implement the full syntax supported by PostgreSQL 9.5 in this area:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE355]'
  prefs: []
  type: TYPE_PRE
- en: 'The above will render:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE356]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[INSERT…ON CONFLICT (Upsert)](../dialects/postgresql.html#postgresql-insert-on-conflict)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#3529](https://www.sqlalchemy.org/trac/ticket/3529)'
  prefs: []
  type: TYPE_NORMAL
- en: '### ARRAY and JSON types now correctly specify “unhashable”'
  prefs: []
  type: TYPE_NORMAL
- en: As described in [Changes regarding “unhashable” types, impacts deduping of ORM
    rows](#change-3499), the ORM relies upon being able to produce a hash function
    for column values when a query’s selected entities mixes full ORM entities with
    column expressions. The `hashable=False` flag is now correctly set on all of PG’s
    “data structure” types, including [`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY") and [`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON
    "sqlalchemy.dialects.postgresql.JSON"). The [`JSONB`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSONB
    "sqlalchemy.dialects.postgresql.JSONB") and [`HSTORE`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.HSTORE
    "sqlalchemy.dialects.postgresql.HSTORE") types already included this flag. For
    [`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY "sqlalchemy.dialects.postgresql.ARRAY"),
    this is conditional based on the [`ARRAY.as_tuple`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY.params.as_tuple
    "sqlalchemy.dialects.postgresql.ARRAY") flag, however it should no longer be necessary
    to set this flag in order to have an array value present in a composed ORM row.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Changes regarding “unhashable” types, impacts deduping of ORM rows](#change-3499)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Correct SQL Types are Established from Indexed Access of ARRAY, JSON, HSTORE](#change-3503)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#3499](https://www.sqlalchemy.org/trac/ticket/3499)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Correct SQL Types are Established from Indexed Access of ARRAY, JSON, HSTORE'
  prefs: []
  type: TYPE_NORMAL
- en: For all three of [`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY"), [`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON
    "sqlalchemy.dialects.postgresql.JSON") and [`HSTORE`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.HSTORE
    "sqlalchemy.dialects.postgresql.HSTORE"), the SQL type assigned to the expression
    returned by indexed access, e.g. `col[someindex]`, should be correct in all cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'This includes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The SQL type assigned to indexed access of an [`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY") takes into account the number of dimensions
    configured. An [`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY") with three dimensions will return a SQL
    expression with a type of [`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY") of one less dimension. Given a column
    with type `ARRAY(Integer, dimensions=3)`, we can now perform this expression:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE357]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Previously, the indexed access to `col[5]` would return an expression of type
    [`Integer`](../core/type_basics.html#sqlalchemy.types.Integer "sqlalchemy.types.Integer")
    where we could no longer perform indexed access for the remaining dimensions,
    unless we used [`cast()`](../core/sqlelement.html#sqlalchemy.sql.expression.cast
    "sqlalchemy.sql.expression.cast") or [`type_coerce()`](../core/sqlelement.html#sqlalchemy.sql.expression.type_coerce
    "sqlalchemy.sql.expression.type_coerce").
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The [`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON
    "sqlalchemy.dialects.postgresql.JSON") and [`JSONB`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSONB
    "sqlalchemy.dialects.postgresql.JSONB") types now mirror what PostgreSQL itself
    does for indexed access. This means that all indexed access for a [`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON
    "sqlalchemy.dialects.postgresql.JSON") or [`JSONB`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSONB
    "sqlalchemy.dialects.postgresql.JSONB") type returns an expression that itself
    is *always* [`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON
    "sqlalchemy.dialects.postgresql.JSON") or [`JSONB`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSONB
    "sqlalchemy.dialects.postgresql.JSONB") itself, unless the [`Comparator.astext`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON.Comparator.astext
    "sqlalchemy.dialects.postgresql.JSON.Comparator.astext") modifier is used. This
    means that whether the indexed access of the JSON structure ultimately refers
    to a string, list, number, or other JSON structure, PostgreSQL always considers
    it to be JSON itself unless it is explicitly cast differently. Like the [`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY") type, this means that it is now straightforward
    to produce JSON expressions with multiple levels of indexed access:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE358]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The “textual” type that is returned by indexed access of [`HSTORE`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.HSTORE
    "sqlalchemy.dialects.postgresql.HSTORE") as well as the “textual” type that is
    returned by indexed access of [`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON
    "sqlalchemy.dialects.postgresql.JSON") and [`JSONB`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSONB
    "sqlalchemy.dialects.postgresql.JSONB") in conjunction with the [`Comparator.astext`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON.Comparator.astext
    "sqlalchemy.dialects.postgresql.JSON.Comparator.astext") modifier is now configurable;
    it defaults to [`TextClause`](../core/sqlelement.html#sqlalchemy.sql.expression.TextClause
    "sqlalchemy.sql.expression.TextClause") in both cases but can be set to a user-defined
    type using the [`JSON.astext_type`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON.params.astext_type
    "sqlalchemy.dialects.postgresql.JSON") or [`HSTORE.text_type`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.HSTORE.params.text_type
    "sqlalchemy.dialects.postgresql.HSTORE") parameters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[The JSON cast() operation now requires .astext is called explicitly](#change-3503-cast)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#3499](https://www.sqlalchemy.org/trac/ticket/3499) [#3487](https://www.sqlalchemy.org/trac/ticket/3487)'
  prefs: []
  type: TYPE_NORMAL
- en: '### The JSON cast() operation now requires `.astext` is called explicitly'
  prefs: []
  type: TYPE_NORMAL
- en: As part of the changes in [Correct SQL Types are Established from Indexed Access
    of ARRAY, JSON, HSTORE](#change-3503), the workings of the [`ColumnElement.cast()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnElement.cast
    "sqlalchemy.sql.expression.ColumnElement.cast") operator on [`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON
    "sqlalchemy.dialects.postgresql.JSON") and [`JSONB`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSONB
    "sqlalchemy.dialects.postgresql.JSONB") no longer implicitly invoke the [`Comparator.astext`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON.Comparator.astext
    "sqlalchemy.dialects.postgresql.JSON.Comparator.astext") modifier; PostgreSQL’s
    JSON/JSONB types support CAST operations to each other without the “astext” aspect.
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that in most cases, an application that was doing this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE359]'
  prefs: []
  type: TYPE_PRE
- en: 'Will now need to change to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE360]'
  prefs: []
  type: TYPE_PRE
- en: '### ARRAY with ENUM will now emit CREATE TYPE for the ENUM'
  prefs: []
  type: TYPE_NORMAL
- en: 'A table definition like the following will now emit CREATE TYPE as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE361]'
  prefs: []
  type: TYPE_PRE
- en: 'emits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE362]'
  prefs: []
  type: TYPE_PRE
- en: '[#2729](https://www.sqlalchemy.org/trac/ticket/2729)'
  prefs: []
  type: TYPE_NORMAL
- en: Check constraints now reflect
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The PostgreSQL dialect now supports reflection of CHECK constraints both within
    the method [`Inspector.get_check_constraints()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_check_constraints
    "sqlalchemy.engine.reflection.Inspector.get_check_constraints") as well as within
    [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    reflection within the [`Table.constraints`](../core/metadata.html#sqlalchemy.schema.Table.constraints
    "sqlalchemy.schema.Table.constraints") collection.
  prefs: []
  type: TYPE_NORMAL
- en: “Plain” and “Materialized” views can be inspected separately
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The new argument `PGInspector.get_view_names.include` allows specification
    of which sub-types of views should be returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE363]'
  prefs: []
  type: TYPE_PRE
- en: '[#3588](https://www.sqlalchemy.org/trac/ticket/3588)'
  prefs: []
  type: TYPE_NORMAL
- en: Added tablespace option to Index
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The [`Index`](../core/constraints.html#sqlalchemy.schema.Index "sqlalchemy.schema.Index")
    object now accepts the argument `postgresql_tablespace` in order to specify TABLESPACE,
    the same way as accepted by the [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") object.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Index Storage Parameters](../dialects/postgresql.html#postgresql-index-storage)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#3720](https://www.sqlalchemy.org/trac/ticket/3720)'
  prefs: []
  type: TYPE_NORMAL
- en: Support for PyGreSQL
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The [PyGreSQL](https://pypi.org/project/PyGreSQL) DBAPI is now supported.
  prefs: []
  type: TYPE_NORMAL
- en: The “postgres” module is removed
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `sqlalchemy.dialects.postgres` module, long deprecated, is removed; this
    has emitted a warning for many years and projects should be calling upon `sqlalchemy.dialects.postgresql`.
    Engine URLs of the form `postgres://` will still continue to function, however.
  prefs: []
  type: TYPE_NORMAL
- en: Support for FOR UPDATE SKIP LOCKED / FOR NO KEY UPDATE / FOR KEY SHARE
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The new parameters [`GenerativeSelect.with_for_update.skip_locked`](../core/selectable.html#sqlalchemy.sql.expression.GenerativeSelect.with_for_update.params.skip_locked
    "sqlalchemy.sql.expression.GenerativeSelect.with_for_update") and [`GenerativeSelect.with_for_update.key_share`](../core/selectable.html#sqlalchemy.sql.expression.GenerativeSelect.with_for_update.params.key_share
    "sqlalchemy.sql.expression.GenerativeSelect.with_for_update") in both Core and
    ORM apply a modification to a “SELECT…FOR UPDATE” or “SELECT…FOR SHARE” query
    on the PostgreSQL backend:'
  prefs: []
  type: TYPE_NORMAL
- en: 'SELECT FOR NO KEY UPDATE:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE364]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'SELECT FOR UPDATE SKIP LOCKED:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE365]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'SELECT FOR KEY SHARE:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE366]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Dialect Improvements and Changes - MySQL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '### MySQL JSON Support'
  prefs: []
  type: TYPE_NORMAL
- en: A new type [`JSON`](../dialects/mysql.html#sqlalchemy.dialects.mysql.JSON "sqlalchemy.dialects.mysql.JSON")
    is added to the MySQL dialect supporting the JSON type newly added to MySQL 5.7\.
    This type provides both persistence of JSON as well as rudimentary indexed-access
    using the `JSON_EXTRACT` function internally. An indexable JSON column that works
    across MySQL and PostgreSQL can be achieved by using the [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON") datatype common to both MySQL and PostgreSQL.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[JSON support added to Core](#change-3619)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#3547](https://www.sqlalchemy.org/trac/ticket/3547)  ### Added support for
    AUTOCOMMIT “isolation level”'
  prefs: []
  type: TYPE_NORMAL
- en: 'The MySQL dialect now accepts the value “AUTOCOMMIT” for the [`create_engine.isolation_level`](../core/engines.html#sqlalchemy.create_engine.params.isolation_level
    "sqlalchemy.create_engine") and [`Connection.execution_options.isolation_level`](../core/connections.html#sqlalchemy.engine.Connection.execution_options.params.isolation_level
    "sqlalchemy.engine.Connection.execution_options") parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE367]'
  prefs: []
  type: TYPE_PRE
- en: The isolation level makes use of the various “autocommit” attributes provided
    by most MySQL DBAPIs.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3332](https://www.sqlalchemy.org/trac/ticket/3332)  ### No more generation
    of an implicit KEY for composite primary key w/ AUTO_INCREMENT'
  prefs: []
  type: TYPE_NORMAL
- en: 'The MySQL dialect had the behavior such that if a composite primary key on
    an InnoDB table featured AUTO_INCREMENT on one of its columns which was not the
    first column, e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE368]'
  prefs: []
  type: TYPE_PRE
- en: 'DDL such as the following would be generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE369]'
  prefs: []
  type: TYPE_PRE
- en: Note the above “KEY” with an auto-generated name; this is a change that found
    its way into the dialect many years ago in response to the issue that the AUTO_INCREMENT
    would otherwise fail on InnoDB without this additional KEY.
  prefs: []
  type: TYPE_NORMAL
- en: 'This workaround has been removed and replaced with the much better system of
    just stating the AUTO_INCREMENT column *first* within the primary key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE370]'
  prefs: []
  type: TYPE_PRE
- en: 'To maintain explicit control of the ordering of primary key columns, use the
    [`PrimaryKeyConstraint`](../core/constraints.html#sqlalchemy.schema.PrimaryKeyConstraint
    "sqlalchemy.schema.PrimaryKeyConstraint") construct explicitly (1.1.0b2) (along
    with a KEY for the autoincrement column as required by MySQL), e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE371]'
  prefs: []
  type: TYPE_PRE
- en: 'Along with the change [The .autoincrement directive is no longer implicitly
    enabled for a composite primary key column](#change-3216), composite primary keys
    with or without auto increment are now easier to specify; [`Column.autoincrement`](../core/metadata.html#sqlalchemy.schema.Column.params.autoincrement
    "sqlalchemy.schema.Column") now defaults to the value `"auto"` and the `autoincrement=False`
    directives are no longer needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE372]  ### MySQL JSON Support'
  prefs: []
  type: TYPE_NORMAL
- en: A new type [`JSON`](../dialects/mysql.html#sqlalchemy.dialects.mysql.JSON "sqlalchemy.dialects.mysql.JSON")
    is added to the MySQL dialect supporting the JSON type newly added to MySQL 5.7\.
    This type provides both persistence of JSON as well as rudimentary indexed-access
    using the `JSON_EXTRACT` function internally. An indexable JSON column that works
    across MySQL and PostgreSQL can be achieved by using the [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON") datatype common to both MySQL and PostgreSQL.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[JSON support added to Core](#change-3619)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#3547](https://www.sqlalchemy.org/trac/ticket/3547)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Added support for AUTOCOMMIT “isolation level”'
  prefs: []
  type: TYPE_NORMAL
- en: 'The MySQL dialect now accepts the value “AUTOCOMMIT” for the [`create_engine.isolation_level`](../core/engines.html#sqlalchemy.create_engine.params.isolation_level
    "sqlalchemy.create_engine") and [`Connection.execution_options.isolation_level`](../core/connections.html#sqlalchemy.engine.Connection.execution_options.params.isolation_level
    "sqlalchemy.engine.Connection.execution_options") parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE373]'
  prefs: []
  type: TYPE_PRE
- en: The isolation level makes use of the various “autocommit” attributes provided
    by most MySQL DBAPIs.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3332](https://www.sqlalchemy.org/trac/ticket/3332)'
  prefs: []
  type: TYPE_NORMAL
- en: '### No more generation of an implicit KEY for composite primary key w/ AUTO_INCREMENT'
  prefs: []
  type: TYPE_NORMAL
- en: 'The MySQL dialect had the behavior such that if a composite primary key on
    an InnoDB table featured AUTO_INCREMENT on one of its columns which was not the
    first column, e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE374]'
  prefs: []
  type: TYPE_PRE
- en: 'DDL such as the following would be generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE375]'
  prefs: []
  type: TYPE_PRE
- en: Note the above “KEY” with an auto-generated name; this is a change that found
    its way into the dialect many years ago in response to the issue that the AUTO_INCREMENT
    would otherwise fail on InnoDB without this additional KEY.
  prefs: []
  type: TYPE_NORMAL
- en: 'This workaround has been removed and replaced with the much better system of
    just stating the AUTO_INCREMENT column *first* within the primary key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE376]'
  prefs: []
  type: TYPE_PRE
- en: 'To maintain explicit control of the ordering of primary key columns, use the
    [`PrimaryKeyConstraint`](../core/constraints.html#sqlalchemy.schema.PrimaryKeyConstraint
    "sqlalchemy.schema.PrimaryKeyConstraint") construct explicitly (1.1.0b2) (along
    with a KEY for the autoincrement column as required by MySQL), e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE377]'
  prefs: []
  type: TYPE_PRE
- en: 'Along with the change [The .autoincrement directive is no longer implicitly
    enabled for a composite primary key column](#change-3216), composite primary keys
    with or without auto increment are now easier to specify; [`Column.autoincrement`](../core/metadata.html#sqlalchemy.schema.Column.params.autoincrement
    "sqlalchemy.schema.Column") now defaults to the value `"auto"` and the `autoincrement=False`
    directives are no longer needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE378]'
  prefs: []
  type: TYPE_PRE
- en: Dialect Improvements and Changes - SQLite
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '### Right-nested join workaround lifted for SQLite version 3.7.16'
  prefs: []
  type: TYPE_NORMAL
- en: In version 0.9, the feature introduced by [Many JOIN and LEFT OUTER JOIN expressions
    will no longer be wrapped in (SELECT * FROM ..) AS ANON_1](migration_09.html#feature-joins-09)
    went through lots of effort to support rewriting of joins on SQLite to always
    use subqueries in order to achieve a “right-nested-join” effect, as SQLite has
    not supported this syntax for many years. Ironically, the version of SQLite noted
    in that migration note, 3.7.15.2, was the *last* version of SQLite to actually
    have this limitation! The next release was 3.7.16 and support for right nested
    joins was quietly added. In 1.1, the work to identify the specific SQLite version
    and source commit where this change was made was done (SQLite’s changelog refers
    to it with the cryptic phrase “Enhance the query optimizer to exploit transitive
    join constraints” without linking to any issue number, change number, or further
    explanation), and the workarounds present in this change are now lifted for SQLite
    when the DBAPI reports that version 3.7.16 or greater is in effect.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3634](https://www.sqlalchemy.org/trac/ticket/3634)  ### Dotted column names
    workaround lifted for SQLite version 3.10.0'
  prefs: []
  type: TYPE_NORMAL
- en: The SQLite dialect has long had a workaround for an issue where the database
    driver does not report the correct column names for some SQL result sets, in particular
    when UNION is used. The workaround is detailed at [Dotted Column Names](../dialects/sqlite.html#sqlite-dotted-column-names),
    and requires that SQLAlchemy assume that any column name with a dot in it is actually
    a `tablename.columnname` combination delivered via this buggy behavior, with an
    option to turn it off via the `sqlite_raw_colnames` execution option.
  prefs: []
  type: TYPE_NORMAL
- en: As of SQLite version 3.10.0, the bug in UNION and other queries has been fixed;
    like the change described in [Right-nested join workaround lifted for SQLite version
    3.7.16](#change-3634), SQLite’s changelog only identifies it cryptically as “Added
    the colUsed field to sqlite3_index_info for use by the sqlite3_module.xBestIndex
    method”, however SQLAlchemy’s translation of these dotted column names is no longer
    required with this version, so is turned off when version 3.10.0 or greater is
    detected.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, the SQLAlchemy `ResultProxy` as of the 1.0 series relies much less
    on column names in result sets when delivering results for Core and ORM SQL constructs,
    so the importance of this issue was already lessened in any case.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3633](https://www.sqlalchemy.org/trac/ticket/3633)  ### Improved Support
    for Remote Schemas'
  prefs: []
  type: TYPE_NORMAL
- en: 'The SQLite dialect now implements [`Inspector.get_schema_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_schema_names
    "sqlalchemy.engine.reflection.Inspector.get_schema_names") and additionally has
    improved support for tables and indexes that are created and reflected from a
    remote schema, which in SQLite is a database that is assigned a name via the `ATTACH`
    statement; previously, the``CREATE INDEX`` DDL didn’t work correctly for a schema-bound
    table and the [`Inspector.get_foreign_keys()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_foreign_keys
    "sqlalchemy.engine.reflection.Inspector.get_foreign_keys") method will now indicate
    the given schema in the results. Cross-schema foreign keys aren’t supported.  ###
    Reflection of the name of PRIMARY KEY constraints'
  prefs: []
  type: TYPE_NORMAL
- en: The SQLite backend now takes advantage of the “sqlite_master” view of SQLite
    in order to extract the name of the primary key constraint of a table from the
    original DDL, in the same way that is achieved for foreign key constraints in
    recent SQLAlchemy versions.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3629](https://www.sqlalchemy.org/trac/ticket/3629)'
  prefs: []
  type: TYPE_NORMAL
- en: Check constraints now reflect
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The SQLite dialect now supports reflection of CHECK constraints both within
    the method [`Inspector.get_check_constraints()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_check_constraints
    "sqlalchemy.engine.reflection.Inspector.get_check_constraints") as well as within
    [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    reflection within the [`Table.constraints`](../core/metadata.html#sqlalchemy.schema.Table.constraints
    "sqlalchemy.schema.Table.constraints") collection.
  prefs: []
  type: TYPE_NORMAL
- en: ON DELETE and ON UPDATE foreign key phrases now reflect
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The [`Inspector`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector
    "sqlalchemy.engine.reflection.Inspector") will now include ON DELETE and ON UPDATE
    phrases from foreign key constraints on the SQLite dialect, and the [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") object as reflected as part of a [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") will also indicate these phrases.
  prefs: []
  type: TYPE_NORMAL
- en: '### Right-nested join workaround lifted for SQLite version 3.7.16'
  prefs: []
  type: TYPE_NORMAL
- en: In version 0.9, the feature introduced by [Many JOIN and LEFT OUTER JOIN expressions
    will no longer be wrapped in (SELECT * FROM ..) AS ANON_1](migration_09.html#feature-joins-09)
    went through lots of effort to support rewriting of joins on SQLite to always
    use subqueries in order to achieve a “right-nested-join” effect, as SQLite has
    not supported this syntax for many years. Ironically, the version of SQLite noted
    in that migration note, 3.7.15.2, was the *last* version of SQLite to actually
    have this limitation! The next release was 3.7.16 and support for right nested
    joins was quietly added. In 1.1, the work to identify the specific SQLite version
    and source commit where this change was made was done (SQLite’s changelog refers
    to it with the cryptic phrase “Enhance the query optimizer to exploit transitive
    join constraints” without linking to any issue number, change number, or further
    explanation), and the workarounds present in this change are now lifted for SQLite
    when the DBAPI reports that version 3.7.16 or greater is in effect.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3634](https://www.sqlalchemy.org/trac/ticket/3634)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Dotted column names workaround lifted for SQLite version 3.10.0'
  prefs: []
  type: TYPE_NORMAL
- en: The SQLite dialect has long had a workaround for an issue where the database
    driver does not report the correct column names for some SQL result sets, in particular
    when UNION is used. The workaround is detailed at [Dotted Column Names](../dialects/sqlite.html#sqlite-dotted-column-names),
    and requires that SQLAlchemy assume that any column name with a dot in it is actually
    a `tablename.columnname` combination delivered via this buggy behavior, with an
    option to turn it off via the `sqlite_raw_colnames` execution option.
  prefs: []
  type: TYPE_NORMAL
- en: As of SQLite version 3.10.0, the bug in UNION and other queries has been fixed;
    like the change described in [Right-nested join workaround lifted for SQLite version
    3.7.16](#change-3634), SQLite’s changelog only identifies it cryptically as “Added
    the colUsed field to sqlite3_index_info for use by the sqlite3_module.xBestIndex
    method”, however SQLAlchemy’s translation of these dotted column names is no longer
    required with this version, so is turned off when version 3.10.0 or greater is
    detected.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, the SQLAlchemy `ResultProxy` as of the 1.0 series relies much less
    on column names in result sets when delivering results for Core and ORM SQL constructs,
    so the importance of this issue was already lessened in any case.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3633](https://www.sqlalchemy.org/trac/ticket/3633)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Improved Support for Remote Schemas'
  prefs: []
  type: TYPE_NORMAL
- en: The SQLite dialect now implements [`Inspector.get_schema_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_schema_names
    "sqlalchemy.engine.reflection.Inspector.get_schema_names") and additionally has
    improved support for tables and indexes that are created and reflected from a
    remote schema, which in SQLite is a database that is assigned a name via the `ATTACH`
    statement; previously, the``CREATE INDEX`` DDL didn’t work correctly for a schema-bound
    table and the [`Inspector.get_foreign_keys()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_foreign_keys
    "sqlalchemy.engine.reflection.Inspector.get_foreign_keys") method will now indicate
    the given schema in the results. Cross-schema foreign keys aren’t supported.
  prefs: []
  type: TYPE_NORMAL
- en: '### Reflection of the name of PRIMARY KEY constraints'
  prefs: []
  type: TYPE_NORMAL
- en: The SQLite backend now takes advantage of the “sqlite_master” view of SQLite
    in order to extract the name of the primary key constraint of a table from the
    original DDL, in the same way that is achieved for foreign key constraints in
    recent SQLAlchemy versions.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3629](https://www.sqlalchemy.org/trac/ticket/3629)'
  prefs: []
  type: TYPE_NORMAL
- en: Check constraints now reflect
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The SQLite dialect now supports reflection of CHECK constraints both within
    the method [`Inspector.get_check_constraints()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_check_constraints
    "sqlalchemy.engine.reflection.Inspector.get_check_constraints") as well as within
    [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    reflection within the [`Table.constraints`](../core/metadata.html#sqlalchemy.schema.Table.constraints
    "sqlalchemy.schema.Table.constraints") collection.
  prefs: []
  type: TYPE_NORMAL
- en: ON DELETE and ON UPDATE foreign key phrases now reflect
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The [`Inspector`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector
    "sqlalchemy.engine.reflection.Inspector") will now include ON DELETE and ON UPDATE
    phrases from foreign key constraints on the SQLite dialect, and the [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") object as reflected as part of a [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") will also indicate these phrases.
  prefs: []
  type: TYPE_NORMAL
- en: Dialect Improvements and Changes - SQL Server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '### Added transaction isolation level support for SQL Server'
  prefs: []
  type: TYPE_NORMAL
- en: 'All SQL Server dialects support transaction isolation level settings via the
    [`create_engine.isolation_level`](../core/engines.html#sqlalchemy.create_engine.params.isolation_level
    "sqlalchemy.create_engine") and [`Connection.execution_options.isolation_level`](../core/connections.html#sqlalchemy.engine.Connection.execution_options.params.isolation_level
    "sqlalchemy.engine.Connection.execution_options") parameters. The four standard
    levels are supported as well as `SNAPSHOT`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE379]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Transaction Isolation Level](../dialects/mssql.html#mssql-isolation-level)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#3534](https://www.sqlalchemy.org/trac/ticket/3534)  ### String / varlength
    types no longer represent “max” explicitly on reflection'
  prefs: []
  type: TYPE_NORMAL
- en: 'When reflecting a type such as [`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String"), [`TextClause`](../core/sqlelement.html#sqlalchemy.sql.expression.TextClause
    "sqlalchemy.sql.expression.TextClause"), etc. which includes a length, an “un-lengthed”
    type under SQL Server would copy the “length” parameter as the value `"max"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE380]'
  prefs: []
  type: TYPE_PRE
- en: 'The “length” parameter in the base types is expected to be an integer value
    or None only; None indicates unbounded length which the SQL Server dialect interprets
    as “max”. The fix then is so that these lengths come out as None, so that the
    type objects work in non-SQL Server contexts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE381]'
  prefs: []
  type: TYPE_PRE
- en: Applications which may have been relying on a direct comparison of the “length”
    value to the string “max” should consider the value of `None` to mean the same
    thing.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3504](https://www.sqlalchemy.org/trac/ticket/3504)'
  prefs: []
  type: TYPE_NORMAL
- en: Support for “non clustered” on primary key to allow clustered elsewhere
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `mssql_clustered` flag available on [`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint"), [`PrimaryKeyConstraint`](../core/constraints.html#sqlalchemy.schema.PrimaryKeyConstraint
    "sqlalchemy.schema.PrimaryKeyConstraint"), [`Index`](../core/constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index") now defaults to `None`, and can be set to False which
    will render the NONCLUSTERED keyword in particular for a primary key, allowing
    a different index to be used as “clustered”.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Clustered Index Support](../dialects/mssql.html#mssql-indexes)'
  prefs: []
  type: TYPE_NORMAL
- en: '### The legacy_schema_aliasing flag is now set to False'
  prefs: []
  type: TYPE_NORMAL
- en: 'SQLAlchemy 1.0.5 introduced the `legacy_schema_aliasing` flag to the MSSQL
    dialect, allowing so-called “legacy mode” aliasing to be turned off. This aliasing
    attempts to turn schema-qualified tables into aliases; given a table such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE382]'
  prefs: []
  type: TYPE_PRE
- en: 'The legacy mode of behavior will attempt to turn a schema-qualified table name
    into an alias:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE383]'
  prefs: []
  type: TYPE_PRE
- en: However, this aliasing has been shown to be unnecessary and in many cases produces
    incorrect SQL.
  prefs: []
  type: TYPE_NORMAL
- en: In SQLAlchemy 1.1, the `legacy_schema_aliasing` flag now defaults to False,
    disabling this mode of behavior and allowing the MSSQL dialect to behave normally
    with schema-qualified tables. For applications which may rely on this behavior,
    set the flag back to True.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3434](https://www.sqlalchemy.org/trac/ticket/3434)  ### Added transaction
    isolation level support for SQL Server'
  prefs: []
  type: TYPE_NORMAL
- en: 'All SQL Server dialects support transaction isolation level settings via the
    [`create_engine.isolation_level`](../core/engines.html#sqlalchemy.create_engine.params.isolation_level
    "sqlalchemy.create_engine") and [`Connection.execution_options.isolation_level`](../core/connections.html#sqlalchemy.engine.Connection.execution_options.params.isolation_level
    "sqlalchemy.engine.Connection.execution_options") parameters. The four standard
    levels are supported as well as `SNAPSHOT`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE384]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Transaction Isolation Level](../dialects/mssql.html#mssql-isolation-level)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#3534](https://www.sqlalchemy.org/trac/ticket/3534)'
  prefs: []
  type: TYPE_NORMAL
- en: '### String / varlength types no longer represent “max” explicitly on reflection'
  prefs: []
  type: TYPE_NORMAL
- en: 'When reflecting a type such as [`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String"), [`TextClause`](../core/sqlelement.html#sqlalchemy.sql.expression.TextClause
    "sqlalchemy.sql.expression.TextClause"), etc. which includes a length, an “un-lengthed”
    type under SQL Server would copy the “length” parameter as the value `"max"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE385]'
  prefs: []
  type: TYPE_PRE
- en: 'The “length” parameter in the base types is expected to be an integer value
    or None only; None indicates unbounded length which the SQL Server dialect interprets
    as “max”. The fix then is so that these lengths come out as None, so that the
    type objects work in non-SQL Server contexts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE386]'
  prefs: []
  type: TYPE_PRE
- en: Applications which may have been relying on a direct comparison of the “length”
    value to the string “max” should consider the value of `None` to mean the same
    thing.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3504](https://www.sqlalchemy.org/trac/ticket/3504)'
  prefs: []
  type: TYPE_NORMAL
- en: Support for “non clustered” on primary key to allow clustered elsewhere
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `mssql_clustered` flag available on [`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint"), [`PrimaryKeyConstraint`](../core/constraints.html#sqlalchemy.schema.PrimaryKeyConstraint
    "sqlalchemy.schema.PrimaryKeyConstraint"), [`Index`](../core/constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index") now defaults to `None`, and can be set to False which
    will render the NONCLUSTERED keyword in particular for a primary key, allowing
    a different index to be used as “clustered”.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Clustered Index Support](../dialects/mssql.html#mssql-indexes)'
  prefs: []
  type: TYPE_NORMAL
- en: '### The legacy_schema_aliasing flag is now set to False'
  prefs: []
  type: TYPE_NORMAL
- en: 'SQLAlchemy 1.0.5 introduced the `legacy_schema_aliasing` flag to the MSSQL
    dialect, allowing so-called “legacy mode” aliasing to be turned off. This aliasing
    attempts to turn schema-qualified tables into aliases; given a table such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE387]'
  prefs: []
  type: TYPE_PRE
- en: 'The legacy mode of behavior will attempt to turn a schema-qualified table name
    into an alias:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE388]'
  prefs: []
  type: TYPE_PRE
- en: However, this aliasing has been shown to be unnecessary and in many cases produces
    incorrect SQL.
  prefs: []
  type: TYPE_NORMAL
- en: In SQLAlchemy 1.1, the `legacy_schema_aliasing` flag now defaults to False,
    disabling this mode of behavior and allowing the MSSQL dialect to behave normally
    with schema-qualified tables. For applications which may rely on this behavior,
    set the flag back to True.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3434](https://www.sqlalchemy.org/trac/ticket/3434)'
  prefs: []
  type: TYPE_NORMAL
- en: Dialect Improvements and Changes - Oracle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Support for SKIP LOCKED
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The new parameter [`GenerativeSelect.with_for_update.skip_locked`](../core/selectable.html#sqlalchemy.sql.expression.GenerativeSelect.with_for_update.params.skip_locked
    "sqlalchemy.sql.expression.GenerativeSelect.with_for_update") in both Core and
    ORM will generate the “SKIP LOCKED” suffix for a “SELECT…FOR UPDATE” or “SELECT..
    FOR SHARE” query.
  prefs: []
  type: TYPE_NORMAL
- en: Support for SKIP LOCKED
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The new parameter [`GenerativeSelect.with_for_update.skip_locked`](../core/selectable.html#sqlalchemy.sql.expression.GenerativeSelect.with_for_update.params.skip_locked
    "sqlalchemy.sql.expression.GenerativeSelect.with_for_update") in both Core and
    ORM will generate the “SKIP LOCKED” suffix for a “SELECT…FOR UPDATE” or “SELECT..
    FOR SHARE” query.
  prefs: []
  type: TYPE_NORMAL
