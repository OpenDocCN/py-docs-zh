["```py\nq = (\n    session.query(User)\n    .filter(User.name.like(\"%ed%\"))\n    .options(subqueryload(User.addresses))\n)\n```", "```py\nSELECT  users.id  AS  users_id,  users.name  AS  users_name\nFROM  users\nWHERE  users.name  LIKE  ?\n('%ed%',)\n\nSELECT  addresses.id  AS  addresses_id,\n  addresses.user_id  AS  addresses_user_id,\n  addresses.email_address  AS  addresses_email_address,\n  anon_1.users_id  AS  anon_1_users_id\nFROM  (SELECT  users.id  AS  users_id\nFROM  users\nWHERE  users.name  LIKE  ?)  AS  anon_1\nJOIN  addresses  ON  anon_1.users_id  =  addresses.user_id\nORDER  BY  anon_1.users_id\n('%ed%',)\n```", "```py\nq = (\n    session.query(User)\n    .filter(User.name.like(\"%ed%\"))\n    .options(selectinload(User.addresses))\n)\n```", "```py\nSELECT  users.id  AS  users_id,  users.name  AS  users_name\nFROM  users\nWHERE  users.name  LIKE  ?\n('%ed%',)\n\nSELECT  users_1.id  AS  users_1_id,\n  addresses.id  AS  addresses_id,\n  addresses.user_id  AS  addresses_user_id,\n  addresses.email_address  AS  addresses_email_address\nFROM  users  AS  users_1\nJOIN  addresses  ON  users_1.id  =  addresses.user_id\nWHERE  users_1.id  IN  (?,  ?)\nORDER  BY  users_1.id\n(1,  3)\n```", "```py\n>>> from sqlalchemy.orm import selectin_polymorphic\n\n>>> query = session.query(Employee).options(\n...     selectin_polymorphic(Employee, [Manager, Engineer])\n... )\n\n>>> query.all()\nSELECT\n  employee.id  AS  employee_id,\n  employee.name  AS  employee_name,\n  employee.type  AS  employee_type\nFROM  employee\n()\n\nSELECT\n  engineer.id  AS  engineer_id,\n  employee.id  AS  employee_id,\n  employee.type  AS  employee_type,\n  engineer.engineer_name  AS  engineer_engineer_name\nFROM  employee  JOIN  engineer  ON  employee.id  =  engineer.id\nWHERE  employee.id  IN  (?,  ?)  ORDER  BY  employee.id\n(1,  2)\n\nSELECT\n  manager.id  AS  manager_id,\n  employee.id  AS  employee_id,\n  employee.type  AS  employee_type,\n  manager.manager_name  AS  manager_manager_name\nFROM  employee  JOIN  manager  ON  employee.id  =  manager.id\nWHERE  employee.id  IN  (?)  ORDER  BY  employee.id\n(3,) \n```", "```py\nfrom sqlalchemy.orm import query_expression\nfrom sqlalchemy.orm import with_expression\n\nclass A(Base):\n    __tablename__ = \"a\"\n    id = Column(Integer, primary_key=True)\n    x = Column(Integer)\n    y = Column(Integer)\n\n    # will be None normally...\n    expr = query_expression()\n\n# but let's give it x + y\na1 = session.query(A).options(with_expression(A.expr, A.x + A.y)).first()\nprint(a1.expr)\n```", "```py\nquery(SomeEntity).filter(SomeEntity.id == SomeOtherEntity.id).filter(\n    SomeOtherEntity.foo == \"bar\"\n).delete()\n```", "```py\nclass Person(Base):\n    # ...\n\n    first_name = Column(String(10))\n    last_name = Column(String(10))\n\n    @hybrid.hybrid_property\n    def name(self):\n        return self.first_name + \" \" + self.last_name\n\n    @name.expression\n    def name(cls):\n        return func.concat(cls.first_name, \" \", cls.last_name)\n\n    @name.update_expression\n    def name(cls, value):\n        f, l = value.split(\" \", 1)\n        return [(cls.first_name, f), (cls.last_name, l)]\n```", "```py\nsession.query(Person).filter(Person.id == 5).update({Person.name: \"Dr. No\"})\n```", "```py\nsession.query(Vertex).update({Edge.start: Point(3, 4)})\n```", "```py\nclass FirstNameOnly(Base):\n    # ...\n\n    first_name = Column(String)\n\n    @hybrid_property\n    def name(self):\n        return self.first_name\n\n    @name.setter\n    def name(self, value):\n        self.first_name = value\n\nclass FirstNameLastName(FirstNameOnly):\n    # ...\n\n    last_name = Column(String)\n\n    @FirstNameOnly.name.getter\n    def name(self):\n        return self.first_name + \" \" + self.last_name\n\n    @name.setter\n    def name(self, value):\n        self.first_name, self.last_name = value.split(\" \", maxsplit=1)\n\n    @name.expression\n    def name(cls):\n        return func.concat(cls.first_name, \" \", cls.last_name)\n```", "```py\nclass FirstNameOnly(Base):\n    @hybrid_property\n    def name(self):\n        return self.first_name\n\n    # WRONG - will raise AttributeError: can't set attribute when\n    # assigning to .name\n    @name.setter\n    def _set_name(self, value):\n        self.first_name = value\n\nclass FirstNameOnly(Base):\n    @hybrid_property\n    def name(self):\n        return self.first_name\n\n    # CORRECT - note regular Python @property works the same way\n    @name.setter\n    def name(self, value):\n        self.first_name = value\n```", "```py\nfrom sqlalchemy.orm.attributes import OP_BULK_REPLACE\n\n@event.listens_for(SomeObject.collection, \"bulk_replace\")\ndef process_collection(target, values, initiator):\n    values[:] = [_make_value(value) for value in values]\n\n@event.listens_for(SomeObject.collection, \"append\", retval=True)\ndef process_collection(target, value, initiator):\n    # make sure bulk_replace didn't already do it\n    if initiator is None or initiator.op is not OP_BULK_REPLACE:\n        return _make_value(value)\n    else:\n        return value\n```", "```py\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.ext.mutable import MutableDict\nfrom sqlalchemy import event\n\nBase = declarative_base()\n\nclass MyDataClass(Base):\n    __tablename__ = \"my_data\"\n    id = Column(Integer, primary_key=True)\n    data = Column(MutableDict.as_mutable(JSONEncodedDict))\n\n@event.listens_for(MyDataClass.data, \"modified\")\ndef modified_json(instance):\n    print(\"json value modified:\", instance.data)\n```", "```py\nsession.refresh(some_object, with_for_update=True)\n```", "```py\nsession.refresh(some_objects, with_for_update={\"read\": True})\n```", "```py\nmodel = session.query(MyModel).first()\nmodel.json_set &= {1, 3}\n```", "```py\nclass A(Base):\n    __tablename__ = \"a\"\n    id = Column(Integer, primary_key=True)\n\n    b_values = association_proxy(\"atob\", \"b_value\")\n    c_values = association_proxy(\"atob\", \"c_value\")\n\nclass B(Base):\n    __tablename__ = \"b\"\n    id = Column(Integer, primary_key=True)\n    a_id = Column(ForeignKey(\"a.id\"))\n    value = Column(String)\n\n    c = relationship(\"C\")\n\nclass C(Base):\n    __tablename__ = \"c\"\n    id = Column(Integer, primary_key=True)\n    b_id = Column(ForeignKey(\"b.id\"))\n    value = Column(String)\n\nclass AtoB(Base):\n    __tablename__ = \"atob\"\n\n    a_id = Column(ForeignKey(\"a.id\"), primary_key=True)\n    b_id = Column(ForeignKey(\"b.id\"), primary_key=True)\n\n    a = relationship(\"A\", backref=\"atob\")\n    b = relationship(\"B\", backref=\"atob\")\n\n    b_value = association_proxy(\"b\", \"value\")\n    c_value = association_proxy(\"b\", \"c\")\n```", "```py\n>>> s.query(A).filter(A.b_values.contains(\"hi\")).all()\nSELECT  a.id  AS  a_id\nFROM  a\nWHERE  EXISTS  (SELECT  1\nFROM  atob\nWHERE  a.id  =  atob.a_id  AND  (EXISTS  (SELECT  1\nFROM  b\nWHERE  b.id  =  atob.b_id  AND  b.value  =  :value_1))) \n```", "```py\n>>> s.query(A).filter(A.c_values.any(value=\"x\")).all()\nSELECT  a.id  AS  a_id\nFROM  a\nWHERE  EXISTS  (SELECT  1\nFROM  atob\nWHERE  a.id  =  atob.a_id  AND  (EXISTS  (SELECT  1\nFROM  b\nWHERE  b.id  =  atob.b_id  AND  (EXISTS  (SELECT  1\nFROM  c\nWHERE  b.id  =  c.b_id  AND  c.value  =  :value_1))))) \n```", "```py\ntokyo = WeatherLocation(\"Asia\", \"Tokyo\")\nnewyork = WeatherLocation(\"North America\", \"New York\")\n\ntokyo.reports.append(Report(80.0))\nnewyork.reports.append(Report(75))\n\nsess = create_session()\n\nsess.add_all([tokyo, newyork, quito])\n\nsess.commit()\n\n# the Report class uses a simple integer primary key.  So across two\n# databases, a primary key will be repeated.  The \"identity_token\" tracks\n# in memory that these two identical primary keys are local to different\n# databases.\n\nnewyork_report = newyork.reports[0]\ntokyo_report = tokyo.reports[0]\n\nassert inspect(newyork_report).identity_key == (Report, (1,), \"north_america\")\nassert inspect(tokyo_report).identity_key == (Report, (1,), \"asia\")\n\n# the token representing the originating shard is also available directly\n\nassert inspect(newyork_report).identity_token == \"north_america\"\nassert inspect(tokyo_report).identity_token == \"asia\"\n```", "```py\nfrom sqlalchemy import Boolean\nfrom sqlalchemy import TypeDecorator\n\nclass LiberalBoolean(TypeDecorator):\n    impl = Boolean\n\n    def process_bind_param(self, value, dialect):\n        if value is not None:\n            value = bool(int(value))\n        return value\n```", "```py\nengine = create_engine(\"mysql+pymysql://\", pool_pre_ping=True)\n```", "```py\nmycolumn  IN  ()\n```", "```py\nSELECT  NULL  IN  (SELECT  1  WHERE  1  !=  1)\n```", "```py\nstmt = select([table]).where(table.c.col.in_(bindparam(\"foo\", expanding=True)))\nconn.execute(stmt, {\"foo\": [1, 2, 3]})\n```", "```py\n(column(\"q\") == null()) != (column(\"y\") == null())\n```", "```py\nTable(\n    \"my_table\",\n    metadata,\n    Column(\"q\", Integer, comment=\"the Q value\"),\n    comment=\"my Q table\",\n)\n```", "```py\nstmt = (\n    users.delete()\n    .where(users.c.id == addresses.c.id)\n    .where(addresses.c.email_address.startswith(\"ed%\"))\n)\nconn.execute(stmt)\n```", "```py\nDELETE  FROM  users  USING  addresses\nWHERE  users.id  =  addresses.id\nAND  (addresses.email_address  LIKE  %(email_address_1)s  ||  '%%')\n```", "```py\n>>> column(\"x\").startswith(\"total%score\", autoescape=True)\n```", "```py\nx  LIKE  :x_1  ||  '%'  ESCAPE  '/'\n```", "```py\n>>> column(\"x\").startswith(\"total/score\", autoescape=True)\n```", "```py\n    float_value = connection.scalar(\n        select([literal(4.56)])  # the \"BindParameter\" will now be\n        # Float, not Numeric(asdecimal=True)\n    )\n    ```", "```py\n    # asdecimal flag is maintained\n    expr = column(\"a\", Integer) * column(\"b\", Numeric(asdecimal=False))\n    assert expr.type.asdecimal == False\n\n    # Float subclass of Numeric is maintained\n    expr = column(\"a\", Integer) * column(\"b\", Float())\n    assert isinstance(expr.type, Float)\n    ```", "```py\n>>> from sqlalchemy import select, table, column, func, tuple_\n>>> t = table(\"t\", column(\"value\"), column(\"x\"), column(\"y\"), column(\"z\"), column(\"q\"))\n>>> stmt = select([func.sum(t.c.value)]).group_by(\n...     func.grouping_sets(\n...         tuple_(t.c.x, t.c.y),\n...         tuple_(t.c.z, t.c.q),\n...     )\n... )\n>>> print(stmt)\nSELECT  sum(t.value)  AS  sum_1\nFROM  t  GROUP  BY  GROUPING  SETS((t.x,  t.y),  (t.z,  t.q)) \n```", "```py\ndef mydefault(context):\n    return context.get_current_parameters()[\"counter\"] + 12\n\nmytable = Table(\n    \"mytable\",\n    metadata_obj,\n    Column(\"counter\", Integer),\n    Column(\"counter_plus_twelve\", Integer, default=mydefault, onupdate=mydefault),\n)\n\nstmt = mytable.insert().values([{\"counter\": 5}, {\"counter\": 18}, {\"counter\": 20}])\n\nconn.execute(stmt)\n```", "```py\nsess = Session()\n\nuser = sess.query(User).filter_by(name=\"x\").first()\n\n@event.listens_for(sess, \"after_rollback\")\ndef after_rollback(session):\n    # 'user.name' is now present, assuming it was already\n    # loaded.  previously this would raise upon trying\n    # to emit a lazy load.\n    print(\"user name: %s\" % user.name)\n\n@event.listens_for(sess, \"after_commit\")\ndef after_commit(session):\n    # 'user.name' is present, assuming it was already\n    # loaded.  this is the existing behavior.\n    print(\"user name: %s\" % user.name)\n\nif should_rollback:\n    sess.rollback()\nelse:\n    sess.commit()\n```", "```py\nsess.query(Manager.id)\n```", "```py\nSELECT  employee.id  FROM  employee  WHERE  employee.type  IN  ('manager')\n```", "```py\nsess.query(func.count(1)).select_from(Manager)\n```", "```py\nSELECT  count(1)  FROM  employee\n```", "```py\nSELECT  count(1)  FROM  employee  WHERE  employee.type  IN  ('manager')\n```", "```py\n>>> a1, a2, a3 = Address(\"a1\"), Address(\"a2\"), Address(\"a3\")\n>>> user.addresses = [a1, a2]\n\n>>> previous_collection = user.addresses\n\n# replace the collection with a new one\n>>> user.addresses = [a2, a3]\n\n>>> previous_collection\n[Address('a1'), Address('a2')]\n```", "```py\nclass A(Base):\n    __tablename__ = \"a\"\n    id = Column(Integer, primary_key=True)\n    bs = relationship(\"B\")\n\n    @validates(\"bs\")\n    def convert_dict_to_b(self, key, value):\n        return B(data=value[\"data\"])\n\nclass B(Base):\n    __tablename__ = \"b\"\n    id = Column(Integer, primary_key=True)\n    a_id = Column(ForeignKey(\"a.id\"))\n    data = Column(String)\n```", "```py\na1 = A()\na1.bs.append({\"data\": \"b1\"})\n```", "```py\na1 = A()\na1.bs = [{\"data\": \"b1\"}]\n```", "```py\nclass A(Base):\n    # ...\n\n    @validates(\"bs\")\n    def validate_b(self, key, value):\n        assert value.data is not None\n        return value\n```", "```py\na1 = A()\n\nb1, b2 = B(data=\"one\"), B(data=\"two\")\na1.bs = [b1, b2]\n```", "```py\nb3 = B(data=\"three\")\na1.bs = [b2, b3]\n```", "```py\na1 = A(data=\"adf\")\ns.add(a1)\n\ns.flush()\n\n# expire, similarly as though we said s.commit()\ns.expire(a1, \"data\")\n\n# will raise InvalidRequestError\nattributes.flag_modified(a1, \"data\")\n```", "```py\nfrom sqlalchemy.orm import attributes\n\nattributes.flag_dirty(a1)\n```", "```py\nfrom sqlalchemy.orm import scoped_session\n\nSession = scoped_session(sessionmaker())\n\nsession = Session(scope=None)\n```", "```py\nclass A(Base):\n    __tablename__ = \"a\"\n    id = Column(Integer, primary_key=True)\n    favorite_b_id = Column(ForeignKey(\"b.id\", name=\"favorite_b_fk\"))\n    bs = relationship(\"B\", primaryjoin=\"A.id == B.a_id\")\n    favorite_b = relationship(\n        \"B\", primaryjoin=\"A.favorite_b_id == B.id\", post_update=True\n    )\n    updated = Column(Integer, onupdate=my_onupdate_function)\n\nclass B(Base):\n    __tablename__ = \"b\"\n    id = Column(Integer, primary_key=True)\n    a_id = Column(ForeignKey(\"a.id\", name=\"a_fk\"))\n\na1 = A()\nb1 = B()\n\na1.bs.append(b1)\na1.favorite_b = b1\na1.updated = 5\ns.add(a1)\ns.flush()\n```", "```py\nINSERT  INTO  a  (favorite_b_id,  updated)  VALUES  (?,  ?)\n(None,  5)\nINSERT  INTO  b  (a_id)  VALUES  (?)\n(1,)\nUPDATE  a  SET  favorite_b_id=?,  updated=?  WHERE  a.id  =  ?\n(1,  5,  1)\n```", "```py\nclass Node(Base):\n    __tablename__ = \"node\"\n    id = Column(Integer, primary_key=True)\n    version_id = Column(Integer, default=0)\n    parent_id = Column(ForeignKey(\"node.id\"))\n    favorite_node_id = Column(ForeignKey(\"node.id\"))\n\n    nodes = relationship(\"Node\", primaryjoin=remote(parent_id) == id)\n    favorite_node = relationship(\n        \"Node\", primaryjoin=favorite_node_id == remote(id), post_update=True\n    )\n\n    __mapper_args__ = {\"version_id_col\": version_id}\n```", "```py\nnode = Node()\nsession.add(node)\nsession.commit()  # node is now version #1\n\nnode = session.query(Node).get(node.id)\nnode.favorite_node = Node()\nsession.commit()  # node is now version #2\n```", "```py\n>>> column(\"x\", types.DateTime).op(\"-%>\")(None).type\nNullType()\n```", "```py\n>>> column(\"x\", types.String(50)).op(\"-%>\")(None).type\nString(length=50)\n```", "```py\n>>> column(\"x\", types.DateTime).op(\"-%>\")(None).type\nDateTime()\n```", "```py\n>>> column(\"x\", types.String(50)).op(\"-%>\", is_comparison=True)(None).type\nBoolean()\n>>> column(\"x\", types.ARRAY(types.Integer)).op(\"-%>\", is_comparison=True)(None).type\nBoolean()\n>>> column(\"x\", types.JSON()).op(\"-%>\", is_comparison=True)(None).type\nBoolean()\n```", "```py\n>>> print(column(\"x\", types.Integer).bool_op(\"-%>\")(5))\nx  -%>  :x_1 \n```", "```py\n>>> from sqlalchemy import literal_column\n>>> print(literal_column(\"some%symbol\"))\nsome%%symbol \n```", "```py\n>>> from sqlalchemy import literal_column\n>>> print(literal_column(\"some%symbol\"))\nsome%symbol\n>>> from sqlalchemy.dialects import mysql\n>>> print(literal_column(\"some%symbol\").compile(dialect=mysql.dialect()))\nsome%%symbol \n```", "```py\nstmt = select([mytable.c.x, mytable.c.y]).order_by(\n    mytable.c.somecolumn.collate(\"fr_FR\")\n)\n```", "```py\nSELECT  mytable.x,  mytable.y,\nFROM  mytable  ORDER  BY  mytable.somecolumn  COLLATE  \"fr_FR\"\n```", "```py\nengine = create_engine(\n    \"postgresql+psycopg2://scott:tiger@host/dbname\", use_batch_mode=True\n)\n```", "```py\nfrom sqlalchemy.dialects.postgresql import INTERVAL\n\nTable(\"my_table\", metadata, Column(\"some_interval\", INTERVAL(fields=\"DAY TO SECOND\")))\n```", "```py\n>>> inspect(engine).get_columns(\"my_table\")\n[{'comment': None,\n 'name': u'some_interval', 'nullable': True,\n 'default': None, 'autoincrement': False,\n 'type': INTERVAL(fields=u'day to second')}]\n```", "```py\nfrom sqlalchemy.dialects.mysql import insert\n\ninsert_stmt = insert(my_table).values(id=\"some_id\", data=\"some data to insert\")\n\non_conflict_stmt = insert_stmt.on_duplicate_key_update(\n    data=insert_stmt.inserted.data, status=\"U\"\n)\n\nconn.execute(on_conflict_stmt)\n```", "```py\nINSERT  INTO  my_table  (id,  data)\nVALUES  (:id,  :data)\nON  DUPLICATE  KEY  UPDATE  data=VALUES(data),  status=:status_1\n```", "```py\n    result = conn.execute(table.insert().values(x=5).returning(table.c.a, table.c.b))\n    ```", "```py\n>>> insp.get_indexes(\"addresses\")\n[{'unique': False, 'column_names': [u'user_id'],\n 'name': u'address_idx', 'dialect_options': {}}]\n\n>>> insp.get_pk_constraint(\"addresses\")\n{'name': u'pk_cons', 'constrained_columns': [u'id']}\n\n>>> insp.get_foreign_keys(\"addresses\")\n[{'referred_table': u'users', 'referred_columns': [u'id'],\n 'referred_schema': None, 'name': u'user_id_fk',\n 'constrained_columns': [u'user_id']}]\n```", "```py\n[\n    {\n        \"referred_table\": \"users\",\n        \"referred_columns\": [\"id\"],\n        \"referred_schema\": None,\n        \"name\": \"USER_ID_FK\",\n        \"constrained_columns\": [\"user_id\"],\n    }\n]\n```", "```py\nTable(\"some_table\", metadata, Column(\"q\", String(50)), schema=\"[MyDataBase.dbo]\")\n```", "```py\nTable(\n    \"some_table\",\n    metadata,\n    Column(\"q\", String(50)),\n    schema=\"[MyDataBase.SomeDB].[MyDB.owner]\",\n)\n```", "```py\nq = (\n    session.query(User)\n    .filter(User.name.like(\"%ed%\"))\n    .options(subqueryload(User.addresses))\n)\n```", "```py\nSELECT  users.id  AS  users_id,  users.name  AS  users_name\nFROM  users\nWHERE  users.name  LIKE  ?\n('%ed%',)\n\nSELECT  addresses.id  AS  addresses_id,\n  addresses.user_id  AS  addresses_user_id,\n  addresses.email_address  AS  addresses_email_address,\n  anon_1.users_id  AS  anon_1_users_id\nFROM  (SELECT  users.id  AS  users_id\nFROM  users\nWHERE  users.name  LIKE  ?)  AS  anon_1\nJOIN  addresses  ON  anon_1.users_id  =  addresses.user_id\nORDER  BY  anon_1.users_id\n('%ed%',)\n```", "```py\nq = (\n    session.query(User)\n    .filter(User.name.like(\"%ed%\"))\n    .options(selectinload(User.addresses))\n)\n```", "```py\nSELECT  users.id  AS  users_id,  users.name  AS  users_name\nFROM  users\nWHERE  users.name  LIKE  ?\n('%ed%',)\n\nSELECT  users_1.id  AS  users_1_id,\n  addresses.id  AS  addresses_id,\n  addresses.user_id  AS  addresses_user_id,\n  addresses.email_address  AS  addresses_email_address\nFROM  users  AS  users_1\nJOIN  addresses  ON  users_1.id  =  addresses.user_id\nWHERE  users_1.id  IN  (?,  ?)\nORDER  BY  users_1.id\n(1,  3)\n```", "```py\n>>> from sqlalchemy.orm import selectin_polymorphic\n\n>>> query = session.query(Employee).options(\n...     selectin_polymorphic(Employee, [Manager, Engineer])\n... )\n\n>>> query.all()\nSELECT\n  employee.id  AS  employee_id,\n  employee.name  AS  employee_name,\n  employee.type  AS  employee_type\nFROM  employee\n()\n\nSELECT\n  engineer.id  AS  engineer_id,\n  employee.id  AS  employee_id,\n  employee.type  AS  employee_type,\n  engineer.engineer_name  AS  engineer_engineer_name\nFROM  employee  JOIN  engineer  ON  employee.id  =  engineer.id\nWHERE  employee.id  IN  (?,  ?)  ORDER  BY  employee.id\n(1,  2)\n\nSELECT\n  manager.id  AS  manager_id,\n  employee.id  AS  employee_id,\n  employee.type  AS  employee_type,\n  manager.manager_name  AS  manager_manager_name\nFROM  employee  JOIN  manager  ON  employee.id  =  manager.id\nWHERE  employee.id  IN  (?)  ORDER  BY  employee.id\n(3,) \n```", "```py\nfrom sqlalchemy.orm import query_expression\nfrom sqlalchemy.orm import with_expression\n\nclass A(Base):\n    __tablename__ = \"a\"\n    id = Column(Integer, primary_key=True)\n    x = Column(Integer)\n    y = Column(Integer)\n\n    # will be None normally...\n    expr = query_expression()\n\n# but let's give it x + y\na1 = session.query(A).options(with_expression(A.expr, A.x + A.y)).first()\nprint(a1.expr)\n```", "```py\nquery(SomeEntity).filter(SomeEntity.id == SomeOtherEntity.id).filter(\n    SomeOtherEntity.foo == \"bar\"\n).delete()\n```", "```py\nclass Person(Base):\n    # ...\n\n    first_name = Column(String(10))\n    last_name = Column(String(10))\n\n    @hybrid.hybrid_property\n    def name(self):\n        return self.first_name + \" \" + self.last_name\n\n    @name.expression\n    def name(cls):\n        return func.concat(cls.first_name, \" \", cls.last_name)\n\n    @name.update_expression\n    def name(cls, value):\n        f, l = value.split(\" \", 1)\n        return [(cls.first_name, f), (cls.last_name, l)]\n```", "```py\nsession.query(Person).filter(Person.id == 5).update({Person.name: \"Dr. No\"})\n```", "```py\nsession.query(Vertex).update({Edge.start: Point(3, 4)})\n```", "```py\nclass FirstNameOnly(Base):\n    # ...\n\n    first_name = Column(String)\n\n    @hybrid_property\n    def name(self):\n        return self.first_name\n\n    @name.setter\n    def name(self, value):\n        self.first_name = value\n\nclass FirstNameLastName(FirstNameOnly):\n    # ...\n\n    last_name = Column(String)\n\n    @FirstNameOnly.name.getter\n    def name(self):\n        return self.first_name + \" \" + self.last_name\n\n    @name.setter\n    def name(self, value):\n        self.first_name, self.last_name = value.split(\" \", maxsplit=1)\n\n    @name.expression\n    def name(cls):\n        return func.concat(cls.first_name, \" \", cls.last_name)\n```", "```py\nclass FirstNameOnly(Base):\n    @hybrid_property\n    def name(self):\n        return self.first_name\n\n    # WRONG - will raise AttributeError: can't set attribute when\n    # assigning to .name\n    @name.setter\n    def _set_name(self, value):\n        self.first_name = value\n\nclass FirstNameOnly(Base):\n    @hybrid_property\n    def name(self):\n        return self.first_name\n\n    # CORRECT - note regular Python @property works the same way\n    @name.setter\n    def name(self, value):\n        self.first_name = value\n```", "```py\nfrom sqlalchemy.orm.attributes import OP_BULK_REPLACE\n\n@event.listens_for(SomeObject.collection, \"bulk_replace\")\ndef process_collection(target, values, initiator):\n    values[:] = [_make_value(value) for value in values]\n\n@event.listens_for(SomeObject.collection, \"append\", retval=True)\ndef process_collection(target, value, initiator):\n    # make sure bulk_replace didn't already do it\n    if initiator is None or initiator.op is not OP_BULK_REPLACE:\n        return _make_value(value)\n    else:\n        return value\n```", "```py\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.ext.mutable import MutableDict\nfrom sqlalchemy import event\n\nBase = declarative_base()\n\nclass MyDataClass(Base):\n    __tablename__ = \"my_data\"\n    id = Column(Integer, primary_key=True)\n    data = Column(MutableDict.as_mutable(JSONEncodedDict))\n\n@event.listens_for(MyDataClass.data, \"modified\")\ndef modified_json(instance):\n    print(\"json value modified:\", instance.data)\n```", "```py\nsession.refresh(some_object, with_for_update=True)\n```", "```py\nsession.refresh(some_objects, with_for_update={\"read\": True})\n```", "```py\nmodel = session.query(MyModel).first()\nmodel.json_set &= {1, 3}\n```", "```py\nclass A(Base):\n    __tablename__ = \"a\"\n    id = Column(Integer, primary_key=True)\n\n    b_values = association_proxy(\"atob\", \"b_value\")\n    c_values = association_proxy(\"atob\", \"c_value\")\n\nclass B(Base):\n    __tablename__ = \"b\"\n    id = Column(Integer, primary_key=True)\n    a_id = Column(ForeignKey(\"a.id\"))\n    value = Column(String)\n\n    c = relationship(\"C\")\n\nclass C(Base):\n    __tablename__ = \"c\"\n    id = Column(Integer, primary_key=True)\n    b_id = Column(ForeignKey(\"b.id\"))\n    value = Column(String)\n\nclass AtoB(Base):\n    __tablename__ = \"atob\"\n\n    a_id = Column(ForeignKey(\"a.id\"), primary_key=True)\n    b_id = Column(ForeignKey(\"b.id\"), primary_key=True)\n\n    a = relationship(\"A\", backref=\"atob\")\n    b = relationship(\"B\", backref=\"atob\")\n\n    b_value = association_proxy(\"b\", \"value\")\n    c_value = association_proxy(\"b\", \"c\")\n```", "```py\n>>> s.query(A).filter(A.b_values.contains(\"hi\")).all()\nSELECT  a.id  AS  a_id\nFROM  a\nWHERE  EXISTS  (SELECT  1\nFROM  atob\nWHERE  a.id  =  atob.a_id  AND  (EXISTS  (SELECT  1\nFROM  b\nWHERE  b.id  =  atob.b_id  AND  b.value  =  :value_1))) \n```", "```py\n>>> s.query(A).filter(A.c_values.any(value=\"x\")).all()\nSELECT  a.id  AS  a_id\nFROM  a\nWHERE  EXISTS  (SELECT  1\nFROM  atob\nWHERE  a.id  =  atob.a_id  AND  (EXISTS  (SELECT  1\nFROM  b\nWHERE  b.id  =  atob.b_id  AND  (EXISTS  (SELECT  1\nFROM  c\nWHERE  b.id  =  c.b_id  AND  c.value  =  :value_1))))) \n```", "```py\ntokyo = WeatherLocation(\"Asia\", \"Tokyo\")\nnewyork = WeatherLocation(\"North America\", \"New York\")\n\ntokyo.reports.append(Report(80.0))\nnewyork.reports.append(Report(75))\n\nsess = create_session()\n\nsess.add_all([tokyo, newyork, quito])\n\nsess.commit()\n\n# the Report class uses a simple integer primary key.  So across two\n# databases, a primary key will be repeated.  The \"identity_token\" tracks\n# in memory that these two identical primary keys are local to different\n# databases.\n\nnewyork_report = newyork.reports[0]\ntokyo_report = tokyo.reports[0]\n\nassert inspect(newyork_report).identity_key == (Report, (1,), \"north_america\")\nassert inspect(tokyo_report).identity_key == (Report, (1,), \"asia\")\n\n# the token representing the originating shard is also available directly\n\nassert inspect(newyork_report).identity_token == \"north_america\"\nassert inspect(tokyo_report).identity_token == \"asia\"\n```", "```py\nq = (\n    session.query(User)\n    .filter(User.name.like(\"%ed%\"))\n    .options(subqueryload(User.addresses))\n)\n```", "```py\nSELECT  users.id  AS  users_id,  users.name  AS  users_name\nFROM  users\nWHERE  users.name  LIKE  ?\n('%ed%',)\n\nSELECT  addresses.id  AS  addresses_id,\n  addresses.user_id  AS  addresses_user_id,\n  addresses.email_address  AS  addresses_email_address,\n  anon_1.users_id  AS  anon_1_users_id\nFROM  (SELECT  users.id  AS  users_id\nFROM  users\nWHERE  users.name  LIKE  ?)  AS  anon_1\nJOIN  addresses  ON  anon_1.users_id  =  addresses.user_id\nORDER  BY  anon_1.users_id\n('%ed%',)\n```", "```py\nq = (\n    session.query(User)\n    .filter(User.name.like(\"%ed%\"))\n    .options(selectinload(User.addresses))\n)\n```", "```py\nSELECT  users.id  AS  users_id,  users.name  AS  users_name\nFROM  users\nWHERE  users.name  LIKE  ?\n('%ed%',)\n\nSELECT  users_1.id  AS  users_1_id,\n  addresses.id  AS  addresses_id,\n  addresses.user_id  AS  addresses_user_id,\n  addresses.email_address  AS  addresses_email_address\nFROM  users  AS  users_1\nJOIN  addresses  ON  users_1.id  =  addresses.user_id\nWHERE  users_1.id  IN  (?,  ?)\nORDER  BY  users_1.id\n(1,  3)\n```", "```py\n>>> from sqlalchemy.orm import selectin_polymorphic\n\n>>> query = session.query(Employee).options(\n...     selectin_polymorphic(Employee, [Manager, Engineer])\n... )\n\n>>> query.all()\nSELECT\n  employee.id  AS  employee_id,\n  employee.name  AS  employee_name,\n  employee.type  AS  employee_type\nFROM  employee\n()\n\nSELECT\n  engineer.id  AS  engineer_id,\n  employee.id  AS  employee_id,\n  employee.type  AS  employee_type,\n  engineer.engineer_name  AS  engineer_engineer_name\nFROM  employee  JOIN  engineer  ON  employee.id  =  engineer.id\nWHERE  employee.id  IN  (?,  ?)  ORDER  BY  employee.id\n(1,  2)\n\nSELECT\n  manager.id  AS  manager_id,\n  employee.id  AS  employee_id,\n  employee.type  AS  employee_type,\n  manager.manager_name  AS  manager_manager_name\nFROM  employee  JOIN  manager  ON  employee.id  =  manager.id\nWHERE  employee.id  IN  (?)  ORDER  BY  employee.id\n(3,) \n```", "```py\nfrom sqlalchemy.orm import query_expression\nfrom sqlalchemy.orm import with_expression\n\nclass A(Base):\n    __tablename__ = \"a\"\n    id = Column(Integer, primary_key=True)\n    x = Column(Integer)\n    y = Column(Integer)\n\n    # will be None normally...\n    expr = query_expression()\n\n# but let's give it x + y\na1 = session.query(A).options(with_expression(A.expr, A.x + A.y)).first()\nprint(a1.expr)\n```", "```py\nquery(SomeEntity).filter(SomeEntity.id == SomeOtherEntity.id).filter(\n    SomeOtherEntity.foo == \"bar\"\n).delete()\n```", "```py\nclass Person(Base):\n    # ...\n\n    first_name = Column(String(10))\n    last_name = Column(String(10))\n\n    @hybrid.hybrid_property\n    def name(self):\n        return self.first_name + \" \" + self.last_name\n\n    @name.expression\n    def name(cls):\n        return func.concat(cls.first_name, \" \", cls.last_name)\n\n    @name.update_expression\n    def name(cls, value):\n        f, l = value.split(\" \", 1)\n        return [(cls.first_name, f), (cls.last_name, l)]\n```", "```py\nsession.query(Person).filter(Person.id == 5).update({Person.name: \"Dr. No\"})\n```", "```py\nsession.query(Vertex).update({Edge.start: Point(3, 4)})\n```", "```py\nclass FirstNameOnly(Base):\n    # ...\n\n    first_name = Column(String)\n\n    @hybrid_property\n    def name(self):\n        return self.first_name\n\n    @name.setter\n    def name(self, value):\n        self.first_name = value\n\nclass FirstNameLastName(FirstNameOnly):\n    # ...\n\n    last_name = Column(String)\n\n    @FirstNameOnly.name.getter\n    def name(self):\n        return self.first_name + \" \" + self.last_name\n\n    @name.setter\n    def name(self, value):\n        self.first_name, self.last_name = value.split(\" \", maxsplit=1)\n\n    @name.expression\n    def name(cls):\n        return func.concat(cls.first_name, \" \", cls.last_name)\n```", "```py\nclass FirstNameOnly(Base):\n    @hybrid_property\n    def name(self):\n        return self.first_name\n\n    # WRONG - will raise AttributeError: can't set attribute when\n    # assigning to .name\n    @name.setter\n    def _set_name(self, value):\n        self.first_name = value\n\nclass FirstNameOnly(Base):\n    @hybrid_property\n    def name(self):\n        return self.first_name\n\n    # CORRECT - note regular Python @property works the same way\n    @name.setter\n    def name(self, value):\n        self.first_name = value\n```", "```py\nfrom sqlalchemy.orm.attributes import OP_BULK_REPLACE\n\n@event.listens_for(SomeObject.collection, \"bulk_replace\")\ndef process_collection(target, values, initiator):\n    values[:] = [_make_value(value) for value in values]\n\n@event.listens_for(SomeObject.collection, \"append\", retval=True)\ndef process_collection(target, value, initiator):\n    # make sure bulk_replace didn't already do it\n    if initiator is None or initiator.op is not OP_BULK_REPLACE:\n        return _make_value(value)\n    else:\n        return value\n```", "```py\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.ext.mutable import MutableDict\nfrom sqlalchemy import event\n\nBase = declarative_base()\n\nclass MyDataClass(Base):\n    __tablename__ = \"my_data\"\n    id = Column(Integer, primary_key=True)\n    data = Column(MutableDict.as_mutable(JSONEncodedDict))\n\n@event.listens_for(MyDataClass.data, \"modified\")\ndef modified_json(instance):\n    print(\"json value modified:\", instance.data)\n```", "```py\nsession.refresh(some_object, with_for_update=True)\n```", "```py\nsession.refresh(some_objects, with_for_update={\"read\": True})\n```", "```py\nmodel = session.query(MyModel).first()\nmodel.json_set &= {1, 3}\n```", "```py\nclass A(Base):\n    __tablename__ = \"a\"\n    id = Column(Integer, primary_key=True)\n\n    b_values = association_proxy(\"atob\", \"b_value\")\n    c_values = association_proxy(\"atob\", \"c_value\")\n\nclass B(Base):\n    __tablename__ = \"b\"\n    id = Column(Integer, primary_key=True)\n    a_id = Column(ForeignKey(\"a.id\"))\n    value = Column(String)\n\n    c = relationship(\"C\")\n\nclass C(Base):\n    __tablename__ = \"c\"\n    id = Column(Integer, primary_key=True)\n    b_id = Column(ForeignKey(\"b.id\"))\n    value = Column(String)\n\nclass AtoB(Base):\n    __tablename__ = \"atob\"\n\n    a_id = Column(ForeignKey(\"a.id\"), primary_key=True)\n    b_id = Column(ForeignKey(\"b.id\"), primary_key=True)\n\n    a = relationship(\"A\", backref=\"atob\")\n    b = relationship(\"B\", backref=\"atob\")\n\n    b_value = association_proxy(\"b\", \"value\")\n    c_value = association_proxy(\"b\", \"c\")\n```", "```py\n>>> s.query(A).filter(A.b_values.contains(\"hi\")).all()\nSELECT  a.id  AS  a_id\nFROM  a\nWHERE  EXISTS  (SELECT  1\nFROM  atob\nWHERE  a.id  =  atob.a_id  AND  (EXISTS  (SELECT  1\nFROM  b\nWHERE  b.id  =  atob.b_id  AND  b.value  =  :value_1))) \n```", "```py\n>>> s.query(A).filter(A.c_values.any(value=\"x\")).all()\nSELECT  a.id  AS  a_id\nFROM  a\nWHERE  EXISTS  (SELECT  1\nFROM  atob\nWHERE  a.id  =  atob.a_id  AND  (EXISTS  (SELECT  1\nFROM  b\nWHERE  b.id  =  atob.b_id  AND  (EXISTS  (SELECT  1\nFROM  c\nWHERE  b.id  =  c.b_id  AND  c.value  =  :value_1))))) \n```", "```py\ntokyo = WeatherLocation(\"Asia\", \"Tokyo\")\nnewyork = WeatherLocation(\"North America\", \"New York\")\n\ntokyo.reports.append(Report(80.0))\nnewyork.reports.append(Report(75))\n\nsess = create_session()\n\nsess.add_all([tokyo, newyork, quito])\n\nsess.commit()\n\n# the Report class uses a simple integer primary key.  So across two\n# databases, a primary key will be repeated.  The \"identity_token\" tracks\n# in memory that these two identical primary keys are local to different\n# databases.\n\nnewyork_report = newyork.reports[0]\ntokyo_report = tokyo.reports[0]\n\nassert inspect(newyork_report).identity_key == (Report, (1,), \"north_america\")\nassert inspect(tokyo_report).identity_key == (Report, (1,), \"asia\")\n\n# the token representing the originating shard is also available directly\n\nassert inspect(newyork_report).identity_token == \"north_america\"\nassert inspect(tokyo_report).identity_token == \"asia\"\n```", "```py\nfrom sqlalchemy import Boolean\nfrom sqlalchemy import TypeDecorator\n\nclass LiberalBoolean(TypeDecorator):\n    impl = Boolean\n\n    def process_bind_param(self, value, dialect):\n        if value is not None:\n            value = bool(int(value))\n        return value\n```", "```py\nengine = create_engine(\"mysql+pymysql://\", pool_pre_ping=True)\n```", "```py\nmycolumn  IN  ()\n```", "```py\nSELECT  NULL  IN  (SELECT  1  WHERE  1  !=  1)\n```", "```py\nstmt = select([table]).where(table.c.col.in_(bindparam(\"foo\", expanding=True)))\nconn.execute(stmt, {\"foo\": [1, 2, 3]})\n```", "```py\n(column(\"q\") == null()) != (column(\"y\") == null())\n```", "```py\nTable(\n    \"my_table\",\n    metadata,\n    Column(\"q\", Integer, comment=\"the Q value\"),\n    comment=\"my Q table\",\n)\n```", "```py\nstmt = (\n    users.delete()\n    .where(users.c.id == addresses.c.id)\n    .where(addresses.c.email_address.startswith(\"ed%\"))\n)\nconn.execute(stmt)\n```", "```py\nDELETE  FROM  users  USING  addresses\nWHERE  users.id  =  addresses.id\nAND  (addresses.email_address  LIKE  %(email_address_1)s  ||  '%%')\n```", "```py\n>>> column(\"x\").startswith(\"total%score\", autoescape=True)\n```", "```py\nx  LIKE  :x_1  ||  '%'  ESCAPE  '/'\n```", "```py\n>>> column(\"x\").startswith(\"total/score\", autoescape=True)\n```", "```py\n    float_value = connection.scalar(\n        select([literal(4.56)])  # the \"BindParameter\" will now be\n        # Float, not Numeric(asdecimal=True)\n    )\n    ```", "```py\n    # asdecimal flag is maintained\n    expr = column(\"a\", Integer) * column(\"b\", Numeric(asdecimal=False))\n    assert expr.type.asdecimal == False\n\n    # Float subclass of Numeric is maintained\n    expr = column(\"a\", Integer) * column(\"b\", Float())\n    assert isinstance(expr.type, Float)\n    ```", "```py\n>>> from sqlalchemy import select, table, column, func, tuple_\n>>> t = table(\"t\", column(\"value\"), column(\"x\"), column(\"y\"), column(\"z\"), column(\"q\"))\n>>> stmt = select([func.sum(t.c.value)]).group_by(\n...     func.grouping_sets(\n...         tuple_(t.c.x, t.c.y),\n...         tuple_(t.c.z, t.c.q),\n...     )\n... )\n>>> print(stmt)\nSELECT  sum(t.value)  AS  sum_1\nFROM  t  GROUP  BY  GROUPING  SETS((t.x,  t.y),  (t.z,  t.q)) \n```", "```py\ndef mydefault(context):\n    return context.get_current_parameters()[\"counter\"] + 12\n\nmytable = Table(\n    \"mytable\",\n    metadata_obj,\n    Column(\"counter\", Integer),\n    Column(\"counter_plus_twelve\", Integer, default=mydefault, onupdate=mydefault),\n)\n\nstmt = mytable.insert().values([{\"counter\": 5}, {\"counter\": 18}, {\"counter\": 20}])\n\nconn.execute(stmt)\n```", "```py\nfrom sqlalchemy import Boolean\nfrom sqlalchemy import TypeDecorator\n\nclass LiberalBoolean(TypeDecorator):\n    impl = Boolean\n\n    def process_bind_param(self, value, dialect):\n        if value is not None:\n            value = bool(int(value))\n        return value\n```", "```py\nengine = create_engine(\"mysql+pymysql://\", pool_pre_ping=True)\n```", "```py\nmycolumn  IN  ()\n```", "```py\nSELECT  NULL  IN  (SELECT  1  WHERE  1  !=  1)\n```", "```py\nstmt = select([table]).where(table.c.col.in_(bindparam(\"foo\", expanding=True)))\nconn.execute(stmt, {\"foo\": [1, 2, 3]})\n```", "```py\n(column(\"q\") == null()) != (column(\"y\") == null())\n```", "```py\nTable(\n    \"my_table\",\n    metadata,\n    Column(\"q\", Integer, comment=\"the Q value\"),\n    comment=\"my Q table\",\n)\n```", "```py\nstmt = (\n    users.delete()\n    .where(users.c.id == addresses.c.id)\n    .where(addresses.c.email_address.startswith(\"ed%\"))\n)\nconn.execute(stmt)\n```", "```py\nDELETE  FROM  users  USING  addresses\nWHERE  users.id  =  addresses.id\nAND  (addresses.email_address  LIKE  %(email_address_1)s  ||  '%%')\n```", "```py\n>>> column(\"x\").startswith(\"total%score\", autoescape=True)\n```", "```py\nx  LIKE  :x_1  ||  '%'  ESCAPE  '/'\n```", "```py\n>>> column(\"x\").startswith(\"total/score\", autoescape=True)\n```", "```py\n    float_value = connection.scalar(\n        select([literal(4.56)])  # the \"BindParameter\" will now be\n        # Float, not Numeric(asdecimal=True)\n    )\n    ```", "```py\n    # asdecimal flag is maintained\n    expr = column(\"a\", Integer) * column(\"b\", Numeric(asdecimal=False))\n    assert expr.type.asdecimal == False\n\n    # Float subclass of Numeric is maintained\n    expr = column(\"a\", Integer) * column(\"b\", Float())\n    assert isinstance(expr.type, Float)\n    ```", "```py\n>>> from sqlalchemy import select, table, column, func, tuple_\n>>> t = table(\"t\", column(\"value\"), column(\"x\"), column(\"y\"), column(\"z\"), column(\"q\"))\n>>> stmt = select([func.sum(t.c.value)]).group_by(\n...     func.grouping_sets(\n...         tuple_(t.c.x, t.c.y),\n...         tuple_(t.c.z, t.c.q),\n...     )\n... )\n>>> print(stmt)\nSELECT  sum(t.value)  AS  sum_1\nFROM  t  GROUP  BY  GROUPING  SETS((t.x,  t.y),  (t.z,  t.q)) \n```", "```py\ndef mydefault(context):\n    return context.get_current_parameters()[\"counter\"] + 12\n\nmytable = Table(\n    \"mytable\",\n    metadata_obj,\n    Column(\"counter\", Integer),\n    Column(\"counter_plus_twelve\", Integer, default=mydefault, onupdate=mydefault),\n)\n\nstmt = mytable.insert().values([{\"counter\": 5}, {\"counter\": 18}, {\"counter\": 20}])\n\nconn.execute(stmt)\n```", "```py\nsess = Session()\n\nuser = sess.query(User).filter_by(name=\"x\").first()\n\n@event.listens_for(sess, \"after_rollback\")\ndef after_rollback(session):\n    # 'user.name' is now present, assuming it was already\n    # loaded.  previously this would raise upon trying\n    # to emit a lazy load.\n    print(\"user name: %s\" % user.name)\n\n@event.listens_for(sess, \"after_commit\")\ndef after_commit(session):\n    # 'user.name' is present, assuming it was already\n    # loaded.  this is the existing behavior.\n    print(\"user name: %s\" % user.name)\n\nif should_rollback:\n    sess.rollback()\nelse:\n    sess.commit()\n```", "```py\nsess.query(Manager.id)\n```", "```py\nSELECT  employee.id  FROM  employee  WHERE  employee.type  IN  ('manager')\n```", "```py\nsess.query(func.count(1)).select_from(Manager)\n```", "```py\nSELECT  count(1)  FROM  employee\n```", "```py\nSELECT  count(1)  FROM  employee  WHERE  employee.type  IN  ('manager')\n```", "```py\n>>> a1, a2, a3 = Address(\"a1\"), Address(\"a2\"), Address(\"a3\")\n>>> user.addresses = [a1, a2]\n\n>>> previous_collection = user.addresses\n\n# replace the collection with a new one\n>>> user.addresses = [a2, a3]\n\n>>> previous_collection\n[Address('a1'), Address('a2')]\n```", "```py\nclass A(Base):\n    __tablename__ = \"a\"\n    id = Column(Integer, primary_key=True)\n    bs = relationship(\"B\")\n\n    @validates(\"bs\")\n    def convert_dict_to_b(self, key, value):\n        return B(data=value[\"data\"])\n\nclass B(Base):\n    __tablename__ = \"b\"\n    id = Column(Integer, primary_key=True)\n    a_id = Column(ForeignKey(\"a.id\"))\n    data = Column(String)\n```", "```py\na1 = A()\na1.bs.append({\"data\": \"b1\"})\n```", "```py\na1 = A()\na1.bs = [{\"data\": \"b1\"}]\n```", "```py\nclass A(Base):\n    # ...\n\n    @validates(\"bs\")\n    def validate_b(self, key, value):\n        assert value.data is not None\n        return value\n```", "```py\na1 = A()\n\nb1, b2 = B(data=\"one\"), B(data=\"two\")\na1.bs = [b1, b2]\n```", "```py\nb3 = B(data=\"three\")\na1.bs = [b2, b3]\n```", "```py\na1 = A(data=\"adf\")\ns.add(a1)\n\ns.flush()\n\n# expire, similarly as though we said s.commit()\ns.expire(a1, \"data\")\n\n# will raise InvalidRequestError\nattributes.flag_modified(a1, \"data\")\n```", "```py\nfrom sqlalchemy.orm import attributes\n\nattributes.flag_dirty(a1)\n```", "```py\nfrom sqlalchemy.orm import scoped_session\n\nSession = scoped_session(sessionmaker())\n\nsession = Session(scope=None)\n```", "```py\nclass A(Base):\n    __tablename__ = \"a\"\n    id = Column(Integer, primary_key=True)\n    favorite_b_id = Column(ForeignKey(\"b.id\", name=\"favorite_b_fk\"))\n    bs = relationship(\"B\", primaryjoin=\"A.id == B.a_id\")\n    favorite_b = relationship(\n        \"B\", primaryjoin=\"A.favorite_b_id == B.id\", post_update=True\n    )\n    updated = Column(Integer, onupdate=my_onupdate_function)\n\nclass B(Base):\n    __tablename__ = \"b\"\n    id = Column(Integer, primary_key=True)\n    a_id = Column(ForeignKey(\"a.id\", name=\"a_fk\"))\n\na1 = A()\nb1 = B()\n\na1.bs.append(b1)\na1.favorite_b = b1\na1.updated = 5\ns.add(a1)\ns.flush()\n```", "```py\nINSERT  INTO  a  (favorite_b_id,  updated)  VALUES  (?,  ?)\n(None,  5)\nINSERT  INTO  b  (a_id)  VALUES  (?)\n(1,)\nUPDATE  a  SET  favorite_b_id=?,  updated=?  WHERE  a.id  =  ?\n(1,  5,  1)\n```", "```py\nclass Node(Base):\n    __tablename__ = \"node\"\n    id = Column(Integer, primary_key=True)\n    version_id = Column(Integer, default=0)\n    parent_id = Column(ForeignKey(\"node.id\"))\n    favorite_node_id = Column(ForeignKey(\"node.id\"))\n\n    nodes = relationship(\"Node\", primaryjoin=remote(parent_id) == id)\n    favorite_node = relationship(\n        \"Node\", primaryjoin=favorite_node_id == remote(id), post_update=True\n    )\n\n    __mapper_args__ = {\"version_id_col\": version_id}\n```", "```py\nnode = Node()\nsession.add(node)\nsession.commit()  # node is now version #1\n\nnode = session.query(Node).get(node.id)\nnode.favorite_node = Node()\nsession.commit()  # node is now version #2\n```", "```py\nsess = Session()\n\nuser = sess.query(User).filter_by(name=\"x\").first()\n\n@event.listens_for(sess, \"after_rollback\")\ndef after_rollback(session):\n    # 'user.name' is now present, assuming it was already\n    # loaded.  previously this would raise upon trying\n    # to emit a lazy load.\n    print(\"user name: %s\" % user.name)\n\n@event.listens_for(sess, \"after_commit\")\ndef after_commit(session):\n    # 'user.name' is present, assuming it was already\n    # loaded.  this is the existing behavior.\n    print(\"user name: %s\" % user.name)\n\nif should_rollback:\n    sess.rollback()\nelse:\n    sess.commit()\n```", "```py\nsess.query(Manager.id)\n```", "```py\nSELECT  employee.id  FROM  employee  WHERE  employee.type  IN  ('manager')\n```", "```py\nsess.query(func.count(1)).select_from(Manager)\n```", "```py\nSELECT  count(1)  FROM  employee\n```", "```py\nSELECT  count(1)  FROM  employee  WHERE  employee.type  IN  ('manager')\n```", "```py\n>>> a1, a2, a3 = Address(\"a1\"), Address(\"a2\"), Address(\"a3\")\n>>> user.addresses = [a1, a2]\n\n>>> previous_collection = user.addresses\n\n# replace the collection with a new one\n>>> user.addresses = [a2, a3]\n\n>>> previous_collection\n[Address('a1'), Address('a2')]\n```", "```py\nclass A(Base):\n    __tablename__ = \"a\"\n    id = Column(Integer, primary_key=True)\n    bs = relationship(\"B\")\n\n    @validates(\"bs\")\n    def convert_dict_to_b(self, key, value):\n        return B(data=value[\"data\"])\n\nclass B(Base):\n    __tablename__ = \"b\"\n    id = Column(Integer, primary_key=True)\n    a_id = Column(ForeignKey(\"a.id\"))\n    data = Column(String)\n```", "```py\na1 = A()\na1.bs.append({\"data\": \"b1\"})\n```", "```py\na1 = A()\na1.bs = [{\"data\": \"b1\"}]\n```", "```py\nclass A(Base):\n    # ...\n\n    @validates(\"bs\")\n    def validate_b(self, key, value):\n        assert value.data is not None\n        return value\n```", "```py\na1 = A()\n\nb1, b2 = B(data=\"one\"), B(data=\"two\")\na1.bs = [b1, b2]\n```", "```py\nb3 = B(data=\"three\")\na1.bs = [b2, b3]\n```", "```py\na1 = A(data=\"adf\")\ns.add(a1)\n\ns.flush()\n\n# expire, similarly as though we said s.commit()\ns.expire(a1, \"data\")\n\n# will raise InvalidRequestError\nattributes.flag_modified(a1, \"data\")\n```", "```py\nfrom sqlalchemy.orm import attributes\n\nattributes.flag_dirty(a1)\n```", "```py\nfrom sqlalchemy.orm import scoped_session\n\nSession = scoped_session(sessionmaker())\n\nsession = Session(scope=None)\n```", "```py\nclass A(Base):\n    __tablename__ = \"a\"\n    id = Column(Integer, primary_key=True)\n    favorite_b_id = Column(ForeignKey(\"b.id\", name=\"favorite_b_fk\"))\n    bs = relationship(\"B\", primaryjoin=\"A.id == B.a_id\")\n    favorite_b = relationship(\n        \"B\", primaryjoin=\"A.favorite_b_id == B.id\", post_update=True\n    )\n    updated = Column(Integer, onupdate=my_onupdate_function)\n\nclass B(Base):\n    __tablename__ = \"b\"\n    id = Column(Integer, primary_key=True)\n    a_id = Column(ForeignKey(\"a.id\", name=\"a_fk\"))\n\na1 = A()\nb1 = B()\n\na1.bs.append(b1)\na1.favorite_b = b1\na1.updated = 5\ns.add(a1)\ns.flush()\n```", "```py\nINSERT  INTO  a  (favorite_b_id,  updated)  VALUES  (?,  ?)\n(None,  5)\nINSERT  INTO  b  (a_id)  VALUES  (?)\n(1,)\nUPDATE  a  SET  favorite_b_id=?,  updated=?  WHERE  a.id  =  ?\n(1,  5,  1)\n```", "```py\nclass Node(Base):\n    __tablename__ = \"node\"\n    id = Column(Integer, primary_key=True)\n    version_id = Column(Integer, default=0)\n    parent_id = Column(ForeignKey(\"node.id\"))\n    favorite_node_id = Column(ForeignKey(\"node.id\"))\n\n    nodes = relationship(\"Node\", primaryjoin=remote(parent_id) == id)\n    favorite_node = relationship(\n        \"Node\", primaryjoin=favorite_node_id == remote(id), post_update=True\n    )\n\n    __mapper_args__ = {\"version_id_col\": version_id}\n```", "```py\nnode = Node()\nsession.add(node)\nsession.commit()  # node is now version #1\n\nnode = session.query(Node).get(node.id)\nnode.favorite_node = Node()\nsession.commit()  # node is now version #2\n```", "```py\n>>> column(\"x\", types.DateTime).op(\"-%>\")(None).type\nNullType()\n```", "```py\n>>> column(\"x\", types.String(50)).op(\"-%>\")(None).type\nString(length=50)\n```", "```py\n>>> column(\"x\", types.DateTime).op(\"-%>\")(None).type\nDateTime()\n```", "```py\n>>> column(\"x\", types.String(50)).op(\"-%>\", is_comparison=True)(None).type\nBoolean()\n>>> column(\"x\", types.ARRAY(types.Integer)).op(\"-%>\", is_comparison=True)(None).type\nBoolean()\n>>> column(\"x\", types.JSON()).op(\"-%>\", is_comparison=True)(None).type\nBoolean()\n```", "```py\n>>> print(column(\"x\", types.Integer).bool_op(\"-%>\")(5))\nx  -%>  :x_1 \n```", "```py\n>>> from sqlalchemy import literal_column\n>>> print(literal_column(\"some%symbol\"))\nsome%%symbol \n```", "```py\n>>> from sqlalchemy import literal_column\n>>> print(literal_column(\"some%symbol\"))\nsome%symbol\n>>> from sqlalchemy.dialects import mysql\n>>> print(literal_column(\"some%symbol\").compile(dialect=mysql.dialect()))\nsome%%symbol \n```", "```py\nstmt = select([mytable.c.x, mytable.c.y]).order_by(\n    mytable.c.somecolumn.collate(\"fr_FR\")\n)\n```", "```py\nSELECT  mytable.x,  mytable.y,\nFROM  mytable  ORDER  BY  mytable.somecolumn  COLLATE  \"fr_FR\"\n```", "```py\n>>> column(\"x\", types.DateTime).op(\"-%>\")(None).type\nNullType()\n```", "```py\n>>> column(\"x\", types.String(50)).op(\"-%>\")(None).type\nString(length=50)\n```", "```py\n>>> column(\"x\", types.DateTime).op(\"-%>\")(None).type\nDateTime()\n```", "```py\n>>> column(\"x\", types.String(50)).op(\"-%>\", is_comparison=True)(None).type\nBoolean()\n>>> column(\"x\", types.ARRAY(types.Integer)).op(\"-%>\", is_comparison=True)(None).type\nBoolean()\n>>> column(\"x\", types.JSON()).op(\"-%>\", is_comparison=True)(None).type\nBoolean()\n```", "```py\n>>> print(column(\"x\", types.Integer).bool_op(\"-%>\")(5))\nx  -%>  :x_1 \n```", "```py\n>>> from sqlalchemy import literal_column\n>>> print(literal_column(\"some%symbol\"))\nsome%%symbol \n```", "```py\n>>> from sqlalchemy import literal_column\n>>> print(literal_column(\"some%symbol\"))\nsome%symbol\n>>> from sqlalchemy.dialects import mysql\n>>> print(literal_column(\"some%symbol\").compile(dialect=mysql.dialect()))\nsome%%symbol \n```", "```py\nstmt = select([mytable.c.x, mytable.c.y]).order_by(\n    mytable.c.somecolumn.collate(\"fr_FR\")\n)\n```", "```py\nSELECT  mytable.x,  mytable.y,\nFROM  mytable  ORDER  BY  mytable.somecolumn  COLLATE  \"fr_FR\"\n```", "```py\nengine = create_engine(\n    \"postgresql+psycopg2://scott:tiger@host/dbname\", use_batch_mode=True\n)\n```", "```py\nfrom sqlalchemy.dialects.postgresql import INTERVAL\n\nTable(\"my_table\", metadata, Column(\"some_interval\", INTERVAL(fields=\"DAY TO SECOND\")))\n```", "```py\n>>> inspect(engine).get_columns(\"my_table\")\n[{'comment': None,\n 'name': u'some_interval', 'nullable': True,\n 'default': None, 'autoincrement': False,\n 'type': INTERVAL(fields=u'day to second')}]\n```", "```py\nengine = create_engine(\n    \"postgresql+psycopg2://scott:tiger@host/dbname\", use_batch_mode=True\n)\n```", "```py\nfrom sqlalchemy.dialects.postgresql import INTERVAL\n\nTable(\"my_table\", metadata, Column(\"some_interval\", INTERVAL(fields=\"DAY TO SECOND\")))\n```", "```py\n>>> inspect(engine).get_columns(\"my_table\")\n[{'comment': None,\n 'name': u'some_interval', 'nullable': True,\n 'default': None, 'autoincrement': False,\n 'type': INTERVAL(fields=u'day to second')}]\n```", "```py\nfrom sqlalchemy.dialects.mysql import insert\n\ninsert_stmt = insert(my_table).values(id=\"some_id\", data=\"some data to insert\")\n\non_conflict_stmt = insert_stmt.on_duplicate_key_update(\n    data=insert_stmt.inserted.data, status=\"U\"\n)\n\nconn.execute(on_conflict_stmt)\n```", "```py\nINSERT  INTO  my_table  (id,  data)\nVALUES  (:id,  :data)\nON  DUPLICATE  KEY  UPDATE  data=VALUES(data),  status=:status_1\n```", "```py\nfrom sqlalchemy.dialects.mysql import insert\n\ninsert_stmt = insert(my_table).values(id=\"some_id\", data=\"some data to insert\")\n\non_conflict_stmt = insert_stmt.on_duplicate_key_update(\n    data=insert_stmt.inserted.data, status=\"U\"\n)\n\nconn.execute(on_conflict_stmt)\n```", "```py\nINSERT  INTO  my_table  (id,  data)\nVALUES  (:id,  :data)\nON  DUPLICATE  KEY  UPDATE  data=VALUES(data),  status=:status_1\n```", "```py\n    result = conn.execute(table.insert().values(x=5).returning(table.c.a, table.c.b))\n    ```", "```py\n>>> insp.get_indexes(\"addresses\")\n[{'unique': False, 'column_names': [u'user_id'],\n 'name': u'address_idx', 'dialect_options': {}}]\n\n>>> insp.get_pk_constraint(\"addresses\")\n{'name': u'pk_cons', 'constrained_columns': [u'id']}\n\n>>> insp.get_foreign_keys(\"addresses\")\n[{'referred_table': u'users', 'referred_columns': [u'id'],\n 'referred_schema': None, 'name': u'user_id_fk',\n 'constrained_columns': [u'user_id']}]\n```", "```py\n[\n    {\n        \"referred_table\": \"users\",\n        \"referred_columns\": [\"id\"],\n        \"referred_schema\": None,\n        \"name\": \"USER_ID_FK\",\n        \"constrained_columns\": [\"user_id\"],\n    }\n]\n```", "```py\n    result = conn.execute(table.insert().values(x=5).returning(table.c.a, table.c.b))\n    ```", "```py\n>>> insp.get_indexes(\"addresses\")\n[{'unique': False, 'column_names': [u'user_id'],\n 'name': u'address_idx', 'dialect_options': {}}]\n\n>>> insp.get_pk_constraint(\"addresses\")\n{'name': u'pk_cons', 'constrained_columns': [u'id']}\n\n>>> insp.get_foreign_keys(\"addresses\")\n[{'referred_table': u'users', 'referred_columns': [u'id'],\n 'referred_schema': None, 'name': u'user_id_fk',\n 'constrained_columns': [u'user_id']}]\n```", "```py\n[\n    {\n        \"referred_table\": \"users\",\n        \"referred_columns\": [\"id\"],\n        \"referred_schema\": None,\n        \"name\": \"USER_ID_FK\",\n        \"constrained_columns\": [\"user_id\"],\n    }\n]\n```", "```py\nTable(\"some_table\", metadata, Column(\"q\", String(50)), schema=\"[MyDataBase.dbo]\")\n```", "```py\nTable(\n    \"some_table\",\n    metadata,\n    Column(\"q\", String(50)),\n    schema=\"[MyDataBase.SomeDB].[MyDB.owner]\",\n)\n```", "```py\nTable(\"some_table\", metadata, Column(\"q\", String(50)), schema=\"[MyDataBase.dbo]\")\n```", "```py\nTable(\n    \"some_table\",\n    metadata,\n    Column(\"q\", String(50)),\n    schema=\"[MyDataBase.SomeDB].[MyDB.owner]\",\n)\n```"]