- en: Data Manipulation with the ORM
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ORM进行数据操作
- en: 原文：[https://docs.sqlalchemy.org/en/20/tutorial/orm_data_manipulation.html](https://docs.sqlalchemy.org/en/20/tutorial/orm_data_manipulation.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://docs.sqlalchemy.org/en/20/tutorial/orm_data_manipulation.html](https://docs.sqlalchemy.org/en/20/tutorial/orm_data_manipulation.html)
- en: The previous section [Working with Data](data.html#tutorial-working-with-data)
    remained focused on the SQL Expression Language from a Core perspective, in order
    to provide continuity across the major SQL statement constructs. This section
    will then build out the lifecycle of the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") and how it interacts with these constructs.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 上一节[处理数据](data.html#tutorial-working-with-data)保持了从核心角度来看SQL表达语言的关注，以便提供各种主要SQL语句结构的连续性。接下来的部分将扩展[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")的生命周期，以及它如何与这些结构交互。
- en: '**Prerequisite Sections** - the ORM focused part of the tutorial builds upon
    two previous ORM-centric sections in this document:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '**先决条件部分** - 教程中ORM重点部分建立在本文档中的两个先前ORM中心部分的基础上：'
- en: '[Executing with an ORM Session](dbapi_transactions.html#tutorial-executing-orm-session)
    - introduces how to make an ORM [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") object'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用ORM会话执行](dbapi_transactions.html#tutorial-executing-orm-session) - 介绍如何创建ORM
    [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")对象'
- en: '[Using ORM Declarative Forms to Define Table Metadata](metadata.html#tutorial-orm-table-metadata)
    - where we set up our ORM mappings of the `User` and `Address` entities'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用ORM声明性表单定义表元数据](metadata.html#tutorial-orm-table-metadata) - 我们在这里设置了`User`和`Address`实体的ORM映射'
- en: '[Selecting ORM Entities and Columns](data_select.html#tutorial-selecting-orm-entities)
    - a few examples on how to run SELECT statements for entities like `User`'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[选择ORM实体和列](data_select.html#tutorial-selecting-orm-entities) - 一些关于如何为诸如`User`之类的实体运行SELECT语句的示例'
- en: '## Inserting Rows using the ORM Unit of Work pattern'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '## 使用ORM工作单元模式插入行'
- en: When using the ORM, the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") object is responsible for constructing [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") constructs and emitting them as INSERT statements
    within the ongoing transaction. The way we instruct the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") to do so is by **adding** object entries to it; the
    [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    then makes sure these new entries will be emitted to the database when they are
    needed, using a process known as a **flush**. The overall process used by the
    [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    to persist objects is known as the [unit of work](../glossary.html#term-unit-of-work)
    pattern.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用ORM时，[`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")对象负责构造[`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert")构造并将它们作为INSERT语句发出到正在进行的事务中。我们指示[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")这样做的方式是通过**添加**对象条目到它; [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")然后确保这些新条目在需要时被发出到数据库，使用称为**flush**的过程。[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")用于持久化对象的整体过程被称为[工作单元](../glossary.html#term-unit-of-work)模式。
- en: Instances of Classes represent Rows
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类的实例代表行
- en: 'Whereas in the previous example we emitted an INSERT using Python dictionaries
    to indicate the data we wanted to add, with the ORM we make direct use of the
    custom Python classes we defined, back at [Using ORM Declarative Forms to Define
    Table Metadata](metadata.html#tutorial-orm-table-metadata). At the class level,
    the `User` and `Address` classes served as a place to define what the corresponding
    database tables should look like. These classes also serve as extensible data
    objects that we use to create and manipulate rows within a transaction as well.
    Below we will create two `User` objects each representing a potential database
    row to be INSERTed:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 而在前一个示例中，我们使用Python字典发出了一个INSERT，以指示我们要添加的数据，使用ORM时，我们直接使用我们定义的自定义Python类，在[使用ORM声明性表单定义表元数据](metadata.html#tutorial-orm-table-metadata)中。在类级别，`User`和`Address`类用作定义相应数据库表应该如何查看的位置。这些类还用作可扩展的数据对象，我们用它们来创建和操作事务中的行。下面我们将创建两个`User`对象，每个对象代表一个要插入的潜在数据库行：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We are able to construct these objects using the names of the mapped columns
    as keyword arguments in the constructor. This is possible as the `User` class
    includes an automatically generated `__init__()` constructor that was provided
    by the ORM mapping so that we could create each object using column names as keys
    in the constructor.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用映射列的名称作为构造函数中的关键字参数来构造这些对象。这是可能的，因为 `User` 类包含一个由 ORM 映射提供的自动生成的 `__init__()`
    构造函数，以便我们可以使用构造函数中的列名作为键来创建每个对象。
- en: 'In a similar manner as in our Core examples of [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert"), we did not include a primary key (i.e. an
    entry for the `id` column), since we would like to make use of the auto-incrementing
    primary key feature of the database, SQLite in this case, which the ORM also integrates
    with. The value of the `id` attribute on the above objects, if we were to view
    it, displays itself as `None`:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于我们在 [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert "sqlalchemy.sql.expression.Insert")
    的核心示例中的做法，我们没有包含主键（即 `id` 列的条目），因为我们希望利用数据库的自动递增主键功能，这里是 SQLite，ORM 也与之集成。上述对象的
    `id` 属性的值，如果我们查看它，会显示为 `None`：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `None` value is provided by SQLAlchemy to indicate that the attribute has
    no value as of yet. SQLAlchemy-mapped attributes always return a value in Python
    and don’t raise `AttributeError` if they’re missing, when dealing with a new object
    that has not had a value assigned.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`None` 值由 SQLAlchemy 提供，表示属性目前没有值。在处理尚未分配值的新对象时，SQLAlchemy 映射的属性始终在 Python
    中返回一个值，并且如果缺少值，则不会引发 `AttributeError`。'
- en: At the moment, our two objects above are said to be in a state called [transient](../glossary.html#term-transient)
    - they are not associated with any database state and are yet to be associated
    with a [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    object that can generate INSERT statements for them.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，上述两个对象被称为处于 [transient](../glossary.html#term-transient) 状态 - 它们与任何数据库状态都没有关联，尚未与可以为它们生成
    INSERT 语句的 [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    对象关联。
- en: Adding objects to a Session
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将对象添加到会话
- en: 'To illustrate the addition process step by step, we will create a [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") without using a context manager (and hence we must make
    sure we close it later!):'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了逐步说明添加过程，我们将创建一个不使用上下文管理器的 [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")（因此我们必须确保稍后关闭它！）：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The objects are then added to the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") using the [`Session.add()`](../orm/session_api.html#sqlalchemy.orm.Session.add
    "sqlalchemy.orm.Session.add") method. When this is called, the objects are in
    a state known as [pending](../glossary.html#term-pending) and have not been inserted
    yet:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用 [`Session.add()`](../orm/session_api.html#sqlalchemy.orm.Session.add "sqlalchemy.orm.Session.add")
    方法将对象添加到 [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    中。当调用此方法时，对象处于一种称为 [pending](../glossary.html#term-pending) 的状态，尚未插入：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'When we have pending objects, we can see this state by looking at a collection
    on the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    called [`Session.new`](../orm/session_api.html#sqlalchemy.orm.Session.new "sqlalchemy.orm.Session.new"):'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有待处理的对象时，我们可以通过查看 [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 上的一个集合来查看这种状态，该集合称为 [`Session.new`](../orm/session_api.html#sqlalchemy.orm.Session.new
    "sqlalchemy.orm.Session.new")：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The above view is using a collection called `IdentitySet` that is essentially
    a Python set that hashes on object identity in all cases (i.e., using Python built-in
    `id()` function, rather than the Python `hash()` function).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 上述视图使用一个名为 `IdentitySet` 的集合，它本质上是一个 Python 集合，以所有情况下的对象标识哈希（即使用 Python 内置的
    `id()` 函数，而不是 Python 的 `hash()` 函数）。
- en: Flushing
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 刷新
- en: The [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    makes use of a pattern known as [unit of work](../glossary.html#term-unit-of-work).
    This generally means it accumulates changes one at a time, but does not actually
    communicate them to the database until needed. This allows it to make better decisions
    about how SQL DML should be emitted in the transaction based on a given set of
    pending changes. When it does emit SQL to the database to push out the current
    set of changes, the process is known as a **flush**.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    使用一种称为[工作单元（unit of work）](../glossary.html#term-unit-of-work)的模式。这通常意味着它逐个累积更改，但实际上直到需要时才将它们传递到数据库。这使它能够根据给定的一组待处理更改，更好地决定如何在事务中发出
    SQL DML。当它确实向数据库发出 SQL 以推送当前更改集时，该过程被称为**刷新**。'
- en: 'We can illustrate the flush process manually by calling the [`Session.flush()`](../orm/session_api.html#sqlalchemy.orm.Session.flush
    "sqlalchemy.orm.Session.flush") method:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过调用[`Session.flush()`](../orm/session_api.html#sqlalchemy.orm.Session.flush
    "sqlalchemy.orm.Session.flush")方法来手动说明刷新过程：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Above we observe the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") was first called upon to emit SQL, so it created a new
    transaction and emitted the appropriate INSERT statements for the two objects.
    The transaction now **remains open** until we call any of the [`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit"), [`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback"), or [`Session.close()`](../orm/session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") methods of [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session").
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 上面我们观察到首先调用[`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")以发出
    SQL，因此它创建了一个新的事务并为两个对象发出了适当的 INSERT 语句。事务现在**保持打开**，直到我们调用任何[`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit")、[`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback")或[`Session.close()`](../orm/session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close")方法。
- en: While [`Session.flush()`](../orm/session_api.html#sqlalchemy.orm.Session.flush
    "sqlalchemy.orm.Session.flush") may be used to manually push out pending changes
    to the current transaction, it is usually unnecessary as the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") features a behavior known as **autoflush**, which we
    will illustrate later. It also flushes out changes whenever [`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") is called.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然[`Session.flush()`](../orm/session_api.html#sqlalchemy.orm.Session.flush "sqlalchemy.orm.Session.flush")可用于手动推送待处理更改到当前事务，但通常是不必要的，因为[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")具有一种称为**自动刷新**的行为，我们稍后将说明。每当调用[`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit")时，它也会刷新更改。
- en: Autogenerated primary key attributes
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自动产生的主键属性
- en: Once the rows are inserted, the two Python objects we’ve created are in a state
    known as [persistent](../glossary.html#term-persistent), where they are associated
    with the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    object in which they were added or loaded, and feature lots of other behaviors
    that will be covered later.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦行被插入，我们创建的两个 Python 对象处于[持久（persistent）](../glossary.html#term-persistent)状态，它们与它们被添加或加载到的[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")对象相关联，并具有稍后将介绍的许多其他行为。
- en: 'Another effect of the INSERT that occurred was that the ORM has retrieved the
    new primary key identifiers for each new object; internally it normally uses the
    same [`CursorResult.inserted_primary_key`](../core/connections.html#sqlalchemy.engine.CursorResult.inserted_primary_key
    "sqlalchemy.engine.CursorResult.inserted_primary_key") accessor we introduced
    previously. The `squidward` and `krabs` objects now have these new primary key
    identifiers associated with them and we can view them by accessing the `id` attribute:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 发生的 INSERT 的另一个效果是 ORM 检索了每个新对象的新主键标识符；在内部，它通常使用我们之前介绍的相同的[`CursorResult.inserted_primary_key`](../core/connections.html#sqlalchemy.engine.CursorResult.inserted_primary_key
    "sqlalchemy.engine.CursorResult.inserted_primary_key")访问器。`squidward` 和 `krabs`
    对象现在具有这些新的主键标识符，并且我们可以通过访问 `id` 属性查看它们：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Tip
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Why did the ORM emit two separate INSERT statements when it could have used
    [executemany](dbapi_transactions.html#tutorial-multiple-parameters)? As we’ll
    see in the next section, the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") when flushing objects always needs to know the primary
    key of newly inserted objects. If a feature such as SQLite’s autoincrement is
    used (other examples include PostgreSQL IDENTITY or SERIAL, using sequences, etc.),
    the [`CursorResult.inserted_primary_key`](../core/connections.html#sqlalchemy.engine.CursorResult.inserted_primary_key
    "sqlalchemy.engine.CursorResult.inserted_primary_key") feature usually requires
    that each INSERT is emitted one row at a time. If we had provided values for the
    primary keys ahead of time, the ORM would have been able to optimize the operation
    better. Some database backends such as [psycopg2](../dialects/postgresql.html#postgresql-psycopg2)
    can also INSERT many rows at once while still being able to retrieve the primary
    key values.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当ORM在刷新对象时为什么会发出两个单独的INSERT语句，而不是使用[executemany](dbapi_transactions.html#tutorial-multiple-parameters)？正如我们将在下一节中看到的，[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")在刷新对象时始终需要知道新插入对象的主键。如果使用了诸如SQLite的自动增量（其他示例包括PostgreSQL
    IDENTITY或SERIAL，使用序列等）之类的功能，则[`CursorResult.inserted_primary_key`](../core/connections.html#sqlalchemy.engine.CursorResult.inserted_primary_key
    "sqlalchemy.engine.CursorResult.inserted_primary_key")功能通常要求每次INSERT都逐行发出。如果我们提前为主键提供了值，ORM将能够更好地优化操作。一些数据库后端，如[psycopg2](../dialects/postgresql.html#postgresql-psycopg2)，还可以一次插入多行，同时仍然能够检索主键值。
- en: Getting Objects by Primary Key from the Identity Map
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过主键从身份映射获取对象
- en: 'The primary key identity of the objects are significant to the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), as the objects are now linked to this identity in memory
    using a feature known as the [identity map](../glossary.html#term-identity-map).
    The identity map is an in-memory store that links all objects currently loaded
    in memory to their primary key identity. We can observe this by retrieving one
    of the above objects using the [`Session.get()`](../orm/session_api.html#sqlalchemy.orm.Session.get
    "sqlalchemy.orm.Session.get") method, which will return an entry from the identity
    map if locally present, otherwise emitting a SELECT:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的主键标识对于[`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")非常重要，因为这些对象现在使用称为[身份映射](../glossary.html#term-identity-map)的功能与此标识在内存中连接在一起。身份映射是一个内存存储器，它将当前加载在内存中的所有对象与它们的主键标识链接起来。我们可以通过使用[`Session.get()`](../orm/session_api.html#sqlalchemy.orm.Session.get
    "sqlalchemy.orm.Session.get")方法之一来检索上述对象之一来观察到这一点，如果本地存在，则返回身份映射中的条目，否则发出一个SELECT：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The important thing to note about the identity map is that it maintains a **unique
    instance** of a particular Python object per a particular database identity, within
    the scope of a particular [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") object. We may observe that the `some_squidward` refers
    to the **same object** as that of `squidward` previously:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 身份映射的重要一点是，在特定[`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")对象的范围内，它维护着特定Python对象的**唯一实例**与特定数据库标识的关系。我们可以观察到，`some_squidward`指的是之前`squidward`所指的**同一个对象**：
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The identity map is a critical feature that allows complex sets of objects to
    be manipulated within a transaction without things getting out of sync.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 身份映射是一个关键特性，允许在事务中操作复杂的对象集合而不会出现同步问题。
- en: Committing
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提交
- en: 'There’s much more to say about how the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") works which will be discussed further. For now we will
    commit the transaction so that we can build up knowledge on how to SELECT rows
    before examining more ORM behaviors and features:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 关于[`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")的工作方式还有很多要说的，这将在后续进一步讨论。现在我们将提交事务，以便在深入研究ORM行为和特性之前积累关于如何在SELECT行之前的知识：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The above operation will commit the transaction that was in progress. The objects
    which we’ve dealt with are still [attached](../glossary.html#term-attached) to
    the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session"),
    which is a state they stay in until the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is closed (which is introduced at [Closing a Session](#tutorial-orm-closing)).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 上述操作将提交正在进行的事务。 我们处理过的对象仍然[附加](../glossary.html#term-attached)到 [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")，这是一个状态，直到 [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")关闭（在[关闭会话](#tutorial-orm-closing)中介绍）。
- en: Tip
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'An important thing to note is that attributes on the objects that we just worked
    with have been [expired](../glossary.html#term-expired), meaning, when we next
    access any attributes on them, the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") will start a new transaction and re-load their state.
    This option is sometimes problematic for both performance reasons, or if one wishes
    to use the objects after closing the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") (which is known as the [detached](../glossary.html#term-detached)
    state), as they will not have any state and will have no [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") with which to load that state, leading to “detached
    instance” errors. The behavior is controllable using a parameter called [`Session.expire_on_commit`](../orm/session_api.html#sqlalchemy.orm.Session.params.expire_on_commit
    "sqlalchemy.orm.Session"). More on this is at [Closing a Session](#tutorial-orm-closing).  ##
    Updating ORM Objects using the Unit of Work pattern'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '注意的一件重要事情是，我们刚刚处理的对象上的属性已经[过期](../glossary.html#term-expired)，意味着，当我们下一次访问它们的任何属性时，[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 将启动一个新的事务并重新加载它们的状态。 这个选项有时对性能原因或者如果希望在关闭[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")后继续使用对象（这被称为[分离](../glossary.html#term-detached)状态）可能会有问题，因为它们将不会有任何状态，并且将没有
    [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    与其一起加载该状态，导致“分离实例”错误。 可以使用一个名为[`Session.expire_on_commit`](../orm/session_api.html#sqlalchemy.orm.Session.params.expire_on_commit
    "sqlalchemy.orm.Session")的参数来控制行为。 更多信息请参见[关闭会话](#tutorial-orm-closing)。  ## 使用工作单元模式更新
    ORM 对象'
- en: In the preceding section [Using UPDATE and DELETE Statements](data_update.html#tutorial-core-update-delete),
    we introduced the [`Update`](../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update") construct that represents a SQL UPDATE statement.
    When using the ORM, there are two ways in which this construct is used. The primary
    way is that it is emitted automatically as part of the [unit of work](../glossary.html#term-unit-of-work)
    process used by the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), where an UPDATE statement is emitted on a per-primary
    key basis corresponding to individual objects that have changes on them.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的一节[使用 UPDATE 和 DELETE 语句](data_update.html#tutorial-core-update-delete)中，我们介绍了代表
    SQL UPDATE 语句的 [`Update`](../core/dml.html#sqlalchemy.sql.expression.Update "sqlalchemy.sql.expression.Update")
    构造。 当使用 ORM 时，有两种方式使用此构造。 主要方式是，它作为[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")使用的工作单元过程的一部分自动发出，其中对具有更改的单个对象对应的每个主键发出一个 UPDATE 语句。
- en: 'Supposing we loaded the `User` object for the username `sandy` into a transaction
    (also showing off the [`Select.filter_by()`](../core/selectable.html#sqlalchemy.sql.expression.Select.filter_by
    "sqlalchemy.sql.expression.Select.filter_by") method as well as the [`Result.scalar_one()`](../core/connections.html#sqlalchemy.engine.Result.scalar_one
    "sqlalchemy.engine.Result.scalar_one") method):'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们将用户名为`sandy`的`User`对象加载到一个事务中（同时还展示了[`Select.filter_by()`](../core/selectable.html#sqlalchemy.sql.expression.Select.filter_by
    "sqlalchemy.sql.expression.Select.filter_by")方法以及[`Result.scalar_one()`](../core/connections.html#sqlalchemy.engine.Result.scalar_one
    "sqlalchemy.engine.Result.scalar_one")方法）：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The Python object `sandy` as mentioned before acts as a **proxy** for the row
    in the database, more specifically the database row **in terms of the current
    transaction**, that has the primary key identity of `2`:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Python 对象`sandy`充当数据库中的行的**代理**，更具体地说，是**相对于当前事务的**具有主键标识`2`的数据库行：
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If we alter the attributes of this object, the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") tracks this change:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们更改此对象的属性，[`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")将跟踪此更改：
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The object appears in a collection called [`Session.dirty`](../orm/session_api.html#sqlalchemy.orm.Session.dirty
    "sqlalchemy.orm.Session.dirty"), indicating the object is “dirty”:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 对象出现在一个名为[`Session.dirty`](../orm/session_api.html#sqlalchemy.orm.Session.dirty
    "sqlalchemy.orm.Session.dirty")的集合中，表示对象“脏”：
- en: '[PRE13]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'When the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    next emits a flush, an UPDATE will be emitted that updates this value in the database.
    As mentioned previously, a flush occurs automatically before we emit any SELECT,
    using a behavior known as **autoflush**. We can query directly for the `User.fullname`
    column from this row and we will get our updated value back:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当[`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")下次执行
    flush 时，将会发出一个 UPDATE，以在数据库中更新此值。如前所述，在发出任何 SELECT 之前，会自动执行 flush，这种行为称为**自动 flush**。我们可以直接查询这一行的`User.fullname`列，我们将得到我们的更新值：
- en: '[PRE14]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We can see above that we requested that the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") execute a single [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") statement. However the SQL emitted shows that
    an UPDATE were emitted as well, which was the flush process pushing out pending
    changes. The `sandy` Python object is now no longer considered dirty:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到上面我们请求[`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")执行了一个单独的[`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select")语句。然而，发出的 SQL 显示了还发出了一个 UPDATE，这是 flush 过程推出挂起的更改。`sandy`
    Python 对象现在不再被认为是脏的：
- en: '[PRE15]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: However note we are **still in a transaction** and our changes have not been
    pushed to the database’s permanent storage. Since Sandy’s last name is in fact
    “Cheeks” not “Squirrel”, we will repair this mistake later when we roll back the
    transaction. But first we’ll make some more data changes.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 然而请注意，我们**仍然处于一个事务中**，我们的更改尚未推送到数据库的永久存储中。由于桑迪的姓实际上是“Cheeks”而不是“Squirrel”，我们将在回滚事务时修复这个错误。但首先我们会做一些更多的数据更改。
- en: See also
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 亦可参见
- en: '[Flushing](../orm/session_basics.html#session-flushing)- details the flush
    process as well as information about the [`Session.autoflush`](../orm/session_api.html#sqlalchemy.orm.Session.params.autoflush
    "sqlalchemy.orm.Session") setting.  ## Deleting ORM Objects using the Unit of
    Work pattern'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '[Flush](../orm/session_basics.html#session-flushing)-详细说明了 flush 过程以及关于[`Session.autoflush`](../orm/session_api.html#sqlalchemy.orm.Session.params.autoflush
    "sqlalchemy.orm.Session")设置的信息。##使用工作单元模式删除 ORM 对象'
- en: 'To round out the basic persistence operations, an individual ORM object may
    be marked for deletion within the [unit of work](../glossary.html#term-unit-of-work)
    process by using the [`Session.delete()`](../orm/session_api.html#sqlalchemy.orm.Session.delete
    "sqlalchemy.orm.Session.delete") method. Let’s load up `patrick` from the database:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成基本的持久性操作，可以使用[`Session.delete()`](../orm/session_api.html#sqlalchemy.orm.Session.delete
    "sqlalchemy.orm.Session.delete")方法在[工作单元](../glossary.html#term-unit-of-work)过程中标记一个个别的ORM对象以进行删除操作。让我们从数据库加载`patrick`：
- en: '[PRE16]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If we mark `patrick` for deletion, as is the case with other operations, nothing
    actually happens yet until a flush proceeds:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们标记`patrick`以进行删除，与其他操作一样，直到进行 flush 才会实际发生任何事情：
- en: '[PRE17]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Current ORM behavior is that `patrick` stays in the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") until the flush proceeds, which as mentioned before
    occurs if we emit a query:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的 ORM 行为是`patrick`会一直留在[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")中，直到 flush 进行，如前所述，如果我们发出查询，就会发生 flush：
- en: '[PRE18]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Above, the SELECT we asked to emit was preceded by a DELETE, which indicated
    the pending deletion for `patrick` proceeded. There was also a `SELECT` against
    the `address` table, which was prompted by the ORM looking for rows in this table
    which may be related to the target row; this behavior is part of a behavior known
    as [cascade](../glossary.html#term-cascade), and can be tailored to work more
    efficiently by allowing the database to handle related rows in `address` automatically;
    the section [delete](../orm/cascades.html#cascade-delete) has all the detail on
    this.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面，我们要求发出的 SELECT 语句之前是一个 DELETE，这表明 `patrick` 的待删除操作已经进行了。还有一个针对 `address`
    表的 `SELECT`，这是由于 ORM 在寻找与目标行可能相关的这个表中的行而引起的；这种行为是所谓的 [级联](../glossary.html#term-cascade)
    行为的一部分，并且可以通过允许数据库自动处理 `address` 中的相关行来更有效地工作；关于此的详细信息请参见 [delete](../orm/cascades.html#cascade-delete)。
- en: See also
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[delete](../orm/cascades.html#cascade-delete) - describes how to tune the behavior
    of [`Session.delete()`](../orm/session_api.html#sqlalchemy.orm.Session.delete
    "sqlalchemy.orm.Session.delete") in terms of how related rows in other tables
    should be handled.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '[delete](../orm/cascades.html#cascade-delete) - 描述了如何调整 [`Session.delete()`](../orm/session_api.html#sqlalchemy.orm.Session.delete
    "sqlalchemy.orm.Session.delete") 的行为，以便处理其他表中的相关行应该如何处理。'
- en: 'Beyond that, the `patrick` object instance now being deleted is no longer considered
    to be persistent within the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), as is shown by the containment check:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，现在正在被删除的 `patrick` 对象实例不再被视为在 [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 中持久存在，这可以通过包含性检查来显示：
- en: '[PRE19]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'However just like the UPDATEs we made to the `sandy` object, every change we’ve
    made here is local to an ongoing transaction, which won’t become permanent if
    we don’t commit it. As rolling the transaction back is actually more interesting
    at the moment, we will do that in the next section.  ## Bulk / Multi Row INSERT,
    upsert, UPDATE and DELETE'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，就像我们对 `sandy` 对象进行的更新一样，我们在这里做出的每一个改变都只在正在进行的事务中有效，如果我们不提交事务，这些改变就不会永久保存。由于此刻回滚事务更加有趣，我们将在下一节中进行。##
    批量/多行 INSERT、upsert、UPDATE 和 DELETE
- en: The [unit of work](../glossary.html#term-unit-of-work) techniques discussed
    in this section are intended to integrate [dml](../glossary.html#term-DML), or
    INSERT/UPDATE/DELETE statements, with Python object mechanics, often involving
    complex graphs of inter-related objects. Once objects are added to a [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") using [`Session.add()`](../orm/session_api.html#sqlalchemy.orm.Session.add
    "sqlalchemy.orm.Session.add"), the unit of work process transparently emits INSERT/UPDATE/DELETE
    on our behalf as attributes on our objects are created and modified.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 本节讨论的工作单元技术旨在将 [dml](../glossary.html#term-DML)（即 INSERT/UPDATE/DELETE 语句）与
    Python 对象机制集成，通常涉及到相互关联对象的复杂图。一旦对象使用 [`Session.add()`](../orm/session_api.html#sqlalchemy.orm.Session.add
    "sqlalchemy.orm.Session.add") 添加到 [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 中，工作单元过程会自动代表我们发出 INSERT/UPDATE/DELETE，因为我们的对象属性被创建和修改。
- en: However, the ORM [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") also has the ability to process commands that allow
    it to emit INSERT, UPDATE and DELETE statements directly without being passed
    any ORM-persisted objects, instead being passed lists of values to be INSERTed,
    UPDATEd, or upserted, or WHERE criteria so that an UPDATE or DELETE statement
    that matches many rows at once can be invoked. This mode of use is of particular
    importance when large numbers of rows must be affected without the need to construct
    and manipulate mapped objects, which may be cumbersome and unnecessary for simplistic,
    performance-intensive tasks such as large bulk inserts.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，ORM [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    也有处理命令的能力，使其能够直接发出 INSERT、UPDATE 和 DELETE 语句，而不需要传递任何 ORM 持久化的对象，而是传递要 INSERT、UPDATE
    或 upsert 的值列表，或者 WHERE 条件，以便可以调用一次匹配多行的 UPDATE 或 DELETE 语句。当需要影响大量行而无需构建和操作映射对象时，这种用法尤为重要，因为对于简单、性能密集型的任务，如大批量插入，这可能是繁琐和不必要的。
- en: The Bulk / Multi row features of the ORM [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") make use of the [`insert()`](../core/dml.html#sqlalchemy.sql.expression.insert
    "sqlalchemy.sql.expression.insert"), [`update()`](../core/dml.html#sqlalchemy.sql.expression.update
    "sqlalchemy.sql.expression.update") and [`delete()`](../core/dml.html#sqlalchemy.sql.expression.delete
    "sqlalchemy.sql.expression.delete") constructs directly, and their usage resembles
    how they are used with SQLAlchemy Core (first introduced in this tutorial at [Using
    INSERT Statements](data_insert.html#tutorial-core-insert) and [Using UPDATE and
    DELETE Statements](data_update.html#tutorial-core-update-delete)). When using
    these constructs with the ORM [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") instead of a plain [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection"), their construction, execution and result handling
    is fully integrated with the ORM.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: ORM的批量/多行功能[`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")直接使用[`insert()`](../core/dml.html#sqlalchemy.sql.expression.insert
    "sqlalchemy.sql.expression.insert")、[`update()`](../core/dml.html#sqlalchemy.sql.expression.update
    "sqlalchemy.sql.expression.update")和[`delete()`](../core/dml.html#sqlalchemy.sql.expression.delete
    "sqlalchemy.sql.expression.delete")构造，并且它们的使用方式类似于与SQLAlchemy Core一起使用它们的方式（首次在本教程中介绍于[使用INSERT语句](data_insert.html#tutorial-core-insert)和[使用UPDATE和DELETE语句](data_update.html#tutorial-core-update-delete)）。当使用这些构造与ORM[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")而不是普通的[`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")时，它们的构建、执行和结果处理与ORM完全集成。
- en: For background and examples on using these features, see the section [ORM-Enabled
    INSERT, UPDATE, and DELETE statements](../orm/queryguide/dml.html#orm-expression-update-delete)
    in the [ORM Querying Guide](../orm/queryguide/index.html).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 关于使用这些功能的背景和示例，请参见[ORM-启用的INSERT、UPDATE和DELETE语句](../orm/queryguide/dml.html#orm-expression-update-delete)部分，位于[ORM查询指南](../orm/queryguide/index.html)中。
- en: See also
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[ORM-Enabled INSERT, UPDATE, and DELETE statements](../orm/queryguide/dml.html#orm-expression-update-delete)
    - in the [ORM Querying Guide](../orm/queryguide/index.html)'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '[ORM-启用的INSERT、UPDATE和DELETE语句](../orm/queryguide/dml.html#orm-expression-update-delete)
    - 在[ORM查询指南](../orm/queryguide/index.html)中'
- en: Rolling Back
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回滚
- en: 'The [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    has a [`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") method that as expected emits a ROLLBACK on
    the SQL connection in progress. However, it also has an effect on the objects
    that are currently associated with the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), in our previous example the Python object `sandy`.
    While we changed the `.fullname` of the `sandy` object to read `"Sandy Squirrel"`,
    we want to roll back this change. Calling [`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") will not only roll back the transaction but
    also **expire** all objects currently associated with this [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), which will have the effect that they will refresh themselves
    when next accessed using a process known as [lazy loading](../glossary.html#term-lazy-loading):'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")有一个[`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback")方法，如预期般在进行中的SQL连接上发出ROLLBACK。但是，它还会影响当前与[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")关联的对象，例如我们先前示例中的Python对象`sandy`。虽然我们将`sandy`对象的`.fullname`更改为读取`"Sandy
    Squirrel"`，但我们想要回滚此更改。调用[`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback")不仅会回滚事务，还会**过期**与此[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")当前关联的所有对象，这将使它们在下次使用时自动刷新，使用一种称为[延迟加载](../glossary.html#term-lazy-loading)的过程：'
- en: '[PRE20]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To view the “expiration” process more closely, we may observe that the Python
    object `sandy` has no state left within its Python `__dict__`, with the exception
    of a special SQLAlchemy internal state object:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 要更仔细地查看“过期”过程，我们可以观察到Python对象`sandy`在其Python`__dict__`中没有留下状态，除了一个特殊的SQLAlchemy内部状态对象：
- en: '[PRE21]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This is the “[expired](../glossary.html#term-expired)” state; accessing the
    attribute again will autobegin a new transaction and refresh `sandy` with the
    current database row:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这是“[过期](../glossary.html#term-expired)”状态；再次访问属性将自动开始一个新的事务，并使用当前数据库行刷新`sandy`：
- en: '[PRE22]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We may now observe that the full database row was also populated into the `__dict__`
    of the `sandy` object:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以观察到完整的数据库行也被填充到`sandy`对象的`__dict__`中：
- en: '[PRE23]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'For deleted objects, when we earlier noted that `patrick` was no longer in
    the session, that object’s identity is also restored:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 对于删除的对象，当我们之前注意到`patrick`不再在会话中时，该对象的身份也被恢复：
- en: '[PRE24]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'and of course the database data is present again as well:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，数据库数据也再次出现了：
- en: '[PRE25]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '## Closing a Session'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '## 关闭会话'
- en: 'Within the above sections we used a [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") object outside of a Python context manager, that is,
    we didn’t use the `with` statement. That’s fine, however if we are doing things
    this way, it’s best that we explicitly close out the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") when we are done with it:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述部分中，我们在 Python 上下文管理器之外使用了一个[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")对象，也就是说，我们没有使用`with`语句。这没问题，但是如果我们以这种方式操作，最好在完成后明确关闭[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")：
- en: '[PRE26]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Closing the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session"),
    which is what happens when we use it in a context manager as well, accomplishes
    the following things:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 关闭[`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")，也就是当我们在上下文管理器中使用它时发生的情况，会实现以下几个目标：
- en: It [releases](../glossary.html#term-releases) all connection resources to the
    connection pool, cancelling out (e.g. rolling back) any transactions that were
    in progress.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它[释放](../glossary.html#term-releases)所有连接资源到连接池中，取消（例如回滚）任何正在进行的事务。
- en: This means that when we make use of a session to perform some read-only tasks
    and then close it, we don’t need to explicitly call upon [`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") to make sure the transaction is rolled back;
    the connection pool handles this.
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这意味着当我们使用一个会话执行一些只读任务然后关闭它时，我们不需要显式调用[`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback")来确保事务被回滚；连接池会处理这个问题。
- en: It **expunges** all objects from the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session").
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它**清除**[`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")中的所有对象。
- en: 'This means that all the Python objects we had loaded for this [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), like `sandy`, `patrick` and `squidward`, are now in
    a state known as [detached](../glossary.html#term-detached). In particular, we
    will note that objects that were still in an [expired](../glossary.html#term-expired)
    state, for example due to the call to [`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit"), are now non-functional, as they don’t contain
    the state of a current row and are no longer associated with any database transaction
    in which to be refreshed:'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这意味着我们为这个[`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")加载的所有
    Python 对象，比如`sandy`、`patrick`和`squidward`，现在处于称为[分离](../glossary.html#term-detached)的状态。特别是，我们会注意到仍处于[过期](../glossary.html#term-expired)状态的对象，例如由于调用了[`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit")，现在已经不可用，因为它们不包含当前行的状态，并且不再与任何数据库事务相关联，也不再可以被刷新：
- en: '[PRE27]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The detached objects can be re-associated with the same, or a new [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") using the [`Session.add()`](../orm/session_api.html#sqlalchemy.orm.Session.add
    "sqlalchemy.orm.Session.add") method, which will re-establish their relationship
    with their particular database row:'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 分离的对象可以使用[`Session.add()`](../orm/session_api.html#sqlalchemy.orm.Session.add
    "sqlalchemy.orm.Session.add")方法重新与相同或新的[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")关联，这将重新建立它们与特定数据库行的关系：
- en: '[PRE28]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Tip
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 提示
- en: 'Try to avoid using objects in their detached state, if possible. When the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is closed, clean up references to all the previously
    attached objects as well. For cases where detached objects are necessary, typically
    the immediate display of just-committed objects for a web application where the
    [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    is closed before the view is rendered, set the [`Session.expire_on_commit`](../orm/session_api.html#sqlalchemy.orm.Session.params.expire_on_commit
    "sqlalchemy.orm.Session") flag to `False`.  ## Inserting Rows using the ORM Unit
    of Work pattern'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 尽量避免使用对象处于分离状态。当关闭 [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 时，也清理对所有先前附加对象的引用。对于需要分离对象的情况，通常是在 Web 应用程序中立即显示刚提交的对象的情况下，其中
    [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    在渲染视图之前关闭，在这种情况下，将 [`Session.expire_on_commit`](../orm/session_api.html#sqlalchemy.orm.Session.params.expire_on_commit
    "sqlalchemy.orm.Session") 标志设置为 `False`。## 使用 ORM 工作单元模式插入行
- en: When using the ORM, the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") object is responsible for constructing [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert") constructs and emitting them as INSERT statements
    within the ongoing transaction. The way we instruct the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") to do so is by **adding** object entries to it; the
    [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    then makes sure these new entries will be emitted to the database when they are
    needed, using a process known as a **flush**. The overall process used by the
    [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    to persist objects is known as the [unit of work](../glossary.html#term-unit-of-work)
    pattern.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 ORM 时，[`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    对象负责构造 [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert "sqlalchemy.sql.expression.Insert")
    构造，并在进行中的事务中发出它们作为 INSERT 语句。我们指示 [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 这样做的方式是通过向其中**添加**对象条目；然后，[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 确保这些新条目在需要时将被发出到数据库中，使用一种称为 **flush** 的过程。[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 用于持久化对象的整体过程称为 [工作单元](../glossary.html#term-unit-of-work)
    模式。
- en: Instances of Classes represent Rows
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类的实例代表行
- en: 'Whereas in the previous example we emitted an INSERT using Python dictionaries
    to indicate the data we wanted to add, with the ORM we make direct use of the
    custom Python classes we defined, back at [Using ORM Declarative Forms to Define
    Table Metadata](metadata.html#tutorial-orm-table-metadata). At the class level,
    the `User` and `Address` classes served as a place to define what the corresponding
    database tables should look like. These classes also serve as extensible data
    objects that we use to create and manipulate rows within a transaction as well.
    Below we will create two `User` objects each representing a potential database
    row to be INSERTed:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 而在上一个示例中，我们使用 Python 字典发出了一个 INSERT，以指示我们要添加的数据，使用 ORM 时，我们直接使用我们在 [使用 ORM 声明性表单定义表元数据](metadata.html#tutorial-orm-table-metadata)
    中定义的自定义 Python 类。在类级别上，`User` 和 `Address` 类充当了定义相应数据库表应该如何的地方。这些类还作为可扩展的数据对象，我们用它来在事务中创建和操作行。下面我们将创建两个
    `User` 对象，每个对象代表一个待插入的潜在数据库行：
- en: '[PRE29]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We are able to construct these objects using the names of the mapped columns
    as keyword arguments in the constructor. This is possible as the `User` class
    includes an automatically generated `__init__()` constructor that was provided
    by the ORM mapping so that we could create each object using column names as keys
    in the constructor.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用映射列的名称作为构造函数中的关键字参数来构造这些对象。这是可能的，因为 `User` 类包含了由 ORM 映射提供的自动生成的 `__init__()`
    构造函数，以便我们可以使用列名作为构造函数中的键来创建每个对象。
- en: 'In a similar manner as in our Core examples of [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert"), we did not include a primary key (i.e. an
    entry for the `id` column), since we would like to make use of the auto-incrementing
    primary key feature of the database, SQLite in this case, which the ORM also integrates
    with. The value of the `id` attribute on the above objects, if we were to view
    it, displays itself as `None`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们Core示例中的[`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert "sqlalchemy.sql.expression.Insert")类似，我们没有包含主键（即`id`列的条目），因为我们希望利用数据库的自动递增主键特性，此处为SQLite，ORM也与之集成。如果我们要查看上述对象的`id`属性的值，则显示为`None`：
- en: '[PRE30]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `None` value is provided by SQLAlchemy to indicate that the attribute has
    no value as of yet. SQLAlchemy-mapped attributes always return a value in Python
    and don’t raise `AttributeError` if they’re missing, when dealing with a new object
    that has not had a value assigned.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`None`值由SQLAlchemy提供，以指示属性目前尚无值。SQLAlchemy映射的属性始终在Python中返回一个值，并且在处理尚未分配值的新对象时不会引发`AttributeError`。'
- en: At the moment, our two objects above are said to be in a state called [transient](../glossary.html#term-transient)
    - they are not associated with any database state and are yet to be associated
    with a [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    object that can generate INSERT statements for them.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们上述的两个对象被称为[transient](../glossary.html#term-transient)状态 - 它们与任何数据库状态都没有关联，尚未关联到可以为它们生成INSERT语句的[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")对象。
- en: Adding objects to a Session
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加对象到会话
- en: 'To illustrate the addition process step by step, we will create a [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") without using a context manager (and hence we must make
    sure we close it later!):'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 为了逐步说明添加过程，我们将创建一个不使用上下文管理器的[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")（因此我们必须确保稍后关闭它！）：
- en: '[PRE31]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The objects are then added to the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") using the [`Session.add()`](../orm/session_api.html#sqlalchemy.orm.Session.add
    "sqlalchemy.orm.Session.add") method. When this is called, the objects are in
    a state known as [pending](../glossary.html#term-pending) and have not been inserted
    yet:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用[`Session.add()`](../orm/session_api.html#sqlalchemy.orm.Session.add "sqlalchemy.orm.Session.add")方法将对象添加到[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")中。当调用此方法时，对象处于称为[pending](../glossary.html#term-pending)的状态，尚未插入：
- en: '[PRE32]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'When we have pending objects, we can see this state by looking at a collection
    on the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    called [`Session.new`](../orm/session_api.html#sqlalchemy.orm.Session.new "sqlalchemy.orm.Session.new"):'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们有待处理的对象时，我们可以通过查看[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")上的一个集合来查看此状态，该集合称为[`Session.new`](../orm/session_api.html#sqlalchemy.orm.Session.new
    "sqlalchemy.orm.Session.new")：
- en: '[PRE33]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The above view is using a collection called `IdentitySet` that is essentially
    a Python set that hashes on object identity in all cases (i.e., using Python built-in
    `id()` function, rather than the Python `hash()` function).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 上述视图使用了一个名为`IdentitySet`的集合，实质上是一个Python集合，以所有情况下的对象标识进行哈希（即使用Python内置的`id()`函数，而不是Python的`hash()`函数）。
- en: Flushing
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 刷新
- en: The [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    makes use of a pattern known as [unit of work](../glossary.html#term-unit-of-work).
    This generally means it accumulates changes one at a time, but does not actually
    communicate them to the database until needed. This allows it to make better decisions
    about how SQL DML should be emitted in the transaction based on a given set of
    pending changes. When it does emit SQL to the database to push out the current
    set of changes, the process is known as a **flush**.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")使用一种称为[unit
    of work](../glossary.html#term-unit-of-work)的模式。这通常意味着它逐一累积更改，但实际上直到需要才会将它们传达到数据库。这允许它根据给定的一组待处理更改做出有关在事务中应该发出SQL
    DML的更好决策。当它发出SQL到数据库以推出当前一组更改时，该过程称为**flush**。'
- en: 'We can illustrate the flush process manually by calling the [`Session.flush()`](../orm/session_api.html#sqlalchemy.orm.Session.flush
    "sqlalchemy.orm.Session.flush") method:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过手动调用[`Session.flush()`](../orm/session_api.html#sqlalchemy.orm.Session.flush
    "sqlalchemy.orm.Session.flush")方法来说明刷新过程：
- en: '[PRE34]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Above we observe the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") was first called upon to emit SQL, so it created a new
    transaction and emitted the appropriate INSERT statements for the two objects.
    The transaction now **remains open** until we call any of the [`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit"), [`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback"), or [`Session.close()`](../orm/session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") methods of [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session").
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，[`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")首先被调用以发出SQL，因此它创建了一个新事务，并为两个对象发出了适当的INSERT语句。直到我们调用[`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit")、[`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback")或[`Session.close()`](../orm/session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close")方法之一，该事务现在**保持打开状态**[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")。
- en: While [`Session.flush()`](../orm/session_api.html#sqlalchemy.orm.Session.flush
    "sqlalchemy.orm.Session.flush") may be used to manually push out pending changes
    to the current transaction, it is usually unnecessary as the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") features a behavior known as **autoflush**, which we
    will illustrate later. It also flushes out changes whenever [`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") is called.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然[`Session.flush()`](../orm/session_api.html#sqlalchemy.orm.Session.flush "sqlalchemy.orm.Session.flush")可以用于手动推送当前事务中的待处理更改，但通常是不必要的，因为[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")具有一个被称为**自动刷新**的行为，我们稍后会说明。每当调用[`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit")时，它也会刷新更改。
- en: Autogenerated primary key attributes
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自动生成的主键属性
- en: Once the rows are inserted, the two Python objects we’ve created are in a state
    known as [persistent](../glossary.html#term-persistent), where they are associated
    with the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    object in which they were added or loaded, and feature lots of other behaviors
    that will be covered later.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦行被插入，我们创建的两个Python对象处于一种称为[持久性](../glossary.html#term-persistent)的状态，它们与它们所添加或加载的[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")对象相关联，并具有许多其他行为，稍后将进行介绍。
- en: 'Another effect of the INSERT that occurred was that the ORM has retrieved the
    new primary key identifiers for each new object; internally it normally uses the
    same [`CursorResult.inserted_primary_key`](../core/connections.html#sqlalchemy.engine.CursorResult.inserted_primary_key
    "sqlalchemy.engine.CursorResult.inserted_primary_key") accessor we introduced
    previously. The `squidward` and `krabs` objects now have these new primary key
    identifiers associated with them and we can view them by accessing the `id` attribute:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: INSERT操作的另一个效果是ORM检索了每个新对象的新主键标识符；内部通常使用我们之前介绍的相同的[`CursorResult.inserted_primary_key`](../core/connections.html#sqlalchemy.engine.CursorResult.inserted_primary_key
    "sqlalchemy.engine.CursorResult.inserted_primary_key")访问器。`squidward`和`krabs`对象现在具有这些新的主键标识符，并且我们可以通过访问`id`属性查看它们：
- en: '[PRE35]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Tip
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Why did the ORM emit two separate INSERT statements when it could have used
    [executemany](dbapi_transactions.html#tutorial-multiple-parameters)? As we’ll
    see in the next section, the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") when flushing objects always needs to know the primary
    key of newly inserted objects. If a feature such as SQLite’s autoincrement is
    used (other examples include PostgreSQL IDENTITY or SERIAL, using sequences, etc.),
    the [`CursorResult.inserted_primary_key`](../core/connections.html#sqlalchemy.engine.CursorResult.inserted_primary_key
    "sqlalchemy.engine.CursorResult.inserted_primary_key") feature usually requires
    that each INSERT is emitted one row at a time. If we had provided values for the
    primary keys ahead of time, the ORM would have been able to optimize the operation
    better. Some database backends such as [psycopg2](../dialects/postgresql.html#postgresql-psycopg2)
    can also INSERT many rows at once while still being able to retrieve the primary
    key values.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么ORM在可以使用[executemany](dbapi_transactions.html#tutorial-multiple-parameters)时发出两个单独的INSERT语句？正如我们将在下一节中看到的那样，当刷新对象时，[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")总是需要知道新插入对象的主键。如果使用了诸如SQLite的自动增量（其他示例包括PostgreSQL IDENTITY或SERIAL，使用序列等）之类的功能，则[`CursorResult.inserted_primary_key`](../core/connections.html#sqlalchemy.engine.CursorResult.inserted_primary_key
    "sqlalchemy.engine.CursorResult.inserted_primary_key")功能通常要求每个INSERT逐行发出。如果我们事先提供了主键的值，ORM将能够更好地优化操作。一些数据库后端，如[psycopg2](../dialects/postgresql.html#postgresql-psycopg2)，也可以一次插入多行，同时仍然能够检索主键值。
- en: Getting Objects by Primary Key from the Identity Map
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过主键从标识映射获取对象
- en: 'The primary key identity of the objects are significant to the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), as the objects are now linked to this identity in memory
    using a feature known as the [identity map](../glossary.html#term-identity-map).
    The identity map is an in-memory store that links all objects currently loaded
    in memory to their primary key identity. We can observe this by retrieving one
    of the above objects using the [`Session.get()`](../orm/session_api.html#sqlalchemy.orm.Session.get
    "sqlalchemy.orm.Session.get") method, which will return an entry from the identity
    map if locally present, otherwise emitting a SELECT:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的主键标识对于[`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")来说非常重要，因为这些对象现在使用一种称为[标识映射](../glossary.html#term-identity-map)的特性与此标识在内存中连接起来。标识映射是一个在内存中的存储器，将当前加载在内存中的所有对象链接到它们的主键标识。我们可以通过使用[`Session.get()`](../orm/session_api.html#sqlalchemy.orm.Session.get
    "sqlalchemy.orm.Session.get")方法检索上述对象之一来观察到这一点，如果本地存在，则会从标识映射中返回一个条目，否则会发出一个SELECT：
- en: '[PRE36]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The important thing to note about the identity map is that it maintains a **unique
    instance** of a particular Python object per a particular database identity, within
    the scope of a particular [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") object. We may observe that the `some_squidward` refers
    to the **same object** as that of `squidward` previously:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 关于标识映射的重要事情是，它在特定[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")对象的范围内维护特定数据库标识的特定Python对象的**唯一实例**。我们可以观察到，`some_squidward`指的是先前的`squidward`的**相同对象**：
- en: '[PRE37]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The identity map is a critical feature that allows complex sets of objects to
    be manipulated within a transaction without things getting out of sync.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 标识映射是一个关键特性，它允许在事务中处理复杂的对象集合而不会使事情失去同步。
- en: Committing
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Committing
- en: 'There’s much more to say about how the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") works which will be discussed further. For now we will
    commit the transaction so that we can build up knowledge on how to SELECT rows
    before examining more ORM behaviors and features:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 关于[`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")的工作还有很多要说的内容，这将在更进一步讨论。现在我们将提交事务，以便在查看更多ORM行为和特性之前构建对如何SELECT行的知识：
- en: '[PRE38]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The above operation will commit the transaction that was in progress. The objects
    which we’ve dealt with are still [attached](../glossary.html#term-attached) to
    the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session"),
    which is a state they stay in until the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is closed (which is introduced at [Closing a Session](#tutorial-orm-closing)).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 上述操作将提交进行中的事务。我们处理过的对象仍然[附加](../glossary.html#term-attached)到[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")上，这是它们保持的状态，直到关闭[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")（在[关闭会话](#tutorial-orm-closing)中介绍）。
- en: Tip
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: An important thing to note is that attributes on the objects that we just worked
    with have been [expired](../glossary.html#term-expired), meaning, when we next
    access any attributes on them, the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") will start a new transaction and re-load their state.
    This option is sometimes problematic for both performance reasons, or if one wishes
    to use the objects after closing the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") (which is known as the [detached](../glossary.html#term-detached)
    state), as they will not have any state and will have no [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") with which to load that state, leading to “detached
    instance” errors. The behavior is controllable using a parameter called [`Session.expire_on_commit`](../orm/session_api.html#sqlalchemy.orm.Session.params.expire_on_commit
    "sqlalchemy.orm.Session"). More on this is at [Closing a Session](#tutorial-orm-closing).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的一点是，我们刚刚使用的对象上的属性已经[过期](../glossary.html#term-expired)，意味着当我们下次访问它们的任何属性时，[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")将启动一个新的事务并重新加载它们的状态。这个选项有时会因为性能原因或者如果希望在关闭[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")后继续使用对象（即已知的[分离](../glossary.html#term-detached)状态），而带来问题，因为它们将没有任何状态，并且将没有任何[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")来加载该状态，导致“分离实例”错误。这种行为可以通过一个名为[`Session.expire_on_commit`](../orm/session_api.html#sqlalchemy.orm.Session.params.expire_on_commit
    "sqlalchemy.orm.Session")的参数来控制。更多信息请参阅[关闭会话](#tutorial-orm-closing)。
- en: Instances of Classes represent Rows
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类的实例代表行
- en: 'Whereas in the previous example we emitted an INSERT using Python dictionaries
    to indicate the data we wanted to add, with the ORM we make direct use of the
    custom Python classes we defined, back at [Using ORM Declarative Forms to Define
    Table Metadata](metadata.html#tutorial-orm-table-metadata). At the class level,
    the `User` and `Address` classes served as a place to define what the corresponding
    database tables should look like. These classes also serve as extensible data
    objects that we use to create and manipulate rows within a transaction as well.
    Below we will create two `User` objects each representing a potential database
    row to be INSERTed:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们使用Python字典发出了一个INSERT，以指示我们想要添加的数据，而使用ORM时，我们直接使用了我们定义的自定义Python类，在[使用ORM声明式表单定义表元数据](metadata.html#tutorial-orm-table-metadata)回到之前。在类级别上，`User`和`Address`类用作定义相应数据库表应该是什么样子的地方。这些类还充当我们用于在事务内创建和操作行的可扩展数据对象。接下来，我们将创建两个`User`对象，每个对象都代表一个可能要INSERT的数据库行：
- en: '[PRE39]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We are able to construct these objects using the names of the mapped columns
    as keyword arguments in the constructor. This is possible as the `User` class
    includes an automatically generated `__init__()` constructor that was provided
    by the ORM mapping so that we could create each object using column names as keys
    in the constructor.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能够使用映射列的名称作为构造函数中的关键字参数来构造这些对象。这是可能的，因为`User`类包含了一个由ORM映射提供的自动生成的`__init__()`构造函数，以便我们可以使用列名作为构造函数中的键来创建每个对象。
- en: 'In a similar manner as in our Core examples of [`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert
    "sqlalchemy.sql.expression.Insert"), we did not include a primary key (i.e. an
    entry for the `id` column), since we would like to make use of the auto-incrementing
    primary key feature of the database, SQLite in this case, which the ORM also integrates
    with. The value of the `id` attribute on the above objects, if we were to view
    it, displays itself as `None`:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们在核心示例中的[`Insert`](../core/dml.html#sqlalchemy.sql.expression.Insert "sqlalchemy.sql.expression.Insert")类似，我们没有包含主键（即`id`列的条目），因为我们希望利用数据库的自动递增主键功能，本例中为SQLite，ORM也与之集成。如果我们查看上述对象的`id`属性的值，会显示为`None`：
- en: '[PRE40]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `None` value is provided by SQLAlchemy to indicate that the attribute has
    no value as of yet. SQLAlchemy-mapped attributes always return a value in Python
    and don’t raise `AttributeError` if they’re missing, when dealing with a new object
    that has not had a value assigned.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`None`值由SQLAlchemy提供，表示该属性目前没有值。SQLAlchemy映射的属性始终在Python中返回一个值，并且在处理尚未分配值的新对象时，不会引发`AttributeError`。'
- en: At the moment, our two objects above are said to be in a state called [transient](../glossary.html#term-transient)
    - they are not associated with any database state and are yet to be associated
    with a [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    object that can generate INSERT statements for them.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们上面的两个对象被称为[瞬态](../glossary.html#term-transient)状态 - 它们与任何数据库状态都没有关联，尚未与可以为它们生成INSERT语句的[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")对象关联。
- en: Adding objects to a Session
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将对象添加到会话
- en: 'To illustrate the addition process step by step, we will create a [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") without using a context manager (and hence we must make
    sure we close it later!):'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 为了逐步说明添加过程，我们将创建一个不使用上下文管理器的[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")（因此我们必须确保稍后关闭它！）：
- en: '[PRE41]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The objects are then added to the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") using the [`Session.add()`](../orm/session_api.html#sqlalchemy.orm.Session.add
    "sqlalchemy.orm.Session.add") method. When this is called, the objects are in
    a state known as [pending](../glossary.html#term-pending) and have not been inserted
    yet:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 然后使用[`Session.add()`](../orm/session_api.html#sqlalchemy.orm.Session.add "sqlalchemy.orm.Session.add")方法将对象添加到[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")中。调用此方法时，对象处于称为[待定](../glossary.html#term-pending)状态，尚未插入：
- en: '[PRE42]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'When we have pending objects, we can see this state by looking at a collection
    on the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    called [`Session.new`](../orm/session_api.html#sqlalchemy.orm.Session.new "sqlalchemy.orm.Session.new"):'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '当我们有待定对象时，可以通过查看[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")上的一个集合来查看这种状态，该集合称为[`Session.new`](../orm/session_api.html#sqlalchemy.orm.Session.new
    "sqlalchemy.orm.Session.new"):'
- en: '[PRE43]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The above view is using a collection called `IdentitySet` that is essentially
    a Python set that hashes on object identity in all cases (i.e., using Python built-in
    `id()` function, rather than the Python `hash()` function).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 上述视图使用一个名为`IdentitySet`的集合，它本质上是一个Python集合，在所有情况下都使用对象标识哈希（即使用Python内置的`id()`函数，而不是Python的`hash()`函数）。
- en: Flushing
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 刷新
- en: The [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    makes use of a pattern known as [unit of work](../glossary.html#term-unit-of-work).
    This generally means it accumulates changes one at a time, but does not actually
    communicate them to the database until needed. This allows it to make better decisions
    about how SQL DML should be emitted in the transaction based on a given set of
    pending changes. When it does emit SQL to the database to push out the current
    set of changes, the process is known as a **flush**.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")使用一种称为[工作单元](../glossary.html#term-unit-of-work)的模式。这通常意味着它逐个累积更改，但直到需要才实际将它们传达给数据库。这使其能够根据给定的一组待定更改更好地决定应该如何发出SQL
    DML。当它向数据库发出SQL以推送当前一组更改时，该过程称为**刷新**。'
- en: 'We can illustrate the flush process manually by calling the [`Session.flush()`](../orm/session_api.html#sqlalchemy.orm.Session.flush
    "sqlalchemy.orm.Session.flush") method:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过调用[`Session.flush()`](../orm/session_api.html#sqlalchemy.orm.Session.flush
    "sqlalchemy.orm.Session.flush")方法手动说明刷新过程：
- en: '[PRE44]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Above we observe the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") was first called upon to emit SQL, so it created a new
    transaction and emitted the appropriate INSERT statements for the two objects.
    The transaction now **remains open** until we call any of the [`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit"), [`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback"), or [`Session.close()`](../orm/session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") methods of [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session").
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 首先我们观察到 [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    首次被调用以发出 SQL，因此它创建了一个新的事务并为两个对象发出了适当的 INSERT 语句。这个事务现在 **保持开启**，直到我们调用 [`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit")、[`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") 或 [`Session.close()`](../orm/session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") 方法之一。
- en: While [`Session.flush()`](../orm/session_api.html#sqlalchemy.orm.Session.flush
    "sqlalchemy.orm.Session.flush") may be used to manually push out pending changes
    to the current transaction, it is usually unnecessary as the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") features a behavior known as **autoflush**, which we
    will illustrate later. It also flushes out changes whenever [`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") is called.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 [`Session.flush()`](../orm/session_api.html#sqlalchemy.orm.Session.flush
    "sqlalchemy.orm.Session.flush") 可以用来手动推送待定更改到当前事务，但通常不需要，因为 [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 具有一种称为 **自动刷新** 的行为，稍后我们将说明。它还会在每次调用 [`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") 时刷新更改。
- en: Autogenerated primary key attributes
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自动生成的主键属性
- en: Once the rows are inserted, the two Python objects we’ve created are in a state
    known as [persistent](../glossary.html#term-persistent), where they are associated
    with the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    object in which they were added or loaded, and feature lots of other behaviors
    that will be covered later.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦行被插入，我们创建的两个 Python 对象处于所谓的 [持久化](../glossary.html#term-persistent) 状态，它们与它们被添加或加载的
    [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    对象相关联，并具有稍后将会介绍的许多其他行为。
- en: 'Another effect of the INSERT that occurred was that the ORM has retrieved the
    new primary key identifiers for each new object; internally it normally uses the
    same [`CursorResult.inserted_primary_key`](../core/connections.html#sqlalchemy.engine.CursorResult.inserted_primary_key
    "sqlalchemy.engine.CursorResult.inserted_primary_key") accessor we introduced
    previously. The `squidward` and `krabs` objects now have these new primary key
    identifiers associated with them and we can view them by accessing the `id` attribute:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: INSERT 操作的另一个效果是 ORM 检索了每个新对象的新主键标识符；内部通常使用我们之前介绍的相同的 [`CursorResult.inserted_primary_key`](../core/connections.html#sqlalchemy.engine.CursorResult.inserted_primary_key
    "sqlalchemy.engine.CursorResult.inserted_primary_key") 访问器。`squidward` 和 `krabs`
    对象现在与这些新的主键标识符相关联，我们可以通过访问 `id` 属性查看它们：
- en: '[PRE45]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Tip
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Why did the ORM emit two separate INSERT statements when it could have used
    [executemany](dbapi_transactions.html#tutorial-multiple-parameters)? As we’ll
    see in the next section, the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") when flushing objects always needs to know the primary
    key of newly inserted objects. If a feature such as SQLite’s autoincrement is
    used (other examples include PostgreSQL IDENTITY or SERIAL, using sequences, etc.),
    the [`CursorResult.inserted_primary_key`](../core/connections.html#sqlalchemy.engine.CursorResult.inserted_primary_key
    "sqlalchemy.engine.CursorResult.inserted_primary_key") feature usually requires
    that each INSERT is emitted one row at a time. If we had provided values for the
    primary keys ahead of time, the ORM would have been able to optimize the operation
    better. Some database backends such as [psycopg2](../dialects/postgresql.html#postgresql-psycopg2)
    can also INSERT many rows at once while still being able to retrieve the primary
    key values.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么ORM在可以使用[executemany](dbapi_transactions.html#tutorial-multiple-parameters)的情况下发出了两个单独的INSERT语句？正如我们将在下一节中看到的那样，当刷新对象时，[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")始终需要知道新插入对象的主键。如果使用了诸如SQLite的自增等功能（其他示例包括PostgreSQL的IDENTITY或SERIAL，使用序列等），则[`CursorResult.inserted_primary_key`](../core/connections.html#sqlalchemy.engine.CursorResult.inserted_primary_key
    "sqlalchemy.engine.CursorResult.inserted_primary_key")特性通常要求每个INSERT一次发出一行。如果我们提前为主键提供了值，ORM将能够更好地优化操作。一些数据库后端，如[psycopg2](../dialects/postgresql.html#postgresql-psycopg2)，也可以一次插入多行，同时仍然能够检索主键值。
- en: Getting Objects by Primary Key from the Identity Map
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从标识映射获取主键的对象
- en: 'The primary key identity of the objects are significant to the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), as the objects are now linked to this identity in memory
    using a feature known as the [identity map](../glossary.html#term-identity-map).
    The identity map is an in-memory store that links all objects currently loaded
    in memory to their primary key identity. We can observe this by retrieving one
    of the above objects using the [`Session.get()`](../orm/session_api.html#sqlalchemy.orm.Session.get
    "sqlalchemy.orm.Session.get") method, which will return an entry from the identity
    map if locally present, otherwise emitting a SELECT:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的主键身份对于[`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")非常重要，因为现在使用称为[标识映射](../glossary.html#term-identity-map)的功能将对象与此标识在内存中连接起来。标识映射是一个在内存中的存储，它将当前加载在内存中的所有对象与它们的主键标识连接起来。我们可以通过使用[`Session.get()`](../orm/session_api.html#sqlalchemy.orm.Session.get
    "sqlalchemy.orm.Session.get")方法之一检索上述对象来观察到这一点，如果在本地存在，则会从标识映射返回一个条目，否则会发出一个SELECT：
- en: '[PRE46]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The important thing to note about the identity map is that it maintains a **unique
    instance** of a particular Python object per a particular database identity, within
    the scope of a particular [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") object. We may observe that the `some_squidward` refers
    to the **same object** as that of `squidward` previously:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 关于标识映射的重要事情是，它在特定的[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")对象的范围内维护了一个特定数据库标识的特定Python对象的**唯一实例**。我们可以观察到，`some_squidward`引用的是之前`squidward`的**同一对象**：
- en: '[PRE47]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The identity map is a critical feature that allows complex sets of objects to
    be manipulated within a transaction without things getting out of sync.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 标识映射是一个关键功能，允许在事务中操作复杂的对象集合而不会出现不同步的情况。
- en: Committing
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提交
- en: 'There’s much more to say about how the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") works which will be discussed further. For now we will
    commit the transaction so that we can build up knowledge on how to SELECT rows
    before examining more ORM behaviors and features:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 关于[`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")如何工作还有很多要说的内容，这将在以后进一步讨论。目前，我们将提交事务，以便在检查更多ORM行为和特性之前积累关于如何SELECT行的知识：
- en: '[PRE48]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The above operation will commit the transaction that was in progress. The objects
    which we’ve dealt with are still [attached](../glossary.html#term-attached) to
    the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session"),
    which is a state they stay in until the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is closed (which is introduced at [Closing a Session](#tutorial-orm-closing)).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 上述操作将提交正在进行的事务。我们处理过的对象仍然[附加](../glossary.html#term-attached)到[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")，这是它们保持的状态，直到[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")关闭（在[关闭会话](#tutorial-orm-closing)中介绍）。
- en: Tip
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: An important thing to note is that attributes on the objects that we just worked
    with have been [expired](../glossary.html#term-expired), meaning, when we next
    access any attributes on them, the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") will start a new transaction and re-load their state.
    This option is sometimes problematic for both performance reasons, or if one wishes
    to use the objects after closing the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") (which is known as the [detached](../glossary.html#term-detached)
    state), as they will not have any state and will have no [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") with which to load that state, leading to “detached
    instance” errors. The behavior is controllable using a parameter called [`Session.expire_on_commit`](../orm/session_api.html#sqlalchemy.orm.Session.params.expire_on_commit
    "sqlalchemy.orm.Session"). More on this is at [Closing a Session](#tutorial-orm-closing).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的重要事项是，我们刚刚处理过的对象上的属性已经[过期](../glossary.html#term-expired)，意味着，当我们下次访问它们的任何属性时，[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")将启动一个新事务并重新加载它们的状态。这个选项有时会因为性能原因或者在关闭[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")后希望使用对象（即[分离](../glossary.html#term-detached)状态）而带来问题，因为它们将不再具有任何状态，并且没有[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")来加载该状态，导致“分离实例”错误。这种行为可以通过一个名为[`Session.expire_on_commit`](../orm/session_api.html#sqlalchemy.orm.Session.params.expire_on_commit
    "sqlalchemy.orm.Session")的参数来控制。更多信息请参考[关闭会话](#tutorial-orm-closing)。
- en: '## Updating ORM Objects using the Unit of Work pattern'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '## 使用工作单元模式更新 ORM 对象'
- en: In the preceding section [Using UPDATE and DELETE Statements](data_update.html#tutorial-core-update-delete),
    we introduced the [`Update`](../core/dml.html#sqlalchemy.sql.expression.Update
    "sqlalchemy.sql.expression.Update") construct that represents a SQL UPDATE statement.
    When using the ORM, there are two ways in which this construct is used. The primary
    way is that it is emitted automatically as part of the [unit of work](../glossary.html#term-unit-of-work)
    process used by the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), where an UPDATE statement is emitted on a per-primary
    key basis corresponding to individual objects that have changes on them.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节[使用 UPDATE 和 DELETE 语句](data_update.html#tutorial-core-update-delete)中，我们介绍了代表
    SQL UPDATE 语句的[`Update`](../core/dml.html#sqlalchemy.sql.expression.Update "sqlalchemy.sql.expression.Update")构造。在使用
    ORM 时，有两种方式可以使用这个构造。主要方式是它会自动作为[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")使用的工作单元过程的一部分发出，其中会针对具有更改的单个对象按照每个主键的方式发出 UPDATE 语句。
- en: 'Supposing we loaded the `User` object for the username `sandy` into a transaction
    (also showing off the [`Select.filter_by()`](../core/selectable.html#sqlalchemy.sql.expression.Select.filter_by
    "sqlalchemy.sql.expression.Select.filter_by") method as well as the [`Result.scalar_one()`](../core/connections.html#sqlalchemy.engine.Result.scalar_one
    "sqlalchemy.engine.Result.scalar_one") method):'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们将用户名为`sandy`的`User`对象加载到一个事务中（同时展示[`Select.filter_by()`](../core/selectable.html#sqlalchemy.sql.expression.Select.filter_by
    "sqlalchemy.sql.expression.Select.filter_by")方法以及[`Result.scalar_one()`](../core/connections.html#sqlalchemy.engine.Result.scalar_one
    "sqlalchemy.engine.Result.scalar_one")方法）：
- en: '[PRE49]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The Python object `sandy` as mentioned before acts as a **proxy** for the row
    in the database, more specifically the database row **in terms of the current
    transaction**, that has the primary key identity of `2`:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Python 对象`sandy`充当数据库中行的**代理**，更具体地说是当前事务中具有主键标识`2`的数据库行：
- en: '[PRE50]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'If we alter the attributes of this object, the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") tracks this change:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们更改此对象的属性，[`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")会跟踪此更改：
- en: '[PRE51]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The object appears in a collection called [`Session.dirty`](../orm/session_api.html#sqlalchemy.orm.Session.dirty
    "sqlalchemy.orm.Session.dirty"), indicating the object is “dirty”:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 对象出现在称为[`Session.dirty`](../orm/session_api.html#sqlalchemy.orm.Session.dirty
    "sqlalchemy.orm.Session.dirty")的集合中，表示对象是“脏”的：
- en: '[PRE52]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'When the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    next emits a flush, an UPDATE will be emitted that updates this value in the database.
    As mentioned previously, a flush occurs automatically before we emit any SELECT,
    using a behavior known as **autoflush**. We can query directly for the `User.fullname`
    column from this row and we will get our updated value back:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 当[`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")再次发出刷新时，将发出一个更新，将此值在数据库中更新。如前所述，在发出任何
    SELECT 之前，刷新会自动发生，使用称为**自动刷新**的行为。我们可以直接查询该行的 `User.fullname` 列，我们将得到我们的更新值：
- en: '[PRE53]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We can see above that we requested that the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") execute a single [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") statement. However the SQL emitted shows that
    an UPDATE were emitted as well, which was the flush process pushing out pending
    changes. The `sandy` Python object is now no longer considered dirty:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到我们请求[`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")执行了一个单独的[`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select")语句。但是，发出的 SQL 表明还发出了 UPDATE，这是刷新过程推出挂起更改。`sandy`
    Python 对象现在不再被视为脏：
- en: '[PRE54]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: However note we are **still in a transaction** and our changes have not been
    pushed to the database’s permanent storage. Since Sandy’s last name is in fact
    “Cheeks” not “Squirrel”, we will repair this mistake later when we roll back the
    transaction. But first we’ll make some more data changes.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 但请注意，我们仍然**处于事务中**，我们的更改尚未推送到数据库的永久存储中。由于 Sandy 的姓实际上是“Cheeks”而不是“Squirrel”，我们稍后会在回滚事务时修复此错误。但首先我们将进行更多的数据更改。
- en: See also
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 另见
- en: '[Flushing](../orm/session_basics.html#session-flushing)- details the flush
    process as well as information about the [`Session.autoflush`](../orm/session_api.html#sqlalchemy.orm.Session.params.autoflush
    "sqlalchemy.orm.Session") setting.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '[刷新](../orm/session_basics.html#session-flushing)-详细介绍了刷新过程以及有关[`Session.autoflush`](../orm/session_api.html#sqlalchemy.orm.Session.params.autoflush
    "sqlalchemy.orm.Session")设置的信息。'
- en: '## Deleting ORM Objects using the Unit of Work pattern'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '## 使用工作单元模式删除 ORM 对象'
- en: 'To round out the basic persistence operations, an individual ORM object may
    be marked for deletion within the [unit of work](../glossary.html#term-unit-of-work)
    process by using the [`Session.delete()`](../orm/session_api.html#sqlalchemy.orm.Session.delete
    "sqlalchemy.orm.Session.delete") method. Let’s load up `patrick` from the database:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完善基本的持久性操作，可以通过使用[`Session.delete()`](../orm/session_api.html#sqlalchemy.orm.Session.delete
    "sqlalchemy.orm.Session.delete")方法在[工作单元](../glossary.html#term-unit-of-work)过程中标记要删除的单个
    ORM 对象。让我们从数据库中加载 `patrick`：
- en: '[PRE55]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'If we mark `patrick` for deletion, as is the case with other operations, nothing
    actually happens yet until a flush proceeds:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们标记`patrick`要删除，就像其他操作一样，直到刷新进行，实际上什么也不会发生：
- en: '[PRE56]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Current ORM behavior is that `patrick` stays in the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") until the flush proceeds, which as mentioned before
    occurs if we emit a query:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 当前的 ORM 行为是，`patrick` 会留在[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")中，直到刷新进行，正如之前提到的，如果我们发出查询：
- en: '[PRE57]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Above, the SELECT we asked to emit was preceded by a DELETE, which indicated
    the pending deletion for `patrick` proceeded. There was also a `SELECT` against
    the `address` table, which was prompted by the ORM looking for rows in this table
    which may be related to the target row; this behavior is part of a behavior known
    as [cascade](../glossary.html#term-cascade), and can be tailored to work more
    efficiently by allowing the database to handle related rows in `address` automatically;
    the section [delete](../orm/cascades.html#cascade-delete) has all the detail on
    this.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 上面，我们要求发出的 SELECT 之前是一个 DELETE，这表明了对 `patrick` 的待删除操作。还有一个针对 `address` 表的 `SELECT`，这是因为
    ORM 在该表中查找可能与目标行相关的行；这种行为是作为 [级联](../glossary.html#term-cascade) 行为的一部分，并且可以通过允许数据库自动处理
    `address` 中的相关行来更高效地进行调整；[delete](../orm/cascades.html#cascade-delete) 部分详细介绍了这一点。
- en: See also
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[delete](../orm/cascades.html#cascade-delete) - describes how to tune the behavior
    of [`Session.delete()`](../orm/session_api.html#sqlalchemy.orm.Session.delete
    "sqlalchemy.orm.Session.delete") in terms of how related rows in other tables
    should be handled.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '[delete](../orm/cascades.html#cascade-delete) - 描述了如何调整 [`Session.delete()`](../orm/session_api.html#sqlalchemy.orm.Session.delete
    "sqlalchemy.orm.Session.delete") 的行为，以便处理其他表中相关行的方式。'
- en: 'Beyond that, the `patrick` object instance now being deleted is no longer considered
    to be persistent within the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), as is shown by the containment check:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，正在删除的 `patrick` 对象实例不再被认为是 [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 中的持久对象，这可以通过包含检查来展示：
- en: '[PRE58]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: However just like the UPDATEs we made to the `sandy` object, every change we’ve
    made here is local to an ongoing transaction, which won’t become permanent if
    we don’t commit it. As rolling the transaction back is actually more interesting
    at the moment, we will do that in the next section.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，就像我们对 `sandy` 对象进行的 UPDATE 一样，我们在这里所做的每一个更改都仅限于正在进行的事务，如果我们不提交它，这些更改就不会变得永久。由于在当前情况下回滚事务更有趣，我们将在下一节中执行该操作。
- en: '## Bulk / Multi Row INSERT, upsert, UPDATE and DELETE'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '## 批量/多行 INSERT、upsert、UPDATE 和 DELETE'
- en: The [unit of work](../glossary.html#term-unit-of-work) techniques discussed
    in this section are intended to integrate [dml](../glossary.html#term-DML), or
    INSERT/UPDATE/DELETE statements, with Python object mechanics, often involving
    complex graphs of inter-related objects. Once objects are added to a [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") using [`Session.add()`](../orm/session_api.html#sqlalchemy.orm.Session.add
    "sqlalchemy.orm.Session.add"), the unit of work process transparently emits INSERT/UPDATE/DELETE
    on our behalf as attributes on our objects are created and modified.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 此部分讨论的[工作单元](../glossary.html#term-unit-of-work)技术旨在将 [dml](../glossary.html#term-DML)
    或 INSERT/UPDATE/DELETE 语句与 Python 对象机制集成，通常涉及复杂的相互关联对象图。一旦对象使用 [`Session.add()`](../orm/session_api.html#sqlalchemy.orm.Session.add
    "sqlalchemy.orm.Session.add") 添加到 [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 中，工作单元过程将自动代表我们发出 INSERT/UPDATE/DELETE，因为我们的对象属性被创建和修改。
- en: However, the ORM [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") also has the ability to process commands that allow
    it to emit INSERT, UPDATE and DELETE statements directly without being passed
    any ORM-persisted objects, instead being passed lists of values to be INSERTed,
    UPDATEd, or upserted, or WHERE criteria so that an UPDATE or DELETE statement
    that matches many rows at once can be invoked. This mode of use is of particular
    importance when large numbers of rows must be affected without the need to construct
    and manipulate mapped objects, which may be cumbersome and unnecessary for simplistic,
    performance-intensive tasks such as large bulk inserts.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，ORM [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    还具有处理命令的能力，使其能够直接发出 INSERT、UPDATE 和 DELETE 语句，而无需传递任何 ORM 持久化的对象，而是传递要 INSERT、UPDATE
    或 upsert 或 WHERE 条件的值列表，以便一次匹配多行的 UPDATE 或 DELETE 语句可以被调用。当需要影响大量行而无需构造和操作映射对象时，此使用模式尤为重要，因为对于简单、性能密集的任务（如大型批量插入），构造和操作映射对象可能会很麻烦和不必要。
- en: The Bulk / Multi row features of the ORM [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") make use of the [`insert()`](../core/dml.html#sqlalchemy.sql.expression.insert
    "sqlalchemy.sql.expression.insert"), [`update()`](../core/dml.html#sqlalchemy.sql.expression.update
    "sqlalchemy.sql.expression.update") and [`delete()`](../core/dml.html#sqlalchemy.sql.expression.delete
    "sqlalchemy.sql.expression.delete") constructs directly, and their usage resembles
    how they are used with SQLAlchemy Core (first introduced in this tutorial at [Using
    INSERT Statements](data_insert.html#tutorial-core-insert) and [Using UPDATE and
    DELETE Statements](data_update.html#tutorial-core-update-delete)). When using
    these constructs with the ORM [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") instead of a plain [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection"), their construction, execution and result handling
    is fully integrated with the ORM.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: ORM [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")的批量/多行功能直接使用了
    [`insert()`](../core/dml.html#sqlalchemy.sql.expression.insert "sqlalchemy.sql.expression.insert")、[`update()`](../core/dml.html#sqlalchemy.sql.expression.update
    "sqlalchemy.sql.expression.update") 和 [`delete()`](../core/dml.html#sqlalchemy.sql.expression.delete
    "sqlalchemy.sql.expression.delete") 构造，并且它们的使用方式类似于它们在 SQLAlchemy Core 中的使用方式（首次在本教程中介绍了[使用
    INSERT 语句](data_insert.html#tutorial-core-insert)和[使用 UPDATE 和 DELETE 语句](data_update.html#tutorial-core-update-delete)）。当使用这些构造与
    ORM [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    而不是普通的[`Connection`](../core/connections.html#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")时，它们的构建、执行和结果处理与
    ORM 完全集成。
- en: For background and examples on using these features, see the section [ORM-Enabled
    INSERT, UPDATE, and DELETE statements](../orm/queryguide/dml.html#orm-expression-update-delete)
    in the [ORM Querying Guide](../orm/queryguide/index.html).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 有关使用这些功能的背景和示例，请参见[ORM 启用的 INSERT、UPDATE 和 DELETE 语句](../orm/queryguide/dml.html#orm-expression-update-delete)部分，在[ORM
    查询指南](../orm/queryguide/index.html)中。
- en: See also
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[ORM-Enabled INSERT, UPDATE, and DELETE statements](../orm/queryguide/dml.html#orm-expression-update-delete)
    - in the [ORM Querying Guide](../orm/queryguide/index.html)'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '[ORM 启用的 INSERT、UPDATE 和 DELETE 语句](../orm/queryguide/dml.html#orm-expression-update-delete)
    - 在 [ORM 查询指南](../orm/queryguide/index.html)中'
- en: Rolling Back
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 回滚
- en: 'The [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    has a [`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") method that as expected emits a ROLLBACK on
    the SQL connection in progress. However, it also has an effect on the objects
    that are currently associated with the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), in our previous example the Python object `sandy`.
    While we changed the `.fullname` of the `sandy` object to read `"Sandy Squirrel"`,
    we want to roll back this change. Calling [`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") will not only roll back the transaction but
    also **expire** all objects currently associated with this [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), which will have the effect that they will refresh themselves
    when next accessed using a process known as [lazy loading](../glossary.html#term-lazy-loading):'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")有一个
    [`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") 方法，如预期的那样，在进行中的 SQL 连接上发出一个 ROLLBACK。然而，它也对当前与[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")关联的对象产生影响，例如我们之前的示例中的 Python 对象`sandy`。虽然我们已经将`sandy`对象的`.fullname`更改为`"Sandy
    Squirrel"`，但我们想要回滚此更改。调用[`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback")不仅会回滚事务，还会**使当前与此[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")关联的所有对象过期**，这将导致它们在下次使用时自动刷新，这个过程称为[惰性加载](../glossary.html#term-lazy-loading)：'
- en: '[PRE59]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'To view the “expiration” process more closely, we may observe that the Python
    object `sandy` has no state left within its Python `__dict__`, with the exception
    of a special SQLAlchemy internal state object:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 要更仔细地查看“到期”过程，我们可以观察到 Python 对象`sandy`在其 Python `__dict__`中没有剩余的状态，除了一个特殊的 SQLAlchemy
    内部状态对象：
- en: '[PRE60]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'This is the “[expired](../glossary.html#term-expired)” state; accessing the
    attribute again will autobegin a new transaction and refresh `sandy` with the
    current database row:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这是“[过期](../glossary.html#term-expired)”状态；再次访问属性将自动开始一个新的事务，并使用当前数据库行刷新`sandy`：
- en: '[PRE61]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'We may now observe that the full database row was also populated into the `__dict__`
    of the `sandy` object:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以观察到`__dict__`中还填充了`sandy`对象的完整数据库行：
- en: '[PRE62]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'For deleted objects, when we earlier noted that `patrick` was no longer in
    the session, that object’s identity is also restored:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 对于已删除的对象，当我们之前注意到`patrick`不再在会话中时，该对象的标识也被恢复：
- en: '[PRE63]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'and of course the database data is present again as well:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，数据库数据也再次出现了：
- en: '[PRE64]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '## Closing a Session'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '## 关闭会话'
- en: 'Within the above sections we used a [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") object outside of a Python context manager, that is,
    we didn’t use the `with` statement. That’s fine, however if we are doing things
    this way, it’s best that we explicitly close out the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") when we are done with it:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述部分中，我们在Python上下文管理器之外使用了一个[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")对象，也就是说，我们没有使用`with`语句。虽然这样做没问题，但如果我们以这种方式操作，最好在完成后明确关闭[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")：
- en: '[PRE65]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Closing the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session"),
    which is what happens when we use it in a context manager as well, accomplishes
    the following things:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 关闭[`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")，也就是我们在上下文管理器中使用它时发生的事情，可以完成以下工作：
- en: It [releases](../glossary.html#term-releases) all connection resources to the
    connection pool, cancelling out (e.g. rolling back) any transactions that were
    in progress.
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它[释放](../glossary.html#term-releases)所有连接资源到连接池，取消（例如回滚）任何正在进行的事务。
- en: This means that when we make use of a session to perform some read-only tasks
    and then close it, we don’t need to explicitly call upon [`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") to make sure the transaction is rolled back;
    the connection pool handles this.
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这意味着当我们使用会话执行一些只读任务然后关闭它时，我们不需要显式调用[`Session.rollback()`](../orm/session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback")来确保事务被回滚；连接池会处理这个。
- en: It **expunges** all objects from the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session").
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它**从[`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")中清除**所有对象。
- en: 'This means that all the Python objects we had loaded for this [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), like `sandy`, `patrick` and `squidward`, are now in
    a state known as [detached](../glossary.html#term-detached). In particular, we
    will note that objects that were still in an [expired](../glossary.html#term-expired)
    state, for example due to the call to [`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit"), are now non-functional, as they don’t contain
    the state of a current row and are no longer associated with any database transaction
    in which to be refreshed:'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这意味着我们为此[`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")加载的所有Python对象，如`sandy`、`patrick`和`squidward`，现在处于一种称为[分离(detached)](../glossary.html#term-detached)的状态。特别是，我们会注意到仍处于[过期(expired)](../glossary.html#term-expired)状态的对象，例如由于对[`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit")的调用而导致的对象，现在已经不再可用，因为它们不包含当前行的状态，也不再与任何数据库事务相关联以进行刷新：
- en: '[PRE66]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'The detached objects can be re-associated with the same, or a new [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") using the [`Session.add()`](../orm/session_api.html#sqlalchemy.orm.Session.add
    "sqlalchemy.orm.Session.add") method, which will re-establish their relationship
    with their particular database row:'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 分离的对象可以使用[`Session.add()`](../orm/session_api.html#sqlalchemy.orm.Session.add
    "sqlalchemy.orm.Session.add")方法重新关联到相同或新的[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")中，该方法将重新建立它们与特定数据库行的关系：
- en: '[PRE67]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Tip
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 提示
- en: Try to avoid using objects in their detached state, if possible. When the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is closed, clean up references to all the previously
    attached objects as well. For cases where detached objects are necessary, typically
    the immediate display of just-committed objects for a web application where the
    [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    is closed before the view is rendered, set the [`Session.expire_on_commit`](../orm/session_api.html#sqlalchemy.orm.Session.params.expire_on_commit
    "sqlalchemy.orm.Session") flag to `False`.
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 尽量避免在可能的情况下使用对象处于分离状态。当[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")关闭时，同时清理所有先前附加对象的引用。对于需要分离对象的情况，通常是在Web应用程序中即时显示刚提交的对象，而[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")在视图呈现之前关闭的情况下，将[`Session.expire_on_commit`](../orm/session_api.html#sqlalchemy.orm.Session.params.expire_on_commit
    "sqlalchemy.orm.Session")标志设置为`False`。
