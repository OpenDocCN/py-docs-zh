["```py\nclass jax.sharding.Sharding\n```", "```py\nproperty addressable_devices: set[Device]\n```", "```py\naddressable_devices_indices_map(global_shape)\n```", "```py\nproperty device_set: set[Device]\n```", "```py\ndevices_indices_map(global_shape)\n```", "```py\nis_equivalent_to(other, ndim)\n```", "```py\nproperty is_fully_addressable: bool\n```", "```py\nproperty is_fully_replicated: bool\n```", "```py\nproperty memory_kind: str | None\n```", "```py\nshard_shape(global_shape)\n```", "```py\nwith_memory_kind(kind)\n```", "```py\nclass jax.sharding.SingleDeviceSharding\n```", "```py\n>>> single_device_sharding = jax.sharding.SingleDeviceSharding(\n...     jax.devices()[0]) \n```", "```py\nproperty device_set: set[Device]\n```", "```py\ndevices_indices_map(global_shape)\n```", "```py\nproperty is_fully_addressable: bool\n```", "```py\nproperty is_fully_replicated: bool\n```", "```py\nproperty memory_kind: str | None\n```", "```py\nwith_memory_kind(kind)\n```", "```py\nclass jax.sharding.NamedSharding\n```", "```py\n>>> from jax.sharding import Mesh\n>>> from jax.sharding import PartitionSpec as P\n>>> mesh = Mesh(np.array(jax.devices()).reshape(2, 4), ('x', 'y'))\n>>> spec = P('x', 'y')\n>>> named_sharding = jax.sharding.NamedSharding(mesh, spec) \n```", "```py\nproperty addressable_devices: set[Device]\n```", "```py\nproperty device_set: set[Device]\n```", "```py\nproperty is_fully_addressable: bool\n```", "```py\nproperty is_fully_replicated: bool\n```", "```py\nproperty memory_kind: str | None\n```", "```py\nproperty mesh\n```", "```py\nproperty spec\n```", "```py\nwith_memory_kind(kind)\n```", "```py\nclass jax.sharding.PositionalSharding(devices, *, memory_kind=None)\n```", "```py\nproperty device_set: set[Device]\n```", "```py\nproperty is_fully_addressable: bool\n```", "```py\nproperty is_fully_replicated: bool\n```", "```py\nproperty memory_kind: str | None\n```", "```py\nwith_memory_kind(kind)\n```", "```py\nclass jax.sharding.PmapSharding\n```", "```py\nclassmethod default(shape, sharded_dim=0, devices=None)\n```", "```py\nproperty device_set: set[Device]\n```", "```py\nproperty devices\n```", "```py\ndevices_indices_map(global_shape)\n```", "```py\nis_equivalent_to(other, ndim)\n```", "```py\nproperty is_fully_addressable: bool\n```", "```py\nproperty is_fully_replicated: bool\n```", "```py\nproperty memory_kind: str | None\n```", "```py\nshard_shape(global_shape)\n```", "```py\nproperty sharding_spec\n```", "```py\nwith_memory_kind(kind)\n```", "```py\nclass jax.sharding.GSPMDSharding\n```", "```py\nproperty device_set: set[Device]\n```", "```py\nproperty is_fully_addressable: bool\n```", "```py\nproperty is_fully_replicated: bool\n```", "```py\nproperty memory_kind: str | None\n```", "```py\nwith_memory_kind(kind)\n```", "```py\nclass jax.sharding.PartitionSpec(*partitions)\n```", "```py\nclass jax.sharding.Mesh(devices, axis_names)\n```", "```py\n>>> from jax.experimental.pjit import pjit\n>>> from jax.sharding import Mesh\n>>> from jax.sharding import PartitionSpec as P\n>>> import numpy as np\n...\n>>> inp = np.arange(16).reshape((8, 2))\n>>> devices = np.array(jax.devices()).reshape(4, 2)\n...\n>>> # Declare a 2D mesh with axes `x` and `y`.\n>>> global_mesh = Mesh(devices, ('x', 'y'))\n>>> # Use the mesh object directly as a context manager.\n>>> with global_mesh:\n...   out = pjit(lambda x: x, in_shardings=None, out_shardings=None)(inp) \n```", "```py\n>>> # Initialize the Mesh and use the mesh as the context manager.\n>>> with Mesh(devices, ('x', 'y')) as global_mesh:\n...   out = pjit(lambda x: x, in_shardings=None, out_shardings=None)(inp) \n```", "```py\n>>> # Also you can use it as `with ... as ...`.\n>>> global_mesh = Mesh(devices, ('x', 'y'))\n>>> with global_mesh as m:\n...   out = pjit(lambda x: x, in_shardings=None, out_shardings=None)(inp) \n```", "```py\n>>> # You can also use it as `with Mesh(...)`.\n>>> with Mesh(devices, ('x', 'y')):\n...   out = pjit(lambda x: x, in_shardings=None, out_shardings=None)(inp) \n```"]