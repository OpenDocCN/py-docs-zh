- en: Custom derivative rules for JAX-transformable Python functions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JAX 可转换的 Python 函数的自定义导数规则
- en: 原文：[`jax.readthedocs.io/en/latest/notebooks/Custom_derivative_rules_for_Python_code.html`](https://jax.readthedocs.io/en/latest/notebooks/Custom_derivative_rules_for_Python_code.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[`jax.readthedocs.io/en/latest/notebooks/Custom_derivative_rules_for_Python_code.html`](https://jax.readthedocs.io/en/latest/notebooks/Custom_derivative_rules_for_Python_code.html)
- en: '![Open in Colab](https://colab.research.google.com/github/google/jax/blob/main/docs/notebooks/Custom_derivative_rules_for_Python_code.ipynb)
    ![Open in Kaggle](https://kaggle.com/kernels/welcome?src=https://github.com/google/jax/blob/main/docs/notebooks/Custom_derivative_rules_for_Python_code.ipynb)'
  id: totrans-2
  prefs: []
  type: TYPE_IMG
  zh: '![在 Colab 中打开](https://colab.research.google.com/github/google/jax/blob/main/docs/notebooks/Custom_derivative_rules_for_Python_code.ipynb)
    ![在 Kaggle 中打开](https://kaggle.com/kernels/welcome?src=https://github.com/google/jax/blob/main/docs/notebooks/Custom_derivative_rules_for_Python_code.ipynb)'
- en: '*mattjj@ Mar 19 2020, last updated Oct 14 2020*'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*mattjj@ Mar 19 2020, last updated Oct 14 2020*'
- en: 'There are two ways to define differentiation rules in JAX:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: JAX 中定义微分规则的两种方式：
- en: using `jax.custom_jvp` and `jax.custom_vjp` to define custom differentiation
    rules for Python functions that are already JAX-transformable; and
  id: totrans-5
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `jax.custom_jvp` 和 `jax.custom_vjp` 来为已经可转换为 JAX 的 Python 函数定义自定义微分规则；以及
- en: defining new `core.Primitive` instances along with all their transformation
    rules, for example to call into functions from other systems like solvers, simulators,
    or general numerical computing systems.
  id: totrans-6
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义新的 `core.Primitive` 实例及其所有转换规则，例如调用来自其他系统（如求解器、模拟器或一般数值计算系统）的函数。
- en: 'This notebook is about #1\. To read instead about #2, see the [notebook on
    adding primitives](https://jax.readthedocs.io/en/latest/notebooks/How_JAX_primitives_work.html).'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '本笔记本讨论的是 #1\. 要了解关于 #2 的信息，请参阅[关于添加原语的笔记本](https://jax.readthedocs.io/en/latest/notebooks/How_JAX_primitives_work.html)。'
- en: For an introduction to JAX’s automatic differentiation API, see [The Autodiff
    Cookbook](https://jax.readthedocs.io/en/latest/notebooks/autodiff_cookbook.html).
    This notebook assumes some familiarity with [jax.jvp](https://jax.readthedocs.io/en/latest/jax.html#jax.jvp)
    and [jax.grad](https://jax.readthedocs.io/en/latest/jax.html#jax.grad), and the
    mathematical meaning of JVPs and VJPs.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 JAX 自动微分 API 的介绍，请参阅[自动微分手册](https://jax.readthedocs.io/en/latest/notebooks/autodiff_cookbook.html)。本笔记本假定读者已对[jax.jvp](https://jax.readthedocs.io/en/latest/jax.html#jax.jvp)和[jax.grad](https://jax.readthedocs.io/en/latest/jax.html#jax.grad)，以及
    JVPs 和 VJPs 的数学含义有一定了解。
- en: TL;DR
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TL;DR
- en: Custom JVPs with `jax.custom_jvp`
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 `jax.custom_jvp` 进行自定义 JVPs
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Custom VJPs with `jax.custom_vjp`
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 `jax.custom_vjp` 进行自定义 VJPs
- en: '[PRE6]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Example problems
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例问题
- en: To get an idea of what problems `jax.custom_jvp` and `jax.custom_vjp` are meant
    to solve, let’s go over a few examples. A more thorough introduction to the `jax.custom_jvp`
    and `jax.custom_vjp` APIs is in the next section.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解 `jax.custom_jvp` 和 `jax.custom_vjp` 所解决的问题，我们可以看几个例子。有关 `jax.custom_jvp`
    和 `jax.custom_vjp` API 的更详细介绍在下一节中。
- en: Numerical stability
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数值稳定性
- en: One application of `jax.custom_jvp` is to improve the numerical stability of
    differentiation.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`jax.custom_jvp` 的一个应用是提高微分的数值稳定性。'
- en: 'Say we want to write a function called `log1pexp`, which computes \(x \mapsto
    \log ( 1 + e^x )\). We can write that using `jax.numpy`:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想编写一个名为 `log1pexp` 的函数，用于计算 \(x \mapsto \log ( 1 + e^x )\)。我们可以使用 `jax.numpy`
    来写：
- en: '[PRE9]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Since it’s written in terms of `jax.numpy`, it’s JAX-transformable:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 因为它是用 `jax.numpy` 编写的，所以它是 JAX 可转换的：
- en: '[PRE11]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'But there’s a numerical stability problem lurking here:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 但这里存在一个数值稳定性问题：
- en: '[PRE13]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: That doesn’t seem right! After all, the derivative of \(x \mapsto \log (1 +
    e^x)\) is \(x \mapsto \frac{e^x}{1 + e^x}\), and so for large values of \(x\)
    we’d expect the value to be about 1.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 那似乎不对！毕竟，\(x \mapsto \log (1 + e^x)\) 的导数是 \(x \mapsto \frac{e^x}{1 + e^x}\)，因此对于大的
    \(x\) 值，我们期望值约为 1。
- en: 'We can get a bit more insight into what’s going on by looking at the jaxpr
    for the gradient computation:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看梯度计算的 jaxpr，我们可以更深入地了解发生了什么：
- en: '[PRE15]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Stepping through how the jaxpr would be evaluated, we can see that the last
    line would involve multiplying values that floating point math will round to 0
    and \(\infty\), respectively, which is never a good idea. That is, we’re effectively
    evaluating `lambda x: (1 / (1 + jnp.exp(x))) * jnp.exp(x)` for large `x`, which
    effectively turns into `0. * jnp.inf`.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '通过分析 jaxpr 如何评估，我们可以看到最后一行涉及的值相乘会导致浮点数计算四舍五入为 0 和 \(\infty\)，这从未是一个好主意。也就是说，我们实际上在评估大数值的情况下，计算的是
    `lambda x: (1 / (1 + jnp.exp(x))) * jnp.exp(x)`，这实际上会变成 `0. * jnp.inf`。'
- en: Instead of generating such large and small values, hoping for a cancellation
    that floats can’t always provide, we’d rather just express the derivative function
    as a more numerically stable program. In particular, we can write a program that
    more closely evaluates the equal mathematical expression \(1 - \frac{1}{1 + e^x}\),
    with no cancellation in sight.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是生成这样大和小的值，希望浮点数能够提供的取消，我们宁愿将导数函数表达为一个更稳定的数值程序。特别地，我们可以编写一个程序，更接近地评估相等的数学表达式
    \(1 - \frac{1}{1 + e^x}\)，看不到取消。
- en: This problem is interesting because even though our definition of `log1pexp`
    could already be JAX-differentiated (and transformed with `jit`, `vmap`, …), we’re
    not happy with the result of applying standard autodiff rules to the primitives
    comprising `log1pexp` and composing the result. Instead, we’d like to specify
    how the whole function `log1pexp` should be differentiated, as a unit, and thus
    arrange those exponentials better.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题很有趣，因为即使我们的`log1pexp`的定义已经可以进行JAX微分（并且可以使用`jit`、`vmap`等转换），我们对应用标准自动微分规则到组成`log1pexp`并组合结果的结果并不满意。相反，我们想要指定整个函数`log1pexp`如何作为一个单位进行微分，从而更好地安排这些指数。
- en: 'This is one application of custom derivative rules for Python functions that
    are already JAX transformable: specifying how a composite function should be differentiated,
    while still using its original Python definition for other transformations (like
    `jit`, `vmap`, …).'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这是关于Python函数的自定义导数规则的一个应用，这些函数已经可以使用JAX进行转换：指定如何对复合函数进行微分，同时仍然使用其原始的Python定义进行其他转换（如`jit`、`vmap`等）。
- en: 'Here’s a solution using `jax.custom_jvp`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是使用`jax.custom_jvp`的解决方案：
- en: '[PRE17]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Here’s a `defjvps` convenience wrapper to express the same thing:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个`defjvps`方便包装，来表达同样的事情：
- en: '[PRE22]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Enforcing a differentiation convention
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 强制执行微分约定
- en: A related application is to enforce a differentiation convention, perhaps at
    a boundary.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 一个相关的应用是强制执行微分约定，也许在边界处。
- en: 'Consider the function \(f : \mathbb{R}_+ \to \mathbb{R}_+\) with \(f(x) = \frac{x}{1
    + \sqrt{x}}\), where we take \(\mathbb{R}_+ = [0, \infty)\). We might implement
    \(f\) as a program like this:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '考虑函数 \(f : \mathbb{R}_+ \to \mathbb{R}_+\)，其中 \(f(x) = \frac{x}{1 + \sqrt{x}}\)，其中我们取
    \(\mathbb{R}_+ = [0, \infty)\)。我们可以像这样实现 \(f\) 的程序：'
- en: '[PRE25]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'As a mathematical function on \(\mathbb{R}\) (the full real line), \(f\) is
    not differentiable at zero (because the limit defining the derivative doesn’t
    exist from the left). Correspondingly, autodiff produces a `nan` value:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 作为在\(\mathbb{R}\)上的数学函数（完整的实数线），\(f\) 在零点是不可微的（因为从左侧定义导数的极限不存在）。相应地，自动微分产生一个`nan`值：
- en: '[PRE26]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: But mathematically if we think of \(f\) as a function on \(\mathbb{R}_+\) then
    it is differentiable at 0 [Rudin’s Principles of Mathematical Analysis Definition
    5.1, or Tao’s Analysis I 3rd ed. Definition 10.1.1 and Example 10.1.6]. Alternatively,
    we might say as a convention we want to consider the directional derivative from
    the right. So there is a sensible value for the Python function `grad(f)` to return
    at `0.0`, namely `1.0`. By default, JAX’s machinery for differentiation assumes
    all functions are defined over \(\mathbb{R}\) and thus doesn’t produce `1.0` here.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 但是数学上，如果我们将 \(f\) 视为 \(\mathbb{R}_+\) 上的函数，则它在0处是可微的 [Rudin的《数学分析原理》定义5.1，或Tao的《分析I》第3版定义10.1.1和例子10.1.6]。或者，我们可能会说，作为一个惯例，我们希望考虑从右边的方向导数。因此，对于Python函数`grad(f)`在`0.0`处返回1.0是有意义的值。默认情况下，JAX对微分的机制假设所有函数在\(\mathbb{R}\)上定义，因此这里并不会产生`1.0`。
- en: We can use a custom JVP rule! In particular, we can define the JVP rule in terms
    of the derivative function \(x \mapsto \frac{\sqrt{x} + 2}{2(\sqrt{x} + 1)²}\)
    on \(\mathbb{R}_+\),
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用自定义的JVP规则！特别地，我们可以定义JVP规则，关于导数函数 \(x \mapsto \frac{\sqrt{x} + 2}{2(\sqrt{x}
    + 1)²}\) 在 \(\mathbb{R}_+\) 上，
- en: '[PRE28]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Here’s the convenience wrapper version:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是方便包装版本：
- en: '[PRE31]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Gradient clipping
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 梯度剪裁
- en: While in some cases we want to express a mathematical differentiation computation,
    in other cases we may even want to take a step away from mathematics to adjust
    the computation autodiff performs. One canonical example is reverse-mode gradient
    clipping.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在某些情况下，我们想要表达一个数学微分计算，在其他情况下，我们甚至可能想要远离数学，来调整自动微分的计算。一个典型的例子是反向模式梯度剪裁。
- en: 'For gradient clipping, we can use `jnp.clip` together with a `jax.custom_vjp`
    reverse-mode-only rule:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 对于梯度剪裁，我们可以使用`jnp.clip`和一个`jax.custom_vjp`仅逆模式规则：
- en: '[PRE34]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '![../_images/deaae0f99458d9656c1888a740e8fddef86e7a2a68deda903918a80e0b7597be.png](img/db04498f1c15c9de087b25ad2925e897.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![../_images/deaae0f99458d9656c1888a740e8fddef86e7a2a68deda903918a80e0b7597be.png](img/db04498f1c15c9de087b25ad2925e897.png)'
- en: '[PRE37]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '![../_images/8b564451d0b054ab4486979b76183ae8af108a4d106652226651c16843285dde.png](img/fb08b3bfb2e8954bf4b93b2246d79f03.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![../_images/8b564451d0b054ab4486979b76183ae8af108a4d106652226651c16843285dde.png](img/fb08b3bfb2e8954bf4b93b2246d79f03.png)'
- en: Python debugging
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Python 调试
- en: Another application that is motivated by development workflow rather than numerics
    is to set a `pdb` debugger trace in the backward pass of reverse-mode autodiff.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个应用，是受开发工作流程而非数值驱动的动机，是在反向模式自动微分的后向传递中设置`pdb`调试器跟踪。
- en: When trying to track down the source of a `nan` runtime error, or just examine
    carefully the cotangent (gradient) values being propagated, it can be useful to
    insert a debugger at a point in the backward pass that corresponds to a specific
    point in the primal computation. You can do that with `jax.custom_vjp`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试追踪`nan`运行时错误的来源，或者仅仔细检查传播的余切（梯度）值时，可以在反向传递中的特定点插入调试器非常有用。您可以使用`jax.custom_vjp`来实现这一点。
- en: We’ll defer an example until the next section.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节中推迟一个示例。
- en: Implicit function differentiation of iterative implementations
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 迭代实现的隐式函数微分
- en: This example gets pretty deep in the mathematical weeds!
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子涉及到了数学中的深层问题！
- en: Another application for `jax.custom_vjp` is reverse-mode differentiation of
    functions that are JAX-transformable (by `jit`, `vmap`, …) but not efficiently
    JAX-differentiable for some reason, perhaps because they involve `lax.while_loop`.
    (It’s not possible to produce an XLA HLO program that efficiently computes the
    reverse-mode derivative of an XLA HLO While loop because that would require a
    program with unbounded memory use, which isn’t possible to express in XLA HLO,
    at least without side-effecting interactions through infeed/outfeed.)
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个应用`jax.custom_vjp`是对可通过`jit`、`vmap`等转换为JAX但由于某些原因不易JAX可区分的函数进行反向模式微分，也许是因为涉及`lax.while_loop`。（无法生成XLA
    HLO程序有效计算XLA HLO While循环的反向模式导数，因为这将需要具有无界内存使用的程序，这在XLA HLO中是不可能表达的，至少不是通过通过infeed/outfeed的副作用交互。）
- en: 'For example, consider this `fixed_point` routine which computes a fixed point
    by iteratively applying a function in a `while_loop`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑这个`fixed_point`例程，它通过在`while_loop`中迭代应用函数来计算一个不动点：
- en: '[PRE39]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This is an iterative procedure for numerically solving the equation \(x = f(a,
    x)\) for \(x\), by iterating \(x_{t+1} = f(a, x_t)\) until \(x_{t+1}\) is sufficiently
    close to \(x_t\). The result \(x^*\) depends on the parameters \(a\), and so we
    can think of there being a function \(a \mapsto x^*(a)\) that is implicitly defined
    by equation \(x = f(a, x)\).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种通过迭代应用函数\(x_{t+1} = f(a, x_t)\)来数值解方程\(x = f(a, x)\)以计算\(x\)的迭代过程，直到\(x_{t+1}\)足够接近\(x_t\)。结果\(x^*\)取决于参数\(a\)，因此我们可以认为存在一个由方程\(x
    = f(a, x)\)隐式定义的函数\(a \mapsto x^*(a)\)。
- en: 'We can use `fixed_point` to run iterative procedures to convergence, for example
    running Newton’s method to calculate square roots while only executing adds, multiplies,
    and divides:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`fixed_point`运行迭代过程以收敛，例如运行牛顿法来计算平方根，只执行加法、乘法和除法：
- en: '[PRE40]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We can `vmap` or `jit` the function as well:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以对函数进行`vmap`或`jit`处理：
- en: '[PRE43]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We can’t apply reverse-mode automatic differentiation because of the `while_loop`,
    but it turns out we wouldn’t want to anyway: instead of differentiating through
    the implementation of `fixed_point` and all its iterations, we can exploit the
    mathematical structure to do something that is much more memory-efficient (and
    FLOP-efficient in this case, too!). We can instead use the implicit function theorem
    [Prop A.25 of Bertsekas’s Nonlinear Programming, 2nd ed.], which guarantees (under
    some conditions) the existence of the mathematical objects we’re about to use.
    In essence, we linearize at the solution and solve those linear equations iteratively
    to compute the derivatives we want.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`while_loop`，我们无法应用反向模式自动微分，但事实证明我们也不想这样做：我们可以利用数学结构做一些更节省内存（在这种情况下也更节省FLOP）的事情！我们可以使用隐函数定理[Bertsekas的《非线性规划，第二版》附录A.25]，它保证（在某些条件下）我们即将使用的数学对象的存在。本质上，我们在线性化解决方案处进行线性化，并迭代解这些线性方程以计算我们想要的导数。
- en: Consider again the equation \(x = f(a, x)\) and the function \(x^*\). We want
    to evaluate vector-Jacobian products like \(v^\mathsf{T} \mapsto v^\mathsf{T}
    \partial x^*(a_0)\).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 再次考虑方程\(x = f(a, x)\)和函数\(x^*\)。我们想要评估向量-Jacobian乘积，如\(v^\mathsf{T} \mapsto
    v^\mathsf{T} \partial x^*(a_0)\)。
- en: 'At least in an open neighborhood around the point \(a_0\) at which we want
    to differentiate, let’s assume that the equation \(x^*(a) = f(a, x^*(a))\) holds
    for all \(a\). Since the two sides are equal as functions of \(a\), their derivatives
    must be equal as well, so let’s differentiate both sides:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 至少在我们想要求微分的点\(a_0\)周围的开放邻域内，让我们假设方程\(x^*(a) = f(a, x^*(a))\)对所有\(a\)都成立。由于两边作为\(a\)的函数相等，它们的导数也必须相等，所以让我们分别对两边进行微分：
- en: \(\qquad \partial x^*(a) = \partial_0 f(a, x^*(a)) + \partial_1 f(a, x^*(a))
    \partial x^*(a)\).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: \(\qquad \partial x^*(a) = \partial_0 f(a, x^*(a)) + \partial_1 f(a, x^*(a))
    \partial x^*(a)\)。
- en: Setting \(A = \partial_1 f(a_0, x^*(a_0))\) and \(B = \partial_0 f(a_0, x^*(a_0))\),
    we can write the quantity we’re after more simply as
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 设置\(A = \partial_1 f(a_0, x^*(a_0))\)和\(B = \partial_0 f(a_0, x^*(a_0))\)，我们可以更简单地写出我们想要的数量为
- en: \(\qquad \partial x^*(a_0) = B + A \partial x^*(a_0)\),
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: \(\qquad \partial x^*(a_0) = B + A \partial x^*(a_0)\)，
- en: or, by rearranging,
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，通过重新排列，
- en: \(\qquad \partial x^*(a_0) = (I - A)^{-1} B\).
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: \(\qquad \partial x^*(a_0) = (I - A)^{-1} B\)。
- en: That means we can evaluate vector-Jacobian products like
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们可以评估向量-Jacobian乘积，如
- en: \(\qquad v^\mathsf{T} \partial x^*(a_0) = v^\mathsf{T} (I - A)^{-1} B = w^\mathsf{T}
    B\),
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: \(\qquad v^\mathsf{T} \partial x^*(a_0) = v^\mathsf{T} (I - A)^{-1} B = w^\mathsf{T}
    B\)，
- en: where \(w^\mathsf{T} = v^\mathsf{T} (I - A)^{-1}\), or equivalently \(w^\mathsf{T}
    = v^\mathsf{T} + w^\mathsf{T} A\), or equivalently \(w^\mathsf{T}\) is the fixed
    point of the map \(u^\mathsf{T} \mapsto v^\mathsf{T} + u^\mathsf{T} A\). That
    last characterization gives us a way to write the VJP for `fixed_point` in terms
    of a call to `fixed_point`! Moreover, after expanding \(A\) and \(B\) back out,
    we can see we need only to evaluate VJPs of \(f\) at \((a_0, x^*(a_0))\).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 其中\(w^\mathsf{T} = v^\mathsf{T} (I - A)^{-1}\)，或者等效地\(w^\mathsf{T} = v^\mathsf{T}
    + w^\mathsf{T} A\)，或者等效地\(w^\mathsf{T}\)是映射\(u^\mathsf{T} \mapsto v^\mathsf{T}
    + u^\mathsf{T} A\)的不动点。最后一个描述使我们可以根据对`fixed_point`的调用来编写`fixed_point`的VJP！此外，在展开\(A\)和\(B\)之后，我们可以看到我们只需要在\((a_0,
    x^*(a_0))\)处评估\(f\)的VJP。
- en: 'Here’s the upshot:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是要点：
- en: '[PRE45]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We can check our answers by differentiating `jnp.sqrt`, which uses a totally
    different implementation:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过对 `jnp.sqrt` 进行微分来检查我们的答案，它使用了完全不同的实现：
- en: '[PRE50]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: A limitation to this approach is that the argument `f` can’t close over any
    values involved in differentiation. That is, you might notice that we kept the
    parameter `a` explicit in the argument list of `fixed_point`. For this use case,
    consider using the low-level primitive `lax.custom_root`, which allows for deriviatives
    in closed-over variables with custom root-finding functions.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的一个限制是参数`f`不能涉及到任何参与微分的值。也就是说，你可能注意到我们在`fixed_point`的参数列表中明确保留了参数`a`。对于这种用例，考虑使用低级原语`lax.custom_root`，它允许在闭合变量中进行带有自定义根查找函数的导数。
- en: Basic usage of `jax.custom_jvp` and `jax.custom_vjp` APIs
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `jax.custom_jvp` 和 `jax.custom_vjp` API 的基本用法
- en: Use `jax.custom_jvp` to define forward-mode (and, indirectly, reverse-mode)
    rules
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 `jax.custom_jvp` 来定义前向模式（以及间接地，反向模式）规则
- en: 'Here’s a canonical basic example of using `jax.custom_jvp`, where the comments
    use [Haskell-like type signatures](https://wiki.haskell.org/Type_signature):'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是使用 `jax.custom_jvp` 的典型基本示例，其中注释使用[Haskell-like type signatures](https://wiki.haskell.org/Type_signature)。
- en: '[PRE52]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: In words, we start with a primal function `f` that takes inputs of type `a`
    and produces outputs of type `b`. We associate with it a JVP rule function `f_jvp`
    that takes a pair of inputs representing the primal inputs of type `a` and the
    corresponding tangent inputs of type `T a`, and produces a pair of outputs representing
    the primal outputs of type `b` and tangent outputs of type `T b`. The tangent
    outputs should be a linear function of the tangent inputs.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 简言之，我们从一个原始函数`f`开始，它接受类型为`a`的输入并产生类型为`b`的输出。我们与之关联一个JVP规则函数`f_jvp`，它接受一对输入，表示类型为`a`的原始输入和类型为`T
    a`的相应切线输入，并产生一对输出，表示类型为`b`的原始输出和类型为`T b`的切线输出。切线输出应该是切线输入的线性函数。
- en: You can also use `f.defjvp` as a decorator, as in
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用 `f.defjvp` 作为装饰器，就像这样
- en: '[PRE56]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Even though we defined only a JVP rule and no VJP rule, we can use both forward-
    and reverse-mode differentiation on `f`. JAX will automatically transpose the
    linear computation on tangent values from our custom JVP rule, computing the VJP
    as efficiently as if we had written the rule by hand:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们只定义了一个JVP规则而没有VJP规则，但我们可以在`f`上同时使用正向和反向模式的微分。JAX会自动将切线值上的线性计算从我们的自定义JVP规则转置，高效地计算出VJP，就好像我们手工编写了规则一样。
- en: '[PRE57]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: For automatic transposition to work, the JVP rule’s output tangents must be
    linear as a function of the input tangents. Otherwise a transposition error is
    raised.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使自动转置工作，JVP规则的输出切线必须是输入切线的线性函数。否则将引发转置错误。
- en: 'Multiple arguments work like this:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 多个参数的工作方式如下：
- en: '[PRE59]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The `defjvps` convenience wrapper lets us define a JVP for each argument separately,
    and the results are computed separately then summed:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`defjvps`便捷包装器允许我们为每个参数单独定义一个JVP，并分别计算结果后进行求和：'
- en: '[PRE62]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Here’s a `defjvps` example with multiple arguments:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个带有多个参数的`defjvps`示例：
- en: '[PRE65]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'As a shorthand, with `defjvps` you can pass a `None` value to indicate that
    the JVP for a particular argument is zero:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，使用`defjvps`，您可以传递`None`值来指示特定参数的JVP为零：
- en: '[PRE68]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Calling a `jax.custom_jvp` function with keyword arguments, or writing a `jax.custom_jvp`
    function definition with default arguments, are both allowed so long as they can
    be unambiguously mapped to positional arguments based on the function signature
    retrieved by the standard library `inspect.signature` mechanism.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 使用关键字参数调用`jax.custom_jvp`函数，或者编写具有默认参数的`jax.custom_jvp`函数定义，只要能够根据通过标准库`inspect.signature`机制检索到的函数签名映射到位置参数即可。
- en: 'When you’re not performing differentiation, the function `f` is called just
    as if it weren’t decorated by `jax.custom_jvp`:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 当您不执行微分时，函数`f`的调用方式与未被`jax.custom_jvp`修饰时完全一样：
- en: '[PRE71]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The custom JVP rule is invoked during differentiation, whether forward or reverse:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义的JVP规则在微分过程中被调用，无论是正向还是反向：
- en: '[PRE76]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Notice that `f_jvp` calls `f` to compute the primal outputs. In the context
    of higher-order differentiation, each application of a differentiation transform
    will use the custom JVP rule if and only if the rule calls the original `f` to
    compute the primal outputs. (This represents a kind of fundamental tradeoff, where
    we can’t make use of intermediate values from the evaluation of `f` in our rule
    *and also* have the rule apply in all orders of higher-order differentiation.)
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`f_jvp`调用`f`来计算原始输出。在高阶微分的上下文中，每个微分变换的应用将只在规则调用原始`f`来计算原始输出时使用自定义的JVP规则。（这代表一种基本的权衡，我们不能同时利用`f`的评估中间值来制定规则*并且*使规则在所有高阶微分顺序中应用。）
- en: '[PRE80]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'You can use Python control flow with `jax.custom_jvp`:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用Python控制流来使用`jax.custom_jvp`：
- en: '[PRE83]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: Use `jax.custom_vjp` to define custom reverse-mode-only rules
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用`jax.custom_vjp`来定义自定义的仅反向模式规则
- en: 'While `jax.custom_jvp` suffices for controlling both forward- and, via JAX’s
    automatic transposition, reverse-mode differentiation behavior, in some cases
    we may want to directly control a VJP rule, for example in the latter two example
    problems presented above. We can do that with `jax.custom_vjp`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`jax.custom_jvp`足以控制正向和通过JAX的自动转置控制反向模式微分行为，但在某些情况下，我们可能希望直接控制VJP规则，例如在上述后两个示例问题中。我们可以通过`jax.custom_vjp`来实现这一点。
- en: '[PRE86]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: In words, we again start with a primal function `f` that takes inputs of type
    `a` and produces outputs of type `b`. We associate with it two functions, `f_fwd`
    and `f_bwd`, which describe how to perform the forward- and backward-passes of
    reverse-mode autodiff, respectively.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，我们再次从接受类型为`a`的输入并产生类型为`b`的输出的原始函数`f`开始。我们将与之关联两个函数`f_fwd`和`f_bwd`，它们描述了如何执行反向模式自动微分的正向和反向传递。
- en: The function `f_fwd` describes the forward pass, not only the primal computation
    but also what values to save for use on the backward pass. Its input signature
    is just like that of the primal function `f`, in that it takes a primal input
    of type `a`. But as output it produces a pair, where the first element is the
    primal output `b` and the second element is any “residual” data of type `c` to
    be stored for use by the backward pass. (This second output is analogous to [PyTorch’s
    save_for_backward mechanism](https://pytorch.org/tutorials/beginner/examples_autograd/two_layer_net_custom_function.html).)
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`f_fwd`描述了前向传播，不仅包括原始计算，还包括要保存以供后向传播使用的值。其输入签名与原始函数`f`完全相同，即它接受类型为`a`的原始输入。但作为输出，它产生一对值，其中第一个元素是原始输出`b`，第二个元素是类型为`c`的任何“残余”数据，用于后向传播时存储。（这第二个输出类似于[PyTorch的save_for_backward机制](https://pytorch.org/tutorials/beginner/examples_autograd/two_layer_net_custom_function.html)。）
- en: The function `f_bwd` describes the backward pass. It takes two inputs, where
    the first is the residual data of type `c` produced by `f_fwd` and the second
    is the output cotangents of type `CT b` corresponding to the output of the primal
    function. It produces an output of type `CT a` representing the cotangents corresponding
    to the input of the primal function. In particular, the output of `f_bwd` must
    be a sequence (e.g. a tuple) of length equal to the number of arguments to the
    primal function.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 函数`f_bwd`描述了反向传播。它接受两个输入，第一个是由`f_fwd`生成的类型为`c`的残差数据，第二个是对应于原始函数输出的类型为`CT b`的输出共切线。它生成一个类型为`CT
    a`的输出，表示原始函数输入对应的共切线。特别地，`f_bwd`的输出必须是长度等于原始函数参数个数的序列（例如元组）。
- en: 'So multiple arguments work like this:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 多个参数的工作方式如下：
- en: '[PRE89]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Calling a `jax.custom_vjp` function with keyword arguments, or writing a `jax.custom_vjp`
    function definition with default arguments, are both allowed so long as they can
    be unambiguously mapped to positional arguments based on the function signature
    retrieved by the standard library `inspect.signature` mechanism.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 调用带有关键字参数的`jax.custom_vjp`函数，或者编写带有默认参数的`jax.custom_vjp`函数定义，只要可以根据标准库`inspect.signature`机制清晰地映射到位置参数即可。
- en: As with `jax.custom_jvp`, the custom VJP rule comprised by `f_fwd` and `f_bwd`
    is not invoked if differentiation is not applied. If function is evaluated, or
    transformed with `jit`, `vmap`, or other non-differentiation transformations,
    then only `f` is called.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 与`jax.custom_jvp`类似，如果没有应用微分，则不会调用由`f_fwd`和`f_bwd`组成的自定义VJP规则。如果对函数进行评估，或者使用`jit`、`vmap`或其他非微分变换进行转换，则只调用`f`。
- en: '[PRE92]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '**Forward-mode autodiff cannot be used on the** `jax.custom_vjp` **function**
    and will raise an error:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '**无法在** `jax.custom_vjp` **函数上使用前向模式自动微分**，否则会引发错误：'
- en: '[PRE101]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: If you want to use both forward- and reverse-mode, use `jax.custom_jvp` instead.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果希望同时使用前向和反向模式，请使用`jax.custom_jvp`。
- en: 'We can use `jax.custom_vjp` together with `pdb` to insert a debugger trace
    in the backward pass:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`jax.custom_vjp`与`pdb`一起在反向传播中插入调试器跟踪：
- en: '[PRE103]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: More features and details
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多特性和细节
- en: Working with `list` / `tuple` / `dict` containers (and other pytrees)
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用`list` / `tuple` / `dict`容器（和其他pytree）
- en: You should expect standard Python containers like lists, tuples, namedtuples,
    and dicts to just work, along with nested versions of those. In general, any [pytrees](https://jax.readthedocs.io/en/latest/pytrees.html)
    are permissible, so long as their structures are consistent according to the type
    constraints.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该期望标准的Python容器如列表、元组、命名元组和字典可以正常工作，以及这些容器的嵌套版本。总体而言，任何[pytrees](https://jax.readthedocs.io/en/latest/pytrees.html)都是允许的，只要它们的结构符合类型约束。
- en: 'Here’s a contrived example with `jax.custom_jvp`:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个使用`jax.custom_jvp`的构造示例：
- en: '[PRE106]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'And an analogous contrived example with `jax.custom_vjp`:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个类似的使用`jax.custom_vjp`的构造示例：
- en: '[PRE111]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: Handling non-differentiable arguments
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理非可微参数
- en: Some use cases, like the final example problem, call for non-differentiable
    arguments like function-valued arguments to be passed to functions with custom
    differentiation rules, and for those arguments to also be passed to the rules
    themselves. In the case of `fixed_point`, the function argument `f` was such a
    non-differentiable argument. A similar situation arises with `jax.experimental.odeint`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 一些用例，如最后的示例问题，需要将非可微参数（如函数值参数）传递给具有自定义微分规则的函数，并且这些参数也需要传递给规则本身。在`fixed_point`的情况下，函数参数`f`就是这样一个非可微参数。类似的情况在`jax.experimental.odeint`中也会出现。
- en: '`jax.custom_jvp` with `nondiff_argnums`'
  id: totrans-214
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`jax.custom_jvp`与`nondiff_argnums`'
- en: 'Use the optional `nondiff_argnums` parameter to `jax.custom_jvp` to indicate
    arguments like these. Here’s an example with `jax.custom_jvp`:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 使用可选的 `nondiff_argnums` 参数来指示类似这些的参数给 `jax.custom_jvp`。以下是一个带有 `jax.custom_jvp`
    的例子：
- en: '[PRE116]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'Notice the gotcha here: no matter where in the argument list these parameters
    appear, they’re placed at the *start* of the signature of the corresponding JVP
    rule. Here’s another example:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这里的陷阱：无论这些参数在参数列表的哪个位置出现，它们都放置在相应 JVP 规则签名的*起始*位置。这里有另一个例子：
- en: '[PRE121]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '`jax.custom_vjp` with `nondiff_argnums`'
  id: totrans-227
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: '`nondiff_argnums` 与 `jax.custom_vjp`'
- en: 'A similar option exists for `jax.custom_vjp`, and, similarly, the convention
    is that the non-differentiable arguments are passed as the first arguments to
    the `_bwd` rule, no matter where they appear in the signature of the original
    function. The signature of the `_fwd` rule remains unchanged - it is the same
    as the signature of the primal function. Here’s an example:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `jax.custom_vjp` 也有类似的选项，类似地，非可微参数的约定是它们作为 `_bwd` 规则的第一个参数传递，无论它们出现在原始函数签名的哪个位置。
    `_fwd` 规则的签名保持不变 - 它与原始函数的签名相同。以下是一个例子：
- en: '[PRE126]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: See `fixed_point` above for another usage example.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 请参见上面的 `fixed_point` 以获取另一个用法示例。
- en: '**You don’t need to use** `nondiff_argnums` **with array-valued arguments**,
    for example ones with integer dtype. Instead, `nondiff_argnums` should only be
    used for argument values that don’t correspond to JAX types (essentially don’t
    correspond to array types), like Python callables or strings. If JAX detects that
    an argument indicated by `nondiff_argnums` contains a JAX Tracer, then an error
    is raised. The `clip_gradient` function above is a good example of not using `nondiff_argnums`
    for integer-dtype array arguments.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '**对于具有整数 dtype 的数组值参数，不需要使用** `nondiff_argnums` **。相反，`nondiff_argnums` 应仅用于不对应
    JAX 类型（实质上不对应数组类型）的参数值，如 Python 可调用对象或字符串。如果 JAX 检测到由 `nondiff_argnums` 指示的参数包含
    JAX Tracer，则会引发错误。上面的 `clip_gradient` 函数是不使用 `nondiff_argnums` 处理整数 dtype 数组参数的良好示例。'
