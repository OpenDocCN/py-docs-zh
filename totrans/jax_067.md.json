["```py\n# old custom_transforms api to be replaced\n@jax.custom_transforms\ndef f(x):\n  return 2. * x\n\n# f_vjp :: a -> (b, CT b --o CT a)\ndef f_vjp(x):\n  return f(x), lambda g: 3. * x  # 3 instead of 2\n\njax.defvjp_all(f, f_vjp)\n\ngrad(f)(1.)  # 3.\nvmap(grad(f))(np.ones(4))  # [3., 3., 3., 3.]\ngrad(lambda x: vmap(f)(x).sum())(np.ones(4))  # [2., 2., 2., 2.] \n```", "```py\n{ lambda  ; ; a.\n  let b = f_primitive a\n  in [b] } \n```", "```py\n{ lambda  ; ; a.\n  let b = mul 2. a\n  in [b] } \n```", "```py\nvmap(f)(xs) == np.stack([f(x) for x in xs]) \n```", "```py\njvp(vmap(f))(xs) == jvp(lambda xs: np.stack([f(x) for x in xs])) \n```", "```py\n# old custom_transforms api to be replaced\n@jax.custom_transforms\ndef f(x):\n  if x > 0:\n    return x\n  else:\n    return 0.\n\ndef f_vjp(x):\n  return ...\n\njax.defvjp_all(f, f_vjp)\n\ngrad(f)(1.)  # Error! \n```", "```py\nvmap(call(f)) == call(vmap(f)) \n```", "```py\nvmap(custom_jvp_call(f, f_jvp)) == custom_jvp_call(vmap(f), vmap(f_jvp)) \n```", "```py\njvp(call(f)) == call(jvp(f))\n\njvp(custom_jvp_call(f, f_jvp)) == f_jvp \n```", "```py\neval(call(f)) == eval(f)\njit(call(f)) == hlo_call(jit(f))\n\neval(custom_jvp_call(f, f_jvp)) == eval(f)\njit(custom_jvp_call(f, f_jvp)) == hlo_call(jit(f)) \n```", "```py\n# f :: a -> b\n@jax.custom_jvp\ndef f(x):\n  return np.sin(x)\n\n# f_jvp :: (a, T a) -> (b, T b)\ndef f_jvp(primals, tangents):\n  x, = primals\n  t, = tangents\n  return f(x), np.cos(x) * t\n\nf.defjvp(f_jvp) \n```", "```py\n# f :: a -> b\n@jax.custom_vjp\ndef f(x):\n  return np.sin(x)\n\n# f_fwd :: a -> (b, c)\ndef f_fwd(x):\n  return f(x), np.cos(x)\n\n# f_bwd :: (c, CT b) -> CT a\ndef f_bwd(cos_x, g):\n  return (cos_x * g,)\n\nf.defvjp(f_fwd, f_bwd) \n```"]