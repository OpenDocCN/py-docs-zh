- en: TextPage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://pymupdf.readthedocs.io/en/latest/textpage.html](https://pymupdf.readthedocs.io/en/latest/textpage.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This class represents text and images shown on a document page. All [MuPDF document
    types](how-to-open-a-file.html#supported-file-types) are supported.
  prefs: []
  type: TYPE_NORMAL
- en: The usual ways to create a textpage are [`DisplayList.get_textpage()`](displaylist.html#DisplayList.get_textpage
    "DisplayList.get_textpage") and [`Page.get_textpage()`](page.html#Page.get_textpage
    "Page.get_textpage"). Because there is a limited set of methods in this class,
    there exist wrappers in [Page](page.html#page) which are handier to use. The last
    column of this table shows these corresponding [Page](page.html#page) methods.
  prefs: []
  type: TYPE_NORMAL
- en: For a description of what this class is all about, see Appendix 2.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method** | **Description** | page get_text or search method |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| [`extractText()`](#TextPage.extractText "TextPage.extractText") | extract
    plain text | “text” |'
  prefs: []
  type: TYPE_TB
- en: '| [`extractTEXT()`](#TextPage.extractTEXT "TextPage.extractTEXT") | synonym
    of previous | “text” |'
  prefs: []
  type: TYPE_TB
- en: '| [`extractBLOCKS()`](#TextPage.extractBLOCKS "TextPage.extractBLOCKS") | plain
    text grouped in blocks | “blocks” |'
  prefs: []
  type: TYPE_TB
- en: '| [`extractWORDS()`](#TextPage.extractWORDS "TextPage.extractWORDS") | all
    words with their bbox | “words” |'
  prefs: []
  type: TYPE_TB
- en: '| [`extractHTML()`](#TextPage.extractHTML "TextPage.extractHTML") | page content
    in HTML format | “html” |'
  prefs: []
  type: TYPE_TB
- en: '| [`extractXHTML()`](#TextPage.extractXHTML "TextPage.extractXHTML") | page
    content in XHTML format | “xhtml” |'
  prefs: []
  type: TYPE_TB
- en: '| [`extractXML()`](#TextPage.extractXML "TextPage.extractXML") | page text
    in XML format | “xml” |'
  prefs: []
  type: TYPE_TB
- en: '| [`extractDICT()`](#TextPage.extractDICT "TextPage.extractDICT") | page content
    in *dict* format | “dict” |'
  prefs: []
  type: TYPE_TB
- en: '| [`extractJSON()`](#TextPage.extractJSON "TextPage.extractJSON") | page content
    in JSON format | “json” |'
  prefs: []
  type: TYPE_TB
- en: '| [`extractRAWDICT()`](#TextPage.extractRAWDICT "TextPage.extractRAWDICT")
    | page content in *dict* format | “rawdict” |'
  prefs: []
  type: TYPE_TB
- en: '| [`extractRAWJSON()`](#TextPage.extractRAWJSON "TextPage.extractRAWJSON")
    | page content in JSON format | “rawjson” |'
  prefs: []
  type: TYPE_TB
- en: '| [`search()`](#TextPage.search "TextPage.search") | Search for a string in
    the page | [`Page.search_for()`](page.html#Page.search_for "Page.search_for")
    |'
  prefs: []
  type: TYPE_TB
- en: '**Class API**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Return a string of the page’s complete text. The text is UTF-8 unicode and in
    the same sequence as specified at the time of document creation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**sort** (*bool*) – (new in v1.19.1) sort the output by vertical, then horizontal
    coordinates. In many cases, this should suffice to generate a “natural” reading
    order.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Return type:'
  prefs: []
  type: TYPE_NORMAL
- en: str
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Textpage content as a list of text lines grouped by block. Each list items
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The first four entries are the block’s bbox coordinates, *block_type* is 1 for
    an image block, 0 for text. *block_no* is the block sequence number. Multiple
    text lines are joined via line breaks.
  prefs: []
  type: TYPE_NORMAL
- en: For an image block, its bbox and a text line with some image meta information
    is included – **not the image content**.
  prefs: []
  type: TYPE_NORMAL
- en: This is a high-speed method with just enough information to output plain text
    in desired reading sequence.
  prefs: []
  type: TYPE_NORMAL
- en: 'Return type:'
  prefs: []
  type: TYPE_NORMAL
- en: list
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Changed in v1.23.5: added `delimiters` parameter'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Textpage content as a list of single words with bbox information. An item of
    this list looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**delimiters** (*str*) – (new in v1.23.5) use these characters as *additional*
    word separators. By default, all white spaces (including the non-breaking space
    `0xA0`) indicate start and end of a word. Now you can specify more characters
    causing this. For instance, the default will return `"john.doe@outlook.com"` as
    **one** word. If you specify `delimiters="@."` then the **four** words `"john"`,
    `"doe"`, `"outlook"`, `"com"` will be returned. Other possible uses include ignoring
    punctuation characters `delimiters=string.punctuation`. The “word” strings will
    not contain any delimiting character.'
  prefs: []
  type: TYPE_NORMAL
- en: This is a high-speed method which e.g. allows extracting text from within given
    areas or recovering the text reading sequence.
  prefs: []
  type: TYPE_NORMAL
- en: 'Return type:'
  prefs: []
  type: TYPE_NORMAL
- en: list
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Textpage content as a string in HTML format. This version contains complete
    formatting and positioning information. Images are included (encoded as base64
    strings). You need an HTML package to interpret the output in Python. Your internet
    browser should be able to adequately display this information, but see [Controlling
    Quality of HTML Output](app1.html#htmlquality).
  prefs: []
  type: TYPE_NORMAL
- en: 'Return type:'
  prefs: []
  type: TYPE_NORMAL
- en: str
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Textpage content as a Python dictionary. Provides same information detail as
    HTML. See below for the structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**sort** (*bool*) – (new in v1.19.1) sort the output by vertical, then horizontal
    coordinates. In many cases, this should suffice to generate a “natural” reading
    order.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Return type:'
  prefs: []
  type: TYPE_NORMAL
- en: dict
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Textpage content as a JSON string. Created by `json.dumps(TextPage.extractDICT())`.
    It is included for backlevel compatibility. You will probably use this method
    ever only for outputting the result to some file. The method detects binary image
    data and converts them to base64 encoded strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**sort** (*bool*) – (new in v1.19.1) sort the output by vertical, then horizontal
    coordinates. In many cases, this should suffice to generate a “natural” reading
    order.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Return type:'
  prefs: []
  type: TYPE_NORMAL
- en: str
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Textpage content as a string in XHTML format. Text information detail is comparable
    with [`extractTEXT()`](#TextPage.extractTEXT "TextPage.extractTEXT"), but also
    contains images (base64 encoded). This method makes no attempt to re-create the
    original visual appearance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Return type:'
  prefs: []
  type: TYPE_NORMAL
- en: str
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Textpage content as a string in XML format. This contains complete formatting
    information about every single character on the page: font, size, line, paragraph,
    location, color, etc. Contains no images. You need an XML package to interpret
    the output in Python.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Return type:'
  prefs: []
  type: TYPE_NORMAL
- en: str
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Textpage content as a Python dictionary – technically similar to [`extractDICT()`](#TextPage.extractDICT
    "TextPage.extractDICT"), and it contains that information as a subset (including
    any images). It provides additional detail down to each character, which makes
    using XML obsolete in many cases. See below for the structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**sort** (*bool*) – (new in v1.19.1) sort the output by vertical, then horizontal
    coordinates. In many cases, this should suffice to generate a “natural” reading
    order.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Return type:'
  prefs: []
  type: TYPE_NORMAL
- en: dict
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Textpage content as a JSON string. Created by `json.dumps(TextPage.extractRAWDICT())`.
    You will probably use this method ever only for outputting the result to some
    file. The method detects binary image data and converts them to base64 encoded
    strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**sort** (*bool*) – (new in v1.19.1) sort the output by vertical, then horizontal
    coordinates. In many cases, this should suffice to generate a “natural” reading
    order.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Return type:'
  prefs: []
  type: TYPE_NORMAL
- en: str
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Changed in v1.18.2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Search for *string* and return a list of found locations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**needle** (*str*) – the string to search for. Upper and lower cases will all
    match if needle consists of ASCII letters only – it does not yet work for “Ä”
    versus “ä”, etc.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**quads** (*bool*) – return quadrilaterals instead of rectangles.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Return type:'
  prefs: []
  type: TYPE_NORMAL
- en: list
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: a list of [Rect](rect.html#rect) or [Quad](quad.html#quad) objects, each surrounding
    a found *needle* occurrence. As the search string may contain spaces, its parts
    may be found on different lines. In this case, more than one rectangle (resp.
    quadrilateral) are returned. **(Changed in v1.18.2)** The method **now supports
    dehyphenation**, so it will find e.g. “method”, even if it was hyphenated in two
    parts “meth-” and “od” across two lines. The two returned rectangles will contain
    “meth” (no hyphen) and “od”.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '**Overview of changes in v1.18.2:**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `hit_max` parameter has been removed: all hits are always returned.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The [Rect](rect.html) parameter of the [TextPage](#textpage) is now respected:
    only text inside this area is examined. Only characters with fully contained bboxes
    are considered. The wrapper method [`Page.search_for()`](page.html#Page.search_for
    "Page.search_for") correspondingly supports a *clip* parameter.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Hyphenated words** are now found.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Overlapping rectangles** in the same line are now automatically joined. We
    assume that such separations are an artifact created by multiple marked content
    groups, containing parts of the same search needle.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Example Quad versus Rect: when searching for needle “pymupdf”, then the corresponding
    entry will either be the blue rectangle, or, if *quads* was specified, the quad
    *Quad(ul, ur, ll, lr)*.'
  prefs: []
  type: TYPE_NORMAL
- en: '![_images/img-quads.jpg](../Images/dd342f79fb80249423116ac8e3c9c731.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The rectangle associated with the text page. This either equals the rectangle
    of the creating page or the `clip` parameter of [`Page.get_textpage()`](page.html#Page.get_textpage
    "Page.get_textpage") and text extraction / searching methods.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The output of text searching and most text extractions **is restricted to this
    rectangle**. (X)HTML and XML output will however always extract the full page.
  prefs: []
  type: TYPE_NORMAL
- en: '## Structure of Dictionary Outputs'
  prefs: []
  type: TYPE_NORMAL
- en: 'Methods [`TextPage.extractDICT()`](#TextPage.extractDICT "TextPage.extractDICT"),
    [`TextPage.extractJSON()`](#TextPage.extractJSON "TextPage.extractJSON"), [`TextPage.extractRAWDICT()`](#TextPage.extractRAWDICT
    "TextPage.extractRAWDICT"), and [`TextPage.extractRAWJSON()`](#TextPage.extractRAWJSON
    "TextPage.extractRAWJSON") return dictionaries, containing the page’s text and
    image content. The dictionary structures of all four methods are almost equal.
    They strive to map the text page’s information hierarchy of blocks, lines, spans
    and characters as precisely as possible, by representing each of these by its
    own sub-dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: A **page** consists of a list of **block dictionaries**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A (text) **block** consists of a list of **line dictionaries**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **line** consists of a list of **span dictionaries**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **span** either consists of the text itself or, for the RAW variants, a list
    of **character dictionaries**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'RAW variants: a **character** is a dictionary of its origin, bbox and unicode.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All PyMuPDF geometry objects herein (points, rectangles, matrices) are represented
    by there **“like”** formats: a [`rect_like`](glossary.html#rect_like "rect_like")
    *tuple* is used instead of a [Rect](rect.html#rect), etc. The reasons for this
    are performance and memory considerations:'
  prefs: []
  type: TYPE_NORMAL
- en: This code is written in C, where Python tuples can easily be generated. The
    geometry objects on the other hand are defined in Python source only. A conversion
    of each Python tuple into its corresponding geometry object would add significant
    – and largely unnecessary – execution time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A 4-tuple needs about 168 bytes, the corresponding [Rect](rect.html#rect) 472
    bytes - almost three times the size. A “dict” dictionary for a text-heavy page
    contains 300+ bbox objects – which thus require about 50 KB storage as 4-tuples
    versus 140 KB as [Rect](rect.html#rect) objects. A “rawdict” output for such a
    page will however contain **4 to 5 thousand** bboxes, so in this case we talk
    about 750 KB versus 2 MB.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Please also note, that only **bboxes** (= [`rect_like`](glossary.html#rect_like
    "rect_like") 4-tuples) are returned, whereas a [TextPage](#textpage) actually
    has the **full position information** – in [Quad](quad.html#quad) format. The
    reason for this decision is again a memory consideration: a [`quad_like`](glossary.html#quad_like
    "quad_like") needs 488 bytes (3 times the size of a [`rect_like`](glossary.html#rect_like
    "rect_like")). Given the mentioned amounts of generated bboxes, returning [`quad_like`](glossary.html#quad_like
    "quad_like") information would have a significant impact.'
  prefs: []
  type: TYPE_NORMAL
- en: In the vast majority of cases, we are dealing with **horizontal text only**,
    where bboxes provide entirely sufficient information.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, **the full quad information is not lost**: it can be recovered
    as needed for lines, spans, and characters by using the appropriate function from
    the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`recover_quad()`](functions.html#recover_quad "recover_quad") – the quad of
    a complete span'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`recover_span_quad()`](functions.html#recover_span_quad "recover_span_quad")
    – the quad of a character subset of a span'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`recover_line_quad()`](functions.html#recover_line_quad "recover_line_quad")
    – the quad of a line'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`recover_char_quad()`](functions.html#recover_char_quad "recover_char_quad")
    – the quad of a character'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As mentioned, using these functions is ever only needed, if the text is **not
    written horizontally** – `line["dir"] != (1, 0)` – and you need the quad for text
    marker annotations ([`Page.add_highlight_annot()`](page.html#Page.add_highlight_annot
    "Page.add_highlight_annot") and friends).
  prefs: []
  type: TYPE_NORMAL
- en: '![_images/img-textpage.png](../Images/1fad3323220c40ba524a34c147d62563.png)'
  prefs: []
  type: TYPE_IMG
- en: Page Dictionary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '| **Key** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| width | width of the `clip` rectangle *(float)* |'
  prefs: []
  type: TYPE_TB
- en: '| height | height of the `clip` rectangle *(float)* |'
  prefs: []
  type: TYPE_TB
- en: '| blocks | *list* of block dictionaries |'
  prefs: []
  type: TYPE_TB
- en: Block Dictionaries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Block dictionaries come in two different formats for **image blocks** and for
    **text blocks**.
  prefs: []
  type: TYPE_NORMAL
- en: '*(Changed in v1.18.0)* – new dict key *number*, the block number.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*(Changed in v1.18.11)* – new dict key *transform*, the image transformation
    matrix for image blocks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*(Changed in v1.18.11)* – new dict key *size*, the size of the image in bytes
    for image blocks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Image block:**'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Key** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| type | 1 = image *(int)* |'
  prefs: []
  type: TYPE_TB
- en: '| bbox | image bbox on page ([`rect_like`](glossary.html#rect_like "rect_like"))
    |'
  prefs: []
  type: TYPE_TB
- en: '| number | block count *(int)* |'
  prefs: []
  type: TYPE_TB
- en: '| ext | image type *(str)*, as file extension, see below |'
  prefs: []
  type: TYPE_TB
- en: '| width | original image width *(int)* |'
  prefs: []
  type: TYPE_TB
- en: '| height | original image height *(int)* |'
  prefs: []
  type: TYPE_TB
- en: '| colorspace | colorspace component count *(int)* |'
  prefs: []
  type: TYPE_TB
- en: '| xres | resolution in x-direction *(int)* |'
  prefs: []
  type: TYPE_TB
- en: '| yres | resolution in y-direction *(int)* |'
  prefs: []
  type: TYPE_TB
- en: '| bpc | bits per component *(int)* |'
  prefs: []
  type: TYPE_TB
- en: '| transform | matrix transforming image rect to bbox ([`matrix_like`](glossary.html#matrix_like
    "matrix_like")) |'
  prefs: []
  type: TYPE_TB
- en: '| size | size of the image in bytes *(int)* |'
  prefs: []
  type: TYPE_TB
- en: '| image | image content *(bytes)* |'
  prefs: []
  type: TYPE_TB
- en: Possible values of the “ext” key are “bmp”, “gif”, “jpeg”, “jpx” (JPEG 2000),
    “jxr” (JPEG XR), “png”, “pnm”, and “tiff”.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: An image block is generated for **all and every image occurrence** on the page.
    Hence there may be duplicates, if an image is shown at different locations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[TextPage](#textpage) and corresponding method [`Page.get_text()`](page.html#Page.get_text
    "Page.get_text") are **available for all document types**. Only for PDF documents,
    methods [`Document.get_page_images()`](document.html#Document.get_page_images
    "Document.get_page_images") / [`Page.get_images()`](page.html#Page.get_images
    "Page.get_images") offer some overlapping functionality as far as image lists
    are concerned. But both lists **may or may not** contain the same items. Any differences
    are most probably caused by one of the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: “Inline” images (see page 214 of the [Adobe PDF References](app3.html#adobemanual))
    of a PDF page are contained in a textpage, but **do not appear** in [`Page.get_images()`](page.html#Page.get_images
    "Page.get_images").
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Annotations may also contain images – these will **not appear** in [`Page.get_images()`](page.html#Page.get_images
    "Page.get_images").
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Image blocks in a textpage are generated for **every** image location – whether
    or not there are any duplicates. This is in contrast to [`Page.get_images()`](page.html#Page.get_images
    "Page.get_images"), which will list each image only once (per reference name).
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Images mentioned in the page’s [`object`](glossary.html#object "object") definition
    will **always** appear in [`Page.get_images()`](page.html#Page.get_images "Page.get_images")
    [[1]](#f1). But it may happen, that there is no “display” command in the page’s
    [`contents`](glossary.html#contents "contents") (erroneously or on purpose). In
    this case the image will **not appear** in the textpage.
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The image’s “transformation matrix” is defined as the matrix, for which the
    expression `bbox / transform == pymupdf.Rect(0, 0, 1, 1)` is true, lookup details
    here: [Image Transformation Matrix](app3.html#imagetransformation).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Text block:**'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Key** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| type | 0 = text *(int)* |'
  prefs: []
  type: TYPE_TB
- en: '| bbox | block rectangle, [`rect_like`](glossary.html#rect_like "rect_like")
    |'
  prefs: []
  type: TYPE_TB
- en: '| number | block count *(int)* |'
  prefs: []
  type: TYPE_TB
- en: '| lines | *list* of text line dictionaries |'
  prefs: []
  type: TYPE_TB
- en: Line Dictionary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '| **Key** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| bbox | line rectangle, [`rect_like`](glossary.html#rect_like "rect_like")
    |'
  prefs: []
  type: TYPE_TB
- en: '| wmode | writing mode *(int)*: 0 = horizontal, 1 = vertical |'
  prefs: []
  type: TYPE_TB
- en: '| dir | writing direction, [`point_like`](glossary.html#point_like "point_like")
    |'
  prefs: []
  type: TYPE_TB
- en: '| spans | *list* of span dictionaries |'
  prefs: []
  type: TYPE_TB
- en: 'The value of key *“dir”* is the **unit vector** `dir = (cosine, -sine)` of
    the angle, which the text has relative to the x-axis [[2]](#f2). See the following
    picture: The word in each quadrant (counter-clockwise from top-right to bottom-right)
    is rotated by 30, 120, 210 and 300 degrees respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![_images/img-line-dir.png](../Images/15ecc7ea6bdd91ad4e72dbbef2a91170.png)](_images/img-line-dir.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Span Dictionary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Spans contain the actual text. A line contains **more than one span only**,
    if it contains text with different font properties.
  prefs: []
  type: TYPE_NORMAL
- en: Changed in version 1.14.17 Spans now also have a *bbox* key (again).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changed in version 1.17.6 Spans now also have an *origin* key.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| **Key** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| bbox | span rectangle, [`rect_like`](glossary.html#rect_like "rect_like")
    |'
  prefs: []
  type: TYPE_TB
- en: '| origin | the first character’s origin, [`point_like`](glossary.html#point_like
    "point_like") |'
  prefs: []
  type: TYPE_TB
- en: '| font | font name *(str)* |'
  prefs: []
  type: TYPE_TB
- en: '| ascender | ascender of the font *(float)* |'
  prefs: []
  type: TYPE_TB
- en: '| descender | descender of the font *(float)* |'
  prefs: []
  type: TYPE_TB
- en: '| size | font size *(float)* |'
  prefs: []
  type: TYPE_TB
- en: '| flags | font characteristics *(int)* |'
  prefs: []
  type: TYPE_TB
- en: '| color | text color in sRGB format *(int)* |'
  prefs: []
  type: TYPE_TB
- en: '| text | (only for `extractDICT()`) text *(str)* |'
  prefs: []
  type: TYPE_TB
- en: '| chars | (only for `extractRAWDICT()`) *list* of character dictionaries |'
  prefs: []
  type: TYPE_TB
- en: '*(New in version 1.16.0):* *“color”* is the text color encoded in sRGB (int)
    format, e.g. 0xFF0000 for red. There are functions for converting this integer
    back to formats (r, g, b) (PDF with float values from 0 to 1) [`sRGB_to_pdf()`](functions.html#sRGB_to_pdf
    "sRGB_to_pdf"), or (R, G, B), [`sRGB_to_rgb()`](functions.html#sRGB_to_rgb "sRGB_to_rgb")
    (with integer values from 0 to 255).'
  prefs: []
  type: TYPE_NORMAL
- en: '*(New in v1.18.5):* *“ascender”* and *“descender”* are font properties, provided
    relative to [`fontsize`](glossary.html#fontsize "fontsize") 1\. Note that descender
    is a negative value. The following picture shows the relationship to other values
    and properties.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![_images/img-asc-desc.png](../Images/9ea0597ab8c50db132b5765ca4c0e43b.png)](_images/img-asc-desc.png)'
  prefs: []
  type: TYPE_NORMAL
- en: 'These numbers may be used to compute the minimum height of a character (or
    span) – as opposed to the standard height provided in the “bbox” values (which
    actually represents the **line height**). The following code recalculates the
    span bbox to have a height of **fontsize** exactly fitting the text inside:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Caution
  prefs: []
  type: TYPE_NORMAL
- en: The above calculation may deliver a **larger** height! This may e.g. happen
    for OCRed documents, where the risk of all sorts of text artifacts is high. MuPDF
    tries to come up with a reasonable bbox height, independently from the [`fontsize`](glossary.html#fontsize
    "fontsize") found in the PDF. So please ensure that the height of `span["bbox"]`
    is **larger** than `span["size"]`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You may request PyMuPDF to do all of the above automatically by executing `pymupdf.TOOLS.set_small_glyph_heights(True)`.
    This sets a global parameter so that all subsequent text searches and text extractions
    are based on reduced glyph heights, where meaningful.
  prefs: []
  type: TYPE_NORMAL
- en: The following shows the original span rectangle in red and the rectangle with
    re-computed height in blue.
  prefs: []
  type: TYPE_NORMAL
- en: '[![_images/img-span-rect.png](../Images/08fd3328e61e00b5de7d30a5eb69dfb4.png)](_images/img-span-rect.png)'
  prefs: []
  type: TYPE_NORMAL
- en: '*“flags”* is an integer, which represents font properties except for the first
    bit 0\. They are to be interpreted like this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'bit 0: superscripted (2⁰) – not a font property, detected by MuPDF code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'bit 1: italic (2¹)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'bit 2: serifed (2²)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'bit 3: monospaced (2³)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'bit 4: bold (2⁴)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Test these characteristics like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Bits 1 thru 4 are font properties, i.e. encoded in the font program. Please
    note, that this information is not necessarily correct or complete: fonts quite
    often contain wrong data here.'
  prefs: []
  type: TYPE_NORMAL
- en: Character Dictionary for `extractRAWDICT()`
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '| **Key** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| origin | character’s left baseline point, [`point_like`](glossary.html#point_like
    "point_like") |'
  prefs: []
  type: TYPE_TB
- en: '| bbox | character rectangle, [`rect_like`](glossary.html#rect_like "rect_like")
    |'
  prefs: []
  type: TYPE_TB
- en: '| c | the character (unicode) |'
  prefs: []
  type: TYPE_TB
- en: 'This image shows the relationship between a character’s bbox and its quad:
    [![textpagechar](../Images/ee61a05de894965b12f164a4bd64419d.png)](_images/img-textpage-char.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Footnotes
  prefs: []
  type: TYPE_NORMAL
- en: Do you have any feedback on this page?
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: This software is provided AS-IS with no warranty, either express or implied.
    This software is distributed under license and may not be copied, modified or
    distributed except as expressly authorized under the terms of that license. Refer
    to licensing information at [artifex.com](https://www.artifex.com?utm_source=rtd-pymupdf&utm_medium=rtd&utm_content=footer-link)
    or contact Artifex Software Inc., 39 Mesa Street, Suite 108A, San Francisco CA
    94129, United States for further information.
  prefs: []
  type: TYPE_NORMAL
- en: This documentation covers all versions up to 1.24.4.
  prefs: []
  type: TYPE_NORMAL
- en: '[![Discord logo](../Images/66cbb5081103a580193aa66c87b90d9a.png)](https://discord.gg/TSpYGBW4eq)
    ## Structure of Dictionary Outputs'
  prefs: []
  type: TYPE_NORMAL
- en: 'Methods [`TextPage.extractDICT()`](#TextPage.extractDICT "TextPage.extractDICT"),
    [`TextPage.extractJSON()`](#TextPage.extractJSON "TextPage.extractJSON"), [`TextPage.extractRAWDICT()`](#TextPage.extractRAWDICT
    "TextPage.extractRAWDICT"), and [`TextPage.extractRAWJSON()`](#TextPage.extractRAWJSON
    "TextPage.extractRAWJSON") return dictionaries, containing the page’s text and
    image content. The dictionary structures of all four methods are almost equal.
    They strive to map the text page’s information hierarchy of blocks, lines, spans
    and characters as precisely as possible, by representing each of these by its
    own sub-dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: A **page** consists of a list of **block dictionaries**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A (text) **block** consists of a list of **line dictionaries**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **line** consists of a list of **span dictionaries**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **span** either consists of the text itself or, for the RAW variants, a list
    of **character dictionaries**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'RAW variants: a **character** is a dictionary of its origin, bbox and unicode.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All PyMuPDF geometry objects herein (points, rectangles, matrices) are represented
    by there **“like”** formats: a [`rect_like`](glossary.html#rect_like "rect_like")
    *tuple* is used instead of a [Rect](rect.html#rect), etc. The reasons for this
    are performance and memory considerations:'
  prefs: []
  type: TYPE_NORMAL
- en: This code is written in C, where Python tuples can easily be generated. The
    geometry objects on the other hand are defined in Python source only. A conversion
    of each Python tuple into its corresponding geometry object would add significant
    – and largely unnecessary – execution time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A 4-tuple needs about 168 bytes, the corresponding [Rect](rect.html#rect) 472
    bytes - almost three times the size. A “dict” dictionary for a text-heavy page
    contains 300+ bbox objects – which thus require about 50 KB storage as 4-tuples
    versus 140 KB as [Rect](rect.html#rect) objects. A “rawdict” output for such a
    page will however contain **4 to 5 thousand** bboxes, so in this case we talk
    about 750 KB versus 2 MB.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Please also note, that only **bboxes** (= [`rect_like`](glossary.html#rect_like
    "rect_like") 4-tuples) are returned, whereas a [TextPage](#textpage) actually
    has the **full position information** – in [Quad](quad.html#quad) format. The
    reason for this decision is again a memory consideration: a [`quad_like`](glossary.html#quad_like
    "quad_like") needs 488 bytes (3 times the size of a [`rect_like`](glossary.html#rect_like
    "rect_like")). Given the mentioned amounts of generated bboxes, returning [`quad_like`](glossary.html#quad_like
    "quad_like") information would have a significant impact.'
  prefs: []
  type: TYPE_NORMAL
- en: In the vast majority of cases, we are dealing with **horizontal text only**,
    where bboxes provide entirely sufficient information.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, **the full quad information is not lost**: it can be recovered
    as needed for lines, spans, and characters by using the appropriate function from
    the following list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`recover_quad()`](functions.html#recover_quad "recover_quad") – the quad of
    a complete span'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`recover_span_quad()`](functions.html#recover_span_quad "recover_span_quad")
    – the quad of a character subset of a span'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`recover_line_quad()`](functions.html#recover_line_quad "recover_line_quad")
    – the quad of a line'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`recover_char_quad()`](functions.html#recover_char_quad "recover_char_quad")
    – the quad of a character'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As mentioned, using these functions is ever only needed, if the text is **not
    written horizontally** – `line["dir"] != (1, 0)` – and you need the quad for text
    marker annotations ([`Page.add_highlight_annot()`](page.html#Page.add_highlight_annot
    "Page.add_highlight_annot") and friends).
  prefs: []
  type: TYPE_NORMAL
- en: '![_images/img-textpage.png](../Images/1fad3323220c40ba524a34c147d62563.png)'
  prefs: []
  type: TYPE_IMG
- en: Page Dictionary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '| **Key** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| width | width of the `clip` rectangle *(float)* |'
  prefs: []
  type: TYPE_TB
- en: '| height | height of the `clip` rectangle *(float)* |'
  prefs: []
  type: TYPE_TB
- en: '| blocks | *list* of block dictionaries |'
  prefs: []
  type: TYPE_TB
- en: Block Dictionaries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Block dictionaries come in two different formats for **image blocks** and for
    **text blocks**.
  prefs: []
  type: TYPE_NORMAL
- en: '*(Changed in v1.18.0)* – new dict key *number*, the block number.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*(Changed in v1.18.11)* – new dict key *transform*, the image transformation
    matrix for image blocks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*(Changed in v1.18.11)* – new dict key *size*, the size of the image in bytes
    for image blocks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Image block:**'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Key** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| type | 1 = image *(int)* |'
  prefs: []
  type: TYPE_TB
- en: '| bbox | image bbox on page ([`rect_like`](glossary.html#rect_like "rect_like"))
    |'
  prefs: []
  type: TYPE_TB
- en: '| number | block count *(int)* |'
  prefs: []
  type: TYPE_TB
- en: '| ext | image type *(str)*, as file extension, see below |'
  prefs: []
  type: TYPE_TB
- en: '| width | original image width *(int)* |'
  prefs: []
  type: TYPE_TB
- en: '| height | original image height *(int)* |'
  prefs: []
  type: TYPE_TB
- en: '| colorspace | colorspace component count *(int)* |'
  prefs: []
  type: TYPE_TB
- en: '| xres | resolution in x-direction *(int)* |'
  prefs: []
  type: TYPE_TB
- en: '| yres | resolution in y-direction *(int)* |'
  prefs: []
  type: TYPE_TB
- en: '| bpc | bits per component *(int)* |'
  prefs: []
  type: TYPE_TB
- en: '| transform | matrix transforming image rect to bbox ([`matrix_like`](glossary.html#matrix_like
    "matrix_like")) |'
  prefs: []
  type: TYPE_TB
- en: '| size | size of the image in bytes *(int)* |'
  prefs: []
  type: TYPE_TB
- en: '| image | image content *(bytes)* |'
  prefs: []
  type: TYPE_TB
- en: Possible values of the “ext” key are “bmp”, “gif”, “jpeg”, “jpx” (JPEG 2000),
    “jxr” (JPEG XR), “png”, “pnm”, and “tiff”.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: An image block is generated for **all and every image occurrence** on the page.
    Hence there may be duplicates, if an image is shown at different locations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[TextPage](#textpage) and corresponding method [`Page.get_text()`](page.html#Page.get_text
    "Page.get_text") are **available for all document types**. Only for PDF documents,
    methods [`Document.get_page_images()`](document.html#Document.get_page_images
    "Document.get_page_images") / [`Page.get_images()`](page.html#Page.get_images
    "Page.get_images") offer some overlapping functionality as far as image lists
    are concerned. But both lists **may or may not** contain the same items. Any differences
    are most probably caused by one of the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: “Inline” images (see page 214 of the [Adobe PDF References](app3.html#adobemanual))
    of a PDF page are contained in a textpage, but **do not appear** in [`Page.get_images()`](page.html#Page.get_images
    "Page.get_images").
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Annotations may also contain images – these will **not appear** in [`Page.get_images()`](page.html#Page.get_images
    "Page.get_images").
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Image blocks in a textpage are generated for **every** image location – whether
    or not there are any duplicates. This is in contrast to [`Page.get_images()`](page.html#Page.get_images
    "Page.get_images"), which will list each image only once (per reference name).
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Images mentioned in the page’s [`object`](glossary.html#object "object") definition
    will **always** appear in [`Page.get_images()`](page.html#Page.get_images "Page.get_images")
    [[1]](#f1). But it may happen, that there is no “display” command in the page’s
    [`contents`](glossary.html#contents "contents") (erroneously or on purpose). In
    this case the image will **not appear** in the textpage.
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The image’s “transformation matrix” is defined as the matrix, for which the
    expression `bbox / transform == pymupdf.Rect(0, 0, 1, 1)` is true, lookup details
    here: [Image Transformation Matrix](app3.html#imagetransformation).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Text block:**'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Key** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| type | 0 = text *(int)* |'
  prefs: []
  type: TYPE_TB
- en: '| bbox | block rectangle, [`rect_like`](glossary.html#rect_like "rect_like")
    |'
  prefs: []
  type: TYPE_TB
- en: '| number | block count *(int)* |'
  prefs: []
  type: TYPE_TB
- en: '| lines | *list* of text line dictionaries |'
  prefs: []
  type: TYPE_TB
- en: Line Dictionary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '| **Key** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| bbox | line rectangle, [`rect_like`](glossary.html#rect_like "rect_like")
    |'
  prefs: []
  type: TYPE_TB
- en: '| wmode | writing mode *(int)*: 0 = horizontal, 1 = vertical |'
  prefs: []
  type: TYPE_TB
- en: '| dir | writing direction, [`point_like`](glossary.html#point_like "point_like")
    |'
  prefs: []
  type: TYPE_TB
- en: '| spans | *list* of span dictionaries |'
  prefs: []
  type: TYPE_TB
- en: 'The value of key *“dir”* is the **unit vector** `dir = (cosine, -sine)` of
    the angle, which the text has relative to the x-axis [[2]](#f2). See the following
    picture: The word in each quadrant (counter-clockwise from top-right to bottom-right)
    is rotated by 30, 120, 210 and 300 degrees respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![_images/img-line-dir.png](../Images/15ecc7ea6bdd91ad4e72dbbef2a91170.png)](_images/img-line-dir.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Span Dictionary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Spans contain the actual text. A line contains **more than one span only**,
    if it contains text with different font properties.
  prefs: []
  type: TYPE_NORMAL
- en: Changed in version 1.14.17 Spans now also have a *bbox* key (again).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changed in version 1.17.6 Spans now also have an *origin* key.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| **Key** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| bbox | span rectangle, [`rect_like`](glossary.html#rect_like "rect_like")
    |'
  prefs: []
  type: TYPE_TB
- en: '| origin | the first character’s origin, [`point_like`](glossary.html#point_like
    "point_like") |'
  prefs: []
  type: TYPE_TB
- en: '| font | font name *(str)* |'
  prefs: []
  type: TYPE_TB
- en: '| ascender | ascender of the font *(float)* |'
  prefs: []
  type: TYPE_TB
- en: '| descender | descender of the font *(float)* |'
  prefs: []
  type: TYPE_TB
- en: '| size | font size *(float)* |'
  prefs: []
  type: TYPE_TB
- en: '| flags | font characteristics *(int)* |'
  prefs: []
  type: TYPE_TB
- en: '| color | text color in sRGB format *(int)* |'
  prefs: []
  type: TYPE_TB
- en: '| text | (only for `extractDICT()`) text *(str)* |'
  prefs: []
  type: TYPE_TB
- en: '| chars | (only for `extractRAWDICT()`) *list* of character dictionaries |'
  prefs: []
  type: TYPE_TB
- en: '*(New in version 1.16.0):* *“color”* is the text color encoded in sRGB (int)
    format, e.g. 0xFF0000 for red. There are functions for converting this integer
    back to formats (r, g, b) (PDF with float values from 0 to 1) [`sRGB_to_pdf()`](functions.html#sRGB_to_pdf
    "sRGB_to_pdf"), or (R, G, B), [`sRGB_to_rgb()`](functions.html#sRGB_to_rgb "sRGB_to_rgb")
    (with integer values from 0 to 255).'
  prefs: []
  type: TYPE_NORMAL
- en: '*(New in v1.18.5):* *“ascender”* and *“descender”* are font properties, provided
    relative to [`fontsize`](glossary.html#fontsize "fontsize") 1\. Note that descender
    is a negative value. The following picture shows the relationship to other values
    and properties.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![_images/img-asc-desc.png](../Images/9ea0597ab8c50db132b5765ca4c0e43b.png)](_images/img-asc-desc.png)'
  prefs: []
  type: TYPE_NORMAL
- en: 'These numbers may be used to compute the minimum height of a character (or
    span) – as opposed to the standard height provided in the “bbox” values (which
    actually represents the **line height**). The following code recalculates the
    span bbox to have a height of **fontsize** exactly fitting the text inside:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Caution
  prefs: []
  type: TYPE_NORMAL
- en: The above calculation may deliver a **larger** height! This may e.g. happen
    for OCRed documents, where the risk of all sorts of text artifacts is high. MuPDF
    tries to come up with a reasonable bbox height, independently from the [`fontsize`](glossary.html#fontsize
    "fontsize") found in the PDF. So please ensure that the height of `span["bbox"]`
    is **larger** than `span["size"]`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You may request PyMuPDF to do all of the above automatically by executing `pymupdf.TOOLS.set_small_glyph_heights(True)`.
    This sets a global parameter so that all subsequent text searches and text extractions
    are based on reduced glyph heights, where meaningful.
  prefs: []
  type: TYPE_NORMAL
- en: The following shows the original span rectangle in red and the rectangle with
    re-computed height in blue.
  prefs: []
  type: TYPE_NORMAL
- en: '[![_images/img-span-rect.png](../Images/08fd3328e61e00b5de7d30a5eb69dfb4.png)](_images/img-span-rect.png)'
  prefs: []
  type: TYPE_NORMAL
- en: '*“flags”* is an integer, which represents font properties except for the first
    bit 0\. They are to be interpreted like this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'bit 0: superscripted (2⁰) – not a font property, detected by MuPDF code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'bit 1: italic (2¹)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'bit 2: serifed (2²)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'bit 3: monospaced (2³)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'bit 4: bold (2⁴)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Test these characteristics like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Bits 1 thru 4 are font properties, i.e. encoded in the font program. Please
    note, that this information is not necessarily correct or complete: fonts quite
    often contain wrong data here.'
  prefs: []
  type: TYPE_NORMAL
- en: Character Dictionary for `extractRAWDICT()`
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '| **Key** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| origin | character’s left baseline point, [`point_like`](glossary.html#point_like
    "point_like") |'
  prefs: []
  type: TYPE_TB
- en: '| bbox | character rectangle, [`rect_like`](glossary.html#rect_like "rect_like")
    |'
  prefs: []
  type: TYPE_TB
- en: '| c | the character (unicode) |'
  prefs: []
  type: TYPE_TB
- en: 'This image shows the relationship between a character’s bbox and its quad:
    [![textpagechar](../Images/ee61a05de894965b12f164a4bd64419d.png)](_images/img-textpage-char.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Footnotes
  prefs: []
  type: TYPE_NORMAL
- en: Do you have any feedback on this page?
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: This software is provided AS-IS with no warranty, either express or implied.
    This software is distributed under license and may not be copied, modified or
    distributed except as expressly authorized under the terms of that license. Refer
    to licensing information at [artifex.com](https://www.artifex.com?utm_source=rtd-pymupdf&utm_medium=rtd&utm_content=footer-link)
    or contact Artifex Software Inc., 39 Mesa Street, Suite 108A, San Francisco CA
    94129, United States for further information.
  prefs: []
  type: TYPE_NORMAL
- en: This documentation covers all versions up to 1.24.4.
  prefs: []
  type: TYPE_NORMAL
- en: '[![Discord logo](../Images/66cbb5081103a580193aa66c87b90d9a.png)](https://discord.gg/TSpYGBW4eq)'
  prefs: []
  type: TYPE_NORMAL
- en: Page Dictionary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '| **Key** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| width | width of the `clip` rectangle *(float)* |'
  prefs: []
  type: TYPE_TB
- en: '| height | height of the `clip` rectangle *(float)* |'
  prefs: []
  type: TYPE_TB
- en: '| blocks | *list* of block dictionaries |'
  prefs: []
  type: TYPE_TB
- en: Block Dictionaries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Block dictionaries come in two different formats for **image blocks** and for
    **text blocks**.
  prefs: []
  type: TYPE_NORMAL
- en: '*(Changed in v1.18.0)* – new dict key *number*, the block number.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*(Changed in v1.18.11)* – new dict key *transform*, the image transformation
    matrix for image blocks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*(Changed in v1.18.11)* – new dict key *size*, the size of the image in bytes
    for image blocks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Image block:**'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Key** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| type | 1 = image *(int)* |'
  prefs: []
  type: TYPE_TB
- en: '| bbox | image bbox on page ([`rect_like`](glossary.html#rect_like "rect_like"))
    |'
  prefs: []
  type: TYPE_TB
- en: '| number | block count *(int)* |'
  prefs: []
  type: TYPE_TB
- en: '| ext | image type *(str)*, as file extension, see below |'
  prefs: []
  type: TYPE_TB
- en: '| width | original image width *(int)* |'
  prefs: []
  type: TYPE_TB
- en: '| height | original image height *(int)* |'
  prefs: []
  type: TYPE_TB
- en: '| colorspace | colorspace component count *(int)* |'
  prefs: []
  type: TYPE_TB
- en: '| xres | resolution in x-direction *(int)* |'
  prefs: []
  type: TYPE_TB
- en: '| yres | resolution in y-direction *(int)* |'
  prefs: []
  type: TYPE_TB
- en: '| bpc | bits per component *(int)* |'
  prefs: []
  type: TYPE_TB
- en: '| transform | matrix transforming image rect to bbox ([`matrix_like`](glossary.html#matrix_like
    "matrix_like")) |'
  prefs: []
  type: TYPE_TB
- en: '| size | size of the image in bytes *(int)* |'
  prefs: []
  type: TYPE_TB
- en: '| image | image content *(bytes)* |'
  prefs: []
  type: TYPE_TB
- en: Possible values of the “ext” key are “bmp”, “gif”, “jpeg”, “jpx” (JPEG 2000),
    “jxr” (JPEG XR), “png”, “pnm”, and “tiff”.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: An image block is generated for **all and every image occurrence** on the page.
    Hence there may be duplicates, if an image is shown at different locations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[TextPage](#textpage) and corresponding method [`Page.get_text()`](page.html#Page.get_text
    "Page.get_text") are **available for all document types**. Only for PDF documents,
    methods [`Document.get_page_images()`](document.html#Document.get_page_images
    "Document.get_page_images") / [`Page.get_images()`](page.html#Page.get_images
    "Page.get_images") offer some overlapping functionality as far as image lists
    are concerned. But both lists **may or may not** contain the same items. Any differences
    are most probably caused by one of the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: “Inline” images (see page 214 of the [Adobe PDF References](app3.html#adobemanual))
    of a PDF page are contained in a textpage, but **do not appear** in [`Page.get_images()`](page.html#Page.get_images
    "Page.get_images").
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Annotations may also contain images – these will **not appear** in [`Page.get_images()`](page.html#Page.get_images
    "Page.get_images").
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Image blocks in a textpage are generated for **every** image location – whether
    or not there are any duplicates. This is in contrast to [`Page.get_images()`](page.html#Page.get_images
    "Page.get_images"), which will list each image only once (per reference name).
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Images mentioned in the page’s [`object`](glossary.html#object "object") definition
    will **always** appear in [`Page.get_images()`](page.html#Page.get_images "Page.get_images")
    [[1]](#f1). But it may happen, that there is no “display” command in the page’s
    [`contents`](glossary.html#contents "contents") (erroneously or on purpose). In
    this case the image will **not appear** in the textpage.
  prefs:
  - PREF_IND
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The image’s “transformation matrix” is defined as the matrix, for which the
    expression `bbox / transform == pymupdf.Rect(0, 0, 1, 1)` is true, lookup details
    here: [Image Transformation Matrix](app3.html#imagetransformation).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Text block:**'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Key** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| type | 0 = text *(int)* |'
  prefs: []
  type: TYPE_TB
- en: '| bbox | block rectangle, [`rect_like`](glossary.html#rect_like "rect_like")
    |'
  prefs: []
  type: TYPE_TB
- en: '| number | block count *(int)* |'
  prefs: []
  type: TYPE_TB
- en: '| lines | *list* of text line dictionaries |'
  prefs: []
  type: TYPE_TB
- en: Line Dictionary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '| **Key** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| bbox | line rectangle, [`rect_like`](glossary.html#rect_like "rect_like")
    |'
  prefs: []
  type: TYPE_TB
- en: '| wmode | writing mode *(int)*: 0 = horizontal, 1 = vertical |'
  prefs: []
  type: TYPE_TB
- en: '| dir | writing direction, [`point_like`](glossary.html#point_like "point_like")
    |'
  prefs: []
  type: TYPE_TB
- en: '| spans | *list* of span dictionaries |'
  prefs: []
  type: TYPE_TB
- en: 'The value of key *“dir”* is the **unit vector** `dir = (cosine, -sine)` of
    the angle, which the text has relative to the x-axis [[2]](#f2). See the following
    picture: The word in each quadrant (counter-clockwise from top-right to bottom-right)
    is rotated by 30, 120, 210 and 300 degrees respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![_images/img-line-dir.png](../Images/15ecc7ea6bdd91ad4e72dbbef2a91170.png)](_images/img-line-dir.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Span Dictionary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Spans contain the actual text. A line contains **more than one span only**,
    if it contains text with different font properties.
  prefs: []
  type: TYPE_NORMAL
- en: Changed in version 1.14.17 Spans now also have a *bbox* key (again).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changed in version 1.17.6 Spans now also have an *origin* key.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| **Key** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| bbox | span rectangle, [`rect_like`](glossary.html#rect_like "rect_like")
    |'
  prefs: []
  type: TYPE_TB
- en: '| origin | the first character’s origin, [`point_like`](glossary.html#point_like
    "point_like") |'
  prefs: []
  type: TYPE_TB
- en: '| font | font name *(str)* |'
  prefs: []
  type: TYPE_TB
- en: '| ascender | ascender of the font *(float)* |'
  prefs: []
  type: TYPE_TB
- en: '| descender | descender of the font *(float)* |'
  prefs: []
  type: TYPE_TB
- en: '| size | font size *(float)* |'
  prefs: []
  type: TYPE_TB
- en: '| flags | font characteristics *(int)* |'
  prefs: []
  type: TYPE_TB
- en: '| color | text color in sRGB format *(int)* |'
  prefs: []
  type: TYPE_TB
- en: '| text | (only for `extractDICT()`) text *(str)* |'
  prefs: []
  type: TYPE_TB
- en: '| chars | (only for `extractRAWDICT()`) *list* of character dictionaries |'
  prefs: []
  type: TYPE_TB
- en: '*(New in version 1.16.0):* *“color”* is the text color encoded in sRGB (int)
    format, e.g. 0xFF0000 for red. There are functions for converting this integer
    back to formats (r, g, b) (PDF with float values from 0 to 1) [`sRGB_to_pdf()`](functions.html#sRGB_to_pdf
    "sRGB_to_pdf"), or (R, G, B), [`sRGB_to_rgb()`](functions.html#sRGB_to_rgb "sRGB_to_rgb")
    (with integer values from 0 to 255).'
  prefs: []
  type: TYPE_NORMAL
- en: '*(New in v1.18.5):* *“ascender”* and *“descender”* are font properties, provided
    relative to [`fontsize`](glossary.html#fontsize "fontsize") 1\. Note that descender
    is a negative value. The following picture shows the relationship to other values
    and properties.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![_images/img-asc-desc.png](../Images/9ea0597ab8c50db132b5765ca4c0e43b.png)](_images/img-asc-desc.png)'
  prefs: []
  type: TYPE_NORMAL
- en: 'These numbers may be used to compute the minimum height of a character (or
    span) – as opposed to the standard height provided in the “bbox” values (which
    actually represents the **line height**). The following code recalculates the
    span bbox to have a height of **fontsize** exactly fitting the text inside:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Caution
  prefs: []
  type: TYPE_NORMAL
- en: The above calculation may deliver a **larger** height! This may e.g. happen
    for OCRed documents, where the risk of all sorts of text artifacts is high. MuPDF
    tries to come up with a reasonable bbox height, independently from the [`fontsize`](glossary.html#fontsize
    "fontsize") found in the PDF. So please ensure that the height of `span["bbox"]`
    is **larger** than `span["size"]`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You may request PyMuPDF to do all of the above automatically by executing `pymupdf.TOOLS.set_small_glyph_heights(True)`.
    This sets a global parameter so that all subsequent text searches and text extractions
    are based on reduced glyph heights, where meaningful.
  prefs: []
  type: TYPE_NORMAL
- en: The following shows the original span rectangle in red and the rectangle with
    re-computed height in blue.
  prefs: []
  type: TYPE_NORMAL
- en: '[![_images/img-span-rect.png](../Images/08fd3328e61e00b5de7d30a5eb69dfb4.png)](_images/img-span-rect.png)'
  prefs: []
  type: TYPE_NORMAL
- en: '*“flags”* is an integer, which represents font properties except for the first
    bit 0\. They are to be interpreted like this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'bit 0: superscripted (2⁰) – not a font property, detected by MuPDF code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'bit 1: italic (2¹)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'bit 2: serifed (2²)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'bit 3: monospaced (2³)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'bit 4: bold (2⁴)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Test these characteristics like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Bits 1 thru 4 are font properties, i.e. encoded in the font program. Please
    note, that this information is not necessarily correct or complete: fonts quite
    often contain wrong data here.'
  prefs: []
  type: TYPE_NORMAL
- en: Character Dictionary for `extractRAWDICT()`
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '| **Key** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| origin | character’s left baseline point, [`point_like`](glossary.html#point_like
    "point_like") |'
  prefs: []
  type: TYPE_TB
- en: '| bbox | character rectangle, [`rect_like`](glossary.html#rect_like "rect_like")
    |'
  prefs: []
  type: TYPE_TB
- en: '| c | the character (unicode) |'
  prefs: []
  type: TYPE_TB
- en: 'This image shows the relationship between a character’s bbox and its quad:
    [![textpagechar](../Images/ee61a05de894965b12f164a4bd64419d.png)](_images/img-textpage-char.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Footnotes
  prefs: []
  type: TYPE_NORMAL
- en: Do you have any feedback on this page?
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: This software is provided AS-IS with no warranty, either express or implied.
    This software is distributed under license and may not be copied, modified or
    distributed except as expressly authorized under the terms of that license. Refer
    to licensing information at [artifex.com](https://www.artifex.com?utm_source=rtd-pymupdf&utm_medium=rtd&utm_content=footer-link)
    or contact Artifex Software Inc., 39 Mesa Street, Suite 108A, San Francisco CA
    94129, United States for further information.
  prefs: []
  type: TYPE_NORMAL
- en: This documentation covers all versions up to 1.24.4.
  prefs: []
  type: TYPE_NORMAL
- en: '[![Discord logo](../Images/66cbb5081103a580193aa66c87b90d9a.png)](https://discord.gg/TSpYGBW4eq)'
  prefs: []
  type: TYPE_NORMAL
