- en: Session Basics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 会话基础
- en: 原文：[https://docs.sqlalchemy.org/en/20/orm/session_basics.html](https://docs.sqlalchemy.org/en/20/orm/session_basics.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://docs.sqlalchemy.org/en/20/orm/session_basics.html](https://docs.sqlalchemy.org/en/20/orm/session_basics.html)
- en: What does the Session do ?
  id: totrans-2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 会话的作用是什么？
- en: In the most general sense, the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") establishes all conversations with the database and
    represents a “holding zone” for all the objects which you’ve loaded or associated
    with it during its lifespan. It provides the interface where SELECT and other
    queries are made that will return and modify ORM-mapped objects. The ORM objects
    themselves are maintained inside the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), inside a structure called the [identity map](../glossary.html#term-identity-map)
    - a data structure that maintains unique copies of each object, where “unique”
    means “only one object with a particular primary key”.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 从最一般的意义上讲，[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    建立了与数据库的所有交流，并代表了其生命周期内加载或关联的所有对象的“存储区”。它提供了一个接口，用于进行 SELECT 和其他查询，这些查询将返回并修改
    ORM 映射的对象。ORM 对象本身保存在 [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    内部，位于一个称为 [identity map](../glossary.html#term-identity-map) 的结构中 - 这是一种维护每个对象唯一副本的数据结构，其中“唯一”意味着“只有一个具有特定主键的对象”。
- en: The [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    in its most common pattern of use begins in a mostly stateless form. Once queries
    are issued or other objects are persisted with it, it requests a connection resource
    from an [`Engine`](../core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    that is associated with the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), and then establishes a transaction on that connection.
    This transaction remains in effect until the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is instructed to commit or roll back the transaction.
    When the transaction ends, the connection resource associated with the [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") is [released](../glossary.html#term-released) to the
    connection pool managed by the engine. A new transaction then starts with a new
    connection checkout.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在其最常见的使用模式中，[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    以大多数无状态形式开始。一旦发出查询或使用其他对象进行持久化，它将从与 [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 关联的 [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") 请求连接资源，然后在该连接上建立事务。该事务保持生效直到 [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 被指示提交或回滚事务。当事务结束时，与 [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") 关联的连接资源将被 [释放](../glossary.html#term-released) 到引擎管理的连接池中。然后，使用新的连接检出开始新的事务。
- en: The ORM objects maintained by a [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") are [instrumented](../glossary.html#term-instrumented)
    such that whenever an attribute or a collection is modified in the Python program,
    a change event is generated which is recorded by the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"). Whenever the database is about to be queried, or when
    the transaction is about to be committed, the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") first **flushes** all pending changes stored in memory
    to the database. This is known as the [unit of work](../glossary.html#term-unit-of-work)
    pattern.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 由 [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    维护的 ORM 对象被 [instrumented](../glossary.html#term-instrumented) 以便每当 Python 程序中的属性或集合被修改时，都会生成一个变更事件，该事件会被
    [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    记录下来。每当数据库即将被查询或事务即将被提交时，[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    首先 **flushes** 所有存储在内存中的待定更改到数据库中。这被称为 [unit of work](../glossary.html#term-unit-of-work)
    模式。
- en: When using a [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session"),
    it’s useful to consider the ORM mapped objects that it maintains as **proxy objects**
    to database rows, which are local to the transaction being held by the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"). In order to maintain the state on the objects as matching
    what’s actually in the database, there are a variety of events that will cause
    objects to re-access the database in order to keep synchronized. It is possible
    to “detach” objects from a [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), and to continue using them, though this practice has
    its caveats. It’s intended that usually, you’d re-associate detached objects with
    another [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    when you want to work with them again, so that they can resume their normal task
    of representing database state.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    时，将其维护的 ORM 映射对象视为**代理对象**，它们对应于事务在 [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 中保持的本地数据库行。为了保持对象的状态与实际数据库中的状态相匹配，存在各种事件会导致对象重新访问数据库以保持同步。可以“分离”对象与
    [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")，并继续使用它们，尽管这种做法有其注意事项。通常情况下，当您想要再次使用它们时，您会重新将已分离的对象与另一个
    [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    关联起来，以便它们可以恢复其表示数据库状态的正常任务。
- en: '## Basics of Using a Session'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '## 使用会话的基础知识'
- en: The most basic [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    use patterns are presented here.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这里介绍了最基本的 [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    使用模式。
- en: '### Opening and Closing a Session'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '### 打开和关闭会话'
- en: 'The [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    may be constructed on its own or by using the [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker") class. It typically is passed a single [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") as a source of connectivity up front. A typical use
    may look like:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    可以单独构建，也可以使用 [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker "sqlalchemy.orm.sessionmaker")
    类构建。通常，它会在开始时传递一个单独的 [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") 作为连接源。典型的用法可能如下所示：'
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Above, the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    is instantiated with an [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") associated with a particular database URL. It is then
    used in a Python context manager (i.e. `with:` statement) so that it is automatically
    closed at the end of the block; this is equivalent to calling the [`Session.close()`](session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") method.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    是使用与特定数据库 URL 关联的 [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") 实例化的。然后，在 Python 上下文管理器（即 `with:` 语句）中使用它，以便在块结束时自动关闭；这相当于调用
    [`Session.close()`](session_api.html#sqlalchemy.orm.Session.close "sqlalchemy.orm.Session.close")
    方法。
- en: The call to [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") is optional, and is only needed if the work we’ve
    done with the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    includes new data to be persisted to the database. If we were only issuing SELECT
    calls and did not need to write any changes, then the call to [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") would be unnecessary.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 对 [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit "sqlalchemy.orm.Session.commit")
    的调用是可选的，仅在我们与 [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    执行的工作包含要持久化到数据库的新数据时才需要。如果我们只发出 SELECT 调用并且不需要写入任何更改，则对 [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") 的调用是不必要的。
- en: Note
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Note that after [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") is called, either explicitly or when using a
    context manager, all objects associated with the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") are [expired](../glossary.html#term-expired), meaning
    their contents are erased to be re-loaded within the next transaction. If these
    objects are instead [detached](../glossary.html#term-detached), they will be non-functional
    until re-associated with a new [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), unless the [`Session.expire_on_commit`](session_api.html#sqlalchemy.orm.Session.params.expire_on_commit
    "sqlalchemy.orm.Session") parameter is used to disable this behavior. See the
    section [Committing](#session-committing) for more detail.  ### Framing out a
    begin / commit / rollback block'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '注意，在调用 [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") 之后，无论是显式地还是在使用上下文管理器时，与 [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 关联的所有对象都会被[过期](../glossary.html#term-expired)，这意味着它们的内容将被清除以在下一个事务中重新加载。
    如果这些对象被[分离](../glossary.html#term-detached)，除非使用 [`Session.expire_on_commit`](session_api.html#sqlalchemy.orm.Session.params.expire_on_commit
    "sqlalchemy.orm.Session") 参数来禁用此行为，否则它们将无法使用，直到与新的 [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 重新关联。 更多细节请参见[提交](#session-committing)部分。  ### 划定一个开始/提交/回滚块的框架'
- en: 'We may also enclose the [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") call and the overall “framing” of the transaction
    within a context manager for those cases where we will be committing data to the
    database. By “framing” we mean that if all operations succeed, the [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") method will be called, but if any exceptions
    are raised, the [`Session.rollback()`](session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") method will be called so that the transaction
    is rolled back immediately, before propagating the exception outward. In Python
    this is most fundamentally expressed using a `try: / except: / else:` block such
    as:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '对于那些将要向数据库提交数据的情况，我们还可以将 [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") 调用和整个事务的“框架”置于上下文管理器中。 在这里，“框架”意味着如果所有操作成功，则会调用
    [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit "sqlalchemy.orm.Session.commit")
    方法，但如果引发任何异常，则会立即调用 [`Session.rollback()`](session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") 方法，以便在将异常向外传播之前立即回滚事务。 在Python中，这主要是通过使用类似
    `try: / except: / else:` 的代码块来表达的：'
- en: '[PRE1]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The long-form sequence of operations illustrated above can be achieved more
    succinctly by making use of the [`SessionTransaction`](session_api.html#sqlalchemy.orm.SessionTransaction
    "sqlalchemy.orm.SessionTransaction") object returned by the [`Session.begin()`](session_api.html#sqlalchemy.orm.Session.begin
    "sqlalchemy.orm.Session.begin") method, which provides a context manager interface
    for the same sequence of operations:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 [`Session.begin()`](session_api.html#sqlalchemy.orm.Session.begin "sqlalchemy.orm.Session.begin")
    方法返回的 [`SessionTransaction`](session_api.html#sqlalchemy.orm.SessionTransaction
    "sqlalchemy.orm.SessionTransaction") 对象可以更简洁地实现上述的长形操作序列，该对象为相同操作序列提供了上下文管理器接口：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'More succinctly, the two contexts may be combined:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 更简洁地说，这两个上下文可以合并：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Using a sessionmaker
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用一个 sessionmaker
- en: 'The purpose of [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker") is to provide a factory for [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") objects with a fixed configuration. As it is typical
    that an application will have an [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") object in module scope, the [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker") can provide a factory for [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") objects that are against this engine:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '[`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker "sqlalchemy.orm.sessionmaker")
    的目的是为具有固定配置的 [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    对象提供一个工厂。 由于典型的应用程序会在模块范围内具有一个 [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") 对象，因此 [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker") 可以为与此引擎相对应的 [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 对象提供一个工厂：'
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker "sqlalchemy.orm.sessionmaker")
    is analogous to the [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") as a module-level factory for function-level sessions
    / connections. As such it also has its own [`sessionmaker.begin()`](session_api.html#sqlalchemy.orm.sessionmaker.begin
    "sqlalchemy.orm.sessionmaker.begin") method, analogous to [`Engine.begin()`](../core/connections.html#sqlalchemy.engine.Engine.begin
    "sqlalchemy.engine.Engine.begin"), which returns a [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") object and also maintains a begin/commit/rollback block:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '[`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker "sqlalchemy.orm.sessionmaker")
    类似于 [`Engine`](../core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")，是一个模块级别的工厂，用于函数级别的会话
    / 连接。因此，它也有自己的 [`sessionmaker.begin()`](session_api.html#sqlalchemy.orm.sessionmaker.begin
    "sqlalchemy.orm.sessionmaker.begin") 方法，类似于 [`Engine.begin()`](../core/connections.html#sqlalchemy.engine.Engine.begin
    "sqlalchemy.engine.Engine.begin")，它返回一个 [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 对象，并维护一个开始 / 提交 / 回滚块：'
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Where above, the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    will both have its transaction committed as well as that the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") will be closed, when the above `with:` block ends.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述 `with:` 块结束时，[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    的事务将提交，并且 [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    将关闭。
- en: When you write your application, the [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker") factory should be scoped the same as the [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") object created by [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine"), which is typically at module-level or global scope.
    As these objects are both factories, they can be used by any number of functions
    and threads simultaneously.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写应用程序时，[`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker "sqlalchemy.orm.sessionmaker")
    工厂应与 [`create_engine()`](../core/engines.html#sqlalchemy.create_engine "sqlalchemy.create_engine")
    创建的 [`Engine`](../core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    对象的范围相同，通常是模块级或全局范围。由于这些对象都是工厂，因此它们可以被任意数量的函数和线程同时使用。
- en: See also
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker "sqlalchemy.orm.sessionmaker")'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '[`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker "sqlalchemy.orm.sessionmaker")'
- en: '[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")'
- en: '### Querying'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '### 查询'
- en: The primary means of querying is to make use of the [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") construct to create a [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") object, which is then executed to return a
    result using methods such as [`Session.execute()`](session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") and [`Session.scalars()`](session_api.html#sqlalchemy.orm.Session.scalars
    "sqlalchemy.orm.Session.scalars"). Results are then returned in terms of [`Result`](../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") objects, including sub-variants such as [`ScalarResult`](../core/connections.html#sqlalchemy.engine.ScalarResult
    "sqlalchemy.engine.ScalarResult").
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 查询的主要方法是利用 [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") 构造来创建一个 [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") 对象，然后使用诸如 [`Session.execute()`](session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") 和 [`Session.scalars()`](session_api.html#sqlalchemy.orm.Session.scalars
    "sqlalchemy.orm.Session.scalars") 等方法执行该对象以返回结果。然后以 [`Result`](../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") 对象的形式返回结果，包括 [`ScalarResult`](../core/connections.html#sqlalchemy.engine.ScalarResult
    "sqlalchemy.engine.ScalarResult") 等子变体。
- en: 'A complete guide to SQLAlchemy ORM querying can be found at [ORM Querying Guide](queryguide/index.html).
    Some brief examples follow:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy ORM 查询的完整指南可在 [ORM 查询指南](queryguide/index.html) 找到。以下是一些简要示例：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Changed in version 2.0: “2.0” style querying is now standard. See [2.0 Migration
    - ORM Usage](../changelog/migration_20.html#migration-20-query-usage) for migration
    notes from the 1.x series.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 从 2.0 版本开始更改：现在采用“2.0”样式的查询作为标准。请参阅 [2.0 迁移 - ORM 用法](../changelog/migration_20.html#migration-20-query-usage)
    获取从 1.x 系列迁移的注意事项。
- en: See also
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[ORM Querying Guide](queryguide/index.html)  ### Adding New or Existing Items'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '[ORM 查询指南](queryguide/index.html)  ### 添加新项目或现有项目'
- en: '[`Session.add()`](session_api.html#sqlalchemy.orm.Session.add "sqlalchemy.orm.Session.add")
    is used to place instances in the session. For [transient](../glossary.html#term-transient)
    (i.e. brand new) instances, this will have the effect of an INSERT taking place
    for those instances upon the next flush. For instances which are [persistent](../glossary.html#term-persistent)
    (i.e. were loaded by this session), they are already present and do not need to
    be added. Instances which are [detached](../glossary.html#term-detached) (i.e.
    have been removed from a session) may be re-associated with a session using this
    method:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session.add()`](session_api.html#sqlalchemy.orm.Session.add "sqlalchemy.orm.Session.add")
    用于将实例放入会话中。对于[暂时的](../glossary.html#term-transient)（即全新的）实例，这将在下一次刷新时对这些实例执行插入操作。对于[持久的](../glossary.html#term-persistent)（即由此会话加载的）实例，它们已经存在，不需要添加。已[分离的](../glossary.html#term-detached)（即已从会话中移除的）实例可以使用此方法重新关联到会话中：'
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To add a list of items to the session at once, use [`Session.add_all()`](session_api.html#sqlalchemy.orm.Session.add_all
    "sqlalchemy.orm.Session.add_all"):'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '要一次将一系列项目添加到会话中，请使用 [`Session.add_all()`](session_api.html#sqlalchemy.orm.Session.add_all
    "sqlalchemy.orm.Session.add_all"):'
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The [`Session.add()`](session_api.html#sqlalchemy.orm.Session.add "sqlalchemy.orm.Session.add")
    operation **cascades** along the `save-update` cascade. For more details see the
    section [Cascades](cascades.html#unitofwork-cascades).  ### Deleting'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session.add()`](session_api.html#sqlalchemy.orm.Session.add "sqlalchemy.orm.Session.add")
    操作 **级联** 到 `save-update` 级联。有关更多详细信息，请参阅 [级联](cascades.html#unitofwork-cascades)
    部分。### 删除'
- en: 'The [`Session.delete()`](session_api.html#sqlalchemy.orm.Session.delete "sqlalchemy.orm.Session.delete")
    method places an instance into the Session’s list of objects to be marked as deleted:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session.delete()`](session_api.html#sqlalchemy.orm.Session.delete "sqlalchemy.orm.Session.delete")
    方法将实例放入会话的待删除对象列表中：'
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[`Session.delete()`](session_api.html#sqlalchemy.orm.Session.delete "sqlalchemy.orm.Session.delete")
    marks an object for deletion, which will result in a DELETE statement emitted
    for each primary key affected. Before the pending deletes are flushed, objects
    marked by “delete” are present in the [`Session.deleted`](session_api.html#sqlalchemy.orm.Session.deleted
    "sqlalchemy.orm.Session.deleted") collection. After the DELETE, they are expunged
    from the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session"),
    which becomes permanent after the transaction is committed.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session.delete()`](session_api.html#sqlalchemy.orm.Session.delete "sqlalchemy.orm.Session.delete")
    标记对象以进行删除，这将导致针对每个受影响的主键发出 DELETE 语句。在待刷新的删除之前，被“删除”标记的对象存在于 [`Session.deleted`](session_api.html#sqlalchemy.orm.Session.deleted
    "sqlalchemy.orm.Session.deleted") 集合中。DELETE 后，它们从 [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 中删除，该会话在事务提交后变为永久。'
- en: 'There are various important behaviors related to the [`Session.delete()`](session_api.html#sqlalchemy.orm.Session.delete
    "sqlalchemy.orm.Session.delete") operation, particularly in how relationships
    to other objects and collections are handled. There’s more information on how
    this works in the section [Cascades](cascades.html#unitofwork-cascades), but in
    general the rules are:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session.delete()`](session_api.html#sqlalchemy.orm.Session.delete "sqlalchemy.orm.Session.delete")
    操作有各种与其他对象和集合的关系相关的重要行为。有关此操作的详细信息，请参阅 [级联](cascades.html#unitofwork-cascades)
    部分，但总的规则是：'
- en: Rows that correspond to mapped objects that are related to a deleted object
    via the [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")
    directive are **not deleted by default**. If those objects have a foreign key
    constraint back to the row being deleted, those columns are set to NULL. This
    will cause a constraint violation if the columns are non-nullable.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与通过 [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")
    指令与被删除对象相关的映射对象对应的行**默认情况下不会被删除**。如果这些对象有一个外键约束返回到被删除的行，这些列将被设置为 NULL。如果这些列是非空的，这将导致约束违规。
- en: To change the “SET NULL” into a DELETE of a related object’s row, use the [delete](cascades.html#cascade-delete)
    cascade on the [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship").
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要将相关对象的行的“SET NULL”更改为删除，请在 [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") 上使用 [delete](cascades.html#cascade-delete) 级联。
- en: Rows that are in tables linked as “many-to-many” tables, via the [`relationship.secondary`](relationship_api.html#sqlalchemy.orm.relationship.params.secondary
    "sqlalchemy.orm.relationship") parameter, **are** deleted in all cases when the
    object they refer to is deleted.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当表中的行通过[`relationship.secondary`](relationship_api.html#sqlalchemy.orm.relationship.params.secondary
    "sqlalchemy.orm.relationship") 参数链接为“多对多”表时，当它们所指向的对象被删除时，这些行在所有情况下都会被删除。
- en: When related objects include a foreign key constraint back to the object being
    deleted, and the related collections to which they belong are not currently loaded
    into memory, the unit of work will emit a SELECT to fetch all related rows, so
    that their primary key values can be used to emit either UPDATE or DELETE statements
    on those related rows. In this way, the ORM without further instruction will perform
    the function of ON DELETE CASCADE, even if this is configured on Core [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") objects.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当相关对象包含指向要删除对象的外键约束，并且它们所属的相关集合目前未加载到内存中时，工作单元将发出SELECT语句以获取所有相关行，以便它们的主键值可用于发出这些相关行的UPDATE或DELETE语句。这样，即使在Core
    [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") 对象上配置了此功能，ORM也会在没有进一步指示的情况下执行ON DELETE
    CASCADE的功能。
- en: The [`relationship.passive_deletes`](relationship_api.html#sqlalchemy.orm.relationship.params.passive_deletes
    "sqlalchemy.orm.relationship") parameter can be used to tune this behavior and
    rely upon “ON DELETE CASCADE” more naturally; when set to True, this SELECT operation
    will no longer take place, however rows that are locally present will still be
    subject to explicit SET NULL or DELETE. Setting [`relationship.passive_deletes`](relationship_api.html#sqlalchemy.orm.relationship.params.passive_deletes
    "sqlalchemy.orm.relationship") to the string `"all"` will disable **all** related
    object update/delete.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`relationship.passive_deletes`](relationship_api.html#sqlalchemy.orm.relationship.params.passive_deletes
    "sqlalchemy.orm.relationship") 参数可用于调整此行为并更自然地依赖于“ON DELETE CASCADE”；当设置为True时，此SELECT操作将不再发生，但是仍然存在的行仍将受到显式的SET
    NULL或DELETE影响。将 [`relationship.passive_deletes`](relationship_api.html#sqlalchemy.orm.relationship.params.passive_deletes
    "sqlalchemy.orm.relationship.params.passive_deletes") 设置为字符串`"all"`将禁用所有相关对象的更新/删除。'
- en: When the DELETE occurs for an object marked for deletion, the object is not
    automatically removed from collections or object references that refer to it.
    When the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    is expired, these collections may be loaded again so that the object is no longer
    present. However, it is preferable that instead of using [`Session.delete()`](session_api.html#sqlalchemy.orm.Session.delete
    "sqlalchemy.orm.Session.delete") for these objects, the object should instead
    be removed from its collection and then [delete-orphan](cascades.html#cascade-delete-orphan)
    should be used so that it is deleted as a secondary effect of that collection
    removal. See the section [Notes on Delete - Deleting Objects Referenced from Collections
    and Scalar Relationships](cascades.html#session-deleting-from-collections) for
    an example of this.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当标记为删除的对象发生DELETE时，对象不会自动从引用它的集合或对象引用中删除。当[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")过期时，这些集合可能会被重新加载，以便对象不再存在。然而，最好的做法是，不要对这些对象使用[`Session.delete()`](session_api.html#sqlalchemy.orm.Session.delete
    "sqlalchemy.orm.Session.delete")，而是应该从其集合中删除对象，然后使用[delete-orphan](cascades.html#cascade-delete-orphan)
    来确保它在集合删除的次要影响下被删除。有关此的示例，请参阅[删除说明 - 从集合和标量关系中删除对象](cascades.html#session-deleting-from-collections)
    部分。
- en: See also
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[delete](cascades.html#cascade-delete) - describes “delete cascade”, which
    marks related objects for deletion when a lead object is deleted.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '[delete](cascades.html#cascade-delete) - 描述了“删除级联”，当主对象被删除时，标记相关对象以删除。'
- en: '[delete-orphan](cascades.html#cascade-delete-orphan) - describes “delete orphan
    cascade”, which marks related objects for deletion when they are de-associated
    from their lead object.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '[delete-orphan](cascades.html#cascade-delete-orphan) - 描述了“删除孤立对象级联”，当它们与其主对象解除关联时，将标记相关对象以删除。'
- en: '[Notes on Delete - Deleting Objects Referenced from Collections and Scalar
    Relationships](cascades.html#session-deleting-from-collections) - important background
    on [`Session.delete()`](session_api.html#sqlalchemy.orm.Session.delete "sqlalchemy.orm.Session.delete")
    as involves relationships being refreshed in memory.  ### Flushing'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '[删除注释 - 从集合和标量关系中删除引用的对象](cascades.html#session-deleting-from-collections)
    - 关于[`Session.delete()`](session_api.html#sqlalchemy.orm.Session.delete "sqlalchemy.orm.Session.delete")的重要背景，涉及到在内存中刷新关系。###
    刷新'
- en: When the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.session.Session")
    is used with its default configuration, the flush step is nearly always done transparently.
    Specifically, the flush occurs before any individual SQL statement is issued as
    a result of a [`Query`](queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    or a [2.0-style](../glossary.html#term-1) [`Session.execute()`](session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") call, as well as within the [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") call before the transaction is committed. It
    also occurs before a SAVEPOINT is issued when [`Session.begin_nested()`](session_api.html#sqlalchemy.orm.Session.begin_nested
    "sqlalchemy.orm.Session.begin_nested") is used.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.session.Session")使用其默认配置时，刷新步骤几乎总是透明完成的。具体来说，在因[`Query`](queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")或[2.0风格](../glossary.html#term-1)的[`Session.execute()`](session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute")调用而发出任何单个SQL语句之前，以及在[`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit")调用中在事务提交之前，都会发生刷新。当使用[`Session.begin_nested()`](session_api.html#sqlalchemy.orm.Session.begin_nested
    "sqlalchemy.orm.Session.begin_nested")时，也会在发出SAVEPOINT之前发生刷新。
- en: 'A [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    flush can be forced at any time by calling the [`Session.flush()`](session_api.html#sqlalchemy.orm.Session.flush
    "sqlalchemy.orm.Session.flush") method:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过调用[`Session.flush()`](session_api.html#sqlalchemy.orm.Session.flush "sqlalchemy.orm.Session.flush")方法在任何时候强制进行[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")刷新：
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The flush which occurs automatically within the scope of certain methods is
    known as **autoflush**. Autoflush is defined as a configurable, automatic flush
    call which occurs at the beginning of methods including:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些方法的范围内自动发生的刷新称为**自动刷新**。自动刷新被定义为一种可配置的自动刷新调用，该调用发生在包括以下方法的开头：
- en: '[`Session.execute()`](session_api.html#sqlalchemy.orm.Session.execute "sqlalchemy.orm.Session.execute")
    and other SQL-executing methods, when used against ORM-enabled SQL constructs,
    such as [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") objects that refer to ORM entities and/or
    ORM-mapped attributes'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当针对ORM启用的SQL构造（例如引用ORM实体和/或ORM映射属性的[`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select")对象）使用[`Session.execute()`](session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute")和其他执行SQL的方法时
- en: When a [`Query`](queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    is invoked to send SQL to the database
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当调用[`Query`](queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")以将SQL发送到数据库时
- en: Within the [`Session.merge()`](session_api.html#sqlalchemy.orm.Session.merge
    "sqlalchemy.orm.Session.merge") method before querying the database
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在查询数据库之前的[`Session.merge()`](session_api.html#sqlalchemy.orm.Session.merge "sqlalchemy.orm.Session.merge")方法的过程中
- en: When objects are [refreshed](#session-expiring)
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当对象被[刷新](#session-expiring)
- en: When ORM [lazy load](../glossary.html#term-lazy-load) operations occur against
    unloaded object attributes.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当针对未加载对象属性进行ORM[延迟加载](../glossary.html#term-lazy-load)操作时。
- en: 'There are also points at which flushes occur **unconditionally**; these points
    are within key transactional boundaries which include:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些刷新发生的**无条件**点； 这些点位于关键的事务边界内，包括：
- en: Within the process of the [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") method
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit "sqlalchemy.orm.Session.commit")方法的过程中
- en: When [`Session.begin_nested()`](session_api.html#sqlalchemy.orm.Session.begin_nested
    "sqlalchemy.orm.Session.begin_nested") is called
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当调用[`Session.begin_nested()`](session_api.html#sqlalchemy.orm.Session.begin_nested
    "sqlalchemy.orm.Session.begin_nested")时
- en: When the [`Session.prepare()`](session_api.html#sqlalchemy.orm.Session.prepare
    "sqlalchemy.orm.Session.prepare") 2PC method is used.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用[`Session.prepare()`](session_api.html#sqlalchemy.orm.Session.prepare "sqlalchemy.orm.Session.prepare")
    2PC方法时。
- en: 'The **autoflush** behavior, as applied to the previous list of items, can be
    disabled by constructing a [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") or [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker") passing the [`Session.autoflush`](session_api.html#sqlalchemy.orm.Session.params.autoflush
    "sqlalchemy.orm.Session") parameter as `False`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 通过构造一个传递 [`Session.autoflush`](session_api.html#sqlalchemy.orm.Session.params.autoflush
    "sqlalchemy.orm.Session.params.autoflush") 参数为 `False` 的 [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 或 [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker")，可以禁用 **autoflush** 行为，如前述条目列表所示：
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Additionally, autoflush can be temporarily disabled within the flow of using
    a [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    using the [`Session.no_autoflush`](session_api.html#sqlalchemy.orm.Session.no_autoflush
    "sqlalchemy.orm.Session.no_autoflush") context manager:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，可以在使用 [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    期间通过使用 [`Session.no_autoflush`](session_api.html#sqlalchemy.orm.Session.no_autoflush
    "sqlalchemy.orm.Session.no_autoflush") 上下文管理器临时禁用自动刷新（autoflush）：
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '**To reiterate:** The flush process **always occurs** when transactional methods
    such as [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit "sqlalchemy.orm.Session.commit")
    and [`Session.begin_nested()`](session_api.html#sqlalchemy.orm.Session.begin_nested
    "sqlalchemy.orm.Session.begin_nested") are called, regardless of any “autoflush”
    settings, when the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    has remaining pending changes to process.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**再次强调：** 当调用事务方法，如 [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") 和 [`Session.begin_nested()`](session_api.html#sqlalchemy.orm.Session.begin_nested
    "sqlalchemy.orm.Session.begin_nested") 时，无论任何“autoflush”设置，当 [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 仍有待处理的更改时，刷新过程 **总是发生**。'
- en: As the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    only invokes SQL to the database within the context of a [DBAPI](../glossary.html#term-DBAPI)
    transaction, all “flush” operations themselves only occur within a database transaction
    (subject to the [isolation level](session_transaction.html#session-transaction-isolation)
    of the database transaction), provided that the DBAPI is not in [driver level
    autocommit](../core/connections.html#dbapi-autocommit) mode. This means that assuming
    the database connection is providing for [atomicity](../glossary.html#term-atomicity)
    within its transactional settings, if any individual DML statement inside the
    flush fails, the entire operation will be rolled back.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    仅在 [DBAPI](../glossary.html#term-DBAPI) 事务上下文中调用数据库的 SQL，所有“flush”操作本身仅发生在数据库事务内部（取决于数据库事务的
    [隔离级别](session_transaction.html#session-transaction-isolation)），前提是 DBAPI 不处于
    [驱动程序级别的自动提交](../core/connections.html#dbapi-autocommit) 模式。这意味着假设数据库连接在其事务设置中提供了
    [原子性](../glossary.html#term-atomicity)，如果 flush 内的任何单个 DML 语句失败，则整个操作将被回滚。
- en: When a failure occurs within a flush, in order to continue using that same [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), an explicit call to [`Session.rollback()`](session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") is required after a flush fails, even though
    the underlying transaction will have been rolled back already (even if the database
    driver is technically in driver-level autocommit mode). This is so that the overall
    nesting pattern of so-called “subtransactions” is consistently maintained. The
    FAQ section [“This Session’s transaction has been rolled back due to a previous
    exception during flush.” (or similar)](../faq/sessions.html#faq-session-rollback)
    contains a more detailed description of this behavior.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当 flush 中发生故障时，为了继续使用相同的 [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")，需要在 flush 失败后显式调用 [`Session.rollback()`](session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback")，即使底层事务已经被回滚（即使数据库驱动程序在技术上处于驱动程序级别的自动提交模式）。这样做是为了始终保持所谓的“子事务”的整体嵌套模式。FAQ
    部分 [“This Session’s transaction has been rolled back due to a previous exception
    during flush.” (或类似内容)](../faq/sessions.html#faq-session-rollback) 中包含对此行为的更详细描述。
- en: See also
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[“This Session’s transaction has been rolled back due to a previous exception
    during flush.” (or similar)](../faq/sessions.html#faq-session-rollback) - further
    background on why [`Session.rollback()`](session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") must be called when a flush fails.  ### Get
    by Primary Key'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '[“此会话的事务已因刷新期间的先前异常而回滚。”（或类似内容）](../faq/sessions.html#faq-session-rollback)
    - 进一步解释为何在刷新失败时必须调用 [`Session.rollback()`](session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback")。 ### 通过主键获取'
- en: 'As the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    makes use of an [identity map](../glossary.html#term-identity-map) which refers
    to current in-memory objects by primary key, the [`Session.get()`](session_api.html#sqlalchemy.orm.Session.get
    "sqlalchemy.orm.Session.get") method is provided as a means of locating objects
    by primary key, first looking within the current identity map and then querying
    the database for non present values. Such as, to locate a `User` entity with primary
    key identity `(5, )`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    利用了一个[身份映射](../glossary.html#term-identity-map)，通过主键引用当前内存中的对象，因此 [`Session.get()`](session_api.html#sqlalchemy.orm.Session.get
    "sqlalchemy.orm.Session.get") 方法被提供为一种通过主键定位对象的方法，首先在当前身份映射中查找，然后查询数据库以获取不存在的值。例如，要定位主键标识为
    `(5, )` 的 `User` 实体：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The [`Session.get()`](session_api.html#sqlalchemy.orm.Session.get "sqlalchemy.orm.Session.get")
    also includes calling forms for composite primary key values, which may be passed
    as tuples or dictionaries, as well as additional parameters which allow for specific
    loader and execution options. See [`Session.get()`](session_api.html#sqlalchemy.orm.Session.get
    "sqlalchemy.orm.Session.get") for the complete parameter list.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session.get()`](session_api.html#sqlalchemy.orm.Session.get "sqlalchemy.orm.Session.get")
    也包括用于复合主键值的调用形式，可以作为元组或字典传递，以及允许特定加载器和执行选项的其他参数。有关完整参数列表，请参阅 [`Session.get()`](session_api.html#sqlalchemy.orm.Session.get
    "sqlalchemy.orm.Session.get")。'
- en: See also
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`Session.get()`](session_api.html#sqlalchemy.orm.Session.get "sqlalchemy.orm.Session.get")  ###
    Expiring / Refreshing'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session.get()`](session_api.html#sqlalchemy.orm.Session.get "sqlalchemy.orm.Session.get")  ###
    过期 / 刷新'
- en: 'An important consideration that will often come up when using the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is that of dealing with the state that is present on
    objects that have been loaded from the database, in terms of keeping them synchronized
    with the current state of the transaction. The SQLAlchemy ORM is based around
    the concept of an [identity map](../glossary.html#term-identity-map) such that
    when an object is “loaded” from a SQL query, there will be a unique Python object
    instance maintained corresponding to a particular database identity. This means
    if we emit two separate queries, each for the same row, and get a mapped object
    back, the two queries will have returned the same Python object:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    时经常遇到的一个重要考虑因素是处理从数据库加载的对象上存在的状态，以使其与当前事务的状态保持同步。SQLAlchemy ORM 基于[身份映射](../glossary.html#term-identity-map)的概念，这意味着当对象从
    SQL 查询中“加载”时，将维护一个对应于特定数据库标识的唯一 Python 对象实例。这意味着如果我们发出两个单独的查询，每个查询都针对同一行，并获得一个映射对象，则两个查询将返回相同的
    Python 对象：
- en: '[PRE14]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Following from this, when the ORM gets rows back from a query, it will **skip
    the population of attributes** for an object that’s already loaded. The design
    assumption here is to assume a transaction that’s perfectly isolated, and then
    to the degree that the transaction isn’t isolated, the application can take steps
    on an as-needed basis to refresh objects from the database transaction. The FAQ
    entry at [I’m re-loading data with my Session but it isn’t seeing changes that
    I committed elsewhere](../faq/sessions.html#faq-session-identity) discusses this
    concept in more detail.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，当 ORM 从查询中获取行时，它将**跳过已经加载的对象的属性填充**。这里的设计假设是假设一个完全隔离的事务，然后在事务不完全隔离的程度上，应用程序可以根据需要从数据库事务中刷新对象。
    [此 FAQ 条目](../faq/sessions.html#faq-session-identity) 在更详细地讨论了这个概念。
- en: 'When an ORM mapped object is loaded into memory, there are three general ways
    to refresh its contents with new data from the current transaction:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当 ORM 映射对象加载到内存中时，有三种常见方法可以使用当前事务中的新数据刷新其内容：
- en: '**the expire() method** - the [`Session.expire()`](session_api.html#sqlalchemy.orm.Session.expire
    "sqlalchemy.orm.Session.expire") method will erase the contents of selected or
    all attributes of an object, such that they will be loaded from the database when
    they are next accessed, e.g. using a [lazy loading](../glossary.html#term-lazy-loading)
    pattern:'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**expire() 方法** - [`Session.expire()`](session_api.html#sqlalchemy.orm.Session.expire
    "sqlalchemy.orm.Session.expire") 方法将擦除对象的选定或全部属性的内容，以便在下次访问时从数据库加载它们，例如使用 [延迟加载](../glossary.html#term-lazy-loading)
    模式：'
- en: '[PRE15]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '**the refresh() method** - closely related is the [`Session.refresh()`](session_api.html#sqlalchemy.orm.Session.refresh
    "sqlalchemy.orm.Session.refresh") method, which does everything the [`Session.expire()`](session_api.html#sqlalchemy.orm.Session.expire
    "sqlalchemy.orm.Session.expire") method does but also emits one or more SQL queries
    immediately to actually refresh the contents of the object:'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**refresh() 方法** - 相关联的是 [`Session.refresh()`](session_api.html#sqlalchemy.orm.Session.refresh
    "sqlalchemy.orm.Session.refresh") 方法，它做的事情与 [`Session.expire()`](session_api.html#sqlalchemy.orm.Session.expire
    "sqlalchemy.orm.Session.expire") 方法相同，但还会立即发出一个或多个 SQL 查询，以实际刷新对象的内容：'
- en: '[PRE16]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '**the populate_existing() method or execution option** - This is now an execution
    option documented at [Populate Existing](queryguide/api.html#orm-queryguide-populate-existing);
    in legacy form it’s found on the [`Query`](queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object as the [`Query.populate_existing()`](queryguide/query.html#sqlalchemy.orm.Query.populate_existing
    "sqlalchemy.orm.Query.populate_existing") method. This operation in either form
    indicates that objects being returned from a query should be unconditionally re-populated
    from their contents in the database:'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**populate_existing() 方法或执行选项** - 这现在是一个在 [Populate Existing](queryguide/api.html#orm-queryguide-populate-existing)
    中记录的执行选项；在传统形式中，它位于 [`Query`](queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    对象上，作为 [`Query.populate_existing()`](queryguide/query.html#sqlalchemy.orm.Query.populate_existing
    "sqlalchemy.orm.Query.populate_existing") 方法。无论以哪种形式，此操作都表示从查询返回的对象应无条件地从数据库中重新填充：'
- en: '[PRE17]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Further discussion on the refresh / expire concept can be found at [Refreshing
    / Expiring](session_state_management.html#session-expire).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 关于刷新 / 过期概念的进一步讨论，请参阅 [Refreshing / Expiring](session_state_management.html#session-expire)。
- en: See also
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 参见
- en: '[Refreshing / Expiring](session_state_management.html#session-expire)'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '[刷新 / 过期](session_state_management.html#session-expire)'
- en: '[I’m re-loading data with my Session but it isn’t seeing changes that I committed
    elsewhere](../faq/sessions.html#faq-session-identity)'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '[我正在使用我的 Session 重新加载数据，但它没有看到我在其他地方提交的更改](../faq/sessions.html#faq-session-identity)'
- en: UPDATE and DELETE with arbitrary WHERE clause
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用任意 WHERE 子句的 UPDATE 和 DELETE
- en: SQLAlchemy 2.0 includes enhanced capabilities for emitting several varieties
    of ORM-enabled INSERT, UPDATE and DELETE statements. See the document at [ORM-Enabled
    INSERT, UPDATE, and DELETE statements](queryguide/dml.html) for documentation.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 2.0 包括增强的功能，用于发出几种类型的启用 ORM 的 INSERT、UPDATE 和 DELETE 语句。有关文档，请参阅
    [ORM-Enabled INSERT, UPDATE, and DELETE statements](queryguide/dml.html)。
- en: See also
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 参见
- en: '[ORM-Enabled INSERT, UPDATE, and DELETE statements](queryguide/dml.html)'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '[启用 ORM 的 INSERT、UPDATE 和 DELETE 语句](queryguide/dml.html)'
- en: '[ORM UPDATE and DELETE with Custom WHERE Criteria](queryguide/dml.html#orm-queryguide-update-delete-where)'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用自定义 WHERE 条件的 ORM UPDATE 和 DELETE](queryguide/dml.html#orm-queryguide-update-delete-where)'
- en: '### Auto Begin'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '### 自动开始'
- en: The [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    object features a behavior known as **autobegin**. This indicates that the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") will internally consider itself to be in a “transactional”
    state as soon as any work is performed with the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), either involving modifications to the internal state
    of the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    with regards to object state changes, or with operations that require database
    connectivity.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    对象具有一种称为 **autobegin** 的行为。这表示，一旦使用 [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 执行了任何工作，无论是涉及修改 [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 内部状态的工作还是涉及需要数据库连接的操作，[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 将在内部将自身视为处于“事务”状态。'
- en: When the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    is first constructed, there’s no transactional state present. The transactional
    state is begun automatically, when a method such as [`Session.add()`](session_api.html#sqlalchemy.orm.Session.add
    "sqlalchemy.orm.Session.add") or [`Session.execute()`](session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") is invoked, or similarly if a [`Query`](queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") is executed to return results (which ultimately uses [`Session.execute()`](session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute")), or if an attribute is modified on a [persistent](../glossary.html#term-persistent)
    object.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当首次构建 [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    时，不存在事务状态。 当调用诸如 [`Session.add()`](session_api.html#sqlalchemy.orm.Session.add
    "sqlalchemy.orm.Session.add") 或 [`Session.execute()`](session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") 这样的方法时，或者类似地执行 [`Query`](queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") 以返回结果（最终使用 [`Session.execute()`](session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute")），或者如果在 [持久化](../glossary.html#term-persistent)
    对象上修改属性时，将自动开始事务状态。
- en: The transactional state can be checked by accessing the [`Session.in_transaction()`](session_api.html#sqlalchemy.orm.Session.in_transaction
    "sqlalchemy.orm.Session.in_transaction") method, which returns `True` or `False`
    indicating if the “autobegin” step has proceeded. While not normally needed, the
    [`Session.get_transaction()`](session_api.html#sqlalchemy.orm.Session.get_transaction
    "sqlalchemy.orm.Session.get_transaction") method will return the actual [`SessionTransaction`](session_api.html#sqlalchemy.orm.SessionTransaction
    "sqlalchemy.orm.SessionTransaction") object that represents this transactional
    state.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过访问 [`Session.in_transaction()`](session_api.html#sqlalchemy.orm.Session.in_transaction
    "sqlalchemy.orm.Session.in_transaction") 方法来检查事务状态，该方法返回 `True` 或 `False`，指示“自动开始”步骤是否已执行。
    虽然通常不需要，但 [`Session.get_transaction()`](session_api.html#sqlalchemy.orm.Session.get_transaction
    "sqlalchemy.orm.Session.get_transaction") 方法将返回表示此事务状态的实际 [`SessionTransaction`](session_api.html#sqlalchemy.orm.SessionTransaction
    "sqlalchemy.orm.SessionTransaction") 对象。
- en: The transactional state of the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") may also be started explicitly, by invoking the [`Session.begin()`](session_api.html#sqlalchemy.orm.Session.begin
    "sqlalchemy.orm.Session.begin") method. When this method is called, the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is placed into the “transactional” state unconditionally.
    [`Session.begin()`](session_api.html#sqlalchemy.orm.Session.begin "sqlalchemy.orm.Session.begin")
    may be used as a context manager as described at [Framing out a begin / commit
    / rollback block](#session-begin-commit-rollback-block).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    的事务状态也可以通过显式调用 [`Session.begin()`](session_api.html#sqlalchemy.orm.Session.begin
    "sqlalchemy.orm.Session.begin") 方法来启动。 当调用此方法时，[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 无条件地置于“事务性”状态。 [`Session.begin()`](session_api.html#sqlalchemy.orm.Session.begin
    "sqlalchemy.orm.Session.begin") 可以像在 [框架化一个 begin / commit / rollback 块](#session-begin-commit-rollback-block)
    中描述的那样用作上下文管理器。'
- en: '#### Disabling Autobegin to Prevent Implicit Transactions'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 禁用自动开始以防止隐式事务'
- en: 'The “autobegin” behavior may be disabled using the [`Session.autobegin`](session_api.html#sqlalchemy.orm.Session.params.autobegin
    "sqlalchemy.orm.Session") parameter set to `False`. By using this parameter, a
    [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    will require that the [`Session.begin()`](session_api.html#sqlalchemy.orm.Session.begin
    "sqlalchemy.orm.Session.begin") method is called explicitly. Upon construction,
    as well as after any of the [`Session.rollback()`](session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback"), [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit"), or [`Session.close()`](session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") methods are called, the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") won’t implicitly begin any new transactions and will
    raise an error if an attempt to use the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is made without first calling [`Session.begin()`](session_api.html#sqlalchemy.orm.Session.begin
    "sqlalchemy.orm.Session.begin"):'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 [`Session.autobegin`](session_api.html#sqlalchemy.orm.Session.params.autobegin
    "sqlalchemy.orm.Session") 参数将“自动开始”行为设置为 `False` 以禁用该行为。通过使用此参数，[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 将要求显式调用 [`Session.begin()`](session_api.html#sqlalchemy.orm.Session.begin
    "sqlalchemy.orm.Session.begin") 方法。在构造后以及调用 [`Session.rollback()`](session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback")、[`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") 或 [`Session.close()`](session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") 方法后，[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 不会隐式开始任何新事务，并且如果在首次调用 [`Session.begin()`](session_api.html#sqlalchemy.orm.Session.begin
    "sqlalchemy.orm.Session.begin") 之前尝试使用 [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")，则会引发错误：
- en: '[PRE18]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'New in version 2.0: Added [`Session.autobegin`](session_api.html#sqlalchemy.orm.Session.params.autobegin
    "sqlalchemy.orm.Session"), allowing “autobegin” behavior to be disabled  ### Committing'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '新版本 2.0 中新增了 [`Session.autobegin`](session_api.html#sqlalchemy.orm.Session.params.autobegin
    "sqlalchemy.orm.Session")，允许禁用“自动开始”行为。 ### 提交'
- en: '[`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit "sqlalchemy.orm.Session.commit")
    is used to commit the current transaction. At its core this indicates that it
    emits `COMMIT` on all current database connections that have a transaction in
    progress; from a [DBAPI](../glossary.html#term-DBAPI) perspective this means the
    `connection.commit()` DBAPI method is invoked on each DBAPI connection.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit "sqlalchemy.orm.Session.commit")
    用于提交当前事务。在核心上，这表示它会对所有当前具有进行中事务的数据库连接发出 `COMMIT`；从 [DBAPI](../glossary.html#term-DBAPI)
    的角度来看，这意味着会在每个 DBAPI 连接上调用 `connection.commit()` DBAPI 方法。'
- en: When there is no transaction in place for the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), indicating that no operations were invoked on this
    [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    since the previous call to [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit"), the method will begin and commit an internal-only
    “logical” transaction, that does not normally affect the database unless pending
    flush changes were detected, but will still invoke event handlers and object expiration
    rules.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 当对 [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    没有进行事务操作时，表示自上次调用 [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") 以来未对此 [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 执行任何操作时，该方法将开始并提交一个仅限内部的“逻辑”事务，通常不会影响数据库，除非检测到挂起的刷新更改，但仍会调用事件处理程序和对象过期规则。
- en: The [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit "sqlalchemy.orm.Session.commit")
    operation unconditionally issues [`Session.flush()`](session_api.html#sqlalchemy.orm.Session.flush
    "sqlalchemy.orm.Session.flush") before emitting COMMIT on relevant database connections.
    If no pending changes are detected, then no SQL is emitted to the database. This
    behavior is not configurable and is not affected by the [`Session.autoflush`](session_api.html#sqlalchemy.orm.Session.params.autoflush
    "sqlalchemy.orm.Session") parameter.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit "sqlalchemy.orm.Session.commit")
    操作在发出相关数据库连接的 COMMIT 前无条件发出 [`Session.flush()`](session_api.html#sqlalchemy.orm.Session.flush
    "sqlalchemy.orm.Session.flush")。如果未检测到挂起的更改，则不会向数据库发出 SQL。此行为不可配置，并且不受 [`Session.autoflush`](session_api.html#sqlalchemy.orm.Session.params.autoflush
    "sqlalchemy.orm.Session") 参数的影响。'
- en: Subsequent to that, assuming the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is bound to an [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine"), [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") will then COMMIT the actual database transaction
    that is in place, if one was started. After the commit, the [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") object associated with that transaction is closed,
    causing its underlying DBAPI connection to be [released](../glossary.html#term-released)
    back to the connection pool associated with the [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") to which the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is bound.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，假设[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")绑定到一个[`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine")，那么[`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit")将会提交实际的数据库事务，如果有的话。提交之后，与该事务相关联的[`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")对象将被关闭，导致其底层的DBAPI连接被释放回与[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")绑定的[`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine")相关联的连接池中。
- en: For a [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    that’s bound to multiple engines (e.g. as described at [Partitioning Strategies](persistence_techniques.html#session-partitioning)),
    the same COMMIT steps will proceed for each [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") / [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") that is in play within the “logical” transaction
    being committed. These database transactions are uncoordinated with each other
    unless [two-phase features](session_transaction.html#session-twophase) are enabled.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 对于绑定到多个引擎的[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")（例如在[分区策略](persistence_techniques.html#session-partitioning)中描述的），对于每个正在进行“逻辑”提交的[`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") / [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")，相同的提交步骤将继续进行。这些数据库事务在未启用[两阶段特性](session_transaction.html#session-twophase)的情况下是不协调的。
- en: Other connection-interaction patterns are available as well, by binding the
    [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    to a [`Connection`](../core/connections.html#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    directly; in this case, it’s assumed that an externally-managed transaction is
    present, and a real COMMIT will not be emitted automatically in this case; see
    the section [Joining a Session into an External Transaction (such as for test
    suites)](session_transaction.html#session-external-transaction) for background
    on this pattern.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他的连接交互模式可用，通过直接将[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")绑定到一个[`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")；在这种情况下，假定存在一个外部管理的事务，并且在这种情况下不会自动发出真正的COMMIT；请参阅[将会话加入外部事务（例如用于测试套件）](session_transaction.html#session-external-transaction)部分了解此模式的背景。
- en: Finally, all objects within the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") are [expired](../glossary.html#term-expired) as the
    transaction is closed out. This is so that when the instances are next accessed,
    either through attribute access or by them being present in the result of a SELECT,
    they receive the most recent state. This behavior may be controlled by the [`Session.expire_on_commit`](session_api.html#sqlalchemy.orm.Session.params.expire_on_commit
    "sqlalchemy.orm.Session") flag, which may be set to `False` when this behavior
    is undesirable.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在关闭事务时，[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")中的所有对象都将被[过期](../glossary.html#term-expired)。这样，当实例下次被访问时，无论是通过属性访问还是通过它们出现在SELECT的结果中，它们都会接收到最新的状态。此行为可以通过[`Session.expire_on_commit`](session_api.html#sqlalchemy.orm.Session.params.expire_on_commit
    "sqlalchemy.orm.Session")标志来控制，当此行为不希望时，可以将其设置为`False`。
- en: See also
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[Auto Begin](#session-autobegin)  ### Rolling Back'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '[自动开始](#session-autobegin)  ### 回滚'
- en: '[`Session.rollback()`](session_api.html#sqlalchemy.orm.Session.rollback "sqlalchemy.orm.Session.rollback")
    rolls back the current transaction, if any. When there is no transaction in place,
    the method passes silently.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session.rollback()`](session_api.html#sqlalchemy.orm.Session.rollback "sqlalchemy.orm.Session.rollback")
    方法用于回滚当前事务（如果有的话）。当没有事务存在时，该方法会悄然通过。'
- en: 'With a default configured session, the post-rollback state of the session,
    subsequent to a transaction having been begun either via [autobegin](#session-autobegin)
    or by calling the [`Session.begin()`](session_api.html#sqlalchemy.orm.Session.begin
    "sqlalchemy.orm.Session.begin") method explicitly, is as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 使用默认配置的会话，在通过[自动开始](#session-autobegin)或显式调用[`Session.begin()`](session_api.html#sqlalchemy.orm.Session.begin
    "sqlalchemy.orm.Session.begin")方法开始事务后，会话的回滚后状态如下：
- en: Database transactions are rolled back. For a [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") bound to a single [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine"), this means ROLLBACK is emitted for at most a single
    [`Connection`](../core/connections.html#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    that’s currently in use. For [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") objects bound to multiple [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") objects, ROLLBACK is emitted for all [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") objects that were checked out.
  id: totrans-124
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库事务被回滚。对于绑定到单个[`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine")的[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")，这意味着对当前正在使用的最多一个[`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")进行 ROLLBACK。对于绑定到多个[`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine")对象的[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")对象，将对所有检出的[`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")对象发出 ROLLBACK。
- en: ''
  id: totrans-125
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-126
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Database connections are [released](../glossary.html#term-released). This follows
    the same connection-related behavior noted in [Committing](#session-committing),
    where [`Connection`](../core/connections.html#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    objects obtained from [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") objects are closed, causing the DBAPI connections
    to be [released](../glossary.html#term-released) to the connection pool within
    the [`Engine`](../core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine").
    New connections are checked out from the [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") if and when a new transaction begins.
  id: totrans-127
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库连接被[释放](../glossary.html#term-released)。这遵循与[提交](#session-committing)中注意到的相同的与连接相关的行为，其中从[`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine")对象获取的[`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")对象被关闭，导致 DBAPI 连接被释放到[`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine")中的连接池。如果开始新的事务，新连接将从[`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine")中检出。
- en: ''
  id: totrans-128
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-129
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: For a [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    that’s bound directly to a [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") as described at [Joining a Session into an External
    Transaction (such as for test suites)](session_transaction.html#session-external-transaction),
    rollback behavior on this [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") would follow the behavior specified by the [`Session.join_transaction_mode`](session_api.html#sqlalchemy.orm.Session.params.join_transaction_mode
    "sqlalchemy.orm.Session") parameter, which could involve rolling back savepoints
    or emitting a real ROLLBACK.
  id: totrans-130
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于直接绑定到[`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")的[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")（如[加入外部事务的会话（例如用于测试套件）](session_transaction.html#session-external-transaction)中描述的），此[`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")上的回滚行为将遵循由[`Session.join_transaction_mode`](session_api.html#sqlalchemy.orm.Session.params.join_transaction_mode
    "sqlalchemy.orm.Session")参数指定的行为，这可能涉及回滚保存点或发出真正的 ROLLBACK。
- en: ''
  id: totrans-131
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-132
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Objects which were initially in the [pending](../glossary.html#term-pending)
    state when they were added to the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.session.Session") within the lifespan of the transaction are expunged,
    corresponding to their INSERT statement being rolled back. The state of their
    attributes remains unchanged.
  id: totrans-133
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在事务生命周期内将初始处于[pending](../glossary.html#term-pending)状态的对象从被添加到[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.session.Session")中的情况下，将被清除，对应于它们的INSERT语句被回滚。它们属性的状态保持不变。
- en: ''
  id: totrans-134
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-135
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Objects which were marked as [deleted](../glossary.html#term-deleted) within
    the lifespan of the transaction are promoted back to the [persistent](../glossary.html#term-persistent)
    state, corresponding to their DELETE statement being rolled back. Note that if
    those objects were first [pending](../glossary.html#term-pending) within the transaction,
    that operation takes precedence instead.
  id: totrans-136
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在事务生命周期内标记为[deleted](../glossary.html#term-deleted)的对象将被提升回[persistent](../glossary.html#term-persistent)状态，对应于它们的DELETE语句被回滚。请注意，如果这些对象在事务中首先是[pending](../glossary.html#term-pending)，那么该操作将优先执行。
- en: ''
  id: totrans-137
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-138
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: All objects not expunged are fully expired - this is regardless of the [`Session.expire_on_commit`](session_api.html#sqlalchemy.orm.Session.params.expire_on_commit
    "sqlalchemy.orm.Session") setting.
  id: totrans-139
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有未被清除的对象都完全过期 - 这与[`Session.expire_on_commit`](session_api.html#sqlalchemy.orm.Session.params.expire_on_commit
    "sqlalchemy.orm.Session")设置无关。
- en: With that state understood, the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") may safely continue usage after a rollback occurs.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在理解了这种状态之后，[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")可以在发生回滚后安全地继续使用。
- en: 'Changed in version 1.4: The [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") object now features deferred “begin” behavior, as described
    in [autobegin](#session-autobegin). If no transaction is begun, methods like [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") and [`Session.rollback()`](session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") have no effect. This behavior would not have
    been observed prior to 1.4 as under non-autocommit mode, a transaction would always
    be implicitly present.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 从版本1.4开始更改：[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")对象现在具有延迟“begin”行为，如[autobegin](#session-autobegin)中所述。如果没有开始事务，则[`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit")和[`Session.rollback()`](session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback")等方法将无效。在1.4之前不会观察到此行为，因为在非自动提交模式下，事务总是隐式存在。
- en: When a [`Session.flush()`](session_api.html#sqlalchemy.orm.Session.flush "sqlalchemy.orm.Session.flush")
    fails, typically for reasons like primary key, foreign key, or “not nullable”
    constraint violations, a ROLLBACK is issued automatically (it’s currently not
    possible for a flush to continue after a partial failure). However, the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") goes into a state known as “inactive” at this point,
    and the calling application must always call the [`Session.rollback()`](session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") method explicitly so that the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") can go back into a usable state (it can also be simply
    closed and discarded). See the FAQ entry at [“This Session’s transaction has been
    rolled back due to a previous exception during flush.” (or similar)](../faq/sessions.html#faq-session-rollback)
    for further discussion.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 当[`Session.flush()`](session_api.html#sqlalchemy.orm.Session.flush "sqlalchemy.orm.Session.flush")失败时，通常是由于主键、外键或“非空”约束违反等原因，会自动发出ROLLBACK（目前不可能在部分失败后继续刷新）。然而，此时[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")进入一种称为“不活动”的状态，调用应用程序必须始终显式调用[`Session.rollback()`](session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback")方法，以便[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")可以恢复到可用状态（也可以简单地关闭和丢弃）。有关进一步讨论，请参阅[“由于刷新期间的先前异常，此会话的事务已被回滚。”（或类似）的常见问题解答](../faq/sessions.html#faq-session-rollback)。
- en: See also
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 参见
- en: '[Auto Begin](#session-autobegin)  ### Closing'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '[自动开始](#session-autobegin)  ### 关闭'
- en: The [`Session.close()`](session_api.html#sqlalchemy.orm.Session.close "sqlalchemy.orm.Session.close")
    method issues a [`Session.expunge_all()`](session_api.html#sqlalchemy.orm.Session.expunge_all
    "sqlalchemy.orm.Session.expunge_all") which removes all ORM-mapped objects from
    the session, and [releases](../glossary.html#term-releases) any transactional/connection
    resources from the [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") object(s) to which it is bound. When connections are
    returned to the connection pool, transactional state is rolled back as well.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session.close()`](session_api.html#sqlalchemy.orm.Session.close "sqlalchemy.orm.Session.close")
    方法会调用 [`Session.expunge_all()`](session_api.html#sqlalchemy.orm.Session.expunge_all
    "sqlalchemy.orm.Session.expunge_all")，从会话中移除所有 ORM 映射的对象，并释放任何与其绑定的 [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") 对象的事务/连接资源。当连接返回到连接池时，事务状态也会回滚。'
- en: By default, when the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    is closed, it is essentially in the original state as when it was first constructed,
    and **may be used again**. In this sense, the [`Session.close()`](session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") method is more like a “reset” back to the clean
    state and not as much like a “database close” method. In this mode of operation
    the method [`Session.reset()`](session_api.html#sqlalchemy.orm.Session.reset "sqlalchemy.orm.Session.reset")
    is an alias to [`Session.close()`](session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") and behaves in the same way.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，当 [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    关闭时，它实际上处于创建时的原始状态，**可以再次使用**。从这个意义上说，[`Session.close()`](session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") 方法更像是一个“重置”到干净状态，而不是像一个“关闭数据库”的方法。在这种操作模式下，方法
    [`Session.reset()`](session_api.html#sqlalchemy.orm.Session.reset "sqlalchemy.orm.Session.reset")
    是 [`Session.close()`](session_api.html#sqlalchemy.orm.Session.close "sqlalchemy.orm.Session.close")
    的别名，并且行为相同。
- en: The default behavior of [`Session.close()`](session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") can be changed by setting the parameter [`Session.close_resets_only`](session_api.html#sqlalchemy.orm.Session.params.close_resets_only
    "sqlalchemy.orm.Session") to `False`, indicating that the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") cannot be reused after the method [`Session.close()`](session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") has been called. In this mode of operation the
    [`Session.reset()`](session_api.html#sqlalchemy.orm.Session.reset "sqlalchemy.orm.Session.reset")
    method will allow multiple “reset” of the session, behaving like [`Session.close()`](session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") when [`Session.close_resets_only`](session_api.html#sqlalchemy.orm.Session.params.close_resets_only
    "sqlalchemy.orm.Session") is set to `True`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将参数 [`Session.close_resets_only`](session_api.html#sqlalchemy.orm.Session.params.close_resets_only
    "sqlalchemy.orm.Session") 设置为 `False`，可以更改 [`Session.close()`](session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") 的默认行为，表示在调用方法 [`Session.close()`](session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") 后不能重新使用 [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")。在这种操作模式下，当 [`Session.close_resets_only`](session_api.html#sqlalchemy.orm.Session.params.close_resets_only
    "sqlalchemy.orm.Session") 设置为 `True` 时，方法 [`Session.reset()`](session_api.html#sqlalchemy.orm.Session.reset
    "sqlalchemy.orm.Session.reset") 将允许会话的多次“重置”，行为类似于当 [`Session.close_resets_only`](session_api.html#sqlalchemy.orm.Session.params.close_resets_only
    "sqlalchemy.orm.Session") 设置为 `True` 时的 [`Session.close()`](session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close")。
- en: New in version 2.0.22.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 版本 2.0.22 中新增。
- en: 'It’s recommended that the scope of a [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") be limited by a call to [`Session.close()`](session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") at the end, especially if the [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") or [`Session.rollback()`](session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") methods are not used. The [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") may be used as a context manager to ensure that [`Session.close()`](session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") is called:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 建议通过在结尾处调用 [`Session.close()`](session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") 来限制 [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 的范围，特别是如果没有使用 [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") 或 [`Session.rollback()`](session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") 方法。[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 可以作为上下文管理器使用，以确保调用 [`Session.close()`](session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close")：
- en: '[PRE19]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Changed in version 1.4: The [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") object features deferred “begin” behavior, as described
    in [autobegin](#session-autobegin). no longer immediately begins a new transaction
    after the [`Session.close()`](session_api.html#sqlalchemy.orm.Session.close "sqlalchemy.orm.Session.close")
    method is called.  ## Session Frequently Asked Questions'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在版本 1.4 中做了更改：[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    对象具有延迟“开始”行为，如 [autobegin](#session-autobegin) 中所述。在调用 [`Session.close()`](session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") 方法后不再立即开始新的事务。
- en: By this point, many users already have questions about sessions. This section
    presents a mini-FAQ (note that we have also a [real FAQ](../faq/index.html)) of
    the most basic issues one is presented with when using a [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session").
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，许多用户已经对会话有了问题。本节介绍了使用 [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 时所面临的最基本问题的迷你 FAQ（请注意，我们还有一个 [真正的 FAQ](../faq/index.html)）。
- en: When do I make a [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker")?
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 何时创建 [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker "sqlalchemy.orm.sessionmaker")？
- en: Just one time, somewhere in your application’s global scope. It should be looked
    upon as part of your application’s configuration. If your application has three
    .py files in a package, you could, for example, place the [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker") line in your `__init__.py` file; from that point
    on your other modules say “from mypackage import Session”. That way, everyone
    else just uses [`Session()`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session"),
    and the configuration of that session is controlled by that central point.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 只需一次，在应用程序的全局范围的某个地方。它应被视为应用程序配置的一部分。如果您的应用程序在一个包中有三个 .py 文件，您可以将 [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker") 行放在 `__init__.py` 文件中；从那时起，您的其他模块会说“from mypackage
    import Session”。这样，其他所有人只需使用 [`Session()`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")，并且该会话的配置由该中心点控制。
- en: If your application starts up, does imports, but does not know what database
    it’s going to be connecting to, you can bind the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") at the “class” level to the engine later on, using [`sessionmaker.configure()`](session_api.html#sqlalchemy.orm.sessionmaker.configure
    "sqlalchemy.orm.sessionmaker.configure").
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的应用程序启动，进行导入操作，但不知道将要连接到哪个数据库，您可以稍后在“类”级别将 [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 绑定到引擎，使用 [`sessionmaker.configure()`](session_api.html#sqlalchemy.orm.sessionmaker.configure
    "sqlalchemy.orm.sessionmaker.configure")。
- en: In the examples in this section, we will frequently show the [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker") being created right above the line where we actually
    invoke [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session").
    But that’s just for example’s sake! In reality, the [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker") would be somewhere at the module level. The calls
    to instantiate [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    would then be placed at the point in the application where database conversations
    begin.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中的示例中，我们经常会在实际调用 [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    的行的正上方显示 [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker "sqlalchemy.orm.sessionmaker")
    被创建。但那只是为了举例说明！实际上，[`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker") 会在模块级别的某个地方。对 [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 进行实例化的调用将放置在应用程序中开始数据库会话的地方。
- en: '### When do I construct a [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), when do I commit it, and when do I close it?'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '### 我什么时候构建一个 [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")，什么时候提交它，什么时候关闭它？'
- en: A [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    is typically constructed at the beginning of a logical operation where database
    access is potentially anticipated.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    通常在可能预期到数据库访问的逻辑操作开始时构建。
- en: The [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session"),
    whenever it is used to talk to the database, begins a database transaction as
    soon as it starts communicating. This transaction remains in progress until the
    [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    is rolled back, committed, or closed. The [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") will begin a new transaction if it is used again, subsequent
    to the previous transaction ending; from this it follows that the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is capable of having a lifespan across many transactions,
    though only one at a time. We refer to these two concepts as **transaction scope**
    and **session scope**.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 每当 [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    用于与数据库通信时，它会在开始通信时立即启动数据库事务。此事务将持续进行，直到 [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 被回滚、提交或关闭。如果再次使用 [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")，则会开始新的事务，接着之前的事务结束；由此可知，[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 可以跨多个事务具有生命周期，但一次只能进行一个。我们将这两个概念称为 **事务范围** 和 **会话范围**。
- en: It’s usually not very hard to determine the best points at which to begin and
    end the scope of a [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session"),
    though the wide variety of application architectures possible can introduce challenging
    situations.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 通常很容易确定何时开始和结束 [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    的范围，尽管可能存在多种应用程序架构，可能会引入具有挑战性的情况。
- en: 'Some sample scenarios include:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 一些示例场景包括：
- en: Web applications. In this case, it’s best to make use of the SQLAlchemy integrations
    provided by the web framework in use. Or otherwise, the basic pattern is create
    a [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    at the start of a web request, call the [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") method at the end of web requests that do POST,
    PUT, or DELETE, and then close the session at the end of web request. It’s also
    usually a good idea to set [`Session.expire_on_commit`](session_api.html#sqlalchemy.orm.Session.params.expire_on_commit
    "sqlalchemy.orm.Session") to False so that subsequent access to objects that came
    from a [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    within the view layer do not need to emit new SQL queries to refresh the objects,
    if the transaction has been committed already.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web 应用程序。在这种情况下，最好利用所使用的 Web 框架提供的 SQLAlchemy 集成。或者，基本模式是在 Web 请求开始时创建一个[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")，在执行 POST、PUT 或 DELETE 的 Web 请求结束时调用 [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") 方法，然后在 Web 请求结束时关闭会话。通常还应该设置 [`Session.expire_on_commit`](session_api.html#sqlalchemy.orm.Session.params.expire_on_commit
    "sqlalchemy.orm.Session") 为 False，以便来自视图层的对象在事务已经提交后不需要发出新的 SQL 查询来刷新对象。
- en: A background daemon which spawns off child forks would want to create a [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") local to each child process, work with that [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") through the life of the “job” that the fork is handling,
    then tear it down when the job is completed.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个后台守护进程会生成子进程，可能会想要为每个子进程创建一个[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")，在该子进程处理的“作业”生命周期内使用该[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")，然后在作业完成时将其销毁。
- en: For a command-line script, the application would create a single, global [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") that is established when the program begins to do its
    work, and commits it right as the program is completing its task.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于命令行脚本，应用程序会创建一个在程序开始工作时建立的单一全局 [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")，并在程序完成任务时立即提交它。
- en: For a GUI interface-driven application, the scope of the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") may best be within the scope of a user-generated event,
    such as a button push. Or, the scope may correspond to explicit user interaction,
    such as the user “opening” a series of records, then “saving” them.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于基于 GUI 接口的应用程序，[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    的范围可能最好在用户生成的事件范围内，比如按钮点击。或者，范围可能与明确的用户交互相对应，比如用户“打开”一系列记录，然后“保存”它们。
- en: As a general rule, the application should manage the lifecycle of the session
    *externally* to functions that deal with specific data. This is a fundamental
    separation of concerns which keeps data-specific operations agnostic of the context
    in which they access and manipulate that data.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，应用程序应该在处理特定数据的函数**外部**管理会话的生命周期。这是一种基本的关注点分离，使得特定于数据的操作不受其访问和操作数据的上下文的影响。
- en: 'E.g. **don’t do this**:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，**不要这样做**：
- en: '[PRE20]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Keep the lifecycle of the session (and usually the transaction) **separate
    and external**. The example below illustrates how this might look, and additionally
    makes use of a Python context manager (i.e. the `with:` keyword) in order to manage
    the scope of the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    and its transaction automatically:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 将会话（通常也是事务）的生命周期**分离和外部化**。下面的示例说明了这样做的方式，并且另外使用了 Python 上下文管理器（即 `with:` 关键字）来自动管理
    [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    及其事务的范围：
- en: '[PRE21]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Changed in version 1.4: The [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") may be used as a context manager without the use of
    external helper functions.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 自 1.4 版更改：[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    可以作为上下文管理器使用，无需使用外部辅助函数。
- en: Is the Session a cache?
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 会话是缓存吗？
- en: Yeee…no. It’s somewhat used as a cache, in that it implements the [identity
    map](../glossary.html#term-identity-map) pattern, and stores objects keyed to
    their primary key. However, it doesn’t do any kind of query caching. This means,
    if you say `session.scalars(select(Foo).filter_by(name='bar'))`, even if `Foo(name='bar')`
    is right there, in the identity map, the session has no idea about that. It has
    to issue SQL to the database, get the rows back, and then when it sees the primary
    key in the row, *then* it can look in the local identity map and see that the
    object is already there. It’s only when you say `query.get({some primary key})`
    that the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.session.Session")
    doesn’t have to issue a query.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯……不是。它有点像缓存，因为它实现了[identity map](../glossary.html#term-identity-map)模式，并将对象存储为主键键控制的对象。但是，它不执行任何类型的查询缓存。这意味着，如果你说`session.scalars(select(Foo).filter_by(name='bar'))`，即使`Foo(name='bar')`就在那里，在identity
    map中，会话也不知道。它必须向数据库发出SQL，获取行，然后当它看到行中的主键时，*然后*它才能查看本地identity map，并查看对象是否已存在。只有当你说`query.get({some
    primary key})`时，[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.session.Session")才不需要发出查询。
- en: Additionally, the Session stores object instances using a weak reference by
    default. This also defeats the purpose of using the Session as a cache.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，默认情况下，会话(Session)使用弱引用来存储对象实例。这也违背了使用会话作为缓存的初衷。
- en: The [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    is not designed to be a global object from which everyone consults as a “registry”
    of objects. That’s more the job of a **second level cache**. SQLAlchemy provides
    a pattern for implementing second level caching using [dogpile.cache](https://dogpilecache.readthedocs.io/),
    via the [Dogpile Caching](examples.html#examples-caching) example.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")不是设计为所有人都可以向其查询作为“注册表”的全局对象。这更像是**第二级缓存**的工作。SQLAlchemy提供了使用[dogpile.cache](https://dogpilecache.readthedocs.io/)实现第二级缓存的模式，通过[Dogpile
    Caching](examples.html#examples-caching)示例。'
- en: How can I get the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.session.Session")
    for a certain object?
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何获取某个对象的[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.session.Session")？
- en: 'Use the [`Session.object_session()`](session_api.html#sqlalchemy.orm.Session.object_session
    "sqlalchemy.orm.Session.object_session") classmethod available on [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.session.Session"):'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[`Session.object_session()`](session_api.html#sqlalchemy.orm.Session.object_session
    "sqlalchemy.orm.Session.object_session")类方法，该方法可用于[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.session.Session")：
- en: '[PRE22]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The newer [Runtime Inspection API](../core/inspection.html) system can also
    be used:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 较新的[运行时检查 API](../core/inspection.html)系统也可以使用：
- en: '[PRE23]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '### Is the Session thread-safe? Is AsyncSession safe to share in concurrent
    tasks?'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '### 会话(Session)是线程安全的吗？AsyncSession在并发任务中安全吗？'
- en: The [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    is a **mutable, stateful** object that represents a **single database transaction**.
    An instance of [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    therefore **cannot be shared among concurrent threads or asyncio tasks without
    careful synchronization**. The [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is intended to be used in a **non-concurrent** fashion,
    that is, a particular instance of [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") should be used in only one thread or task at a time.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")是一个**可变的、有状态的**对象，表示一个**单一的数据库事务**。因此，[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")的实例**不能在并发线程或asyncio任务之间共享，除非进行仔细的同步**。[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")旨在以**非并发**方式使用，即，特定的[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")实例应在同一时间只在一个线程或任务中使用。'
- en: When using the [`AsyncSession`](extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession
    "sqlalchemy.ext.asyncio.AsyncSession") object from SQLAlchemy’s [asyncio](extensions/asyncio.html)
    extension, this object is only a thin proxy on top of a [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), and the same rules apply; it is an **unsynchronized,
    mutable, stateful object**, so it is **not** safe to use a single instance of
    [`AsyncSession`](extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession "sqlalchemy.ext.asyncio.AsyncSession")
    in multiple asyncio tasks at once.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用SQLAlchemy的[asyncio](extensions/asyncio.html)扩展中的[`AsyncSession`](extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession
    "sqlalchemy.ext.asyncio.AsyncSession")对象时，该对象只是[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")的一个薄代理，同样的规则适用；它是一个**未同步的、可变的、有状态的对象**，因此**不安全**在多个asyncio任务中同时使用单个[`AsyncSession`](extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession
    "sqlalchemy.ext.asyncio.AsyncSession")实例。
- en: An instance of [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    or [`AsyncSession`](extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession
    "sqlalchemy.ext.asyncio.AsyncSession") represents a single logical database transaction,
    referencing only a single [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") at a time for a particular [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") or [`AsyncEngine`](extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncEngine
    "sqlalchemy.ext.asyncio.AsyncEngine") to which the object is bound (note that
    these objects both support being bound to multiple engines at once, however in
    this case there will still be only one connection per engine in play within the
    scope of a transaction).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")或[`AsyncSession`](extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession
    "sqlalchemy.ext.asyncio.AsyncSession")的一个实例代表一个单一的逻辑数据库事务，每次只引用一个特定[`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine")或[`AsyncEngine`](extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncEngine
    "sqlalchemy.ext.asyncio.AsyncEngine")的单个[`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")（请注意，这些对象都支持同时绑定到多个引擎，但在这种情况下，在事务范围内仍然只有一个连接）。'
- en: A database connection within a transaction is also a stateful object that is
    intended to be operated upon in a non-concurrent, sequential fashion. Commands
    are issued on the connection in a sequence, which are handled by the database
    server in the exact order in which they are emitted. As the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") emits commands upon this connection and receives results,
    the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    itself is transitioning through internal state changes that align with the state
    of commands and data present on this connection; states which include if a transaction
    were begun, committed, or rolled back, what SAVEPOINTs if any are in play, as
    well as fine-grained synchronization of the state of individual database rows
    with local ORM-mapped objects.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 事务中的数据库连接也是一个有状态的对象，应该以非并发、顺序的方式进行操作。命令按照序列在连接上发出，并由数据库服务器按照发出的确切顺序处理。当[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")发出命令并接收结果时，[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")本身正在经历与此连接上的命令和数据状态相一致的内部状态更改；这些状态包括事务是否已启动、提交或回滚，正在使用的SAVEPOINT（如果有），以及将数据库行的状态与本地ORM映射的对象同步的细粒度同步。
- en: When designing database applications for concurrency, the appropriate model
    is that each concurrent task / thread works with its own database transaction.
    This is why when discussing the issue of database concurrency, the standard terminology
    used is **multiple, concurrent transactions**. Within traditional RDMS there is
    no analogue for a single database transaction that is receiving and processing
    multiple commands concurrently.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在为并发设计数据库应用程序时，适当的模型是每个并发任务/线程都使用自己的数据库事务。这就是为什么在讨论数据库并发问题时，使用的标准术语是**多个并发事务**。在传统的关系型数据库管理系统中，没有类似于同时接收和处理多个命令的单个数据库事务的模拟。
- en: The concurrency model for SQLAlchemy’s [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") and [`AsyncSession`](extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession
    "sqlalchemy.ext.asyncio.AsyncSession") is therefore **Session per thread, AsyncSession
    per task**. An application that uses multiple threads, or multiple tasks in asyncio
    such as when using an API like `asyncio.gather()` would want to ensure that each
    thread has its own [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session"),
    each asyncio task has its own [`AsyncSession`](extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession
    "sqlalchemy.ext.asyncio.AsyncSession").
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，SQLAlchemy的[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")和[`AsyncSession`](extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession
    "sqlalchemy.ext.asyncio.AsyncSession")的并发模型是**每个线程一个Session，每个任务一个AsyncSession**。一个使用多个线程或多个asyncio任务的应用（例如使用像`asyncio.gather()`这样的API）将希望确保每个线程有其自己的[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")，每个asyncio任务有其自己的[`AsyncSession`](extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession
    "sqlalchemy.ext.asyncio.AsyncSession")。
- en: The best way to ensure this use is by using the [standard context manager pattern](#session-getting)
    locally within the top level Python function that is inside the thread or task,
    which will ensure the lifespan of the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") or [`AsyncSession`](extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession
    "sqlalchemy.ext.asyncio.AsyncSession") is maintained within a local scope.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 确保此使用的最佳方法是在线程或任务内部的顶级Python函数中本地使用[标准上下文管理器模式](#session-getting)，这将确保[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")或[`AsyncSession`](extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession
    "sqlalchemy.ext.asyncio.AsyncSession")的生命周期在局部范围内维护。
- en: For applications that benefit from having a “global” [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") where it’s not an option to pass the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") object to specific functions and methods which require
    it, the [`scoped_session`](contextual.html#sqlalchemy.orm.scoped_session "sqlalchemy.orm.scoped_session")
    approach can provide for a “thread local” [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") object; see the section [Contextual/Thread-local Sessions](contextual.html#unitofwork-contextual)
    for background. Within the asyncio context, the [`async_scoped_session`](extensions/asyncio.html#sqlalchemy.ext.asyncio.async_scoped_session
    "sqlalchemy.ext.asyncio.async_scoped_session") object is the asyncio analogue
    for [`scoped_session`](contextual.html#sqlalchemy.orm.scoped_session "sqlalchemy.orm.scoped_session"),
    however is more challenging to configure as it requires a custom “context” function.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些受益于具有“全局”[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")的应用，其中无法将[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")对象传递给需要它的特定函数和方法的情况，[`scoped_session`](contextual.html#sqlalchemy.orm.scoped_session
    "sqlalchemy.orm.scoped_session")方法可以提供一个“线程本地”的[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")对象；请参阅[上下文/线程本地会话](contextual.html#unitofwork-contextual)一节了解背景。在asyncio环境中，[`async_scoped_session`](extensions/asyncio.html#sqlalchemy.ext.asyncio.async_scoped_session
    "sqlalchemy.ext.asyncio.async_scoped_session")对象是[`scoped_session`](contextual.html#sqlalchemy.orm.scoped_session
    "sqlalchemy.orm.scoped_session")的asyncio模拟，但是更难配置，因为它需要一个自定义的“上下文”函数。
- en: What does the Session do ?
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Session做什么？
- en: In the most general sense, the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") establishes all conversations with the database and
    represents a “holding zone” for all the objects which you’ve loaded or associated
    with it during its lifespan. It provides the interface where SELECT and other
    queries are made that will return and modify ORM-mapped objects. The ORM objects
    themselves are maintained inside the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), inside a structure called the [identity map](../glossary.html#term-identity-map)
    - a data structure that maintains unique copies of each object, where “unique”
    means “only one object with a particular primary key”.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在最一般的意义上，[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")建立了与数据库的所有交流，并代表了在其生命周期内加载或关联的所有对象的“持有区”。它提供了SELECT和其他查询的接口，这些查询将返回和修改ORM映射的对象。ORM对象本身被维护在[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")内部，存储在一个称为[identity map](../glossary.html#term-identity-map)的结构中
    - 这是一种维护每个对象唯一副本的数据结构，其中“唯一”意味着“只有一个具有特定主键的对象”。
- en: The [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    in its most common pattern of use begins in a mostly stateless form. Once queries
    are issued or other objects are persisted with it, it requests a connection resource
    from an [`Engine`](../core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    that is associated with the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), and then establishes a transaction on that connection.
    This transaction remains in effect until the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is instructed to commit or roll back the transaction.
    When the transaction ends, the connection resource associated with the [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") is [released](../glossary.html#term-released) to the
    connection pool managed by the engine. A new transaction then starts with a new
    connection checkout.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    在最常见的使用模式下，以大部分无状态的形式开始。一旦发出查询或使用其他对象进行持久化，它会从与 [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 关联的 [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") 请求连接资源，然后在该连接上建立事务。这个事务会一直保持到 [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 被指示提交或回滚事务。事务结束时，与 [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") 关联的连接资源会被释放到引擎管理的连接池中。然后，一个新的事务会开始，使用一个新的连接。'
- en: The ORM objects maintained by a [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") are [instrumented](../glossary.html#term-instrumented)
    such that whenever an attribute or a collection is modified in the Python program,
    a change event is generated which is recorded by the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"). Whenever the database is about to be queried, or when
    the transaction is about to be committed, the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") first **flushes** all pending changes stored in memory
    to the database. This is known as the [unit of work](../glossary.html#term-unit-of-work)
    pattern.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 由 [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    维护的 ORM 对象被[装饰](../glossary.html#term-instrumented)，这样每当 Python 程序中的属性或集合被修改时，就会生成一个变更事件，由
    [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    记录下来。每当即将查询数据库或即将提交事务时，[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    首先会将内存中的所有待定更改**刷新**到数据库中。这被称为[工作单元](../glossary.html#term-unit-of-work)模式。
- en: When using a [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session"),
    it’s useful to consider the ORM mapped objects that it maintains as **proxy objects**
    to database rows, which are local to the transaction being held by the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"). In order to maintain the state on the objects as matching
    what’s actually in the database, there are a variety of events that will cause
    objects to re-access the database in order to keep synchronized. It is possible
    to “detach” objects from a [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), and to continue using them, though this practice has
    its caveats. It’s intended that usually, you’d re-associate detached objects with
    another [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    when you want to work with them again, so that they can resume their normal task
    of representing database state.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    时，将其维护的 ORM 映射对象视为**代理对象**以访问数据库行，这些对象局限于由 [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 持有的事务。为了保持对象的状态与实际数据库中的内容一致，有多种事件会导致对象重新访问数据库以保持同步。可以将对象“分离”（detach）出
    [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")，并继续使用它们，尽管这种做法有其注意事项。通常情况下，你应该重新将分离的对象与另一个
    [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    关联，以便在需要时恢复其正常的数据库状态表示任务。
- en: '## Basics of Using a Session'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '## 使用会话的基础知识'
- en: The most basic [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    use patterns are presented here.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这里介绍了最基本的 [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    使用模式。
- en: '### Opening and Closing a Session'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '### 开启和关闭会话'
- en: 'The [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    may be constructed on its own or by using the [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker") class. It typically is passed a single [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") as a source of connectivity up front. A typical use
    may look like:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")可以独立构造，也可以使用[`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker")类构造。通常，它被作为连通性的源传递给单个[`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine")。典型的用法可能如下所示：'
- en: '[PRE24]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Above, the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    is instantiated with an [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") associated with a particular database URL. It is then
    used in a Python context manager (i.e. `with:` statement) so that it is automatically
    closed at the end of the block; this is equivalent to calling the [`Session.close()`](session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") method.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")与特定数据库
    URL 关联的[`Engine`](../core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")一起实例化。然后，它在
    Python 上下文管理器（即`with:`语句）中使用，因此它在块结束时会自动关闭；这相当于调用[`Session.close()`](session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close")方法。
- en: The call to [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") is optional, and is only needed if the work we’ve
    done with the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    includes new data to be persisted to the database. If we were only issuing SELECT
    calls and did not need to write any changes, then the call to [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") would be unnecessary.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 对[`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit "sqlalchemy.orm.Session.commit")的调用是可选的，只有当我们与[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")一起完成的工作包括要持久化到数据库的新数据时才需要。如果我们只发出 SELECT 调用并且不需要写入任何更改，则对[`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit")的调用将是不必要的。
- en: Note
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Note that after [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") is called, either explicitly or when using a
    context manager, all objects associated with the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") are [expired](../glossary.html#term-expired), meaning
    their contents are erased to be re-loaded within the next transaction. If these
    objects are instead [detached](../glossary.html#term-detached), they will be non-functional
    until re-associated with a new [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), unless the [`Session.expire_on_commit`](session_api.html#sqlalchemy.orm.Session.params.expire_on_commit
    "sqlalchemy.orm.Session") parameter is used to disable this behavior. See the
    section [Committing](#session-committing) for more detail.  ### Framing out a
    begin / commit / rollback block'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在调用[`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit "sqlalchemy.orm.Session.commit")之后，无论是明确调用还是使用上下文管理器，与[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")关联的所有对象都将被[过期](../glossary.html#term-expired)，这意味着它们的内容将被擦除以在下一个事务中重新加载。如果这些对象是[分离的](../glossary.html#term-detached)，则在重新关联到新的[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")之前，它们将无法正常工作，除非使用[`Session.expire_on_commit`](session_api.html#sqlalchemy.orm.Session.params.expire_on_commit
    "sqlalchemy.orm.Session")参数来禁用此行为。更多细节请参阅[Committing](#session-committing)部分。
- en: 'We may also enclose the [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") call and the overall “framing” of the transaction
    within a context manager for those cases where we will be committing data to the
    database. By “framing” we mean that if all operations succeed, the [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") method will be called, but if any exceptions
    are raised, the [`Session.rollback()`](session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") method will be called so that the transaction
    is rolled back immediately, before propagating the exception outward. In Python
    this is most fundamentally expressed using a `try: / except: / else:` block such
    as:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '我们还可以将 [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") 调用和事务的整体“框架”封装在一个上下文管理器中，对于那些需要将数据提交到数据库的情况。所谓的“框架”是指如果所有操作都成功，则会调用
    [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit "sqlalchemy.orm.Session.commit")
    方法，但如果引发任何异常，则会立即调用 [`Session.rollback()`](session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") 方法，以便立即回滚事务，然后向外传播异常。在 Python 中，这主要是使用 `try:
    / except: / else:` 块来表达的，例如：'
- en: '[PRE25]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The long-form sequence of operations illustrated above can be achieved more
    succinctly by making use of the [`SessionTransaction`](session_api.html#sqlalchemy.orm.SessionTransaction
    "sqlalchemy.orm.SessionTransaction") object returned by the [`Session.begin()`](session_api.html#sqlalchemy.orm.Session.begin
    "sqlalchemy.orm.Session.begin") method, which provides a context manager interface
    for the same sequence of operations:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 [`Session.begin()`](session_api.html#sqlalchemy.orm.Session.begin "sqlalchemy.orm.Session.begin")
    方法返回的 [`SessionTransaction`](session_api.html#sqlalchemy.orm.SessionTransaction
    "sqlalchemy.orm.SessionTransaction") 对象，可以更简洁地实现上面示例中的长序列操作，该对象为相同序列操作提供了一个上下文管理器接口：
- en: '[PRE26]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'More succinctly, the two contexts may be combined:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 更简洁地说，这两个上下文可以合并：
- en: '[PRE27]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Using a sessionmaker
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 sessionmaker
- en: 'The purpose of [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker") is to provide a factory for [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") objects with a fixed configuration. As it is typical
    that an application will have an [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") object in module scope, the [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker") can provide a factory for [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") objects that are against this engine:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '[`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker "sqlalchemy.orm.sessionmaker")
    的目的是为具有固定配置的 [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    对象提供一个工厂。由于典型的情况是应用程序将在模块范围内拥有一个 [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") 对象，[`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker") 可以为针对此引擎的 [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 对象提供一个工厂：'
- en: '[PRE28]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker "sqlalchemy.orm.sessionmaker")
    is analogous to the [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") as a module-level factory for function-level sessions
    / connections. As such it also has its own [`sessionmaker.begin()`](session_api.html#sqlalchemy.orm.sessionmaker.begin
    "sqlalchemy.orm.sessionmaker.begin") method, analogous to [`Engine.begin()`](../core/connections.html#sqlalchemy.engine.Engine.begin
    "sqlalchemy.engine.Engine.begin"), which returns a [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") object and also maintains a begin/commit/rollback block:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '[`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker "sqlalchemy.orm.sessionmaker")
    类似于 [`Engine`](../core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")，作为一个模块级别的工厂，用于创建函数级别的会话
    / 连接。因此，它也有自己的 [`sessionmaker.begin()`](session_api.html#sqlalchemy.orm.sessionmaker.begin
    "sqlalchemy.orm.sessionmaker.begin") 方法，类似于 [`Engine.begin()`](../core/connections.html#sqlalchemy.engine.Engine.begin
    "sqlalchemy.engine.Engine.begin")，它返回一个 [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 对象，并且也维护一个 begin/commit/rollback 块：'
- en: '[PRE29]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Where above, the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    will both have its transaction committed as well as that the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") will be closed, when the above `with:` block ends.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的情况下，当上述 `with:` 块结束时，[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 的事务将被提交，并且 [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 将被关闭。
- en: When you write your application, the [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker") factory should be scoped the same as the [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") object created by [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine"), which is typically at module-level or global scope.
    As these objects are both factories, they can be used by any number of functions
    and threads simultaneously.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 当您编写应用程序时，[`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker "sqlalchemy.orm.sessionmaker")工厂应该与由[`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine")创建的[`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine")对象作用域相同，通常是在模块级或全局级。由于这些对象都是工厂，因此它们可以被任意数量的函数和线程同时使用。
- en: See also
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker "sqlalchemy.orm.sessionmaker")'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '[`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker "sqlalchemy.orm.sessionmaker")'
- en: '[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")'
- en: '### Querying'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '### 查询'
- en: The primary means of querying is to make use of the [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") construct to create a [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") object, which is then executed to return a
    result using methods such as [`Session.execute()`](session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") and [`Session.scalars()`](session_api.html#sqlalchemy.orm.Session.scalars
    "sqlalchemy.orm.Session.scalars"). Results are then returned in terms of [`Result`](../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") objects, including sub-variants such as [`ScalarResult`](../core/connections.html#sqlalchemy.engine.ScalarResult
    "sqlalchemy.engine.ScalarResult").
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 查询的主要手段是利用[`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select")构造来创建一个[`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select")对象，然后使用诸如[`Session.execute()`](session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute")和[`Session.scalars()`](session_api.html#sqlalchemy.orm.Session.scalars
    "sqlalchemy.orm.Session.scalars")等方法执行该对象以返回结果。结果以[`Result`](../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result")对象的形式返回，包括诸如[`ScalarResult`](../core/connections.html#sqlalchemy.engine.ScalarResult
    "sqlalchemy.engine.ScalarResult")等子变体。
- en: 'A complete guide to SQLAlchemy ORM querying can be found at [ORM Querying Guide](queryguide/index.html).
    Some brief examples follow:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy ORM 查询的完整指南可在[ORM 查询指南](queryguide/index.html)中找到。以下是一些简要示例：
- en: '[PRE30]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Changed in version 2.0: “2.0” style querying is now standard. See [2.0 Migration
    - ORM Usage](../changelog/migration_20.html#migration-20-query-usage) for migration
    notes from the 1.x series.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 从2.0版本开始更改：“2.0”风格查询现在是标准的。请参阅[2.0 迁移 - ORM 使用](../changelog/migration_20.html#migration-20-query-usage)了解从1.x系列迁移的注意事项。
- en: See also
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[ORM Querying Guide](queryguide/index.html)  ### Adding New or Existing Items'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '[ORM 查询指南](queryguide/index.html)  ### 添加新项目或现有项目'
- en: '[`Session.add()`](session_api.html#sqlalchemy.orm.Session.add "sqlalchemy.orm.Session.add")
    is used to place instances in the session. For [transient](../glossary.html#term-transient)
    (i.e. brand new) instances, this will have the effect of an INSERT taking place
    for those instances upon the next flush. For instances which are [persistent](../glossary.html#term-persistent)
    (i.e. were loaded by this session), they are already present and do not need to
    be added. Instances which are [detached](../glossary.html#term-detached) (i.e.
    have been removed from a session) may be re-associated with a session using this
    method:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[`Session.add()`](session_api.html#sqlalchemy.orm.Session.add "sqlalchemy.orm.Session.add")将实例放入会话中。对于[瞬态](../glossary.html#term-transient)(即全新的)实例，这将导致在下一次刷新时对这些实例进行插入操作。对于[持久](../glossary.html#term-persistent)(即由此会话加载的)实例，它们已经存在，不需要添加。可以使用此方法将[分离](../glossary.html#term-detached)(即已从会话中删除的)实例重新关联到会话中：
- en: '[PRE31]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'To add a list of items to the session at once, use [`Session.add_all()`](session_api.html#sqlalchemy.orm.Session.add_all
    "sqlalchemy.orm.Session.add_all"):'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 要一次向会话中添加一系列项目，请使用[`Session.add_all()`](session_api.html#sqlalchemy.orm.Session.add_all
    "sqlalchemy.orm.Session.add_all")：
- en: '[PRE32]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The [`Session.add()`](session_api.html#sqlalchemy.orm.Session.add "sqlalchemy.orm.Session.add")
    operation **cascades** along the `save-update` cascade. For more details see the
    section [Cascades](cascades.html#unitofwork-cascades).  ### Deleting'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session.add()`](session_api.html#sqlalchemy.orm.Session.add "sqlalchemy.orm.Session.add")
    操作**沿着** `save-update` 级联进行。有关详细信息，请参阅[Cascades](cascades.html#unitofwork-cascades)部分。###
    删除'
- en: 'The [`Session.delete()`](session_api.html#sqlalchemy.orm.Session.delete "sqlalchemy.orm.Session.delete")
    method places an instance into the Session’s list of objects to be marked as deleted:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session.delete()`](session_api.html#sqlalchemy.orm.Session.delete "sqlalchemy.orm.Session.delete")
    方法将一个实例放入会话的待删除对象列表中：'
- en: '[PRE33]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[`Session.delete()`](session_api.html#sqlalchemy.orm.Session.delete "sqlalchemy.orm.Session.delete")
    marks an object for deletion, which will result in a DELETE statement emitted
    for each primary key affected. Before the pending deletes are flushed, objects
    marked by “delete” are present in the [`Session.deleted`](session_api.html#sqlalchemy.orm.Session.deleted
    "sqlalchemy.orm.Session.deleted") collection. After the DELETE, they are expunged
    from the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session"),
    which becomes permanent after the transaction is committed.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session.delete()`](session_api.html#sqlalchemy.orm.Session.delete "sqlalchemy.orm.Session.delete")标记一个对象为删除状态，这将导致为每个受影响的主键发出一个
    DELETE 语句。在挂起的删除被刷新之前，由“delete”标记的对象存在于 [`Session.deleted`](session_api.html#sqlalchemy.orm.Session.deleted
    "sqlalchemy.orm.Session.deleted") 集合中。删除之后，它们将从 [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 中删除，在事务提交后，这变得永久。'
- en: 'There are various important behaviors related to the [`Session.delete()`](session_api.html#sqlalchemy.orm.Session.delete
    "sqlalchemy.orm.Session.delete") operation, particularly in how relationships
    to other objects and collections are handled. There’s more information on how
    this works in the section [Cascades](cascades.html#unitofwork-cascades), but in
    general the rules are:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 有关[`Session.delete()`](session_api.html#sqlalchemy.orm.Session.delete "sqlalchemy.orm.Session.delete")
    操作的各种重要行为，特别是关于如何处理与其他对象和集合的关系的行为。有关此工作原理的更多信息，请参阅[Cascades](cascades.html#unitofwork-cascades)部分，但总的来说规则是：
- en: Rows that correspond to mapped objects that are related to a deleted object
    via the [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")
    directive are **not deleted by default**. If those objects have a foreign key
    constraint back to the row being deleted, those columns are set to NULL. This
    will cause a constraint violation if the columns are non-nullable.
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")指令关联到已删除对象的映射对象行默认**不会被删除**。如果这些对象具有指回被删除行的外键约束，这些列将设置为
    NULL。如果列是非空的，这将导致约束违规。
- en: To change the “SET NULL” into a DELETE of a related object’s row, use the [delete](cascades.html#cascade-delete)
    cascade on the [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship").
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要将相关对象行的“SET NULL”更改为删除，请在 [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") 上使用[delete](cascades.html#cascade-delete)级联。
- en: Rows that are in tables linked as “many-to-many” tables, via the [`relationship.secondary`](relationship_api.html#sqlalchemy.orm.relationship.params.secondary
    "sqlalchemy.orm.relationship") parameter, **are** deleted in all cases when the
    object they refer to is deleted.
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当链接为“many-to-many”表的表中的行通过[`relationship.secondary`](relationship_api.html#sqlalchemy.orm.relationship.params.secondary
    "sqlalchemy.orm.relationship")参数链接时，当它们所引用的对象被删除时，**它们**在所有情况下都将被删除。
- en: When related objects include a foreign key constraint back to the object being
    deleted, and the related collections to which they belong are not currently loaded
    into memory, the unit of work will emit a SELECT to fetch all related rows, so
    that their primary key values can be used to emit either UPDATE or DELETE statements
    on those related rows. In this way, the ORM without further instruction will perform
    the function of ON DELETE CASCADE, even if this is configured on Core [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") objects.
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当相关对象包含指回正在删除的对象的外键约束，并且它们所属的相关集合当前未加载到内存中时，工作单元将发出一个 SELECT 来获取所有相关行，以便它们的主键值可以用于发出
    UPDATE 或 DELETE 语句以处理这些相关行。通过这种方式，ORM 即使在 Core [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") 对象上配置了 ON DELETE CASCADE，也会执行这个功能，而不需要进一步的指示。
- en: The [`relationship.passive_deletes`](relationship_api.html#sqlalchemy.orm.relationship.params.passive_deletes
    "sqlalchemy.orm.relationship") parameter can be used to tune this behavior and
    rely upon “ON DELETE CASCADE” more naturally; when set to True, this SELECT operation
    will no longer take place, however rows that are locally present will still be
    subject to explicit SET NULL or DELETE. Setting [`relationship.passive_deletes`](relationship_api.html#sqlalchemy.orm.relationship.params.passive_deletes
    "sqlalchemy.orm.relationship") to the string `"all"` will disable **all** related
    object update/delete.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`relationship.passive_deletes`](relationship_api.html#sqlalchemy.orm.relationship.params.passive_deletes
    "sqlalchemy.orm.relationship")参数可用于调整此行为，并更自然地依赖于“ON DELETE CASCADE”；当设置为True时，此SELECT操作将不再发生，但仍然会对本地存在的行进行显式的SET
    NULL或DELETE。将[`relationship.passive_deletes`](relationship_api.html#sqlalchemy.orm.relationship.params.passive_deletes
    "sqlalchemy.orm.relationship")设置为字符串`"all"`将禁用**所有**相关对象的更新/删除。'
- en: When the DELETE occurs for an object marked for deletion, the object is not
    automatically removed from collections or object references that refer to it.
    When the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    is expired, these collections may be loaded again so that the object is no longer
    present. However, it is preferable that instead of using [`Session.delete()`](session_api.html#sqlalchemy.orm.Session.delete
    "sqlalchemy.orm.Session.delete") for these objects, the object should instead
    be removed from its collection and then [delete-orphan](cascades.html#cascade-delete-orphan)
    should be used so that it is deleted as a secondary effect of that collection
    removal. See the section [Notes on Delete - Deleting Objects Referenced from Collections
    and Scalar Relationships](cascades.html#session-deleting-from-collections) for
    an example of this.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当标记为删除的对象发生删除时，该对象不会自动从引用它的集合或对象引用中移除。当[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")过期时，这些集合可能会再次加载，以便对象不再存在。然而，最好的做法是，不要对这些对象使用[`Session.delete()`](session_api.html#sqlalchemy.orm.Session.delete
    "sqlalchemy.orm.Session.delete")，而是应该从其集合中移除对象，然后使用[delete-orphan](cascades.html#cascade-delete-orphan)以便作为该集合移除的次要效果而被删除。请参阅[Notes
    on Delete - Deleting Objects Referenced from Collections and Scalar Relationships](cascades.html#session-deleting-from-collections)部分以获取示例。
- en: See also
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[delete](cascades.html#cascade-delete) - describes “delete cascade”, which
    marks related objects for deletion when a lead object is deleted.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '[delete](cascades.html#cascade-delete) - 描述了“删除级联”，当主对象被删除时，会标记相关对象以进行删除。'
- en: '[delete-orphan](cascades.html#cascade-delete-orphan) - describes “delete orphan
    cascade”, which marks related objects for deletion when they are de-associated
    from their lead object.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '[delete-orphan](cascades.html#cascade-delete-orphan) - 描述了“删除孤儿级联”，当相关对象与其主对象解除关联时，会标记这些相关对象以进行删除。'
- en: '[Notes on Delete - Deleting Objects Referenced from Collections and Scalar
    Relationships](cascades.html#session-deleting-from-collections) - important background
    on [`Session.delete()`](session_api.html#sqlalchemy.orm.Session.delete "sqlalchemy.orm.Session.delete")
    as involves relationships being refreshed in memory.  ### Flushing'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '[Notes on Delete - Deleting Objects Referenced from Collections and Scalar
    Relationships](cascades.html#session-deleting-from-collections) - 关于[`Session.delete()`](session_api.html#sqlalchemy.orm.Session.delete
    "sqlalchemy.orm.Session.delete")的重要背景，涉及在内存中刷新关系。### 刷新'
- en: When the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.session.Session")
    is used with its default configuration, the flush step is nearly always done transparently.
    Specifically, the flush occurs before any individual SQL statement is issued as
    a result of a [`Query`](queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    or a [2.0-style](../glossary.html#term-1) [`Session.execute()`](session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") call, as well as within the [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") call before the transaction is committed. It
    also occurs before a SAVEPOINT is issued when [`Session.begin_nested()`](session_api.html#sqlalchemy.orm.Session.begin_nested
    "sqlalchemy.orm.Session.begin_nested") is used.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 当 [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.session.Session")
    使用其默认配置时，刷新步骤几乎总是透明进行的。具体来说，在由 [`Query`](queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") 或 [2.0 风格](../glossary.html#term-1) 的 [`Session.execute()`](session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") 调用导致发出任何单个 SQL 语句之前，以及在 [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") 调用中在提交事务之前，都会发生刷新。当使用 [`Session.begin_nested()`](session_api.html#sqlalchemy.orm.Session.begin_nested
    "sqlalchemy.orm.Session.begin_nested") 时，还会在发出 SAVEPOINT 之前发生刷新。
- en: 'A [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    flush can be forced at any time by calling the [`Session.flush()`](session_api.html#sqlalchemy.orm.Session.flush
    "sqlalchemy.orm.Session.flush") method:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 可以随时通过调用 [`Session.flush()`](session_api.html#sqlalchemy.orm.Session.flush "sqlalchemy.orm.Session.flush")
    方法来强制执行 [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    的刷新：
- en: '[PRE34]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The flush which occurs automatically within the scope of certain methods is
    known as **autoflush**. Autoflush is defined as a configurable, automatic flush
    call which occurs at the beginning of methods including:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些方法的范围内自动发生的刷新称为**自动刷新**。自动刷新定义为在包括以下方法的开头发生的可配置的自动刷新调用：
- en: '[`Session.execute()`](session_api.html#sqlalchemy.orm.Session.execute "sqlalchemy.orm.Session.execute")
    and other SQL-executing methods, when used against ORM-enabled SQL constructs,
    such as [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") objects that refer to ORM entities and/or
    ORM-mapped attributes'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`Session.execute()`](session_api.html#sqlalchemy.orm.Session.execute "sqlalchemy.orm.Session.execute")
    和其他执行 SQL 的方法，在针对启用了 ORM 的 SQL 构造时使用，比如指向 ORM 实体和/或 ORM 映射属性的 [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") 对象'
- en: When a [`Query`](queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    is invoked to send SQL to the database
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当调用 [`Query`](queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    发送 SQL 到数据库时
- en: Within the [`Session.merge()`](session_api.html#sqlalchemy.orm.Session.merge
    "sqlalchemy.orm.Session.merge") method before querying the database
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在查询数据库之前 [`Session.merge()`](session_api.html#sqlalchemy.orm.Session.merge "sqlalchemy.orm.Session.merge")
    方法中
- en: When objects are [refreshed](#session-expiring)
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当对象被[刷新](#session-expiring)
- en: When ORM [lazy load](../glossary.html#term-lazy-load) operations occur against
    unloaded object attributes.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当针对未加载的对象属性执行 ORM [延迟加载](../glossary.html#term-lazy-load) 操作时。
- en: 'There are also points at which flushes occur **unconditionally**; these points
    are within key transactional boundaries which include:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些无条件发生刷新的点；这些点位于关键事务边界内，包括：
- en: Within the process of the [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") method
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit "sqlalchemy.orm.Session.commit")
    方法的过程中
- en: When [`Session.begin_nested()`](session_api.html#sqlalchemy.orm.Session.begin_nested
    "sqlalchemy.orm.Session.begin_nested") is called
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用 [`Session.begin_nested()`](session_api.html#sqlalchemy.orm.Session.begin_nested
    "sqlalchemy.orm.Session.begin_nested") 时
- en: When the [`Session.prepare()`](session_api.html#sqlalchemy.orm.Session.prepare
    "sqlalchemy.orm.Session.prepare") 2PC method is used.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用 [`Session.prepare()`](session_api.html#sqlalchemy.orm.Session.prepare "sqlalchemy.orm.Session.prepare")
    2PC 方法时。
- en: 'The **autoflush** behavior, as applied to the previous list of items, can be
    disabled by constructing a [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") or [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker") passing the [`Session.autoflush`](session_api.html#sqlalchemy.orm.Session.params.autoflush
    "sqlalchemy.orm.Session") parameter as `False`:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 对于上述项目列表所应用的**自动刷新**行为，可以通过构建一个传递了[`Session.autoflush`](session_api.html#sqlalchemy.orm.Session.params.autoflush
    "sqlalchemy.orm.Session")参数为`False`的[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")或[`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker")来禁用它：
- en: '[PRE35]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Additionally, autoflush can be temporarily disabled within the flow of using
    a [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    using the [`Session.no_autoflush`](session_api.html#sqlalchemy.orm.Session.no_autoflush
    "sqlalchemy.orm.Session.no_autoflush") context manager:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，可以在使用[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")时使用[`Session.no_autoflush`](session_api.html#sqlalchemy.orm.Session.no_autoflush
    "sqlalchemy.orm.Session.no_autoflush")上下文管理器临时禁用自动刷新：
- en: '[PRE36]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '**To reiterate:** The flush process **always occurs** when transactional methods
    such as [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit "sqlalchemy.orm.Session.commit")
    and [`Session.begin_nested()`](session_api.html#sqlalchemy.orm.Session.begin_nested
    "sqlalchemy.orm.Session.begin_nested") are called, regardless of any “autoflush”
    settings, when the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    has remaining pending changes to process.'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '**重申一下：** 当调用事务方法（如[`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit")和[`Session.begin_nested()`](session_api.html#sqlalchemy.orm.Session.begin_nested
    "sqlalchemy.orm.Session.begin_nested")）时，刷新过程**总是发生**，无论任何“自动刷新”设置如何，当[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")仍有待处理的更改时。'
- en: As the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    only invokes SQL to the database within the context of a [DBAPI](../glossary.html#term-DBAPI)
    transaction, all “flush” operations themselves only occur within a database transaction
    (subject to the [isolation level](session_transaction.html#session-transaction-isolation)
    of the database transaction), provided that the DBAPI is not in [driver level
    autocommit](../core/connections.html#dbapi-autocommit) mode. This means that assuming
    the database connection is providing for [atomicity](../glossary.html#term-atomicity)
    within its transactional settings, if any individual DML statement inside the
    flush fails, the entire operation will be rolled back.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 由于[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")只在[DBAPI](../glossary.html#term-DBAPI)事务的上下文中调用SQL到数据库，所有“flush”操作本身只发生在数据库事务内（受数据库事务的[隔离级别](session_transaction.html#session-transaction-isolation)的影响），前提是DBAPI不处于[驱动级别自动提交](../core/connections.html#dbapi-autocommit)模式。这意味着假设数据库连接在其事务设置中提供了[原子性](../glossary.html#term-atomicity)，如果刷新内部的任何个别DML语句失败，整个操作将被回滚。
- en: When a failure occurs within a flush, in order to continue using that same [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), an explicit call to [`Session.rollback()`](session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") is required after a flush fails, even though
    the underlying transaction will have been rolled back already (even if the database
    driver is technically in driver-level autocommit mode). This is so that the overall
    nesting pattern of so-called “subtransactions” is consistently maintained. The
    FAQ section [“This Session’s transaction has been rolled back due to a previous
    exception during flush.” (or similar)](../faq/sessions.html#faq-session-rollback)
    contains a more detailed description of this behavior.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 当刷新过程中发生故障时，为了继续使用相同的[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")，在刷新失败后需要显式调用[`Session.rollback()`](session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback")，即使底层事务已经回滚了（即使数据库驱动程序在技术上处于驱动程序级别的自动提交模式）。这样做是为了始终保持所谓“子事务”的整体嵌套模式。
    FAQ部分[“由于刷新期间的先前异常，此会话的事务已回滚。”（或类似）](../faq/sessions.html#faq-session-rollback)中包含了对此行为的更详细描述。
- en: See also
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[“This Session’s transaction has been rolled back due to a previous exception
    during flush.” (or similar)](../faq/sessions.html#faq-session-rollback) - further
    background on why [`Session.rollback()`](session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") must be called when a flush fails.  ### Get
    by Primary Key'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '[“由于刷新期间发生的先前异常，此会话的事务已回滚。”（或类似）](../faq/sessions.html#faq-session-rollback)
    - 关于在刷新失败时必须调用[`Session.rollback()`](session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback")的更多背景信息。 ### 按主键获取'
- en: 'As the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    makes use of an [identity map](../glossary.html#term-identity-map) which refers
    to current in-memory objects by primary key, the [`Session.get()`](session_api.html#sqlalchemy.orm.Session.get
    "sqlalchemy.orm.Session.get") method is provided as a means of locating objects
    by primary key, first looking within the current identity map and then querying
    the database for non present values. Such as, to locate a `User` entity with primary
    key identity `(5, )`:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 由于[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")利用了一个[标识映射](../glossary.html#term-identity-map)，该映射通过主键引用当前内存中的对象，因此[`Session.get()`](session_api.html#sqlalchemy.orm.Session.get
    "sqlalchemy.orm.Session.get")方法被提供用于通过主键定位对象，首先在当前标识映射内查找，然后在数据库中查询不存在的值。例如，要定位主键标识为`(5,
    )`的`User`实体：
- en: '[PRE37]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The [`Session.get()`](session_api.html#sqlalchemy.orm.Session.get "sqlalchemy.orm.Session.get")
    also includes calling forms for composite primary key values, which may be passed
    as tuples or dictionaries, as well as additional parameters which allow for specific
    loader and execution options. See [`Session.get()`](session_api.html#sqlalchemy.orm.Session.get
    "sqlalchemy.orm.Session.get") for the complete parameter list.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session.get()`](session_api.html#sqlalchemy.orm.Session.get "sqlalchemy.orm.Session.get")
    还包括对复合主键值的调用形式，可以作为元组或字典传递，以及允许特定加载程序和执行选项的其他参数。请参阅[`Session.get()`](session_api.html#sqlalchemy.orm.Session.get
    "sqlalchemy.orm.Session.get")获取完整的参数列表。'
- en: See also
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`Session.get()`](session_api.html#sqlalchemy.orm.Session.get "sqlalchemy.orm.Session.get")  ###
    Expiring / Refreshing'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session.get()`](session_api.html#sqlalchemy.orm.Session.get "sqlalchemy.orm.Session.get")  ###
    过期/刷新'
- en: 'An important consideration that will often come up when using the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is that of dealing with the state that is present on
    objects that have been loaded from the database, in terms of keeping them synchronized
    with the current state of the transaction. The SQLAlchemy ORM is based around
    the concept of an [identity map](../glossary.html#term-identity-map) such that
    when an object is “loaded” from a SQL query, there will be a unique Python object
    instance maintained corresponding to a particular database identity. This means
    if we emit two separate queries, each for the same row, and get a mapped object
    back, the two queries will have returned the same Python object:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")时经常会出现的一个重要考虑因素是处理从数据库加载的对象上存在的状态，以保持它们与事务的当前状态同步。SQLAlchemy
    ORM基于[标识映射](../glossary.html#term-identity-map)的概念，因此当从SQL查询中“加载”对象时，将维护一个对应于特定数据库标识的唯一Python对象实例。这意味着如果我们发出两个单独的查询，每个查询都针对同一行，并返回一个映射对象，则这两个查询将返回相同的Python对象：
- en: '[PRE38]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Following from this, when the ORM gets rows back from a query, it will **skip
    the population of attributes** for an object that’s already loaded. The design
    assumption here is to assume a transaction that’s perfectly isolated, and then
    to the degree that the transaction isn’t isolated, the application can take steps
    on an as-needed basis to refresh objects from the database transaction. The FAQ
    entry at [I’m re-loading data with my Session but it isn’t seeing changes that
    I committed elsewhere](../faq/sessions.html#faq-session-identity) discusses this
    concept in more detail.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 由此可见，当ORM从查询中返回行时，将**跳过已加载的对象的属性填充**。这里的设计假设是假定一个完全隔离的事务，然后在事务不完全隔离的程度上，应用程序可以根据需要从数据库事务中刷新对象。在[我正在重新加载我的Session中的数据，但它没有看到我在其他地方提交的更改](../faq/sessions.html#faq-session-identity)的FAQ条目中更详细地讨论了这个概念。
- en: 'When an ORM mapped object is loaded into memory, there are three general ways
    to refresh its contents with new data from the current transaction:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 当ORM映射对象加载到内存中时，有三种常规方法可以使用当前事务中的新数据刷新其内容：
- en: '**the expire() method** - the [`Session.expire()`](session_api.html#sqlalchemy.orm.Session.expire
    "sqlalchemy.orm.Session.expire") method will erase the contents of selected or
    all attributes of an object, such that they will be loaded from the database when
    they are next accessed, e.g. using a [lazy loading](../glossary.html#term-lazy-loading)
    pattern:'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**expire() 方法** - [`Session.expire()`](session_api.html#sqlalchemy.orm.Session.expire
    "sqlalchemy.orm.Session.expire") 方法将擦除对象的选定或全部属性的内容，以便在下次访问它们时从数据库加载，例如使用[惰性加载](../glossary.html#term-lazy-loading)模式：'
- en: '[PRE39]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '**the refresh() method** - closely related is the [`Session.refresh()`](session_api.html#sqlalchemy.orm.Session.refresh
    "sqlalchemy.orm.Session.refresh") method, which does everything the [`Session.expire()`](session_api.html#sqlalchemy.orm.Session.expire
    "sqlalchemy.orm.Session.expire") method does but also emits one or more SQL queries
    immediately to actually refresh the contents of the object:'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**refresh() 方法** - 与之密切相关的是[`Session.refresh()`](session_api.html#sqlalchemy.orm.Session.refresh
    "sqlalchemy.orm.Session.refresh") 方法，它执行[`Session.expire()`](session_api.html#sqlalchemy.orm.Session.expire
    "sqlalchemy.orm.Session.expire") 方法执行的所有操作，但还立即发出一个或多个SQL查询来实际刷新对象的内容：'
- en: '[PRE40]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '**the populate_existing() method or execution option** - This is now an execution
    option documented at [Populate Existing](queryguide/api.html#orm-queryguide-populate-existing);
    in legacy form it’s found on the [`Query`](queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object as the [`Query.populate_existing()`](queryguide/query.html#sqlalchemy.orm.Query.populate_existing
    "sqlalchemy.orm.Query.populate_existing") method. This operation in either form
    indicates that objects being returned from a query should be unconditionally re-populated
    from their contents in the database:'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**populate_existing() 方法或执行选项** - 现在这是一个在[填充现有](queryguide/api.html#orm-queryguide-populate-existing)中记录的执行选项；在传统形式中，它在[`Query`](queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")对象上作为[`Query.populate_existing()`](queryguide/query.html#sqlalchemy.orm.Query.populate_existing
    "sqlalchemy.orm.Query.populate_existing")方法找到。无论采取哪种形式，此操作表示应从数据库中的内容无条件地重新填充从查询返回的对象：'
- en: '[PRE41]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Further discussion on the refresh / expire concept can be found at [Refreshing
    / Expiring](session_state_management.html#session-expire).
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 关于刷新/过期概念的进一步讨论可在[刷新/过期](session_state_management.html#session-expire)找到。
- en: See also
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Refreshing / Expiring](session_state_management.html#session-expire)'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '[刷新/过期](session_state_management.html#session-expire)'
- en: '[I’m re-loading data with my Session but it isn’t seeing changes that I committed
    elsewhere](../faq/sessions.html#faq-session-identity)'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '[我正在使用我的会话重新加载数据，但它没有看到我在其他地方提交的更改](../faq/sessions.html#faq-session-identity)'
- en: UPDATE and DELETE with arbitrary WHERE clause
  id: totrans-287
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用任意WHERE子句的UPDATE和DELETE
- en: SQLAlchemy 2.0 includes enhanced capabilities for emitting several varieties
    of ORM-enabled INSERT, UPDATE and DELETE statements. See the document at [ORM-Enabled
    INSERT, UPDATE, and DELETE statements](queryguide/dml.html) for documentation.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 2.0包括增强功能，可发出几种类型的ORM启用的INSERT、UPDATE和DELETE语句。有关文档，请参阅[ORM-启用的INSERT、UPDATE和DELETE语句](queryguide/dml.html)。
- en: See also
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[ORM-Enabled INSERT, UPDATE, and DELETE statements](queryguide/dml.html)'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '[ORM-启用的INSERT、UPDATE和DELETE语句](queryguide/dml.html)'
- en: '[ORM UPDATE and DELETE with Custom WHERE Criteria](queryguide/dml.html#orm-queryguide-update-delete-where)'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '[带有自定义WHERE条件的ORM UPDATE和DELETE](queryguide/dml.html#orm-queryguide-update-delete-where)'
- en: '### Auto Begin'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '### 自动开始'
- en: The [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    object features a behavior known as **autobegin**. This indicates that the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") will internally consider itself to be in a “transactional”
    state as soon as any work is performed with the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), either involving modifications to the internal state
    of the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    with regards to object state changes, or with operations that require database
    connectivity.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    对象具有称为**autobegin**的行为。这表示[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")一旦执行了与[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")相关的任何工作，无论涉及对[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")的内部状态进行修改还是需要数据库连接的操作，它都会在内部将自身视为处于“事务”状态。'
- en: When the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    is first constructed, there’s no transactional state present. The transactional
    state is begun automatically, when a method such as [`Session.add()`](session_api.html#sqlalchemy.orm.Session.add
    "sqlalchemy.orm.Session.add") or [`Session.execute()`](session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") is invoked, or similarly if a [`Query`](queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") is executed to return results (which ultimately uses [`Session.execute()`](session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute")), or if an attribute is modified on a [persistent](../glossary.html#term-persistent)
    object.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 当首次构造[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")时，不存在事务状态。当调用方法如[`Session.add()`](session_api.html#sqlalchemy.orm.Session.add
    "sqlalchemy.orm.Session.add")或[`Session.execute()`](session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute")时，或类似地执行用于返回结果的[`Query`](queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")（最终使用[`Session.execute()`](session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute")），或者在[持久化](../glossary.html#term-persistent)对象上修改属性时，事务状态将自动开始。
- en: The transactional state can be checked by accessing the [`Session.in_transaction()`](session_api.html#sqlalchemy.orm.Session.in_transaction
    "sqlalchemy.orm.Session.in_transaction") method, which returns `True` or `False`
    indicating if the “autobegin” step has proceeded. While not normally needed, the
    [`Session.get_transaction()`](session_api.html#sqlalchemy.orm.Session.get_transaction
    "sqlalchemy.orm.Session.get_transaction") method will return the actual [`SessionTransaction`](session_api.html#sqlalchemy.orm.SessionTransaction
    "sqlalchemy.orm.SessionTransaction") object that represents this transactional
    state.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 检查事务状态可以通过访问[`Session.in_transaction()`](session_api.html#sqlalchemy.orm.Session.in_transaction
    "sqlalchemy.orm.Session.in_transaction")方法来实现，该方法返回`True`或`False`，指示“自动开始”步骤是否已经执行。虽然通常不需要，但[`Session.get_transaction()`](session_api.html#sqlalchemy.orm.Session.get_transaction
    "sqlalchemy.orm.Session.get_transaction")方法将返回表示此事务状态的实际[`SessionTransaction`](session_api.html#sqlalchemy.orm.SessionTransaction
    "sqlalchemy.orm.SessionTransaction")对象。
- en: The transactional state of the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") may also be started explicitly, by invoking the [`Session.begin()`](session_api.html#sqlalchemy.orm.Session.begin
    "sqlalchemy.orm.Session.begin") method. When this method is called, the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is placed into the “transactional” state unconditionally.
    [`Session.begin()`](session_api.html#sqlalchemy.orm.Session.begin "sqlalchemy.orm.Session.begin")
    may be used as a context manager as described at [Framing out a begin / commit
    / rollback block](#session-begin-commit-rollback-block).
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以通过调用[`Session.begin()`](session_api.html#sqlalchemy.orm.Session.begin "sqlalchemy.orm.Session.begin")方法显式启动[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")的事务状态。调用此方法时，[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")无条件地被置于“事务性”状态。[`Session.begin()`](session_api.html#sqlalchemy.orm.Session.begin
    "sqlalchemy.orm.Session.begin")可以像描述的那样用作上下文管理器，详见[构建开始 / 提交 / 回滚块的框架](#session-begin-commit-rollback-block)。
- en: '#### Disabling Autobegin to Prevent Implicit Transactions'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 禁用 Autobegin 以防止隐式事务'
- en: 'The “autobegin” behavior may be disabled using the [`Session.autobegin`](session_api.html#sqlalchemy.orm.Session.params.autobegin
    "sqlalchemy.orm.Session") parameter set to `False`. By using this parameter, a
    [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    will require that the [`Session.begin()`](session_api.html#sqlalchemy.orm.Session.begin
    "sqlalchemy.orm.Session.begin") method is called explicitly. Upon construction,
    as well as after any of the [`Session.rollback()`](session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback"), [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit"), or [`Session.close()`](session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") methods are called, the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") won’t implicitly begin any new transactions and will
    raise an error if an attempt to use the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is made without first calling [`Session.begin()`](session_api.html#sqlalchemy.orm.Session.begin
    "sqlalchemy.orm.Session.begin"):'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过将[`Session.autobegin`](session_api.html#sqlalchemy.orm.Session.params.autobegin
    "sqlalchemy.orm.Session")参数设置为`False`来禁用“自动开始”行为。通过使用此参数，[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")将要求显式调用[`Session.begin()`](session_api.html#sqlalchemy.orm.Session.begin
    "sqlalchemy.orm.Session.begin")方法。在构造之后以及在调用任何[`Session.rollback()`](session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback")、[`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit")或[`Session.close()`](session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close")方法之后，如果尝试在没有首先调用[`Session.begin()`](session_api.html#sqlalchemy.orm.Session.begin
    "sqlalchemy.orm.Session.begin")的情况下使用[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")，则不会隐式启动任何新事务，并且将引发错误：
- en: '[PRE42]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'New in version 2.0: Added [`Session.autobegin`](session_api.html#sqlalchemy.orm.Session.params.autobegin
    "sqlalchemy.orm.Session"), allowing “autobegin” behavior to be disabled  ### Committing'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '新版本2.0中新增：添加[`Session.autobegin`](session_api.html#sqlalchemy.orm.Session.params.autobegin
    "sqlalchemy.orm.Session")，允许禁用“自动开始”行为  ### 提交'
- en: '[`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit "sqlalchemy.orm.Session.commit")
    is used to commit the current transaction. At its core this indicates that it
    emits `COMMIT` on all current database connections that have a transaction in
    progress; from a [DBAPI](../glossary.html#term-DBAPI) perspective this means the
    `connection.commit()` DBAPI method is invoked on each DBAPI connection.'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit "sqlalchemy.orm.Session.commit")
    用于提交当前事务。本质上，这表示在所有当前具有正在进行的事务的数据库连接上发出`COMMIT`；从[DBAPI](../glossary.html#term-DBAPI)的角度来看，这意味着在每个DBAPI连接上调用`connection.commit()`
    DBAPI方法。'
- en: When there is no transaction in place for the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), indicating that no operations were invoked on this
    [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    since the previous call to [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit"), the method will begin and commit an internal-only
    “logical” transaction, that does not normally affect the database unless pending
    flush changes were detected, but will still invoke event handlers and object expiration
    rules.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 当[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")没有处于事务中时，表示自从上次调用[`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit")以来，在此[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")上未调用任何操作，该方法将启动并提交一个仅“逻辑”的内部事务，通常不会影响数据库，除非检测到未决刷新更改，但仍将调用事件处理程序和对象过期规则。
- en: The [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit "sqlalchemy.orm.Session.commit")
    operation unconditionally issues [`Session.flush()`](session_api.html#sqlalchemy.orm.Session.flush
    "sqlalchemy.orm.Session.flush") before emitting COMMIT on relevant database connections.
    If no pending changes are detected, then no SQL is emitted to the database. This
    behavior is not configurable and is not affected by the [`Session.autoflush`](session_api.html#sqlalchemy.orm.Session.params.autoflush
    "sqlalchemy.orm.Session") parameter.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在发出相关数据库连接上的COMMIT之前，[`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") 操作无条件地发出[`Session.flush()`](session_api.html#sqlalchemy.orm.Session.flush
    "sqlalchemy.orm.Session.flush")。如果未检测到待处理的更改，则不会向数据库发出任何SQL。此行为不可配置，并且不受[`Session.autoflush`](session_api.html#sqlalchemy.orm.Session.params.autoflush
    "sqlalchemy.orm.Session")参数的影响。
- en: Subsequent to that, assuming the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is bound to an [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine"), [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") will then COMMIT the actual database transaction
    that is in place, if one was started. After the commit, the [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") object associated with that transaction is closed,
    causing its underlying DBAPI connection to be [released](../glossary.html#term-released)
    back to the connection pool associated with the [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") to which the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is bound.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，假设[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")绑定到一个[`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine")，[`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit")将提交当前的数据库事务，如果已经启动。提交后，与该事务关联的[`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")对象将关闭，导致其底层的 DBAPI 连接被释放回与[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")绑定的[`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine")相关联的连接池。
- en: For a [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    that’s bound to multiple engines (e.g. as described at [Partitioning Strategies](persistence_techniques.html#session-partitioning)),
    the same COMMIT steps will proceed for each [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") / [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") that is in play within the “logical” transaction
    being committed. These database transactions are uncoordinated with each other
    unless [two-phase features](session_transaction.html#session-twophase) are enabled.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 对于绑定到多个引擎的[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")（例如在[分区策略](persistence_techniques.html#session-partitioning)中描述的方式），对正在提交的“逻辑”事务中涉及的每个[`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") / [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")都将执行相同的 COMMIT 步骤。除非启用了[两阶段功能](session_transaction.html#session-twophase)，否则这些数据库事务之间不协调。
- en: Other connection-interaction patterns are available as well, by binding the
    [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    to a [`Connection`](../core/connections.html#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    directly; in this case, it’s assumed that an externally-managed transaction is
    present, and a real COMMIT will not be emitted automatically in this case; see
    the section [Joining a Session into an External Transaction (such as for test
    suites)](session_transaction.html#session-external-transaction) for background
    on this pattern.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 其他连接-交互模式也是可用的，通过将[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")直接绑定到[`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")；在这种情况下，假定存在外部管理的事务，并且在这种情况下不会自动发出真正的 COMMIT；有关此模式的背景，请参阅[将
    Session 加入外部事务（例如测试套件）](session_transaction.html#session-external-transaction)部分。
- en: Finally, all objects within the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") are [expired](../glossary.html#term-expired) as the
    transaction is closed out. This is so that when the instances are next accessed,
    either through attribute access or by them being present in the result of a SELECT,
    they receive the most recent state. This behavior may be controlled by the [`Session.expire_on_commit`](session_api.html#sqlalchemy.orm.Session.params.expire_on_commit
    "sqlalchemy.orm.Session") flag, which may be set to `False` when this behavior
    is undesirable.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在事务关闭时，[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")中的所有对象都会被[过期](../glossary.html#term-expired)。这样，当下次访问实例时，无论是通过属性访问还是通过它们出现在
    SELECT 的结果中，它们都会接收到最新状态。这种行为可以由[`Session.expire_on_commit`](session_api.html#sqlalchemy.orm.Session.params.expire_on_commit
    "sqlalchemy.orm.Session")标志来控制，当此行为不可取时可以将其设置为`False`。
- en: See also
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Auto Begin](#session-autobegin)  ### Rolling Back'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '[自动开始](#session-autobegin)  ### 回滚'
- en: '[`Session.rollback()`](session_api.html#sqlalchemy.orm.Session.rollback "sqlalchemy.orm.Session.rollback")
    rolls back the current transaction, if any. When there is no transaction in place,
    the method passes silently.'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session.rollback()`](session_api.html#sqlalchemy.orm.Session.rollback "sqlalchemy.orm.Session.rollback")回滚当前事务（如果有）。当没有事务时，该方法会静默地通过。'
- en: 'With a default configured session, the post-rollback state of the session,
    subsequent to a transaction having been begun either via [autobegin](#session-autobegin)
    or by calling the [`Session.begin()`](session_api.html#sqlalchemy.orm.Session.begin
    "sqlalchemy.orm.Session.begin") method explicitly, is as follows:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 默认配置的会话后回滚状态，即通过[autobegin](#session-autobegin)或显式调用[`Session.begin()`](session_api.html#sqlalchemy.orm.Session.begin
    "sqlalchemy.orm.Session.begin")方法开始事务后的状态如下：
- en: Database transactions are rolled back. For a [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") bound to a single [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine"), this means ROLLBACK is emitted for at most a single
    [`Connection`](../core/connections.html#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    that’s currently in use. For [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") objects bound to multiple [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") objects, ROLLBACK is emitted for all [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") objects that were checked out.
  id: totrans-312
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库事务被回滚。对于绑定到单个[`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine")的[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")，这意味着对当前正在使用的最多一个[`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")进行回滚。对于绑定到多个[`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine")对象的[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")对象，将对所有被检出的[`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")对象进行回滚。
- en: ''
  id: totrans-313
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-314
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Database connections are [released](../glossary.html#term-released). This follows
    the same connection-related behavior noted in [Committing](#session-committing),
    where [`Connection`](../core/connections.html#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    objects obtained from [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") objects are closed, causing the DBAPI connections
    to be [released](../glossary.html#term-released) to the connection pool within
    the [`Engine`](../core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine").
    New connections are checked out from the [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") if and when a new transaction begins.
  id: totrans-315
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库连接被[释放](../glossary.html#term-released)。这遵循了[提交](#session-committing)中注意到的与连接相关的相同行为，即从[`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine")对象获取的[`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")对象被关闭，导致 DBAPI 连接被释放到 [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") 中的连接池中。如果有新的事务开始，会从[`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine")中检出新的连接。
- en: ''
  id: totrans-316
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-317
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: For a [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    that’s bound directly to a [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") as described at [Joining a Session into an External
    Transaction (such as for test suites)](session_transaction.html#session-external-transaction),
    rollback behavior on this [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") would follow the behavior specified by the [`Session.join_transaction_mode`](session_api.html#sqlalchemy.orm.Session.params.join_transaction_mode
    "sqlalchemy.orm.Session") parameter, which could involve rolling back savepoints
    or emitting a real ROLLBACK.
  id: totrans-318
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于直接绑定到[`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")的[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")，如[将会话加入外部事务（例如测试套件）](session_transaction.html#session-external-transaction)中描述的，此[`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")上的回滚行为将遵循由[`Session.join_transaction_mode`](session_api.html#sqlalchemy.orm.Session.params.join_transaction_mode
    "sqlalchemy.orm.Session")参数指定的行为，这可能涉及回滚保存点或发出真正的 ROLLBACK。
- en: ''
  id: totrans-319
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-320
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Objects which were initially in the [pending](../glossary.html#term-pending)
    state when they were added to the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.session.Session") within the lifespan of the transaction are expunged,
    corresponding to their INSERT statement being rolled back. The state of their
    attributes remains unchanged.
  id: totrans-321
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在事务的生命周期内，当对象被添加到[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.session.Session")时最初处于[挂起](../glossary.html#term-pending)状态的对象将被清除，对应其INSERT语句被回滚的情况。它们属性的状态保持不变。
- en: ''
  id: totrans-322
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-323
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Objects which were marked as [deleted](../glossary.html#term-deleted) within
    the lifespan of the transaction are promoted back to the [persistent](../glossary.html#term-persistent)
    state, corresponding to their DELETE statement being rolled back. Note that if
    those objects were first [pending](../glossary.html#term-pending) within the transaction,
    that operation takes precedence instead.
  id: totrans-324
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在事务的生命周期内被标记为[已删除](../glossary.html#term-deleted)的对象将被提升回[持久](../glossary.html#term-persistent)状态，对应其DELETE语句被回滚的情况。请注意，如果这些对象在事务中首先处于[挂起](../glossary.html#term-pending)状态，则该操作优先级较高。
- en: ''
  id: totrans-325
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-326
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: All objects not expunged are fully expired - this is regardless of the [`Session.expire_on_commit`](session_api.html#sqlalchemy.orm.Session.params.expire_on_commit
    "sqlalchemy.orm.Session") setting.
  id: totrans-327
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有未清除的对象都将完全过期 - 这与[`Session.expire_on_commit`](session_api.html#sqlalchemy.orm.Session.params.expire_on_commit
    "sqlalchemy.orm.Session")设置无关。
- en: With that state understood, the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") may safely continue usage after a rollback occurs.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解了这种状态后，[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")在回滚发生后可以安全地继续使用。
- en: 'Changed in version 1.4: The [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") object now features deferred “begin” behavior, as described
    in [autobegin](#session-autobegin). If no transaction is begun, methods like [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") and [`Session.rollback()`](session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") have no effect. This behavior would not have
    been observed prior to 1.4 as under non-autocommit mode, a transaction would always
    be implicitly present.'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 从版本1.4开始更改：[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")对象现在具有延迟“begin”行为，如[自动开始](#session-autobegin)中所述。如果未开始任何事务，则[`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit")和[`Session.rollback()`](session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback")等方法将不起作用。在1.4之前，不会观察到这种行为，因为在非自动提交模式下，事务总是隐式存在的。
- en: When a [`Session.flush()`](session_api.html#sqlalchemy.orm.Session.flush "sqlalchemy.orm.Session.flush")
    fails, typically for reasons like primary key, foreign key, or “not nullable”
    constraint violations, a ROLLBACK is issued automatically (it’s currently not
    possible for a flush to continue after a partial failure). However, the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") goes into a state known as “inactive” at this point,
    and the calling application must always call the [`Session.rollback()`](session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") method explicitly so that the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") can go back into a usable state (it can also be simply
    closed and discarded). See the FAQ entry at [“This Session’s transaction has been
    rolled back due to a previous exception during flush.” (or similar)](../faq/sessions.html#faq-session-rollback)
    for further discussion.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 当[`Session.flush()`](session_api.html#sqlalchemy.orm.Session.flush "sqlalchemy.orm.Session.flush")失败时，通常是由于主键、外键或“非空”约束违规等原因，会自动发出ROLLBACK（当前不可能在部分失败后继续flush）。但是，在此时，[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")进入一种称为“不活跃”的状态，调用应用程序必须始终显式调用[`Session.rollback()`](session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback")方法，以便[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")可以回到可用状态（也可以简单地关闭并丢弃）。有关进一步讨论，请参阅FAQ条目[“此会话的事务由于刷新时的先前异常而被回滚。”（或类似）](../faq/sessions.html#faq-session-rollback)。
- en: See also
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Auto Begin](#session-autobegin)  ### Closing'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '[自动开始](#session-autobegin)  ### 结束'
- en: The [`Session.close()`](session_api.html#sqlalchemy.orm.Session.close "sqlalchemy.orm.Session.close")
    method issues a [`Session.expunge_all()`](session_api.html#sqlalchemy.orm.Session.expunge_all
    "sqlalchemy.orm.Session.expunge_all") which removes all ORM-mapped objects from
    the session, and [releases](../glossary.html#term-releases) any transactional/connection
    resources from the [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") object(s) to which it is bound. When connections are
    returned to the connection pool, transactional state is rolled back as well.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session.close()`](session_api.html#sqlalchemy.orm.Session.close "sqlalchemy.orm.Session.close")
    方法会发出一个[`Session.expunge_all()`](session_api.html#sqlalchemy.orm.Session.expunge_all
    "sqlalchemy.orm.Session.expunge_all")，它将从会话中删除所有ORM映射的对象，并且[释放](../glossary.html#term-releases)与其绑定的[`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine")对象的所有事务/连接资源。当连接返回到连接池时，事务状态也会被回滚。'
- en: By default, when the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    is closed, it is essentially in the original state as when it was first constructed,
    and **may be used again**. In this sense, the [`Session.close()`](session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") method is more like a “reset” back to the clean
    state and not as much like a “database close” method. In this mode of operation
    the method [`Session.reset()`](session_api.html#sqlalchemy.orm.Session.reset "sqlalchemy.orm.Session.reset")
    is an alias to [`Session.close()`](session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") and behaves in the same way.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，当[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")关闭时，它基本上处于最初构建时的原始状态，并且**可以再次使用**。从这个意义上说，[`Session.close()`](session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") 方法更像是“重置”回到清洁状态，而不太像是“关闭数据库”的方法。在这种操作模式下，方法[`Session.reset()`](session_api.html#sqlalchemy.orm.Session.reset
    "sqlalchemy.orm.Session.reset")是[`Session.close()`](session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close")的别名，并且行为相同。
- en: The default behavior of [`Session.close()`](session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") can be changed by setting the parameter [`Session.close_resets_only`](session_api.html#sqlalchemy.orm.Session.params.close_resets_only
    "sqlalchemy.orm.Session") to `False`, indicating that the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") cannot be reused after the method [`Session.close()`](session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") has been called. In this mode of operation the
    [`Session.reset()`](session_api.html#sqlalchemy.orm.Session.reset "sqlalchemy.orm.Session.reset")
    method will allow multiple “reset” of the session, behaving like [`Session.close()`](session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") when [`Session.close_resets_only`](session_api.html#sqlalchemy.orm.Session.params.close_resets_only
    "sqlalchemy.orm.Session") is set to `True`.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session.close()`](session_api.html#sqlalchemy.orm.Session.close "sqlalchemy.orm.Session.close")
    的默认行为可以通过将参数[`Session.close_resets_only`](session_api.html#sqlalchemy.orm.Session.params.close_resets_only
    "sqlalchemy.orm.Session")设置为`False`来更改，这表明在调用方法[`Session.close()`](session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close")后，[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")不能被重用。在这种操作模式下，当[`Session.close_resets_only`](session_api.html#sqlalchemy.orm.Session.params.close_resets_only
    "sqlalchemy.orm.Session")设置为`True`时，方法[`Session.reset()`](session_api.html#sqlalchemy.orm.Session.reset
    "sqlalchemy.orm.Session.reset")将允许会话的多次“重置”，表现得像[`Session.close()`](session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close")一样。'
- en: New in version 2.0.22.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 2.0.22版本中的新增功能。
- en: 'It’s recommended that the scope of a [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") be limited by a call to [`Session.close()`](session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") at the end, especially if the [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") or [`Session.rollback()`](session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") methods are not used. The [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") may be used as a context manager to ensure that [`Session.close()`](session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") is called:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 建议在结束时通过调用 [`Session.close()`](session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") 来限制 [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 的范围，特别是如果未使用 [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") 或 [`Session.rollback()`](session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") 方法。 [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 可以用作上下文管理器，以确保调用 [`Session.close()`](session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close")：
- en: '[PRE43]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Changed in version 1.4: The [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") object features deferred “begin” behavior, as described
    in [autobegin](#session-autobegin). no longer immediately begins a new transaction
    after the [`Session.close()`](session_api.html#sqlalchemy.orm.Session.close "sqlalchemy.orm.Session.close")
    method is called.  ### Opening and Closing a Session'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 自 1.4 版更改：[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    对象具有延迟“begin”行为，如 [autobegin](#session-autobegin) 中所述。在调用 [`Session.close()`](session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") 方法后，不再立即开始新事务。### 开启和关闭会话
- en: 'The [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    may be constructed on its own or by using the [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker") class. It typically is passed a single [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") as a source of connectivity up front. A typical use
    may look like:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    可以自行构建，也可以使用 [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker "sqlalchemy.orm.sessionmaker")
    类。通常，它最初会作为连接性的源传递单个 [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine")。典型的用法可能如下：'
- en: '[PRE44]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Above, the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    is instantiated with an [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") associated with a particular database URL. It is then
    used in a Python context manager (i.e. `with:` statement) so that it is automatically
    closed at the end of the block; this is equivalent to calling the [`Session.close()`](session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") method.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 上面，[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    是通过与特定数据库 URL 关联的 [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") 实例化的。然后在 Python 上下文管理器中使用（即 `with:` 语句），以便在块结束时自动关闭；这相当于调用
    [`Session.close()`](session_api.html#sqlalchemy.orm.Session.close "sqlalchemy.orm.Session.close")
    方法。
- en: The call to [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") is optional, and is only needed if the work we’ve
    done with the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    includes new data to be persisted to the database. If we were only issuing SELECT
    calls and did not need to write any changes, then the call to [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") would be unnecessary.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit "sqlalchemy.orm.Session.commit")
    是可选的，只有在我们与 [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    一起完成的工作包括要持久化到数据库的新数据时才需要。如果我们只是发出 SELECT 调用并且不需要写入任何更改，则调用 [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") 将是不必要的。
- en: Note
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 注
- en: Note that after [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") is called, either explicitly or when using a
    context manager, all objects associated with the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") are [expired](../glossary.html#term-expired), meaning
    their contents are erased to be re-loaded within the next transaction. If these
    objects are instead [detached](../glossary.html#term-detached), they will be non-functional
    until re-associated with a new [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), unless the [`Session.expire_on_commit`](session_api.html#sqlalchemy.orm.Session.params.expire_on_commit
    "sqlalchemy.orm.Session") parameter is used to disable this behavior. See the
    section [Committing](#session-committing) for more detail.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在调用[`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit "sqlalchemy.orm.Session.commit")之后，无论是显式调用还是使用上下文管理器，与[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")相关联的所有对象都将被[过期](../glossary.html#term-expired)，这意味着它们的内容将被擦除以在下一个事务中重新加载。如果这些对象被[分离](../glossary.html#term-detached)，它们将无法正常工作，直到与新的[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")重新关联，除非使用[`Session.expire_on_commit`](session_api.html#sqlalchemy.orm.Session.params.expire_on_commit
    "sqlalchemy.orm.Session")参数来禁用此行为。更多详细信息请参见[提交](#session-committing)部分。
- en: '### Framing out a begin / commit / rollback block'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '### 制定开始/提交/回滚块的框架'
- en: 'We may also enclose the [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") call and the overall “framing” of the transaction
    within a context manager for those cases where we will be committing data to the
    database. By “framing” we mean that if all operations succeed, the [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") method will be called, but if any exceptions
    are raised, the [`Session.rollback()`](session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") method will be called so that the transaction
    is rolled back immediately, before propagating the exception outward. In Python
    this is most fundamentally expressed using a `try: / except: / else:` block such
    as:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将[`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit "sqlalchemy.orm.Session.commit")调用和事务的整体“框架”封装在上下文管理器中，以用于那些将数据提交到数据库的情况。所谓“框架”是指如果所有操作成功，则会调用[`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit")方法，但如果引发任何异常，则会立即调用[`Session.rollback()`](session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback")方法，以便立即回滚事务，然后将异常传播出去。在Python中，这主要是通过`try:/except:/else:`块来表达的，例如：
- en: '[PRE45]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The long-form sequence of operations illustrated above can be achieved more
    succinctly by making use of the [`SessionTransaction`](session_api.html#sqlalchemy.orm.SessionTransaction
    "sqlalchemy.orm.SessionTransaction") object returned by the [`Session.begin()`](session_api.html#sqlalchemy.orm.Session.begin
    "sqlalchemy.orm.Session.begin") method, which provides a context manager interface
    for the same sequence of operations:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 上面示例的长形操作序列可以通过使用[`Session.begin()`](session_api.html#sqlalchemy.orm.Session.begin
    "sqlalchemy.orm.Session.begin")方法返回的[`SessionTransaction`](session_api.html#sqlalchemy.orm.SessionTransaction
    "sqlalchemy.orm.SessionTransaction")对象来更简洁地实现，该对象为相同操作序列提供了上下文管理器接口：
- en: '[PRE46]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'More succinctly, the two contexts may be combined:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 更简洁地，这两个上下文可以结合使用：
- en: '[PRE47]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Using a sessionmaker
  id: totrans-353
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用sessionmaker
- en: 'The purpose of [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker") is to provide a factory for [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") objects with a fixed configuration. As it is typical
    that an application will have an [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") object in module scope, the [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker") can provide a factory for [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") objects that are against this engine:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '[`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker "sqlalchemy.orm.sessionmaker")的目的是提供一个固定配置的[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")对象工厂。由于典型的应用程序在模块范围内会有一个[`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine")对象，[`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker")可以为与此引擎对应的[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")对象提供一个工厂：'
- en: '[PRE48]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker "sqlalchemy.orm.sessionmaker")
    is analogous to the [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") as a module-level factory for function-level sessions
    / connections. As such it also has its own [`sessionmaker.begin()`](session_api.html#sqlalchemy.orm.sessionmaker.begin
    "sqlalchemy.orm.sessionmaker.begin") method, analogous to [`Engine.begin()`](../core/connections.html#sqlalchemy.engine.Engine.begin
    "sqlalchemy.engine.Engine.begin"), which returns a [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") object and also maintains a begin/commit/rollback block:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '[`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker "sqlalchemy.orm.sessionmaker")
    与 [`Engine`](../core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    类似，是用于函数级会话/连接的模块级工厂。因此，它还有自己的 [`sessionmaker.begin()`](session_api.html#sqlalchemy.orm.sessionmaker.begin
    "sqlalchemy.orm.sessionmaker.begin") 方法，类似于 [`Engine.begin()`](../core/connections.html#sqlalchemy.engine.Engine.begin
    "sqlalchemy.engine.Engine.begin")，它返回一个 [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 对象，并且还维护一个开始/提交/回滚块：'
- en: '[PRE49]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Where above, the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    will both have its transaction committed as well as that the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") will be closed, when the above `with:` block ends.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述情况下，当上述 `with:` 块结束时，[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 将提交其事务，并且 [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 将关闭。
- en: When you write your application, the [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker") factory should be scoped the same as the [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") object created by [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine"), which is typically at module-level or global scope.
    As these objects are both factories, they can be used by any number of functions
    and threads simultaneously.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写应用程序时，[`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker "sqlalchemy.orm.sessionmaker")
    工厂应该与 [`create_engine()`](../core/engines.html#sqlalchemy.create_engine "sqlalchemy.create_engine")
    创建的 [`Engine`](../core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    对象保持相同的作用域，通常在模块级或全局级别。由于这些对象都是工厂，因此它们可以被任意数量的函数和线程同时使用。
- en: See also
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker "sqlalchemy.orm.sessionmaker")'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '[`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker "sqlalchemy.orm.sessionmaker")'
- en: '[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")'
- en: '### Querying'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '### 查询'
- en: The primary means of querying is to make use of the [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") construct to create a [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") object, which is then executed to return a
    result using methods such as [`Session.execute()`](session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") and [`Session.scalars()`](session_api.html#sqlalchemy.orm.Session.scalars
    "sqlalchemy.orm.Session.scalars"). Results are then returned in terms of [`Result`](../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") objects, including sub-variants such as [`ScalarResult`](../core/connections.html#sqlalchemy.engine.ScalarResult
    "sqlalchemy.engine.ScalarResult").
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 查询的主要方式是利用 [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") 构造创建一个 [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") 对象，然后使用诸如 [`Session.execute()`](session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") 和 [`Session.scalars()`](session_api.html#sqlalchemy.orm.Session.scalars
    "sqlalchemy.orm.Session.scalars") 等方法执行以返回结果。结果然后以 [`Result`](../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") 对象的形式返回，包括诸如 [`ScalarResult`](../core/connections.html#sqlalchemy.engine.ScalarResult
    "sqlalchemy.engine.ScalarResult") 等子变体。
- en: 'A complete guide to SQLAlchemy ORM querying can be found at [ORM Querying Guide](queryguide/index.html).
    Some brief examples follow:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '[SQLAlchemy ORM 查询指南](queryguide/index.html)提供了完整的 SQLAlchemy ORM 查询指南。以下是一些简要示例：'
- en: '[PRE50]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Changed in version 2.0: “2.0” style querying is now standard. See [2.0 Migration
    - ORM Usage](../changelog/migration_20.html#migration-20-query-usage) for migration
    notes from the 1.x series.'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 从版本 2.0 开始更改：“2.0”样式查询现在是标准的。请参阅 [2.0 迁移 - ORM 使用](../changelog/migration_20.html#migration-20-query-usage)
    查看从 1.x 系列迁移的注意事项。
- en: See also
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[ORM Querying Guide](queryguide/index.html)'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '[ORM 查询指南](queryguide/index.html)'
- en: '### Adding New or Existing Items'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '### 添加新的或现有的项目'
- en: '[`Session.add()`](session_api.html#sqlalchemy.orm.Session.add "sqlalchemy.orm.Session.add")
    is used to place instances in the session. For [transient](../glossary.html#term-transient)
    (i.e. brand new) instances, this will have the effect of an INSERT taking place
    for those instances upon the next flush. For instances which are [persistent](../glossary.html#term-persistent)
    (i.e. were loaded by this session), they are already present and do not need to
    be added. Instances which are [detached](../glossary.html#term-detached) (i.e.
    have been removed from a session) may be re-associated with a session using this
    method:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session.add()`](session_api.html#sqlalchemy.orm.Session.add "sqlalchemy.orm.Session.add")
    用于将实例放入会话中。对于[临时](../glossary.html#term-transient)（即全新）的实例，这将在下一次刷新时导致对这些实例进行INSERT。对于[持久](../glossary.html#term-persistent)（即由此会话加载的）实例，它们已经存在，不需要添加。[分离](../glossary.html#term-detached)（即已从会话中移除的）实例可以使用此方法重新关联到会话中：'
- en: '[PRE51]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'To add a list of items to the session at once, use [`Session.add_all()`](session_api.html#sqlalchemy.orm.Session.add_all
    "sqlalchemy.orm.Session.add_all"):'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 要一次性向会话中添加项目列表，请使用[`Session.add_all()`](session_api.html#sqlalchemy.orm.Session.add_all
    "sqlalchemy.orm.Session.add_all")：
- en: '[PRE52]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The [`Session.add()`](session_api.html#sqlalchemy.orm.Session.add "sqlalchemy.orm.Session.add")
    operation **cascades** along the `save-update` cascade. For more details see the
    section [Cascades](cascades.html#unitofwork-cascades).
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session.add()`](session_api.html#sqlalchemy.orm.Session.add "sqlalchemy.orm.Session.add")
    操作**级联**执行`save-update`级联。更多详情请参阅[Cascades](cascades.html#unitofwork-cascades)部分。'
- en: '### Deleting'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '### 删除'
- en: 'The [`Session.delete()`](session_api.html#sqlalchemy.orm.Session.delete "sqlalchemy.orm.Session.delete")
    method places an instance into the Session’s list of objects to be marked as deleted:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session.delete()`](session_api.html#sqlalchemy.orm.Session.delete "sqlalchemy.orm.Session.delete")
    方法将一个实例放入会话的待删除对象列表中：'
- en: '[PRE53]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[`Session.delete()`](session_api.html#sqlalchemy.orm.Session.delete "sqlalchemy.orm.Session.delete")
    marks an object for deletion, which will result in a DELETE statement emitted
    for each primary key affected. Before the pending deletes are flushed, objects
    marked by “delete” are present in the [`Session.deleted`](session_api.html#sqlalchemy.orm.Session.deleted
    "sqlalchemy.orm.Session.deleted") collection. After the DELETE, they are expunged
    from the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session"),
    which becomes permanent after the transaction is committed.'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session.delete()`](session_api.html#sqlalchemy.orm.Session.delete "sqlalchemy.orm.Session.delete")
    标记一个对象为删除状态，这将导致为每个受影响的主键发出DELETE语句。在挂起的删除被刷新之前，“delete”标记的对象存在于[`Session.deleted`](session_api.html#sqlalchemy.orm.Session.deleted
    "sqlalchemy.orm.Session.deleted")集合中。删除后，它们将从[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")中移除，在事务提交后，这将变得永久。'
- en: 'There are various important behaviors related to the [`Session.delete()`](session_api.html#sqlalchemy.orm.Session.delete
    "sqlalchemy.orm.Session.delete") operation, particularly in how relationships
    to other objects and collections are handled. There’s more information on how
    this works in the section [Cascades](cascades.html#unitofwork-cascades), but in
    general the rules are:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 与[`Session.delete()`](session_api.html#sqlalchemy.orm.Session.delete "sqlalchemy.orm.Session.delete")操作相关的各种重要行为，尤其是与其他对象和集合的关系如何处理的行为。有关此操作的更多信息，请参见[Cascades](cascades.html#unitofwork-cascades)部分，但通常规则如下：
- en: Rows that correspond to mapped objects that are related to a deleted object
    via the [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")
    directive are **not deleted by default**. If those objects have a foreign key
    constraint back to the row being deleted, those columns are set to NULL. This
    will cause a constraint violation if the columns are non-nullable.
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")指令与已删除对象相关联的映射对象对应的行**默认不会被删除**。如果这些对象对被删除的行有一个外键约束，则这些列将设置为NULL。如果这些列是非空的，这将导致约束违反。
- en: To change the “SET NULL” into a DELETE of a related object’s row, use the [delete](cascades.html#cascade-delete)
    cascade on the [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship").
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要将“SET NULL”更改为相关对象行的DELETE，请使用[`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") 上的删除级联。
- en: Rows that are in tables linked as “many-to-many” tables, via the [`relationship.secondary`](relationship_api.html#sqlalchemy.orm.relationship.params.secondary
    "sqlalchemy.orm.relationship") parameter, **are** deleted in all cases when the
    object they refer to is deleted.
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为“多对多”表链接的表中的行，通过[`relationship.secondary`](relationship_api.html#sqlalchemy.orm.relationship.params.secondary
    "sqlalchemy.orm.relationship")参数，**在**所有情况下都会被删除，当它们引用的对象被删除时。
- en: When related objects include a foreign key constraint back to the object being
    deleted, and the related collections to which they belong are not currently loaded
    into memory, the unit of work will emit a SELECT to fetch all related rows, so
    that their primary key values can be used to emit either UPDATE or DELETE statements
    on those related rows. In this way, the ORM without further instruction will perform
    the function of ON DELETE CASCADE, even if this is configured on Core [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") objects.
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当相关对象包含返回到正在删除的对象的外键约束，并且它们所属的相关集合当前未加载到内存中时，工作单元将发出SELECT来获取所有相关行，以便它们的主键值可以用于发出UPDATE或DELETE语句在这些相关行上。通过这种方式，ORM将在没有进一步指示的情况下执行ON
    DELETE CASCADE的功能，即使这在Core [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint")对象上进行了配置。
- en: The [`relationship.passive_deletes`](relationship_api.html#sqlalchemy.orm.relationship.params.passive_deletes
    "sqlalchemy.orm.relationship") parameter can be used to tune this behavior and
    rely upon “ON DELETE CASCADE” more naturally; when set to True, this SELECT operation
    will no longer take place, however rows that are locally present will still be
    subject to explicit SET NULL or DELETE. Setting [`relationship.passive_deletes`](relationship_api.html#sqlalchemy.orm.relationship.params.passive_deletes
    "sqlalchemy.orm.relationship") to the string `"all"` will disable **all** related
    object update/delete.
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`relationship.passive_deletes`](relationship_api.html#sqlalchemy.orm.relationship.params.passive_deletes
    "sqlalchemy.orm.relationship")参数可用于调整此行为，并更自然地依赖于“ON DELETE CASCADE”；当设置为True时，此SELECT操作将不再发生，但是仍将对本地存在的行进行显式的SET
    NULL或DELETE。将[`relationship.passive_deletes`](relationship_api.html#sqlalchemy.orm.relationship.params.passive_deletes
    "sqlalchemy.orm.relationship")设置为字符串`"all"`将禁用**所有**相关对象的更新/删除。'
- en: When the DELETE occurs for an object marked for deletion, the object is not
    automatically removed from collections or object references that refer to it.
    When the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    is expired, these collections may be loaded again so that the object is no longer
    present. However, it is preferable that instead of using [`Session.delete()`](session_api.html#sqlalchemy.orm.Session.delete
    "sqlalchemy.orm.Session.delete") for these objects, the object should instead
    be removed from its collection and then [delete-orphan](cascades.html#cascade-delete-orphan)
    should be used so that it is deleted as a secondary effect of that collection
    removal. See the section [Notes on Delete - Deleting Objects Referenced from Collections
    and Scalar Relationships](cascades.html#session-deleting-from-collections) for
    an example of this.
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当标记为删除的对象发生删除时，并不会自动从引用它的集合或对象引用中删除该对象。当[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")过期时，这些集合可能会再次加载，以便对象不再存在。但是，最好不要对这些对象使用[`Session.delete()`](session_api.html#sqlalchemy.orm.Session.delete
    "sqlalchemy.orm.Session.delete")，而是应该从其集合中移除对象，然后使用[delete-orphan](cascades.html#cascade-delete-orphan)，以使其作为该集合移除的副作用而被删除。请参见部分[关于删除
    - 从集合和标量关系中删除引用的对象](cascades.html#session-deleting-from-collections)以获取示例。
- en: See also
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 参见
- en: '[delete](cascades.html#cascade-delete) - describes “delete cascade”, which
    marks related objects for deletion when a lead object is deleted.'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '[delete](cascades.html#cascade-delete) - 描述了“级联删除”，当主对象被删除时，会标记相关对象为删除。'
- en: '[delete-orphan](cascades.html#cascade-delete-orphan) - describes “delete orphan
    cascade”, which marks related objects for deletion when they are de-associated
    from their lead object.'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '[delete-orphan](cascades.html#cascade-delete-orphan) - 描述了“孤立删除级联”，当它们从其主对象中取消关联时，会标记相关对象为删除。'
- en: '[Notes on Delete - Deleting Objects Referenced from Collections and Scalar
    Relationships](cascades.html#session-deleting-from-collections) - important background
    on [`Session.delete()`](session_api.html#sqlalchemy.orm.Session.delete "sqlalchemy.orm.Session.delete")
    as involves relationships being refreshed in memory.'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '[删除说明 - 删除从集合和标量关系引用的对象](cascades.html#session-deleting-from-collections) -
    有关[`Session.delete()`](session_api.html#sqlalchemy.orm.Session.delete "sqlalchemy.orm.Session.delete")的重要背景，涉及在内存中刷新关系。'
- en: '### Flushing'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '### 刷新'
- en: When the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.session.Session")
    is used with its default configuration, the flush step is nearly always done transparently.
    Specifically, the flush occurs before any individual SQL statement is issued as
    a result of a [`Query`](queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    or a [2.0-style](../glossary.html#term-1) [`Session.execute()`](session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") call, as well as within the [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") call before the transaction is committed. It
    also occurs before a SAVEPOINT is issued when [`Session.begin_nested()`](session_api.html#sqlalchemy.orm.Session.begin_nested
    "sqlalchemy.orm.Session.begin_nested") is used.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 当[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.session.Session")以其默认配置使用时，刷新步骤几乎总是在透明地完成。具体来说，在由[`Query`](queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")或[2.0 风格](../glossary.html#term-1)的[`Session.execute()`](session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute")调用引发任何单个 SQL 语句的情况下，以及在提交事务之前的[`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit")调用之前，都会发生刷新。它还在使用[`Session.begin_nested()`](session_api.html#sqlalchemy.orm.Session.begin_nested
    "sqlalchemy.orm.Session.begin_nested")时发出 SAVEPOINT 前发生。
- en: 'A [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    flush can be forced at any time by calling the [`Session.flush()`](session_api.html#sqlalchemy.orm.Session.flush
    "sqlalchemy.orm.Session.flush") method:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过调用[`Session.flush()`](session_api.html#sqlalchemy.orm.Session.flush "sqlalchemy.orm.Session.flush")方法随时强制执行[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")刷新：
- en: '[PRE54]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'The flush which occurs automatically within the scope of certain methods is
    known as **autoflush**. Autoflush is defined as a configurable, automatic flush
    call which occurs at the beginning of methods including:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些方法的范围内自动发生的刷新称为**自动刷新**。自动刷新被定义为在以下方法开始时发生的可配置的自动刷新调用：
- en: '[`Session.execute()`](session_api.html#sqlalchemy.orm.Session.execute "sqlalchemy.orm.Session.execute")
    and other SQL-executing methods, when used against ORM-enabled SQL constructs,
    such as [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") objects that refer to ORM entities and/or
    ORM-mapped attributes'
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当针对启用 ORM 的 SQL 构造执行方法（如针对 ORM 实体和/或 ORM 映射属性的[`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select")对象）使用[`Session.execute()`](session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute")和其他执行 SQL 的方法时
- en: When a [`Query`](queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    is invoked to send SQL to the database
  id: totrans-397
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当调用[`Query`](queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")来将
    SQL 发送到数据库时
- en: Within the [`Session.merge()`](session_api.html#sqlalchemy.orm.Session.merge
    "sqlalchemy.orm.Session.merge") method before querying the database
  id: totrans-398
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在查询数据库之前的[`Session.merge()`](session_api.html#sqlalchemy.orm.Session.merge "sqlalchemy.orm.Session.merge")方法内
- en: When objects are [refreshed](#session-expiring)
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当对象被[刷新](#session-expiring)
- en: When ORM [lazy load](../glossary.html#term-lazy-load) operations occur against
    unloaded object attributes.
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当针对未加载对象属性进行 ORM [惰性加载](../glossary.html#term-lazy-load) 操作时。
- en: 'There are also points at which flushes occur **unconditionally**; these points
    are within key transactional boundaries which include:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 也有一些刷新会**无条件**发生；这些点位于关键事务边界内，包括：
- en: Within the process of the [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") method
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit "sqlalchemy.orm.Session.commit")方法的过程中
- en: When [`Session.begin_nested()`](session_api.html#sqlalchemy.orm.Session.begin_nested
    "sqlalchemy.orm.Session.begin_nested") is called
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当调用[`Session.begin_nested()`](session_api.html#sqlalchemy.orm.Session.begin_nested
    "sqlalchemy.orm.Session.begin_nested")时
- en: When the [`Session.prepare()`](session_api.html#sqlalchemy.orm.Session.prepare
    "sqlalchemy.orm.Session.prepare") 2PC method is used.
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用[`Session.prepare()`](session_api.html#sqlalchemy.orm.Session.prepare "sqlalchemy.orm.Session.prepare")
    2PC 方法时。
- en: 'The **autoflush** behavior, as applied to the previous list of items, can be
    disabled by constructing a [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") or [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker") passing the [`Session.autoflush`](session_api.html#sqlalchemy.orm.Session.params.autoflush
    "sqlalchemy.orm.Session") parameter as `False`:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 作为前面项目的一部分应用的**自动刷新**行为可以通过构造一个传递[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")或[`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker")的[`Session.autoflush`](session_api.html#sqlalchemy.orm.Session.params.autoflush
    "sqlalchemy.orm.Session")参数为`False`来禁用：
- en: '[PRE55]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Additionally, autoflush can be temporarily disabled within the flow of using
    a [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    using the [`Session.no_autoflush`](session_api.html#sqlalchemy.orm.Session.no_autoflush
    "sqlalchemy.orm.Session.no_autoflush") context manager:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，自动刷新可以在使用[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")的流程中暂时禁用，使用[`Session.no_autoflush`](session_api.html#sqlalchemy.orm.Session.no_autoflush
    "sqlalchemy.orm.Session.no_autoflush")上下文管理器：
- en: '[PRE56]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '**To reiterate:** The flush process **always occurs** when transactional methods
    such as [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit "sqlalchemy.orm.Session.commit")
    and [`Session.begin_nested()`](session_api.html#sqlalchemy.orm.Session.begin_nested
    "sqlalchemy.orm.Session.begin_nested") are called, regardless of any “autoflush”
    settings, when the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    has remaining pending changes to process.'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '**重申一下：** 当调用事务方法（例如[`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit")和[`Session.begin_nested()`](session_api.html#sqlalchemy.orm.Session.begin_nested
    "sqlalchemy.orm.Session.begin_nested")）时，刷新过程**总是发生**，而不管任何“自动刷新”设置如何，当[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")还有未处理的待处理更改时。'
- en: As the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    only invokes SQL to the database within the context of a [DBAPI](../glossary.html#term-DBAPI)
    transaction, all “flush” operations themselves only occur within a database transaction
    (subject to the [isolation level](session_transaction.html#session-transaction-isolation)
    of the database transaction), provided that the DBAPI is not in [driver level
    autocommit](../core/connections.html#dbapi-autocommit) mode. This means that assuming
    the database connection is providing for [atomicity](../glossary.html#term-atomicity)
    within its transactional settings, if any individual DML statement inside the
    flush fails, the entire operation will be rolled back.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 由于[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")仅在[DBAPI](../glossary.html#term-DBAPI)事务的上下文中调用数据库的SQL，所有“刷新”操作本身仅发生在数据库事务内（取决于数据库事务的[隔离级别](session_transaction.html#session-transaction-isolation)），前提是DBAPI不处于[驱动程序级别的自动提交](../core/connections.html#dbapi-autocommit)模式。这意味着假设数据库连接在其事务设置中提供了[原子性](../glossary.html#term-atomicity)，如果刷新中的任何单个DML语句失败，整个操作都将被回滚。
- en: When a failure occurs within a flush, in order to continue using that same [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), an explicit call to [`Session.rollback()`](session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") is required after a flush fails, even though
    the underlying transaction will have been rolled back already (even if the database
    driver is technically in driver-level autocommit mode). This is so that the overall
    nesting pattern of so-called “subtransactions” is consistently maintained. The
    FAQ section [“This Session’s transaction has been rolled back due to a previous
    exception during flush.” (or similar)](../faq/sessions.html#faq-session-rollback)
    contains a more detailed description of this behavior.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 在刷新过程中发生故障时，为了继续使用相同的[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")，即使底层事务已经回滚（即使数据库驱动程序在技术上处于驱动程序级别的自动提交模式），也需要在刷新失败后显式调用[`Session.rollback()`](session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback")，这样可以保持所谓的“子事务”的整体嵌套模式的一致性。[“由于刷新期间发生的先前异常，此会话的事务已被回滚。”（或类似）](../faq/sessions.html#faq-session-rollback)FAQ部分包含了对此行为的更详细描述。
- en: See also
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[“This Session’s transaction has been rolled back due to a previous exception
    during flush.” (or similar)](../faq/sessions.html#faq-session-rollback) - further
    background on why [`Session.rollback()`](session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") must be called when a flush fails.'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '[“由于在刷新期间发生的先前异常，此会话的事务已回滚。”（或类似）](../faq/sessions.html#faq-session-rollback)
    - 关于在刷新失败时为什么必须调用 [`Session.rollback()`](session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") 的更多背景信息。'
- en: '### Get by Primary Key'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '### 按主键获取'
- en: 'As the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    makes use of an [identity map](../glossary.html#term-identity-map) which refers
    to current in-memory objects by primary key, the [`Session.get()`](session_api.html#sqlalchemy.orm.Session.get
    "sqlalchemy.orm.Session.get") method is provided as a means of locating objects
    by primary key, first looking within the current identity map and then querying
    the database for non present values. Such as, to locate a `User` entity with primary
    key identity `(5, )`:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    使用的是一个 [标识映射](../glossary.html#term-identity-map)，它通过主键引用当前内存中的对象，因此 [`Session.get()`](session_api.html#sqlalchemy.orm.Session.get
    "sqlalchemy.orm.Session.get") 方法被提供作为一种通过主键定位对象的方法，首先查找当前标识映射，然后查询数据库以获取不存在的值。例如，要定位具有主键标识
    `(5, )` 的 `User` 实体：
- en: '[PRE57]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The [`Session.get()`](session_api.html#sqlalchemy.orm.Session.get "sqlalchemy.orm.Session.get")
    also includes calling forms for composite primary key values, which may be passed
    as tuples or dictionaries, as well as additional parameters which allow for specific
    loader and execution options. See [`Session.get()`](session_api.html#sqlalchemy.orm.Session.get
    "sqlalchemy.orm.Session.get") for the complete parameter list.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session.get()`](session_api.html#sqlalchemy.orm.Session.get "sqlalchemy.orm.Session.get")
    还包括用于复合主键值的调用形式，可以作为元组或字典传递，以及允许特定加载器和执行选项的附加参数。参见 [`Session.get()`](session_api.html#sqlalchemy.orm.Session.get
    "sqlalchemy.orm.Session.get") 以获取完整的参数列表。'
- en: See also
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`Session.get()`](session_api.html#sqlalchemy.orm.Session.get "sqlalchemy.orm.Session.get")'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session.get()`](session_api.html#sqlalchemy.orm.Session.get "sqlalchemy.orm.Session.get")'
- en: '### Expiring / Refreshing'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '### 过期 / 刷新'
- en: 'An important consideration that will often come up when using the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is that of dealing with the state that is present on
    objects that have been loaded from the database, in terms of keeping them synchronized
    with the current state of the transaction. The SQLAlchemy ORM is based around
    the concept of an [identity map](../glossary.html#term-identity-map) such that
    when an object is “loaded” from a SQL query, there will be a unique Python object
    instance maintained corresponding to a particular database identity. This means
    if we emit two separate queries, each for the same row, and get a mapped object
    back, the two queries will have returned the same Python object:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    时经常会遇到的一个重要考虑因素是处理从数据库加载的对象上存在的状态，以保持它们与事务的当前状态同步。SQLAlchemy ORM 是基于一个 [标识映射](../glossary.html#term-identity-map)
    的概念，即当从 SQL 查询中“加载”对象时，将维护一个与特定数据库标识相对应的唯一 Python 对象实例。这意味着如果我们发出两个单独的查询，每个查询都针对同一行，并获得一个映射对象，则这两个查询将返回相同的
    Python 对象：
- en: '[PRE58]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Following from this, when the ORM gets rows back from a query, it will **skip
    the population of attributes** for an object that’s already loaded. The design
    assumption here is to assume a transaction that’s perfectly isolated, and then
    to the degree that the transaction isn’t isolated, the application can take steps
    on an as-needed basis to refresh objects from the database transaction. The FAQ
    entry at [I’m re-loading data with my Session but it isn’t seeing changes that
    I committed elsewhere](../faq/sessions.html#faq-session-identity) discusses this
    concept in more detail.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 由此可见，当 ORM 从查询中获取行时，它将**跳过已加载对象的属性的填充**。这里的设计假设是假设一个完全隔离的事务，然后根据事务的隔离程度，应用程序可以根据需要采取步骤从数据库事务中刷新对象。[我正在使用我的会话重新加载数据，但它看不到我在其他地方提交的更改](../faq/sessions.html#faq-session-identity)的
    FAQ 条目更详细地讨论了这个概念。
- en: 'When an ORM mapped object is loaded into memory, there are three general ways
    to refresh its contents with new data from the current transaction:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 当将 ORM 映射对象加载到内存中时，有三种常见方法可以使用当前事务的新数据刷新其内容：
- en: '**the expire() method** - the [`Session.expire()`](session_api.html#sqlalchemy.orm.Session.expire
    "sqlalchemy.orm.Session.expire") method will erase the contents of selected or
    all attributes of an object, such that they will be loaded from the database when
    they are next accessed, e.g. using a [lazy loading](../glossary.html#term-lazy-loading)
    pattern:'
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**expire() 方法** - [`Session.expire()`](session_api.html#sqlalchemy.orm.Session.expire
    "sqlalchemy.orm.Session.expire") 方法将擦除对象的选定或所有属性的内容，以便在下次访问时从数据库加载它们，例如使用[延迟加载](../glossary.html#term-lazy-loading)模式：'
- en: '[PRE59]'
  id: totrans-426
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '**the refresh() method** - closely related is the [`Session.refresh()`](session_api.html#sqlalchemy.orm.Session.refresh
    "sqlalchemy.orm.Session.refresh") method, which does everything the [`Session.expire()`](session_api.html#sqlalchemy.orm.Session.expire
    "sqlalchemy.orm.Session.expire") method does but also emits one or more SQL queries
    immediately to actually refresh the contents of the object:'
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**refresh() 方法** - 与之密切相关的是[`Session.refresh()`](session_api.html#sqlalchemy.orm.Session.refresh
    "sqlalchemy.orm.Session.refresh")方法，它执行[`Session.expire()`](session_api.html#sqlalchemy.orm.Session.expire
    "sqlalchemy.orm.Session.expire")方法的所有操作，但还会立即发出一个或多个SQL查询以实际刷新对象的内容：'
- en: '[PRE60]'
  id: totrans-428
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '**the populate_existing() method or execution option** - This is now an execution
    option documented at [Populate Existing](queryguide/api.html#orm-queryguide-populate-existing);
    in legacy form it’s found on the [`Query`](queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object as the [`Query.populate_existing()`](queryguide/query.html#sqlalchemy.orm.Query.populate_existing
    "sqlalchemy.orm.Query.populate_existing") method. This operation in either form
    indicates that objects being returned from a query should be unconditionally re-populated
    from their contents in the database:'
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**populate_existing() 方法或执行选项** - 这现在是一个在[Populate Existing](queryguide/api.html#orm-queryguide-populate-existing)文档中记录的执行选项；在传统形式中，它在[`Query`](queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")对象上作为[`Query.populate_existing()`](queryguide/query.html#sqlalchemy.orm.Query.populate_existing
    "sqlalchemy.orm.Query.populate_existing")方法找到。无论以哪种形式，此操作都表示从查询返回的对象应无条件地从数据库中重新填充：'
- en: '[PRE61]'
  id: totrans-430
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Further discussion on the refresh / expire concept can be found at [Refreshing
    / Expiring](session_state_management.html#session-expire).
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 有关刷新 / 过期概念的进一步讨论，请参阅[刷新 / 过期](session_state_management.html#session-expire)。
- en: See also
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Refreshing / Expiring](session_state_management.html#session-expire)'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '[刷新 / 过期](session_state_management.html#session-expire)'
- en: '[I’m re-loading data with my Session but it isn’t seeing changes that I committed
    elsewhere](../faq/sessions.html#faq-session-identity)'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: '[我正在使用我的Session重新加载数据，但它没有看到我在其他地方提交的更改](../faq/sessions.html#faq-session-identity)'
- en: UPDATE and DELETE with arbitrary WHERE clause
  id: totrans-435
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用任意WHERE子句的UPDATE和DELETE
- en: SQLAlchemy 2.0 includes enhanced capabilities for emitting several varieties
    of ORM-enabled INSERT, UPDATE and DELETE statements. See the document at [ORM-Enabled
    INSERT, UPDATE, and DELETE statements](queryguide/dml.html) for documentation.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 2.0包括增强功能，用于发出几种ORM启用的INSERT、UPDATE和DELETE语句。请参阅[ORM-Enabled INSERT,
    UPDATE, and DELETE statements](queryguide/dml.html)文档。
- en: See also
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[ORM-Enabled INSERT, UPDATE, and DELETE statements](queryguide/dml.html)'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: '[ORM-Enabled INSERT, UPDATE, and DELETE statements](queryguide/dml.html)'
- en: '[ORM UPDATE and DELETE with Custom WHERE Criteria](queryguide/dml.html#orm-queryguide-update-delete-where)'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用自定义WHERE条件的ORM UPDATE和DELETE](queryguide/dml.html#orm-queryguide-update-delete-where)'
- en: '### Auto Begin'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: '### 自动开始'
- en: The [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    object features a behavior known as **autobegin**. This indicates that the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") will internally consider itself to be in a “transactional”
    state as soon as any work is performed with the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), either involving modifications to the internal state
    of the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    with regards to object state changes, or with operations that require database
    connectivity.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")对象具有称为**autobegin**的行为。这表示当使用[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")执行任何工作时，无论涉及修改[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")的内部状态以进行对象状态更改，还是涉及需要数据库连接的操作，[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")将在内部认为自己处于“事务”状态。'
- en: When the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    is first constructed, there’s no transactional state present. The transactional
    state is begun automatically, when a method such as [`Session.add()`](session_api.html#sqlalchemy.orm.Session.add
    "sqlalchemy.orm.Session.add") or [`Session.execute()`](session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") is invoked, or similarly if a [`Query`](queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") is executed to return results (which ultimately uses [`Session.execute()`](session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute")), or if an attribute is modified on a [persistent](../glossary.html#term-persistent)
    object.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 当 [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    第一次被构造时，没有事务状态存在。当调用诸如 [`Session.add()`](session_api.html#sqlalchemy.orm.Session.add
    "sqlalchemy.orm.Session.add") 或 [`Session.execute()`](session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") 这样的方法时，事务状态会自动开始，或者类似地，如果执行 [`Query`](queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") 来返回结果（最终使用 [`Session.execute()`](session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute")），或者如果在 [持久化](../glossary.html#term-persistent)
    对象上修改属性。
- en: The transactional state can be checked by accessing the [`Session.in_transaction()`](session_api.html#sqlalchemy.orm.Session.in_transaction
    "sqlalchemy.orm.Session.in_transaction") method, which returns `True` or `False`
    indicating if the “autobegin” step has proceeded. While not normally needed, the
    [`Session.get_transaction()`](session_api.html#sqlalchemy.orm.Session.get_transaction
    "sqlalchemy.orm.Session.get_transaction") method will return the actual [`SessionTransaction`](session_api.html#sqlalchemy.orm.SessionTransaction
    "sqlalchemy.orm.SessionTransaction") object that represents this transactional
    state.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过访问 [`Session.in_transaction()`](session_api.html#sqlalchemy.orm.Session.in_transaction
    "sqlalchemy.orm.Session.in_transaction") 方法来检查事务状态，该方法返回 `True` 或 `False`，指示“自动开始”步骤是否已执行。虽然通常不需要，但
    [`Session.get_transaction()`](session_api.html#sqlalchemy.orm.Session.get_transaction
    "sqlalchemy.orm.Session.get_transaction") 方法将返回表示此事务状态的实际 [`SessionTransaction`](session_api.html#sqlalchemy.orm.SessionTransaction
    "sqlalchemy.orm.SessionTransaction") 对象。
- en: The transactional state of the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") may also be started explicitly, by invoking the [`Session.begin()`](session_api.html#sqlalchemy.orm.Session.begin
    "sqlalchemy.orm.Session.begin") method. When this method is called, the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is placed into the “transactional” state unconditionally.
    [`Session.begin()`](session_api.html#sqlalchemy.orm.Session.begin "sqlalchemy.orm.Session.begin")
    may be used as a context manager as described at [Framing out a begin / commit
    / rollback block](#session-begin-commit-rollback-block).
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    的事务状态也可以通过显式调用 [`Session.begin()`](session_api.html#sqlalchemy.orm.Session.begin
    "sqlalchemy.orm.Session.begin") 方法来启动。当调用此方法时，[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 无条件地处于“事务”状态。[`Session.begin()`](session_api.html#sqlalchemy.orm.Session.begin
    "sqlalchemy.orm.Session.begin") 可以像 [框架化一个 begin / commit / rollback 块](#session-begin-commit-rollback-block)
    中描述的那样用作上下文管理器。'
- en: '#### Disabling Autobegin to Prevent Implicit Transactions'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 禁用 Autobegin 以防止隐式事务'
- en: 'The “autobegin” behavior may be disabled using the [`Session.autobegin`](session_api.html#sqlalchemy.orm.Session.params.autobegin
    "sqlalchemy.orm.Session") parameter set to `False`. By using this parameter, a
    [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    will require that the [`Session.begin()`](session_api.html#sqlalchemy.orm.Session.begin
    "sqlalchemy.orm.Session.begin") method is called explicitly. Upon construction,
    as well as after any of the [`Session.rollback()`](session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback"), [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit"), or [`Session.close()`](session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") methods are called, the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") won’t implicitly begin any new transactions and will
    raise an error if an attempt to use the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is made without first calling [`Session.begin()`](session_api.html#sqlalchemy.orm.Session.begin
    "sqlalchemy.orm.Session.begin"):'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: “自动开始”行为可以通过将[`Session.autobegin`](session_api.html#sqlalchemy.orm.Session.params.autobegin
    "sqlalchemy.orm.Session")参数设置为`False`来禁用。通过使用此参数，[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")将要求显式调用[`Session.begin()`](session_api.html#sqlalchemy.orm.Session.begin
    "sqlalchemy.orm.Session.begin")方法。在构造时，以及在调用任何[`Session.rollback()`](session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback")、[`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit")或[`Session.close()`](session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close")方法之后，[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")不会隐式开始任何新事务，并且如果尝试在未首先调用[`Session.begin()`](session_api.html#sqlalchemy.orm.Session.begin
    "sqlalchemy.orm.Session.begin")的情况下使用[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")，将会引发错误：
- en: '[PRE62]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'New in version 2.0: Added [`Session.autobegin`](session_api.html#sqlalchemy.orm.Session.params.autobegin
    "sqlalchemy.orm.Session"), allowing “autobegin” behavior to be disabled  ####
    Disabling Autobegin to Prevent Implicit Transactions'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: '新版本 2.0 中：添加了 [`Session.autobegin`](session_api.html#sqlalchemy.orm.Session.params.autobegin
    "sqlalchemy.orm.Session")，允许禁用“自动开始”行为 #### 禁用自动开始以防止隐式事务'
- en: 'The “autobegin” behavior may be disabled using the [`Session.autobegin`](session_api.html#sqlalchemy.orm.Session.params.autobegin
    "sqlalchemy.orm.Session") parameter set to `False`. By using this parameter, a
    [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    will require that the [`Session.begin()`](session_api.html#sqlalchemy.orm.Session.begin
    "sqlalchemy.orm.Session.begin") method is called explicitly. Upon construction,
    as well as after any of the [`Session.rollback()`](session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback"), [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit"), or [`Session.close()`](session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") methods are called, the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") won’t implicitly begin any new transactions and will
    raise an error if an attempt to use the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is made without first calling [`Session.begin()`](session_api.html#sqlalchemy.orm.Session.begin
    "sqlalchemy.orm.Session.begin"):'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: “自动开始”行为可以通过将[`Session.autobegin`](session_api.html#sqlalchemy.orm.Session.params.autobegin
    "sqlalchemy.orm.Session")参数设置为`False`来禁用。通过使用此参数，[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")将要求显式调用[`Session.begin()`](session_api.html#sqlalchemy.orm.Session.begin
    "sqlalchemy.orm.Session.begin")方法。在构造时，以及在调用任何[`Session.rollback()`](session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback")、[`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit")或[`Session.close()`](session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close")方法之后，[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")不会隐式开始任何新事务，并且如果尝试在未首先调用[`Session.begin()`](session_api.html#sqlalchemy.orm.Session.begin
    "sqlalchemy.orm.Session.begin")的情况下使用[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")，将会引发错误：
- en: '[PRE63]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'New in version 2.0: Added [`Session.autobegin`](session_api.html#sqlalchemy.orm.Session.params.autobegin
    "sqlalchemy.orm.Session"), allowing “autobegin” behavior to be disabled'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 新版本 2.0 中：添加了 [`Session.autobegin`](session_api.html#sqlalchemy.orm.Session.params.autobegin
    "sqlalchemy.orm.Session")，允许禁用“自动开始”行为
- en: '### Committing'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: '### 提交'
- en: '[`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit "sqlalchemy.orm.Session.commit")
    is used to commit the current transaction. At its core this indicates that it
    emits `COMMIT` on all current database connections that have a transaction in
    progress; from a [DBAPI](../glossary.html#term-DBAPI) perspective this means the
    `connection.commit()` DBAPI method is invoked on each DBAPI connection.'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit "sqlalchemy.orm.Session.commit")
    用于提交当前事务。在其核心，这表示对所有当前具有正在进行事务的数据库连接发出`COMMIT`；从[DBAPI](../glossary.html#term-DBAPI)的角度来看，这意味着在每个
    DBAPI 连接上调用 `connection.commit()` DBAPI 方法。'
- en: When there is no transaction in place for the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), indicating that no operations were invoked on this
    [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    since the previous call to [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit"), the method will begin and commit an internal-only
    “logical” transaction, that does not normally affect the database unless pending
    flush changes were detected, but will still invoke event handlers and object expiration
    rules.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 当[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")没有处于事务中时，表示自上次调用[`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit")以来，对此[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")没有调用操作，该方法将开始并提交一个仅“逻辑”事务，通常不会影响数据库，除非检测到待定的刷新更改，但仍然会调用事件处理程序和对象过期规则。
- en: The [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit "sqlalchemy.orm.Session.commit")
    operation unconditionally issues [`Session.flush()`](session_api.html#sqlalchemy.orm.Session.flush
    "sqlalchemy.orm.Session.flush") before emitting COMMIT on relevant database connections.
    If no pending changes are detected, then no SQL is emitted to the database. This
    behavior is not configurable and is not affected by the [`Session.autoflush`](session_api.html#sqlalchemy.orm.Session.params.autoflush
    "sqlalchemy.orm.Session") parameter.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit "sqlalchemy.orm.Session.commit")
    操作在发出相关数据库连接的 COMMIT 之前无条件地发出 [`Session.flush()`](session_api.html#sqlalchemy.orm.Session.flush
    "sqlalchemy.orm.Session.flush")。如果未检测到待定更改，则不会向数据库发出 SQL。此行为不可配置，并且不受 [`Session.autoflush`](session_api.html#sqlalchemy.orm.Session.params.autoflush
    "sqlalchemy.orm.Session") 参数的影响。'
- en: Subsequent to that, assuming the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is bound to an [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine"), [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") will then COMMIT the actual database transaction
    that is in place, if one was started. After the commit, the [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") object associated with that transaction is closed,
    causing its underlying DBAPI connection to be [released](../glossary.html#term-released)
    back to the connection pool associated with the [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") to which the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is bound.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，假设[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")绑定到一个[`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine")，则[`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit")将 COMMIT 实际的数据库事务，如果已启动。提交后，与该事务关联的[`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")对象将关闭，导致其底层的 DBAPI 连接被释放回与[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")绑定的[`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine")相关联的连接池。
- en: For a [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    that’s bound to multiple engines (e.g. as described at [Partitioning Strategies](persistence_techniques.html#session-partitioning)),
    the same COMMIT steps will proceed for each [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") / [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") that is in play within the “logical” transaction
    being committed. These database transactions are uncoordinated with each other
    unless [two-phase features](session_transaction.html#session-twophase) are enabled.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 对于绑定到多个引擎（例如在[分区策略](persistence_techniques.html#session-partitioning)中描述的那样）的[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")，相同的COMMIT步骤将为每个在“逻辑”事务中使用的[`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") / [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") 进行。除非启用了[两阶段功能](session_transaction.html#session-twophase)，否则这些数据库事务之间是不协调的。
- en: Other connection-interaction patterns are available as well, by binding the
    [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    to a [`Connection`](../core/connections.html#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    directly; in this case, it’s assumed that an externally-managed transaction is
    present, and a real COMMIT will not be emitted automatically in this case; see
    the section [Joining a Session into an External Transaction (such as for test
    suites)](session_transaction.html#session-external-transaction) for background
    on this pattern.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他的连接交互模式，可以直接将[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")绑定到[`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")上；在这种情况下，假定存在外部管理的事务，并且在这种情况下不会自动发出真正的COMMIT；有关此模式的背景信息，请参见[加入外部事务的会话（例如测试套件）](session_transaction.html#session-external-transaction)一节。
- en: Finally, all objects within the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") are [expired](../glossary.html#term-expired) as the
    transaction is closed out. This is so that when the instances are next accessed,
    either through attribute access or by them being present in the result of a SELECT,
    they receive the most recent state. This behavior may be controlled by the [`Session.expire_on_commit`](session_api.html#sqlalchemy.orm.Session.params.expire_on_commit
    "sqlalchemy.orm.Session") flag, which may be set to `False` when this behavior
    is undesirable.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")内的所有对象在事务关闭时都会被[过期](../glossary.html#term-expired)。这样，在下次访问实例时，无论是通过属性访问还是通过它们存在于SELECT结果中，它们都会接收到最新的状态。此行为可以通过[`Session.expire_on_commit`](session_api.html#sqlalchemy.orm.Session.params.expire_on_commit
    "sqlalchemy.orm.Session")标志来控制，当不希望这种行为时，可以将其设置为`False`。
- en: See also
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Auto Begin](#session-autobegin)'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: '[自动开始](#session-autobegin)'
- en: '### Rolling Back'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: '### 回滚'
- en: '[`Session.rollback()`](session_api.html#sqlalchemy.orm.Session.rollback "sqlalchemy.orm.Session.rollback")
    rolls back the current transaction, if any. When there is no transaction in place,
    the method passes silently.'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session.rollback()`](session_api.html#sqlalchemy.orm.Session.rollback "sqlalchemy.orm.Session.rollback")回滚当前事务（如果有）。当没有事务时，该方法会静默地通过。'
- en: 'With a default configured session, the post-rollback state of the session,
    subsequent to a transaction having been begun either via [autobegin](#session-autobegin)
    or by calling the [`Session.begin()`](session_api.html#sqlalchemy.orm.Session.begin
    "sqlalchemy.orm.Session.begin") method explicitly, is as follows:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 默认配置的会话（session）后，会话的事务回滚状态，其后续是通过[自动开始](#session-autobegin)或显式调用[`Session.begin()`](session_api.html#sqlalchemy.orm.Session.begin
    "sqlalchemy.orm.Session.begin")方法开始事务后的情况如下：
- en: Database transactions are rolled back. For a [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") bound to a single [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine"), this means ROLLBACK is emitted for at most a single
    [`Connection`](../core/connections.html#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    that’s currently in use. For [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") objects bound to multiple [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") objects, ROLLBACK is emitted for all [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") objects that were checked out.
  id: totrans-465
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库事务将被回滚。对于绑定到单个[`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine")的[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")，这意味着针对当前正在使用的最多一个[`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")发出 ROLLBACK。对于绑定到多个[`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine")对象的[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")对象，针对所有被检出的[`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")对象发出 ROLLBACK。
- en: ''
  id: totrans-466
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-467
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Database connections are [released](../glossary.html#term-released). This follows
    the same connection-related behavior noted in [Committing](#session-committing),
    where [`Connection`](../core/connections.html#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    objects obtained from [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") objects are closed, causing the DBAPI connections
    to be [released](../glossary.html#term-released) to the connection pool within
    the [`Engine`](../core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine").
    New connections are checked out from the [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") if and when a new transaction begins.
  id: totrans-468
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库连接将被[释放](../glossary.html#term-released)。这遵循了[提交](#session-committing)中指出的与连接相关的相同行为，其中从[`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine")对象获取的[`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")对象将被关闭，导致DBAPI连接被释放到[`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine")中的连接池中。如果有新的事务开始，则会从[`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine")中检出新连接。
- en: ''
  id: totrans-469
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-470
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: For a [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    that’s bound directly to a [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") as described at [Joining a Session into an External
    Transaction (such as for test suites)](session_transaction.html#session-external-transaction),
    rollback behavior on this [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") would follow the behavior specified by the [`Session.join_transaction_mode`](session_api.html#sqlalchemy.orm.Session.params.join_transaction_mode
    "sqlalchemy.orm.Session") parameter, which could involve rolling back savepoints
    or emitting a real ROLLBACK.
  id: totrans-471
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于直接绑定到[`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")的[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")，如[将会话加入外部事务（比如测试套件）](session_transaction.html#session-external-transaction)，此[`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")上的回滚行为将遵循[`Session.join_transaction_mode`](session_api.html#sqlalchemy.orm.Session.params.join_transaction_mode
    "sqlalchemy.orm.Session")参数指定的行为，这可能涉及回滚保存点或发出真正的 ROLLBACK。
- en: ''
  id: totrans-472
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-473
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Objects which were initially in the [pending](../glossary.html#term-pending)
    state when they were added to the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.session.Session") within the lifespan of the transaction are expunged,
    corresponding to their INSERT statement being rolled back. The state of their
    attributes remains unchanged.
  id: totrans-474
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在事务生命周期内将[挂起](../glossary.html#term-pending)状态的对象从添加到[`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.session.Session")中时的状态是被移除的，对应于其 INSERT 语句的回滚。它们的属性状态保持不变。
- en: ''
  id: totrans-475
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-476
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Objects which were marked as [deleted](../glossary.html#term-deleted) within
    the lifespan of the transaction are promoted back to the [persistent](../glossary.html#term-persistent)
    state, corresponding to their DELETE statement being rolled back. Note that if
    those objects were first [pending](../glossary.html#term-pending) within the transaction,
    that operation takes precedence instead.
  id: totrans-477
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  id: totrans-478
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  id: totrans-479
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: All objects not expunged are fully expired - this is regardless of the [`Session.expire_on_commit`](session_api.html#sqlalchemy.orm.Session.params.expire_on_commit
    "sqlalchemy.orm.Session") setting.
  id: totrans-480
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: With that state understood, the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") may safely continue usage after a rollback occurs.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.4: The [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") object now features deferred “begin” behavior, as described
    in [autobegin](#session-autobegin). If no transaction is begun, methods like [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") and [`Session.rollback()`](session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") have no effect. This behavior would not have
    been observed prior to 1.4 as under non-autocommit mode, a transaction would always
    be implicitly present.'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
- en: When a [`Session.flush()`](session_api.html#sqlalchemy.orm.Session.flush "sqlalchemy.orm.Session.flush")
    fails, typically for reasons like primary key, foreign key, or “not nullable”
    constraint violations, a ROLLBACK is issued automatically (it’s currently not
    possible for a flush to continue after a partial failure). However, the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") goes into a state known as “inactive” at this point,
    and the calling application must always call the [`Session.rollback()`](session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") method explicitly so that the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") can go back into a usable state (it can also be simply
    closed and discarded). See the FAQ entry at [“This Session’s transaction has been
    rolled back due to a previous exception during flush.” (or similar)](../faq/sessions.html#faq-session-rollback)
    for further discussion.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: See also
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: '[Auto Begin](#session-autobegin)'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
- en: '### Closing'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
- en: The [`Session.close()`](session_api.html#sqlalchemy.orm.Session.close "sqlalchemy.orm.Session.close")
    method issues a [`Session.expunge_all()`](session_api.html#sqlalchemy.orm.Session.expunge_all
    "sqlalchemy.orm.Session.expunge_all") which removes all ORM-mapped objects from
    the session, and [releases](../glossary.html#term-releases) any transactional/connection
    resources from the [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") object(s) to which it is bound. When connections are
    returned to the connection pool, transactional state is rolled back as well.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
- en: By default, when the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    is closed, it is essentially in the original state as when it was first constructed,
    and **may be used again**. In this sense, the [`Session.close()`](session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") method is more like a “reset” back to the clean
    state and not as much like a “database close” method. In this mode of operation
    the method [`Session.reset()`](session_api.html#sqlalchemy.orm.Session.reset "sqlalchemy.orm.Session.reset")
    is an alias to [`Session.close()`](session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") and behaves in the same way.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
- en: The default behavior of [`Session.close()`](session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") can be changed by setting the parameter [`Session.close_resets_only`](session_api.html#sqlalchemy.orm.Session.params.close_resets_only
    "sqlalchemy.orm.Session") to `False`, indicating that the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") cannot be reused after the method [`Session.close()`](session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") has been called. In this mode of operation the
    [`Session.reset()`](session_api.html#sqlalchemy.orm.Session.reset "sqlalchemy.orm.Session.reset")
    method will allow multiple “reset” of the session, behaving like [`Session.close()`](session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") when [`Session.close_resets_only`](session_api.html#sqlalchemy.orm.Session.params.close_resets_only
    "sqlalchemy.orm.Session") is set to `True`.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.22.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s recommended that the scope of a [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") be limited by a call to [`Session.close()`](session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") at the end, especially if the [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") or [`Session.rollback()`](session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") methods are not used. The [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") may be used as a context manager to ensure that [`Session.close()`](session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") is called:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Changed in version 1.4: The [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") object features deferred “begin” behavior, as described
    in [autobegin](#session-autobegin). no longer immediately begins a new transaction
    after the [`Session.close()`](session_api.html#sqlalchemy.orm.Session.close "sqlalchemy.orm.Session.close")
    method is called.'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
- en: '## Session Frequently Asked Questions'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
- en: By this point, many users already have questions about sessions. This section
    presents a mini-FAQ (note that we have also a [real FAQ](../faq/index.html)) of
    the most basic issues one is presented with when using a [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session").
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
- en: When do I make a [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker")?
  id: totrans-496
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Just one time, somewhere in your application’s global scope. It should be looked
    upon as part of your application’s configuration. If your application has three
    .py files in a package, you could, for example, place the [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker") line in your `__init__.py` file; from that point
    on your other modules say “from mypackage import Session”. That way, everyone
    else just uses [`Session()`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session"),
    and the configuration of that session is controlled by that central point.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
- en: If your application starts up, does imports, but does not know what database
    it’s going to be connecting to, you can bind the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") at the “class” level to the engine later on, using [`sessionmaker.configure()`](session_api.html#sqlalchemy.orm.sessionmaker.configure
    "sqlalchemy.orm.sessionmaker.configure").
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
- en: In the examples in this section, we will frequently show the [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker") being created right above the line where we actually
    invoke [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session").
    But that’s just for example’s sake! In reality, the [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker") would be somewhere at the module level. The calls
    to instantiate [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    would then be placed at the point in the application where database conversations
    begin.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
- en: '### When do I construct a [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), when do I commit it, and when do I close it?'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
- en: A [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    is typically constructed at the beginning of a logical operation where database
    access is potentially anticipated.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
- en: The [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session"),
    whenever it is used to talk to the database, begins a database transaction as
    soon as it starts communicating. This transaction remains in progress until the
    [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    is rolled back, committed, or closed. The [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") will begin a new transaction if it is used again, subsequent
    to the previous transaction ending; from this it follows that the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is capable of having a lifespan across many transactions,
    though only one at a time. We refer to these two concepts as **transaction scope**
    and **session scope**.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
- en: It’s usually not very hard to determine the best points at which to begin and
    end the scope of a [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session"),
    though the wide variety of application architectures possible can introduce challenging
    situations.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
- en: 'Some sample scenarios include:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
- en: Web applications. In this case, it’s best to make use of the SQLAlchemy integrations
    provided by the web framework in use. Or otherwise, the basic pattern is create
    a [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    at the start of a web request, call the [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") method at the end of web requests that do POST,
    PUT, or DELETE, and then close the session at the end of web request. It’s also
    usually a good idea to set [`Session.expire_on_commit`](session_api.html#sqlalchemy.orm.Session.params.expire_on_commit
    "sqlalchemy.orm.Session") to False so that subsequent access to objects that came
    from a [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    within the view layer do not need to emit new SQL queries to refresh the objects,
    if the transaction has been committed already.
  id: totrans-505
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A background daemon which spawns off child forks would want to create a [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") local to each child process, work with that [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") through the life of the “job” that the fork is handling,
    then tear it down when the job is completed.
  id: totrans-506
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a command-line script, the application would create a single, global [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") that is established when the program begins to do its
    work, and commits it right as the program is completing its task.
  id: totrans-507
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a GUI interface-driven application, the scope of the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") may best be within the scope of a user-generated event,
    such as a button push. Or, the scope may correspond to explicit user interaction,
    such as the user “opening” a series of records, then “saving” them.
  id: totrans-508
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a general rule, the application should manage the lifecycle of the session
    *externally* to functions that deal with specific data. This is a fundamental
    separation of concerns which keeps data-specific operations agnostic of the context
    in which they access and manipulate that data.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
- en: 'E.g. **don’t do this**:'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Keep the lifecycle of the session (and usually the transaction) **separate
    and external**. The example below illustrates how this might look, and additionally
    makes use of a Python context manager (i.e. the `with:` keyword) in order to manage
    the scope of the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    and its transaction automatically:'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Changed in version 1.4: The [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") may be used as a context manager without the use of
    external helper functions.'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
- en: Is the Session a cache?
  id: totrans-515
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Yeee…no. It’s somewhat used as a cache, in that it implements the [identity
    map](../glossary.html#term-identity-map) pattern, and stores objects keyed to
    their primary key. However, it doesn’t do any kind of query caching. This means,
    if you say `session.scalars(select(Foo).filter_by(name='bar'))`, even if `Foo(name='bar')`
    is right there, in the identity map, the session has no idea about that. It has
    to issue SQL to the database, get the rows back, and then when it sees the primary
    key in the row, *then* it can look in the local identity map and see that the
    object is already there. It’s only when you say `query.get({some primary key})`
    that the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.session.Session")
    doesn’t have to issue a query.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, the Session stores object instances using a weak reference by
    default. This also defeats the purpose of using the Session as a cache.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
- en: The [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    is not designed to be a global object from which everyone consults as a “registry”
    of objects. That’s more the job of a **second level cache**. SQLAlchemy provides
    a pattern for implementing second level caching using [dogpile.cache](https://dogpilecache.readthedocs.io/),
    via the [Dogpile Caching](examples.html#examples-caching) example.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
- en: How can I get the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.session.Session")
    for a certain object?
  id: totrans-519
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Use the [`Session.object_session()`](session_api.html#sqlalchemy.orm.Session.object_session
    "sqlalchemy.orm.Session.object_session") classmethod available on [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.session.Session"):'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The newer [Runtime Inspection API](../core/inspection.html) system can also
    be used:'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '### Is the Session thread-safe? Is AsyncSession safe to share in concurrent
    tasks?'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
- en: The [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    is a **mutable, stateful** object that represents a **single database transaction**.
    An instance of [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    therefore **cannot be shared among concurrent threads or asyncio tasks without
    careful synchronization**. The [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is intended to be used in a **non-concurrent** fashion,
    that is, a particular instance of [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") should be used in only one thread or task at a time.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
- en: When using the [`AsyncSession`](extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession
    "sqlalchemy.ext.asyncio.AsyncSession") object from SQLAlchemy’s [asyncio](extensions/asyncio.html)
    extension, this object is only a thin proxy on top of a [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), and the same rules apply; it is an **unsynchronized,
    mutable, stateful object**, so it is **not** safe to use a single instance of
    [`AsyncSession`](extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession "sqlalchemy.ext.asyncio.AsyncSession")
    in multiple asyncio tasks at once.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
- en: An instance of [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    or [`AsyncSession`](extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession
    "sqlalchemy.ext.asyncio.AsyncSession") represents a single logical database transaction,
    referencing only a single [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") at a time for a particular [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") or [`AsyncEngine`](extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncEngine
    "sqlalchemy.ext.asyncio.AsyncEngine") to which the object is bound (note that
    these objects both support being bound to multiple engines at once, however in
    this case there will still be only one connection per engine in play within the
    scope of a transaction).
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
- en: A database connection within a transaction is also a stateful object that is
    intended to be operated upon in a non-concurrent, sequential fashion. Commands
    are issued on the connection in a sequence, which are handled by the database
    server in the exact order in which they are emitted. As the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") emits commands upon this connection and receives results,
    the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    itself is transitioning through internal state changes that align with the state
    of commands and data present on this connection; states which include if a transaction
    were begun, committed, or rolled back, what SAVEPOINTs if any are in play, as
    well as fine-grained synchronization of the state of individual database rows
    with local ORM-mapped objects.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
- en: When designing database applications for concurrency, the appropriate model
    is that each concurrent task / thread works with its own database transaction.
    This is why when discussing the issue of database concurrency, the standard terminology
    used is **multiple, concurrent transactions**. Within traditional RDMS there is
    no analogue for a single database transaction that is receiving and processing
    multiple commands concurrently.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
- en: The concurrency model for SQLAlchemy’s [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") and [`AsyncSession`](extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession
    "sqlalchemy.ext.asyncio.AsyncSession") is therefore **Session per thread, AsyncSession
    per task**. An application that uses multiple threads, or multiple tasks in asyncio
    such as when using an API like `asyncio.gather()` would want to ensure that each
    thread has its own [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session"),
    each asyncio task has its own [`AsyncSession`](extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession
    "sqlalchemy.ext.asyncio.AsyncSession").
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
- en: The best way to ensure this use is by using the [standard context manager pattern](#session-getting)
    locally within the top level Python function that is inside the thread or task,
    which will ensure the lifespan of the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") or [`AsyncSession`](extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession
    "sqlalchemy.ext.asyncio.AsyncSession") is maintained within a local scope.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
- en: For applications that benefit from having a “global” [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") where it’s not an option to pass the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") object to specific functions and methods which require
    it, the [`scoped_session`](contextual.html#sqlalchemy.orm.scoped_session "sqlalchemy.orm.scoped_session")
    approach can provide for a “thread local” [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") object; see the section [Contextual/Thread-local Sessions](contextual.html#unitofwork-contextual)
    for background. Within the asyncio context, the [`async_scoped_session`](extensions/asyncio.html#sqlalchemy.ext.asyncio.async_scoped_session
    "sqlalchemy.ext.asyncio.async_scoped_session") object is the asyncio analogue
    for [`scoped_session`](contextual.html#sqlalchemy.orm.scoped_session "sqlalchemy.orm.scoped_session"),
    however is more challenging to configure as it requires a custom “context” function.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
- en: When do I make a [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker")?
  id: totrans-533
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Just one time, somewhere in your application’s global scope. It should be looked
    upon as part of your application’s configuration. If your application has three
    .py files in a package, you could, for example, place the [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker") line in your `__init__.py` file; from that point
    on your other modules say “from mypackage import Session”. That way, everyone
    else just uses [`Session()`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session"),
    and the configuration of that session is controlled by that central point.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
- en: If your application starts up, does imports, but does not know what database
    it’s going to be connecting to, you can bind the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") at the “class” level to the engine later on, using [`sessionmaker.configure()`](session_api.html#sqlalchemy.orm.sessionmaker.configure
    "sqlalchemy.orm.sessionmaker.configure").
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
- en: In the examples in this section, we will frequently show the [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker") being created right above the line where we actually
    invoke [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session").
    But that’s just for example’s sake! In reality, the [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker") would be somewhere at the module level. The calls
    to instantiate [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    would then be placed at the point in the application where database conversations
    begin.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
- en: '### When do I construct a [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), when do I commit it, and when do I close it?'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
- en: A [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    is typically constructed at the beginning of a logical operation where database
    access is potentially anticipated.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
- en: The [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session"),
    whenever it is used to talk to the database, begins a database transaction as
    soon as it starts communicating. This transaction remains in progress until the
    [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    is rolled back, committed, or closed. The [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") will begin a new transaction if it is used again, subsequent
    to the previous transaction ending; from this it follows that the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is capable of having a lifespan across many transactions,
    though only one at a time. We refer to these two concepts as **transaction scope**
    and **session scope**.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
- en: It’s usually not very hard to determine the best points at which to begin and
    end the scope of a [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session"),
    though the wide variety of application architectures possible can introduce challenging
    situations.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
- en: 'Some sample scenarios include:'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
- en: Web applications. In this case, it’s best to make use of the SQLAlchemy integrations
    provided by the web framework in use. Or otherwise, the basic pattern is create
    a [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    at the start of a web request, call the [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") method at the end of web requests that do POST,
    PUT, or DELETE, and then close the session at the end of web request. It’s also
    usually a good idea to set [`Session.expire_on_commit`](session_api.html#sqlalchemy.orm.Session.params.expire_on_commit
    "sqlalchemy.orm.Session") to False so that subsequent access to objects that came
    from a [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    within the view layer do not need to emit new SQL queries to refresh the objects,
    if the transaction has been committed already.
  id: totrans-542
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A background daemon which spawns off child forks would want to create a [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") local to each child process, work with that [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") through the life of the “job” that the fork is handling,
    then tear it down when the job is completed.
  id: totrans-543
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a command-line script, the application would create a single, global [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") that is established when the program begins to do its
    work, and commits it right as the program is completing its task.
  id: totrans-544
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a GUI interface-driven application, the scope of the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") may best be within the scope of a user-generated event,
    such as a button push. Or, the scope may correspond to explicit user interaction,
    such as the user “opening” a series of records, then “saving” them.
  id: totrans-545
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a general rule, the application should manage the lifecycle of the session
    *externally* to functions that deal with specific data. This is a fundamental
    separation of concerns which keeps data-specific operations agnostic of the context
    in which they access and manipulate that data.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
- en: 'E.g. **don’t do this**:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Keep the lifecycle of the session (and usually the transaction) **separate
    and external**. The example below illustrates how this might look, and additionally
    makes use of a Python context manager (i.e. the `with:` keyword) in order to manage
    the scope of the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    and its transaction automatically:'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Changed in version 1.4: The [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") may be used as a context manager without the use of
    external helper functions.'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
- en: Is the Session a cache?
  id: totrans-552
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Yeee…no. It’s somewhat used as a cache, in that it implements the [identity
    map](../glossary.html#term-identity-map) pattern, and stores objects keyed to
    their primary key. However, it doesn’t do any kind of query caching. This means,
    if you say `session.scalars(select(Foo).filter_by(name='bar'))`, even if `Foo(name='bar')`
    is right there, in the identity map, the session has no idea about that. It has
    to issue SQL to the database, get the rows back, and then when it sees the primary
    key in the row, *then* it can look in the local identity map and see that the
    object is already there. It’s only when you say `query.get({some primary key})`
    that the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.session.Session")
    doesn’t have to issue a query.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, the Session stores object instances using a weak reference by
    default. This also defeats the purpose of using the Session as a cache.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
- en: The [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    is not designed to be a global object from which everyone consults as a “registry”
    of objects. That’s more the job of a **second level cache**. SQLAlchemy provides
    a pattern for implementing second level caching using [dogpile.cache](https://dogpilecache.readthedocs.io/),
    via the [Dogpile Caching](examples.html#examples-caching) example.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
- en: How can I get the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.session.Session")
    for a certain object?
  id: totrans-556
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Use the [`Session.object_session()`](session_api.html#sqlalchemy.orm.Session.object_session
    "sqlalchemy.orm.Session.object_session") classmethod available on [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.session.Session"):'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'The newer [Runtime Inspection API](../core/inspection.html) system can also
    be used:'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '### Is the Session thread-safe? Is AsyncSession safe to share in concurrent
    tasks?'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
- en: The [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    is a **mutable, stateful** object that represents a **single database transaction**.
    An instance of [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    therefore **cannot be shared among concurrent threads or asyncio tasks without
    careful synchronization**. The [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is intended to be used in a **non-concurrent** fashion,
    that is, a particular instance of [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") should be used in only one thread or task at a time.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
- en: When using the [`AsyncSession`](extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession
    "sqlalchemy.ext.asyncio.AsyncSession") object from SQLAlchemy’s [asyncio](extensions/asyncio.html)
    extension, this object is only a thin proxy on top of a [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), and the same rules apply; it is an **unsynchronized,
    mutable, stateful object**, so it is **not** safe to use a single instance of
    [`AsyncSession`](extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession "sqlalchemy.ext.asyncio.AsyncSession")
    in multiple asyncio tasks at once.
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
- en: An instance of [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    or [`AsyncSession`](extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession
    "sqlalchemy.ext.asyncio.AsyncSession") represents a single logical database transaction,
    referencing only a single [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") at a time for a particular [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") or [`AsyncEngine`](extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncEngine
    "sqlalchemy.ext.asyncio.AsyncEngine") to which the object is bound (note that
    these objects both support being bound to multiple engines at once, however in
    this case there will still be only one connection per engine in play within the
    scope of a transaction).
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
- en: A database connection within a transaction is also a stateful object that is
    intended to be operated upon in a non-concurrent, sequential fashion. Commands
    are issued on the connection in a sequence, which are handled by the database
    server in the exact order in which they are emitted. As the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") emits commands upon this connection and receives results,
    the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    itself is transitioning through internal state changes that align with the state
    of commands and data present on this connection; states which include if a transaction
    were begun, committed, or rolled back, what SAVEPOINTs if any are in play, as
    well as fine-grained synchronization of the state of individual database rows
    with local ORM-mapped objects.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
- en: When designing database applications for concurrency, the appropriate model
    is that each concurrent task / thread works with its own database transaction.
    This is why when discussing the issue of database concurrency, the standard terminology
    used is **multiple, concurrent transactions**. Within traditional RDMS there is
    no analogue for a single database transaction that is receiving and processing
    multiple commands concurrently.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
- en: The concurrency model for SQLAlchemy’s [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") and [`AsyncSession`](extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession
    "sqlalchemy.ext.asyncio.AsyncSession") is therefore **Session per thread, AsyncSession
    per task**. An application that uses multiple threads, or multiple tasks in asyncio
    such as when using an API like `asyncio.gather()` would want to ensure that each
    thread has its own [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session"),
    each asyncio task has its own [`AsyncSession`](extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession
    "sqlalchemy.ext.asyncio.AsyncSession").
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
- en: The best way to ensure this use is by using the [standard context manager pattern](#session-getting)
    locally within the top level Python function that is inside the thread or task,
    which will ensure the lifespan of the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") or [`AsyncSession`](extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession
    "sqlalchemy.ext.asyncio.AsyncSession") is maintained within a local scope.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
- en: For applications that benefit from having a “global” [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") where it’s not an option to pass the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") object to specific functions and methods which require
    it, the [`scoped_session`](contextual.html#sqlalchemy.orm.scoped_session "sqlalchemy.orm.scoped_session")
    approach can provide for a “thread local” [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") object; see the section [Contextual/Thread-local Sessions](contextual.html#unitofwork-contextual)
    for background. Within the asyncio context, the [`async_scoped_session`](extensions/asyncio.html#sqlalchemy.ext.asyncio.async_scoped_session
    "sqlalchemy.ext.asyncio.async_scoped_session") object is the asyncio analogue
    for [`scoped_session`](contextual.html#sqlalchemy.orm.scoped_session "sqlalchemy.orm.scoped_session"),
    however is more challenging to configure as it requires a custom “context” function.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
