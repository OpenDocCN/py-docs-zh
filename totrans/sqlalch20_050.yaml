- en: Session Basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.sqlalchemy.org/en/20/orm/session_basics.html](https://docs.sqlalchemy.org/en/20/orm/session_basics.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: What does the Session do ?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the most general sense, the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") establishes all conversations with the database and
    represents a “holding zone” for all the objects which you’ve loaded or associated
    with it during its lifespan. It provides the interface where SELECT and other
    queries are made that will return and modify ORM-mapped objects. The ORM objects
    themselves are maintained inside the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), inside a structure called the [identity map](../glossary.html#term-identity-map)
    - a data structure that maintains unique copies of each object, where “unique”
    means “only one object with a particular primary key”.
  prefs: []
  type: TYPE_NORMAL
- en: The [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    in its most common pattern of use begins in a mostly stateless form. Once queries
    are issued or other objects are persisted with it, it requests a connection resource
    from an [`Engine`](../core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    that is associated with the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), and then establishes a transaction on that connection.
    This transaction remains in effect until the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is instructed to commit or roll back the transaction.
    When the transaction ends, the connection resource associated with the [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") is [released](../glossary.html#term-released) to the
    connection pool managed by the engine. A new transaction then starts with a new
    connection checkout.
  prefs: []
  type: TYPE_NORMAL
- en: The ORM objects maintained by a [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") are [instrumented](../glossary.html#term-instrumented)
    such that whenever an attribute or a collection is modified in the Python program,
    a change event is generated which is recorded by the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"). Whenever the database is about to be queried, or when
    the transaction is about to be committed, the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") first **flushes** all pending changes stored in memory
    to the database. This is known as the [unit of work](../glossary.html#term-unit-of-work)
    pattern.
  prefs: []
  type: TYPE_NORMAL
- en: When using a [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session"),
    it’s useful to consider the ORM mapped objects that it maintains as **proxy objects**
    to database rows, which are local to the transaction being held by the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"). In order to maintain the state on the objects as matching
    what’s actually in the database, there are a variety of events that will cause
    objects to re-access the database in order to keep synchronized. It is possible
    to “detach” objects from a [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), and to continue using them, though this practice has
    its caveats. It’s intended that usually, you’d re-associate detached objects with
    another [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    when you want to work with them again, so that they can resume their normal task
    of representing database state.
  prefs: []
  type: TYPE_NORMAL
- en: '## Basics of Using a Session'
  prefs: []
  type: TYPE_NORMAL
- en: The most basic [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    use patterns are presented here.
  prefs: []
  type: TYPE_NORMAL
- en: '### Opening and Closing a Session'
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    may be constructed on its own or by using the [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker") class. It typically is passed a single [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") as a source of connectivity up front. A typical use
    may look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Above, the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    is instantiated with an [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") associated with a particular database URL. It is then
    used in a Python context manager (i.e. `with:` statement) so that it is automatically
    closed at the end of the block; this is equivalent to calling the [`Session.close()`](session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") method.
  prefs: []
  type: TYPE_NORMAL
- en: The call to [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") is optional, and is only needed if the work we’ve
    done with the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    includes new data to be persisted to the database. If we were only issuing SELECT
    calls and did not need to write any changes, then the call to [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") would be unnecessary.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that after [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") is called, either explicitly or when using a
    context manager, all objects associated with the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") are [expired](../glossary.html#term-expired), meaning
    their contents are erased to be re-loaded within the next transaction. If these
    objects are instead [detached](../glossary.html#term-detached), they will be non-functional
    until re-associated with a new [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), unless the [`Session.expire_on_commit`](session_api.html#sqlalchemy.orm.Session.params.expire_on_commit
    "sqlalchemy.orm.Session") parameter is used to disable this behavior. See the
    section [Committing](#session-committing) for more detail.  ### Framing out a
    begin / commit / rollback block'
  prefs: []
  type: TYPE_NORMAL
- en: 'We may also enclose the [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") call and the overall “framing” of the transaction
    within a context manager for those cases where we will be committing data to the
    database. By “framing” we mean that if all operations succeed, the [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") method will be called, but if any exceptions
    are raised, the [`Session.rollback()`](session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") method will be called so that the transaction
    is rolled back immediately, before propagating the exception outward. In Python
    this is most fundamentally expressed using a `try: / except: / else:` block such
    as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The long-form sequence of operations illustrated above can be achieved more
    succinctly by making use of the [`SessionTransaction`](session_api.html#sqlalchemy.orm.SessionTransaction
    "sqlalchemy.orm.SessionTransaction") object returned by the [`Session.begin()`](session_api.html#sqlalchemy.orm.Session.begin
    "sqlalchemy.orm.Session.begin") method, which provides a context manager interface
    for the same sequence of operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'More succinctly, the two contexts may be combined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Using a sessionmaker
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The purpose of [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker") is to provide a factory for [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") objects with a fixed configuration. As it is typical
    that an application will have an [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") object in module scope, the [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker") can provide a factory for [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") objects that are against this engine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker "sqlalchemy.orm.sessionmaker")
    is analogous to the [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") as a module-level factory for function-level sessions
    / connections. As such it also has its own [`sessionmaker.begin()`](session_api.html#sqlalchemy.orm.sessionmaker.begin
    "sqlalchemy.orm.sessionmaker.begin") method, analogous to [`Engine.begin()`](../core/connections.html#sqlalchemy.engine.Engine.begin
    "sqlalchemy.engine.Engine.begin"), which returns a [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") object and also maintains a begin/commit/rollback block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Where above, the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    will both have its transaction committed as well as that the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") will be closed, when the above `with:` block ends.
  prefs: []
  type: TYPE_NORMAL
- en: When you write your application, the [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker") factory should be scoped the same as the [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") object created by [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine"), which is typically at module-level or global scope.
    As these objects are both factories, they can be used by any number of functions
    and threads simultaneously.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker "sqlalchemy.orm.sessionmaker")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")'
  prefs: []
  type: TYPE_NORMAL
- en: '### Querying'
  prefs: []
  type: TYPE_NORMAL
- en: The primary means of querying is to make use of the [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") construct to create a [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") object, which is then executed to return a
    result using methods such as [`Session.execute()`](session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") and [`Session.scalars()`](session_api.html#sqlalchemy.orm.Session.scalars
    "sqlalchemy.orm.Session.scalars"). Results are then returned in terms of [`Result`](../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") objects, including sub-variants such as [`ScalarResult`](../core/connections.html#sqlalchemy.engine.ScalarResult
    "sqlalchemy.engine.ScalarResult").
  prefs: []
  type: TYPE_NORMAL
- en: 'A complete guide to SQLAlchemy ORM querying can be found at [ORM Querying Guide](queryguide/index.html).
    Some brief examples follow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Changed in version 2.0: “2.0” style querying is now standard. See [2.0 Migration
    - ORM Usage](../changelog/migration_20.html#migration-20-query-usage) for migration
    notes from the 1.x series.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[ORM Querying Guide](queryguide/index.html)  ### Adding New or Existing Items'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Session.add()`](session_api.html#sqlalchemy.orm.Session.add "sqlalchemy.orm.Session.add")
    is used to place instances in the session. For [transient](../glossary.html#term-transient)
    (i.e. brand new) instances, this will have the effect of an INSERT taking place
    for those instances upon the next flush. For instances which are [persistent](../glossary.html#term-persistent)
    (i.e. were loaded by this session), they are already present and do not need to
    be added. Instances which are [detached](../glossary.html#term-detached) (i.e.
    have been removed from a session) may be re-associated with a session using this
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'To add a list of items to the session at once, use [`Session.add_all()`](session_api.html#sqlalchemy.orm.Session.add_all
    "sqlalchemy.orm.Session.add_all"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The [`Session.add()`](session_api.html#sqlalchemy.orm.Session.add "sqlalchemy.orm.Session.add")
    operation **cascades** along the `save-update` cascade. For more details see the
    section [Cascades](cascades.html#unitofwork-cascades).  ### Deleting'
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`Session.delete()`](session_api.html#sqlalchemy.orm.Session.delete "sqlalchemy.orm.Session.delete")
    method places an instance into the Session’s list of objects to be marked as deleted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[`Session.delete()`](session_api.html#sqlalchemy.orm.Session.delete "sqlalchemy.orm.Session.delete")
    marks an object for deletion, which will result in a DELETE statement emitted
    for each primary key affected. Before the pending deletes are flushed, objects
    marked by “delete” are present in the [`Session.deleted`](session_api.html#sqlalchemy.orm.Session.deleted
    "sqlalchemy.orm.Session.deleted") collection. After the DELETE, they are expunged
    from the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session"),
    which becomes permanent after the transaction is committed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are various important behaviors related to the [`Session.delete()`](session_api.html#sqlalchemy.orm.Session.delete
    "sqlalchemy.orm.Session.delete") operation, particularly in how relationships
    to other objects and collections are handled. There’s more information on how
    this works in the section [Cascades](cascades.html#unitofwork-cascades), but in
    general the rules are:'
  prefs: []
  type: TYPE_NORMAL
- en: Rows that correspond to mapped objects that are related to a deleted object
    via the [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")
    directive are **not deleted by default**. If those objects have a foreign key
    constraint back to the row being deleted, those columns are set to NULL. This
    will cause a constraint violation if the columns are non-nullable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To change the “SET NULL” into a DELETE of a related object’s row, use the [delete](cascades.html#cascade-delete)
    cascade on the [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship").
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rows that are in tables linked as “many-to-many” tables, via the [`relationship.secondary`](relationship_api.html#sqlalchemy.orm.relationship.params.secondary
    "sqlalchemy.orm.relationship") parameter, **are** deleted in all cases when the
    object they refer to is deleted.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When related objects include a foreign key constraint back to the object being
    deleted, and the related collections to which they belong are not currently loaded
    into memory, the unit of work will emit a SELECT to fetch all related rows, so
    that their primary key values can be used to emit either UPDATE or DELETE statements
    on those related rows. In this way, the ORM without further instruction will perform
    the function of ON DELETE CASCADE, even if this is configured on Core [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [`relationship.passive_deletes`](relationship_api.html#sqlalchemy.orm.relationship.params.passive_deletes
    "sqlalchemy.orm.relationship") parameter can be used to tune this behavior and
    rely upon “ON DELETE CASCADE” more naturally; when set to True, this SELECT operation
    will no longer take place, however rows that are locally present will still be
    subject to explicit SET NULL or DELETE. Setting [`relationship.passive_deletes`](relationship_api.html#sqlalchemy.orm.relationship.params.passive_deletes
    "sqlalchemy.orm.relationship") to the string `"all"` will disable **all** related
    object update/delete.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the DELETE occurs for an object marked for deletion, the object is not
    automatically removed from collections or object references that refer to it.
    When the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    is expired, these collections may be loaded again so that the object is no longer
    present. However, it is preferable that instead of using [`Session.delete()`](session_api.html#sqlalchemy.orm.Session.delete
    "sqlalchemy.orm.Session.delete") for these objects, the object should instead
    be removed from its collection and then [delete-orphan](cascades.html#cascade-delete-orphan)
    should be used so that it is deleted as a secondary effect of that collection
    removal. See the section [Notes on Delete - Deleting Objects Referenced from Collections
    and Scalar Relationships](cascades.html#session-deleting-from-collections) for
    an example of this.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[delete](cascades.html#cascade-delete) - describes “delete cascade”, which
    marks related objects for deletion when a lead object is deleted.'
  prefs: []
  type: TYPE_NORMAL
- en: '[delete-orphan](cascades.html#cascade-delete-orphan) - describes “delete orphan
    cascade”, which marks related objects for deletion when they are de-associated
    from their lead object.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Notes on Delete - Deleting Objects Referenced from Collections and Scalar
    Relationships](cascades.html#session-deleting-from-collections) - important background
    on [`Session.delete()`](session_api.html#sqlalchemy.orm.Session.delete "sqlalchemy.orm.Session.delete")
    as involves relationships being refreshed in memory.  ### Flushing'
  prefs: []
  type: TYPE_NORMAL
- en: When the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.session.Session")
    is used with its default configuration, the flush step is nearly always done transparently.
    Specifically, the flush occurs before any individual SQL statement is issued as
    a result of a [`Query`](queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    or a [2.0-style](../glossary.html#term-1) [`Session.execute()`](session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") call, as well as within the [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") call before the transaction is committed. It
    also occurs before a SAVEPOINT is issued when [`Session.begin_nested()`](session_api.html#sqlalchemy.orm.Session.begin_nested
    "sqlalchemy.orm.Session.begin_nested") is used.
  prefs: []
  type: TYPE_NORMAL
- en: 'A [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    flush can be forced at any time by calling the [`Session.flush()`](session_api.html#sqlalchemy.orm.Session.flush
    "sqlalchemy.orm.Session.flush") method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The flush which occurs automatically within the scope of certain methods is
    known as **autoflush**. Autoflush is defined as a configurable, automatic flush
    call which occurs at the beginning of methods including:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Session.execute()`](session_api.html#sqlalchemy.orm.Session.execute "sqlalchemy.orm.Session.execute")
    and other SQL-executing methods, when used against ORM-enabled SQL constructs,
    such as [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") objects that refer to ORM entities and/or
    ORM-mapped attributes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a [`Query`](queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    is invoked to send SQL to the database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Within the [`Session.merge()`](session_api.html#sqlalchemy.orm.Session.merge
    "sqlalchemy.orm.Session.merge") method before querying the database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When objects are [refreshed](#session-expiring)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When ORM [lazy load](../glossary.html#term-lazy-load) operations occur against
    unloaded object attributes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are also points at which flushes occur **unconditionally**; these points
    are within key transactional boundaries which include:'
  prefs: []
  type: TYPE_NORMAL
- en: Within the process of the [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When [`Session.begin_nested()`](session_api.html#sqlalchemy.orm.Session.begin_nested
    "sqlalchemy.orm.Session.begin_nested") is called
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the [`Session.prepare()`](session_api.html#sqlalchemy.orm.Session.prepare
    "sqlalchemy.orm.Session.prepare") 2PC method is used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The **autoflush** behavior, as applied to the previous list of items, can be
    disabled by constructing a [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") or [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker") passing the [`Session.autoflush`](session_api.html#sqlalchemy.orm.Session.params.autoflush
    "sqlalchemy.orm.Session") parameter as `False`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, autoflush can be temporarily disabled within the flow of using
    a [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    using the [`Session.no_autoflush`](session_api.html#sqlalchemy.orm.Session.no_autoflush
    "sqlalchemy.orm.Session.no_autoflush") context manager:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '**To reiterate:** The flush process **always occurs** when transactional methods
    such as [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit "sqlalchemy.orm.Session.commit")
    and [`Session.begin_nested()`](session_api.html#sqlalchemy.orm.Session.begin_nested
    "sqlalchemy.orm.Session.begin_nested") are called, regardless of any “autoflush”
    settings, when the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    has remaining pending changes to process.'
  prefs: []
  type: TYPE_NORMAL
- en: As the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    only invokes SQL to the database within the context of a [DBAPI](../glossary.html#term-DBAPI)
    transaction, all “flush” operations themselves only occur within a database transaction
    (subject to the [isolation level](session_transaction.html#session-transaction-isolation)
    of the database transaction), provided that the DBAPI is not in [driver level
    autocommit](../core/connections.html#dbapi-autocommit) mode. This means that assuming
    the database connection is providing for [atomicity](../glossary.html#term-atomicity)
    within its transactional settings, if any individual DML statement inside the
    flush fails, the entire operation will be rolled back.
  prefs: []
  type: TYPE_NORMAL
- en: When a failure occurs within a flush, in order to continue using that same [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), an explicit call to [`Session.rollback()`](session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") is required after a flush fails, even though
    the underlying transaction will have been rolled back already (even if the database
    driver is technically in driver-level autocommit mode). This is so that the overall
    nesting pattern of so-called “subtransactions” is consistently maintained. The
    FAQ section [“This Session’s transaction has been rolled back due to a previous
    exception during flush.” (or similar)](../faq/sessions.html#faq-session-rollback)
    contains a more detailed description of this behavior.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[“This Session’s transaction has been rolled back due to a previous exception
    during flush.” (or similar)](../faq/sessions.html#faq-session-rollback) - further
    background on why [`Session.rollback()`](session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") must be called when a flush fails.  ### Get
    by Primary Key'
  prefs: []
  type: TYPE_NORMAL
- en: 'As the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    makes use of an [identity map](../glossary.html#term-identity-map) which refers
    to current in-memory objects by primary key, the [`Session.get()`](session_api.html#sqlalchemy.orm.Session.get
    "sqlalchemy.orm.Session.get") method is provided as a means of locating objects
    by primary key, first looking within the current identity map and then querying
    the database for non present values. Such as, to locate a `User` entity with primary
    key identity `(5, )`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The [`Session.get()`](session_api.html#sqlalchemy.orm.Session.get "sqlalchemy.orm.Session.get")
    also includes calling forms for composite primary key values, which may be passed
    as tuples or dictionaries, as well as additional parameters which allow for specific
    loader and execution options. See [`Session.get()`](session_api.html#sqlalchemy.orm.Session.get
    "sqlalchemy.orm.Session.get") for the complete parameter list.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Session.get()`](session_api.html#sqlalchemy.orm.Session.get "sqlalchemy.orm.Session.get")  ###
    Expiring / Refreshing'
  prefs: []
  type: TYPE_NORMAL
- en: 'An important consideration that will often come up when using the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is that of dealing with the state that is present on
    objects that have been loaded from the database, in terms of keeping them synchronized
    with the current state of the transaction. The SQLAlchemy ORM is based around
    the concept of an [identity map](../glossary.html#term-identity-map) such that
    when an object is “loaded” from a SQL query, there will be a unique Python object
    instance maintained corresponding to a particular database identity. This means
    if we emit two separate queries, each for the same row, and get a mapped object
    back, the two queries will have returned the same Python object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Following from this, when the ORM gets rows back from a query, it will **skip
    the population of attributes** for an object that’s already loaded. The design
    assumption here is to assume a transaction that’s perfectly isolated, and then
    to the degree that the transaction isn’t isolated, the application can take steps
    on an as-needed basis to refresh objects from the database transaction. The FAQ
    entry at [I’m re-loading data with my Session but it isn’t seeing changes that
    I committed elsewhere](../faq/sessions.html#faq-session-identity) discusses this
    concept in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'When an ORM mapped object is loaded into memory, there are three general ways
    to refresh its contents with new data from the current transaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '**the expire() method** - the [`Session.expire()`](session_api.html#sqlalchemy.orm.Session.expire
    "sqlalchemy.orm.Session.expire") method will erase the contents of selected or
    all attributes of an object, such that they will be loaded from the database when
    they are next accessed, e.g. using a [lazy loading](../glossary.html#term-lazy-loading)
    pattern:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**the refresh() method** - closely related is the [`Session.refresh()`](session_api.html#sqlalchemy.orm.Session.refresh
    "sqlalchemy.orm.Session.refresh") method, which does everything the [`Session.expire()`](session_api.html#sqlalchemy.orm.Session.expire
    "sqlalchemy.orm.Session.expire") method does but also emits one or more SQL queries
    immediately to actually refresh the contents of the object:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**the populate_existing() method or execution option** - This is now an execution
    option documented at [Populate Existing](queryguide/api.html#orm-queryguide-populate-existing);
    in legacy form it’s found on the [`Query`](queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object as the [`Query.populate_existing()`](queryguide/query.html#sqlalchemy.orm.Query.populate_existing
    "sqlalchemy.orm.Query.populate_existing") method. This operation in either form
    indicates that objects being returned from a query should be unconditionally re-populated
    from their contents in the database:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Further discussion on the refresh / expire concept can be found at [Refreshing
    / Expiring](session_state_management.html#session-expire).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Refreshing / Expiring](session_state_management.html#session-expire)'
  prefs: []
  type: TYPE_NORMAL
- en: '[I’m re-loading data with my Session but it isn’t seeing changes that I committed
    elsewhere](../faq/sessions.html#faq-session-identity)'
  prefs: []
  type: TYPE_NORMAL
- en: UPDATE and DELETE with arbitrary WHERE clause
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: SQLAlchemy 2.0 includes enhanced capabilities for emitting several varieties
    of ORM-enabled INSERT, UPDATE and DELETE statements. See the document at [ORM-Enabled
    INSERT, UPDATE, and DELETE statements](queryguide/dml.html) for documentation.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[ORM-Enabled INSERT, UPDATE, and DELETE statements](queryguide/dml.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[ORM UPDATE and DELETE with Custom WHERE Criteria](queryguide/dml.html#orm-queryguide-update-delete-where)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Auto Begin'
  prefs: []
  type: TYPE_NORMAL
- en: The [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    object features a behavior known as **autobegin**. This indicates that the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") will internally consider itself to be in a “transactional”
    state as soon as any work is performed with the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), either involving modifications to the internal state
    of the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    with regards to object state changes, or with operations that require database
    connectivity.
  prefs: []
  type: TYPE_NORMAL
- en: When the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    is first constructed, there’s no transactional state present. The transactional
    state is begun automatically, when a method such as [`Session.add()`](session_api.html#sqlalchemy.orm.Session.add
    "sqlalchemy.orm.Session.add") or [`Session.execute()`](session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") is invoked, or similarly if a [`Query`](queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") is executed to return results (which ultimately uses [`Session.execute()`](session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute")), or if an attribute is modified on a [persistent](../glossary.html#term-persistent)
    object.
  prefs: []
  type: TYPE_NORMAL
- en: The transactional state can be checked by accessing the [`Session.in_transaction()`](session_api.html#sqlalchemy.orm.Session.in_transaction
    "sqlalchemy.orm.Session.in_transaction") method, which returns `True` or `False`
    indicating if the “autobegin” step has proceeded. While not normally needed, the
    [`Session.get_transaction()`](session_api.html#sqlalchemy.orm.Session.get_transaction
    "sqlalchemy.orm.Session.get_transaction") method will return the actual [`SessionTransaction`](session_api.html#sqlalchemy.orm.SessionTransaction
    "sqlalchemy.orm.SessionTransaction") object that represents this transactional
    state.
  prefs: []
  type: TYPE_NORMAL
- en: The transactional state of the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") may also be started explicitly, by invoking the [`Session.begin()`](session_api.html#sqlalchemy.orm.Session.begin
    "sqlalchemy.orm.Session.begin") method. When this method is called, the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is placed into the “transactional” state unconditionally.
    [`Session.begin()`](session_api.html#sqlalchemy.orm.Session.begin "sqlalchemy.orm.Session.begin")
    may be used as a context manager as described at [Framing out a begin / commit
    / rollback block](#session-begin-commit-rollback-block).
  prefs: []
  type: TYPE_NORMAL
- en: '#### Disabling Autobegin to Prevent Implicit Transactions'
  prefs: []
  type: TYPE_NORMAL
- en: 'The “autobegin” behavior may be disabled using the [`Session.autobegin`](session_api.html#sqlalchemy.orm.Session.params.autobegin
    "sqlalchemy.orm.Session") parameter set to `False`. By using this parameter, a
    [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    will require that the [`Session.begin()`](session_api.html#sqlalchemy.orm.Session.begin
    "sqlalchemy.orm.Session.begin") method is called explicitly. Upon construction,
    as well as after any of the [`Session.rollback()`](session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback"), [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit"), or [`Session.close()`](session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") methods are called, the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") won’t implicitly begin any new transactions and will
    raise an error if an attempt to use the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is made without first calling [`Session.begin()`](session_api.html#sqlalchemy.orm.Session.begin
    "sqlalchemy.orm.Session.begin"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'New in version 2.0: Added [`Session.autobegin`](session_api.html#sqlalchemy.orm.Session.params.autobegin
    "sqlalchemy.orm.Session"), allowing “autobegin” behavior to be disabled  ### Committing'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit "sqlalchemy.orm.Session.commit")
    is used to commit the current transaction. At its core this indicates that it
    emits `COMMIT` on all current database connections that have a transaction in
    progress; from a [DBAPI](../glossary.html#term-DBAPI) perspective this means the
    `connection.commit()` DBAPI method is invoked on each DBAPI connection.'
  prefs: []
  type: TYPE_NORMAL
- en: When there is no transaction in place for the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), indicating that no operations were invoked on this
    [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    since the previous call to [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit"), the method will begin and commit an internal-only
    “logical” transaction, that does not normally affect the database unless pending
    flush changes were detected, but will still invoke event handlers and object expiration
    rules.
  prefs: []
  type: TYPE_NORMAL
- en: The [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit "sqlalchemy.orm.Session.commit")
    operation unconditionally issues [`Session.flush()`](session_api.html#sqlalchemy.orm.Session.flush
    "sqlalchemy.orm.Session.flush") before emitting COMMIT on relevant database connections.
    If no pending changes are detected, then no SQL is emitted to the database. This
    behavior is not configurable and is not affected by the [`Session.autoflush`](session_api.html#sqlalchemy.orm.Session.params.autoflush
    "sqlalchemy.orm.Session") parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Subsequent to that, assuming the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is bound to an [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine"), [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") will then COMMIT the actual database transaction
    that is in place, if one was started. After the commit, the [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") object associated with that transaction is closed,
    causing its underlying DBAPI connection to be [released](../glossary.html#term-released)
    back to the connection pool associated with the [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") to which the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is bound.
  prefs: []
  type: TYPE_NORMAL
- en: For a [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    that’s bound to multiple engines (e.g. as described at [Partitioning Strategies](persistence_techniques.html#session-partitioning)),
    the same COMMIT steps will proceed for each [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") / [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") that is in play within the “logical” transaction
    being committed. These database transactions are uncoordinated with each other
    unless [two-phase features](session_transaction.html#session-twophase) are enabled.
  prefs: []
  type: TYPE_NORMAL
- en: Other connection-interaction patterns are available as well, by binding the
    [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    to a [`Connection`](../core/connections.html#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    directly; in this case, it’s assumed that an externally-managed transaction is
    present, and a real COMMIT will not be emitted automatically in this case; see
    the section [Joining a Session into an External Transaction (such as for test
    suites)](session_transaction.html#session-external-transaction) for background
    on this pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, all objects within the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") are [expired](../glossary.html#term-expired) as the
    transaction is closed out. This is so that when the instances are next accessed,
    either through attribute access or by them being present in the result of a SELECT,
    they receive the most recent state. This behavior may be controlled by the [`Session.expire_on_commit`](session_api.html#sqlalchemy.orm.Session.params.expire_on_commit
    "sqlalchemy.orm.Session") flag, which may be set to `False` when this behavior
    is undesirable.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Auto Begin](#session-autobegin)  ### Rolling Back'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Session.rollback()`](session_api.html#sqlalchemy.orm.Session.rollback "sqlalchemy.orm.Session.rollback")
    rolls back the current transaction, if any. When there is no transaction in place,
    the method passes silently.'
  prefs: []
  type: TYPE_NORMAL
- en: 'With a default configured session, the post-rollback state of the session,
    subsequent to a transaction having been begun either via [autobegin](#session-autobegin)
    or by calling the [`Session.begin()`](session_api.html#sqlalchemy.orm.Session.begin
    "sqlalchemy.orm.Session.begin") method explicitly, is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Database transactions are rolled back. For a [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") bound to a single [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine"), this means ROLLBACK is emitted for at most a single
    [`Connection`](../core/connections.html#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    that’s currently in use. For [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") objects bound to multiple [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") objects, ROLLBACK is emitted for all [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") objects that were checked out.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Database connections are [released](../glossary.html#term-released). This follows
    the same connection-related behavior noted in [Committing](#session-committing),
    where [`Connection`](../core/connections.html#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    objects obtained from [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") objects are closed, causing the DBAPI connections
    to be [released](../glossary.html#term-released) to the connection pool within
    the [`Engine`](../core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine").
    New connections are checked out from the [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") if and when a new transaction begins.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: For a [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    that’s bound directly to a [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") as described at [Joining a Session into an External
    Transaction (such as for test suites)](session_transaction.html#session-external-transaction),
    rollback behavior on this [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") would follow the behavior specified by the [`Session.join_transaction_mode`](session_api.html#sqlalchemy.orm.Session.params.join_transaction_mode
    "sqlalchemy.orm.Session") parameter, which could involve rolling back savepoints
    or emitting a real ROLLBACK.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Objects which were initially in the [pending](../glossary.html#term-pending)
    state when they were added to the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.session.Session") within the lifespan of the transaction are expunged,
    corresponding to their INSERT statement being rolled back. The state of their
    attributes remains unchanged.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Objects which were marked as [deleted](../glossary.html#term-deleted) within
    the lifespan of the transaction are promoted back to the [persistent](../glossary.html#term-persistent)
    state, corresponding to their DELETE statement being rolled back. Note that if
    those objects were first [pending](../glossary.html#term-pending) within the transaction,
    that operation takes precedence instead.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: All objects not expunged are fully expired - this is regardless of the [`Session.expire_on_commit`](session_api.html#sqlalchemy.orm.Session.params.expire_on_commit
    "sqlalchemy.orm.Session") setting.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: With that state understood, the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") may safely continue usage after a rollback occurs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.4: The [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") object now features deferred “begin” behavior, as described
    in [autobegin](#session-autobegin). If no transaction is begun, methods like [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") and [`Session.rollback()`](session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") have no effect. This behavior would not have
    been observed prior to 1.4 as under non-autocommit mode, a transaction would always
    be implicitly present.'
  prefs: []
  type: TYPE_NORMAL
- en: When a [`Session.flush()`](session_api.html#sqlalchemy.orm.Session.flush "sqlalchemy.orm.Session.flush")
    fails, typically for reasons like primary key, foreign key, or “not nullable”
    constraint violations, a ROLLBACK is issued automatically (it’s currently not
    possible for a flush to continue after a partial failure). However, the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") goes into a state known as “inactive” at this point,
    and the calling application must always call the [`Session.rollback()`](session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") method explicitly so that the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") can go back into a usable state (it can also be simply
    closed and discarded). See the FAQ entry at [“This Session’s transaction has been
    rolled back due to a previous exception during flush.” (or similar)](../faq/sessions.html#faq-session-rollback)
    for further discussion.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Auto Begin](#session-autobegin)  ### Closing'
  prefs: []
  type: TYPE_NORMAL
- en: The [`Session.close()`](session_api.html#sqlalchemy.orm.Session.close "sqlalchemy.orm.Session.close")
    method issues a [`Session.expunge_all()`](session_api.html#sqlalchemy.orm.Session.expunge_all
    "sqlalchemy.orm.Session.expunge_all") which removes all ORM-mapped objects from
    the session, and [releases](../glossary.html#term-releases) any transactional/connection
    resources from the [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") object(s) to which it is bound. When connections are
    returned to the connection pool, transactional state is rolled back as well.
  prefs: []
  type: TYPE_NORMAL
- en: By default, when the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    is closed, it is essentially in the original state as when it was first constructed,
    and **may be used again**. In this sense, the [`Session.close()`](session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") method is more like a “reset” back to the clean
    state and not as much like a “database close” method. In this mode of operation
    the method [`Session.reset()`](session_api.html#sqlalchemy.orm.Session.reset "sqlalchemy.orm.Session.reset")
    is an alias to [`Session.close()`](session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") and behaves in the same way.
  prefs: []
  type: TYPE_NORMAL
- en: The default behavior of [`Session.close()`](session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") can be changed by setting the parameter [`Session.close_resets_only`](session_api.html#sqlalchemy.orm.Session.params.close_resets_only
    "sqlalchemy.orm.Session") to `False`, indicating that the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") cannot be reused after the method [`Session.close()`](session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") has been called. In this mode of operation the
    [`Session.reset()`](session_api.html#sqlalchemy.orm.Session.reset "sqlalchemy.orm.Session.reset")
    method will allow multiple “reset” of the session, behaving like [`Session.close()`](session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") when [`Session.close_resets_only`](session_api.html#sqlalchemy.orm.Session.params.close_resets_only
    "sqlalchemy.orm.Session") is set to `True`.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.22.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s recommended that the scope of a [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") be limited by a call to [`Session.close()`](session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") at the end, especially if the [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") or [`Session.rollback()`](session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") methods are not used. The [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") may be used as a context manager to ensure that [`Session.close()`](session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") is called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Changed in version 1.4: The [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") object features deferred “begin” behavior, as described
    in [autobegin](#session-autobegin). no longer immediately begins a new transaction
    after the [`Session.close()`](session_api.html#sqlalchemy.orm.Session.close "sqlalchemy.orm.Session.close")
    method is called.  ## Session Frequently Asked Questions'
  prefs: []
  type: TYPE_NORMAL
- en: By this point, many users already have questions about sessions. This section
    presents a mini-FAQ (note that we have also a [real FAQ](../faq/index.html)) of
    the most basic issues one is presented with when using a [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session").
  prefs: []
  type: TYPE_NORMAL
- en: When do I make a [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker")?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Just one time, somewhere in your application’s global scope. It should be looked
    upon as part of your application’s configuration. If your application has three
    .py files in a package, you could, for example, place the [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker") line in your `__init__.py` file; from that point
    on your other modules say “from mypackage import Session”. That way, everyone
    else just uses [`Session()`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session"),
    and the configuration of that session is controlled by that central point.
  prefs: []
  type: TYPE_NORMAL
- en: If your application starts up, does imports, but does not know what database
    it’s going to be connecting to, you can bind the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") at the “class” level to the engine later on, using [`sessionmaker.configure()`](session_api.html#sqlalchemy.orm.sessionmaker.configure
    "sqlalchemy.orm.sessionmaker.configure").
  prefs: []
  type: TYPE_NORMAL
- en: In the examples in this section, we will frequently show the [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker") being created right above the line where we actually
    invoke [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session").
    But that’s just for example’s sake! In reality, the [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker") would be somewhere at the module level. The calls
    to instantiate [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    would then be placed at the point in the application where database conversations
    begin.
  prefs: []
  type: TYPE_NORMAL
- en: '### When do I construct a [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), when do I commit it, and when do I close it?'
  prefs: []
  type: TYPE_NORMAL
- en: A [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    is typically constructed at the beginning of a logical operation where database
    access is potentially anticipated.
  prefs: []
  type: TYPE_NORMAL
- en: The [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session"),
    whenever it is used to talk to the database, begins a database transaction as
    soon as it starts communicating. This transaction remains in progress until the
    [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    is rolled back, committed, or closed. The [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") will begin a new transaction if it is used again, subsequent
    to the previous transaction ending; from this it follows that the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is capable of having a lifespan across many transactions,
    though only one at a time. We refer to these two concepts as **transaction scope**
    and **session scope**.
  prefs: []
  type: TYPE_NORMAL
- en: It’s usually not very hard to determine the best points at which to begin and
    end the scope of a [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session"),
    though the wide variety of application architectures possible can introduce challenging
    situations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some sample scenarios include:'
  prefs: []
  type: TYPE_NORMAL
- en: Web applications. In this case, it’s best to make use of the SQLAlchemy integrations
    provided by the web framework in use. Or otherwise, the basic pattern is create
    a [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    at the start of a web request, call the [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") method at the end of web requests that do POST,
    PUT, or DELETE, and then close the session at the end of web request. It’s also
    usually a good idea to set [`Session.expire_on_commit`](session_api.html#sqlalchemy.orm.Session.params.expire_on_commit
    "sqlalchemy.orm.Session") to False so that subsequent access to objects that came
    from a [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    within the view layer do not need to emit new SQL queries to refresh the objects,
    if the transaction has been committed already.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A background daemon which spawns off child forks would want to create a [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") local to each child process, work with that [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") through the life of the “job” that the fork is handling,
    then tear it down when the job is completed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a command-line script, the application would create a single, global [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") that is established when the program begins to do its
    work, and commits it right as the program is completing its task.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a GUI interface-driven application, the scope of the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") may best be within the scope of a user-generated event,
    such as a button push. Or, the scope may correspond to explicit user interaction,
    such as the user “opening” a series of records, then “saving” them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a general rule, the application should manage the lifecycle of the session
    *externally* to functions that deal with specific data. This is a fundamental
    separation of concerns which keeps data-specific operations agnostic of the context
    in which they access and manipulate that data.
  prefs: []
  type: TYPE_NORMAL
- en: 'E.g. **don’t do this**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Keep the lifecycle of the session (and usually the transaction) **separate
    and external**. The example below illustrates how this might look, and additionally
    makes use of a Python context manager (i.e. the `with:` keyword) in order to manage
    the scope of the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    and its transaction automatically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Changed in version 1.4: The [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") may be used as a context manager without the use of
    external helper functions.'
  prefs: []
  type: TYPE_NORMAL
- en: Is the Session a cache?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Yeee…no. It’s somewhat used as a cache, in that it implements the [identity
    map](../glossary.html#term-identity-map) pattern, and stores objects keyed to
    their primary key. However, it doesn’t do any kind of query caching. This means,
    if you say `session.scalars(select(Foo).filter_by(name='bar'))`, even if `Foo(name='bar')`
    is right there, in the identity map, the session has no idea about that. It has
    to issue SQL to the database, get the rows back, and then when it sees the primary
    key in the row, *then* it can look in the local identity map and see that the
    object is already there. It’s only when you say `query.get({some primary key})`
    that the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.session.Session")
    doesn’t have to issue a query.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, the Session stores object instances using a weak reference by
    default. This also defeats the purpose of using the Session as a cache.
  prefs: []
  type: TYPE_NORMAL
- en: The [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    is not designed to be a global object from which everyone consults as a “registry”
    of objects. That’s more the job of a **second level cache**. SQLAlchemy provides
    a pattern for implementing second level caching using [dogpile.cache](https://dogpilecache.readthedocs.io/),
    via the [Dogpile Caching](examples.html#examples-caching) example.
  prefs: []
  type: TYPE_NORMAL
- en: How can I get the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.session.Session")
    for a certain object?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Use the [`Session.object_session()`](session_api.html#sqlalchemy.orm.Session.object_session
    "sqlalchemy.orm.Session.object_session") classmethod available on [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.session.Session"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The newer [Runtime Inspection API](../core/inspection.html) system can also
    be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '### Is the Session thread-safe? Is AsyncSession safe to share in concurrent
    tasks?'
  prefs: []
  type: TYPE_NORMAL
- en: The [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    is a **mutable, stateful** object that represents a **single database transaction**.
    An instance of [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    therefore **cannot be shared among concurrent threads or asyncio tasks without
    careful synchronization**. The [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is intended to be used in a **non-concurrent** fashion,
    that is, a particular instance of [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") should be used in only one thread or task at a time.
  prefs: []
  type: TYPE_NORMAL
- en: When using the [`AsyncSession`](extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession
    "sqlalchemy.ext.asyncio.AsyncSession") object from SQLAlchemy’s [asyncio](extensions/asyncio.html)
    extension, this object is only a thin proxy on top of a [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), and the same rules apply; it is an **unsynchronized,
    mutable, stateful object**, so it is **not** safe to use a single instance of
    [`AsyncSession`](extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession "sqlalchemy.ext.asyncio.AsyncSession")
    in multiple asyncio tasks at once.
  prefs: []
  type: TYPE_NORMAL
- en: An instance of [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    or [`AsyncSession`](extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession
    "sqlalchemy.ext.asyncio.AsyncSession") represents a single logical database transaction,
    referencing only a single [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") at a time for a particular [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") or [`AsyncEngine`](extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncEngine
    "sqlalchemy.ext.asyncio.AsyncEngine") to which the object is bound (note that
    these objects both support being bound to multiple engines at once, however in
    this case there will still be only one connection per engine in play within the
    scope of a transaction).
  prefs: []
  type: TYPE_NORMAL
- en: A database connection within a transaction is also a stateful object that is
    intended to be operated upon in a non-concurrent, sequential fashion. Commands
    are issued on the connection in a sequence, which are handled by the database
    server in the exact order in which they are emitted. As the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") emits commands upon this connection and receives results,
    the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    itself is transitioning through internal state changes that align with the state
    of commands and data present on this connection; states which include if a transaction
    were begun, committed, or rolled back, what SAVEPOINTs if any are in play, as
    well as fine-grained synchronization of the state of individual database rows
    with local ORM-mapped objects.
  prefs: []
  type: TYPE_NORMAL
- en: When designing database applications for concurrency, the appropriate model
    is that each concurrent task / thread works with its own database transaction.
    This is why when discussing the issue of database concurrency, the standard terminology
    used is **multiple, concurrent transactions**. Within traditional RDMS there is
    no analogue for a single database transaction that is receiving and processing
    multiple commands concurrently.
  prefs: []
  type: TYPE_NORMAL
- en: The concurrency model for SQLAlchemy’s [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") and [`AsyncSession`](extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession
    "sqlalchemy.ext.asyncio.AsyncSession") is therefore **Session per thread, AsyncSession
    per task**. An application that uses multiple threads, or multiple tasks in asyncio
    such as when using an API like `asyncio.gather()` would want to ensure that each
    thread has its own [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session"),
    each asyncio task has its own [`AsyncSession`](extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession
    "sqlalchemy.ext.asyncio.AsyncSession").
  prefs: []
  type: TYPE_NORMAL
- en: The best way to ensure this use is by using the [standard context manager pattern](#session-getting)
    locally within the top level Python function that is inside the thread or task,
    which will ensure the lifespan of the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") or [`AsyncSession`](extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession
    "sqlalchemy.ext.asyncio.AsyncSession") is maintained within a local scope.
  prefs: []
  type: TYPE_NORMAL
- en: For applications that benefit from having a “global” [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") where it’s not an option to pass the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") object to specific functions and methods which require
    it, the [`scoped_session`](contextual.html#sqlalchemy.orm.scoped_session "sqlalchemy.orm.scoped_session")
    approach can provide for a “thread local” [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") object; see the section [Contextual/Thread-local Sessions](contextual.html#unitofwork-contextual)
    for background. Within the asyncio context, the [`async_scoped_session`](extensions/asyncio.html#sqlalchemy.ext.asyncio.async_scoped_session
    "sqlalchemy.ext.asyncio.async_scoped_session") object is the asyncio analogue
    for [`scoped_session`](contextual.html#sqlalchemy.orm.scoped_session "sqlalchemy.orm.scoped_session"),
    however is more challenging to configure as it requires a custom “context” function.
  prefs: []
  type: TYPE_NORMAL
- en: What does the Session do ?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the most general sense, the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") establishes all conversations with the database and
    represents a “holding zone” for all the objects which you’ve loaded or associated
    with it during its lifespan. It provides the interface where SELECT and other
    queries are made that will return and modify ORM-mapped objects. The ORM objects
    themselves are maintained inside the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), inside a structure called the [identity map](../glossary.html#term-identity-map)
    - a data structure that maintains unique copies of each object, where “unique”
    means “only one object with a particular primary key”.
  prefs: []
  type: TYPE_NORMAL
- en: The [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    in its most common pattern of use begins in a mostly stateless form. Once queries
    are issued or other objects are persisted with it, it requests a connection resource
    from an [`Engine`](../core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine")
    that is associated with the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), and then establishes a transaction on that connection.
    This transaction remains in effect until the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is instructed to commit or roll back the transaction.
    When the transaction ends, the connection resource associated with the [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") is [released](../glossary.html#term-released) to the
    connection pool managed by the engine. A new transaction then starts with a new
    connection checkout.
  prefs: []
  type: TYPE_NORMAL
- en: The ORM objects maintained by a [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") are [instrumented](../glossary.html#term-instrumented)
    such that whenever an attribute or a collection is modified in the Python program,
    a change event is generated which is recorded by the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"). Whenever the database is about to be queried, or when
    the transaction is about to be committed, the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") first **flushes** all pending changes stored in memory
    to the database. This is known as the [unit of work](../glossary.html#term-unit-of-work)
    pattern.
  prefs: []
  type: TYPE_NORMAL
- en: When using a [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session"),
    it’s useful to consider the ORM mapped objects that it maintains as **proxy objects**
    to database rows, which are local to the transaction being held by the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"). In order to maintain the state on the objects as matching
    what’s actually in the database, there are a variety of events that will cause
    objects to re-access the database in order to keep synchronized. It is possible
    to “detach” objects from a [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), and to continue using them, though this practice has
    its caveats. It’s intended that usually, you’d re-associate detached objects with
    another [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    when you want to work with them again, so that they can resume their normal task
    of representing database state.
  prefs: []
  type: TYPE_NORMAL
- en: '## Basics of Using a Session'
  prefs: []
  type: TYPE_NORMAL
- en: The most basic [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    use patterns are presented here.
  prefs: []
  type: TYPE_NORMAL
- en: '### Opening and Closing a Session'
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    may be constructed on its own or by using the [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker") class. It typically is passed a single [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") as a source of connectivity up front. A typical use
    may look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Above, the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    is instantiated with an [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") associated with a particular database URL. It is then
    used in a Python context manager (i.e. `with:` statement) so that it is automatically
    closed at the end of the block; this is equivalent to calling the [`Session.close()`](session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") method.
  prefs: []
  type: TYPE_NORMAL
- en: The call to [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") is optional, and is only needed if the work we’ve
    done with the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    includes new data to be persisted to the database. If we were only issuing SELECT
    calls and did not need to write any changes, then the call to [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") would be unnecessary.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that after [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") is called, either explicitly or when using a
    context manager, all objects associated with the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") are [expired](../glossary.html#term-expired), meaning
    their contents are erased to be re-loaded within the next transaction. If these
    objects are instead [detached](../glossary.html#term-detached), they will be non-functional
    until re-associated with a new [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), unless the [`Session.expire_on_commit`](session_api.html#sqlalchemy.orm.Session.params.expire_on_commit
    "sqlalchemy.orm.Session") parameter is used to disable this behavior. See the
    section [Committing](#session-committing) for more detail.  ### Framing out a
    begin / commit / rollback block'
  prefs: []
  type: TYPE_NORMAL
- en: 'We may also enclose the [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") call and the overall “framing” of the transaction
    within a context manager for those cases where we will be committing data to the
    database. By “framing” we mean that if all operations succeed, the [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") method will be called, but if any exceptions
    are raised, the [`Session.rollback()`](session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") method will be called so that the transaction
    is rolled back immediately, before propagating the exception outward. In Python
    this is most fundamentally expressed using a `try: / except: / else:` block such
    as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The long-form sequence of operations illustrated above can be achieved more
    succinctly by making use of the [`SessionTransaction`](session_api.html#sqlalchemy.orm.SessionTransaction
    "sqlalchemy.orm.SessionTransaction") object returned by the [`Session.begin()`](session_api.html#sqlalchemy.orm.Session.begin
    "sqlalchemy.orm.Session.begin") method, which provides a context manager interface
    for the same sequence of operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'More succinctly, the two contexts may be combined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Using a sessionmaker
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The purpose of [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker") is to provide a factory for [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") objects with a fixed configuration. As it is typical
    that an application will have an [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") object in module scope, the [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker") can provide a factory for [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") objects that are against this engine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker "sqlalchemy.orm.sessionmaker")
    is analogous to the [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") as a module-level factory for function-level sessions
    / connections. As such it also has its own [`sessionmaker.begin()`](session_api.html#sqlalchemy.orm.sessionmaker.begin
    "sqlalchemy.orm.sessionmaker.begin") method, analogous to [`Engine.begin()`](../core/connections.html#sqlalchemy.engine.Engine.begin
    "sqlalchemy.engine.Engine.begin"), which returns a [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") object and also maintains a begin/commit/rollback block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Where above, the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    will both have its transaction committed as well as that the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") will be closed, when the above `with:` block ends.
  prefs: []
  type: TYPE_NORMAL
- en: When you write your application, the [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker") factory should be scoped the same as the [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") object created by [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine"), which is typically at module-level or global scope.
    As these objects are both factories, they can be used by any number of functions
    and threads simultaneously.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker "sqlalchemy.orm.sessionmaker")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")'
  prefs: []
  type: TYPE_NORMAL
- en: '### Querying'
  prefs: []
  type: TYPE_NORMAL
- en: The primary means of querying is to make use of the [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") construct to create a [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") object, which is then executed to return a
    result using methods such as [`Session.execute()`](session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") and [`Session.scalars()`](session_api.html#sqlalchemy.orm.Session.scalars
    "sqlalchemy.orm.Session.scalars"). Results are then returned in terms of [`Result`](../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") objects, including sub-variants such as [`ScalarResult`](../core/connections.html#sqlalchemy.engine.ScalarResult
    "sqlalchemy.engine.ScalarResult").
  prefs: []
  type: TYPE_NORMAL
- en: 'A complete guide to SQLAlchemy ORM querying can be found at [ORM Querying Guide](queryguide/index.html).
    Some brief examples follow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Changed in version 2.0: “2.0” style querying is now standard. See [2.0 Migration
    - ORM Usage](../changelog/migration_20.html#migration-20-query-usage) for migration
    notes from the 1.x series.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[ORM Querying Guide](queryguide/index.html)  ### Adding New or Existing Items'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Session.add()`](session_api.html#sqlalchemy.orm.Session.add "sqlalchemy.orm.Session.add")
    is used to place instances in the session. For [transient](../glossary.html#term-transient)
    (i.e. brand new) instances, this will have the effect of an INSERT taking place
    for those instances upon the next flush. For instances which are [persistent](../glossary.html#term-persistent)
    (i.e. were loaded by this session), they are already present and do not need to
    be added. Instances which are [detached](../glossary.html#term-detached) (i.e.
    have been removed from a session) may be re-associated with a session using this
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'To add a list of items to the session at once, use [`Session.add_all()`](session_api.html#sqlalchemy.orm.Session.add_all
    "sqlalchemy.orm.Session.add_all"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The [`Session.add()`](session_api.html#sqlalchemy.orm.Session.add "sqlalchemy.orm.Session.add")
    operation **cascades** along the `save-update` cascade. For more details see the
    section [Cascades](cascades.html#unitofwork-cascades).  ### Deleting'
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`Session.delete()`](session_api.html#sqlalchemy.orm.Session.delete "sqlalchemy.orm.Session.delete")
    method places an instance into the Session’s list of objects to be marked as deleted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[`Session.delete()`](session_api.html#sqlalchemy.orm.Session.delete "sqlalchemy.orm.Session.delete")
    marks an object for deletion, which will result in a DELETE statement emitted
    for each primary key affected. Before the pending deletes are flushed, objects
    marked by “delete” are present in the [`Session.deleted`](session_api.html#sqlalchemy.orm.Session.deleted
    "sqlalchemy.orm.Session.deleted") collection. After the DELETE, they are expunged
    from the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session"),
    which becomes permanent after the transaction is committed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are various important behaviors related to the [`Session.delete()`](session_api.html#sqlalchemy.orm.Session.delete
    "sqlalchemy.orm.Session.delete") operation, particularly in how relationships
    to other objects and collections are handled. There’s more information on how
    this works in the section [Cascades](cascades.html#unitofwork-cascades), but in
    general the rules are:'
  prefs: []
  type: TYPE_NORMAL
- en: Rows that correspond to mapped objects that are related to a deleted object
    via the [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")
    directive are **not deleted by default**. If those objects have a foreign key
    constraint back to the row being deleted, those columns are set to NULL. This
    will cause a constraint violation if the columns are non-nullable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To change the “SET NULL” into a DELETE of a related object’s row, use the [delete](cascades.html#cascade-delete)
    cascade on the [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship").
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rows that are in tables linked as “many-to-many” tables, via the [`relationship.secondary`](relationship_api.html#sqlalchemy.orm.relationship.params.secondary
    "sqlalchemy.orm.relationship") parameter, **are** deleted in all cases when the
    object they refer to is deleted.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When related objects include a foreign key constraint back to the object being
    deleted, and the related collections to which they belong are not currently loaded
    into memory, the unit of work will emit a SELECT to fetch all related rows, so
    that their primary key values can be used to emit either UPDATE or DELETE statements
    on those related rows. In this way, the ORM without further instruction will perform
    the function of ON DELETE CASCADE, even if this is configured on Core [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [`relationship.passive_deletes`](relationship_api.html#sqlalchemy.orm.relationship.params.passive_deletes
    "sqlalchemy.orm.relationship") parameter can be used to tune this behavior and
    rely upon “ON DELETE CASCADE” more naturally; when set to True, this SELECT operation
    will no longer take place, however rows that are locally present will still be
    subject to explicit SET NULL or DELETE. Setting [`relationship.passive_deletes`](relationship_api.html#sqlalchemy.orm.relationship.params.passive_deletes
    "sqlalchemy.orm.relationship") to the string `"all"` will disable **all** related
    object update/delete.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the DELETE occurs for an object marked for deletion, the object is not
    automatically removed from collections or object references that refer to it.
    When the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    is expired, these collections may be loaded again so that the object is no longer
    present. However, it is preferable that instead of using [`Session.delete()`](session_api.html#sqlalchemy.orm.Session.delete
    "sqlalchemy.orm.Session.delete") for these objects, the object should instead
    be removed from its collection and then [delete-orphan](cascades.html#cascade-delete-orphan)
    should be used so that it is deleted as a secondary effect of that collection
    removal. See the section [Notes on Delete - Deleting Objects Referenced from Collections
    and Scalar Relationships](cascades.html#session-deleting-from-collections) for
    an example of this.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[delete](cascades.html#cascade-delete) - describes “delete cascade”, which
    marks related objects for deletion when a lead object is deleted.'
  prefs: []
  type: TYPE_NORMAL
- en: '[delete-orphan](cascades.html#cascade-delete-orphan) - describes “delete orphan
    cascade”, which marks related objects for deletion when they are de-associated
    from their lead object.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Notes on Delete - Deleting Objects Referenced from Collections and Scalar
    Relationships](cascades.html#session-deleting-from-collections) - important background
    on [`Session.delete()`](session_api.html#sqlalchemy.orm.Session.delete "sqlalchemy.orm.Session.delete")
    as involves relationships being refreshed in memory.  ### Flushing'
  prefs: []
  type: TYPE_NORMAL
- en: When the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.session.Session")
    is used with its default configuration, the flush step is nearly always done transparently.
    Specifically, the flush occurs before any individual SQL statement is issued as
    a result of a [`Query`](queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    or a [2.0-style](../glossary.html#term-1) [`Session.execute()`](session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") call, as well as within the [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") call before the transaction is committed. It
    also occurs before a SAVEPOINT is issued when [`Session.begin_nested()`](session_api.html#sqlalchemy.orm.Session.begin_nested
    "sqlalchemy.orm.Session.begin_nested") is used.
  prefs: []
  type: TYPE_NORMAL
- en: 'A [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    flush can be forced at any time by calling the [`Session.flush()`](session_api.html#sqlalchemy.orm.Session.flush
    "sqlalchemy.orm.Session.flush") method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The flush which occurs automatically within the scope of certain methods is
    known as **autoflush**. Autoflush is defined as a configurable, automatic flush
    call which occurs at the beginning of methods including:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Session.execute()`](session_api.html#sqlalchemy.orm.Session.execute "sqlalchemy.orm.Session.execute")
    and other SQL-executing methods, when used against ORM-enabled SQL constructs,
    such as [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") objects that refer to ORM entities and/or
    ORM-mapped attributes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a [`Query`](queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    is invoked to send SQL to the database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Within the [`Session.merge()`](session_api.html#sqlalchemy.orm.Session.merge
    "sqlalchemy.orm.Session.merge") method before querying the database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When objects are [refreshed](#session-expiring)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When ORM [lazy load](../glossary.html#term-lazy-load) operations occur against
    unloaded object attributes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are also points at which flushes occur **unconditionally**; these points
    are within key transactional boundaries which include:'
  prefs: []
  type: TYPE_NORMAL
- en: Within the process of the [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When [`Session.begin_nested()`](session_api.html#sqlalchemy.orm.Session.begin_nested
    "sqlalchemy.orm.Session.begin_nested") is called
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the [`Session.prepare()`](session_api.html#sqlalchemy.orm.Session.prepare
    "sqlalchemy.orm.Session.prepare") 2PC method is used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The **autoflush** behavior, as applied to the previous list of items, can be
    disabled by constructing a [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") or [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker") passing the [`Session.autoflush`](session_api.html#sqlalchemy.orm.Session.params.autoflush
    "sqlalchemy.orm.Session") parameter as `False`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, autoflush can be temporarily disabled within the flow of using
    a [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    using the [`Session.no_autoflush`](session_api.html#sqlalchemy.orm.Session.no_autoflush
    "sqlalchemy.orm.Session.no_autoflush") context manager:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '**To reiterate:** The flush process **always occurs** when transactional methods
    such as [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit "sqlalchemy.orm.Session.commit")
    and [`Session.begin_nested()`](session_api.html#sqlalchemy.orm.Session.begin_nested
    "sqlalchemy.orm.Session.begin_nested") are called, regardless of any “autoflush”
    settings, when the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    has remaining pending changes to process.'
  prefs: []
  type: TYPE_NORMAL
- en: As the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    only invokes SQL to the database within the context of a [DBAPI](../glossary.html#term-DBAPI)
    transaction, all “flush” operations themselves only occur within a database transaction
    (subject to the [isolation level](session_transaction.html#session-transaction-isolation)
    of the database transaction), provided that the DBAPI is not in [driver level
    autocommit](../core/connections.html#dbapi-autocommit) mode. This means that assuming
    the database connection is providing for [atomicity](../glossary.html#term-atomicity)
    within its transactional settings, if any individual DML statement inside the
    flush fails, the entire operation will be rolled back.
  prefs: []
  type: TYPE_NORMAL
- en: When a failure occurs within a flush, in order to continue using that same [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), an explicit call to [`Session.rollback()`](session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") is required after a flush fails, even though
    the underlying transaction will have been rolled back already (even if the database
    driver is technically in driver-level autocommit mode). This is so that the overall
    nesting pattern of so-called “subtransactions” is consistently maintained. The
    FAQ section [“This Session’s transaction has been rolled back due to a previous
    exception during flush.” (or similar)](../faq/sessions.html#faq-session-rollback)
    contains a more detailed description of this behavior.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[“This Session’s transaction has been rolled back due to a previous exception
    during flush.” (or similar)](../faq/sessions.html#faq-session-rollback) - further
    background on why [`Session.rollback()`](session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") must be called when a flush fails.  ### Get
    by Primary Key'
  prefs: []
  type: TYPE_NORMAL
- en: 'As the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    makes use of an [identity map](../glossary.html#term-identity-map) which refers
    to current in-memory objects by primary key, the [`Session.get()`](session_api.html#sqlalchemy.orm.Session.get
    "sqlalchemy.orm.Session.get") method is provided as a means of locating objects
    by primary key, first looking within the current identity map and then querying
    the database for non present values. Such as, to locate a `User` entity with primary
    key identity `(5, )`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The [`Session.get()`](session_api.html#sqlalchemy.orm.Session.get "sqlalchemy.orm.Session.get")
    also includes calling forms for composite primary key values, which may be passed
    as tuples or dictionaries, as well as additional parameters which allow for specific
    loader and execution options. See [`Session.get()`](session_api.html#sqlalchemy.orm.Session.get
    "sqlalchemy.orm.Session.get") for the complete parameter list.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Session.get()`](session_api.html#sqlalchemy.orm.Session.get "sqlalchemy.orm.Session.get")  ###
    Expiring / Refreshing'
  prefs: []
  type: TYPE_NORMAL
- en: 'An important consideration that will often come up when using the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is that of dealing with the state that is present on
    objects that have been loaded from the database, in terms of keeping them synchronized
    with the current state of the transaction. The SQLAlchemy ORM is based around
    the concept of an [identity map](../glossary.html#term-identity-map) such that
    when an object is “loaded” from a SQL query, there will be a unique Python object
    instance maintained corresponding to a particular database identity. This means
    if we emit two separate queries, each for the same row, and get a mapped object
    back, the two queries will have returned the same Python object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Following from this, when the ORM gets rows back from a query, it will **skip
    the population of attributes** for an object that’s already loaded. The design
    assumption here is to assume a transaction that’s perfectly isolated, and then
    to the degree that the transaction isn’t isolated, the application can take steps
    on an as-needed basis to refresh objects from the database transaction. The FAQ
    entry at [I’m re-loading data with my Session but it isn’t seeing changes that
    I committed elsewhere](../faq/sessions.html#faq-session-identity) discusses this
    concept in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'When an ORM mapped object is loaded into memory, there are three general ways
    to refresh its contents with new data from the current transaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '**the expire() method** - the [`Session.expire()`](session_api.html#sqlalchemy.orm.Session.expire
    "sqlalchemy.orm.Session.expire") method will erase the contents of selected or
    all attributes of an object, such that they will be loaded from the database when
    they are next accessed, e.g. using a [lazy loading](../glossary.html#term-lazy-loading)
    pattern:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**the refresh() method** - closely related is the [`Session.refresh()`](session_api.html#sqlalchemy.orm.Session.refresh
    "sqlalchemy.orm.Session.refresh") method, which does everything the [`Session.expire()`](session_api.html#sqlalchemy.orm.Session.expire
    "sqlalchemy.orm.Session.expire") method does but also emits one or more SQL queries
    immediately to actually refresh the contents of the object:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**the populate_existing() method or execution option** - This is now an execution
    option documented at [Populate Existing](queryguide/api.html#orm-queryguide-populate-existing);
    in legacy form it’s found on the [`Query`](queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object as the [`Query.populate_existing()`](queryguide/query.html#sqlalchemy.orm.Query.populate_existing
    "sqlalchemy.orm.Query.populate_existing") method. This operation in either form
    indicates that objects being returned from a query should be unconditionally re-populated
    from their contents in the database:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Further discussion on the refresh / expire concept can be found at [Refreshing
    / Expiring](session_state_management.html#session-expire).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Refreshing / Expiring](session_state_management.html#session-expire)'
  prefs: []
  type: TYPE_NORMAL
- en: '[I’m re-loading data with my Session but it isn’t seeing changes that I committed
    elsewhere](../faq/sessions.html#faq-session-identity)'
  prefs: []
  type: TYPE_NORMAL
- en: UPDATE and DELETE with arbitrary WHERE clause
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: SQLAlchemy 2.0 includes enhanced capabilities for emitting several varieties
    of ORM-enabled INSERT, UPDATE and DELETE statements. See the document at [ORM-Enabled
    INSERT, UPDATE, and DELETE statements](queryguide/dml.html) for documentation.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[ORM-Enabled INSERT, UPDATE, and DELETE statements](queryguide/dml.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[ORM UPDATE and DELETE with Custom WHERE Criteria](queryguide/dml.html#orm-queryguide-update-delete-where)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Auto Begin'
  prefs: []
  type: TYPE_NORMAL
- en: The [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    object features a behavior known as **autobegin**. This indicates that the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") will internally consider itself to be in a “transactional”
    state as soon as any work is performed with the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), either involving modifications to the internal state
    of the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    with regards to object state changes, or with operations that require database
    connectivity.
  prefs: []
  type: TYPE_NORMAL
- en: When the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    is first constructed, there’s no transactional state present. The transactional
    state is begun automatically, when a method such as [`Session.add()`](session_api.html#sqlalchemy.orm.Session.add
    "sqlalchemy.orm.Session.add") or [`Session.execute()`](session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") is invoked, or similarly if a [`Query`](queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") is executed to return results (which ultimately uses [`Session.execute()`](session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute")), or if an attribute is modified on a [persistent](../glossary.html#term-persistent)
    object.
  prefs: []
  type: TYPE_NORMAL
- en: The transactional state can be checked by accessing the [`Session.in_transaction()`](session_api.html#sqlalchemy.orm.Session.in_transaction
    "sqlalchemy.orm.Session.in_transaction") method, which returns `True` or `False`
    indicating if the “autobegin” step has proceeded. While not normally needed, the
    [`Session.get_transaction()`](session_api.html#sqlalchemy.orm.Session.get_transaction
    "sqlalchemy.orm.Session.get_transaction") method will return the actual [`SessionTransaction`](session_api.html#sqlalchemy.orm.SessionTransaction
    "sqlalchemy.orm.SessionTransaction") object that represents this transactional
    state.
  prefs: []
  type: TYPE_NORMAL
- en: The transactional state of the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") may also be started explicitly, by invoking the [`Session.begin()`](session_api.html#sqlalchemy.orm.Session.begin
    "sqlalchemy.orm.Session.begin") method. When this method is called, the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is placed into the “transactional” state unconditionally.
    [`Session.begin()`](session_api.html#sqlalchemy.orm.Session.begin "sqlalchemy.orm.Session.begin")
    may be used as a context manager as described at [Framing out a begin / commit
    / rollback block](#session-begin-commit-rollback-block).
  prefs: []
  type: TYPE_NORMAL
- en: '#### Disabling Autobegin to Prevent Implicit Transactions'
  prefs: []
  type: TYPE_NORMAL
- en: 'The “autobegin” behavior may be disabled using the [`Session.autobegin`](session_api.html#sqlalchemy.orm.Session.params.autobegin
    "sqlalchemy.orm.Session") parameter set to `False`. By using this parameter, a
    [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    will require that the [`Session.begin()`](session_api.html#sqlalchemy.orm.Session.begin
    "sqlalchemy.orm.Session.begin") method is called explicitly. Upon construction,
    as well as after any of the [`Session.rollback()`](session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback"), [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit"), or [`Session.close()`](session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") methods are called, the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") won’t implicitly begin any new transactions and will
    raise an error if an attempt to use the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is made without first calling [`Session.begin()`](session_api.html#sqlalchemy.orm.Session.begin
    "sqlalchemy.orm.Session.begin"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'New in version 2.0: Added [`Session.autobegin`](session_api.html#sqlalchemy.orm.Session.params.autobegin
    "sqlalchemy.orm.Session"), allowing “autobegin” behavior to be disabled  ### Committing'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit "sqlalchemy.orm.Session.commit")
    is used to commit the current transaction. At its core this indicates that it
    emits `COMMIT` on all current database connections that have a transaction in
    progress; from a [DBAPI](../glossary.html#term-DBAPI) perspective this means the
    `connection.commit()` DBAPI method is invoked on each DBAPI connection.'
  prefs: []
  type: TYPE_NORMAL
- en: When there is no transaction in place for the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), indicating that no operations were invoked on this
    [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    since the previous call to [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit"), the method will begin and commit an internal-only
    “logical” transaction, that does not normally affect the database unless pending
    flush changes were detected, but will still invoke event handlers and object expiration
    rules.
  prefs: []
  type: TYPE_NORMAL
- en: The [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit "sqlalchemy.orm.Session.commit")
    operation unconditionally issues [`Session.flush()`](session_api.html#sqlalchemy.orm.Session.flush
    "sqlalchemy.orm.Session.flush") before emitting COMMIT on relevant database connections.
    If no pending changes are detected, then no SQL is emitted to the database. This
    behavior is not configurable and is not affected by the [`Session.autoflush`](session_api.html#sqlalchemy.orm.Session.params.autoflush
    "sqlalchemy.orm.Session") parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Subsequent to that, assuming the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is bound to an [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine"), [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") will then COMMIT the actual database transaction
    that is in place, if one was started. After the commit, the [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") object associated with that transaction is closed,
    causing its underlying DBAPI connection to be [released](../glossary.html#term-released)
    back to the connection pool associated with the [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") to which the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is bound.
  prefs: []
  type: TYPE_NORMAL
- en: For a [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    that’s bound to multiple engines (e.g. as described at [Partitioning Strategies](persistence_techniques.html#session-partitioning)),
    the same COMMIT steps will proceed for each [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") / [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") that is in play within the “logical” transaction
    being committed. These database transactions are uncoordinated with each other
    unless [two-phase features](session_transaction.html#session-twophase) are enabled.
  prefs: []
  type: TYPE_NORMAL
- en: Other connection-interaction patterns are available as well, by binding the
    [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    to a [`Connection`](../core/connections.html#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    directly; in this case, it’s assumed that an externally-managed transaction is
    present, and a real COMMIT will not be emitted automatically in this case; see
    the section [Joining a Session into an External Transaction (such as for test
    suites)](session_transaction.html#session-external-transaction) for background
    on this pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, all objects within the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") are [expired](../glossary.html#term-expired) as the
    transaction is closed out. This is so that when the instances are next accessed,
    either through attribute access or by them being present in the result of a SELECT,
    they receive the most recent state. This behavior may be controlled by the [`Session.expire_on_commit`](session_api.html#sqlalchemy.orm.Session.params.expire_on_commit
    "sqlalchemy.orm.Session") flag, which may be set to `False` when this behavior
    is undesirable.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Auto Begin](#session-autobegin)  ### Rolling Back'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Session.rollback()`](session_api.html#sqlalchemy.orm.Session.rollback "sqlalchemy.orm.Session.rollback")
    rolls back the current transaction, if any. When there is no transaction in place,
    the method passes silently.'
  prefs: []
  type: TYPE_NORMAL
- en: 'With a default configured session, the post-rollback state of the session,
    subsequent to a transaction having been begun either via [autobegin](#session-autobegin)
    or by calling the [`Session.begin()`](session_api.html#sqlalchemy.orm.Session.begin
    "sqlalchemy.orm.Session.begin") method explicitly, is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Database transactions are rolled back. For a [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") bound to a single [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine"), this means ROLLBACK is emitted for at most a single
    [`Connection`](../core/connections.html#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    that’s currently in use. For [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") objects bound to multiple [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") objects, ROLLBACK is emitted for all [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") objects that were checked out.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Database connections are [released](../glossary.html#term-released). This follows
    the same connection-related behavior noted in [Committing](#session-committing),
    where [`Connection`](../core/connections.html#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    objects obtained from [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") objects are closed, causing the DBAPI connections
    to be [released](../glossary.html#term-released) to the connection pool within
    the [`Engine`](../core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine").
    New connections are checked out from the [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") if and when a new transaction begins.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: For a [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    that’s bound directly to a [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") as described at [Joining a Session into an External
    Transaction (such as for test suites)](session_transaction.html#session-external-transaction),
    rollback behavior on this [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") would follow the behavior specified by the [`Session.join_transaction_mode`](session_api.html#sqlalchemy.orm.Session.params.join_transaction_mode
    "sqlalchemy.orm.Session") parameter, which could involve rolling back savepoints
    or emitting a real ROLLBACK.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Objects which were initially in the [pending](../glossary.html#term-pending)
    state when they were added to the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.session.Session") within the lifespan of the transaction are expunged,
    corresponding to their INSERT statement being rolled back. The state of their
    attributes remains unchanged.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Objects which were marked as [deleted](../glossary.html#term-deleted) within
    the lifespan of the transaction are promoted back to the [persistent](../glossary.html#term-persistent)
    state, corresponding to their DELETE statement being rolled back. Note that if
    those objects were first [pending](../glossary.html#term-pending) within the transaction,
    that operation takes precedence instead.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: All objects not expunged are fully expired - this is regardless of the [`Session.expire_on_commit`](session_api.html#sqlalchemy.orm.Session.params.expire_on_commit
    "sqlalchemy.orm.Session") setting.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: With that state understood, the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") may safely continue usage after a rollback occurs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.4: The [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") object now features deferred “begin” behavior, as described
    in [autobegin](#session-autobegin). If no transaction is begun, methods like [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") and [`Session.rollback()`](session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") have no effect. This behavior would not have
    been observed prior to 1.4 as under non-autocommit mode, a transaction would always
    be implicitly present.'
  prefs: []
  type: TYPE_NORMAL
- en: When a [`Session.flush()`](session_api.html#sqlalchemy.orm.Session.flush "sqlalchemy.orm.Session.flush")
    fails, typically for reasons like primary key, foreign key, or “not nullable”
    constraint violations, a ROLLBACK is issued automatically (it’s currently not
    possible for a flush to continue after a partial failure). However, the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") goes into a state known as “inactive” at this point,
    and the calling application must always call the [`Session.rollback()`](session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") method explicitly so that the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") can go back into a usable state (it can also be simply
    closed and discarded). See the FAQ entry at [“This Session’s transaction has been
    rolled back due to a previous exception during flush.” (or similar)](../faq/sessions.html#faq-session-rollback)
    for further discussion.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Auto Begin](#session-autobegin)  ### Closing'
  prefs: []
  type: TYPE_NORMAL
- en: The [`Session.close()`](session_api.html#sqlalchemy.orm.Session.close "sqlalchemy.orm.Session.close")
    method issues a [`Session.expunge_all()`](session_api.html#sqlalchemy.orm.Session.expunge_all
    "sqlalchemy.orm.Session.expunge_all") which removes all ORM-mapped objects from
    the session, and [releases](../glossary.html#term-releases) any transactional/connection
    resources from the [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") object(s) to which it is bound. When connections are
    returned to the connection pool, transactional state is rolled back as well.
  prefs: []
  type: TYPE_NORMAL
- en: By default, when the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    is closed, it is essentially in the original state as when it was first constructed,
    and **may be used again**. In this sense, the [`Session.close()`](session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") method is more like a “reset” back to the clean
    state and not as much like a “database close” method. In this mode of operation
    the method [`Session.reset()`](session_api.html#sqlalchemy.orm.Session.reset "sqlalchemy.orm.Session.reset")
    is an alias to [`Session.close()`](session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") and behaves in the same way.
  prefs: []
  type: TYPE_NORMAL
- en: The default behavior of [`Session.close()`](session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") can be changed by setting the parameter [`Session.close_resets_only`](session_api.html#sqlalchemy.orm.Session.params.close_resets_only
    "sqlalchemy.orm.Session") to `False`, indicating that the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") cannot be reused after the method [`Session.close()`](session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") has been called. In this mode of operation the
    [`Session.reset()`](session_api.html#sqlalchemy.orm.Session.reset "sqlalchemy.orm.Session.reset")
    method will allow multiple “reset” of the session, behaving like [`Session.close()`](session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") when [`Session.close_resets_only`](session_api.html#sqlalchemy.orm.Session.params.close_resets_only
    "sqlalchemy.orm.Session") is set to `True`.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.22.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s recommended that the scope of a [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") be limited by a call to [`Session.close()`](session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") at the end, especially if the [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") or [`Session.rollback()`](session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") methods are not used. The [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") may be used as a context manager to ensure that [`Session.close()`](session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") is called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Changed in version 1.4: The [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") object features deferred “begin” behavior, as described
    in [autobegin](#session-autobegin). no longer immediately begins a new transaction
    after the [`Session.close()`](session_api.html#sqlalchemy.orm.Session.close "sqlalchemy.orm.Session.close")
    method is called.  ### Opening and Closing a Session'
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    may be constructed on its own or by using the [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker") class. It typically is passed a single [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") as a source of connectivity up front. A typical use
    may look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Above, the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    is instantiated with an [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") associated with a particular database URL. It is then
    used in a Python context manager (i.e. `with:` statement) so that it is automatically
    closed at the end of the block; this is equivalent to calling the [`Session.close()`](session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") method.
  prefs: []
  type: TYPE_NORMAL
- en: The call to [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") is optional, and is only needed if the work we’ve
    done with the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    includes new data to be persisted to the database. If we were only issuing SELECT
    calls and did not need to write any changes, then the call to [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") would be unnecessary.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Note that after [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") is called, either explicitly or when using a
    context manager, all objects associated with the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") are [expired](../glossary.html#term-expired), meaning
    their contents are erased to be re-loaded within the next transaction. If these
    objects are instead [detached](../glossary.html#term-detached), they will be non-functional
    until re-associated with a new [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), unless the [`Session.expire_on_commit`](session_api.html#sqlalchemy.orm.Session.params.expire_on_commit
    "sqlalchemy.orm.Session") parameter is used to disable this behavior. See the
    section [Committing](#session-committing) for more detail.
  prefs: []
  type: TYPE_NORMAL
- en: '### Framing out a begin / commit / rollback block'
  prefs: []
  type: TYPE_NORMAL
- en: 'We may also enclose the [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") call and the overall “framing” of the transaction
    within a context manager for those cases where we will be committing data to the
    database. By “framing” we mean that if all operations succeed, the [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") method will be called, but if any exceptions
    are raised, the [`Session.rollback()`](session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") method will be called so that the transaction
    is rolled back immediately, before propagating the exception outward. In Python
    this is most fundamentally expressed using a `try: / except: / else:` block such
    as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The long-form sequence of operations illustrated above can be achieved more
    succinctly by making use of the [`SessionTransaction`](session_api.html#sqlalchemy.orm.SessionTransaction
    "sqlalchemy.orm.SessionTransaction") object returned by the [`Session.begin()`](session_api.html#sqlalchemy.orm.Session.begin
    "sqlalchemy.orm.Session.begin") method, which provides a context manager interface
    for the same sequence of operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'More succinctly, the two contexts may be combined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Using a sessionmaker
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The purpose of [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker") is to provide a factory for [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") objects with a fixed configuration. As it is typical
    that an application will have an [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") object in module scope, the [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker") can provide a factory for [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") objects that are against this engine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker "sqlalchemy.orm.sessionmaker")
    is analogous to the [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") as a module-level factory for function-level sessions
    / connections. As such it also has its own [`sessionmaker.begin()`](session_api.html#sqlalchemy.orm.sessionmaker.begin
    "sqlalchemy.orm.sessionmaker.begin") method, analogous to [`Engine.begin()`](../core/connections.html#sqlalchemy.engine.Engine.begin
    "sqlalchemy.engine.Engine.begin"), which returns a [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") object and also maintains a begin/commit/rollback block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Where above, the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    will both have its transaction committed as well as that the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") will be closed, when the above `with:` block ends.
  prefs: []
  type: TYPE_NORMAL
- en: When you write your application, the [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker") factory should be scoped the same as the [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") object created by [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine"), which is typically at module-level or global scope.
    As these objects are both factories, they can be used by any number of functions
    and threads simultaneously.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker "sqlalchemy.orm.sessionmaker")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")'
  prefs: []
  type: TYPE_NORMAL
- en: '### Querying'
  prefs: []
  type: TYPE_NORMAL
- en: The primary means of querying is to make use of the [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") construct to create a [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") object, which is then executed to return a
    result using methods such as [`Session.execute()`](session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") and [`Session.scalars()`](session_api.html#sqlalchemy.orm.Session.scalars
    "sqlalchemy.orm.Session.scalars"). Results are then returned in terms of [`Result`](../core/connections.html#sqlalchemy.engine.Result
    "sqlalchemy.engine.Result") objects, including sub-variants such as [`ScalarResult`](../core/connections.html#sqlalchemy.engine.ScalarResult
    "sqlalchemy.engine.ScalarResult").
  prefs: []
  type: TYPE_NORMAL
- en: 'A complete guide to SQLAlchemy ORM querying can be found at [ORM Querying Guide](queryguide/index.html).
    Some brief examples follow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Changed in version 2.0: “2.0” style querying is now standard. See [2.0 Migration
    - ORM Usage](../changelog/migration_20.html#migration-20-query-usage) for migration
    notes from the 1.x series.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[ORM Querying Guide](queryguide/index.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Adding New or Existing Items'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Session.add()`](session_api.html#sqlalchemy.orm.Session.add "sqlalchemy.orm.Session.add")
    is used to place instances in the session. For [transient](../glossary.html#term-transient)
    (i.e. brand new) instances, this will have the effect of an INSERT taking place
    for those instances upon the next flush. For instances which are [persistent](../glossary.html#term-persistent)
    (i.e. were loaded by this session), they are already present and do not need to
    be added. Instances which are [detached](../glossary.html#term-detached) (i.e.
    have been removed from a session) may be re-associated with a session using this
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'To add a list of items to the session at once, use [`Session.add_all()`](session_api.html#sqlalchemy.orm.Session.add_all
    "sqlalchemy.orm.Session.add_all"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The [`Session.add()`](session_api.html#sqlalchemy.orm.Session.add "sqlalchemy.orm.Session.add")
    operation **cascades** along the `save-update` cascade. For more details see the
    section [Cascades](cascades.html#unitofwork-cascades).
  prefs: []
  type: TYPE_NORMAL
- en: '### Deleting'
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`Session.delete()`](session_api.html#sqlalchemy.orm.Session.delete "sqlalchemy.orm.Session.delete")
    method places an instance into the Session’s list of objects to be marked as deleted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[`Session.delete()`](session_api.html#sqlalchemy.orm.Session.delete "sqlalchemy.orm.Session.delete")
    marks an object for deletion, which will result in a DELETE statement emitted
    for each primary key affected. Before the pending deletes are flushed, objects
    marked by “delete” are present in the [`Session.deleted`](session_api.html#sqlalchemy.orm.Session.deleted
    "sqlalchemy.orm.Session.deleted") collection. After the DELETE, they are expunged
    from the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session"),
    which becomes permanent after the transaction is committed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are various important behaviors related to the [`Session.delete()`](session_api.html#sqlalchemy.orm.Session.delete
    "sqlalchemy.orm.Session.delete") operation, particularly in how relationships
    to other objects and collections are handled. There’s more information on how
    this works in the section [Cascades](cascades.html#unitofwork-cascades), but in
    general the rules are:'
  prefs: []
  type: TYPE_NORMAL
- en: Rows that correspond to mapped objects that are related to a deleted object
    via the [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")
    directive are **not deleted by default**. If those objects have a foreign key
    constraint back to the row being deleted, those columns are set to NULL. This
    will cause a constraint violation if the columns are non-nullable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To change the “SET NULL” into a DELETE of a related object’s row, use the [delete](cascades.html#cascade-delete)
    cascade on the [`relationship()`](relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship").
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rows that are in tables linked as “many-to-many” tables, via the [`relationship.secondary`](relationship_api.html#sqlalchemy.orm.relationship.params.secondary
    "sqlalchemy.orm.relationship") parameter, **are** deleted in all cases when the
    object they refer to is deleted.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When related objects include a foreign key constraint back to the object being
    deleted, and the related collections to which they belong are not currently loaded
    into memory, the unit of work will emit a SELECT to fetch all related rows, so
    that their primary key values can be used to emit either UPDATE or DELETE statements
    on those related rows. In this way, the ORM without further instruction will perform
    the function of ON DELETE CASCADE, even if this is configured on Core [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The [`relationship.passive_deletes`](relationship_api.html#sqlalchemy.orm.relationship.params.passive_deletes
    "sqlalchemy.orm.relationship") parameter can be used to tune this behavior and
    rely upon “ON DELETE CASCADE” more naturally; when set to True, this SELECT operation
    will no longer take place, however rows that are locally present will still be
    subject to explicit SET NULL or DELETE. Setting [`relationship.passive_deletes`](relationship_api.html#sqlalchemy.orm.relationship.params.passive_deletes
    "sqlalchemy.orm.relationship") to the string `"all"` will disable **all** related
    object update/delete.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the DELETE occurs for an object marked for deletion, the object is not
    automatically removed from collections or object references that refer to it.
    When the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    is expired, these collections may be loaded again so that the object is no longer
    present. However, it is preferable that instead of using [`Session.delete()`](session_api.html#sqlalchemy.orm.Session.delete
    "sqlalchemy.orm.Session.delete") for these objects, the object should instead
    be removed from its collection and then [delete-orphan](cascades.html#cascade-delete-orphan)
    should be used so that it is deleted as a secondary effect of that collection
    removal. See the section [Notes on Delete - Deleting Objects Referenced from Collections
    and Scalar Relationships](cascades.html#session-deleting-from-collections) for
    an example of this.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[delete](cascades.html#cascade-delete) - describes “delete cascade”, which
    marks related objects for deletion when a lead object is deleted.'
  prefs: []
  type: TYPE_NORMAL
- en: '[delete-orphan](cascades.html#cascade-delete-orphan) - describes “delete orphan
    cascade”, which marks related objects for deletion when they are de-associated
    from their lead object.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Notes on Delete - Deleting Objects Referenced from Collections and Scalar
    Relationships](cascades.html#session-deleting-from-collections) - important background
    on [`Session.delete()`](session_api.html#sqlalchemy.orm.Session.delete "sqlalchemy.orm.Session.delete")
    as involves relationships being refreshed in memory.'
  prefs: []
  type: TYPE_NORMAL
- en: '### Flushing'
  prefs: []
  type: TYPE_NORMAL
- en: When the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.session.Session")
    is used with its default configuration, the flush step is nearly always done transparently.
    Specifically, the flush occurs before any individual SQL statement is issued as
    a result of a [`Query`](queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    or a [2.0-style](../glossary.html#term-1) [`Session.execute()`](session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") call, as well as within the [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") call before the transaction is committed. It
    also occurs before a SAVEPOINT is issued when [`Session.begin_nested()`](session_api.html#sqlalchemy.orm.Session.begin_nested
    "sqlalchemy.orm.Session.begin_nested") is used.
  prefs: []
  type: TYPE_NORMAL
- en: 'A [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    flush can be forced at any time by calling the [`Session.flush()`](session_api.html#sqlalchemy.orm.Session.flush
    "sqlalchemy.orm.Session.flush") method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The flush which occurs automatically within the scope of certain methods is
    known as **autoflush**. Autoflush is defined as a configurable, automatic flush
    call which occurs at the beginning of methods including:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Session.execute()`](session_api.html#sqlalchemy.orm.Session.execute "sqlalchemy.orm.Session.execute")
    and other SQL-executing methods, when used against ORM-enabled SQL constructs,
    such as [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") objects that refer to ORM entities and/or
    ORM-mapped attributes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a [`Query`](queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    is invoked to send SQL to the database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Within the [`Session.merge()`](session_api.html#sqlalchemy.orm.Session.merge
    "sqlalchemy.orm.Session.merge") method before querying the database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When objects are [refreshed](#session-expiring)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When ORM [lazy load](../glossary.html#term-lazy-load) operations occur against
    unloaded object attributes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are also points at which flushes occur **unconditionally**; these points
    are within key transactional boundaries which include:'
  prefs: []
  type: TYPE_NORMAL
- en: Within the process of the [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When [`Session.begin_nested()`](session_api.html#sqlalchemy.orm.Session.begin_nested
    "sqlalchemy.orm.Session.begin_nested") is called
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the [`Session.prepare()`](session_api.html#sqlalchemy.orm.Session.prepare
    "sqlalchemy.orm.Session.prepare") 2PC method is used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The **autoflush** behavior, as applied to the previous list of items, can be
    disabled by constructing a [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") or [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker") passing the [`Session.autoflush`](session_api.html#sqlalchemy.orm.Session.params.autoflush
    "sqlalchemy.orm.Session") parameter as `False`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Additionally, autoflush can be temporarily disabled within the flow of using
    a [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    using the [`Session.no_autoflush`](session_api.html#sqlalchemy.orm.Session.no_autoflush
    "sqlalchemy.orm.Session.no_autoflush") context manager:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '**To reiterate:** The flush process **always occurs** when transactional methods
    such as [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit "sqlalchemy.orm.Session.commit")
    and [`Session.begin_nested()`](session_api.html#sqlalchemy.orm.Session.begin_nested
    "sqlalchemy.orm.Session.begin_nested") are called, regardless of any “autoflush”
    settings, when the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    has remaining pending changes to process.'
  prefs: []
  type: TYPE_NORMAL
- en: As the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    only invokes SQL to the database within the context of a [DBAPI](../glossary.html#term-DBAPI)
    transaction, all “flush” operations themselves only occur within a database transaction
    (subject to the [isolation level](session_transaction.html#session-transaction-isolation)
    of the database transaction), provided that the DBAPI is not in [driver level
    autocommit](../core/connections.html#dbapi-autocommit) mode. This means that assuming
    the database connection is providing for [atomicity](../glossary.html#term-atomicity)
    within its transactional settings, if any individual DML statement inside the
    flush fails, the entire operation will be rolled back.
  prefs: []
  type: TYPE_NORMAL
- en: When a failure occurs within a flush, in order to continue using that same [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), an explicit call to [`Session.rollback()`](session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") is required after a flush fails, even though
    the underlying transaction will have been rolled back already (even if the database
    driver is technically in driver-level autocommit mode). This is so that the overall
    nesting pattern of so-called “subtransactions” is consistently maintained. The
    FAQ section [“This Session’s transaction has been rolled back due to a previous
    exception during flush.” (or similar)](../faq/sessions.html#faq-session-rollback)
    contains a more detailed description of this behavior.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[“This Session’s transaction has been rolled back due to a previous exception
    during flush.” (or similar)](../faq/sessions.html#faq-session-rollback) - further
    background on why [`Session.rollback()`](session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") must be called when a flush fails.'
  prefs: []
  type: TYPE_NORMAL
- en: '### Get by Primary Key'
  prefs: []
  type: TYPE_NORMAL
- en: 'As the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    makes use of an [identity map](../glossary.html#term-identity-map) which refers
    to current in-memory objects by primary key, the [`Session.get()`](session_api.html#sqlalchemy.orm.Session.get
    "sqlalchemy.orm.Session.get") method is provided as a means of locating objects
    by primary key, first looking within the current identity map and then querying
    the database for non present values. Such as, to locate a `User` entity with primary
    key identity `(5, )`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The [`Session.get()`](session_api.html#sqlalchemy.orm.Session.get "sqlalchemy.orm.Session.get")
    also includes calling forms for composite primary key values, which may be passed
    as tuples or dictionaries, as well as additional parameters which allow for specific
    loader and execution options. See [`Session.get()`](session_api.html#sqlalchemy.orm.Session.get
    "sqlalchemy.orm.Session.get") for the complete parameter list.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Session.get()`](session_api.html#sqlalchemy.orm.Session.get "sqlalchemy.orm.Session.get")'
  prefs: []
  type: TYPE_NORMAL
- en: '### Expiring / Refreshing'
  prefs: []
  type: TYPE_NORMAL
- en: 'An important consideration that will often come up when using the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is that of dealing with the state that is present on
    objects that have been loaded from the database, in terms of keeping them synchronized
    with the current state of the transaction. The SQLAlchemy ORM is based around
    the concept of an [identity map](../glossary.html#term-identity-map) such that
    when an object is “loaded” from a SQL query, there will be a unique Python object
    instance maintained corresponding to a particular database identity. This means
    if we emit two separate queries, each for the same row, and get a mapped object
    back, the two queries will have returned the same Python object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Following from this, when the ORM gets rows back from a query, it will **skip
    the population of attributes** for an object that’s already loaded. The design
    assumption here is to assume a transaction that’s perfectly isolated, and then
    to the degree that the transaction isn’t isolated, the application can take steps
    on an as-needed basis to refresh objects from the database transaction. The FAQ
    entry at [I’m re-loading data with my Session but it isn’t seeing changes that
    I committed elsewhere](../faq/sessions.html#faq-session-identity) discusses this
    concept in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'When an ORM mapped object is loaded into memory, there are three general ways
    to refresh its contents with new data from the current transaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '**the expire() method** - the [`Session.expire()`](session_api.html#sqlalchemy.orm.Session.expire
    "sqlalchemy.orm.Session.expire") method will erase the contents of selected or
    all attributes of an object, such that they will be loaded from the database when
    they are next accessed, e.g. using a [lazy loading](../glossary.html#term-lazy-loading)
    pattern:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**the refresh() method** - closely related is the [`Session.refresh()`](session_api.html#sqlalchemy.orm.Session.refresh
    "sqlalchemy.orm.Session.refresh") method, which does everything the [`Session.expire()`](session_api.html#sqlalchemy.orm.Session.expire
    "sqlalchemy.orm.Session.expire") method does but also emits one or more SQL queries
    immediately to actually refresh the contents of the object:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**the populate_existing() method or execution option** - This is now an execution
    option documented at [Populate Existing](queryguide/api.html#orm-queryguide-populate-existing);
    in legacy form it’s found on the [`Query`](queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object as the [`Query.populate_existing()`](queryguide/query.html#sqlalchemy.orm.Query.populate_existing
    "sqlalchemy.orm.Query.populate_existing") method. This operation in either form
    indicates that objects being returned from a query should be unconditionally re-populated
    from their contents in the database:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Further discussion on the refresh / expire concept can be found at [Refreshing
    / Expiring](session_state_management.html#session-expire).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Refreshing / Expiring](session_state_management.html#session-expire)'
  prefs: []
  type: TYPE_NORMAL
- en: '[I’m re-loading data with my Session but it isn’t seeing changes that I committed
    elsewhere](../faq/sessions.html#faq-session-identity)'
  prefs: []
  type: TYPE_NORMAL
- en: UPDATE and DELETE with arbitrary WHERE clause
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: SQLAlchemy 2.0 includes enhanced capabilities for emitting several varieties
    of ORM-enabled INSERT, UPDATE and DELETE statements. See the document at [ORM-Enabled
    INSERT, UPDATE, and DELETE statements](queryguide/dml.html) for documentation.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[ORM-Enabled INSERT, UPDATE, and DELETE statements](queryguide/dml.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '[ORM UPDATE and DELETE with Custom WHERE Criteria](queryguide/dml.html#orm-queryguide-update-delete-where)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Auto Begin'
  prefs: []
  type: TYPE_NORMAL
- en: The [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    object features a behavior known as **autobegin**. This indicates that the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") will internally consider itself to be in a “transactional”
    state as soon as any work is performed with the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), either involving modifications to the internal state
    of the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    with regards to object state changes, or with operations that require database
    connectivity.
  prefs: []
  type: TYPE_NORMAL
- en: When the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    is first constructed, there’s no transactional state present. The transactional
    state is begun automatically, when a method such as [`Session.add()`](session_api.html#sqlalchemy.orm.Session.add
    "sqlalchemy.orm.Session.add") or [`Session.execute()`](session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") is invoked, or similarly if a [`Query`](queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") is executed to return results (which ultimately uses [`Session.execute()`](session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute")), or if an attribute is modified on a [persistent](../glossary.html#term-persistent)
    object.
  prefs: []
  type: TYPE_NORMAL
- en: The transactional state can be checked by accessing the [`Session.in_transaction()`](session_api.html#sqlalchemy.orm.Session.in_transaction
    "sqlalchemy.orm.Session.in_transaction") method, which returns `True` or `False`
    indicating if the “autobegin” step has proceeded. While not normally needed, the
    [`Session.get_transaction()`](session_api.html#sqlalchemy.orm.Session.get_transaction
    "sqlalchemy.orm.Session.get_transaction") method will return the actual [`SessionTransaction`](session_api.html#sqlalchemy.orm.SessionTransaction
    "sqlalchemy.orm.SessionTransaction") object that represents this transactional
    state.
  prefs: []
  type: TYPE_NORMAL
- en: The transactional state of the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") may also be started explicitly, by invoking the [`Session.begin()`](session_api.html#sqlalchemy.orm.Session.begin
    "sqlalchemy.orm.Session.begin") method. When this method is called, the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is placed into the “transactional” state unconditionally.
    [`Session.begin()`](session_api.html#sqlalchemy.orm.Session.begin "sqlalchemy.orm.Session.begin")
    may be used as a context manager as described at [Framing out a begin / commit
    / rollback block](#session-begin-commit-rollback-block).
  prefs: []
  type: TYPE_NORMAL
- en: '#### Disabling Autobegin to Prevent Implicit Transactions'
  prefs: []
  type: TYPE_NORMAL
- en: 'The “autobegin” behavior may be disabled using the [`Session.autobegin`](session_api.html#sqlalchemy.orm.Session.params.autobegin
    "sqlalchemy.orm.Session") parameter set to `False`. By using this parameter, a
    [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    will require that the [`Session.begin()`](session_api.html#sqlalchemy.orm.Session.begin
    "sqlalchemy.orm.Session.begin") method is called explicitly. Upon construction,
    as well as after any of the [`Session.rollback()`](session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback"), [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit"), or [`Session.close()`](session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") methods are called, the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") won’t implicitly begin any new transactions and will
    raise an error if an attempt to use the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is made without first calling [`Session.begin()`](session_api.html#sqlalchemy.orm.Session.begin
    "sqlalchemy.orm.Session.begin"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'New in version 2.0: Added [`Session.autobegin`](session_api.html#sqlalchemy.orm.Session.params.autobegin
    "sqlalchemy.orm.Session"), allowing “autobegin” behavior to be disabled  ####
    Disabling Autobegin to Prevent Implicit Transactions'
  prefs: []
  type: TYPE_NORMAL
- en: 'The “autobegin” behavior may be disabled using the [`Session.autobegin`](session_api.html#sqlalchemy.orm.Session.params.autobegin
    "sqlalchemy.orm.Session") parameter set to `False`. By using this parameter, a
    [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    will require that the [`Session.begin()`](session_api.html#sqlalchemy.orm.Session.begin
    "sqlalchemy.orm.Session.begin") method is called explicitly. Upon construction,
    as well as after any of the [`Session.rollback()`](session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback"), [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit"), or [`Session.close()`](session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") methods are called, the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") won’t implicitly begin any new transactions and will
    raise an error if an attempt to use the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is made without first calling [`Session.begin()`](session_api.html#sqlalchemy.orm.Session.begin
    "sqlalchemy.orm.Session.begin"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'New in version 2.0: Added [`Session.autobegin`](session_api.html#sqlalchemy.orm.Session.params.autobegin
    "sqlalchemy.orm.Session"), allowing “autobegin” behavior to be disabled'
  prefs: []
  type: TYPE_NORMAL
- en: '### Committing'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit "sqlalchemy.orm.Session.commit")
    is used to commit the current transaction. At its core this indicates that it
    emits `COMMIT` on all current database connections that have a transaction in
    progress; from a [DBAPI](../glossary.html#term-DBAPI) perspective this means the
    `connection.commit()` DBAPI method is invoked on each DBAPI connection.'
  prefs: []
  type: TYPE_NORMAL
- en: When there is no transaction in place for the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), indicating that no operations were invoked on this
    [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    since the previous call to [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit"), the method will begin and commit an internal-only
    “logical” transaction, that does not normally affect the database unless pending
    flush changes were detected, but will still invoke event handlers and object expiration
    rules.
  prefs: []
  type: TYPE_NORMAL
- en: The [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit "sqlalchemy.orm.Session.commit")
    operation unconditionally issues [`Session.flush()`](session_api.html#sqlalchemy.orm.Session.flush
    "sqlalchemy.orm.Session.flush") before emitting COMMIT on relevant database connections.
    If no pending changes are detected, then no SQL is emitted to the database. This
    behavior is not configurable and is not affected by the [`Session.autoflush`](session_api.html#sqlalchemy.orm.Session.params.autoflush
    "sqlalchemy.orm.Session") parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Subsequent to that, assuming the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is bound to an [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine"), [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") will then COMMIT the actual database transaction
    that is in place, if one was started. After the commit, the [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") object associated with that transaction is closed,
    causing its underlying DBAPI connection to be [released](../glossary.html#term-released)
    back to the connection pool associated with the [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") to which the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is bound.
  prefs: []
  type: TYPE_NORMAL
- en: For a [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    that’s bound to multiple engines (e.g. as described at [Partitioning Strategies](persistence_techniques.html#session-partitioning)),
    the same COMMIT steps will proceed for each [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") / [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") that is in play within the “logical” transaction
    being committed. These database transactions are uncoordinated with each other
    unless [two-phase features](session_transaction.html#session-twophase) are enabled.
  prefs: []
  type: TYPE_NORMAL
- en: Other connection-interaction patterns are available as well, by binding the
    [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    to a [`Connection`](../core/connections.html#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    directly; in this case, it’s assumed that an externally-managed transaction is
    present, and a real COMMIT will not be emitted automatically in this case; see
    the section [Joining a Session into an External Transaction (such as for test
    suites)](session_transaction.html#session-external-transaction) for background
    on this pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, all objects within the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") are [expired](../glossary.html#term-expired) as the
    transaction is closed out. This is so that when the instances are next accessed,
    either through attribute access or by them being present in the result of a SELECT,
    they receive the most recent state. This behavior may be controlled by the [`Session.expire_on_commit`](session_api.html#sqlalchemy.orm.Session.params.expire_on_commit
    "sqlalchemy.orm.Session") flag, which may be set to `False` when this behavior
    is undesirable.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Auto Begin](#session-autobegin)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Rolling Back'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Session.rollback()`](session_api.html#sqlalchemy.orm.Session.rollback "sqlalchemy.orm.Session.rollback")
    rolls back the current transaction, if any. When there is no transaction in place,
    the method passes silently.'
  prefs: []
  type: TYPE_NORMAL
- en: 'With a default configured session, the post-rollback state of the session,
    subsequent to a transaction having been begun either via [autobegin](#session-autobegin)
    or by calling the [`Session.begin()`](session_api.html#sqlalchemy.orm.Session.begin
    "sqlalchemy.orm.Session.begin") method explicitly, is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Database transactions are rolled back. For a [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") bound to a single [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine"), this means ROLLBACK is emitted for at most a single
    [`Connection`](../core/connections.html#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    that’s currently in use. For [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") objects bound to multiple [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") objects, ROLLBACK is emitted for all [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") objects that were checked out.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Database connections are [released](../glossary.html#term-released). This follows
    the same connection-related behavior noted in [Committing](#session-committing),
    where [`Connection`](../core/connections.html#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    objects obtained from [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") objects are closed, causing the DBAPI connections
    to be [released](../glossary.html#term-released) to the connection pool within
    the [`Engine`](../core/connections.html#sqlalchemy.engine.Engine "sqlalchemy.engine.Engine").
    New connections are checked out from the [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") if and when a new transaction begins.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: For a [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    that’s bound directly to a [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") as described at [Joining a Session into an External
    Transaction (such as for test suites)](session_transaction.html#session-external-transaction),
    rollback behavior on this [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") would follow the behavior specified by the [`Session.join_transaction_mode`](session_api.html#sqlalchemy.orm.Session.params.join_transaction_mode
    "sqlalchemy.orm.Session") parameter, which could involve rolling back savepoints
    or emitting a real ROLLBACK.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Objects which were initially in the [pending](../glossary.html#term-pending)
    state when they were added to the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.session.Session") within the lifespan of the transaction are expunged,
    corresponding to their INSERT statement being rolled back. The state of their
    attributes remains unchanged.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: Objects which were marked as [deleted](../glossary.html#term-deleted) within
    the lifespan of the transaction are promoted back to the [persistent](../glossary.html#term-persistent)
    state, corresponding to their DELETE statement being rolled back. Note that if
    those objects were first [pending](../glossary.html#term-pending) within the transaction,
    that operation takes precedence instead.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: All objects not expunged are fully expired - this is regardless of the [`Session.expire_on_commit`](session_api.html#sqlalchemy.orm.Session.params.expire_on_commit
    "sqlalchemy.orm.Session") setting.
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: With that state understood, the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") may safely continue usage after a rollback occurs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.4: The [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") object now features deferred “begin” behavior, as described
    in [autobegin](#session-autobegin). If no transaction is begun, methods like [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") and [`Session.rollback()`](session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") have no effect. This behavior would not have
    been observed prior to 1.4 as under non-autocommit mode, a transaction would always
    be implicitly present.'
  prefs: []
  type: TYPE_NORMAL
- en: When a [`Session.flush()`](session_api.html#sqlalchemy.orm.Session.flush "sqlalchemy.orm.Session.flush")
    fails, typically for reasons like primary key, foreign key, or “not nullable”
    constraint violations, a ROLLBACK is issued automatically (it’s currently not
    possible for a flush to continue after a partial failure). However, the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") goes into a state known as “inactive” at this point,
    and the calling application must always call the [`Session.rollback()`](session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") method explicitly so that the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") can go back into a usable state (it can also be simply
    closed and discarded). See the FAQ entry at [“This Session’s transaction has been
    rolled back due to a previous exception during flush.” (or similar)](../faq/sessions.html#faq-session-rollback)
    for further discussion.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Auto Begin](#session-autobegin)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Closing'
  prefs: []
  type: TYPE_NORMAL
- en: The [`Session.close()`](session_api.html#sqlalchemy.orm.Session.close "sqlalchemy.orm.Session.close")
    method issues a [`Session.expunge_all()`](session_api.html#sqlalchemy.orm.Session.expunge_all
    "sqlalchemy.orm.Session.expunge_all") which removes all ORM-mapped objects from
    the session, and [releases](../glossary.html#term-releases) any transactional/connection
    resources from the [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") object(s) to which it is bound. When connections are
    returned to the connection pool, transactional state is rolled back as well.
  prefs: []
  type: TYPE_NORMAL
- en: By default, when the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    is closed, it is essentially in the original state as when it was first constructed,
    and **may be used again**. In this sense, the [`Session.close()`](session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") method is more like a “reset” back to the clean
    state and not as much like a “database close” method. In this mode of operation
    the method [`Session.reset()`](session_api.html#sqlalchemy.orm.Session.reset "sqlalchemy.orm.Session.reset")
    is an alias to [`Session.close()`](session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") and behaves in the same way.
  prefs: []
  type: TYPE_NORMAL
- en: The default behavior of [`Session.close()`](session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") can be changed by setting the parameter [`Session.close_resets_only`](session_api.html#sqlalchemy.orm.Session.params.close_resets_only
    "sqlalchemy.orm.Session") to `False`, indicating that the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") cannot be reused after the method [`Session.close()`](session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") has been called. In this mode of operation the
    [`Session.reset()`](session_api.html#sqlalchemy.orm.Session.reset "sqlalchemy.orm.Session.reset")
    method will allow multiple “reset” of the session, behaving like [`Session.close()`](session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") when [`Session.close_resets_only`](session_api.html#sqlalchemy.orm.Session.params.close_resets_only
    "sqlalchemy.orm.Session") is set to `True`.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.22.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s recommended that the scope of a [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") be limited by a call to [`Session.close()`](session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") at the end, especially if the [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") or [`Session.rollback()`](session_api.html#sqlalchemy.orm.Session.rollback
    "sqlalchemy.orm.Session.rollback") methods are not used. The [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") may be used as a context manager to ensure that [`Session.close()`](session_api.html#sqlalchemy.orm.Session.close
    "sqlalchemy.orm.Session.close") is called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Changed in version 1.4: The [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") object features deferred “begin” behavior, as described
    in [autobegin](#session-autobegin). no longer immediately begins a new transaction
    after the [`Session.close()`](session_api.html#sqlalchemy.orm.Session.close "sqlalchemy.orm.Session.close")
    method is called.'
  prefs: []
  type: TYPE_NORMAL
- en: '## Session Frequently Asked Questions'
  prefs: []
  type: TYPE_NORMAL
- en: By this point, many users already have questions about sessions. This section
    presents a mini-FAQ (note that we have also a [real FAQ](../faq/index.html)) of
    the most basic issues one is presented with when using a [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session").
  prefs: []
  type: TYPE_NORMAL
- en: When do I make a [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker")?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Just one time, somewhere in your application’s global scope. It should be looked
    upon as part of your application’s configuration. If your application has three
    .py files in a package, you could, for example, place the [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker") line in your `__init__.py` file; from that point
    on your other modules say “from mypackage import Session”. That way, everyone
    else just uses [`Session()`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session"),
    and the configuration of that session is controlled by that central point.
  prefs: []
  type: TYPE_NORMAL
- en: If your application starts up, does imports, but does not know what database
    it’s going to be connecting to, you can bind the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") at the “class” level to the engine later on, using [`sessionmaker.configure()`](session_api.html#sqlalchemy.orm.sessionmaker.configure
    "sqlalchemy.orm.sessionmaker.configure").
  prefs: []
  type: TYPE_NORMAL
- en: In the examples in this section, we will frequently show the [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker") being created right above the line where we actually
    invoke [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session").
    But that’s just for example’s sake! In reality, the [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker") would be somewhere at the module level. The calls
    to instantiate [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    would then be placed at the point in the application where database conversations
    begin.
  prefs: []
  type: TYPE_NORMAL
- en: '### When do I construct a [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), when do I commit it, and when do I close it?'
  prefs: []
  type: TYPE_NORMAL
- en: A [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    is typically constructed at the beginning of a logical operation where database
    access is potentially anticipated.
  prefs: []
  type: TYPE_NORMAL
- en: The [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session"),
    whenever it is used to talk to the database, begins a database transaction as
    soon as it starts communicating. This transaction remains in progress until the
    [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    is rolled back, committed, or closed. The [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") will begin a new transaction if it is used again, subsequent
    to the previous transaction ending; from this it follows that the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is capable of having a lifespan across many transactions,
    though only one at a time. We refer to these two concepts as **transaction scope**
    and **session scope**.
  prefs: []
  type: TYPE_NORMAL
- en: It’s usually not very hard to determine the best points at which to begin and
    end the scope of a [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session"),
    though the wide variety of application architectures possible can introduce challenging
    situations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some sample scenarios include:'
  prefs: []
  type: TYPE_NORMAL
- en: Web applications. In this case, it’s best to make use of the SQLAlchemy integrations
    provided by the web framework in use. Or otherwise, the basic pattern is create
    a [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    at the start of a web request, call the [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") method at the end of web requests that do POST,
    PUT, or DELETE, and then close the session at the end of web request. It’s also
    usually a good idea to set [`Session.expire_on_commit`](session_api.html#sqlalchemy.orm.Session.params.expire_on_commit
    "sqlalchemy.orm.Session") to False so that subsequent access to objects that came
    from a [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    within the view layer do not need to emit new SQL queries to refresh the objects,
    if the transaction has been committed already.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A background daemon which spawns off child forks would want to create a [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") local to each child process, work with that [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") through the life of the “job” that the fork is handling,
    then tear it down when the job is completed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a command-line script, the application would create a single, global [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") that is established when the program begins to do its
    work, and commits it right as the program is completing its task.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a GUI interface-driven application, the scope of the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") may best be within the scope of a user-generated event,
    such as a button push. Or, the scope may correspond to explicit user interaction,
    such as the user “opening” a series of records, then “saving” them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a general rule, the application should manage the lifecycle of the session
    *externally* to functions that deal with specific data. This is a fundamental
    separation of concerns which keeps data-specific operations agnostic of the context
    in which they access and manipulate that data.
  prefs: []
  type: TYPE_NORMAL
- en: 'E.g. **don’t do this**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Keep the lifecycle of the session (and usually the transaction) **separate
    and external**. The example below illustrates how this might look, and additionally
    makes use of a Python context manager (i.e. the `with:` keyword) in order to manage
    the scope of the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    and its transaction automatically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Changed in version 1.4: The [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") may be used as a context manager without the use of
    external helper functions.'
  prefs: []
  type: TYPE_NORMAL
- en: Is the Session a cache?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Yeee…no. It’s somewhat used as a cache, in that it implements the [identity
    map](../glossary.html#term-identity-map) pattern, and stores objects keyed to
    their primary key. However, it doesn’t do any kind of query caching. This means,
    if you say `session.scalars(select(Foo).filter_by(name='bar'))`, even if `Foo(name='bar')`
    is right there, in the identity map, the session has no idea about that. It has
    to issue SQL to the database, get the rows back, and then when it sees the primary
    key in the row, *then* it can look in the local identity map and see that the
    object is already there. It’s only when you say `query.get({some primary key})`
    that the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.session.Session")
    doesn’t have to issue a query.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, the Session stores object instances using a weak reference by
    default. This also defeats the purpose of using the Session as a cache.
  prefs: []
  type: TYPE_NORMAL
- en: The [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    is not designed to be a global object from which everyone consults as a “registry”
    of objects. That’s more the job of a **second level cache**. SQLAlchemy provides
    a pattern for implementing second level caching using [dogpile.cache](https://dogpilecache.readthedocs.io/),
    via the [Dogpile Caching](examples.html#examples-caching) example.
  prefs: []
  type: TYPE_NORMAL
- en: How can I get the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.session.Session")
    for a certain object?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Use the [`Session.object_session()`](session_api.html#sqlalchemy.orm.Session.object_session
    "sqlalchemy.orm.Session.object_session") classmethod available on [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.session.Session"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'The newer [Runtime Inspection API](../core/inspection.html) system can also
    be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '### Is the Session thread-safe? Is AsyncSession safe to share in concurrent
    tasks?'
  prefs: []
  type: TYPE_NORMAL
- en: The [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    is a **mutable, stateful** object that represents a **single database transaction**.
    An instance of [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    therefore **cannot be shared among concurrent threads or asyncio tasks without
    careful synchronization**. The [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is intended to be used in a **non-concurrent** fashion,
    that is, a particular instance of [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") should be used in only one thread or task at a time.
  prefs: []
  type: TYPE_NORMAL
- en: When using the [`AsyncSession`](extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession
    "sqlalchemy.ext.asyncio.AsyncSession") object from SQLAlchemy’s [asyncio](extensions/asyncio.html)
    extension, this object is only a thin proxy on top of a [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), and the same rules apply; it is an **unsynchronized,
    mutable, stateful object**, so it is **not** safe to use a single instance of
    [`AsyncSession`](extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession "sqlalchemy.ext.asyncio.AsyncSession")
    in multiple asyncio tasks at once.
  prefs: []
  type: TYPE_NORMAL
- en: An instance of [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    or [`AsyncSession`](extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession
    "sqlalchemy.ext.asyncio.AsyncSession") represents a single logical database transaction,
    referencing only a single [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") at a time for a particular [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") or [`AsyncEngine`](extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncEngine
    "sqlalchemy.ext.asyncio.AsyncEngine") to which the object is bound (note that
    these objects both support being bound to multiple engines at once, however in
    this case there will still be only one connection per engine in play within the
    scope of a transaction).
  prefs: []
  type: TYPE_NORMAL
- en: A database connection within a transaction is also a stateful object that is
    intended to be operated upon in a non-concurrent, sequential fashion. Commands
    are issued on the connection in a sequence, which are handled by the database
    server in the exact order in which they are emitted. As the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") emits commands upon this connection and receives results,
    the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    itself is transitioning through internal state changes that align with the state
    of commands and data present on this connection; states which include if a transaction
    were begun, committed, or rolled back, what SAVEPOINTs if any are in play, as
    well as fine-grained synchronization of the state of individual database rows
    with local ORM-mapped objects.
  prefs: []
  type: TYPE_NORMAL
- en: When designing database applications for concurrency, the appropriate model
    is that each concurrent task / thread works with its own database transaction.
    This is why when discussing the issue of database concurrency, the standard terminology
    used is **multiple, concurrent transactions**. Within traditional RDMS there is
    no analogue for a single database transaction that is receiving and processing
    multiple commands concurrently.
  prefs: []
  type: TYPE_NORMAL
- en: The concurrency model for SQLAlchemy’s [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") and [`AsyncSession`](extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession
    "sqlalchemy.ext.asyncio.AsyncSession") is therefore **Session per thread, AsyncSession
    per task**. An application that uses multiple threads, or multiple tasks in asyncio
    such as when using an API like `asyncio.gather()` would want to ensure that each
    thread has its own [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session"),
    each asyncio task has its own [`AsyncSession`](extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession
    "sqlalchemy.ext.asyncio.AsyncSession").
  prefs: []
  type: TYPE_NORMAL
- en: The best way to ensure this use is by using the [standard context manager pattern](#session-getting)
    locally within the top level Python function that is inside the thread or task,
    which will ensure the lifespan of the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") or [`AsyncSession`](extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession
    "sqlalchemy.ext.asyncio.AsyncSession") is maintained within a local scope.
  prefs: []
  type: TYPE_NORMAL
- en: For applications that benefit from having a “global” [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") where it’s not an option to pass the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") object to specific functions and methods which require
    it, the [`scoped_session`](contextual.html#sqlalchemy.orm.scoped_session "sqlalchemy.orm.scoped_session")
    approach can provide for a “thread local” [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") object; see the section [Contextual/Thread-local Sessions](contextual.html#unitofwork-contextual)
    for background. Within the asyncio context, the [`async_scoped_session`](extensions/asyncio.html#sqlalchemy.ext.asyncio.async_scoped_session
    "sqlalchemy.ext.asyncio.async_scoped_session") object is the asyncio analogue
    for [`scoped_session`](contextual.html#sqlalchemy.orm.scoped_session "sqlalchemy.orm.scoped_session"),
    however is more challenging to configure as it requires a custom “context” function.
  prefs: []
  type: TYPE_NORMAL
- en: When do I make a [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker")?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Just one time, somewhere in your application’s global scope. It should be looked
    upon as part of your application’s configuration. If your application has three
    .py files in a package, you could, for example, place the [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker") line in your `__init__.py` file; from that point
    on your other modules say “from mypackage import Session”. That way, everyone
    else just uses [`Session()`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session"),
    and the configuration of that session is controlled by that central point.
  prefs: []
  type: TYPE_NORMAL
- en: If your application starts up, does imports, but does not know what database
    it’s going to be connecting to, you can bind the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") at the “class” level to the engine later on, using [`sessionmaker.configure()`](session_api.html#sqlalchemy.orm.sessionmaker.configure
    "sqlalchemy.orm.sessionmaker.configure").
  prefs: []
  type: TYPE_NORMAL
- en: In the examples in this section, we will frequently show the [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker") being created right above the line where we actually
    invoke [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session").
    But that’s just for example’s sake! In reality, the [`sessionmaker`](session_api.html#sqlalchemy.orm.sessionmaker
    "sqlalchemy.orm.sessionmaker") would be somewhere at the module level. The calls
    to instantiate [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    would then be placed at the point in the application where database conversations
    begin.
  prefs: []
  type: TYPE_NORMAL
- en: '### When do I construct a [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), when do I commit it, and when do I close it?'
  prefs: []
  type: TYPE_NORMAL
- en: A [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    is typically constructed at the beginning of a logical operation where database
    access is potentially anticipated.
  prefs: []
  type: TYPE_NORMAL
- en: The [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session"),
    whenever it is used to talk to the database, begins a database transaction as
    soon as it starts communicating. This transaction remains in progress until the
    [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    is rolled back, committed, or closed. The [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") will begin a new transaction if it is used again, subsequent
    to the previous transaction ending; from this it follows that the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is capable of having a lifespan across many transactions,
    though only one at a time. We refer to these two concepts as **transaction scope**
    and **session scope**.
  prefs: []
  type: TYPE_NORMAL
- en: It’s usually not very hard to determine the best points at which to begin and
    end the scope of a [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session"),
    though the wide variety of application architectures possible can introduce challenging
    situations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some sample scenarios include:'
  prefs: []
  type: TYPE_NORMAL
- en: Web applications. In this case, it’s best to make use of the SQLAlchemy integrations
    provided by the web framework in use. Or otherwise, the basic pattern is create
    a [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    at the start of a web request, call the [`Session.commit()`](session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") method at the end of web requests that do POST,
    PUT, or DELETE, and then close the session at the end of web request. It’s also
    usually a good idea to set [`Session.expire_on_commit`](session_api.html#sqlalchemy.orm.Session.params.expire_on_commit
    "sqlalchemy.orm.Session") to False so that subsequent access to objects that came
    from a [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    within the view layer do not need to emit new SQL queries to refresh the objects,
    if the transaction has been committed already.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A background daemon which spawns off child forks would want to create a [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") local to each child process, work with that [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") through the life of the “job” that the fork is handling,
    then tear it down when the job is completed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a command-line script, the application would create a single, global [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") that is established when the program begins to do its
    work, and commits it right as the program is completing its task.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For a GUI interface-driven application, the scope of the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") may best be within the scope of a user-generated event,
    such as a button push. Or, the scope may correspond to explicit user interaction,
    such as the user “opening” a series of records, then “saving” them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a general rule, the application should manage the lifecycle of the session
    *externally* to functions that deal with specific data. This is a fundamental
    separation of concerns which keeps data-specific operations agnostic of the context
    in which they access and manipulate that data.
  prefs: []
  type: TYPE_NORMAL
- en: 'E.g. **don’t do this**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Keep the lifecycle of the session (and usually the transaction) **separate
    and external**. The example below illustrates how this might look, and additionally
    makes use of a Python context manager (i.e. the `with:` keyword) in order to manage
    the scope of the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    and its transaction automatically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Changed in version 1.4: The [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") may be used as a context manager without the use of
    external helper functions.'
  prefs: []
  type: TYPE_NORMAL
- en: Is the Session a cache?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Yeee…no. It’s somewhat used as a cache, in that it implements the [identity
    map](../glossary.html#term-identity-map) pattern, and stores objects keyed to
    their primary key. However, it doesn’t do any kind of query caching. This means,
    if you say `session.scalars(select(Foo).filter_by(name='bar'))`, even if `Foo(name='bar')`
    is right there, in the identity map, the session has no idea about that. It has
    to issue SQL to the database, get the rows back, and then when it sees the primary
    key in the row, *then* it can look in the local identity map and see that the
    object is already there. It’s only when you say `query.get({some primary key})`
    that the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.session.Session")
    doesn’t have to issue a query.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, the Session stores object instances using a weak reference by
    default. This also defeats the purpose of using the Session as a cache.
  prefs: []
  type: TYPE_NORMAL
- en: The [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    is not designed to be a global object from which everyone consults as a “registry”
    of objects. That’s more the job of a **second level cache**. SQLAlchemy provides
    a pattern for implementing second level caching using [dogpile.cache](https://dogpilecache.readthedocs.io/),
    via the [Dogpile Caching](examples.html#examples-caching) example.
  prefs: []
  type: TYPE_NORMAL
- en: How can I get the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.session.Session")
    for a certain object?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Use the [`Session.object_session()`](session_api.html#sqlalchemy.orm.Session.object_session
    "sqlalchemy.orm.Session.object_session") classmethod available on [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.session.Session"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'The newer [Runtime Inspection API](../core/inspection.html) system can also
    be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '### Is the Session thread-safe? Is AsyncSession safe to share in concurrent
    tasks?'
  prefs: []
  type: TYPE_NORMAL
- en: The [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    is a **mutable, stateful** object that represents a **single database transaction**.
    An instance of [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    therefore **cannot be shared among concurrent threads or asyncio tasks without
    careful synchronization**. The [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is intended to be used in a **non-concurrent** fashion,
    that is, a particular instance of [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") should be used in only one thread or task at a time.
  prefs: []
  type: TYPE_NORMAL
- en: When using the [`AsyncSession`](extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession
    "sqlalchemy.ext.asyncio.AsyncSession") object from SQLAlchemy’s [asyncio](extensions/asyncio.html)
    extension, this object is only a thin proxy on top of a [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), and the same rules apply; it is an **unsynchronized,
    mutable, stateful object**, so it is **not** safe to use a single instance of
    [`AsyncSession`](extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession "sqlalchemy.ext.asyncio.AsyncSession")
    in multiple asyncio tasks at once.
  prefs: []
  type: TYPE_NORMAL
- en: An instance of [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    or [`AsyncSession`](extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession
    "sqlalchemy.ext.asyncio.AsyncSession") represents a single logical database transaction,
    referencing only a single [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") at a time for a particular [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") or [`AsyncEngine`](extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncEngine
    "sqlalchemy.ext.asyncio.AsyncEngine") to which the object is bound (note that
    these objects both support being bound to multiple engines at once, however in
    this case there will still be only one connection per engine in play within the
    scope of a transaction).
  prefs: []
  type: TYPE_NORMAL
- en: A database connection within a transaction is also a stateful object that is
    intended to be operated upon in a non-concurrent, sequential fashion. Commands
    are issued on the connection in a sequence, which are handled by the database
    server in the exact order in which they are emitted. As the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") emits commands upon this connection and receives results,
    the [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    itself is transitioning through internal state changes that align with the state
    of commands and data present on this connection; states which include if a transaction
    were begun, committed, or rolled back, what SAVEPOINTs if any are in play, as
    well as fine-grained synchronization of the state of individual database rows
    with local ORM-mapped objects.
  prefs: []
  type: TYPE_NORMAL
- en: When designing database applications for concurrency, the appropriate model
    is that each concurrent task / thread works with its own database transaction.
    This is why when discussing the issue of database concurrency, the standard terminology
    used is **multiple, concurrent transactions**. Within traditional RDMS there is
    no analogue for a single database transaction that is receiving and processing
    multiple commands concurrently.
  prefs: []
  type: TYPE_NORMAL
- en: The concurrency model for SQLAlchemy’s [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") and [`AsyncSession`](extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession
    "sqlalchemy.ext.asyncio.AsyncSession") is therefore **Session per thread, AsyncSession
    per task**. An application that uses multiple threads, or multiple tasks in asyncio
    such as when using an API like `asyncio.gather()` would want to ensure that each
    thread has its own [`Session`](session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session"),
    each asyncio task has its own [`AsyncSession`](extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession
    "sqlalchemy.ext.asyncio.AsyncSession").
  prefs: []
  type: TYPE_NORMAL
- en: The best way to ensure this use is by using the [standard context manager pattern](#session-getting)
    locally within the top level Python function that is inside the thread or task,
    which will ensure the lifespan of the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") or [`AsyncSession`](extensions/asyncio.html#sqlalchemy.ext.asyncio.AsyncSession
    "sqlalchemy.ext.asyncio.AsyncSession") is maintained within a local scope.
  prefs: []
  type: TYPE_NORMAL
- en: For applications that benefit from having a “global” [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") where it’s not an option to pass the [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") object to specific functions and methods which require
    it, the [`scoped_session`](contextual.html#sqlalchemy.orm.scoped_session "sqlalchemy.orm.scoped_session")
    approach can provide for a “thread local” [`Session`](session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") object; see the section [Contextual/Thread-local Sessions](contextual.html#unitofwork-contextual)
    for background. Within the asyncio context, the [`async_scoped_session`](extensions/asyncio.html#sqlalchemy.ext.asyncio.async_scoped_session
    "sqlalchemy.ext.asyncio.async_scoped_session") object is the asyncio analogue
    for [`scoped_session`](contextual.html#sqlalchemy.orm.scoped_session "sqlalchemy.orm.scoped_session"),
    however is more challenging to configure as it requires a custom “context” function.
  prefs: []
  type: TYPE_NORMAL
