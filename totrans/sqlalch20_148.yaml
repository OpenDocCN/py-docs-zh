- en: What’s New in SQLAlchemy 0.7?
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SQLAlchemy 0.7中的新功能？
- en: 原文：[https://docs.sqlalchemy.org/en/20/changelog/migration_07.html](https://docs.sqlalchemy.org/en/20/changelog/migration_07.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://docs.sqlalchemy.org/en/20/changelog/migration_07.html](https://docs.sqlalchemy.org/en/20/changelog/migration_07.html)
- en: About this Document
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 关于本文档
- en: This document describes changes between SQLAlchemy version 0.6, last released
    May 5, 2012, and SQLAlchemy version 0.7, undergoing maintenance releases as of
    October, 2012.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本文描述了SQLAlchemy版本0.6（最后发布于2012年5月5日）和SQLAlchemy版本0.7（截至2012年10月正在进行维护发布）之间的更改。
- en: 'Document date: July 27, 2011'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 文档日期：2011年7月27日
- en: Introduction
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍
- en: This guide introduces what’s new in SQLAlchemy version 0.7, and also documents
    changes which affect users migrating their applications from the 0.6 series of
    SQLAlchemy to 0.7.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本指南介绍了SQLAlchemy版本0.7中的新功能，还记录了影响用户将其应用程序从SQLAlchemy 0.6系列迁移到0.7的更改。
- en: To as great a degree as possible, changes are made in such a way as to not break
    compatibility with applications built for 0.6\. The changes that are necessarily
    not backwards compatible are very few, and all but one, the change to mutable
    attribute defaults, should affect an exceedingly small portion of applications
    - many of the changes regard non-public APIs and undocumented hacks some users
    may have been attempting to use.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 尽可能地，更改是以不破坏为0.6构建的应用程序的兼容性的方式进行的。必然不向后兼容的更改非常少，除了可变属性默认值的更改之外，应该只影响极小部分应用程序
    - 许多更改涉及非公共API和一些用户可能一直在尝试使用的未记录的黑客。
- en: A second, even smaller class of non-backwards-compatible changes is also documented.
    This class of change regards those features and behaviors that have been deprecated
    at least since version 0.5 and have been raising warnings since their deprecation.
    These changes would only affect applications that are still using 0.4- or early
    0.5-style APIs. As the project matures, we have fewer and fewer of these kinds
    of changes with 0.x level releases, which is a product of our API having ever
    fewer features that are less than ideal for the use cases they were meant to solve.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 还有第二个更小的非向后兼容更改类别也有文档记录。这类更改涉及那些至少自0.5版本以来已被弃用并自弃用以来一直引发警告的功能和行为。这些更改只会影响仍在使用0.4或早期0.5风格API的应用程序。随着项目的成熟，我们在0.x级别发布中有越来越少这类更改，这是由于我们的API具有越来越少的功能，这些功能不太适合它们原本要解决的用例。
- en: An array of existing functionalities have been superseded in SQLAlchemy 0.7\.
    There’s not much difference between the terms “superseded” and “deprecated”, except
    that the former has a much weaker suggestion of the old feature would ever be
    removed. In 0.7, features like `synonym` and `comparable_property`, as well as
    all the `Extension` and other event classes, have been superseded. But these “superseded”
    features have been re-implemented such that their implementations live mostly
    outside of core ORM code, so their continued “hanging around” doesn’t impact SQLAlchemy’s
    ability to further streamline and refine its internals, and we expect them to
    remain within the API for the foreseeable future.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 一系列现有功能在SQLAlchemy 0.7中已被取代。术语“取代”和“弃用”之间没有太大区别，只是前者更弱地暗示了旧功能可能会被移除。在0.7中，像`synonym`和`comparable_property`这样的功能，以及所有的`Extension`和其他事件类都已被取代。但这些“被取代”的功能已被重新实现，使得它们的实现大部分存在于核心ORM代码之外，因此它们的持续“挂在那里”并不影响SQLAlchemy进一步简化和完善其内部结构的能力，我们预计它们将在可预见的未来保留在API中。
- en: New Features
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 新功能
- en: New Event System
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 新事件系统
- en: SQLAlchemy started early with the `MapperExtension` class, which provided hooks
    into the persistence cycle of mappers. As SQLAlchemy quickly became more componentized,
    pushing mappers into a more focused configurational role, many more “extension”,
    “listener”, and “proxy” classes popped up to solve various activity-interception
    use cases in an ad-hoc fashion. Part of this was driven by the divergence of activities;
    `ConnectionProxy` objects wanted to provide a system of rewriting statements and
    parameters; `AttributeExtension` provided a system of replacing incoming values,
    and `DDL` objects had events that could be switched off of dialect-sensitive callables.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy早期使用了`MapperExtension`类，该类提供了对映射器持久性周期的钩子。随着SQLAlchemy迅速变得更加组件化，将映射器推入更专注的配置角色，许多更多的“扩展”，“监听器”和“代理”类出现，以以一种临时方式解决各种活动拦截用例。部分原因是由活动的分歧驱动的；`ConnectionProxy`对象希望提供一个重写语句和参数的系统；`AttributeExtension`提供了一个替换传入值的系统，而`DDL`对象具有可以根据方言敏感的可调用函数进行切换的事件。
- en: 0.7 re-implements virtually all of these plugin points with a new, unified approach,
    which retains all the functionalities of the different systems, provides more
    flexibility and less boilerplate, performs better, and eliminates the need to
    learn radically different APIs for each event subsystem. The pre-existing classes
    `MapperExtension`, `SessionExtension`, `AttributeExtension`, `ConnectionProxy`,
    `PoolListener` as well as the `DDLElement.execute_at` method are deprecated and
    now implemented in terms of the new system - these APIs remain fully functional
    and are expected to remain in place for the foreseeable future.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 0.7 版本重新实现了几乎所有这些插件点，采用了一种新的、统一的方法，保留了不同系统的所有功能，提供了更多的灵活性和更少的样板代码，性能更好，并且消除了需要为每个事件子系统学习根本不同的
    API 的必要性。之前存在的类 `MapperExtension`、`SessionExtension`、`AttributeExtension`、`ConnectionProxy`、`PoolListener`
    以及 `DDLElement.execute_at` 方法已被弃用，现在根据新系统实现 - 这些 API 仍然完全可用，并预计将在可预见的未来保持不变。
- en: The new approach uses named events and user-defined callables to associate activities
    with events. The API’s look and feel was driven by such diverse sources as JQuery,
    Blinker, and Hibernate, and was also modified further on several occasions during
    conferences with dozens of users on Twitter, which appears to have a much higher
    response rate than the mailing list for such questions.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 新方法使用命名事件和用户定义的可调用对象将活动与事件关联起来。API 的外观和感觉受到了 JQuery、Blinker 和 Hibernate 等多样化来源的驱动，并且在与数十位用户进行的
    Twitter 会议期间进行了多次修改，这似乎比邮件列表对此类问题的回应率要高得多。
- en: It also features an open-ended system of target specification that allows events
    to be associated with API classes, such as for all `Session` or `Engine` objects,
    with specific instances of API classes, such as for a specific `Pool` or `Mapper`,
    as well as for related objects like a user- defined class that’s mapped, or something
    as specific as a certain attribute on instances of a particular subclass of a
    mapped parent class. Individual listener subsystems can apply wrappers to incoming
    user- defined listener functions which modify how they are called - an mapper
    event can receive either the instance of the object being operated upon, or its
    underlying `InstanceState` object. An attribute event can opt whether or not to
    have the responsibility of returning a new value.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 它还具有一个开放式的目标规范系统，允许将事件与 API 类关联，例如所有 `Session` 或 `Engine` 对象，以及与 API 类的特定实例关联，例如特定的
    `Pool` 或 `Mapper`，以及与用户定义的类（映射的类）或特定子类的实例的特定属性等相关对象。各个监听器子系统可以对传入的用户定义监听器函数应用包装器，修改它们的调用方式
    - 映射器事件可以接收被操作对象的实例，或者其底层的 `InstanceState` 对象。属性事件可以选择是否有责任返回一个新值。
- en: Several systems now build upon the new event API, including the new “mutable
    attributes” API as well as composite attributes. The greater emphasis on events
    has also led to the introduction of a handful of new events, including attribute
    expiration and refresh operations, pickle loads/dumps operations, completed mapper
    construction operations.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 几个系统现在基于新的事件 API 进行构建，包括新的“可变属性” API 以及复合属性。对事件的更大强调还导致了一些新事件的引入，包括属性过期和刷新操作，pickle
    加载/转储操作，完成的映射器构建操作。
- en: See also
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Events](../core/event.html)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '[事件](../core/event.html)'
- en: '[#1902](https://www.sqlalchemy.org/trac/ticket/1902)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '[#1902](https://www.sqlalchemy.org/trac/ticket/1902)'
- en: Hybrid Attributes, implements/supersedes synonym(), comparable_property()
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Hybrid Attributes，实现/取代了 synonym()、comparable_property()
- en: The “derived attributes” example has now been turned into an official extension.
    The typical use case for `synonym()` is to provide descriptor access to a mapped
    column; the use case for `comparable_property()` is to be able to return a `PropComparator`
    from any descriptor. In practice, the approach of “derived” is easier to use,
    more extensible, is implemented in a few dozen lines of pure Python with almost
    no imports, and doesn’t require the ORM core to even be aware of it. The feature
    is now known as the “Hybrid Attributes” extension.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: “派生属性”示例现在已成为官方扩展。`synonym()` 的典型用例是为映射列提供描述符访问；`comparable_property()` 的用例是能够从任何描述符返回
    `PropComparator`。实际上，“派生”的方法更易于使用，更具可扩展性，用几十行纯 Python 实现，几乎不需要导入，甚至不需要 ORM 核心知道它。该功能现在被称为“Hybrid
    Attributes”扩展。
- en: '`synonym()` and `comparable_property()` are still part of the ORM, though their
    implementations have been moved outwards, building on an approach that is similar
    to that of the hybrid extension, so that the core ORM mapper/query/property modules
    aren’t really aware of them otherwise.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`synonym()`和`comparable_property()`仍然是ORM的一部分，尽管它们的实现已经移出，建立在类似于混合扩展的方法上，因此核心ORM映射器/查询/属性模块在其他方面并不真正意识到它们。'
- en: See also
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[Hybrid Attributes](../orm/extensions/hybrid.html)'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '[混合属性](../orm/extensions/hybrid.html)'
- en: '[#1903](https://www.sqlalchemy.org/trac/ticket/1903)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '[#1903](https://www.sqlalchemy.org/trac/ticket/1903)'
- en: Speed Enhancements
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 速度增强
- en: 'As is customary with all major SQLA releases, a wide pass through the internals
    to reduce overhead and callcounts has been made which further reduces the work
    needed in common scenarios. Highlights of this release include:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有主要SQLA版本一样，通过内部进行广泛遍历以减少开销和调用次数，进一步减少了常见情况下所需的工作量。此版本的亮点包括：
- en: The flush process will now bundle INSERT statements into batches fed to `cursor.executemany()`,
    for rows where the primary key is already present. In particular this usually
    applies to the “child” table on a joined table inheritance configuration, meaning
    the number of calls to `cursor.execute` for a large bulk insert of joined- table
    objects can be cut in half, allowing native DBAPI optimizations to take place
    for those statements passed to `cursor.executemany()` (such as re-using a prepared
    statement).
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 刷新过程现在将INSERT语句捆绑成批次提供给`cursor.executemany()`，对于主键已经存在的行。特别是这通常适用于连接表继承配置中的“子”表，这意味着对于大量连接表对象的大量插入，可以将对`cursor.execute`的调用次数减半，从而允许本地DBAPI优化为那些传递给`cursor.executemany()`的语句（如重用准备好的语句）。
- en: The codepath invoked when accessing a many-to-one reference to a related object
    that’s already loaded has been greatly simplified. The identity map is checked
    directly without the need to generate a new `Query` object first, which is expensive
    in the context of thousands of in-memory many-to-ones being accessed. The usage
    of constructed-per-call “loader” objects is also no longer used for the majority
    of lazy attribute loads.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当访问已加载的相关对象的多对一引用时调用的代码路径已经大大简化。直接检查标识映射，无需首先生成新的`Query`对象，这在上下文中访问成千上万个内存中的多对一时是昂贵的。对于大多数延迟属性加载，也不再使用每次调用构造的“加载器”对象。
- en: The rewrite of composites allows a shorter codepath when mapper internals access
    mapped attributes within a flush.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新编写组合使得在映射器内部访问刷新时映射属性的代码路径更短。
- en: New inlined attribute access functions replace the previous usage of “history”
    when the “save-update” and other cascade operations need to cascade among the
    full scope of datamembers associated with an attribute. This reduces the overhead
    of generating a new `History` object for this speed-critical operation.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的内联属性访问函数取代了以前在“保存-更新”和其他级联操作需要在属性关联的所有数据成员范围内级联时使用“历史”时的用法。这减少了为这个速度关键操作生成新的`History`对象的开销。
- en: The internals of the `ExecutionContext`, the object corresponding to a statement
    execution, have been inlined and simplified.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ExecutionContext`的内部，即对语句执行的对象，已经被内联和简化。'
- en: The `bind_processor()` and `result_processor()` callables generated by types
    for each statement execution are now cached (carefully, so as to avoid memory
    leaks for ad-hoc types and dialects) for the lifespan of that type, further reducing
    per-statement call overhead.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为每个语句执行生成的类型的`bind_processor()`和`result_processor()`可调用现在被缓存（小心处理，以避免临时类型和方言的内存泄漏）为该类型的生命周期，进一步减少每个语句的调用开销。
- en: The collection of “bind processors” for a particular `Compiled` instance of
    a statement is also cached on the `Compiled` object, taking further advantage
    of the “compiled cache” used by the flush process to re-use the same compiled
    form of INSERT, UPDATE, DELETE statements.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特定语句的`Compiled`实例的“绑定处理器”集合也被缓存在`Compiled`对象上，进一步利用刷新过程使用的“编译缓存”来重用相同的编译形式的INSERT、UPDATE、DELETE语句。
- en: A demonstration of callcount reduction including a sample benchmark script is
    at [https://techspot.zzzeek.org/2010/12/12/a-tale-of-three](https://techspot.zzzeek.org/2010/12/12/a-tale-of-three)-
    profiles/
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 包括一个示例基准脚本在内的减少调用次数的演示可在[https://techspot.zzzeek.org/2010/12/12/a-tale-of-three](https://techspot.zzzeek.org/2010/12/12/a-tale-of-three)-
    profiles/中找到。
- en: Composites Rewritten
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重写组合
- en: The “composite” feature has been rewritten, like `synonym()` and `comparable_property()`,
    to use a lighter weight implementation based on descriptors and events, rather
    than building into the ORM internals. This allowed the removal of some latency
    from the mapper/unit of work internals, and simplifies the workings of composite.
    The composite attribute now no longer conceals the underlying columns it builds
    upon, which now remain as regular attributes. Composites can also act as a proxy
    for `relationship()` as well as `Column()` attributes.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: “复合”特性已被重写，与`synonym()`和`comparable_property()`一样，使用了基于描述符和事件的轻量级实现，而不是构建到ORM内部。这使得从映射器/工作单元内部删除了一些延迟，并简化了复合的工作原理。复合属性现在不再隐藏其建立在其上的基础列，这些列现在保持为常规属性。复合对象还可以充当`relationship()`以及`Column()`属性的代理。
- en: The major backwards-incompatible change of composites is that they no longer
    use the `mutable=True` system to detect in-place mutations. Please use the [Mutation
    Tracking](https://www.sqlalchemy.org/docs/07/orm/extensions/mutable.html) extension
    to establish in-place change events to existing composite usage.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 复合的主要向后不兼容变更是，它们不再使用`mutable=True`系统来检测原地突变。请使用[Mutation Tracking](https://www.sqlalchemy.org/docs/07/orm/extensions/mutable.html)扩展来建立对现有复合用法的原位更改事件。
- en: See also
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Composite Column Types](../orm/composites.html#mapper-composite)'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '[复合列类型](../orm/composites.html#mapper-composite)'
- en: '[Mutation Tracking](../orm/extensions/mutable.html)'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '[突变追踪](../orm/extensions/mutable.html)'
- en: '[#2008](https://www.sqlalchemy.org/trac/ticket/2008) [#2024](https://www.sqlalchemy.org/trac/ticket/2024)'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2008](https://www.sqlalchemy.org/trac/ticket/2008) [#2024](https://www.sqlalchemy.org/trac/ticket/2024)'
- en: More succinct form of query.join(target, onclause)
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更简洁的查询.join(target, onclause)形式
- en: 'The default method of issuing `query.join()` to a target with an explicit onclause
    is now:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 向具有显式 onclause 的目标发出`query.join()`的默认方法现在是：
- en: '[PRE0]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In 0.6, this usage was considered to be an error, because `join()` accepts multiple
    arguments corresponding to multiple JOIN clauses - the two-argument form needed
    to be in a tuple to disambiguate between single-argument and two- argument join
    targets. In the middle of 0.6 we added detection and an error message for this
    specific calling style, since it was so common. In 0.7, since we are detecting
    the exact pattern anyway, and since having to type out a tuple for no reason is
    extremely annoying, the non- tuple method now becomes the “normal” way to do it.
    The “multiple JOIN” use case is exceedingly rare compared to the single join case,
    and multiple joins these days are more clearly represented by multiple calls to
    `join()`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在0.6版本中，此用法被认为是错误的，因为`join()`接受多个参数，对应于多个JOIN子句 - 两个参数形式需要在元组中以消除单参数和双参数连接目标之间的歧义。在0.6的中间，我们添加了对此特定调用样式的检测和错误消息，因为它是如此常见。在0.7中，由于我们无论如何都在检测确切的模式，并且由于为了没有理由而必须键入元组而极端烦人，因此非元组方法现在成为“正常”方法。这种“多个JOIN”用例与单个JOIN用例相比极为罕见，而且这些天多次连接更清楚地表示为多次调用`join()`。
- en: The tuple form will remain for backwards compatibility.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 元组形式将保留以确保向后兼容性。
- en: 'Note that all the other forms of `query.join()` remain unchanged:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，所有其他形式的`query.join()`保持不变：
- en: '[PRE1]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[Querying with Joins](https://www.sqlalchemy.org/docs/07/orm/tutorial.html#querying-with-joins)'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用联接查询](https://www.sqlalchemy.org/docs/07/orm/tutorial.html#querying-with-joins)'
- en: '[#1923](https://www.sqlalchemy.org/trac/ticket/1923)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '[#1923](https://www.sqlalchemy.org/trac/ticket/1923)'
- en: '### Mutation event extension, supersedes “mutable=True”'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '### 突变事件扩展，取代了“mutable=True”'
- en: A new extension, [Mutation Tracking](../orm/extensions/mutable.html), provides
    a mechanism by which user-defined datatypes can provide change events back to
    the owning parent or parents. The extension includes an approach for scalar database
    values, such as those managed by [`PickleType`](../core/type_basics.html#sqlalchemy.types.PickleType
    "sqlalchemy.types.PickleType"), `postgresql.ARRAY`, or other custom `MutableType`
    classes, as well as an approach for ORM “composites”, those configured using [`composite()`](../orm/composites.html#sqlalchemy.orm.composite
    "sqlalchemy.orm.composite").
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 一个新的扩展，[突变追踪](../orm/extensions/mutable.html)，提供了一种机制，通过该机制，用户定义的数据类型可以向拥有的父对象提供更改事件。该扩展包括了一种用于标量数据库值的方法，例如由[`PickleType`](../core/type_basics.html#sqlalchemy.types.PickleType
    "sqlalchemy.types.PickleType")、`postgresql.ARRAY`或其他自定义`MutableType`类管理的值，以及一种用于ORM“复合”对象的方法，这些对象使用[`composite()`](../orm/composites.html#sqlalchemy.orm.composite
    "sqlalchemy.orm.composite")进行配置。
- en: See also
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Mutation Tracking](../orm/extensions/mutable.html)'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '[突变追踪](../orm/extensions/mutable.html)'
- en: NULLS FIRST / NULLS LAST operators
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: NULLS FIRST / NULLS LAST 运算符
- en: These are implemented as an extension to the `asc()` and `desc()` operators,
    called `nullsfirst()` and `nullslast()`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这些作为 `asc()` 和 `desc()` 操作符的扩展实现，称为 `nullsfirst()` 和 `nullslast()`。
- en: See also
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 另见
- en: '[`nullsfirst()`](../core/sqlelement.html#sqlalchemy.sql.expression.nullsfirst
    "sqlalchemy.sql.expression.nullsfirst")'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '[`nullsfirst()`](../core/sqlelement.html#sqlalchemy.sql.expression.nullsfirst
    "sqlalchemy.sql.expression.nullsfirst")'
- en: '[`nullslast()`](../core/sqlelement.html#sqlalchemy.sql.expression.nullslast
    "sqlalchemy.sql.expression.nullslast")'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '[`nullslast()`](../core/sqlelement.html#sqlalchemy.sql.expression.nullslast
    "sqlalchemy.sql.expression.nullslast")'
- en: '[#723](https://www.sqlalchemy.org/trac/ticket/723)'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '[#723](https://www.sqlalchemy.org/trac/ticket/723)'
- en: select.distinct(), query.distinct() accepts *args for PostgreSQL DISTINCT ON
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: select.distinct()、query.distinct() 接受 *args 用于 PostgreSQL 的 DISTINCT ON
- en: This was already available by passing a list of expressions to the `distinct`
    keyword argument of `select()`, the `distinct()` method of `select()` and `Query`
    now accept positional arguments which are rendered as DISTINCT ON when a PostgreSQL
    backend is used.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 通过向 `select()` 的 `distinct` 关键字参数传递表达式列表，现在当使用 PostgreSQL 后端时，`select()` 和 `Query`
    的 `distinct()` 方法接受位置参数，这些参数将被渲染为 DISTINCT ON。
- en: '[distinct()](https://www.sqlalchemy.org/docs/07/core/expression_api.html#sqlalchemy.sql.expression.Select.distinct)'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '[distinct()](https://www.sqlalchemy.org/docs/07/core/expression_api.html#sqlalchemy.sql.expression.Select.distinct)'
- en: '[Query.distinct()](https://www.sqlalchemy.org/docs/07/orm/query.html#sqlalchemy.orm.query.Query.distinct)'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '[Query.distinct()](https://www.sqlalchemy.org/docs/07/orm/query.html#sqlalchemy.orm.query.Query.distinct)'
- en: '[#1069](https://www.sqlalchemy.org/trac/ticket/1069)'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '[#1069](https://www.sqlalchemy.org/trac/ticket/1069)'
- en: '`Index()` can be placed inline inside of `Table`, `__table_args__`'
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`Index()` 可以嵌入到 `Table`、`__table_args__` 内。'
- en: 'The Index() construct can be created inline with a Table definition, using
    strings as column names, as an alternative to the creation of the index outside
    of the Table. That is:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Index() 构造可以与 Table 定义一起内联创建，使用字符串作为列名，作为在 Table 外部创建索引的替代方法。即：
- en: '[PRE2]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The primary rationale here is for the benefit of declarative `__table_args__`,
    particularly when used with mixins:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的主要理由是为了声明性 `__table_args__` 的利益，特别是与混入类一起使用时：
- en: '[PRE3]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[Indexes](https://www.sqlalchemy.org/docs/07/core/schema.html#indexes)'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '[Indexes](https://www.sqlalchemy.org/docs/07/core/schema.html#indexes)'
- en: Window Function SQL Construct
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 窗口函数 SQL 结构
- en: A “window function” provides to a statement information about the result set
    as it’s produced. This allows criteria against various things like “row number”,
    “rank” and so forth. They are known to be supported at least by PostgreSQL, SQL
    Server and Oracle, possibly others.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: “窗口函数”在语句生成结果集时向其提供信息。这允许针对诸如“行号”、“排名”等各种条件进行判断。已知至少由 PostgreSQL、SQL Server
    和 Oracle 支持。可能还有其他数据库也支持。
- en: 'The best introduction to window functions is on PostgreSQL’s site, where window
    functions have been supported since version 8.4:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的窗口函数介绍在 PostgreSQL 网站上，自从版本 8.4 开始就支持窗口函数：
- en: '[https://www.postgresql.org/docs/current/static/tutorial-window.html](https://www.postgresql.org/docs/current/static/tutorial-window.html)'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.postgresql.org/docs/current/static/tutorial-window.html](https://www.postgresql.org/docs/current/static/tutorial-window.html)'
- en: 'SQLAlchemy provides a simple construct typically invoked via an existing function
    clause, using the `over()` method, which accepts `order_by` and `partition_by`
    keyword arguments. Below we replicate the first example in PG’s tutorial:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 提供了一个简单的构造，通常通过现有函数子句调用，使用 `over()` 方法，该方法接受 `order_by` 和 `partition_by`
    关键字参数。下面我们复制了 PG 教程中的第一个示例：
- en: '[PRE4]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'SQL:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 'SQL:'
- en: '[PRE5]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[sqlalchemy.sql.expression.over](https://www.sqlalchemy.org/docs/07/core/expression_api.html#sqlalchemy.sql.expression.over)'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '[sqlalchemy.sql.expression.over](https://www.sqlalchemy.org/docs/07/core/expression_api.html#sqlalchemy.sql.expression.over)'
- en: '[#1844](https://www.sqlalchemy.org/trac/ticket/1844)'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '[#1844](https://www.sqlalchemy.org/trac/ticket/1844)'
- en: execution_options() on Connection accepts “isolation_level” argument
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Connection 上的 execution_options() 接受 “isolation_level” 参数
- en: This sets the transaction isolation level for a single `Connection`, until that
    `Connection` is closed and its underlying DBAPI resource returned to the connection
    pool, upon which the isolation level is reset back to the default. The default
    isolation level is set using the `isolation_level` argument to `create_engine()`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这为单个 `Connection` 设置了事务隔离级别，直到该 `Connection` 关闭并且其底层的 DBAPI 资源返回到连接池，此时隔离级别将重置回默认值。默认的隔离级别是通过
    `create_engine()` 的 `isolation_level` 参数设置的。
- en: Transaction isolation support is currently only supported by the PostgreSQL
    and SQLite backends.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 目前只有 PostgreSQL 和 SQLite 后端支持事务隔离。
- en: '[execution_options()](https://www.sqlalchemy.org/docs/07/core/connections.html#sqlalchemy.engine.base.Connection.execution_options)'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '[execution_options()](https://www.sqlalchemy.org/docs/07/core/connections.html#sqlalchemy.engine.base.Connection.execution_options)'
- en: '[#2001](https://www.sqlalchemy.org/trac/ticket/2001)'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2001](https://www.sqlalchemy.org/trac/ticket/2001)'
- en: '`TypeDecorator` works with integer primary key columns'
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`TypeDecorator`与整数主键列一起工作'
- en: A `TypeDecorator` which extends the behavior of `Integer` can be used with a
    primary key column. The “autoincrement” feature of `Column` will now recognize
    that the underlying database column is still an integer so that lastrowid mechanisms
    continue to function. The `TypeDecorator` itself will have its result value processor
    applied to newly generated primary keys, including those received by the DBAPI
    `cursor.lastrowid` accessor.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用扩展`Integer`行为的`TypeDecorator`与主键列一起使用。`Column`的“autoincrement”功能现在将识别底层数据库列仍然是整数，以便继续使
    lastrowid 机制正常工作。`TypeDecorator`本身的结果值处理器将应用于新生成的主键，包括通过 DBAPI `cursor.lastrowid`
    访问器接收的主键。
- en: '[#2005](https://www.sqlalchemy.org/trac/ticket/2005) [#2006](https://www.sqlalchemy.org/trac/ticket/2006)'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2005](https://www.sqlalchemy.org/trac/ticket/2005) [#2006](https://www.sqlalchemy.org/trac/ticket/2006)'
- en: '`TypeDecorator` is present in the “sqlalchemy” import space'
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`TypeDecorator`存在于“sqlalchemy”导入空间中'
- en: No longer need to import this from `sqlalchemy.types`, it’s now mirrored in
    `sqlalchemy`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 不再需要从`sqlalchemy.types`导入，现在在`sqlalchemy`中有镜像。
- en: New Dialects
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 新方言
- en: 'Dialects have been added:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 已添加方言：
- en: 'a MySQLdb driver for the Drizzle database:'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于 Drizzle 数据库的 MySQLdb 驱动程序：
- en: '[Drizzle](https://www.sqlalchemy.org/docs/07/dialects/drizzle.html)'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[Drizzle](https://www.sqlalchemy.org/docs/07/dialects/drizzle.html)'
- en: 'support for the pymysql DBAPI:'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持 pymysql DBAPI：
- en: '[pymsql Notes](https://www.sqlalchemy.org/docs/07/dialects/mysql.html#module-sqlalchemy.dialects.mysql.pymysql)'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[pymsql Notes](https://www.sqlalchemy.org/docs/07/dialects/mysql.html#module-sqlalchemy.dialects.mysql.pymysql)'
- en: psycopg2 now works with Python 3
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: psycopg2 现在支持 Python 3
- en: Behavioral Changes (Backwards Compatible)
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 行为变化（向后兼容）
- en: C Extensions Build by Default
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 默认情况下构建 C 扩展
- en: This is as of 0.7b4\. The exts will build if cPython 2.xx is detected. If the
    build fails, such as on a windows install, that condition is caught and the non-C
    install proceeds. The C exts won’t build if Python 3 or PyPy is used.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这是从0.7b4开始的。如果检测到 cPython 2.xx，则会构建扩展。如果构建失败，例如在 Windows 安装中，会捕获该条件并继续非 C 安装。如果使用
    Python 3 或 PyPy，则不会构建 C 扩展。
- en: Query.count() simplified, should work virtually always
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 简化了 Query.count()，几乎总是有效
- en: 'The very old guesswork which occurred within `Query.count()` has been modernized
    to use `.from_self()`. That is, `query.count()` is now equivalent to:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`Query.count()`中非常古老的猜测现在已经现代化，使用`.from_self()`。也就是说，`query.count()`现在等效于：'
- en: '[PRE6]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Previously, internal logic attempted to rewrite the columns clause of the query
    itself, and upon detection of a “subquery” condition, such as a column-based query
    that might have aggregates in it, or a query with DISTINCT, would go through a
    convoluted process of rewriting the columns clause. This logic failed in complex
    conditions, particularly those involving joined table inheritance, and was long
    obsolete by the more comprehensive `.from_self()` call.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，内部逻辑尝试重写查询本身的列子句，并在检测到“子查询”条件时，例如可能在其中包含聚合的基于列的查询，或者具有 DISTINCT 的查询时，会经历一个复杂的过程来重写列子句。这种逻辑在复杂条件下失败，特别是涉及联接表继承的条件，并且长期以来已经被更全面的`.from_self()`调用所取代。
- en: 'The SQL emitted by `query.count()` is now always of the form:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`query.count()`现在始终生成以下形式的SQL：'
- en: '[PRE7]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: that is, the original query is preserved entirely inside of a subquery, with
    no more guessing as to how count should be applied.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，原始查询完全保留在子查询中，不再猜测如何应用 count。
- en: '[#2093](https://www.sqlalchemy.org/trac/ticket/2093)'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2093](https://www.sqlalchemy.org/trac/ticket/2093)'
- en: To emit a non-subquery form of count()
  id: totrans-111
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 发出非子查询形式的 count()
- en: 'MySQL users have already reported that the MyISAM engine not surprisingly falls
    over completely with this simple change. Note that for a simple `count()` that
    optimizes for DBs that can’t handle simple subqueries, `func.count()` should be
    used:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL 用户已经报告说 MyISAM 引擎不出所料地完全崩溃了。请注意，对于优化不能处理简单子查询的数据库的简单`count()`，应该使用`func.count()`：
- en: '[PRE8]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'or for `count(*)`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 或者对于`count(*)`：
- en: '[PRE9]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: LIMIT/OFFSET clauses now use bind parameters
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: LIMIT/OFFSET 子句现在使用绑定参数
- en: The LIMIT and OFFSET clauses, or their backend equivalents (i.e. TOP, ROW NUMBER
    OVER, etc.), use bind parameters for the actual values, for all backends which
    support it (most except for Sybase). This allows better query optimizer performance
    as the textual string for multiple statements with differing LIMIT/OFFSET are
    now identical.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: LIMIT 和 OFFSET 子句，或其后端等效项（即 TOP、ROW NUMBER OVER 等），对于所有支持的后端（除了 Sybase），使用绑定参数进行实际值，这允许更好的查询优化器性能，因为具有不同
    LIMIT/OFFSET 的多个语句的文本字符串现在是相同的。
- en: '[#805](https://www.sqlalchemy.org/trac/ticket/805)'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '[#805](https://www.sqlalchemy.org/trac/ticket/805)'
- en: Logging enhancements
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 日志增强
- en: Vinay Sajip has provided a patch to our logging system such that the “hex string”
    embedded in logging statements for engines and pools is no longer needed to allow
    the `echo` flag to work correctly. A new system that uses filtered logging objects
    allows us to maintain our current behavior of `echo` being local to individual
    engines without the need for additional identifying strings local to those engines.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Vinay Sajip 提供了一个补丁，使我们的日志系统中不再需要嵌入在引擎和池日志语句中的“十六进制字符串”以使 `echo` 标志能够正常工作。使用过滤日志对象的新系统使我们能够保持当前行为，即
    `echo` 仅适用于各个引擎，而无需为这些引擎添加额外的标识字符串。
- en: '[#1926](https://www.sqlalchemy.org/trac/ticket/1926)'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '[#1926](https://www.sqlalchemy.org/trac/ticket/1926)'
- en: Simplified polymorphic_on assignment
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 简化的 polymorphic_on 赋值
- en: 'The population of the `polymorphic_on` column-mapped attribute, when used in
    an inheritance scenario, now occurs when the object is constructed, i.e. its `__init__`
    method is called, using the init event. The attribute then behaves the same as
    any other column-mapped attribute. Previously, special logic would fire off during
    flush to populate this column, which prevented any user code from modifying its
    behavior. The new approach improves upon this in three ways: 1\. the polymorphic
    identity is now present on the object as soon as its constructed; 2\. the polymorphic
    identity can be changed by user code without any difference in behavior from any
    other column-mapped attribute; 3\. the internals of the mapper during flush are
    simplified and no longer need to make special checks for this column.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当在继承场景中使用时，`polymorphic_on` 列映射属性的填充现在发生在对象构造时，即其 `__init__` 方法被调用时，使用 init
    事件。然后，该属性的行为与任何其他列映射属性相同。以前，特殊逻辑会在刷新期间触发以填充此列，这会阻止任何用户代码修改其行为。新方法在三个方面改进了这一点：1.
    多态标识现在在对象构造时立即存在；2. 多态标识可以被用户代码更改，而不会与任何其他列映射属性的行为有任何区别；3. 刷新期间映射器的内部简化，不再需要对此列进行特殊检查。
- en: '[#1895](https://www.sqlalchemy.org/trac/ticket/1895)'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '[#1895](https://www.sqlalchemy.org/trac/ticket/1895)'
- en: contains_eager() chains across multiple paths (i.e. “all()”)
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在多个路径（即“all()”）上进行 contains_eager() 链
- en: 'The ``contains_eager()[PRE10]contains_eager()`` calls. Instead of:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '``contains_eager()[PRE10]contains_eager()`` 调用。而不是：'
- en: '[PRE11]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'you can say:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以说：
- en: '[PRE12]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[#2032](https://www.sqlalchemy.org/trac/ticket/2032)'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2032](https://www.sqlalchemy.org/trac/ticket/2032)'
- en: Flushing of orphans that have no parent is allowed
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 允许刷新没有父级的孤立对象
- en: We’ve had a long standing behavior that checks for a so- called “orphan” during
    flush, that is, an object which is associated with a `relationship()` that specifies
    “delete- orphan” cascade, has been newly added to the session for an INSERT, and
    no parent relationship has been established. This check was added years ago to
    accommodate some test cases which tested the orphan behavior for consistency.
    In modern SQLA, this check is no longer needed on the Python side. The equivalent
    behavior of the “orphan check” is accomplished by making the foreign key reference
    to the object’s parent row NOT NULL, where the database does its job of establishing
    data consistency in the same way SQLA allows most other operations to do. If the
    object’s parent foreign key is nullable, then the row can be inserted. The “orphan”
    behavior runs when the object was persisted with a particular parent, and is then
    disassociated with that parent, leading to a DELETE statement emitted for it.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直有一个长期存在的行为，即在刷新期间检查所谓的“孤立对象”，即与指定“delete-orphan”级联的 `relationship()` 关联的对象，已经被新增到会话中进行插入，并且没有建立父关系。多年前添加了此检查以适应一些测试用例，这些测试用例测试了孤立行为的一致性。在现代
    SQLA 中，此检查在 Python 端不再需要。通过使外键引用对象的父行 NOT NULL，数据库会以与 SQLA 允许大多数其他操作相同的方式建立数据一致性。如果对象的父外键可为空，则可以插入行。当对象与特定父对象一起持久化，然后与该父对象解除关联时，会触发“孤立”行为，导致为其发出
    DELETE 语句。
- en: '[#1912](https://www.sqlalchemy.org/trac/ticket/1912)'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '[#1912](https://www.sqlalchemy.org/trac/ticket/1912)'
- en: Warnings generated when collection members, scalar referents not part of the
    flush
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在刷新时生成警告，当集合成员、标量引用不在刷新中时
- en: Warnings are now emitted when related objects referenced via a loaded `relationship()`
    on a parent object marked as “dirty” are not present in the current `Session`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当父对象上标记为 “脏” 的加载的 `relationship()` 引用的相关对象不在当前 `Session` 中时，现在会发出警告。
- en: The `save-update` cascade takes effect when objects are added to the `Session`,
    or when objects are first associated with a parent, so that an object and everything
    related to it are usually all present in the same `Session`. However, if `save-update`
    cascade is disabled for a particular `relationship()`, then this behavior does
    not occur, and the flush process does not try to correct for it, instead staying
    consistent to the configured cascade behavior. Previously, when such objects were
    detected during the flush, they were silently skipped. The new behavior is that
    a warning is emitted, for the purposes of alerting to a situation that more often
    than not is the source of unexpected behavior.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当对象添加到 `Session` 中或首次与父对象关联时，`save-update` 级联生效，因此对象及其相关内容通常都存在于同一个 `Session`
    中。然而，如果对于特定的 `relationship()` 禁用了 `save-update` 级联，则不会发生这种行为，刷新过程也不会尝试纠正它，而是保持与配置的级联行为一致。以前，在刷新时检测到这样的对象时，它们会被静默跳过。新的行为是发出警告，目的是提醒可能是意外行为来源的情况。
- en: '[#1973](https://www.sqlalchemy.org/trac/ticket/1973)'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '[#1973](https://www.sqlalchemy.org/trac/ticket/1973)'
- en: Setup no longer installs a Nose plugin
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装程序不再安装 Nose 插件
- en: Since we moved to nose we’ve used a plugin that installs via setuptools, so
    that the `nosetests` script would automatically run SQLA’s plugin code, necessary
    for our tests to have a full environment. In the middle of 0.6, we realized that
    the import pattern here meant that Nose’s “coverage” plugin would break, since
    “coverage” requires that it be started before any modules to be covered are imported;
    so in the middle of 0.6 we made the situation worse by adding a separate `sqlalchemy-nose`
    package to the build to overcome this.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 自从我们转向 nose 以来，我们使用了一个通过 setuptools 安装的插件，这样 `nosetests` 脚本会自动运行 SQLA 的插件代码，这对于我们的测试来说是必要的，以便具有完整的环境。在
    0.6 中间，我们意识到这里的导入模式意味着 Nose 的 “coverage” 插件会中断，因为 “coverage” 要求在导入要覆盖的任何模块之前启动它；因此，在
    0.6 中间，我们通过添加一个单独的 `sqlalchemy-nose` 包来解决这个问题，使情况变得更糟。
- en: In 0.7 we’ve done away with trying to get `nosetests` to work automatically,
    since the SQLAlchemy module would produce a large number of nose configuration
    options for all usages of `nosetests`, not just the SQLAlchemy unit tests themselves,
    and the additional `sqlalchemy-nose` install was an even worse idea, producing
    an extra package in Python environments. The `sqla_nose.py` script in 0.7 is now
    the only way to run the tests with nose.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在 0.7 中，我们放弃了尝试让 `nosetests` 自动工作，因为 SQLAlchemy 模块会为所有使用 `nosetests` 的用法产生大量的
    nose 配置选项，不仅仅是 SQLAlchemy 单元测试本身，而且额外的 `sqlalchemy-nose` 安装是一个更糟糕的想法，在 Python
    环境中产生了一个额外的包。在 0.7 中，`sqla_nose.py` 脚本现在是使用 nose 运行测试的唯一方法。
- en: '[#1949](https://www.sqlalchemy.org/trac/ticket/1949)'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '[#1949](https://www.sqlalchemy.org/trac/ticket/1949)'
- en: Non-`Table`-derived constructs can be mapped
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 非 `Table` 派生的构造可以被映射
- en: A construct that isn’t against any `Table` at all, like a function, can be mapped.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 一个根本不针对任何 `Table` 的构造，比如一个函数，可以被映射。
- en: '[PRE13]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[#1876](https://www.sqlalchemy.org/trac/ticket/1876)'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '[#1876](https://www.sqlalchemy.org/trac/ticket/1876)'
- en: aliased() accepts `FromClause` elements
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: aliased() 接受 `FromClause` 元素
- en: This is a convenience helper such that in the case a plain `FromClause`, such
    as a `select`, `Table` or `join` is passed to the `orm.aliased()` construct, it
    passes through to the `.alias()` method of that from construct rather than constructing
    an ORM level `AliasedClass`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个方便的辅助程序，当传递一个普通的 `FromClause`，比如一个 `select`、`Table` 或 `join` 到 `orm.aliased()`
    构造时，它会通过到达该 from 构造的 `.alias()` 方法，而不是构造一个 ORM 级别的 `AliasedClass`。
- en: '[#2018](https://www.sqlalchemy.org/trac/ticket/2018)'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2018](https://www.sqlalchemy.org/trac/ticket/2018)'
- en: Session.connection(), Session.execute() accept ‘bind’
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Session.connection()，Session.execute() 接受 ‘bind’
- en: This is to allow execute/connection operations to participate in the open transaction
    of an engine explicitly. It also allows custom subclasses of `Session` that implement
    their own `get_bind()` method and arguments to use those custom arguments with
    both the `execute()` and `connection()` methods equally.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这是为了允许 execute/connection 操作明确参与引擎的开放事务。它还允许自定义的 `Session` 子类实现自己的 `get_bind()`
    方法和参数，以便在 `execute()` 和 `connection()` 方法中同样使用这些自定义参数。
- en: '[Session.connection](https://www.sqlalchemy.org/docs/07/orm/session.html#sqlalchemy.orm.session.Session.connection)
    [Session.execute](https://www.sqlalchemy.org/docs/07/orm/session.html#sqlalchemy.orm.session.Session.execute)'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '[Session.connection](https://www.sqlalchemy.org/docs/07/orm/session.html#sqlalchemy.orm.session.Session.connection)
    [Session.execute](https://www.sqlalchemy.org/docs/07/orm/session.html#sqlalchemy.orm.session.Session.execute)'
- en: '[#1996](https://www.sqlalchemy.org/trac/ticket/1996)'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '[#1996](https://www.sqlalchemy.org/trac/ticket/1996)'
- en: Standalone bind parameters in columns clause auto-labeled.
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 独立的绑定参数在列子句中自动标记。
- en: Bind parameters present in the “columns clause” of a select are now auto-labeled
    like other “anonymous” clauses, which among other things allows their “type” to
    be meaningful when the row is fetched, as in result row processors.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 存在于 select 的“columns clause”中的绑定参数现在像其他“匿名”子句一样自动标记，这样在获取行时它们的“类型”就有意义，就像结果行处理器一样。
- en: SQLite - relative file paths are normalized through os.path.abspath()
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SQLite - 相对文件路径通过 os.path.abspath() 进行标准化
- en: This so that a script that changes the current directory will continue to target
    the same location as subsequent SQLite connections are established.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，更改当前目录的脚本将继续定位到后续建立的 SQLite 连接的相同位置。
- en: '[#2036](https://www.sqlalchemy.org/trac/ticket/2036)'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2036](https://www.sqlalchemy.org/trac/ticket/2036)'
- en: MS-SQL - `String`/`Unicode`/`VARCHAR`/`NVARCHAR`/`VARBINARY` emit “max” for
    no length
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: MS-SQL - `String`/`Unicode`/`VARCHAR`/`NVARCHAR`/`VARBINARY` 在未指定长度时发出“max”
- en: On the MS-SQL backend, the String/Unicode types, and their counterparts VARCHAR/
    NVARCHAR, as well as VARBINARY ([#1833](https://www.sqlalchemy.org/trac/ticket/1833))
    emit “max” as the length when no length is specified. This makes it more compatible
    with PostgreSQL’s VARCHAR type which is similarly unbounded when no length specified.
    SQL Server defaults the length on these types to ‘1’ when no length is specified.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在 MS-SQL 后端，String/Unicode 类型及其对应的 VARCHAR/NVARCHAR，以及 VARBINARY ([#1833](https://www.sqlalchemy.org/trac/ticket/1833))
    在未指定长度时发出“max”作为长度。这使其更兼容于 PostgreSQL 的 VARCHAR 类型，当未指定长度时同样是无界限的。SQL Server 在未指定长度时默认这些类型的长度为‘1’。
- en: Behavioral Changes (Backwards Incompatible)
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 行为变更（不兼容后向）
- en: Note again, aside from the default mutability change, most of these changes
    are *extremely minor* and will not affect most users.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 再次注意，除了默认的可变性更改外，大多数这些更改都是*极其微小*的，不会影响大多数用户。
- en: '`PickleType` and ARRAY mutability turned off by default'
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`PickleType` 和 ARRAY 的可变性默认关闭'
- en: 'This change refers to the default behavior of the ORM when mapping columns
    that have either the `PickleType` or `postgresql.ARRAY` datatypes. The `mutable`
    flag is now set to `False` by default. If an existing application uses these types
    and depends upon detection of in-place mutations, the type object must be constructed
    with `mutable=True` to restore the 0.6 behavior:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 此更改涉及 ORM 在映射具有 `PickleType` 或 `postgresql.ARRAY` 数据类型的列时的默认行为。`mutable` 标志现在默认设置为
    `False`。如果现有应用程序使用这些类型并依赖于就地变异的检测，则必须使用 `mutable=True` 构造类型对象以恢复 0.6 版本的行为：
- en: '[PRE14]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `mutable=True` flag is being phased out, in favor of the new [Mutation Tracking](https://www.sqlalchemy.org/docs/07/orm/extensions/mutable.html)
    extension. This extension provides a mechanism by which user-defined datatypes
    can provide change events back to the owning parent or parents.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`mutable=True` 标志正在逐步淘汰，取而代之的是新的[Mutation Tracking](https://www.sqlalchemy.org/docs/07/orm/extensions/mutable.html)
    扩展。该扩展提供了一种机制，通过该机制，用户定义的数据类型可以向拥有的父级或父级提供更改事件。'
- en: The previous approach of using `mutable=True` does not provide for change events
    - instead, the ORM must scan through all mutable values present in a session and
    compare them against their original value for changes every time `flush()` is
    called, which is a very time consuming event. This is a holdover from the very
    early days of SQLAlchemy when `flush()` was not automatic and the history tracking
    system was not nearly as sophisticated as it is now.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 以前使用`mutable=True`的方法不提供更改事件 - 相反，ORM必须在每次调用`flush()`时扫描会话中存在的所有可变值，并将它们与它们的原始值进行比较，这是一个非常耗时的事件。这是SQLAlchemy非常早期的遗留问题，当时`flush()`不是自动的，历史跟踪系统也不像现在这样复杂。
- en: Existing applications which use `PickleType`, `postgresql.ARRAY` or other `MutableType`
    subclasses, and require in-place mutation detection, should migrate to the new
    mutation tracking system, as `mutable=True` is likely to be deprecated in the
    future.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现有应用程序使用`PickleType`，`postgresql.ARRAY`或其他`MutableType`子类，并需要原地变异检测的应用程序应该迁移到新的变异跟踪系统，因为`mutable=True`可能会在未来被弃用。
- en: '[#1980](https://www.sqlalchemy.org/trac/ticket/1980)'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '[#1980](https://www.sqlalchemy.org/trac/ticket/1980)'
- en: Mutability detection of `composite()` requires the Mutation Tracking Extension
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`composite()`的可变性检测需要变异跟踪扩展'
- en: So-called “composite” mapped attributes, those configured using the technique
    described at [Composite Column Types](https://www.sqlalchemy.org/docs/07/orm/mapper_config.html#composite-column-types),
    have been re-implemented such that the ORM internals are no longer aware of them
    (leading to shorter and more efficient codepaths in critical sections). While
    composite types are generally intended to be treated as immutable value objects,
    this was never enforced. For applications that use composites with mutability,
    the [Mutation Tracking](https://www.sqlalchemy.org/docs/07/orm/extensions/mutable.html)
    extension offers a base class which establishes a mechanism for user-defined composite
    types to send change event messages back to the owning parent or parents of each
    object.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 所谓的“复合”映射属性，使用在[复合列类型](https://www.sqlalchemy.org/docs/07/orm/mapper_config.html#composite-column-types)中描述的技术配置的那些，已经重新实现，以使ORM内部不再意识到它们（导致关键部分中的代码路径更短更高效）。虽然复合类型通常应被视为不可变值对象，但从未强制执行。对于使用具有可变性的复合的应用程序，[变异跟踪](https://www.sqlalchemy.org/docs/07/orm/extensions/mutable.html)扩展提供了一个基类，该基类建立了一个机制，使用户定义的复合类型能够向每个对象的拥有父对象或父对象发送更改事件消息。
- en: Applications which use composite types and rely upon in- place mutation detection
    of these objects should either migrate to the “mutation tracking” extension, or
    change the usage of the composite types such that in-place changes are no longer
    needed (i.e., treat them as immutable value objects).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 使用复合类型并依赖于这些对象的原地变异检测的应用程序应该迁移到“变异跟踪”扩展，或者更改复合类型的使用，以便不再需要原地更改（即将它们视为不可变值对象）。
- en: SQLite - the SQLite dialect now uses `NullPool` for file-based databases
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SQLite - SQLite方言现在对基于文件的数据库使用`NullPool`
- en: This change is **99.999% backwards compatible**, unless you are using temporary
    tables across connection pool connections.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这个改变是**99.999%向后兼容**，除非您在连接池连接之间使用临时表。
- en: A file-based SQLite connection is blazingly fast, and using `NullPool` means
    that each call to `Engine.connect` creates a new pysqlite connection.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 基于文件的SQLite连接速度非常快，使用`NullPool`意味着每次调用`Engine.connect`都会创建一个新的pysqlite连接。
- en: Previously, the `SingletonThreadPool` was used, which meant that all connections
    to a certain engine in a thread would be the same connection. It’s intended that
    the new approach is more intuitive, particularly when multiple connections are
    used.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，使用`SingletonThreadPool`，这意味着在一个线程中对某个引擎的所有连接将是相同的连接。新方法更直观，特别是在使用多个连接时。
- en: '`SingletonThreadPool` is still the default engine when a `:memory:` database
    is used.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`:memory:`数据库时，`SingletonThreadPool`仍然是默认引擎。
- en: Note that this change **breaks temporary tables used across Session commits**,
    due to the way SQLite handles temp tables. See the note at [https://www.sqlalchemy.org/docs/dialects/sqlite.html#using](https://www.sqlalchemy.org/docs/dialects/sqlite.html#using)-
    temporary-tables-with-sqlite if temporary tables beyond the scope of one pool
    connection are desired.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个改变**破坏了跨会话提交使用的临时表**，这是由于SQLite处理临时表的方式。如果需要超出一个连接池连接范围的临时表，请参阅[https://www.sqlalchemy.org/docs/dialects/sqlite.html#using](https://www.sqlalchemy.org/docs/dialects/sqlite.html#using)-
    temporary-tables-with-sqlite中的说明。
- en: '[#1921](https://www.sqlalchemy.org/trac/ticket/1921)'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '[#1921](https://www.sqlalchemy.org/trac/ticket/1921)'
- en: '`Session.merge()` checks version ids for versioned mappers'
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`Session.merge()`为具有版本控制的映射器检查版本id'
- en: Session.merge() will check the version id of the incoming state against that
    of the database, assuming the mapping uses version ids and incoming state has
    a version_id assigned, and raise StaleDataError if they don’t match. This is the
    correct behavior, in that if incoming state contains a stale version id, it should
    be assumed the state is stale.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`Session.merge()`将会检查传入状态的版本id与数据库中的版本id是否匹配，假设映射使用了版本id，并且传入状态已经分配了一个版本id，如果它们不匹配，则会引发`StaleDataError`。这是正确的行为，因为如果传入状态包含一个过期的版本id，则应该假设该状态已过期。'
- en: If merging data into a versioned state, the version id attribute can be left
    undefined, and no version check will take place.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将数据合并到一个有版本控制的状态中，则版本id属性可以不定义，并且不会进行版本检查。
- en: This check was confirmed by examining what Hibernate does - both the `merge()`
    and the versioning features were originally adapted from Hibernate.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 通过检查Hibernate的做法已确认了这一点 - `merge()`和版本控制功能最初都是从Hibernate适配而来的。
- en: '[#2027](https://www.sqlalchemy.org/trac/ticket/2027)'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2027](https://www.sqlalchemy.org/trac/ticket/2027)'
- en: Tuple label names in Query Improved
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查询中改进的元组标签名称
- en: This improvement is potentially slightly backwards incompatible for an application
    that relied upon the old behavior.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这种改进可能对依赖于旧行为的应用程序稍微具有向后不兼容性。
- en: 'Given two mapped classes `Foo` and `Bar` each with a column `spam`:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 给定两个映射类`Foo`和`Bar`，每个类都有一个名为`spam`的列：
- en: '[PRE15]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The name given to the single column yielded by `qu` will be `spam`. Previously
    it would be something like `foo_spam` due to the way the `union` would combine
    things, which is inconsistent with the name `spam` in the case of a non-unioned
    query.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 由`qu`产生的单个列的名称将是`spam`。之前由于`union`组合的方式，它可能是`foo_spam`之类的东西，这与非联合查询的情况下的`spam`名称不一致。
- en: '[#1942](https://www.sqlalchemy.org/trac/ticket/1942)'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '[#1942](https://www.sqlalchemy.org/trac/ticket/1942)'
- en: Mapped column attributes reference the most specific column first
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 映射的列属性首先引用最具体的列
- en: This is a change to the behavior involved when a mapped column attribute references
    multiple columns, specifically when dealing with an attribute on a joined-table
    subclass that has the same name as that of an attribute on the superclass.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个行为变更，涉及到当一个映射的列属性引用多个列时，特别是在处理一个具有与超类相同名称的属性的联接表子类的属性时。
- en: 'Using declarative, the scenario is this:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 使用声明式的情况是这样的：
- en: '[PRE16]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Above, the attribute `Child.id` refers to both the `child.id` column as well
    as `parent.id` - this due to the name of the attribute. If it were named differently
    on the class, such as `Child.child_id`, it then maps distinctly to `child.id`,
    with `Child.id` being the same attribute as `Parent.id`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，属性`Child.id`同时引用了`child.id`列和`parent.id`列 - 这是由于属性的名称。如果在类上以不同的方式命名它，比如`Child.child_id`，那么它将明确地映射到`child.id`，而`Child.id`将是与`Parent.id`相同的属性。
- en: When the `id` attribute is made to reference both `parent.id` and `child.id`,
    it stores them in an ordered list. An expression such as `Child.id` then refers
    to just *one* of those columns when rendered. Up until 0.6, this column would
    be `parent.id`. In 0.7, it is the less surprising `child.id`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当`id`属性被设置为引用`parent.id`和`child.id`时，它们会被存储在一个有序列表中。例如`Child.id`这样的表达式在渲染时只会引用其中*一个*列。直到0.6版本，这个列会是`parent.id`。在0.7版本中，它是不那么令人惊讶的`child.id`。
- en: The legacy of this behavior deals with behaviors and restrictions of the ORM
    that don’t really apply anymore; all that was needed was to reverse the order.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为的传统与ORM的行为和限制相关，这些限制实际上已经不适用了；一切所需的只是颠倒顺序。
- en: 'A primary advantage of this approach is that it’s now easier to construct `primaryjoin`
    expressions that refer to the local column:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的一个主要优势是现在更容易构造引用本地列的`primaryjoin`表达式：
- en: '[PRE17]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Prior to 0.7 the `Child.id` expression would reference `Parent.id`, and it would
    be necessary to map `child.id` to a distinct attribute.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在0.7版本之前，`Child.id`表达式会引用`Parent.id`，并且需要将`child.id`映射到一个不同的属性上。
- en: 'It also means that a query like this one changes its behavior:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这也意味着像这样的查询的行为发生了变化：
- en: '[PRE18]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In 0.6, this would render:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在0.6版本中，这将呈现为：
- en: '[PRE19]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'in 0.7, you get:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在0.7版本中，您会得到：
- en: '[PRE20]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'which you’ll note is a cartesian product - this behavior is now equivalent
    to that of any other attribute that is local to `Child`. The `with_polymorphic()`
    method, or a similar strategy of explicitly joining the underlying `Table` objects,
    is used to render a query against all `Parent` objects with criteria against `Child`,
    in the same manner as that of 0.5 and 0.6:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到这是一个笛卡尔积 - 这种行为现在等同于`Child`中的任何其他局部属性。`with_polymorphic()` 方法或类似的显式连接基础
    `Table` 对象的策略，用于对所有带有`Child`条件的 `Parent` 对象进行查询，方式与0.5和0.6相同：
- en: '[PRE21]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Which on both 0.6 and 0.7 renders:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在0.6和0.7版本都是这样呈现的：
- en: '[PRE22]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Another effect of this change is that a joined-inheritance load across two tables
    will populate from the child table’s value, not that of the parent table. An unusual
    case is that a query against “Parent” using `with_polymorphic="*"` issues a query
    against “parent”, with a LEFT OUTER JOIN to “child”. The row is located in “Parent”,
    sees the polymorphic identity corresponds to “Child”, but suppose the actual row
    in “child” has been *deleted*. Due to this corruption, the row comes in with all
    the columns corresponding to “child” set to NULL - this is now the value that
    gets populated, not the one in the parent table.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这种更改的另一个效果是，跨两个表的连接继承加载将从子表的值填充，而不是从父表的值填充。一个不寻常的情况是，使用`with_polymorphic="*"`对“Parent”进行查询会对“parent”发出查询，并且左外连接到“child”。行位于“Parent”中，看到多态标识对应于“Child”，但是假设“child”中的实际行已被*删除*。由于这种损坏，行会带有所有对应于“child”的列设置为NULL的值
    - 这是现在被填充的值，而不是父表中的值。
- en: '[#1892](https://www.sqlalchemy.org/trac/ticket/1892)'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '[#1892](https://www.sqlalchemy.org/trac/ticket/1892)'
- en: Mapping to joins with two or more same-named columns requires explicit declaration
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将两个或更多同名列映射到连接时需要明确声明
- en: This is somewhat related to the previous change in [#1892](https://www.sqlalchemy.org/trac/ticket/1892).
    When mapping to a join, same-named columns must be explicitly linked to mapped
    attributes, i.e. as described in [Mapping a Class Against Multiple Tables](http://www.sqlalchemy.org/docs/07/orm/mapper_config.html#mapping-a-class-against-multiple-tables).
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这与之前的变更[#1892](https://www.sqlalchemy.org/trac/ticket/1892)有些相关。在映射到连接时，同名列必须显式地链接到映射属性，即如[将类映射到多个表](http://www.sqlalchemy.org/docs/07/orm/mapper_config.html#mapping-a-class-against-multiple-tables)中描述的那样。
- en: 'Given two tables `foo` and `bar`, each with a primary key column `id`, the
    following now produces an error:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 给定两个表 `foo` 和 `bar`，每个表都有一个主键列 `id`，现在会产生一个错误：
- en: '[PRE23]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This because the `mapper()` refuses to guess what column is the primary representation
    of `FooBar.id` - is it `foo.c.id` or is it `bar.c.id` ? The attribute must be
    explicit:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为 `mapper()` 拒绝猜测 `FooBar.id` 的主要表示列是 `foo.c.id` 还是 `bar.c.id`？属性必须是明确的：
- en: '[PRE24]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[#1896](https://www.sqlalchemy.org/trac/ticket/1896)'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '[#1896](https://www.sqlalchemy.org/trac/ticket/1896)'
- en: Mapper requires that polymorphic_on column be present in the mapped selectable
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 映射器要求多态性的列在映射的可选择项中存在
- en: 'This is a warning in 0.6, now an error in 0.7\. The column given for `polymorphic_on`
    must be in the mapped selectable. This to prevent some occasional user errors
    such as:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在0.6中是一个警告，现在在0.7中是一个错误。给定用于 `polymorphic_on` 的列必须在映射的可选择项中。这是为了防止一些偶发的用户错误，例如：
- en: '[PRE25]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: where above the polymorphic_on needs to be on a `sometable` column, in this
    case perhaps `sometable.c.some_lookup_id`. There are also some “polymorphic union”
    scenarios where similar mistakes sometimes occur.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`polymorphic_on` 需要在`sometable`列上，也许是`sometable.c.some_lookup_id`。有时还会出现一些“多态联合”场景，类似的错误有时也会发生。
- en: Such a configuration error has always been “wrong”, and the above mapping doesn’t
    work as specified - the column would be ignored. It is however potentially backwards
    incompatible in the rare case that an application has been unknowingly relying
    upon this behavior.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的配置错误一直都是“错误”的，并且上述映射不按照指定的方式工作 - 列将被忽略。然而，在极少数情况下，这可能是向后不兼容的，因为应用程序可能一直在无意中依赖于这种行为。
- en: '[#1875](https://www.sqlalchemy.org/trac/ticket/1875)'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '[#1875](https://www.sqlalchemy.org/trac/ticket/1875)'
- en: '`DDL()` constructs now escape percent signs'
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`DDL()` 构造现在会转义百分号'
- en: Previously, percent signs in `DDL()` strings would have to be escaped, i.e.
    `%%` depending on DBAPI, for those DBAPIs that accept `pyformat` or `format` binds
    (i.e. psycopg2, mysql-python), which was inconsistent versus `text()` constructs
    which did this automatically. The same escaping now occurs for `DDL()` as for
    `text()`.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，在 `DDL()` 字符串中的百分号必须进行转义，即 `%%` 取决于 DBAPI，对于那些接受 `pyformat` 或 `format` 绑定的
    DBAPI（例如 psycopg2，mysql-python），这与自动执行此操作的 `text()` 构造不一致。现在，`DDL()` 与 `text()`
    一样进行相同的转义。
- en: '[#1897](https://www.sqlalchemy.org/trac/ticket/1897)'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '[#1897](https://www.sqlalchemy.org/trac/ticket/1897)'
- en: '`Table.c` / `MetaData.tables` refined a bit, don’t allow direct mutation'
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`Table.c` / `MetaData.tables` 稍微精炼了一下，不允许直接变异。'
- en: Another area where some users were tinkering around in such a way that doesn’t
    actually work as expected, but still left an exceedingly small chance that some
    application was relying upon this behavior, the construct returned by the `.c`
    attribute on `Table` and the `.tables` attribute on `MetaData` is explicitly non-mutable.
    The “mutable” version of the construct is now private. Adding columns to `.c`
    involves using the `append_column()` method of `Table`, which ensures things are
    associated with the parent `Table` in the appropriate way; similarly, `MetaData.tables`
    has a contract with the `Table` objects stored in this dictionary, as well as
    a little bit of new bookkeeping in that a `set()` of all schema names is tracked,
    which is satisfied only by using the public `Table` constructor as well as `Table.tometadata()`.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个领域，一些用户在进行某种方式的尝试时实际上并不按预期工作，但仍然留下了极小的机会，即某些应用程序依赖于这种行为，`.c` 属性在 `Table`
    上返回的构造和 `MetaData` 上的 `.tables` 属性明确是不可变的。构造的“可变”版本现在是私有的。向 `.c` 添加列涉及使用 `Table`
    的 `append_column()` 方法，这确保了事物以适当的方式与父 `Table` 关联；同样，`MetaData.tables` 与存储在此字典中的
    `Table` 对象有一个合同，以及一些新的簿记，跟踪所有模式名称的 `set()`，只有通过使用公共 `Table` 构造函数以及 `Table.tometadata()`
    才能满足。
- en: It is of course possible that the `ColumnCollection` and `dict` collections
    consulted by these attributes could someday implement events on all of their mutational
    methods such that the appropriate bookkeeping occurred upon direct mutation of
    the collections, but until someone has the motivation to implement all that along
    with dozens of new unit tests, narrowing the paths to mutation of these collections
    will ensure no application is attempting to rely upon usages that are currently
    not supported.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，`ColumnCollection` 和 `dict` 集合可能会在某一天实现对其所有变异方法的事件，以便在直接变异集合时发生适当的簿记，但在有人有动力实现所有这些以及数十个新单元测试之前，缩小这些集合的变异路径将确保没有应用程序试图依赖当前不支持的用法。
- en: '[#1893](https://www.sqlalchemy.org/trac/ticket/1893) [#1917](https://www.sqlalchemy.org/trac/ticket/1917)'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '[#1893](https://www.sqlalchemy.org/trac/ticket/1893) [#1917](https://www.sqlalchemy.org/trac/ticket/1917)'
- en: server_default consistently returns None for all inserted_primary_key values
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`server_default` 对所有 `inserted_primary_key` 值始终返回 `None`。'
- en: Established consistency when server_default is present on an Integer PK column.
    SQLA doesn’t pre-fetch these, nor do they come back in cursor.lastrowid (DBAPI).
    Ensured all backends consistently return None in result.inserted_primary_key for
    these - some backends may have returned a value previously. Using a server_default
    on a primary key column is extremely unusual. If a special function or SQL expression
    is used to generate primary key defaults, this should be established as a Python-side
    “default” instead of server_default.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `server_default` 出现在整数主键列上时确立了一致性。SQLA 不会预取这些值，也不会在 `cursor.lastrowid`（DBAPI）中返回它们。确保所有后端在
    `result.inserted_primary_key` 中一致地返回 `None` - 一些后端可能之前返回过一个值。在主键列上使用 `server_default`
    是极不寻常的。如果使用特殊函数或 SQL 表达式生成主键默认值，则应将其确定为 Python 端的“default” 而不是 `server_default`。
- en: Regarding reflection for this case, reflection of an int PK col with a server_default
    sets the “autoincrement” flag to False, except in the case of a PG SERIAL col
    where we detected a sequence default.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这种情况的反射，具有 `server_default` 的 int PK 列的反射将“autoincrement” 标志设置为 `False`，除非是
    PG SERIAL 列，我们检测到一个序列默认值。
- en: '[#2020](https://www.sqlalchemy.org/trac/ticket/2020) [#2021](https://www.sqlalchemy.org/trac/ticket/2021)'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2020](https://www.sqlalchemy.org/trac/ticket/2020) [#2021](https://www.sqlalchemy.org/trac/ticket/2021)'
- en: The `sqlalchemy.exceptions` alias in sys.modules is removed
  id: totrans-236
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`sys.modules` 中的 `sqlalchemy.exceptions` 别名被移除。'
- en: 'For a few years we’ve added the string `sqlalchemy.exceptions` to `sys.modules`,
    so that a statement like “`import sqlalchemy.exceptions`” would work. The name
    of the core exceptions module has been `exc` for a long time now, so the recommended
    import for this module is:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 几年来，我们一直将字符串 `sqlalchemy.exceptions` 添加到 `sys.modules` 中，以便像“`import sqlalchemy.exceptions`”这样的语句能够正常工作。核心异常模块的名称现在已经是
    `exc` 很长时间了，因此建议导入此模块的方式是：
- en: '[PRE26]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `exceptions` name is still present in “`sqlalchemy`” for applications which
    might have said `from sqlalchemy import exceptions`, but they should also start
    using the `exc` name.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 对于可能已经说过 `from sqlalchemy import exceptions` 的应用程序，`exceptions` 名称仍然存在于“`sqlalchemy`”中，但他们也应该开始使用
    `exc` 名称。
- en: Query Timing Recipe Changes
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查询时间配方更改
- en: While not part of SQLAlchemy itself, it’s worth mentioning that the rework of
    the `ConnectionProxy` into the new event system means it is no longer appropriate
    for the “Timing all Queries” recipe. Please adjust query-timers to use the `before_cursor_execute()`
    and `after_cursor_execute()` events, demonstrated in the updated recipe UsageRecipes/Profiling.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然不是 SQLAlchemy 本身的一部分，但值得一提的是，将 `ConnectionProxy` 重构为新的事件系统意味着不再适用于“Timing
    all Queries”配方。请调整查询计时器以使用 `before_cursor_execute()` 和 `after_cursor_execute()`
    事件，在更新后的配方 UsageRecipes/Profiling 中有示例。
- en: Deprecated API
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 弃用的 API
- en: Default constructor on types will not accept arguments
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类型上的默认构造函数不会接受参数
- en: Simple types like `Integer`, `Date` etc. in the core types module don’t accept
    arguments. The default constructor that accepts/ignores a catchall `\*args, \**kwargs`
    is restored as of 0.7b4/0.7.0, but emits a deprecation warning.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 核心类型模块中的简单类型如 `Integer`、`Date` 等不接受参数。从 0.7b4/0.7.0 开始，接受/忽略 catchall `\*args,
    \**kwargs` 的默认构造函数已经恢复，但会发出弃用警告。
- en: If arguments are being used with a core type like `Integer`, it may be that
    you intended to use a dialect specific type, such as `sqlalchemy.dialects.mysql.INTEGER`
    which does accept a “display_width” argument for example.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在核心类型如 `Integer` 中使用参数，可能是你打算使用特定于方言的类型，比如 `sqlalchemy.dialects.mysql.INTEGER`，它接受一个“display_width”参数。
- en: compile_mappers() renamed configure_mappers(), simplified configuration internals
  id: totrans-246
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: compile_mappers() 重命名为 configure_mappers()，简化配置内部
- en: This system slowly morphed from something small, implemented local to an individual
    mapper, and poorly named into something that’s more of a global “registry-” level
    function and poorly named, so we’ve fixed both by moving the implementation out
    of `Mapper` altogether and renaming it to `configure_mappers()`. It is of course
    normally not needed for an application to call `configure_mappers()` as this process
    occurs on an as-needed basis, as soon as the mappings are needed via attribute
    or query access.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这个系统从最初是一个小型的、实现在单个映射器本地的东西，命名不当，逐渐演变成了更像是一个全局“注册表”级别的功能，命名不当，因此我们通过将实现移出 `Mapper`
    并将其重命名为 `configure_mappers()` 来修复这两个问题。当然，通常情况下应用程序不需要调用 `configure_mappers()`，因为这个过程是根据需要的，一旦通过属性或查询访问需要映射时就会发生。
- en: '[#1966](https://www.sqlalchemy.org/trac/ticket/1966)'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '[#1966](https://www.sqlalchemy.org/trac/ticket/1966)'
- en: Core listener/proxy superseded by event listeners
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 核心监听器/代理被事件监听器取代
- en: '`PoolListener`, `ConnectionProxy`, `DDLElement.execute_at` are superseded by
    `event.listen()`, using the `PoolEvents`, `EngineEvents`, `DDLEvents` dispatch
    targets, respectively.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`PoolListener`、`ConnectionProxy`、`DDLElement.execute_at` 被分别替代为 `event.listen()`，使用
    `PoolEvents`、`EngineEvents`、`DDLEvents` 分发目标。'
- en: ORM extensions superseded by event listeners
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ORM 扩展被事件监听��取代
- en: '`MapperExtension`, `AttributeExtension`, `SessionExtension` are superseded
    by `event.listen()`, using the `MapperEvents`/`InstanceEvents`, `AttributeEvents`,
    `SessionEvents`, dispatch targets, respectively.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '`MapperExtension`、`AttributeExtension`、`SessionExtension` 被分别替代为 `event.listen()`，使用
    `MapperEvents`/`InstanceEvents`、`AttributeEvents`、`SessionEvents` 分发目标。'
- en: Sending a string to ‘distinct’ in select() for MySQL should be done via prefixes
  id: totrans-253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 MySQL 中，将字符串发送到 `select()` 的 ‘distinct’ 应该通过前缀来完成
- en: 'This obscure feature allows this pattern with the MySQL backend:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这个晦涩的特性允许在 MySQL 后端中使用这种模式：
- en: '[PRE27]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `prefixes` keyword or `prefix_with()` method should be used for non-standard
    or unusual prefixes:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 对于非标准或不寻常的前缀，应该使用 `prefixes` 关键字或 `prefix_with()` 方法：
- en: '[PRE28]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '`useexisting` superseded by `extend_existing` and `keep_existing`'
  id: totrans-258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`useexisting` 被 `extend_existing` 和 `keep_existing` 取代'
- en: The `useexisting` flag on Table has been superseded by a new pair of flags `keep_existing`
    and `extend_existing`. `extend_existing` is equivalent to `useexisting` - the
    existing Table is returned, and additional constructor elements are added. With
    `keep_existing`, the existing Table is returned, but additional constructor elements
    are not added - these elements are only applied when the Table is newly created.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: Table 上的 `useexisting` 标志已被新的一对标志 `keep_existing` 和 `extend_existing` 取代。`extend_existing`
    等同于 `useexisting` - 返回现有的 Table，并添加额外的构造元素。使用 `keep_existing`，返回现有的 Table，但不添加额外的构造元素
    - 这些元素仅在新创建 Table 时应用。
- en: Backwards Incompatible API Changes
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不兼容的后向 API 更改
- en: Callables passed to `bindparam()` don’t get evaluated - affects the Beaker example
  id: totrans-261
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 传递给 `bindparam()` 的可调用对象不会被评估 - 影响 Beaker 示例
- en: '[#1950](https://www.sqlalchemy.org/trac/ticket/1950)'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '[#1950](https://www.sqlalchemy.org/trac/ticket/1950)'
- en: Note this affects the Beaker caching example, where the workings of the `_params_from_query()`
    function needed a slight adjustment. If you’re using code from the Beaker example,
    this change should be applied.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这影响了 Beaker 缓存示例，其中 `_params_from_query()` 函数的工作需要进行轻微调整。如果您正在使用 Beaker
    示例中的代码，则应用此更改。
- en: types.type_map is now private, types._type_map
  id: totrans-264
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: types.type_map 现在是私有的，types._type_map
- en: We noticed some users tapping into this dictionary inside of `sqlalchemy.types`
    as a shortcut to associating Python types with SQL types. We can’t guarantee the
    contents or format of this dictionary, and additionally the business of associating
    Python types in a one-to-one fashion has some grey areas that should are best
    decided by individual applications, so we’ve underscored this attribute.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们注意到一些用户在 `sqlalchemy.types` 内部利用这个字典作为将 Python 类型与 SQL 类型关联的快捷方式。我们无法保证这个字典的内容或格式，并且将
    Python 类型一对一关联的业务有一些灰色地带，最好由各个应用程序自行决定，因此我们已经强调了这个属性。
- en: '[#1870](https://www.sqlalchemy.org/trac/ticket/1870)'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '[#1870](https://www.sqlalchemy.org/trac/ticket/1870)'
- en: Renamed the `alias` keyword arg of standalone `alias()` function to `name`
  id: totrans-267
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将独立 `alias()` 函数的 `alias` 关键字参数重命名为 `name`
- en: This so that the keyword argument `name` matches that of the `alias()` methods
    on all `FromClause` objects as well as the `name` argument on `Query.subquery()`.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这样关键字参数 `name` 与所有 `FromClause` 对象上的 `alias()` 方法以及 `Query.subquery()` 上的 `name`
    参数匹配。
- en: Only code that uses the standalone `alias()` function, and not the method bound
    functions, and passes the alias name using the explicit keyword name `alias`,
    and not positionally, would need modification here.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 只有使用独立的 `alias()` 函数，而不是方法绑定函数，并且使用显式关键字名称 `alias` 而不是位置上的别名名称的代码需要在这里进行修改。
- en: Non-public `Pool` methods underscored
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 非公共 `Pool` 方法已加下划线
- en: All methods of `Pool` and subclasses which are not intended for public use have
    been renamed with underscores. That they were not named this way previously was
    a bug.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 `Pool` 及其子类的所有不打算公开使用的方法都已改名为下划线。它们以前没有这样命名是一个错误。
- en: 'Pooling methods now underscored or removed:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 现在下划线或已移除的池化方法：
- en: '`Pool.create_connection()` -> `Pool._create_connection()`'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '`Pool.create_connection()` -> `Pool._create_connection()`'
- en: '`Pool.do_get()` -> `Pool._do_get()`'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '`Pool.do_get()` -> `Pool._do_get()`'
- en: '`Pool.do_return_conn()` -> `Pool._do_return_conn()`'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '`Pool.do_return_conn()` -> `Pool._do_return_conn()`'
- en: '`Pool.do_return_invalid()` -> removed, was not used'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '`Pool.do_return_invalid()` -> 已移除，未被使用'
- en: '`Pool.return_conn()` -> `Pool._return_conn()`'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '`Pool.return_conn()` -> `Pool._return_conn()`'
- en: '`Pool.get()` -> `Pool._get()`, public API is `Pool.connect()`'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '`Pool.get()` -> `Pool._get()`, 公共 API 是 `Pool.connect()`'
- en: '`SingletonThreadPool.cleanup()` -> `_cleanup()`'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '`SingletonThreadPool.cleanup()` -> `_cleanup()`'
- en: '`SingletonThreadPool.dispose_local()` -> removed, use `conn.invalidate()`'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '`SingletonThreadPool.dispose_local()` -> 已移除，使用 `conn.invalidate()`'
- en: '[#1982](https://www.sqlalchemy.org/trac/ticket/1982)'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '[#1982](https://www.sqlalchemy.org/trac/ticket/1982)'
- en: Previously Deprecated, Now Removed
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 以前弃用，现在已移除
- en: Query.join(), Query.outerjoin(), eagerload(), eagerload_all(), others no longer
    allow lists of attributes as arguments
  id: totrans-283
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Query.join(), Query.outerjoin(), eagerload(), eagerload_all(), 其他不再允许将属性列表作为参数
- en: 'Passing a list of attributes or attribute names to `Query.join`, `eagerload()`,
    and similar has been deprecated since 0.5:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 从 0.5 开始，将属性或属性名称列表传递给 `Query.join`, `eagerload()` 等已被弃用：
- en: '[PRE29]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'These methods all accept *args as of the 0.5 series:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法在 0.5 系列中都接受 *args：
- en: '[PRE30]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '`ScopedSession.mapper` is removed'
  id: totrans-288
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`ScopedSession.mapper` 已移除'
- en: This feature provided a mapper extension which linked class- based functionality
    with a particular `ScopedSession`, in particular providing the behavior such that
    new object instances would be automatically associated with that session. The
    feature was overused by tutorials and frameworks which led to great user confusion
    due to its implicit behavior, and was deprecated in 0.5.5\. Techniques for replicating
    its functionality are at [wiki:UsageRecipes/SessionAwareMapper]
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这一功能提供了一个映射器扩展，将基于类的功能与特定的`ScopedSession`链接起来，特别是提供了这样的行为，即新对象实例将自动与该会话关联。 该功能被教程和框架过度使用，导致用户混淆，因为其隐式行为，并在0.5.5中被弃用。
    复制其功能的技术在[wiki:UsageRecipes/SessionAwareMapper]中。
- en: Introduction
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍
- en: This guide introduces what’s new in SQLAlchemy version 0.7, and also documents
    changes which affect users migrating their applications from the 0.6 series of
    SQLAlchemy to 0.7.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 本指南介绍了SQLAlchemy版本0.7中的新功能，并记录了影响用户将其应用程序从SQLAlchemy 0.6系列迁移到0.7的更改。
- en: To as great a degree as possible, changes are made in such a way as to not break
    compatibility with applications built for 0.6\. The changes that are necessarily
    not backwards compatible are very few, and all but one, the change to mutable
    attribute defaults, should affect an exceedingly small portion of applications
    - many of the changes regard non-public APIs and undocumented hacks some users
    may have been attempting to use.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 尽可能地，更改是以不破坏为0.6构建的应用程序的兼容性的方式进行的。 必然不向后兼容的更改非常少，除了一个，即对可变属性默认值的更改，应该影响极小部分应用程序
    - 许多更改涉及非公共API和未记录的一些用户可能一直在尝试使用的黑客技巧。
- en: A second, even smaller class of non-backwards-compatible changes is also documented.
    This class of change regards those features and behaviors that have been deprecated
    at least since version 0.5 and have been raising warnings since their deprecation.
    These changes would only affect applications that are still using 0.4- or early
    0.5-style APIs. As the project matures, we have fewer and fewer of these kinds
    of changes with 0.x level releases, which is a product of our API having ever
    fewer features that are less than ideal for the use cases they were meant to solve.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '还有第二个更小的一类不向后兼容的更改也有文档记录。 这类更改涉及那些自0.5版本以来已被弃用并自弃用以来一直引发警告的功能和行为。 这些更改只会影响仍在使用0.4或早期0.5样式API的应用程序。
    随着项目的成熟，我们在0.x级别发布中有越来越少这类更改，这是由于我们的API具有越来越少的功能，这些功能对于它们旨在解决的用例来说不太理想。 '
- en: An array of existing functionalities have been superseded in SQLAlchemy 0.7\.
    There’s not much difference between the terms “superseded” and “deprecated”, except
    that the former has a much weaker suggestion of the old feature would ever be
    removed. In 0.7, features like `synonym` and `comparable_property`, as well as
    all the `Extension` and other event classes, have been superseded. But these “superseded”
    features have been re-implemented such that their implementations live mostly
    outside of core ORM code, so their continued “hanging around” doesn’t impact SQLAlchemy’s
    ability to further streamline and refine its internals, and we expect them to
    remain within the API for the foreseeable future.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在SQLAlchemy 0.7中，一系列现有功能已被取代。 “取代”和“弃用”之间没有太大区别，只是前者对旧功能的暗示要被删除的可能性较小。 在0.7中，像`synonym`和`comparable_property`以及所有`Extension`和其他事件类等功能已被取代。
    但是这些“取代”功能已被重新实现，使得它们的实现主要存在于核心ORM代码之外，因此它们的持续“挂在”不会影响SQLAlchemy进一步简化和完善其内部的能力，并且我们预计它们将在可预见的未来保留在API中。
- en: New Features
  id: totrans-295
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 新功能
- en: New Event System
  id: totrans-296
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 新事件系统
- en: SQLAlchemy started early with the `MapperExtension` class, which provided hooks
    into the persistence cycle of mappers. As SQLAlchemy quickly became more componentized,
    pushing mappers into a more focused configurational role, many more “extension”,
    “listener”, and “proxy” classes popped up to solve various activity-interception
    use cases in an ad-hoc fashion. Part of this was driven by the divergence of activities;
    `ConnectionProxy` objects wanted to provide a system of rewriting statements and
    parameters; `AttributeExtension` provided a system of replacing incoming values,
    and `DDL` objects had events that could be switched off of dialect-sensitive callables.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 早期开始使用 `MapperExtension` 类，该类提供了对映射器持久性周期的钩子。随着 SQLAlchemy 快速变得更加组件化，将映射器推入更专注的配置角色，许多更多的“扩展”、“监听器”和“代理”类出现，以以一种临时的方式解决各种活动拦截用例。其中一部分是由活动的分歧驱动的；`ConnectionProxy`
    对象希望提供一个重写语句和参数的系统；`AttributeExtension` 提供了一个替换传入值的系统，而 `DDL` 对象具有可以切换到方言敏感可调用对象的事件。
- en: 0.7 re-implements virtually all of these plugin points with a new, unified approach,
    which retains all the functionalities of the different systems, provides more
    flexibility and less boilerplate, performs better, and eliminates the need to
    learn radically different APIs for each event subsystem. The pre-existing classes
    `MapperExtension`, `SessionExtension`, `AttributeExtension`, `ConnectionProxy`,
    `PoolListener` as well as the `DDLElement.execute_at` method are deprecated and
    now implemented in terms of the new system - these APIs remain fully functional
    and are expected to remain in place for the foreseeable future.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 0.7 重新实现了几乎所有这些插件点，采用了一种新的、统一的方法，保留了不同系统的所有功能，提供了更多的灵活性和更少的样板代码，性能更好，并消除了需要为每个事件子系统学习根本不同的
    API 的必要性。现有的类 `MapperExtension`、`SessionExtension`、`AttributeExtension`、`ConnectionProxy`、`PoolListener`
    以及 `DDLElement.execute_at` 方法已被弃用，现在根据新系统实现 - 这些 API 仍然完全可用，并预计将在可预见的未来保持不变。
- en: The new approach uses named events and user-defined callables to associate activities
    with events. The API’s look and feel was driven by such diverse sources as JQuery,
    Blinker, and Hibernate, and was also modified further on several occasions during
    conferences with dozens of users on Twitter, which appears to have a much higher
    response rate than the mailing list for such questions.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 新方法使用命名事件和用户定义的可调用对象将活动与事件关联起来。API 的外观和感觉受到了 JQuery、Blinker 和 Hibernate 等多样化来源的驱动，并且在与数十位用户进行的
    Twitter 会议期间进行了多次修改，这似乎比邮件列表对这类问题的回应率要高得多。
- en: It also features an open-ended system of target specification that allows events
    to be associated with API classes, such as for all `Session` or `Engine` objects,
    with specific instances of API classes, such as for a specific `Pool` or `Mapper`,
    as well as for related objects like a user- defined class that’s mapped, or something
    as specific as a certain attribute on instances of a particular subclass of a
    mapped parent class. Individual listener subsystems can apply wrappers to incoming
    user- defined listener functions which modify how they are called - an mapper
    event can receive either the instance of the object being operated upon, or its
    underlying `InstanceState` object. An attribute event can opt whether or not to
    have the responsibility of returning a new value.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 它还具有一个开放式的目标规范系统，允许将事件与 API 类关联，例如所有 `Session` 或 `Engine` 对象，以及与 API 类的特定实例关联，例如特定的
    `Pool` 或 `Mapper`，以及与用户定义的类相关的对象，例如映射的类，或者特定子类的实例上的某个属性。个别监听器子系统可以将包装器应用于传入的用户定义的监听器函数，从而修改它们的调用方式
    - 映射器事件可以接收被操作对象的实例，或者其底层的 `InstanceState` 对象。属性事件可以选择是否要负责返回一个新值。
- en: Several systems now build upon the new event API, including the new “mutable
    attributes” API as well as composite attributes. The greater emphasis on events
    has also led to the introduction of a handful of new events, including attribute
    expiration and refresh operations, pickle loads/dumps operations, completed mapper
    construction operations.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 几个系统现在基于新的事件 API 构建，包括新的“可变属性” API 以及复合属性。对事件的更大强调还导致引入了一些新事件，包括属性过期和刷新操作，pickle
    加载/转储操作，完成的映射器构造操作。
- en: See also
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[Events](../core/event.html)'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '[事件](../core/event.html)'
- en: '[#1902](https://www.sqlalchemy.org/trac/ticket/1902)'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '[#1902](https://www.sqlalchemy.org/trac/ticket/1902)'
- en: Hybrid Attributes, implements/supersedes synonym(), comparable_property()
  id: totrans-305
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 混合属性，实现/取代了 synonym()、comparable_property()
- en: The “derived attributes” example has now been turned into an official extension.
    The typical use case for `synonym()` is to provide descriptor access to a mapped
    column; the use case for `comparable_property()` is to be able to return a `PropComparator`
    from any descriptor. In practice, the approach of “derived” is easier to use,
    more extensible, is implemented in a few dozen lines of pure Python with almost
    no imports, and doesn’t require the ORM core to even be aware of it. The feature
    is now known as the “Hybrid Attributes” extension.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: “派生属性”示例现在已经转变为官方扩展。`synonym()`的典型用例是为映射列提供描述符访问；`comparable_property()`的用例是能够从任何描述符返回`PropComparator`。实际上，“派生”的方法更易于使用，更具可扩展性，用几十行纯Python实现几乎不需要导入，甚至不需要ORM核心意识到它。该功能现在被称为“混合属性”扩展。
- en: '`synonym()` and `comparable_property()` are still part of the ORM, though their
    implementations have been moved outwards, building on an approach that is similar
    to that of the hybrid extension, so that the core ORM mapper/query/property modules
    aren’t really aware of them otherwise.'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '`synonym()`和`comparable_property()`仍然是ORM的一部分，尽管它们的实现已经移出，建立在类似于混合扩展的方法之上，以便核心ORM映射器/查询/属性模块在其他情况下并不真正意识到它们。'
- en: See also
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Hybrid Attributes](../orm/extensions/hybrid.html)'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '[混合属性](../orm/extensions/hybrid.html)'
- en: '[#1903](https://www.sqlalchemy.org/trac/ticket/1903)'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '[#1903](https://www.sqlalchemy.org/trac/ticket/1903)'
- en: Speed Enhancements
  id: totrans-311
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 速度增强
- en: 'As is customary with all major SQLA releases, a wide pass through the internals
    to reduce overhead and callcounts has been made which further reduces the work
    needed in common scenarios. Highlights of this release include:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有主要SQLA版本一样，通过内部进行广泛的遍历以减少开销和调用次数，进一步减少了在常见情况下所需的工作量。此版本的亮点包括：
- en: The flush process will now bundle INSERT statements into batches fed to `cursor.executemany()`,
    for rows where the primary key is already present. In particular this usually
    applies to the “child” table on a joined table inheritance configuration, meaning
    the number of calls to `cursor.execute` for a large bulk insert of joined- table
    objects can be cut in half, allowing native DBAPI optimizations to take place
    for those statements passed to `cursor.executemany()` (such as re-using a prepared
    statement).
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 刷新过程现在将INSERT语句捆绑成批次供`cursor.executemany()`执行，对于主键已经存在的行。特别是在连接表继承配置中通常适用于“子”表，这意味着对于大量连接表对象的大批量插入，可以将对`cursor.execute`的调用次数减半，从而允许本地DBAPI优化对传递给`cursor.executemany()`的语句进行（例如重用准备好的语句）。
- en: The codepath invoked when accessing a many-to-one reference to a related object
    that’s already loaded has been greatly simplified. The identity map is checked
    directly without the need to generate a new `Query` object first, which is expensive
    in the context of thousands of in-memory many-to-ones being accessed. The usage
    of constructed-per-call “loader” objects is also no longer used for the majority
    of lazy attribute loads.
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当访问已加载的相关对象的多对一引用时，调用的代码路径已经大大简化。直接检查标识映射，无需首先生成新的`Query`对象，这在访问成千上万个内存中的多对一时是昂贵的。对于大多数延迟属性加载，也不再使用每次构造的“加载器”对象。
- en: The rewrite of composites allows a shorter codepath when mapper internals access
    mapped attributes within a flush.
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新编写组合使得在映射器内部访问映射属性时可以走更短的代码路径。
- en: New inlined attribute access functions replace the previous usage of “history”
    when the “save-update” and other cascade operations need to cascade among the
    full scope of datamembers associated with an attribute. This reduces the overhead
    of generating a new `History` object for this speed-critical operation.
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的内联属性访问函数取代了以前在“保存-更新”和其他级联操作需要在属性关联的所有数据成员范围内级联时使用“history”的做法。这减少了为这个速度关键操作生成新的`History`对象的开销。
- en: The internals of the `ExecutionContext`, the object corresponding to a statement
    execution, have been inlined and simplified.
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ExecutionContext`的内部，即对语句执行的对象，已经被内联和简化。'
- en: The `bind_processor()` and `result_processor()` callables generated by types
    for each statement execution are now cached (carefully, so as to avoid memory
    leaks for ad-hoc types and dialects) for the lifespan of that type, further reducing
    per-statement call overhead.
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由类型为每个语句执行生成的`bind_processor()`和`result_processor()`可调用现在被缓存（谨慎地，以避免临时类型和方言的内存泄漏）为该类型的寿命，进一步减少每个语句调用的开销。
- en: The collection of “bind processors” for a particular `Compiled` instance of
    a statement is also cached on the `Compiled` object, taking further advantage
    of the “compiled cache” used by the flush process to re-use the same compiled
    form of INSERT, UPDATE, DELETE statements.
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特定`Compiled`语句实例的“绑定处理器”集合也缓存在`Compiled`对象上，进一步利用了由刷新过程使用的“编译缓存”来重复使用相同的INSERT、UPDATE、DELETE语句的编译形式。
- en: A demonstration of callcount reduction including a sample benchmark script is
    at [https://techspot.zzzeek.org/2010/12/12/a-tale-of-three](https://techspot.zzzeek.org/2010/12/12/a-tale-of-three)-
    profiles/
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 包括一个示例基准脚本的调用次数减少演示在[https://techspot.zzzeek.org/2010/12/12/a-tale-of-three](https://techspot.zzzeek.org/2010/12/12/a-tale-of-three)-
    profiles/
- en: Composites Rewritten
  id: totrans-321
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 复合已重写
- en: The “composite” feature has been rewritten, like `synonym()` and `comparable_property()`,
    to use a lighter weight implementation based on descriptors and events, rather
    than building into the ORM internals. This allowed the removal of some latency
    from the mapper/unit of work internals, and simplifies the workings of composite.
    The composite attribute now no longer conceals the underlying columns it builds
    upon, which now remain as regular attributes. Composites can also act as a proxy
    for `relationship()` as well as `Column()` attributes.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: “composite”功能已被重写，类似于`synonym()`和`comparable_property()`，使用了基于描述符和事件的轻量级实现，而不是构建到ORM内部。这样做可以从映射器/工作单元内部删除一些延迟，并简化复合属性的工作方式。复合属性现在不再隐藏其构建在其上的基础列，这些列现在保持为常规属性。复合还可以充当`relationship()`以及`Column()`属性的代理。
- en: The major backwards-incompatible change of composites is that they no longer
    use the `mutable=True` system to detect in-place mutations. Please use the [Mutation
    Tracking](https://www.sqlalchemy.org/docs/07/orm/extensions/mutable.html) extension
    to establish in-place change events to existing composite usage.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 复合的主要不兼容性变化是它们不再使用`mutable=True`系统来检测原地突变。请使用[Mutation Tracking](https://www.sqlalchemy.org/docs/07/orm/extensions/mutable.html)扩展来建立对现有复合使用的原地更改事件。
- en: See also
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Composite Column Types](../orm/composites.html#mapper-composite)'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '[复合列类型](../orm/composites.html#mapper-composite)'
- en: '[Mutation Tracking](../orm/extensions/mutable.html)'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '[Mutation Tracking](../orm/extensions/mutable.html)'
- en: '[#2008](https://www.sqlalchemy.org/trac/ticket/2008) [#2024](https://www.sqlalchemy.org/trac/ticket/2024)'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2008](https://www.sqlalchemy.org/trac/ticket/2008) [#2024](https://www.sqlalchemy.org/trac/ticket/2024)'
- en: More succinct form of query.join(target, onclause)
  id: totrans-328
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更简洁的查询.join(target, onclause)形式
- en: 'The default method of issuing `query.join()` to a target with an explicit onclause
    is now:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 向具有显式onclause的目标发出`query.join()`的默认方法现在是：
- en: '[PRE31]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In 0.6, this usage was considered to be an error, because `join()` accepts multiple
    arguments corresponding to multiple JOIN clauses - the two-argument form needed
    to be in a tuple to disambiguate between single-argument and two- argument join
    targets. In the middle of 0.6 we added detection and an error message for this
    specific calling style, since it was so common. In 0.7, since we are detecting
    the exact pattern anyway, and since having to type out a tuple for no reason is
    extremely annoying, the non- tuple method now becomes the “normal” way to do it.
    The “multiple JOIN” use case is exceedingly rare compared to the single join case,
    and multiple joins these days are more clearly represented by multiple calls to
    `join()`.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在0.6版本中，这种用法被认为是错误的，因为`join()`接受多个参数对应于多个JOIN子句 - 两个参数形式需要在元组中以消除单参数和双参数连接目标之间的歧义。在0.6中间，我们为这种特定的调用风格添加了检测和错误消息，因为它是如此常见。在0.7中，由于我们无论如何都在检测确切的模式，并且因为不得不无缘无故地输入一个元组是极其恼人的，非元组方法现在成为“正常”做法。与单个连接情况相比，“多个JOIN”用例极为罕见，而如今多个连接更清晰地表示为多次调用`join()`。
- en: The tuple form will remain for backwards compatibility.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 元组形式将保留以确保向后兼容性。
- en: 'Note that all the other forms of `query.join()` remain unchanged:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，所有其他形式的`query.join()`保持不变：
- en: '[PRE32]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[Querying with Joins](https://www.sqlalchemy.org/docs/07/orm/tutorial.html#querying-with-joins)'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用连接查询](https://www.sqlalchemy.org/docs/07/orm/tutorial.html#querying-with-joins)'
- en: '[#1923](https://www.sqlalchemy.org/trac/ticket/1923)'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '[#1923](https://www.sqlalchemy.org/trac/ticket/1923)'
- en: '### Mutation event extension, supersedes “mutable=True”'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '### 突变事件扩展，取代“mutable=True”'
- en: A new extension, [Mutation Tracking](../orm/extensions/mutable.html), provides
    a mechanism by which user-defined datatypes can provide change events back to
    the owning parent or parents. The extension includes an approach for scalar database
    values, such as those managed by [`PickleType`](../core/type_basics.html#sqlalchemy.types.PickleType
    "sqlalchemy.types.PickleType"), `postgresql.ARRAY`, or other custom `MutableType`
    classes, as well as an approach for ORM “composites”, those configured using [`composite()`](../orm/composites.html#sqlalchemy.orm.composite
    "sqlalchemy.orm.composite").
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 一个新的扩展，[Mutation Tracking](../orm/extensions/mutable.html)，提供了一种机制，用户定义的数据类型可以向拥有的父级或父级提供更改事件。该扩展包括一种用于标量数据库值的方法，例如由[`PickleType`](../core/type_basics.html#sqlalchemy.types.PickleType
    "sqlalchemy.types.PickleType")、`postgresql.ARRAY`或其他自定义`MutableType`类管理的值，以及一种用于
    ORM “组合”配置的方法，这些配置使用[`composite()`](../orm/composites.html#sqlalchemy.orm.composite
    "sqlalchemy.orm.composite")。
- en: See also
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Mutation Tracking](../orm/extensions/mutable.html)'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '[Mutation Tracking](../orm/extensions/mutable.html)'
- en: NULLS FIRST / NULLS LAST operators
  id: totrans-341
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: NULLS FIRST / NULLS LAST 操作符
- en: These are implemented as an extension to the `asc()` and `desc()` operators,
    called `nullsfirst()` and `nullslast()`.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 这些操作符作为`asc()`和`desc()`操作符的扩展实现，称为`nullsfirst()`和`nullslast()`。
- en: See also
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`nullsfirst()`](../core/sqlelement.html#sqlalchemy.sql.expression.nullsfirst
    "sqlalchemy.sql.expression.nullsfirst")'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '[`nullsfirst()`](../core/sqlelement.html#sqlalchemy.sql.expression.nullsfirst
    "sqlalchemy.sql.expression.nullsfirst")'
- en: '[`nullslast()`](../core/sqlelement.html#sqlalchemy.sql.expression.nullslast
    "sqlalchemy.sql.expression.nullslast")'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '[`nullslast()`](../core/sqlelement.html#sqlalchemy.sql.expression.nullslast
    "sqlalchemy.sql.expression.nullslast")'
- en: '[#723](https://www.sqlalchemy.org/trac/ticket/723)'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '[#723](https://www.sqlalchemy.org/trac/ticket/723)'
- en: select.distinct(), query.distinct() accepts *args for PostgreSQL DISTINCT ON
  id: totrans-347
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: select.distinct()、query.distinct()接受 PostgreSQL DISTINCT ON 的*args
- en: This was already available by passing a list of expressions to the `distinct`
    keyword argument of `select()`, the `distinct()` method of `select()` and `Query`
    now accept positional arguments which are rendered as DISTINCT ON when a PostgreSQL
    backend is used.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将表达式列表传递给`select()`的`distinct`关键字参数，现在`select()`和`Query`的`distinct()`方法接受位置参数，当使用
    PostgreSQL 后端时，这些参数将被渲染为 DISTINCT ON。
- en: '[distinct()](https://www.sqlalchemy.org/docs/07/core/expression_api.html#sqlalchemy.sql.expression.Select.distinct)'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '[distinct()](https://www.sqlalchemy.org/docs/07/core/expression_api.html#sqlalchemy.sql.expression.Select.distinct)'
- en: '[Query.distinct()](https://www.sqlalchemy.org/docs/07/orm/query.html#sqlalchemy.orm.query.Query.distinct)'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '[Query.distinct()](https://www.sqlalchemy.org/docs/07/orm/query.html#sqlalchemy.orm.query.Query.distinct)'
- en: '[#1069](https://www.sqlalchemy.org/trac/ticket/1069)'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '[#1069](https://www.sqlalchemy.org/trac/ticket/1069)'
- en: '`Index()` can be placed inline inside of `Table`, `__table_args__`'
  id: totrans-352
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`Index()`可以内联放置在`Table`、`__table_args__`中'
- en: 'The Index() construct can be created inline with a Table definition, using
    strings as column names, as an alternative to the creation of the index outside
    of the Table. That is:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: Index() 构造可以与 Table 定义内联创建，使用字符串作为列名，作为在 Table 外创建索引的替代方法。即：
- en: '[PRE33]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The primary rationale here is for the benefit of declarative `__table_args__`,
    particularly when used with mixins:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的主要原因是为了声明式`__table_args__`的好处，特别是在与 mixins 一起使用时：
- en: '[PRE34]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[Indexes](https://www.sqlalchemy.org/docs/07/core/schema.html#indexes)'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '[Indexes](https://www.sqlalchemy.org/docs/07/core/schema.html#indexes)'
- en: Window Function SQL Construct
  id: totrans-358
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 窗口函数 SQL 构造
- en: A “window function” provides to a statement information about the result set
    as it’s produced. This allows criteria against various things like “row number”,
    “rank” and so forth. They are known to be supported at least by PostgreSQL, SQL
    Server and Oracle, possibly others.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: “窗口函数”向语句提供有关生成的结果集的信息。这允许根据诸如“行号”、“排名”等各种条件进行筛选。它们至少被 PostgreSQL、SQL Server
    和 Oracle 支持，可能还有其他数据库。
- en: 'The best introduction to window functions is on PostgreSQL’s site, where window
    functions have been supported since version 8.4:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 关于窗口函数的最佳介绍在 PostgreSQL 的网站上，自从 8.4 版本以来就支持窗口函数：
- en: '[https://www.postgresql.org/docs/current/static/tutorial-window.html](https://www.postgresql.org/docs/current/static/tutorial-window.html)'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.postgresql.org/docs/current/static/tutorial-window.html](https://www.postgresql.org/docs/current/static/tutorial-window.html)'
- en: 'SQLAlchemy provides a simple construct typically invoked via an existing function
    clause, using the `over()` method, which accepts `order_by` and `partition_by`
    keyword arguments. Below we replicate the first example in PG’s tutorial:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 提供了一个简单的构造，通常通过现有的函数子句调用，使用`over()`方法，接受`order_by`和`partition_by`关键字参数。下面我们复制了
    PG 教程中的第一个示例：
- en: '[PRE35]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'SQL:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 'SQL:'
- en: '[PRE36]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[sqlalchemy.sql.expression.over](https://www.sqlalchemy.org/docs/07/core/expression_api.html#sqlalchemy.sql.expression.over)'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '[sqlalchemy.sql.expression.over](https://www.sqlalchemy.org/docs/07/core/expression_api.html#sqlalchemy.sql.expression.over)'
- en: '[#1844](https://www.sqlalchemy.org/trac/ticket/1844)'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: '[#1844](https://www.sqlalchemy.org/trac/ticket/1844)'
- en: execution_options() on Connection accepts “isolation_level” argument
  id: totrans-368
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Connection上的execution_options()接受“isolation_level”参数
- en: This sets the transaction isolation level for a single `Connection`, until that
    `Connection` is closed and its underlying DBAPI resource returned to the connection
    pool, upon which the isolation level is reset back to the default. The default
    isolation level is set using the `isolation_level` argument to `create_engine()`.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为单个`Connection`设置事务隔离级别，直到该`Connection`关闭并其底层DBAPI资源返回到连接池，此时隔离级别将重置为默认值。默认的隔离级别是使用`create_engine()`的`isolation_level`参数设置的。
- en: Transaction isolation support is currently only supported by the PostgreSQL
    and SQLite backends.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 事务隔离支持目前仅由PostgreSQL和SQLite后端支持。
- en: '[execution_options()](https://www.sqlalchemy.org/docs/07/core/connections.html#sqlalchemy.engine.base.Connection.execution_options)'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '[execution_options()](https://www.sqlalchemy.org/docs/07/core/connections.html#sqlalchemy.engine.base.Connection.execution_options)'
- en: '[#2001](https://www.sqlalchemy.org/trac/ticket/2001)'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2001](https://www.sqlalchemy.org/trac/ticket/2001)'
- en: '`TypeDecorator` works with integer primary key columns'
  id: totrans-373
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`TypeDecorator`与整数主键列一起使用'
- en: A `TypeDecorator` which extends the behavior of `Integer` can be used with a
    primary key column. The “autoincrement” feature of `Column` will now recognize
    that the underlying database column is still an integer so that lastrowid mechanisms
    continue to function. The `TypeDecorator` itself will have its result value processor
    applied to newly generated primary keys, including those received by the DBAPI
    `cursor.lastrowid` accessor.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`TypeDecorator`，它扩展了`Integer`的行为，可以与主键列一起使用。`Column`的“autoincrement”特性现在将识别到底层数据库列仍然是整数，以便`lastrowid`机制继续正常工作。`TypeDecorator`本身将其结果值处理器应用于新生成的主键，包括通过DBAPI
    `cursor.lastrowid`访问器接收到的主键。
- en: '[#2005](https://www.sqlalchemy.org/trac/ticket/2005) [#2006](https://www.sqlalchemy.org/trac/ticket/2006)'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2005](https://www.sqlalchemy.org/trac/ticket/2005) [#2006](https://www.sqlalchemy.org/trac/ticket/2006)'
- en: '`TypeDecorator` is present in the “sqlalchemy” import space'
  id: totrans-376
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`TypeDecorator`存在于“sqlalchemy”导入空间中'
- en: No longer need to import this from `sqlalchemy.types`, it’s now mirrored in
    `sqlalchemy`.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 不再需要从`sqlalchemy.types`导入此内容，现在在`sqlalchemy`中有镜像。
- en: New Dialects
  id: totrans-378
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 新方言
- en: 'Dialects have been added:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 已添加方言：
- en: 'a MySQLdb driver for the Drizzle database:'
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于Drizzle数据库的MySQLdb驱动程序：
- en: '[Drizzle](https://www.sqlalchemy.org/docs/07/dialects/drizzle.html)'
  id: totrans-381
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[Drizzle](https://www.sqlalchemy.org/docs/07/dialects/drizzle.html)'
- en: 'support for the pymysql DBAPI:'
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持pymysql DBAPI：
- en: '[pymsql Notes](https://www.sqlalchemy.org/docs/07/dialects/mysql.html#module-sqlalchemy.dialects.mysql.pymysql)'
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[pymsql Notes](https://www.sqlalchemy.org/docs/07/dialects/mysql.html#module-sqlalchemy.dialects.mysql.pymysql)'
- en: psycopg2 now works with Python 3
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: psycopg2现在与Python 3兼容
- en: New Event System
  id: totrans-385
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 新事件系统
- en: SQLAlchemy started early with the `MapperExtension` class, which provided hooks
    into the persistence cycle of mappers. As SQLAlchemy quickly became more componentized,
    pushing mappers into a more focused configurational role, many more “extension”,
    “listener”, and “proxy” classes popped up to solve various activity-interception
    use cases in an ad-hoc fashion. Part of this was driven by the divergence of activities;
    `ConnectionProxy` objects wanted to provide a system of rewriting statements and
    parameters; `AttributeExtension` provided a system of replacing incoming values,
    and `DDL` objects had events that could be switched off of dialect-sensitive callables.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy早期开始使用`MapperExtension`类，该类提供了对映射器持久化周期的钩子。随着SQLAlchemy迅速变得更加组件化，将映射器推入更专注的配置角色，许多更多的“extension”、“listener”和“proxy”类出现，以解决各种活动拦截用例。部分原因是由活动的分歧驱动的；`ConnectionProxy`对象希望提供一个重写语句和参数的系统；`AttributeExtension`提供了一个替换传入值的系统，而`DDL`对象具有可以切换为方言敏感可调用的事件。
- en: 0.7 re-implements virtually all of these plugin points with a new, unified approach,
    which retains all the functionalities of the different systems, provides more
    flexibility and less boilerplate, performs better, and eliminates the need to
    learn radically different APIs for each event subsystem. The pre-existing classes
    `MapperExtension`, `SessionExtension`, `AttributeExtension`, `ConnectionProxy`,
    `PoolListener` as well as the `DDLElement.execute_at` method are deprecated and
    now implemented in terms of the new system - these APIs remain fully functional
    and are expected to remain in place for the foreseeable future.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 0.7版本使用了一种新的、统一的方法重新实现了几乎所有这些插件点，保留了不同系统的所有功能，提供了更多的灵活性和更少的样板代码，性能更好，并且消除了需要为每个事件子系统学习根本不同的API的必要性。预先存在的类`MapperExtension`、`SessionExtension`、`AttributeExtension`、`ConnectionProxy`、`PoolListener`以及`DDLElement.execute_at`方法已被弃用，现在根据新系统实现
    - 这些API仍然完全可用，并且预计将在可预见的未来保持不变。
- en: The new approach uses named events and user-defined callables to associate activities
    with events. The API’s look and feel was driven by such diverse sources as JQuery,
    Blinker, and Hibernate, and was also modified further on several occasions during
    conferences with dozens of users on Twitter, which appears to have a much higher
    response rate than the mailing list for such questions.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 新方法使用命名事件和用户定义的可调用对象将活动与事件关联起来。API的外观和感觉受到了JQuery、Blinder和Hibernate等多样化来源的驱动，并且在与数十名用户进行的会议期间多次进行了修改，这些会议在Twitter上的响应率似乎比邮件列表更高。
- en: It also features an open-ended system of target specification that allows events
    to be associated with API classes, such as for all `Session` or `Engine` objects,
    with specific instances of API classes, such as for a specific `Pool` or `Mapper`,
    as well as for related objects like a user- defined class that’s mapped, or something
    as specific as a certain attribute on instances of a particular subclass of a
    mapped parent class. Individual listener subsystems can apply wrappers to incoming
    user- defined listener functions which modify how they are called - an mapper
    event can receive either the instance of the object being operated upon, or its
    underlying `InstanceState` object. An attribute event can opt whether or not to
    have the responsibility of returning a new value.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 它还具有一种开放式的目标规范系统，允许将事件与API类关联，例如所有的`Session`或`Engine`对象，以及特定API类的实例，例如特定的`Pool`或`Mapper`，以及相关对象，如映射的用户定义类，或者特定子类的映射父类实例的特定属性。各个监听器子系统可以对传入的用户定义监听器函数应用包装器，修改它们的调用方式
    - 映射事件可以接收被操作对象的实例，或者其底层的`InstanceState`对象。属性事件可以选择是否要负责返回一个新值。
- en: Several systems now build upon the new event API, including the new “mutable
    attributes” API as well as composite attributes. The greater emphasis on events
    has also led to the introduction of a handful of new events, including attribute
    expiration and refresh operations, pickle loads/dumps operations, completed mapper
    construction operations.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 几个系统现在建立在新的事件API之上，包括新的“可变属性”API以及复合属性。对事件的更大强调还导致引入了一些新事件，包括属性过期和刷新操作，pickle加载/转储操作，完成的映射器构造操作。
- en: See also
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Events](../core/event.html)'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '[事件](../core/event.html)'
- en: '[#1902](https://www.sqlalchemy.org/trac/ticket/1902)'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '[#1902](https://www.sqlalchemy.org/trac/ticket/1902)'
- en: Hybrid Attributes, implements/supersedes synonym(), comparable_property()
  id: totrans-394
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 混合属性，实现/取代了synonym()、comparable_property()
- en: The “derived attributes” example has now been turned into an official extension.
    The typical use case for `synonym()` is to provide descriptor access to a mapped
    column; the use case for `comparable_property()` is to be able to return a `PropComparator`
    from any descriptor. In practice, the approach of “derived” is easier to use,
    more extensible, is implemented in a few dozen lines of pure Python with almost
    no imports, and doesn’t require the ORM core to even be aware of it. The feature
    is now known as the “Hybrid Attributes” extension.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: “派生属性”示例现在已成为官方扩展。`synonym()`的典型用例是为映射列提供描述符访问；`comparable_property()`的用例是能够从任何描述符返回`PropComparator`。实际上，“派生”的方法更容易使用，更具可扩展性，用几十行纯Python实现，几乎不需要导入，甚至不需要ORM核心知道它。该功能现在被称为“混合属性”扩展。
- en: '`synonym()` and `comparable_property()` are still part of the ORM, though their
    implementations have been moved outwards, building on an approach that is similar
    to that of the hybrid extension, so that the core ORM mapper/query/property modules
    aren’t really aware of them otherwise.'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '`synonym()`和`comparable_property()`仍然是ORM的一部分，尽管它们的实现已经移出，建立在类似于混合扩展的方法上，因此核心ORM映射器/查询/属性模块在其他情况下并不真正意识到它们。'
- en: See also
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[Hybrid Attributes](../orm/extensions/hybrid.html)'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '[混合属性](../orm/extensions/hybrid.html)'
- en: '[#1903](https://www.sqlalchemy.org/trac/ticket/1903)'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '[#1903](https://www.sqlalchemy.org/trac/ticket/1903)'
- en: Speed Enhancements
  id: totrans-400
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 速度增强
- en: 'As is customary with all major SQLA releases, a wide pass through the internals
    to reduce overhead and callcounts has been made which further reduces the work
    needed in common scenarios. Highlights of this release include:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有主要SQLA版本一样，通过内部进行广泛的遍历以减少开销和调用次数，进一步减少了常见情况下所需的工作量。此版本的亮点包括：
- en: The flush process will now bundle INSERT statements into batches fed to `cursor.executemany()`,
    for rows where the primary key is already present. In particular this usually
    applies to the “child” table on a joined table inheritance configuration, meaning
    the number of calls to `cursor.execute` for a large bulk insert of joined- table
    objects can be cut in half, allowing native DBAPI optimizations to take place
    for those statements passed to `cursor.executemany()` (such as re-using a prepared
    statement).
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 刷新过程现在将INSERT语句捆绑成批次提供给`cursor.executemany()`，对于主键已经存在的行。特别是这通常适用于连接表继承配置中的“子”表，这意味着对于大量连接表对象的批量插入，可以将`cursor.execute`的调用次数减少一半，从而允许针对那些传递给`cursor.executemany()`的语句进行本地DBAPI优化（例如重用准备好的语句）。
- en: The codepath invoked when accessing a many-to-one reference to a related object
    that’s already loaded has been greatly simplified. The identity map is checked
    directly without the need to generate a new `Query` object first, which is expensive
    in the context of thousands of in-memory many-to-ones being accessed. The usage
    of constructed-per-call “loader” objects is also no longer used for the majority
    of lazy attribute loads.
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当访问已加载的相关对象的多对一引用时，调用的代码路径已经大大简化。直接检查标识映射，无需首先生成一个新的`Query`对象，这在访问成千上万个内存中的多对一时是昂贵的。对于大多数延迟属性加载，也不再使用每次构造的“加载器”对象。
- en: The rewrite of composites allows a shorter codepath when mapper internals access
    mapped attributes within a flush.
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重写复合体允许在映射器内部访问在刷新中与映射属性相关的属性时，使用更短的代码路径。
- en: New inlined attribute access functions replace the previous usage of “history”
    when the “save-update” and other cascade operations need to cascade among the
    full scope of datamembers associated with an attribute. This reduces the overhead
    of generating a new `History` object for this speed-critical operation.
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的内联属性访问函数取代了以前在“save-update”和其他级联操作需要在属性的所有数据成员范围内级联时使用“history”的用法。这减少了为这个速度关键操作生成新的`History`对象的开销。
- en: The internals of the `ExecutionContext`, the object corresponding to a statement
    execution, have been inlined and simplified.
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ExecutionContext`的内部，对应于语句执行的对象，已经内联并简化。'
- en: The `bind_processor()` and `result_processor()` callables generated by types
    for each statement execution are now cached (carefully, so as to avoid memory
    leaks for ad-hoc types and dialects) for the lifespan of that type, further reducing
    per-statement call overhead.
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为每个语句执行生成的类型的`bind_processor()`和`result_processor()`可调用现在被缓存（小心翼翼地，以避免对临时类型和方言造成内存泄漏），在该类型的生命周期内，进一步减少每个语句调用的开销。
- en: The collection of “bind processors” for a particular `Compiled` instance of
    a statement is also cached on the `Compiled` object, taking further advantage
    of the “compiled cache” used by the flush process to re-use the same compiled
    form of INSERT, UPDATE, DELETE statements.
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特定`Compiled`实例的“绑定处理器”集合也被缓存在`Compiled`对象上，进一步利用刷新过程使用的“编译缓存”，以重用相同的INSERT、UPDATE、DELETE语句的编译形式。
- en: A demonstration of callcount reduction including a sample benchmark script is
    at [https://techspot.zzzeek.org/2010/12/12/a-tale-of-three](https://techspot.zzzeek.org/2010/12/12/a-tale-of-three)-
    profiles/
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 一个减少调用次数的演示，包括一个示例基准脚本，位于[https://techspot.zzzeek.org/2010/12/12/a-tale-of-three](https://techspot.zzzeek.org/2010/12/12/a-tale-of-three)-
    profiles/。
- en: Composites Rewritten
  id: totrans-410
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 复合体重写
- en: The “composite” feature has been rewritten, like `synonym()` and `comparable_property()`,
    to use a lighter weight implementation based on descriptors and events, rather
    than building into the ORM internals. This allowed the removal of some latency
    from the mapper/unit of work internals, and simplifies the workings of composite.
    The composite attribute now no longer conceals the underlying columns it builds
    upon, which now remain as regular attributes. Composites can also act as a proxy
    for `relationship()` as well as `Column()` attributes.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: “复合”功能已经被重写，就像`synonym()`和`comparable_property()`一样，使用基于描述符和事件的轻量级实现，而不是构建到ORM内部。这允许从映射器/工作单元内部删除一些延迟，并简化复合的工作方式。复合属性现在不再隐藏其构建在其上的基础列，这些列现在保持为常规属性。复合还可以充当`relationship()`以及`Column()`属性的代理。
- en: The major backwards-incompatible change of composites is that they no longer
    use the `mutable=True` system to detect in-place mutations. Please use the [Mutation
    Tracking](https://www.sqlalchemy.org/docs/07/orm/extensions/mutable.html) extension
    to establish in-place change events to existing composite usage.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 复合的主要不兼容变更是，它们不再使用`mutable=True`系统来检测原地变异。请使用[Mutation Tracking](https://www.sqlalchemy.org/docs/07/orm/extensions/mutable.html)扩展来建立对现有复合使用的原地更改事件。
- en: See also
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[Composite Column Types](../orm/composites.html#mapper-composite)'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '[复合列类型](../orm/composites.html#mapper-composite)'
- en: '[Mutation Tracking](../orm/extensions/mutable.html)'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '[变异跟踪](../orm/extensions/mutable.html)'
- en: '[#2008](https://www.sqlalchemy.org/trac/ticket/2008) [#2024](https://www.sqlalchemy.org/trac/ticket/2024)'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2008](https://www.sqlalchemy.org/trac/ticket/2008) [#2024](https://www.sqlalchemy.org/trac/ticket/2024)'
- en: More succinct form of query.join(target, onclause)
  id: totrans-417
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更简洁的查询.join(target, onclause)形式
- en: 'The default method of issuing `query.join()` to a target with an explicit onclause
    is now:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 向具有显式onclause的目标发出`query.join()`的默认方法现在是：
- en: '[PRE37]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In 0.6, this usage was considered to be an error, because `join()` accepts multiple
    arguments corresponding to multiple JOIN clauses - the two-argument form needed
    to be in a tuple to disambiguate between single-argument and two- argument join
    targets. In the middle of 0.6 we added detection and an error message for this
    specific calling style, since it was so common. In 0.7, since we are detecting
    the exact pattern anyway, and since having to type out a tuple for no reason is
    extremely annoying, the non- tuple method now becomes the “normal” way to do it.
    The “multiple JOIN” use case is exceedingly rare compared to the single join case,
    and multiple joins these days are more clearly represented by multiple calls to
    `join()`.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 在0.6版本中，这种用法被认为是错误的，因为`join()`接受多个参数对应于多个JOIN子句 - 两个参数形式需要在元组中以消除单参数和双参数连接目标之间的歧义。在0.6的中间，我们添加了检测和针对这种特定调用风格的错误消息，因为这种情况非常普遍。在0.7中，由于我们无论如何都在检测确切的模式，并且由于不得不无缘无故地输入元组非常恼人，非元组方法现在成为“正常”做法。与单个连接情况相比，“多个JOIN”用例极为罕见，而如今多个连接更清晰地表示为多次调用`join()`。
- en: The tuple form will remain for backwards compatibility.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 元组形式将保留以确保向后兼容性。
- en: 'Note that all the other forms of `query.join()` remain unchanged:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，所有其他形式的`query.join()`保持不变：
- en: '[PRE38]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[Querying with Joins](https://www.sqlalchemy.org/docs/07/orm/tutorial.html#querying-with-joins)'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用连接查询](https://www.sqlalchemy.org/docs/07/orm/tutorial.html#querying-with-joins)'
- en: '[#1923](https://www.sqlalchemy.org/trac/ticket/1923)'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '[#1923](https://www.sqlalchemy.org/trac/ticket/1923)'
- en: '### Mutation event extension, supersedes “mutable=True”'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: '### 变异事件扩展，取代“mutable=True”'
- en: A new extension, [Mutation Tracking](../orm/extensions/mutable.html), provides
    a mechanism by which user-defined datatypes can provide change events back to
    the owning parent or parents. The extension includes an approach for scalar database
    values, such as those managed by [`PickleType`](../core/type_basics.html#sqlalchemy.types.PickleType
    "sqlalchemy.types.PickleType"), `postgresql.ARRAY`, or other custom `MutableType`
    classes, as well as an approach for ORM “composites”, those configured using [`composite()`](../orm/composites.html#sqlalchemy.orm.composite
    "sqlalchemy.orm.composite").
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 一个新的扩展，[变异跟踪](../orm/extensions/mutable.html)，提供了一种机制，通过该机制，用户定义的数据类型可以向拥有的父级或父级提供更改事件。该扩展包括一种用于标量数据库值的方法，例如由[`PickleType`](../core/type_basics.html#sqlalchemy.types.PickleType
    "sqlalchemy.types.PickleType")管理的值，`postgresql.ARRAY`或其他自定义`MutableType`类，以及一种用于ORM“复合”配置的方法，这些配置使用[`composite()`](../orm/composites.html#sqlalchemy.orm.composite
    "sqlalchemy.orm.composite")。
- en: See also
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[Mutation Tracking](../orm/extensions/mutable.html)'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: '[变异跟踪](../orm/extensions/mutable.html)'
- en: NULLS FIRST / NULLS LAST operators
  id: totrans-430
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: NULLS FIRST / NULLS LAST 操作符
- en: These are implemented as an extension to the `asc()` and `desc()` operators,
    called `nullsfirst()` and `nullslast()`.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 这些被实现为`asc()`和`desc()`运算符的扩展，称为`nullsfirst()`和`nullslast()`。
- en: See also
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`nullsfirst()`](../core/sqlelement.html#sqlalchemy.sql.expression.nullsfirst
    "sqlalchemy.sql.expression.nullsfirst")'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '[`nullsfirst()`](../core/sqlelement.html#sqlalchemy.sql.expression.nullsfirst
    "sqlalchemy.sql.expression.nullsfirst")'
- en: '[`nullslast()`](../core/sqlelement.html#sqlalchemy.sql.expression.nullslast
    "sqlalchemy.sql.expression.nullslast")'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: '[`nullslast()`](../core/sqlelement.html#sqlalchemy.sql.expression.nullslast
    "sqlalchemy.sql.expression.nullslast")'
- en: '[#723](https://www.sqlalchemy.org/trac/ticket/723)'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: '[#723](https://www.sqlalchemy.org/trac/ticket/723)'
- en: select.distinct(), query.distinct() accepts *args for PostgreSQL DISTINCT ON
  id: totrans-436
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: select.distinct()，query.distinct()接受*args用于PostgreSQL DISTINCT ON
- en: This was already available by passing a list of expressions to the `distinct`
    keyword argument of `select()`, the `distinct()` method of `select()` and `Query`
    now accept positional arguments which are rendered as DISTINCT ON when a PostgreSQL
    backend is used.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将表达式列表传递给`select()`的`distinct`关键字参数，现在`select()`和`Query`的`distinct()`方法接受位置参数，当使用PostgreSQL后端时，这些参数将被渲染为DISTINCT
    ON。
- en: '[distinct()](https://www.sqlalchemy.org/docs/07/core/expression_api.html#sqlalchemy.sql.expression.Select.distinct)'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: '[distinct()](https://www.sqlalchemy.org/docs/07/core/expression_api.html#sqlalchemy.sql.expression.Select.distinct)'
- en: '[Query.distinct()](https://www.sqlalchemy.org/docs/07/orm/query.html#sqlalchemy.orm.query.Query.distinct)'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '[Query.distinct()](https://www.sqlalchemy.org/docs/07/orm/query.html#sqlalchemy.orm.query.Query.distinct)'
- en: '[#1069](https://www.sqlalchemy.org/trac/ticket/1069)'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: '[#1069](https://www.sqlalchemy.org/trac/ticket/1069)'
- en: '`Index()` can be placed inline inside of `Table`, `__table_args__`'
  id: totrans-441
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`Index()`可以内联放置在`Table`、`__table_args__`内'
- en: 'The Index() construct can be created inline with a Table definition, using
    strings as column names, as an alternative to the creation of the index outside
    of the Table. That is:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: Index()构造可以与Table定义内联创建，使用字符串作为列名，作为在Table之外创建索引的替代方法。即：
- en: '[PRE39]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The primary rationale here is for the benefit of declarative `__table_args__`,
    particularly when used with mixins:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的主要原因是为了声明性`__table_args__`的好处，特别是在与混合使用时：
- en: '[PRE40]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[Indexes](https://www.sqlalchemy.org/docs/07/core/schema.html#indexes)'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: '[Indexes](https://www.sqlalchemy.org/docs/07/core/schema.html#indexes)'
- en: Window Function SQL Construct
  id: totrans-447
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 窗口函数SQL构造
- en: A “window function” provides to a statement information about the result set
    as it’s produced. This allows criteria against various things like “row number”,
    “rank” and so forth. They are known to be supported at least by PostgreSQL, SQL
    Server and Oracle, possibly others.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: “窗口函数”为语句提供了有关生成的结果集的信息。这允许根据诸如“行号”、“排名”等各种条件进行查询。它们至少被已知支持的PostgreSQL、SQL Server和Oracle支持，可能还有其他数据库。
- en: 'The best introduction to window functions is on PostgreSQL’s site, where window
    functions have been supported since version 8.4:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 关于窗口函数的最佳介绍在PostgreSQL的网站上，窗口函数自8.4版本起就得到支持：
- en: '[https://www.postgresql.org/docs/current/static/tutorial-window.html](https://www.postgresql.org/docs/current/static/tutorial-window.html)'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.postgresql.org/docs/current/static/tutorial-window.html](https://www.postgresql.org/docs/current/static/tutorial-window.html)'
- en: 'SQLAlchemy provides a simple construct typically invoked via an existing function
    clause, using the `over()` method, which accepts `order_by` and `partition_by`
    keyword arguments. Below we replicate the first example in PG’s tutorial:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy提供了一个简单的构造，通常通过现有的函数子句调用，使用`over()`方法，接受`order_by`和`partition_by`关键字参数。下面我们复制了PG教程中的第一个示例：
- en: '[PRE41]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'SQL:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: SQL：
- en: '[PRE42]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[sqlalchemy.sql.expression.over](https://www.sqlalchemy.org/docs/07/core/expression_api.html#sqlalchemy.sql.expression.over)'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: '[sqlalchemy.sql.expression.over](https://www.sqlalchemy.org/docs/07/core/expression_api.html#sqlalchemy.sql.expression.over)'
- en: '[#1844](https://www.sqlalchemy.org/trac/ticket/1844)'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: '[#1844](https://www.sqlalchemy.org/trac/ticket/1844)'
- en: execution_options() on Connection accepts “isolation_level” argument
  id: totrans-457
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Connection上的execution_options()接受“isolation_level”参数
- en: This sets the transaction isolation level for a single `Connection`, until that
    `Connection` is closed and its underlying DBAPI resource returned to the connection
    pool, upon which the isolation level is reset back to the default. The default
    isolation level is set using the `isolation_level` argument to `create_engine()`.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 这为单个`Connection`设置了事务隔离级别，直到该`Connection`关闭并其底层DBAPI资源返回到连接池，此时隔离级别将重置为默认值。默认的隔离级别是使用`create_engine()`的`isolation_level`参数设置的。
- en: Transaction isolation support is currently only supported by the PostgreSQL
    and SQLite backends.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 事务隔离支持目前仅由PostgreSQL和SQLite后端支持。
- en: '[execution_options()](https://www.sqlalchemy.org/docs/07/core/connections.html#sqlalchemy.engine.base.Connection.execution_options)'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: '[execution_options()](https://www.sqlalchemy.org/docs/07/core/connections.html#sqlalchemy.engine.base.Connection.execution_options)'
- en: '[#2001](https://www.sqlalchemy.org/trac/ticket/2001)'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2001](https://www.sqlalchemy.org/trac/ticket/2001)'
- en: '`TypeDecorator` works with integer primary key columns'
  id: totrans-462
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`TypeDecorator` 与整数主键列一起使用'
- en: A `TypeDecorator` which extends the behavior of `Integer` can be used with a
    primary key column. The “autoincrement” feature of `Column` will now recognize
    that the underlying database column is still an integer so that lastrowid mechanisms
    continue to function. The `TypeDecorator` itself will have its result value processor
    applied to newly generated primary keys, including those received by the DBAPI
    `cursor.lastrowid` accessor.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用扩展`Integer`行为的`TypeDecorator`与主键列一起使用。`Column`的“autoincrement”特性现在将识别到底层数据库列仍然是整数，以便`lastrowid`机制继续正常工作。`TypeDecorator`本身的结果值处理器将应用于新生成的主键，包括通过
    DBAPI `cursor.lastrowid`访问器接收到的主键。
- en: '[#2005](https://www.sqlalchemy.org/trac/ticket/2005) [#2006](https://www.sqlalchemy.org/trac/ticket/2006)'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2005](https://www.sqlalchemy.org/trac/ticket/2005) [#2006](https://www.sqlalchemy.org/trac/ticket/2006)'
- en: '`TypeDecorator` is present in the “sqlalchemy” import space'
  id: totrans-465
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`TypeDecorator` 存在于“sqlalchemy”导入空间中'
- en: No longer need to import this from `sqlalchemy.types`, it’s now mirrored in
    `sqlalchemy`.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 不再需要从`sqlalchemy.types`导入，现在在`sqlalchemy`中有镜像。
- en: New Dialects
  id: totrans-467
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 新方言
- en: 'Dialects have been added:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 已添加方言：
- en: 'a MySQLdb driver for the Drizzle database:'
  id: totrans-469
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于 Drizzle 数据库的 MySQLdb 驱动程序：
- en: '[Drizzle](https://www.sqlalchemy.org/docs/07/dialects/drizzle.html)'
  id: totrans-470
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[Drizzle](https://www.sqlalchemy.org/docs/07/dialects/drizzle.html)'
- en: 'support for the pymysql DBAPI:'
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持 pymysql DBAPI：
- en: '[pymsql Notes](https://www.sqlalchemy.org/docs/07/dialects/mysql.html#module-sqlalchemy.dialects.mysql.pymysql)'
  id: totrans-472
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[pymsql Notes](https://www.sqlalchemy.org/docs/07/dialects/mysql.html#module-sqlalchemy.dialects.mysql.pymysql)'
- en: psycopg2 now works with Python 3
  id: totrans-473
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: psycopg2 现在与 Python 3 兼容
- en: Behavioral Changes (Backwards Compatible)
  id: totrans-474
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 行为变更（向后兼容）
- en: C Extensions Build by Default
  id: totrans-475
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 默认情况下构建 C 扩展
- en: This is as of 0.7b4\. The exts will build if cPython 2.xx is detected. If the
    build fails, such as on a windows install, that condition is caught and the non-C
    install proceeds. The C exts won’t build if Python 3 or PyPy is used.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 这是从 0.7b4 开始的。如果检测到 cPython 2.xx，则会构建扩展。如果构建失败，例如在 Windows 安装中，会捕获该条件并继续非 C
    安装。如果使用 Python 3 或 PyPy，则不会构建 C 扩展。
- en: Query.count() simplified, should work virtually always
  id: totrans-477
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 简化的 Query.count()，几乎总是有效
- en: 'The very old guesswork which occurred within `Query.count()` has been modernized
    to use `.from_self()`. That is, `query.count()` is now equivalent to:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: '`Query.count()`内部的非常古老的猜测现在已经被现代化，使用`.from_self()`。也就是说，`query.count()`现在等效于：'
- en: '[PRE43]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Previously, internal logic attempted to rewrite the columns clause of the query
    itself, and upon detection of a “subquery” condition, such as a column-based query
    that might have aggregates in it, or a query with DISTINCT, would go through a
    convoluted process of rewriting the columns clause. This logic failed in complex
    conditions, particularly those involving joined table inheritance, and was long
    obsolete by the more comprehensive `.from_self()` call.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，内部逻辑尝试重写查询本身的列子句，并在检测到“子查询”条件时，例如可能在其中具有聚合的基于列的查询，或具有 DISTINCT 的查询时，会经历一个繁琐的过程来重写列子句。这种逻辑在复杂条件下失败，特别是涉及联接表继承的条件，并且长期以来已经被更全面的`.from_self()`调用所淘汰。
- en: 'The SQL emitted by `query.count()` is now always of the form:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: '`query.count()`生成的 SQL 现在总是形式为：'
- en: '[PRE44]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: that is, the original query is preserved entirely inside of a subquery, with
    no more guessing as to how count should be applied.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，原始查询完全保留在子查询中，不再需要猜测如何应用计数。
- en: '[#2093](https://www.sqlalchemy.org/trac/ticket/2093)'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2093](https://www.sqlalchemy.org/trac/ticket/2093)'
- en: To emit a non-subquery form of count()
  id: totrans-485
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 发出非子查询形式的 count()
- en: 'MySQL users have already reported that the MyISAM engine not surprisingly falls
    over completely with this simple change. Note that for a simple `count()` that
    optimizes for DBs that can’t handle simple subqueries, `func.count()` should be
    used:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL 用户已经报告说，MyISAM 引擎在这个简单的更改中完全崩溃，这并不奇怪。请注意，对于优化不能处理简单子查询的数据库的简单`count()`，应该使用`func.count()`：
- en: '[PRE45]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'or for `count(*)`:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 或者对于`count(*)`：
- en: '[PRE46]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: LIMIT/OFFSET clauses now use bind parameters
  id: totrans-490
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: LIMIT/OFFSET 子句现在使用绑定参数
- en: The LIMIT and OFFSET clauses, or their backend equivalents (i.e. TOP, ROW NUMBER
    OVER, etc.), use bind parameters for the actual values, for all backends which
    support it (most except for Sybase). This allows better query optimizer performance
    as the textual string for multiple statements with differing LIMIT/OFFSET are
    now identical.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: LIMIT和OFFSET子句，或其后端等效项（即TOP，ROW NUMBER OVER等），对于支持它的所有后端使用绑定参数进行实际值，（除了Sybase之外的大多数后端）。这样做可以提高查询优化器的性能，因为具有不同LIMIT/OFFSET的多个语句的文本字符串现在是相同的。
- en: '[#805](https://www.sqlalchemy.org/trac/ticket/805)'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: '[#805](https://www.sqlalchemy.org/trac/ticket/805)'
- en: Logging enhancements
  id: totrans-493
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 日志增强
- en: Vinay Sajip has provided a patch to our logging system such that the “hex string”
    embedded in logging statements for engines and pools is no longer needed to allow
    the `echo` flag to work correctly. A new system that uses filtered logging objects
    allows us to maintain our current behavior of `echo` being local to individual
    engines without the need for additional identifying strings local to those engines.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: Vinay Sajip提供了一个补丁，使我们的日志系统中不再需要在引擎和池的日志语句中嵌入“十六进制字符串”以使`echo`标志正常工作。使用过滤日志对象的新系统使我们能够保持`echo`仅适用于各个引擎而无需额外的标识字符串。
- en: '[#1926](https://www.sqlalchemy.org/trac/ticket/1926)'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: '[#1926](https://www.sqlalchemy.org/trac/ticket/1926)'
- en: Simplified polymorphic_on assignment
  id: totrans-496
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 简化的多态_on赋值
- en: 'The population of the `polymorphic_on` column-mapped attribute, when used in
    an inheritance scenario, now occurs when the object is constructed, i.e. its `__init__`
    method is called, using the init event. The attribute then behaves the same as
    any other column-mapped attribute. Previously, special logic would fire off during
    flush to populate this column, which prevented any user code from modifying its
    behavior. The new approach improves upon this in three ways: 1\. the polymorphic
    identity is now present on the object as soon as its constructed; 2\. the polymorphic
    identity can be changed by user code without any difference in behavior from any
    other column-mapped attribute; 3\. the internals of the mapper during flush are
    simplified and no longer need to make special checks for this column.'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 在继承场景中使用时，`polymorphic_on`列映射属性的填充现在发生在对象构造时，即调用其`__init__`方法时，使用init事件。然后，该属性的行为与任何其他列映射属性相同。以前，特殊逻辑会在刷新期间触发以填充此列，这会阻止任何用户代码修改其行为。新方法在三个方面改进了这一点：1.多态标识现在在对象构造时立即存在；2.用户代码可以更改多态标识而不会与任何其他列映射属性有任何不同的行为；3.在刷新期间，映射器的内部简化，不再需要对此列进行特殊检查。
- en: '[#1895](https://www.sqlalchemy.org/trac/ticket/1895)'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: '[#1895](https://www.sqlalchemy.org/trac/ticket/1895)'
- en: contains_eager() chains across multiple paths (i.e. “all()”)
  id: totrans-499
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 跨多个路径（即“all()”）的contains_eager()链
- en: 'The ``contains_eager()[PRE47]contains_eager()`` calls. Instead of:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: '``contains_eager()[PRE47]contains_eager()``调用。而不是：'
- en: '[PRE48]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'you can say:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以说：
- en: '[PRE49]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[#2032](https://www.sqlalchemy.org/trac/ticket/2032)'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2032](https://www.sqlalchemy.org/trac/ticket/2032)'
- en: Flushing of orphans that have no parent is allowed
  id: totrans-505
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 允许刷新没有父级的孤儿
- en: We’ve had a long standing behavior that checks for a so- called “orphan” during
    flush, that is, an object which is associated with a `relationship()` that specifies
    “delete- orphan” cascade, has been newly added to the session for an INSERT, and
    no parent relationship has been established. This check was added years ago to
    accommodate some test cases which tested the orphan behavior for consistency.
    In modern SQLA, this check is no longer needed on the Python side. The equivalent
    behavior of the “orphan check” is accomplished by making the foreign key reference
    to the object’s parent row NOT NULL, where the database does its job of establishing
    data consistency in the same way SQLA allows most other operations to do. If the
    object’s parent foreign key is nullable, then the row can be inserted. The “orphan”
    behavior runs when the object was persisted with a particular parent, and is then
    disassociated with that parent, leading to a DELETE statement emitted for it.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直有一个长期存在的行为，即在刷新时检查所谓的“孤儿”，即与指定“delete-orphan”级联的`relationship()`相关联的对象，已经被新添加到会话中进行INSERT操作，但尚未建立父关系。多年前添加了此检查以适应一些测试用例，这些测试用例测试了孤儿行为的一致性。在现代SQLA中，这种检查在Python端不再需要。通过使对象的外键引用对象的父行为NOT
    NULL，数据库会以SQLA允许大多数其他操作执行的方式确保数据一致性，从而实现“孤儿检查”的等效行为。如果对象的父外键是可为空的，则可以插入行。当对象与特定父对象一起持久化，然后与该父对象解除关联时，会触发“孤儿”行为，导致为其发出DELETE语句。
- en: '[#1912](https://www.sqlalchemy.org/trac/ticket/1912)'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: '[#1912](https://www.sqlalchemy.org/trac/ticket/1912)'
- en: Warnings generated when collection members, scalar referents not part of the
    flush
  id: totrans-508
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在收集成员，不是刷新的标量引用时生成的警告
- en: Warnings are now emitted when related objects referenced via a loaded `relationship()`
    on a parent object marked as “dirty” are not present in the current `Session`.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 当通过父对象上标记为“脏”的加载`relationship()`引用的相关对象在当前`Session`中不存在时，现在会发出警告。
- en: The `save-update` cascade takes effect when objects are added to the `Session`,
    or when objects are first associated with a parent, so that an object and everything
    related to it are usually all present in the same `Session`. However, if `save-update`
    cascade is disabled for a particular `relationship()`, then this behavior does
    not occur, and the flush process does not try to correct for it, instead staying
    consistent to the configured cascade behavior. Previously, when such objects were
    detected during the flush, they were silently skipped. The new behavior is that
    a warning is emitted, for the purposes of alerting to a situation that more often
    than not is the source of unexpected behavior.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 当对象被添加到`Session`时，或者当对象首次与父对象关联时，`save-update`级联生效，以便对象及其所有相关内容通常都存在于同一个`Session`中。但是，如果对于特定的`relationship()`禁用了`save-update`级联，则此行为不会发生，并且刷新过程不会尝试纠正它，而是保持一致到配置的级联行为。以前，在刷新期间检测到这样的对象时，它们会被静默跳过。新行为是发出警告，目的是提醒一个经常是意外行为来源的情况。
- en: '[#1973](https://www.sqlalchemy.org/trac/ticket/1973)'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: '[#1973](https://www.sqlalchemy.org/trac/ticket/1973)'
- en: Setup no longer installs a Nose plugin
  id: totrans-512
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置不再安装Nose插件
- en: Since we moved to nose we’ve used a plugin that installs via setuptools, so
    that the `nosetests` script would automatically run SQLA’s plugin code, necessary
    for our tests to have a full environment. In the middle of 0.6, we realized that
    the import pattern here meant that Nose’s “coverage” plugin would break, since
    “coverage” requires that it be started before any modules to be covered are imported;
    so in the middle of 0.6 we made the situation worse by adding a separate `sqlalchemy-nose`
    package to the build to overcome this.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 自从我们转向nose以来，我们使用了一个通过setuptools安装的插件，这样`nosetests`脚本会自动运行SQLA的插件代码，这对于我们的测试来说是必要的，以便有一个完整的环境。在0.6的中间，我们意识到这里的导入模式意味着Nose的“coverage”插件会中断，因为“coverage”要求在导入要覆盖的任何模块之前启动它；所以在0.6的中间，我们通过添加一个单独的`sqlalchemy-nose`包来克服这一情况，使情况变得更糟。
- en: In 0.7 we’ve done away with trying to get `nosetests` to work automatically,
    since the SQLAlchemy module would produce a large number of nose configuration
    options for all usages of `nosetests`, not just the SQLAlchemy unit tests themselves,
    and the additional `sqlalchemy-nose` install was an even worse idea, producing
    an extra package in Python environments. The `sqla_nose.py` script in 0.7 is now
    the only way to run the tests with nose.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 在0.7中，我们已经放弃了尝试让`nosetests`自动工作，因为SQLAlchemy模块会为所有`nosetests`的用法产生大量的nose配置选项，而不仅仅是SQLAlchemy单元测试本身，而且额外的`sqlalchemy-nose`安装甚至更糟，会在Python环境中产生一个额外的包。在0.7中，`sqla_nose.py`脚本现在是使用nose运行测试的唯一方法。
- en: '[#1949](https://www.sqlalchemy.org/trac/ticket/1949)'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: '[#1949](https://www.sqlalchemy.org/trac/ticket/1949)'
- en: Non-`Table`-derived constructs can be mapped
  id: totrans-516
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 非`Table`派生的构造可以被映射
- en: A construct that isn’t against any `Table` at all, like a function, can be mapped.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 一个根本不针对任何`Table`的构造，比如一个函数，可以被映射。
- en: '[PRE50]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[#1876](https://www.sqlalchemy.org/trac/ticket/1876)'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: '[#1876](https://www.sqlalchemy.org/trac/ticket/1876)'
- en: aliased() accepts `FromClause` elements
  id: totrans-520
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: aliased()接受`FromClause`元素
- en: This is a convenience helper such that in the case a plain `FromClause`, such
    as a `select`, `Table` or `join` is passed to the `orm.aliased()` construct, it
    passes through to the `.alias()` method of that from construct rather than constructing
    an ORM level `AliasedClass`.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个方便的辅助工具，以便在传递一个普通的`FromClause`，比如一个`select`，`Table`或`join`到`orm.aliased()`构造时，它会通过到该from构造的`.alias()`方法，而不是构造一个ORM级别的`AliasedClass`。
- en: '[#2018](https://www.sqlalchemy.org/trac/ticket/2018)'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2018](https://www.sqlalchemy.org/trac/ticket/2018)'
- en: Session.connection(), Session.execute() accept ‘bind’
  id: totrans-523
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Session.connection()，Session.execute()接受‘bind’
- en: This is to allow execute/connection operations to participate in the open transaction
    of an engine explicitly. It also allows custom subclasses of `Session` that implement
    their own `get_bind()` method and arguments to use those custom arguments with
    both the `execute()` and `connection()` methods equally.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 这是为了允许执行/连接操作明确参与引擎的打开事务。它还允许`Session`的自定义子类实现自己的`get_bind()`方法和参数，以便在`execute()`和`connection()`方法中等效地使用这些自定义参数。
- en: '[Session.connection](https://www.sqlalchemy.org/docs/07/orm/session.html#sqlalchemy.orm.session.Session.connection)
    [Session.execute](https://www.sqlalchemy.org/docs/07/orm/session.html#sqlalchemy.orm.session.Session.execute)'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: '[Session.connection](https://www.sqlalchemy.org/docs/07/orm/session.html#sqlalchemy.orm.session.Session.connection)
    [Session.execute](https://www.sqlalchemy.org/docs/07/orm/session.html#sqlalchemy.orm.session.Session.execute)'
- en: '[#1996](https://www.sqlalchemy.org/trac/ticket/1996)'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: '[#1996](https://www.sqlalchemy.org/trac/ticket/1996)'
- en: Standalone bind parameters in columns clause auto-labeled.
  id: totrans-527
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 列子句中的独立绑定参数自动标记。
- en: Bind parameters present in the “columns clause” of a select are now auto-labeled
    like other “anonymous” clauses, which among other things allows their “type” to
    be meaningful when the row is fetched, as in result row processors.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择的“列子句”中存在的绑定参数现在像其他“匿名”子句一样自动标记，这样在获取行时它们的“类型”就有意义，就像结果行处理器一样。
- en: SQLite - relative file paths are normalized through os.path.abspath()
  id: totrans-529
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SQLite - 相对文件路径通过os.path.abspath()进行标准化
- en: This so that a script that changes the current directory will continue to target
    the same location as subsequent SQLite connections are established.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，更改当前目录的脚本将继续以后续建立的SQLite连接的相同位置为目标。
- en: '[#2036](https://www.sqlalchemy.org/trac/ticket/2036)'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2036](https://www.sqlalchemy.org/trac/ticket/2036)'
- en: MS-SQL - `String`/`Unicode`/`VARCHAR`/`NVARCHAR`/`VARBINARY` emit “max” for
    no length
  id: totrans-532
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: MS-SQL - `String`/`Unicode`/`VARCHAR`/`NVARCHAR`/`VARBINARY`在未指定长度时发出“max”
- en: On the MS-SQL backend, the String/Unicode types, and their counterparts VARCHAR/
    NVARCHAR, as well as VARBINARY ([#1833](https://www.sqlalchemy.org/trac/ticket/1833))
    emit “max” as the length when no length is specified. This makes it more compatible
    with PostgreSQL’s VARCHAR type which is similarly unbounded when no length specified.
    SQL Server defaults the length on these types to ‘1’ when no length is specified.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 在MS-SQL后端，String/Unicode类型及其对应的VARCHAR/NVARCHAR类型，以及VARBINARY ([#1833](https://www.sqlalchemy.org/trac/ticket/1833))在未指定长度时发出“max”作为长度。这使其与PostgreSQL的VARCHAR类型更兼容，当未指定长度时同样是无界的。SQL
    Server在未指定长度时将这些类型的长度默认为‘1’。
- en: C Extensions Build by Default
  id: totrans-534
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 默认构建C扩展
- en: This is as of 0.7b4\. The exts will build if cPython 2.xx is detected. If the
    build fails, such as on a windows install, that condition is caught and the non-C
    install proceeds. The C exts won’t build if Python 3 or PyPy is used.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 这是从0.7b4开始的。如果检测到cPython 2.xx，则将构建扩展。如果构建失败，例如在Windows安装中，将捕获该条件并继续非C安装。如果使用Python
    3或PyPy，则不会构建C扩展。
- en: Query.count() simplified, should work virtually always
  id: totrans-536
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Query.count()简化，几乎总是有效
- en: 'The very old guesswork which occurred within `Query.count()` has been modernized
    to use `.from_self()`. That is, `query.count()` is now equivalent to:'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: '`Query.count()`内部的非常古老的猜测现已现代化为使用`.from_self()`。也就是说，`query.count()`现在等效于：'
- en: '[PRE51]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Previously, internal logic attempted to rewrite the columns clause of the query
    itself, and upon detection of a “subquery” condition, such as a column-based query
    that might have aggregates in it, or a query with DISTINCT, would go through a
    convoluted process of rewriting the columns clause. This logic failed in complex
    conditions, particularly those involving joined table inheritance, and was long
    obsolete by the more comprehensive `.from_self()` call.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，内部逻辑尝试重写查询本身的列子句，并在检测到“子查询”条件时，例如可能在其中具有聚合函数的基于列的查询，或具有DISTINCT的查询，将经历一个复杂的过程来重写列子句。这种逻辑在复杂条件下失败，特别是涉及联接表继承的条件，并且已经被更全面的`.from_self()`调用长时间废弃。
- en: 'The SQL emitted by `query.count()` is now always of the form:'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: '`query.count()`发出的SQL现在始终是以下形式：'
- en: '[PRE52]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: that is, the original query is preserved entirely inside of a subquery, with
    no more guessing as to how count should be applied.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 即原始查询完全保留在子查询中，不再猜测应如何应用计数。
- en: '[#2093](https://www.sqlalchemy.org/trac/ticket/2093)'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2093](https://www.sqlalchemy.org/trac/ticket/2093)'
- en: To emit a non-subquery form of count()
  id: totrans-544
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 发出非子查询形式的count()
- en: 'MySQL users have already reported that the MyISAM engine not surprisingly falls
    over completely with this simple change. Note that for a simple `count()` that
    optimizes for DBs that can’t handle simple subqueries, `func.count()` should be
    used:'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL用户已经报告说，MyISAM引擎不出所料地完全崩溃了这个简单的更改。请注意，对于优化无法处理简单子查询的数据库的简单`count()`，应使用`func.count()`：
- en: '[PRE53]'
  id: totrans-546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'or for `count(*)`:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 或对于`count(*)`：
- en: '[PRE54]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: To emit a non-subquery form of count()
  id: totrans-549
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 发出非子查询形式的count()
- en: 'MySQL users have already reported that the MyISAM engine not surprisingly falls
    over completely with this simple change. Note that for a simple `count()` that
    optimizes for DBs that can’t handle simple subqueries, `func.count()` should be
    used:'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL用户已经报告说，MyISAM引擎不出所料地完全崩溃了这个简单的更改。请注意，对于优化无法处理简单子查询的数据库的简单`count()`，应使用`func.count()`：
- en: '[PRE55]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'or for `count(*)`:'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 或对于`count(*)`：
- en: '[PRE56]'
  id: totrans-553
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: LIMIT/OFFSET clauses now use bind parameters
  id: totrans-554
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: LIMIT/OFFSET子句现在使用绑定参数
- en: The LIMIT and OFFSET clauses, or their backend equivalents (i.e. TOP, ROW NUMBER
    OVER, etc.), use bind parameters for the actual values, for all backends which
    support it (most except for Sybase). This allows better query optimizer performance
    as the textual string for multiple statements with differing LIMIT/OFFSET are
    now identical.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: LIMIT和OFFSET子句，或其后端等效项（即TOP，ROW NUMBER OVER等），对实际值使用绑定参数，对于支持它的所有后端（除了Sybase）。这允许更好的查询优化器性能，因为具有不同LIMIT/OFFSET的多个语句的文本字符串现在是相同的。
- en: '[#805](https://www.sqlalchemy.org/trac/ticket/805)'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: '[#805](https://www.sqlalchemy.org/trac/ticket/805)'
- en: Logging enhancements
  id: totrans-557
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 日志增强
- en: Vinay Sajip has provided a patch to our logging system such that the “hex string”
    embedded in logging statements for engines and pools is no longer needed to allow
    the `echo` flag to work correctly. A new system that uses filtered logging objects
    allows us to maintain our current behavior of `echo` being local to individual
    engines without the need for additional identifying strings local to those engines.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: Vinay Sajip提供了一个补丁，使我们的日志系统中不再需要“十六进制字符串”嵌入到引擎和池的日志语句中，以使`echo`标志能够正确工作。使用过滤日志对象的新系统使我们能够保持我们当前的`echo`行为，即`echo`局限于各个引擎，而无需额外的标识字符串局限于这些引擎。
- en: '[#1926](https://www.sqlalchemy.org/trac/ticket/1926)'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: '[#1926](https://www.sqlalchemy.org/trac/ticket/1926)'
- en: Simplified polymorphic_on assignment
  id: totrans-560
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 简化的多态_on赋值
- en: 'The population of the `polymorphic_on` column-mapped attribute, when used in
    an inheritance scenario, now occurs when the object is constructed, i.e. its `__init__`
    method is called, using the init event. The attribute then behaves the same as
    any other column-mapped attribute. Previously, special logic would fire off during
    flush to populate this column, which prevented any user code from modifying its
    behavior. The new approach improves upon this in three ways: 1\. the polymorphic
    identity is now present on the object as soon as its constructed; 2\. the polymorphic
    identity can be changed by user code without any difference in behavior from any
    other column-mapped attribute; 3\. the internals of the mapper during flush are
    simplified and no longer need to make special checks for this column.'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 当在继承场景中使用时，`polymorphic_on`列映射属性的人口现在在对象构造时发生，即调用其`__init__`方法，使用init事件。然后，该属性的行为与任何其他列映射属性相同。以前，特殊逻辑会在刷新时触发以填充此列，这会阻止任何用户代码修改其行为。新方法在三个方面改进了这一点：1.
    多态标识现在在对象构造时立即存在；2. 多态标识可以被用户代码更改，而不会与任何其他列映射属性的行为有任何区别；3. 刷新期间映射器的内部简化，不再需要对此列进行特殊检查。
- en: '[#1895](https://www.sqlalchemy.org/trac/ticket/1895)'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: '[#1895](https://www.sqlalchemy.org/trac/ticket/1895)'
- en: contains_eager() chains across multiple paths (i.e. “all()”)
  id: totrans-563
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 包含跨多个路径（即“all()”）的contains_eager()链
- en: 'The ``contains_eager()[PRE57]contains_eager()`` calls. Instead of:'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: '``contains_eager()[PRE57]contains_eager()``调用。而不是：'
- en: '[PRE58]'
  id: totrans-565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'you can say:'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以说：
- en: '[PRE59]'
  id: totrans-567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[#2032](https://www.sqlalchemy.org/trac/ticket/2032)'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2032](https://www.sqlalchemy.org/trac/ticket/2032)'
- en: Flushing of orphans that have no parent is allowed
  id: totrans-569
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 允许刷新没有父级的孤立对象
- en: We’ve had a long standing behavior that checks for a so- called “orphan” during
    flush, that is, an object which is associated with a `relationship()` that specifies
    “delete- orphan” cascade, has been newly added to the session for an INSERT, and
    no parent relationship has been established. This check was added years ago to
    accommodate some test cases which tested the orphan behavior for consistency.
    In modern SQLA, this check is no longer needed on the Python side. The equivalent
    behavior of the “orphan check” is accomplished by making the foreign key reference
    to the object’s parent row NOT NULL, where the database does its job of establishing
    data consistency in the same way SQLA allows most other operations to do. If the
    object’s parent foreign key is nullable, then the row can be inserted. The “orphan”
    behavior runs when the object was persisted with a particular parent, and is then
    disassociated with that parent, leading to a DELETE statement emitted for it.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 我们长期以来一直有一个行为，即在执行 flush 操作时检查所谓的“孤立对象”，即，与一个指定了“delete-orphan”级联的 `relationship()`
    相关联的对象已经被新增到了会话中以进行 INSERT 操作，但尚未建立父关系。多年前，为了满足一些测试用例对孤立对象行为的一致性进行测试，添加了此检查。在现代
    SQLA 中，不再需要在 Python 端进行此检查。通过将对象的外键引用设置为对象的父行的 NOT NULL，数据库会在确立数据一致性方面发挥作用，SQLA
    允许大多数其他操作以相同的方式完成。如果对象的父外键可为空，则可以插入行。当对象被持久化到特定父对象，并且然后与该父对象取消关联时，“孤立”行为会运行，导致为其发出
    DELETE 语句。
- en: '[#1912](https://www.sqlalchemy.org/trac/ticket/1912)'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: '[#1912](https://www.sqlalchemy.org/trac/ticket/1912)'
- en: Warnings generated when collection members, scalar referents not part of the
    flush
  id: totrans-572
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在刷新时生成的警告，集合成员，不是刷新的一部分的标量引用
- en: Warnings are now emitted when related objects referenced via a loaded `relationship()`
    on a parent object marked as “dirty” are not present in the current `Session`.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 当通过父对象上标记为“脏”的加载的 `relationship()` 引用的相关对象在当前 `Session` 中不存在时，会发出警告。
- en: The `save-update` cascade takes effect when objects are added to the `Session`,
    or when objects are first associated with a parent, so that an object and everything
    related to it are usually all present in the same `Session`. However, if `save-update`
    cascade is disabled for a particular `relationship()`, then this behavior does
    not occur, and the flush process does not try to correct for it, instead staying
    consistent to the configured cascade behavior. Previously, when such objects were
    detected during the flush, they were silently skipped. The new behavior is that
    a warning is emitted, for the purposes of alerting to a situation that more often
    than not is the source of unexpected behavior.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 当对象被添加到 `Session` 中，或者当对象首次与父对象关联时，`save-update` 级联会生效，以便对象及其相关内容通常都存在于同一个 `Session`
    中。但是，如果对特定的 `relationship()` 禁用了 `save-update` 级联，则此行为不会发生，并且刷新过程不会尝试进行纠正，而是保持一致性以配置的级联行为。以前，在刷新期间检测到此类对象时，它们会被静默跳过。新行为是发出警告，以便提醒通常是意外行为的根源。
- en: '[#1973](https://www.sqlalchemy.org/trac/ticket/1973)'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: '[#1973](https://www.sqlalchemy.org/trac/ticket/1973)'
- en: Setup no longer installs a Nose plugin
  id: totrans-576
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置不再安装 Nose 插件。
- en: Since we moved to nose we’ve used a plugin that installs via setuptools, so
    that the `nosetests` script would automatically run SQLA’s plugin code, necessary
    for our tests to have a full environment. In the middle of 0.6, we realized that
    the import pattern here meant that Nose’s “coverage” plugin would break, since
    “coverage” requires that it be started before any modules to be covered are imported;
    so in the middle of 0.6 we made the situation worse by adding a separate `sqlalchemy-nose`
    package to the build to overcome this.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 自从我们使用 nose 以来，我们已经使用通过 setuptools 安装的插件，以便 `nosetests` 脚本会自动运行 SQLA 的插件代码，这对于我们的测试来说是必要的，以获得完整的环境。在
    0.6 版本中间，我们意识到这里的导入模式意味着 Nose 的“覆盖率”插件会中断，因为“覆盖率”要求在导入要覆盖的任何模块之前启动；因此，在 0.6 版本中间，我们通过添加一个单独的
    `sqlalchemy-nose` 包到构建中来克服这个问题，使情况变得更糟。
- en: In 0.7 we’ve done away with trying to get `nosetests` to work automatically,
    since the SQLAlchemy module would produce a large number of nose configuration
    options for all usages of `nosetests`, not just the SQLAlchemy unit tests themselves,
    and the additional `sqlalchemy-nose` install was an even worse idea, producing
    an extra package in Python environments. The `sqla_nose.py` script in 0.7 is now
    the only way to run the tests with nose.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 在0.7中，我们放弃了尝试自动使`nosetests`工作，因为SQLAlchemy模块会为所有`nosetests`的用法产生大量的nose配置选项，而不仅仅是SQLAlchemy单元测试本身，而且额外的`sqlalchemy-nose`安装是一个更糟糕的想法，会在Python环境中产生一个额外的包。在0.7中，`sqla_nose.py`脚本现在是使用nose运行测试的唯一方法。
- en: '[#1949](https://www.sqlalchemy.org/trac/ticket/1949)'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: '[#1949](https://www.sqlalchemy.org/trac/ticket/1949)'
- en: Non-`Table`-derived constructs can be mapped
  id: totrans-580
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 非`Table`派生的构造可以被映射
- en: A construct that isn’t against any `Table` at all, like a function, can be mapped.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 一个根本不针对任何`Table`的构造，比如一个函数，可以被映射。
- en: '[PRE60]'
  id: totrans-582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[#1876](https://www.sqlalchemy.org/trac/ticket/1876)'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: '[#1876](https://www.sqlalchemy.org/trac/ticket/1876)'
- en: aliased() accepts `FromClause` elements
  id: totrans-584
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: aliased()接受`FromClause`元素
- en: This is a convenience helper such that in the case a plain `FromClause`, such
    as a `select`, `Table` or `join` is passed to the `orm.aliased()` construct, it
    passes through to the `.alias()` method of that from construct rather than constructing
    an ORM level `AliasedClass`.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个方便的辅助工具，以便在传递一个普通的`FromClause`，比如一个`select`，`Table`或`join`到`orm.aliased()`构造时，它会通过到该from构造的`.alias()`方法，而不是构造一个ORM级别的`AliasedClass`。
- en: '[#2018](https://www.sqlalchemy.org/trac/ticket/2018)'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2018](https://www.sqlalchemy.org/trac/ticket/2018)'
- en: Session.connection(), Session.execute() accept ‘bind’
  id: totrans-587
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Session.connection()，Session.execute()接受‘bind’
- en: This is to allow execute/connection operations to participate in the open transaction
    of an engine explicitly. It also allows custom subclasses of `Session` that implement
    their own `get_bind()` method and arguments to use those custom arguments with
    both the `execute()` and `connection()` methods equally.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 这是为了允许execute/connection操作明确参与引擎的打开事务。它还允许`Session`的自定义子类实现自己的`get_bind()`方法和参数，以便在`execute()`和`connection()`方法中同等使用这些自定义参数。
- en: '[Session.connection](https://www.sqlalchemy.org/docs/07/orm/session.html#sqlalchemy.orm.session.Session.connection)
    [Session.execute](https://www.sqlalchemy.org/docs/07/orm/session.html#sqlalchemy.orm.session.Session.execute)'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: '[Session.connection](https://www.sqlalchemy.org/docs/07/orm/session.html#sqlalchemy.orm.session.Session.connection)
    [Session.execute](https://www.sqlalchemy.org/docs/07/orm/session.html#sqlalchemy.orm.session.Session.execute)'
- en: '[#1996](https://www.sqlalchemy.org/trac/ticket/1996)'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: '[#1996](https://www.sqlalchemy.org/trac/ticket/1996)'
- en: Standalone bind parameters in columns clause auto-labeled.
  id: totrans-591
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 列子句中的独立绑定参数自动标记。
- en: Bind parameters present in the “columns clause” of a select are now auto-labeled
    like other “anonymous” clauses, which among other things allows their “type” to
    be meaningful when the row is fetched, as in result row processors.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 在select的“columns clause”中存在的绑定参数现在会像其他“匿名”子句一样自动标记，这样在获取行时它们的“类型”就会有意义，就像结果行处理器一样。
- en: SQLite - relative file paths are normalized through os.path.abspath()
  id: totrans-593
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SQLite - 相对文件路径通过os.path.abspath()进行标准化
- en: This so that a script that changes the current directory will continue to target
    the same location as subsequent SQLite connections are established.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，一个改变当前目录的脚本将继续以后续建立的SQLite连接的相同位置为目标。
- en: '[#2036](https://www.sqlalchemy.org/trac/ticket/2036)'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2036](https://www.sqlalchemy.org/trac/ticket/2036)'
- en: MS-SQL - `String`/`Unicode`/`VARCHAR`/`NVARCHAR`/`VARBINARY` emit “max” for
    no length
  id: totrans-596
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: MS-SQL - `String`/`Unicode`/`VARCHAR`/`NVARCHAR`/`VARBINARY`在没有长度时发出“max”
- en: On the MS-SQL backend, the String/Unicode types, and their counterparts VARCHAR/
    NVARCHAR, as well as VARBINARY ([#1833](https://www.sqlalchemy.org/trac/ticket/1833))
    emit “max” as the length when no length is specified. This makes it more compatible
    with PostgreSQL’s VARCHAR type which is similarly unbounded when no length specified.
    SQL Server defaults the length on these types to ‘1’ when no length is specified.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 在MS-SQL后端，String/Unicode类型及其对应的VARCHAR/ NVARCHAR类型，以及VARBINARY ([#1833](https://www.sqlalchemy.org/trac/ticket/1833))在没有指定长度时发出“max”作为长度。这使其更兼容于PostgreSQL的VARCHAR类型，当没有指定长度时也是无限制的。SQL
    Server在没有指定长度时将这些类型的长度默认为‘1’。
- en: Behavioral Changes (Backwards Incompatible)
  id: totrans-598
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 行为变更（不兼容）
- en: Note again, aside from the default mutability change, most of these changes
    are *extremely minor* and will not affect most users.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 再次注意，除了默认的可变性更改外，大多数这些更改都是*非常微小*的，不会影响大多数用户。
- en: '`PickleType` and ARRAY mutability turned off by default'
  id: totrans-600
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`PickleType`和ARRAY的可变性默认关闭'
- en: 'This change refers to the default behavior of the ORM when mapping columns
    that have either the `PickleType` or `postgresql.ARRAY` datatypes. The `mutable`
    flag is now set to `False` by default. If an existing application uses these types
    and depends upon detection of in-place mutations, the type object must be constructed
    with `mutable=True` to restore the 0.6 behavior:'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 这个改变涉及ORM映射具有`PickleType`或`postgresql.ARRAY`数据类型的列时的默认行为。`mutable`标志现在默认设置为`False`。如果现有应用程序使用这些类型并依赖于检测就地变异，那么类型对象必须使用`mutable=True`构造以恢复0.6版本的行为：
- en: '[PRE61]'
  id: totrans-602
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The `mutable=True` flag is being phased out, in favor of the new [Mutation Tracking](https://www.sqlalchemy.org/docs/07/orm/extensions/mutable.html)
    extension. This extension provides a mechanism by which user-defined datatypes
    can provide change events back to the owning parent or parents.
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: '`mutable=True`标志正在逐步淘汰，而新的[Mutation Tracking](https://www.sqlalchemy.org/docs/07/orm/extensions/mutable.html)扩展则更受青睐。该扩展提供了一种机制，使用户定义的数据类型能够向拥有父对象发送更改事件。'
- en: The previous approach of using `mutable=True` does not provide for change events
    - instead, the ORM must scan through all mutable values present in a session and
    compare them against their original value for changes every time `flush()` is
    called, which is a very time consuming event. This is a holdover from the very
    early days of SQLAlchemy when `flush()` was not automatic and the history tracking
    system was not nearly as sophisticated as it is now.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 先前使用`mutable=True`的方法不提供更改事件 - 相反，ORM必须在每次调用`flush()`时扫描会话中存在的所有可变值，并将它们与原始值进行比较以检测更改，这是一个非常耗时的事件。这是SQLAlchemy非常早期的遗留问题，当时`flush()`不是自动的，历史跟踪系统也不像现在这样复杂。
- en: Existing applications which use `PickleType`, `postgresql.ARRAY` or other `MutableType`
    subclasses, and require in-place mutation detection, should migrate to the new
    mutation tracking system, as `mutable=True` is likely to be deprecated in the
    future.
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 现有应用程序使用`PickleType`、`postgresql.ARRAY`或其他`MutableType`子类，并且需要就地变异检测的应用程序，应该迁移到新的变异跟踪系统，因为`mutable=True`可能会在未来被弃用。
- en: '[#1980](https://www.sqlalchemy.org/trac/ticket/1980)'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: '[#1980](https://www.sqlalchemy.org/trac/ticket/1980)'
- en: Mutability detection of `composite()` requires the Mutation Tracking Extension
  id: totrans-607
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`composite()`的可变性检测需要使用Mutation Tracking Extension。'
- en: So-called “composite” mapped attributes, those configured using the technique
    described at [Composite Column Types](https://www.sqlalchemy.org/docs/07/orm/mapper_config.html#composite-column-types),
    have been re-implemented such that the ORM internals are no longer aware of them
    (leading to shorter and more efficient codepaths in critical sections). While
    composite types are generally intended to be treated as immutable value objects,
    this was never enforced. For applications that use composites with mutability,
    the [Mutation Tracking](https://www.sqlalchemy.org/docs/07/orm/extensions/mutable.html)
    extension offers a base class which establishes a mechanism for user-defined composite
    types to send change event messages back to the owning parent or parents of each
    object.
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 所谓的“复合”映射属性，即使用[Composite Column Types](https://www.sqlalchemy.org/docs/07/orm/mapper_config.html#composite-column-types)描述的技术配置的属性，已经重新实现，ORM内部不再意识到它们（导致关键部分的代码路径更短更高效）。虽然复合类型通常被视为不可变的值对象，但从未强制执行。对于使用具有可变性的复合对象的应用程序，[Mutation
    Tracking](https://www.sqlalchemy.org/docs/07/orm/extensions/mutable.html)扩展提供了一个基类，该基类建立了一个机制，使用户定义的复合类型能够向每个对象的拥有父对象发送更改事件消息。
- en: Applications which use composite types and rely upon in- place mutation detection
    of these objects should either migrate to the “mutation tracking” extension, or
    change the usage of the composite types such that in-place changes are no longer
    needed (i.e., treat them as immutable value objects).
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 使用复合类型并依赖于这些对象的就地变异检测的应用程序应该迁移到“变异跟踪”扩展，或者更改复合类型的使用方式，使得不再需要就地更改（即将其视为不可变的值对象）。
- en: SQLite - the SQLite dialect now uses `NullPool` for file-based databases
  id: totrans-610
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SQLite - SQLite方言现在对基于文件的数据库使用`NullPool`。
- en: This change is **99.999% backwards compatible**, unless you are using temporary
    tables across connection pool connections.
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 这个改变是**99.999%向后兼容**的，除非你在连接池连接之间使用临时表。
- en: A file-based SQLite connection is blazingly fast, and using `NullPool` means
    that each call to `Engine.connect` creates a new pysqlite connection.
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 基于文件的SQLite连接速度非常快，使用`NullPool`意味着每次调用`Engine.connect`都会创建一个新的pysqlite连接。
- en: Previously, the `SingletonThreadPool` was used, which meant that all connections
    to a certain engine in a thread would be the same connection. It’s intended that
    the new approach is more intuitive, particularly when multiple connections are
    used.
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 以前使用的是`SingletonThreadPool`，这意味着线程中对某个引擎的所有连接都是相同的连接。新方法更直观，特别是在使用多个连接时。
- en: '`SingletonThreadPool` is still the default engine when a `:memory:` database
    is used.'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`:memory:`数据库时，`SingletonThreadPool`仍然是默认引擎。
- en: Note that this change **breaks temporary tables used across Session commits**,
    due to the way SQLite handles temp tables. See the note at [https://www.sqlalchemy.org/docs/dialects/sqlite.html#using](https://www.sqlalchemy.org/docs/dialects/sqlite.html#using)-
    temporary-tables-with-sqlite if temporary tables beyond the scope of one pool
    connection are desired.
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个改变**破坏了跨Session提交使用的临时表**，这是由于SQLite处理临时表的方式造成的。如果需要超出一个连接池范围的临时表，请参阅[https://www.sqlalchemy.org/docs/dialects/sqlite.html#using](https://www.sqlalchemy.org/docs/dialects/sqlite.html#using)-
    temporary-tables-with-sqlite中的说明。
- en: '[#1921](https://www.sqlalchemy.org/trac/ticket/1921)'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: '[#1921](https://www.sqlalchemy.org/trac/ticket/1921)'
- en: '`Session.merge()` checks version ids for versioned mappers'
  id: totrans-617
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`Session.merge()`检查版本化映射器的版本id'
- en: Session.merge() will check the version id of the incoming state against that
    of the database, assuming the mapping uses version ids and incoming state has
    a version_id assigned, and raise StaleDataError if they don’t match. This is the
    correct behavior, in that if incoming state contains a stale version id, it should
    be assumed the state is stale.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: Session.merge()将检查传入状态的版本id与数据库的版本id是否匹配，假设映射使用版本id并且传入状态已分配版本id，并且如果它们不匹配，则引发StaleDataError。这是正确的行为，因为如果传入状态包含过时的版本id，则应假定状态是过时的。
- en: If merging data into a versioned state, the version id attribute can be left
    undefined, and no version check will take place.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将数据合并到版本化状态中，则可以将版本id属性未定义，并且不会进行版本检查。
- en: This check was confirmed by examining what Hibernate does - both the `merge()`
    and the versioning features were originally adapted from Hibernate.
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 通过检查Hibernate的操作来确认了这个检查 - `merge()`和版本化功能最初都是从Hibernate中适应过来的。
- en: '[#2027](https://www.sqlalchemy.org/trac/ticket/2027)'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2027](https://www.sqlalchemy.org/trac/ticket/2027)'
- en: Tuple label names in Query Improved
  id: totrans-622
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查询中的元组标签名称改进
- en: This improvement is potentially slightly backwards incompatible for an application
    that relied upon the old behavior.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 这个改进对于依赖于旧行为的应用程序可能会有一点向后不兼容。
- en: 'Given two mapped classes `Foo` and `Bar` each with a column `spam`:'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 给定两个映射类`Foo`和`Bar`，每个类都有一个列`spam`：
- en: '[PRE62]'
  id: totrans-625
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The name given to the single column yielded by `qu` will be `spam`. Previously
    it would be something like `foo_spam` due to the way the `union` would combine
    things, which is inconsistent with the name `spam` in the case of a non-unioned
    query.
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 由`qu`产生的单个列的名称将是`spam`。以前会是类似`foo_spam`的东西，这是由于`union`组合事物的方式，这与非联合查询的情况下的名称`spam`不一致。
- en: '[#1942](https://www.sqlalchemy.org/trac/ticket/1942)'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: '[#1942](https://www.sqlalchemy.org/trac/ticket/1942)'
- en: Mapped column attributes reference the most specific column first
  id: totrans-628
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 映射列属性首先引用最具体的列
- en: This is a change to the behavior involved when a mapped column attribute references
    multiple columns, specifically when dealing with an attribute on a joined-table
    subclass that has the same name as that of an attribute on the superclass.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在映射列属性引用多个列时涉及的行为更改，特别是在处理具有与超类属性相同名称的连接表子类上的属性时。
- en: 'Using declarative, the scenario is this:'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 使用声明性，情景是这样的：
- en: '[PRE63]'
  id: totrans-631
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Above, the attribute `Child.id` refers to both the `child.id` column as well
    as `parent.id` - this due to the name of the attribute. If it were named differently
    on the class, such as `Child.child_id`, it then maps distinctly to `child.id`,
    with `Child.id` being the same attribute as `Parent.id`.
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 上面，属性`Child.id`同时指代`child.id`列和`parent.id` - 这是由于属性的名称。如果在类上命名不同，比如`Child.child_id`，那么它将明确映射到`child.id`，而`Child.id`将与`Parent.id`相同。
- en: When the `id` attribute is made to reference both `parent.id` and `child.id`,
    it stores them in an ordered list. An expression such as `Child.id` then refers
    to just *one* of those columns when rendered. Up until 0.6, this column would
    be `parent.id`. In 0.7, it is the less surprising `child.id`.
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 当`id`属性被设置为引用`parent.id`和`child.id`时，它们被存储在一个有序列表中。这样，诸如`Child.id`的表达式在呈现时只引用*其中一个*列。直到0.6版本，这一列将是`parent.id`。在0.7版本中，它是更少令人惊讶的`child.id`。
- en: The legacy of this behavior deals with behaviors and restrictions of the ORM
    that don’t really apply anymore; all that was needed was to reverse the order.
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为的遗留与ORM的行为和限制有关，这些限制实际上已经不再适用；所需要的只是颠倒顺序。
- en: 'A primary advantage of this approach is that it’s now easier to construct `primaryjoin`
    expressions that refer to the local column:'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的一个主要优势是现在更容易构造引用本地列的`primaryjoin`表达式：
- en: '[PRE64]'
  id: totrans-636
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Prior to 0.7 the `Child.id` expression would reference `Parent.id`, and it would
    be necessary to map `child.id` to a distinct attribute.
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 在0.7之前，`Child.id`表达式将引用`Parent.id`，并且需要将`child.id`映射到一个不同的属性。
- en: 'It also means that a query like this one changes its behavior:'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 这也意味着这样一个查询的行为发生了变化：
- en: '[PRE65]'
  id: totrans-639
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'In 0.6, this would render:'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 在0.6中，这将产生：
- en: '[PRE66]'
  id: totrans-641
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'in 0.7, you get:'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 在0.7版中，你会得到：
- en: '[PRE67]'
  id: totrans-643
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'which you’ll note is a cartesian product - this behavior is now equivalent
    to that of any other attribute that is local to `Child`. The `with_polymorphic()`
    method, or a similar strategy of explicitly joining the underlying `Table` objects,
    is used to render a query against all `Parent` objects with criteria against `Child`,
    in the same manner as that of 0.5 and 0.6:'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到这是一个笛卡尔积 - 这种行为现在等同于任何其他本地于`Child`的属性。`with_polymorphic()`方法，或者类似的显式连接底层`Table`对象的策略，用于以与0.5和0.6相同的方式渲染针对所有`Parent`对象的查询，并针对`Child`进行条件限制：
- en: '[PRE68]'
  id: totrans-645
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Which on both 0.6 and 0.7 renders:'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 在0.6和0.7上都会产生：
- en: '[PRE69]'
  id: totrans-647
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Another effect of this change is that a joined-inheritance load across two tables
    will populate from the child table’s value, not that of the parent table. An unusual
    case is that a query against “Parent” using `with_polymorphic="*"` issues a query
    against “parent”, with a LEFT OUTER JOIN to “child”. The row is located in “Parent”,
    sees the polymorphic identity corresponds to “Child”, but suppose the actual row
    in “child” has been *deleted*. Due to this corruption, the row comes in with all
    the columns corresponding to “child” set to NULL - this is now the value that
    gets populated, not the one in the parent table.
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 这种变化的另一个影响是，跨两个表的连接继承加载将从子表的值填充，而不是父表的值。一个不寻常的情况是，使用`with_polymorphic="*"`对“Parent”进行查询，会发出一个针对“parent”的查询，带有一个左外连接到“child”。行位于“Parent”，看到多态标识对应于“Child”，但假设“child”中的实际行已经*被删除*。由于这种损坏，行将带有所有对应于“child”的列设置为NULL的列
    - 这现在是被填充的值，而不是父表中的值。
- en: '[#1892](https://www.sqlalchemy.org/trac/ticket/1892)'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: '[#1892](https://www.sqlalchemy.org/trac/ticket/1892)'
- en: Mapping to joins with two or more same-named columns requires explicit declaration
  id: totrans-650
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 映射到具有两个或更多同名列的连接需要明确声明。
- en: This is somewhat related to the previous change in [#1892](https://www.sqlalchemy.org/trac/ticket/1892).
    When mapping to a join, same-named columns must be explicitly linked to mapped
    attributes, i.e. as described in [Mapping a Class Against Multiple Tables](http://www.sqlalchemy.org/docs/07/orm/mapper_config.html#mapping-a-class-against-multiple-tables).
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 这与先前在[#1892](https://www.sqlalchemy.org/trac/ticket/1892)中的更改有些相关。在映射到连接时，同名列必须明确链接到映射的属性，即如[在多个表上映射一个类](http://www.sqlalchemy.org/docs/07/orm/mapper_config.html#mapping-a-class-against-multiple-tables)中所述。
- en: 'Given two tables `foo` and `bar`, each with a primary key column `id`, the
    following now produces an error:'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 给定两个表`foo`和`bar`，每个表都有一个主键列`id`，现在以下内容会产生错误：
- en: '[PRE70]'
  id: totrans-653
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'This because the `mapper()` refuses to guess what column is the primary representation
    of `FooBar.id` - is it `foo.c.id` or is it `bar.c.id` ? The attribute must be
    explicit:'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为`mapper()`拒绝猜测哪一列是`FooBar.id`的主要表示 - 是`foo.c.id`还是`bar.c.id`？属性必须是明确的：
- en: '[PRE71]'
  id: totrans-655
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[#1896](https://www.sqlalchemy.org/trac/ticket/1896)'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: '[#1896](https://www.sqlalchemy.org/trac/ticket/1896)'
- en: Mapper requires that polymorphic_on column be present in the mapped selectable
  id: totrans-657
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Mapper要求在映射的可选择项中存在多态列`polymorphic_on`。
- en: 'This is a warning in 0.6, now an error in 0.7\. The column given for `polymorphic_on`
    must be in the mapped selectable. This to prevent some occasional user errors
    such as:'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 这是0.6版的警告，现在在0.7版中已经成为错误。给定`polymorphic_on`的列必须在映射的可选择项中。这是为了防止一些偶发的用户错误，例如：
- en: '[PRE72]'
  id: totrans-659
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: where above the polymorphic_on needs to be on a `sometable` column, in this
    case perhaps `sometable.c.some_lookup_id`. There are also some “polymorphic union”
    scenarios where similar mistakes sometimes occur.
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`polymorphic_on`需要在`sometable`列上，例如在这种情况下可能是`sometable.c.some_lookup_id`。还有一些“多态联合”场景，类似的错误有时会发生。
- en: Such a configuration error has always been “wrong”, and the above mapping doesn’t
    work as specified - the column would be ignored. It is however potentially backwards
    incompatible in the rare case that an application has been unknowingly relying
    upon this behavior.
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的配置错误一直是“错误的”，上述映射不像规定的那样工作 - 该列将被忽略。然而，如果某个应用程序不知情地依赖于此行为，则这可能是潜在的向后不兼容的情况。
- en: '[#1875](https://www.sqlalchemy.org/trac/ticket/1875)'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: '[#1875](https://www.sqlalchemy.org/trac/ticket/1875)'
- en: '`DDL()` constructs now escape percent signs'
  id: totrans-663
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`DDL()`构造现在转义百分号'
- en: Previously, percent signs in `DDL()` strings would have to be escaped, i.e.
    `%%` depending on DBAPI, for those DBAPIs that accept `pyformat` or `format` binds
    (i.e. psycopg2, mysql-python), which was inconsistent versus `text()` constructs
    which did this automatically. The same escaping now occurs for `DDL()` as for
    `text()`.
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，在`DDL()`字符串中的百分号必须转义，即 `%%` 取决于 DBAPI，对于那些接受`pyformat`或`format`绑定（即 psycopg2，mysql-python），这与`text()`构造函数自动执行的操作不一致。现在对于`DDL()`与`text()`，进行了相同的转义。
- en: '[#1897](https://www.sqlalchemy.org/trac/ticket/1897)'
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: '[#1897](https://www.sqlalchemy.org/trac/ticket/1897)'
- en: '`Table.c` / `MetaData.tables` refined a bit, don’t allow direct mutation'
  id: totrans-666
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`Table.c` / `MetaData.tables` 稍微改进，不允许直接突变'
- en: Another area where some users were tinkering around in such a way that doesn’t
    actually work as expected, but still left an exceedingly small chance that some
    application was relying upon this behavior, the construct returned by the `.c`
    attribute on `Table` and the `.tables` attribute on `MetaData` is explicitly non-mutable.
    The “mutable” version of the construct is now private. Adding columns to `.c`
    involves using the `append_column()` method of `Table`, which ensures things are
    associated with the parent `Table` in the appropriate way; similarly, `MetaData.tables`
    has a contract with the `Table` objects stored in this dictionary, as well as
    a little bit of new bookkeeping in that a `set()` of all schema names is tracked,
    which is satisfied only by using the public `Table` constructor as well as `Table.tometadata()`.
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个区域是，一些用户以一种实际上不按预期工作的方式进行尝试，但仍然留下了极小的可能性，即某些应用程序正在依赖于此行为，`Table`的`.c`属性返回的构造和`MetaData`的`.tables`属性是明确不可变的。构造的“可变”版本现在是私有的。向`.c`添加列涉及使用`Table`的`append_column()`方法，该方法确保事物以适当的方式与父`Table`关联;
    同样，`MetaData.tables`与此字典中存储的`Table`对象有一个协议，以及一些新的簿记，即跟踪所有模式名称的`set()`，仅使用公共`Table`构造函数以及`Table.tometadata()`才能满足。
- en: It is of course possible that the `ColumnCollection` and `dict` collections
    consulted by these attributes could someday implement events on all of their mutational
    methods such that the appropriate bookkeeping occurred upon direct mutation of
    the collections, but until someone has the motivation to implement all that along
    with dozens of new unit tests, narrowing the paths to mutation of these collections
    will ensure no application is attempting to rely upon usages that are currently
    not supported.
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，`ColumnCollection`和`dict`这些属性所查询的集合可能会在所有突变方法上实现事件，以便在直接突变集合时发生适当的簿记，但是在有人有动力实现所有这些以及数十个新单元测试之前，缩小这些集合突变路径将确保没有应用程序试图依赖于当前不受支持的用法。
- en: '[#1893](https://www.sqlalchemy.org/trac/ticket/1893) [#1917](https://www.sqlalchemy.org/trac/ticket/1917)'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: '[#1893](https://www.sqlalchemy.org/trac/ticket/1893) [#1917](https://www.sqlalchemy.org/trac/ticket/1917)'
- en: server_default consistently returns None for all inserted_primary_key values
  id: totrans-670
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: server_default 对所有 inserted_primary_key 值一致地返回 None
- en: Established consistency when server_default is present on an Integer PK column.
    SQLA doesn’t pre-fetch these, nor do they come back in cursor.lastrowid (DBAPI).
    Ensured all backends consistently return None in result.inserted_primary_key for
    these - some backends may have returned a value previously. Using a server_default
    on a primary key column is extremely unusual. If a special function or SQL expression
    is used to generate primary key defaults, this should be established as a Python-side
    “default” instead of server_default.
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Integer PK 列上存在 server_default 时确保一致性。SQLA不预先获取这些，它们也不会在 cursor.lastrowid（DBAPI）中返回。确保所有后端一致地对这些值在
    result.inserted_primary_key 中返回 None - 一些后端以前可能返回了一个值。在主键列上使用 server_default 是极不常见的。如果使用特殊函数或
    SQL 表达式生成主键默认值，则应将其建立为 Python 端的“默认”而不是 server_default。
- en: Regarding reflection for this case, reflection of an int PK col with a server_default
    sets the “autoincrement” flag to False, except in the case of a PG SERIAL col
    where we detected a sequence default.
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这种情况的反射，使用具有server_default的int PK列的反射将“autoincrement”标志设置为False，除非在检测到序列默认值的PG
    SERIAL列的情况下。
- en: '[#2020](https://www.sqlalchemy.org/trac/ticket/2020) [#2021](https://www.sqlalchemy.org/trac/ticket/2021)'
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2020](https://www.sqlalchemy.org/trac/ticket/2020) [#2021](https://www.sqlalchemy.org/trac/ticket/2021)'
- en: The `sqlalchemy.exceptions` alias in sys.modules is removed
  id: totrans-674
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`sqlalchemy.exceptions`在sys.modules中的别名已被移除'
- en: 'For a few years we’ve added the string `sqlalchemy.exceptions` to `sys.modules`,
    so that a statement like “`import sqlalchemy.exceptions`” would work. The name
    of the core exceptions module has been `exc` for a long time now, so the recommended
    import for this module is:'
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 几年来，我们已经将字符串`sqlalchemy.exceptions`添加到`sys.modules`中，以便像“`import sqlalchemy.exceptions`”这样的语句可以工作。核心异常模块的名称现在已经是`exc`很长时间了，因此该模块的推荐导入方式是：
- en: '[PRE73]'
  id: totrans-676
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: The `exceptions` name is still present in “`sqlalchemy`” for applications which
    might have said `from sqlalchemy import exceptions`, but they should also start
    using the `exc` name.
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 对于可能已经说过`from sqlalchemy import exceptions`的应用程序，“`sqlalchemy`”中仍然存在`exceptions`名称，但他们也应该开始使用`exc`名称。
- en: Query Timing Recipe Changes
  id: totrans-678
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查询时间配方更改
- en: While not part of SQLAlchemy itself, it’s worth mentioning that the rework of
    the `ConnectionProxy` into the new event system means it is no longer appropriate
    for the “Timing all Queries” recipe. Please adjust query-timers to use the `before_cursor_execute()`
    and `after_cursor_execute()` events, demonstrated in the updated recipe UsageRecipes/Profiling.
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然不是SQLAlchemy本身的一部分，但值得一提的是，将`ConnectionProxy`重构为新的事件系统意味着不再适用于“Timing all
    Queries”配方。请调整查询计时器以使用`before_cursor_execute()`和`after_cursor_execute()`事件，在更新的配方UsageRecipes/Profiling中有示例。
- en: '`PickleType` and ARRAY mutability turned off by default'
  id: totrans-680
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`PickleType`和ARRAY的可变性默认关闭'
- en: 'This change refers to the default behavior of the ORM when mapping columns
    that have either the `PickleType` or `postgresql.ARRAY` datatypes. The `mutable`
    flag is now set to `False` by default. If an existing application uses these types
    and depends upon detection of in-place mutations, the type object must be constructed
    with `mutable=True` to restore the 0.6 behavior:'
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 此更改涉及ORM在映射具有`PickleType`或`postgresql.ARRAY`数据类型的列时的默认行为。`mutable`标志现在默认设置为`False`。如果现有应用程序使用这些类型并依赖于原地变异的检测，则必须使用`mutable=True`构造类型对象以恢复0.6行为：
- en: '[PRE74]'
  id: totrans-682
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: The `mutable=True` flag is being phased out, in favor of the new [Mutation Tracking](https://www.sqlalchemy.org/docs/07/orm/extensions/mutable.html)
    extension. This extension provides a mechanism by which user-defined datatypes
    can provide change events back to the owning parent or parents.
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: '`mutable=True`标志正在逐步淘汰，取而代之的是新的[Mutation Tracking](https://www.sqlalchemy.org/docs/07/orm/extensions/mutable.html)扩展。该扩展提供了一种机制，使用户定义的数据类型可以向拥有的父级或父级提供更改事件。'
- en: The previous approach of using `mutable=True` does not provide for change events
    - instead, the ORM must scan through all mutable values present in a session and
    compare them against their original value for changes every time `flush()` is
    called, which is a very time consuming event. This is a holdover from the very
    early days of SQLAlchemy when `flush()` was not automatic and the history tracking
    system was not nearly as sophisticated as it is now.
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 先前使用`mutable=True`的方法不提供更改事件 - 相反，ORM必须在每次调用`flush()`时扫描会话中存在的所有可变值，并将它们与原始值进行比较以检测更改，这是一个非常耗时的事件。这是SQLAlchemy非常早期的遗留问题，当时`flush()`不是自动的，历史跟踪系统也没有现在这么复杂。
- en: Existing applications which use `PickleType`, `postgresql.ARRAY` or other `MutableType`
    subclasses, and require in-place mutation detection, should migrate to the new
    mutation tracking system, as `mutable=True` is likely to be deprecated in the
    future.
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`PickleType`、`postgresql.ARRAY`或其他`MutableType`子类，并且需要原地变异检测的现有应用程序，应该迁移到新的变异跟踪系统，因为`mutable=True`可能会在未来被弃用。
- en: '[#1980](https://www.sqlalchemy.org/trac/ticket/1980)'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: '[#1980](https://www.sqlalchemy.org/trac/ticket/1980)'
- en: Mutability detection of `composite()` requires the Mutation Tracking Extension
  id: totrans-687
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`composite()`的可变性检测需要Mutation Tracking扩展'
- en: So-called “composite” mapped attributes, those configured using the technique
    described at [Composite Column Types](https://www.sqlalchemy.org/docs/07/orm/mapper_config.html#composite-column-types),
    have been re-implemented such that the ORM internals are no longer aware of them
    (leading to shorter and more efficient codepaths in critical sections). While
    composite types are generally intended to be treated as immutable value objects,
    this was never enforced. For applications that use composites with mutability,
    the [Mutation Tracking](https://www.sqlalchemy.org/docs/07/orm/extensions/mutable.html)
    extension offers a base class which establishes a mechanism for user-defined composite
    types to send change event messages back to the owning parent or parents of each
    object.
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 所谓“复合”映射属性，即使用[复合列类型](https://www.sqlalchemy.org/docs/07/orm/mapper_config.html#composite-column-types)描述的技术配置的属性，已经重新实现，使得ORM内部不再意识到它们（导致关键部分的代码路径更短更高效）。虽然复合类型通常被视为不可变的值对象，但从未强制执行。对于使用具有可变性的复合类型的应用程序，[变异跟踪](https://www.sqlalchemy.org/docs/07/orm/extensions/mutable.html)扩展提供了一个基类，建立了一个机制，使用户定义的复合类型能够向每个对象的拥有父对象发送更改事件消息。
- en: Applications which use composite types and rely upon in- place mutation detection
    of these objects should either migrate to the “mutation tracking” extension, or
    change the usage of the composite types such that in-place changes are no longer
    needed (i.e., treat them as immutable value objects).
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 使用复合类型并依赖于这些对象的原地变异检测的应用程序应该迁移到“变异跟踪”扩展，或者更改复合类型的使用方式，使得不再需要原地更改（即将其视为不可变的值对象）。
- en: SQLite - the SQLite dialect now uses `NullPool` for file-based databases
  id: totrans-690
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SQLite - SQLite方言现在对于基于文件的数据库使用`NullPool`
- en: This change is **99.999% backwards compatible**, unless you are using temporary
    tables across connection pool connections.
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 这个改变**99.999%向后兼容**，除非您正在跨连接池连接使用临时表。
- en: A file-based SQLite connection is blazingly fast, and using `NullPool` means
    that each call to `Engine.connect` creates a new pysqlite connection.
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 基于文件的SQLite连接非常快速，并且使用`NullPool`意味着每次调用`Engine.connect`都会创建一个新的pysqlite连接。
- en: Previously, the `SingletonThreadPool` was used, which meant that all connections
    to a certain engine in a thread would be the same connection. It’s intended that
    the new approach is more intuitive, particularly when multiple connections are
    used.
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: 以前使用的是`SingletonThreadPool`，这意味着线程中对某个引擎的所有连接都是相同的连接。新方法的目的是更直观，特别是在使用多个连接时。
- en: '`SingletonThreadPool` is still the default engine when a `:memory:` database
    is used.'
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`:memory:`数据库时，`SingletonThreadPool`仍然是默认引擎。
- en: Note that this change **breaks temporary tables used across Session commits**,
    due to the way SQLite handles temp tables. See the note at [https://www.sqlalchemy.org/docs/dialects/sqlite.html#using](https://www.sqlalchemy.org/docs/dialects/sqlite.html#using)-
    temporary-tables-with-sqlite if temporary tables beyond the scope of one pool
    connection are desired.
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个改变**破坏了跨Session提交使用的临时表**，这是由于SQLite处理临时表的方式。如果需要超出一个连接池连接范围的临时表，请参阅[https://www.sqlalchemy.org/docs/dialects/sqlite.html#using](https://www.sqlalchemy.org/docs/dialects/sqlite.html#using)-
    temporary-tables-with-sqlite中的说明。
- en: '[#1921](https://www.sqlalchemy.org/trac/ticket/1921)'
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: '[#1921](https://www.sqlalchemy.org/trac/ticket/1921)'
- en: '`Session.merge()` checks version ids for versioned mappers'
  id: totrans-697
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`Session.merge()`检查带版本的映射器的版本ID'
- en: Session.merge() will check the version id of the incoming state against that
    of the database, assuming the mapping uses version ids and incoming state has
    a version_id assigned, and raise StaleDataError if they don’t match. This is the
    correct behavior, in that if incoming state contains a stale version id, it should
    be assumed the state is stale.
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: '`Session.merge()`将检查传入状态的版本ID与数据库的版本ID是否匹配，假设映射使用版本ID并且传入状态已分配版本ID，并且如果它们不匹配，则引发StaleDataError。这是正确的行为，即如果传入状态包含过时的版本ID，则应假定状态是过时的。'
- en: If merging data into a versioned state, the version id attribute can be left
    undefined, and no version check will take place.
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将数据合并到带版本的状态中，则可以将版本ID属性留空，不会进行版本检查。
- en: This check was confirmed by examining what Hibernate does - both the `merge()`
    and the versioning features were originally adapted from Hibernate.
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 通过检查Hibernate的操作确认了这一变化 - `merge()`和版本控制功能最初都是从Hibernate中适应过来的。
- en: '[#2027](https://www.sqlalchemy.org/trac/ticket/2027)'
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2027](https://www.sqlalchemy.org/trac/ticket/2027)'
- en: Tuple label names in Query Improved
  id: totrans-702
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查询改进中的元组标签名称
- en: This improvement is potentially slightly backwards incompatible for an application
    that relied upon the old behavior.
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 这种改进对于依赖旧行为的应用程序可能会有一点点向后不兼容。
- en: 'Given two mapped classes `Foo` and `Bar` each with a column `spam`:'
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 给定两个映射类`Foo`和`Bar`，每个类都有一个名为`spam`的列：
- en: '[PRE75]'
  id: totrans-705
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: The name given to the single column yielded by `qu` will be `spam`. Previously
    it would be something like `foo_spam` due to the way the `union` would combine
    things, which is inconsistent with the name `spam` in the case of a non-unioned
    query.
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 由`qu`生成的单列的名称将是`spam`。以前会是类似于`foo_spam`的东西，这是由于`union`的组合方式导致的，这与非联合查询中的名称`spam`不一致。
- en: '[#1942](https://www.sqlalchemy.org/trac/ticket/1942)'
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: '[#1942](https://www.sqlalchemy.org/trac/ticket/1942)'
- en: Mapped column attributes reference the most specific column first
  id: totrans-708
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 映射列属性首先引用最具体的列
- en: This is a change to the behavior involved when a mapped column attribute references
    multiple columns, specifically when dealing with an attribute on a joined-table
    subclass that has the same name as that of an attribute on the superclass.
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在映射列属性引用多个列时涉及的行为变化，特别是在处理具有与超类属性相同名称的连接表子类上的属性时。
- en: 'Using declarative, the scenario is this:'
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 使用声明性，情景如下：
- en: '[PRE76]'
  id: totrans-711
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: Above, the attribute `Child.id` refers to both the `child.id` column as well
    as `parent.id` - this due to the name of the attribute. If it were named differently
    on the class, such as `Child.child_id`, it then maps distinctly to `child.id`,
    with `Child.id` being the same attribute as `Parent.id`.
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 上面，属性`Child.id`同时指代`child.id`列和`parent.id` - 这是由于属性的名称。如果在类上命名不同，比如`Child.child_id`，那么它将明确映射到`child.id`，而`Child.id`将成为与`Parent.id`相同的属性。
- en: When the `id` attribute is made to reference both `parent.id` and `child.id`,
    it stores them in an ordered list. An expression such as `Child.id` then refers
    to just *one* of those columns when rendered. Up until 0.6, this column would
    be `parent.id`. In 0.7, it is the less surprising `child.id`.
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 当`id`属性被设置为引用`parent.id`和`child.id`时，它们被存储在一个有序列表中。这样，诸如`Child.id`的表达式在呈现时只会引用其中的*一个*列。直到0.6版本，这一列将是`parent.id`。在0.7版本中，它是更少令人惊讶的`child.id`。
- en: The legacy of this behavior deals with behaviors and restrictions of the ORM
    that don’t really apply anymore; all that was needed was to reverse the order.
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为的遗留涉及到ORM的行为和限制，这些限制实际上已经不再适用；只需要改变顺序即可。
- en: 'A primary advantage of this approach is that it’s now easier to construct `primaryjoin`
    expressions that refer to the local column:'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的一个主要优势是现在更容易构建引用本地列的`primaryjoin`表达式：
- en: '[PRE77]'
  id: totrans-716
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Prior to 0.7 the `Child.id` expression would reference `Parent.id`, and it would
    be necessary to map `child.id` to a distinct attribute.
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 在0.7之前，`Child.id`表达式将引用`Parent.id`，并且需要将`child.id`映射到一个不同的属性。
- en: 'It also means that a query like this one changes its behavior:'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 这也意味着这样一个查询的行为发生了变化：
- en: '[PRE78]'
  id: totrans-719
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'In 0.6, this would render:'
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 在0.6版本中，会呈现如下：
- en: '[PRE79]'
  id: totrans-721
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'in 0.7, you get:'
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 在0.7中，你会得到：
- en: '[PRE80]'
  id: totrans-723
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'which you’ll note is a cartesian product - this behavior is now equivalent
    to that of any other attribute that is local to `Child`. The `with_polymorphic()`
    method, or a similar strategy of explicitly joining the underlying `Table` objects,
    is used to render a query against all `Parent` objects with criteria against `Child`,
    in the same manner as that of 0.5 and 0.6:'
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到这是一个笛卡尔积 - 这种行为现在等同于任何本地于`Child`的其他属性。`with_polymorphic()`方法，或者类似的显式连接基础`Table`对象的策略，用于对所有具有针对`Child`的条件的`Parent`对象进行查询，方式与0.5和0.6相同：
- en: '[PRE81]'
  id: totrans-725
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Which on both 0.6 and 0.7 renders:'
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 在0.6和0.7版本中都会呈现：
- en: '[PRE82]'
  id: totrans-727
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Another effect of this change is that a joined-inheritance load across two tables
    will populate from the child table’s value, not that of the parent table. An unusual
    case is that a query against “Parent” using `with_polymorphic="*"` issues a query
    against “parent”, with a LEFT OUTER JOIN to “child”. The row is located in “Parent”,
    sees the polymorphic identity corresponds to “Child”, but suppose the actual row
    in “child” has been *deleted*. Due to this corruption, the row comes in with all
    the columns corresponding to “child” set to NULL - this is now the value that
    gets populated, not the one in the parent table.
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: 这种变化的另一个影响是，跨两个表的连接继承加载将从子表的值填充，而不是父表的值。一个不寻常的情况是，使用`with_polymorphic="*"`对“Parent”进行查询会发出一个针对“parent”的查询，并与“child”进行左外连接。行位于“Parent”，看到多态标识对应于“Child”，但假设“child”中的实际行已经*删除*。由于这种损坏，行中所有与“child”对应的列都设置为NULL
    - 这现在是被填充的值，而不是父表中的值。
- en: '[#1892](https://www.sqlalchemy.org/trac/ticket/1892)'
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: '[#1892](https://www.sqlalchemy.org/trac/ticket/1892)'
- en: Mapping to joins with two or more same-named columns requires explicit declaration
  id: totrans-730
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 映射到具有两个或更多同名列的连接需要明确声明
- en: This is somewhat related to the previous change in [#1892](https://www.sqlalchemy.org/trac/ticket/1892).
    When mapping to a join, same-named columns must be explicitly linked to mapped
    attributes, i.e. as described in [Mapping a Class Against Multiple Tables](http://www.sqlalchemy.org/docs/07/orm/mapper_config.html#mapping-a-class-against-multiple-tables).
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: 这与[#1892](https://www.sqlalchemy.org/trac/ticket/1892)中的先前更改有些相关。在映射到连接时，同名列必须明确链接到映射属性，即如[映射一个类到多个表](http://www.sqlalchemy.org/docs/07/orm/mapper_config.html#mapping-a-class-against-multiple-tables)中所述。
- en: 'Given two tables `foo` and `bar`, each with a primary key column `id`, the
    following now produces an error:'
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 给定两个表`foo`和`bar`，每个表都有一个主键列`id`，现在执行以下操作会产生错误：
- en: '[PRE83]'
  id: totrans-733
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'This because the `mapper()` refuses to guess what column is the primary representation
    of `FooBar.id` - is it `foo.c.id` or is it `bar.c.id` ? The attribute must be
    explicit:'
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为`mapper()`拒绝猜测哪一列是`FooBar.id`的主要表示 - 是`foo.c.id`还是`bar.c.id`？属性必须明确：
- en: '[PRE84]'
  id: totrans-735
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[#1896](https://www.sqlalchemy.org/trac/ticket/1896)'
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: '[#1896](https://www.sqlalchemy.org/trac/ticket/1896)'
- en: Mapper requires that polymorphic_on column be present in the mapped selectable
  id: totrans-737
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 映射器要求在映射的可选择项中存在多态列
- en: 'This is a warning in 0.6, now an error in 0.7\. The column given for `polymorphic_on`
    must be in the mapped selectable. This to prevent some occasional user errors
    such as:'
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: 这在0.6中是一个警告，现在在0.7中是一个错误。为`polymorphic_on`指定的列必须在映射的可选择项中。这是为了防止一些偶尔发生的用户错误，例如：
- en: '[PRE85]'
  id: totrans-739
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: where above the polymorphic_on needs to be on a `sometable` column, in this
    case perhaps `sometable.c.some_lookup_id`. There are also some “polymorphic union”
    scenarios where similar mistakes sometimes occur.
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，`polymorphic_on`需要在`sometable`列上，此时可能是`sometable.c.some_lookup_id`。有时也会发生一些类似的“多态联合”场景中的错误。
- en: Such a configuration error has always been “wrong”, and the above mapping doesn’t
    work as specified - the column would be ignored. It is however potentially backwards
    incompatible in the rare case that an application has been unknowingly relying
    upon this behavior.
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 这种配置错误一直是“错误的”，上述映射不按规定工作 - 列将被忽略。然而，在极少数情况下，如果应用程序无意中依赖于这种行为，则可能会产生潜在的向后不兼容性。
- en: '[#1875](https://www.sqlalchemy.org/trac/ticket/1875)'
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: '[#1875](https://www.sqlalchemy.org/trac/ticket/1875)'
- en: '`DDL()` constructs now escape percent signs'
  id: totrans-743
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`DDL()`构造现在转义百分号'
- en: Previously, percent signs in `DDL()` strings would have to be escaped, i.e.
    `%%` depending on DBAPI, for those DBAPIs that accept `pyformat` or `format` binds
    (i.e. psycopg2, mysql-python), which was inconsistent versus `text()` constructs
    which did this automatically. The same escaping now occurs for `DDL()` as for
    `text()`.
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，在`DDL()`字符串中的百分号必须进行转义，即根据DBAPI，对于那些接受`pyformat`或`format`绑定（例如psycopg2，mysql-python）的DBAPI，这是不一致的，与`text()`构造自动执行的操作不同。现在，`DDL()`与`text()`一样进行相同的转义。
- en: '[#1897](https://www.sqlalchemy.org/trac/ticket/1897)'
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: '[#1897](https://www.sqlalchemy.org/trac/ticket/1897)'
- en: '`Table.c` / `MetaData.tables` refined a bit, don’t allow direct mutation'
  id: totrans-746
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`Table.c` / `MetaData.tables`稍作调整，不允许直接变异'
- en: Another area where some users were tinkering around in such a way that doesn’t
    actually work as expected, but still left an exceedingly small chance that some
    application was relying upon this behavior, the construct returned by the `.c`
    attribute on `Table` and the `.tables` attribute on `MetaData` is explicitly non-mutable.
    The “mutable” version of the construct is now private. Adding columns to `.c`
    involves using the `append_column()` method of `Table`, which ensures things are
    associated with the parent `Table` in the appropriate way; similarly, `MetaData.tables`
    has a contract with the `Table` objects stored in this dictionary, as well as
    a little bit of new bookkeeping in that a `set()` of all schema names is tracked,
    which is satisfied only by using the public `Table` constructor as well as `Table.tometadata()`.
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个领域，一些用户在进行尝试时，并不按预期工作，但仍然存在极小的可能性，即某些应用程序依赖于这种行为，`Table`的`.c`属性和`MetaData`的`.tables`属性返回的构造明确是不可变的。构造的“可变”版本现在是私有的。向`.c`添加列涉及使用`Table`的`append_column()`方法，这确保了事物以适当的方式与父`Table`关联；同样，`MetaData.tables`与存储在此字典中的`Table`对象有合同，还有一点新的簿记，即跟踪所有模式名称的`set()`，只有使用公共`Table`构造函数以及`Table.tometadata()`才能满足。
- en: It is of course possible that the `ColumnCollection` and `dict` collections
    consulted by these attributes could someday implement events on all of their mutational
    methods such that the appropriate bookkeeping occurred upon direct mutation of
    the collections, but until someone has the motivation to implement all that along
    with dozens of new unit tests, narrowing the paths to mutation of these collections
    will ensure no application is attempting to rely upon usages that are currently
    not supported.
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，`ColumnCollection` 和 `dict` 集合在这些属性上进行咨询的情况下，可能会有一天实现所有变异方法的事件，从而在直接变异集合时发生适当的簿记，但在有人有动力实现所有这些以及数十个新单元测试之前，缩小这些集合的变异路径将确保没有应用程序试图依赖当前不受支持的用法。
- en: '[#1893](https://www.sqlalchemy.org/trac/ticket/1893) [#1917](https://www.sqlalchemy.org/trac/ticket/1917)'
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: '[#1893](https://www.sqlalchemy.org/trac/ticket/1893) [#1917](https://www.sqlalchemy.org/trac/ticket/1917)'
- en: server_default consistently returns None for all inserted_primary_key values
  id: totrans-750
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: server_default 对所有 inserted_primary_key 值一致地返回 None。
- en: Established consistency when server_default is present on an Integer PK column.
    SQLA doesn’t pre-fetch these, nor do they come back in cursor.lastrowid (DBAPI).
    Ensured all backends consistently return None in result.inserted_primary_key for
    these - some backends may have returned a value previously. Using a server_default
    on a primary key column is extremely unusual. If a special function or SQL expression
    is used to generate primary key defaults, this should be established as a Python-side
    “default” instead of server_default.
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 当在 Integer PK 列上存在 server_default 时，已确立一致性。 SQLA 不会预取这些值，它们也不会在 cursor.lastrowid（DBAPI）中返回。
    确保所有后端一致地在 result.inserted_primary_key 中为这些值返回 None-一些后端以前可能返回了一个值。 在主键列上使用 server_default
    是极不寻常的。 如果使用特殊函数或 SQL 表达式生成主键默认值，则应将其建立为 Python 端的“默认”而不是 server_default。
- en: Regarding reflection for this case, reflection of an int PK col with a server_default
    sets the “autoincrement” flag to False, except in the case of a PG SERIAL col
    where we detected a sequence default.
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 关于此情况的反射，具有服务器默认值的 int PK 列的反射将 “autoincrement” 标志设置为 False，但在检测到 PG SERIAL
    列的序列默认值的情况下除外。
- en: '[#2020](https://www.sqlalchemy.org/trac/ticket/2020) [#2021](https://www.sqlalchemy.org/trac/ticket/2021)'
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2020](https://www.sqlalchemy.org/trac/ticket/2020) [#2021](https://www.sqlalchemy.org/trac/ticket/2021)'
- en: The `sqlalchemy.exceptions` alias in sys.modules is removed
  id: totrans-754
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`sqlalchemy.exceptions` 在 sys.modules 中的别名已被移除。'
- en: 'For a few years we’ve added the string `sqlalchemy.exceptions` to `sys.modules`,
    so that a statement like “`import sqlalchemy.exceptions`” would work. The name
    of the core exceptions module has been `exc` for a long time now, so the recommended
    import for this module is:'
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 几年来，我们已经将字符串 `sqlalchemy.exceptions` 添加到 `sys.modules` 中，以便像 “`import sqlalchemy.exceptions`”
    这样的语句可以工作。 核心异常模块的名称已经很久以来是 `exc`，因此建议导入此模块的方式是：
- en: '[PRE86]'
  id: totrans-756
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: The `exceptions` name is still present in “`sqlalchemy`” for applications which
    might have said `from sqlalchemy import exceptions`, but they should also start
    using the `exc` name.
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: '`exceptions` 名称仍然存在于“`sqlalchemy`”中，供可能已经使用 `from sqlalchemy import exceptions`
    的应用程序使用，但他们也应该开始使用 `exc` 名称。'
- en: Query Timing Recipe Changes
  id: totrans-758
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查询时间配方更改
- en: While not part of SQLAlchemy itself, it’s worth mentioning that the rework of
    the `ConnectionProxy` into the new event system means it is no longer appropriate
    for the “Timing all Queries” recipe. Please adjust query-timers to use the `before_cursor_execute()`
    and `after_cursor_execute()` events, demonstrated in the updated recipe UsageRecipes/Profiling.
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然不是 SQLAlchemy 本身的一部分，但值得一提的是，将 `ConnectionProxy` 重构为新的事件系统意味着它不再适用于“Timing
    all Queries”配方。 请调整查询计时器以使用 `before_cursor_execute()` 和 `after_cursor_execute()`
    事件，在更新的配方 UsageRecipes/Profiling 中有示例。
- en: Deprecated API
  id: totrans-760
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 已弃用的 API
- en: Default constructor on types will not accept arguments
  id: totrans-761
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类型的默认构造函数不会接受参数。
- en: Simple types like `Integer`, `Date` etc. in the core types module don’t accept
    arguments. The default constructor that accepts/ignores a catchall `\*args, \**kwargs`
    is restored as of 0.7b4/0.7.0, but emits a deprecation warning.
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 核心类型模块中的诸如 `Integer`、`Date` 等简单类型不接受参数。 从 0.7b4/0.7.0 开始，接受/忽略 catchall `\*args,
    \**kwargs` 的默认构造函数已经恢复，但会发出弃用警告。
- en: If arguments are being used with a core type like `Integer`, it may be that
    you intended to use a dialect specific type, such as `sqlalchemy.dialects.mysql.INTEGER`
    which does accept a “display_width” argument for example.
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: 如果正在使用诸如 `Integer` 等核心类型的参数，可能是您打算使用特定于方言的类型，例如 `sqlalchemy.dialects.mysql.INTEGER`，该类型接受“display_width”参数，例如。
- en: compile_mappers() renamed configure_mappers(), simplified configuration internals
  id: totrans-764
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`compile_mappers()`重命名为`configure_mappers()`，简化配置内部。'
- en: This system slowly morphed from something small, implemented local to an individual
    mapper, and poorly named into something that’s more of a global “registry-” level
    function and poorly named, so we’ve fixed both by moving the implementation out
    of `Mapper` altogether and renaming it to `configure_mappers()`. It is of course
    normally not needed for an application to call `configure_mappers()` as this process
    occurs on an as-needed basis, as soon as the mappings are needed via attribute
    or query access.
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: 这个系统从一个小型、局部实现在单个映射器上，并且命名不当的东西慢慢演变成了更像是全局“注册表”级别函数且命名不当的东西，所以我们通过将实现移出`Mapper`并将其重命名为`configure_mappers()`来修复了这两个问题。当然，一般情况下应用程序通常不需要调用`configure_mappers()`，因为这个过程是根据需要的，一旦通过属性或查询访问需要映射时就会发生。
- en: '[#1966](https://www.sqlalchemy.org/trac/ticket/1966)'
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: '[#1966](https://www.sqlalchemy.org/trac/ticket/1966)'
- en: Core listener/proxy superseded by event listeners
  id: totrans-767
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 核心监听器/代理被事件监听器取代。
- en: '`PoolListener`, `ConnectionProxy`, `DDLElement.execute_at` are superseded by
    `event.listen()`, using the `PoolEvents`, `EngineEvents`, `DDLEvents` dispatch
    targets, respectively.'
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: '`PoolListener`、`ConnectionProxy`、`DDLElement.execute_at`被`event.listen()`取代，分别使用`PoolEvents`、`EngineEvents`、`DDLEvents`作为分派目标。'
- en: ORM extensions superseded by event listeners
  id: totrans-769
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ORM 扩展被事件监听器取代。
- en: '`MapperExtension`, `AttributeExtension`, `SessionExtension` are superseded
    by `event.listen()`, using the `MapperEvents`/`InstanceEvents`, `AttributeEvents`,
    `SessionEvents`, dispatch targets, respectively.'
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: '`MapperExtension`、`AttributeExtension`、`SessionExtension`被`event.listen()`取代，分别使用`MapperEvents`/`InstanceEvents`、`AttributeEvents`、`SessionEvents`作为分派目标。'
- en: Sending a string to ‘distinct’ in select() for MySQL should be done via prefixes
  id: totrans-771
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在 MySQL 中，将字符串发送给 `select()` 的 `distinct` 应通过前缀进行。
- en: 'This obscure feature allows this pattern with the MySQL backend:'
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 这个晦涩的功能允许使用 MySQL 后端的这种模式：
- en: '[PRE87]'
  id: totrans-773
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'The `prefixes` keyword or `prefix_with()` method should be used for non-standard
    or unusual prefixes:'
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: 对于非标准或不寻常的前缀，应使用`prefixes`关键字或`prefix_with()`方法：
- en: '[PRE88]'
  id: totrans-775
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '`useexisting` superseded by `extend_existing` and `keep_existing`'
  id: totrans-776
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`useexisting`被`extend_existing`和`keep_existing`取代。'
- en: The `useexisting` flag on Table has been superseded by a new pair of flags `keep_existing`
    and `extend_existing`. `extend_existing` is equivalent to `useexisting` - the
    existing Table is returned, and additional constructor elements are added. With
    `keep_existing`, the existing Table is returned, but additional constructor elements
    are not added - these elements are only applied when the Table is newly created.
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 对表的`useexisting`标志已被新的一对标志`keep_existing`和`extend_existing`取代。`extend_existing`等同于`useexisting`
    - 返回现有表，并添加额外的构造元素。使用`keep_existing`，返回现有表，但不添加额外的构造元素 - 这些元素仅在表新建时应用。
- en: Default constructor on types will not accept arguments
  id: totrans-778
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类的默认构造函数不接受参数。
- en: Simple types like `Integer`, `Date` etc. in the core types module don’t accept
    arguments. The default constructor that accepts/ignores a catchall `\*args, \**kwargs`
    is restored as of 0.7b4/0.7.0, but emits a deprecation warning.
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: 核心类型模块中的简单类型，如`Integer`、`Date`等，不接受参数。接受/忽略通用参数 `\*args, \**kwargs` 的默认构造函数在
    0.7b4/0.7.0 版本中已恢复，但会发出弃用警告。
- en: If arguments are being used with a core type like `Integer`, it may be that
    you intended to use a dialect specific type, such as `sqlalchemy.dialects.mysql.INTEGER`
    which does accept a “display_width” argument for example.
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在核心类型如`Integer`中使用参数，可能是您打算使用特定于方言的类型，例如`sqlalchemy.dialects.mysql.INTEGER`，例如它接受“display_width”参数。
- en: compile_mappers() renamed configure_mappers(), simplified configuration internals
  id: totrans-781
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`compile_mappers()`重命名为`configure_mappers()`，简化配置内部。'
- en: This system slowly morphed from something small, implemented local to an individual
    mapper, and poorly named into something that’s more of a global “registry-” level
    function and poorly named, so we’ve fixed both by moving the implementation out
    of `Mapper` altogether and renaming it to `configure_mappers()`. It is of course
    normally not needed for an application to call `configure_mappers()` as this process
    occurs on an as-needed basis, as soon as the mappings are needed via attribute
    or query access.
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: 这个系统从一个小型、局部实现在单个映射器上，并且命名不当的东西慢慢演变成了更像是全局“注册表”级别函数且命名不当的东西，所以我们通过将实现移出`Mapper`并将其重命名为`configure_mappers()`来修复了这两个问题。当然，一般情况下应用程序通常不需要调用`configure_mappers()`，因为这个过程是根据需要的，一旦通过属性或查询访问需要映射时就会发生。
- en: '[#1966](https://www.sqlalchemy.org/trac/ticket/1966)'
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: '[#1966](https://www.sqlalchemy.org/trac/ticket/1966)'
- en: Core listener/proxy superseded by event listeners
  id: totrans-784
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 核心监听器/代理被事件监听器取代
- en: '`PoolListener`, `ConnectionProxy`, `DDLElement.execute_at` are superseded by
    `event.listen()`, using the `PoolEvents`, `EngineEvents`, `DDLEvents` dispatch
    targets, respectively.'
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: '`PoolListener`、`ConnectionProxy`、`DDLElement.execute_at` 被 `event.listen()`
    取代，分别使用 `PoolEvents`、`EngineEvents`、`DDLEvents` 分发目标。'
- en: ORM extensions superseded by event listeners
  id: totrans-786
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ORM 扩展被事件监听器取代
- en: '`MapperExtension`, `AttributeExtension`, `SessionExtension` are superseded
    by `event.listen()`, using the `MapperEvents`/`InstanceEvents`, `AttributeEvents`,
    `SessionEvents`, dispatch targets, respectively.'
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: '`MapperExtension`、`AttributeExtension`、`SessionExtension` 被 `event.listen()`
    取代，分别使用 `MapperEvents`/`InstanceEvents`、`AttributeEvents`、`SessionEvents`、分发目标。'
- en: Sending a string to ‘distinct’ in select() for MySQL should be done via prefixes
  id: totrans-788
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为了在 MySQL 中向 `select()` 中的 ‘distinct’ 发送字符串，应该通过前缀来完成
- en: 'This obscure feature allows this pattern with the MySQL backend:'
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: 这个隐晦的特性允许在 MySQL 后端中使用这种模式：
- en: '[PRE89]'
  id: totrans-790
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'The `prefixes` keyword or `prefix_with()` method should be used for non-standard
    or unusual prefixes:'
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: 应该使用 `prefixes` 关键字或 `prefix_with()` 方法来处理非标准或不寻常的前缀：
- en: '[PRE90]'
  id: totrans-792
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '`useexisting` superseded by `extend_existing` and `keep_existing`'
  id: totrans-793
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`useexisting` 被 `extend_existing` 和 `keep_existing` 取代'
- en: The `useexisting` flag on Table has been superseded by a new pair of flags `keep_existing`
    and `extend_existing`. `extend_existing` is equivalent to `useexisting` - the
    existing Table is returned, and additional constructor elements are added. With
    `keep_existing`, the existing Table is returned, but additional constructor elements
    are not added - these elements are only applied when the Table is newly created.
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: Table 上的 `useexisting` 标志已被一对新标志 `keep_existing` 和 `extend_existing` 取代。`extend_existing`
    等同于 `useexisting` - 返回现有的 Table，并添加额外的构造元素。使用 `keep_existing`，返回现有的 Table，但不添加额外的构造元素
    - 这些元素仅在创建新 Table 时应用。
- en: Backwards Incompatible API Changes
  id: totrans-795
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向后不兼容的 API 更改
- en: Callables passed to `bindparam()` don’t get evaluated - affects the Beaker example
  id: totrans-796
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 传递给 `bindparam()` 的可调用对象不会被评估 - 影响 Beaker 示例
- en: '[#1950](https://www.sqlalchemy.org/trac/ticket/1950)'
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: '[#1950](https://www.sqlalchemy.org/trac/ticket/1950)'
- en: Note this affects the Beaker caching example, where the workings of the `_params_from_query()`
    function needed a slight adjustment. If you’re using code from the Beaker example,
    this change should be applied.
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这会影响 Beaker 缓存示例，其中 `_params_from_query()` 函数的工作方式需要进行轻微调整。如果您正在使用 Beaker
    示例中的代码，则应用此更改。
- en: types.type_map is now private, types._type_map
  id: totrans-799
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: types.type_map 现在是私有的，types._type_map
- en: We noticed some users tapping into this dictionary inside of `sqlalchemy.types`
    as a shortcut to associating Python types with SQL types. We can’t guarantee the
    contents or format of this dictionary, and additionally the business of associating
    Python types in a one-to-one fashion has some grey areas that should are best
    decided by individual applications, so we’ve underscored this attribute.
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: 我们注意到一些用户在 `sqlalchemy.types` 中利用这个字典作为将 Python 类型与 SQL 类型关联的快捷方式。我们无法保证这个字典的内容或格式，此外，将
    Python 类型一对一关联的业务有一些灰色地带，最好由各个应用程序自行决定，因此我们强调了这个属性。
- en: '[#1870](https://www.sqlalchemy.org/trac/ticket/1870)'
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: '[#1870](https://www.sqlalchemy.org/trac/ticket/1870)'
- en: Renamed the `alias` keyword arg of standalone `alias()` function to `name`
  id: totrans-802
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将独立 `alias()` 函数的 `alias` 关键字参数重命名为 `name`
- en: This so that the keyword argument `name` matches that of the `alias()` methods
    on all `FromClause` objects as well as the `name` argument on `Query.subquery()`.
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: 这样关键字参数 `name` 就与所有 `FromClause` 对象上的 `alias()` 方法以及 `Query.subquery()` 上的 `name`
    参数匹配了。
- en: Only code that uses the standalone `alias()` function, and not the method bound
    functions, and passes the alias name using the explicit keyword name `alias`,
    and not positionally, would need modification here.
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: 只有使用独立的 `alias()` 函数的代码，而不是绑定方法函数，并且使用显式关键字名称 `alias` 而不是位置上的别名名称传递的代码需要在这里进行修改。
- en: Non-public `Pool` methods underscored
  id: totrans-805
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 非公共 `Pool` 方法已被下划线标记
- en: All methods of `Pool` and subclasses which are not intended for public use have
    been renamed with underscores. That they were not named this way previously was
    a bug.
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: 所有不打算公开使用的 `Pool` 及其子类方法都已重命名为下划线。之前没有以这种方式命名是一个错误。
- en: 'Pooling methods now underscored or removed:'
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已经弃用或删除了池化方法：
- en: '`Pool.create_connection()` -> `Pool._create_connection()`'
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: '`Pool.create_connection()` -> `Pool._create_connection()`'
- en: '`Pool.do_get()` -> `Pool._do_get()`'
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: '`Pool.do_get()` -> `Pool._do_get()`'
- en: '`Pool.do_return_conn()` -> `Pool._do_return_conn()`'
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: '`Pool.do_return_conn()` -> `Pool._do_return_conn()`'
- en: '`Pool.do_return_invalid()` -> removed, was not used'
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: '`Pool.do_return_invalid()` -> 已移除，未被使用'
- en: '`Pool.return_conn()` -> `Pool._return_conn()`'
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: '`Pool.return_conn()` -> `Pool._return_conn()`'
- en: '`Pool.get()` -> `Pool._get()`, public API is `Pool.connect()`'
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: '`Pool.get()` -> `Pool._get()`, 公共 API 是 `Pool.connect()`'
- en: '`SingletonThreadPool.cleanup()` -> `_cleanup()`'
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: '`SingletonThreadPool.cleanup()` -> `_cleanup()`'
- en: '`SingletonThreadPool.dispose_local()` -> removed, use `conn.invalidate()`'
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: '`SingletonThreadPool.dispose_local()` -> 已移除，使用 `conn.invalidate()`'
- en: '[#1982](https://www.sqlalchemy.org/trac/ticket/1982)'
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: '[#1982](https://www.sqlalchemy.org/trac/ticket/1982)'
- en: Callables passed to `bindparam()` don’t get evaluated - affects the Beaker example
  id: totrans-817
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 传递给 `bindparam()` 的可调用对象不会被评估 - 影响 Beaker 示例
- en: '[#1950](https://www.sqlalchemy.org/trac/ticket/1950)'
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: '[#1950](https://www.sqlalchemy.org/trac/ticket/1950)'
- en: Note this affects the Beaker caching example, where the workings of the `_params_from_query()`
    function needed a slight adjustment. If you’re using code from the Beaker example,
    this change should be applied.
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这会影响 Beaker 缓存示例，其中 `_params_from_query()` 函数的工作需要进行轻微调整。如果你正在使用 Beaker
    示例中的代码，应用这一变更。
- en: types.type_map is now private, types._type_map
  id: totrans-820
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: types.type_map 现在是私有的，types._type_map
- en: We noticed some users tapping into this dictionary inside of `sqlalchemy.types`
    as a shortcut to associating Python types with SQL types. We can’t guarantee the
    contents or format of this dictionary, and additionally the business of associating
    Python types in a one-to-one fashion has some grey areas that should are best
    decided by individual applications, so we’ve underscored this attribute.
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: 我们注意到一些用户在 `sqlalchemy.types` 中利用这个字典作为将 Python 类型与 SQL 类型关联的快捷方式。我们无法保证这个字典的内容或格式，此外，将
    Python 类型与 SQL 类型一对一关联的业务有一些灰色地带，最好由各个应用程序自行决定，因此我们已经将这个属性标记为下划线。
- en: '[#1870](https://www.sqlalchemy.org/trac/ticket/1870)'
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: '[#1870](https://www.sqlalchemy.org/trac/ticket/1870)'
- en: Renamed the `alias` keyword arg of standalone `alias()` function to `name`
  id: totrans-823
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将独立 `alias()` 函数的 `alias` 关键字参数重命名为 `name`
- en: This so that the keyword argument `name` matches that of the `alias()` methods
    on all `FromClause` objects as well as the `name` argument on `Query.subquery()`.
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做是为了使关键字参数 `name` 与所有 `FromClause` 对象上的 `alias()` 方法以及 `Query.subquery()`
    上的 `name` 参数匹配。
- en: Only code that uses the standalone `alias()` function, and not the method bound
    functions, and passes the alias name using the explicit keyword name `alias`,
    and not positionally, would need modification here.
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: 只有使用独立 `alias()` 函数的代码，而不是绑定方法函数，并且使用显式关键字名称 `alias` 而不是位置参数传递别名的代码需要在这里进行修改。
- en: Non-public `Pool` methods underscored
  id: totrans-826
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 非公共 `Pool` 方法已被标记下划线
- en: All methods of `Pool` and subclasses which are not intended for public use have
    been renamed with underscores. That they were not named this way previously was
    a bug.
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 `Pool` 及其子类的不打算公开使用的方法都已重命名为下划线。它们之前没有以这种方式命名是一个 bug。
- en: 'Pooling methods now underscored or removed:'
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: 池化方法现在已经强调或移除：
- en: '`Pool.create_connection()` -> `Pool._create_connection()`'
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: '`Pool.create_connection()` -> `Pool._create_connection()`'
- en: '`Pool.do_get()` -> `Pool._do_get()`'
  id: totrans-830
  prefs: []
  type: TYPE_NORMAL
  zh: '`Pool.do_get()` -> `Pool._do_get()`'
- en: '`Pool.do_return_conn()` -> `Pool._do_return_conn()`'
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: '`Pool.do_return_conn()` -> `Pool._do_return_conn()`'
- en: '`Pool.do_return_invalid()` -> removed, was not used'
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: '`Pool.do_return_invalid()` -> 已移除，未被使用'
- en: '`Pool.return_conn()` -> `Pool._return_conn()`'
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: '`Pool.return_conn()` -> `Pool._return_conn()`'
- en: '`Pool.get()` -> `Pool._get()`, public API is `Pool.connect()`'
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: '`Pool.get()` -> `Pool._get()`, 公共 API 是 `Pool.connect()`'
- en: '`SingletonThreadPool.cleanup()` -> `_cleanup()`'
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: '`SingletonThreadPool.cleanup()` -> `_cleanup()`'
- en: '`SingletonThreadPool.dispose_local()` -> removed, use `conn.invalidate()`'
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: '`SingletonThreadPool.dispose_local()` -> 已移除，使用 `conn.invalidate()`'
- en: '[#1982](https://www.sqlalchemy.org/trac/ticket/1982)'
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: '[#1982](https://www.sqlalchemy.org/trac/ticket/1982)'
- en: Previously Deprecated, Now Removed
  id: totrans-838
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 之前已弃用，现在已移除
- en: Query.join(), Query.outerjoin(), eagerload(), eagerload_all(), others no longer
    allow lists of attributes as arguments
  id: totrans-839
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Query.join()、Query.outerjoin()、eagerload()、eagerload_all() 等不再允许作为参数传递属性列表。
- en: 'Passing a list of attributes or attribute names to `Query.join`, `eagerload()`,
    and similar has been deprecated since 0.5:'
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: 自 0.5 版本以来，将属性或属性名称列表传递给 `Query.join`、`eagerload()` 和类似方法已被弃用：
- en: '[PRE91]'
  id: totrans-841
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'These methods all accept *args as of the 0.5 series:'
  id: totrans-842
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法自 0.5 系列以来都接受 *args：
- en: '[PRE92]'
  id: totrans-843
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '`ScopedSession.mapper` is removed'
  id: totrans-844
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`ScopedSession.mapper` 已被移除'
- en: This feature provided a mapper extension which linked class- based functionality
    with a particular `ScopedSession`, in particular providing the behavior such that
    new object instances would be automatically associated with that session. The
    feature was overused by tutorials and frameworks which led to great user confusion
    due to its implicit behavior, and was deprecated in 0.5.5\. Techniques for replicating
    its functionality are at [wiki:UsageRecipes/SessionAwareMapper]
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: 此功能提供了一个映射器扩展，将基于类的功能与特定的`ScopedSession`关联起来，特别是提供了新对象实例自动与该会话关联的行为。该功能被教程和框架过度使用，由于其隐式行为而导致用户混乱，并在0.5.5中被弃用。复制其功能的技术位于[wiki:UsageRecipes/SessionAwareMapper]。
- en: Query.join(), Query.outerjoin(), eagerload(), eagerload_all(), others no longer
    allow lists of attributes as arguments
  id: totrans-846
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`Query.join()`、`Query.outerjoin()`、`eagerload()`、`eagerload_all()`等不再接受属性列表作为参数。'
- en: 'Passing a list of attributes or attribute names to `Query.join`, `eagerload()`,
    and similar has been deprecated since 0.5:'
  id: totrans-847
  prefs: []
  type: TYPE_NORMAL
  zh: 自0.5版本以来，向`Query.join`、`eagerload()`等传递属性列表或属性名称已被弃用。
- en: '[PRE93]'
  id: totrans-848
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'These methods all accept *args as of the 0.5 series:'
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: 0.5系列以来，这些方法都接受`*args`。
- en: '[PRE94]'
  id: totrans-850
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '`ScopedSession.mapper` is removed'
  id: totrans-851
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`ScopedSession.mapper`已移除。'
- en: This feature provided a mapper extension which linked class- based functionality
    with a particular `ScopedSession`, in particular providing the behavior such that
    new object instances would be automatically associated with that session. The
    feature was overused by tutorials and frameworks which led to great user confusion
    due to its implicit behavior, and was deprecated in 0.5.5\. Techniques for replicating
    its functionality are at [wiki:UsageRecipes/SessionAwareMapper]
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: 此功能提供了一个映射器扩展，将基于类的功能与特定的`ScopedSession`关联起来，特别是提供了新对象实例自动与该会话关联的行为。该功能被教程和框架过度使用，由于其隐式行为而导致用户混乱，并在0.5.5中被弃用。复制其功能的技术位于[wiki:UsageRecipes/SessionAwareMapper]。
