- en: jax.experimental.sparse module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[`jax.readthedocs.io/en/latest/jax.experimental.sparse.html`](https://jax.readthedocs.io/en/latest/jax.experimental.sparse.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The `jax.experimental.sparse` module includes experimental support for sparse
    matrix operations in JAX. It is under active development, and the API is subject
    to change. The primary interfaces made available are the `BCOO` sparse array type,
    and the `sparsify()` transform.
  prefs: []
  type: TYPE_NORMAL
- en: Batched-coordinate (BCOO) sparse matrices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The main high-level sparse object currently available in JAX is the `BCOO`,
    or *batched coordinate* sparse array, which offers a compressed storage format
    compatible with JAX transformations, in particular JIT (e.g. `jax.jit()`), batching
    (e.g. `jax.vmap()`) and autodiff (e.g. `jax.grad()`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of creating a sparse array from a dense array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Convert back to a dense array with the `todense()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The BCOO format is a somewhat modified version of the standard COO format,
    and the dense representation can be seen in the `data` and `indices` attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'BCOO objects have familiar array-like attributes, as well as sparse-specific
    attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'BCOO objects also implement a number of array-like methods, to allow you to
    use them directly within jax programs. For example, here we compute the transposed
    matrix-vector product:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'BCOO objects are designed to be compatible with JAX transforms, including `jax.jit()`,
    `jax.vmap()`, `jax.grad()`, and others. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Note, however, that under normal circumstances `jax.numpy` and `jax.lax` functions
    do not know how to handle sparse matrices, so attempting to compute things like
    `jnp.dot(M_sp.T, y)` will result in an error (however, see the next section).
  prefs: []
  type: TYPE_NORMAL
- en: Sparsify transform
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An overarching goal of the JAX sparse implementation is to provide a means to
    switch from dense to sparse computation seamlessly, without having to modify the
    dense implementation. This sparse experiment accomplishes this through the `sparsify()`
    transform.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this function, which computes a more complicated result from a matrix
    and a vector input:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Were we to pass a sparse matrix to this directly, it would result in an error,
    because `jnp` functions do not recognize sparse inputs. However, with `sparsify()`,
    we get a version of this function that does accept sparse matrices:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Support for `sparsify()` includes a large number of the most common primitives,
    including:'
  prefs: []
  type: TYPE_NORMAL
- en: generalized (batched) matrix products & einstein summations (`dot_general_p`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: zero-preserving elementwise binary operations (e.g. `add_p`, `mul_p`, etc.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: zero-preserving elementwise unary operations (e.g. `abs_p`, `jax.lax.neg_p`,
    etc.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: summation reductions (`reduce_sum_p`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: general indexing operations (`slice_p`, lax.dynamic_slice_p, lax.gather_p)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: concatenation and stacking (`concatenate_p`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: transposition & reshaping ((`transpose_p`, `reshape_p`, `squeeze_p`, `broadcast_in_dim_p`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: some higher-order functions (`cond_p`, `while_p`, `scan_p`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: some simple 1D convolutions (`conv_general_dilated_p`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nearly any `jax.numpy` function that lowers to these supported primitives can
    be used within a sparsify transform to operate on sparse arrays. This set of primitives
    is enough to enable relatively sophisticated sparse workflows, as the next section
    will show.
  prefs: []
  type: TYPE_NORMAL
- en: 'Example: sparse logistic regression'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As an example of a more complicated sparse workflow, let’s consider a simple
    logistic regression implemented in JAX. Notice that the following implementation
    has no reference to sparsity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This returns the best-fit parameters of a dense logistic regression problem.
    To fit the same model on sparse data, we can apply the `sparsify()` transform:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Sparse API Reference
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '| `sparsify`(f[, use_tracer]) | Experimental sparsification transform. |'
  prefs: []
  type: TYPE_TB
- en: '| `grad`(fun[, argnums, has_aux]) | Sparse-aware version of `jax.grad()` |'
  prefs: []
  type: TYPE_TB
- en: '| `value_and_grad`(fun[, argnums, has_aux]) | Sparse-aware version of `jax.value_and_grad()`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `empty`(shape[, dtype, index_dtype, sparse_format]) | Create an empty sparse
    array. |'
  prefs: []
  type: TYPE_TB
- en: '| `eye`(N[, M, k, dtype, index_dtype, sparse_format]) | Create 2D sparse identity
    matrix. |'
  prefs: []
  type: TYPE_TB
- en: '| `todense`(arr) | Convert input to a dense matrix. |'
  prefs: []
  type: TYPE_TB
- en: '| `random_bcoo`(key, shape, *[, dtype, ...]) | Generate a random BCOO matrix.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `JAXSparse`(args, *, shape) | Base class for high-level JAX sparse objects.
    |'
  prefs: []
  type: TYPE_TB
- en: BCOO Data Structure
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`BCOO` is the *Batched COO format*, and is the main sparse data structure implemented
    in `jax.experimental.sparse`. Its operations are compatible with JAX’s core transformations,
    including batching (e.g. `jax.vmap()`) and autodiff (e.g. `jax.grad()`).'
  prefs: []
  type: TYPE_NORMAL
- en: '| `BCOO`(args, *, shape[, indices_sorted, ...]) | Experimental batched COO
    matrix implemented in JAX |'
  prefs: []
  type: TYPE_TB
- en: '| `bcoo_broadcast_in_dim`(mat, *, shape, ...) | Expand the size and rank of
    a BCOO array by duplicating the data. |'
  prefs: []
  type: TYPE_TB
- en: '| `bcoo_concatenate`(operands, *, dimension) | Sparse implementation of `jax.lax.concatenate()`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `bcoo_dot_general`(lhs, rhs, *, dimension_numbers) | A general contraction
    operation. |'
  prefs: []
  type: TYPE_TB
- en: '| `bcoo_dot_general_sampled`(A, B, indices, *, ...) | A contraction operation
    with output computed at given sparse indices. |'
  prefs: []
  type: TYPE_TB
- en: '| `bcoo_dynamic_slice`(mat, start_indices, ...) | Sparse implementation of
    {func}`jax.lax.dynamic_slice`. |'
  prefs: []
  type: TYPE_TB
- en: '| `bcoo_extract`(sparr, arr, *[, assume_unique]) | Extract values from a dense
    array according to the sparse array''s indices. |'
  prefs: []
  type: TYPE_TB
- en: '| `bcoo_fromdense`(mat, *[, nse, n_batch, ...]) | Create BCOO-format sparse
    matrix from a dense matrix. |'
  prefs: []
  type: TYPE_TB
- en: '| `bcoo_gather`(operand, start_indices, ...[, ...]) | BCOO version of lax.gather.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `bcoo_multiply_dense`(sp_mat, v) | An element-wise multiplication between
    a sparse and a dense array. |'
  prefs: []
  type: TYPE_TB
- en: '| `bcoo_multiply_sparse`(lhs, rhs) | An element-wise multiplication of two
    sparse arrays. |'
  prefs: []
  type: TYPE_TB
- en: '| `bcoo_update_layout`(mat, *[, n_batch, ...]) | Update the storage layout
    (i.e. n_batch & n_dense) of a BCOO matrix. |'
  prefs: []
  type: TYPE_TB
- en: '| `bcoo_reduce_sum`(mat, *, axes) | Sum array element over given axes. |'
  prefs: []
  type: TYPE_TB
- en: '| `bcoo_reshape`(mat, *, new_sizes[, dimensions]) | Sparse implementation of
    {func}`jax.lax.reshape`. |'
  prefs: []
  type: TYPE_TB
- en: '| `bcoo_slice`(mat, *, start_indices, limit_indices) | Sparse implementation
    of {func}`jax.lax.slice`. |'
  prefs: []
  type: TYPE_TB
- en: '| `bcoo_sort_indices`(mat) | Sort indices of a BCOO array. |'
  prefs: []
  type: TYPE_TB
- en: '| `bcoo_squeeze`(arr, *, dimensions) | Sparse implementation of {func}`jax.lax.squeeze`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `bcoo_sum_duplicates`(mat[, nse]) | Sums duplicate indices within a BCOO
    array, returning an array with sorted indices. |'
  prefs: []
  type: TYPE_TB
- en: '| `bcoo_todense`(mat) | Convert batched sparse matrix to a dense matrix. |'
  prefs: []
  type: TYPE_TB
- en: '| `bcoo_transpose`(mat, *, permutation) | Transpose a BCOO-format array. |'
  prefs: []
  type: TYPE_TB
- en: BCSR Data Structure
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`BCSR` is the *Batched Compressed Sparse Row* format, and is under development.
    Its operations are compatible with JAX’s core transformations, including batching
    (e.g. `jax.vmap()`) and autodiff (e.g. `jax.grad()`).'
  prefs: []
  type: TYPE_NORMAL
- en: '| `BCSR`(args, *, shape[, indices_sorted, ...]) | Experimental batched CSR
    matrix implemented in JAX. |'
  prefs: []
  type: TYPE_TB
- en: '| `bcsr_dot_general`(lhs, rhs, *, dimension_numbers) | A general contraction
    operation. |'
  prefs: []
  type: TYPE_TB
- en: '| `bcsr_extract`(indices, indptr, mat) | Extract values from a dense matrix
    at given BCSR (indices, indptr). |'
  prefs: []
  type: TYPE_TB
- en: '| `bcsr_fromdense`(mat, *[, nse, n_batch, ...]) | Create BCSR-format sparse
    matrix from a dense matrix. |'
  prefs: []
  type: TYPE_TB
- en: '| `bcsr_todense`(mat) | Convert batched sparse matrix to a dense matrix. |'
  prefs: []
  type: TYPE_TB
- en: Other Sparse Data Structures
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Other sparse data structures include `COO`, `CSR`, and `CSC`. These are reference
    implementations of simple sparse structures with a few core operations implemented.
    Their operations are generally compatible with autodiff transformations such as
    `jax.grad()`, but not with batching transforms like `jax.vmap()`.
  prefs: []
  type: TYPE_NORMAL
- en: '| `COO`(args, *, shape[, rows_sorted, cols_sorted]) | Experimental COO matrix
    implemented in JAX. |'
  prefs: []
  type: TYPE_TB
- en: '| `CSC`(args, *, shape) | Experimental CSC matrix implemented in JAX; API subject
    to change. |'
  prefs: []
  type: TYPE_TB
- en: '| `CSR`(args, *, shape) | Experimental CSR matrix implemented in JAX. |'
  prefs: []
  type: TYPE_TB
- en: '| `coo_fromdense`(mat, *[, nse, index_dtype]) | Create a COO-format sparse
    matrix from a dense matrix. |'
  prefs: []
  type: TYPE_TB
- en: '| `coo_matmat`(mat, B, *[, transpose]) | Product of COO sparse matrix and a
    dense matrix. |'
  prefs: []
  type: TYPE_TB
- en: '| `coo_matvec`(mat, v[, transpose]) | Product of COO sparse matrix and a dense
    vector. |'
  prefs: []
  type: TYPE_TB
- en: '| `coo_todense`(mat) | Convert a COO-format sparse matrix to a dense matrix.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `csr_fromdense`(mat, *[, nse, index_dtype]) | Create a CSR-format sparse
    matrix from a dense matrix. |'
  prefs: []
  type: TYPE_TB
- en: '| `csr_matmat`(mat, B, *[, transpose]) | Product of CSR sparse matrix and a
    dense matrix. |'
  prefs: []
  type: TYPE_TB
- en: '| `csr_matvec`(mat, v[, transpose]) | Product of CSR sparse matrix and a dense
    vector. |'
  prefs: []
  type: TYPE_TB
- en: '| `csr_todense`(mat) | Convert a CSR-format sparse matrix to a dense matrix.
    |'
  prefs: []
  type: TYPE_TB
- en: '### `jax.experimental.sparse.linalg`'
  prefs: []
  type: TYPE_NORMAL
- en: Sparse linear algebra routines.
  prefs: []
  type: TYPE_NORMAL
- en: '| `spsolve`(data, indices, indptr, b[, tol, reorder]) | A sparse direct solver
    using QR factorization. |'
  prefs: []
  type: TYPE_TB
- en: '| `lobpcg_standard`(A, X[, m, tol]) | Compute the top-k standard eigenvalues
    using the LOBPCG routine. |'
  prefs: []
  type: TYPE_TB
