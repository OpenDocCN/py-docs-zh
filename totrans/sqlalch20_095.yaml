- en: Custom Types
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义类型
- en: 原文：[https://docs.sqlalchemy.org/en/20/core/custom_types.html](https://docs.sqlalchemy.org/en/20/core/custom_types.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://docs.sqlalchemy.org/en/20/core/custom_types.html](https://docs.sqlalchemy.org/en/20/core/custom_types.html)
- en: A variety of methods exist to redefine the behavior of existing types as well
    as to provide new ones.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 存在各种方法来重新定义现有类型的行为以及提供新类型。
- en: Overriding Type Compilation
  id: totrans-3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 覆盖类型编译
- en: 'A frequent need is to force the “string” version of a type, that is the one
    rendered in a CREATE TABLE statement or other SQL function like CAST, to be changed.
    For example, an application may want to force the rendering of `BINARY` for all
    platforms except for one, in which is wants `BLOB` to be rendered. Usage of an
    existing generic type, in this case [`LargeBinary`](type_basics.html#sqlalchemy.types.LargeBinary
    "sqlalchemy.types.LargeBinary"), is preferred for most use cases. But to control
    types more accurately, a compilation directive that is per-dialect can be associated
    with any type:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 经常需要强制类型的“字符串”版本，即在CREATE TABLE语句或其他SQL函数（如CAST）中呈现的版本进行更改。例如，应用程序可能希望强制在除一个平台外的所有平台上呈现`BINARY`，在该平台上希望呈现`BLOB`。对于大多数用例，首选使用现有的通用类型，例如[`LargeBinary`](type_basics.html#sqlalchemy.types.LargeBinary
    "sqlalchemy.types.LargeBinary")。但为了更准确地控制类型，可以将每个方言的编译指令与任何类型关联起来：
- en: '[PRE0]'
  id: totrans-5
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The above code allows the usage of [`BINARY`](type_basics.html#sqlalchemy.types.BINARY
    "sqlalchemy.types.BINARY"), which will produce the string `BINARY` against all
    backends except SQLite, in which case it will produce `BLOB`.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码允许使用[`BINARY`](type_basics.html#sqlalchemy.types.BINARY "sqlalchemy.types.BINARY")，它将针对除SQLite外的所有后端生成字符串`BINARY`，在SQLite的情况下，它将生成`BLOB`。
- en: See the section [Changing Compilation of Types](compiler.html#type-compilation-extension),
    a subsection of [Custom SQL Constructs and Compilation Extension](compiler.html),
    for additional examples.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[更改类型编译](compiler.html#type-compilation-extension)部分，这是[自定义SQL构造和编译扩展](compiler.html)的一个子部分，其中包含额外的示例。
- en: '## Augmenting Existing Types'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '## 增强现有类型'
- en: The [`TypeDecorator`](#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")
    allows the creation of custom types which add bind-parameter and result-processing
    behavior to an existing type object. It is used when additional in-Python [marshalling](../glossary.html#term-marshalling)
    of data to and/or from the database is required.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '[`TypeDecorator`](#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")允许创建自定义类型，为现有类型对象添加绑定参数和结果处理行为。当需要对数据进行额外的Python内部[编组](../glossary.html#term-marshalling)以及/或从数据库中进行时使用。'
- en: Note
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The bind- and result-processing of [`TypeDecorator`](#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") is **in addition** to the processing already
    performed by the hosted type, which is customized by SQLAlchemy on a per-DBAPI
    basis to perform processing specific to that DBAPI. While it is possible to replace
    this handling for a given type through direct subclassing, it is never needed
    in practice and SQLAlchemy no longer supports this as a public use case.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[`TypeDecorator`](#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")的绑定和结果处理是**额外的**，除了由托管类型已执行的处理外，SQLAlchemy还会根据每个DBAPI定制来执行特定于该DBAPI的处理。虽然可以通过直接子类化来替换给定类型的处理，但在实践中从不需要，并且SQLAlchemy不再支持这作为公共用例。'
- en: '| Object Name | Description |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| 对象名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| [TypeDecorator](#sqlalchemy.types.TypeDecorator) | Allows the creation of
    types which add additional functionality to an existing type. |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| [TypeDecorator](#sqlalchemy.types.TypeDecorator) | 允许创建类型，为现有类型添加额外功能。 |'
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Allows the creation of types which add additional functionality to an existing
    type.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 允许创建类型，为现有类型添加额外功能。
- en: This method is preferred to direct subclassing of SQLAlchemy’s built-in types
    as it ensures that all required functionality of the underlying type is kept in
    place.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法优于直接子类化SQLAlchemy内置类型，因为它确保保留底层类型的所有必需功能。
- en: 'Typical usage:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 典型用法：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The class-level `impl` attribute is required, and can reference any [`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") class. Alternatively, the [`load_dialect_impl()`](#sqlalchemy.types.TypeDecorator.load_dialect_impl
    "sqlalchemy.types.TypeDecorator.load_dialect_impl") method can be used to provide
    different type classes based on the dialect given; in this case, the `impl` variable
    can reference `TypeEngine` as a placeholder.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 类级别的`impl`属性是必需的，并且可以引用任何[`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine")类。或者，可以使用[`load_dialect_impl()`](#sqlalchemy.types.TypeDecorator.load_dialect_impl
    "sqlalchemy.types.TypeDecorator.load_dialect_impl")方法根据给定的方言提供不同的类型类；在这种情况下，`impl`变量可以引用`TypeEngine`作为占位符。
- en: The [`TypeDecorator.cache_ok`](#sqlalchemy.types.TypeDecorator.cache_ok "sqlalchemy.types.TypeDecorator.cache_ok")
    class-level flag indicates if this custom [`TypeDecorator`](#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") is safe to be used as part of a cache key. This
    flag defaults to `None` which will initially generate a warning when the SQL compiler
    attempts to generate a cache key for a statement that uses this type. If the [`TypeDecorator`](#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") is not guaranteed to produce the same bind/result
    behavior and SQL generation every time, this flag should be set to `False`; otherwise
    if the class produces the same behavior each time, it may be set to `True`. See
    [`TypeDecorator.cache_ok`](#sqlalchemy.types.TypeDecorator.cache_ok "sqlalchemy.types.TypeDecorator.cache_ok")
    for further notes on how this works.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '[`TypeDecorator.cache_ok`](#sqlalchemy.types.TypeDecorator.cache_ok "sqlalchemy.types.TypeDecorator.cache_ok")类级别标志指示此自定义[`TypeDecorator`](#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator")是否可以安全地用作缓存键的一部分。此标志默认为`None`，当 SQL 编译器尝试为使用此类型的语句生成缓存键时，将最初生成警告。如果[`TypeDecorator`](#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator")不能保证每次都产生相同的绑定/结果行为和 SQL 生成，则应将此标志设置为`False`；否则，如果该类每次都产生相同的行为，则可以设置为`True`。有关此工作原理的更多说明，请参见[`TypeDecorator.cache_ok`](#sqlalchemy.types.TypeDecorator.cache_ok
    "sqlalchemy.types.TypeDecorator.cache_ok")。'
- en: 'Types that receive a Python type that isn’t similar to the ultimate type used
    may want to define the [`TypeDecorator.coerce_compared_value()`](#sqlalchemy.types.TypeDecorator.coerce_compared_value
    "sqlalchemy.types.TypeDecorator.coerce_compared_value") method. This is used to
    give the expression system a hint when coercing Python objects into bind parameters
    within expressions. Consider this expression:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 接收不类似于最终使用的类型的 Python 类型的类型可能希望定义[`TypeDecorator.coerce_compared_value()`](#sqlalchemy.types.TypeDecorator.coerce_compared_value
    "sqlalchemy.types.TypeDecorator.coerce_compared_value")方法。这用于在表达式中将 Python 对象强制转换为绑定参数时给表达式系统一个提示。考虑这个表达式：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Above, if “somecol” is an `Integer` variant, it makes sense that we’re doing
    date arithmetic, where above is usually interpreted by databases as adding a number
    of days to the given date. The expression system does the right thing by not attempting
    to coerce the “date()” value into an integer-oriented bind parameter.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面，如果“somecol”是一个`Integer`变体，我们做日期算术操作是有意义的，其中上面通常被数据库解释为将一些天数加到给定日期上。表达式系统通过不试图将“date()”值强制转换为面向整数的绑定参数来做正确的事情。
- en: 'However, in the case of `TypeDecorator`, we are usually changing an incoming
    Python type to something new - `TypeDecorator` by default will “coerce” the non-typed
    side to be the same type as itself. Such as below, we define an “epoch” type that
    stores a date value as an integer:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，在`TypeDecorator`的情况下，我们通常会将一个传入的 Python 类型更改为新的东西 - 默认情况下，`TypeDecorator`会将非类型化的一侧“强制”成与自身相同的类型。例如下面，我们定义了一个将日期值存储为整数的“epoch”类型：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Our expression of `somecol + date` with the above type will coerce the “date”
    on the right side to also be treated as `MyEpochType`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上述类型的`somecol + date`表达式将会强制右侧的“date”也被视为`MyEpochType`。
- en: 'This behavior can be overridden via the [`TypeDecorator.coerce_compared_value()`](#sqlalchemy.types.TypeDecorator.coerce_compared_value
    "sqlalchemy.types.TypeDecorator.coerce_compared_value") method, which returns
    a type that should be used for the value of the expression. Below we set it such
    that an integer value will be treated as an `Integer`, and any other value is
    assumed to be a date and will be treated as a `MyEpochType`:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 通过[`TypeDecorator.coerce_compared_value()`](#sqlalchemy.types.TypeDecorator.coerce_compared_value
    "sqlalchemy.types.TypeDecorator.coerce_compared_value")方法可以覆盖此行为，该方法返回一个应用于表达式值的类型。在下面的示例中，我们设置了一个整数值将被视为`Integer`，而任何其他值都被假定为日期并将被视为`MyEpochType`：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Warning
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: 'Note that the **behavior of coerce_compared_value is not inherited by default
    from that of the base type**. If the [`TypeDecorator`](#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") is augmenting a type that requires special logic
    for certain types of operators, this method **must** be overridden. A key example
    is when decorating the [`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON
    "sqlalchemy.dialects.postgresql.JSON") and [`JSONB`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSONB
    "sqlalchemy.dialects.postgresql.JSONB") types; the default rules of [`TypeEngine.coerce_compared_value()`](type_api.html#sqlalchemy.types.TypeEngine.coerce_compared_value
    "sqlalchemy.types.TypeEngine.coerce_compared_value") should be used in order to
    deal with operators like index operations:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，**coerce_compared_value 的行为不会默认从基本类型那里继承**。如果 [`TypeDecorator`](#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") 是增强某种类型需要特殊逻辑的装饰器，这个方法 **必须** 被重写。一个关键的例子是当装饰
    [`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON "sqlalchemy.dialects.postgresql.JSON")
    和 [`JSONB`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSONB "sqlalchemy.dialects.postgresql.JSONB")
    类型时；应该使用 [`TypeEngine.coerce_compared_value()`](type_api.html#sqlalchemy.types.TypeEngine.coerce_compared_value
    "sqlalchemy.types.TypeEngine.coerce_compared_value") 的默认规则来处理像索引操作这样的操作符：
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Without the above step, index operations such as `mycol['foo']` will cause the
    index value `'foo'` to be JSON encoded.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 没有上述步骤，索引操作，比如`mycol['foo']`会导致索引值`'foo'`被 JSON 编码。
- en: 'Similarly, when working with the [`ARRAY`](type_basics.html#sqlalchemy.types.ARRAY
    "sqlalchemy.types.ARRAY") datatype, the type coercion for index operations (e.g.
    `mycol[5]`) is also handled by [`TypeDecorator.coerce_compared_value()`](#sqlalchemy.types.TypeDecorator.coerce_compared_value
    "sqlalchemy.types.TypeDecorator.coerce_compared_value"), where again a simple
    override is sufficient unless special rules are needed for particular operators:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，当使用 [`ARRAY`](type_basics.html#sqlalchemy.types.ARRAY "sqlalchemy.types.ARRAY")
    数据类型时，索引操作的类型强制转换（例如 `mycol[5]`）也由 [`TypeDecorator.coerce_compared_value()`](#sqlalchemy.types.TypeDecorator.coerce_compared_value
    "sqlalchemy.types.TypeDecorator.coerce_compared_value") 处理，再次简单的重写就足够了，除非对特定操作符需要特殊规则：
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '**Members**'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**成员**'
- en: '[cache_ok](#sqlalchemy.types.TypeDecorator.cache_ok), [operate()](#sqlalchemy.types.TypeDecorator.Comparator.operate),
    [reverse_operate()](#sqlalchemy.types.TypeDecorator.Comparator.reverse_operate),
    [__init__()](#sqlalchemy.types.TypeDecorator.__init__), [bind_expression()](#sqlalchemy.types.TypeDecorator.bind_expression),
    [bind_processor()](#sqlalchemy.types.TypeDecorator.bind_processor), [coerce_compared_value()](#sqlalchemy.types.TypeDecorator.coerce_compared_value),
    [coerce_to_is_types](#sqlalchemy.types.TypeDecorator.coerce_to_is_types), [column_expression()](#sqlalchemy.types.TypeDecorator.column_expression),
    [comparator_factory](#sqlalchemy.types.TypeDecorator.comparator_factory), [compare_values()](#sqlalchemy.types.TypeDecorator.compare_values),
    [copy()](#sqlalchemy.types.TypeDecorator.copy), [get_dbapi_type()](#sqlalchemy.types.TypeDecorator.get_dbapi_type),
    [literal_processor()](#sqlalchemy.types.TypeDecorator.literal_processor), [load_dialect_impl()](#sqlalchemy.types.TypeDecorator.load_dialect_impl),
    [process_bind_param()](#sqlalchemy.types.TypeDecorator.process_bind_param), [process_literal_param()](#sqlalchemy.types.TypeDecorator.process_literal_param),
    [process_result_value()](#sqlalchemy.types.TypeDecorator.process_result_value),
    [result_processor()](#sqlalchemy.types.TypeDecorator.result_processor), [sort_key_function](#sqlalchemy.types.TypeDecorator.sort_key_function),
    [type_engine()](#sqlalchemy.types.TypeDecorator.type_engine)'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '[cache_ok](#sqlalchemy.types.TypeDecorator.cache_ok), [operate()](#sqlalchemy.types.TypeDecorator.Comparator.operate),
    [reverse_operate()](#sqlalchemy.types.TypeDecorator.Comparator.reverse_operate),
    [__init__()](#sqlalchemy.types.TypeDecorator.__init__), [bind_expression()](#sqlalchemy.types.TypeDecorator.bind_expression),
    [bind_processor()](#sqlalchemy.types.TypeDecorator.bind_processor), [coerce_compared_value()](#sqlalchemy.types.TypeDecorator.coerce_compared_value),
    [coerce_to_is_types](#sqlalchemy.types.TypeDecorator.coerce_to_is_types), [column_expression()](#sqlalchemy.types.TypeDecorator.column_expression),
    [comparator_factory](#sqlalchemy.types.TypeDecorator.comparator_factory), [compare_values()](#sqlalchemy.types.TypeDecorator.compare_values),
    [copy()](#sqlalchemy.types.TypeDecorator.copy), [get_dbapi_type()](#sqlalchemy.types.TypeDecorator.get_dbapi_type),
    [literal_processor()](#sqlalchemy.types.TypeDecorator.literal_processor), [load_dialect_impl()](#sqlalchemy.types.TypeDecorator.load_dialect_impl),
    [process_bind_param()](#sqlalchemy.types.TypeDecorator.process_bind_param), [process_literal_param()](#sqlalchemy.types.TypeDecorator.process_literal_param),
    [process_result_value()](#sqlalchemy.types.TypeDecorator.process_result_value),
    [result_processor()](#sqlalchemy.types.TypeDecorator.result_processor), [sort_key_function](#sqlalchemy.types.TypeDecorator.sort_key_function),
    [type_engine()](#sqlalchemy.types.TypeDecorator.type_engine)'
- en: '**Class signature**'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**类签名**'
- en: class [`sqlalchemy.types.TypeDecorator`](#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")
    (`sqlalchemy.sql.expression.SchemaEventTarget`, [`sqlalchemy.types.ExternalType`](type_api.html#sqlalchemy.types.ExternalType
    "sqlalchemy.types.ExternalType"), [`sqlalchemy.types.TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine"))
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 类 [`sqlalchemy.types.TypeDecorator`](#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")
    (`sqlalchemy.sql.expression.SchemaEventTarget`, [`sqlalchemy.types.ExternalType`](type_api.html#sqlalchemy.types.ExternalType
    "sqlalchemy.types.ExternalType"), [`sqlalchemy.types.TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine"))
- en: '[PRE8]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '*inherited from the* [`ExternalType.cache_ok`](type_api.html#sqlalchemy.types.ExternalType.cache_ok
    "sqlalchemy.types.ExternalType.cache_ok") *attribute of* [`ExternalType`](type_api.html#sqlalchemy.types.ExternalType
    "sqlalchemy.types.ExternalType")'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '*继承自* [`ExternalType.cache_ok`](type_api.html#sqlalchemy.types.ExternalType.cache_ok
    "sqlalchemy.types.ExternalType.cache_ok") *属性* 的 [`ExternalType`](type_api.html#sqlalchemy.types.ExternalType
    "sqlalchemy.types.ExternalType")'
- en: Indicate if statements using this [`ExternalType`](type_api.html#sqlalchemy.types.ExternalType
    "sqlalchemy.types.ExternalType") are “safe to cache”.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此 [`ExternalType`](type_api.html#sqlalchemy.types.ExternalType "sqlalchemy.types.ExternalType")
    表示的 if 语句是否“可以缓存”。
- en: 'The default value `None` will emit a warning and then not allow caching of
    a statement which includes this type. Set to `False` to disable statements using
    this type from being cached at all without a warning. When set to `True`, the
    object’s class and selected elements from its state will be used as part of the
    cache key. For example, using a [`TypeDecorator`](#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator"):'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 默认值 `None` 会发出警告，然后不允许缓存包含此类型的语句。将其设置为 `False` 可以禁用使用此类型的语句的缓存，而不发出警告。当设置为 `True`
    时，对象的类和其状态的选定元素将用作缓存键的一部分。例如，使用 [`TypeDecorator`](#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator")：
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The cache key for the above type would be equivalent to:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 上述类型的缓存键将等同于：
- en: '[PRE10]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The caching scheme will extract attributes from the type that correspond to
    the names of parameters in the `__init__()` method. Above, the “choices” attribute
    becomes part of the cache key but “internal_only” does not, because there is no
    parameter named “internal_only”.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存方案将从类型中提取与 `__init__()` 方法中参数名称相对应的属性。在上面的例子中，“choices” 属性成为缓存键的一部分，但“internal_only”
    不会，因为没有名为 “internal_only” 的参数。
- en: The requirements for cacheable elements is that they are hashable and also that
    they indicate the same SQL rendered for expressions using this type every time
    for a given cache value.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 可缓存元素的要求是它们是可哈希的，并且还要求对于给定缓存值，它们每次都指示使用此类型的表达式的相同 SQL 渲染。
- en: 'To accommodate for datatypes that refer to unhashable structures such as dictionaries,
    sets and lists, these objects can be made “cacheable” by assigning hashable structures
    to the attributes whose names correspond with the names of the arguments. For
    example, a datatype which accepts a dictionary of lookup values may publish this
    as a sorted series of tuples. Given a previously un-cacheable type as:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为了适应引用不可哈希结构（如字典、集合和列表）的数据类型，可以通过将可哈希结构分配给其名称与参数名称对应的属性来使这些对象“可缓存”。例如，一个接受查找值字典的数据类型可以将其公布为一系列已排序的元组。给定一个先前不可缓存的类型如下：
- en: '[PRE11]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Where “lookup” is a dictionary. The type will not be able to generate a cache
    key:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 其中“lookup”是一个字典。该类型将无法生成缓存键：
- en: '[PRE12]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'If we **did** set up such a cache key, it wouldn’t be usable. We would get
    a tuple structure that contains a dictionary inside of it, which cannot itself
    be used as a key in a “cache dictionary” such as SQLAlchemy’s statement cache,
    since Python dictionaries aren’t hashable:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们**确实**设置了这样的缓存键，它将无法使用。我们将得到一个包含字典的元组结构，该字典本身无法作为“缓存字典”中的键使用，例如 SQLAlchemy
    的语句缓存，因为 Python 字典不可哈希：
- en: '[PRE13]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The type may be made cacheable by assigning a sorted tuple of tuples to the
    “.lookup” attribute:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将排序后的元组元组分配给“.lookup”属性，可以使该类型可缓存：
- en: '[PRE14]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Where above, the cache key for `LookupType({"a": 10, "b": 20})` will be:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '在上面，`LookupType({"a": 10, "b": 20})` 的缓存键将是：'
- en: '[PRE15]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'New in version 1.4.14: - added the `cache_ok` flag to allow some configurability
    of caching for [`TypeDecorator`](#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")
    classes.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 新功能，在版本 1.4.14 中：- 为 [`TypeDecorator`](#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")
    类添加了 `cache_ok` 标志，以允许对缓存进行一些可配置性。
- en: 'New in version 1.4.28: - added the [`ExternalType`](type_api.html#sqlalchemy.types.ExternalType
    "sqlalchemy.types.ExternalType") mixin which generalizes the `cache_ok` flag to
    both the [`TypeDecorator`](#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")
    and [`UserDefinedType`](#sqlalchemy.types.UserDefinedType "sqlalchemy.types.UserDefinedType")
    classes.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 新版本1.4.28中增加了[`ExternalType`](type_api.html#sqlalchemy.types.ExternalType "sqlalchemy.types.ExternalType")
    mixin，它将`cache_ok`标志推广到[`TypeDecorator`](#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")和[`UserDefinedType`](#sqlalchemy.types.UserDefinedType
    "sqlalchemy.types.UserDefinedType")类。
- en: See also
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[SQL Compilation Caching](connections.html#sql-caching)'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '[SQL 编译缓存](connections.html#sql-caching)'
- en: '[PRE16]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: A [`Comparator`](type_api.html#sqlalchemy.types.TypeEngine.Comparator "sqlalchemy.types.TypeEngine.Comparator")
    that is specific to [`TypeDecorator`](#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator").
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 一个特定于[`TypeDecorator`](#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")的[`Comparator`](type_api.html#sqlalchemy.types.TypeEngine.Comparator
    "sqlalchemy.types.TypeEngine.Comparator")。
- en: User-defined [`TypeDecorator`](#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")
    classes should not typically need to modify this.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 用户定义的[`TypeDecorator`](#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")类通常不需要修改此内容。
- en: '**Class signature**'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**类签名**'
- en: class [`sqlalchemy.types.TypeDecorator.Comparator`](#sqlalchemy.types.TypeDecorator.Comparator
    "sqlalchemy.types.TypeDecorator.Comparator") (`sqlalchemy.types.Comparator`)
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 类[`sqlalchemy.types.TypeDecorator.Comparator`](#sqlalchemy.types.TypeDecorator.Comparator
    "sqlalchemy.types.TypeDecorator.Comparator")（`sqlalchemy.types.Comparator`）
- en: '[PRE17]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Operate on an argument.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 对参数进行操作。
- en: This is the lowest level of operation, raises `NotImplementedError` by default.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这是最低级的操作，默认情况下引发`NotImplementedError`。
- en: 'Overriding this on a subclass can allow common behavior to be applied to all
    operations. For example, overriding [`ColumnOperators`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators
    "sqlalchemy.sql.expression.ColumnOperators") to apply `func.lower()` to the left
    and right side:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在子类中覆盖此内容可以允许将通用行为应用于所有操作。例如，覆盖[`ColumnOperators`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators
    "sqlalchemy.sql.expression.ColumnOperators")以将`func.lower()`应用于左右两侧：
- en: '[PRE18]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Parameters:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '`op` – Operator callable.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`op` – 运算符可调用。'
- en: '`*other` – the ‘other’ side of the operation. Will be a single scalar for most
    operations.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*other` – 操作的‘其他’一侧。对于大多数操作，将是单个标量。'
- en: '`**kwargs` – modifiers. These may be passed by special operators such as `ColumnOperators.contains()`.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**kwargs` – 修饰符。这些可以通过特殊的运算符传递，例如`ColumnOperators.contains()`。'
- en: '[PRE19]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Reverse operate on an argument.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 对参数进行反向操作。
- en: Usage is the same as [`operate()`](#sqlalchemy.types.TypeDecorator.Comparator.operate
    "sqlalchemy.types.TypeDecorator.Comparator.operate").
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 使用方式与[`operate()`](#sqlalchemy.types.TypeDecorator.Comparator.operate "sqlalchemy.types.TypeDecorator.Comparator.operate")相同。
- en: '[PRE20]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Construct a [`TypeDecorator`](#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator").
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 构造一个[`TypeDecorator`](#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")。
- en: Arguments sent here are passed to the constructor of the class assigned to the
    `impl` class level attribute, assuming the `impl` is a callable, and the resulting
    object is assigned to the `self.impl` instance attribute (thus overriding the
    class attribute of the same name).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 发送到这里的参数将传递给分配给`impl`类级属性的类的构造函数，假设`impl`是可调用的，并且将生成的对象分配给`self.impl`实例属性（从而覆盖同名的类属性）。
- en: If the class level `impl` is not a callable (the unusual case), it will be assigned
    to the same instance attribute ‘as-is’, ignoring those arguments passed to the
    constructor.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果类级`impl`不是可调用的（不寻常的情况），它将被分配给相同的实例属性，忽略传递给构造函数的参数。
- en: Subclasses can override this to customize the generation of `self.impl` entirely.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 子类可以覆盖此内容以完全自定义`self.impl`的生成。
- en: '[PRE21]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Given a bind value (i.e. a [`BindParameter`](sqlelement.html#sqlalchemy.sql.expression.BindParameter
    "sqlalchemy.sql.expression.BindParameter") instance), return a SQL expression
    which will typically wrap the given parameter.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个绑定值（即一个[`BindParameter`](sqlelement.html#sqlalchemy.sql.expression.BindParameter
    "sqlalchemy.sql.expression.BindParameter")实例），返回一个SQL表达式，该表达式通常将给定参数包装起来。
- en: Note
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This method is called during the **SQL compilation** phase of a statement, when
    rendering a SQL string. It is **not** necessarily called against specific values,
    and should not be confused with the [`TypeDecorator.process_bind_param()`](#sqlalchemy.types.TypeDecorator.process_bind_param
    "sqlalchemy.types.TypeDecorator.process_bind_param") method, which is the more
    typical method that processes the actual value passed to a particular parameter
    at statement execution time.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法在语句的**SQL编译**阶段调用，当渲染SQL字符串时。它**不一定**针对特定值调用，并且不应与[`TypeDecorator.process_bind_param()`](#sqlalchemy.types.TypeDecorator.process_bind_param
    "sqlalchemy.types.TypeDecorator.process_bind_param")方法混淆，后者是处理语句执行时传递给特定参数的实际值的更典型方法。
- en: Subclasses of [`TypeDecorator`](#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")
    can override this method to provide custom bind expression behavior for the type.
    This implementation will **replace** that of the underlying implementation type.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '[`TypeDecorator`](#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")的子类可以重写此方法，以提供类型的自定义绑定表达式行为。此实现将**替换**基础实现类型的实现。'
- en: '[PRE22]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Provide a bound value processing function for the given [`Dialect`](internals.html#sqlalchemy.engine.Dialect
    "sqlalchemy.engine.Dialect").
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 为给定的[`Dialect`](internals.html#sqlalchemy.engine.Dialect "sqlalchemy.engine.Dialect")提供一个绑定值处理函数。
- en: This is the method that fulfills the [`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") contract for bound value conversion which normally
    occurs via the [`TypeEngine.bind_processor()`](type_api.html#sqlalchemy.types.TypeEngine.bind_processor
    "sqlalchemy.types.TypeEngine.bind_processor") method.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过[`TypeEngine.bind_processor()`](type_api.html#sqlalchemy.types.TypeEngine.bind_processor
    "sqlalchemy.types.TypeEngine.bind_processor")方法通常发生的绑定值转换的方法，它履行了[`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine")合同。
- en: Note
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: User-defined subclasses of [`TypeDecorator`](#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") should **not** implement this method, and should
    instead implement [`TypeDecorator.process_bind_param()`](#sqlalchemy.types.TypeDecorator.process_bind_param
    "sqlalchemy.types.TypeDecorator.process_bind_param") so that the “inner” processing
    provided by the implementing type is maintained.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '[`TypeDecorator`](#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")
    的用户定义的子类**不应该**实现这个方法，而应该实现[`TypeDecorator.process_bind_param()`](#sqlalchemy.types.TypeDecorator.process_bind_param
    "sqlalchemy.types.TypeDecorator.process_bind_param")，以便保持实现类型提供的“内部”处理。'
- en: 'Parameters:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**dialect** – Dialect instance in use.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**dialect** – 正在使用的方言实例。'
- en: '[PRE23]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Suggest a type for a ‘coerced’ Python value in an expression.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在表达式中建议为“强制转换”的 Python 值提供一种类型。
- en: 'By default, returns self. This method is called by the expression system when
    an object using this type is on the left or right side of an expression against
    a plain Python object which does not yet have a SQLAlchemy type assigned:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，返回 self。当使用此类型的对象在表达式左侧或右侧与尚未分配 SQLAlchemy 类型的普通 Python 对象相比时，表达式系统将调用此方法：
- en: '[PRE24]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Where above, if `somecolumn` uses this type, this method will be called with
    the value `operator.add` and `35`. The return value is whatever SQLAlchemy type
    should be used for `35` for this particular operation.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述情况下，如果`somecolumn`使用此类型，则将使用值`operator.add`和`35`调用此方法。返回值是为这个特定操作应该使用的SQLAlchemy类型。
- en: '[PRE25]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Specify those Python types which should be coerced at the expression level to
    “IS <constant>” when compared using `==` (and same for `IS NOT` in conjunction
    with `!=`).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 指定那些应该在表达式级别强制转换为“IS <constant>”的 Python 类型，当使用`==`进行比较时（对于`!=`结合`IS NOT`也是如此）。
- en: For most SQLAlchemy types, this includes `NoneType`, as well as `bool`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数SQLAlchemy类型，这包括`NoneType`，以及`bool`。
- en: '[`TypeDecorator`](#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")
    modifies this list to only include `NoneType`, as typedecorator implementations
    that deal with boolean types are common.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '[`TypeDecorator`](#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")
    修改此列表，只包括`NoneType`，因为处理布尔类型的typedecorator实现是常见的。'
- en: Custom [`TypeDecorator`](#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")
    classes can override this attribute to return an empty tuple, in which case no
    values will be coerced to constants.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义[`TypeDecorator`](#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")类可以重写此属性以返回一个空元组，在这种情况下，不会将任何值强制转换为常量。
- en: '[PRE26]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Given a SELECT column expression, return a wrapping SQL expression.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个SELECT列表达式，返回一个包装的SQL表达式。
- en: Note
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This method is called during the **SQL compilation** phase of a statement, when
    rendering a SQL string. It is **not** called against specific values, and should
    not be confused with the [`TypeDecorator.process_result_value()`](#sqlalchemy.types.TypeDecorator.process_result_value
    "sqlalchemy.types.TypeDecorator.process_result_value") method, which is the more
    typical method that processes the actual value returned in a result row subsequent
    to statement execution time.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法在语句的**SQL编译**阶段调用，当渲染SQL字符串时。它**不会**针对特定值进行调用，并且不应将其与[`TypeDecorator.process_result_value()`](#sqlalchemy.types.TypeDecorator.process_result_value
    "sqlalchemy.types.TypeDecorator.process_result_value")方法混淆，后者是处理语句执行后返回的实际值的更典型的方法。
- en: Subclasses of [`TypeDecorator`](#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")
    can override this method to provide custom column expression behavior for the
    type. This implementation will **replace** that of the underlying implementation
    type.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '[`TypeDecorator`](#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")的子类可以重写此方法，以为类型提供自定义列表达式行为。此实现将**替换**底层实现类型的实现。'
- en: See the description of [`TypeEngine.column_expression()`](type_api.html#sqlalchemy.types.TypeEngine.column_expression
    "sqlalchemy.types.TypeEngine.column_expression") for a complete description of
    the method’s use.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 有关方法用途的完整描述，请参阅[`TypeEngine.column_expression()`](type_api.html#sqlalchemy.types.TypeEngine.column_expression
    "sqlalchemy.types.TypeEngine.column_expression")的描述。
- en: '[PRE27]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: A [`Comparator`](type_api.html#sqlalchemy.types.TypeEngine.Comparator "sqlalchemy.types.TypeEngine.Comparator")
    class which will apply to operations performed by owning [`ColumnElement`](sqlelement.html#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement") objects.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 一个[`Comparator`](type_api.html#sqlalchemy.types.TypeEngine.Comparator "sqlalchemy.types.TypeEngine.Comparator")类，将应用于由拥有的[`ColumnElement`](sqlelement.html#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement")对象执行的操作。
- en: The [`comparator_factory`](#sqlalchemy.types.TypeDecorator.comparator_factory
    "sqlalchemy.types.TypeDecorator.comparator_factory") attribute is a hook consulted
    by the core expression system when column and SQL expression operations are performed.
    When a [`Comparator`](type_api.html#sqlalchemy.types.TypeEngine.Comparator "sqlalchemy.types.TypeEngine.Comparator")
    class is associated with this attribute, it allows custom re-definition of all
    existing operators, as well as definition of new operators. Existing operators
    include those provided by Python operator overloading such as `ColumnOperators.__add__()`
    and `ColumnOperators.__eq__()`, those provided as standard attributes of [`ColumnOperators`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators
    "sqlalchemy.sql.operators.ColumnOperators") such as `ColumnOperators.like()` and
    `ColumnOperators.in_()`.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行列和SQL表达式操作时，核心表达式系统会查找[`comparator_factory`](#sqlalchemy.types.TypeDecorator.comparator_factory
    "sqlalchemy.types.TypeDecorator.comparator_factory")属性。当与此属性相关联的是一个[`Comparator`](type_api.html#sqlalchemy.types.TypeEngine.Comparator
    "sqlalchemy.types.TypeEngine.Comparator")类时，它允许自定义重新定义所有现有运算符，以及定义新的运算符。现有运算符包括通过Python运算符重载提供的运算符，如`ColumnOperators.__add__()`和`ColumnOperators.__eq__()`，以及作为[`ColumnOperators`](sqlelement.html#sqlalchemy.sql.operators.ColumnOperators
    "sqlalchemy.sql.operators.ColumnOperators")的标准属性提供的运算符，如`ColumnOperators.like()`和`ColumnOperators.in_()`。
- en: Rudimentary usage of this hook is allowed through simple subclassing of existing
    types, or alternatively by using [`TypeDecorator`](#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator"). See the documentation section [Redefining and
    Creating New Operators](#types-operators) for examples.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 通过简单地对现有类型进行子类化或者使用[`TypeDecorator`](#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")，可以允许对这个钩子进行基本的使用。有关示例，请参阅文档中的[Redefining
    and Creating New Operators](#types-operators)部分。
- en: '[PRE28]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Given two values, compare them for equality.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 给定两个值，比较它们是否相等。
- en: By default this calls upon [`TypeEngine.compare_values()`](type_api.html#sqlalchemy.types.TypeEngine.compare_values
    "sqlalchemy.types.TypeEngine.compare_values") of the underlying “impl”, which
    in turn usually uses the Python equals operator `==`.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，这将调用底层“impl”的[`TypeEngine.compare_values()`](type_api.html#sqlalchemy.types.TypeEngine.compare_values
    "sqlalchemy.types.TypeEngine.compare_values")，这通常使用Python相等运算符`==`。
- en: This function is used by the ORM to compare an original-loaded value with an
    intercepted “changed” value, to determine if a net change has occurred.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数由ORM用于将原始加载的值与拦截的“更改”值进行比较，以确定是否发生了净变化。
- en: '[PRE29]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Produce a copy of this [`TypeDecorator`](#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")
    instance.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 生产这个[`TypeDecorator`](#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")实例的副本。
- en: This is a shallow copy and is provided to fulfill part of the [`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") contract. It usually does not need to be overridden
    unless the user-defined [`TypeDecorator`](#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")
    has local state that should be deep-copied.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个浅拷贝，并提供了部分[`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine "sqlalchemy.types.TypeEngine")合约的实现。通常不需要重写，除非用户定义的[`TypeDecorator`](#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator")具有应该深拷贝的本地状态。
- en: '[PRE30]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Return the DBAPI type object represented by this [`TypeDecorator`](#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator").
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 返回由此[`TypeDecorator`](#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")表示的DBAPI类型对象。
- en: By default this calls upon [`TypeEngine.get_dbapi_type()`](type_api.html#sqlalchemy.types.TypeEngine.get_dbapi_type
    "sqlalchemy.types.TypeEngine.get_dbapi_type") of the underlying “impl”.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，这将调用底层“impl”的[`TypeEngine.get_dbapi_type()`](type_api.html#sqlalchemy.types.TypeEngine.get_dbapi_type
    "sqlalchemy.types.TypeEngine.get_dbapi_type")。
- en: '[PRE31]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Provide a literal processing function for the given [`Dialect`](internals.html#sqlalchemy.engine.Dialect
    "sqlalchemy.engine.Dialect").
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 为给定的[`Dialect`](internals.html#sqlalchemy.engine.Dialect "sqlalchemy.engine.Dialect")提供一个字面处理函数。
- en: This is the method that fulfills the [`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") contract for literal value conversion which normally
    occurs via the [`TypeEngine.literal_processor()`](type_api.html#sqlalchemy.types.TypeEngine.literal_processor
    "sqlalchemy.types.TypeEngine.literal_processor") method.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这是履行通过[`TypeEngine.literal_processor()`](type_api.html#sqlalchemy.types.TypeEngine.literal_processor
    "sqlalchemy.types.TypeEngine.literal_processor")方法正常发生的字面值转换的[`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine")合约的方法。
- en: Note
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: User-defined subclasses of [`TypeDecorator`](#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") should **not** implement this method, and should
    instead implement [`TypeDecorator.process_literal_param()`](#sqlalchemy.types.TypeDecorator.process_literal_param
    "sqlalchemy.types.TypeDecorator.process_literal_param") so that the “inner” processing
    provided by the implementing type is maintained.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 用户定义的[`TypeDecorator`](#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")子类**不应该**实现此方法，而应该实现[`TypeDecorator.process_literal_param()`](#sqlalchemy.types.TypeDecorator.process_literal_param
    "sqlalchemy.types.TypeDecorator.process_literal_param")，以便维护实现类型提供的“内部”处理。
- en: '[PRE32]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Return a [`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine "sqlalchemy.types.TypeEngine")
    object corresponding to a dialect.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 返回与方言对应的[`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine "sqlalchemy.types.TypeEngine")对象。
- en: This is an end-user override hook that can be used to provide differing types
    depending on the given dialect. It is used by the [`TypeDecorator`](#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") implementation of [`type_engine()`](#sqlalchemy.types.TypeDecorator.type_engine
    "sqlalchemy.types.TypeDecorator.type_engine") to help determine what type should
    ultimately be returned for a given [`TypeDecorator`](#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator").
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个最终用户的覆盖钩子，可用于根据给定的方言提供不同的类型。它被[`TypeDecorator`](#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator")的实现在帮助确定对于给定的[`TypeDecorator`](#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator")应最终返回什么类型时使用。
- en: By default returns `self.impl`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下返回`self.impl`。
- en: '[PRE33]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Receive a bound parameter value to be converted.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 接收要转换的绑定参数值。
- en: Custom subclasses of [`TypeDecorator`](#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")
    should override this method to provide custom behaviors for incoming data values.
    This method is called at **statement execution time** and is passed the literal
    Python data value which is to be associated with a bound parameter in the statement.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义的[`TypeDecorator`](#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")子类应该重写此方法，以提供传入数据值的自定义行为。此方法在**语句执行时间**被调用，并传递要与语句中的绑定参数关联的字面Python数据值。
- en: The operation could be anything desired to perform custom behavior, such as
    transforming or serializing data. This could also be used as a hook for validating
    logic.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 操作可以是任何所需的自定义行为，例如转换或序列化数据。这也可以用作验证逻辑的钩子。
- en: 'Parameters:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '`value` – Data to operate upon, of any type expected by this method in the
    subclass. Can be `None`.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`value` – 要操作的数据，应为子类中此方法预期的任何类型。可以是`None`。'
- en: '`dialect` – the [`Dialect`](internals.html#sqlalchemy.engine.Dialect "sqlalchemy.engine.Dialect")
    in use.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dialect` – 使用的[`Dialect`](internals.html#sqlalchemy.engine.Dialect "sqlalchemy.engine.Dialect")。'
- en: See also
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Augmenting Existing Types](#types-typedecorator)'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '[增强现有类型](#types-typedecorator)'
- en: '[`TypeDecorator.process_result_value()`](#sqlalchemy.types.TypeDecorator.process_result_value
    "sqlalchemy.types.TypeDecorator.process_result_value")'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '[`TypeDecorator.process_result_value()`](#sqlalchemy.types.TypeDecorator.process_result_value
    "sqlalchemy.types.TypeDecorator.process_result_value")'
- en: '[PRE34]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Receive a literal parameter value to be rendered inline within a statement.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 接收要在语句中内联呈现的文字参数值。
- en: Note
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This method is called during the **SQL compilation** phase of a statement, when
    rendering a SQL string. Unlike other SQL compilation methods, it is passed a specific
    Python value to be rendered as a string. However it should not be confused with
    the [`TypeDecorator.process_bind_param()`](#sqlalchemy.types.TypeDecorator.process_bind_param
    "sqlalchemy.types.TypeDecorator.process_bind_param") method, which is the more
    typical method that processes the actual value passed to a particular parameter
    at statement execution time.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法在**SQL编译**阶段的语句执行时被调用，用于渲染SQL字符串。与其他SQL编译方法不同，它接收一个特定的Python值作为字符串进行渲染。但是不要将其与[`TypeDecorator.process_bind_param()`](#sqlalchemy.types.TypeDecorator.process_bind_param
    "sqlalchemy.types.TypeDecorator.process_bind_param")方法混淆，后者是在语句执行时处理传递给特定参数的实际值的更典型的方法。
- en: Custom subclasses of [`TypeDecorator`](#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")
    should override this method to provide custom behaviors for incoming data values
    that are in the special case of being rendered as literals.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '[`TypeDecorator`](#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")的自定义子类应重写此方法，以提供对特殊情况下作为文字呈现的传入数据值的自定义行为。'
- en: The returned string will be rendered into the output string.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的字符串将被渲染到输出字符串中。
- en: '[PRE35]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Receive a result-row column value to be converted.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 接收要转换的结果行列值。
- en: Custom subclasses of [`TypeDecorator`](#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")
    should override this method to provide custom behaviors for data values being
    received in result rows coming from the database. This method is called at **result
    fetching time** and is passed the literal Python data value that’s extracted from
    a database result row.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '[`TypeDecorator`](#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")的自定义子类应重写此方法，以提供从数据库结果行中接收到的数据值的自定义行为。此方法在**结果提取时**被调用，并传递从数据库结果行中提取的字面Python数据值。'
- en: The operation could be anything desired to perform custom behavior, such as
    transforming or deserializing data.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 操作可以是任何希望执行自定义行为的内容，例如转换或反序列化数据。
- en: 'Parameters:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '`value` – Data to operate upon, of any type expected by this method in the
    subclass. Can be `None`.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`value` – 要操作的数据，其类型由该子类中的此方法期望的类型决定。可以是`None`。'
- en: '`dialect` – the [`Dialect`](internals.html#sqlalchemy.engine.Dialect "sqlalchemy.engine.Dialect")
    in use.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dialect` – 使用的[`Dialect`](internals.html#sqlalchemy.engine.Dialect "sqlalchemy.engine.Dialect")。'
- en: See also
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Augmenting Existing Types](#types-typedecorator)'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '[增强现有类型](#types-typedecorator)'
- en: '[`TypeDecorator.process_bind_param()`](#sqlalchemy.types.TypeDecorator.process_bind_param
    "sqlalchemy.types.TypeDecorator.process_bind_param")'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '[`TypeDecorator.process_bind_param()`](#sqlalchemy.types.TypeDecorator.process_bind_param
    "sqlalchemy.types.TypeDecorator.process_bind_param")'
- en: '[PRE36]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Provide a result value processing function for the given [`Dialect`](internals.html#sqlalchemy.engine.Dialect
    "sqlalchemy.engine.Dialect").
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 为给定的[`Dialect`](internals.html#sqlalchemy.engine.Dialect "sqlalchemy.engine.Dialect")提供结果值处理函数。
- en: This is the method that fulfills the [`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") contract for bound value conversion which normally
    occurs via the [`TypeEngine.result_processor()`](type_api.html#sqlalchemy.types.TypeEngine.result_processor
    "sqlalchemy.types.TypeEngine.result_processor") method.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这是满足[`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine "sqlalchemy.types.TypeEngine")约定的方法，用于绑定值转换，通常通过[`TypeEngine.result_processor()`](type_api.html#sqlalchemy.types.TypeEngine.result_processor
    "sqlalchemy.types.TypeEngine.result_processor")方法进行。
- en: Note
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: User-defined subclasses of [`TypeDecorator`](#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") should **not** implement this method, and should
    instead implement [`TypeDecorator.process_result_value()`](#sqlalchemy.types.TypeDecorator.process_result_value
    "sqlalchemy.types.TypeDecorator.process_result_value") so that the “inner” processing
    provided by the implementing type is maintained.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 用户定义的 [`TypeDecorator`](#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")
    的子类**不应**实现这个方法，而应该实现 [`TypeDecorator.process_result_value()`](#sqlalchemy.types.TypeDecorator.process_result_value
    "sqlalchemy.types.TypeDecorator.process_result_value")，以便保持实现类型提供的“内部”处理。
- en: 'Parameters:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '`dialect` – Dialect instance in use.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dialect` – 正在使用的方言实例。'
- en: '`coltype` – A SQLAlchemy data type'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`coltype` – 一个 SQLAlchemy 数据类型。'
- en: '[PRE37]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: A sorting function that can be passed as the key to sorted.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 一个可以作为 sorted 的键传递的排序函数。
- en: The default value of `None` indicates that the values stored by this type are
    self-sorting.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`None` 的默认值表示此类型存储的值是自排序的。'
- en: New in version 1.3.8.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 版本 1.3.8 中的新功能。
- en: '[PRE38]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Return a dialect-specific [`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") instance for this [`TypeDecorator`](#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator").
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 为这个 [`TypeDecorator`](#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")
    返回一个特定方言的 [`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine "sqlalchemy.types.TypeEngine")
    实例。
- en: In most cases this returns a dialect-adapted form of the [`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") type represented by `self.impl`. Makes usage of
    `dialect_impl()`. Behavior can be customized here by overriding [`load_dialect_impl()`](#sqlalchemy.types.TypeDecorator.load_dialect_impl
    "sqlalchemy.types.TypeDecorator.load_dialect_impl").
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，这将返回一个由 `self.impl` 表示的 [`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") 类型的方言适配形式。使用 `dialect_impl()`。通过覆盖 [`load_dialect_impl()`](#sqlalchemy.types.TypeDecorator.load_dialect_impl
    "sqlalchemy.types.TypeDecorator.load_dialect_impl") 可在此处自定义行为。
- en: TypeDecorator Recipes
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TypeDecorator 配方
- en: A few key [`TypeDecorator`](#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")
    recipes follow.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些关键的 [`TypeDecorator`](#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")
    配方。
- en: '### Coercing Encoded Strings to Unicode'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '### 将编码字符串强制转换为 Unicode'
- en: A common source of confusion regarding the [`Unicode`](type_basics.html#sqlalchemy.types.Unicode
    "sqlalchemy.types.Unicode") type is that it is intended to deal *only* with Python
    `unicode` objects on the Python side, meaning values passed to it as bind parameters
    must be of the form `u'some string'` if using Python 2 and not 3. The encoding/decoding
    functions it performs are only to suit what the DBAPI in use requires, and are
    primarily a private implementation detail.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 [`Unicode`](type_basics.html#sqlalchemy.types.Unicode "sqlalchemy.types.Unicode")
    类型的一个常见困惑是，它仅用于处理 Python 端的 `unicode` 对象，这意味着作为绑定参数传递给它的值必须是 `u'some string'`
    的形式，如果使用的是 Python 2 而不是 3。它执行的编码/解码函数仅适应所使用的 DBAPI 需要的内容，并且主要是一个私有实现细节。
- en: 'The use case of a type that can safely receive Python bytestrings, that is
    strings that contain non-ASCII characters and are not `u''''` objects in Python
    2, can be achieved using a [`TypeDecorator`](#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")
    which coerces as needed:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过使用需要时强制转换的 [`TypeDecorator`](#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")
    来实现安全接收 Python 字节串的用例：
- en: '[PRE39]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Rounding Numerics
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 四舍五入数值
- en: 'Some database connectors like those of SQL Server choke if a Decimal is passed
    with too many decimal places. Here’s a recipe that rounds them down:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 一些数据库连接器（如 SQL Server 的连接器）如果传递带有太多小数位的 Decimal 会出错。以下是一个将其四舍五入的配方：
- en: '[PRE40]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Store Timezone Aware Timestamps as Timezone Naive UTC
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将时区感知时间戳存储为时区无关的 UTC 时间
- en: 'Timestamps in databases should always be stored in a timezone-agnostic way.
    For most databases, this means ensuring a timestamp is first in the UTC timezone
    before it is stored, then storing it as timezone-naive (that is, without any timezone
    associated with it; UTC is assumed to be the “implicit” timezone). Alternatively,
    database-specific types like PostgreSQLs “TIMESTAMP WITH TIMEZONE” are often preferred
    for their richer functionality; however, storing as plain UTC will work on all
    databases and drivers. When a timezone-intelligent database type is not an option
    or is not preferred, the [`TypeDecorator`](#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")
    can be used to create a datatype that convert timezone aware timestamps into timezone
    naive and back again. Below, Python’s built-in `datetime.timezone.utc` timezone
    is used to normalize and denormalize:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库中的时间戳应始终以不考虑时区的方式存储。对于大多数数据库，这意味着首先将时间戳设置为 UTC 时区，然后将其存储为无时区（即，没有与之关联的任何时区；假定
    UTC 为“隐式”时区）。或者，通常更喜欢使用数据库特定类型，如 PostgreSQL 的“带时区的时间戳”，因为它们具有更丰富的功能；但是，以纯 UTC
    存储将在所有数据库和驱动程序上运行。当智能时区的数据库类型不可用或不受欢迎时，可以使用 [`TypeDecorator`](#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") 创建一种将时区感知时间戳转换为时区不敏感时间戳的数据类型。下面，使用 Python 内置的
    `datetime.timezone.utc` 时区来归一化和反归一化：
- en: '[PRE41]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '### Backend-agnostic GUID Type'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '### 与后端无关的 GUID 类型'
- en: Note
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Since version 2.0 the built-in [`Uuid`](type_basics.html#sqlalchemy.types.Uuid
    "sqlalchemy.types.Uuid") type that behaves similarly should be preferred. This
    example is presented just as an example of a type decorator that receives and
    returns python objects.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 自 2.0 版本起，应优先使用内置的 [`Uuid`](type_basics.html#sqlalchemy.types.Uuid "sqlalchemy.types.Uuid")
    类型，其行为类似。此示例仅作为接收和返回 Python 对象的类型装饰器的示例。
- en: 'Receives and returns Python uuid() objects. Uses the PG UUID type when using
    PostgreSQL, UNIQUEIDENTIFIER when using MSSQL, CHAR(32) on other backends, storing
    them in stringified format. The `GUIDHyphens` version stores the value with hyphens
    instead of just the hex string, using a CHAR(36) type:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 接收并返回 Python uuid() 对象。在使用 PostgreSQL 时使用 PG UUID 类型，在使用 MSSQL 时使用 UNIQUEIDENTIFIER，在其他后端上使用
    CHAR(32)，以字符串格式存储它们。`GUIDHyphens` 版本使用带连字符的值而不仅仅是十六进制字符串，使用 CHAR(36) 类型存储：
- en: '[PRE42]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Linking Python `uuid.UUID` to the Custom Type for ORM mappings
  id: totrans-194
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 将 Python `uuid.UUID` 链接到 ORM 映射的自定义类型
- en: 'When declaring ORM mappings using [Annotated Declarative Table](../orm/declarative_tables.html#orm-declarative-mapped-column)
    mappings, the custom `GUID` type defined above may be associated with the Python
    `uuid.UUID` datatype by adding it to the [type annotation map](../orm/declarative_tables.html#orm-declarative-mapped-column-type-map),
    which is typically defined on the [`DeclarativeBase`](../orm/mapping_api.html#sqlalchemy.orm.DeclarativeBase
    "sqlalchemy.orm.DeclarativeBase") class:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 [注释式声明表](../orm/declarative_tables.html#orm-declarative-mapped-column) 映射声明
    ORM 映射时，可以通过将其添加到 [类型注解映射](../orm/declarative_tables.html#orm-declarative-mapped-column-type-map)
    中，将上述自定义 `GUID` 类型与 Python `uuid.UUID` 数据类型相关联，该类型通常定义在 [`DeclarativeBase`](../orm/mapping_api.html#sqlalchemy.orm.DeclarativeBase
    "sqlalchemy.orm.DeclarativeBase") 类上：
- en: '[PRE43]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'With the above configuration, ORM mapped classes which extend from `Base` may
    refer to Python `uuid.UUID` in annotations which will make use of `GUID` automatically:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 通过上述配置，继承自 `Base` 的 ORM 映射类可以在注解中引用 Python `uuid.UUID`，这将自动使用 `GUID`：
- en: '[PRE44]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: See also
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[Customizing the Type Map](../orm/declarative_tables.html#orm-declarative-mapped-column-type-map)'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '[自定义类型映射](../orm/declarative_tables.html#orm-declarative-mapped-column-type-map)'
- en: Marshal JSON Strings
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编组 JSON 字符串
- en: 'This type uses `simplejson` to marshal Python data structures to/from JSON.
    Can be modified to use Python’s builtin json encoder:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 此类型使用 `simplejson` 将 Python 数据结构编组为 JSON。可修改为使用 Python 内置的 json 编码器：
- en: '[PRE45]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Adding Mutability
  id: totrans-204
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加可变性
- en: 'The ORM by default will not detect “mutability” on such a type as above - meaning,
    in-place changes to values will not be detected and will not be flushed. Without
    further steps, you instead would need to replace the existing value with a new
    one on each parent object to detect changes:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，ORM 不会检测上述类型的“可变性”——这意味着，对值的原地更改不会被检测到，也不会被刷新。如果没有进一步的步骤，您将需要在每个父对象上使用新对象替换现有值以检测更改：
- en: '[PRE46]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The above limitation may be fine, as many applications may not require that
    the values are ever mutated once created. For those which do have this requirement,
    support for mutability is best applied using the `sqlalchemy.ext.mutable` extension.
    For a dictionary-oriented JSON structure, we can apply this as:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 上述限制可能是可以接受的，因为许多应用程序可能不需要在创建后对值进行任何变异。对于那些确实具有此要求的应用程序，最好使用`sqlalchemy.ext.mutable`扩展来支持可变性。对于以字典为导向的JSON结构，我们可以这样应用：
- en: '[PRE47]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: See also
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Mutation Tracking](../orm/extensions/mutable.html)'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '[变异跟踪](../orm/extensions/mutable.html)'
- en: Dealing with Comparison Operations
  id: totrans-211
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 处理比较操作
- en: 'The default behavior of [`TypeDecorator`](#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")
    is to coerce the “right hand side” of any expression into the same type. For a
    type like JSON, this means that any operator used must make sense in terms of
    JSON. For some cases, users may wish for the type to behave like JSON in some
    circumstances, and as plain text in others. One example is if one wanted to handle
    the LIKE operator for the JSON type. LIKE makes no sense against a JSON structure,
    but it does make sense against the underlying textual representation. To get at
    this with a type like `JSONEncodedDict`, we need to **coerce** the column to a
    textual form using [`cast()`](sqlelement.html#sqlalchemy.sql.expression.cast "sqlalchemy.sql.expression.cast")
    or [`type_coerce()`](sqlelement.html#sqlalchemy.sql.expression.type_coerce "sqlalchemy.sql.expression.type_coerce")
    before attempting to use this operator:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '[`TypeDecorator`](#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")的默认行为是将任何表达式的“右侧”强制转换为相同类型。对于像JSON这样的类型，这意味着任何使用的操作符必须在JSON方面有意义。对于某些情况，用户可能希望在某些情况下使类型像JSON一样行为，在其他情况下像纯文本一样行为。一个例子是如果想要处理JSON类型的LIKE操作符。LIKE对JSON结构没有意义，但对底层文本表示有意义。要使用`JSONEncodedDict`这样的类型来实现这一点，我们需要在尝试使用此操作符之前使用[`cast()`](sqlelement.html#sqlalchemy.sql.expression.cast
    "sqlalchemy.sql.expression.cast")或[`type_coerce()`](sqlelement.html#sqlalchemy.sql.expression.type_coerce
    "sqlalchemy.sql.expression.type_coerce")将列强制转换为文本形式：'
- en: '[PRE48]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[`TypeDecorator`](#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")
    provides a built-in system for working up type translations like these based on
    operators. If we wanted to frequently use the LIKE operator with our JSON object
    interpreted as a string, we can build it into the type by overriding the [`TypeDecorator.coerce_compared_value()`](#sqlalchemy.types.TypeDecorator.coerce_compared_value
    "sqlalchemy.types.TypeDecorator.coerce_compared_value") method:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '[`TypeDecorator`](#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")提供了一个内置系统，用于基于操作符构建这些类型转换。如果我们想要经常使用LIKE操作符，并将我们的JSON对象解释为字符串，我们可以通过覆盖[`TypeDecorator.coerce_compared_value()`](#sqlalchemy.types.TypeDecorator.coerce_compared_value
    "sqlalchemy.types.TypeDecorator.coerce_compared_value")方法将其构建到类型中：'
- en: '[PRE49]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Above is just one approach to handling an operator like “LIKE”. Other applications
    may wish to raise `NotImplementedError` for operators that have no meaning with
    a JSON object such as “LIKE”, rather than automatically coercing to text.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 以上只是处理像“LIKE”这样的操作符的一种方法。其他应用程序可能希望对于 JSON 对象没有意义的操作符（如“LIKE”）引发`NotImplementedError`，而不是自动强制转换为文本。
- en: '## Applying SQL-level Bind/Result Processing'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '## 应用SQL级别的绑定/结果处理'
- en: As seen in the section [Augmenting Existing Types](#types-typedecorator), SQLAlchemy
    allows Python functions to be invoked both when parameters are sent to a statement,
    as well as when result rows are loaded from the database, to apply transformations
    to the values as they are sent to or from the database. It is also possible to
    define SQL-level transformations as well. The rationale here is when only the
    relational database contains a particular series of functions that are necessary
    to coerce incoming and outgoing data between an application and persistence format.
    Examples include using database-defined encryption/decryption functions, as well
    as stored procedures that handle geographic data.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如在[扩展现有类型](#types-typedecorator)一节中所见，SQLAlchemy允许在参数发送到语句时以及从数据库加载结果行时调用Python函数，以对发送到或从数据库的值应用转换。还可以定义SQL级别的转换。其理念在于，当只有关系数据库包含一系列必要的函数来在应用程序和持久性格式之间强制转换传入和传出数据时。示例包括使用数据库定义的加密/解密函数，以及处理地理数据的存储过程。
- en: 'Any [`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine "sqlalchemy.types.TypeEngine"),
    [`UserDefinedType`](#sqlalchemy.types.UserDefinedType "sqlalchemy.types.UserDefinedType")
    or [`TypeDecorator`](#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")
    subclass can include implementations of [`TypeEngine.bind_expression()`](type_api.html#sqlalchemy.types.TypeEngine.bind_expression
    "sqlalchemy.types.TypeEngine.bind_expression") and/or [`TypeEngine.column_expression()`](type_api.html#sqlalchemy.types.TypeEngine.column_expression
    "sqlalchemy.types.TypeEngine.column_expression"), which when defined to return
    a non-`None` value should return a [`ColumnElement`](sqlelement.html#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement") expression to be injected into the
    SQL statement, either surrounding bound parameters or a column expression. For
    example, to build a `Geometry` type which will apply the PostGIS function `ST_GeomFromText`
    to all outgoing values and the function `ST_AsText` to all incoming data, we can
    create our own subclass of [`UserDefinedType`](#sqlalchemy.types.UserDefinedType
    "sqlalchemy.types.UserDefinedType") which provides these methods in conjunction
    with [`func`](sqlelement.html#sqlalchemy.sql.expression.func "sqlalchemy.sql.expression.func"):'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 任何 [`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine "sqlalchemy.types.TypeEngine")、[`UserDefinedType`](#sqlalchemy.types.UserDefinedType
    "sqlalchemy.types.UserDefinedType") 或 [`TypeDecorator`](#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") 的子类都可以包含 [`TypeEngine.bind_expression()`](type_api.html#sqlalchemy.types.TypeEngine.bind_expression
    "sqlalchemy.types.TypeEngine.bind_expression") 和/或 [`TypeEngine.column_expression()`](type_api.html#sqlalchemy.types.TypeEngine.column_expression
    "sqlalchemy.types.TypeEngine.column_expression") 的实现，当定义为返回非 `None` 值时，应返回一个 [`ColumnElement`](sqlelement.html#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement") 表达式，以注入到 SQL 语句中，要么围绕绑定参数，要么是列表达式。例如，要构建一个
    `Geometry` 类型，它将对所有传出值应用 PostGIS 函数 `ST_GeomFromText`，并对所有传入数据应用函数 `ST_AsText`，我们可以创建我们自己的
    [`UserDefinedType`](#sqlalchemy.types.UserDefinedType "sqlalchemy.types.UserDefinedType")
    的子类，并与 [`func`](sqlelement.html#sqlalchemy.sql.expression.func "sqlalchemy.sql.expression.func")
    一起提供这些方法：
- en: '[PRE50]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We can apply the `Geometry` type into [`Table`](metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") metadata and use it in a [`select()`](selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") construct:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将 `Geometry` 类型应用到 [`Table`](metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    元数据中，并在 [`select()`](selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select")
    构造中使用它：
- en: '[PRE51]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The resulting SQL embeds both functions as appropriate. `ST_AsText` is applied
    to the columns clause so that the return value is run through the function before
    passing into a result set, and `ST_GeomFromText` is run on the bound parameter
    so that the passed-in value is converted:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 结果的 SQL 将两个函数嵌入到适当的位置。`ST_AsText` 应用于列子句，以便返回值在进入结果集之前通过该函数运行，而 `ST_GeomFromText`
    则在绑定参数上运行，以便转换传入的值：
- en: '[PRE52]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The [`TypeEngine.column_expression()`](type_api.html#sqlalchemy.types.TypeEngine.column_expression
    "sqlalchemy.types.TypeEngine.column_expression") method interacts with the mechanics
    of the compiler such that the SQL expression does not interfere with the labeling
    of the wrapped expression. Such as, if we rendered a [`select()`](selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") against a [`label()`](sqlelement.html#sqlalchemy.sql.expression.label
    "sqlalchemy.sql.expression.label") of our expression, the string label is moved
    to the outside of the wrapped expression:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '[`TypeEngine.column_expression()`](type_api.html#sqlalchemy.types.TypeEngine.column_expression
    "sqlalchemy.types.TypeEngine.column_expression") 方法与编译器的机制交互，以确保 SQL 表达式不会干扰包装表达式的标记。例如，如果我们对表达式的
    [`label()`](sqlelement.html#sqlalchemy.sql.expression.label "sqlalchemy.sql.expression.label")
    渲染一个 [`select()`](selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select")，字符串标签将移动到包装表达式的外部：'
- en: '[PRE53]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Output:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE54]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Another example is we decorate [`BYTEA`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.BYTEA
    "sqlalchemy.dialects.postgresql.BYTEA") to provide a `PGPString`, which will make
    use of the PostgreSQL `pgcrypto` extension to encrypt/decrypt values transparently:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是我们装饰 [`BYTEA`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.BYTEA
    "sqlalchemy.dialects.postgresql.BYTEA") 以提供一个 `PGPString`，它将使用 PostgreSQL 的 `pgcrypto`
    扩展来透明地加密/解密值：
- en: '[PRE55]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The `pgp_sym_encrypt` and `pgp_sym_decrypt` functions are applied to the INSERT
    and SELECT statements:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`pgp_sym_encrypt` 和 `pgp_sym_decrypt` 函数应用于 INSERT 和 SELECT 语句：'
- en: '[PRE56]  ## Redefining and Creating New Operators'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE56]  ## 重新定义和创建新操作符'
- en: SQLAlchemy Core defines a fixed set of expression operators available to all
    column expressions. Some of these operations have the effect of overloading Python’s
    built-in operators; examples of such operators include [`ColumnOperators.__eq__()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.__eq__
    "sqlalchemy.sql.expression.ColumnOperators.__eq__") (`table.c.somecolumn == 'foo'`),
    [`ColumnOperators.__invert__()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.__invert__
    "sqlalchemy.sql.expression.ColumnOperators.__invert__") (`~table.c.flag`), and
    [`ColumnOperators.__add__()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.__add__
    "sqlalchemy.sql.expression.ColumnOperators.__add__") (`table.c.x + table.c.y`).
    Other operators are exposed as explicit methods on column expressions, such as
    [`ColumnOperators.in_()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.in_
    "sqlalchemy.sql.expression.ColumnOperators.in_") (`table.c.value.in_(['x', 'y'])`)
    and [`ColumnOperators.like()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.like
    "sqlalchemy.sql.expression.ColumnOperators.like") (`table.c.value.like('%ed%')`).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy Core 定义了一组固定的表达式运算符，可用于所有列表达式。其中一些操作的效果是重载 Python 的内置运算符；此类运算符的示例包括[`ColumnOperators.__eq__()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.__eq__
    "sqlalchemy.sql.expression.ColumnOperators.__eq__")（`table.c.somecolumn == 'foo'`）、[`ColumnOperators.__invert__()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.__invert__
    "sqlalchemy.sql.expression.ColumnOperators.__invert__")（`~table.c.flag`）和[`ColumnOperators.__add__()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.__add__
    "sqlalchemy.sql.expression.ColumnOperators.__add__")（`table.c.x + table.c.y`）。其他运算符作为列表达式的显式方法公开，例如[`ColumnOperators.in_()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.in_
    "sqlalchemy.sql.expression.ColumnOperators.in_")（`table.c.value.in_(['x', 'y'])`）和[`ColumnOperators.like()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.like
    "sqlalchemy.sql.expression.ColumnOperators.like")（`table.c.value.like('%ed%')`）。
- en: 'When the need arises for a SQL operator that isn’t directly supported by the
    already supplied methods above, the most expedient way to produce this operator
    is to use the [`Operators.op()`](sqlelement.html#sqlalchemy.sql.expression.Operators.op
    "sqlalchemy.sql.expression.Operators.op") method on any SQL expression object;
    this method is given a string representing the SQL operator to render, and the
    return value is a Python callable that accepts any arbitrary right-hand side expression:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要使用尚未直接支持的 SQL 运算符时，最快的方法是在任何 SQL 表达式对象上使用[`Operators.op()`](sqlelement.html#sqlalchemy.sql.expression.Operators.op
    "sqlalchemy.sql.expression.Operators.op")方法；此方法接受表示要渲染的 SQL 运算符的字符串，并返回一个 Python
    可调用对象，该对象接受任意的右侧表达式：
- en: '[PRE57]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: When making use of custom SQL types, there is also a means of implementing custom
    operators as above that are automatically present upon any column expression that
    makes use of that column type, without the need to directly call [`Operators.op()`](sqlelement.html#sqlalchemy.sql.expression.Operators.op
    "sqlalchemy.sql.expression.Operators.op") each time the operator is to be used.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用自定义 SQL 类型时，还有一种方法可以实现自定义运算符，这些运算符与使用该列类型的任何列表达式自动关联，而无需每次使用运算符时直接调用[`Operators.op()`](sqlelement.html#sqlalchemy.sql.expression.Operators.op
    "sqlalchemy.sql.expression.Operators.op")。
- en: 'To achieve this, a SQL expression construct consults the [`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") object associated with the construct in order to
    determine the behavior of the built-in operators as well as to look for new methods
    that may have been invoked. [`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") defines a “comparison” object implemented by the
    [`Comparator`](type_api.html#sqlalchemy.types.TypeEngine.Comparator "sqlalchemy.types.TypeEngine.Comparator")
    class to provide the base behavior for SQL operators, and many specific types
    provide their own sub-implementations of this class. User-defined [`Comparator`](type_api.html#sqlalchemy.types.TypeEngine.Comparator
    "sqlalchemy.types.TypeEngine.Comparator") implementations can be built directly
    into a simple subclass of a particular type in order to override or define new
    operations. Below, we create a [`Integer`](type_basics.html#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer") subclass which overrides the [`ColumnOperators.__add__()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.__add__
    "sqlalchemy.sql.expression.ColumnOperators.__add__") operator, which in turn uses
    [`Operators.op()`](sqlelement.html#sqlalchemy.sql.expression.Operators.op "sqlalchemy.sql.expression.Operators.op")
    to produce the custom SQL itself:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，SQL 表达式构造会查询与构造关联的[`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine")对象，以确定内置运算符的行为，以及查找可能已调用的新方法。 [`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") 定义了一个由[`Comparator`](type_api.html#sqlalchemy.types.TypeEngine.Comparator
    "sqlalchemy.types.TypeEngine.Comparator")类实现的“比较”对象，为 SQL 运算符提供基本行为，许多特定类型提供了该类的自己的子实现。用户定义的[`Comparator`](type_api.html#sqlalchemy.types.TypeEngine.Comparator
    "sqlalchemy.types.TypeEngine.Comparator")实现可以直接构建到特定类型的简单子类中，以覆盖或定义新操作。下面，我们创建一个[`Integer`](type_basics.html#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer")子类，该子类重写了[`ColumnOperators.__add__()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.__add__
    "sqlalchemy.sql.expression.ColumnOperators.__add__")运算符，而该运算符又使用[`Operators.op()`](sqlelement.html#sqlalchemy.sql.expression.Operators.op
    "sqlalchemy.sql.expression.Operators.op")来生成自定义的 SQL 本身：
- en: '[PRE58]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The above configuration creates a new class `MyInt`, which establishes the [`TypeEngine.comparator_factory`](type_api.html#sqlalchemy.types.TypeEngine.comparator_factory
    "sqlalchemy.types.TypeEngine.comparator_factory") attribute as referring to a
    new class, subclassing the [`Comparator`](type_api.html#sqlalchemy.types.TypeEngine.Comparator
    "sqlalchemy.types.TypeEngine.Comparator") class associated with the [`Integer`](type_basics.html#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer") type.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 上述配置创建了一个名为`MyInt`的新类，该类将[`TypeEngine.comparator_factory`](type_api.html#sqlalchemy.types.TypeEngine.comparator_factory
    "sqlalchemy.types.TypeEngine.comparator_factory")属性设置为指向一个新的类，该类是[`Integer`](type_basics.html#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer")类型相关联的[`Comparator`](type_api.html#sqlalchemy.types.TypeEngine.Comparator
    "sqlalchemy.types.TypeEngine.Comparator")类的子类。
- en: 'Usage:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 用法：
- en: '[PRE59]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The implementation for [`ColumnOperators.__add__()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.__add__
    "sqlalchemy.sql.expression.ColumnOperators.__add__") is consulted by an owning
    SQL expression, by instantiating the [`Comparator`](type_api.html#sqlalchemy.types.TypeEngine.Comparator
    "sqlalchemy.types.TypeEngine.Comparator") with itself as the `expr` attribute.
    This attribute may be used when the implementation needs to refer to the originating
    [`ColumnElement`](sqlelement.html#sqlalchemy.sql.expression.ColumnElement "sqlalchemy.sql.expression.ColumnElement")
    object directly:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '[`ColumnOperators.__add__()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.__add__
    "sqlalchemy.sql.expression.ColumnOperators.__add__")的实现由拥有的 SQL 表达式查询，通过将其自身作为`expr`属性来实例化[`Comparator`](type_api.html#sqlalchemy.types.TypeEngine.Comparator
    "sqlalchemy.types.TypeEngine.Comparator")。当实现需要直接引用源 [`ColumnElement`](sqlelement.html#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement") 对象时，可以使用该属性：'
- en: '[PRE60]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'New methods added to a [`Comparator`](type_api.html#sqlalchemy.types.TypeEngine.Comparator
    "sqlalchemy.types.TypeEngine.Comparator") are exposed on an owning SQL expression
    object using a dynamic lookup scheme, which exposes methods added to [`Comparator`](type_api.html#sqlalchemy.types.TypeEngine.Comparator
    "sqlalchemy.types.TypeEngine.Comparator") onto the owning [`ColumnElement`](sqlelement.html#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement") expression construct. For example,
    to add a `log()` function to integers:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 添加到 [`Comparator`](type_api.html#sqlalchemy.types.TypeEngine.Comparator "sqlalchemy.types.TypeEngine.Comparator")
    的新方法通过动态查找方案暴露在拥有的 SQL 表达式对象上，该方案将 [`Comparator`](type_api.html#sqlalchemy.types.TypeEngine.Comparator
    "sqlalchemy.types.TypeEngine.Comparator") 添加到拥有的 [`ColumnElement`](sqlelement.html#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement") 表达式构造上的方法。例如，要为整数添加 `log()` 函数：
- en: '[PRE61]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Using the above type:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上述类型：
- en: '[PRE62]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'When using [`Operators.op()`](sqlelement.html#sqlalchemy.sql.expression.Operators.op
    "sqlalchemy.sql.expression.Operators.op") for comparison operations that return
    a boolean result, the [`Operators.op.is_comparison`](sqlelement.html#sqlalchemy.sql.expression.Operators.op.params.is_comparison
    "sqlalchemy.sql.expression.Operators.op") flag should be set to `True`:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用返回布尔结果的比较操作的 [`Operators.op()`](sqlelement.html#sqlalchemy.sql.expression.Operators.op
    "sqlalchemy.sql.expression.Operators.op") 时，应将 [`Operators.op.is_comparison`](sqlelement.html#sqlalchemy.sql.expression.Operators.op.params.is_comparison
    "sqlalchemy.sql.expression.Operators.op") 标志设置为 `True`：
- en: '[PRE63]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Unary operations are also possible. For example, to add an implementation of
    the PostgreSQL factorial operator, we combine the [`UnaryExpression`](sqlelement.html#sqlalchemy.sql.expression.UnaryExpression
    "sqlalchemy.sql.expression.UnaryExpression") construct along with a [`custom_op`](sqlelement.html#sqlalchemy.sql.expression.custom_op
    "sqlalchemy.sql.expression.custom_op") to produce the factorial expression:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 一元操作也是可能的。例如，要添加 PostgreSQL 阶乘运算符的实现，我们将 [`UnaryExpression`](sqlelement.html#sqlalchemy.sql.expression.UnaryExpression
    "sqlalchemy.sql.expression.UnaryExpression") 构造与 [`custom_op`](sqlelement.html#sqlalchemy.sql.expression.custom_op
    "sqlalchemy.sql.expression.custom_op") 结合起来产生阶乘表达式：
- en: '[PRE64]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Using the above type:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上述类型：
- en: '[PRE65]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: See also
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`Operators.op()`](sqlelement.html#sqlalchemy.sql.expression.Operators.op "sqlalchemy.sql.expression.Operators.op")'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Operators.op()`](sqlelement.html#sqlalchemy.sql.expression.Operators.op "sqlalchemy.sql.expression.Operators.op")'
- en: '[`TypeEngine.comparator_factory`](type_api.html#sqlalchemy.types.TypeEngine.comparator_factory
    "sqlalchemy.types.TypeEngine.comparator_factory")'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '[`TypeEngine.comparator_factory`](type_api.html#sqlalchemy.types.TypeEngine.comparator_factory
    "sqlalchemy.types.TypeEngine.comparator_factory")'
- en: Creating New Types
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建新类型
- en: The [`UserDefinedType`](#sqlalchemy.types.UserDefinedType "sqlalchemy.types.UserDefinedType")
    class is provided as a simple base class for defining entirely new database types.
    Use this to represent native database types not known by SQLAlchemy. If only Python
    translation behavior is needed, use [`TypeDecorator`](#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") instead.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '[`UserDefinedType`](#sqlalchemy.types.UserDefinedType "sqlalchemy.types.UserDefinedType")
    类被提供为定义全新数据库类型的简单基类。使用此类来表示 SQLAlchemy 不知道的原生数据库类型。如果只需要 Python 转换行为，请改用 [`TypeDecorator`](#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator")。'
- en: '| Object Name | Description |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| 对象名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| [UserDefinedType](#sqlalchemy.types.UserDefinedType) | Base for user defined
    types. |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '| [UserDefinedType](#sqlalchemy.types.UserDefinedType) | 用户自定义类型的基础。|'
- en: '[PRE66]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Base for user defined types.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 用户自定义类型的基础。
- en: 'This should be the base of new types. Note that for most cases, [`TypeDecorator`](#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") is probably more appropriate:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该是新类型的基础。注意，对于大多数情况，[`TypeDecorator`](#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")
    可能更合适：
- en: '[PRE67]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Once the type is made, it’s immediately usable:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦类型创建完成，就可以立即使用：
- en: '[PRE68]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The `get_col_spec()` method will in most cases receive a keyword argument `type_expression`
    which refers to the owning expression of the type as being compiled, such as a
    [`Column`](metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    or [`cast()`](sqlelement.html#sqlalchemy.sql.expression.cast "sqlalchemy.sql.expression.cast")
    construct. This keyword is only sent if the method accepts keyword arguments (e.g.
    `**kw`) in its argument signature; introspection is used to check for this in
    order to support legacy forms of this function.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_col_spec()` 方法在大多数情况下将接收一个关键字参数 `type_expression`，该参数指的是正在编译的类型的拥有表达式，例如
    [`Column`](metadata  .html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    或 [`cast()`](sqlelement.html#sqlalchemy.sql.expression.cast "sqlalchemy.sql.expression.cast")
    构造。只有在方法接受关键字参数（例如 `**kw`）时才会发送此关键字；对于支持此函数的旧形式，使用内省来检查是否存在此关键字。'
- en: The [`UserDefinedType.cache_ok`](#sqlalchemy.types.UserDefinedType.cache_ok
    "sqlalchemy.types.UserDefinedType.cache_ok") class-level flag indicates if this
    custom [`UserDefinedType`](#sqlalchemy.types.UserDefinedType "sqlalchemy.types.UserDefinedType")
    is safe to be used as part of a cache key. This flag defaults to `None` which
    will initially generate a warning when the SQL compiler attempts to generate a
    cache key for a statement that uses this type. If the [`UserDefinedType`](#sqlalchemy.types.UserDefinedType
    "sqlalchemy.types.UserDefinedType") is not guaranteed to produce the same bind/result
    behavior and SQL generation every time, this flag should be set to `False`; otherwise
    if the class produces the same behavior each time, it may be set to `True`. See
    [`UserDefinedType.cache_ok`](#sqlalchemy.types.UserDefinedType.cache_ok "sqlalchemy.types.UserDefinedType.cache_ok")
    for further notes on how this works.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '[`UserDefinedType.cache_ok`](#sqlalchemy.types.UserDefinedType.cache_ok "sqlalchemy.types.UserDefinedType.cache_ok")
    类级标志指示此自定义 [`UserDefinedType`](#sqlalchemy.types.UserDefinedType "sqlalchemy.types.UserDefinedType")
    是否安全用作缓存键的一部分。此标志默认为 `None`，当 SQL 编译器尝试为使用此类型的语古句生成缓存键时，将首先生成警告。如果不能保证 [`UserDefinedType`](#sqlalchemy.types.UserDefinedType
    "sqlalchemy.types.UserDefinedType") 每次产生相同的绑定/结果行为和 SQL 生成行为，则应将此标志设置为 `False`；否则，如果类每次产生相同的行为，则可以将其设置为
    `True`。有关此工作原理的更多说明，请参见 [`UserDefinedType.cache_ok`](#sqlalchemy.types.UserDefinedType.cache_ok
    "sqlalchemy(。types.UserDefinedType.cache_ok")。'
- en: 'New in version 1.4.28: Generalized the [`ExternalType.cache_ok`](type_api.html#sqlalchemy.types.ExternalType.cache_ok
    "sqlalchemy.types.ExternalType.cache_ok") flag so that it is available for both
    [`TypeDecorator`](#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")
    as well as [`UserDefinedType`](#sqlalchemy.types.UserDefinedType "sqlalchemy.types.UserDefinedType").'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 新版本 1.4.28 中的更新：将 [`ExternalType.cache_ok`](type_api.html#sqlalchemy.types.ExternalType.cache_ok
    "sqlalchemy.types.ExternalType.cache_ok") 标志泛化，以便它对 [`TypeDecorator`](#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") 和 'dUserDefinedType`](#sqlalchemy.types.UserDefinedType
    "sqlalchemy.types.UserDefinedType") 都可用。
- en: '**Members**'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '**成员**'
- en: '[cache_ok](#sqlalchemy.types.UserDefinedType.cache_ok), [coerce_compared_value()](#sqlalchemy.types.UserDefinedType.coerce_compared_value),
    [ensure_kwarg](#sqlalchemy.types.UserDefinedType.ensure_kwarg)'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '[cache_ok](#sqlalchemy.types.UserDefinedType.cache_ok), [coerce_compared_value()](#sqlalchemy.types.UserDefinedType.coerce_compared_value),
    [ensure_kwarg](#sqlalchemy.types.UserDefinedType.ensure_kwarg)'
- en: '**Class signature**'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '**类签名**'
- en: class [`sqlalchemy.types.UserDefinedType`](#sqlalchemy.types.UserDefinedType
    "sqlalchemy.types.UserDefinedType") ([`sqlalchemy.types.ExternalType`](type_api.html#sqlalchemy.types.ExternalType
    "sqlalchemy.types.ExternalType"), `sqlalchemy.types.TypeEngineMixin`, [`sqlalchemy.types.TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine"), `sqlalchemy.util.langhelpers.EnsureKWArg`)
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 类 [`sqlalchemy.types.UserDefinedType`](#sqlalchemy.types.UserDefinedType "sqlalchemy.types.UserDefinedType")（[`sqlalchemy.types.ExternalType`](type_api.html#sqlalchemy.types.ExternalType
    "sqlalchemy.types.ExternalType")、`sqlalchemy.types.TypeEngineMixin`、[`sqlalchemy.types.TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine")、`sqlalchemy.util.langhelpers.EnsureKWArg`)
- en: '[PRE69]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '*inherited from the* [`ExternalType.cache_ok`](type_api.html#sqlalchemy.types.ExternalType.cache_ok
    "sqlalchemy.types.ExternalType.cache_ok") *attribute of* [`ExternalType`](type_api.html#sqlalchemy.types.ExternalType
    "sqlalchemy.types.ExternalType")'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '*继承自* [`ExternalType.cache_ok`](type_api.html#sqlalchemy.types.ExternalType.cache_ok
    "sqlalchemy.types.ExternalType.cache_ok") *属性的* [`ExternalType`](type_api.html#sqlalchemy.types.ExternalType
    "sqlalchemy.types.ExternalType")'
- en: Indicate if statements using this [`ExternalType`](type_api.html#sqlalchemy.types.ExternalType
    "sqlalchemy.types.ExternalType") are “safe to cache”.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 指示使用此 [`ExternalType`](type_api.html#sqlalchemy.types.ExternalType "sqlalchemy.types.ExternalType")
    的语句是否“可缓存”。
- en: 'The default value `None` will emit a warning and then not allow caching of
    a statement which includes this type. Set to `False` to disable statements using
    this type from being cached at all without a warning. When set to `True`, the
    object’s class and selected elements from its state will be used as part of the
    cache key. For example, using a [`TypeDecorator`](#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator"):'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 默认值 `None` 将发出警告，然后不允许缓存包含此类型的语句。将其设置为 `False` 可完全禁用对包含此类型的语句进行缓存而不发出警告。当设置为
    `True` 时，对象的类和其状态中的选定元素将作为缓存键的一部分使用。例如，使用 [`TypeDecorator`](#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator")：
- en: '[PRE70]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The cache key for the above type would be equivalent to:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 上述类型的缓存键将等同于：
- en: '[PRE71]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: The caching scheme will extract attributes from the type that correspond to
    the names of parameters in the `__init__()` method. Above, the “choices” attribute
    becomes part of the cache key but “internal_only” does not, because there is no
    parameter named “internal_only”.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存方案将从与 `__init__()` 方法中的参数名称相对应的类型中提取属性。在上面的例子中，“choices”属性成为缓存键的一部分，但“internal_only”则不是，因为没有名为“internal_only”的参数。
- en: The requirements for cacheable elements is that they are hashable and also that
    they indicate the same SQL rendered for expressions using this type every time
    for a given cache value.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 可缓存元素的要求是它们可哈希，并且它们指示对于给定缓存值的情况下，每次使用此类型的表达式渲染的 SQL 相同。
- en: 'To accommodate for datatypes that refer to unhashable structures such as dictionaries,
    sets and lists, these objects can be made “cacheable” by assigning hashable structures
    to the attributes whose names correspond with the names of the arguments. For
    example, a datatype which accepts a dictionary of lookup values may publish this
    as a sorted series of tuples. Given a previously un-cacheable type as:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 为了适应指向不可哈希结构（如字典、集合和列表）的数据类型，这些对象可以通过将可哈希结构分配给与参数名称相对应的属性来使其“可缓存”。例如，接受查找值字典的数据类型可能会将其公开为排序后的元组系列。假设以前不可缓存的类型为：
- en: '[PRE72]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Where “lookup” is a dictionary. The type will not be able to generate a cache
    key:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 其中“lookup”是一个字典。该类型将无法生成缓存键：
- en: '[PRE73]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'If we **did** set up such a cache key, it wouldn’t be usable. We would get
    a tuple structure that contains a dictionary inside of it, which cannot itself
    be used as a key in a “cache dictionary” such as SQLAlchemy’s statement cache,
    since Python dictionaries aren’t hashable:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们**设置**了这样的缓存键，它将无法使用。我们将得到一个包含字典的元组结构，该字典本身不能作为“缓存字典”中的键，比如 SQLAlchemy 的语句缓存，因为
    Python 字典不可哈希：
- en: '[PRE74]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The type may be made cacheable by assigning a sorted tuple of tuples to the
    “.lookup” attribute:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 可通过将排序后的元组系列分配给“.lookup”属性来使类型可缓存：
- en: '[PRE75]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Where above, the cache key for `LookupType({"a": 10, "b": 20})` will be:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '在上面的例子中，`LookupType({"a": 10, "b": 20})` 的缓存键将是：'
- en: '[PRE76]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'New in version 1.4.14: - added the `cache_ok` flag to allow some configurability
    of caching for [`TypeDecorator`](#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")
    classes.'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 新版本 1.4.14 中新增：- 添加了 `cache_ok` 标志，以允许对 [`TypeDecorator`](#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") 类进行某些缓存的可配置性。
- en: 'New in version 1.4.28: - added the [`ExternalType`](type_api.html#sqlalchemy.types.ExternalType
    "sqlalchemy.types.ExternalType") mixin which generalizes the `cache_ok` flag to
    both the [`TypeDecorator`](#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")
    and [`UserDefinedType`](#sqlalchemy.types.UserDefinedType "sqlalchemy.types.UserDefinedType")
    classes.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 新版本 1.4.28 中新增：- 添加了[`ExternalType`](type_api.html#sqlalchemy.types.ExternalType
    "sqlalchemy.types.ExternalType") mixin，该 mixin 将 `cache_ok` 标志泛化到了 [`TypeDecorator`](#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") 和 [`UserDefinedType`](#sqlalchemy.types.UserDefinedType
    "sqlalchemy.types.UserDefinedType") 类。
- en: See also
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[SQL Compilation Caching](connections.html#sql-caching)'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '[SQL 编译缓存](connections.html#sql-caching)'
- en: '[PRE77]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Suggest a type for a ‘coerced’ Python value in an expression.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 建议为表达式中的“强制转换”Python值提供一个类型。
- en: Default behavior for [`UserDefinedType`](#sqlalchemy.types.UserDefinedType "sqlalchemy.types.UserDefinedType")
    is the same as that of [`TypeDecorator`](#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator");
    by default it returns `self`, assuming the compared value should be coerced into
    the same type as this one. See [`TypeDecorator.coerce_compared_value()`](#sqlalchemy.types.TypeDecorator.coerce_compared_value
    "sqlalchemy.types.TypeDecorator.coerce_compared_value") for more detail.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '[`UserDefinedType`](#sqlalchemy.types.UserDefinedType "sqlalchemy.types.UserDefinedType")的默认行为与[`TypeDecorator`](#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator")的默认行为相同；默认情况下，它返回`self`，假设比较的值应强制转换为与此相同类型。有关更多详细信息，请参阅[`TypeDecorator.coerce_compared_value()`](#sqlalchemy.types.TypeDecorator.coerce_compared_value
    "sqlalchemy.types.TypeDecorator.coerce_compared_value")。'
- en: '[PRE78]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: a regular expression that indicates method names for which the method should
    accept `**kw` arguments.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 表示应接受`**kw`参数的方法名称的正则表达式。
- en: The class will scan for methods matching the name template and decorate them
    if necessary to ensure `**kw` parameters are accepted.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 类将扫描与名称模板匹配的方法，并在必要时装饰它们，以确保接受`**kw`参数。
- en: '## Working with Custom Types and Reflection'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '## 使用自定义类型和反射'
- en: It is important to note that database types which are modified to have additional
    in-Python behaviors, including types based on [`TypeDecorator`](#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") as well as other user-defined subclasses of
    datatypes, do not have any representation within a database schema. When using
    database the introspection features described at [Reflecting Database Objects](reflection.html#metadata-reflection),
    SQLAlchemy makes use of a fixed mapping which links the datatype information reported
    by a database server to a SQLAlchemy datatype object. For example, if we look
    inside of a PostgreSQL schema at the definition for a particular database column,
    we might receive back the string `"VARCHAR"`. SQLAlchemy’s PostgreSQL dialect
    has a hardcoded mapping which links the string name `"VARCHAR"` to the SQLAlchemy
    [`VARCHAR`](type_basics.html#sqlalchemy.types.VARCHAR "sqlalchemy.types.VARCHAR")
    class, and that’s how when we emit a statement like `Table('my_table', m, autoload_with=engine)`,
    the [`Column`](metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    object within it would have an instance of [`VARCHAR`](type_basics.html#sqlalchemy.types.VARCHAR
    "sqlalchemy.types.VARCHAR") present inside of it.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，被修改以具有附加Python行为的数据库类型，包括基于[`TypeDecorator`](#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator")的类型以及其他用户定义的数据类型子类，不在数据库模式中具有任何表示。当使用数据库中所述的反射功能时[Reflecting
    Database Objects](reflection.html#metadata-reflection)，SQLAlchemy使用一个固定映射，将数据库服务器报告的数据类型信息链接到SQLAlchemy数据类型对象。例如，如果我们在PostgreSQL模式中查看特定数据库列的定义，我们可能会收到字符串`"VARCHAR"`。SQLAlchemy的PostgreSQL方言具有一个硬编码映射，将字符串名称`"VARCHAR"`链接到SQLAlchemy
    [`VARCHAR`](type_basics.html#sqlalchemy.types.VARCHAR "sqlalchemy.types.VARCHAR")类，这就是为什么当我们发出类似`Table('my_table',
    m, autoload_with=engine)`的语句时，其中的[`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")对象将在其内部具有[`VARCHAR`](type_basics.html#sqlalchemy.types.VARCHAR
    "sqlalchemy.types.VARCHAR")的实例的原因。
- en: 'The implication of this is that if a [`Table`](metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") object makes use of type objects that don’t correspond
    directly to the database-native type name, if we create a new [`Table`](metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") object against a new [`MetaData`](metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") collection for this database table elsewhere using
    reflection, it will not have this datatype. For example:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着如果一个[`Table`](metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")对象使用的类型对象与数据库本地类型名称不直接对应，如果我们在其他地方使用反射为此数据库表创建一个新的[`Table`](metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")对象，并针对一个新的[`MetaData`](metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData")集合，那么它将不会有此数据类型。例如：
- en: '[PRE79]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Above, we made use of [`PickleType`](type_basics.html#sqlalchemy.types.PickleType
    "sqlalchemy.types.PickleType"), which is a [`TypeDecorator`](#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") that works on top of the [`LargeBinary`](type_basics.html#sqlalchemy.types.LargeBinary
    "sqlalchemy.types.LargeBinary") datatype, which on SQLite corresponds to the database
    type `BLOB`. In the CREATE TABLE, we see that the `BLOB` datatype is used. The
    SQLite database knows nothing about the [`PickleType`](type_basics.html#sqlalchemy.types.PickleType
    "sqlalchemy.types.PickleType") we’ve used.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面，我们使用了[`PickleType`](type_basics.html#sqlalchemy.types.PickleType "sqlalchemy.types.PickleType")，这是一个在[`LargeBinary`](type_basics.html#sqlalchemy.types.LargeBinary
    "sqlalchemy.types.LargeBinary")数据类型上工作的[`TypeDecorator`](#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator")，在SQLite中对应于数据库类型`BLOB`。在CREATE TABLE中，我们看到使用了`BLOB`数据类型。SQLite数据库对我们使用的[`PickleType`](type_basics.html#sqlalchemy.types.PickleType
    "sqlalchemy.types.PickleType")一无所知。
- en: 'If we look at the datatype of `my_table.c.data.type`, as this is a Python object
    that was created by us directly, it is [`PickleType`](type_basics.html#sqlalchemy.types.PickleType
    "sqlalchemy.types.PickleType"):'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看`my_table.c.data.type`的数据类型，因为这是我们直接创建的一个Python对象，它是[`PickleType`](type_basics.html#sqlalchemy.types.PickleType
    "sqlalchemy.types.PickleType")：
- en: '[PRE80]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'However, if we create another instance of [`Table`](metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") using reflection, the use of [`PickleType`](type_basics.html#sqlalchemy.types.PickleType
    "sqlalchemy.types.PickleType") is not represented in the SQLite database we’ve
    created; we instead get back [`BLOB`](type_basics.html#sqlalchemy.types.BLOB "sqlalchemy.types.BLOB"):'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们使用反射创建另一个[`Table`](metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")实例，我们创建的SQLite数据库中不会表示使用了[`PickleType`](type_basics.html#sqlalchemy.types.PickleType
    "sqlalchemy.types.PickleType")；相反，我们会得到[`BLOB`](type_basics.html#sqlalchemy.types.BLOB
    "sqlalchemy.types.BLOB")：
- en: '[PRE81]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Typically, when an application defines explicit [`Table`](metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") metadata with custom types, there is no need to use
    table reflection because the necessary [`Table`](metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") metadata is already present. However, for the case
    where an application, or a combination of them, need to make use of both explicit
    [`Table`](metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table") metadata
    which includes custom, Python-level datatypes, as well as [`Table`](metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects which set up their [`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects as reflected from the database, which nevertheless
    still need to exhibit the additional Python behaviors of the custom datatypes,
    additional steps must be taken to allow this.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当应用程序定义具有自定义类型的显式[`Table`](metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")元数据时，没有必要使用表反射，因为必要的[`Table`](metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")元数据已经存在。但是，对于需要同时使用显式[`Table`](metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")元数据（其中包括自定义的Python级别数据类型）以及设置其[`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")对象作为从数据库反映出的[`Table`](metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")对象的应用程序或它们的组合的情况，仍然需要展示自定义数据类型的附加Python行为，必须采取额外的步骤来允许这样做。
- en: 'The most straightforward is to override specific columns as described at [Overriding
    Reflected Columns](reflection.html#reflection-overriding-columns). In this technique,
    we simply use reflection in combination with explicit [`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects for those columns for which we want to use
    a custom or decorated datatype:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的方法是根据[重写反射列](reflection.html#reflection-overriding-columns)中描述的重写特定列。在这种技术中，我们简单地使用反射与那些我们想要使用自定义或装饰的数据类型的列的显式[`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")对象结合使用：
- en: '[PRE82]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'The `my_reflected_table` object above is reflected, and will load the definition
    of the “id” column from the SQLite database. But for the “data” column, we’ve
    overridden the reflected object with an explicit [`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") definition that includes our desired in-Python datatype,
    the [`PickleType`](type_basics.html#sqlalchemy.types.PickleType "sqlalchemy.types.PickleType").
    The reflection process will leave this [`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") object intact:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的`my_reflected_table`对象被反射，并将从SQLite数据库加载“id”列的定义。但对于“data”列，我们已经使用了一个显式的[`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")定义来覆盖反射对象，其中包括我们想要的Python数据类型，[`PickleType`](type_basics.html#sqlalchemy.types.PickleType
    "sqlalchemy.types.PickleType")。反射过程将保持此[`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")对象不变：
- en: '[PRE83]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'A more elaborate way to convert from database-native type objects to custom
    datatypes is to use the [`DDLEvents.column_reflect()`](events.html#sqlalchemy.events.DDLEvents.column_reflect
    "sqlalchemy.events.DDLEvents.column_reflect") event handler. If for example we
    knew that we wanted all [`BLOB`](type_basics.html#sqlalchemy.types.BLOB "sqlalchemy.types.BLOB")
    datatypes to in fact be [`PickleType`](type_basics.html#sqlalchemy.types.PickleType
    "sqlalchemy.types.PickleType"), we could set up a rule across the board:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更加详细的将数据库原生类型对象转换为自定义数据类型的方法是使用[`DDLEvents.column_reflect()`](events.html#sqlalchemy.events.DDLEvents.column_reflect
    "sqlalchemy.events.DDLEvents.column_reflect")事件处理程序。例如，如果我们知道我们想要所有的[`BLOB`](type_basics.html#sqlalchemy.types.BLOB
    "sqlalchemy.types.BLOB")数据类型实际上是[`PickleType`](type_basics.html#sqlalchemy.types.PickleType
    "sqlalchemy.types.PickleType")，我们可以设置一个全局规则：
- en: '[PRE84]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: When the above code is invoked *before* any table reflection occurs (note also
    it should be invoked **only once** in the application, as it is a global rule),
    upon reflecting any [`Table`](metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    that includes a column with a [`BLOB`](type_basics.html#sqlalchemy.types.BLOB
    "sqlalchemy.types.BLOB") datatype, the resulting datatype will be stored in the
    [`Column`](metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    object as [`PickleType`](type_basics.html#sqlalchemy.types.PickleType "sqlalchemy.types.PickleType").
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 当上述代码在任何表反射发生之前被调用*之前*（还要注意它应该**仅在应用程序中调用一次**，因为它是一个全局规则）时，当反射包含有[`BLOB`](type_basics.html#sqlalchemy.types.BLOB
    "sqlalchemy.types.BLOB")数据类型的任何[`Table`](metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")时，结果数据类型将存储在[`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")对象中，作为[`PickleType`](type_basics.html#sqlalchemy.types.PickleType
    "sqlalchemy.types.PickleType")。
- en: In practice, the above event-based approach would likely have additional rules
    in order to affect only those columns where the datatype is important, such as
    a lookup table of table names and possibly column names, or other heuristics in
    order to accurately determine which columns should be established with an in Python
    datatype.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，上述基于事件的方法可能会有额外的规则，以便只影响那些数据类型重要的列，比如表名和可能列名的查找表，或者其他启发式方法，以准确确定应该用Python数据类型来建立哪些列。
- en: Overriding Type Compilation
  id: totrans-322
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重写类型编译
- en: 'A frequent need is to force the “string” version of a type, that is the one
    rendered in a CREATE TABLE statement or other SQL function like CAST, to be changed.
    For example, an application may want to force the rendering of `BINARY` for all
    platforms except for one, in which is wants `BLOB` to be rendered. Usage of an
    existing generic type, in this case [`LargeBinary`](type_basics.html#sqlalchemy.types.LargeBinary
    "sqlalchemy.types.LargeBinary"), is preferred for most use cases. But to control
    types more accurately, a compilation directive that is per-dialect can be associated
    with any type:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 经常需要强制使用类型的“字符串”版本，即在CREATE TABLE语句或其他SQL函数（如CAST）中呈现的版本进行更改。例如，应用程序可能希望强制对所有平台渲染`BINARY`，除了一个平台外，该平台希望渲染`BLOB`。对于大多数用例，使用现有的通用类型，例如[`LargeBinary`](type_basics.html#sqlalchemy.types.LargeBinary
    "sqlalchemy.types.LargeBinary")，更为合适。但是为了更准确地控制类型，可以将每个方言的编译指令与任何类型相关联：
- en: '[PRE85]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: The above code allows the usage of [`BINARY`](type_basics.html#sqlalchemy.types.BINARY
    "sqlalchemy.types.BINARY"), which will produce the string `BINARY` against all
    backends except SQLite, in which case it will produce `BLOB`.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码允许使用[`BINARY`](type_basics.html#sqlalchemy.types.BINARY "sqlalchemy.types.BINARY")，在除SQLite以外的所有后端中，它将产生字符串`BINARY`，而在SQLite中，它将产生`BLOB`。
- en: See the section [Changing Compilation of Types](compiler.html#type-compilation-extension),
    a subsection of [Custom SQL Constructs and Compilation Extension](compiler.html),
    for additional examples.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅 [更改类型的编译](compiler.html#type-compilation-extension) 部分，[自定义 SQL 构造和编译扩展](compiler.html)
    的一个子节，以获取其他示例。
- en: '## Augmenting Existing Types'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '## 增强现有类型'
- en: The [`TypeDecorator`](#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")
    allows the creation of custom types which add bind-parameter and result-processing
    behavior to an existing type object. It is used when additional in-Python [marshalling](../glossary.html#term-marshalling)
    of data to and/or from the database is required.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '[`TypeDecorator`](#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")
    允许创建自定义类型，将绑定参数和结果处理行为添加到现有类型对象中。当需要额外的在 Python 中对数据进行数据库内/外编组时使用。'
- en: Note
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The bind- and result-processing of [`TypeDecorator`](#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") is **in addition** to the processing already
    performed by the hosted type, which is customized by SQLAlchemy on a per-DBAPI
    basis to perform processing specific to that DBAPI. While it is possible to replace
    this handling for a given type through direct subclassing, it is never needed
    in practice and SQLAlchemy no longer supports this as a public use case.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '[`TypeDecorator`](#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")
    的绑定和结果处理**除了**已由托管类型执行的处理外，还由 SQLAlchemy 基于每个 DBAPI 进行自定义，以执行特定于该 DBAPI 的处理。虽然可能通过直接子类化替换给定类型的此处理，但在实践中从不需要，并且
    SQLAlchemy 不再支持此作为公共用例。'
- en: '| Object Name | Description |'
  id: totrans-331
  prefs: []
  type: TYPE_TB
  zh: '| 对象名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-332
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| [TypeDecorator](#sqlalchemy.types.TypeDecorator) | Allows the creation of
    types which add additional functionality to an existing type. |'
  id: totrans-333
  prefs: []
  type: TYPE_TB
  zh: '| [TypeDecorator](#sqlalchemy.types.TypeDecorator) | 允许创建将额外功能添加到现有类型的类型。 |'
- en: '[PRE86]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Allows the creation of types which add additional functionality to an existing
    type.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 允许创建将额外功能添加到现有类型的类型。
- en: This method is preferred to direct subclassing of SQLAlchemy’s built-in types
    as it ensures that all required functionality of the underlying type is kept in
    place.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 与直接子类化 SQLAlchemy 的内置类型相比，此方法更受欢迎，因为它确保了底层类型的所有必需功能都得到保留。
- en: 'Typical usage:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 典型用法：
- en: '[PRE87]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: The class-level `impl` attribute is required, and can reference any [`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") class. Alternatively, the [`load_dialect_impl()`](#sqlalchemy.types.TypeDecorator.load_dialect_impl
    "sqlalchemy.types.TypeDecorator.load_dialect_impl") method can be used to provide
    different type classes based on the dialect given; in this case, the `impl` variable
    can reference `TypeEngine` as a placeholder.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 类级别的 `impl` 属性是必需的，并且可以引用任何 [`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") 类。或者，可以使用 [`load_dialect_impl()`](#sqlalchemy.types.TypeDecorator.load_dialect_impl
    "sqlalchemy.types.TypeDecorator.load_dialect_impl") 方法来基于给定的方言提供不同的类型类；在这种情况下，`impl`
    变量可以引用 `TypeEngine` 作为占位符。
- en: The [`TypeDecorator.cache_ok`](#sqlalchemy.types.TypeDecorator.cache_ok "sqlalchemy.types.TypeDecorator.cache_ok")
    class-level flag indicates if this custom [`TypeDecorator`](#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") is safe to be used as part of a cache key. This
    flag defaults to `None` which will initially generate a warning when the SQL compiler
    attempts to generate a cache key for a statement that uses this type. If the [`TypeDecorator`](#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") is not guaranteed to produce the same bind/result
    behavior and SQL generation every time, this flag should be set to `False`; otherwise
    if the class produces the same behavior each time, it may be set to `True`. See
    [`TypeDecorator.cache_ok`](#sqlalchemy.types.TypeDecorator.cache_ok "sqlalchemy.types.TypeDecorator.cache_ok")
    for further notes on how this works.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '[`TypeDecorator.cache_ok`](#sqlalchemy.types.TypeDecorator.cache_ok "sqlalchemy.types.TypeDecorator.cache_ok")
    类级别的标志指示此自定义 [`TypeDecorator`](#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")
    是否安全用于作为缓存键的一部分。此标志默认为 `None`，在 SQL 编译器尝试为使用此类型的语句生成缓存键时，将最初生成警告。如果不能保证每次生成的绑定/结果行为和
    SQL 生成都相同，则应将此标志设置为 `False`；否则，如果该类每次都产生相同的行为，则可以将其设置为 `True`。有关此功能的更多说明，请参阅 [`TypeDecorator.cache_ok`](#sqlalchemy.types.TypeDecorator.cache_ok
    "sqlalchemy.types.TypeDecorator.cache_ok")。'
- en: 'Types that receive a Python type that isn’t similar to the ultimate type used
    may want to define the [`TypeDecorator.coerce_compared_value()`](#sqlalchemy.types.TypeDecorator.coerce_compared_value
    "sqlalchemy.types.TypeDecorator.coerce_compared_value") method. This is used to
    give the expression system a hint when coercing Python objects into bind parameters
    within expressions. Consider this expression:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 接收Python类型而不是与最终使用的类型相似的Python类型的类型可能希望定义[`TypeDecorator.coerce_compared_value()`](#sqlalchemy.types.TypeDecorator.coerce_compared_value
    "sqlalchemy.types.TypeDecorator.coerce_compared_value")方法。这用于在表达式中将Python对象强制转换为绑定参数时为表达式系统提供提示。考虑以下表达式：
- en: '[PRE88]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Above, if “somecol” is an `Integer` variant, it makes sense that we’re doing
    date arithmetic, where above is usually interpreted by databases as adding a number
    of days to the given date. The expression system does the right thing by not attempting
    to coerce the “date()” value into an integer-oriented bind parameter.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 如果“somecol”是一个`Integer`变体，我们进行日期算术操作是有道理的，其中上面通常被数据库解释为将一定数量的天数添加到给定日期。表达式系统通过不尝试将“date()`”值强制转换为整数导向绑定参数来实现正确的操作。
- en: 'However, in the case of `TypeDecorator`, we are usually changing an incoming
    Python type to something new - `TypeDecorator` by default will “coerce” the non-typed
    side to be the same type as itself. Such as below, we define an “epoch” type that
    stores a date value as an integer:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在`TypeDecorator`的情况下，我们通常将传入的Python类型更改为新的类型 - `TypeDecorator`默认会“强制”非类型化的一侧成为与其自身相同的类型。例如，我们定义了一个将日期值存储为整数的“epoch”类型如下：
- en: '[PRE89]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Our expression of `somecol + date` with the above type will coerce the “date”
    on the right side to also be treated as `MyEpochType`.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的表达式`somecol + date`将使用上述类型将右侧的“date”强制转换为`MyEpochType`。
- en: 'This behavior can be overridden via the [`TypeDecorator.coerce_compared_value()`](#sqlalchemy.types.TypeDecorator.coerce_compared_value
    "sqlalchemy.types.TypeDecorator.coerce_compared_value") method, which returns
    a type that should be used for the value of the expression. Below we set it such
    that an integer value will be treated as an `Integer`, and any other value is
    assumed to be a date and will be treated as a `MyEpochType`:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 此行为可以通过[`TypeDecorator.coerce_compared_value()`](#sqlalchemy.types.TypeDecorator.coerce_compared_value
    "sqlalchemy.types.TypeDecorator.coerce_compared_value")方法进行覆盖，该方法返回应该用于表达式值的类型。以下我们设置它，以使整数值将被视为`Integer`，并且任何其他值都被假定为日期并将被视为`MyEpochType`：
- en: '[PRE90]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Warning
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 警告
- en: 'Note that the **behavior of coerce_compared_value is not inherited by default
    from that of the base type**. If the [`TypeDecorator`](#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") is augmenting a type that requires special logic
    for certain types of operators, this method **must** be overridden. A key example
    is when decorating the [`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON
    "sqlalchemy.dialects.postgresql.JSON") and [`JSONB`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSONB
    "sqlalchemy.dialects.postgresql.JSONB") types; the default rules of [`TypeEngine.coerce_compared_value()`](type_api.html#sqlalchemy.types.TypeEngine.coerce_compared_value
    "sqlalchemy.types.TypeEngine.coerce_compared_value") should be used in order to
    deal with operators like index operations:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，**coerce_compared_value的行为默认不会从基本类型那里继承**。如果[`TypeDecorator`](#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator")是用于增强某种类型，以便针对某些类型的运算符执行特殊逻辑，那么必须重写此方法。一个关键示例是装饰[`JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON
    "sqlalchemy.dialects.postgresql.JSON")和[`JSONB`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSONB
    "sqlalchemy.dialects.postgresql.JSONB")类型; 应使用[`TypeEngine.coerce_compared_value()`](type_api.html#sqlalchemy.types.TypeEngine.coerce_compared_value
    "sqlalchemy.types.TypeEngine.coerce_compared_value")的默认规则来处理诸如索引操作之类的运算符：
- en: '[PRE91]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Without the above step, index operations such as `mycol['foo']` will cause the
    index value `'foo'` to be JSON encoded.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有上述步骤，诸如`mycol['foo']`的索引操作将导致索引值`'foo'`被JSON编码。
- en: 'Similarly, when working with the [`ARRAY`](type_basics.html#sqlalchemy.types.ARRAY
    "sqlalchemy.types.ARRAY") datatype, the type coercion for index operations (e.g.
    `mycol[5]`) is also handled by [`TypeDecorator.coerce_compared_value()`](#sqlalchemy.types.TypeDecorator.coerce_compared_value
    "sqlalchemy.types.TypeDecorator.coerce_compared_value"), where again a simple
    override is sufficient unless special rules are needed for particular operators:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，在使用[`ARRAY`](type_basics.html#sqlalchemy.types.ARRAY "sqlalchemy.types.ARRAY")数据类型时，索引操作（例如`mycol[5]`）的类型强制转换也由[`TypeDecorator.coerce_compared_value()`](#sqlalchemy.types.TypeDecorator.coerce_compared_value
    "sqlalchemy.types.TypeDecorator.coerce_compared_value")处理，除非需要特定操作符的特殊规则，否则简单的重写就足够了：
- en: '[PRE92]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '**Members**'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '**成员**'
- en: '[cache_ok](#sqlalchemy.types.TypeDecorator.cache_ok), [operate()](#sqlalchemy.types.TypeDecorator.Comparator.operate),
    [reverse_operate()](#sqlalchemy.types.TypeDecorator.Comparator.reverse_operate),
    [__init__()](#sqlalchemy.types.TypeDecorator.__init__), [bind_expression()](#sqlalchemy.types.TypeDecorator.bind_expression),
    [bind_processor()](#sqlalchemy.types.TypeDecorator.bind_processor), [coerce_compared_value()](#sqlalchemy.types.TypeDecorator.coerce_compared_value),
    [coerce_to_is_types](#sqlalchemy.types.TypeDecorator.coerce_to_is_types), [column_expression()](#sqlalchemy.types.TypeDecorator.column_expression),
    [comparator_factory](#sqlalchemy.types.TypeDecorator.comparator_factory), [compare_values()](#sqlalchemy.types.TypeDecorator.compare_values),
    [copy()](#sqlalchemy.types.TypeDecorator.copy), [get_dbapi_type()](#sqlalchemy.types.TypeDecorator.get_dbapi_type),
    [literal_processor()](#sqlalchemy.types.TypeDecorator.literal_processor), [load_dialect_impl()](#sqlalchemy.types.TypeDecorator.load_dialect_impl),
    [process_bind_param()](#sqlalchemy.types.TypeDecorator.process_bind_param), [process_literal_param()](#sqlalchemy.types.TypeDecorator.process_literal_param),
    [process_result_value()](#sqlalchemy.types.TypeDecorator.process_result_value),
    [result_processor()](#sqlalchemy.types.TypeDecorator.result_processor), [sort_key_function](#sqlalchemy.types.TypeDecorator.sort_key_function),
    [type_engine()](#sqlalchemy.types.TypeDecorator.type_engine)'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '[cache_ok](#sqlalchemy.types.TypeDecorator.cache_ok), [operate()](#sqlalchemy.types.TypeDecorator.Comparator.operate),
    [reverse_operate()](#sqlalchemy.types.TypeDecorator.Comparator.reverse_operate),
    [__init__()](#sqlalchemy.types.TypeDecorator.__init__), [bind_expression()](#sqlalchemy.types.TypeDecorator.bind_expression),
    [bind_processor()](#sqlalchemy.types.TypeDecorator.bind_processor), [coerce_compared_value()](#sqlalchemy.types.TypeDecorator.coerce_compared_value),
    [coerce_to_is_types](#sqlalchemy.types.TypeDecorator.coerce_to_is_types), [column_expression()](#sqlalchemy.types.TypeDecorator.column_expression),
    [comparator_factory](#sqlalchemy.types.TypeDecorator.comparator_factory), [compare_values()](#sqlalchemy.types.TypeDecorator.compare_values),
    [copy()](#sqlalchemy.types.TypeDecorator.copy), [get_dbapi_type()](#sqlalchemy.types.TypeDecorator.get_dbapi_type),
    [literal_processor()](#sqlalchemy.types.TypeDecorator.literal_processor), [load_dialect_impl()](#sqlalchemy.types.TypeDecorator.load_dialect_impl),
    [process_bind_param()](#sqlalchemy.types.TypeDecorator.process_bind_param), [process_literal_param()](#sqlalchemy.types.TypeDecorator.process_literal_param),
    [process_result_value()](#sqlalchemy.types.TypeDecorator.process_result_value),
    [result_processor()](#sqlalchemy.types.TypeDecorator.result_processor), [sort_key_function](#sqlalchemy.types.TypeDecorator.sort_key_function),
    [type_engine()](#sqlalchemy.types.TypeDecorator.type_engine)'
- en: '**Class signature**'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '**类签名**'
- en: class [`sqlalchemy.types.TypeDecorator`](#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")
    (`sqlalchemy.sql.expression.SchemaEventTarget`, [`sqlalchemy.types.ExternalType`](type_api.html#sqlalchemy.types.ExternalType
    "sqlalchemy.types.ExternalType"), [`sqlalchemy.types.TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine"))
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 类[`sqlalchemy.types.TypeDecorator`](#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")
    (`sqlalchemy.sql.expression.SchemaEventTarget`, [`sqlalchemy.types.ExternalType`](type_api.html#sqlalchemy.types.ExternalType
    "sqlalchemy.types.ExternalType"), [`sqlalchemy.types.TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine"))
- en: '[PRE93]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '*inherited from the* [`ExternalType.cache_ok`](type_api.html#sqlalchemy.types.ExternalType.cache_ok
    "sqlalchemy.types.ExternalType.cache_ok") *attribute of* [`ExternalType`](type_api.html#sqlalchemy.types.ExternalType
    "sqlalchemy.types.ExternalType")'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '*继承自* [`ExternalType.cache_ok`](type_api.html#sqlalchemy.types.ExternalType.cache_ok
    "sqlalchemy.types.ExternalType.cache_ok") *属性的* [`ExternalType`](type_api.html#sqlalchemy.types.ExternalType
    "sqlalchemy.types.ExternalType")'
- en: Indicate if statements using this [`ExternalType`](type_api.html#sqlalchemy.types.ExternalType
    "sqlalchemy.types.ExternalType") are “safe to cache”.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 表明使用此[`ExternalType`](type_api.html#sqlalchemy.types.ExternalType "sqlalchemy.types.ExternalType")的语句是否“可以缓存”。
- en: 'The default value `None` will emit a warning and then not allow caching of
    a statement which includes this type. Set to `False` to disable statements using
    this type from being cached at all without a warning. When set to `True`, the
    object’s class and selected elements from its state will be used as part of the
    cache key. For example, using a [`TypeDecorator`](#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator"):'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '默认值`None`将发出警告，然后不允许缓存包含此类型的语句。将其设置为`False`以禁用包含此类型的语句的缓存，而无需警告。当设置为`True`时，对象的类和其状态中选择的元素将用作缓存键的一部分。例如，使用[`TypeDecorator`](#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator"):'
- en: '[PRE94]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'The cache key for the above type would be equivalent to:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 上述类型的缓存键将等同于：
- en: '[PRE95]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: The caching scheme will extract attributes from the type that correspond to
    the names of parameters in the `__init__()` method. Above, the “choices” attribute
    becomes part of the cache key but “internal_only” does not, because there is no
    parameter named “internal_only”.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存方案将从类型中提取与`__init__()`方法中参数名称对应的属性。以上，“choices”属性成为缓存键的一部分，但“internal_only”不会，因为没有名为“internal_only”的参数。
- en: The requirements for cacheable elements is that they are hashable and also that
    they indicate the same SQL rendered for expressions using this type every time
    for a given cache value.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 可缓存元素的要求是它们是可哈希的，并且还表明对于给定缓存值，每次使用此类型的表达式呈现相同的SQL。
- en: 'To accommodate for datatypes that refer to unhashable structures such as dictionaries,
    sets and lists, these objects can be made “cacheable” by assigning hashable structures
    to the attributes whose names correspond with the names of the arguments. For
    example, a datatype which accepts a dictionary of lookup values may publish this
    as a sorted series of tuples. Given a previously un-cacheable type as:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 为了适应引用不可哈希结构（如字典、集合和列表）的数据类型，这些对象可以通过将可哈希结构分配给与参数名称对应的属性来“可缓存”。例如，一个接受查找值字典的数据类型可以将其公开为一系列排序后的元组。给定先前不可缓存的类型：
- en: '[PRE96]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Where “lookup” is a dictionary. The type will not be able to generate a cache
    key:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 其中“lookup”是一个字典。该类型将无法生成缓存键：
- en: '[PRE97]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'If we **did** set up such a cache key, it wouldn’t be usable. We would get
    a tuple structure that contains a dictionary inside of it, which cannot itself
    be used as a key in a “cache dictionary” such as SQLAlchemy’s statement cache,
    since Python dictionaries aren’t hashable:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们**确实**设置了这样一个缓存键，它将无法使用。我们将得到一个包含其中一个字典的元组结构，这个字典本身不能作为“缓存字典”中的键，比如SQLAlchemy的语句缓存，因为Python字典不可哈希：
- en: '[PRE98]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'The type may be made cacheable by assigning a sorted tuple of tuples to the
    “.lookup” attribute:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 可通过将排序后的元组分配给“.lookup”属性来使类型可缓存：
- en: '[PRE99]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Where above, the cache key for `LookupType({"a": 10, "b": 20})` will be:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '在上面的例子中，`LookupType({"a": 10, "b": 20})`的缓存键将是：'
- en: '[PRE100]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'New in version 1.4.14: - added the `cache_ok` flag to allow some configurability
    of caching for [`TypeDecorator`](#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")
    classes.'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 1.4.14版本中新增：- 添加了`cache_ok`标志，以允许对[`TypeDecorator`](#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator")类的缓存进行一些可配置性。
- en: 'New in version 1.4.28: - added the [`ExternalType`](type_api.html#sqlalchemy.types.ExternalType
    "sqlalchemy.types.ExternalType") mixin which generalizes the `cache_ok` flag to
    both the [`TypeDecorator`](#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")
    and [`UserDefinedType`](#sqlalchemy.types.UserDefinedType "sqlalchemy.types.UserDefinedType")
    classes.'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 1.4.28版本中新增：- 添加了[`ExternalType`](type_api.html#sqlalchemy.types.ExternalType
    "sqlalchemy.types.ExternalType") mixin，将`cache_ok`标志泛化到[`TypeDecorator`](#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator")和[`UserDefinedType`](#sqlalchemy.types.UserDefinedType
    "sqlalchemy.types.UserDefinedType")类中。
- en: See also
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[SQL Compilation Caching](connections.html#sql-caching)'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '[SQL 编译缓存](connections.html#sql-caching)'
- en: '[PRE101]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: A [`Comparator`](type_api.html#sqlalchemy.types.TypeEngine.Comparator "sqlalchemy.types.TypeEngine.Comparator")
    that is specific to [`TypeDecorator`](#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator").
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 一个专门针对[`TypeDecorator`](#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")的[`Comparator`](type_api.html#sqlalchemy.types.TypeEngine.Comparator
    "sqlalchemy.types.TypeEngine.Comparator")。
- en: User-defined [`TypeDecorator`](#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")
    classes should not typically need to modify this.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 通常不需要修改用户定义的[`TypeDecorator`](#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")类。
- en: '**Class signature**'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '**类签名**'
- en: class [`sqlalchemy.types.TypeDecorator.Comparator`](#sqlalchemy.types.TypeDecorator.Comparator
    "sqlalchemy.types.TypeDecorator.Comparator") (`sqlalchemy.types.Comparator`)
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 类[`sqlalchemy.types.TypeDecorator.Comparator`](#sqlalchemy.types.TypeDecorator.Comparator
    "sqlalchemy.types.TypeDecorator.Comparator") (`sqlalchemy.types.Comparator`)
- en: '[PRE102]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Operate on an argument.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 对参数进行操作。
- en: This is the lowest level of operation, raises `NotImplementedError` by default.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 这是操作的最低级别，默认情况下引发`NotImplementedError`。
- en: 'Overriding this on a subclass can allow common behavior to be applied to all
    operations. For example, overriding [`ColumnOperators`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators
    "sqlalchemy.sql.expression.ColumnOperators") to apply `func.lower()` to the left
    and right side:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 在子类中覆盖这一点可以让所有操作应用通用行为。例如，覆盖[`ColumnOperators`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators
    "sqlalchemy.sql.expression.ColumnOperators")以将`func.lower()`应用于左侧和右侧：
- en: '[PRE103]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Parameters:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '`op` – Operator callable.'
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`op` – 运算符可调用。'
- en: '`*other` – the ‘other’ side of the operation. Will be a single scalar for most
    operations.'
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`*other` – 操作的‘其他’一侧。对于大多数操作，将是一个单一标量。'
- en: '`**kwargs` – modifiers. These may be passed by special operators such as `ColumnOperators.contains()`.'
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**kwargs` – 修改器。这些可能会被特殊运算符（例如 `ColumnOperators.contains()`）传递。'
- en: '[PRE104]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: Reverse operate on an argument.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 对参数执行反向操作。
- en: Usage is the same as [`operate()`](#sqlalchemy.types.TypeDecorator.Comparator.operate
    "sqlalchemy.types.TypeDecorator.Comparator.operate").
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 使用方式与 [`operate()`](#sqlalchemy.types.TypeDecorator.Comparator.operate "sqlalchemy.types.TypeDecorator.Comparator.operate")
    相同。
- en: '[PRE105]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: Construct a [`TypeDecorator`](#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator").
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 构造一个 [`TypeDecorator`](#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")。
- en: Arguments sent here are passed to the constructor of the class assigned to the
    `impl` class level attribute, assuming the `impl` is a callable, and the resulting
    object is assigned to the `self.impl` instance attribute (thus overriding the
    class attribute of the same name).
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 发送到此处的参数将传递给分配给 `impl` 类级别属性的类的构造函数，假设 `impl` 是可调用的，并且生成的对象将被分配给 `self.impl`
    实例属性（因此覆盖了同名的类属性）。
- en: If the class level `impl` is not a callable (the unusual case), it will be assigned
    to the same instance attribute ‘as-is’, ignoring those arguments passed to the
    constructor.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 如果类级别的 `impl` 不是可调用的（不寻常的情况），它将被分配给相同的实例属性‘原样’，忽略传递给构造函数的那些参数。
- en: Subclasses can override this to customize the generation of `self.impl` entirely.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 子类可以重写此方法以完全自定义 `self.impl` 的生成。
- en: '[PRE106]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Given a bind value (i.e. a [`BindParameter`](sqlelement.html#sqlalchemy.sql.expression.BindParameter
    "sqlalchemy.sql.expression.BindParameter") instance), return a SQL expression
    which will typically wrap the given parameter.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个绑定值（即一个 [`BindParameter`](sqlelement.html#sqlalchemy.sql.expression.BindParameter
    "sqlalchemy.sql.expression.BindParameter") 实例），返回一个 SQL 表达式，通常会包装给定的参数。
- en: Note
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This method is called during the **SQL compilation** phase of a statement, when
    rendering a SQL string. It is **not** necessarily called against specific values,
    and should not be confused with the [`TypeDecorator.process_bind_param()`](#sqlalchemy.types.TypeDecorator.process_bind_param
    "sqlalchemy.types.TypeDecorator.process_bind_param") method, which is the more
    typical method that processes the actual value passed to a particular parameter
    at statement execution time.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 在语句的 **SQL 编译** 阶段调用此方法，当渲染 SQL 字符串时。它**不一定**针对特定值调用，并且不应与 [`TypeDecorator.process_bind_param()`](#sqlalchemy.types.TypeDecorator.process_bind_param
    "sqlalchemy.types.TypeDecorator.process_bind_param") 方法混淆，后者是处理语句执行时传递给特定参数的实际值的更典型方法。
- en: Subclasses of [`TypeDecorator`](#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")
    can override this method to provide custom bind expression behavior for the type.
    This implementation will **replace** that of the underlying implementation type.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: '[`TypeDecorator`](#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")
    的子类可以重写此方法以为类型提供自定义绑定表达式行为。此实现将**替换**底层实现类型的实现。'
- en: '[PRE107]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Provide a bound value processing function for the given [`Dialect`](internals.html#sqlalchemy.engine.Dialect
    "sqlalchemy.engine.Dialect").
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 为给定 [`Dialect`](internals.html#sqlalchemy.engine.Dialect "sqlalchemy.engine.Dialect")
    提供一个绑定值处理函数。
- en: This is the method that fulfills the [`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") contract for bound value conversion which normally
    occurs via the [`TypeEngine.bind_processor()`](type_api.html#sqlalchemy.types.TypeEngine.bind_processor
    "sqlalchemy.types.TypeEngine.bind_processor") method.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 这是执行绑定值转换的方法，通常通过 [`TypeEngine.bind_processor()`](type_api.html#sqlalchemy.types.TypeEngine.bind_processor
    "sqlalchemy.types.TypeEngine.bind_processor") 方法在 **SQL 编译** 阶段的语句中发生。
- en: Note
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: User-defined subclasses of [`TypeDecorator`](#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") should **not** implement this method, and should
    instead implement [`TypeDecorator.process_bind_param()`](#sqlalchemy.types.TypeDecorator.process_bind_param
    "sqlalchemy.types.TypeDecorator.process_bind_param") so that the “inner” processing
    provided by the implementing type is maintained.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '[`TypeDecorator`](#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")
    的用户定义子类**不应该**实现这个方法，而应该实现 [`TypeDecorator.process_bind_param()`](#sqlalchemy.types.TypeDecorator.process_bind_param
    "sqlalchemy.types.TypeDecorator.process_bind_param") 方法，以保持实现类型提供的“内部”处理。'
- en: 'Parameters:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '**dialect** – Dialect instance in use.'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '**dialect** – 正在使用的 Dialect 实例。'
- en: '[PRE108]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: Suggest a type for a ‘coerced’ Python value in an expression.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 为表达式中的‘强制’Python值建议一种类型。
- en: 'By default, returns self. This method is called by the expression system when
    an object using this type is on the left or right side of an expression against
    a plain Python object which does not yet have a SQLAlchemy type assigned:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，返回self。 当此类型的对象位于尚未分配SQLAlchemy类型的纯Python对象的表达式的左侧或右侧时，表达式系统会调用此方法：
- en: '[PRE109]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: Where above, if `somecolumn` uses this type, this method will be called with
    the value `operator.add` and `35`. The return value is whatever SQLAlchemy type
    should be used for `35` for this particular operation.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述情况中，如果`somecolumn`使用了这种类型，则将使用值`operator.add`和`35`调用此方法。 返回值是应该用于此特定操作的`35`的任何SQLAlchemy类型。
- en: '[PRE110]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: Specify those Python types which should be coerced at the expression level to
    “IS <constant>” when compared using `==` (and same for `IS NOT` in conjunction
    with `!=`).
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 指定那些应该在表达式级别上被强制转换为“IS <constant>”的Python类型，当使用`==`进行比较时（与`!=`结合使用时同样适用于`IS
    NOT`）。
- en: For most SQLAlchemy types, this includes `NoneType`, as well as `bool`.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数SQLAlchemy类型，这包括`NoneType`，以及`bool`。
- en: '[`TypeDecorator`](#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")
    modifies this list to only include `NoneType`, as typedecorator implementations
    that deal with boolean types are common.'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '[`TypeDecorator`](#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")修改此列表以仅包括`NoneType`，因为处理布尔类型的类型装饰器实现很常见。'
- en: Custom [`TypeDecorator`](#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")
    classes can override this attribute to return an empty tuple, in which case no
    values will be coerced to constants.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义[`TypeDecorator`](#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")类可以重写此属性以返回一个空元组，在这种情况下，不会将任何值强制转换为常量。
- en: '[PRE111]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: Given a SELECT column expression, return a wrapping SQL expression.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 给定SELECT列表达式，返回包装的SQL表达式。
- en: Note
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This method is called during the **SQL compilation** phase of a statement, when
    rendering a SQL string. It is **not** called against specific values, and should
    not be confused with the [`TypeDecorator.process_result_value()`](#sqlalchemy.types.TypeDecorator.process_result_value
    "sqlalchemy.types.TypeDecorator.process_result_value") method, which is the more
    typical method that processes the actual value returned in a result row subsequent
    to statement execution time.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法在语句的**SQL编译**阶段调用，用于呈现SQL字符串。 它**不会**针对特定值调用，并且不应与[`TypeDecorator.process_result_value()`](#sqlalchemy.types.TypeDecorator.process_result_value
    "sqlalchemy.types.TypeDecorator.process_result_value")方法混淆，后者是处理在语句执行后返回的结果行中实际值的更典型方法。
- en: Subclasses of [`TypeDecorator`](#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")
    can override this method to provide custom column expression behavior for the
    type. This implementation will **replace** that of the underlying implementation
    type.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: '[`TypeDecorator`](#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")的子类可以重写此方法以为该类型提供自定义列表达式行为。
    该实现将**替换**底层实现类型的实现。'
- en: See the description of [`TypeEngine.column_expression()`](type_api.html#sqlalchemy.types.TypeEngine.column_expression
    "sqlalchemy.types.TypeEngine.column_expression") for a complete description of
    the method’s use.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 有关方法使用的完整描述，请参阅[`TypeEngine.column_expression()`](type_api.html#sqlalchemy.types.TypeEngine.column_expression
    "sqlalchemy.types.TypeEngine.column_expression")的描述。
- en: '[PRE112]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: A [`Comparator`](type_api.html#sqlalchemy.types.TypeEngine.Comparator "sqlalchemy.types.TypeEngine.Comparator")
    class which will apply to operations performed by owning [`ColumnElement`](sqlelement.html#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement") objects.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 一个[`Comparator`](type_api.html#sqlalchemy.types.TypeEngine.Comparator "sqlalchemy.types.TypeEngine.Comparator")类，将应用于由拥有的操作[`ColumnElement`](sqlelement.html#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement")对象执行。
- en: The [`comparator_factory`](#sqlalchemy.types.TypeDecorator.comparator_factory
    "sqlalchemy.types.TypeDecorator.comparator_factory") attribute is a hook consulted
    by the core expression system when column and SQL expression operations are performed.
    When a [`Comparator`](type_api.html#sqlalchemy.types.TypeEngine.Comparator "sqlalchemy.types.TypeEngine.Comparator")
    class is associated with this attribute, it allows custom re-definition of all
    existing operators, as well as definition of new operators. Existing operators
    include those provided by Python operator overloading such as `ColumnOperators.__add__()`
    and `ColumnOperators.__eq__()`, those provided as standard attributes of [`ColumnOperators`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators
    "sqlalchemy.sql.operators.ColumnOperators") such as `ColumnOperators.like()` and
    `ColumnOperators.in_()`.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 当在列和 SQL 表达式操作时，核心表达式系统会查询[`comparator_factory`](#sqlalchemy.types.TypeDecorator.comparator_factory
    "sqlalchemy.types.TypeDecorator.comparator_factory")属性。当与此属性关联的[`Comparator`](type_api.html#sqlalchemy.types.TypeEngine.Comparator
    "sqlalchemy.types.TypeEngine.Comparator")类时，它允许自定义重新定义所有现有运算符，以及定义新的运算符。现有运算符包括通过
    Python 运算符重载提供的`ColumnOperators.__add__()`和`ColumnOperators.__eq__()`，以及由[`ColumnOperators`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators
    "sqlalchemy.sql.operators.ColumnOperators")的标准属性提供的运算符，如`ColumnOperators.like()`和`ColumnOperators.in_()`。
- en: Rudimentary usage of this hook is allowed through simple subclassing of existing
    types, or alternatively by using [`TypeDecorator`](#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator"). See the documentation section [Redefining and
    Creating New Operators](#types-operators) for examples.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 通过简单地对现有类型进行子类化或者使用[`TypeDecorator`](#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")，可以允许对此钩子进行基本用法。请参阅文档部分[Redefining
    and Creating New Operators](#types-operators)以获取示例。
- en: '[PRE113]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: Given two values, compare them for equality.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 给定两个值，比较它们是否相等。
- en: By default this calls upon [`TypeEngine.compare_values()`](type_api.html#sqlalchemy.types.TypeEngine.compare_values
    "sqlalchemy.types.TypeEngine.compare_values") of the underlying “impl”, which
    in turn usually uses the Python equals operator `==`.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，这会调用底层“impl”的[`TypeEngine.compare_values()`](type_api.html#sqlalchemy.types.TypeEngine.compare_values
    "sqlalchemy.types.TypeEngine.compare_values")，该方法通常使用 Python 的等于运算符`==`。
- en: This function is used by the ORM to compare an original-loaded value with an
    intercepted “changed” value, to determine if a net change has occurred.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数由 ORM 用于比较原始加载的值与拦截的“更改”值，以确定是否发生了净变化。
- en: '[PRE114]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: Produce a copy of this [`TypeDecorator`](#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")
    instance.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 生成此[`TypeDecorator`](#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")实例的副本。
- en: This is a shallow copy and is provided to fulfill part of the [`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") contract. It usually does not need to be overridden
    unless the user-defined [`TypeDecorator`](#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")
    has local state that should be deep-copied.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个浅拷贝，并提供了[`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine "sqlalchemy.types.TypeEngine")合同的部分。除非用户定义的[`TypeDecorator`](#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator")具有应该被深度复制的本地状态，否则通常不需要重写它。
- en: '[PRE115]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: Return the DBAPI type object represented by this [`TypeDecorator`](#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator").
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 返回由此[`TypeDecorator`](#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")表示的
    DBAPI 类型对象。
- en: By default this calls upon [`TypeEngine.get_dbapi_type()`](type_api.html#sqlalchemy.types.TypeEngine.get_dbapi_type
    "sqlalchemy.types.TypeEngine.get_dbapi_type") of the underlying “impl”.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，这会调用底层“impl”的[`TypeEngine.get_dbapi_type()`](type_api.html#sqlalchemy.types.TypeEngine.get_dbapi_type
    "sqlalchemy.types.TypeEngine.get_dbapi_type")。
- en: '[PRE116]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: Provide a literal processing function for the given [`Dialect`](internals.html#sqlalchemy.engine.Dialect
    "sqlalchemy.engine.Dialect").
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 为给定的[`Dialect`](internals.html#sqlalchemy.engine.Dialect "sqlalchemy.engine.Dialect")提供一个字面值处理函数。
- en: This is the method that fulfills the [`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") contract for literal value conversion which normally
    occurs via the [`TypeEngine.literal_processor()`](type_api.html#sqlalchemy.types.TypeEngine.literal_processor
    "sqlalchemy.types.TypeEngine.literal_processor") method.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 这是实现通常通过[`TypeEngine.literal_processor()`](type_api.html#sqlalchemy.types.TypeEngine.literal_processor
    "sqlalchemy.types.TypeEngine.literal_processor")方法进行的字面值转换的[`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine")合同的方法。
- en: Note
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: User-defined subclasses of [`TypeDecorator`](#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") should **not** implement this method, and should
    instead implement [`TypeDecorator.process_literal_param()`](#sqlalchemy.types.TypeDecorator.process_literal_param
    "sqlalchemy.types.TypeDecorator.process_literal_param") so that the “inner” processing
    provided by the implementing type is maintained.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 用户定义的[`TypeDecorator`](#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")子类**不应该**实现这个方法，而应该实现[`TypeDecorator.process_literal_param()`](#sqlalchemy.types.TypeDecorator.process_literal_param
    "sqlalchemy.types.TypeDecorator.process_literal_param")，以便保持实现类型提供的“内部”处理。
- en: '[PRE117]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: Return a [`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine "sqlalchemy.types.TypeEngine")
    object corresponding to a dialect.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 返回对应于方言的[`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine "sqlalchemy.types.TypeEngine")对象。
- en: This is an end-user override hook that can be used to provide differing types
    depending on the given dialect. It is used by the [`TypeDecorator`](#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") implementation of [`type_engine()`](#sqlalchemy.types.TypeDecorator.type_engine
    "sqlalchemy.types.TypeDecorator.type_engine") to help determine what type should
    ultimately be returned for a given [`TypeDecorator`](#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator").
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个最终用户覆盖的钩子，可用于根据给定的方言提供不同的类型。它由[`TypeDecorator`](#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator")的[`type_engine()`](#sqlalchemy.types.TypeDecorator.type_engine
    "sqlalchemy.types.TypeDecorator.type_engine")实现使用，以帮助确定对于给定的[`TypeDecorator`](#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator")最终应该返回什么类型。
- en: By default returns `self.impl`.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下返回`self.impl`。
- en: '[PRE118]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: Receive a bound parameter value to be converted.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 接收要转换的绑定参数值。
- en: Custom subclasses of [`TypeDecorator`](#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")
    should override this method to provide custom behaviors for incoming data values.
    This method is called at **statement execution time** and is passed the literal
    Python data value which is to be associated with a bound parameter in the statement.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义的[`TypeDecorator`](#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")子类应该重写此方法，以提供传入数据值的自定义行为。此方法在**语句执行时间**调用，并传递要与语句中的绑定参数相关联的字面Python数据值。
- en: The operation could be anything desired to perform custom behavior, such as
    transforming or serializing data. This could also be used as a hook for validating
    logic.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 操作可以是任何想要执行自定义行为的内容，比如转换或序列化数据。这也可以用作验证逻辑的钩子。
- en: 'Parameters:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '`value` – Data to operate upon, of any type expected by this method in the
    subclass. Can be `None`.'
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`value` – 要操作的数据，由子类中此方法期望的任何类型。可以是`None`。'
- en: '`dialect` – the [`Dialect`](internals.html#sqlalchemy.engine.Dialect "sqlalchemy.engine.Dialect")
    in use.'
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dialect` – 正在使用的[`Dialect`](internals.html#sqlalchemy.engine.Dialect "sqlalchemy.engine.Dialect")。'
- en: See also
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Augmenting Existing Types](#types-typedecorator)'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: '[扩展现有类型](#types-typedecorator)'
- en: '[`TypeDecorator.process_result_value()`](#sqlalchemy.types.TypeDecorator.process_result_value
    "sqlalchemy.types.TypeDecorator.process_result_value")'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: '[`TypeDecorator.process_result_value()`](#sqlalchemy.types.TypeDecorator.process_result_value
    "sqlalchemy.types.TypeDecorator.process_result_value")'
- en: '[PRE119]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: Receive a literal parameter value to be rendered inline within a statement.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 接收要在语句中内联呈现的字面参数值。
- en: Note
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This method is called during the **SQL compilation** phase of a statement, when
    rendering a SQL string. Unlike other SQL compilation methods, it is passed a specific
    Python value to be rendered as a string. However it should not be confused with
    the [`TypeDecorator.process_bind_param()`](#sqlalchemy.types.TypeDecorator.process_bind_param
    "sqlalchemy.types.TypeDecorator.process_bind_param") method, which is the more
    typical method that processes the actual value passed to a particular parameter
    at statement execution time.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 在语句的**SQL编译**阶段调用此方法，当呈现SQL字符串时。与其他SQL编译方法不同，它会传递一个具体的Python值，以字符串形式呈现。但是，它不应与[`TypeDecorator.process_bind_param()`](#sqlalchemy.types.TypeDecorator.process_bind_param
    "sqlalchemy.types.TypeDecorator.process_bind_param")方法混淆，后者是处理在语句执行时传递给特定参数的实际值的更典型方法。
- en: Custom subclasses of [`TypeDecorator`](#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")
    should override this method to provide custom behaviors for incoming data values
    that are in the special case of being rendered as literals.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义的[`TypeDecorator`](#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")子类应该重写这个方法，以提供特定情况下的自定义行为，用于处理作为字面值呈现的传入数据值。
- en: The returned string will be rendered into the output string.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 返回的字符串将呈现到输出字符串中。
- en: '[PRE120]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: Receive a result-row column value to be converted.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 接收要转换的结果行列值。
- en: Custom subclasses of [`TypeDecorator`](#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")
    should override this method to provide custom behaviors for data values being
    received in result rows coming from the database. This method is called at **result
    fetching time** and is passed the literal Python data value that’s extracted from
    a database result row.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义的[`TypeDecorator`](#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")子类应重写此方法，以提供从数据库返回的结果行中接收的数据值的自定义行为。此方法在**结果获取时间**调用，并传递从数据库结果行中提取的字面Python数据值。
- en: The operation could be anything desired to perform custom behavior, such as
    transforming or deserializing data.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 操作可以是任何所需的自定义行为，例如转换或反序列化数据。
- en: 'Parameters:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '`value` – Data to operate upon, of any type expected by this method in the
    subclass. Can be `None`.'
  id: totrans-476
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`value` – 要操作的数据，子类中此方法所期望的任何类型的数据。可以为`None`。'
- en: '`dialect` – the [`Dialect`](internals.html#sqlalchemy.engine.Dialect "sqlalchemy.engine.Dialect")
    in use.'
  id: totrans-477
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dialect` – 正在使用的[`Dialect`](internals.html#sqlalchemy.engine.Dialect "sqlalchemy.engine.Dialect")。'
- en: See also
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Augmenting Existing Types](#types-typedecorator)'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: '[增强现有类型](#types-typedecorator)'
- en: '[`TypeDecorator.process_bind_param()`](#sqlalchemy.types.TypeDecorator.process_bind_param
    "sqlalchemy.types.TypeDecorator.process_bind_param")'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: '[`TypeDecorator.process_bind_param()`](#sqlalchemy.types.TypeDecorator.process_bind_param
    "sqlalchemy.types.TypeDecorator.process_bind_param")'
- en: '[PRE121]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: Provide a result value processing function for the given [`Dialect`](internals.html#sqlalchemy.engine.Dialect
    "sqlalchemy.engine.Dialect").
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 为给定的[`Dialect`](internals.html#sqlalchemy.engine.Dialect "sqlalchemy.engine.Dialect")提供结果值处理函数。
- en: This is the method that fulfills the [`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") contract for bound value conversion which normally
    occurs via the [`TypeEngine.result_processor()`](type_api.html#sqlalchemy.types.TypeEngine.result_processor
    "sqlalchemy.types.TypeEngine.result_processor") method.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 这是满足绑定值转换的[`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine "sqlalchemy.types.TypeEngine")契约的方法，通常通过[`TypeEngine.result_processor()`](type_api.html#sqlalchemy.types.TypeEngine.result_processor
    "sqlalchemy.types.TypeEngine.result_processor")方法进行。
- en: Note
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: User-defined subclasses of [`TypeDecorator`](#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") should **not** implement this method, and should
    instead implement [`TypeDecorator.process_result_value()`](#sqlalchemy.types.TypeDecorator.process_result_value
    "sqlalchemy.types.TypeDecorator.process_result_value") so that the “inner” processing
    provided by the implementing type is maintained.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 用户定义的[`TypeDecorator`](#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")子类**不应**实现此方法，而应该实现[`TypeDecorator.process_result_value()`](#sqlalchemy.types.TypeDecorator.process_result_value
    "sqlalchemy.types.TypeDecorator.process_result_value")，以便维护实现类型提供的“内部”处理。
- en: 'Parameters:'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 参数：
- en: '`dialect` – Dialect instance in use.'
  id: totrans-487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dialect` – 正在使用的方言实例。'
- en: '`coltype` – A SQLAlchemy data type'
  id: totrans-488
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`coltype` – 一个SQLAlchemy数据类型。'
- en: '[PRE122]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: A sorting function that can be passed as the key to sorted.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 一个可作为排序关键字传递给`sorted`的排序函数。
- en: The default value of `None` indicates that the values stored by this type are
    self-sorting.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: '`None`的默认值表示此类型存储的值是自排序的。'
- en: New in version 1.3.8.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 版本 1.3.8 中新增。
- en: '[PRE123]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: Return a dialect-specific [`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") instance for this [`TypeDecorator`](#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator").
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 为此[`TypeDecorator`](#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")返回一个特定于方言的[`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine")实例。
- en: In most cases this returns a dialect-adapted form of the [`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") type represented by `self.impl`. Makes usage of
    `dialect_impl()`. Behavior can be customized here by overriding [`load_dialect_impl()`](#sqlalchemy.types.TypeDecorator.load_dialect_impl
    "sqlalchemy.types.TypeDecorator.load_dialect_impl").
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，此方法返回由`self.impl`表示的[`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine")类型的方言适配形式。使用`dialect_impl()`。可以通过重写[`load_dialect_impl()`](#sqlalchemy.types.TypeDecorator.load_dialect_impl
    "sqlalchemy.types.TypeDecorator.load_dialect_impl")来在此处自定义行为。
- en: TypeDecorator Recipes
  id: totrans-496
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TypeDecorator 示例
- en: A few key [`TypeDecorator`](#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")
    recipes follow.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些关键的[`TypeDecorator`](#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")示例。
- en: '### Coercing Encoded Strings to Unicode'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: '### 将编码字符串强制转换为Unicode'
- en: A common source of confusion regarding the [`Unicode`](type_basics.html#sqlalchemy.types.Unicode
    "sqlalchemy.types.Unicode") type is that it is intended to deal *only* with Python
    `unicode` objects on the Python side, meaning values passed to it as bind parameters
    must be of the form `u'some string'` if using Python 2 and not 3. The encoding/decoding
    functions it performs are only to suit what the DBAPI in use requires, and are
    primarily a private implementation detail.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Unicode`](type_basics.html#sqlalchemy.types.Unicode "sqlalchemy.types.Unicode")
    类型常见的一个令人困惑的地方是，它仅在 Python 一侧处理 Python `unicode` 对象，这意味着作为绑定参数传递给它的值必须是 `u''some
    string''` 的形式，如果使用的是 Python 2 而不是 3。它执行的编码/解码函数仅适合于所使用的 DBAPI 所需，并且主要是一个私有的实现细节。'
- en: 'The use case of a type that can safely receive Python bytestrings, that is
    strings that contain non-ASCII characters and are not `u''''` objects in Python
    2, can be achieved using a [`TypeDecorator`](#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")
    which coerces as needed:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 [`TypeDecorator`](#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")
    ，可以实现安全接收 Python 字节串的类型的用例，即包含非 ASCII 字符并且在 Python 2 中不是 `u''` 对象的字符串，必要时进行强制转换：
- en: '[PRE124]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: Rounding Numerics
  id: totrans-502
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数字四舍五入
- en: 'Some database connectors like those of SQL Server choke if a Decimal is passed
    with too many decimal places. Here’s a recipe that rounds them down:'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 一些数据库连接器（如 SQL Server 的连接器）如果传递的 Decimal 有太多的小数位数，会出现问题。以下是将其四舍五入的方法：
- en: '[PRE125]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: Store Timezone Aware Timestamps as Timezone Naive UTC
  id: totrans-505
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将时区感知时间戳存储为时区无关的 UTC
- en: 'Timestamps in databases should always be stored in a timezone-agnostic way.
    For most databases, this means ensuring a timestamp is first in the UTC timezone
    before it is stored, then storing it as timezone-naive (that is, without any timezone
    associated with it; UTC is assumed to be the “implicit” timezone). Alternatively,
    database-specific types like PostgreSQLs “TIMESTAMP WITH TIMEZONE” are often preferred
    for their richer functionality; however, storing as plain UTC will work on all
    databases and drivers. When a timezone-intelligent database type is not an option
    or is not preferred, the [`TypeDecorator`](#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")
    can be used to create a datatype that convert timezone aware timestamps into timezone
    naive and back again. Below, Python’s built-in `datetime.timezone.utc` timezone
    is used to normalize and denormalize:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库中的时间戳应始终以与时区无关的方式存储。对于大多数数据库来说，这意味着确保时间戳首先处于 UTC 时区，然后将其存储为时区无关的（即，没有与之关联的任何时区；UTC
    被假定为“隐式”时区）。另外，通常首选数据库特定类型，如 PostgreSQL 的 “TIMESTAMP WITH TIMEZONE” ，因为其功能更丰富；但是，存储为纯
    UTC 将在所有数据库和驱动程序上工作。当时区智能数据库类型不是一个选择或不被首选时，可以使用 [`TypeDecorator`](#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") 创建一个将时区感知时间戳转换为时区无关的数据类型，并反之亦然。下面，Python 的内置
    `datetime.timezone.utc` 时区用于标准化和非标准化：
- en: '[PRE126]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '### Backend-agnostic GUID Type'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: '### 与后端无关的 GUID 类型'
- en: Note
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Since version 2.0 the built-in [`Uuid`](type_basics.html#sqlalchemy.types.Uuid
    "sqlalchemy.types.Uuid") type that behaves similarly should be preferred. This
    example is presented just as an example of a type decorator that receives and
    returns python objects.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 自版本 2.0 起，内置的 [`Uuid`](type_basics.html#sqlalchemy.types.Uuid "sqlalchemy.types.Uuid")
    类型行为类似应该优先考虑。这个示例只是一个接收并返回 Python 对象的类型装饰器的示例。
- en: 'Receives and returns Python uuid() objects. Uses the PG UUID type when using
    PostgreSQL, UNIQUEIDENTIFIER when using MSSQL, CHAR(32) on other backends, storing
    them in stringified format. The `GUIDHyphens` version stores the value with hyphens
    instead of just the hex string, using a CHAR(36) type:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 接收和返回 Python 的 uuid() 对象。在使用 PostgreSQL 时使用 PG UUID 类型，在使用 MSSQL 时使用 UNIQUEIDENTIFIER，在其他后端使用
    CHAR(32)，以字符串格式存储。`GUIDHyphens` 版本使用带连字符的方式存储值，而不仅仅是十六进制字符串，使用 CHAR(36) 类型：
- en: '[PRE127]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: Linking Python `uuid.UUID` to the Custom Type for ORM mappings
  id: totrans-513
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 将 Python `uuid.UUID` 链接到 ORM 映射的自定义类型
- en: 'When declaring ORM mappings using [Annotated Declarative Table](../orm/declarative_tables.html#orm-declarative-mapped-column)
    mappings, the custom `GUID` type defined above may be associated with the Python
    `uuid.UUID` datatype by adding it to the [type annotation map](../orm/declarative_tables.html#orm-declarative-mapped-column-type-map),
    which is typically defined on the [`DeclarativeBase`](../orm/mapping_api.html#sqlalchemy.orm.DeclarativeBase
    "sqlalchemy.orm.DeclarativeBase") class:'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 [注释的声明性表](../orm/declarative_tables.html#orm-declarative-mapped-column)
    进行 ORM 映射时，可以通过将其添加到 [类型注释映射](../orm/declarative_tables.html#orm-declarative-mapped-column-type-map)
    中将上面定义的自定义 `GUID` 类型与 Python `uuid.UUID` 数据类型关联起来，该映射通常在 [`DeclarativeBase`](../orm/mapping_api.html#sqlalchemy.orm.DeclarativeBase
    "sqlalchemy.orm.DeclarativeBase") 类上定义：
- en: '[PRE128]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'With the above configuration, ORM mapped classes which extend from `Base` may
    refer to Python `uuid.UUID` in annotations which will make use of `GUID` automatically:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上述配置，从 `Base` 扩展的 ORM 映射类可以在注释中引用 Python `uuid.UUID`，这将自动使用 `GUID`：
- en: '[PRE129]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: See also
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Customizing the Type Map](../orm/declarative_tables.html#orm-declarative-mapped-column-type-map)'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: '[自定义类型映射](../orm/declarative_tables.html#orm-declarative-mapped-column-type-map)'
- en: Marshal JSON Strings
  id: totrans-520
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编组 JSON 字符串
- en: 'This type uses `simplejson` to marshal Python data structures to/from JSON.
    Can be modified to use Python’s builtin json encoder:'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 此类型使用 `simplejson` 将 Python 数据结构编组到 JSON 中。可以修改为使用 Python 的内置 json 编码器：
- en: '[PRE130]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: Adding Mutability
  id: totrans-523
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加可变性
- en: 'The ORM by default will not detect “mutability” on such a type as above - meaning,
    in-place changes to values will not be detected and will not be flushed. Without
    further steps, you instead would need to replace the existing value with a new
    one on each parent object to detect changes:'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，ORM 不会检测上述类型的“可变性” - 这意味着对值的原地更改不会被检测到也不会被刷新。在没有进一步步骤的情况下，您需要在每个父对象上用新值替换现有值才能检测到更改：
- en: '[PRE131]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'The above limitation may be fine, as many applications may not require that
    the values are ever mutated once created. For those which do have this requirement,
    support for mutability is best applied using the `sqlalchemy.ext.mutable` extension.
    For a dictionary-oriented JSON structure, we can apply this as:'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 上述限制可能是可以接受的，因为许多应用程序可能不需要在创建后对值进行修改。对于那些确实具有此要求的应用程序，最好使用 `sqlalchemy.ext.mutable`
    扩展来支持可变性。对于以字典为导向的 JSON 结构，我们可以这样应用：
- en: '[PRE132]'
  id: totrans-527
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: See also
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Mutation Tracking](../orm/extensions/mutable.html)'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: '[变异跟踪](../orm/extensions/mutable.html)'
- en: Dealing with Comparison Operations
  id: totrans-530
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 处理比较操作
- en: 'The default behavior of [`TypeDecorator`](#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")
    is to coerce the “right hand side” of any expression into the same type. For a
    type like JSON, this means that any operator used must make sense in terms of
    JSON. For some cases, users may wish for the type to behave like JSON in some
    circumstances, and as plain text in others. One example is if one wanted to handle
    the LIKE operator for the JSON type. LIKE makes no sense against a JSON structure,
    but it does make sense against the underlying textual representation. To get at
    this with a type like `JSONEncodedDict`, we need to **coerce** the column to a
    textual form using [`cast()`](sqlelement.html#sqlalchemy.sql.expression.cast "sqlalchemy.sql.expression.cast")
    or [`type_coerce()`](sqlelement.html#sqlalchemy.sql.expression.type_coerce "sqlalchemy.sql.expression.type_coerce")
    before attempting to use this operator:'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: '[`TypeDecorator`](#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")
    的默认行为是将任何表达式的“右侧”强制转换为相同的类型。对于像 JSON 这样的类型，这意味着任何使用的运算符都必须符合 JSON 的意义。对于一些情况，用户可能希望该类型在某些情况下像
    JSON 一样行事，在其他情况下像纯文本一样行事。一个例子是，如果一个人希望处理 JSON 类型的 LIKE 运算符。LIKE 对 JSON 结构毫无意义，但对底层文本表示是有意义的。要使用类似于
    `JSONEncodedDict` 这样的类型来处理这个问题，我们需要在尝试使用此运算符之前将列强制转换为文本形式，使用 [`cast()`](sqlelement.html#sqlalchemy.sql.expression.cast
    "sqlalchemy.sql.expression.cast") 或 [`type_coerce()`](sqlelement.html#sqlalchemy.sql.expression.type_coerce
    "sqlalchemy.sql.expression.type_coerce")：'
- en: '[PRE133]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[`TypeDecorator`](#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")
    provides a built-in system for working up type translations like these based on
    operators. If we wanted to frequently use the LIKE operator with our JSON object
    interpreted as a string, we can build it into the type by overriding the [`TypeDecorator.coerce_compared_value()`](#sqlalchemy.types.TypeDecorator.coerce_compared_value
    "sqlalchemy.types.TypeDecorator.coerce_compared_value") method:'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: '[`TypeDecorator`](#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")
    提供了一个内置系统，用于基于运算符工作的类型转换，例如这些。如果我们想要频繁地使用 LIKE 运算符，并将我们的 JSON 对象解释为字符串，我们可以通过重写[`TypeDecorator.coerce_compared_value()`](#sqlalchemy.types.TypeDecorator.coerce_compared_value
    "sqlalchemy.types.TypeDecorator.coerce_compared_value") 方法将其构建到类型中：'
- en: '[PRE134]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: Above is just one approach to handling an operator like “LIKE”. Other applications
    may wish to raise `NotImplementedError` for operators that have no meaning with
    a JSON object such as “LIKE”, rather than automatically coercing to text.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 上述只是处理像“LIKE”这样的运算符的一种方法。其他应用程序可能希望对于没有与 JSON 对象具有意义的运算符（如“LIKE”）引发`NotImplementedError`，而不是自动强制转换为文本。
- en: '### Coercing Encoded Strings to Unicode'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: '### 将编码字符串强制转换为 Unicode'
- en: A common source of confusion regarding the [`Unicode`](type_basics.html#sqlalchemy.types.Unicode
    "sqlalchemy.types.Unicode") type is that it is intended to deal *only* with Python
    `unicode` objects on the Python side, meaning values passed to it as bind parameters
    must be of the form `u'some string'` if using Python 2 and not 3. The encoding/decoding
    functions it performs are only to suit what the DBAPI in use requires, and are
    primarily a private implementation detail.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 [`Unicode`](type_basics.html#sqlalchemy.types.Unicode "sqlalchemy.types.Unicode")
    类型的一个常见困惑是，它只打算在 Python 侧处理 Python `unicode` 对象，这意味着作为绑定参数传递给它的值必须是`u'some string'`
    的形式，如果使用的是 Python 2 而不是 3。它执行的编码/解码函数仅适应所使用的 DBAPI 需要，主要是私有实现细节。
- en: 'The use case of a type that can safely receive Python bytestrings, that is
    strings that contain non-ASCII characters and are not `u''''` objects in Python
    2, can be achieved using a [`TypeDecorator`](#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")
    which coerces as needed:'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用[`TypeDecorator`](#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")
    实现根据需要进行转换的类型的使用案例，该类型可以安全地接收 Python 字节串，即包含非 ASCII 字符并且不是 Python 2 中的`u''`对象的字符串：
- en: '[PRE135]'
  id: totrans-539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: Rounding Numerics
  id: totrans-540
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 四舍五入数值
- en: 'Some database connectors like those of SQL Server choke if a Decimal is passed
    with too many decimal places. Here’s a recipe that rounds them down:'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 如果传递的 Decimal 具有太多小数位数，则某些数据库连接器（例如 SQL Server 的连接器）会中断。下面是一个将其舍入的方法：
- en: '[PRE136]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: Store Timezone Aware Timestamps as Timezone Naive UTC
  id: totrans-543
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将时区感知时间戳存储为时区无关的 UTC
- en: 'Timestamps in databases should always be stored in a timezone-agnostic way.
    For most databases, this means ensuring a timestamp is first in the UTC timezone
    before it is stored, then storing it as timezone-naive (that is, without any timezone
    associated with it; UTC is assumed to be the “implicit” timezone). Alternatively,
    database-specific types like PostgreSQLs “TIMESTAMP WITH TIMEZONE” are often preferred
    for their richer functionality; however, storing as plain UTC will work on all
    databases and drivers. When a timezone-intelligent database type is not an option
    or is not preferred, the [`TypeDecorator`](#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")
    can be used to create a datatype that convert timezone aware timestamps into timezone
    naive and back again. Below, Python’s built-in `datetime.timezone.utc` timezone
    is used to normalize and denormalize:'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库中的时间戳应始终以时区不可知的方式存储。对于大多数数据库来说，这意味着确保时间戳首先在 UTC 时区中，然后将其存储为时区无关的（即，没有与之关联的任何时区；假定
    UTC 是“隐式”时区）。或者，通常首选像 PostgreSQL 的“带时区的时间戳”这样的数据库特定类型，因为其更丰富的功能；然而，将其存储为纯 UTC
    将适用于所有数据库和驱动程序。当时区智能型数据库类型不可用或不被偏爱时，[`TypeDecorator`](#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") 可用于创建将时区感知时间戳转换为时区无关时间戳并再次转换的数据类型。在下面的示例中，Python
    的内置`datetime.timezone.utc` 时区用于规范化和反规范化：
- en: '[PRE137]'
  id: totrans-545
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '### Backend-agnostic GUID Type'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: '### 跨后端 GUID 类型'
- en: Note
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Since version 2.0 the built-in [`Uuid`](type_basics.html#sqlalchemy.types.Uuid
    "sqlalchemy.types.Uuid") type that behaves similarly should be preferred. This
    example is presented just as an example of a type decorator that receives and
    returns python objects.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 自 2.0 版本起，内置的[`Uuid`](type_basics.html#sqlalchemy.types.Uuid "sqlalchemy.types.Uuid")
    类型的行为类似的类型应优先考虑。此示例仅作为一个接收并返回 Python 对象的类型装饰器的示例。
- en: 'Receives and returns Python uuid() objects. Uses the PG UUID type when using
    PostgreSQL, UNIQUEIDENTIFIER when using MSSQL, CHAR(32) on other backends, storing
    them in stringified format. The `GUIDHyphens` version stores the value with hyphens
    instead of just the hex string, using a CHAR(36) type:'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 接收和返回 Python `uuid()` 对象。在使用 PostgreSQL 时使用 PG UUID 类型，在使用 MSSQL 时使用 UNIQUEIDENTIFIER，在其他后端上使用
    CHAR(32)，将其存储为字符串格式。`GUIDHyphens` 版本使用带连字符的值而不仅仅是十六进制字符串，使用 CHAR(36) 类型存储：
- en: '[PRE138]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: Linking Python `uuid.UUID` to the Custom Type for ORM mappings
  id: totrans-551
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 将 Python `uuid.UUID` 链接到 ORM 映射的自定义类型
- en: 'When declaring ORM mappings using [Annotated Declarative Table](../orm/declarative_tables.html#orm-declarative-mapped-column)
    mappings, the custom `GUID` type defined above may be associated with the Python
    `uuid.UUID` datatype by adding it to the [type annotation map](../orm/declarative_tables.html#orm-declarative-mapped-column-type-map),
    which is typically defined on the [`DeclarativeBase`](../orm/mapping_api.html#sqlalchemy.orm.DeclarativeBase
    "sqlalchemy.orm.DeclarativeBase") class:'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 [注释声明的声明性表](../orm/declarative_tables.html#orm-declarative-mapped-column)
    映射来声明 ORM 映射时，可以通过将其添加到 [类型注释映射](../orm/declarative_tables.html#orm-declarative-mapped-column-type-map)
    中，将上面定义的自定义`GUID`类型与 Python `uuid.UUID` 数据类型关联起来，该类型通常定义在 [`DeclarativeBase`](../orm/mapping_api.html#sqlalchemy.orm.DeclarativeBase
    "sqlalchemy.orm.DeclarativeBase") 类上：
- en: '[PRE139]'
  id: totrans-553
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'With the above configuration, ORM mapped classes which extend from `Base` may
    refer to Python `uuid.UUID` in annotations which will make use of `GUID` automatically:'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 有了上述配置，从`Base`继承的 ORM 映射类可以在注释中引用 Python `uuid.UUID`，这将自动使用`GUID`：
- en: '[PRE140]'
  id: totrans-555
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: See also
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Customizing the Type Map](../orm/declarative_tables.html#orm-declarative-mapped-column-type-map)'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: '[自定义类型映射](../orm/declarative_tables.html#orm-declarative-mapped-column-type-map)'
- en: Linking Python `uuid.UUID` to the Custom Type for ORM mappings
  id: totrans-558
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 将 Python `uuid.UUID` 链接到 ORM 映射的自定义类型
- en: 'When declaring ORM mappings using [Annotated Declarative Table](../orm/declarative_tables.html#orm-declarative-mapped-column)
    mappings, the custom `GUID` type defined above may be associated with the Python
    `uuid.UUID` datatype by adding it to the [type annotation map](../orm/declarative_tables.html#orm-declarative-mapped-column-type-map),
    which is typically defined on the [`DeclarativeBase`](../orm/mapping_api.html#sqlalchemy.orm.DeclarativeBase
    "sqlalchemy.orm.DeclarativeBase") class:'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 [注释声明的声明性表](../orm/declarative_tables.html#orm-declarative-mapped-column)
    映射来声明 ORM 映射时，可以通过将其添加到 [类型注释映射](../orm/declarative_tables.html#orm-declarative-mapped-column-type-map)
    中，将上面定义的自定义`GUID`类型与 Python `uuid.UUID` 数据类型关联起来，该类型通常定义在 [`DeclarativeBase`](../orm/mapping_api.html#sqlalchemy.orm.DeclarativeBase
    "sqlalchemy.orm.DeclarativeBase") 类上：
- en: '[PRE141]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'With the above configuration, ORM mapped classes which extend from `Base` may
    refer to Python `uuid.UUID` in annotations which will make use of `GUID` automatically:'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 有了上述配置，从`Base`继承的 ORM 映射类可以在注释中引用 Python `uuid.UUID`，这将自动使用`GUID`：
- en: '[PRE142]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: See also
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Customizing the Type Map](../orm/declarative_tables.html#orm-declarative-mapped-column-type-map)'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: '[自定义类型映射](../orm/declarative_tables.html#orm-declarative-mapped-column-type-map)'
- en: Marshal JSON Strings
  id: totrans-565
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编组 JSON 字符串
- en: 'This type uses `simplejson` to marshal Python data structures to/from JSON.
    Can be modified to use Python’s builtin json encoder:'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 此类型使用`simplejson`将 Python 数据结构编组为/从 JSON。可以修改为使用 Python 的内置 json 编码器：
- en: '[PRE143]'
  id: totrans-567
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: Adding Mutability
  id: totrans-568
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加可变性
- en: 'The ORM by default will not detect “mutability” on such a type as above - meaning,
    in-place changes to values will not be detected and will not be flushed. Without
    further steps, you instead would need to replace the existing value with a new
    one on each parent object to detect changes:'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: ORM 默认情况下不会检测上述类型的“可变性”——这意味着对值的原地更改不会被检测到也不会被刷新。如果没有进一步的步骤，您将需要在每个父对象上用新对象替换现有值以检测更改：
- en: '[PRE144]'
  id: totrans-570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'The above limitation may be fine, as many applications may not require that
    the values are ever mutated once created. For those which do have this requirement,
    support for mutability is best applied using the `sqlalchemy.ext.mutable` extension.
    For a dictionary-oriented JSON structure, we can apply this as:'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 以上限制可能是可以接受的，因为许多应用程序可能不需要在创建后对值进行变异。对于那些确实具有此要求的应用程序，最好使用`sqlalchemy.ext.mutable`扩展来支持可变性。对于以字典为导向的
    JSON 结构，我们可以这样应用：
- en: '[PRE145]'
  id: totrans-572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: See also
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Mutation Tracking](../orm/extensions/mutable.html)'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: '[变异追踪](../orm/extensions/mutable.html)'
- en: Dealing with Comparison Operations
  id: totrans-575
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 处理比较操作
- en: 'The default behavior of [`TypeDecorator`](#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")
    is to coerce the “right hand side” of any expression into the same type. For a
    type like JSON, this means that any operator used must make sense in terms of
    JSON. For some cases, users may wish for the type to behave like JSON in some
    circumstances, and as plain text in others. One example is if one wanted to handle
    the LIKE operator for the JSON type. LIKE makes no sense against a JSON structure,
    but it does make sense against the underlying textual representation. To get at
    this with a type like `JSONEncodedDict`, we need to **coerce** the column to a
    textual form using [`cast()`](sqlelement.html#sqlalchemy.sql.expression.cast "sqlalchemy.sql.expression.cast")
    or [`type_coerce()`](sqlelement.html#sqlalchemy.sql.expression.type_coerce "sqlalchemy.sql.expression.type_coerce")
    before attempting to use this operator:'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: '[`TypeDecorator`](#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")的默认行为是将任何表达式的“右手边”强制转换为相同的类型。对于JSON之类的类型，这意味着任何使用的运算符都必须在JSON的术语中有意义。对于某些情况，用户可能希望类型在某些情况下像JSON一样行为，在其他情况下像纯文本一样行为。一个例子是如果想要处理JSON类型的LIKE运算符。LIKE对JSON结构没有意义，但对底层文本表示有意义。要通过`JSONEncodedDict`类型实现这一点，我们需要在尝试使用此运算符之前使用[`cast()`](sqlelement.html#sqlalchemy.sql.expression.cast
    "sqlalchemy.sql.expression.cast")或[`type_coerce()`](sqlelement.html#sqlalchemy.sql.expression.type_coerce
    "sqlalchemy.sql.expression.type_coerce")将列强制转换为文本形式：'
- en: '[PRE146]'
  id: totrans-577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[`TypeDecorator`](#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")
    provides a built-in system for working up type translations like these based on
    operators. If we wanted to frequently use the LIKE operator with our JSON object
    interpreted as a string, we can build it into the type by overriding the [`TypeDecorator.coerce_compared_value()`](#sqlalchemy.types.TypeDecorator.coerce_compared_value
    "sqlalchemy.types.TypeDecorator.coerce_compared_value") method:'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: '[`TypeDecorator`](#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")提供了一种基于运算符的类型翻译的内置系统。如果我们希望经常使用LIKE运算符，将我们的JSON对象解释为字符串，我们可以通过重写[`TypeDecorator.coerce_compared_value()`](#sqlalchemy.types.TypeDecorator.coerce_compared_value
    "sqlalchemy.types.TypeDecorator.coerce_compared_value")方法将其构建到类型中：'
- en: '[PRE147]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: Above is just one approach to handling an operator like “LIKE”. Other applications
    may wish to raise `NotImplementedError` for operators that have no meaning with
    a JSON object such as “LIKE”, rather than automatically coercing to text.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 上面只是处理诸如“LIKE”之类运算符的一种方法。其他应用程序可能希望对于JSON对象没有意义的运算符（如“LIKE”）引发`NotImplementedError`，而不是自动强制转换为文本。
- en: Adding Mutability
  id: totrans-581
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加可变性
- en: 'The ORM by default will not detect “mutability” on such a type as above - meaning,
    in-place changes to values will not be detected and will not be flushed. Without
    further steps, you instead would need to replace the existing value with a new
    one on each parent object to detect changes:'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: ORM默认不会检测上述类型的“可变性”——这意味着对值的原地更改不会被检测到，也不会被刷新。如果没有进一步的步骤，您将需要在每个父对象上用新值替换现有值以检测更改：
- en: '[PRE148]'
  id: totrans-583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'The above limitation may be fine, as many applications may not require that
    the values are ever mutated once created. For those which do have this requirement,
    support for mutability is best applied using the `sqlalchemy.ext.mutable` extension.
    For a dictionary-oriented JSON structure, we can apply this as:'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 以上限制可能是可以接受的，因为许多应用程序可能不要求一旦创建就对值进行突变。对于那些具有此要求的应用程序，最好使用`sqlalchemy.ext.mutable`扩展来支持可变性。对于面向字典的JSON结构，我们可以这样应用：
- en: '[PRE149]'
  id: totrans-585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: See also
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 参见
- en: '[Mutation Tracking](../orm/extensions/mutable.html)'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: '[突变跟踪](../orm/extensions/mutable.html)'
- en: Dealing with Comparison Operations
  id: totrans-588
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 处理比较操作
- en: 'The default behavior of [`TypeDecorator`](#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")
    is to coerce the “right hand side” of any expression into the same type. For a
    type like JSON, this means that any operator used must make sense in terms of
    JSON. For some cases, users may wish for the type to behave like JSON in some
    circumstances, and as plain text in others. One example is if one wanted to handle
    the LIKE operator for the JSON type. LIKE makes no sense against a JSON structure,
    but it does make sense against the underlying textual representation. To get at
    this with a type like `JSONEncodedDict`, we need to **coerce** the column to a
    textual form using [`cast()`](sqlelement.html#sqlalchemy.sql.expression.cast "sqlalchemy.sql.expression.cast")
    or [`type_coerce()`](sqlelement.html#sqlalchemy.sql.expression.type_coerce "sqlalchemy.sql.expression.type_coerce")
    before attempting to use this operator:'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: '[`TypeDecorator`](#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")的默认行为是将任何表达式的“右侧”强制转换为相同类型。对于像JSON这样的类型，这意味着任何使用的运算符都必须从JSON的角度来看是有意义的。对于某些情况，用户可能希望该类型在某些情况下表现得像JSON，在其他情况下表现为纯文本。一个例子是，如果一个人希望处理JSON类型的LIKE运算符。对于JSON结构来说，LIKE没有意义，但对于基础文本表示来说是有意义的。要想在像`JSONEncodedDict`这样的类型中实现这一点，我们需要使用[`cast()`](sqlelement.html#sqlalchemy.sql.expression.cast
    "sqlalchemy.sql.expression.cast")或[`type_coerce()`](sqlelement.html#sqlalchemy.sql.expression.type_coerce
    "sqlalchemy.sql.expression.type_coerce")将列强制转换为文本形式，然后再尝试使用此运算符：'
- en: '[PRE150]'
  id: totrans-590
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '[`TypeDecorator`](#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")
    provides a built-in system for working up type translations like these based on
    operators. If we wanted to frequently use the LIKE operator with our JSON object
    interpreted as a string, we can build it into the type by overriding the [`TypeDecorator.coerce_compared_value()`](#sqlalchemy.types.TypeDecorator.coerce_compared_value
    "sqlalchemy.types.TypeDecorator.coerce_compared_value") method:'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: '[`TypeDecorator`](#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")提供了一个基于运算符的系统，用于处理此类类型转换。如果我们想要频繁地使用LIKE运算符，并将我们的JSON对象解释为字符串，我们可以通过重写[`TypeDecorator.coerce_compared_value()`](#sqlalchemy.types.TypeDecorator.coerce_compared_value
    "sqlalchemy.types.TypeDecorator.coerce_compared_value")方法将其构建到类型中。'
- en: '[PRE151]'
  id: totrans-592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: Above is just one approach to handling an operator like “LIKE”. Other applications
    may wish to raise `NotImplementedError` for operators that have no meaning with
    a JSON object such as “LIKE”, rather than automatically coercing to text.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 上面只是处理“LIKE”运算符的一种方法。其他应用程序可能希望对于JSON对象没有意义的运算符（如“LIKE”）抛出`NotImplementedError`，而不是自动转换为文本。
- en: '## Applying SQL-level Bind/Result Processing'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: '## 应用SQL级别的绑定/结果处理'
- en: As seen in the section [Augmenting Existing Types](#types-typedecorator), SQLAlchemy
    allows Python functions to be invoked both when parameters are sent to a statement,
    as well as when result rows are loaded from the database, to apply transformations
    to the values as they are sent to or from the database. It is also possible to
    define SQL-level transformations as well. The rationale here is when only the
    relational database contains a particular series of functions that are necessary
    to coerce incoming and outgoing data between an application and persistence format.
    Examples include using database-defined encryption/decryption functions, as well
    as stored procedures that handle geographic data.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 如在[扩展现有类型](#types-typedecorator)部分所示，SQLAlchemy允许在向语句发送参数以及从数据库加载结果行时调用Python函数，以对值进行转换，使其在发送到数据库时或从数据库加载时进行转换。还可以定义SQL级别的转换。这里的理念是，当只有关系数据库包含特定系列的函数时，这些函数对于在应用程序和持久性格式之间转换传入和传出数据是必要的。示例包括使用数据库定义的加密/解密函数，以及处理地理数据的存储过程。
- en: 'Any [`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine "sqlalchemy.types.TypeEngine"),
    [`UserDefinedType`](#sqlalchemy.types.UserDefinedType "sqlalchemy.types.UserDefinedType")
    or [`TypeDecorator`](#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")
    subclass can include implementations of [`TypeEngine.bind_expression()`](type_api.html#sqlalchemy.types.TypeEngine.bind_expression
    "sqlalchemy.types.TypeEngine.bind_expression") and/or [`TypeEngine.column_expression()`](type_api.html#sqlalchemy.types.TypeEngine.column_expression
    "sqlalchemy.types.TypeEngine.column_expression"), which when defined to return
    a non-`None` value should return a [`ColumnElement`](sqlelement.html#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement") expression to be injected into the
    SQL statement, either surrounding bound parameters or a column expression. For
    example, to build a `Geometry` type which will apply the PostGIS function `ST_GeomFromText`
    to all outgoing values and the function `ST_AsText` to all incoming data, we can
    create our own subclass of [`UserDefinedType`](#sqlalchemy.types.UserDefinedType
    "sqlalchemy.types.UserDefinedType") which provides these methods in conjunction
    with [`func`](sqlelement.html#sqlalchemy.sql.expression.func "sqlalchemy.sql.expression.func"):'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 任何[`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine "sqlalchemy.types.TypeEngine")、[`UserDefinedType`](#sqlalchemy.types.UserDefinedType
    "sqlalchemy.types.UserDefinedType")或[`TypeDecorator`](#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator")子类都可以包含[`TypeEngine.bind_expression()`](type_api.html#sqlalchemy.types.TypeEngine.bind_expression
    "sqlalchemy.types.TypeEngine.bind_expression")和/或[`TypeEngine.column_expression()`](type_api.html#sqlalchemy.types.TypeEngine.column_expression
    "sqlalchemy.types.TypeEngine.column_expression")的实现，当定义为返回非`None`值时，应返回一个要注入到SQL语句中的[`ColumnElement`](sqlelement.html#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement")表达式，无论是围绕绑定参数还是列表达式。例如，为了构建一个`Geometry`类型，该类型将对所有传出值应用PostGIS函数`ST_GeomFromText`，对所有传入数据应用函数`ST_AsText`，我们可以创建自己的[`UserDefinedType`](#sqlalchemy.types.UserDefinedType
    "sqlalchemy.types.UserDefinedType")子类，该子类提供这些方法与[`func`](sqlelement.html#sqlalchemy.sql.expression.func
    "sqlalchemy.sql.expression.func")一起使用：
- en: '[PRE152]'
  id: totrans-597
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'We can apply the `Geometry` type into [`Table`](metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") metadata and use it in a [`select()`](selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") construct:'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将`Geometry`类型应用到[`Table`](metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")元数据中，并在[`select()`](selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select")构造中使用它：
- en: '[PRE153]'
  id: totrans-599
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'The resulting SQL embeds both functions as appropriate. `ST_AsText` is applied
    to the columns clause so that the return value is run through the function before
    passing into a result set, and `ST_GeomFromText` is run on the bound parameter
    so that the passed-in value is converted:'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 结果的SQL嵌入了两个函数。`ST_AsText`应用于列子句，以便返回值在传递到结果集之前通过函数运行，而`ST_GeomFromText`应用于绑定参数，以便传入值被转换：
- en: '[PRE154]'
  id: totrans-601
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: 'The [`TypeEngine.column_expression()`](type_api.html#sqlalchemy.types.TypeEngine.column_expression
    "sqlalchemy.types.TypeEngine.column_expression") method interacts with the mechanics
    of the compiler such that the SQL expression does not interfere with the labeling
    of the wrapped expression. Such as, if we rendered a [`select()`](selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") against a [`label()`](sqlelement.html#sqlalchemy.sql.expression.label
    "sqlalchemy.sql.expression.label") of our expression, the string label is moved
    to the outside of the wrapped expression:'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: '[`TypeEngine.column_expression()`](type_api.html#sqlalchemy.types.TypeEngine.column_expression
    "sqlalchemy.types.TypeEngine.column_expression")方法与编译器的机制交互，使得SQL表达式不会干扰包装表达式的标记。例如，如果我们针对我们表达式的[`label()`](sqlelement.html#sqlalchemy.sql.expression.label
    "sqlalchemy.sql.expression.label")进行了[`select()`](selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select")，字符串标签会移动到包装表达式的外部：'
- en: '[PRE155]'
  id: totrans-603
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: 'Output:'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 输出：
- en: '[PRE156]'
  id: totrans-605
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'Another example is we decorate [`BYTEA`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.BYTEA
    "sqlalchemy.dialects.postgresql.BYTEA") to provide a `PGPString`, which will make
    use of the PostgreSQL `pgcrypto` extension to encrypt/decrypt values transparently:'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是我们装饰[`BYTEA`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.BYTEA
    "sqlalchemy.dialects.postgresql.BYTEA")以提供`PGPString`，这将利用PostgreSQL的`pgcrypto`扩展来透明地加密/解密值：
- en: '[PRE157]'
  id: totrans-607
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: 'The `pgp_sym_encrypt` and `pgp_sym_decrypt` functions are applied to the INSERT
    and SELECT statements:'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: '`pgp_sym_encrypt`和`pgp_sym_decrypt`函数应用于INSERT和SELECT语句：'
- en: '[PRE158]'
  id: totrans-609
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '## Redefining and Creating New Operators'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: '## 重新定义和创建新操作符'
- en: SQLAlchemy Core defines a fixed set of expression operators available to all
    column expressions. Some of these operations have the effect of overloading Python’s
    built-in operators; examples of such operators include [`ColumnOperators.__eq__()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.__eq__
    "sqlalchemy.sql.expression.ColumnOperators.__eq__") (`table.c.somecolumn == 'foo'`),
    [`ColumnOperators.__invert__()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.__invert__
    "sqlalchemy.sql.expression.ColumnOperators.__invert__") (`~table.c.flag`), and
    [`ColumnOperators.__add__()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.__add__
    "sqlalchemy.sql.expression.ColumnOperators.__add__") (`table.c.x + table.c.y`).
    Other operators are exposed as explicit methods on column expressions, such as
    [`ColumnOperators.in_()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.in_
    "sqlalchemy.sql.expression.ColumnOperators.in_") (`table.c.value.in_(['x', 'y'])`)
    and [`ColumnOperators.like()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.like
    "sqlalchemy.sql.expression.ColumnOperators.like") (`table.c.value.like('%ed%')`).
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy核心定义了一组固定的表达式操作符，可用于所有列表达式。其中一些操作具有重载Python内置操作符的效果；此类操作符的示例包括[`ColumnOperators.__eq__()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.__eq__
    "sqlalchemy.sql.expression.ColumnOperators.__eq__")（`table.c.somecolumn == 'foo'`）、[`ColumnOperators.__invert__()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.__invert__
    "sqlalchemy.sql.expression.ColumnOperators.__invert__")（`~table.c.flag`）和[`ColumnOperators.__add__()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.__add__
    "sqlalchemy.sql.expression.ColumnOperators.__add__")（`table.c.x + table.c.y`）。其他操作符作为列表达式上的显式方法公开，例如[`ColumnOperators.in_()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.in_
    "sqlalchemy.sql.expression.ColumnOperators.in_")（`table.c.value.in_(['x', 'y'])`）和[`ColumnOperators.like()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.like
    "sqlalchemy.sql.expression.ColumnOperators.like")（`table.c.value.like('%ed%')`）。
- en: 'When the need arises for a SQL operator that isn’t directly supported by the
    already supplied methods above, the most expedient way to produce this operator
    is to use the [`Operators.op()`](sqlelement.html#sqlalchemy.sql.expression.Operators.op
    "sqlalchemy.sql.expression.Operators.op") method on any SQL expression object;
    this method is given a string representing the SQL operator to render, and the
    return value is a Python callable that accepts any arbitrary right-hand side expression:'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要使用SQL操作符而已直接支持的情况下，最方便的方法是在任何SQL表达式对象上使用[`Operators.op()`](sqlelement.html#sqlalchemy.sql.expression.Operators.op
    "sqlalchemy.sql.expression.Operators.op")方法；该方法接受一个表示要呈现的SQL操作符的字符串，并返回一个接受任意右侧表达式的Python可调用对象：
- en: '[PRE159]'
  id: totrans-613
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: When making use of custom SQL types, there is also a means of implementing custom
    operators as above that are automatically present upon any column expression that
    makes use of that column type, without the need to directly call [`Operators.op()`](sqlelement.html#sqlalchemy.sql.expression.Operators.op
    "sqlalchemy.sql.expression.Operators.op") each time the operator is to be used.
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用自定义SQL类型时，还有一种实现自定义操作符的方法，就像上面提到的那样，这些操作符在使用该列类型的任何列表达式上自动存在，而无需在每次使用操作符时直接调用[`Operators.op()`](sqlelement.html#sqlalchemy.sql.expression.Operators.op
    "sqlalchemy.sql.expression.Operators.op")。
- en: 'To achieve this, a SQL expression construct consults the [`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") object associated with the construct in order to
    determine the behavior of the built-in operators as well as to look for new methods
    that may have been invoked. [`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") defines a “comparison” object implemented by the
    [`Comparator`](type_api.html#sqlalchemy.types.TypeEngine.Comparator "sqlalchemy.types.TypeEngine.Comparator")
    class to provide the base behavior for SQL operators, and many specific types
    provide their own sub-implementations of this class. User-defined [`Comparator`](type_api.html#sqlalchemy.types.TypeEngine.Comparator
    "sqlalchemy.types.TypeEngine.Comparator") implementations can be built directly
    into a simple subclass of a particular type in order to override or define new
    operations. Below, we create a [`Integer`](type_basics.html#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer") subclass which overrides the [`ColumnOperators.__add__()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.__add__
    "sqlalchemy.sql.expression.ColumnOperators.__add__") operator, which in turn uses
    [`Operators.op()`](sqlelement.html#sqlalchemy.sql.expression.Operators.op "sqlalchemy.sql.expression.Operators.op")
    to produce the custom SQL itself:'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，SQL 表达式构造会参考与构造关联的[`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine")对象，以确定内置运算符的行为，并寻找可能已被调用的新方法。[`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine")定义了一个由[`Comparator`](type_api.html#sqlalchemy.types.TypeEngine.Comparator
    "sqlalchemy.types.TypeEngine.Comparator")类实现的“比较”对象，为 SQL 运算符提供基本行为，许多具体类型提供了它们自己的此类的子实现。用户定义的[`Comparator`](type_api.html#sqlalchemy.types.TypeEngine.Comparator
    "sqlalchemy.types.TypeEngine.Comparator")实现可以直接构建到特定类型的简单子类中，以覆盖或定义新操作。下面，我们创建一个[`Integer`](type_basics.html#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer")子类，它重写了[`ColumnOperators.__add__()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.__add__
    "sqlalchemy.sql.expression.ColumnOperators.__add__")运算符，而该运算符又使用[`Operators.op()`](sqlelement.html#sqlalchemy.sql.expression.Operators.op
    "sqlalchemy.sql.expression.Operators.op")来生成自定义的 SQL 代码：
- en: '[PRE160]'
  id: totrans-616
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: The above configuration creates a new class `MyInt`, which establishes the [`TypeEngine.comparator_factory`](type_api.html#sqlalchemy.types.TypeEngine.comparator_factory
    "sqlalchemy.types.TypeEngine.comparator_factory") attribute as referring to a
    new class, subclassing the [`Comparator`](type_api.html#sqlalchemy.types.TypeEngine.Comparator
    "sqlalchemy.types.TypeEngine.Comparator") class associated with the [`Integer`](type_basics.html#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer") type.
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 上述配置创建了一个新的类`MyInt`，它将[`TypeEngine.comparator_factory`](type_api.html#sqlalchemy.types.TypeEngine.comparator_factory
    "sqlalchemy.types.TypeEngine.comparator_factory")属性设置为引用一个新的类，该类是与[`Integer`](type_basics.html#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer")类型关联的[`Comparator`](type_api.html#sqlalchemy.types.TypeEngine.Comparator
    "sqlalchemy.types.TypeEngine.Comparator")类的子类。
- en: 'Usage:'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 使用方法：
- en: '[PRE161]'
  id: totrans-619
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: 'The implementation for [`ColumnOperators.__add__()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.__add__
    "sqlalchemy.sql.expression.ColumnOperators.__add__") is consulted by an owning
    SQL expression, by instantiating the [`Comparator`](type_api.html#sqlalchemy.types.TypeEngine.Comparator
    "sqlalchemy.types.TypeEngine.Comparator") with itself as the `expr` attribute.
    This attribute may be used when the implementation needs to refer to the originating
    [`ColumnElement`](sqlelement.html#sqlalchemy.sql.expression.ColumnElement "sqlalchemy.sql.expression.ColumnElement")
    object directly:'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 对于[`ColumnOperators.__add__()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.__add__
    "sqlalchemy.sql.expression.ColumnOperators.__add__")的实现是由拥有的 SQL 表达式进行参考的，通过使用自身作为`expr`属性来实例化[`Comparator`](type_api.html#sqlalchemy.types.TypeEngine.Comparator
    "sqlalchemy.types.TypeEngine.Comparator")。当实现需要直接引用原始[`ColumnElement`](sqlelement.html#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement")对象时，可以使用此属性：
- en: '[PRE162]'
  id: totrans-621
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: 'New methods added to a [`Comparator`](type_api.html#sqlalchemy.types.TypeEngine.Comparator
    "sqlalchemy.types.TypeEngine.Comparator") are exposed on an owning SQL expression
    object using a dynamic lookup scheme, which exposes methods added to [`Comparator`](type_api.html#sqlalchemy.types.TypeEngine.Comparator
    "sqlalchemy.types.TypeEngine.Comparator") onto the owning [`ColumnElement`](sqlelement.html#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement") expression construct. For example,
    to add a `log()` function to integers:'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 [`Comparator`](type_api.html#sqlalchemy.types.TypeEngine.Comparator "sqlalchemy.types.TypeEngine.Comparator")
    添加的新方法，通过动态查找方案暴露在拥有 SQL 表达式对象上，这样可以将添加到 [`Comparator`](type_api.html#sqlalchemy.types.TypeEngine.Comparator
    "sqlalchemy.types.TypeEngine.Comparator") 的方法暴露到拥有的 [`ColumnElement`](sqlelement.html#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement") 表达式构造上。例如，要为整数添加一个 `log()` 函数：
- en: '[PRE163]'
  id: totrans-623
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: 'Using the above type:'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上述类型：
- en: '[PRE164]'
  id: totrans-625
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: 'When using [`Operators.op()`](sqlelement.html#sqlalchemy.sql.expression.Operators.op
    "sqlalchemy.sql.expression.Operators.op") for comparison operations that return
    a boolean result, the [`Operators.op.is_comparison`](sqlelement.html#sqlalchemy.sql.expression.Operators.op.params.is_comparison
    "sqlalchemy.sql.expression.Operators.op") flag should be set to `True`:'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 [`Operators.op()`](sqlelement.html#sqlalchemy.sql.expression.Operators.op
    "sqlalchemy.sql.expression.Operators.op") 进行返回布尔结果的比较操作时，应将 [`Operators.op.is_comparison`](sqlelement.html#sqlalchemy.sql.expression.Operators.op.params.is_comparison
    "sqlalchemy.sql.expression.Operators.op") 标志设置为 `True`：
- en: '[PRE165]'
  id: totrans-627
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: 'Unary operations are also possible. For example, to add an implementation of
    the PostgreSQL factorial operator, we combine the [`UnaryExpression`](sqlelement.html#sqlalchemy.sql.expression.UnaryExpression
    "sqlalchemy.sql.expression.UnaryExpression") construct along with a [`custom_op`](sqlelement.html#sqlalchemy.sql.expression.custom_op
    "sqlalchemy.sql.expression.custom_op") to produce the factorial expression:'
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 一元操作也是可能的。例如，要添加 PostgreSQL 阶乘运算符的实现，我们结合 [`UnaryExpression`](sqlelement.html#sqlalchemy.sql.expression.UnaryExpression
    "sqlalchemy.sql.expression.UnaryExpression") 构造以及 [`custom_op`](sqlelement.html#sqlalchemy.sql.expression.custom_op
    "sqlalchemy.sql.expression.custom_op") 来生成阶乘表达式：
- en: '[PRE166]'
  id: totrans-629
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: 'Using the above type:'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上述类型：
- en: '[PRE167]'
  id: totrans-631
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: See also
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`Operators.op()`](sqlelement.html#sqlalchemy.sql.expression.Operators.op "sqlalchemy.sql.expression.Operators.op")'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Operators.op()`](sqlelement.html#sqlalchemy.sql.expression.Operators.op "sqlalchemy.sql.expression.Operators.op")'
- en: '[`TypeEngine.comparator_factory`](type_api.html#sqlalchemy.types.TypeEngine.comparator_factory
    "sqlalchemy.types.TypeEngine.comparator_factory")'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: '[`TypeEngine.comparator_factory`](type_api.html#sqlalchemy.types.TypeEngine.comparator_factory
    "sqlalchemy.types.TypeEngine.comparator_factory")'
- en: Creating New Types
  id: totrans-635
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建新类型
- en: The [`UserDefinedType`](#sqlalchemy.types.UserDefinedType "sqlalchemy.types.UserDefinedType")
    class is provided as a simple base class for defining entirely new database types.
    Use this to represent native database types not known by SQLAlchemy. If only Python
    translation behavior is needed, use [`TypeDecorator`](#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") instead.
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: '[`UserDefinedType`](#sqlalchemy.types.UserDefinedType "sqlalchemy.types.UserDefinedType")
    类被提供作为定义全新数据库类型的简单基类。使用它来表示 SQLAlchemy 不知道的本地数据库类型。如果只需要 Python 转换行为，请改用 [`TypeDecorator`](#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator")。'
- en: '| Object Name | Description |'
  id: totrans-637
  prefs: []
  type: TYPE_TB
  zh: '| 对象名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-638
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| [UserDefinedType](#sqlalchemy.types.UserDefinedType) | Base for user defined
    types. |'
  id: totrans-639
  prefs: []
  type: TYPE_TB
  zh: '| [UserDefinedType](#sqlalchemy.types.UserDefinedType) | 用户定义类型的基础。 |'
- en: '[PRE168]'
  id: totrans-640
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: Base for user defined types.
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 用户定义类型的基础。
- en: 'This should be the base of new types. Note that for most cases, [`TypeDecorator`](#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") is probably more appropriate:'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该是新类型的基础。请注意，对于大多数情况，[`TypeDecorator`](#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")
    可能更合适：
- en: '[PRE169]'
  id: totrans-643
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: 'Once the type is made, it’s immediately usable:'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦类型被创建，它立即可用：
- en: '[PRE170]'
  id: totrans-645
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: The `get_col_spec()` method will in most cases receive a keyword argument `type_expression`
    which refers to the owning expression of the type as being compiled, such as a
    [`Column`](metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    or [`cast()`](sqlelement.html#sqlalchemy.sql.expression.cast "sqlalchemy.sql.expression.cast")
    construct. This keyword is only sent if the method accepts keyword arguments (e.g.
    `**kw`) in its argument signature; introspection is used to check for this in
    order to support legacy forms of this function.
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: '`get_col_spec()` 方法在大多数情况下将接收一个关键字参数 `type_expression`，该参数指的是类型的拥有表达式在编译时，例如
    [`Column`](metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    或 [`cast()`](sqlelement.html#sqlalchemy.sql.expression.cast "sqlalchemy.sql.expression.cast")
    构造。仅当方法接受关键字参数（例如 `**kw`）时才发送此关键字；用于检查此函数的传统形式的内省。'
- en: The [`UserDefinedType.cache_ok`](#sqlalchemy.types.UserDefinedType.cache_ok
    "sqlalchemy.types.UserDefinedType.cache_ok") class-level flag indicates if this
    custom [`UserDefinedType`](#sqlalchemy.types.UserDefinedType "sqlalchemy.types.UserDefinedType")
    is safe to be used as part of a cache key. This flag defaults to `None` which
    will initially generate a warning when the SQL compiler attempts to generate a
    cache key for a statement that uses this type. If the [`UserDefinedType`](#sqlalchemy.types.UserDefinedType
    "sqlalchemy.types.UserDefinedType") is not guaranteed to produce the same bind/result
    behavior and SQL generation every time, this flag should be set to `False`; otherwise
    if the class produces the same behavior each time, it may be set to `True`. See
    [`UserDefinedType.cache_ok`](#sqlalchemy.types.UserDefinedType.cache_ok "sqlalchemy.types.UserDefinedType.cache_ok")
    for further notes on how this works.
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: '[`UserDefinedType.cache_ok`](#sqlalchemy.types.UserDefinedType.cache_ok "sqlalchemy.types.UserDefinedType.cache_ok")
    类级标志指示此自定义 [`UserDefinedType`](#sqlalchemy.types.UserDefinedType "sqlalchemy.types.UserDefinedType")
    是否安全用作缓存键的一部分。此标志默认为 `None`，当 SQL 编译器尝试为使用此类型的语句生成缓存键时，最初会生成警告。如果不能保证 [`UserDefinedType`](#sqlalchemy.types.UserDefinedType
    "sqlalchemy.types.UserDefinedType") 每次产生相同的绑定/结果行为和 SQL 生成，应将此标志设置为 `False`；否则，如果类每次产生相同的行为，则可以设置为
    `True`。有关此功能的详细说明，请参阅 [`UserDefinedType.cache_ok`](#sqlalchemy.types.UserDefinedType.cache_ok
    "sqlalchemy.types.UserDefinedType.cache_ok")。'
- en: 'New in version 1.4.28: Generalized the [`ExternalType.cache_ok`](type_api.html#sqlalchemy.types.ExternalType.cache_ok
    "sqlalchemy.types.ExternalType.cache_ok") flag so that it is available for both
    [`TypeDecorator`](#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")
    as well as [`UserDefinedType`](#sqlalchemy.types.UserDefinedType "sqlalchemy.types.UserDefinedType").'
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 新版本 1.4.28 中：将 [`ExternalType.cache_ok`](type_api.html#sqlalchemy.types.ExternalType.cache_ok
    "sqlalchemy.types.ExternalType.cache_ok") 标志泛化，以便它同时适用于 [`TypeDecorator`](#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") 和 [`UserDefinedType`](#sqlalchemy.types.UserDefinedType
    "sqlalchemy.types.UserDefinedType")。
- en: '**Members**'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: '**成员**'
- en: '[cache_ok](#sqlalchemy.types.UserDefinedType.cache_ok), [coerce_compared_value()](#sqlalchemy.types.UserDefinedType.coerce_compared_value),
    [ensure_kwarg](#sqlalchemy.types.UserDefinedType.ensure_kwarg)'
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: '[cache_ok](#sqlalchemy.types.UserDefinedType.cache_ok)，[coerce_compared_value()](#sqlalchemy.types.UserDefinedType.coerce_compared_value)，[ensure_kwarg](#sqlalchemy.types.UserDefinedType.ensure_kwarg)'
- en: '**Class signature**'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: '**类签名**'
- en: class [`sqlalchemy.types.UserDefinedType`](#sqlalchemy.types.UserDefinedType
    "sqlalchemy.types.UserDefinedType") ([`sqlalchemy.types.ExternalType`](type_api.html#sqlalchemy.types.ExternalType
    "sqlalchemy.types.ExternalType"), `sqlalchemy.types.TypeEngineMixin`, [`sqlalchemy.types.TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine"), `sqlalchemy.util.langhelpers.EnsureKWArg`)
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 类 [`sqlalchemy.types.UserDefinedType`](#sqlalchemy.types.UserDefinedType "sqlalchemy.types.UserDefinedType")（[`sqlalchemy.types.ExternalType`](type_api.html#sqlalchemy.types.ExternalType
    "sqlalchemy.types.ExternalType")，`sqlalchemy.types.TypeEngineMixin`，[`sqlalchemy.types.TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine")，`sqlalchemy.util.langhelpers.EnsureKWArg`）
- en: '[PRE171]'
  id: totrans-653
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: '*inherited from the* [`ExternalType.cache_ok`](type_api.html#sqlalchemy.types.ExternalType.cache_ok
    "sqlalchemy.types.ExternalType.cache_ok") *attribute of* [`ExternalType`](type_api.html#sqlalchemy.types.ExternalType
    "sqlalchemy.types.ExternalType")'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: '*继承自* [`ExternalType.cache_ok`](type_api.html#sqlalchemy.types.ExternalType.cache_ok
    "sqlalchemy.types.ExternalType.cache_ok") *属性的* [`ExternalType`](type_api.html#sqlalchemy.types.ExternalType
    "sqlalchemy.types.ExternalType")'
- en: Indicate if statements using this [`ExternalType`](type_api.html#sqlalchemy.types.ExternalType
    "sqlalchemy.types.ExternalType") are “safe to cache”.
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 指示使用此 [`ExternalType`](type_api.html#sqlalchemy.types.ExternalType "sqlalchemy.types.ExternalType")
    的语句是否“可缓存”。
- en: 'The default value `None` will emit a warning and then not allow caching of
    a statement which includes this type. Set to `False` to disable statements using
    this type from being cached at all without a warning. When set to `True`, the
    object’s class and selected elements from its state will be used as part of the
    cache key. For example, using a [`TypeDecorator`](#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator"):'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 默认值`None`将发出警告，然后不允许缓存包含此类型的语句。将其设置为`False`以完全禁用使用此类型的语句的缓存，而无需警告。当设置为`True`时，对象的类和其状态的选定元素将用作缓存键的一部分。例如，使用[`TypeDecorator`](#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator")：
- en: '[PRE172]'
  id: totrans-657
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: 'The cache key for the above type would be equivalent to:'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 上述类型的缓存键将等同于：
- en: '[PRE173]'
  id: totrans-659
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: The caching scheme will extract attributes from the type that correspond to
    the names of parameters in the `__init__()` method. Above, the “choices” attribute
    becomes part of the cache key but “internal_only” does not, because there is no
    parameter named “internal_only”.
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存方案将从与`__init__()`方法中的参数名称相对应的类型中提取属性。在上面的例子中，“choices”属性成为缓存键的一部分，但“internal_only”不是，因为没有名为“internal_only”的参数。
- en: The requirements for cacheable elements is that they are hashable and also that
    they indicate the same SQL rendered for expressions using this type every time
    for a given cache value.
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 可缓存元素的要求是它们是可哈希的，并且还要表明对于给定缓存值，每次使用此类型的表达式渲染的SQL都相同。
- en: 'To accommodate for datatypes that refer to unhashable structures such as dictionaries,
    sets and lists, these objects can be made “cacheable” by assigning hashable structures
    to the attributes whose names correspond with the names of the arguments. For
    example, a datatype which accepts a dictionary of lookup values may publish this
    as a sorted series of tuples. Given a previously un-cacheable type as:'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 为了适应引用不可哈希结构的数据类型，如字典、集合和列表的数据类型，可以通过将可哈希结构分配给名称与参数名称对应的属性来使这些对象“可缓存”。例如，接受查找值字典的数据类型可以将其发布为排序的元组系列。给定一个以前不可缓存的类型如下：
- en: '[PRE174]'
  id: totrans-663
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: 'Where “lookup” is a dictionary. The type will not be able to generate a cache
    key:'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: “查找”是一个字典。该类型将无法生成缓存键：
- en: '[PRE175]'
  id: totrans-665
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: 'If we **did** set up such a cache key, it wouldn’t be usable. We would get
    a tuple structure that contains a dictionary inside of it, which cannot itself
    be used as a key in a “cache dictionary” such as SQLAlchemy’s statement cache,
    since Python dictionaries aren’t hashable:'
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们**确实**设置了这样的缓存键，它将无法使用。我们将得到一个包含字典的元组结构，这个字典本身不能作为“缓存字典”中的键使用，例如SQLAlchemy的语句缓存，因为Python字典不是可哈希的：
- en: '[PRE176]'
  id: totrans-667
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: 'The type may be made cacheable by assigning a sorted tuple of tuples to the
    “.lookup” attribute:'
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 可通过将排序的元组分配给“.lookup”属性来使上述类型可缓存：
- en: '[PRE177]'
  id: totrans-669
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: 'Where above, the cache key for `LookupType({"a": 10, "b": 20})` will be:'
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: '在上面的情况下，“LookupType({"a": 10, "b": 20})”的缓存键将为：'
- en: '[PRE178]'
  id: totrans-671
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: 'New in version 1.4.14: - added the `cache_ok` flag to allow some configurability
    of caching for [`TypeDecorator`](#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")
    classes.'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 新版本1.4.14中新增了：- 添加了`cache_ok`标志，允许对[`TypeDecorator`](#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator")类的缓存进行一些可配置性。
- en: 'New in version 1.4.28: - added the [`ExternalType`](type_api.html#sqlalchemy.types.ExternalType
    "sqlalchemy.types.ExternalType") mixin which generalizes the `cache_ok` flag to
    both the [`TypeDecorator`](#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")
    and [`UserDefinedType`](#sqlalchemy.types.UserDefinedType "sqlalchemy.types.UserDefinedType")
    classes.'
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: 新版本1.4.28中新增了：- 添加了[`ExternalType`](type_api.html#sqlalchemy.types.ExternalType
    "sqlalchemy.types.ExternalType")混合类型，它将`cache_ok`标志推广到了[`TypeDecorator`](#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator")和[`UserDefinedType`](#sqlalchemy.types.UserDefinedType
    "sqlalchemy.types.UserDefinedType")类。
- en: See also
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[SQL Compilation Caching](connections.html#sql-caching)'
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: '[SQL 编译缓存](connections.html#sql-caching)'
- en: '[PRE179]'
  id: totrans-676
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: Suggest a type for a ‘coerced’ Python value in an expression.
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 为表达式中的“强制转换”Python值建议一种类型。
- en: Default behavior for [`UserDefinedType`](#sqlalchemy.types.UserDefinedType "sqlalchemy.types.UserDefinedType")
    is the same as that of [`TypeDecorator`](#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator");
    by default it returns `self`, assuming the compared value should be coerced into
    the same type as this one. See [`TypeDecorator.coerce_compared_value()`](#sqlalchemy.types.TypeDecorator.coerce_compared_value
    "sqlalchemy.types.TypeDecorator.coerce_compared_value") for more detail.
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: '[`UserDefinedType`](#sqlalchemy.types.UserDefinedType "sqlalchemy.types.UserDefinedType")
    的默认行为与 [`TypeDecorator`](#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")
    的默认行为相同；默认情况下，它返回 `self`，假设比较的值应该被强制转换为与此相同的类型。有关更多详细信息，请参见 [`TypeDecorator.coerce_compared_value()`](#sqlalchemy.types.TypeDecorator.coerce_compared_value
    "sqlalchemy.types.TypeDecorator.coerce_compared_value")。'
- en: '[PRE180]'
  id: totrans-679
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: a regular expression that indicates method names for which the method should
    accept `**kw` arguments.
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 一个用于指示方法名称的正则表达式，该方法应接受`**kw`参数。
- en: The class will scan for methods matching the name template and decorate them
    if necessary to ensure `**kw` parameters are accepted.
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: 类将扫描匹配名称模板的方法，并在必要时装饰它们，以确保接受`**kw`参数。
- en: '## Working with Custom Types and Reflection'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: '## 使用自定义类型和反射'
- en: It is important to note that database types which are modified to have additional
    in-Python behaviors, including types based on [`TypeDecorator`](#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") as well as other user-defined subclasses of
    datatypes, do not have any representation within a database schema. When using
    database the introspection features described at [Reflecting Database Objects](reflection.html#metadata-reflection),
    SQLAlchemy makes use of a fixed mapping which links the datatype information reported
    by a database server to a SQLAlchemy datatype object. For example, if we look
    inside of a PostgreSQL schema at the definition for a particular database column,
    we might receive back the string `"VARCHAR"`. SQLAlchemy’s PostgreSQL dialect
    has a hardcoded mapping which links the string name `"VARCHAR"` to the SQLAlchemy
    [`VARCHAR`](type_basics.html#sqlalchemy.types.VARCHAR "sqlalchemy.types.VARCHAR")
    class, and that’s how when we emit a statement like `Table('my_table', m, autoload_with=engine)`,
    the [`Column`](metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    object within it would have an instance of [`VARCHAR`](type_basics.html#sqlalchemy.types.VARCHAR
    "sqlalchemy.types.VARCHAR") present inside of it.
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，被修改以具有额外的 Python 行为的数据库类型，包括基于[`TypeDecorator`](#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator")的类型以及其他用户定义的数据类型子类，在数据库模式中没有任何表示。当使用数据库中描述的反射功能时，SQLAlchemy
    使用一个固定的映射，将数据库服务器报告的数据类型信息链接到一个 SQLAlchemy 数据类型对象上。例如，如果我们在 PostgreSQL 模式中查看特定数据库列的定义，可能会收到字符串`"VARCHAR"`。SQLAlchemy
    的 PostgreSQL 方言有一个硬编码的映射，将字符串名称`"VARCHAR"`链接到 SQLAlchemy [`VARCHAR`](type_basics.html#sqlalchemy.types.VARCHAR
    "sqlalchemy.types.VARCHAR") 类，这就是当我们发出像`Table('my_table', m, autoload_with=engine)`这样的语句时，其中的
    [`Column`](metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    对象内会有一个 [`VARCHAR`](type_basics.html#sqlalchemy.types.VARCHAR "sqlalchemy.types.VARCHAR")
    的实例存在的原因。
- en: 'The implication of this is that if a [`Table`](metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") object makes use of type objects that don’t correspond
    directly to the database-native type name, if we create a new [`Table`](metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") object against a new [`MetaData`](metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") collection for this database table elsewhere using
    reflection, it will not have this datatype. For example:'
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着如果一个 [`Table`](metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    对象使用的类型对象不直接对应于数据库本机类型名称，如果我们在其他地方使用反射为此数据库表创建新的 [`Table`](metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") 对象，则它将没有此数据类型。例如：
- en: '[PRE181]'
  id: totrans-685
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: Above, we made use of [`PickleType`](type_basics.html#sqlalchemy.types.PickleType
    "sqlalchemy.types.PickleType"), which is a [`TypeDecorator`](#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") that works on top of the [`LargeBinary`](type_basics.html#sqlalchemy.types.LargeBinary
    "sqlalchemy.types.LargeBinary") datatype, which on SQLite corresponds to the database
    type `BLOB`. In the CREATE TABLE, we see that the `BLOB` datatype is used. The
    SQLite database knows nothing about the [`PickleType`](type_basics.html#sqlalchemy.types.PickleType
    "sqlalchemy.types.PickleType") we’ve used.
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面，我们使用了[`PickleType`](type_basics.html#sqlalchemy.types.PickleType "sqlalchemy.types.PickleType")，它是一个作用于[`LargeBinary`](type_basics.html#sqlalchemy.types.LargeBinary
    "sqlalchemy.types.LargeBinary")数据类型之上的[`TypeDecorator`](#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator")，在SQLite中对应着数据库类型`BLOB`。在CREATE TABLE中，我们可以看到使用了`BLOB`数据类型。SQLite数据库对我们使用的[`PickleType`](type_basics.html#sqlalchemy.types.PickleType
    "sqlalchemy.types.PickleType")一无所知。
- en: 'If we look at the datatype of `my_table.c.data.type`, as this is a Python object
    that was created by us directly, it is [`PickleType`](type_basics.html#sqlalchemy.types.PickleType
    "sqlalchemy.types.PickleType"):'
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们看一下`my_table.c.data.type`的数据类型，因为这是我们直接创建的Python对象，它是[`PickleType`](type_basics.html#sqlalchemy.types.PickleType
    "sqlalchemy.types.PickleType")：
- en: '[PRE182]'
  id: totrans-688
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: 'However, if we create another instance of [`Table`](metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") using reflection, the use of [`PickleType`](type_basics.html#sqlalchemy.types.PickleType
    "sqlalchemy.types.PickleType") is not represented in the SQLite database we’ve
    created; we instead get back [`BLOB`](type_basics.html#sqlalchemy.types.BLOB "sqlalchemy.types.BLOB"):'
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: '然而，如果我们使用反射创建另一个[`Table`](metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")实例，我们创建的SQLite数据库中不会反映出[`PickleType`](type_basics.html#sqlalchemy.types.PickleType
    "sqlalchemy.types.PickleType")的使用；相反，我们得到的是[`BLOB`](type_basics.html#sqlalchemy.types.BLOB
    "sqlalchemy.types.BLOB"):'
- en: '[PRE183]'
  id: totrans-690
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: Typically, when an application defines explicit [`Table`](metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") metadata with custom types, there is no need to use
    table reflection because the necessary [`Table`](metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") metadata is already present. However, for the case
    where an application, or a combination of them, need to make use of both explicit
    [`Table`](metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table") metadata
    which includes custom, Python-level datatypes, as well as [`Table`](metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects which set up their [`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects as reflected from the database, which nevertheless
    still need to exhibit the additional Python behaviors of the custom datatypes,
    additional steps must be taken to allow this.
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当应用程序使用自定义类型定义明确的[`Table`](metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")元数据时，不需要使用表反射，因为必要的[`Table`](metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")元数据已经存在。然而，对于一个应用程序或一组应用程序需要同时使用包含自定义Python级数据类型的明确[`Table`](metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")元数据以及设置其[`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")对象作为从数据库反映的[`Table`](metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")对象的情况，仍然需要展示自定义数据类型的附加Python行为，必须采取额外的步骤来允许这种情况。
- en: 'The most straightforward is to override specific columns as described at [Overriding
    Reflected Columns](reflection.html#reflection-overriding-columns). In this technique,
    we simply use reflection in combination with explicit [`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects for those columns for which we want to use
    a custom or decorated datatype:'
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 最直接的方法是按照[覆盖反射列](reflection.html#reflection-overriding-columns)中描述的覆盖特定列。在这种技术中，我们只需将反射与那些我们想要使用自定义或装饰数据类型的列的显式[`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")对象结合使用：
- en: '[PRE184]'
  id: totrans-693
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: 'The `my_reflected_table` object above is reflected, and will load the definition
    of the “id” column from the SQLite database. But for the “data” column, we’ve
    overridden the reflected object with an explicit [`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") definition that includes our desired in-Python datatype,
    the [`PickleType`](type_basics.html#sqlalchemy.types.PickleType "sqlalchemy.types.PickleType").
    The reflection process will leave this [`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") object intact:'
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的`my_reflected_table`对象被反映出来，并将从SQLite数据库加载“id”列的定义。但对于“data”列，我们用一个显式的[`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")定义来覆盖了反射对象，其中包括我们想要的Python数据类型，[`PickleType`](type_basics.html#sqlalchemy.types.PickleType
    "sqlalchemy.types.PickleType")。反射过程将保留此[`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")对象不变：
- en: '[PRE185]'
  id: totrans-695
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: 'A more elaborate way to convert from database-native type objects to custom
    datatypes is to use the [`DDLEvents.column_reflect()`](events.html#sqlalchemy.events.DDLEvents.column_reflect
    "sqlalchemy.events.DDLEvents.column_reflect") event handler. If for example we
    knew that we wanted all [`BLOB`](type_basics.html#sqlalchemy.types.BLOB "sqlalchemy.types.BLOB")
    datatypes to in fact be [`PickleType`](type_basics.html#sqlalchemy.types.PickleType
    "sqlalchemy.types.PickleType"), we could set up a rule across the board:'
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 从数据库本地类型对象转换为自定义数据类型的更详细的方法是使用[`DDLEvents.column_reflect()`](events.html#sqlalchemy.events.DDLEvents.column_reflect
    "sqlalchemy.events.DDLEvents.column_reflect")事件处理程序。例如，如果我们知道我们想要的所有[`BLOB`](type_basics.html#sqlalchemy.types.BLOB
    "sqlalchemy.types.BLOB")数据类型实际上都是[`PickleType`](type_basics.html#sqlalchemy.types.PickleType
    "sqlalchemy.types.PickleType")，我们可以设置一个跨越整个的规则：
- en: '[PRE186]'
  id: totrans-697
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: When the above code is invoked *before* any table reflection occurs (note also
    it should be invoked **only once** in the application, as it is a global rule),
    upon reflecting any [`Table`](metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    that includes a column with a [`BLOB`](type_basics.html#sqlalchemy.types.BLOB
    "sqlalchemy.types.BLOB") datatype, the resulting datatype will be stored in the
    [`Column`](metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    object as [`PickleType`](type_basics.html#sqlalchemy.types.PickleType "sqlalchemy.types.PickleType").
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: 当上述代码在任何表反射发生之前*调用*（还要注意它应该在应用程序中**仅调用一次**，因为它是一个全局规则）时，对于包含具有[`BLOB`](type_basics.html#sqlalchemy.types.BLOB
    "sqlalchemy.types.BLOB")数据类型列的任何[`Table`](metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")，结果数据类型将存储在[`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")对象中作为[`PickleType`](type_basics.html#sqlalchemy.types.PickleType
    "sqlalchemy.types.PickleType")。
- en: In practice, the above event-based approach would likely have additional rules
    in order to affect only those columns where the datatype is important, such as
    a lookup table of table names and possibly column names, or other heuristics in
    order to accurately determine which columns should be established with an in Python
    datatype.
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，上述基于事件的方法可能会有额外的规则，以便仅影响那些数据类型很重要的列，例如表名和可能列名的查找表，或者其他启发式方法，以准确确定应该用Python数据类型建立哪些列。
