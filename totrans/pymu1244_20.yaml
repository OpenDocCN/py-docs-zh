- en: Low-Level Interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://pymupdf.readthedocs.io/en/latest/recipes-low-level-interfaces.html](https://pymupdf.readthedocs.io/en/latest/recipes-low-level-interfaces.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Numerous methods are available to access and manipulate PDF files on a fairly
    low level. Admittedly, a clear distinction between “low level” and “normal” functionality
    is not always possible or subject to personal taste.
  prefs: []
  type: TYPE_NORMAL
- en: It also may happen, that functionality previously deemed low-level is later
    on assessed as being part of the normal interface. This has happened in v1.14.0
    for the class [Tools](tools.html#tools) - you now find it as an item in the Classes
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: It is a matter of documentation only in which chapter of the documentation you
    find what you are looking for. Everything is available and always via the same
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: How to Iterate through the [`xref`](glossary.html#xref "xref") Table
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A PDF’s [`xref`](glossary.html#xref "xref") table is a list of all objects
    defined in the file. This table may easily contain many thousands of entries –
    the manual [Adobe PDF References](app3.html#adobemanual) for example has 127,000
    objects. Table entry “0” is reserved and must not be touched. The following script
    loops through the [`xref`](glossary.html#xref "xref") table and prints each object’s
    definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: A PDF object definition is an ordinary ASCII string.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: How to Handle Object Streams
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some object types contain additional data apart from their object definition.
    Examples are images, fonts, embedded files or commands describing the appearance
    of a page.
  prefs: []
  type: TYPE_NORMAL
- en: Objects of these types are called “stream objects”. PyMuPDF allows reading an
    object’s stream via method [`Document.xref_stream()`](document.html#Document.xref_stream
    "Document.xref_stream") with the object’s [`xref`](glossary.html#xref "xref")
    as an argument. It is also possible to write back a modified version of a stream
    using [`Document.update_stream()`](document.html#Document.update_stream "Document.update_stream").
  prefs: []
  type: TYPE_NORMAL
- en: 'Assume that the following snippet wants to read all streams of a PDF for whatever
    reason:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[`Document.xref_stream()`](document.html#Document.xref_stream "Document.xref_stream")
    automatically returns a stream decompressed as a bytes object – and [`Document.update_stream()`](document.html#Document.update_stream
    "Document.update_stream") automatically compresses it if beneficial.'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: How to Handle Page Contents
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A PDF page can have zero or multiple [`contents`](glossary.html#contents "contents")
    objects. These are stream objects describing **what** appears **where** and **how**
    on a page (like text and images). They are written in a special mini-language
    described e.g. in chapter “APPENDIX A - Operator Summary” on page 643 of the [Adobe
    PDF References](app3.html#adobemanual).
  prefs: []
  type: TYPE_NORMAL
- en: Every PDF reader application must be able to interpret the contents syntax to
    reproduce the intended appearance of the page.
  prefs: []
  type: TYPE_NORMAL
- en: If multiple [`contents`](glossary.html#contents "contents") objects are provided,
    they must be interpreted in the specified sequence in exactly the same way as
    if they were provided as a concatenation of the several.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are good technical arguments for having multiple [`contents`](glossary.html#contents
    "contents") objects:'
  prefs: []
  type: TYPE_NORMAL
- en: It is a lot easier and faster to just add new [`contents`](glossary.html#contents
    "contents") objects than maintaining a single big one (which entails reading,
    decompressing, modifying, recompressing, and rewriting it for each change).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When working with incremental updates, a modified big [`contents`](glossary.html#contents
    "contents") object will bloat the update delta and can thus easily negate the
    efficiency of incremental saves.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, PyMuPDF adds new, small [`contents`](glossary.html#contents "contents")
    objects in methods [`Page.insert_image()`](page.html#Page.insert_image "Page.insert_image"),
    [`Page.show_pdf_page()`](page.html#Page.show_pdf_page "Page.show_pdf_page") and
    the [Shape](shape.html#shape) methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there are also situations when a **single** [`contents`](glossary.html#contents
    "contents") object is beneficial: it is easier to interpret and more compressible
    than multiple smaller ones.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are two ways of combining multiple contents of a page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The clean function [`Page.clean_contents()`](functions.html#Page.clean_contents
    "Page.clean_contents") does a lot more than just glueing [`contents`](glossary.html#contents
    "contents") objects: it also corrects and optimizes the PDF operator syntax of
    the page and removes any inconsistencies with the page’s object definition.'
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: How to Access the PDF Catalog
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is a central (“root”) object of a PDF. It serves as a starting point to
    reach important other objects and it also contains some global options for the
    PDF:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Indentation, line breaks and comments are inserted here for clarification purposes
    only and will not normally appear. For more information on the PDF catalog see
    section 7.7.2 on page 71 of the [Adobe PDF References](app3.html#adobemanual).
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: How to Access the PDF File Trailer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The trailer of a PDF file is a [`dictionary`](glossary.html#dictionary "dictionary")
    located towards the end of the file. It contains special objects, and pointers
    to important other information. See [Adobe PDF References](app3.html#adobemanual)
    p. 42\. Here is an overview:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Key** | **Type** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Size | int | Number of entries in the cross-reference table + 1. |'
  prefs: []
  type: TYPE_TB
- en: '| Prev | int | Offset to previous [`xref`](glossary.html#xref "xref") section
    (indicates incremental updates). |'
  prefs: []
  type: TYPE_TB
- en: '| Root | dictionary | (indirect) Pointer to the catalog. See previous section.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Encrypt | dictionary | Pointer to encryption object (encrypted files only).
    |'
  prefs: []
  type: TYPE_TB
- en: '| Info | dictionary | (indirect) Pointer to information (metadata). |'
  prefs: []
  type: TYPE_TB
- en: '| ID | array | File identifier consisting of two byte strings. |'
  prefs: []
  type: TYPE_TB
- en: '| XRefStm | int | Offset of a cross-reference stream. See [Adobe PDF References](app3.html#adobemanual)
    p. 49. |'
  prefs: []
  type: TYPE_TB
- en: Access this information via PyMuPDF with [`Document.pdf_trailer()`](document.html#Document.pdf_trailer
    "Document.pdf_trailer") or, equivalently, via [`Document.xref_object()`](document.html#Document.xref_object
    "Document.xref_object") using -1 instead of a valid [`xref`](glossary.html#xref
    "xref") number.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: How to Access XML Metadata
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A PDF may contain XML metadata in addition to the standard metadata format.
    In fact, most PDF viewer or modification software adds this type of information
    when saving the PDF (Adobe, Nitro PDF, PDF-XChange, etc.).
  prefs: []
  type: TYPE_NORMAL
- en: PyMuPDF has no way to **interpret or change** this information directly, because
    it contains no XML features. XML metadata is however stored as a [`stream`](glossary.html#stream
    "stream") object, so it can be read, modified with appropriate software and written
    back.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Using some XML package, the XML data can be interpreted and / or modified and
    then stored back. The following also works, if the PDF previously had no XML metadata:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: How to Extend PDF Metadata
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Attribute [`Document.metadata`](document.html#Document.metadata "Document.metadata")
    is designed so it works for all [supported document types](how-to-open-a-file.html#supported-file-types)
    in the same way: it is a Python dictionary with a **fixed set of key-value pairs**.
    Correspondingly, [`Document.set_metadata()`](document.html#Document.set_metadata
    "Document.set_metadata") only accepts standard keys.'
  prefs: []
  type: TYPE_NORMAL
- en: However, PDFs may contain items not accessible like this. Also, there may be
    reasons to store additional information, like copyrights. Here is a way to handle
    **arbitrary metadata items** by using PyMuPDF low-level functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, look at this standard metadata output of some PDF:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the following code to see **all items** stored in the metadata object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '*Vice versa*, you can also **store private metadata items** in a PDF. It is
    your responsibility to make sure that these items conform to PDF specifications
    - especially they must be (unicode) strings. Consult section 14.3 (p. 548) of
    the [Adobe PDF References](app3.html#adobemanual) for details and caveats:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: To delete selected keys, use `doc.xref_set_key(xref, "mykey", "null")`. As explained
    in the next section, string “null” is the PDF equivalent to Python’s `None`. A
    key with that value will be treated as not being specified – and physically removed
    in garbage collections.
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: How to Read and Update PDF Objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There also exist granular, elegant ways to access and manipulate selected PDF
    [`dictionary`](glossary.html#dictionary "dictionary") keys.
  prefs: []
  type: TYPE_NORMAL
- en: '[`Document.xref_get_keys()`](document.html#Document.xref_get_keys "Document.xref_get_keys")
    returns the PDF keys of the object at [`xref`](glossary.html#xref "xref"):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Compare with the full object definition:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Single keys can also be accessed directly via [`Document.xref_get_key()`](document.html#Document.xref_get_key
    "Document.xref_get_key"). The value **always is a string** together with type
    information, that helps with interpreting it:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here is a full listing of the above page keys:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: An undefined key inquiry returns `('null', 'null')` – PDF object type `null`
    corresponds to `None` in Python. Similar for the booleans `true` and `false`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let us add a new key to the page definition that sets its rotation to 90 degrees
    (you are aware that there actually exists [`Page.set_rotation()`](page.html#Page.set_rotation
    "Page.set_rotation") for this?):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This method can also be used to remove a key from the [`xref`](glossary.html#xref
    "xref") dictionary by setting its value to `null`: The following will remove the
    rotation specification from the page: `doc.xref_set_key(page.xref, "Rotate", "null")`.
    Similarly, to remove all links, annotations and fields from a page, use `doc.xref_set_key(page.xref,
    "Annots", "null")`. Because `Annots` by definition is an array, setting en empty
    array with the statement `doc.xref_set_key(page.xref, "Annots", "[]")` would do
    the same job in this case.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'PDF dictionaries can be hierarchically nested. In the following page object
    definition both, [Font](font.html#font) and `XObject` are subdictionaries of `Resources`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The above situation **is supported** by methods [`Document.xref_set_key()`](document.html#Document.xref_set_key
    "Document.xref_set_key") and [`Document.xref_get_key()`](document.html#Document.xref_get_key
    "Document.xref_get_key"): use a path-like notation to point at the required key.
    For example, to retrieve the value of key `Im1` above, specify the complete chain
    of dictionaries “above” it in the key argument: `"Resources/XObject/Im1"`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The path notation can also be used to **directly set a value**: use the following
    to let `Im1` point to a different object:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Be aware, that **no semantic checks** whatsoever will take place here: if the
    PDF has no xref 9999, it won’t be detected at this point.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If a key does not exist, it will be created by setting its value. Moreover,
    if any intermediate keys do not exist either, they will also be created as necessary.
    The following creates an array `D` several levels below the existing dictionary
    `A`. Intermediate dictionaries `B` and `C` are automatically created:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When setting key values, basic **PDF syntax checking** will be done by MuPDF.
    For example, new keys can only be created **below a dictionary**. The following
    tries to create some new string item `E` below the previously created array `D`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'It is also **not possible**, to create a key if some higher level key is an
    **“indirect”** object, i.e. an xref. In other words, xrefs can only be modified
    directly and not implicitly via other objects referencing them:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Caution
  prefs: []
  type: TYPE_NORMAL
- en: These are expert functions! There are no validations as to whether valid PDF
    objects, xrefs, etc. are specified. As with other low-level methods there is the
    risk to render the PDF, or parts of it unusable.
  prefs: []
  type: TYPE_NORMAL
- en: Do you have any feedback on this page?
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: This software is provided AS-IS with no warranty, either express or implied.
    This software is distributed under license and may not be copied, modified or
    distributed except as expressly authorized under the terms of that license. Refer
    to licensing information at [artifex.com](https://www.artifex.com?utm_source=rtd-pymupdf&utm_medium=rtd&utm_content=footer-link)
    or contact Artifex Software Inc., 39 Mesa Street, Suite 108A, San Francisco CA
    94129, United States for further information.
  prefs: []
  type: TYPE_NORMAL
- en: This documentation covers all versions up to 1.24.4.
  prefs: []
  type: TYPE_NORMAL
- en: '[![Discord logo](../Images/66cbb5081103a580193aa66c87b90d9a.png)](https://discord.gg/TSpYGBW4eq)'
  prefs: []
  type: TYPE_NORMAL
- en: How to Iterate through the [`xref`](glossary.html#xref "xref") Table
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A PDF’s [`xref`](glossary.html#xref "xref") table is a list of all objects
    defined in the file. This table may easily contain many thousands of entries –
    the manual [Adobe PDF References](app3.html#adobemanual) for example has 127,000
    objects. Table entry “0” is reserved and must not be touched. The following script
    loops through the [`xref`](glossary.html#xref "xref") table and prints each object’s
    definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This produces the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: A PDF object definition is an ordinary ASCII string.
  prefs: []
  type: TYPE_NORMAL
- en: How to Handle Object Streams
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some object types contain additional data apart from their object definition.
    Examples are images, fonts, embedded files or commands describing the appearance
    of a page.
  prefs: []
  type: TYPE_NORMAL
- en: Objects of these types are called “stream objects”. PyMuPDF allows reading an
    object’s stream via method [`Document.xref_stream()`](document.html#Document.xref_stream
    "Document.xref_stream") with the object’s [`xref`](glossary.html#xref "xref")
    as an argument. It is also possible to write back a modified version of a stream
    using [`Document.update_stream()`](document.html#Document.update_stream "Document.update_stream").
  prefs: []
  type: TYPE_NORMAL
- en: 'Assume that the following snippet wants to read all streams of a PDF for whatever
    reason:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[`Document.xref_stream()`](document.html#Document.xref_stream "Document.xref_stream")
    automatically returns a stream decompressed as a bytes object – and [`Document.update_stream()`](document.html#Document.update_stream
    "Document.update_stream") automatically compresses it if beneficial.'
  prefs: []
  type: TYPE_NORMAL
- en: How to Handle Page Contents
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A PDF page can have zero or multiple [`contents`](glossary.html#contents "contents")
    objects. These are stream objects describing **what** appears **where** and **how**
    on a page (like text and images). They are written in a special mini-language
    described e.g. in chapter “APPENDIX A - Operator Summary” on page 643 of the [Adobe
    PDF References](app3.html#adobemanual).
  prefs: []
  type: TYPE_NORMAL
- en: Every PDF reader application must be able to interpret the contents syntax to
    reproduce the intended appearance of the page.
  prefs: []
  type: TYPE_NORMAL
- en: If multiple [`contents`](glossary.html#contents "contents") objects are provided,
    they must be interpreted in the specified sequence in exactly the same way as
    if they were provided as a concatenation of the several.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are good technical arguments for having multiple [`contents`](glossary.html#contents
    "contents") objects:'
  prefs: []
  type: TYPE_NORMAL
- en: It is a lot easier and faster to just add new [`contents`](glossary.html#contents
    "contents") objects than maintaining a single big one (which entails reading,
    decompressing, modifying, recompressing, and rewriting it for each change).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When working with incremental updates, a modified big [`contents`](glossary.html#contents
    "contents") object will bloat the update delta and can thus easily negate the
    efficiency of incremental saves.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, PyMuPDF adds new, small [`contents`](glossary.html#contents "contents")
    objects in methods [`Page.insert_image()`](page.html#Page.insert_image "Page.insert_image"),
    [`Page.show_pdf_page()`](page.html#Page.show_pdf_page "Page.show_pdf_page") and
    the [Shape](shape.html#shape) methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there are also situations when a **single** [`contents`](glossary.html#contents
    "contents") object is beneficial: it is easier to interpret and more compressible
    than multiple smaller ones.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are two ways of combining multiple contents of a page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The clean function [`Page.clean_contents()`](functions.html#Page.clean_contents
    "Page.clean_contents") does a lot more than just glueing [`contents`](glossary.html#contents
    "contents") objects: it also corrects and optimizes the PDF operator syntax of
    the page and removes any inconsistencies with the page’s object definition.'
  prefs: []
  type: TYPE_NORMAL
- en: How to Access the PDF Catalog
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is a central (“root”) object of a PDF. It serves as a starting point to
    reach important other objects and it also contains some global options for the
    PDF:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Indentation, line breaks and comments are inserted here for clarification purposes
    only and will not normally appear. For more information on the PDF catalog see
    section 7.7.2 on page 71 of the [Adobe PDF References](app3.html#adobemanual).
  prefs: []
  type: TYPE_NORMAL
- en: How to Access the PDF File Trailer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The trailer of a PDF file is a [`dictionary`](glossary.html#dictionary "dictionary")
    located towards the end of the file. It contains special objects, and pointers
    to important other information. See [Adobe PDF References](app3.html#adobemanual)
    p. 42\. Here is an overview:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Key** | **Type** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Size | int | Number of entries in the cross-reference table + 1. |'
  prefs: []
  type: TYPE_TB
- en: '| Prev | int | Offset to previous [`xref`](glossary.html#xref "xref") section
    (indicates incremental updates). |'
  prefs: []
  type: TYPE_TB
- en: '| Root | dictionary | (indirect) Pointer to the catalog. See previous section.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Encrypt | dictionary | Pointer to encryption object (encrypted files only).
    |'
  prefs: []
  type: TYPE_TB
- en: '| Info | dictionary | (indirect) Pointer to information (metadata). |'
  prefs: []
  type: TYPE_TB
- en: '| ID | array | File identifier consisting of two byte strings. |'
  prefs: []
  type: TYPE_TB
- en: '| XRefStm | int | Offset of a cross-reference stream. See [Adobe PDF References](app3.html#adobemanual)
    p. 49. |'
  prefs: []
  type: TYPE_TB
- en: Access this information via PyMuPDF with [`Document.pdf_trailer()`](document.html#Document.pdf_trailer
    "Document.pdf_trailer") or, equivalently, via [`Document.xref_object()`](document.html#Document.xref_object
    "Document.xref_object") using -1 instead of a valid [`xref`](glossary.html#xref
    "xref") number.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: How to Access XML Metadata
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A PDF may contain XML metadata in addition to the standard metadata format.
    In fact, most PDF viewer or modification software adds this type of information
    when saving the PDF (Adobe, Nitro PDF, PDF-XChange, etc.).
  prefs: []
  type: TYPE_NORMAL
- en: PyMuPDF has no way to **interpret or change** this information directly, because
    it contains no XML features. XML metadata is however stored as a [`stream`](glossary.html#stream
    "stream") object, so it can be read, modified with appropriate software and written
    back.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Using some XML package, the XML data can be interpreted and / or modified and
    then stored back. The following also works, if the PDF previously had no XML metadata:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: How to Extend PDF Metadata
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Attribute [`Document.metadata`](document.html#Document.metadata "Document.metadata")
    is designed so it works for all [supported document types](how-to-open-a-file.html#supported-file-types)
    in the same way: it is a Python dictionary with a **fixed set of key-value pairs**.
    Correspondingly, [`Document.set_metadata()`](document.html#Document.set_metadata
    "Document.set_metadata") only accepts standard keys.'
  prefs: []
  type: TYPE_NORMAL
- en: However, PDFs may contain items not accessible like this. Also, there may be
    reasons to store additional information, like copyrights. Here is a way to handle
    **arbitrary metadata items** by using PyMuPDF low-level functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, look at this standard metadata output of some PDF:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the following code to see **all items** stored in the metadata object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '*Vice versa*, you can also **store private metadata items** in a PDF. It is
    your responsibility to make sure that these items conform to PDF specifications
    - especially they must be (unicode) strings. Consult section 14.3 (p. 548) of
    the [Adobe PDF References](app3.html#adobemanual) for details and caveats:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: To delete selected keys, use `doc.xref_set_key(xref, "mykey", "null")`. As explained
    in the next section, string “null” is the PDF equivalent to Python’s `None`. A
    key with that value will be treated as not being specified – and physically removed
    in garbage collections.
  prefs: []
  type: TYPE_NORMAL
- en: How to Read and Update PDF Objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There also exist granular, elegant ways to access and manipulate selected PDF
    [`dictionary`](glossary.html#dictionary "dictionary") keys.
  prefs: []
  type: TYPE_NORMAL
- en: '[`Document.xref_get_keys()`](document.html#Document.xref_get_keys "Document.xref_get_keys")
    returns the PDF keys of the object at [`xref`](glossary.html#xref "xref"):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Compare with the full object definition:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Single keys can also be accessed directly via [`Document.xref_get_key()`](document.html#Document.xref_get_key
    "Document.xref_get_key"). The value **always is a string** together with type
    information, that helps with interpreting it:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here is a full listing of the above page keys:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: An undefined key inquiry returns `('null', 'null')` – PDF object type `null`
    corresponds to `None` in Python. Similar for the booleans `true` and `false`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let us add a new key to the page definition that sets its rotation to 90 degrees
    (you are aware that there actually exists [`Page.set_rotation()`](page.html#Page.set_rotation
    "Page.set_rotation") for this?):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This method can also be used to remove a key from the [`xref`](glossary.html#xref
    "xref") dictionary by setting its value to `null`: The following will remove the
    rotation specification from the page: `doc.xref_set_key(page.xref, "Rotate", "null")`.
    Similarly, to remove all links, annotations and fields from a page, use `doc.xref_set_key(page.xref,
    "Annots", "null")`. Because `Annots` by definition is an array, setting en empty
    array with the statement `doc.xref_set_key(page.xref, "Annots", "[]")` would do
    the same job in this case.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'PDF dictionaries can be hierarchically nested. In the following page object
    definition both, [Font](font.html#font) and `XObject` are subdictionaries of `Resources`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The above situation **is supported** by methods [`Document.xref_set_key()`](document.html#Document.xref_set_key
    "Document.xref_set_key") and [`Document.xref_get_key()`](document.html#Document.xref_get_key
    "Document.xref_get_key"): use a path-like notation to point at the required key.
    For example, to retrieve the value of key `Im1` above, specify the complete chain
    of dictionaries “above” it in the key argument: `"Resources/XObject/Im1"`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The path notation can also be used to **directly set a value**: use the following
    to let `Im1` point to a different object:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Be aware, that **no semantic checks** whatsoever will take place here: if the
    PDF has no xref 9999, it won’t be detected at this point.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If a key does not exist, it will be created by setting its value. Moreover,
    if any intermediate keys do not exist either, they will also be created as necessary.
    The following creates an array `D` several levels below the existing dictionary
    `A`. Intermediate dictionaries `B` and `C` are automatically created:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When setting key values, basic **PDF syntax checking** will be done by MuPDF.
    For example, new keys can only be created **below a dictionary**. The following
    tries to create some new string item `E` below the previously created array `D`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'It is also **not possible**, to create a key if some higher level key is an
    **“indirect”** object, i.e. an xref. In other words, xrefs can only be modified
    directly and not implicitly via other objects referencing them:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Caution
  prefs: []
  type: TYPE_NORMAL
- en: These are expert functions! There are no validations as to whether valid PDF
    objects, xrefs, etc. are specified. As with other low-level methods there is the
    risk to render the PDF, or parts of it unusable.
  prefs: []
  type: TYPE_NORMAL
- en: Do you have any feedback on this page?
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: This software is provided AS-IS with no warranty, either express or implied.
    This software is distributed under license and may not be copied, modified or
    distributed except as expressly authorized under the terms of that license. Refer
    to licensing information at [artifex.com](https://www.artifex.com?utm_source=rtd-pymupdf&utm_medium=rtd&utm_content=footer-link)
    or contact Artifex Software Inc., 39 Mesa Street, Suite 108A, San Francisco CA
    94129, United States for further information.
  prefs: []
  type: TYPE_NORMAL
- en: This documentation covers all versions up to 1.24.4.
  prefs: []
  type: TYPE_NORMAL
- en: '[![Discord logo](../Images/66cbb5081103a580193aa66c87b90d9a.png)](https://discord.gg/TSpYGBW4eq)'
  prefs: []
  type: TYPE_NORMAL
