["```py\nimport jax\nimport jax.numpy as jnp \n```", "```py\ndef g(W, x):\n  y = jnp.dot(W, x)\n  return jnp.sin(y)\n\ndef f(W1, W2, W3, x):\n  x = g(W1, x)\n  x = g(W2, x)\n  x = g(W3, x)\n  return x\n\nW1 = jnp.ones((5, 4))\nW2 = jnp.ones((6, 5))\nW3 = jnp.ones((7, 6))\nx = jnp.ones(4)\n\n# Inspect the 'residual' values to be saved on the forward pass\n# if we were to evaluate `jax.grad(f)(W1, W2, W3, x)`\nfrom jax.ad_checkpoint import print_saved_residuals\njax.ad_checkpoint.print_saved_residuals(f, W1, W2, W3, x) \n```", "```py\nf32[5,4] from the argument 'W1'\nf32[6,5] from the argument 'W2'\nf32[7,6] from the argument 'W3'\nf32[4] from the argument 'x'\nf32[5] output of sin from <ipython-input-4-f510dde58e22>:3 (g)\nf32[5] output of cos from <ipython-input-4-f510dde58e22>:3 (g)\nf32[6] output of sin from <ipython-input-4-f510dde58e22>:3 (g)\nf32[6] output of cos from <ipython-input-4-f510dde58e22>:3 (g)\nf32[7] output of cos from <ipython-input-4-f510dde58e22>:3 (g) \n```", "```py\ndef f2(W1, W2, W3, x):\n  x = jax.checkpoint(g)(W1, x)\n  x = jax.checkpoint(g)(W2, x)\n  x = jax.checkpoint(g)(W3, x)\n  return x\n\njax.ad_checkpoint.print_saved_residuals(f2, W1, W2, W3, x) \n```", "```py\nf32[5,4] from the argument 'W1'\nf32[6,5] from the argument 'W2'\nf32[7,6] from the argument 'W3'\nf32[4] from the argument 'x'\nf32[5] output of sin from <ipython-input-4-f510dde58e22>:3 (g)\nf32[6] output of sin from <ipython-input-4-f510dde58e22>:3 (g) \n```", "```py\nf3 = jax.checkpoint(f, policy=jax.checkpoint_policies.dots_with_no_batch_dims_saveable)\njax.ad_checkpoint.print_saved_residuals(f3, W1, W2, W3, x) \n```", "```py\nf32[5,4] from the argument 'W1'\nf32[6,5] from the argument 'W2'\nf32[7,6] from the argument 'W3'\nf32[4] from the argument 'x'\nf32[5] output of dot_general from <ipython-input-4-f510dde58e22>:2 (g)\nf32[6] output of dot_general from <ipython-input-4-f510dde58e22>:2 (g)\nf32[7] output of dot_general from <ipython-input-4-f510dde58e22>:2 (g) \n```", "```py\nfrom jax.ad_checkpoint import checkpoint_name\n\ndef f4(W1, W2, W3, x):\n  x = checkpoint_name(g(W1, x), name='a')\n  x = checkpoint_name(g(W2, x), name='b')\n  x = checkpoint_name(g(W3, x), name='c')\n  return x\n\nf4 = jax.checkpoint(f4, policy=jax.checkpoint_policies.save_only_these_names('a'))\njax.ad_checkpoint.print_saved_residuals(f4, W1, W2, W3, x) \n```", "```py\nf32[5,4] from the argument 'W1'\nf32[6,5] from the argument 'W2'\nf32[7,6] from the argument 'W3'\nf32[4] from the argument 'x'\nf32[5] named 'a' from <ipython-input-7-fc0ed1c14b8d>:4 (f4) \n```", "```py\nfrom jax.tree_util import tree_flatten, tree_unflatten\n\nfrom rich.console import Console\nfrom rich.table import Table\nimport rich.text\n\ndef print_fwd_bwd(f, *args, **kwargs) -> None:\n  args, in_tree = tree_flatten((args, kwargs))\n\n  def f_(*args):\n    args, kwargs = tree_unflatten(in_tree, args)\n    return f(*args, **kwargs)\n\n  fwd = jax.make_jaxpr(lambda *args: jax.vjp(f_, *args))(*args).jaxpr\n\n  y, f_vjp = jax.vjp(f_, *args)\n  res, in_tree = tree_flatten(f_vjp)\n\n  def g_(*args):\n    *res, y = args\n    f_vjp = tree_unflatten(in_tree, res)\n    return f_vjp(y)\n\n  bwd = jax.make_jaxpr(g_)(*res, y).jaxpr\n\n  table = Table(show_header=False, show_lines=True, padding=(1, 2, 0, 2), box=None)\n  table.add_row(\"[bold green]forward computation:\",\n                \"[bold green]backward computation:\")\n  table.add_row(rich.text.Text.from_ansi(str(fwd)),\n                rich.text.Text.from_ansi(str(bwd)))\n  console = Console(width=240, force_jupyter=True)\n  console.print(table)\n\ndef _renderable_repr(self):\n  return self.html\nrich.jupyter.JupyterRenderable._repr_html_ = _renderable_repr \n```", "```py\n# no use of jax.checkpoint:\nprint_fwd_bwd(f, W1, W2, W3, x) \n```", "```py\n\n  forward computation:                                                        backward computation:                                                                   \n\n  { lambda ; a:f32[5,4] b:f32[6,5] c:f32[7,6] d:f32[4]. let                   { lambda ; a:f32[7] b:f32[6] c:f32[7,6] d:f32[6] e:f32[5] f:f32[6,5] g:f32[5] h:f32[4]  \n   e:f32[5] = dot_general[dimension_numbers=(([1], [0]), ([], []))] a d        i:f32[5,4] j:f32[7]. let                                                            \n      f:f32[5] = sin e                                                         k:f32[7] = mul j a                                                                  \n      g:f32[5] = cos e                                                            l:f32[6] = dot_general[dimension_numbers=(([0], [0]), ([], []))] k c                \n      h:f32[6] = dot_general[dimension_numbers=(([1], [0]), ([], []))] b f        m:f32[7,6] = dot_general[dimension_numbers=(([], []), ([], []))] k b                \n      i:f32[6] = sin h                                                            n:f32[6] = mul l d                                                                  \n      j:f32[6] = cos h                                                            o:f32[5] = dot_general[dimension_numbers=(([0], [0]), ([], []))] n f                \n      k:f32[7] = dot_general[dimension_numbers=(([1], [0]), ([], []))] c i        p:f32[6,5] = dot_general[dimension_numbers=(([], []), ([], []))] n e                \n      l:f32[7] = sin k                                                            q:f32[5] = mul o g                                                                  \n      m:f32[7] = cos k                                                            r:f32[4] = dot_general[dimension_numbers=(([0], [0]), ([], []))] q i                \n   in (l, m, i, c, j, f, b, g, d, a) }                                           s:f32[5,4] = dot_general[dimension_numbers=(([], []), ([], []))] q h                \n                                                                               in (s, p, m, r) }                                                                     \n\n```", "```py\n# using jax.checkpoint with policy=jax.checkpoint_policies.dots_with_no_batch_dims_saveable:\nprint_fwd_bwd(f3, W1, W2, W3, x) \n```", "```py\n\n  forward computation:                                                        backward computation:                                                                          \n\n  { lambda ; a:f32[5,4] b:f32[6,5] c:f32[7,6] d:f32[4]. let                   { lambda ; a:f32[5] b:f32[6] c:f32[7] d:f32[5,4] e:f32[6,5] f:f32[7,6] g:f32[4] h:f32[7]. let  \n   e:f32[5] = dot_general[dimension_numbers=(([1], [0]), ([], []))] a d     i:f32[5,4] j:f32[6,5] k:f32[7,6] l:f32[4] = remat2[                                        \n      f:f32[5] = sin e                                                              differentiated=True                                                                      \n      g:f32[6] = dot_general[dimension_numbers=(([1], [0]), ([], []))] b f    jaxpr={ lambda ; m:f32[5] n:f32[6] o:f32[7] p:f32[5,4] q:f32[6,5] r:f32[7,6]             \n      h:f32[6] = sin g                                                                  s:f32[4] t:f32[7]. let                                                               \n      i:f32[7] = dot_general[dimension_numbers=(([1], [0]), ([], []))] c h     u:f32[5] = sin m                                                                     \n      j:f32[7] = sin i                                                                  v:f32[5] = cos m                                                                     \n   in (j, e, g, i, a, b, c, d) }                                                       w:f32[6] = sin n                                                                     \n                                                                                        x:f32[6] = cos n                                                                     \n                                                                                        y:f32[7] = cos o                                                                     \n                                                                                        z:f32[7] = mul t y                                                                   \n                                                                                        ba:f32[6] = dot_general[dimension_numbers=(([0], [0]), ([], []))] z r                \n                                                                                        bb:f32[6] = mul ba x                                                                 \n                                                                                        bc:f32[5] = dot_general[dimension_numbers=(([0], [0]), ([], []))] bb q               \n                                                                                        bd:f32[5] = mul bc v                                                                 \n                                                                                        be:f32[4] = dot_general[dimension_numbers=(([0], [0]), ([], []))] bd p               \n                                                                                        bf:f32[5,4] = dot_general[dimension_numbers=(([], []), ([], []))] bd s               \n                                                                                        bg:f32[6,5] = dot_general[dimension_numbers=(([], []), ([], []))] bb u               \n                                                                                        bh:f32[7,6] = dot_general[dimension_numbers=(([], []), ([], []))] z w                \n                                                                               in (bf, bg, bh, be) }                                                                  \n                                                                                    policy=<function dot_with_no_batch_dims at 0x7f5e469b1700>                               \n                                                                                    prevent_cse=True                                                                         \n                                                                                  ] a b c d e f g h                                                                          \n                                                                               in (i, j, k, l) }                                                                            \n\n```", "```py\ndef sin_vjp(x):\n  y = jnp.sin(x)\n  cos_x = jnp.cos(x)\n  return y, lambda y_bar: cos_x * y_bar \n```", "```py\ndef sin_vjp2(x):\n  y = jnp.sin(x)\n  return y, lambda y_bar: jnp.cos(x) * y_bar \n```", "```py\ndef f(x):\n  y = g(x)\n  z = h(y)\n  return z\n\ndef f_vjp(x):\n  y, g_vjp = jax.vjp(g, x)\n  z, h_vjp = jax.vjp(h, y)\n  def f_bwd(z_bar):\n    y_bar, = h_vjp(z_bar)\n    x_bar, = g_vjp(y_bar)\n    return x_bar\n  return z, f_bwd \n```", "```py\ndef f_vjp_checkpoint(x):\n  y = g(x)\n  z, h_vjp = jax.vjp(h, y)\n  def f_bwd2(z_bar):\n    y_bar, = h_vjp(z_bar)\n    _, g_vjp = jax.vjp(g, x)\n    x_bar, = g_vjp(y_bar)\n    return x_bar\n  return z, f_bwd2 \n```", "```py\ndef f_checkpoint(x):\n  y = jax.checkpoint(g)(x)\n  z = h(y)\n  return z \n```", "```py\ndef f_checkpoint_grad(x):\n  y = g(x)                  # step 1\n  _, h_vjp = jax.vjp(h)(y)  # step 2\n  y_bar, = h_vjp(1.0)       # step 3\n  _, g_vjp = jax.vjp(g, x)  # step 4\n  x_bar, = g_vjp(y_bar)     # step 5\n  return x_bar \n```", "```py\ndef f_grad_bad(x):\n  _ = f(x)                  # step 1\n  _, f_vjp = jax.vjp(f, x)  # step 2\n  x_bar, = f_vjp(1.0)       # step 3\n  return x_bar \n```", "```py\ndef f_grad_bad2(x):\n  y, g_vjp = jax.vjp(g, x)  # step 1\n  z = h(y)                  # step 2\n  _, h_vjp = jax.vjp(h, y)  # step 3\n  y_bar, = h_vjp(1.0)       # step 3\n  x_bar, = g_vjp(y_bar)     # step 5\n  return x_bar \n```", "```py\ndef loss(params, x, y):\n  return jnp.sum((predict(params, x) - y)**2)\n\ndef predict(params, x):\n  *Ws, Wlast = params\n  for W in Ws:\n    x = layer(W, x)\n  x = jnp.dot(Wlast, x)\n  return x\n\ndef layer(W, x):\n  return jnp.sin(jnp.dot(W, x)) \n```", "```py\nW1 = W2 = W3 = jnp.ones((4, 4))\nparams = [W1, W2, W3]\nx = jnp.ones(4)\ny = jnp.ones(4) \n```", "```py\nprint_saved_residuals(loss, params, x, y) \n```", "```py\nf32[4,4] from the argument 'params'\nf32[4,4] from the argument 'params'\nf32[4,4] from the argument 'params'\nf32[4] from the argument 'x'\nf32[4] output of sin from <ipython-input-18-3808b5023c3d>:12 (layer)\nf32[4] output of cos from <ipython-input-18-3808b5023c3d>:12 (layer)\nf32[4] output of sin from <ipython-input-18-3808b5023c3d>:12 (layer)\nf32[4] output of cos from <ipython-input-18-3808b5023c3d>:12 (layer)\nf32[4] output of mul from <ipython-input-18-3808b5023c3d>:2 (loss) \n```", "```py\nloss_checkpoint = jax.checkpoint(loss, policy=jax.checkpoint_policies.dots_with_no_batch_dims_saveable)\nprint_saved_residuals(loss_checkpoint, params, x, y) \n```", "```py\nf32[4,4] from the argument 'params'\nf32[4,4] from the argument 'params'\nf32[4,4] from the argument 'params'\nf32[4] from the argument 'x'\nf32[4] from the argument 'y'\nf32[4] output of dot_general from <ipython-input-18-3808b5023c3d>:12 (layer)\nf32[4] output of dot_general from <ipython-input-18-3808b5023c3d>:12 (layer)\nf32[4] output of dot_general from <ipython-input-18-3808b5023c3d>:8 (predict) \n```", "```py\nfrom jax.ad_checkpoint import checkpoint_name\n\ndef predict(params, x):\n  *Ws, Wlast = params\n  for i, W in enumerate(Ws):\n    x = layer(W, x)\n    x = checkpoint_name(x, name=f'layer{i}_output')\n  x = jnp.dot(Wlast, x)\n  return x \n```", "```py\nprint_saved_residuals(loss, params, x, y) \n```", "```py\nf32[4,4] from the argument 'params'\nf32[4,4] from the argument 'params'\nf32[4,4] from the argument 'params'\nf32[4] from the argument 'x'\nf32[4] output of cos from <ipython-input-18-3808b5023c3d>:12 (layer)\nf32[4] named 'layer0_output' from <ipython-input-22-e48aedf368ad>:7 (predict)\nf32[4] output of cos from <ipython-input-18-3808b5023c3d>:12 (layer)\nf32[4] named 'layer1_output' from <ipython-input-22-e48aedf368ad>:7 (predict)\nf32[4] output of mul from <ipython-input-18-3808b5023c3d>:2 (loss) \n```", "```py\nloss_checkpoint2 = jax.checkpoint(loss, policy=jax.checkpoint_policies.save_any_names_but_these('layer1_output'))\nprint_saved_residuals(loss_checkpoint2, params, x, y) \n```", "```py\nf32[4,4] from the argument 'params'\nf32[4,4] from the argument 'params'\nf32[4,4] from the argument 'params'\nf32[4] from the argument 'x'\nf32[4] from the argument 'y' \n```", "```py\ndef chain_compose(funs):\n  def f(x):\n    for fun in funs:\n      x = fun(x)\n    return x\n  return f\n\nf = chain_compose([jnp.sin] * 8)\nprint_saved_residuals(f, 3.) \n```", "```py\nf32[] output of cos from <ipython-input-25-46b5594773cb>:4 (f)\nf32[] output of cos from <ipython-input-25-46b5594773cb>:4 (f)\nf32[] output of cos from <ipython-input-25-46b5594773cb>:4 (f)\nf32[] output of cos from <ipython-input-25-46b5594773cb>:4 (f)\nf32[] output of cos from <ipython-input-25-46b5594773cb>:4 (f)\nf32[] output of cos from <ipython-input-25-46b5594773cb>:4 (f)\nf32[] output of cos from <ipython-input-25-46b5594773cb>:4 (f)\nf32[] output of cos from <ipython-input-25-46b5594773cb>:4 (f) \n```", "```py\nf = chain_compose([jnp.sin] * 16)\nprint_saved_residuals(f, 3.) \n```", "```py\nf32[] output of cos from <ipython-input-25-46b5594773cb>:4 (f)\nf32[] output of cos from <ipython-input-25-46b5594773cb>:4 (f)\nf32[] output of cos from <ipython-input-25-46b5594773cb>:4 (f)\nf32[] output of cos from <ipython-input-25-46b5594773cb>:4 (f)\nf32[] output of cos from <ipython-input-25-46b5594773cb>:4 (f)\nf32[] output of cos from <ipython-input-25-46b5594773cb>:4 (f)\nf32[] output of cos from <ipython-input-25-46b5594773cb>:4 (f)\nf32[] output of cos from <ipython-input-25-46b5594773cb>:4 (f)\nf32[] output of cos from <ipython-input-25-46b5594773cb>:4 (f)\nf32[] output of cos from <ipython-input-25-46b5594773cb>:4 (f)\nf32[] output of cos from <ipython-input-25-46b5594773cb>:4 (f)\nf32[] output of cos from <ipython-input-25-46b5594773cb>:4 (f)\nf32[] output of cos from <ipython-input-25-46b5594773cb>:4 (f)\nf32[] output of cos from <ipython-input-25-46b5594773cb>:4 (f)\nf32[] output of cos from <ipython-input-25-46b5594773cb>:4 (f)\nf32[] output of cos from <ipython-input-25-46b5594773cb>:4 (f) \n```", "```py\ndef recursive_checkpoint(funs):\n  if len(funs) == 1:\n    return funs[0]\n  elif len(funs) == 2:\n    f1, f2 = funs\n    return lambda x: f1(f2(x))\n  else:\n    f1 = recursive_checkpoint(funs[:len(funs)//2])\n    f2 = recursive_checkpoint(funs[len(funs)//2:])\n    return lambda x: f1(jax.checkpoint(f2)(x)) \n```", "```py\nf = recursive_checkpoint([jnp.sin] * 8)\nprint_saved_residuals(f, 3.) \n```", "```py\nf32[] from the argument 'x'\nf32[] output of sin from <ipython-input-27-86f83c871e81>:6 (<lambda>)\nf32[] output of cos from <ipython-input-27-86f83c871e81>:6 (<lambda>)\nf32[] output of cos from <ipython-input-27-86f83c871e81>:6 (<lambda>) \n```", "```py\nf = recursive_checkpoint([jnp.sin] * 16)\nprint_saved_residuals(f, 3.) \n```", "```py\nf32[] from the argument 'x'\nf32[] output of sin from <ipython-input-27-86f83c871e81>:6 (<lambda>)\nf32[] output of sin from <ipython-input-27-86f83c871e81>:6 (<lambda>)\nf32[] output of cos from <ipython-input-27-86f83c871e81>:6 (<lambda>)\nf32[] output of cos from <ipython-input-27-86f83c871e81>:6 (<lambda>) \n```", "```py\nf = chain_compose([jnp.sin] * 8)\nprint_fwd_bwd(f, 3.) \n```", "```py\n\n  forward computation:                  backward computation:                                                                    \n\n  { lambda ; a:f32[]. let               { lambda ; a:f32[] b:f32[] c:f32[] d:f32[] e:f32[] f:f32[] g:f32[] h:f32[] i:f32[]. let  \n   b:f32[] = sin a                    j:f32[] = mul i a                                                                    \n      c:f32[] = cos a                       k:f32[] = mul j b                                                                    \n      d:f32[] = sin b                       l:f32[] = mul k c                                                                    \n      e:f32[] = cos b                       m:f32[] = mul l d                                                                    \n      f:f32[] = sin d                       n:f32[] = mul m e                                                                    \n      g:f32[] = cos d                       o:f32[] = mul n f                                                                    \n      h:f32[] = sin f                       p:f32[] = mul o g                                                                    \n      i:f32[] = cos f                       q:f32[] = mul p h                                                                    \n      j:f32[] = sin h                    in (q,) }                                                                              \n      k:f32[] = cos h                                                                                                            \n      l:f32[] = sin j                                                                                                            \n      m:f32[] = cos j                                                                                                            \n      n:f32[] = sin l                                                                                                            \n      o:f32[] = cos l                                                                                                            \n      p:f32[] = sin n                                                                                                            \n      q:f32[] = cos n                                                                                                            \n   in (p, q, o, m, k, i, g, e, c) }                                                                                             \n\n```", "```py\nf = recursive_checkpoint([jnp.sin] * 8)\nprint_fwd_bwd(f, 3.) \n```", "```py\n\n  forward computation:                                                              backward computation:                               \n\n  { lambda ; a:f32[]. let                                                           { lambda ; a:f32[] b:f32[] c:f32[] d:f32[]. let     \n   b:f32[] = remat2[                                                              e:f32[] = mul d a                               \n        differentiated=False                                                            f:f32[] = mul e b                               \n  jaxpr={ lambda ; c:f32[]. let d:f32[] = sin c; e:f32[] = sin d in (e,) }        g:f32[] = remat2[                               \n        policy=None                                                                       differentiated=True                           \n        prevent_cse=True                                                            jaxpr={ lambda ; h:f32[] i:f32[]. let         \n      ] a                                                                            j:f32[] = sin h                           \n      f:f32[] = sin b                                                                         k:f32[] = cos h                           \n      g:f32[] = sin f                                                                         l:f32[] = cos j                           \n      h:f32[] = sin g                                                                         m:f32[] = mul i l                         \n      i:f32[] = sin h                                                                         n:f32[] = mul m k                         \n      j:f32[] = sin i                                                                in (n,) }                                   \n      k:f32[] = cos i                                                                     policy=None                                   \n      l:f32[] = sin j                                                                     prevent_cse=True                              \n      m:f32[] = cos j                                                                   ] c f                                           \n   in (l, m, k, g, a) }                                                                o:f32[] = remat2[                               \n                                                                                          differentiated=True                           \n                                                                                    jaxpr={ lambda ; p:f32[] q:f32[]. let         \n                                                                                     r:f32[] = sin p                           \n                                                                                              s:f32[] = sin r                           \n                                                                                              t:f32[] = sin s                           \n                                                                                              u:f32[] = cos s                           \n                                                                                              v:f32[] = cos t                           \n                                                                                              w:f32[] = mul q v                         \n                                                                                              x:f32[] = mul w u                         \n                                                                                              y:f32[] = remat2[                         \n                                                                                                differentiated=True                     \n                                                                                    jaxpr={ lambda ; z:f32[] ba:f32[]. let  \n                                                                                     bb:f32[] = sin z                    \n                                                                                                    bc:f32[] = cos z                    \n                                                                                                    bd:f32[] = cos bb                   \n                                                                                                    be:f32[] = mul ba bd                \n                                                                                                    bf:f32[] = mul be bc                \n                                                                                     in (bf,) }                            \n                                                                                                policy=None                             \n                                                                                                prevent_cse=True                        \n                                                                                              ] p x                                     \n                                                                                     in (y,) }                                   \n                                                                                          policy=None                                   \n                                                                                          prevent_cse=True                              \n                                                                                        ] 3.0 g                                         \n                                                                                     in (o,) }                                         \n\n```", "```py\nLayerParam = tuple[jnp.ndarray, jnp.ndarray]  # weights, bias pair for a layer\nParamsList = list[LayerParam]\n\ndef net(params: ParamsList, x: jnp.ndarray):\n  for W, b in params:\n    x = jnp.maximum(jnp.dot(x, W) + b, 0.)\n  return x \n```", "```py\nStackedWeights = jnp.ndarray  # all weight matrices stacked together\nStackedBiases = jnp.ndarray   # all bias vectors stacked together\n\nall_weights = jnp.stack([W for W, _ in params])\nall_biases = jnp.stack([b for _, b in params])\n\ndef layer(x, W_b_pair):\n  W, b = W_b_pair\n  out = jnp.maximum(jnp.dot(x, W) + b, 0.)\n  return out, None\n\ndef net(all_weights, all_biases, x):\n  x, _ = jax.lax.scan(layer, x, (all_weights, all_biases))\n  return x \n```", "```py\nfrom functools import partial\n\n@partial(jax.checkpoint,\n         policy=jax.checkpoint_policies.dots_with_no_batch_dims_saveable)\ndef layer(x, W_b_pair):\n  W, b = W_b_pair\n  out = jnp.maximum(jnp.dot(x, W) + b, 0.)\n  return out, None \n```"]