["```py\nfrom sqlalchemy.ext.compiler import compiles\nfrom sqlalchemy.types import BINARY\n\n@compiles(BINARY, \"sqlite\")\ndef compile_binary_sqlite(type_, compiler, **kw):\n    return \"BLOB\"\n```", "```py\nclass sqlalchemy.types.TypeDecorator\n```", "```py\nimport sqlalchemy.types as types\n\nclass MyType(types.TypeDecorator):\n  '''Prefixes Unicode values with \"PREFIX:\" on the way in and\n strips it off on the way out.\n '''\n\n    impl = types.Unicode\n\n    cache_ok = True\n\n    def process_bind_param(self, value, dialect):\n        return \"PREFIX:\" + value\n\n    def process_result_value(self, value, dialect):\n        return value[7:]\n\n    def copy(self, **kw):\n        return MyType(self.impl.length)\n```", "```py\nmytable.c.somecol + datetime.date(2009, 5, 15)\n```", "```py\nclass MyEpochType(types.TypeDecorator):\n    impl = types.Integer\n\n    cache_ok = True\n\n    epoch = datetime.date(1970, 1, 1)\n\n    def process_bind_param(self, value, dialect):\n        return (value - self.epoch).days\n\n    def process_result_value(self, value, dialect):\n        return self.epoch + timedelta(days=value)\n```", "```py\ndef coerce_compared_value(self, op, value):\n    if isinstance(value, int):\n        return Integer()\n    else:\n        return self\n```", "```py\nfrom sqlalchemy import JSON\nfrom sqlalchemy import TypeDecorator\n\nclass MyJsonType(TypeDecorator):\n    impl = JSON\n\n    cache_ok = True\n\n    def coerce_compared_value(self, op, value):\n        return self.impl.coerce_compared_value(op, value)\n```", "```py\nfrom sqlalchemy import ARRAY\nfrom sqlalchemy import TypeDecorator\n\nclass MyArrayType(TypeDecorator):\n    impl = ARRAY\n\n    cache_ok = True\n\n    def coerce_compared_value(self, op, value):\n        return self.impl.coerce_compared_value(op, value)\n```", "```py\nattribute cache_ok: bool | None = None\n```", "```py\nclass MyType(TypeDecorator):\n    impl = String\n\n    cache_ok = True\n\n    def __init__(self, choices):\n        self.choices = tuple(choices)\n        self.internal_only = True\n```", "```py\n>>> MyType([\"a\", \"b\", \"c\"])._static_cache_key\n(<class '__main__.MyType'>, ('choices', ('a', 'b', 'c')))\n```", "```py\nclass LookupType(UserDefinedType):\n  '''a custom type that accepts a dictionary as a parameter.\n\n this is the non-cacheable version, as \"self.lookup\" is not\n hashable.\n\n '''\n\n    def __init__(self, lookup):\n        self.lookup = lookup\n\n    def get_col_spec(self, **kw):\n        return \"VARCHAR(255)\"\n\n    def bind_processor(self, dialect):\n        # ...  works with \"self.lookup\" ...\n```", "```py\n>>> type_ = LookupType({\"a\": 10, \"b\": 20})\n>>> type_._static_cache_key\n<stdin>:1: SAWarning: UserDefinedType LookupType({'a': 10, 'b': 20}) will not\nproduce a cache key because the ``cache_ok`` flag is not set to True.\nSet this flag to True if this type object's state is safe to use\nin a cache key, or False to disable this warning.\nsymbol('no_cache')\n```", "```py\n>>> # set cache_ok = True\n>>> type_.cache_ok = True\n\n>>> # this is the cache key it would generate\n>>> key = type_._static_cache_key\n>>> key\n(<class '__main__.LookupType'>, ('lookup', {'a': 10, 'b': 20}))\n\n>>> # however this key is not hashable, will fail when used with\n>>> # SQLAlchemy statement cache\n>>> some_cache = {key: \"some sql value\"}\nTraceback (most recent call last): File \"<stdin>\", line 1,\nin <module> TypeError: unhashable type: 'dict'\n```", "```py\nclass LookupType(UserDefinedType):\n  '''a custom type that accepts a dictionary as a parameter.\n\n The dictionary is stored both as itself in a private variable,\n and published in a public variable as a sorted tuple of tuples,\n which is hashable and will also return the same value for any\n two equivalent dictionaries.  Note it assumes the keys and\n values of the dictionary are themselves hashable.\n\n '''\n\n    cache_ok = True\n\n    def __init__(self, lookup):\n        self._lookup = lookup\n\n        # assume keys/values of \"lookup\" are hashable; otherwise\n        # they would also need to be converted in some way here\n        self.lookup = tuple(\n            (key, lookup[key]) for key in sorted(lookup)\n        )\n\n    def get_col_spec(self, **kw):\n        return \"VARCHAR(255)\"\n\n    def bind_processor(self, dialect):\n        # ...  works with \"self._lookup\" ...\n```", "```py\n>>> LookupType({\"a\": 10, \"b\": 20})._static_cache_key\n(<class '__main__.LookupType'>, ('lookup', (('a', 10), ('b', 20))))\n```", "```py\nclass Comparator\n```", "```py\nmethod operate(op: OperatorType, *other: Any, **kwargs: Any) \u2192 ColumnElement[_CT]\n```", "```py\nclass MyComparator(ColumnOperators):\n    def operate(self, op, other, **kwargs):\n        return op(func.lower(self), func.lower(other), **kwargs)\n```", "```py\nmethod reverse_operate(op: OperatorType, other: Any, **kwargs: Any) \u2192 ColumnElement[_CT]\n```", "```py\nmethod __init__(*args: Any, **kwargs: Any)\n```", "```py\nmethod bind_expression(bindparam: BindParameter[_T]) \u2192 ColumnElement[_T] | None\n```", "```py\nmethod bind_processor(dialect: Dialect) \u2192 _BindProcessorType[_T] | None\n```", "```py\nmethod coerce_compared_value(op: OperatorType | None, value: Any) \u2192 Any\n```", "```py\nexpr = table.c.somecolumn + 35\n```", "```py\nattribute coerce_to_is_types: Sequence[Type[Any]] = (<class 'NoneType'>,)\n```", "```py\nmethod column_expression(column: ColumnElement[_T]) \u2192 ColumnElement[_T] | None\n```", "```py\nattribute comparator_factory: _ComparatorFactory[Any]\n```", "```py\nmethod compare_values(x: Any, y: Any) \u2192 bool\n```", "```py\nmethod copy(**kw: Any) \u2192 Self\n```", "```py\nmethod get_dbapi_type(dbapi: module) \u2192 Any | None\n```", "```py\nmethod literal_processor(dialect: Dialect) \u2192 _LiteralProcessorType[_T] | None\n```", "```py\nmethod load_dialect_impl(dialect: Dialect) \u2192 TypeEngine[Any]\n```", "```py\nmethod process_bind_param(value: _T | None, dialect: Dialect) \u2192 Any\n```", "```py\nmethod process_literal_param(value: _T | None, dialect: Dialect) \u2192 str\n```", "```py\nmethod process_result_value(value: Any | None, dialect: Dialect) \u2192 _T | None\n```", "```py\nmethod result_processor(dialect: Dialect, coltype: Any) \u2192 _ResultProcessorType[_T] | None\n```", "```py\nattribute sort_key_function: Callable[[Any], Any] | None\n```", "```py\nmethod type_engine(dialect: Dialect) \u2192 TypeEngine[Any]\n```", "```py\nfrom sqlalchemy.types import TypeDecorator, Unicode\n\nclass CoerceUTF8(TypeDecorator):\n  \"\"\"Safely coerce Python bytestrings to Unicode\n before passing off to the database.\"\"\"\n\n    impl = Unicode\n\n    def process_bind_param(self, value, dialect):\n        if isinstance(value, str):\n            value = value.decode(\"utf-8\")\n        return value\n```", "```py\nfrom sqlalchemy.types import TypeDecorator, Numeric\nfrom decimal import Decimal\n\nclass SafeNumeric(TypeDecorator):\n  \"\"\"Adds quantization to Numeric.\"\"\"\n\n    impl = Numeric\n\n    def __init__(self, *arg, **kw):\n        TypeDecorator.__init__(self, *arg, **kw)\n        self.quantize_int = -self.impl.scale\n        self.quantize = Decimal(10) ** self.quantize_int\n\n    def process_bind_param(self, value, dialect):\n        if isinstance(value, Decimal) and value.as_tuple()[2] < self.quantize_int:\n            value = value.quantize(self.quantize)\n        return value\n```", "```py\nimport datetime\n\nclass TZDateTime(TypeDecorator):\n    impl = DateTime\n    cache_ok = True\n\n    def process_bind_param(self, value, dialect):\n        if value is not None:\n            if not value.tzinfo or value.tzinfo.utcoffset(value) is None:\n                raise TypeError(\"tzinfo is required\")\n            value = value.astimezone(datetime.timezone.utc).replace(tzinfo=None)\n        return value\n\n    def process_result_value(self, value, dialect):\n        if value is not None:\n            value = value.replace(tzinfo=datetime.timezone.utc)\n        return value\n```", "```py\nfrom operator import attrgetter\nfrom sqlalchemy.types import TypeDecorator, CHAR\nfrom sqlalchemy.dialects.mssql import UNIQUEIDENTIFIER\nfrom sqlalchemy.dialects.postgresql import UUID\nimport uuid\n\nclass GUID(TypeDecorator):\n  \"\"\"Platform-independent GUID type.\n\n Uses PostgreSQL's UUID type or MSSQL's UNIQUEIDENTIFIER,\n otherwise uses CHAR(32), storing as stringified hex values.\n\n \"\"\"\n\n    impl = CHAR\n    cache_ok = True\n\n    _default_type = CHAR(32)\n    _uuid_as_str = attrgetter(\"hex\")\n\n    def load_dialect_impl(self, dialect):\n        if dialect.name == \"postgresql\":\n            return dialect.type_descriptor(UUID())\n        elif dialect.name == \"mssql\":\n            return dialect.type_descriptor(UNIQUEIDENTIFIER())\n        else:\n            return dialect.type_descriptor(self._default_type)\n\n    def process_bind_param(self, value, dialect):\n        if value is None or dialect.name in (\"postgresql\", \"mssql\"):\n            return value\n        else:\n            if not isinstance(value, uuid.UUID):\n                value = uuid.UUID(value)\n            return self._uuid_as_str(value)\n\n    def process_result_value(self, value, dialect):\n        if value is None:\n            return value\n        else:\n            if not isinstance(value, uuid.UUID):\n                value = uuid.UUID(value)\n            return value\n\nclass GUIDHyphens(GUID):\n  \"\"\"Platform-independent GUID type.\n\n Uses PostgreSQL's UUID type or MSSQL's UNIQUEIDENTIFIER,\n otherwise uses CHAR(36), storing as stringified uuid values.\n\n \"\"\"\n\n    _default_type = CHAR(36)\n    _uuid_as_str = str\n```", "```py\nimport uuid\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column\n\nclass Base(DeclarativeBase):\n    type_annotation_map = {\n        uuid.UUID: GUID,\n    }\n```", "```py\nclass MyModel(Base):\n    __tablename__ = \"my_table\"\n\n    id: Mapped[uuid.UUID] = mapped_column(primary_key=True)\n```", "```py\nfrom sqlalchemy.types import TypeDecorator, VARCHAR\nimport json\n\nclass JSONEncodedDict(TypeDecorator):\n  \"\"\"Represents an immutable structure as a json-encoded string.\n\n Usage:\n\n JSONEncodedDict(255)\n\n \"\"\"\n\n    impl = VARCHAR\n\n    cache_ok = True\n\n    def process_bind_param(self, value, dialect):\n        if value is not None:\n            value = json.dumps(value)\n\n        return value\n\n    def process_result_value(self, value, dialect):\n        if value is not None:\n            value = json.loads(value)\n        return value\n```", "```py\nobj.json_value[\"key\"] = \"value\"  # will *not* be detected by the ORM\n\nobj.json_value = {\"key\": \"value\"}  # *will* be detected by the ORM\n```", "```py\njson_type = MutableDict.as_mutable(JSONEncodedDict)\n\nclass MyClass(Base):\n    #  ...\n\n    json_data = Column(json_type)\n```", "```py\nfrom sqlalchemy import type_coerce, String\n\nstmt = select(my_table).where(type_coerce(my_table.c.json_data, String).like(\"%foo%\"))\n```", "```py\nfrom sqlalchemy.sql import operators\nfrom sqlalchemy import String\n\nclass JSONEncodedDict(TypeDecorator):\n    impl = VARCHAR\n\n    cache_ok = True\n\n    def coerce_compared_value(self, op, value):\n        if op in (operators.like_op, operators.not_like_op):\n            return String()\n        else:\n            return self\n\n    def process_bind_param(self, value, dialect):\n        if value is not None:\n            value = json.dumps(value)\n\n        return value\n\n    def process_result_value(self, value, dialect):\n        if value is not None:\n            value = json.loads(value)\n        return value\n```", "```py\nfrom sqlalchemy import func\nfrom sqlalchemy.types import UserDefinedType\n\nclass Geometry(UserDefinedType):\n    def get_col_spec(self):\n        return \"GEOMETRY\"\n\n    def bind_expression(self, bindvalue):\n        return func.ST_GeomFromText(bindvalue, type_=self)\n\n    def column_expression(self, col):\n        return func.ST_AsText(col, type_=self)\n```", "```py\ngeometry = Table(\n    \"geometry\",\n    metadata,\n    Column(\"geom_id\", Integer, primary_key=True),\n    Column(\"geom_data\", Geometry),\n)\n\nprint(\n    select(geometry).where(\n        geometry.c.geom_data == \"LINESTRING(189412 252431,189631 259122)\"\n    )\n)\n```", "```py\nSELECT  geometry.geom_id,  ST_AsText(geometry.geom_data)  AS  geom_data_1\nFROM  geometry\nWHERE  geometry.geom_data  =  ST_GeomFromText(:geom_data_2)\n```", "```py\nprint(select(geometry.c.geom_data.label(\"my_data\")))\n```", "```py\nSELECT  ST_AsText(geometry.geom_data)  AS  my_data\nFROM  geometry\n```", "```py\nfrom sqlalchemy import (\n    create_engine,\n    String,\n    select,\n    func,\n    MetaData,\n    Table,\n    Column,\n    type_coerce,\n    TypeDecorator,\n)\n\nfrom sqlalchemy.dialects.postgresql import BYTEA\n\nclass PGPString(TypeDecorator):\n    impl = BYTEA\n\n    cache_ok = True\n\n    def __init__(self, passphrase):\n        super(PGPString, self).__init__()\n\n        self.passphrase = passphrase\n\n    def bind_expression(self, bindvalue):\n        # convert the bind's type from PGPString to\n        # String, so that it's passed to psycopg2 as is without\n        # a dbapi.Binary wrapper\n        bindvalue = type_coerce(bindvalue, String)\n        return func.pgp_sym_encrypt(bindvalue, self.passphrase)\n\n    def column_expression(self, col):\n        return func.pgp_sym_decrypt(col, self.passphrase)\n\nmetadata_obj = MetaData()\nmessage = Table(\n    \"message\",\n    metadata_obj,\n    Column(\"username\", String(50)),\n    Column(\"message\", PGPString(\"this is my passphrase\")),\n)\n\nengine = create_engine(\"postgresql+psycopg2://scott:tiger@localhost/test\", echo=True)\nwith engine.begin() as conn:\n    metadata_obj.create_all(conn)\n\n    conn.execute(\n        message.insert(),\n        {\"username\": \"some user\", \"message\": \"this is my message\"},\n    )\n\n    print(\n        conn.scalar(select(message.c.message).where(message.c.username == \"some user\"))\n    )\n```", "```py\nINSERT  INTO  message  (username,  message)\n  VALUES  (%(username)s,  pgp_sym_encrypt(%(message)s,  %(pgp_sym_encrypt_1)s))\n  -- {'username': 'some user', 'message': 'this is my message',\n  --  'pgp_sym_encrypt_1': 'this is my passphrase'}\n\nSELECT  pgp_sym_decrypt(message.message,  %(pgp_sym_decrypt_1)s)  AS  message_1\n  FROM  message\n  WHERE  message.username  =  %(username_1)s\n  -- {'pgp_sym_decrypt_1': 'this is my passphrase', 'username_1': 'some user'}\n```", "```py\n>>> from sqlalchemy import column\n>>> expr = column(\"x\").op(\">>\")(column(\"y\"))\n>>> print(expr)\nx  >>  y \n```", "```py\nfrom sqlalchemy import Integer\n\nclass MyInt(Integer):\n    class comparator_factory(Integer.Comparator):\n        def __add__(self, other):\n            return self.op(\"goofy\")(other)\n```", "```py\n>>> sometable = Table(\"sometable\", metadata, Column(\"data\", MyInt))\n>>> print(sometable.c.data + 5)\nsometable.data  goofy  :data_1 \n```", "```py\nfrom sqlalchemy import Integer\n\nclass MyInt(Integer):\n    class comparator_factory(Integer.Comparator):\n        def __add__(self, other):\n            return func.special_addition(self.expr, other)\n```", "```py\nfrom sqlalchemy import Integer, func\n\nclass MyInt(Integer):\n    class comparator_factory(Integer.Comparator):\n        def log(self, other):\n            return func.log(self.expr, other)\n```", "```py\n>>> print(sometable.c.data.log(5))\nlog(:log_1,  :log_2) \n```", "```py\nclass MyInt(Integer):\n    class comparator_factory(Integer.Comparator):\n        def is_frobnozzled(self, other):\n            return self.op(\"--is_frobnozzled->\", is_comparison=True)(other)\n```", "```py\nfrom sqlalchemy import Integer\nfrom sqlalchemy.sql.expression import UnaryExpression\nfrom sqlalchemy.sql import operators\n\nclass MyInteger(Integer):\n    class comparator_factory(Integer.Comparator):\n        def factorial(self):\n            return UnaryExpression(\n                self.expr, modifier=operators.custom_op(\"!\"), type_=MyInteger\n            )\n```", "```py\n>>> from sqlalchemy.sql import column\n>>> print(column(\"x\", MyInteger).factorial())\nx  ! \n```", "```py\nclass sqlalchemy.types.UserDefinedType\n```", "```py\nimport sqlalchemy.types as types\n\nclass MyType(types.UserDefinedType):\n    cache_ok = True\n\n    def __init__(self, precision = 8):\n        self.precision = precision\n\n    def get_col_spec(self, **kw):\n        return \"MYTYPE(%s)\" % self.precision\n\n    def bind_processor(self, dialect):\n        def process(value):\n            return value\n        return process\n\n    def result_processor(self, dialect, coltype):\n        def process(value):\n            return value\n        return process\n```", "```py\ntable = Table('foo', metadata_obj,\n    Column('id', Integer, primary_key=True),\n    Column('data', MyType(16))\n    )\n```", "```py\nattribute cache_ok: bool | None = None\n```", "```py\nclass MyType(TypeDecorator):\n    impl = String\n\n    cache_ok = True\n\n    def __init__(self, choices):\n        self.choices = tuple(choices)\n        self.internal_only = True\n```", "```py\n>>> MyType([\"a\", \"b\", \"c\"])._static_cache_key\n(<class '__main__.MyType'>, ('choices', ('a', 'b', 'c')))\n```", "```py\nclass LookupType(UserDefinedType):\n  '''a custom type that accepts a dictionary as a parameter.\n\n this is the non-cacheable version, as \"self.lookup\" is not\n hashable.\n\n '''\n\n    def __init__(self, lookup):\n        self.lookup = lookup\n\n    def get_col_spec(self, **kw):\n        return \"VARCHAR(255)\"\n\n    def bind_processor(self, dialect):\n        # ...  works with \"self.lookup\" ...\n```", "```py\n>>> type_ = LookupType({\"a\": 10, \"b\": 20})\n>>> type_._static_cache_key\n<stdin>:1: SAWarning: UserDefinedType LookupType({'a': 10, 'b': 20}) will not\nproduce a cache key because the ``cache_ok`` flag is not set to True.\nSet this flag to True if this type object's state is safe to use\nin a cache key, or False to disable this warning.\nsymbol('no_cache')\n```", "```py\n>>> # set cache_ok = True\n>>> type_.cache_ok = True\n\n>>> # this is the cache key it would generate\n>>> key = type_._static_cache_key\n>>> key\n(<class '__main__.LookupType'>, ('lookup', {'a': 10, 'b': 20}))\n\n>>> # however this key is not hashable, will fail when used with\n>>> # SQLAlchemy statement cache\n>>> some_cache = {key: \"some sql value\"}\nTraceback (most recent call last): File \"<stdin>\", line 1,\nin <module> TypeError: unhashable type: 'dict'\n```", "```py\nclass LookupType(UserDefinedType):\n  '''a custom type that accepts a dictionary as a parameter.\n\n The dictionary is stored both as itself in a private variable,\n and published in a public variable as a sorted tuple of tuples,\n which is hashable and will also return the same value for any\n two equivalent dictionaries.  Note it assumes the keys and\n values of the dictionary are themselves hashable.\n\n '''\n\n    cache_ok = True\n\n    def __init__(self, lookup):\n        self._lookup = lookup\n\n        # assume keys/values of \"lookup\" are hashable; otherwise\n        # they would also need to be converted in some way here\n        self.lookup = tuple(\n            (key, lookup[key]) for key in sorted(lookup)\n        )\n\n    def get_col_spec(self, **kw):\n        return \"VARCHAR(255)\"\n\n    def bind_processor(self, dialect):\n        # ...  works with \"self._lookup\" ...\n```", "```py\n>>> LookupType({\"a\": 10, \"b\": 20})._static_cache_key\n(<class '__main__.LookupType'>, ('lookup', (('a', 10), ('b', 20))))\n```", "```py\nmethod coerce_compared_value(op: OperatorType | None, value: Any) \u2192 TypeEngine[Any]\n```", "```py\nattribute ensure_kwarg: str = 'get_col_spec'\n```", "```py\n>>> from sqlalchemy import (\n...     Table,\n...     Column,\n...     MetaData,\n...     create_engine,\n...     PickleType,\n...     Integer,\n... )\n>>> metadata = MetaData()\n>>> my_table = Table(\n...     \"my_table\", metadata, Column(\"id\", Integer), Column(\"data\", PickleType)\n... )\n>>> engine = create_engine(\"sqlite://\", echo=\"debug\")\n>>> my_table.create(engine)\nINFO  sqlalchemy.engine.base.Engine\nCREATE  TABLE  my_table  (\n  id  INTEGER,\n  data  BLOB\n) \n```", "```py\n>>> my_table.c.data.type\nPickleType()\n```", "```py\n>>> metadata_two = MetaData()\n>>> my_reflected_table = Table(\"my_table\", metadata_two, autoload_with=engine)\nINFO  sqlalchemy.engine.base.Engine  PRAGMA  main.table_info(\"my_table\")\nINFO  sqlalchemy.engine.base.Engine  ()\nDEBUG  sqlalchemy.engine.base.Engine  Col  ('cid',  'name',  'type',  'notnull',  'dflt_value',  'pk')\nDEBUG  sqlalchemy.engine.base.Engine  Row  (0,  'id',  'INTEGER',  0,  None,  0)\nDEBUG  sqlalchemy.engine.base.Engine  Row  (1,  'data',  'BLOB',  0,  None,  0)\n\n>>>  my_reflected_table.c.data.type\nBLOB() \n```", "```py\n>>> metadata_three = MetaData()\n>>> my_reflected_table = Table(\n...     \"my_table\",\n...     metadata_three,\n...     Column(\"data\", PickleType),\n...     autoload_with=engine,\n... )\n```", "```py\n>>> my_reflected_table.c.data.type\nPickleType()\n```", "```py\nfrom sqlalchemy import BLOB\nfrom sqlalchemy import event\nfrom sqlalchemy import PickleType\nfrom sqlalchemy import Table\n\n@event.listens_for(Table, \"column_reflect\")\ndef _setup_pickletype(inspector, table, column_info):\n    if isinstance(column_info[\"type\"], BLOB):\n        column_info[\"type\"] = PickleType()\n```", "```py\nfrom sqlalchemy.ext.compiler import compiles\nfrom sqlalchemy.types import BINARY\n\n@compiles(BINARY, \"sqlite\")\ndef compile_binary_sqlite(type_, compiler, **kw):\n    return \"BLOB\"\n```", "```py\nclass sqlalchemy.types.TypeDecorator\n```", "```py\nimport sqlalchemy.types as types\n\nclass MyType(types.TypeDecorator):\n  '''Prefixes Unicode values with \"PREFIX:\" on the way in and\n strips it off on the way out.\n '''\n\n    impl = types.Unicode\n\n    cache_ok = True\n\n    def process_bind_param(self, value, dialect):\n        return \"PREFIX:\" + value\n\n    def process_result_value(self, value, dialect):\n        return value[7:]\n\n    def copy(self, **kw):\n        return MyType(self.impl.length)\n```", "```py\nmytable.c.somecol + datetime.date(2009, 5, 15)\n```", "```py\nclass MyEpochType(types.TypeDecorator):\n    impl = types.Integer\n\n    cache_ok = True\n\n    epoch = datetime.date(1970, 1, 1)\n\n    def process_bind_param(self, value, dialect):\n        return (value - self.epoch).days\n\n    def process_result_value(self, value, dialect):\n        return self.epoch + timedelta(days=value)\n```", "```py\ndef coerce_compared_value(self, op, value):\n    if isinstance(value, int):\n        return Integer()\n    else:\n        return self\n```", "```py\nfrom sqlalchemy import JSON\nfrom sqlalchemy import TypeDecorator\n\nclass MyJsonType(TypeDecorator):\n    impl = JSON\n\n    cache_ok = True\n\n    def coerce_compared_value(self, op, value):\n        return self.impl.coerce_compared_value(op, value)\n```", "```py\nfrom sqlalchemy import ARRAY\nfrom sqlalchemy import TypeDecorator\n\nclass MyArrayType(TypeDecorator):\n    impl = ARRAY\n\n    cache_ok = True\n\n    def coerce_compared_value(self, op, value):\n        return self.impl.coerce_compared_value(op, value)\n```", "```py\nattribute cache_ok: bool | None = None\n```", "```py\nclass MyType(TypeDecorator):\n    impl = String\n\n    cache_ok = True\n\n    def __init__(self, choices):\n        self.choices = tuple(choices)\n        self.internal_only = True\n```", "```py\n>>> MyType([\"a\", \"b\", \"c\"])._static_cache_key\n(<class '__main__.MyType'>, ('choices', ('a', 'b', 'c')))\n```", "```py\nclass LookupType(UserDefinedType):\n  '''a custom type that accepts a dictionary as a parameter.\n\n this is the non-cacheable version, as \"self.lookup\" is not\n hashable.\n\n '''\n\n    def __init__(self, lookup):\n        self.lookup = lookup\n\n    def get_col_spec(self, **kw):\n        return \"VARCHAR(255)\"\n\n    def bind_processor(self, dialect):\n        # ...  works with \"self.lookup\" ...\n```", "```py\n>>> type_ = LookupType({\"a\": 10, \"b\": 20})\n>>> type_._static_cache_key\n<stdin>:1: SAWarning: UserDefinedType LookupType({'a': 10, 'b': 20}) will not\nproduce a cache key because the ``cache_ok`` flag is not set to True.\nSet this flag to True if this type object's state is safe to use\nin a cache key, or False to disable this warning.\nsymbol('no_cache')\n```", "```py\n>>> # set cache_ok = True\n>>> type_.cache_ok = True\n\n>>> # this is the cache key it would generate\n>>> key = type_._static_cache_key\n>>> key\n(<class '__main__.LookupType'>, ('lookup', {'a': 10, 'b': 20}))\n\n>>> # however this key is not hashable, will fail when used with\n>>> # SQLAlchemy statement cache\n>>> some_cache = {key: \"some sql value\"}\nTraceback (most recent call last): File \"<stdin>\", line 1,\nin <module> TypeError: unhashable type: 'dict'\n```", "```py\nclass LookupType(UserDefinedType):\n  '''a custom type that accepts a dictionary as a parameter.\n\n The dictionary is stored both as itself in a private variable,\n and published in a public variable as a sorted tuple of tuples,\n which is hashable and will also return the same value for any\n two equivalent dictionaries.  Note it assumes the keys and\n values of the dictionary are themselves hashable.\n\n '''\n\n    cache_ok = True\n\n    def __init__(self, lookup):\n        self._lookup = lookup\n\n        # assume keys/values of \"lookup\" are hashable; otherwise\n        # they would also need to be converted in some way here\n        self.lookup = tuple(\n            (key, lookup[key]) for key in sorted(lookup)\n        )\n\n    def get_col_spec(self, **kw):\n        return \"VARCHAR(255)\"\n\n    def bind_processor(self, dialect):\n        # ...  works with \"self._lookup\" ...\n```", "```py\n>>> LookupType({\"a\": 10, \"b\": 20})._static_cache_key\n(<class '__main__.LookupType'>, ('lookup', (('a', 10), ('b', 20))))\n```", "```py\nclass Comparator\n```", "```py\nmethod operate(op: OperatorType, *other: Any, **kwargs: Any) \u2192 ColumnElement[_CT]\n```", "```py\nclass MyComparator(ColumnOperators):\n    def operate(self, op, other, **kwargs):\n        return op(func.lower(self), func.lower(other), **kwargs)\n```", "```py\nmethod reverse_operate(op: OperatorType, other: Any, **kwargs: Any) \u2192 ColumnElement[_CT]\n```", "```py\nmethod __init__(*args: Any, **kwargs: Any)\n```", "```py\nmethod bind_expression(bindparam: BindParameter[_T]) \u2192 ColumnElement[_T] | None\n```", "```py\nmethod bind_processor(dialect: Dialect) \u2192 _BindProcessorType[_T] | None\n```", "```py\nmethod coerce_compared_value(op: OperatorType | None, value: Any) \u2192 Any\n```", "```py\nexpr = table.c.somecolumn + 35\n```", "```py\nattribute coerce_to_is_types: Sequence[Type[Any]] = (<class 'NoneType'>,)\n```", "```py\nmethod column_expression(column: ColumnElement[_T]) \u2192 ColumnElement[_T] | None\n```", "```py\nattribute comparator_factory: _ComparatorFactory[Any]\n```", "```py\nmethod compare_values(x: Any, y: Any) \u2192 bool\n```", "```py\nmethod copy(**kw: Any) \u2192 Self\n```", "```py\nmethod get_dbapi_type(dbapi: module) \u2192 Any | None\n```", "```py\nmethod literal_processor(dialect: Dialect) \u2192 _LiteralProcessorType[_T] | None\n```", "```py\nmethod load_dialect_impl(dialect: Dialect) \u2192 TypeEngine[Any]\n```", "```py\nmethod process_bind_param(value: _T | None, dialect: Dialect) \u2192 Any\n```", "```py\nmethod process_literal_param(value: _T | None, dialect: Dialect) \u2192 str\n```", "```py\nmethod process_result_value(value: Any | None, dialect: Dialect) \u2192 _T | None\n```", "```py\nmethod result_processor(dialect: Dialect, coltype: Any) \u2192 _ResultProcessorType[_T] | None\n```", "```py\nattribute sort_key_function: Callable[[Any], Any] | None\n```", "```py\nmethod type_engine(dialect: Dialect) \u2192 TypeEngine[Any]\n```", "```py\nfrom sqlalchemy.types import TypeDecorator, Unicode\n\nclass CoerceUTF8(TypeDecorator):\n  \"\"\"Safely coerce Python bytestrings to Unicode\n before passing off to the database.\"\"\"\n\n    impl = Unicode\n\n    def process_bind_param(self, value, dialect):\n        if isinstance(value, str):\n            value = value.decode(\"utf-8\")\n        return value\n```", "```py\nfrom sqlalchemy.types import TypeDecorator, Numeric\nfrom decimal import Decimal\n\nclass SafeNumeric(TypeDecorator):\n  \"\"\"Adds quantization to Numeric.\"\"\"\n\n    impl = Numeric\n\n    def __init__(self, *arg, **kw):\n        TypeDecorator.__init__(self, *arg, **kw)\n        self.quantize_int = -self.impl.scale\n        self.quantize = Decimal(10) ** self.quantize_int\n\n    def process_bind_param(self, value, dialect):\n        if isinstance(value, Decimal) and value.as_tuple()[2] < self.quantize_int:\n            value = value.quantize(self.quantize)\n        return value\n```", "```py\nimport datetime\n\nclass TZDateTime(TypeDecorator):\n    impl = DateTime\n    cache_ok = True\n\n    def process_bind_param(self, value, dialect):\n        if value is not None:\n            if not value.tzinfo or value.tzinfo.utcoffset(value) is None:\n                raise TypeError(\"tzinfo is required\")\n            value = value.astimezone(datetime.timezone.utc).replace(tzinfo=None)\n        return value\n\n    def process_result_value(self, value, dialect):\n        if value is not None:\n            value = value.replace(tzinfo=datetime.timezone.utc)\n        return value\n```", "```py\nfrom operator import attrgetter\nfrom sqlalchemy.types import TypeDecorator, CHAR\nfrom sqlalchemy.dialects.mssql import UNIQUEIDENTIFIER\nfrom sqlalchemy.dialects.postgresql import UUID\nimport uuid\n\nclass GUID(TypeDecorator):\n  \"\"\"Platform-independent GUID type.\n\n Uses PostgreSQL's UUID type or MSSQL's UNIQUEIDENTIFIER,\n otherwise uses CHAR(32), storing as stringified hex values.\n\n \"\"\"\n\n    impl = CHAR\n    cache_ok = True\n\n    _default_type = CHAR(32)\n    _uuid_as_str = attrgetter(\"hex\")\n\n    def load_dialect_impl(self, dialect):\n        if dialect.name == \"postgresql\":\n            return dialect.type_descriptor(UUID())\n        elif dialect.name == \"mssql\":\n            return dialect.type_descriptor(UNIQUEIDENTIFIER())\n        else:\n            return dialect.type_descriptor(self._default_type)\n\n    def process_bind_param(self, value, dialect):\n        if value is None or dialect.name in (\"postgresql\", \"mssql\"):\n            return value\n        else:\n            if not isinstance(value, uuid.UUID):\n                value = uuid.UUID(value)\n            return self._uuid_as_str(value)\n\n    def process_result_value(self, value, dialect):\n        if value is None:\n            return value\n        else:\n            if not isinstance(value, uuid.UUID):\n                value = uuid.UUID(value)\n            return value\n\nclass GUIDHyphens(GUID):\n  \"\"\"Platform-independent GUID type.\n\n Uses PostgreSQL's UUID type or MSSQL's UNIQUEIDENTIFIER,\n otherwise uses CHAR(36), storing as stringified uuid values.\n\n \"\"\"\n\n    _default_type = CHAR(36)\n    _uuid_as_str = str\n```", "```py\nimport uuid\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column\n\nclass Base(DeclarativeBase):\n    type_annotation_map = {\n        uuid.UUID: GUID,\n    }\n```", "```py\nclass MyModel(Base):\n    __tablename__ = \"my_table\"\n\n    id: Mapped[uuid.UUID] = mapped_column(primary_key=True)\n```", "```py\nfrom sqlalchemy.types import TypeDecorator, VARCHAR\nimport json\n\nclass JSONEncodedDict(TypeDecorator):\n  \"\"\"Represents an immutable structure as a json-encoded string.\n\n Usage:\n\n JSONEncodedDict(255)\n\n \"\"\"\n\n    impl = VARCHAR\n\n    cache_ok = True\n\n    def process_bind_param(self, value, dialect):\n        if value is not None:\n            value = json.dumps(value)\n\n        return value\n\n    def process_result_value(self, value, dialect):\n        if value is not None:\n            value = json.loads(value)\n        return value\n```", "```py\nobj.json_value[\"key\"] = \"value\"  # will *not* be detected by the ORM\n\nobj.json_value = {\"key\": \"value\"}  # *will* be detected by the ORM\n```", "```py\njson_type = MutableDict.as_mutable(JSONEncodedDict)\n\nclass MyClass(Base):\n    #  ...\n\n    json_data = Column(json_type)\n```", "```py\nfrom sqlalchemy import type_coerce, String\n\nstmt = select(my_table).where(type_coerce(my_table.c.json_data, String).like(\"%foo%\"))\n```", "```py\nfrom sqlalchemy.sql import operators\nfrom sqlalchemy import String\n\nclass JSONEncodedDict(TypeDecorator):\n    impl = VARCHAR\n\n    cache_ok = True\n\n    def coerce_compared_value(self, op, value):\n        if op in (operators.like_op, operators.not_like_op):\n            return String()\n        else:\n            return self\n\n    def process_bind_param(self, value, dialect):\n        if value is not None:\n            value = json.dumps(value)\n\n        return value\n\n    def process_result_value(self, value, dialect):\n        if value is not None:\n            value = json.loads(value)\n        return value\n```", "```py\nfrom sqlalchemy.types import TypeDecorator, Unicode\n\nclass CoerceUTF8(TypeDecorator):\n  \"\"\"Safely coerce Python bytestrings to Unicode\n before passing off to the database.\"\"\"\n\n    impl = Unicode\n\n    def process_bind_param(self, value, dialect):\n        if isinstance(value, str):\n            value = value.decode(\"utf-8\")\n        return value\n```", "```py\nfrom sqlalchemy.types import TypeDecorator, Numeric\nfrom decimal import Decimal\n\nclass SafeNumeric(TypeDecorator):\n  \"\"\"Adds quantization to Numeric.\"\"\"\n\n    impl = Numeric\n\n    def __init__(self, *arg, **kw):\n        TypeDecorator.__init__(self, *arg, **kw)\n        self.quantize_int = -self.impl.scale\n        self.quantize = Decimal(10) ** self.quantize_int\n\n    def process_bind_param(self, value, dialect):\n        if isinstance(value, Decimal) and value.as_tuple()[2] < self.quantize_int:\n            value = value.quantize(self.quantize)\n        return value\n```", "```py\nimport datetime\n\nclass TZDateTime(TypeDecorator):\n    impl = DateTime\n    cache_ok = True\n\n    def process_bind_param(self, value, dialect):\n        if value is not None:\n            if not value.tzinfo or value.tzinfo.utcoffset(value) is None:\n                raise TypeError(\"tzinfo is required\")\n            value = value.astimezone(datetime.timezone.utc).replace(tzinfo=None)\n        return value\n\n    def process_result_value(self, value, dialect):\n        if value is not None:\n            value = value.replace(tzinfo=datetime.timezone.utc)\n        return value\n```", "```py\nfrom operator import attrgetter\nfrom sqlalchemy.types import TypeDecorator, CHAR\nfrom sqlalchemy.dialects.mssql import UNIQUEIDENTIFIER\nfrom sqlalchemy.dialects.postgresql import UUID\nimport uuid\n\nclass GUID(TypeDecorator):\n  \"\"\"Platform-independent GUID type.\n\n Uses PostgreSQL's UUID type or MSSQL's UNIQUEIDENTIFIER,\n otherwise uses CHAR(32), storing as stringified hex values.\n\n \"\"\"\n\n    impl = CHAR\n    cache_ok = True\n\n    _default_type = CHAR(32)\n    _uuid_as_str = attrgetter(\"hex\")\n\n    def load_dialect_impl(self, dialect):\n        if dialect.name == \"postgresql\":\n            return dialect.type_descriptor(UUID())\n        elif dialect.name == \"mssql\":\n            return dialect.type_descriptor(UNIQUEIDENTIFIER())\n        else:\n            return dialect.type_descriptor(self._default_type)\n\n    def process_bind_param(self, value, dialect):\n        if value is None or dialect.name in (\"postgresql\", \"mssql\"):\n            return value\n        else:\n            if not isinstance(value, uuid.UUID):\n                value = uuid.UUID(value)\n            return self._uuid_as_str(value)\n\n    def process_result_value(self, value, dialect):\n        if value is None:\n            return value\n        else:\n            if not isinstance(value, uuid.UUID):\n                value = uuid.UUID(value)\n            return value\n\nclass GUIDHyphens(GUID):\n  \"\"\"Platform-independent GUID type.\n\n Uses PostgreSQL's UUID type or MSSQL's UNIQUEIDENTIFIER,\n otherwise uses CHAR(36), storing as stringified uuid values.\n\n \"\"\"\n\n    _default_type = CHAR(36)\n    _uuid_as_str = str\n```", "```py\nimport uuid\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column\n\nclass Base(DeclarativeBase):\n    type_annotation_map = {\n        uuid.UUID: GUID,\n    }\n```", "```py\nclass MyModel(Base):\n    __tablename__ = \"my_table\"\n\n    id: Mapped[uuid.UUID] = mapped_column(primary_key=True)\n```", "```py\nimport uuid\nfrom sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column\n\nclass Base(DeclarativeBase):\n    type_annotation_map = {\n        uuid.UUID: GUID,\n    }\n```", "```py\nclass MyModel(Base):\n    __tablename__ = \"my_table\"\n\n    id: Mapped[uuid.UUID] = mapped_column(primary_key=True)\n```", "```py\nfrom sqlalchemy.types import TypeDecorator, VARCHAR\nimport json\n\nclass JSONEncodedDict(TypeDecorator):\n  \"\"\"Represents an immutable structure as a json-encoded string.\n\n Usage:\n\n JSONEncodedDict(255)\n\n \"\"\"\n\n    impl = VARCHAR\n\n    cache_ok = True\n\n    def process_bind_param(self, value, dialect):\n        if value is not None:\n            value = json.dumps(value)\n\n        return value\n\n    def process_result_value(self, value, dialect):\n        if value is not None:\n            value = json.loads(value)\n        return value\n```", "```py\nobj.json_value[\"key\"] = \"value\"  # will *not* be detected by the ORM\n\nobj.json_value = {\"key\": \"value\"}  # *will* be detected by the ORM\n```", "```py\njson_type = MutableDict.as_mutable(JSONEncodedDict)\n\nclass MyClass(Base):\n    #  ...\n\n    json_data = Column(json_type)\n```", "```py\nfrom sqlalchemy import type_coerce, String\n\nstmt = select(my_table).where(type_coerce(my_table.c.json_data, String).like(\"%foo%\"))\n```", "```py\nfrom sqlalchemy.sql import operators\nfrom sqlalchemy import String\n\nclass JSONEncodedDict(TypeDecorator):\n    impl = VARCHAR\n\n    cache_ok = True\n\n    def coerce_compared_value(self, op, value):\n        if op in (operators.like_op, operators.not_like_op):\n            return String()\n        else:\n            return self\n\n    def process_bind_param(self, value, dialect):\n        if value is not None:\n            value = json.dumps(value)\n\n        return value\n\n    def process_result_value(self, value, dialect):\n        if value is not None:\n            value = json.loads(value)\n        return value\n```", "```py\nobj.json_value[\"key\"] = \"value\"  # will *not* be detected by the ORM\n\nobj.json_value = {\"key\": \"value\"}  # *will* be detected by the ORM\n```", "```py\njson_type = MutableDict.as_mutable(JSONEncodedDict)\n\nclass MyClass(Base):\n    #  ...\n\n    json_data = Column(json_type)\n```", "```py\nfrom sqlalchemy import type_coerce, String\n\nstmt = select(my_table).where(type_coerce(my_table.c.json_data, String).like(\"%foo%\"))\n```", "```py\nfrom sqlalchemy.sql import operators\nfrom sqlalchemy import String\n\nclass JSONEncodedDict(TypeDecorator):\n    impl = VARCHAR\n\n    cache_ok = True\n\n    def coerce_compared_value(self, op, value):\n        if op in (operators.like_op, operators.not_like_op):\n            return String()\n        else:\n            return self\n\n    def process_bind_param(self, value, dialect):\n        if value is not None:\n            value = json.dumps(value)\n\n        return value\n\n    def process_result_value(self, value, dialect):\n        if value is not None:\n            value = json.loads(value)\n        return value\n```", "```py\nfrom sqlalchemy import func\nfrom sqlalchemy.types import UserDefinedType\n\nclass Geometry(UserDefinedType):\n    def get_col_spec(self):\n        return \"GEOMETRY\"\n\n    def bind_expression(self, bindvalue):\n        return func.ST_GeomFromText(bindvalue, type_=self)\n\n    def column_expression(self, col):\n        return func.ST_AsText(col, type_=self)\n```", "```py\ngeometry = Table(\n    \"geometry\",\n    metadata,\n    Column(\"geom_id\", Integer, primary_key=True),\n    Column(\"geom_data\", Geometry),\n)\n\nprint(\n    select(geometry).where(\n        geometry.c.geom_data == \"LINESTRING(189412 252431,189631 259122)\"\n    )\n)\n```", "```py\nSELECT  geometry.geom_id,  ST_AsText(geometry.geom_data)  AS  geom_data_1\nFROM  geometry\nWHERE  geometry.geom_data  =  ST_GeomFromText(:geom_data_2)\n```", "```py\nprint(select(geometry.c.geom_data.label(\"my_data\")))\n```", "```py\nSELECT  ST_AsText(geometry.geom_data)  AS  my_data\nFROM  geometry\n```", "```py\nfrom sqlalchemy import (\n    create_engine,\n    String,\n    select,\n    func,\n    MetaData,\n    Table,\n    Column,\n    type_coerce,\n    TypeDecorator,\n)\n\nfrom sqlalchemy.dialects.postgresql import BYTEA\n\nclass PGPString(TypeDecorator):\n    impl = BYTEA\n\n    cache_ok = True\n\n    def __init__(self, passphrase):\n        super(PGPString, self).__init__()\n\n        self.passphrase = passphrase\n\n    def bind_expression(self, bindvalue):\n        # convert the bind's type from PGPString to\n        # String, so that it's passed to psycopg2 as is without\n        # a dbapi.Binary wrapper\n        bindvalue = type_coerce(bindvalue, String)\n        return func.pgp_sym_encrypt(bindvalue, self.passphrase)\n\n    def column_expression(self, col):\n        return func.pgp_sym_decrypt(col, self.passphrase)\n\nmetadata_obj = MetaData()\nmessage = Table(\n    \"message\",\n    metadata_obj,\n    Column(\"username\", String(50)),\n    Column(\"message\", PGPString(\"this is my passphrase\")),\n)\n\nengine = create_engine(\"postgresql+psycopg2://scott:tiger@localhost/test\", echo=True)\nwith engine.begin() as conn:\n    metadata_obj.create_all(conn)\n\n    conn.execute(\n        message.insert(),\n        {\"username\": \"some user\", \"message\": \"this is my message\"},\n    )\n\n    print(\n        conn.scalar(select(message.c.message).where(message.c.username == \"some user\"))\n    )\n```", "```py\nINSERT  INTO  message  (username,  message)\n  VALUES  (%(username)s,  pgp_sym_encrypt(%(message)s,  %(pgp_sym_encrypt_1)s))\n  -- {'username': 'some user', 'message': 'this is my message',\n  --  'pgp_sym_encrypt_1': 'this is my passphrase'}\n\nSELECT  pgp_sym_decrypt(message.message,  %(pgp_sym_decrypt_1)s)  AS  message_1\n  FROM  message\n  WHERE  message.username  =  %(username_1)s\n  -- {'pgp_sym_decrypt_1': 'this is my passphrase', 'username_1': 'some user'}\n```", "```py\n>>> from sqlalchemy import column\n>>> expr = column(\"x\").op(\">>\")(column(\"y\"))\n>>> print(expr)\nx  >>  y \n```", "```py\nfrom sqlalchemy import Integer\n\nclass MyInt(Integer):\n    class comparator_factory(Integer.Comparator):\n        def __add__(self, other):\n            return self.op(\"goofy\")(other)\n```", "```py\n>>> sometable = Table(\"sometable\", metadata, Column(\"data\", MyInt))\n>>> print(sometable.c.data + 5)\nsometable.data  goofy  :data_1 \n```", "```py\nfrom sqlalchemy import Integer\n\nclass MyInt(Integer):\n    class comparator_factory(Integer.Comparator):\n        def __add__(self, other):\n            return func.special_addition(self.expr, other)\n```", "```py\nfrom sqlalchemy import Integer, func\n\nclass MyInt(Integer):\n    class comparator_factory(Integer.Comparator):\n        def log(self, other):\n            return func.log(self.expr, other)\n```", "```py\n>>> print(sometable.c.data.log(5))\nlog(:log_1,  :log_2) \n```", "```py\nclass MyInt(Integer):\n    class comparator_factory(Integer.Comparator):\n        def is_frobnozzled(self, other):\n            return self.op(\"--is_frobnozzled->\", is_comparison=True)(other)\n```", "```py\nfrom sqlalchemy import Integer\nfrom sqlalchemy.sql.expression import UnaryExpression\nfrom sqlalchemy.sql import operators\n\nclass MyInteger(Integer):\n    class comparator_factory(Integer.Comparator):\n        def factorial(self):\n            return UnaryExpression(\n                self.expr, modifier=operators.custom_op(\"!\"), type_=MyInteger\n            )\n```", "```py\n>>> from sqlalchemy.sql import column\n>>> print(column(\"x\", MyInteger).factorial())\nx  ! \n```", "```py\nclass sqlalchemy.types.UserDefinedType\n```", "```py\nimport sqlalchemy.types as types\n\nclass MyType(types.UserDefinedType):\n    cache_ok = True\n\n    def __init__(self, precision = 8):\n        self.precision = precision\n\n    def get_col_spec(self, **kw):\n        return \"MYTYPE(%s)\" % self.precision\n\n    def bind_processor(self, dialect):\n        def process(value):\n            return value\n        return process\n\n    def result_processor(self, dialect, coltype):\n        def process(value):\n            return value\n        return process\n```", "```py\ntable = Table('foo', metadata_obj,\n    Column('id', Integer, primary_key=True),\n    Column('data', MyType(16))\n    )\n```", "```py\nattribute cache_ok: bool | None = None\n```", "```py\nclass MyType(TypeDecorator):\n    impl = String\n\n    cache_ok = True\n\n    def __init__(self, choices):\n        self.choices = tuple(choices)\n        self.internal_only = True\n```", "```py\n>>> MyType([\"a\", \"b\", \"c\"])._static_cache_key\n(<class '__main__.MyType'>, ('choices', ('a', 'b', 'c')))\n```", "```py\nclass LookupType(UserDefinedType):\n  '''a custom type that accepts a dictionary as a parameter.\n\n this is the non-cacheable version, as \"self.lookup\" is not\n hashable.\n\n '''\n\n    def __init__(self, lookup):\n        self.lookup = lookup\n\n    def get_col_spec(self, **kw):\n        return \"VARCHAR(255)\"\n\n    def bind_processor(self, dialect):\n        # ...  works with \"self.lookup\" ...\n```", "```py\n>>> type_ = LookupType({\"a\": 10, \"b\": 20})\n>>> type_._static_cache_key\n<stdin>:1: SAWarning: UserDefinedType LookupType({'a': 10, 'b': 20}) will not\nproduce a cache key because the ``cache_ok`` flag is not set to True.\nSet this flag to True if this type object's state is safe to use\nin a cache key, or False to disable this warning.\nsymbol('no_cache')\n```", "```py\n>>> # set cache_ok = True\n>>> type_.cache_ok = True\n\n>>> # this is the cache key it would generate\n>>> key = type_._static_cache_key\n>>> key\n(<class '__main__.LookupType'>, ('lookup', {'a': 10, 'b': 20}))\n\n>>> # however this key is not hashable, will fail when used with\n>>> # SQLAlchemy statement cache\n>>> some_cache = {key: \"some sql value\"}\nTraceback (most recent call last): File \"<stdin>\", line 1,\nin <module> TypeError: unhashable type: 'dict'\n```", "```py\nclass LookupType(UserDefinedType):\n  '''a custom type that accepts a dictionary as a parameter.\n\n The dictionary is stored both as itself in a private variable,\n and published in a public variable as a sorted tuple of tuples,\n which is hashable and will also return the same value for any\n two equivalent dictionaries.  Note it assumes the keys and\n values of the dictionary are themselves hashable.\n\n '''\n\n    cache_ok = True\n\n    def __init__(self, lookup):\n        self._lookup = lookup\n\n        # assume keys/values of \"lookup\" are hashable; otherwise\n        # they would also need to be converted in some way here\n        self.lookup = tuple(\n            (key, lookup[key]) for key in sorted(lookup)\n        )\n\n    def get_col_spec(self, **kw):\n        return \"VARCHAR(255)\"\n\n    def bind_processor(self, dialect):\n        # ...  works with \"self._lookup\" ...\n```", "```py\n>>> LookupType({\"a\": 10, \"b\": 20})._static_cache_key\n(<class '__main__.LookupType'>, ('lookup', (('a', 10), ('b', 20))))\n```", "```py\nmethod coerce_compared_value(op: OperatorType | None, value: Any) \u2192 TypeEngine[Any]\n```", "```py\nattribute ensure_kwarg: str = 'get_col_spec'\n```", "```py\n>>> from sqlalchemy import (\n...     Table,\n...     Column,\n...     MetaData,\n...     create_engine,\n...     PickleType,\n...     Integer,\n... )\n>>> metadata = MetaData()\n>>> my_table = Table(\n...     \"my_table\", metadata, Column(\"id\", Integer), Column(\"data\", PickleType)\n... )\n>>> engine = create_engine(\"sqlite://\", echo=\"debug\")\n>>> my_table.create(engine)\nINFO  sqlalchemy.engine.base.Engine\nCREATE  TABLE  my_table  (\n  id  INTEGER,\n  data  BLOB\n) \n```", "```py\n>>> my_table.c.data.type\nPickleType()\n```", "```py\n>>> metadata_two = MetaData()\n>>> my_reflected_table = Table(\"my_table\", metadata_two, autoload_with=engine)\nINFO  sqlalchemy.engine.base.Engine  PRAGMA  main.table_info(\"my_table\")\nINFO  sqlalchemy.engine.base.Engine  ()\nDEBUG  sqlalchemy.engine.base.Engine  Col  ('cid',  'name',  'type',  'notnull',  'dflt_value',  'pk')\nDEBUG  sqlalchemy.engine.base.Engine  Row  (0,  'id',  'INTEGER',  0,  None,  0)\nDEBUG  sqlalchemy.engine.base.Engine  Row  (1,  'data',  'BLOB',  0,  None,  0)\n\n>>>  my_reflected_table.c.data.type\nBLOB() \n```", "```py\n>>> metadata_three = MetaData()\n>>> my_reflected_table = Table(\n...     \"my_table\",\n...     metadata_three,\n...     Column(\"data\", PickleType),\n...     autoload_with=engine,\n... )\n```", "```py\n>>> my_reflected_table.c.data.type\nPickleType()\n```", "```py\nfrom sqlalchemy import BLOB\nfrom sqlalchemy import event\nfrom sqlalchemy import PickleType\nfrom sqlalchemy import Table\n\n@event.listens_for(Table, \"column_reflect\")\ndef _setup_pickletype(inspector, table, column_info):\n    if isinstance(column_info[\"type\"], BLOB):\n        column_info[\"type\"] = PickleType()\n```"]