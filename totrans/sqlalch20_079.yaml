- en: Operator Reference
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.sqlalchemy.org/en/20/core/operators.html](https://docs.sqlalchemy.org/en/20/core/operators.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This section details usage of the operators that are available to construct
    SQL expressions.
  prefs: []
  type: TYPE_NORMAL
- en: 'These methods are presented in terms of the [`Operators`](sqlelement.html#sqlalchemy.sql.expression.Operators
    "sqlalchemy.sql.expression.Operators") and [`ColumnOperators`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators
    "sqlalchemy.sql.expression.ColumnOperators") base classes. The methods are then
    available on descendants of these classes, including:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Column`](metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    objects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`ColumnElement`](sqlelement.html#sqlalchemy.sql.expression.ColumnElement "sqlalchemy.sql.expression.ColumnElement")
    objects more generally, which are the root of all Core SQL Expression language
    column-level expressions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`InstrumentedAttribute`](../orm/internals.html#sqlalchemy.orm.InstrumentedAttribute
    "sqlalchemy.orm.InstrumentedAttribute") objects, which are ORM level mapped attributes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The operators are first introduced in the tutorial sections, including:'
  prefs: []
  type: TYPE_NORMAL
- en: '[SQLAlchemy Unified Tutorial](../tutorial/index.html) - unified tutorial in
    [2.0 style](../glossary.html#term-2.0-style)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Object Relational Tutorial](../orm/tutorial.html) - ORM tutorial in [1.x style](../glossary.html#term-1.x-style)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[SQL Expression Language Tutorial](tutorial.html) - Core tutorial in [1.x style](../glossary.html#term-1.x-style)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparison Operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Basic comparisons which apply to many datatypes, including numerics, strings,
    dates, and many others:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.__eq__()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.__eq__
    "sqlalchemy.sql.expression.ColumnOperators.__eq__") (Python “`==`” operator):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[`ColumnOperators.__ne__()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.__ne__
    "sqlalchemy.sql.expression.ColumnOperators.__ne__") (Python “`!=`” operator):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[`ColumnOperators.__gt__()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.__gt__
    "sqlalchemy.sql.expression.ColumnOperators.__gt__") (Python “`>`” operator):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[`ColumnOperators.__lt__()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.__lt__
    "sqlalchemy.sql.expression.ColumnOperators.__lt__") (Python “`<`” operator):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[`ColumnOperators.__ge__()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.__ge__
    "sqlalchemy.sql.expression.ColumnOperators.__ge__") (Python “`>=`” operator):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[`ColumnOperators.__le__()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.__le__
    "sqlalchemy.sql.expression.ColumnOperators.__le__") (Python “`<=`” operator):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[`ColumnOperators.between()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.between
    "sqlalchemy.sql.expression.ColumnOperators.between"):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: IN Comparisons
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The SQL IN operator is a subject all its own in SQLAlchemy. As the IN operator
    is usually used against a list of fixed values, SQLAlchemy’s feature of bound
    parameter coercion makes use of a special form of SQL compilation that renders
    an interim SQL string for compilation that’s formed into the final list of bound
    parameters in a second step. In other words, “it just works”.
  prefs: []
  type: TYPE_NORMAL
- en: IN against a list of values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'IN is available most typically by passing a list of values to the [`ColumnOperators.in_()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.in_
    "sqlalchemy.sql.expression.ColumnOperators.in_") method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The special bound form `__[POSTCOMPILE` is rendered into individual parameters
    at execution time, illustrated below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Empty IN Expressions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'SQLAlchemy produces a mathematically valid result for an empty IN expression
    by rendering a backend-specific subquery that returns no rows. Again in other
    words, “it just works”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The “empty set” subquery above generalizes correctly and is also rendered in
    terms of the IN operator which remains in place.
  prefs: []
  type: TYPE_NORMAL
- en: NOT IN
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '“NOT IN” is available via the [`ColumnOperators.not_in()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.not_in
    "sqlalchemy.sql.expression.ColumnOperators.not_in") operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This is typically more easily available by negating with the `~` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Tuple IN Expressions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Comparison of tuples to tuples is common with IN, as among other use cases
    accommodates for the case when matching rows to a set of potential composite primary
    key values. The [`tuple_()`](sqlelement.html#sqlalchemy.sql.expression.tuple_
    "sqlalchemy.sql.expression.tuple_") construct provides the basic building block
    for tuple comparisons. The `Tuple.in_()` operator then receives a list of tuples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'To illustrate the parameters rendered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Subquery IN
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Finally, the [`ColumnOperators.in_()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.in_
    "sqlalchemy.sql.expression.ColumnOperators.in_") and [`ColumnOperators.not_in()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.not_in
    "sqlalchemy.sql.expression.ColumnOperators.not_in") operators work with subqueries.
    The form provides that a [`Select`](selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") construct is passed in directly, without any
    explicit conversion to a named subquery:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Tuples work as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Identity Comparisons
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'These operators involve testing for special SQL values such as `NULL`, boolean
    constants such as `true` or `false` which some databases support:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.is_()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.is_
    "sqlalchemy.sql.expression.ColumnOperators.is_"):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This operator will provide exactly the SQL for “x IS y”, most often seen as
    “<expr> IS NULL”. The `NULL` constant is most easily acquired using regular Python
    `None`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'SQL NULL is also explicitly available, if needed, using the [`null()`](sqlelement.html#sqlalchemy.sql.expression.null
    "sqlalchemy.sql.expression.null") construct:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The [`ColumnOperators.is_()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.is_
    "sqlalchemy.sql.expression.ColumnOperators.is_") operator is automatically invoked
    when using the [`ColumnOperators.__eq__()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.__eq__
    "sqlalchemy.sql.expression.ColumnOperators.__eq__") overloaded operator, i.e.
    `==`, in conjunction with the `None` or [`null()`](sqlelement.html#sqlalchemy.sql.expression.null
    "sqlalchemy.sql.expression.null") value. In this way, there’s typically not a
    need to use [`ColumnOperators.is_()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.is_
    "sqlalchemy.sql.expression.ColumnOperators.is_") explicitly, particularly when
    used with a dynamic value:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that the Python `is` operator is **not overloaded**. Even though Python
    provides hooks to overload operators such as `==` and `!=`, it does **not** provide
    any way to redefine `is`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`ColumnOperators.is_not()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.is_not
    "sqlalchemy.sql.expression.ColumnOperators.is_not"):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Similar to [`ColumnOperators.is_()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.is_
    "sqlalchemy.sql.expression.ColumnOperators.is_"), produces “IS NOT”:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Is similarly equivalent to `!= None`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[`ColumnOperators.is_distinct_from()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.is_distinct_from
    "sqlalchemy.sql.expression.ColumnOperators.is_distinct_from"):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Produces SQL IS DISTINCT FROM:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[`ColumnOperators.isnot_distinct_from()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.isnot_distinct_from
    "sqlalchemy.sql.expression.ColumnOperators.isnot_distinct_from"):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Produces SQL IS NOT DISTINCT FROM:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: String Comparisons
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[`ColumnOperators.like()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.like
    "sqlalchemy.sql.expression.ColumnOperators.like"):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[`ColumnOperators.ilike()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.ilike
    "sqlalchemy.sql.expression.ColumnOperators.ilike"):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Case insensitive LIKE makes use of the SQL `lower()` function on a generic
    backend. On the PostgreSQL backend it will use `ILIKE`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[`ColumnOperators.notlike()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.notlike
    "sqlalchemy.sql.expression.ColumnOperators.notlike"):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[`ColumnOperators.notilike()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.notilike
    "sqlalchemy.sql.expression.ColumnOperators.notilike"):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: String Containment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'String containment operators are basically built as a combination of LIKE and
    the string concatenation operator, which is `||` on most backends or sometimes
    a function like `concat()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.startswith()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.startswith
    "sqlalchemy.sql.expression.ColumnOperators.startswith"):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[`ColumnOperators.endswith()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.endswith
    "sqlalchemy.sql.expression.ColumnOperators.endswith"):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[`ColumnOperators.contains()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.contains
    "sqlalchemy.sql.expression.ColumnOperators.contains"):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: String matching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Matching operators are always backend-specific and may provide different behaviors
    and results on different databases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.match()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.match
    "sqlalchemy.sql.expression.ColumnOperators.match"):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is a dialect-specific operator that makes use of the MATCH feature of
    the underlying database, if available:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[`ColumnOperators.regexp_match()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.regexp_match
    "sqlalchemy.sql.expression.ColumnOperators.regexp_match"):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This operator is dialect specific. We can illustrate it in terms of for example
    the PostgreSQL dialect:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Or MySQL:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '## String Alteration'
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.concat()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.concat
    "sqlalchemy.sql.expression.ColumnOperators.concat"):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'String concatenation:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This operator is available via [`ColumnOperators.__add__()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.__add__
    "sqlalchemy.sql.expression.ColumnOperators.__add__"), that is, the Python `+`
    operator, when working with a column expression that derives from [`String`](type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String"):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The operator will produce the appropriate database-specific construct, such
    as on MySQL it’s historically been the `concat()` SQL function:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[`ColumnOperators.regexp_replace()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.regexp_replace
    "sqlalchemy.sql.expression.ColumnOperators.regexp_replace"):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Complementary to `ColumnOperators.regexp()` this produces REGEXP REPLACE equivalent
    for the backends which support it:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[`ColumnOperators.collate()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.collate
    "sqlalchemy.sql.expression.ColumnOperators.collate"):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Produces the COLLATE SQL operator which provides for specific collations at
    expression time:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To use COLLATE against a literal value, use the [`literal()`](sqlelement.html#sqlalchemy.sql.expression.literal
    "sqlalchemy.sql.expression.literal") construct:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Arithmetic Operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[`ColumnOperators.__add__()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.__add__
    "sqlalchemy.sql.expression.ColumnOperators.__add__"), [`ColumnOperators.__radd__()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.__radd__
    "sqlalchemy.sql.expression.ColumnOperators.__radd__") (Python “`+`” operator):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that when the datatype of the expression is [`String`](type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String") or similar, the [`ColumnOperators.__add__()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.__add__
    "sqlalchemy.sql.expression.ColumnOperators.__add__") operator instead produces
    [string concatenation](#queryguide-operators-concat-op).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`ColumnOperators.__sub__()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.__sub__
    "sqlalchemy.sql.expression.ColumnOperators.__sub__"), [`ColumnOperators.__rsub__()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.__rsub__
    "sqlalchemy.sql.expression.ColumnOperators.__rsub__") (Python “`-`” operator):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[`ColumnOperators.__mul__()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.__mul__
    "sqlalchemy.sql.expression.ColumnOperators.__mul__"), [`ColumnOperators.__rmul__()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.__rmul__
    "sqlalchemy.sql.expression.ColumnOperators.__rmul__") (Python “`*`” operator):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[`ColumnOperators.__truediv__()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.__truediv__
    "sqlalchemy.sql.expression.ColumnOperators.__truediv__"), [`ColumnOperators.__rtruediv__()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.__rtruediv__
    "sqlalchemy.sql.expression.ColumnOperators.__rtruediv__") (Python “`/`” operator).
    This is the Python `truediv` operator, which will ensure integer true division
    occurs:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Changed in version 2.0: The Python `/` operator now ensures integer true division
    takes place'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`ColumnOperators.__floordiv__()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.__floordiv__
    "sqlalchemy.sql.expression.ColumnOperators.__floordiv__"), [`ColumnOperators.__rfloordiv__()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.__rfloordiv__
    "sqlalchemy.sql.expression.ColumnOperators.__rfloordiv__") (Python “`//`” operator).
    This is the Python `floordiv` operator, which will ensure floor division occurs.
    For the default backend as well as backends such as PostgreSQL, the SQL `/` operator
    normally behaves this way for integer values:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For backends that don’t use floor division by default, or when used with numeric
    values, the FLOOR() function is used to ensure floor division:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'New in version 2.0: Support for FLOOR division'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`ColumnOperators.__mod__()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.__mod__
    "sqlalchemy.sql.expression.ColumnOperators.__mod__"), [`ColumnOperators.__rmod__()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.__rmod__
    "sqlalchemy.sql.expression.ColumnOperators.__rmod__") (Python “`%`” operator):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '## Bitwise Operators'
  prefs: []
  type: TYPE_NORMAL
- en: Bitwise operator functions provide uniform access to bitwise operators across
    different backends, which are expected to operate on compatible values such as
    integers and bit-strings (e.g. PostgreSQL [`BIT`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.BIT
    "sqlalchemy.dialects.postgresql.BIT") and similar). Note that these are **not**
    general boolean operators.
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 2.0.2: Added dedicated operators for bitwise operations.'
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.bitwise_not()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.bitwise_not
    "sqlalchemy.sql.expression.ColumnOperators.bitwise_not"), [`bitwise_not()`](sqlelement.html#sqlalchemy.sql.expression.bitwise_not
    "sqlalchemy.sql.expression.bitwise_not"). Available as a column-level method,
    producing a bitwise NOT clause against a parent object:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This operator is also available as a column-expression-level method, applying
    bitwise NOT to an individual column expression:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[`ColumnOperators.bitwise_and()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.bitwise_and
    "sqlalchemy.sql.expression.ColumnOperators.bitwise_and") produces bitwise AND:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[`ColumnOperators.bitwise_or()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.bitwise_or
    "sqlalchemy.sql.expression.ColumnOperators.bitwise_or") produces bitwise OR:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[`ColumnOperators.bitwise_xor()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.bitwise_xor
    "sqlalchemy.sql.expression.ColumnOperators.bitwise_xor") produces bitwise XOR:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For PostgreSQL dialects, “#” is used to represent bitwise XOR; this emits automatically
    when using one of these backends:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[`ColumnOperators.bitwise_rshift()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.bitwise_rshift
    "sqlalchemy.sql.expression.ColumnOperators.bitwise_rshift"), [`ColumnOperators.bitwise_lshift()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.bitwise_lshift
    "sqlalchemy.sql.expression.ColumnOperators.bitwise_lshift") produce bitwise shift
    operators:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Using Conjunctions and Negations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The most common conjunction, “AND”, is automatically applied if we make repeated
    use of the [`Select.where()`](selectable.html#sqlalchemy.sql.expression.Select.where
    "sqlalchemy.sql.expression.Select.where") method, as well as similar methods such
    as [`Update.where()`](dml.html#sqlalchemy.sql.expression.Update.where "sqlalchemy.sql.expression.Update.where")
    and [`Delete.where()`](dml.html#sqlalchemy.sql.expression.Delete.where "sqlalchemy.sql.expression.Delete.where"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[`Select.where()`](selectable.html#sqlalchemy.sql.expression.Select.where "sqlalchemy.sql.expression.Select.where"),
    [`Update.where()`](dml.html#sqlalchemy.sql.expression.Update.where "sqlalchemy.sql.expression.Update.where")
    and [`Delete.where()`](dml.html#sqlalchemy.sql.expression.Delete.where "sqlalchemy.sql.expression.Delete.where")
    also accept multiple expressions with the same effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The “AND” conjunction, as well as its partner “OR”, are both available directly
    using the [`and_()`](sqlelement.html#sqlalchemy.sql.expression.and_ "sqlalchemy.sql.expression.and_")
    and [`or_()`](sqlelement.html#sqlalchemy.sql.expression.or_ "sqlalchemy.sql.expression.or_")
    functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'A negation is available using the [`not_()`](sqlelement.html#sqlalchemy.sql.expression.not_
    "sqlalchemy.sql.expression.not_") function. This will typically invert the operator
    in a boolean expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'It also may apply a keyword such as `NOT` when appropriate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Conjunction Operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The above conjunction functions [`and_()`](sqlelement.html#sqlalchemy.sql.expression.and_
    "sqlalchemy.sql.expression.and_"), [`or_()`](sqlelement.html#sqlalchemy.sql.expression.or_
    "sqlalchemy.sql.expression.or_"), [`not_()`](sqlelement.html#sqlalchemy.sql.expression.not_
    "sqlalchemy.sql.expression.not_") are also available as overloaded Python operators:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The Python `&`, `|` and `~` operators take high precedence in the language;
    as a result, parenthesis must usually be applied for operands that themselves
    contain expressions, as indicated in the examples below.
  prefs: []
  type: TYPE_NORMAL
- en: '[`Operators.__and__()`](sqlelement.html#sqlalchemy.sql.expression.Operators.__and__
    "sqlalchemy.sql.expression.Operators.__and__") (Python “`&`” operator):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Python binary `&` operator is overloaded to behave the same as [`and_()`](sqlelement.html#sqlalchemy.sql.expression.and_
    "sqlalchemy.sql.expression.and_") (note parenthesis around the two operands):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[`Operators.__or__()`](sqlelement.html#sqlalchemy.sql.expression.Operators.__or__
    "sqlalchemy.sql.expression.Operators.__or__") (Python “`|`” operator):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Python binary `|` operator is overloaded to behave the same as [`or_()`](sqlelement.html#sqlalchemy.sql.expression.or_
    "sqlalchemy.sql.expression.or_") (note parenthesis around the two operands):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[`Operators.__invert__()`](sqlelement.html#sqlalchemy.sql.expression.Operators.__invert__
    "sqlalchemy.sql.expression.Operators.__invert__") (Python “`~`” operator):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Python binary `~` operator is overloaded to behave the same as [`not_()`](sqlelement.html#sqlalchemy.sql.expression.not_
    "sqlalchemy.sql.expression.not_"), either inverting the existing operator, or
    applying the `NOT` keyword to the expression as a whole:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Comparison Operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Basic comparisons which apply to many datatypes, including numerics, strings,
    dates, and many others:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.__eq__()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.__eq__
    "sqlalchemy.sql.expression.ColumnOperators.__eq__") (Python “`==`” operator):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[`ColumnOperators.__ne__()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.__ne__
    "sqlalchemy.sql.expression.ColumnOperators.__ne__") (Python “`!=`” operator):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[`ColumnOperators.__gt__()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.__gt__
    "sqlalchemy.sql.expression.ColumnOperators.__gt__") (Python “`>`” operator):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[`ColumnOperators.__lt__()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.__lt__
    "sqlalchemy.sql.expression.ColumnOperators.__lt__") (Python “`<`” operator):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[`ColumnOperators.__ge__()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.__ge__
    "sqlalchemy.sql.expression.ColumnOperators.__ge__") (Python “`>=`” operator):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[`ColumnOperators.__le__()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.__le__
    "sqlalchemy.sql.expression.ColumnOperators.__le__") (Python “`<=`” operator):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[`ColumnOperators.between()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.between
    "sqlalchemy.sql.expression.ColumnOperators.between"):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: IN Comparisons
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The SQL IN operator is a subject all its own in SQLAlchemy. As the IN operator
    is usually used against a list of fixed values, SQLAlchemy’s feature of bound
    parameter coercion makes use of a special form of SQL compilation that renders
    an interim SQL string for compilation that’s formed into the final list of bound
    parameters in a second step. In other words, “it just works”.
  prefs: []
  type: TYPE_NORMAL
- en: IN against a list of values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'IN is available most typically by passing a list of values to the [`ColumnOperators.in_()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.in_
    "sqlalchemy.sql.expression.ColumnOperators.in_") method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'The special bound form `__[POSTCOMPILE` is rendered into individual parameters
    at execution time, illustrated below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Empty IN Expressions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'SQLAlchemy produces a mathematically valid result for an empty IN expression
    by rendering a backend-specific subquery that returns no rows. Again in other
    words, “it just works”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: The “empty set” subquery above generalizes correctly and is also rendered in
    terms of the IN operator which remains in place.
  prefs: []
  type: TYPE_NORMAL
- en: NOT IN
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '“NOT IN” is available via the [`ColumnOperators.not_in()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.not_in
    "sqlalchemy.sql.expression.ColumnOperators.not_in") operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'This is typically more easily available by negating with the `~` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Tuple IN Expressions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Comparison of tuples to tuples is common with IN, as among other use cases
    accommodates for the case when matching rows to a set of potential composite primary
    key values. The [`tuple_()`](sqlelement.html#sqlalchemy.sql.expression.tuple_
    "sqlalchemy.sql.expression.tuple_") construct provides the basic building block
    for tuple comparisons. The `Tuple.in_()` operator then receives a list of tuples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'To illustrate the parameters rendered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Subquery IN
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Finally, the [`ColumnOperators.in_()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.in_
    "sqlalchemy.sql.expression.ColumnOperators.in_") and [`ColumnOperators.not_in()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.not_in
    "sqlalchemy.sql.expression.ColumnOperators.not_in") operators work with subqueries.
    The form provides that a [`Select`](selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") construct is passed in directly, without any
    explicit conversion to a named subquery:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Tuples work as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: IN against a list of values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'IN is available most typically by passing a list of values to the [`ColumnOperators.in_()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.in_
    "sqlalchemy.sql.expression.ColumnOperators.in_") method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'The special bound form `__[POSTCOMPILE` is rendered into individual parameters
    at execution time, illustrated below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Empty IN Expressions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'SQLAlchemy produces a mathematically valid result for an empty IN expression
    by rendering a backend-specific subquery that returns no rows. Again in other
    words, “it just works”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: The “empty set” subquery above generalizes correctly and is also rendered in
    terms of the IN operator which remains in place.
  prefs: []
  type: TYPE_NORMAL
- en: NOT IN
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '“NOT IN” is available via the [`ColumnOperators.not_in()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.not_in
    "sqlalchemy.sql.expression.ColumnOperators.not_in") operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'This is typically more easily available by negating with the `~` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Tuple IN Expressions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Comparison of tuples to tuples is common with IN, as among other use cases
    accommodates for the case when matching rows to a set of potential composite primary
    key values. The [`tuple_()`](sqlelement.html#sqlalchemy.sql.expression.tuple_
    "sqlalchemy.sql.expression.tuple_") construct provides the basic building block
    for tuple comparisons. The `Tuple.in_()` operator then receives a list of tuples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'To illustrate the parameters rendered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Subquery IN
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Finally, the [`ColumnOperators.in_()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.in_
    "sqlalchemy.sql.expression.ColumnOperators.in_") and [`ColumnOperators.not_in()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.not_in
    "sqlalchemy.sql.expression.ColumnOperators.not_in") operators work with subqueries.
    The form provides that a [`Select`](selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") construct is passed in directly, without any
    explicit conversion to a named subquery:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Tuples work as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Identity Comparisons
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'These operators involve testing for special SQL values such as `NULL`, boolean
    constants such as `true` or `false` which some databases support:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.is_()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.is_
    "sqlalchemy.sql.expression.ColumnOperators.is_"):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This operator will provide exactly the SQL for “x IS y”, most often seen as
    “<expr> IS NULL”. The `NULL` constant is most easily acquired using regular Python
    `None`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'SQL NULL is also explicitly available, if needed, using the [`null()`](sqlelement.html#sqlalchemy.sql.expression.null
    "sqlalchemy.sql.expression.null") construct:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The [`ColumnOperators.is_()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.is_
    "sqlalchemy.sql.expression.ColumnOperators.is_") operator is automatically invoked
    when using the [`ColumnOperators.__eq__()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.__eq__
    "sqlalchemy.sql.expression.ColumnOperators.__eq__") overloaded operator, i.e.
    `==`, in conjunction with the `None` or [`null()`](sqlelement.html#sqlalchemy.sql.expression.null
    "sqlalchemy.sql.expression.null") value. In this way, there’s typically not a
    need to use [`ColumnOperators.is_()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.is_
    "sqlalchemy.sql.expression.ColumnOperators.is_") explicitly, particularly when
    used with a dynamic value:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that the Python `is` operator is **not overloaded**. Even though Python
    provides hooks to overload operators such as `==` and `!=`, it does **not** provide
    any way to redefine `is`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`ColumnOperators.is_not()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.is_not
    "sqlalchemy.sql.expression.ColumnOperators.is_not"):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Similar to [`ColumnOperators.is_()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.is_
    "sqlalchemy.sql.expression.ColumnOperators.is_"), produces “IS NOT”:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Is similarly equivalent to `!= None`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[`ColumnOperators.is_distinct_from()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.is_distinct_from
    "sqlalchemy.sql.expression.ColumnOperators.is_distinct_from"):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Produces SQL IS DISTINCT FROM:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[`ColumnOperators.isnot_distinct_from()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.isnot_distinct_from
    "sqlalchemy.sql.expression.ColumnOperators.isnot_distinct_from"):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Produces SQL IS NOT DISTINCT FROM:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: String Comparisons
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[`ColumnOperators.like()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.like
    "sqlalchemy.sql.expression.ColumnOperators.like"):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[`ColumnOperators.ilike()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.ilike
    "sqlalchemy.sql.expression.ColumnOperators.ilike"):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Case insensitive LIKE makes use of the SQL `lower()` function on a generic
    backend. On the PostgreSQL backend it will use `ILIKE`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[`ColumnOperators.notlike()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.notlike
    "sqlalchemy.sql.expression.ColumnOperators.notlike"):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[`ColumnOperators.notilike()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.notilike
    "sqlalchemy.sql.expression.ColumnOperators.notilike"):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: String Containment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'String containment operators are basically built as a combination of LIKE and
    the string concatenation operator, which is `||` on most backends or sometimes
    a function like `concat()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.startswith()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.startswith
    "sqlalchemy.sql.expression.ColumnOperators.startswith"):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[`ColumnOperators.endswith()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.endswith
    "sqlalchemy.sql.expression.ColumnOperators.endswith"):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[`ColumnOperators.contains()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.contains
    "sqlalchemy.sql.expression.ColumnOperators.contains"):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: String matching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Matching operators are always backend-specific and may provide different behaviors
    and results on different databases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.match()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.match
    "sqlalchemy.sql.expression.ColumnOperators.match"):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is a dialect-specific operator that makes use of the MATCH feature of
    the underlying database, if available:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[`ColumnOperators.regexp_match()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.regexp_match
    "sqlalchemy.sql.expression.ColumnOperators.regexp_match"):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This operator is dialect specific. We can illustrate it in terms of for example
    the PostgreSQL dialect:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Or MySQL:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '## String Alteration'
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.concat()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.concat
    "sqlalchemy.sql.expression.ColumnOperators.concat"):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'String concatenation:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This operator is available via [`ColumnOperators.__add__()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.__add__
    "sqlalchemy.sql.expression.ColumnOperators.__add__"), that is, the Python `+`
    operator, when working with a column expression that derives from [`String`](type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String"):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The operator will produce the appropriate database-specific construct, such
    as on MySQL it’s historically been the `concat()` SQL function:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[`ColumnOperators.regexp_replace()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.regexp_replace
    "sqlalchemy.sql.expression.ColumnOperators.regexp_replace"):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Complementary to `ColumnOperators.regexp()` this produces REGEXP REPLACE equivalent
    for the backends which support it:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[`ColumnOperators.collate()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.collate
    "sqlalchemy.sql.expression.ColumnOperators.collate"):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Produces the COLLATE SQL operator which provides for specific collations at
    expression time:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To use COLLATE against a literal value, use the [`literal()`](sqlelement.html#sqlalchemy.sql.expression.literal
    "sqlalchemy.sql.expression.literal") construct:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Arithmetic Operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[`ColumnOperators.__add__()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.__add__
    "sqlalchemy.sql.expression.ColumnOperators.__add__"), [`ColumnOperators.__radd__()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.__radd__
    "sqlalchemy.sql.expression.ColumnOperators.__radd__") (Python “`+`” operator):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that when the datatype of the expression is [`String`](type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String") or similar, the [`ColumnOperators.__add__()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.__add__
    "sqlalchemy.sql.expression.ColumnOperators.__add__") operator instead produces
    [string concatenation](#queryguide-operators-concat-op).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`ColumnOperators.__sub__()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.__sub__
    "sqlalchemy.sql.expression.ColumnOperators.__sub__"), [`ColumnOperators.__rsub__()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.__rsub__
    "sqlalchemy.sql.expression.ColumnOperators.__rsub__") (Python “`-`” operator):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[`ColumnOperators.__mul__()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.__mul__
    "sqlalchemy.sql.expression.ColumnOperators.__mul__"), [`ColumnOperators.__rmul__()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.__rmul__
    "sqlalchemy.sql.expression.ColumnOperators.__rmul__") (Python “`*`” operator):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[`ColumnOperators.__truediv__()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.__truediv__
    "sqlalchemy.sql.expression.ColumnOperators.__truediv__"), [`ColumnOperators.__rtruediv__()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.__rtruediv__
    "sqlalchemy.sql.expression.ColumnOperators.__rtruediv__") (Python “`/`” operator).
    This is the Python `truediv` operator, which will ensure integer true division
    occurs:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Changed in version 2.0: The Python `/` operator now ensures integer true division
    takes place'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`ColumnOperators.__floordiv__()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.__floordiv__
    "sqlalchemy.sql.expression.ColumnOperators.__floordiv__"), [`ColumnOperators.__rfloordiv__()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.__rfloordiv__
    "sqlalchemy.sql.expression.ColumnOperators.__rfloordiv__") (Python “`//`” operator).
    This is the Python `floordiv` operator, which will ensure floor division occurs.
    For the default backend as well as backends such as PostgreSQL, the SQL `/` operator
    normally behaves this way for integer values:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For backends that don’t use floor division by default, or when used with numeric
    values, the FLOOR() function is used to ensure floor division:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'New in version 2.0: Support for FLOOR division'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[`ColumnOperators.__mod__()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.__mod__
    "sqlalchemy.sql.expression.ColumnOperators.__mod__"), [`ColumnOperators.__rmod__()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.__rmod__
    "sqlalchemy.sql.expression.ColumnOperators.__rmod__") (Python “`%`” operator):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '## Bitwise Operators'
  prefs: []
  type: TYPE_NORMAL
- en: Bitwise operator functions provide uniform access to bitwise operators across
    different backends, which are expected to operate on compatible values such as
    integers and bit-strings (e.g. PostgreSQL [`BIT`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.BIT
    "sqlalchemy.dialects.postgresql.BIT") and similar). Note that these are **not**
    general boolean operators.
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 2.0.2: Added dedicated operators for bitwise operations.'
  prefs: []
  type: TYPE_NORMAL
- en: '[`ColumnOperators.bitwise_not()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.bitwise_not
    "sqlalchemy.sql.expression.ColumnOperators.bitwise_not"), [`bitwise_not()`](sqlelement.html#sqlalchemy.sql.expression.bitwise_not
    "sqlalchemy.sql.expression.bitwise_not"). Available as a column-level method,
    producing a bitwise NOT clause against a parent object:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This operator is also available as a column-expression-level method, applying
    bitwise NOT to an individual column expression:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[`ColumnOperators.bitwise_and()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.bitwise_and
    "sqlalchemy.sql.expression.ColumnOperators.bitwise_and") produces bitwise AND:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[`ColumnOperators.bitwise_or()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.bitwise_or
    "sqlalchemy.sql.expression.ColumnOperators.bitwise_or") produces bitwise OR:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[`ColumnOperators.bitwise_xor()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.bitwise_xor
    "sqlalchemy.sql.expression.ColumnOperators.bitwise_xor") produces bitwise XOR:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For PostgreSQL dialects, “#” is used to represent bitwise XOR; this emits automatically
    when using one of these backends:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[`ColumnOperators.bitwise_rshift()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.bitwise_rshift
    "sqlalchemy.sql.expression.ColumnOperators.bitwise_rshift"), [`ColumnOperators.bitwise_lshift()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.bitwise_lshift
    "sqlalchemy.sql.expression.ColumnOperators.bitwise_lshift") produce bitwise shift
    operators:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Using Conjunctions and Negations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The most common conjunction, “AND”, is automatically applied if we make repeated
    use of the [`Select.where()`](selectable.html#sqlalchemy.sql.expression.Select.where
    "sqlalchemy.sql.expression.Select.where") method, as well as similar methods such
    as [`Update.where()`](dml.html#sqlalchemy.sql.expression.Update.where "sqlalchemy.sql.expression.Update.where")
    and [`Delete.where()`](dml.html#sqlalchemy.sql.expression.Delete.where "sqlalchemy.sql.expression.Delete.where"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: '[`Select.where()`](selectable.html#sqlalchemy.sql.expression.Select.where "sqlalchemy.sql.expression.Select.where"),
    [`Update.where()`](dml.html#sqlalchemy.sql.expression.Update.where "sqlalchemy.sql.expression.Update.where")
    and [`Delete.where()`](dml.html#sqlalchemy.sql.expression.Delete.where "sqlalchemy.sql.expression.Delete.where")
    also accept multiple expressions with the same effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'The “AND” conjunction, as well as its partner “OR”, are both available directly
    using the [`and_()`](sqlelement.html#sqlalchemy.sql.expression.and_ "sqlalchemy.sql.expression.and_")
    and [`or_()`](sqlelement.html#sqlalchemy.sql.expression.or_ "sqlalchemy.sql.expression.or_")
    functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'A negation is available using the [`not_()`](sqlelement.html#sqlalchemy.sql.expression.not_
    "sqlalchemy.sql.expression.not_") function. This will typically invert the operator
    in a boolean expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 'It also may apply a keyword such as `NOT` when appropriate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: Conjunction Operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The above conjunction functions [`and_()`](sqlelement.html#sqlalchemy.sql.expression.and_
    "sqlalchemy.sql.expression.and_"), [`or_()`](sqlelement.html#sqlalchemy.sql.expression.or_
    "sqlalchemy.sql.expression.or_"), [`not_()`](sqlelement.html#sqlalchemy.sql.expression.not_
    "sqlalchemy.sql.expression.not_") are also available as overloaded Python operators:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The Python `&`, `|` and `~` operators take high precedence in the language;
    as a result, parenthesis must usually be applied for operands that themselves
    contain expressions, as indicated in the examples below.
  prefs: []
  type: TYPE_NORMAL
- en: '[`Operators.__and__()`](sqlelement.html#sqlalchemy.sql.expression.Operators.__and__
    "sqlalchemy.sql.expression.Operators.__and__") (Python “`&`” operator):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Python binary `&` operator is overloaded to behave the same as [`and_()`](sqlelement.html#sqlalchemy.sql.expression.and_
    "sqlalchemy.sql.expression.and_") (note parenthesis around the two operands):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[`Operators.__or__()`](sqlelement.html#sqlalchemy.sql.expression.Operators.__or__
    "sqlalchemy.sql.expression.Operators.__or__") (Python “`|`” operator):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Python binary `|` operator is overloaded to behave the same as [`or_()`](sqlelement.html#sqlalchemy.sql.expression.or_
    "sqlalchemy.sql.expression.or_") (note parenthesis around the two operands):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[`Operators.__invert__()`](sqlelement.html#sqlalchemy.sql.expression.Operators.__invert__
    "sqlalchemy.sql.expression.Operators.__invert__") (Python “`~`” operator):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Python binary `~` operator is overloaded to behave the same as [`not_()`](sqlelement.html#sqlalchemy.sql.expression.not_
    "sqlalchemy.sql.expression.not_"), either inverting the existing operator, or
    applying the `NOT` keyword to the expression as a whole:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
