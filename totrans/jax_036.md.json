["```py\nclass jax.errors.ConcretizationTypeError(tracer, context='')\n```", "```py\n>>> from functools import partial\n>>> from jax import jit\n>>> import jax.numpy as jnp\n>>> @jit\n... def func(x, axis):\n...   return x.min(axis) \n```", "```py\n>>> func(jnp.arange(4), 0)  \nTraceback (most recent call last):\n  ...\nConcretizationTypeError: Abstract tracer value encountered where concrete\nvalue is expected: axis argument to jnp.min(). \n```", "```py\n>>> @partial(jit, static_argnums=1)\n... def func(x, axis):\n...   return x.min(axis)\n\n>>> func(jnp.arange(4), 0)\nArray(0, dtype=int32) \n```", "```py\n>>> @jit\n... def func(x):\n...     return jnp.where(x < 0)\n\n>>> func(jnp.arange(4))  \nTraceback (most recent call last):\n  ...\nConcretizationTypeError: Abstract tracer value encountered where concrete value is expected:\nThe error arose in jnp.nonzero. \n```", "```py\n>>> @jit\n... def func(x):\n...     indices = jnp.where(x > 1)\n...     return x[indices].sum()\n\n>>> func(jnp.arange(4))  \nTraceback (most recent call last):\n  ...\nConcretizationTypeError: Abstract tracer value encountered where concrete\nvalue is expected: The error arose in jnp.nonzero. \n```", "```py\n>>> @jit\n... def func(x):\n...   return jnp.where(x > 1, x, 0).sum()\n\n>>> func(jnp.arange(4))\nArray(5, dtype=int32) \n```", "```py\nclass jax.errors.KeyReuseError(message)\n```", "```py\n>>> with jax.debug_key_reuse(True):  \n...   key = jax.random.key(0)\n...   value = jax.random.uniform(key)\n...   new_value = jax.random.uniform(key)\n...\n---------------------------------------------------------------------------\nKeyReuseError                             Traceback (most recent call last)\n...\nKeyReuseError: Previously-consumed key passed to jit-compiled function at index 0 \n```", "```py\nclass jax.errors.NonConcreteBooleanIndexError(tracer)\n```", "```py\n>>> import jax\n>>> import jax.numpy as jnp\n\n>>> @jax.jit\n... def positive_values(x):\n...   return x[x > 0]\n\n>>> positive_values(jnp.arange(-5, 5))  \nTraceback (most recent call last):\n  ...\nNonConcreteBooleanIndexError: Array boolean indices must be concrete: ShapedArray(bool[10]) \n```", "```py\n>>> @jax.jit\n... def sum_of_positive(x):\n...   return x[x > 0].sum()\n\n>>> sum_of_positive(jnp.arange(-5, 5))  \nTraceback (most recent call last):\n  ...\nNonConcreteBooleanIndexError: Array boolean indices must be concrete: ShapedArray(bool[10]) \n```", "```py\n>>> @jax.jit\n... def sum_of_positive(x):\n...   return jnp.where(x > 0, x, 0).sum()\n\n>>> sum_of_positive(jnp.arange(-5, 5))\nArray(10, dtype=int32) \n```", "```py\n>>> @jax.jit\n... def manual_clip(x):\n...   return x.at[x < 0].set(0)\n\n>>> manual_clip(jnp.arange(-2, 2))  \nTraceback (most recent call last):\n  ...\nNonConcreteBooleanIndexError: Array boolean indices must be concrete: ShapedArray(bool[4]) \n```", "```py\n>>> @jax.jit\n... def manual_clip(x):\n...   return jnp.where(x < 0, 0, x)\n\n>>> manual_clip(jnp.arange(-2, 2))\nArray([0, 0, 0, 1], dtype=int32) \n```", "```py\nclass jax.errors.TracerArrayConversionError(tracer)\n```", "```py\n>>> from jax import jit\n>>> import numpy as np\n\n>>> @jit\n... def func(x):\n...   return np.sin(x)\n\n>>> func(np.arange(4))  \nTraceback (most recent call last):\n  ...\nTracerArrayConversionError: The numpy.ndarray conversion method\n__array__() was called on traced array with shape int32[4] \n```", "```py\n>>> import jax.numpy as jnp\n>>> @jit\n... def func(x):\n...   return jnp.sin(x)\n\n>>> func(jnp.arange(4))\nArray([0\\.        , 0.84147096, 0.9092974 , 0.14112   ], dtype=float32) \n```", "```py\n>>> x = np.arange(10)\n\n>>> @jit\n... def func(i):\n...   return x[i]\n\n>>> func(0)  \nTraceback (most recent call last):\n  ...\nTracerArrayConversionError: The numpy.ndarray conversion method\n__array__() was called on traced array with shape int32[0] \n```", "```py\n>>> @jit\n... def func(i):\n...   return jnp.asarray(x)[i]\n\n>>> func(0)\nArray(0, dtype=int32) \n```", "```py\n>>> from functools import partial\n>>> @partial(jit, static_argnums=(0,))\n... def func(i):\n...   return x[i]\n\n>>> func(0)\nArray(0, dtype=int32) \n```", "```py\nclass jax.errors.TracerBoolConversionError(tracer)\n```", "```py\n>>> from jax import jit\n>>> import jax.numpy as jnp\n>>> @jit\n... def func(x, y):\n...   return x if x.sum() < y.sum() else y\n\n>>> func(jnp.ones(4), jnp.zeros(4))  \nTraceback (most recent call last):\n  ...\nTracerBoolConversionError: Attempted boolean conversion of JAX Tracer [...] \n```", "```py\n>>> @jit\n... def func(x, y):\n...   return jnp.where(x.sum() < y.sum(), x, y)\n\n>>> func(jnp.ones(4), jnp.zeros(4))\nArray([0., 0., 0., 0.], dtype=float32) \n```", "```py\n>>> @jit\n... def func(x, normalize=True):\n...   if normalize:\n...     return x / x.sum()\n...   return x\n\n>>> func(jnp.arange(5), True)  \nTraceback (most recent call last):\n  ...\nTracerBoolConversionError: Attempted boolean conversion of JAX Tracer ... \n```", "```py\n>>> from functools import partial\n>>> @partial(jit, static_argnames=['normalize'])\n... def func(x, normalize=True):\n...   if normalize:\n...     return x / x.sum()\n...   return x\n\n>>> func(jnp.arange(5), True)\nArray([0\\. , 0.1, 0.2, 0.3, 0.4], dtype=float32) \n```", "```py\n>>> @jit\n... def func(x):\n...   return min(x, 0) \n```", "```py\n>>> func(2)  \nTraceback (most recent call last):\n  ...\nTracerBoolConversionError: Attempted boolean conversion of JAX Tracer ... \n```", "```py\n>>> @jit\n... def func(x):\n...   return jnp.minimum(x, 0) \n```", "```py\n>>> print(func(2))\n0 \n```", "```py\nclass jax.errors.TracerIntegerConversionError(tracer)\n```", "```py\n>>> from jax import jit\n>>> import numpy as np\n\n>>> @jit\n... def func(x, axis):\n...   return np.split(x, 2, axis)\n\n>>> func(np.arange(4), 0)  \nTraceback (most recent call last):\n  ...\nTracerIntegerConversionError: The __index__() method was called on\ntraced array with shape int32[0] \n```", "```py\n>>> from functools import partial\n>>> @partial(jit, static_argnums=1)\n... def func(x, axis):\n...   return np.split(x, 2, axis)\n\n>>> func(np.arange(10), 0)\n[Array([0, 1, 2, 3, 4], dtype=int32),\n Array([5, 6, 7, 8, 9], dtype=int32)] \n```", "```py\n>>> jit(lambda arr: np.split(arr, 2, 0))(np.arange(4))\n[Array([0, 1], dtype=int32), Array([2, 3], dtype=int32)] \n```", "```py\n>>> import jax.numpy as jnp\n>>> from jax import jit\n\n>>> L = [1, 2, 3]\n\n>>> @jit\n... def func(i):\n...   return L[i]\n\n>>> func(0)  \nTraceback (most recent call last):\n  ...\nTracerIntegerConversionError: The __index__() method was called on\ntraced array with shape int32[0] \n```", "```py\n>>> @jit\n... def func(i):\n...   return jnp.array(L)[i]\n\n>>> func(0)\nArray(1, dtype=int32) \n```", "```py\n>>> from functools import partial\n>>> @partial(jit, static_argnums=0)\n... def func(i):\n...   return L[i]\n\n>>> func(0)\nArray(1, dtype=int32, weak_type=True) \n```", "```py\nclass jax.errors.UnexpectedTracerError(msg)\n```", "```py\n>>> from jax import jit\n>>> import jax.numpy as jnp\n\n>>> outs = []\n>>> @jit                   # 1\n... def side_effecting(x):\n...   y = x + 1            # 3\n...   outs.append(y)       # 4\n\n>>> x = 1\n>>> side_effecting(x)      # 2\n>>> outs[0] + 1            # 5 \nTraceback (most recent call last):\n  ...\nUnexpectedTracerError: Encountered an unexpected tracer. \n```", "```py\n>>> from jax import jit\n>>> import jax.numpy as jnp\n\n>>> outs = []\n>>> @jit\n... def not_side_effecting(x):\n...   y = x+1\n...   return y\n\n>>> x = 1\n>>> y = not_side_effecting(x)\n>>> outs.append(y)\n>>> outs[0] + 1  # all good! no longer a leaked value.\nArray(3, dtype=int32, weak_type=True) \n```", "```py\n>>> from jax import jit\n>>> import jax.numpy as jnp\n\n>>> outs = []\n>>> @jit\n... def side_effecting(x):\n...   y = x+1\n...   outs.append(y)\n\n>>> x = 1\n>>> with jax.checking_leaks():\n...   y = side_effecting(x)  \nTraceback (most recent call last):\n  ...\nException: Leaked Trace \n```"]