["```py\nuser_preference = Table(\n    \"user_preference\",\n    metadata_obj,\n    Column(\"pref_id\", Integer, primary_key=True),\n    Column(\"user_id\", Integer, ForeignKey(\"user.user_id\"), nullable=False),\n    Column(\"pref_name\", String(40), nullable=False),\n    Column(\"pref_value\", String(100)),\n)\n```", "```py\nForeignKey(user.c.user_id)\n```", "```py\ninvoice = Table(\n    \"invoice\",\n    metadata_obj,\n    Column(\"invoice_id\", Integer, primary_key=True),\n    Column(\"ref_num\", Integer, primary_key=True),\n    Column(\"description\", String(60), nullable=False),\n)\n```", "```py\ninvoice_item = Table(\n    \"invoice_item\",\n    metadata_obj,\n    Column(\"item_id\", Integer, primary_key=True),\n    Column(\"item_name\", String(60), nullable=False),\n    Column(\"invoice_id\", Integer, nullable=False),\n    Column(\"ref_num\", Integer, nullable=False),\n    ForeignKeyConstraint(\n        [\"invoice_id\", \"ref_num\"], [\"invoice.invoice_id\", \"invoice.ref_num\"]\n    ),\n)\n```", "```py\nCREATE  TABLE  addresses  (\n  id  INTEGER  NOT  NULL,\n  user_id  INTEGER,\n  email_address  VARCHAR  NOT  NULL,\n  PRIMARY  KEY  (id),\n  CONSTRAINT  user_id_fk  FOREIGN  KEY(user_id)  REFERENCES  users  (id)\n)\n```", "```py\nnode = Table(\n    \"node\",\n    metadata_obj,\n    Column(\"node_id\", Integer, primary_key=True),\n    Column(\"primary_element\", Integer, ForeignKey(\"element.element_id\")),\n)\n\nelement = Table(\n    \"element\",\n    metadata_obj,\n    Column(\"element_id\", Integer, primary_key=True),\n    Column(\"parent_node_id\", Integer),\n    ForeignKeyConstraint(\n        [\"parent_node_id\"], [\"node.node_id\"], name=\"fk_element_parent_node_id\"\n    ),\n)\n```", "```py\n>>> with engine.connect() as conn:\n...     metadata_obj.create_all(conn, checkfirst=False)\nCREATE  TABLE  element  (\n  element_id  SERIAL  NOT  NULL,\n  parent_node_id  INTEGER,\n  PRIMARY  KEY  (element_id)\n)\n\nCREATE  TABLE  node  (\n  node_id  SERIAL  NOT  NULL,\n  primary_element  INTEGER,\n  PRIMARY  KEY  (node_id)\n)\n\nALTER  TABLE  element  ADD  CONSTRAINT  fk_element_parent_node_id\n  FOREIGN  KEY(parent_node_id)  REFERENCES  node  (node_id)\nALTER  TABLE  node  ADD  FOREIGN  KEY(primary_element)\n  REFERENCES  element  (element_id) \n```", "```py\n>>> with engine.connect() as conn:\n...     metadata_obj.drop_all(conn, checkfirst=False)\nALTER  TABLE  element  DROP  CONSTRAINT  fk_element_parent_node_id\nDROP  TABLE  node\nDROP  TABLE  element \n```", "```py\nsqlalchemy.exc.CircularDependencyError: Can't sort tables for DROP;\nan unresolvable foreign key dependency exists between tables:\nelement, node.  Please ensure that the ForeignKey and ForeignKeyConstraint\nobjects involved in the cycle have names so that they can be dropped\nusing DROP CONSTRAINT.\n```", "```py\nelement = Table(\n    \"element\",\n    metadata_obj,\n    Column(\"element_id\", Integer, primary_key=True),\n    Column(\"parent_node_id\", Integer),\n    ForeignKeyConstraint(\n        [\"parent_node_id\"],\n        [\"node.node_id\"],\n        use_alter=True,\n        name=\"fk_element_parent_node_id\",\n    ),\n)\n```", "```py\n>>> with engine.connect() as conn:\n...     metadata_obj.create_all(conn, checkfirst=False)\nCREATE  TABLE  element  (\n  element_id  SERIAL  NOT  NULL,\n  parent_node_id  INTEGER,\n  PRIMARY  KEY  (element_id)\n)\n\nCREATE  TABLE  node  (\n  node_id  SERIAL  NOT  NULL,\n  primary_element  INTEGER,\n  PRIMARY  KEY  (node_id),\n  FOREIGN  KEY(primary_element)  REFERENCES  element  (element_id)\n)\n\nALTER  TABLE  element  ADD  CONSTRAINT  fk_element_parent_node_id\nFOREIGN  KEY(parent_node_id)  REFERENCES  node  (node_id) \n```", "```py\nsqlalchemy.exc.CompileError: Can't emit DROP CONSTRAINT for constraint\nForeignKeyConstraint(...); it has no name\n```", "```py\nchild = Table(\n    \"child\",\n    metadata_obj,\n    Column(\n        \"id\",\n        Integer,\n        ForeignKey(\"parent.id\", onupdate=\"CASCADE\", ondelete=\"CASCADE\"),\n        primary_key=True,\n    ),\n)\n\ncomposite = Table(\n    \"composite\",\n    metadata_obj,\n    Column(\"id\", Integer, primary_key=True),\n    Column(\"rev_id\", Integer),\n    Column(\"note_id\", Integer),\n    ForeignKeyConstraint(\n        [\"rev_id\", \"note_id\"],\n        [\"revisions.id\", \"revisions.note_id\"],\n        onupdate=\"CASCADE\",\n        ondelete=\"SET NULL\",\n    ),\n)\n```", "```py\nfrom sqlalchemy import UniqueConstraint\n\nmetadata_obj = MetaData()\nmytable = Table(\n    \"mytable\",\n    metadata_obj,\n    # per-column anonymous unique constraint\n    Column(\"col1\", Integer, unique=True),\n    Column(\"col2\", Integer),\n    Column(\"col3\", Integer),\n    # explicit/composite unique constraint.  'name' is optional.\n    UniqueConstraint(\"col2\", \"col3\", name=\"uix_1\"),\n)\n```", "```py\nfrom sqlalchemy import CheckConstraint\n\nmetadata_obj = MetaData()\nmytable = Table(\n    \"mytable\",\n    metadata_obj,\n    # per-column CHECK constraint\n    Column(\"col1\", Integer, CheckConstraint(\"col1>5\")),\n    Column(\"col2\", Integer),\n    Column(\"col3\", Integer),\n    # table level CHECK constraint.  'name' is optional.\n    CheckConstraint(\"col2 > col3 + 5\", name=\"check1\"),\n)\n\nmytable.create(engine)\nCREATE  TABLE  mytable  (\n  col1  INTEGER  CHECK  (col1>5),\n  col2  INTEGER,\n  col3  INTEGER,\n  CONSTRAINT  check1  CHECK  (col2  >  col3  +  5)\n) \n```", "```py\nfrom sqlalchemy import PrimaryKeyConstraint\n\nmy_table = Table(\n    \"mytable\",\n    metadata_obj,\n    Column(\"id\", Integer),\n    Column(\"version_id\", Integer),\n    Column(\"data\", String(50)),\n    PrimaryKeyConstraint(\"id\", \"version_id\", name=\"mytable_pk\"),\n)\n```", "```py\nconvention = {\n    \"ix\": \"ix_%(column_0_label)s\",\n    \"uq\": \"uq_%(table_name)s_%(column_0_name)s\",\n    \"ck\": \"ck_%(table_name)s_%(constraint_name)s\",\n    \"fk\": \"fk_%(table_name)s_%(column_0_name)s_%(referred_table_name)s\",\n    \"pk\": \"pk_%(table_name)s\",\n}\n\nmetadata_obj = MetaData(naming_convention=convention)\n```", "```py\n>>> user_table = Table(\n...     \"user\",\n...     metadata_obj,\n...     Column(\"id\", Integer, primary_key=True),\n...     Column(\"name\", String(30), nullable=False),\n...     UniqueConstraint(\"name\"),\n... )\n>>> list(user_table.constraints)[1].name\n'uq_user_name'\n```", "```py\n>>> user_table = Table(\n...     \"user\",\n...     metadata_obj,\n...     Column(\"id\", Integer, primary_key=True),\n...     Column(\"name\", String(30), nullable=False, unique=True),\n... )\n>>> list(user_table.constraints)[1].name\n'uq_user_name'\n```", "```py\ndef upgrade():\n    op.create_unique_constraint(\"uq_user_name\", \"user\", [\"name\"])\n```", "```py\n>>> from sqlalchemy.sql.schema import DEFAULT_NAMING_CONVENTION\n>>> DEFAULT_NAMING_CONVENTION\nimmutabledict({'ix': 'ix_%(column_0_label)s'})\n```", "```py\nmetadata_obj = MetaData(\n    naming_convention={\"uq\": \"uq_%(table_name)s_%(column_0_N_name)s\"}\n)\n\nlong_names = Table(\n    \"long_names\",\n    metadata_obj,\n    Column(\"information_channel_code\", Integer, key=\"a\"),\n    Column(\"billing_convention_name\", Integer, key=\"b\"),\n    Column(\"product_identifier\", Integer, key=\"c\"),\n    UniqueConstraint(\"a\", \"b\", \"c\"),\n)\n```", "```py\nCREATE  TABLE  long_names  (\n  information_channel_code  INTEGER,\n  billing_convention_name  INTEGER,\n  product_identifier  INTEGER,\n  CONSTRAINT  uq_long_names_information_channel_code_billing_conventi_a79e\n  UNIQUE  (information_channel_code,  billing_convention_name,  product_identifier)\n)\n```", "```py\nimport uuid\n\ndef fk_guid(constraint, table):\n    str_tokens = (\n        [\n            table.name,\n        ]\n        + [element.parent.name for element in constraint.elements]\n        + [element.target_fullname for element in constraint.elements]\n    )\n    guid = uuid.uuid5(uuid.NAMESPACE_OID, \"_\".join(str_tokens).encode(\"ascii\"))\n    return str(guid)\n\nconvention = {\n    \"fk_guid\": fk_guid,\n    \"ix\": \"ix_%(column_0_label)s\",\n    \"fk\": \"fk_%(fk_guid)s\",\n}\n```", "```py\n>>> metadata_obj = MetaData(naming_convention=convention)\n\n>>> user_table = Table(\n...     \"user\",\n...     metadata_obj,\n...     Column(\"id\", Integer, primary_key=True),\n...     Column(\"version\", Integer, primary_key=True),\n...     Column(\"data\", String(30)),\n... )\n>>> address_table = Table(\n...     \"address\",\n...     metadata_obj,\n...     Column(\"id\", Integer, primary_key=True),\n...     Column(\"user_id\", Integer),\n...     Column(\"user_version_id\", Integer),\n... )\n>>> fk = ForeignKeyConstraint([\"user_id\", \"user_version_id\"], [\"user.id\", \"user.version\"])\n>>> address_table.append_constraint(fk)\n>>> fk.name\nfk_0cd51ab5-8d70-56e8-a83c-86661737766d\n```", "```py\nmetadata_obj = MetaData(\n    naming_convention={\"ck\": \"ck_%(table_name)s_%(constraint_name)s\"}\n)\n\nTable(\n    \"foo\",\n    metadata_obj,\n    Column(\"value\", Integer),\n    CheckConstraint(\"value > 5\", name=\"value_gt_5\"),\n)\n```", "```py\nCREATE  TABLE  foo  (\n  value  INTEGER,\n  CONSTRAINT  ck_foo_value_gt_5  CHECK  (value  >  5)\n)\n```", "```py\nmetadata_obj = MetaData(naming_convention={\"ck\": \"ck_%(table_name)s_%(column_0_name)s\"})\n\nfoo = Table(\"foo\", metadata_obj, Column(\"value\", Integer))\n\nCheckConstraint(foo.c.value > 5)\n```", "```py\nfrom sqlalchemy import column\n\nmetadata_obj = MetaData(naming_convention={\"ck\": \"ck_%(table_name)s_%(column_0_name)s\"})\n\nfoo = Table(\n    \"foo\", metadata_obj, Column(\"value\", Integer), CheckConstraint(column(\"value\") > 5)\n)\n```", "```py\nCREATE  TABLE  foo  (\n  value  INTEGER,\n  CONSTRAINT  ck_foo_value  CHECK  (value  >  5)\n)\n```", "```py\nTable(\"foo\", metadata_obj, Column(\"flag\", Boolean(name=\"ck_foo_flag\")))\n```", "```py\nmetadata_obj = MetaData(\n    naming_convention={\"ck\": \"ck_%(table_name)s_%(constraint_name)s\"}\n)\n\nTable(\"foo\", metadata_obj, Column(\"flag\", Boolean(name=\"flag_bool\")))\n```", "```py\nCREATE  TABLE  foo  (\n  flag  BOOL,\n  CONSTRAINT  ck_foo_flag_bool  CHECK  (flag  IN  (0,  1))\n)\n```", "```py\nmetadata_obj = MetaData(naming_convention={\"ck\": \"ck_%(table_name)s_%(column_0_name)s\"})\n\nTable(\"foo\", metadata_obj, Column(\"flag\", Boolean()))\n```", "```py\nCREATE  TABLE  foo  (\n  flag  BOOL,\n  CONSTRAINT  ck_foo_flag  CHECK  (flag  IN  (0,  1))\n)\n```", "```py\nclass sqlalchemy.schema.Constraint\n```", "```py\nmethod __init__(name: _ConstraintNameArgument = None, deferrable: bool | None = None, initially: str | None = None, info: _InfoType | None = None, comment: str | None = None, _create_rule: Any | None = None, _type_bound: bool = False, **dialect_kw: Any) \u2192 None\n```", "```py\nclassmethod argument_for(dialect_name, argument_name, default)\n```", "```py\nIndex.argument_for(\"mydialect\", \"length\", None)\n\nsome_index = Index('a', 'b', mydialect_length=5)\n```", "```py\nmethod copy(**kw: Any) \u2192 Self\n```", "```py\nmethod ddl_if(dialect: str | None = None, callable_: DDLIfCallable | None = None, state: Any | None = None) \u2192 Self\n```", "```py\nattribute dialect_kwargs\n```", "```py\nattribute dialect_options\n```", "```py\narg = my_object.dialect_options['postgresql']['where']\n```", "```py\nattribute info\n```", "```py\nattribute kwargs\n```", "```py\nclass sqlalchemy.schema.ColumnCollectionMixin\n```", "```py\nclass sqlalchemy.schema.ColumnCollectionConstraint\n```", "```py\nmethod __init__(*columns: _DDLColumnArgument, name: _ConstraintNameArgument = None, deferrable: bool | None = None, initially: str | None = None, info: _InfoType | None = None, _autoattach: bool = True, _column_flag: bool = False, _gather_expressions: List[_DDLColumnArgument] | None = None, **dialect_kw: Any) \u2192 None\n```", "```py\nclassmethod argument_for(dialect_name, argument_name, default)\n```", "```py\nIndex.argument_for(\"mydialect\", \"length\", None)\n\nsome_index = Index('a', 'b', mydialect_length=5)\n```", "```py\nattribute columns: ReadOnlyColumnCollection[str, Column[Any]]\n```", "```py\nmethod contains_column(col: Column[Any]) \u2192 bool\n```", "```py\nmethod copy(*, target_table: Table | None = None, **kw: Any) \u2192 ColumnCollectionConstraint\n```", "```py\nmethod ddl_if(dialect: str | None = None, callable_: DDLIfCallable | None = None, state: Any | None = None) \u2192 Self\n```", "```py\nattribute dialect_kwargs\n```", "```py\nattribute dialect_options\n```", "```py\narg = my_object.dialect_options['postgresql']['where']\n```", "```py\nattribute info\n```", "```py\nattribute kwargs\n```", "```py\nclass sqlalchemy.schema.CheckConstraint\n```", "```py\nmethod __init__(sqltext: _TextCoercedExpressionArgument[Any], name: _ConstraintNameArgument = None, deferrable: bool | None = None, initially: str | None = None, table: Table | None = None, info: _InfoType | None = None, _create_rule: Any | None = None, _autoattach: bool = True, _type_bound: bool = False, **dialect_kw: Any) \u2192 None\n```", "```py\n    CheckConstraint(r\"foo ~ E'a(?\\:b|c)d\")\n    ```", "```py\nclassmethod argument_for(dialect_name, argument_name, default)\n```", "```py\nIndex.argument_for(\"mydialect\", \"length\", None)\n\nsome_index = Index('a', 'b', mydialect_length=5)\n```", "```py\nattribute columns: ReadOnlyColumnCollection[str, Column[Any]]\n```", "```py\nmethod contains_column(col: Column[Any]) \u2192 bool\n```", "```py\nmethod copy(*, target_table: Table | None = None, **kw: Any) \u2192 CheckConstraint\n```", "```py\nmethod ddl_if(dialect: str | None = None, callable_: DDLIfCallable | None = None, state: Any | None = None) \u2192 Self\n```", "```py\nattribute dialect_kwargs\n```", "```py\nattribute dialect_options\n```", "```py\narg = my_object.dialect_options['postgresql']['where']\n```", "```py\nattribute info\n```", "```py\nattribute kwargs\n```", "```py\nclass sqlalchemy.schema.ForeignKey\n```", "```py\nt = Table(\"remote_table\", metadata,\n    Column(\"remote_id\", ForeignKey(\"main_table.id\"))\n)\n```", "```py\nmethod __init__(column: _DDLColumnArgument, _constraint: ForeignKeyConstraint | None = None, use_alter: bool = False, name: _ConstraintNameArgument = None, onupdate: str | None = None, ondelete: str | None = None, deferrable: bool | None = None, initially: str | None = None, link_to_name: bool = False, match: str | None = None, info: _InfoType | None = None, comment: str | None = None, _unresolvable: bool = False, **dialect_kw: Any)\n```", "```py\nclassmethod argument_for(dialect_name, argument_name, default)\n```", "```py\nIndex.argument_for(\"mydialect\", \"length\", None)\n\nsome_index = Index('a', 'b', mydialect_length=5)\n```", "```py\nattribute column\n```", "```py\nmethod copy(*, schema: str | None = None, **kw: Any) \u2192 ForeignKey\n```", "```py\nattribute dialect_kwargs\n```", "```py\nattribute dialect_options\n```", "```py\narg = my_object.dialect_options['postgresql']['where']\n```", "```py\nmethod get_referent(table: FromClause) \u2192 Column[Any] | None\n```", "```py\nattribute info\n```", "```py\nattribute kwargs\n```", "```py\nmethod references(table: Table) \u2192 bool\n```", "```py\nattribute target_fullname\n```", "```py\nclass sqlalchemy.schema.ForeignKeyConstraint\n```", "```py\nmethod __init__(columns: _typing_Sequence[_DDLColumnArgument], refcolumns: _typing_Sequence[_DDLColumnArgument], name: _ConstraintNameArgument = None, onupdate: str | None = None, ondelete: str | None = None, deferrable: bool | None = None, initially: str | None = None, use_alter: bool = False, link_to_name: bool = False, match: str | None = None, table: Table | None = None, info: _InfoType | None = None, comment: str | None = None, **dialect_kw: Any) \u2192 None\n```", "```py\nclassmethod argument_for(dialect_name, argument_name, default)\n```", "```py\nIndex.argument_for(\"mydialect\", \"length\", None)\n\nsome_index = Index('a', 'b', mydialect_length=5)\n```", "```py\nattribute column_keys\n```", "```py\nattribute columns: ReadOnlyColumnCollection[str, Column[Any]]\n```", "```py\nmethod contains_column(col: Column[Any]) \u2192 bool\n```", "```py\nmethod copy(*, schema: str | None = None, target_table: Table | None = None, **kw: Any) \u2192 ForeignKeyConstraint\n```", "```py\nmethod ddl_if(dialect: str | None = None, callable_: DDLIfCallable | None = None, state: Any | None = None) \u2192 Self\n```", "```py\nattribute dialect_kwargs\n```", "```py\nattribute dialect_options\n```", "```py\narg = my_object.dialect_options['postgresql']['where']\n```", "```py\nattribute elements: List[ForeignKey]\n```", "```py\nattribute info\n```", "```py\nattribute kwargs\n```", "```py\nattribute referred_table\n```", "```py\nclass sqlalchemy.schema.HasConditionalDDL\n```", "```py\nmethod ddl_if(dialect: str | None = None, callable_: DDLIfCallable | None = None, state: Any | None = None) \u2192 Self\n```", "```py\nclass sqlalchemy.schema.PrimaryKeyConstraint\n```", "```py\n>>> my_table = Table('mytable', metadata,\n...                 Column('id', Integer, primary_key=True),\n...                 Column('version_id', Integer, primary_key=True),\n...                 Column('data', String(50))\n...     )\n>>> my_table.primary_key\nPrimaryKeyConstraint(\n Column('id', Integer(), table=<mytable>,\n primary_key=True, nullable=False),\n Column('version_id', Integer(), table=<mytable>,\n primary_key=True, nullable=False)\n)\n```", "```py\nmy_table = Table('mytable', metadata,\n            Column('id', Integer),\n            Column('version_id', Integer),\n            Column('data', String(50)),\n            PrimaryKeyConstraint('id', 'version_id',\n                                 name='mytable_pk')\n        )\n```", "```py\nmy_table = Table('mytable', metadata,\n            Column('id', Integer, primary_key=True),\n            Column('version_id', Integer, primary_key=True),\n            Column('data', String(50)),\n            PrimaryKeyConstraint(name='mytable_pk',\n                                 mssql_clustered=True)\n        )\n```", "```py\nclassmethod argument_for(dialect_name, argument_name, default)\n```", "```py\nIndex.argument_for(\"mydialect\", \"length\", None)\n\nsome_index = Index('a', 'b', mydialect_length=5)\n```", "```py\nattribute columns: ReadOnlyColumnCollection[str, Column[Any]]\n```", "```py\nmethod contains_column(col: Column[Any]) \u2192 bool\n```", "```py\nmethod copy(*, target_table: Table | None = None, **kw: Any) \u2192 ColumnCollectionConstraint\n```", "```py\nmethod ddl_if(dialect: str | None = None, callable_: DDLIfCallable | None = None, state: Any | None = None) \u2192 Self\n```", "```py\nattribute dialect_kwargs\n```", "```py\nattribute dialect_options\n```", "```py\narg = my_object.dialect_options['postgresql']['where']\n```", "```py\nattribute info\n```", "```py\nattribute kwargs\n```", "```py\nclass sqlalchemy.schema.UniqueConstraint\n```", "```py\nmethod __init__(*columns: _DDLColumnArgument, name: _ConstraintNameArgument = None, deferrable: bool | None = None, initially: str | None = None, info: _InfoType | None = None, _autoattach: bool = True, _column_flag: bool = False, _gather_expressions: List[_DDLColumnArgument] | None = None, **dialect_kw: Any) \u2192 None\n```", "```py\nclassmethod argument_for(dialect_name, argument_name, default)\n```", "```py\nIndex.argument_for(\"mydialect\", \"length\", None)\n\nsome_index = Index('a', 'b', mydialect_length=5)\n```", "```py\nattribute columns: ReadOnlyColumnCollection[str, Column[Any]]\n```", "```py\nmethod contains_column(col: Column[Any]) \u2192 bool\n```", "```py\nmethod copy(*, target_table: Table | None = None, **kw: Any) \u2192 ColumnCollectionConstraint\n```", "```py\nmethod ddl_if(dialect: str | None = None, callable_: DDLIfCallable | None = None, state: Any | None = None) \u2192 Self\n```", "```py\nattribute dialect_kwargs\n```", "```py\nattribute dialect_options\n```", "```py\narg = my_object.dialect_options['postgresql']['where']\n```", "```py\nattribute info\n```", "```py\nattribute kwargs\n```", "```py\nfunction sqlalchemy.schema.conv(value: str, quote: bool | None = None) \u2192 Any\n```", "```py\nm = MetaData(naming_convention={\n    \"ck\": \"ck_%(table_name)s_%(constraint_name)s\"\n})\nt = Table('t', m, Column('x', Integer),\n                CheckConstraint('x > 5', name='x5'))\n```", "```py\nm = MetaData(naming_convention={\n    \"ck\": \"ck_%(table_name)s_%(constraint_name)s\"\n})\nt = Table('t', m, Column('x', Integer),\n                CheckConstraint('x > 5', name=conv('ck_t_x5')))\n```", "```py\nmetadata_obj = MetaData()\nmytable = Table(\n    \"mytable\",\n    metadata_obj,\n    # an indexed column, with index \"ix_mytable_col1\"\n    Column(\"col1\", Integer, index=True),\n    # a uniquely indexed column with index \"ix_mytable_col2\"\n    Column(\"col2\", Integer, index=True, unique=True),\n    Column(\"col3\", Integer),\n    Column(\"col4\", Integer),\n    Column(\"col5\", Integer),\n    Column(\"col6\", Integer),\n)\n\n# place an index on col3, col4\nIndex(\"idx_col34\", mytable.c.col3, mytable.c.col4)\n\n# place a unique index on col5, col6\nIndex(\"myindex\", mytable.c.col5, mytable.c.col6, unique=True)\n\nmytable.create(engine)\nCREATE  TABLE  mytable  (\n  col1  INTEGER,\n  col2  INTEGER,\n  col3  INTEGER,\n  col4  INTEGER,\n  col5  INTEGER,\n  col6  INTEGER\n)\nCREATE  INDEX  ix_mytable_col1  ON  mytable  (col1)\nCREATE  UNIQUE  INDEX  ix_mytable_col2  ON  mytable  (col2)\nCREATE  UNIQUE  INDEX  myindex  ON  mytable  (col5,  col6)\nCREATE  INDEX  idx_col34  ON  mytable  (col3,  col4) \n```", "```py\nmetadata_obj = MetaData()\nmytable = Table(\n    \"mytable\",\n    metadata_obj,\n    Column(\"col1\", Integer),\n    Column(\"col2\", Integer),\n    Column(\"col3\", Integer),\n    Column(\"col4\", Integer),\n    # place an index on col1, col2\n    Index(\"idx_col12\", \"col1\", \"col2\"),\n    # place a unique index on col3, col4\n    Index(\"idx_col34\", \"col3\", \"col4\", unique=True),\n)\n```", "```py\ni = Index(\"someindex\", mytable.c.col5)\ni.create(engine)\nCREATE  INDEX  someindex  ON  mytable  (col5) \n```", "```py\nfrom sqlalchemy import Index\n\nIndex(\"someindex\", mytable.c.somecol.desc())\n```", "```py\nfrom sqlalchemy import func, Index\n\nIndex(\"someindex\", func.lower(mytable.c.somecol))\n```", "```py\nclass sqlalchemy.schema.Index\n```", "```py\nsometable = Table(\"sometable\", metadata,\n                Column(\"name\", String(50)),\n                Column(\"address\", String(100))\n            )\n\nIndex(\"some_index\", sometable.c.name)\n```", "```py\nsometable = Table(\"sometable\", metadata,\n                Column(\"name\", String(50), index=True)\n            )\n```", "```py\nIndex(\"some_index\", sometable.c.name, sometable.c.address)\n```", "```py\nIndex(\"some_index\", func.lower(sometable.c.name))\n```", "```py\nTable(\"sometable\", metadata,\n                Column(\"name\", String(50)),\n                Column(\"address\", String(100)),\n                Index(\"some_index\", \"name\", \"address\")\n        )\n```", "```py\nfrom sqlalchemy import text\n\nTable(\"sometable\", metadata,\n                Column(\"name\", String(50)),\n                Column(\"address\", String(100)),\n                Index(\"some_index\", text(\"lower(name)\"))\n        )\n```", "```py\nmethod __init__(name: str | None, *expressions: _DDLColumnArgument, unique: bool = False, quote: bool | None = None, info: _InfoType | None = None, _table: Table | None = None, _column_flag: bool = False, **dialect_kw: Any) \u2192 None\n```", "```py\nclassmethod argument_for(dialect_name, argument_name, default)\n```", "```py\nIndex.argument_for(\"mydialect\", \"length\", None)\n\nsome_index = Index('a', 'b', mydialect_length=5)\n```", "```py\nmethod create(bind: _CreateDropBind, checkfirst: bool = False) \u2192 None\n```", "```py\nmethod ddl_if(dialect: str | None = None, callable_: DDLIfCallable | None = None, state: Any | None = None) \u2192 Self\n```", "```py\nattribute dialect_kwargs\n```", "```py\nattribute dialect_options\n```", "```py\narg = my_object.dialect_options['postgresql']['where']\n```", "```py\nmethod drop(bind: _CreateDropBind, checkfirst: bool = False) \u2192 None\n```", "```py\nattribute info\n```", "```py\nattribute kwargs\n```", "```py\nuser_preference = Table(\n    \"user_preference\",\n    metadata_obj,\n    Column(\"pref_id\", Integer, primary_key=True),\n    Column(\"user_id\", Integer, ForeignKey(\"user.user_id\"), nullable=False),\n    Column(\"pref_name\", String(40), nullable=False),\n    Column(\"pref_value\", String(100)),\n)\n```", "```py\nForeignKey(user.c.user_id)\n```", "```py\ninvoice = Table(\n    \"invoice\",\n    metadata_obj,\n    Column(\"invoice_id\", Integer, primary_key=True),\n    Column(\"ref_num\", Integer, primary_key=True),\n    Column(\"description\", String(60), nullable=False),\n)\n```", "```py\ninvoice_item = Table(\n    \"invoice_item\",\n    metadata_obj,\n    Column(\"item_id\", Integer, primary_key=True),\n    Column(\"item_name\", String(60), nullable=False),\n    Column(\"invoice_id\", Integer, nullable=False),\n    Column(\"ref_num\", Integer, nullable=False),\n    ForeignKeyConstraint(\n        [\"invoice_id\", \"ref_num\"], [\"invoice.invoice_id\", \"invoice.ref_num\"]\n    ),\n)\n```", "```py\nCREATE  TABLE  addresses  (\n  id  INTEGER  NOT  NULL,\n  user_id  INTEGER,\n  email_address  VARCHAR  NOT  NULL,\n  PRIMARY  KEY  (id),\n  CONSTRAINT  user_id_fk  FOREIGN  KEY(user_id)  REFERENCES  users  (id)\n)\n```", "```py\nnode = Table(\n    \"node\",\n    metadata_obj,\n    Column(\"node_id\", Integer, primary_key=True),\n    Column(\"primary_element\", Integer, ForeignKey(\"element.element_id\")),\n)\n\nelement = Table(\n    \"element\",\n    metadata_obj,\n    Column(\"element_id\", Integer, primary_key=True),\n    Column(\"parent_node_id\", Integer),\n    ForeignKeyConstraint(\n        [\"parent_node_id\"], [\"node.node_id\"], name=\"fk_element_parent_node_id\"\n    ),\n)\n```", "```py\n>>> with engine.connect() as conn:\n...     metadata_obj.create_all(conn, checkfirst=False)\nCREATE  TABLE  element  (\n  element_id  SERIAL  NOT  NULL,\n  parent_node_id  INTEGER,\n  PRIMARY  KEY  (element_id)\n)\n\nCREATE  TABLE  node  (\n  node_id  SERIAL  NOT  NULL,\n  primary_element  INTEGER,\n  PRIMARY  KEY  (node_id)\n)\n\nALTER  TABLE  element  ADD  CONSTRAINT  fk_element_parent_node_id\n  FOREIGN  KEY(parent_node_id)  REFERENCES  node  (node_id)\nALTER  TABLE  node  ADD  FOREIGN  KEY(primary_element)\n  REFERENCES  element  (element_id) \n```", "```py\n>>> with engine.connect() as conn:\n...     metadata_obj.drop_all(conn, checkfirst=False)\nALTER  TABLE  element  DROP  CONSTRAINT  fk_element_parent_node_id\nDROP  TABLE  node\nDROP  TABLE  element \n```", "```py\nsqlalchemy.exc.CircularDependencyError: Can't sort tables for DROP;\nan unresolvable foreign key dependency exists between tables:\nelement, node.  Please ensure that the ForeignKey and ForeignKeyConstraint\nobjects involved in the cycle have names so that they can be dropped\nusing DROP CONSTRAINT.\n```", "```py\nelement = Table(\n    \"element\",\n    metadata_obj,\n    Column(\"element_id\", Integer, primary_key=True),\n    Column(\"parent_node_id\", Integer),\n    ForeignKeyConstraint(\n        [\"parent_node_id\"],\n        [\"node.node_id\"],\n        use_alter=True,\n        name=\"fk_element_parent_node_id\",\n    ),\n)\n```", "```py\n>>> with engine.connect() as conn:\n...     metadata_obj.create_all(conn, checkfirst=False)\nCREATE  TABLE  element  (\n  element_id  SERIAL  NOT  NULL,\n  parent_node_id  INTEGER,\n  PRIMARY  KEY  (element_id)\n)\n\nCREATE  TABLE  node  (\n  node_id  SERIAL  NOT  NULL,\n  primary_element  INTEGER,\n  PRIMARY  KEY  (node_id),\n  FOREIGN  KEY(primary_element)  REFERENCES  element  (element_id)\n)\n\nALTER  TABLE  element  ADD  CONSTRAINT  fk_element_parent_node_id\nFOREIGN  KEY(parent_node_id)  REFERENCES  node  (node_id) \n```", "```py\nsqlalchemy.exc.CompileError: Can't emit DROP CONSTRAINT for constraint\nForeignKeyConstraint(...); it has no name\n```", "```py\nchild = Table(\n    \"child\",\n    metadata_obj,\n    Column(\n        \"id\",\n        Integer,\n        ForeignKey(\"parent.id\", onupdate=\"CASCADE\", ondelete=\"CASCADE\"),\n        primary_key=True,\n    ),\n)\n\ncomposite = Table(\n    \"composite\",\n    metadata_obj,\n    Column(\"id\", Integer, primary_key=True),\n    Column(\"rev_id\", Integer),\n    Column(\"note_id\", Integer),\n    ForeignKeyConstraint(\n        [\"rev_id\", \"note_id\"],\n        [\"revisions.id\", \"revisions.note_id\"],\n        onupdate=\"CASCADE\",\n        ondelete=\"SET NULL\",\n    ),\n)\n```", "```py\nCREATE  TABLE  addresses  (\n  id  INTEGER  NOT  NULL,\n  user_id  INTEGER,\n  email_address  VARCHAR  NOT  NULL,\n  PRIMARY  KEY  (id),\n  CONSTRAINT  user_id_fk  FOREIGN  KEY(user_id)  REFERENCES  users  (id)\n)\n```", "```py\nnode = Table(\n    \"node\",\n    metadata_obj,\n    Column(\"node_id\", Integer, primary_key=True),\n    Column(\"primary_element\", Integer, ForeignKey(\"element.element_id\")),\n)\n\nelement = Table(\n    \"element\",\n    metadata_obj,\n    Column(\"element_id\", Integer, primary_key=True),\n    Column(\"parent_node_id\", Integer),\n    ForeignKeyConstraint(\n        [\"parent_node_id\"], [\"node.node_id\"], name=\"fk_element_parent_node_id\"\n    ),\n)\n```", "```py\n>>> with engine.connect() as conn:\n...     metadata_obj.create_all(conn, checkfirst=False)\nCREATE  TABLE  element  (\n  element_id  SERIAL  NOT  NULL,\n  parent_node_id  INTEGER,\n  PRIMARY  KEY  (element_id)\n)\n\nCREATE  TABLE  node  (\n  node_id  SERIAL  NOT  NULL,\n  primary_element  INTEGER,\n  PRIMARY  KEY  (node_id)\n)\n\nALTER  TABLE  element  ADD  CONSTRAINT  fk_element_parent_node_id\n  FOREIGN  KEY(parent_node_id)  REFERENCES  node  (node_id)\nALTER  TABLE  node  ADD  FOREIGN  KEY(primary_element)\n  REFERENCES  element  (element_id) \n```", "```py\n>>> with engine.connect() as conn:\n...     metadata_obj.drop_all(conn, checkfirst=False)\nALTER  TABLE  element  DROP  CONSTRAINT  fk_element_parent_node_id\nDROP  TABLE  node\nDROP  TABLE  element \n```", "```py\nsqlalchemy.exc.CircularDependencyError: Can't sort tables for DROP;\nan unresolvable foreign key dependency exists between tables:\nelement, node.  Please ensure that the ForeignKey and ForeignKeyConstraint\nobjects involved in the cycle have names so that they can be dropped\nusing DROP CONSTRAINT.\n```", "```py\nelement = Table(\n    \"element\",\n    metadata_obj,\n    Column(\"element_id\", Integer, primary_key=True),\n    Column(\"parent_node_id\", Integer),\n    ForeignKeyConstraint(\n        [\"parent_node_id\"],\n        [\"node.node_id\"],\n        use_alter=True,\n        name=\"fk_element_parent_node_id\",\n    ),\n)\n```", "```py\n>>> with engine.connect() as conn:\n...     metadata_obj.create_all(conn, checkfirst=False)\nCREATE  TABLE  element  (\n  element_id  SERIAL  NOT  NULL,\n  parent_node_id  INTEGER,\n  PRIMARY  KEY  (element_id)\n)\n\nCREATE  TABLE  node  (\n  node_id  SERIAL  NOT  NULL,\n  primary_element  INTEGER,\n  PRIMARY  KEY  (node_id),\n  FOREIGN  KEY(primary_element)  REFERENCES  element  (element_id)\n)\n\nALTER  TABLE  element  ADD  CONSTRAINT  fk_element_parent_node_id\nFOREIGN  KEY(parent_node_id)  REFERENCES  node  (node_id) \n```", "```py\nsqlalchemy.exc.CompileError: Can't emit DROP CONSTRAINT for constraint\nForeignKeyConstraint(...); it has no name\n```", "```py\nchild = Table(\n    \"child\",\n    metadata_obj,\n    Column(\n        \"id\",\n        Integer,\n        ForeignKey(\"parent.id\", onupdate=\"CASCADE\", ondelete=\"CASCADE\"),\n        primary_key=True,\n    ),\n)\n\ncomposite = Table(\n    \"composite\",\n    metadata_obj,\n    Column(\"id\", Integer, primary_key=True),\n    Column(\"rev_id\", Integer),\n    Column(\"note_id\", Integer),\n    ForeignKeyConstraint(\n        [\"rev_id\", \"note_id\"],\n        [\"revisions.id\", \"revisions.note_id\"],\n        onupdate=\"CASCADE\",\n        ondelete=\"SET NULL\",\n    ),\n)\n```", "```py\nfrom sqlalchemy import UniqueConstraint\n\nmetadata_obj = MetaData()\nmytable = Table(\n    \"mytable\",\n    metadata_obj,\n    # per-column anonymous unique constraint\n    Column(\"col1\", Integer, unique=True),\n    Column(\"col2\", Integer),\n    Column(\"col3\", Integer),\n    # explicit/composite unique constraint.  'name' is optional.\n    UniqueConstraint(\"col2\", \"col3\", name=\"uix_1\"),\n)\n```", "```py\nfrom sqlalchemy import CheckConstraint\n\nmetadata_obj = MetaData()\nmytable = Table(\n    \"mytable\",\n    metadata_obj,\n    # per-column CHECK constraint\n    Column(\"col1\", Integer, CheckConstraint(\"col1>5\")),\n    Column(\"col2\", Integer),\n    Column(\"col3\", Integer),\n    # table level CHECK constraint.  'name' is optional.\n    CheckConstraint(\"col2 > col3 + 5\", name=\"check1\"),\n)\n\nmytable.create(engine)\nCREATE  TABLE  mytable  (\n  col1  INTEGER  CHECK  (col1>5),\n  col2  INTEGER,\n  col3  INTEGER,\n  CONSTRAINT  check1  CHECK  (col2  >  col3  +  5)\n) \n```", "```py\nfrom sqlalchemy import PrimaryKeyConstraint\n\nmy_table = Table(\n    \"mytable\",\n    metadata_obj,\n    Column(\"id\", Integer),\n    Column(\"version_id\", Integer),\n    Column(\"data\", String(50)),\n    PrimaryKeyConstraint(\"id\", \"version_id\", name=\"mytable_pk\"),\n)\n```", "```py\nconvention = {\n    \"ix\": \"ix_%(column_0_label)s\",\n    \"uq\": \"uq_%(table_name)s_%(column_0_name)s\",\n    \"ck\": \"ck_%(table_name)s_%(constraint_name)s\",\n    \"fk\": \"fk_%(table_name)s_%(column_0_name)s_%(referred_table_name)s\",\n    \"pk\": \"pk_%(table_name)s\",\n}\n\nmetadata_obj = MetaData(naming_convention=convention)\n```", "```py\n>>> user_table = Table(\n...     \"user\",\n...     metadata_obj,\n...     Column(\"id\", Integer, primary_key=True),\n...     Column(\"name\", String(30), nullable=False),\n...     UniqueConstraint(\"name\"),\n... )\n>>> list(user_table.constraints)[1].name\n'uq_user_name'\n```", "```py\n>>> user_table = Table(\n...     \"user\",\n...     metadata_obj,\n...     Column(\"id\", Integer, primary_key=True),\n...     Column(\"name\", String(30), nullable=False, unique=True),\n... )\n>>> list(user_table.constraints)[1].name\n'uq_user_name'\n```", "```py\ndef upgrade():\n    op.create_unique_constraint(\"uq_user_name\", \"user\", [\"name\"])\n```", "```py\n>>> from sqlalchemy.sql.schema import DEFAULT_NAMING_CONVENTION\n>>> DEFAULT_NAMING_CONVENTION\nimmutabledict({'ix': 'ix_%(column_0_label)s'})\n```", "```py\nmetadata_obj = MetaData(\n    naming_convention={\"uq\": \"uq_%(table_name)s_%(column_0_N_name)s\"}\n)\n\nlong_names = Table(\n    \"long_names\",\n    metadata_obj,\n    Column(\"information_channel_code\", Integer, key=\"a\"),\n    Column(\"billing_convention_name\", Integer, key=\"b\"),\n    Column(\"product_identifier\", Integer, key=\"c\"),\n    UniqueConstraint(\"a\", \"b\", \"c\"),\n)\n```", "```py\nCREATE  TABLE  long_names  (\n  information_channel_code  INTEGER,\n  billing_convention_name  INTEGER,\n  product_identifier  INTEGER,\n  CONSTRAINT  uq_long_names_information_channel_code_billing_conventi_a79e\n  UNIQUE  (information_channel_code,  billing_convention_name,  product_identifier)\n)\n```", "```py\nimport uuid\n\ndef fk_guid(constraint, table):\n    str_tokens = (\n        [\n            table.name,\n        ]\n        + [element.parent.name for element in constraint.elements]\n        + [element.target_fullname for element in constraint.elements]\n    )\n    guid = uuid.uuid5(uuid.NAMESPACE_OID, \"_\".join(str_tokens).encode(\"ascii\"))\n    return str(guid)\n\nconvention = {\n    \"fk_guid\": fk_guid,\n    \"ix\": \"ix_%(column_0_label)s\",\n    \"fk\": \"fk_%(fk_guid)s\",\n}\n```", "```py\n>>> metadata_obj = MetaData(naming_convention=convention)\n\n>>> user_table = Table(\n...     \"user\",\n...     metadata_obj,\n...     Column(\"id\", Integer, primary_key=True),\n...     Column(\"version\", Integer, primary_key=True),\n...     Column(\"data\", String(30)),\n... )\n>>> address_table = Table(\n...     \"address\",\n...     metadata_obj,\n...     Column(\"id\", Integer, primary_key=True),\n...     Column(\"user_id\", Integer),\n...     Column(\"user_version_id\", Integer),\n... )\n>>> fk = ForeignKeyConstraint([\"user_id\", \"user_version_id\"], [\"user.id\", \"user.version\"])\n>>> address_table.append_constraint(fk)\n>>> fk.name\nfk_0cd51ab5-8d70-56e8-a83c-86661737766d\n```", "```py\nmetadata_obj = MetaData(\n    naming_convention={\"ck\": \"ck_%(table_name)s_%(constraint_name)s\"}\n)\n\nTable(\n    \"foo\",\n    metadata_obj,\n    Column(\"value\", Integer),\n    CheckConstraint(\"value > 5\", name=\"value_gt_5\"),\n)\n```", "```py\nCREATE  TABLE  foo  (\n  value  INTEGER,\n  CONSTRAINT  ck_foo_value_gt_5  CHECK  (value  >  5)\n)\n```", "```py\nmetadata_obj = MetaData(naming_convention={\"ck\": \"ck_%(table_name)s_%(column_0_name)s\"})\n\nfoo = Table(\"foo\", metadata_obj, Column(\"value\", Integer))\n\nCheckConstraint(foo.c.value > 5)\n```", "```py\nfrom sqlalchemy import column\n\nmetadata_obj = MetaData(naming_convention={\"ck\": \"ck_%(table_name)s_%(column_0_name)s\"})\n\nfoo = Table(\n    \"foo\", metadata_obj, Column(\"value\", Integer), CheckConstraint(column(\"value\") > 5)\n)\n```", "```py\nCREATE  TABLE  foo  (\n  value  INTEGER,\n  CONSTRAINT  ck_foo_value  CHECK  (value  >  5)\n)\n```", "```py\nTable(\"foo\", metadata_obj, Column(\"flag\", Boolean(name=\"ck_foo_flag\")))\n```", "```py\nmetadata_obj = MetaData(\n    naming_convention={\"ck\": \"ck_%(table_name)s_%(constraint_name)s\"}\n)\n\nTable(\"foo\", metadata_obj, Column(\"flag\", Boolean(name=\"flag_bool\")))\n```", "```py\nCREATE  TABLE  foo  (\n  flag  BOOL,\n  CONSTRAINT  ck_foo_flag_bool  CHECK  (flag  IN  (0,  1))\n)\n```", "```py\nmetadata_obj = MetaData(naming_convention={\"ck\": \"ck_%(table_name)s_%(column_0_name)s\"})\n\nTable(\"foo\", metadata_obj, Column(\"flag\", Boolean()))\n```", "```py\nCREATE  TABLE  foo  (\n  flag  BOOL,\n  CONSTRAINT  ck_foo_flag  CHECK  (flag  IN  (0,  1))\n)\n```", "```py\nconvention = {\n    \"ix\": \"ix_%(column_0_label)s\",\n    \"uq\": \"uq_%(table_name)s_%(column_0_name)s\",\n    \"ck\": \"ck_%(table_name)s_%(constraint_name)s\",\n    \"fk\": \"fk_%(table_name)s_%(column_0_name)s_%(referred_table_name)s\",\n    \"pk\": \"pk_%(table_name)s\",\n}\n\nmetadata_obj = MetaData(naming_convention=convention)\n```", "```py\n>>> user_table = Table(\n...     \"user\",\n...     metadata_obj,\n...     Column(\"id\", Integer, primary_key=True),\n...     Column(\"name\", String(30), nullable=False),\n...     UniqueConstraint(\"name\"),\n... )\n>>> list(user_table.constraints)[1].name\n'uq_user_name'\n```", "```py\n>>> user_table = Table(\n...     \"user\",\n...     metadata_obj,\n...     Column(\"id\", Integer, primary_key=True),\n...     Column(\"name\", String(30), nullable=False, unique=True),\n... )\n>>> list(user_table.constraints)[1].name\n'uq_user_name'\n```", "```py\ndef upgrade():\n    op.create_unique_constraint(\"uq_user_name\", \"user\", [\"name\"])\n```", "```py\n>>> from sqlalchemy.sql.schema import DEFAULT_NAMING_CONVENTION\n>>> DEFAULT_NAMING_CONVENTION\nimmutabledict({'ix': 'ix_%(column_0_label)s'})\n```", "```py\nmetadata_obj = MetaData(\n    naming_convention={\"uq\": \"uq_%(table_name)s_%(column_0_N_name)s\"}\n)\n\nlong_names = Table(\n    \"long_names\",\n    metadata_obj,\n    Column(\"information_channel_code\", Integer, key=\"a\"),\n    Column(\"billing_convention_name\", Integer, key=\"b\"),\n    Column(\"product_identifier\", Integer, key=\"c\"),\n    UniqueConstraint(\"a\", \"b\", \"c\"),\n)\n```", "```py\nCREATE  TABLE  long_names  (\n  information_channel_code  INTEGER,\n  billing_convention_name  INTEGER,\n  product_identifier  INTEGER,\n  CONSTRAINT  uq_long_names_information_channel_code_billing_conventi_a79e\n  UNIQUE  (information_channel_code,  billing_convention_name,  product_identifier)\n)\n```", "```py\nimport uuid\n\ndef fk_guid(constraint, table):\n    str_tokens = (\n        [\n            table.name,\n        ]\n        + [element.parent.name for element in constraint.elements]\n        + [element.target_fullname for element in constraint.elements]\n    )\n    guid = uuid.uuid5(uuid.NAMESPACE_OID, \"_\".join(str_tokens).encode(\"ascii\"))\n    return str(guid)\n\nconvention = {\n    \"fk_guid\": fk_guid,\n    \"ix\": \"ix_%(column_0_label)s\",\n    \"fk\": \"fk_%(fk_guid)s\",\n}\n```", "```py\n>>> metadata_obj = MetaData(naming_convention=convention)\n\n>>> user_table = Table(\n...     \"user\",\n...     metadata_obj,\n...     Column(\"id\", Integer, primary_key=True),\n...     Column(\"version\", Integer, primary_key=True),\n...     Column(\"data\", String(30)),\n... )\n>>> address_table = Table(\n...     \"address\",\n...     metadata_obj,\n...     Column(\"id\", Integer, primary_key=True),\n...     Column(\"user_id\", Integer),\n...     Column(\"user_version_id\", Integer),\n... )\n>>> fk = ForeignKeyConstraint([\"user_id\", \"user_version_id\"], [\"user.id\", \"user.version\"])\n>>> address_table.append_constraint(fk)\n>>> fk.name\nfk_0cd51ab5-8d70-56e8-a83c-86661737766d\n```", "```py\nmetadata_obj = MetaData(\n    naming_convention={\"ck\": \"ck_%(table_name)s_%(constraint_name)s\"}\n)\n\nTable(\n    \"foo\",\n    metadata_obj,\n    Column(\"value\", Integer),\n    CheckConstraint(\"value > 5\", name=\"value_gt_5\"),\n)\n```", "```py\nCREATE  TABLE  foo  (\n  value  INTEGER,\n  CONSTRAINT  ck_foo_value_gt_5  CHECK  (value  >  5)\n)\n```", "```py\nmetadata_obj = MetaData(naming_convention={\"ck\": \"ck_%(table_name)s_%(column_0_name)s\"})\n\nfoo = Table(\"foo\", metadata_obj, Column(\"value\", Integer))\n\nCheckConstraint(foo.c.value > 5)\n```", "```py\nfrom sqlalchemy import column\n\nmetadata_obj = MetaData(naming_convention={\"ck\": \"ck_%(table_name)s_%(column_0_name)s\"})\n\nfoo = Table(\n    \"foo\", metadata_obj, Column(\"value\", Integer), CheckConstraint(column(\"value\") > 5)\n)\n```", "```py\nCREATE  TABLE  foo  (\n  value  INTEGER,\n  CONSTRAINT  ck_foo_value  CHECK  (value  >  5)\n)\n```", "```py\nTable(\"foo\", metadata_obj, Column(\"flag\", Boolean(name=\"ck_foo_flag\")))\n```", "```py\nmetadata_obj = MetaData(\n    naming_convention={\"ck\": \"ck_%(table_name)s_%(constraint_name)s\"}\n)\n\nTable(\"foo\", metadata_obj, Column(\"flag\", Boolean(name=\"flag_bool\")))\n```", "```py\nCREATE  TABLE  foo  (\n  flag  BOOL,\n  CONSTRAINT  ck_foo_flag_bool  CHECK  (flag  IN  (0,  1))\n)\n```", "```py\nmetadata_obj = MetaData(naming_convention={\"ck\": \"ck_%(table_name)s_%(column_0_name)s\"})\n\nTable(\"foo\", metadata_obj, Column(\"flag\", Boolean()))\n```", "```py\nCREATE  TABLE  foo  (\n  flag  BOOL,\n  CONSTRAINT  ck_foo_flag  CHECK  (flag  IN  (0,  1))\n)\n```", "```py\nclass sqlalchemy.schema.Constraint\n```", "```py\nmethod __init__(name: _ConstraintNameArgument = None, deferrable: bool | None = None, initially: str | None = None, info: _InfoType | None = None, comment: str | None = None, _create_rule: Any | None = None, _type_bound: bool = False, **dialect_kw: Any) \u2192 None\n```", "```py\nclassmethod argument_for(dialect_name, argument_name, default)\n```", "```py\nIndex.argument_for(\"mydialect\", \"length\", None)\n\nsome_index = Index('a', 'b', mydialect_length=5)\n```", "```py\nmethod copy(**kw: Any) \u2192 Self\n```", "```py\nmethod ddl_if(dialect: str | None = None, callable_: DDLIfCallable | None = None, state: Any | None = None) \u2192 Self\n```", "```py\nattribute dialect_kwargs\n```", "```py\nattribute dialect_options\n```", "```py\narg = my_object.dialect_options['postgresql']['where']\n```", "```py\nattribute info\n```", "```py\nattribute kwargs\n```", "```py\nclass sqlalchemy.schema.ColumnCollectionMixin\n```", "```py\nclass sqlalchemy.schema.ColumnCollectionConstraint\n```", "```py\nmethod __init__(*columns: _DDLColumnArgument, name: _ConstraintNameArgument = None, deferrable: bool | None = None, initially: str | None = None, info: _InfoType | None = None, _autoattach: bool = True, _column_flag: bool = False, _gather_expressions: List[_DDLColumnArgument] | None = None, **dialect_kw: Any) \u2192 None\n```", "```py\nclassmethod argument_for(dialect_name, argument_name, default)\n```", "```py\nIndex.argument_for(\"mydialect\", \"length\", None)\n\nsome_index = Index('a', 'b', mydialect_length=5)\n```", "```py\nattribute columns: ReadOnlyColumnCollection[str, Column[Any]]\n```", "```py\nmethod contains_column(col: Column[Any]) \u2192 bool\n```", "```py\nmethod copy(*, target_table: Table | None = None, **kw: Any) \u2192 ColumnCollectionConstraint\n```", "```py\nmethod ddl_if(dialect: str | None = None, callable_: DDLIfCallable | None = None, state: Any | None = None) \u2192 Self\n```", "```py\nattribute dialect_kwargs\n```", "```py\nattribute dialect_options\n```", "```py\narg = my_object.dialect_options['postgresql']['where']\n```", "```py\nattribute info\n```", "```py\nattribute kwargs\n```", "```py\nclass sqlalchemy.schema.CheckConstraint\n```", "```py\nmethod __init__(sqltext: _TextCoercedExpressionArgument[Any], name: _ConstraintNameArgument = None, deferrable: bool | None = None, initially: str | None = None, table: Table | None = None, info: _InfoType | None = None, _create_rule: Any | None = None, _autoattach: bool = True, _type_bound: bool = False, **dialect_kw: Any) \u2192 None\n```", "```py\n    CheckConstraint(r\"foo ~ E'a(?\\:b|c)d\")\n    ```", "```py\nclassmethod argument_for(dialect_name, argument_name, default)\n```", "```py\nIndex.argument_for(\"mydialect\", \"length\", None)\n\nsome_index = Index('a', 'b', mydialect_length=5)\n```", "```py\nattribute columns: ReadOnlyColumnCollection[str, Column[Any]]\n```", "```py\nmethod contains_column(col: Column[Any]) \u2192 bool\n```", "```py\nmethod copy(*, target_table: Table | None = None, **kw: Any) \u2192 CheckConstraint\n```", "```py\nmethod ddl_if(dialect: str | None = None, callable_: DDLIfCallable | None = None, state: Any | None = None) \u2192 Self\n```", "```py\nattribute dialect_kwargs\n```", "```py\nattribute dialect_options\n```", "```py\narg = my_object.dialect_options['postgresql']['where']\n```", "```py\nattribute info\n```", "```py\nattribute kwargs\n```", "```py\nclass sqlalchemy.schema.ForeignKey\n```", "```py\nt = Table(\"remote_table\", metadata,\n    Column(\"remote_id\", ForeignKey(\"main_table.id\"))\n)\n```", "```py\nmethod __init__(column: _DDLColumnArgument, _constraint: ForeignKeyConstraint | None = None, use_alter: bool = False, name: _ConstraintNameArgument = None, onupdate: str | None = None, ondelete: str | None = None, deferrable: bool | None = None, initially: str | None = None, link_to_name: bool = False, match: str | None = None, info: _InfoType | None = None, comment: str | None = None, _unresolvable: bool = False, **dialect_kw: Any)\n```", "```py\nclassmethod argument_for(dialect_name, argument_name, default)\n```", "```py\nIndex.argument_for(\"mydialect\", \"length\", None)\n\nsome_index = Index('a', 'b', mydialect_length=5)\n```", "```py\nattribute column\n```", "```py\nmethod copy(*, schema: str | None = None, **kw: Any) \u2192 ForeignKey\n```", "```py\nattribute dialect_kwargs\n```", "```py\nattribute dialect_options\n```", "```py\narg = my_object.dialect_options['postgresql']['where']\n```", "```py\nmethod get_referent(table: FromClause) \u2192 Column[Any] | None\n```", "```py\nattribute info\n```", "```py\nattribute kwargs\n```", "```py\nmethod references(table: Table) \u2192 bool\n```", "```py\nattribute target_fullname\n```", "```py\nclass sqlalchemy.schema.ForeignKeyConstraint\n```", "```py\nmethod __init__(columns: _typing_Sequence[_DDLColumnArgument], refcolumns: _typing_Sequence[_DDLColumnArgument], name: _ConstraintNameArgument = None, onupdate: str | None = None, ondelete: str | None = None, deferrable: bool | None = None, initially: str | None = None, use_alter: bool = False, link_to_name: bool = False, match: str | None = None, table: Table | None = None, info: _InfoType | None = None, comment: str | None = None, **dialect_kw: Any) \u2192 None\n```", "```py\nclassmethod argument_for(dialect_name, argument_name, default)\n```", "```py\nIndex.argument_for(\"mydialect\", \"length\", None)\n\nsome_index = Index('a', 'b', mydialect_length=5)\n```", "```py\nattribute column_keys\n```", "```py\nattribute columns: ReadOnlyColumnCollection[str, Column[Any]]\n```", "```py\nmethod contains_column(col: Column[Any]) \u2192 bool\n```", "```py\nmethod copy(*, schema: str | None = None, target_table: Table | None = None, **kw: Any) \u2192 ForeignKeyConstraint\n```", "```py\nmethod ddl_if(dialect: str | None = None, callable_: DDLIfCallable | None = None, state: Any | None = None) \u2192 Self\n```", "```py\nattribute dialect_kwargs\n```", "```py\nattribute dialect_options\n```", "```py\narg = my_object.dialect_options['postgresql']['where']\n```", "```py\nattribute elements: List[ForeignKey]\n```", "```py\nattribute info\n```", "```py\nattribute kwargs\n```", "```py\nattribute referred_table\n```", "```py\nclass sqlalchemy.schema.HasConditionalDDL\n```", "```py\nmethod ddl_if(dialect: str | None = None, callable_: DDLIfCallable | None = None, state: Any | None = None) \u2192 Self\n```", "```py\nclass sqlalchemy.schema.PrimaryKeyConstraint\n```", "```py\n>>> my_table = Table('mytable', metadata,\n...                 Column('id', Integer, primary_key=True),\n...                 Column('version_id', Integer, primary_key=True),\n...                 Column('data', String(50))\n...     )\n>>> my_table.primary_key\nPrimaryKeyConstraint(\n Column('id', Integer(), table=<mytable>,\n primary_key=True, nullable=False),\n Column('version_id', Integer(), table=<mytable>,\n primary_key=True, nullable=False)\n)\n```", "```py\nmy_table = Table('mytable', metadata,\n            Column('id', Integer),\n            Column('version_id', Integer),\n            Column('data', String(50)),\n            PrimaryKeyConstraint('id', 'version_id',\n                                 name='mytable_pk')\n        )\n```", "```py\nmy_table = Table('mytable', metadata,\n            Column('id', Integer, primary_key=True),\n            Column('version_id', Integer, primary_key=True),\n            Column('data', String(50)),\n            PrimaryKeyConstraint(name='mytable_pk',\n                                 mssql_clustered=True)\n        )\n```", "```py\nclassmethod argument_for(dialect_name, argument_name, default)\n```", "```py\nIndex.argument_for(\"mydialect\", \"length\", None)\n\nsome_index = Index('a', 'b', mydialect_length=5)\n```", "```py\nattribute columns: ReadOnlyColumnCollection[str, Column[Any]]\n```", "```py\nmethod contains_column(col: Column[Any]) \u2192 bool\n```", "```py\nmethod copy(*, target_table: Table | None = None, **kw: Any) \u2192 ColumnCollectionConstraint\n```", "```py\nmethod ddl_if(dialect: str | None = None, callable_: DDLIfCallable | None = None, state: Any | None = None) \u2192 Self\n```", "```py\nattribute dialect_kwargs\n```", "```py\nattribute dialect_options\n```", "```py\narg = my_object.dialect_options['postgresql']['where']\n```", "```py\nattribute info\n```", "```py\nattribute kwargs\n```", "```py\nclass sqlalchemy.schema.UniqueConstraint\n```", "```py\nmethod __init__(*columns: _DDLColumnArgument, name: _ConstraintNameArgument = None, deferrable: bool | None = None, initially: str | None = None, info: _InfoType | None = None, _autoattach: bool = True, _column_flag: bool = False, _gather_expressions: List[_DDLColumnArgument] | None = None, **dialect_kw: Any) \u2192 None\n```", "```py\nclassmethod argument_for(dialect_name, argument_name, default)\n```", "```py\nIndex.argument_for(\"mydialect\", \"length\", None)\n\nsome_index = Index('a', 'b', mydialect_length=5)\n```", "```py\nattribute columns: ReadOnlyColumnCollection[str, Column[Any]]\n```", "```py\nmethod contains_column(col: Column[Any]) \u2192 bool\n```", "```py\nmethod copy(*, target_table: Table | None = None, **kw: Any) \u2192 ColumnCollectionConstraint\n```", "```py\nmethod ddl_if(dialect: str | None = None, callable_: DDLIfCallable | None = None, state: Any | None = None) \u2192 Self\n```", "```py\nattribute dialect_kwargs\n```", "```py\nattribute dialect_options\n```", "```py\narg = my_object.dialect_options['postgresql']['where']\n```", "```py\nattribute info\n```", "```py\nattribute kwargs\n```", "```py\nfunction sqlalchemy.schema.conv(value: str, quote: bool | None = None) \u2192 Any\n```", "```py\nm = MetaData(naming_convention={\n    \"ck\": \"ck_%(table_name)s_%(constraint_name)s\"\n})\nt = Table('t', m, Column('x', Integer),\n                CheckConstraint('x > 5', name='x5'))\n```", "```py\nm = MetaData(naming_convention={\n    \"ck\": \"ck_%(table_name)s_%(constraint_name)s\"\n})\nt = Table('t', m, Column('x', Integer),\n                CheckConstraint('x > 5', name=conv('ck_t_x5')))\n```", "```py\nmetadata_obj = MetaData()\nmytable = Table(\n    \"mytable\",\n    metadata_obj,\n    # an indexed column, with index \"ix_mytable_col1\"\n    Column(\"col1\", Integer, index=True),\n    # a uniquely indexed column with index \"ix_mytable_col2\"\n    Column(\"col2\", Integer, index=True, unique=True),\n    Column(\"col3\", Integer),\n    Column(\"col4\", Integer),\n    Column(\"col5\", Integer),\n    Column(\"col6\", Integer),\n)\n\n# place an index on col3, col4\nIndex(\"idx_col34\", mytable.c.col3, mytable.c.col4)\n\n# place a unique index on col5, col6\nIndex(\"myindex\", mytable.c.col5, mytable.c.col6, unique=True)\n\nmytable.create(engine)\nCREATE  TABLE  mytable  (\n  col1  INTEGER,\n  col2  INTEGER,\n  col3  INTEGER,\n  col4  INTEGER,\n  col5  INTEGER,\n  col6  INTEGER\n)\nCREATE  INDEX  ix_mytable_col1  ON  mytable  (col1)\nCREATE  UNIQUE  INDEX  ix_mytable_col2  ON  mytable  (col2)\nCREATE  UNIQUE  INDEX  myindex  ON  mytable  (col5,  col6)\nCREATE  INDEX  idx_col34  ON  mytable  (col3,  col4) \n```", "```py\nmetadata_obj = MetaData()\nmytable = Table(\n    \"mytable\",\n    metadata_obj,\n    Column(\"col1\", Integer),\n    Column(\"col2\", Integer),\n    Column(\"col3\", Integer),\n    Column(\"col4\", Integer),\n    # place an index on col1, col2\n    Index(\"idx_col12\", \"col1\", \"col2\"),\n    # place a unique index on col3, col4\n    Index(\"idx_col34\", \"col3\", \"col4\", unique=True),\n)\n```", "```py\ni = Index(\"someindex\", mytable.c.col5)\ni.create(engine)\nCREATE  INDEX  someindex  ON  mytable  (col5) \n```", "```py\nfrom sqlalchemy import Index\n\nIndex(\"someindex\", mytable.c.somecol.desc())\n```", "```py\nfrom sqlalchemy import func, Index\n\nIndex(\"someindex\", func.lower(mytable.c.somecol))\n```", "```py\nfrom sqlalchemy import Index\n\nIndex(\"someindex\", mytable.c.somecol.desc())\n```", "```py\nfrom sqlalchemy import func, Index\n\nIndex(\"someindex\", func.lower(mytable.c.somecol))\n```", "```py\nclass sqlalchemy.schema.Index\n```", "```py\nsometable = Table(\"sometable\", metadata,\n                Column(\"name\", String(50)),\n                Column(\"address\", String(100))\n            )\n\nIndex(\"some_index\", sometable.c.name)\n```", "```py\nsometable = Table(\"sometable\", metadata,\n                Column(\"name\", String(50), index=True)\n            )\n```", "```py\nIndex(\"some_index\", sometable.c.name, sometable.c.address)\n```", "```py\nIndex(\"some_index\", func.lower(sometable.c.name))\n```", "```py\nTable(\"sometable\", metadata,\n                Column(\"name\", String(50)),\n                Column(\"address\", String(100)),\n                Index(\"some_index\", \"name\", \"address\")\n        )\n```", "```py\nfrom sqlalchemy import text\n\nTable(\"sometable\", metadata,\n                Column(\"name\", String(50)),\n                Column(\"address\", String(100)),\n                Index(\"some_index\", text(\"lower(name)\"))\n        )\n```", "```py\nmethod __init__(name: str | None, *expressions: _DDLColumnArgument, unique: bool = False, quote: bool | None = None, info: _InfoType | None = None, _table: Table | None = None, _column_flag: bool = False, **dialect_kw: Any) \u2192 None\n```", "```py\nclassmethod argument_for(dialect_name, argument_name, default)\n```", "```py\nIndex.argument_for(\"mydialect\", \"length\", None)\n\nsome_index = Index('a', 'b', mydialect_length=5)\n```", "```py\nmethod create(bind: _CreateDropBind, checkfirst: bool = False) \u2192 None\n```", "```py\nmethod ddl_if(dialect: str | None = None, callable_: DDLIfCallable | None = None, state: Any | None = None) \u2192 Self\n```", "```py\nattribute dialect_kwargs\n```", "```py\nattribute dialect_options\n```", "```py\narg = my_object.dialect_options['postgresql']['where']\n```", "```py\nmethod drop(bind: _CreateDropBind, checkfirst: bool = False) \u2192 None\n```", "```py\nattribute info\n```", "```py\nattribute kwargs\n```"]