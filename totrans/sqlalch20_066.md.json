["```py\nfrom sqlalchemy.ext import baked\n\nbakery = baked.bakery()\n```", "```py\nfrom sqlalchemy import bindparam\n\ndef search_for_user(session, username, email=None):\n    baked_query = bakery(lambda session: session.query(User))\n    baked_query += lambda q: q.filter(User.name == bindparam(\"username\"))\n\n    baked_query += lambda q: q.order_by(User.id)\n\n    if email:\n        baked_query += lambda q: q.filter(User.email == bindparam(\"email\"))\n\n    result = baked_query(session).params(username=username, email=email).all()\n\n    return result\n```", "```py\nsession = Session(bind=engine)\nfor id_ in random.sample(ids, n):\n    session.query(Customer).filter(Customer.id == id_).one()\n```", "```py\nbakery = baked.bakery()\ns = Session(bind=engine)\nfor id_ in random.sample(ids, n):\n    q = bakery(lambda s: s.query(Customer))\n    q += lambda q: q.filter(Customer.id == bindparam(\"id\"))\n    q(s).params(id=id_).one()\n```", "```py\ntest_baked_query : test a baked query of the full entity.\n                   (10000 iterations); total fn calls 1951294\n\ntest_orm_query :   test a straight ORM query of the full entity.\n                   (10000 iterations); total fn calls 7900535\n```", "```py\ntest_baked_query : test a baked query of the full entity.\n                   (10000 iterations); total time 2.174126 sec\n\ntest_orm_query :   test a straight ORM query of the full entity.\n                   (10000 iterations); total time 7.958516 sec\n```", "```py\nmy_simple_cache = {}\n\ndef lookup(session, id_argument):\n    if \"my_key\" not in my_simple_cache:\n        query = session.query(Model).filter(Model.id == bindparam(\"id\"))\n        my_simple_cache[\"my_key\"] = query.with_session(None)\n    else:\n        query = my_simple_cache[\"my_key\"].with_session(session)\n\n    return query.params(id=id_argument).all()\n```", "```py\nmy_simple_cache = {}\n\ndef lookup(session, id_argument):\n    if \"my_key\" not in my_simple_cache:\n        query = session.query(Model).filter(Model.id == bindparam(\"id\"))\n        my_simple_cache[\"my_key\"] = query.with_session(None).bake()\n    else:\n        query = my_simple_cache[\"my_key\"].with_session(session)\n\n    return query.params(id=id_argument).all()\n```", "```py\nbakery = baked.bakery()\n\ndef lookup(session, id_argument):\n    def create_model_query(session):\n        return session.query(Model).filter(Model.id == bindparam(\"id\"))\n\n    parameterized_query = bakery.bake(create_model_query)\n    return parameterized_query(session).params(id=id_argument).all()\n```", "```py\nmy_simple_cache = {}\n\ndef lookup(session, id_argument, include_frobnizzle=False):\n    if include_frobnizzle:\n        cache_key = \"my_key_with_frobnizzle\"\n    else:\n        cache_key = \"my_key_without_frobnizzle\"\n\n    if cache_key not in my_simple_cache:\n        query = session.query(Model).filter(Model.id == bindparam(\"id\"))\n        if include_frobnizzle:\n            query = query.filter(Model.frobnizzle == True)\n\n        my_simple_cache[cache_key] = query.with_session(None).bake()\n    else:\n        query = my_simple_cache[cache_key].with_session(session)\n\n    return query.params(id=id_argument).all()\n```", "```py\nbakery = baked.bakery()\n\ndef lookup(session, id_argument, include_frobnizzle=False):\n    def create_model_query(session):\n        return session.query(Model).filter(Model.id == bindparam(\"id\"))\n\n    parameterized_query = bakery.bake(create_model_query)\n\n    if include_frobnizzle:\n\n        def include_frobnizzle_in_query(query):\n            return query.filter(Model.frobnizzle == True)\n\n        parameterized_query = parameterized_query.with_criteria(\n            include_frobnizzle_in_query\n        )\n\n    return parameterized_query(session).params(id=id_argument).all()\n```", "```py\nbakery = baked.bakery()\n\ndef lookup(session, id_argument, include_frobnizzle=False):\n    parameterized_query = bakery.bake(\n        lambda s: s.query(Model).filter(Model.id == bindparam(\"id\"))\n    )\n\n    if include_frobnizzle:\n        parameterized_query += lambda q: q.filter(Model.frobnizzle == True)\n\n    return parameterized_query(session).params(id=id_argument).all()\n```", "```py\nbakery = baked.bakery()\n\nbaked_query = bakery(lambda session: session.query(User))\nbaked_query += lambda q: q.filter(User.name.in_(bindparam(\"username\", expanding=True)))\n\nresult = baked_query.with_session(session).params(username=[\"ed\", \"fred\"]).all()\n```", "```py\nbakery = baked.bakery()\n\n# a baked query that will end up being used as a subquery\nmy_subq = bakery(lambda s: s.query(User.id))\nmy_subq += lambda q: q.filter(User.id == Address.user_id)\n\n# select a correlated subquery in the top columns list,\n# we have the \"session\" argument, pass that\nmy_q = bakery(lambda s: s.query(Address.id, my_subq.to_query(s).as_scalar()))\n\n# use a correlated subquery in some of the criteria, we have\n# the \"query\" argument, pass that.\nmy_q += lambda q: q.filter(my_subq.to_query(q).exists())\n```", "```py\n@event.listens_for(Query, \"before_compile\", retval=True, bake_ok=True)\ndef my_event(query):\n    for desc in query.column_descriptions:\n        if desc[\"type\"] is User:\n            entity = desc[\"entity\"]\n            query = query.filter(entity.deleted == False)\n    return query\n```", "```py\nsession = Session(engine, enable_baked_queries=False)\n```", "```py\nfunction sqlalchemy.ext.baked.bakery(size=200, _size_alert=None)\n```", "```py\nclass sqlalchemy.ext.baked.BakedQuery\n```", "```py\nmethod add_criteria(fn, *args)\n```", "```py\nclassmethod bakery(size=200, _size_alert=None)\n```", "```py\nmethod for_session(session)\n```", "```py\nmethod spoil(full=False)\n```", "```py\nmethod to_query(query_or_session)\n```", "```py\nsub_bq = self.bakery(lambda s: s.query(User.name))\nsub_bq += lambda q: q.filter(\n    User.id == Address.user_id).correlate(Address)\n\nmain_bq = self.bakery(lambda s: s.query(Address))\nmain_bq += lambda q: q.filter(\n    sub_bq.to_query(q).exists())\n```", "```py\nsub_bq = self.bakery(lambda s: s.query(User.name))\nsub_bq += lambda q: q.filter(\n    User.id == Address.user_id).correlate(Address)\n\nmain_bq = self.bakery(\n    lambda s: s.query(\n    Address.id, sub_bq.to_query(q).scalar_subquery())\n)\n```", "```py\nmethod with_criteria(fn, *args)\n```", "```py\nclass sqlalchemy.ext.baked.Bakery\n```", "```py\nclass sqlalchemy.ext.baked.Result\n```", "```py\nmethod all()\n```", "```py\nmethod count()\n```", "```py\nmethod first()\n```", "```py\nmethod get(ident)\n```", "```py\nmethod one()\n```", "```py\nmethod one_or_none()\n```", "```py\nmethod params(*args, **kw)\n```", "```py\nmethod scalar()\n```", "```py\nmethod with_post_criteria(fn)\n```", "```py\nfrom sqlalchemy.ext import baked\n\nbakery = baked.bakery()\n```", "```py\nfrom sqlalchemy import bindparam\n\ndef search_for_user(session, username, email=None):\n    baked_query = bakery(lambda session: session.query(User))\n    baked_query += lambda q: q.filter(User.name == bindparam(\"username\"))\n\n    baked_query += lambda q: q.order_by(User.id)\n\n    if email:\n        baked_query += lambda q: q.filter(User.email == bindparam(\"email\"))\n\n    result = baked_query(session).params(username=username, email=email).all()\n\n    return result\n```", "```py\nsession = Session(bind=engine)\nfor id_ in random.sample(ids, n):\n    session.query(Customer).filter(Customer.id == id_).one()\n```", "```py\nbakery = baked.bakery()\ns = Session(bind=engine)\nfor id_ in random.sample(ids, n):\n    q = bakery(lambda s: s.query(Customer))\n    q += lambda q: q.filter(Customer.id == bindparam(\"id\"))\n    q(s).params(id=id_).one()\n```", "```py\ntest_baked_query : test a baked query of the full entity.\n                   (10000 iterations); total fn calls 1951294\n\ntest_orm_query :   test a straight ORM query of the full entity.\n                   (10000 iterations); total fn calls 7900535\n```", "```py\ntest_baked_query : test a baked query of the full entity.\n                   (10000 iterations); total time 2.174126 sec\n\ntest_orm_query :   test a straight ORM query of the full entity.\n                   (10000 iterations); total time 7.958516 sec\n```", "```py\nmy_simple_cache = {}\n\ndef lookup(session, id_argument):\n    if \"my_key\" not in my_simple_cache:\n        query = session.query(Model).filter(Model.id == bindparam(\"id\"))\n        my_simple_cache[\"my_key\"] = query.with_session(None)\n    else:\n        query = my_simple_cache[\"my_key\"].with_session(session)\n\n    return query.params(id=id_argument).all()\n```", "```py\nmy_simple_cache = {}\n\ndef lookup(session, id_argument):\n    if \"my_key\" not in my_simple_cache:\n        query = session.query(Model).filter(Model.id == bindparam(\"id\"))\n        my_simple_cache[\"my_key\"] = query.with_session(None).bake()\n    else:\n        query = my_simple_cache[\"my_key\"].with_session(session)\n\n    return query.params(id=id_argument).all()\n```", "```py\nbakery = baked.bakery()\n\ndef lookup(session, id_argument):\n    def create_model_query(session):\n        return session.query(Model).filter(Model.id == bindparam(\"id\"))\n\n    parameterized_query = bakery.bake(create_model_query)\n    return parameterized_query(session).params(id=id_argument).all()\n```", "```py\nmy_simple_cache = {}\n\ndef lookup(session, id_argument, include_frobnizzle=False):\n    if include_frobnizzle:\n        cache_key = \"my_key_with_frobnizzle\"\n    else:\n        cache_key = \"my_key_without_frobnizzle\"\n\n    if cache_key not in my_simple_cache:\n        query = session.query(Model).filter(Model.id == bindparam(\"id\"))\n        if include_frobnizzle:\n            query = query.filter(Model.frobnizzle == True)\n\n        my_simple_cache[cache_key] = query.with_session(None).bake()\n    else:\n        query = my_simple_cache[cache_key].with_session(session)\n\n    return query.params(id=id_argument).all()\n```", "```py\nbakery = baked.bakery()\n\ndef lookup(session, id_argument, include_frobnizzle=False):\n    def create_model_query(session):\n        return session.query(Model).filter(Model.id == bindparam(\"id\"))\n\n    parameterized_query = bakery.bake(create_model_query)\n\n    if include_frobnizzle:\n\n        def include_frobnizzle_in_query(query):\n            return query.filter(Model.frobnizzle == True)\n\n        parameterized_query = parameterized_query.with_criteria(\n            include_frobnizzle_in_query\n        )\n\n    return parameterized_query(session).params(id=id_argument).all()\n```", "```py\nbakery = baked.bakery()\n\ndef lookup(session, id_argument, include_frobnizzle=False):\n    parameterized_query = bakery.bake(\n        lambda s: s.query(Model).filter(Model.id == bindparam(\"id\"))\n    )\n\n    if include_frobnizzle:\n        parameterized_query += lambda q: q.filter(Model.frobnizzle == True)\n\n    return parameterized_query(session).params(id=id_argument).all()\n```", "```py\nbakery = baked.bakery()\n\nbaked_query = bakery(lambda session: session.query(User))\nbaked_query += lambda q: q.filter(User.name.in_(bindparam(\"username\", expanding=True)))\n\nresult = baked_query.with_session(session).params(username=[\"ed\", \"fred\"]).all()\n```", "```py\nbakery = baked.bakery()\n\n# a baked query that will end up being used as a subquery\nmy_subq = bakery(lambda s: s.query(User.id))\nmy_subq += lambda q: q.filter(User.id == Address.user_id)\n\n# select a correlated subquery in the top columns list,\n# we have the \"session\" argument, pass that\nmy_q = bakery(lambda s: s.query(Address.id, my_subq.to_query(s).as_scalar()))\n\n# use a correlated subquery in some of the criteria, we have\n# the \"query\" argument, pass that.\nmy_q += lambda q: q.filter(my_subq.to_query(q).exists())\n```", "```py\n@event.listens_for(Query, \"before_compile\", retval=True, bake_ok=True)\ndef my_event(query):\n    for desc in query.column_descriptions:\n        if desc[\"type\"] is User:\n            entity = desc[\"entity\"]\n            query = query.filter(entity.deleted == False)\n    return query\n```", "```py\nbakery = baked.bakery()\n\nbaked_query = bakery(lambda session: session.query(User))\nbaked_query += lambda q: q.filter(User.name.in_(bindparam(\"username\", expanding=True)))\n\nresult = baked_query.with_session(session).params(username=[\"ed\", \"fred\"]).all()\n```", "```py\nbakery = baked.bakery()\n\n# a baked query that will end up being used as a subquery\nmy_subq = bakery(lambda s: s.query(User.id))\nmy_subq += lambda q: q.filter(User.id == Address.user_id)\n\n# select a correlated subquery in the top columns list,\n# we have the \"session\" argument, pass that\nmy_q = bakery(lambda s: s.query(Address.id, my_subq.to_query(s).as_scalar()))\n\n# use a correlated subquery in some of the criteria, we have\n# the \"query\" argument, pass that.\nmy_q += lambda q: q.filter(my_subq.to_query(q).exists())\n```", "```py\n@event.listens_for(Query, \"before_compile\", retval=True, bake_ok=True)\ndef my_event(query):\n    for desc in query.column_descriptions:\n        if desc[\"type\"] is User:\n            entity = desc[\"entity\"]\n            query = query.filter(entity.deleted == False)\n    return query\n```", "```py\nsession = Session(engine, enable_baked_queries=False)\n```", "```py\nfunction sqlalchemy.ext.baked.bakery(size=200, _size_alert=None)\n```", "```py\nclass sqlalchemy.ext.baked.BakedQuery\n```", "```py\nmethod add_criteria(fn, *args)\n```", "```py\nclassmethod bakery(size=200, _size_alert=None)\n```", "```py\nmethod for_session(session)\n```", "```py\nmethod spoil(full=False)\n```", "```py\nmethod to_query(query_or_session)\n```", "```py\nsub_bq = self.bakery(lambda s: s.query(User.name))\nsub_bq += lambda q: q.filter(\n    User.id == Address.user_id).correlate(Address)\n\nmain_bq = self.bakery(lambda s: s.query(Address))\nmain_bq += lambda q: q.filter(\n    sub_bq.to_query(q).exists())\n```", "```py\nsub_bq = self.bakery(lambda s: s.query(User.name))\nsub_bq += lambda q: q.filter(\n    User.id == Address.user_id).correlate(Address)\n\nmain_bq = self.bakery(\n    lambda s: s.query(\n    Address.id, sub_bq.to_query(q).scalar_subquery())\n)\n```", "```py\nmethod with_criteria(fn, *args)\n```", "```py\nclass sqlalchemy.ext.baked.Bakery\n```", "```py\nclass sqlalchemy.ext.baked.Result\n```", "```py\nmethod all()\n```", "```py\nmethod count()\n```", "```py\nmethod first()\n```", "```py\nmethod get(ident)\n```", "```py\nmethod one()\n```", "```py\nmethod one_or_none()\n```", "```py\nmethod params(*args, **kw)\n```", "```py\nmethod scalar()\n```", "```py\nmethod with_post_criteria(fn)\n```"]