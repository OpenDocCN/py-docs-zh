- en: Pixmap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://pymupdf.readthedocs.io/en/latest/pixmap.html](https://pymupdf.readthedocs.io/en/latest/pixmap.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Pixmaps (“pixel maps”) are objects at the heart of MuPDF’s rendering capabilities.
    They represent plane rectangular sets of pixels. Each pixel is described by a
    number of bytes (“components”) defining its color, plus an optional alpha byte
    defining its transparency.
  prefs: []
  type: TYPE_NORMAL
- en: In PyMuPDF, there exist several ways to create a pixmap. Except the first one,
    all of them are available as overloaded constructors. A pixmap can be created
    …
  prefs: []
  type: TYPE_NORMAL
- en: from a document page (method [`Page.get_pixmap()`](page.html#Page.get_pixmap
    "Page.get_pixmap"))
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: empty, based on [Colorspace](colorspace.html#colorspace) and [IRect](irect.html#irect)
    information
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: from a file
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: from an in-memory image
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: from a memory area of plain pixels
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: from an image inside a PDF document
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: as a copy of another pixmap
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: A number of image formats is supported as input for points 3\. and 4\. above.
    See section [Supported Input Image Formats](#imagefiles).
  prefs: []
  type: TYPE_NORMAL
- en: Have a look at the [FAQ](faq.html#faq) section to see some pixmap usage “at
    work”.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Method / Attribute** | **Short Description** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| [`Pixmap.clear_with()`](#Pixmap.clear_with "Pixmap.clear_with") | clear parts
    of the pixmap |'
  prefs: []
  type: TYPE_TB
- en: '| [`Pixmap.color_count()`](#Pixmap.color_count "Pixmap.color_count") | determine
    used colors |'
  prefs: []
  type: TYPE_TB
- en: '| [`Pixmap.color_topusage()`](#Pixmap.color_topusage "Pixmap.color_topusage")
    | determine share of most used color |'
  prefs: []
  type: TYPE_TB
- en: '| [`Pixmap.copy()`](#Pixmap.copy "Pixmap.copy") | copy parts of another pixmap
    |'
  prefs: []
  type: TYPE_TB
- en: '| [`Pixmap.gamma_with()`](#Pixmap.gamma_with "Pixmap.gamma_with") | apply a
    gamma factor to the pixmap |'
  prefs: []
  type: TYPE_TB
- en: '| [`Pixmap.invert_irect()`](#Pixmap.invert_irect "Pixmap.invert_irect") | invert
    the pixels of a given area |'
  prefs: []
  type: TYPE_TB
- en: '| [`Pixmap.pdfocr_save()`](#Pixmap.pdfocr_save "Pixmap.pdfocr_save") | save
    the pixmap as an OCRed 1-page PDF |'
  prefs: []
  type: TYPE_TB
- en: '| [`Pixmap.pdfocr_tobytes()`](#Pixmap.pdfocr_tobytes "Pixmap.pdfocr_tobytes")
    | save the pixmap as an OCRed 1-page PDF |'
  prefs: []
  type: TYPE_TB
- en: '| [`Pixmap.pil_save()`](#Pixmap.pil_save "Pixmap.pil_save") | save as image
    using pillow |'
  prefs: []
  type: TYPE_TB
- en: '| [`Pixmap.pil_tobytes()`](#Pixmap.pil_tobytes "Pixmap.pil_tobytes") | write
    to `bytes` object using pillow |'
  prefs: []
  type: TYPE_TB
- en: '| [`Pixmap.pixel()`](#Pixmap.pixel "Pixmap.pixel") | return the value of a
    pixel |'
  prefs: []
  type: TYPE_TB
- en: '| [`Pixmap.save()`](#Pixmap.save "Pixmap.save") | save the pixmap in a variety
    of formats |'
  prefs: []
  type: TYPE_TB
- en: '| [`Pixmap.set_alpha()`](#Pixmap.set_alpha "Pixmap.set_alpha") | set alpha
    values |'
  prefs: []
  type: TYPE_TB
- en: '| [`Pixmap.set_dpi()`](#Pixmap.set_dpi "Pixmap.set_dpi") | set the image resolution
    |'
  prefs: []
  type: TYPE_TB
- en: '| [`Pixmap.set_origin()`](#Pixmap.set_origin "Pixmap.set_origin") | set pixmap
    x,y values |'
  prefs: []
  type: TYPE_TB
- en: '| [`Pixmap.set_pixel()`](#Pixmap.set_pixel "Pixmap.set_pixel") | set color
    and alpha of a pixel |'
  prefs: []
  type: TYPE_TB
- en: '| [`Pixmap.set_rect()`](#Pixmap.set_rect "Pixmap.set_rect") | set color and
    alpha of all pixels in a rectangle |'
  prefs: []
  type: TYPE_TB
- en: '| [`Pixmap.shrink()`](#Pixmap.shrink "Pixmap.shrink") | reduce size keeping
    proportions |'
  prefs: []
  type: TYPE_TB
- en: '| [`Pixmap.tint_with()`](#Pixmap.tint_with "Pixmap.tint_with") | tint the pixmap
    |'
  prefs: []
  type: TYPE_TB
- en: '| [`Pixmap.tobytes()`](#Pixmap.tobytes "Pixmap.tobytes") | return a memory
    area in a variety of formats |'
  prefs: []
  type: TYPE_TB
- en: '| [`Pixmap.warp()`](#Pixmap.warp "Pixmap.warp") | return a pixmap made from
    a quad inside |'
  prefs: []
  type: TYPE_TB
- en: '| [`Pixmap.alpha`](#Pixmap.alpha "Pixmap.alpha") | transparency indicator |'
  prefs: []
  type: TYPE_TB
- en: '| [`Pixmap.colorspace`](#Pixmap.colorspace "Pixmap.colorspace") | pixmap’s
    [Colorspace](colorspace.html#colorspace) |'
  prefs: []
  type: TYPE_TB
- en: '| [`Pixmap.digest`](#Pixmap.digest "Pixmap.digest") | MD5 hashcode of the pixmap
    |'
  prefs: []
  type: TYPE_TB
- en: '| [`Pixmap.height`](#Pixmap.height "Pixmap.height") | pixmap height |'
  prefs: []
  type: TYPE_TB
- en: '| [`Pixmap.interpolate`](#Pixmap.interpolate "Pixmap.interpolate") | interpolation
    method indicator |'
  prefs: []
  type: TYPE_TB
- en: '| [`Pixmap.is_monochrome`](#Pixmap.is_monochrome "Pixmap.is_monochrome") |
    check if only black and white occur |'
  prefs: []
  type: TYPE_TB
- en: '| [`Pixmap.is_unicolor`](#Pixmap.is_unicolor "Pixmap.is_unicolor") | check
    if only one color occurs |'
  prefs: []
  type: TYPE_TB
- en: '| [`Pixmap.irect`](#Pixmap.irect "Pixmap.irect") | [IRect](irect.html#irect)
    of the pixmap |'
  prefs: []
  type: TYPE_TB
- en: '| [`Pixmap.n`](#Pixmap.n "Pixmap.n") | bytes per pixel |'
  prefs: []
  type: TYPE_TB
- en: '| [`Pixmap.samples_mv`](#Pixmap.samples_mv "Pixmap.samples_mv") | `memoryview`
    of pixel area |'
  prefs: []
  type: TYPE_TB
- en: '| [`Pixmap.samples_ptr`](#Pixmap.samples_ptr "Pixmap.samples_ptr") | Python
    pointer to pixel area |'
  prefs: []
  type: TYPE_TB
- en: '| [`Pixmap.samples`](#Pixmap.samples "Pixmap.samples") | `bytes` copy of pixel
    area |'
  prefs: []
  type: TYPE_TB
- en: '| [`Pixmap.size`](#Pixmap.size "Pixmap.size") | pixmap’s total length |'
  prefs: []
  type: TYPE_TB
- en: '| [`Pixmap.stride`](#Pixmap.stride "Pixmap.stride") | size of one image row
    |'
  prefs: []
  type: TYPE_TB
- en: '| [`Pixmap.width`](#Pixmap.width "Pixmap.width") | pixmap width |'
  prefs: []
  type: TYPE_TB
- en: '| [`Pixmap.x`](#Pixmap.x "Pixmap.x") | X-coordinate of top-left corner |'
  prefs: []
  type: TYPE_TB
- en: '| [`Pixmap.xres`](#Pixmap.xres "Pixmap.xres") | resolution in X-direction |'
  prefs: []
  type: TYPE_TB
- en: '| [`Pixmap.y`](#Pixmap.y "Pixmap.y") | Y-coordinate of top-left corner |'
  prefs: []
  type: TYPE_TB
- en: '| [`Pixmap.yres`](#Pixmap.yres "Pixmap.yres") | resolution in Y-direction |'
  prefs: []
  type: TYPE_TB
- en: '**Class API**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '**New empty pixmap:** Create an empty pixmap of size and origin given by the
    rectangle. So, *irect.top_left* designates the top left corner of the pixmap,
    and its width and height are *irect.width* resp. *irect.height*. Note that the
    image area is **not initialized** and will contain crap data – use eg. [`clear_with()`](#Pixmap.clear_with
    "Pixmap.clear_with") or [`set_rect()`](#Pixmap.set_rect "Pixmap.set_rect") to
    be sure.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**colorspace** ([Colorspace](colorspace.html#colorspace)) – colorspace.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**irect** (*irect_like*) – The pixmap’s position and dimension.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**alpha** (*bool*) – Specifies whether transparency bytes should be included.
    Default is *False*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '**Copy and set colorspace:** Copy *source* pixmap converting colorspace. Any
    colorspace combination is possible, but source colorspace must not be *None*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**colorspace** ([Colorspace](colorspace.html#colorspace)) – desired **target**
    colorspace. This **may also be** *None*. In this case, a “masking” pixmap is created:
    its [`Pixmap.samples`](#Pixmap.samples "Pixmap.samples") will consist of the source’s
    alpha bytes only.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**source** (*Pixmap*) – the source pixmap.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: New in v1.18.18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Copy and add image mask:** Copy *source* pixmap, add an alpha channel with
    transparency data from a mask pixmap.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**source** ([Pixmap](#pixmap)) – pixmap without alpha channel.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**mask** ([Pixmap](#pixmap)) – a mask pixmap. Must be a graysale pixmap.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '**Copy and scale:** Copy *source* pixmap, scaling new width and height values
    – the image will appear stretched or shrunk accordingly. Supports partial copying.
    The source colorspace may be *None*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**source** (*Pixmap*) – the source pixmap.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**width** (*float*) – desired target width.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**height** (*float*) – desired target height.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**clip** (*irect_like*) – restrict the resulting pixmap to this region of the
    **scaled** pixmap.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If width or height do not *represent* integers (i.e. `value.is_integer() !=
    True`), then the resulting pixmap **will have an alpha channel**.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '**Copy and add or drop alpha:** Copy *source* and add or drop its alpha channel.
    Identical copy if *alpha* equals *source.alpha*. If an alpha channel is added,
    its values will be set to 255.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**source** (*Pixmap*) – source pixmap.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**alpha** (*bool*) – whether the target will have an alpha channel, default
    and mandatory if source colorspace is *None*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical use includes separation of color and transparency bytes in separate
    pixmaps. Some applications require this like e.g. *wx.Bitmap.FromBufferAndAlpha()*
    of *wxPython*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '**From a file:** Create a pixmap from *filename*. All properties are inferred
    from the input. The origin of the resulting pixmap is *(0, 0)*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**filename** (*str*) – Path of the image file.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '**From memory:** Create a pixmap from a memory area. All properties are inferred
    from the input. The origin of the resulting pixmap is *(0, 0)*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**stream** (*bytes**,**bytearray**,**BytesIO*) –'
  prefs: []
  type: TYPE_NORMAL
- en: Data containing a complete, valid image. Could have been created by e.g. *stream
    = bytearray(open(‘image.file’, ‘rb’).read())*. Type *bytes* is supported in **Python
    3 only**, because *bytes == str* in Python 2 and the method will interpret the
    stream as a filename.
  prefs: []
  type: TYPE_NORMAL
- en: '*Changed in version 1.14.13:* *io.BytesIO* is now also supported.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '**From plain pixels:** Create a pixmap from *samples*. Each pixel must be represented
    by a number of bytes as controlled by the *colorspace* and *alpha* parameters.
    The origin of the resulting pixmap is *(0, 0)*. This method is useful when raw
    image data are provided by some other program – see [FAQ](faq.html#faq).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**colorspace** ([Colorspace](colorspace.html#colorspace)) – Colorspace of image.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**width** (*int*) – image width'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**height** (*int*) – image height'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**samples** (*bytes**,**bytearray**,**BytesIO*) –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: an area containing all pixels of the image. Must include alpha values if specified.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Changed in version 1.14.13:* (1) *io.BytesIO* can now also be used. (2) Data
    are now **copied** to the pixmap, so may safely be deleted or become unavailable.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**alpha** (*bool*) – whether a transparency channel is included.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The following equation **must be true**: *(colorspace.n + alpha) * width *
    height == len(samples)*.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Starting with version 1.14.13, the samples data are **copied** to the pixmap.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '**From a PDF image:** Create a pixmap from an image **contained in PDF** *doc*
    identified by its [`xref`](glossary.html#xref "xref"). All pimap properties are
    set by the image. Have a look at [extract-img1.py](https://github.com/pymupdf/PyMuPDF/tree/master/demo/extract-img1.py)
    and [extract-img2.py](https://github.com/pymupdf/PyMuPDF/tree/master/demo/extract-img2.py)
    to see how this can be used to recover all of a PDF’s images.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**doc** ([Document](document.html#document)) – an opened **PDF** document.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**xref** (*int*) – the [`xref`](glossary.html#xref "xref") of an image object.
    For example, you can make a list of images used on a particular page with [`Document.get_page_images()`](document.html#Document.get_page_images
    "Document.get_page_images"), which also shows the [`xref`](glossary.html#xref
    "xref") numbers of each image.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Initialize the samples area.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**value** (*int*) – if specified, values from 0 to 255 are valid. Each color
    byte of each pixel will be set to this value, while alpha will be set to 255 (non-transparent)
    if present. If omitted, then all bytes (including any alpha) are cleared to *0x00*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**irect** (*irect_like*) – the area to be cleared. Omit to clear the whole
    pixmap. Can only be specified, if *value* is also specified.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Colorize a pixmap by replacing black and / or white with colors given as **sRGB
    integer** values. Only colorspaces [`CS_GRAY`](vars.html#CS_GRAY "CS_GRAY") and
    [`CS_RGB`](vars.html#CS_RGB "CS_RGB") are supported, others are ignored with a
    warning.
  prefs: []
  type: TYPE_NORMAL
- en: If the colorspace is [`CS_GRAY`](vars.html#CS_GRAY "CS_GRAY"), the average *(red
    + green + blue)/3* will be taken. The pixmap will be changed in place.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**black** (*int*) – replace black with this value. Specifying 0x000000 makes
    no changes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**white** (*int*) – replace white with this value. Specifying 0xFFFFFF makes
    no changes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '`tint_with(0x000000, 0xFFFFFF)` is a no-op.'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`tint_with(0x00FF00, 0xFFFFFF)` changes black to green, leaves white intact.'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  - PREF_IND
  type: TYPE_NORMAL
- en: '`tint_with(0xFF0000, 0x0000FF)` changes black to red and white to blue.'
  prefs:
  - PREF_BQ
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Apply a gamma factor to a pixmap, i.e. lighten or darken it. Pixmaps with colorspace
    *None* are ignored with a warning.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**gamma** (*float*) – *gamma = 1.0* does nothing, *gamma < 1.0* lightens, *gamma
    > 1.0* darkens the image.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Shrink the pixmap by dividing both, its width and height by 2:sup:`n`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**n** (*int*) – determines the new pixmap (samples) size. For example, a value
    of 2 divides width and height by 4 and thus results in a size of one 16^(th) of
    the original. Values less than 1 are ignored with a warning.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Use this methods to reduce a pixmap’s size retaining its proportion. The pixmap
    is changed “in place”. If you want to keep original and also have more granular
    choices, use the resp. copy constructor above.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '*New in version:: 1.14.5:* Return the value of the pixel at location (x, y)
    (column, line).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**x** (*int*) – the column number of the pixel. Must be in `range(pix.width)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**y** (*int*) – the line number of the pixel, Must be in `range(pix.height)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Return type:'
  prefs: []
  type: TYPE_NORMAL
- en: list
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: a list of color values and, potentially the alpha value. Its length and content
    depend on the pixmap’s colorspace and the presence of an alpha. For RGBA pixmaps
    the result would e.g. be *[r, g, b, a]*. All items are integers in `range(256)`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '*New in version 1.14.7:* Manipulate the pixel at location (x, y) (column, line).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**x** (*int*) – the column number of the pixel. Must be in `range(pix.width)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**y** (*int*) – the line number of the pixel. Must be in `range(pix.height)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**color** (*sequence*) – the desired pixel value given as a sequence of integers
    in `range(256)`. The length of the sequence must equal [`Pixmap.n`](#Pixmap.n
    "Pixmap.n"), which includes any alpha byte.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '*New in version 1.14.8:* Set the pixels of a rectangle to a value.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**irect** (*irect_like*) – the rectangle to be filled with the value. The actual
    area is the intersection of this parameter and [`Pixmap.irect`](#Pixmap.irect
    "Pixmap.irect"). For an empty intersection (or an invalid parameter), no change
    will happen.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**color** (*sequence*) – the desired value, given as a sequence of integers
    in `range(256)`. The length of the sequence must equal [`Pixmap.n`](#Pixmap.n
    "Pixmap.n"), which includes any alpha byte.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Return type:'
  prefs: []
  type: TYPE_NORMAL
- en: bool
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: '*False* if the rectangle was invalid or had an empty intersection with [`Pixmap.irect`](#Pixmap.irect
    "Pixmap.irect"), else *True*.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This method is equivalent to [`Pixmap.set_pixel()`](#Pixmap.set_pixel "Pixmap.set_pixel")
    executed for each pixel in the rectangle, but is obviously **very much faster**
    if many pixels are involved.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This method can be used similar to [`Pixmap.clear_with()`](#Pixmap.clear_with
    "Pixmap.clear_with") to initialize a pixmap with a certain color like this: *pix.set_rect(pix.irect,
    (255, 255, 0))* (RGB example, colors the complete pixmap with yellow).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: New in v1.17.7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set the x and y values of the pixmap’s top-left point.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**x** (*int*) – x coordinate'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**y** (*int*) – y coordinate'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: New in v1.16.17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Changed in v1.18.0: When saving as a PNG image, these values will be stored
    now.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set the resolution (dpi) in x and y direction.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**xres** (*int*) – resolution in x direction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**yres** (*int*) – resolution in y direction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Changed in v 1.18.13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Change the alpha values. The pixmap must have an alpha channel.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**alphavalues** (*bytes**,**bytearray**,**BytesIO*) – the new alpha values.
    If provided, its length must be at least *width * height*. If omitted (`None`),
    all alpha values are set to 255 (no transparency). *Changed in version 1.14.13:*
    *io.BytesIO* is now also accepted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**premultiply** (*bool*) – *New in v1.18.13:* whether to premultiply color
    components with the alpha value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**opaque** (*list**,**tuple*) – ignore the alpha value and set this color to
    fully transparent. A sequence of integers in `range(256)` with a length of [`Pixmap.n`](#Pixmap.n
    "Pixmap.n"). Default is *None*. For example, a typical choice for RGB would be
    `opaque=(255, 255, 255)` (white).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Invert the color of all pixels in [IRect](irect.html#irect) *irect*. Will have
    no effect if colorspace is *None*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**irect** (*irect_like*) – The area to be inverted. Omit to invert everything.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Copy the *irect* part of the *source* pixmap into the corresponding area of
    this one. The two pixmaps may have different dimensions and can each have [`CS_GRAY`](vars.html#CS_GRAY
    "CS_GRAY") or [`CS_RGB`](vars.html#CS_RGB "CS_RGB") colorspaces, but they currently
    **must** have the same alpha property [[2]](#f2). The copy mechanism automatically
    adjusts discrepancies between source and target like so:'
  prefs: []
  type: TYPE_NORMAL
- en: If copying from [`CS_GRAY`](vars.html#CS_GRAY "CS_GRAY") to [`CS_RGB`](vars.html#CS_RGB
    "CS_RGB"), the source gray-shade value will be put into each of the three rgb
    component bytes. If the other way round, *(r + g + b) / 3* will be taken as the
    gray-shade value of the target.
  prefs: []
  type: TYPE_NORMAL
- en: Between *irect* and the target pixmap’s rectangle, an “intersection” is calculated
    at first. This takes into account the rectangle coordinates and the current attribute
    values [`Pixmap.x`](#Pixmap.x "Pixmap.x") and [`Pixmap.y`](#Pixmap.y "Pixmap.y")
    (which you are free to modify for this purpose via [`Pixmap.set_origin()`](#Pixmap.set_origin
    "Pixmap.set_origin")). Then the corresponding data of this intersection are copied.
    If the intersection is empty, nothing will happen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**source** ([Pixmap](#pixmap)) – source pixmap.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**irect** (*irect_like*) – The area to be copied.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Example: Suppose you have two pixmaps, `pix1` and `pix2` and you want to copy
    the lower right quarter of `pix2` to `pix1` such that it starts at the top-left
    point of `pix1`. Use the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[![_images/img-pixmapcopy.jpg](../Images/320db08e8f18c0a5ba863ee171f2b2bd.png)](_images/img-pixmapcopy.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Changed in v1.22.0: Added **direct support of JPEG** images. Image quality
    can be controlled via parameter “jpg_quality”.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Save pixmap as an image file. Depending on the output chosen, only some or all
    colorspaces are supported and different file extensions can be chosen. Please
    see the table below.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**filename** (*str**,**Path**,**file*) – The file to save to. May be provided
    as a string, as a `pathlib.Path` or as a Python file object. In the latter two
    cases, the filename is taken from the resp. object. The filename’s extension determines
    the image format, which can be overruled by the output parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**output** (*str*) – The desired image format. The default is the filename’s
    extension. If both, this value and the file extension are unsupported, an exception
    is raised. For possible values see [Supported Output Image Formats](#pixmapoutput).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**jpg_quality** (*int*) – The desired image quality, default 95\. Only applies
    to JPEG images, else ignored. This parameter trades quality against file size.
    A value of 98 is close to lossless. Higher values should not lead to better quality.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Raises:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ValueError** – For unsupported image formats.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'New in version 1.14.5: Return the pixmap as a *bytes* memory object of the
    specified format – similar to [`save()`](#Pixmap.save "Pixmap.save").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Changed in v1.22.0: Added **direct JPEG support**. Image quality can be influenced
    via new parameter “jpg_quality”.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**output** (*str*) – The desired image format. The default is “png”. For possible
    values see [Supported Output Image Formats](#pixmapoutput).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**jpg_quality** (*int*) – The desired image quality, default 95\. Only applies
    to JPEG images, else ignored. This parameter trades quality against file size.
    A value of 98 is close to lossless. Higher values should not lead to better quality.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**output** – The requested image format. The default is “png”. For other possible
    values see [Supported Output Image Formats](#pixmapoutput).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Raises:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ValueError** – For unsupported image formats.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Return type:'
  prefs: []
  type: TYPE_NORMAL
- en: bytes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: New in v1.19.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Changed in v1.22.5: Support of new parameter for Tesseract’s tessdata.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Perform text recognition using Tesseract and save the image as a 1-page PDF
    with an OCR text layer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**filename** (*str**,**fp*) – identifies the file to save to. May be either
    a string or a pointer to a file opened with “wb” (includes `io.BytesIO()` objects).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**compress** (*bool*) – whether to compress the resulting PDF, default is `True`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**language** (*str*) – the languages occurring in the image. This must be specified
    in Tesseract format. Default is “eng” for English. Use “+”-separated Tesseract
    language codes for multiple languages, like “eng+spa” for English and Spanish.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**tessdata** (*str*) – folder name of Tesseract’s language support. If omitted,
    this information must be present as environment variable [`TESSDATA_PREFIX`](functions.html#TESSDATA_PREFIX
    "TESSDATA_PREFIX").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '**Will fail** if Tesseract is not installed or if the environment variable
    “TESSDATA_PREFIX” is not set to the `tessdata` folder name and not provided as
    parameter.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: New in v1.19.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Changed in v1.22.5: Support of new parameter for Tesseract’s tessdata.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Perform text recognition using Tesseract and convert the image to a 1-page PDF
    with an OCR text layer. Internally invokes [`Pixmap.pdfocr_save()`](#Pixmap.pdfocr_save
    "Pixmap.pdfocr_save").
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: A 1-page PDF file in memory. Could be opened like `doc=pymupdf.open("pdf", pix.pdfocr_tobytes())`,
    and text extractions could be performed on its `page=doc[0]`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Another possible use is insertion into some pdf. The following snippet reads
    the images of a folder and stores them as pages in a new PDF that contain an OCR
    text layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: New in v1.17.3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write the pixmap as an image file using Pillow. Use this method for output unsupported
    by MuPDF. Examples are
  prefs: []
  type: TYPE_NORMAL
- en: Formats JPX, J2K, WebP, etc.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing EXIF information.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you do not provide dpi information, the values *xres*, *yres* stored with
    the pixmap are automatically used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A simple example: `pix.pil_save("some.webp", optimize=True, dpi=(150, 150))`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**unmultiply** (*bool*) – If the pixmap’s colorspace is RGB with transparency,
    the alpha values may or may not already be multiplied into the color components
    ref/green/blue (called “premultiplied”). To enforce undoing premultiplication,
    set this parameter to `True`. To learn about some background, e.g. look for “Premultiplied
    alpha” [here](https://en.wikipedia.org/wiki/Glossary_of_computer_graphics#P).'
  prefs: []
  type: TYPE_NORMAL
- en: For details on other parameters see the Pillow documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Since v1.22.0, PyMuPDF supports JPEG output directly. We recommended to no longer
    use this method for JPEG output – for performance reasons and for avoiding unnecessary
    external dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Raises:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ImportError** – if Pillow is not installed.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: New in v1.17.3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Return an image as a bytes object in the specified format using Pillow. For
    example `stream = pix.pil_tobytes(format="WEBP", optimize=True, dpi=(150, 150))`.
    Also see above. For details on other parameters see the Pillow documentation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Raises:'
  prefs: []
  type: TYPE_NORMAL
- en: '**ImportError** – if Pillow is not installed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Return type:'
  prefs: []
  type: TYPE_NORMAL
- en: bytes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: New in v1.19.3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Return a new pixmap by “warping” the quad such that the quad corners become
    the new pixmap’s corners. The target pixmap’s [IRect](irect.html) will be `(0,
    0, width, height)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**quad** (*quad_like*) – a convex quad with coordinates inside [`Pixmap.irect`](#Pixmap.irect
    "Pixmap.irect") (including the border points).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**width** (*int*) – desired resulting width.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**height** (*int*) – desired resulting height.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A new pixmap where the quad corners are mapped to the pixmap corners in a clockwise
    fashion: `quad.ul -> irect.tl`, `quad.ur -> irect.tr`, etc.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Return type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Pixmap](#pixmap)'
  prefs: []
  type: TYPE_NORMAL
- en: '[![_images/img-warp.png](../Images/153b2284232ec54e56424c176d17a43e.png)](_images/img-warp.png)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: New in v1.19.2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changed in v1.19.3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Determine the pixmap’s unique colors and their count.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**colors** (*bool*) – *(changed in v1.19.3)* If `True` return a dictionary
    of color pixels and their usage count, else just the number of unique colors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**clip** (*rect_like*) – a rectangle inside [`Pixmap.irect`](#Pixmap.irect
    "Pixmap.irect"). If provided, only those pixels are considered. This allows inspecting
    sub-rectangles of a given pixmap directly – instead of building sub-pixmaps.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Return type:'
  prefs: []
  type: TYPE_NORMAL
- en: dict or int
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: 'either the number of colors, or a dictionary with the items `pixel: count`.
    The pixel key is a `bytes` object of length [`Pixmap.n`](#Pixmap.n "Pixmap.n").'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To recover the **tuple** of a pixel, use `tuple(colors.keys()[i])` for the i-th
    item.
  prefs: []
  type: TYPE_NORMAL
- en: The response time depends on the pixmap’s samples size and may be more than
    a second for very large pixmaps.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Where applicable, pixels with different alpha values will be treated as different
    colors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: New in v1.19.3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Return the most frequently used color and its relative frequency.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**clip** (*rect_like*) – A rectangle inside [`Pixmap.irect`](#Pixmap.irect
    "Pixmap.irect"). If provided, only those pixels are considered. This allows inspecting
    sub-rectangles of a given pixmap directly – instead of building sub-pixmaps.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Return type:'
  prefs: []
  type: TYPE_NORMAL
- en: tuple
  prefs: []
  type: TYPE_NORMAL
- en: 'Returns:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A tuple `(ratio, pixel)` where `0 < ratio <= 1` and *pixel* is the pixel value
    of the color. Use this to decide if the image is “almost” unicolor: a response
    `(0.95, b"x00x00x00")` means that 95% of all pixels are black. See an example
    here [How to Use Pixmaps: Checking Text Visibility](recipes-images.html#recipesimages-p).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Indicates whether the pixmap contains transparency information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Type:'
  prefs: []
  type: TYPE_NORMAL
- en: bool
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The MD5 hashcode (16 bytes) of the pixmap. This is a technical value used for
    unique identifications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Type:'
  prefs: []
  type: TYPE_NORMAL
- en: bytes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The colorspace of the pixmap. This value may be *None* if the image is to be
    treated as a so-called *image mask* or *stencil mask* (currently happens for extracted
    PDF document images only).
  prefs: []
  type: TYPE_NORMAL
- en: 'Type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[Colorspace](colorspace.html#colorspace)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Contains the length of one row of image data in [`Pixmap.samples`](#Pixmap.samples
    "Pixmap.samples"). This is primarily used for calculation purposes. The following
    expressions are true:'
  prefs: []
  type: TYPE_NORMAL
- en: '`len(samples) == height * stride`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`width * n == stride`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Type:'
  prefs: []
  type: TYPE_NORMAL
- en: int
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: New in v1.19.2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is `True` for a gray pixmap which only has the colors black and white.
  prefs: []
  type: TYPE_NORMAL
- en: 'Type:'
  prefs: []
  type: TYPE_NORMAL
- en: bool
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: New in v1.19.2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is `True` if all pixels are identical (any colorspace). Where applicable, pixels
    with different alpha values will be treated as different colors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Type:'
  prefs: []
  type: TYPE_NORMAL
- en: bool
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Contains the [IRect](irect.html#irect) of the pixmap.
  prefs: []
  type: TYPE_NORMAL
- en: 'Type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[IRect](irect.html#irect)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The color and (if [`Pixmap.alpha`](#Pixmap.alpha "Pixmap.alpha") is true) transparency
    values for all pixels. It is an area of `width * height * n` bytes. Each n bytes
    define one pixel. Each successive n bytes yield another pixel in scanline order.
    Subsequent scanlines follow each other with no padding. E.g. for an RGBA colorspace
    this means, *samples* is a sequence of bytes like *…, R, G, B, A, …*, and the
    four byte values R, G, B, A define one pixel.
  prefs: []
  type: TYPE_NORMAL
- en: This area can be passed to other graphics libraries like PIL (Python Imaging
    Library) to do additional processing like saving the pixmap in other image formats.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The underlying data is typically a **large** memory area, from which a `bytes`
    copy is made for this attribute … each time you access it: for example an RGB-rendered
    letter page has a samples size of almost 1.4 MB. So consider assigning a new variable
    to it or use the `memoryview` version [`Pixmap.samples_mv`](#Pixmap.samples_mv
    "Pixmap.samples_mv") (new in v1.18.17).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any changes to the underlying data are available only after accessing this attribute
    again. This is different from using the memoryview version.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Type:'
  prefs: []
  type: TYPE_NORMAL
- en: bytes
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: New in v1.18.17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Like [`Pixmap.samples`](#Pixmap.samples "Pixmap.samples"), but in Python `memoryview`
    format. It is built pointing to the memory in the pixmap – not from a copy of
    it. So its creation speed is independent from the pixmap size, and any changes
    to pixels will be available immediately.
  prefs: []
  type: TYPE_NORMAL
- en: Copies like `bytearray(pix.samples_mv)`, or `bytes(pixmap.samples_mv)` are equivalent
    to and can be used in place of `pix.samples`.
  prefs: []
  type: TYPE_NORMAL
- en: We also have `len(pix.samples) == len(pix.samples_mv)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at this example from a 2 MB JPEG: the memoryview is **ten thousand times
    faster**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Type:'
  prefs: []
  type: TYPE_NORMAL
- en: memoryview
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: New in v1.18.17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Python pointer to the pixel area. This is a special integer format, which can
    be used by supporting applications (such as PyQt) to directly address the samples
    area and thus build their images extremely fast. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Both of the above lead to the same Qt image, but (2) can be **many hundred times
    faster**, because it avoids an additional copy of the pixel area.
  prefs: []
  type: TYPE_NORMAL
- en: 'Type:'
  prefs: []
  type: TYPE_NORMAL
- en: int
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Contains *len(pixmap)*. This will generally equal *len(pix.samples)* plus some
    platform-specific value for defining other attributes of the object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Type:'
  prefs: []
  type: TYPE_NORMAL
- en: int
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Width of the region in pixels.
  prefs: []
  type: TYPE_NORMAL
- en: 'Type:'
  prefs: []
  type: TYPE_NORMAL
- en: int
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Height of the region in pixels.
  prefs: []
  type: TYPE_NORMAL
- en: 'Type:'
  prefs: []
  type: TYPE_NORMAL
- en: int
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: X-coordinate of top-left corner in pixels. Cannot directly be changed – use
    [`Pixmap.set_origin()`](#Pixmap.set_origin "Pixmap.set_origin").
  prefs: []
  type: TYPE_NORMAL
- en: 'Type:'
  prefs: []
  type: TYPE_NORMAL
- en: int
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Y-coordinate of top-left corner in pixels. Cannot directly be changed – use
    [`Pixmap.set_origin()`](#Pixmap.set_origin "Pixmap.set_origin").
  prefs: []
  type: TYPE_NORMAL
- en: 'Type:'
  prefs: []
  type: TYPE_NORMAL
- en: int
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Number of components per pixel. This number depends on colorspace and alpha.
    If colorspace is not *None* (stencil masks), then *Pixmap.n - Pixmap.alpha ==
    pixmap.colorspace.n* is true. If colorspace is *None*, then *n == alpha == 1*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Type:'
  prefs: []
  type: TYPE_NORMAL
- en: int
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Horizontal resolution in dpi (dots per inch). Please also see [`resolution`](glossary.html#resolution
    "resolution"). Cannot directly be changed – use [`Pixmap.set_dpi()`](#Pixmap.set_dpi
    "Pixmap.set_dpi").
  prefs: []
  type: TYPE_NORMAL
- en: 'Type:'
  prefs: []
  type: TYPE_NORMAL
- en: int
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Vertical resolution in dpi (dots per inch). Please also see [`resolution`](glossary.html#resolution
    "resolution"). Cannot directly be changed – use [`Pixmap.set_dpi()`](#Pixmap.set_dpi
    "Pixmap.set_dpi").
  prefs: []
  type: TYPE_NORMAL
- en: 'Type:'
  prefs: []
  type: TYPE_NORMAL
- en: int
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: An information-only boolean flag set to *True* if the image will be drawn using
    “linear interpolation”. If *False* “nearest neighbour sampling” will be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Type:'
  prefs: []
  type: TYPE_NORMAL
- en: bool
  prefs: []
  type: TYPE_NORMAL
- en: '## Supported Input Image Formats'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following file types are supported as **input** to construct pixmaps: **BMP,
    JPEG, GIF, TIFF, JXR, JPX**, **PNG**, **PAM** and all of the **Portable Anymap**
    family (**PBM, PGM, PNM, PPM**). This support is two-fold:'
  prefs: []
  type: TYPE_NORMAL
- en: Directly create a pixmap with *Pixmap(filename)* or *Pixmap(byterray)*. The
    pixmap will then have properties as determined by the image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open such files with *pymupdf.open(…)*. The result will then appear as a document
    containing one single page. Creating a pixmap of this page offers all the options
    available in this context: apply a matrix, choose colorspace and alpha, confine
    the pixmap to a clip area, etc.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**SVG images** are only supported via method 2 above, not directly as pixmaps.
    But remember: the result of this is a **raster image** as is always the case with
    pixmaps [[1]](#f1).  ## Supported Output Image Formats'
  prefs: []
  type: TYPE_NORMAL
- en: A number of image **output** formats are supported. You have the option to either
    write an image directly to a file ([`Pixmap.save()`](#Pixmap.save "Pixmap.save")),
    or to generate a bytes object ([`Pixmap.tobytes()`](#Pixmap.tobytes "Pixmap.tobytes")).
    Both methods accept a string identifying the desired format (**Format** column
    below). Please note that not all combinations of pixmap colorspace, transparency
    support (alpha) and image format are possible.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Format** | **Colorspaces** | **alpha** | **Extensions** | **Description**
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| jpg, jpeg | gray, rgb, cmyk | no | .jpg, .jpeg | Joint Photographic Experts
    Group |'
  prefs: []
  type: TYPE_TB
- en: '| pam | gray, rgb, cmyk | yes | .pam | Portable Arbitrary Map |'
  prefs: []
  type: TYPE_TB
- en: '| pbm | gray, rgb | no | .pbm | Portable Bitmap |'
  prefs: []
  type: TYPE_TB
- en: '| pgm | gray, rgb | no | .pgm | Portable Graymap |'
  prefs: []
  type: TYPE_TB
- en: '| png | gray, rgb | yes | .png | Portable Network Graphics |'
  prefs: []
  type: TYPE_TB
- en: '| pnm | gray, rgb | no | .pnm | Portable Anymap |'
  prefs: []
  type: TYPE_TB
- en: '| ppm | gray, rgb | no | .ppm | Portable Pixmap |'
  prefs: []
  type: TYPE_TB
- en: '| ps | gray, rgb, cmyk | no | .ps | Adobe PostScript Image |'
  prefs: []
  type: TYPE_TB
- en: '| psd | gray, rgb, cmyk | yes | .psd | Adobe Photoshop Document |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Not all image file types are supported (or at least common) on all OS platforms.
    E.g. PAM and the Portable Anymap formats are rare or even unknown on Windows.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Especially pertaining to CMYK colorspaces, you can always convert a CMYK pixmap
    to an RGB pixmap with *rgb_pix = pymupdf.Pixmap(pymupdf.csRGB, cmyk_pix)* and
    then save that in the desired format.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As can be seen, MuPDF’s image support range is different for input and output.
    Among those supported both ways, PNG and JPEG are probably the most popular.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We also recommend using “ppm” formats as input to tkinter’s *PhotoImage* method
    like this: *tkimg = tkinter.PhotoImage(data=pix.tobytes(“ppm”))* (also see the
    tutorial). This is **very** fast (**60 times** faster than PNG).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Footnotes
  prefs: []
  type: TYPE_NORMAL
- en: Do you have any feedback on this page?
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: This software is provided AS-IS with no warranty, either express or implied.
    This software is distributed under license and may not be copied, modified or
    distributed except as expressly authorized under the terms of that license. Refer
    to licensing information at [artifex.com](https://www.artifex.com?utm_source=rtd-pymupdf&utm_medium=rtd&utm_content=footer-link)
    or contact Artifex Software Inc., 39 Mesa Street, Suite 108A, San Francisco CA
    94129, United States for further information.
  prefs: []
  type: TYPE_NORMAL
- en: This documentation covers all versions up to 1.24.4.
  prefs: []
  type: TYPE_NORMAL
- en: '[![Discord logo](../Images/66cbb5081103a580193aa66c87b90d9a.png)](https://discord.gg/TSpYGBW4eq)
    ## Supported Input Image Formats'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following file types are supported as **input** to construct pixmaps: **BMP,
    JPEG, GIF, TIFF, JXR, JPX**, **PNG**, **PAM** and all of the **Portable Anymap**
    family (**PBM, PGM, PNM, PPM**). This support is two-fold:'
  prefs: []
  type: TYPE_NORMAL
- en: Directly create a pixmap with *Pixmap(filename)* or *Pixmap(byterray)*. The
    pixmap will then have properties as determined by the image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open such files with *pymupdf.open(…)*. The result will then appear as a document
    containing one single page. Creating a pixmap of this page offers all the options
    available in this context: apply a matrix, choose colorspace and alpha, confine
    the pixmap to a clip area, etc.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**SVG images** are only supported via method 2 above, not directly as pixmaps.
    But remember: the result of this is a **raster image** as is always the case with
    pixmaps [[1]](#f1).'
  prefs: []
  type: TYPE_NORMAL
- en: '## Supported Output Image Formats'
  prefs: []
  type: TYPE_NORMAL
- en: A number of image **output** formats are supported. You have the option to either
    write an image directly to a file ([`Pixmap.save()`](#Pixmap.save "Pixmap.save")),
    or to generate a bytes object ([`Pixmap.tobytes()`](#Pixmap.tobytes "Pixmap.tobytes")).
    Both methods accept a string identifying the desired format (**Format** column
    below). Please note that not all combinations of pixmap colorspace, transparency
    support (alpha) and image format are possible.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Format** | **Colorspaces** | **alpha** | **Extensions** | **Description**
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| jpg, jpeg | gray, rgb, cmyk | no | .jpg, .jpeg | Joint Photographic Experts
    Group |'
  prefs: []
  type: TYPE_TB
- en: '| pam | gray, rgb, cmyk | yes | .pam | Portable Arbitrary Map |'
  prefs: []
  type: TYPE_TB
- en: '| pbm | gray, rgb | no | .pbm | Portable Bitmap |'
  prefs: []
  type: TYPE_TB
- en: '| pgm | gray, rgb | no | .pgm | Portable Graymap |'
  prefs: []
  type: TYPE_TB
- en: '| png | gray, rgb | yes | .png | Portable Network Graphics |'
  prefs: []
  type: TYPE_TB
- en: '| pnm | gray, rgb | no | .pnm | Portable Anymap |'
  prefs: []
  type: TYPE_TB
- en: '| ppm | gray, rgb | no | .ppm | Portable Pixmap |'
  prefs: []
  type: TYPE_TB
- en: '| ps | gray, rgb, cmyk | no | .ps | Adobe PostScript Image |'
  prefs: []
  type: TYPE_TB
- en: '| psd | gray, rgb, cmyk | yes | .psd | Adobe Photoshop Document |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Not all image file types are supported (or at least common) on all OS platforms.
    E.g. PAM and the Portable Anymap formats are rare or even unknown on Windows.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Especially pertaining to CMYK colorspaces, you can always convert a CMYK pixmap
    to an RGB pixmap with *rgb_pix = pymupdf.Pixmap(pymupdf.csRGB, cmyk_pix)* and
    then save that in the desired format.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As can be seen, MuPDF’s image support range is different for input and output.
    Among those supported both ways, PNG and JPEG are probably the most popular.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We also recommend using “ppm” formats as input to tkinter’s *PhotoImage* method
    like this: *tkimg = tkinter.PhotoImage(data=pix.tobytes(“ppm”))* (also see the
    tutorial). This is **very** fast (**60 times** faster than PNG).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Footnotes
  prefs: []
  type: TYPE_NORMAL
- en: Do you have any feedback on this page?
  prefs: []
  type: TYPE_NORMAL
- en: '* * *'
  prefs: []
  type: TYPE_NORMAL
- en: This software is provided AS-IS with no warranty, either express or implied.
    This software is distributed under license and may not be copied, modified or
    distributed except as expressly authorized under the terms of that license. Refer
    to licensing information at [artifex.com](https://www.artifex.com?utm_source=rtd-pymupdf&utm_medium=rtd&utm_content=footer-link)
    or contact Artifex Software Inc., 39 Mesa Street, Suite 108A, San Francisco CA
    94129, United States for further information.
  prefs: []
  type: TYPE_NORMAL
- en: This documentation covers all versions up to 1.24.4.
  prefs: []
  type: TYPE_NORMAL
- en: '[![Discord logo](../Images/66cbb5081103a580193aa66c87b90d9a.png)](https://discord.gg/TSpYGBW4eq)'
  prefs: []
  type: TYPE_NORMAL
