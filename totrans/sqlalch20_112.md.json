["```py\nfrom sqlalchemy import Table, MetaData, Column, Integer\n\nm = MetaData()\nt = Table('t', m,\n        Column('id', Integer, primary_key=True),\n        Column('x', Integer))\nm.create_all(engine)\n```", "```py\nCREATE  TABLE  t  (\n  id  INTEGER  NOT  NULL  IDENTITY,\n  x  INTEGER  NULL,\n  PRIMARY  KEY  (id)\n)\n```", "```py\nm = MetaData()\nt = Table('t', m,\n        Column('id', Integer, primary_key=True, autoincrement=False),\n        Column('x', Integer))\nm.create_all(engine)\n```", "```py\nm = MetaData()\nt = Table('t', m,\n        Column('id', Integer, primary_key=True, autoincrement=False),\n        Column('x', Integer, autoincrement=True))\nm.create_all(engine)\n```", "```py\nfrom sqlalchemy import Table, Integer, Column, Identity\n\ntest = Table(\n    'test', metadata,\n    Column(\n        'id',\n        Integer,\n        primary_key=True,\n        Identity(start=100, increment=10)\n    ),\n    Column('name', String(20))\n)\n```", "```py\nCREATE  TABLE  test  (\n  id  INTEGER  NOT  NULL  IDENTITY(100,10)  PRIMARY  KEY,\n  name  VARCHAR(20)  NULL,\n  )\n```", "```py\nfrom sqlalchemy import Column\nfrom sqlalchemy import Integer\nfrom sqlalchemy import Numeric\nfrom sqlalchemy import String\nfrom sqlalchemy.ext.declarative import declarative_base\n\nBase = declarative_base()\n\nclass TestTable(Base):\n    __tablename__ = \"test\"\n    id = Column(\n        Integer().with_variant(Numeric(10, 0), \"mssql\"),\n        primary_key=True,\n        autoincrement=True,\n    )\n    name = Column(String)\n```", "```py\nfrom sqlalchemy import TypeDecorator\n\nclass NumericAsInteger(TypeDecorator):\n  '''normalize floating point return values into ints'''\n\n    impl = Numeric(10, 0, asdecimal=False)\n    cache_ok = True\n\n    def process_result_value(self, value, dialect):\n        if value is not None:\n            value = int(value)\n        return value\n\nclass TestTable(Base):\n    __tablename__ = \"test\"\n    id = Column(\n        Integer().with_variant(NumericAsInteger, \"mssql\"),\n        primary_key=True,\n        autoincrement=True,\n    )\n    name = Column(String)\n```", "```py\n    INSERT  INTO  t  (x)  OUTPUT  inserted.id  VALUES  (?)\n    ```", "```py\n        t = Table(\n            't',\n            metadata,\n            Column('id', Integer, primary_key=True),\n            Column('x', Integer),\n            implicit_returning=False\n        )\n        ```", "```py\n        INSERT  INTO  t  (x)  VALUES  (?);  select  scope_identity()\n        ```", "```py\nm = MetaData()\nt = Table('t', m, Column('id', Integer, primary_key=True),\n                Column('x', Integer))\nm.create_all(engine)\n\nwith engine.begin() as conn:\n    conn.execute(t.insert(), {'id': 1, 'x':1}, {'id':2, 'x':2})\n```", "```py\nCREATE  TABLE  t  (\n  id  INTEGER  NOT  NULL  IDENTITY(1,1),\n  x  INTEGER  NULL,\n  PRIMARY  KEY  (id)\n)\n\nCOMMIT\nSET  IDENTITY_INSERT  t  ON\nINSERT  INTO  t  (id,  x)  VALUES  (?,  ?)\n((1,  1),  (2,  2))\nSET  IDENTITY_INSERT  t  OFF\nCOMMIT\n```", "```py\n>>> from sqlalchemy import Sequence\n>>> from sqlalchemy.schema import CreateSequence\n>>> from sqlalchemy.dialects import mssql\n>>> print(CreateSequence(Sequence(\"my_seq\", start=1)).compile(dialect=mssql.dialect()))\nCREATE  SEQUENCE  my_seq  START  WITH  1 \n```", "```py\nseq = Sequence(\"my_sequence\", start=1)\n```", "```py\nmy_table = Table(\n    'my_table', metadata,\n    Column('my_data', VARCHAR(None)),\n    Column('my_n_data', NVARCHAR(None))\n)\n```", "```py\nfrom sqlalchemy import VARCHAR\nColumn('login', VARCHAR(32, collation='Latin1_General_CI_AS'))\n```", "```py\nlogin VARCHAR(32) COLLATE Latin1_General_CI_AS NULL\n```", "```py\nselect(some_table).limit(5)\n```", "```py\nSELECT TOP 5 col1, col2.. FROM table\n```", "```py\nselect(some_table).order_by(some_table.c.col3).limit(5).offset(10)\n```", "```py\nSELECT anon_1.col1, anon_1.col2 FROM (SELECT col1, col2,\nROW_NUMBER() OVER (ORDER BY col3) AS\nmssql_rn FROM table WHERE t.x = :x_1) AS\nanon_1 WHERE mssql_rn > :param_1 AND mssql_rn <= :param_2 + :param_1\n```", "```py\ne = create_engine(\"mssql+pyodbc://u:p@dsn\", supports_comments=False)\n```", "```py\nengine = create_engine(\n    \"mssql+pyodbc://scott:tiger@ms_2008\",\n    isolation_level=\"REPEATABLE READ\"\n)\n```", "```py\nconnection = engine.connect()\nconnection = connection.execution_options(\n    isolation_level=\"READ COMMITTED\"\n)\n```", "```py\nfrom sqlalchemy import create_engine\nfrom sqlalchemy import event\n\nmssql_engine = create_engine(\n    \"mssql+pyodbc://scott:tiger^5HHH@mssql2017:1433/test?driver=ODBC+Driver+17+for+SQL+Server\",\n\n    # disable default reset-on-return scheme\n    pool_reset_on_return=None,\n)\n\n@event.listens_for(mssql_engine, \"reset\")\ndef _reset_mssql(dbapi_connection, connection_record, reset_state):\n    if not reset_state.terminate_only:\n        dbapi_connection.execute(\"{call sys.sp_reset_connection}\")\n\n    # so that the DBAPI itself knows that the connection has been\n    # reset\n    dbapi_connection.rollback()\n```", "```py\nname VARCHAR(20) NULL\n```", "```py\nname VARCHAR(20)\n```", "```py\n    eng = create_engine(\"mssql+pymssql://user:pass@host/db\",\n                    deprecate_large_types=True)\n    ```", "```py\nTable(\n    \"some_table\", metadata,\n    Column(\"q\", String(50)),\n    schema=\"mydatabase.dbo\"\n)\n```", "```py\nTable(\n    \"some_table\", metadata,\n    Column(\"q\", String(50)),\n    schema=\"MyDataBase.dbo\"\n)\n```", "```py\nTable(\n    \"some_table\", metadata,\n    Column(\"q\", String(50)),\n    schema=\"[MyDataBase.dbo]\"\n)\n```", "```py\nTable(\n    \"some_table\", metadata,\n    Column(\"q\", String(50)),\n    schema=\"[MyDataBase.Period].[MyOwner.Dot]\"\n)\n```", "```py\naccount_table = Table(\n    'account', metadata,\n    Column('id', Integer, primary_key=True),\n    Column('info', String(100)),\n    schema=\"customer_schema\"\n)\n```", "```py\n>>> eng = create_engine(\"mssql+pymssql://mydsn\", legacy_schema_aliasing=True)\n>>> print(account_table.select().compile(eng))\nSELECT  account_1.id,  account_1.info\nFROM  customer_schema.account  AS  account_1 \n```", "```py\nIndex(\"my_index\", table.c.x, mssql_clustered=True)\n```", "```py\nTable('my_table', metadata,\n      Column('x', ...),\n      Column('y', ...),\n      PrimaryKeyConstraint(\"x\", \"y\", mssql_clustered=True))\n```", "```py\nCREATE TABLE my_table (x INTEGER NOT NULL, y INTEGER NOT NULL,\n                       PRIMARY KEY CLUSTERED (x, y))\n```", "```py\nTable('my_table', metadata,\n      Column('x', ...),\n      Column('y', ...),\n      PrimaryKeyConstraint(\"x\"),\n      UniqueConstraint(\"y\", mssql_clustered=True),\n      )\n```", "```py\nTable('my_table', metadata,\n      Column('x', ...),\n      Column('y', ...),\n      PrimaryKeyConstraint(\"x\", \"y\", mssql_clustered=False))\n```", "```py\nCREATE TABLE my_table (x INTEGER NOT NULL, y INTEGER NOT NULL,\n                       PRIMARY KEY NONCLUSTERED (x, y))\n```", "```py\nIndex(\"my_index\", table.c.x, mssql_columnstore=True)\n```", "```py\nidx = Index(\"my_index\", mssql_clustered=True, mssql_columnstore=True)\n# required to associate the index with the table\ntable.append_constraint(idx)\n```", "```py\nIndex(\"my_index\", table.c.x, mssql_include=['y'])\n```", "```py\nIndex(\"my_index\", table.c.x, mssql_where=table.c.x > 10)\n```", "```py\nIndex(\"my_index\", table.c.x.desc())\n```", "```py\nTable('mytable', metadata,\n    Column('id', Integer, primary_key=True),\n    # ...,\n    implicit_returning=False\n)\n```", "```py\nclass MyClass(Base):\n    # ...\n    __table_args__ = {'implicit_returning':False}\n```", "```py\nALTER DATABASE MyDatabase SET ALLOW_SNAPSHOT_ISOLATION ON\n\nALTER DATABASE MyDatabase SET READ_COMMITTED_SNAPSHOT ON\n```", "```py\nfunction sqlalchemy.dialects.mssql.try_cast(expression: _ColumnExpressionOrLiteralArgument[Any], type_: _TypeEngineArgument[_T]) \u2192 TryCast[_T]\n```", "```py\nfrom sqlalchemy import select, try_cast, Numeric\n\nstmt = select(\n    try_cast(product_table.c.unit_price, Numeric(10, 4))\n)\n```", "```py\nSELECT TRY_CAST (product_table.unit_price AS NUMERIC(10, 4))\nFROM product_table\n```", "```py\nfrom sqlalchemy.dialects.mssql import (\n    BIGINT,\n    BINARY,\n    BIT,\n    CHAR,\n    DATE,\n    DATETIME,\n    DATETIME2,\n    DATETIMEOFFSET,\n    DECIMAL,\n    DOUBLE_PRECISION,\n    FLOAT,\n    IMAGE,\n    INTEGER,\n    JSON,\n    MONEY,\n    NCHAR,\n    NTEXT,\n    NUMERIC,\n    NVARCHAR,\n    REAL,\n    SMALLDATETIME,\n    SMALLINT,\n    SMALLMONEY,\n    SQL_VARIANT,\n    TEXT,\n    TIME,\n    TIMESTAMP,\n    TINYINT,\n    UNIQUEIDENTIFIER,\n    VARBINARY,\n    VARCHAR,\n)\n```", "```py\nclass sqlalchemy.dialects.mssql.BIT\n```", "```py\nmethod __init__(create_constraint: bool = False, name: str | None = None, _create_events: bool = True, _adapted_from: SchemaType | None = None)\n```", "```py\nclass sqlalchemy.dialects.mssql.CHAR\n```", "```py\nmethod __init__(length: int | None = None, collation: str | None = None)\n```", "```py\n    >>> from sqlalchemy import cast, select, String\n    >>> print(select(cast('some string', String(collation='utf8'))))\n    SELECT  CAST(:param_1  AS  VARCHAR  COLLATE  utf8)  AS  anon_1 \n    ```", "```py\nclass sqlalchemy.dialects.mssql.DATETIME2\n```", "```py\nclass sqlalchemy.dialects.mssql.DATETIMEOFFSET\n```", "```py\nclass sqlalchemy.dialects.mssql.DOUBLE_PRECISION\n```", "```py\nclass sqlalchemy.dialects.mssql.IMAGE\n```", "```py\nmethod __init__(length: int | None = None)\n```", "```py\nclass sqlalchemy.dialects.mssql.JSON\n```", "```py\n    stmt = select(\n        data_table.c.data[\"some key\"].as_json()\n    ).where(\n        data_table.c.data[\"some key\"].as_json() == {\"sub\": \"structure\"}\n    )\n    ```", "```py\n    stmt = select(\n        data_table.c.data[\"some key\"].as_string()\n    ).where(\n        data_table.c.data[\"some key\"].as_string() == \"some string\"\n    )\n    ```", "```py\nmethod __init__(none_as_null: bool = False)\n```", "```py\nfrom sqlalchemy import null\nconn.execute(table.insert(), {\"data\": null()})\n```", "```py\nclass sqlalchemy.dialects.mssql.MONEY\n```", "```py\nclass sqlalchemy.dialects.mssql.NCHAR\n```", "```py\nmethod __init__(length: int | None = None, collation: str | None = None)\n```", "```py\n    >>> from sqlalchemy import cast, select, String\n    >>> print(select(cast('some string', String(collation='utf8'))))\n    SELECT  CAST(:param_1  AS  VARCHAR  COLLATE  utf8)  AS  anon_1 \n    ```", "```py\nclass sqlalchemy.dialects.mssql.NTEXT\n```", "```py\nmethod __init__(length: int | None = None, collation: str | None = None)\n```", "```py\n    >>> from sqlalchemy import cast, select, String\n    >>> print(select(cast('some string', String(collation='utf8'))))\n    SELECT  CAST(:param_1  AS  VARCHAR  COLLATE  utf8)  AS  anon_1 \n    ```", "```py\nclass sqlalchemy.dialects.mssql.NVARCHAR\n```", "```py\nmethod __init__(length: int | None = None, collation: str | None = None)\n```", "```py\n    >>> from sqlalchemy import cast, select, String\n    >>> print(select(cast('some string', String(collation='utf8'))))\n    SELECT  CAST(:param_1  AS  VARCHAR  COLLATE  utf8)  AS  anon_1 \n    ```", "```py\nclass sqlalchemy.dialects.mssql.REAL\n```", "```py\nclass sqlalchemy.dialects.mssql.ROWVERSION\n```", "```py\nmethod __init__(convert_int=False)\n```", "```py\nclass sqlalchemy.dialects.mssql.SMALLDATETIME\n```", "```py\nmethod __init__(timezone: bool = False)\n```", "```py\nclass sqlalchemy.dialects.mssql.SMALLMONEY\n```", "```py\nclass sqlalchemy.dialects.mssql.SQL_VARIANT\n```", "```py\nclass sqlalchemy.dialects.mssql.TEXT\n```", "```py\nmethod __init__(length: int | None = None, collation: str | None = None)\n```", "```py\n    >>> from sqlalchemy import cast, select, String\n    >>> print(select(cast('some string', String(collation='utf8'))))\n    SELECT  CAST(:param_1  AS  VARCHAR  COLLATE  utf8)  AS  anon_1 \n    ```", "```py\nclass sqlalchemy.dialects.mssql.TIME\n```", "```py\nclass sqlalchemy.dialects.mssql.TIMESTAMP\n```", "```py\nmethod __init__(convert_int=False)\n```", "```py\nclass sqlalchemy.dialects.mssql.TINYINT\n```", "```py\nclass sqlalchemy.dialects.mssql.UNIQUEIDENTIFIER\n```", "```py\nmethod __init__(as_uuid: bool = True)\n```", "```py\nclass sqlalchemy.dialects.mssql.VARBINARY\n```", "```py\nmethod __init__(length=None, filestream=False)\n```", "```py\nclass sqlalchemy.dialects.mssql.VARCHAR\n```", "```py\nmethod __init__(length: int | None = None, collation: str | None = None)\n```", "```py\n    >>> from sqlalchemy import cast, select, String\n    >>> print(select(cast('some string', String(collation='utf8'))))\n    SELECT  CAST(:param_1  AS  VARCHAR  COLLATE  utf8)  AS  anon_1 \n    ```", "```py\nclass sqlalchemy.dialects.mssql.XML\n```", "```py\nmethod __init__(length: int | None = None, collation: str | None = None)\n```", "```py\n    >>> from sqlalchemy import cast, select, String\n    >>> print(select(cast('some string', String(collation='utf8'))))\n    SELECT  CAST(:param_1  AS  VARCHAR  COLLATE  utf8)  AS  anon_1 \n    ```", "```py\nmssql+pyodbc://<username>:<password>@<dsnname>\n```", "```py\nengine = create_engine(\"mssql+pyodbc://scott:tiger@some_dsn\")\n```", "```py\nDSN=some_dsn;UID=scott;PWD=tiger\n```", "```py\nengine = create_engine(\"mssql+pyodbc://scott:tiger@myhost:port/databasename?driver=ODBC+Driver+17+for+SQL+Server\")\n```", "```py\ne = create_engine(\n    \"mssql+pyodbc://scott:tiger@mssql2017:1433/test?\"\n    \"driver=ODBC+Driver+18+for+SQL+Server&TrustServerCertificate=yes\"\n    \"&authentication=ActiveDirectoryIntegrated\"\n)\n```", "```py\nfrom sqlalchemy.engine import URL\nconnection_url = URL.create(\n    \"mssql+pyodbc\",\n    username=\"scott\",\n    password=\"tiger\",\n    host=\"mssql2017\",\n    port=1433,\n    database=\"test\",\n    query={\n        \"driver\": \"ODBC Driver 18 for SQL Server\",\n        \"TrustServerCertificate\": \"yes\",\n        \"authentication\": \"ActiveDirectoryIntegrated\",\n    },\n)\n```", "```py\nfrom sqlalchemy.engine import URL\nconnection_string = \"DRIVER={SQL Server Native Client 10.0};SERVER=dagger;DATABASE=test;UID=user;PWD=password\"\nconnection_url = URL.create(\"mssql+pyodbc\", query={\"odbc_connect\": connection_string})\n\nengine = create_engine(connection_url)\n```", "```py\nimport struct\nfrom sqlalchemy import create_engine, event\nfrom sqlalchemy.engine.url import URL\nfrom azure import identity\n\nSQL_COPT_SS_ACCESS_TOKEN = 1256  # Connection option for access tokens, as defined in msodbcsql.h\nTOKEN_URL = \"https://database.windows.net/\"  # The token URL for any Azure SQL database\n\nconnection_string = \"mssql+pyodbc://@my-server.database.windows.net/myDb?driver=ODBC+Driver+17+for+SQL+Server\"\n\nengine = create_engine(connection_string)\n\nazure_credentials = identity.DefaultAzureCredential()\n\n@event.listens_for(engine, \"do_connect\")\ndef provide_token(dialect, conn_rec, cargs, cparams):\n    # remove the \"Trusted_Connection\" parameter that SQLAlchemy adds\n    cargs[0] = cargs[0].replace(\";Trusted_Connection=Yes\", \"\")\n\n    # create token credential\n    raw_token = azure_credentials.get_token(TOKEN_URL).token.encode(\"utf-16-le\")\n    token_struct = struct.pack(f\"<I{len(raw_token)}s\", len(raw_token), raw_token)\n\n    # apply it to keyword arguments\n    cparams[\"attrs_before\"] = {SQL_COPT_SS_ACCESS_TOKEN: token_struct}\n```", "```py\nengine = create_engine(connection_url, ignore_no_transaction_on_rollback=True)\n```", "```py\nconnection_url = sa.engine.URL.create(\n    \"mssql+pyodbc\",\n    username=\"scott\",\n    password=\"tiger\",\n    host=\"dw.azure.example.com\",\n    database=\"mydb\",\n    query={\n        \"driver\": \"ODBC Driver 17 for SQL Server\",\n        \"autocommit\": \"True\",\n    },\n)\n\nengine = create_engine(connection_url).execution_options(\n    isolation_level=\"AUTOCOMMIT\"\n)\n```", "```py\nconnection_url = sa.engine.URL.create(\n    \"mssql+pyodbc\",\n    username=\"scott\",\n    password=\"tiger\",\n    host=\"mssqlserver.example.com\",\n    database=\"mydb\",\n    query={\n        \"driver\": \"ODBC Driver 18 for SQL Server\",\n        \"LongAsMax\": \"Yes\",\n    },\n)\n```", "```py\nimport pyodbc\n\npyodbc.pooling = False\n\n# don't use the engine before pooling is set to False\nengine = create_engine(\"mssql+pyodbc://user:pass@dsn\")\n```", "```py\nengine = create_engine(\n    \"mssql+pyodbc://scott:tiger@mssql2017:1433/test?driver=ODBC+Driver+17+for+SQL+Server\",\n    fast_executemany=True)\n```", "```py\nmssql+pymssql://<username>:<password>@<freetds_name>/?charset=utf8\n```", "```py\nmssql+aioodbc://<username>:<password>@<dsnname>\n```", "```py\nfrom sqlalchemy.ext.asyncio import create_async_engine\nengine = create_async_engine(\n    \"mssql+aioodbc://scott:tiger@mssql2017:1433/test?\"\n    \"driver=ODBC+Driver+18+for+SQL+Server&TrustServerCertificate=yes\"\n)\n```", "```py\nfrom sqlalchemy import Table, MetaData, Column, Integer\n\nm = MetaData()\nt = Table('t', m,\n        Column('id', Integer, primary_key=True),\n        Column('x', Integer))\nm.create_all(engine)\n```", "```py\nCREATE  TABLE  t  (\n  id  INTEGER  NOT  NULL  IDENTITY,\n  x  INTEGER  NULL,\n  PRIMARY  KEY  (id)\n)\n```", "```py\nm = MetaData()\nt = Table('t', m,\n        Column('id', Integer, primary_key=True, autoincrement=False),\n        Column('x', Integer))\nm.create_all(engine)\n```", "```py\nm = MetaData()\nt = Table('t', m,\n        Column('id', Integer, primary_key=True, autoincrement=False),\n        Column('x', Integer, autoincrement=True))\nm.create_all(engine)\n```", "```py\nfrom sqlalchemy import Table, Integer, Column, Identity\n\ntest = Table(\n    'test', metadata,\n    Column(\n        'id',\n        Integer,\n        primary_key=True,\n        Identity(start=100, increment=10)\n    ),\n    Column('name', String(20))\n)\n```", "```py\nCREATE  TABLE  test  (\n  id  INTEGER  NOT  NULL  IDENTITY(100,10)  PRIMARY  KEY,\n  name  VARCHAR(20)  NULL,\n  )\n```", "```py\nfrom sqlalchemy import Column\nfrom sqlalchemy import Integer\nfrom sqlalchemy import Numeric\nfrom sqlalchemy import String\nfrom sqlalchemy.ext.declarative import declarative_base\n\nBase = declarative_base()\n\nclass TestTable(Base):\n    __tablename__ = \"test\"\n    id = Column(\n        Integer().with_variant(Numeric(10, 0), \"mssql\"),\n        primary_key=True,\n        autoincrement=True,\n    )\n    name = Column(String)\n```", "```py\nfrom sqlalchemy import TypeDecorator\n\nclass NumericAsInteger(TypeDecorator):\n  '''normalize floating point return values into ints'''\n\n    impl = Numeric(10, 0, asdecimal=False)\n    cache_ok = True\n\n    def process_result_value(self, value, dialect):\n        if value is not None:\n            value = int(value)\n        return value\n\nclass TestTable(Base):\n    __tablename__ = \"test\"\n    id = Column(\n        Integer().with_variant(NumericAsInteger, \"mssql\"),\n        primary_key=True,\n        autoincrement=True,\n    )\n    name = Column(String)\n```", "```py\n    INSERT  INTO  t  (x)  OUTPUT  inserted.id  VALUES  (?)\n    ```", "```py\n        t = Table(\n            't',\n            metadata,\n            Column('id', Integer, primary_key=True),\n            Column('x', Integer),\n            implicit_returning=False\n        )\n        ```", "```py\n        INSERT  INTO  t  (x)  VALUES  (?);  select  scope_identity()\n        ```", "```py\nm = MetaData()\nt = Table('t', m, Column('id', Integer, primary_key=True),\n                Column('x', Integer))\nm.create_all(engine)\n\nwith engine.begin() as conn:\n    conn.execute(t.insert(), {'id': 1, 'x':1}, {'id':2, 'x':2})\n```", "```py\nCREATE  TABLE  t  (\n  id  INTEGER  NOT  NULL  IDENTITY(1,1),\n  x  INTEGER  NULL,\n  PRIMARY  KEY  (id)\n)\n\nCOMMIT\nSET  IDENTITY_INSERT  t  ON\nINSERT  INTO  t  (id,  x)  VALUES  (?,  ?)\n((1,  1),  (2,  2))\nSET  IDENTITY_INSERT  t  OFF\nCOMMIT\n```", "```py\nfrom sqlalchemy import Table, Integer, Column, Identity\n\ntest = Table(\n    'test', metadata,\n    Column(\n        'id',\n        Integer,\n        primary_key=True,\n        Identity(start=100, increment=10)\n    ),\n    Column('name', String(20))\n)\n```", "```py\nCREATE  TABLE  test  (\n  id  INTEGER  NOT  NULL  IDENTITY(100,10)  PRIMARY  KEY,\n  name  VARCHAR(20)  NULL,\n  )\n```", "```py\nfrom sqlalchemy import Column\nfrom sqlalchemy import Integer\nfrom sqlalchemy import Numeric\nfrom sqlalchemy import String\nfrom sqlalchemy.ext.declarative import declarative_base\n\nBase = declarative_base()\n\nclass TestTable(Base):\n    __tablename__ = \"test\"\n    id = Column(\n        Integer().with_variant(Numeric(10, 0), \"mssql\"),\n        primary_key=True,\n        autoincrement=True,\n    )\n    name = Column(String)\n```", "```py\nfrom sqlalchemy import TypeDecorator\n\nclass NumericAsInteger(TypeDecorator):\n  '''normalize floating point return values into ints'''\n\n    impl = Numeric(10, 0, asdecimal=False)\n    cache_ok = True\n\n    def process_result_value(self, value, dialect):\n        if value is not None:\n            value = int(value)\n        return value\n\nclass TestTable(Base):\n    __tablename__ = \"test\"\n    id = Column(\n        Integer().with_variant(NumericAsInteger, \"mssql\"),\n        primary_key=True,\n        autoincrement=True,\n    )\n    name = Column(String)\n```", "```py\n    INSERT  INTO  t  (x)  OUTPUT  inserted.id  VALUES  (?)\n    ```", "```py\n        t = Table(\n            't',\n            metadata,\n            Column('id', Integer, primary_key=True),\n            Column('x', Integer),\n            implicit_returning=False\n        )\n        ```", "```py\n        INSERT  INTO  t  (x)  VALUES  (?);  select  scope_identity()\n        ```", "```py\nm = MetaData()\nt = Table('t', m, Column('id', Integer, primary_key=True),\n                Column('x', Integer))\nm.create_all(engine)\n\nwith engine.begin() as conn:\n    conn.execute(t.insert(), {'id': 1, 'x':1}, {'id':2, 'x':2})\n```", "```py\nCREATE  TABLE  t  (\n  id  INTEGER  NOT  NULL  IDENTITY(1,1),\n  x  INTEGER  NULL,\n  PRIMARY  KEY  (id)\n)\n\nCOMMIT\nSET  IDENTITY_INSERT  t  ON\nINSERT  INTO  t  (id,  x)  VALUES  (?,  ?)\n((1,  1),  (2,  2))\nSET  IDENTITY_INSERT  t  OFF\nCOMMIT\n```", "```py\n>>> from sqlalchemy import Sequence\n>>> from sqlalchemy.schema import CreateSequence\n>>> from sqlalchemy.dialects import mssql\n>>> print(CreateSequence(Sequence(\"my_seq\", start=1)).compile(dialect=mssql.dialect()))\nCREATE  SEQUENCE  my_seq  START  WITH  1 \n```", "```py\nseq = Sequence(\"my_sequence\", start=1)\n```", "```py\nmy_table = Table(\n    'my_table', metadata,\n    Column('my_data', VARCHAR(None)),\n    Column('my_n_data', NVARCHAR(None))\n)\n```", "```py\nfrom sqlalchemy import VARCHAR\nColumn('login', VARCHAR(32, collation='Latin1_General_CI_AS'))\n```", "```py\nlogin VARCHAR(32) COLLATE Latin1_General_CI_AS NULL\n```", "```py\nselect(some_table).limit(5)\n```", "```py\nSELECT TOP 5 col1, col2.. FROM table\n```", "```py\nselect(some_table).order_by(some_table.c.col3).limit(5).offset(10)\n```", "```py\nSELECT anon_1.col1, anon_1.col2 FROM (SELECT col1, col2,\nROW_NUMBER() OVER (ORDER BY col3) AS\nmssql_rn FROM table WHERE t.x = :x_1) AS\nanon_1 WHERE mssql_rn > :param_1 AND mssql_rn <= :param_2 + :param_1\n```", "```py\ne = create_engine(\"mssql+pyodbc://u:p@dsn\", supports_comments=False)\n```", "```py\nengine = create_engine(\n    \"mssql+pyodbc://scott:tiger@ms_2008\",\n    isolation_level=\"REPEATABLE READ\"\n)\n```", "```py\nconnection = engine.connect()\nconnection = connection.execution_options(\n    isolation_level=\"READ COMMITTED\"\n)\n```", "```py\nfrom sqlalchemy import create_engine\nfrom sqlalchemy import event\n\nmssql_engine = create_engine(\n    \"mssql+pyodbc://scott:tiger^5HHH@mssql2017:1433/test?driver=ODBC+Driver+17+for+SQL+Server\",\n\n    # disable default reset-on-return scheme\n    pool_reset_on_return=None,\n)\n\n@event.listens_for(mssql_engine, \"reset\")\ndef _reset_mssql(dbapi_connection, connection_record, reset_state):\n    if not reset_state.terminate_only:\n        dbapi_connection.execute(\"{call sys.sp_reset_connection}\")\n\n    # so that the DBAPI itself knows that the connection has been\n    # reset\n    dbapi_connection.rollback()\n```", "```py\nname VARCHAR(20) NULL\n```", "```py\nname VARCHAR(20)\n```", "```py\n    eng = create_engine(\"mssql+pymssql://user:pass@host/db\",\n                    deprecate_large_types=True)\n    ```", "```py\nTable(\n    \"some_table\", metadata,\n    Column(\"q\", String(50)),\n    schema=\"mydatabase.dbo\"\n)\n```", "```py\nTable(\n    \"some_table\", metadata,\n    Column(\"q\", String(50)),\n    schema=\"MyDataBase.dbo\"\n)\n```", "```py\nTable(\n    \"some_table\", metadata,\n    Column(\"q\", String(50)),\n    schema=\"[MyDataBase.dbo]\"\n)\n```", "```py\nTable(\n    \"some_table\", metadata,\n    Column(\"q\", String(50)),\n    schema=\"[MyDataBase.Period].[MyOwner.Dot]\"\n)\n```", "```py\naccount_table = Table(\n    'account', metadata,\n    Column('id', Integer, primary_key=True),\n    Column('info', String(100)),\n    schema=\"customer_schema\"\n)\n```", "```py\n>>> eng = create_engine(\"mssql+pymssql://mydsn\", legacy_schema_aliasing=True)\n>>> print(account_table.select().compile(eng))\nSELECT  account_1.id,  account_1.info\nFROM  customer_schema.account  AS  account_1 \n```", "```py\nIndex(\"my_index\", table.c.x, mssql_clustered=True)\n```", "```py\nTable('my_table', metadata,\n      Column('x', ...),\n      Column('y', ...),\n      PrimaryKeyConstraint(\"x\", \"y\", mssql_clustered=True))\n```", "```py\nCREATE TABLE my_table (x INTEGER NOT NULL, y INTEGER NOT NULL,\n                       PRIMARY KEY CLUSTERED (x, y))\n```", "```py\nTable('my_table', metadata,\n      Column('x', ...),\n      Column('y', ...),\n      PrimaryKeyConstraint(\"x\"),\n      UniqueConstraint(\"y\", mssql_clustered=True),\n      )\n```", "```py\nTable('my_table', metadata,\n      Column('x', ...),\n      Column('y', ...),\n      PrimaryKeyConstraint(\"x\", \"y\", mssql_clustered=False))\n```", "```py\nCREATE TABLE my_table (x INTEGER NOT NULL, y INTEGER NOT NULL,\n                       PRIMARY KEY NONCLUSTERED (x, y))\n```", "```py\nIndex(\"my_index\", table.c.x, mssql_columnstore=True)\n```", "```py\nidx = Index(\"my_index\", mssql_clustered=True, mssql_columnstore=True)\n# required to associate the index with the table\ntable.append_constraint(idx)\n```", "```py\nIndex(\"my_index\", table.c.x, mssql_include=['y'])\n```", "```py\nIndex(\"my_index\", table.c.x, mssql_where=table.c.x > 10)\n```", "```py\nIndex(\"my_index\", table.c.x.desc())\n```", "```py\nIndex(\"my_index\", table.c.x, mssql_include=['y'])\n```", "```py\nIndex(\"my_index\", table.c.x, mssql_where=table.c.x > 10)\n```", "```py\nIndex(\"my_index\", table.c.x.desc())\n```", "```py\nTable('mytable', metadata,\n    Column('id', Integer, primary_key=True),\n    # ...,\n    implicit_returning=False\n)\n```", "```py\nclass MyClass(Base):\n    # ...\n    __table_args__ = {'implicit_returning':False}\n```", "```py\nALTER DATABASE MyDatabase SET ALLOW_SNAPSHOT_ISOLATION ON\n\nALTER DATABASE MyDatabase SET READ_COMMITTED_SNAPSHOT ON\n```", "```py\nfunction sqlalchemy.dialects.mssql.try_cast(expression: _ColumnExpressionOrLiteralArgument[Any], type_: _TypeEngineArgument[_T]) \u2192 TryCast[_T]\n```", "```py\nfrom sqlalchemy import select, try_cast, Numeric\n\nstmt = select(\n    try_cast(product_table.c.unit_price, Numeric(10, 4))\n)\n```", "```py\nSELECT TRY_CAST (product_table.unit_price AS NUMERIC(10, 4))\nFROM product_table\n```", "```py\nfrom sqlalchemy.dialects.mssql import (\n    BIGINT,\n    BINARY,\n    BIT,\n    CHAR,\n    DATE,\n    DATETIME,\n    DATETIME2,\n    DATETIMEOFFSET,\n    DECIMAL,\n    DOUBLE_PRECISION,\n    FLOAT,\n    IMAGE,\n    INTEGER,\n    JSON,\n    MONEY,\n    NCHAR,\n    NTEXT,\n    NUMERIC,\n    NVARCHAR,\n    REAL,\n    SMALLDATETIME,\n    SMALLINT,\n    SMALLMONEY,\n    SQL_VARIANT,\n    TEXT,\n    TIME,\n    TIMESTAMP,\n    TINYINT,\n    UNIQUEIDENTIFIER,\n    VARBINARY,\n    VARCHAR,\n)\n```", "```py\nclass sqlalchemy.dialects.mssql.BIT\n```", "```py\nmethod __init__(create_constraint: bool = False, name: str | None = None, _create_events: bool = True, _adapted_from: SchemaType | None = None)\n```", "```py\nclass sqlalchemy.dialects.mssql.CHAR\n```", "```py\nmethod __init__(length: int | None = None, collation: str | None = None)\n```", "```py\n    >>> from sqlalchemy import cast, select, String\n    >>> print(select(cast('some string', String(collation='utf8'))))\n    SELECT  CAST(:param_1  AS  VARCHAR  COLLATE  utf8)  AS  anon_1 \n    ```", "```py\nclass sqlalchemy.dialects.mssql.DATETIME2\n```", "```py\nclass sqlalchemy.dialects.mssql.DATETIMEOFFSET\n```", "```py\nclass sqlalchemy.dialects.mssql.DOUBLE_PRECISION\n```", "```py\nclass sqlalchemy.dialects.mssql.IMAGE\n```", "```py\nmethod __init__(length: int | None = None)\n```", "```py\nclass sqlalchemy.dialects.mssql.JSON\n```", "```py\n    stmt = select(\n        data_table.c.data[\"some key\"].as_json()\n    ).where(\n        data_table.c.data[\"some key\"].as_json() == {\"sub\": \"structure\"}\n    )\n    ```", "```py\n    stmt = select(\n        data_table.c.data[\"some key\"].as_string()\n    ).where(\n        data_table.c.data[\"some key\"].as_string() == \"some string\"\n    )\n    ```", "```py\nmethod __init__(none_as_null: bool = False)\n```", "```py\nfrom sqlalchemy import null\nconn.execute(table.insert(), {\"data\": null()})\n```", "```py\nclass sqlalchemy.dialects.mssql.MONEY\n```", "```py\nclass sqlalchemy.dialects.mssql.NCHAR\n```", "```py\nmethod __init__(length: int | None = None, collation: str | None = None)\n```", "```py\n    >>> from sqlalchemy import cast, select, String\n    >>> print(select(cast('some string', String(collation='utf8'))))\n    SELECT  CAST(:param_1  AS  VARCHAR  COLLATE  utf8)  AS  anon_1 \n    ```", "```py\nclass sqlalchemy.dialects.mssql.NTEXT\n```", "```py\nmethod __init__(length: int | None = None, collation: str | None = None)\n```", "```py\n    >>> from sqlalchemy import cast, select, String\n    >>> print(select(cast('some string', String(collation='utf8'))))\n    SELECT  CAST(:param_1  AS  VARCHAR  COLLATE  utf8)  AS  anon_1 \n    ```", "```py\nclass sqlalchemy.dialects.mssql.NVARCHAR\n```", "```py\nmethod __init__(length: int | None = None, collation: str | None = None)\n```", "```py\n    >>> from sqlalchemy import cast, select, String\n    >>> print(select(cast('some string', String(collation='utf8'))))\n    SELECT  CAST(:param_1  AS  VARCHAR  COLLATE  utf8)  AS  anon_1 \n    ```", "```py\nclass sqlalchemy.dialects.mssql.REAL\n```", "```py\nclass sqlalchemy.dialects.mssql.ROWVERSION\n```", "```py\nmethod __init__(convert_int=False)\n```", "```py\nclass sqlalchemy.dialects.mssql.SMALLDATETIME\n```", "```py\nmethod __init__(timezone: bool = False)\n```", "```py\nclass sqlalchemy.dialects.mssql.SMALLMONEY\n```", "```py\nclass sqlalchemy.dialects.mssql.SQL_VARIANT\n```", "```py\nclass sqlalchemy.dialects.mssql.TEXT\n```", "```py\nmethod __init__(length: int | None = None, collation: str | None = None)\n```", "```py\n    >>> from sqlalchemy import cast, select, String\n    >>> print(select(cast('some string', String(collation='utf8'))))\n    SELECT  CAST(:param_1  AS  VARCHAR  COLLATE  utf8)  AS  anon_1 \n    ```", "```py\nclass sqlalchemy.dialects.mssql.TIME\n```", "```py\nclass sqlalchemy.dialects.mssql.TIMESTAMP\n```", "```py\nmethod __init__(convert_int=False)\n```", "```py\nclass sqlalchemy.dialects.mssql.TINYINT\n```", "```py\nclass sqlalchemy.dialects.mssql.UNIQUEIDENTIFIER\n```", "```py\nmethod __init__(as_uuid: bool = True)\n```", "```py\nclass sqlalchemy.dialects.mssql.VARBINARY\n```", "```py\nmethod __init__(length=None, filestream=False)\n```", "```py\nclass sqlalchemy.dialects.mssql.VARCHAR\n```", "```py\nmethod __init__(length: int | None = None, collation: str | None = None)\n```", "```py\n    >>> from sqlalchemy import cast, select, String\n    >>> print(select(cast('some string', String(collation='utf8'))))\n    SELECT  CAST(:param_1  AS  VARCHAR  COLLATE  utf8)  AS  anon_1 \n    ```", "```py\nclass sqlalchemy.dialects.mssql.XML\n```", "```py\nmethod __init__(length: int | None = None, collation: str | None = None)\n```", "```py\n    >>> from sqlalchemy import cast, select, String\n    >>> print(select(cast('some string', String(collation='utf8'))))\n    SELECT  CAST(:param_1  AS  VARCHAR  COLLATE  utf8)  AS  anon_1 \n    ```", "```py\nmssql+pyodbc://<username>:<password>@<dsnname>\n```", "```py\nengine = create_engine(\"mssql+pyodbc://scott:tiger@some_dsn\")\n```", "```py\nDSN=some_dsn;UID=scott;PWD=tiger\n```", "```py\nengine = create_engine(\"mssql+pyodbc://scott:tiger@myhost:port/databasename?driver=ODBC+Driver+17+for+SQL+Server\")\n```", "```py\ne = create_engine(\n    \"mssql+pyodbc://scott:tiger@mssql2017:1433/test?\"\n    \"driver=ODBC+Driver+18+for+SQL+Server&TrustServerCertificate=yes\"\n    \"&authentication=ActiveDirectoryIntegrated\"\n)\n```", "```py\nfrom sqlalchemy.engine import URL\nconnection_url = URL.create(\n    \"mssql+pyodbc\",\n    username=\"scott\",\n    password=\"tiger\",\n    host=\"mssql2017\",\n    port=1433,\n    database=\"test\",\n    query={\n        \"driver\": \"ODBC Driver 18 for SQL Server\",\n        \"TrustServerCertificate\": \"yes\",\n        \"authentication\": \"ActiveDirectoryIntegrated\",\n    },\n)\n```", "```py\nfrom sqlalchemy.engine import URL\nconnection_string = \"DRIVER={SQL Server Native Client 10.0};SERVER=dagger;DATABASE=test;UID=user;PWD=password\"\nconnection_url = URL.create(\"mssql+pyodbc\", query={\"odbc_connect\": connection_string})\n\nengine = create_engine(connection_url)\n```", "```py\nimport struct\nfrom sqlalchemy import create_engine, event\nfrom sqlalchemy.engine.url import URL\nfrom azure import identity\n\nSQL_COPT_SS_ACCESS_TOKEN = 1256  # Connection option for access tokens, as defined in msodbcsql.h\nTOKEN_URL = \"https://database.windows.net/\"  # The token URL for any Azure SQL database\n\nconnection_string = \"mssql+pyodbc://@my-server.database.windows.net/myDb?driver=ODBC+Driver+17+for+SQL+Server\"\n\nengine = create_engine(connection_string)\n\nazure_credentials = identity.DefaultAzureCredential()\n\n@event.listens_for(engine, \"do_connect\")\ndef provide_token(dialect, conn_rec, cargs, cparams):\n    # remove the \"Trusted_Connection\" parameter that SQLAlchemy adds\n    cargs[0] = cargs[0].replace(\";Trusted_Connection=Yes\", \"\")\n\n    # create token credential\n    raw_token = azure_credentials.get_token(TOKEN_URL).token.encode(\"utf-16-le\")\n    token_struct = struct.pack(f\"<I{len(raw_token)}s\", len(raw_token), raw_token)\n\n    # apply it to keyword arguments\n    cparams[\"attrs_before\"] = {SQL_COPT_SS_ACCESS_TOKEN: token_struct}\n```", "```py\nengine = create_engine(connection_url, ignore_no_transaction_on_rollback=True)\n```", "```py\nconnection_url = sa.engine.URL.create(\n    \"mssql+pyodbc\",\n    username=\"scott\",\n    password=\"tiger\",\n    host=\"dw.azure.example.com\",\n    database=\"mydb\",\n    query={\n        \"driver\": \"ODBC Driver 17 for SQL Server\",\n        \"autocommit\": \"True\",\n    },\n)\n\nengine = create_engine(connection_url).execution_options(\n    isolation_level=\"AUTOCOMMIT\"\n)\n```", "```py\nconnection_url = sa.engine.URL.create(\n    \"mssql+pyodbc\",\n    username=\"scott\",\n    password=\"tiger\",\n    host=\"mssqlserver.example.com\",\n    database=\"mydb\",\n    query={\n        \"driver\": \"ODBC Driver 18 for SQL Server\",\n        \"LongAsMax\": \"Yes\",\n    },\n)\n```", "```py\nimport pyodbc\n\npyodbc.pooling = False\n\n# don't use the engine before pooling is set to False\nengine = create_engine(\"mssql+pyodbc://user:pass@dsn\")\n```", "```py\nengine = create_engine(\n    \"mssql+pyodbc://scott:tiger@mssql2017:1433/test?driver=ODBC+Driver+17+for+SQL+Server\",\n    fast_executemany=True)\n```", "```py\nmssql+pyodbc://<username>:<password>@<dsnname>\n```", "```py\nengine = create_engine(\"mssql+pyodbc://scott:tiger@some_dsn\")\n```", "```py\nDSN=some_dsn;UID=scott;PWD=tiger\n```", "```py\nengine = create_engine(\"mssql+pyodbc://scott:tiger@myhost:port/databasename?driver=ODBC+Driver+17+for+SQL+Server\")\n```", "```py\ne = create_engine(\n    \"mssql+pyodbc://scott:tiger@mssql2017:1433/test?\"\n    \"driver=ODBC+Driver+18+for+SQL+Server&TrustServerCertificate=yes\"\n    \"&authentication=ActiveDirectoryIntegrated\"\n)\n```", "```py\nfrom sqlalchemy.engine import URL\nconnection_url = URL.create(\n    \"mssql+pyodbc\",\n    username=\"scott\",\n    password=\"tiger\",\n    host=\"mssql2017\",\n    port=1433,\n    database=\"test\",\n    query={\n        \"driver\": \"ODBC Driver 18 for SQL Server\",\n        \"TrustServerCertificate\": \"yes\",\n        \"authentication\": \"ActiveDirectoryIntegrated\",\n    },\n)\n```", "```py\nfrom sqlalchemy.engine import URL\nconnection_string = \"DRIVER={SQL Server Native Client 10.0};SERVER=dagger;DATABASE=test;UID=user;PWD=password\"\nconnection_url = URL.create(\"mssql+pyodbc\", query={\"odbc_connect\": connection_string})\n\nengine = create_engine(connection_url)\n```", "```py\nimport struct\nfrom sqlalchemy import create_engine, event\nfrom sqlalchemy.engine.url import URL\nfrom azure import identity\n\nSQL_COPT_SS_ACCESS_TOKEN = 1256  # Connection option for access tokens, as defined in msodbcsql.h\nTOKEN_URL = \"https://database.windows.net/\"  # The token URL for any Azure SQL database\n\nconnection_string = \"mssql+pyodbc://@my-server.database.windows.net/myDb?driver=ODBC+Driver+17+for+SQL+Server\"\n\nengine = create_engine(connection_string)\n\nazure_credentials = identity.DefaultAzureCredential()\n\n@event.listens_for(engine, \"do_connect\")\ndef provide_token(dialect, conn_rec, cargs, cparams):\n    # remove the \"Trusted_Connection\" parameter that SQLAlchemy adds\n    cargs[0] = cargs[0].replace(\";Trusted_Connection=Yes\", \"\")\n\n    # create token credential\n    raw_token = azure_credentials.get_token(TOKEN_URL).token.encode(\"utf-16-le\")\n    token_struct = struct.pack(f\"<I{len(raw_token)}s\", len(raw_token), raw_token)\n\n    # apply it to keyword arguments\n    cparams[\"attrs_before\"] = {SQL_COPT_SS_ACCESS_TOKEN: token_struct}\n```", "```py\nengine = create_engine(connection_url, ignore_no_transaction_on_rollback=True)\n```", "```py\nconnection_url = sa.engine.URL.create(\n    \"mssql+pyodbc\",\n    username=\"scott\",\n    password=\"tiger\",\n    host=\"dw.azure.example.com\",\n    database=\"mydb\",\n    query={\n        \"driver\": \"ODBC Driver 17 for SQL Server\",\n        \"autocommit\": \"True\",\n    },\n)\n\nengine = create_engine(connection_url).execution_options(\n    isolation_level=\"AUTOCOMMIT\"\n)\n```", "```py\nconnection_url = sa.engine.URL.create(\n    \"mssql+pyodbc\",\n    username=\"scott\",\n    password=\"tiger\",\n    host=\"mssqlserver.example.com\",\n    database=\"mydb\",\n    query={\n        \"driver\": \"ODBC Driver 18 for SQL Server\",\n        \"LongAsMax\": \"Yes\",\n    },\n)\n```", "```py\nengine = create_engine(\"mssql+pyodbc://scott:tiger@some_dsn\")\n```", "```py\nDSN=some_dsn;UID=scott;PWD=tiger\n```", "```py\nengine = create_engine(\"mssql+pyodbc://scott:tiger@myhost:port/databasename?driver=ODBC+Driver+17+for+SQL+Server\")\n```", "```py\ne = create_engine(\n    \"mssql+pyodbc://scott:tiger@mssql2017:1433/test?\"\n    \"driver=ODBC+Driver+18+for+SQL+Server&TrustServerCertificate=yes\"\n    \"&authentication=ActiveDirectoryIntegrated\"\n)\n```", "```py\nfrom sqlalchemy.engine import URL\nconnection_url = URL.create(\n    \"mssql+pyodbc\",\n    username=\"scott\",\n    password=\"tiger\",\n    host=\"mssql2017\",\n    port=1433,\n    database=\"test\",\n    query={\n        \"driver\": \"ODBC Driver 18 for SQL Server\",\n        \"TrustServerCertificate\": \"yes\",\n        \"authentication\": \"ActiveDirectoryIntegrated\",\n    },\n)\n```", "```py\nfrom sqlalchemy.engine import URL\nconnection_string = \"DRIVER={SQL Server Native Client 10.0};SERVER=dagger;DATABASE=test;UID=user;PWD=password\"\nconnection_url = URL.create(\"mssql+pyodbc\", query={\"odbc_connect\": connection_string})\n\nengine = create_engine(connection_url)\n```", "```py\nimport struct\nfrom sqlalchemy import create_engine, event\nfrom sqlalchemy.engine.url import URL\nfrom azure import identity\n\nSQL_COPT_SS_ACCESS_TOKEN = 1256  # Connection option for access tokens, as defined in msodbcsql.h\nTOKEN_URL = \"https://database.windows.net/\"  # The token URL for any Azure SQL database\n\nconnection_string = \"mssql+pyodbc://@my-server.database.windows.net/myDb?driver=ODBC+Driver+17+for+SQL+Server\"\n\nengine = create_engine(connection_string)\n\nazure_credentials = identity.DefaultAzureCredential()\n\n@event.listens_for(engine, \"do_connect\")\ndef provide_token(dialect, conn_rec, cargs, cparams):\n    # remove the \"Trusted_Connection\" parameter that SQLAlchemy adds\n    cargs[0] = cargs[0].replace(\";Trusted_Connection=Yes\", \"\")\n\n    # create token credential\n    raw_token = azure_credentials.get_token(TOKEN_URL).token.encode(\"utf-16-le\")\n    token_struct = struct.pack(f\"<I{len(raw_token)}s\", len(raw_token), raw_token)\n\n    # apply it to keyword arguments\n    cparams[\"attrs_before\"] = {SQL_COPT_SS_ACCESS_TOKEN: token_struct}\n```", "```py\nengine = create_engine(connection_url, ignore_no_transaction_on_rollback=True)\n```", "```py\nconnection_url = sa.engine.URL.create(\n    \"mssql+pyodbc\",\n    username=\"scott\",\n    password=\"tiger\",\n    host=\"dw.azure.example.com\",\n    database=\"mydb\",\n    query={\n        \"driver\": \"ODBC Driver 17 for SQL Server\",\n        \"autocommit\": \"True\",\n    },\n)\n\nengine = create_engine(connection_url).execution_options(\n    isolation_level=\"AUTOCOMMIT\"\n)\n```", "```py\nconnection_url = sa.engine.URL.create(\n    \"mssql+pyodbc\",\n    username=\"scott\",\n    password=\"tiger\",\n    host=\"mssqlserver.example.com\",\n    database=\"mydb\",\n    query={\n        \"driver\": \"ODBC Driver 18 for SQL Server\",\n        \"LongAsMax\": \"Yes\",\n    },\n)\n```", "```py\nimport pyodbc\n\npyodbc.pooling = False\n\n# don't use the engine before pooling is set to False\nengine = create_engine(\"mssql+pyodbc://user:pass@dsn\")\n```", "```py\nengine = create_engine(\n    \"mssql+pyodbc://scott:tiger@mssql2017:1433/test?driver=ODBC+Driver+17+for+SQL+Server\",\n    fast_executemany=True)\n```", "```py\nmssql+pymssql://<username>:<password>@<freetds_name>/?charset=utf8\n```", "```py\nmssql+pymssql://<username>:<password>@<freetds_name>/?charset=utf8\n```", "```py\nmssql+aioodbc://<username>:<password>@<dsnname>\n```", "```py\nfrom sqlalchemy.ext.asyncio import create_async_engine\nengine = create_async_engine(\n    \"mssql+aioodbc://scott:tiger@mssql2017:1433/test?\"\n    \"driver=ODBC+Driver+18+for+SQL+Server&TrustServerCertificate=yes\"\n)\n```", "```py\nmssql+aioodbc://<username>:<password>@<dsnname>\n```"]