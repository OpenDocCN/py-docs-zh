["```py\n>>> messages = Table(\"messages\", metadata_obj, autoload_with=engine)\n>>> [c.name for c in messages.columns]\n['message_id', 'message_name', 'date']\n```", "```py\n>>> shopping_cart_items = Table(\"shopping_cart_items\", metadata_obj, autoload_with=engine)\n>>> \"shopping_carts\" in metadata_obj.tables\nTrue\n```", "```py\nshopping_carts = Table(\"shopping_carts\", metadata_obj)\n```", "```py\n>>> mytable = Table(\n...     \"mytable\",\n...     metadata_obj,\n...     Column(\n...         \"id\", Integer, primary_key=True\n...     ),  # override reflected 'id' to have primary key\n...     Column(\"mydata\", Unicode(50)),  # override reflected 'mydata' to be Unicode\n...     # additional Column objects which require no change are reflected normally\n...     autoload_with=some_engine,\n... )\n```", "```py\nmy_view = Table(\"some_view\", metadata, autoload_with=engine)\n```", "```py\nmy_view = Table(\n    \"some_view\",\n    metadata,\n    Column(\"view_id\", Integer, primary_key=True),\n    Column(\"related_thing\", Integer, ForeignKey(\"othertable.thing_id\")),\n    autoload_with=engine,\n)\n```", "```py\nmetadata_obj = MetaData()\nmetadata_obj.reflect(bind=someengine)\nusers_table = metadata_obj.tables[\"users\"]\naddresses_table = metadata_obj.tables[\"addresses\"]\n```", "```py\nmetadata_obj = MetaData()\nmetadata_obj.reflect(bind=someengine)\nwith someengine.begin() as conn:\n    for table in reversed(metadata_obj.sorted_tables):\n        conn.execute(table.delete())\n```", "```py\n>>> metadata_obj = MetaData(schema=\"project\")\n```", "```py\n>>> # uses `schema` configured in metadata_obj\n>>> metadata_obj.reflect(someengine)\n```", "```py\n>>> metadata_obj.tables[\"project.messages\"]\nTable('messages', MetaData(), Column('message_id', INTEGER(), table=<messages>), schema='project')\n```", "```py\n>>> messages = Table(\"messages\", metadata_obj, schema=\"project\", autoload_with=someengine)\n>>> messages\nTable('messages', MetaData(), Column('message_id', INTEGER(), table=<messages>), schema='project')\n```", "```py\n>>> metadata_obj = MetaData()\n>>> metadata_obj.reflect(someengine, schema=\"project\")\n```", "```py\n>>> # add tables from the \"customer\" schema\n>>> metadata_obj.reflect(someengine, schema=\"customer\")\n>>> # add tables from the default schema\n>>> metadata_obj.reflect(someengine)\n```", "```py\n-- schema qualified\nSELECT  message_id  FROM  project.messages\n\n-- non-schema qualified\nSELECT  message_id  FROM  messages\n```", "```py\n>>> # reflect in non-schema qualified fashion\n>>> messages_table_1 = Table(\"messages\", metadata_obj, autoload_with=someengine)\n>>> # reflect in schema qualified fashion\n>>> messages_table_2 = Table(\n...     \"messages\", metadata_obj, schema=\"project\", autoload_with=someengine\n... )\n>>> # two different objects\n>>> messages_table_1 is messages_table_2\nFalse\n>>> # stored in two different ways\n>>> metadata.tables[\"messages\"] is messages_table_1\nTrue\n>>> metadata.tables[\"project.messages\"] is messages_table_2\nTrue\n```", "```py\n>>> # reflect \"messages\" in a schema qualified fashion\n>>> messages_table_1 = Table(\n...     \"messages\", metadata_obj, schema=\"project\", autoload_with=someengine\n... )\n```", "```py\n>>> messages_table_1.c.project_id\nColumn('project_id', INTEGER(), ForeignKey('project.projects.project_id'), table=<messages>)\n```", "```py\n>>> # reflect \"projects\" in a non-schema qualified fashion\n>>> projects_table_1 = Table(\"projects\", metadata_obj, autoload_with=someengine)\n```", "```py\n>>> # messages does not refer to projects_table_1 above\n>>> messages_table_1.c.project_id.references(projects_table_1.c.project_id)\nFalse\n```", "```py\n>>> # it refers to this one\n>>> projects_table_2 = metadata_obj.tables[\"project.projects\"]\n>>> messages_table_1.c.project_id.references(projects_table_2.c.project_id)\nTrue\n```", "```py\n>>> # they're different, as one non-schema qualified and the other one is\n>>> projects_table_1 is projects_table_2\nFalse\n```", "```py\nfrom sqlalchemy import create_engine\nfrom sqlalchemy import inspect\n\nengine = create_engine(\"...\")\ninsp = inspect(engine)\nprint(insp.get_table_names())\n```", "```py\nclass sqlalchemy.engine.reflection.Inspector\n```", "```py\nfrom sqlalchemy import inspect, create_engine\nengine = create_engine('...')\ninsp = inspect(engine)\n```", "```py\nmethod __init__(bind: Engine | Connection)\n```", "```py\nattribute bind: Engine | Connection\n```", "```py\nmethod clear_cache() \u2192 None\n```", "```py\nattribute default_schema_name\n```", "```py\nattribute dialect: Dialect\n```", "```py\nattribute engine: Engine\n```", "```py\nclassmethod from_engine(bind: Engine) \u2192 Inspector\n```", "```py\nmethod get_check_constraints(table_name: str, schema: str | None = None, **kw: Any) \u2192 List[ReflectedCheckConstraint]\n```", "```py\nmethod get_columns(table_name: str, schema: str | None = None, **kw: Any) \u2192 List[ReflectedColumn]\n```", "```py\nmethod get_foreign_keys(table_name: str, schema: str | None = None, **kw: Any) \u2192 List[ReflectedForeignKeyConstraint]\n```", "```py\nmethod get_indexes(table_name: str, schema: str | None = None, **kw: Any) \u2192 List[ReflectedIndex]\n```", "```py\nmethod get_materialized_view_names(schema: str | None = None, **kw: Any) \u2192 List[str]\n```", "```py\nmethod get_multi_check_constraints(schema: str | None = None, filter_names: Sequence[str] | None = None, kind: ObjectKind = ObjectKind.TABLE, scope: ObjectScope = ObjectScope.DEFAULT, **kw: Any) \u2192 Dict[TableKey, List[ReflectedCheckConstraint]]\n```", "```py\nmethod get_multi_columns(schema: str | None = None, filter_names: Sequence[str] | None = None, kind: ObjectKind = ObjectKind.TABLE, scope: ObjectScope = ObjectScope.DEFAULT, **kw: Any) \u2192 Dict[TableKey, List[ReflectedColumn]]\n```", "```py\nmethod get_multi_foreign_keys(schema: str | None = None, filter_names: Sequence[str] | None = None, kind: ObjectKind = ObjectKind.TABLE, scope: ObjectScope = ObjectScope.DEFAULT, **kw: Any) \u2192 Dict[TableKey, List[ReflectedForeignKeyConstraint]]\n```", "```py\nmethod get_multi_indexes(schema: str | None = None, filter_names: Sequence[str] | None = None, kind: ObjectKind = ObjectKind.TABLE, scope: ObjectScope = ObjectScope.DEFAULT, **kw: Any) \u2192 Dict[TableKey, List[ReflectedIndex]]\n```", "```py\nmethod get_multi_pk_constraint(schema: str | None = None, filter_names: Sequence[str] | None = None, kind: ObjectKind = ObjectKind.TABLE, scope: ObjectScope = ObjectScope.DEFAULT, **kw: Any) \u2192 Dict[TableKey, ReflectedPrimaryKeyConstraint]\n```", "```py\nmethod get_multi_table_comment(schema: str | None = None, filter_names: Sequence[str] | None = None, kind: ObjectKind = ObjectKind.TABLE, scope: ObjectScope = ObjectScope.DEFAULT, **kw: Any) \u2192 Dict[TableKey, ReflectedTableComment]\n```", "```py\nmethod get_multi_table_options(schema: str | None = None, filter_names: Sequence[str] | None = None, kind: ObjectKind = ObjectKind.TABLE, scope: ObjectScope = ObjectScope.DEFAULT, **kw: Any) \u2192 Dict[TableKey, Dict[str, Any]]\n```", "```py\nmethod get_multi_unique_constraints(schema: str | None = None, filter_names: Sequence[str] | None = None, kind: ObjectKind = ObjectKind.TABLE, scope: ObjectScope = ObjectScope.DEFAULT, **kw: Any) \u2192 Dict[TableKey, List[ReflectedUniqueConstraint]]\n```", "```py\nmethod get_pk_constraint(table_name: str, schema: str | None = None, **kw: Any) \u2192 ReflectedPrimaryKeyConstraint\n```", "```py\nmethod get_schema_names(**kw: Any) \u2192 List[str]\n```", "```py\nmethod get_sequence_names(schema: str | None = None, **kw: Any) \u2192 List[str]\n```", "```py\nmethod get_sorted_table_and_fkc_names(schema: str | None = None, **kw: Any) \u2192 List[Tuple[str | None, List[Tuple[str, str | None]]]]\n```", "```py\nmethod get_table_comment(table_name: str, schema: str | None = None, **kw: Any) \u2192 ReflectedTableComment\n```", "```py\nmethod get_table_names(schema: str | None = None, **kw: Any) \u2192 List[str]\n```", "```py\nmethod get_table_options(table_name: str, schema: str | None = None, **kw: Any) \u2192 Dict[str, Any]\n```", "```py\nmethod get_temp_table_names(**kw: Any) \u2192 List[str]\n```", "```py\nmethod get_temp_view_names(**kw: Any) \u2192 List[str]\n```", "```py\nmethod get_unique_constraints(table_name: str, schema: str | None = None, **kw: Any) \u2192 List[ReflectedUniqueConstraint]\n```", "```py\nmethod get_view_definition(view_name: str, schema: str | None = None, **kw: Any) \u2192 str\n```", "```py\nmethod get_view_names(schema: str | None = None, **kw: Any) \u2192 List[str]\n```", "```py\nmethod has_index(table_name: str, index_name: str, schema: str | None = None, **kw: Any) \u2192 bool\n```", "```py\nmethod has_schema(schema_name: str, **kw: Any) \u2192 bool\n```", "```py\nmethod has_sequence(sequence_name: str, schema: str | None = None, **kw: Any) \u2192 bool\n```", "```py\nmethod has_table(table_name: str, schema: str | None = None, **kw: Any) \u2192 bool\n```", "```py\nattribute info_cache: Dict[Any, Any]\n```", "```py\nmethod reflect_table(table: Table, include_columns: Collection[str] | None, exclude_columns: Collection[str] = (), resolve_fks: bool = True, _extend_on: Set[Table] | None = None, _reflect_info: _ReflectionInfo | None = None) \u2192 None\n```", "```py\nfrom sqlalchemy import create_engine, MetaData, Table\nfrom sqlalchemy import inspect\n\nengine = create_engine('...')\nmeta = MetaData()\nuser_table = Table('user', meta)\ninsp = inspect(engine)\ninsp.reflect_table(user_table, None)\n```", "```py\nmethod sort_tables_on_foreign_key_dependency(consider_schemas: Collection[str | None] = (None,), **kw: Any) \u2192 List[Tuple[Tuple[str | None, str] | None, List[Tuple[Tuple[str | None, str], str | None]]]]\n```", "```py\nclass sqlalchemy.engine.interfaces.ReflectedColumn\n```", "```py\nattribute autoincrement: NotRequired[bool]\n```", "```py\nattribute comment: NotRequired[str | None]\n```", "```py\nattribute computed: NotRequired[ReflectedComputed]\n```", "```py\nattribute default: str | None\n```", "```py\nattribute dialect_options: NotRequired[Dict[str, Any]]\n```", "```py\nattribute identity: NotRequired[ReflectedIdentity]\n```", "```py\nattribute name: str\n```", "```py\nattribute nullable: bool\n```", "```py\nattribute type: TypeEngine[Any]\n```", "```py\nclass sqlalchemy.engine.interfaces.ReflectedComputed\n```", "```py\nattribute persisted: NotRequired[bool]\n```", "```py\nattribute sqltext: str\n```", "```py\nclass sqlalchemy.engine.interfaces.ReflectedCheckConstraint\n```", "```py\nattribute dialect_options: NotRequired[Dict[str, Any]]\n```", "```py\nattribute sqltext: str\n```", "```py\nclass sqlalchemy.engine.interfaces.ReflectedForeignKeyConstraint\n```", "```py\nattribute constrained_columns: List[str]\n```", "```py\nattribute options: NotRequired[Dict[str, Any]]\n```", "```py\nattribute referred_columns: List[str]\n```", "```py\nattribute referred_schema: str | None\n```", "```py\nattribute referred_table: str\n```", "```py\nclass sqlalchemy.engine.interfaces.ReflectedIdentity\n```", "```py\nattribute always: bool\n```", "```py\nattribute cache: int | None\n```", "```py\nattribute cycle: bool\n```", "```py\nattribute increment: int\n```", "```py\nattribute maxvalue: int\n```", "```py\nattribute minvalue: int\n```", "```py\nattribute nomaxvalue: bool\n```", "```py\nattribute nominvalue: bool\n```", "```py\nattribute on_null: bool\n```", "```py\nattribute order: bool\n```", "```py\nattribute start: int\n```", "```py\nclass sqlalchemy.engine.interfaces.ReflectedIndex\n```", "```py\nattribute column_names: List[str | None]\n```", "```py\nattribute column_sorting: NotRequired[Dict[str, Tuple[str]]]\n```", "```py\nattribute dialect_options: NotRequired[Dict[str, Any]]\n```", "```py\nattribute duplicates_constraint: NotRequired[str | None]\n```", "```py\nattribute expressions: NotRequired[List[str]]\n```", "```py\nattribute include_columns: NotRequired[List[str]]\n```", "```py\nattribute name: str | None\n```", "```py\nattribute unique: bool\n```", "```py\nclass sqlalchemy.engine.interfaces.ReflectedPrimaryKeyConstraint\n```", "```py\nattribute constrained_columns: List[str]\n```", "```py\nattribute dialect_options: NotRequired[Dict[str, Any]]\n```", "```py\nclass sqlalchemy.engine.interfaces.ReflectedUniqueConstraint\n```", "```py\nattribute column_names: List[str]\n```", "```py\nattribute dialect_options: NotRequired[Dict[str, Any]]\n```", "```py\nattribute duplicates_index: NotRequired[str | None]\n```", "```py\nclass sqlalchemy.engine.interfaces.ReflectedTableComment\n```", "```py\nattribute text: str | None\n```", "```py\nCREATE  TABLE  IF  NOT  EXISTS  my_table  (\n  id  INTEGER  PRIMARY  KEY  AUTO_INCREMENT,\n  data1  VARCHAR(50)  CHARACTER  SET  latin1,\n  data2  MEDIUMINT(4),\n  data3  TINYINT(2)\n)\n```", "```py\n>>> from sqlalchemy import MetaData, Table, create_engine\n>>> mysql_engine = create_engine(\"mysql+mysqldb://scott:tiger@localhost/test\")\n>>> metadata_obj = MetaData()\n>>> my_mysql_table = Table(\"my_table\", metadata_obj, autoload_with=mysql_engine)\n```", "```py\n>>> from sqlalchemy.schema import CreateTable\n>>> print(CreateTable(my_mysql_table).compile(mysql_engine))\nCREATE  TABLE  my_table  (\nid  INTEGER(11)  NOT  NULL  AUTO_INCREMENT,\ndata1  VARCHAR(50)  CHARACTER  SET  latin1,\ndata2  MEDIUMINT(4),\ndata3  TINYINT(2),\nPRIMARY  KEY  (id)\n)ENGINE=InnoDB  DEFAULT  CHARSET=utf8mb4 \n```", "```py\n>>> from sqlalchemy import event\n>>> metadata_obj = MetaData()\n\n>>> @event.listens_for(metadata_obj, \"column_reflect\")\n... def genericize_datatypes(inspector, tablename, column_dict):\n...     column_dict[\"type\"] = column_dict[\"type\"].as_generic()\n\n>>> my_generic_table = Table(\"my_table\", metadata_obj, autoload_with=mysql_engine)\n```", "```py\n>>> pg_engine = create_engine(\"postgresql+psycopg2://scott:tiger@localhost/test\", echo=True)\n>>> my_generic_table.create(pg_engine)\nCREATE  TABLE  my_table  (\n  id  SERIAL  NOT  NULL,\n  data1  VARCHAR(50),\n  data2  INTEGER,\n  data3  INTEGER,\n  PRIMARY  KEY  (id)\n) \n```", "```py\n>>> mytable = Table(\n...     \"mytable\",\n...     metadata_obj,\n...     Column(\n...         \"id\", Integer, primary_key=True\n...     ),  # override reflected 'id' to have primary key\n...     Column(\"mydata\", Unicode(50)),  # override reflected 'mydata' to be Unicode\n...     # additional Column objects which require no change are reflected normally\n...     autoload_with=some_engine,\n... )\n```", "```py\nmy_view = Table(\"some_view\", metadata, autoload_with=engine)\n```", "```py\nmy_view = Table(\n    \"some_view\",\n    metadata,\n    Column(\"view_id\", Integer, primary_key=True),\n    Column(\"related_thing\", Integer, ForeignKey(\"othertable.thing_id\")),\n    autoload_with=engine,\n)\n```", "```py\nmetadata_obj = MetaData()\nmetadata_obj.reflect(bind=someengine)\nusers_table = metadata_obj.tables[\"users\"]\naddresses_table = metadata_obj.tables[\"addresses\"]\n```", "```py\nmetadata_obj = MetaData()\nmetadata_obj.reflect(bind=someengine)\nwith someengine.begin() as conn:\n    for table in reversed(metadata_obj.sorted_tables):\n        conn.execute(table.delete())\n```", "```py\n>>> metadata_obj = MetaData(schema=\"project\")\n```", "```py\n>>> # uses `schema` configured in metadata_obj\n>>> metadata_obj.reflect(someengine)\n```", "```py\n>>> metadata_obj.tables[\"project.messages\"]\nTable('messages', MetaData(), Column('message_id', INTEGER(), table=<messages>), schema='project')\n```", "```py\n>>> messages = Table(\"messages\", metadata_obj, schema=\"project\", autoload_with=someengine)\n>>> messages\nTable('messages', MetaData(), Column('message_id', INTEGER(), table=<messages>), schema='project')\n```", "```py\n>>> metadata_obj = MetaData()\n>>> metadata_obj.reflect(someengine, schema=\"project\")\n```", "```py\n>>> # add tables from the \"customer\" schema\n>>> metadata_obj.reflect(someengine, schema=\"customer\")\n>>> # add tables from the default schema\n>>> metadata_obj.reflect(someengine)\n```", "```py\n-- schema qualified\nSELECT  message_id  FROM  project.messages\n\n-- non-schema qualified\nSELECT  message_id  FROM  messages\n```", "```py\n>>> # reflect in non-schema qualified fashion\n>>> messages_table_1 = Table(\"messages\", metadata_obj, autoload_with=someengine)\n>>> # reflect in schema qualified fashion\n>>> messages_table_2 = Table(\n...     \"messages\", metadata_obj, schema=\"project\", autoload_with=someengine\n... )\n>>> # two different objects\n>>> messages_table_1 is messages_table_2\nFalse\n>>> # stored in two different ways\n>>> metadata.tables[\"messages\"] is messages_table_1\nTrue\n>>> metadata.tables[\"project.messages\"] is messages_table_2\nTrue\n```", "```py\n>>> # reflect \"messages\" in a schema qualified fashion\n>>> messages_table_1 = Table(\n...     \"messages\", metadata_obj, schema=\"project\", autoload_with=someengine\n... )\n```", "```py\n>>> messages_table_1.c.project_id\nColumn('project_id', INTEGER(), ForeignKey('project.projects.project_id'), table=<messages>)\n```", "```py\n>>> # reflect \"projects\" in a non-schema qualified fashion\n>>> projects_table_1 = Table(\"projects\", metadata_obj, autoload_with=someengine)\n```", "```py\n>>> # messages does not refer to projects_table_1 above\n>>> messages_table_1.c.project_id.references(projects_table_1.c.project_id)\nFalse\n```", "```py\n>>> # it refers to this one\n>>> projects_table_2 = metadata_obj.tables[\"project.projects\"]\n>>> messages_table_1.c.project_id.references(projects_table_2.c.project_id)\nTrue\n```", "```py\n>>> # they're different, as one non-schema qualified and the other one is\n>>> projects_table_1 is projects_table_2\nFalse\n```", "```py\n-- schema qualified\nSELECT  message_id  FROM  project.messages\n\n-- non-schema qualified\nSELECT  message_id  FROM  messages\n```", "```py\n>>> # reflect in non-schema qualified fashion\n>>> messages_table_1 = Table(\"messages\", metadata_obj, autoload_with=someengine)\n>>> # reflect in schema qualified fashion\n>>> messages_table_2 = Table(\n...     \"messages\", metadata_obj, schema=\"project\", autoload_with=someengine\n... )\n>>> # two different objects\n>>> messages_table_1 is messages_table_2\nFalse\n>>> # stored in two different ways\n>>> metadata.tables[\"messages\"] is messages_table_1\nTrue\n>>> metadata.tables[\"project.messages\"] is messages_table_2\nTrue\n```", "```py\n>>> # reflect \"messages\" in a schema qualified fashion\n>>> messages_table_1 = Table(\n...     \"messages\", metadata_obj, schema=\"project\", autoload_with=someengine\n... )\n```", "```py\n>>> messages_table_1.c.project_id\nColumn('project_id', INTEGER(), ForeignKey('project.projects.project_id'), table=<messages>)\n```", "```py\n>>> # reflect \"projects\" in a non-schema qualified fashion\n>>> projects_table_1 = Table(\"projects\", metadata_obj, autoload_with=someengine)\n```", "```py\n>>> # messages does not refer to projects_table_1 above\n>>> messages_table_1.c.project_id.references(projects_table_1.c.project_id)\nFalse\n```", "```py\n>>> # it refers to this one\n>>> projects_table_2 = metadata_obj.tables[\"project.projects\"]\n>>> messages_table_1.c.project_id.references(projects_table_2.c.project_id)\nTrue\n```", "```py\n>>> # they're different, as one non-schema qualified and the other one is\n>>> projects_table_1 is projects_table_2\nFalse\n```", "```py\nfrom sqlalchemy import create_engine\nfrom sqlalchemy import inspect\n\nengine = create_engine(\"...\")\ninsp = inspect(engine)\nprint(insp.get_table_names())\n```", "```py\nclass sqlalchemy.engine.reflection.Inspector\n```", "```py\nfrom sqlalchemy import inspect, create_engine\nengine = create_engine('...')\ninsp = inspect(engine)\n```", "```py\nmethod __init__(bind: Engine | Connection)\n```", "```py\nattribute bind: Engine | Connection\n```", "```py\nmethod clear_cache() \u2192 None\n```", "```py\nattribute default_schema_name\n```", "```py\nattribute dialect: Dialect\n```", "```py\nattribute engine: Engine\n```", "```py\nclassmethod from_engine(bind: Engine) \u2192 Inspector\n```", "```py\nmethod get_check_constraints(table_name: str, schema: str | None = None, **kw: Any) \u2192 List[ReflectedCheckConstraint]\n```", "```py\nmethod get_columns(table_name: str, schema: str | None = None, **kw: Any) \u2192 List[ReflectedColumn]\n```", "```py\nmethod get_foreign_keys(table_name: str, schema: str | None = None, **kw: Any) \u2192 List[ReflectedForeignKeyConstraint]\n```", "```py\nmethod get_indexes(table_name: str, schema: str | None = None, **kw: Any) \u2192 List[ReflectedIndex]\n```", "```py\nmethod get_materialized_view_names(schema: str | None = None, **kw: Any) \u2192 List[str]\n```", "```py\nmethod get_multi_check_constraints(schema: str | None = None, filter_names: Sequence[str] | None = None, kind: ObjectKind = ObjectKind.TABLE, scope: ObjectScope = ObjectScope.DEFAULT, **kw: Any) \u2192 Dict[TableKey, List[ReflectedCheckConstraint]]\n```", "```py\nmethod get_multi_columns(schema: str | None = None, filter_names: Sequence[str] | None = None, kind: ObjectKind = ObjectKind.TABLE, scope: ObjectScope = ObjectScope.DEFAULT, **kw: Any) \u2192 Dict[TableKey, List[ReflectedColumn]]\n```", "```py\nmethod get_multi_foreign_keys(schema: str | None = None, filter_names: Sequence[str] | None = None, kind: ObjectKind = ObjectKind.TABLE, scope: ObjectScope = ObjectScope.DEFAULT, **kw: Any) \u2192 Dict[TableKey, List[ReflectedForeignKeyConstraint]]\n```", "```py\nmethod get_multi_indexes(schema: str | None = None, filter_names: Sequence[str] | None = None, kind: ObjectKind = ObjectKind.TABLE, scope: ObjectScope = ObjectScope.DEFAULT, **kw: Any) \u2192 Dict[TableKey, List[ReflectedIndex]]\n```", "```py\nmethod get_multi_pk_constraint(schema: str | None = None, filter_names: Sequence[str] | None = None, kind: ObjectKind = ObjectKind.TABLE, scope: ObjectScope = ObjectScope.DEFAULT, **kw: Any) \u2192 Dict[TableKey, ReflectedPrimaryKeyConstraint]\n```", "```py\nmethod get_multi_table_comment(schema: str | None = None, filter_names: Sequence[str] | None = None, kind: ObjectKind = ObjectKind.TABLE, scope: ObjectScope = ObjectScope.DEFAULT, **kw: Any) \u2192 Dict[TableKey, ReflectedTableComment]\n```", "```py\nmethod get_multi_table_options(schema: str | None = None, filter_names: Sequence[str] | None = None, kind: ObjectKind = ObjectKind.TABLE, scope: ObjectScope = ObjectScope.DEFAULT, **kw: Any) \u2192 Dict[TableKey, Dict[str, Any]]\n```", "```py\nmethod get_multi_unique_constraints(schema: str | None = None, filter_names: Sequence[str] | None = None, kind: ObjectKind = ObjectKind.TABLE, scope: ObjectScope = ObjectScope.DEFAULT, **kw: Any) \u2192 Dict[TableKey, List[ReflectedUniqueConstraint]]\n```", "```py\nmethod get_pk_constraint(table_name: str, schema: str | None = None, **kw: Any) \u2192 ReflectedPrimaryKeyConstraint\n```", "```py\nmethod get_schema_names(**kw: Any) \u2192 List[str]\n```", "```py\nmethod get_sequence_names(schema: str | None = None, **kw: Any) \u2192 List[str]\n```", "```py\nmethod get_sorted_table_and_fkc_names(schema: str | None = None, **kw: Any) \u2192 List[Tuple[str | None, List[Tuple[str, str | None]]]]\n```", "```py\nmethod get_table_comment(table_name: str, schema: str | None = None, **kw: Any) \u2192 ReflectedTableComment\n```", "```py\nmethod get_table_names(schema: str | None = None, **kw: Any) \u2192 List[str]\n```", "```py\nmethod get_table_options(table_name: str, schema: str | None = None, **kw: Any) \u2192 Dict[str, Any]\n```", "```py\nmethod get_temp_table_names(**kw: Any) \u2192 List[str]\n```", "```py\nmethod get_temp_view_names(**kw: Any) \u2192 List[str]\n```", "```py\nmethod get_unique_constraints(table_name: str, schema: str | None = None, **kw: Any) \u2192 List[ReflectedUniqueConstraint]\n```", "```py\nmethod get_view_definition(view_name: str, schema: str | None = None, **kw: Any) \u2192 str\n```", "```py\nmethod get_view_names(schema: str | None = None, **kw: Any) \u2192 List[str]\n```", "```py\nmethod has_index(table_name: str, index_name: str, schema: str | None = None, **kw: Any) \u2192 bool\n```", "```py\nmethod has_schema(schema_name: str, **kw: Any) \u2192 bool\n```", "```py\nmethod has_sequence(sequence_name: str, schema: str | None = None, **kw: Any) \u2192 bool\n```", "```py\nmethod has_table(table_name: str, schema: str | None = None, **kw: Any) \u2192 bool\n```", "```py\nattribute info_cache: Dict[Any, Any]\n```", "```py\nmethod reflect_table(table: Table, include_columns: Collection[str] | None, exclude_columns: Collection[str] = (), resolve_fks: bool = True, _extend_on: Set[Table] | None = None, _reflect_info: _ReflectionInfo | None = None) \u2192 None\n```", "```py\nfrom sqlalchemy import create_engine, MetaData, Table\nfrom sqlalchemy import inspect\n\nengine = create_engine('...')\nmeta = MetaData()\nuser_table = Table('user', meta)\ninsp = inspect(engine)\ninsp.reflect_table(user_table, None)\n```", "```py\nmethod sort_tables_on_foreign_key_dependency(consider_schemas: Collection[str | None] = (None,), **kw: Any) \u2192 List[Tuple[Tuple[str | None, str] | None, List[Tuple[Tuple[str | None, str], str | None]]]]\n```", "```py\nclass sqlalchemy.engine.interfaces.ReflectedColumn\n```", "```py\nattribute autoincrement: NotRequired[bool]\n```", "```py\nattribute comment: NotRequired[str | None]\n```", "```py\nattribute computed: NotRequired[ReflectedComputed]\n```", "```py\nattribute default: str | None\n```", "```py\nattribute dialect_options: NotRequired[Dict[str, Any]]\n```", "```py\nattribute identity: NotRequired[ReflectedIdentity]\n```", "```py\nattribute name: str\n```", "```py\nattribute nullable: bool\n```", "```py\nattribute type: TypeEngine[Any]\n```", "```py\nclass sqlalchemy.engine.interfaces.ReflectedComputed\n```", "```py\nattribute persisted: NotRequired[bool]\n```", "```py\nattribute sqltext: str\n```", "```py\nclass sqlalchemy.engine.interfaces.ReflectedCheckConstraint\n```", "```py\nattribute dialect_options: NotRequired[Dict[str, Any]]\n```", "```py\nattribute sqltext: str\n```", "```py\nclass sqlalchemy.engine.interfaces.ReflectedForeignKeyConstraint\n```", "```py\nattribute constrained_columns: List[str]\n```", "```py\nattribute options: NotRequired[Dict[str, Any]]\n```", "```py\nattribute referred_columns: List[str]\n```", "```py\nattribute referred_schema: str | None\n```", "```py\nattribute referred_table: str\n```", "```py\nclass sqlalchemy.engine.interfaces.ReflectedIdentity\n```", "```py\nattribute always: bool\n```", "```py\nattribute cache: int | None\n```", "```py\nattribute cycle: bool\n```", "```py\nattribute increment: int\n```", "```py\nattribute maxvalue: int\n```", "```py\nattribute minvalue: int\n```", "```py\nattribute nomaxvalue: bool\n```", "```py\nattribute nominvalue: bool\n```", "```py\nattribute on_null: bool\n```", "```py\nattribute order: bool\n```", "```py\nattribute start: int\n```", "```py\nclass sqlalchemy.engine.interfaces.ReflectedIndex\n```", "```py\nattribute column_names: List[str | None]\n```", "```py\nattribute column_sorting: NotRequired[Dict[str, Tuple[str]]]\n```", "```py\nattribute dialect_options: NotRequired[Dict[str, Any]]\n```", "```py\nattribute duplicates_constraint: NotRequired[str | None]\n```", "```py\nattribute expressions: NotRequired[List[str]]\n```", "```py\nattribute include_columns: NotRequired[List[str]]\n```", "```py\nattribute name: str | None\n```", "```py\nattribute unique: bool\n```", "```py\nclass sqlalchemy.engine.interfaces.ReflectedPrimaryKeyConstraint\n```", "```py\nattribute constrained_columns: List[str]\n```", "```py\nattribute dialect_options: NotRequired[Dict[str, Any]]\n```", "```py\nclass sqlalchemy.engine.interfaces.ReflectedUniqueConstraint\n```", "```py\nattribute column_names: List[str]\n```", "```py\nattribute dialect_options: NotRequired[Dict[str, Any]]\n```", "```py\nattribute duplicates_index: NotRequired[str | None]\n```", "```py\nclass sqlalchemy.engine.interfaces.ReflectedTableComment\n```", "```py\nattribute text: str | None\n```", "```py\nCREATE  TABLE  IF  NOT  EXISTS  my_table  (\n  id  INTEGER  PRIMARY  KEY  AUTO_INCREMENT,\n  data1  VARCHAR(50)  CHARACTER  SET  latin1,\n  data2  MEDIUMINT(4),\n  data3  TINYINT(2)\n)\n```", "```py\n>>> from sqlalchemy import MetaData, Table, create_engine\n>>> mysql_engine = create_engine(\"mysql+mysqldb://scott:tiger@localhost/test\")\n>>> metadata_obj = MetaData()\n>>> my_mysql_table = Table(\"my_table\", metadata_obj, autoload_with=mysql_engine)\n```", "```py\n>>> from sqlalchemy.schema import CreateTable\n>>> print(CreateTable(my_mysql_table).compile(mysql_engine))\nCREATE  TABLE  my_table  (\nid  INTEGER(11)  NOT  NULL  AUTO_INCREMENT,\ndata1  VARCHAR(50)  CHARACTER  SET  latin1,\ndata2  MEDIUMINT(4),\ndata3  TINYINT(2),\nPRIMARY  KEY  (id)\n)ENGINE=InnoDB  DEFAULT  CHARSET=utf8mb4 \n```", "```py\n>>> from sqlalchemy import event\n>>> metadata_obj = MetaData()\n\n>>> @event.listens_for(metadata_obj, \"column_reflect\")\n... def genericize_datatypes(inspector, tablename, column_dict):\n...     column_dict[\"type\"] = column_dict[\"type\"].as_generic()\n\n>>> my_generic_table = Table(\"my_table\", metadata_obj, autoload_with=mysql_engine)\n```", "```py\n>>> pg_engine = create_engine(\"postgresql+psycopg2://scott:tiger@localhost/test\", echo=True)\n>>> my_generic_table.create(pg_engine)\nCREATE  TABLE  my_table  (\n  id  SERIAL  NOT  NULL,\n  data1  VARCHAR(50),\n  data2  INTEGER,\n  data3  INTEGER,\n  PRIMARY  KEY  (id)\n) \n```"]