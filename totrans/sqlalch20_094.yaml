- en: The Type Hierarchy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.sqlalchemy.org/en/20/core/type_basics.html](https://docs.sqlalchemy.org/en/20/core/type_basics.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: SQLAlchemy provides abstractions for most common database data types, as well
    as several techniques for customization of datatypes.
  prefs: []
  type: TYPE_NORMAL
- en: Database types are represented using Python classes, all of which ultimately
    extend from the base type class known as [`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine"). There are two general categories of datatypes,
    each of which express themselves within the typing hierarchy in different ways.
    The category used by an individual datatype class can be identified based on the
    use of two different naming conventions, which are “CamelCase” and “UPPERCASE”.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Setting up MetaData with Table objects](../tutorial/metadata.html#tutorial-core-metadata)
    - in the [SQLAlchemy Unified Tutorial](../tutorial/index.html#unified-tutorial).
    Illustrates the most rudimental use of [`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") type objects to define [`Table`](metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") metadata and introduces the concept of type objects
    in tutorial form.'
  prefs: []
  type: TYPE_NORMAL
- en: The “CamelCase” datatypes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The rudimental types have “CamelCase” names such as [`String`](#sqlalchemy.types.String
    "sqlalchemy.types.String"), [`Numeric`](#sqlalchemy.types.Numeric "sqlalchemy.types.Numeric"),
    [`Integer`](#sqlalchemy.types.Integer "sqlalchemy.types.Integer"), and [`DateTime`](#sqlalchemy.types.DateTime
    "sqlalchemy.types.DateTime"). All of the immediate subclasses of [`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") are “CamelCase” types. The “CamelCase” types are
    to the greatest degree possible **database agnostic**, meaning they can all be
    used on any database backend where they will behave in such a way as appropriate
    to that backend in order to produce the desired behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of a straightforward “CamelCase” datatype is [`String`](#sqlalchemy.types.String
    "sqlalchemy.types.String"). On most backends, using this datatype in a [table
    specification](metadata.html#metadata-describing) will correspond to the `VARCHAR`
    database type being used on the target backend, delivering string values to and
    from the database, as in the example below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: When using a particular [`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") class in a [`Table`](metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") definition or in any SQL expression overall, if no
    arguments are required it may be passed as the class itself, that is, without
    instantiating it with `()`. If arguments are needed, such as the length argument
    of 60 in the `"email_address"` column above, the type may be instantiated.
  prefs: []
  type: TYPE_NORMAL
- en: Another “CamelCase” datatype that expresses more backend-specific behavior is
    the [`Boolean`](#sqlalchemy.types.Boolean "sqlalchemy.types.Boolean") datatype.
    Unlike [`String`](#sqlalchemy.types.String "sqlalchemy.types.String"), which represents
    a string datatype that all databases have, not every backend has a real “boolean”
    datatype; some make use of integers or BIT values 0 and 1, some have boolean literal
    constants `true` and `false` while others dont. For this datatype, [`Boolean`](#sqlalchemy.types.Boolean
    "sqlalchemy.types.Boolean") may render `BOOLEAN` on a backend such as PostgreSQL,
    `BIT` on the MySQL backend and `SMALLINT` on Oracle. As data is sent and received
    from the database using this type, based on the dialect in use it may be interpreting
    Python numeric or boolean values.
  prefs: []
  type: TYPE_NORMAL
- en: The typical SQLAlchemy application will likely wish to use primarily “CamelCase”
    types in the general case, as they will generally provide the best basic behavior
    and be automatically portable to all backends.
  prefs: []
  type: TYPE_NORMAL
- en: Reference for the general set of “CamelCase” datatypes is below at [Generic
    “CamelCase” Types](#types-generic).
  prefs: []
  type: TYPE_NORMAL
- en: The “UPPERCASE” datatypes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In contrast to the “CamelCase” types are the “UPPERCASE” datatypes. These datatypes
    are always inherited from a particular “CamelCase” datatype, and always represent
    an **exact** datatype. When using an “UPPERCASE” datatype, the name of the type
    is always rendered exactly as given, without regard for whether or not the current
    backend supports it. Therefore the use of “UPPERCASE” types in a SQLAlchemy application
    indicates that specific datatypes are required, which then implies that the application
    would normally, without additional steps taken, be limited to those backends which
    use the type exactly as given. Examples of UPPERCASE types include [`VARCHAR`](#sqlalchemy.types.VARCHAR
    "sqlalchemy.types.VARCHAR"), [`NUMERIC`](#sqlalchemy.types.NUMERIC "sqlalchemy.types.NUMERIC"),
    [`INTEGER`](#sqlalchemy.types.INTEGER "sqlalchemy.types.INTEGER"), and [`TIMESTAMP`](#sqlalchemy.types.TIMESTAMP
    "sqlalchemy.types.TIMESTAMP"), which inherit directly from the previously mentioned
    “CamelCase” types [`String`](#sqlalchemy.types.String "sqlalchemy.types.String"),
    [`Numeric`](#sqlalchemy.types.Numeric "sqlalchemy.types.Numeric"), [`Integer`](#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer"), and [`DateTime`](#sqlalchemy.types.DateTime "sqlalchemy.types.DateTime"),
    respectively.
  prefs: []
  type: TYPE_NORMAL
- en: The “UPPERCASE” datatypes that are part of `sqlalchemy.types` are common SQL
    types that typically expect to be available on at least two backends if not more.
  prefs: []
  type: TYPE_NORMAL
- en: Reference for the general set of “UPPERCASE” datatypes is below at [SQL Standard
    and Multiple Vendor “UPPERCASE” Types](#types-sqlstandard).
  prefs: []
  type: TYPE_NORMAL
- en: '## Backend-specific “UPPERCASE” datatypes'
  prefs: []
  type: TYPE_NORMAL
- en: Most databases also have their own datatypes that are either fully specific
    to those databases, or add additional arguments that are specific to those databases.
    For these datatypes, specific SQLAlchemy dialects provide **backend-specific**
    “UPPERCASE” datatypes, for a SQL type that has no analogue on other backends.
    Examples of backend-specific uppercase datatypes include PostgreSQL’s [`JSONB`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSONB
    "sqlalchemy.dialects.postgresql.JSONB"), SQL Server’s [`IMAGE`](../dialects/mssql.html#sqlalchemy.dialects.mssql.IMAGE
    "sqlalchemy.dialects.mssql.IMAGE") and MySQL’s [`TINYTEXT`](../dialects/mysql.html#sqlalchemy.dialects.mysql.TINYTEXT
    "sqlalchemy.dialects.mysql.TINYTEXT").
  prefs: []
  type: TYPE_NORMAL
- en: Specific backends may also include “UPPERCASE” datatypes that extend the arguments
    available from that same “UPPERCASE” datatype as found in the `sqlalchemy.types`
    module. An example is when creating a MySQL string datatype, one might want to
    specify MySQL-specific arguments such as `charset` or `national`, which are available
    from the MySQL version of [`VARCHAR`](../dialects/mysql.html#sqlalchemy.dialects.mysql.VARCHAR
    "sqlalchemy.dialects.mysql.VARCHAR") as the MySQL-only parameters [`VARCHAR.charset`](../dialects/mysql.html#sqlalchemy.dialects.mysql.VARCHAR.params.charset
    "sqlalchemy.dialects.mysql.VARCHAR") and [`VARCHAR.national`](../dialects/mysql.html#sqlalchemy.dialects.mysql.VARCHAR.params.national
    "sqlalchemy.dialects.mysql.VARCHAR").
  prefs: []
  type: TYPE_NORMAL
- en: 'API documentation for backend-specific types are in the dialect-specific documentation,
    listed at [Dialects](../dialects/index.html).  ## Using “UPPERCASE” and Backend-specific
    types for multiple backends'
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing the presence of “UPPERCASE” and “CamelCase” types leads to the natural
    use case of how to make use of “UPPERCASE” datatypes for backend-specific options,
    but only when that backend is in use. To tie together the database-agnostic “CamelCase”
    and backend-specific “UPPERCASE” systems, one makes use of the [`TypeEngine.with_variant()`](type_api.html#sqlalchemy.types.TypeEngine.with_variant
    "sqlalchemy.types.TypeEngine.with_variant") method in order to **compose** types
    together to work with specific behaviors on specific backends.
  prefs: []
  type: TYPE_NORMAL
- en: 'Such as, to use the [`String`](#sqlalchemy.types.String "sqlalchemy.types.String")
    datatype, but when running on MySQL to make use of the [`VARCHAR.charset`](../dialects/mysql.html#sqlalchemy.dialects.mysql.VARCHAR.params.charset
    "sqlalchemy.dialects.mysql.VARCHAR") parameter of [`VARCHAR`](../dialects/mysql.html#sqlalchemy.dialects.mysql.VARCHAR
    "sqlalchemy.dialects.mysql.VARCHAR") when the table is created on MySQL or MariaDB,
    [`TypeEngine.with_variant()`](type_api.html#sqlalchemy.types.TypeEngine.with_variant
    "sqlalchemy.types.TypeEngine.with_variant") may be used as below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the above table definition, the `"bio"` column will have string-behaviors
    on all backends. On most backends it will render in DDL as `VARCHAR`. However
    on MySQL and MariaDB (indicated by database URLs that start with `mysql` or `mariadb`),
    it will render as `VARCHAR(255) CHARACTER SET utf8`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`TypeEngine.with_variant()`](type_api.html#sqlalchemy.types.TypeEngine.with_variant
    "sqlalchemy.types.TypeEngine.with_variant") - additional usage examples and notes  ##
    Generic “CamelCase” Types'
  prefs: []
  type: TYPE_NORMAL
- en: Generic types specify a column that can read, write and store a particular type
    of Python data. SQLAlchemy will choose the best database column type available
    on the target database when issuing a `CREATE TABLE` statement. For complete control
    over which column type is emitted in `CREATE TABLE`, such as `VARCHAR` see [SQL
    Standard and Multiple Vendor “UPPERCASE” Types](#types-sqlstandard) and the other
    sections of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '| Object Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| [BigInteger](#sqlalchemy.types.BigInteger) | A type for bigger `int` integers.
    |'
  prefs: []
  type: TYPE_TB
- en: '| [Boolean](#sqlalchemy.types.Boolean) | A bool datatype. |'
  prefs: []
  type: TYPE_TB
- en: '| [Date](#sqlalchemy.types.Date) | A type for `datetime.date()` objects. |'
  prefs: []
  type: TYPE_TB
- en: '| [DateTime](#sqlalchemy.types.DateTime) | A type for `datetime.datetime()`
    objects. |'
  prefs: []
  type: TYPE_TB
- en: '| [Double](#sqlalchemy.types.Double) | A type for double `FLOAT` floating point
    types. |'
  prefs: []
  type: TYPE_TB
- en: '| [Enum](#sqlalchemy.types.Enum) | Generic Enum Type. |'
  prefs: []
  type: TYPE_TB
- en: '| [Float](#sqlalchemy.types.Float) | Type representing floating point types,
    such as `FLOAT` or `REAL`. |'
  prefs: []
  type: TYPE_TB
- en: '| [Integer](#sqlalchemy.types.Integer) | A type for `int` integers. |'
  prefs: []
  type: TYPE_TB
- en: '| [Interval](#sqlalchemy.types.Interval) | A type for `datetime.timedelta()`
    objects. |'
  prefs: []
  type: TYPE_TB
- en: '| [LargeBinary](#sqlalchemy.types.LargeBinary) | A type for large binary byte
    data. |'
  prefs: []
  type: TYPE_TB
- en: '| [MatchType](#sqlalchemy.types.MatchType) | Refers to the return type of the
    MATCH operator. |'
  prefs: []
  type: TYPE_TB
- en: '| [Numeric](#sqlalchemy.types.Numeric) | Base for non-integer numeric types,
    such as `NUMERIC`, `FLOAT`, `DECIMAL`, and other variants. |'
  prefs: []
  type: TYPE_TB
- en: '| [PickleType](#sqlalchemy.types.PickleType) | Holds Python objects, which
    are serialized using pickle. |'
  prefs: []
  type: TYPE_TB
- en: '| [SchemaType](#sqlalchemy.types.SchemaType) | Add capabilities to a type which
    allow for schema-level DDL to be associated with a type. |'
  prefs: []
  type: TYPE_TB
- en: '| [SmallInteger](#sqlalchemy.types.SmallInteger) | A type for smaller `int`
    integers. |'
  prefs: []
  type: TYPE_TB
- en: '| [String](#sqlalchemy.types.String) | The base for all string and character
    types. |'
  prefs: []
  type: TYPE_TB
- en: '| [Text](#sqlalchemy.types.Text) | A variably sized string type. |'
  prefs: []
  type: TYPE_TB
- en: '| [Time](#sqlalchemy.types.Time) | A type for `datetime.time()` objects. |'
  prefs: []
  type: TYPE_TB
- en: '| [Unicode](#sqlalchemy.types.Unicode) | A variable length Unicode string type.
    |'
  prefs: []
  type: TYPE_TB
- en: '| [UnicodeText](#sqlalchemy.types.UnicodeText) | An unbounded-length Unicode
    string type. |'
  prefs: []
  type: TYPE_TB
- en: '| [Uuid](#sqlalchemy.types.Uuid) | Represent a database agnostic UUID datatype.
    |'
  prefs: []
  type: TYPE_TB
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: A type for bigger `int` integers.
  prefs: []
  type: TYPE_NORMAL
- en: Typically generates a `BIGINT` in DDL, and otherwise acts like a normal [`Integer`](#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer") on the Python side.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.types.BigInteger`](#sqlalchemy.types.BigInteger "sqlalchemy.types.BigInteger")
    ([`sqlalchemy.types.Integer`](#sqlalchemy.types.Integer "sqlalchemy.types.Integer"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: A bool datatype.
  prefs: []
  type: TYPE_NORMAL
- en: '[`Boolean`](#sqlalchemy.types.Boolean "sqlalchemy.types.Boolean") typically
    uses BOOLEAN or SMALLINT on the DDL side, and on the Python side deals in `True`
    or `False`.'
  prefs: []
  type: TYPE_NORMAL
- en: The [`Boolean`](#sqlalchemy.types.Boolean "sqlalchemy.types.Boolean") datatype
    currently has two levels of assertion that the values persisted are simple true/false
    values. For all backends, only the Python values `None`, `True`, `False`, `1`
    or `0` are accepted as parameter values. For those backends that don’t support
    a “native boolean” datatype, an option exists to also create a CHECK constraint
    on the target column
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.2: the [`Boolean`](#sqlalchemy.types.Boolean "sqlalchemy.types.Boolean")
    datatype now asserts that incoming Python values are already in pure boolean form.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.types.Boolean.__init__), [bind_processor()](#sqlalchemy.types.Boolean.bind_processor),
    [literal_processor()](#sqlalchemy.types.Boolean.literal_processor), [python_type](#sqlalchemy.types.Boolean.python_type),
    [result_processor()](#sqlalchemy.types.Boolean.result_processor)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.types.Boolean`](#sqlalchemy.types.Boolean "sqlalchemy.types.Boolean")
    ([`sqlalchemy.types.SchemaType`](#sqlalchemy.types.SchemaType "sqlalchemy.types.SchemaType"),
    `sqlalchemy.types.Emulated`, [`sqlalchemy.types.TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Construct a Boolean.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`create_constraint` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: defaults to False. If the boolean is generated as an int/smallint, also create
    a CHECK constraint on the table that ensures 1 or 0 as a value.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: it is strongly recommended that the CHECK constraint have an explicit name in
    order to support schema-management concerns. This can be established either by
    setting the [`Boolean.name`](#sqlalchemy.types.Boolean.params.name "sqlalchemy.types.Boolean")
    parameter or by setting up an appropriate naming convention; see [Configuring
    Constraint Naming Conventions](constraints.html#constraint-naming-conventions)
    for background.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Changed in version 1.4: - this flag now defaults to False, meaning no CHECK
    constraint is generated for a non-native enumerated type.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`name` – if a CHECK constraint is generated, specify the name of the constraint.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Return a conversion function for processing bind values.
  prefs: []
  type: TYPE_NORMAL
- en: Returns a callable which will receive a bind parameter value as the sole positional
    argument and will return a value to send to the DB-API.
  prefs: []
  type: TYPE_NORMAL
- en: If processing is not necessary, the method should return `None`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This method is only called relative to a **dialect specific type object**, which
    is often **private to a dialect in use** and is not the same type object as the
    public facing one, which means it’s not feasible to subclass a [`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") class in order to provide an alternate [`TypeEngine.bind_processor()`](type_api.html#sqlalchemy.types.TypeEngine.bind_processor
    "sqlalchemy.types.TypeEngine.bind_processor") method, unless subclassing the [`UserDefinedType`](custom_types.html#sqlalchemy.types.UserDefinedType
    "sqlalchemy.types.UserDefinedType") class explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: To provide alternate behavior for [`TypeEngine.bind_processor()`](type_api.html#sqlalchemy.types.TypeEngine.bind_processor
    "sqlalchemy.types.TypeEngine.bind_processor"), implement a [`TypeDecorator`](custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") class and provide an implementation of [`TypeDecorator.process_bind_param()`](custom_types.html#sqlalchemy.types.TypeDecorator.process_bind_param
    "sqlalchemy.types.TypeDecorator.process_bind_param").
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Augmenting Existing Types](custom_types.html#types-typedecorator)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**dialect** – Dialect instance in use.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Return a conversion function for processing literal values that are to be rendered
    directly without using binds.
  prefs: []
  type: TYPE_NORMAL
- en: This function is used when the compiler makes use of the “literal_binds” flag,
    typically used in DDL generation as well as in certain scenarios where backends
    don’t accept bound parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Returns a callable which will receive a literal Python value as the sole positional
    argument and will return a string representation to be rendered in a SQL statement.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This method is only called relative to a **dialect specific type object**, which
    is often **private to a dialect in use** and is not the same type object as the
    public facing one, which means it’s not feasible to subclass a [`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") class in order to provide an alternate [`TypeEngine.literal_processor()`](type_api.html#sqlalchemy.types.TypeEngine.literal_processor
    "sqlalchemy.types.TypeEngine.literal_processor") method, unless subclassing the
    [`UserDefinedType`](custom_types.html#sqlalchemy.types.UserDefinedType "sqlalchemy.types.UserDefinedType")
    class explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: To provide alternate behavior for [`TypeEngine.literal_processor()`](type_api.html#sqlalchemy.types.TypeEngine.literal_processor
    "sqlalchemy.types.TypeEngine.literal_processor"), implement a [`TypeDecorator`](custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") class and provide an implementation of [`TypeDecorator.process_literal_param()`](custom_types.html#sqlalchemy.types.TypeDecorator.process_literal_param
    "sqlalchemy.types.TypeDecorator.process_literal_param").
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Augmenting Existing Types](custom_types.html#types-typedecorator)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Return a conversion function for processing result row values.
  prefs: []
  type: TYPE_NORMAL
- en: Returns a callable which will receive a result row column value as the sole
    positional argument and will return a value to return to the user.
  prefs: []
  type: TYPE_NORMAL
- en: If processing is not necessary, the method should return `None`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This method is only called relative to a **dialect specific type object**, which
    is often **private to a dialect in use** and is not the same type object as the
    public facing one, which means it’s not feasible to subclass a [`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") class in order to provide an alternate [`TypeEngine.result_processor()`](type_api.html#sqlalchemy.types.TypeEngine.result_processor
    "sqlalchemy.types.TypeEngine.result_processor") method, unless subclassing the
    [`UserDefinedType`](custom_types.html#sqlalchemy.types.UserDefinedType "sqlalchemy.types.UserDefinedType")
    class explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: To provide alternate behavior for [`TypeEngine.result_processor()`](type_api.html#sqlalchemy.types.TypeEngine.result_processor
    "sqlalchemy.types.TypeEngine.result_processor"), implement a [`TypeDecorator`](custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") class and provide an implementation of [`TypeDecorator.process_result_value()`](custom_types.html#sqlalchemy.types.TypeDecorator.process_result_value
    "sqlalchemy.types.TypeDecorator.process_result_value").
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Augmenting Existing Types](custom_types.html#types-typedecorator)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dialect` – Dialect instance in use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`coltype` – DBAPI coltype argument received in cursor.description.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: A type for `datetime.date()` objects.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[get_dbapi_type()](#sqlalchemy.types.Date.get_dbapi_type), [literal_processor()](#sqlalchemy.types.Date.literal_processor),
    [python_type](#sqlalchemy.types.Date.python_type)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.types.Date`](#sqlalchemy.types.Date "sqlalchemy.types.Date")
    (`sqlalchemy.types._RenderISO8601NoT`, `sqlalchemy.types.HasExpressionLookup`,
    [`sqlalchemy.types.TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine "sqlalchemy.types.TypeEngine"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Return the corresponding type object from the underlying DB-API, if any.
  prefs: []
  type: TYPE_NORMAL
- en: This can be useful for calling `setinputsizes()`, for example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Return a conversion function for processing literal values that are to be rendered
    directly without using binds.
  prefs: []
  type: TYPE_NORMAL
- en: This function is used when the compiler makes use of the “literal_binds” flag,
    typically used in DDL generation as well as in certain scenarios where backends
    don’t accept bound parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Returns a callable which will receive a literal Python value as the sole positional
    argument and will return a string representation to be rendered in a SQL statement.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This method is only called relative to a **dialect specific type object**, which
    is often **private to a dialect in use** and is not the same type object as the
    public facing one, which means it’s not feasible to subclass a [`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") class in order to provide an alternate [`TypeEngine.literal_processor()`](type_api.html#sqlalchemy.types.TypeEngine.literal_processor
    "sqlalchemy.types.TypeEngine.literal_processor") method, unless subclassing the
    [`UserDefinedType`](custom_types.html#sqlalchemy.types.UserDefinedType "sqlalchemy.types.UserDefinedType")
    class explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: To provide alternate behavior for [`TypeEngine.literal_processor()`](type_api.html#sqlalchemy.types.TypeEngine.literal_processor
    "sqlalchemy.types.TypeEngine.literal_processor"), implement a [`TypeDecorator`](custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") class and provide an implementation of [`TypeDecorator.process_literal_param()`](custom_types.html#sqlalchemy.types.TypeDecorator.process_literal_param
    "sqlalchemy.types.TypeDecorator.process_literal_param").
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Augmenting Existing Types](custom_types.html#types-typedecorator)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: A type for `datetime.datetime()` objects.
  prefs: []
  type: TYPE_NORMAL
- en: Date and time types return objects from the Python `datetime` module. Most DBAPIs
    have built in support for the datetime module, with the noted exception of SQLite.
    In the case of SQLite, date and time types are stored as strings which are then
    converted back to datetime objects when rows are returned.
  prefs: []
  type: TYPE_NORMAL
- en: For the time representation within the datetime type, some backends include
    additional options, such as timezone support and fractional seconds support. For
    fractional seconds, use the dialect-specific datatype, such as [`TIME`](../dialects/mysql.html#sqlalchemy.dialects.mysql.TIME
    "sqlalchemy.dialects.mysql.TIME"). For timezone support, use at least the [`TIMESTAMP`](#sqlalchemy.types.TIMESTAMP
    "sqlalchemy.types.TIMESTAMP") datatype, if not the dialect-specific datatype object.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.types.DateTime.__init__), [get_dbapi_type()](#sqlalchemy.types.DateTime.get_dbapi_type),
    [literal_processor()](#sqlalchemy.types.DateTime.literal_processor), [python_type](#sqlalchemy.types.DateTime.python_type)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.types.DateTime`](#sqlalchemy.types.DateTime "sqlalchemy.types.DateTime")
    (`sqlalchemy.types._RenderISO8601NoT`, `sqlalchemy.types.HasExpressionLookup`,
    [`sqlalchemy.types.TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine "sqlalchemy.types.TypeEngine"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Construct a new [`DateTime`](#sqlalchemy.types.DateTime "sqlalchemy.types.DateTime").
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**timezone** – boolean. Indicates that the datetime type should enable timezone
    support, if available on the **base date/time-holding type only**. It is recommended
    to make use of the [`TIMESTAMP`](#sqlalchemy.types.TIMESTAMP "sqlalchemy.types.TIMESTAMP")
    datatype directly when using this flag, as some databases include separate generic
    date/time-holding types distinct from the timezone-capable TIMESTAMP datatype,
    such as Oracle.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Return the corresponding type object from the underlying DB-API, if any.
  prefs: []
  type: TYPE_NORMAL
- en: This can be useful for calling `setinputsizes()`, for example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Return a conversion function for processing literal values that are to be rendered
    directly without using binds.
  prefs: []
  type: TYPE_NORMAL
- en: This function is used when the compiler makes use of the “literal_binds” flag,
    typically used in DDL generation as well as in certain scenarios where backends
    don’t accept bound parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Returns a callable which will receive a literal Python value as the sole positional
    argument and will return a string representation to be rendered in a SQL statement.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This method is only called relative to a **dialect specific type object**, which
    is often **private to a dialect in use** and is not the same type object as the
    public facing one, which means it’s not feasible to subclass a [`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") class in order to provide an alternate [`TypeEngine.literal_processor()`](type_api.html#sqlalchemy.types.TypeEngine.literal_processor
    "sqlalchemy.types.TypeEngine.literal_processor") method, unless subclassing the
    [`UserDefinedType`](custom_types.html#sqlalchemy.types.UserDefinedType "sqlalchemy.types.UserDefinedType")
    class explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: To provide alternate behavior for [`TypeEngine.literal_processor()`](type_api.html#sqlalchemy.types.TypeEngine.literal_processor
    "sqlalchemy.types.TypeEngine.literal_processor"), implement a [`TypeDecorator`](custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") class and provide an implementation of [`TypeDecorator.process_literal_param()`](custom_types.html#sqlalchemy.types.TypeDecorator.process_literal_param
    "sqlalchemy.types.TypeDecorator.process_literal_param").
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Augmenting Existing Types](custom_types.html#types-typedecorator)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Generic Enum Type.
  prefs: []
  type: TYPE_NORMAL
- en: The [`Enum`](#sqlalchemy.types.Enum "sqlalchemy.types.Enum") type provides a
    set of possible string values which the column is constrained towards.
  prefs: []
  type: TYPE_NORMAL
- en: The [`Enum`](#sqlalchemy.types.Enum "sqlalchemy.types.Enum") type will make
    use of the backend’s native “ENUM” type if one is available; otherwise, it uses
    a VARCHAR datatype. An option also exists to automatically produce a CHECK constraint
    when the VARCHAR (so called “non-native”) variant is produced; see the [`Enum.create_constraint`](#sqlalchemy.types.Enum.params.create_constraint
    "sqlalchemy.types.Enum") flag.
  prefs: []
  type: TYPE_NORMAL
- en: The [`Enum`](#sqlalchemy.types.Enum "sqlalchemy.types.Enum") type also provides
    in-Python validation of string values during both read and write operations. When
    reading a value from the database in a result set, the string value is always
    checked against the list of possible values and a `LookupError` is raised if no
    match is found. When passing a value to the database as a plain string within
    a SQL statement, if the [`Enum.validate_strings`](#sqlalchemy.types.Enum.params.validate_strings
    "sqlalchemy.types.Enum") parameter is set to True, a `LookupError` is raised for
    any string value that’s not located in the given list of possible values; note
    that this impacts usage of LIKE expressions with enumerated values (an unusual
    use case).
  prefs: []
  type: TYPE_NORMAL
- en: The source of enumerated values may be a list of string values, or alternatively
    a PEP-435-compliant enumerated class. For the purposes of the [`Enum`](#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum") datatype, this class need only provide a `__members__`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using an enumerated class, the enumerated objects are used both for input
    and output, rather than strings as is the case with a plain-string enumerated
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Above, the string names of each element, e.g. “one”, “two”, “three”, are persisted
    to the database; the values of the Python Enum, here indicated as integers, are
    **not** used; the value of each enum can therefore be any kind of Python object
    whether or not it is persistable.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to persist the values and not the names, the [`Enum.values_callable`](#sqlalchemy.types.Enum.params.values_callable
    "sqlalchemy.types.Enum") parameter may be used. The value of this parameter is
    a user-supplied callable, which is intended to be used with a PEP-435-compliant
    enumerated class and returns a list of string values to be persisted. For a simple
    enumeration that uses string values, a callable such as `lambda x: [e.value for
    e in x]` is sufficient.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Using Python Enum or pep-586 Literal types in the type map](../orm/declarative_tables.html#orm-declarative-mapped-column-enums)
    - background on using the [`Enum`](#sqlalchemy.types.Enum "sqlalchemy.types.Enum")
    datatype with the ORM’s [ORM Annotated Declarative](../orm/declarative_tables.html#orm-declarative-mapped-column)
    feature.'
  prefs: []
  type: TYPE_NORMAL
- en: '[`ENUM`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ENUM "sqlalchemy.dialects.postgresql.ENUM")
    - PostgreSQL-specific type, which has additional functionality.'
  prefs: []
  type: TYPE_NORMAL
- en: '[`ENUM`](../dialects/mysql.html#sqlalchemy.dialects.mysql.ENUM "sqlalchemy.dialects.mysql.ENUM")
    - MySQL-specific type'
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.types.Enum.__init__), [create()](#sqlalchemy.types.Enum.create),
    [drop()](#sqlalchemy.types.Enum.drop)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.types.Enum`](#sqlalchemy.types.Enum "sqlalchemy.types.Enum")
    ([`sqlalchemy.types.String`](#sqlalchemy.types.String "sqlalchemy.types.String"),
    [`sqlalchemy.types.SchemaType`](#sqlalchemy.types.SchemaType "sqlalchemy.types.SchemaType"),
    `sqlalchemy.types.Emulated`, [`sqlalchemy.types.TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Construct an enum.
  prefs: []
  type: TYPE_NORMAL
- en: Keyword arguments which don’t apply to a specific backend are ignored by that
    backend.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`*enums` – either exactly one PEP-435 compliant enumerated type or one or more
    string labels.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`create_constraint` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: defaults to False. When creating a non-native enumerated type, also build a
    CHECK constraint on the database against the valid values.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: it is strongly recommended that the CHECK constraint have an explicit name in
    order to support schema-management concerns. This can be established either by
    setting the [`Enum.name`](#sqlalchemy.types.Enum.params.name "sqlalchemy.types.Enum")
    parameter or by setting up an appropriate naming convention; see [Configuring
    Constraint Naming Conventions](constraints.html#constraint-naming-conventions)
    for background.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Changed in version 1.4: - this flag now defaults to False, meaning no CHECK
    constraint is generated for a non-native enumerated type.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`metadata` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Associate this type directly with a `MetaData` object. For types that exist
    on the target database as an independent schema construct (PostgreSQL), this type
    will be created and dropped within `create_all()` and `drop_all()` operations.
    If the type is not associated with any `MetaData` object, it will associate itself
    with each `Table` in which it is used, and will be created when any of those individual
    tables are created, after a check is performed for its existence. The type is
    only dropped when `drop_all()` is called for that `Table` object’s metadata, however.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The value of the [`MetaData.schema`](metadata.html#sqlalchemy.schema.MetaData.params.schema
    "sqlalchemy.schema.MetaData") parameter of the [`MetaData`](metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") object, if set, will be used as the default value
    of the [`Enum.schema`](#sqlalchemy.types.Enum.params.schema "sqlalchemy.types.Enum")
    on this object if an explicit value is not otherwise supplied.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Changed in version 1.4.12: [`Enum`](#sqlalchemy.types.Enum "sqlalchemy.types.Enum")
    inherits the [`MetaData.schema`](metadata.html#sqlalchemy.schema.MetaData.params.schema
    "sqlalchemy.schema.MetaData") parameter of the [`MetaData`](metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") object if present, when passed using the [`Enum.metadata`](#sqlalchemy.types.Enum.params.metadata
    "sqlalchemy.types.Enum") parameter.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`name` – The name of this type. This is required for PostgreSQL and any future
    supported database which requires an explicitly named type, or an explicitly named
    constraint in order to generate the type and/or a table that uses it. If a PEP-435
    enumerated class was used, its name (converted to lower case) is used by default.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`native_enum` – Use the database’s native ENUM type when available. Defaults
    to True. When False, uses VARCHAR + check constraint for all backends. When False,
    the VARCHAR length can be controlled with [`Enum.length`](#sqlalchemy.types.Enum.params.length
    "sqlalchemy.types.Enum"); currently “length” is ignored if native_enum=True.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`length` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allows specifying a custom length for the VARCHAR when a non-native enumeration
    datatype is used. By default it uses the length of the longest value.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Changed in version 2.0.0: The [`Enum.length`](#sqlalchemy.types.Enum.params.length
    "sqlalchemy.types.Enum") parameter is used unconditionally for `VARCHAR` rendering
    regardless of the [`Enum.native_enum`](#sqlalchemy.types.Enum.params.native_enum
    "sqlalchemy.types.Enum") parameter, for those backends where `VARCHAR` is used
    for enumerated datatypes.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`schema` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Schema name of this type. For types that exist on the target database as an
    independent schema construct (PostgreSQL), this parameter specifies the named
    schema in which the type is present.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If not present, the schema name will be taken from the [`MetaData`](metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") collection if passed as [`Enum.metadata`](#sqlalchemy.types.Enum.params.metadata
    "sqlalchemy.types.Enum"), for a [`MetaData`](metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") that includes the [`MetaData.schema`](metadata.html#sqlalchemy.schema.MetaData.params.schema
    "sqlalchemy.schema.MetaData") parameter.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Changed in version 1.4.12: [`Enum`](#sqlalchemy.types.Enum "sqlalchemy.types.Enum")
    inherits the [`MetaData.schema`](metadata.html#sqlalchemy.schema.MetaData.params.schema
    "sqlalchemy.schema.MetaData") parameter of the [`MetaData`](metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") object if present, when passed using the [`Enum.metadata`](#sqlalchemy.types.Enum.params.metadata
    "sqlalchemy.types.Enum") parameter.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Otherwise, if the [`Enum.inherit_schema`](#sqlalchemy.types.Enum.params.inherit_schema
    "sqlalchemy.types.Enum") flag is set to `True`, the schema will be inherited from
    the associated [`Table`](metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    object if any; when [`Enum.inherit_schema`](#sqlalchemy.types.Enum.params.inherit_schema
    "sqlalchemy.types.Enum") is at its default of `False`, the owning table’s schema
    is **not** used.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`quote` – Set explicit quoting preferences for the type’s name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`inherit_schema` – When `True`, the “schema” from the owning [`Table`](metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") will be copied to the “schema” attribute of this [`Enum`](#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum"), replacing whatever value was passed for the `schema`
    attribute. This also takes effect when using the [`Table.to_metadata()`](metadata.html#sqlalchemy.schema.Table.to_metadata
    "sqlalchemy.schema.Table.to_metadata") operation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`validate_strings` – when True, string values that are being passed to the
    database in a SQL statement will be checked for validity against the list of enumerated
    values. Unrecognized values will result in a `LookupError` being raised.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`values_callable` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A callable which will be passed the PEP-435 compliant enumerated type, which
    should then return a list of string values to be persisted. This allows for alternate
    usages such as using the string value of an enum to be persisted to the database
    instead of its name. The callable must return the values to be persisted in the
    same order as iterating through the Enum’s `__member__` attribute. For example
    `lambda x: [i.value for i in x]`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: New in version 1.2.3.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`sort_key_function` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a Python callable which may be used as the “key” argument in the Python `sorted()`
    built-in. The SQLAlchemy ORM requires that primary key columns which are mapped
    must be sortable in some way. When using an unsortable enumeration object such
    as a Python 3 `Enum` object, this parameter may be used to set a default sort
    key function for the objects. By default, the database value of the enumeration
    is used as the sorting function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: New in version 1.3.8.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`omit_aliases` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A boolean that when true will remove aliases from pep 435 enums. defaults to
    `True`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Changed in version 2.0: This parameter now defaults to True.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`SchemaType.create()`](#sqlalchemy.types.SchemaType.create
    "sqlalchemy.types.SchemaType.create") *method of* [`SchemaType`](#sqlalchemy.types.SchemaType
    "sqlalchemy.types.SchemaType")'
  prefs: []
  type: TYPE_NORMAL
- en: Issue CREATE DDL for this type, if applicable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`SchemaType.drop()`](#sqlalchemy.types.SchemaType.drop
    "sqlalchemy.types.SchemaType.drop") *method of* [`SchemaType`](#sqlalchemy.types.SchemaType
    "sqlalchemy.types.SchemaType")'
  prefs: []
  type: TYPE_NORMAL
- en: Issue DROP DDL for this type, if applicable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: A type for double `FLOAT` floating point types.
  prefs: []
  type: TYPE_NORMAL
- en: Typically generates a `DOUBLE` or `DOUBLE_PRECISION` in DDL, and otherwise acts
    like a normal [`Float`](#sqlalchemy.types.Float "sqlalchemy.types.Float") on the
    Python side.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.types.Double`](#sqlalchemy.types.Double "sqlalchemy.types.Double")
    ([`sqlalchemy.types.Float`](#sqlalchemy.types.Float "sqlalchemy.types.Float"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Type representing floating point types, such as `FLOAT` or `REAL`.
  prefs: []
  type: TYPE_NORMAL
- en: This type returns Python `float` objects by default, unless the [`Float.asdecimal`](#sqlalchemy.types.Float.params.asdecimal
    "sqlalchemy.types.Float") flag is set to `True`, in which case they are coerced
    to `decimal.Decimal` objects.
  prefs: []
  type: TYPE_NORMAL
- en: When a [`Float.precision`](#sqlalchemy.types.Float.params.precision "sqlalchemy.types.Float")
    is not provided in a [`Float`](#sqlalchemy.types.Float "sqlalchemy.types.Float")
    type some backend may compile this type as an 8 bytes / 64 bit float datatype.
    To use a 4 bytes / 32 bit float datatype a precision <= 24 can usually be provided
    or the [`REAL`](#sqlalchemy.types.REAL "sqlalchemy.types.REAL") type can be used.
    This is known to be the case in the PostgreSQL and MSSQL dialects that render
    the type as `FLOAT` that’s in both an alias of `DOUBLE PRECISION`. Other third
    party dialects may have similar behavior.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.types.Float.__init__), [result_processor()](#sqlalchemy.types.Float.result_processor)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.types.Float`](#sqlalchemy.types.Float "sqlalchemy.types.Float")
    ([`sqlalchemy.types.Numeric`](#sqlalchemy.types.Numeric "sqlalchemy.types.Numeric"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Construct a Float.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`precision` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the numeric precision for use in DDL `CREATE TABLE`. Backends **should** attempt
    to ensure this precision indicates a number of digits for the generic [`Float`](#sqlalchemy.types.Float
    "sqlalchemy.types.Float") datatype.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For the Oracle backend, the [`Float.precision`](#sqlalchemy.types.Float.params.precision
    "sqlalchemy.types.Float") parameter is not accepted when rendering DDL, as Oracle
    does not support float precision specified as a number of decimal places. Instead,
    use the Oracle-specific [`FLOAT`](../dialects/oracle.html#sqlalchemy.dialects.oracle.FLOAT
    "sqlalchemy.dialects.oracle.FLOAT") datatype and specify the [`FLOAT.binary_precision`](../dialects/oracle.html#sqlalchemy.dialects.oracle.FLOAT.params.binary_precision
    "sqlalchemy.dialects.oracle.FLOAT") parameter. This is new in version 2.0 of SQLAlchemy.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To create a database agnostic [`Float`](#sqlalchemy.types.Float "sqlalchemy.types.Float")
    that separately specifies binary precision for Oracle, use [`TypeEngine.with_variant()`](type_api.html#sqlalchemy.types.TypeEngine.with_variant
    "sqlalchemy.types.TypeEngine.with_variant") as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`asdecimal` – the same flag as that of [`Numeric`](#sqlalchemy.types.Numeric
    "sqlalchemy.types.Numeric"), but defaults to `False`. Note that setting this flag
    to `True` results in floating point conversion.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`decimal_return_scale` – Default scale to use when converting from floats to
    Python decimals. Floating point values will typically be much longer due to decimal
    inaccuracy, and most floating point database types don’t have a notion of “scale”,
    so by default the float type looks for the first ten decimal places when converting.
    Specifying this value will override that length. Note that the MySQL float types,
    which do include “scale”, will use “scale” as the default for decimal_return_scale,
    if not otherwise specified.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Return a conversion function for processing result row values.
  prefs: []
  type: TYPE_NORMAL
- en: Returns a callable which will receive a result row column value as the sole
    positional argument and will return a value to return to the user.
  prefs: []
  type: TYPE_NORMAL
- en: If processing is not necessary, the method should return `None`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This method is only called relative to a **dialect specific type object**, which
    is often **private to a dialect in use** and is not the same type object as the
    public facing one, which means it’s not feasible to subclass a [`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") class in order to provide an alternate [`TypeEngine.result_processor()`](type_api.html#sqlalchemy.types.TypeEngine.result_processor
    "sqlalchemy.types.TypeEngine.result_processor") method, unless subclassing the
    [`UserDefinedType`](custom_types.html#sqlalchemy.types.UserDefinedType "sqlalchemy.types.UserDefinedType")
    class explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: To provide alternate behavior for [`TypeEngine.result_processor()`](type_api.html#sqlalchemy.types.TypeEngine.result_processor
    "sqlalchemy.types.TypeEngine.result_processor"), implement a [`TypeDecorator`](custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") class and provide an implementation of [`TypeDecorator.process_result_value()`](custom_types.html#sqlalchemy.types.TypeDecorator.process_result_value
    "sqlalchemy.types.TypeDecorator.process_result_value").
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Augmenting Existing Types](custom_types.html#types-typedecorator)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dialect` – Dialect instance in use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`coltype` – DBAPI coltype argument received in cursor.description.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: A type for `int` integers.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[get_dbapi_type()](#sqlalchemy.types.Integer.get_dbapi_type), [literal_processor()](#sqlalchemy.types.Integer.literal_processor),
    [python_type](#sqlalchemy.types.Integer.python_type)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.types.Integer`](#sqlalchemy.types.Integer "sqlalchemy.types.Integer")
    (`sqlalchemy.types.HasExpressionLookup`, [`sqlalchemy.types.TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Return the corresponding type object from the underlying DB-API, if any.
  prefs: []
  type: TYPE_NORMAL
- en: This can be useful for calling `setinputsizes()`, for example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Return a conversion function for processing literal values that are to be rendered
    directly without using binds.
  prefs: []
  type: TYPE_NORMAL
- en: This function is used when the compiler makes use of the “literal_binds” flag,
    typically used in DDL generation as well as in certain scenarios where backends
    don’t accept bound parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Returns a callable which will receive a literal Python value as the sole positional
    argument and will return a string representation to be rendered in a SQL statement.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This method is only called relative to a **dialect specific type object**, which
    is often **private to a dialect in use** and is not the same type object as the
    public facing one, which means it’s not feasible to subclass a [`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") class in order to provide an alternate [`TypeEngine.literal_processor()`](type_api.html#sqlalchemy.types.TypeEngine.literal_processor
    "sqlalchemy.types.TypeEngine.literal_processor") method, unless subclassing the
    [`UserDefinedType`](custom_types.html#sqlalchemy.types.UserDefinedType "sqlalchemy.types.UserDefinedType")
    class explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: To provide alternate behavior for [`TypeEngine.literal_processor()`](type_api.html#sqlalchemy.types.TypeEngine.literal_processor
    "sqlalchemy.types.TypeEngine.literal_processor"), implement a [`TypeDecorator`](custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") class and provide an implementation of [`TypeDecorator.process_literal_param()`](custom_types.html#sqlalchemy.types.TypeDecorator.process_literal_param
    "sqlalchemy.types.TypeDecorator.process_literal_param").
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Augmenting Existing Types](custom_types.html#types-typedecorator)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: A type for `datetime.timedelta()` objects.
  prefs: []
  type: TYPE_NORMAL
- en: The Interval type deals with `datetime.timedelta` objects. In PostgreSQL and
    Oracle, the native `INTERVAL` type is used; for others, the value is stored as
    a date which is relative to the “epoch” (Jan. 1, 1970).
  prefs: []
  type: TYPE_NORMAL
- en: Note that the `Interval` type does not currently provide date arithmetic operations
    on platforms which do not support interval types natively. Such operations usually
    require transformation of both sides of the expression (such as, conversion of
    both sides into integer epoch values first) which currently is a manual procedure
    (such as via [`expression.func`](sqlelement.html#sqlalchemy.sql.expression.func
    "sqlalchemy.sql.expression.func")).
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.types.Interval.__init__), [adapt_to_emulated()](#sqlalchemy.types.Interval.adapt_to_emulated),
    [bind_processor()](#sqlalchemy.types.Interval.bind_processor), [cache_ok](#sqlalchemy.types.Interval.cache_ok),
    [coerce_compared_value()](#sqlalchemy.types.Interval.coerce_compared_value), [comparator_factory](#sqlalchemy.types.Interval.comparator_factory),
    [impl](#sqlalchemy.types.Interval.impl), [python_type](#sqlalchemy.types.Interval.python_type),
    [result_processor()](#sqlalchemy.types.Interval.result_processor)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.types.Interval`](#sqlalchemy.types.Interval "sqlalchemy.types.Interval")
    (`sqlalchemy.types.Emulated`, `sqlalchemy.types._AbstractInterval`, [`sqlalchemy.types.TypeDecorator`](custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.types.Interval.Comparator`](#sqlalchemy.types.Interval.Comparator
    "sqlalchemy.types.Interval.Comparator") (`sqlalchemy.types.Comparator`, `sqlalchemy.types.Comparator`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Construct an Interval object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`native` – when True, use the actual INTERVAL type provided by the database,
    if supported (currently PostgreSQL, Oracle). Otherwise, represent the interval
    data as an epoch value regardless.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`second_precision` – For native interval types which support a “fractional
    seconds precision” parameter, i.e. Oracle and PostgreSQL'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`day_precision` – for native interval types which support a “day precision”
    parameter, i.e. Oracle.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Given an impl class, adapt this type to the impl assuming “emulated”.
  prefs: []
  type: TYPE_NORMAL
- en: The impl should also be an “emulated” version of this type, most likely the
    same class as this type itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'e.g.: sqltypes.Enum adapts to the Enum class.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Return a conversion function for processing bind values.
  prefs: []
  type: TYPE_NORMAL
- en: Returns a callable which will receive a bind parameter value as the sole positional
    argument and will return a value to send to the DB-API.
  prefs: []
  type: TYPE_NORMAL
- en: If processing is not necessary, the method should return `None`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This method is only called relative to a **dialect specific type object**, which
    is often **private to a dialect in use** and is not the same type object as the
    public facing one, which means it’s not feasible to subclass a [`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") class in order to provide an alternate [`TypeEngine.bind_processor()`](type_api.html#sqlalchemy.types.TypeEngine.bind_processor
    "sqlalchemy.types.TypeEngine.bind_processor") method, unless subclassing the [`UserDefinedType`](custom_types.html#sqlalchemy.types.UserDefinedType
    "sqlalchemy.types.UserDefinedType") class explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: To provide alternate behavior for [`TypeEngine.bind_processor()`](type_api.html#sqlalchemy.types.TypeEngine.bind_processor
    "sqlalchemy.types.TypeEngine.bind_processor"), implement a [`TypeDecorator`](custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") class and provide an implementation of [`TypeDecorator.process_bind_param()`](custom_types.html#sqlalchemy.types.TypeDecorator.process_bind_param
    "sqlalchemy.types.TypeDecorator.process_bind_param").
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Augmenting Existing Types](custom_types.html#types-typedecorator)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**dialect** – Dialect instance in use.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Indicate if statements using this [`ExternalType`](type_api.html#sqlalchemy.types.ExternalType
    "sqlalchemy.types.ExternalType") are “safe to cache”.
  prefs: []
  type: TYPE_NORMAL
- en: 'The default value `None` will emit a warning and then not allow caching of
    a statement which includes this type. Set to `False` to disable statements using
    this type from being cached at all without a warning. When set to `True`, the
    object’s class and selected elements from its state will be used as part of the
    cache key. For example, using a [`TypeDecorator`](custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The cache key for the above type would be equivalent to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The caching scheme will extract attributes from the type that correspond to
    the names of parameters in the `__init__()` method. Above, the “choices” attribute
    becomes part of the cache key but “internal_only” does not, because there is no
    parameter named “internal_only”.
  prefs: []
  type: TYPE_NORMAL
- en: The requirements for cacheable elements is that they are hashable and also that
    they indicate the same SQL rendered for expressions using this type every time
    for a given cache value.
  prefs: []
  type: TYPE_NORMAL
- en: 'To accommodate for datatypes that refer to unhashable structures such as dictionaries,
    sets and lists, these objects can be made “cacheable” by assigning hashable structures
    to the attributes whose names correspond with the names of the arguments. For
    example, a datatype which accepts a dictionary of lookup values may publish this
    as a sorted series of tuples. Given a previously un-cacheable type as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Where “lookup” is a dictionary. The type will not be able to generate a cache
    key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'If we **did** set up such a cache key, it wouldn’t be usable. We would get
    a tuple structure that contains a dictionary inside of it, which cannot itself
    be used as a key in a “cache dictionary” such as SQLAlchemy’s statement cache,
    since Python dictionaries aren’t hashable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The type may be made cacheable by assigning a sorted tuple of tuples to the
    “.lookup” attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Where above, the cache key for `LookupType({"a": 10, "b": 20})` will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'New in version 1.4.14: - added the `cache_ok` flag to allow some configurability
    of caching for [`TypeDecorator`](custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") classes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 1.4.28: - added the [`ExternalType`](type_api.html#sqlalchemy.types.ExternalType
    "sqlalchemy.types.ExternalType") mixin which generalizes the `cache_ok` flag to
    both the [`TypeDecorator`](custom_types.html#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")
    and [`UserDefinedType`](custom_types.html#sqlalchemy.types.UserDefinedType "sqlalchemy.types.UserDefinedType")
    classes.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[SQL Compilation Caching](connections.html#sql-caching)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Suggest a type for a ‘coerced’ Python value in an expression.
  prefs: []
  type: TYPE_NORMAL
- en: Given an operator and value, gives the type a chance to return a type which
    the value should be coerced into.
  prefs: []
  type: TYPE_NORMAL
- en: The default behavior here is conservative; if the right-hand side is already
    coerced into a SQL type based on its Python type, it is usually left alone.
  prefs: []
  type: TYPE_NORMAL
- en: End-user functionality extension here should generally be via [`TypeDecorator`](custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator"), which provides more liberal behavior in that
    it defaults to coercing the other side of the expression into this type, thus
    applying special Python conversions above and beyond those needed by the DBAPI
    to both ides. It also provides the public method [`TypeDecorator.coerce_compared_value()`](custom_types.html#sqlalchemy.types.TypeDecorator.coerce_compared_value
    "sqlalchemy.types.TypeDecorator.coerce_compared_value") which is intended for
    end-user customization of this behavior.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: alias of [`Comparator`](#sqlalchemy.types.Interval.Comparator "sqlalchemy.sql.sqltypes.Interval.Comparator")
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: alias of [`DateTime`](#sqlalchemy.types.DateTime "sqlalchemy.sql.sqltypes.DateTime")
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Return a conversion function for processing result row values.
  prefs: []
  type: TYPE_NORMAL
- en: Returns a callable which will receive a result row column value as the sole
    positional argument and will return a value to return to the user.
  prefs: []
  type: TYPE_NORMAL
- en: If processing is not necessary, the method should return `None`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This method is only called relative to a **dialect specific type object**, which
    is often **private to a dialect in use** and is not the same type object as the
    public facing one, which means it’s not feasible to subclass a [`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") class in order to provide an alternate [`TypeEngine.result_processor()`](type_api.html#sqlalchemy.types.TypeEngine.result_processor
    "sqlalchemy.types.TypeEngine.result_processor") method, unless subclassing the
    [`UserDefinedType`](custom_types.html#sqlalchemy.types.UserDefinedType "sqlalchemy.types.UserDefinedType")
    class explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: To provide alternate behavior for [`TypeEngine.result_processor()`](type_api.html#sqlalchemy.types.TypeEngine.result_processor
    "sqlalchemy.types.TypeEngine.result_processor"), implement a [`TypeDecorator`](custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") class and provide an implementation of [`TypeDecorator.process_result_value()`](custom_types.html#sqlalchemy.types.TypeDecorator.process_result_value
    "sqlalchemy.types.TypeDecorator.process_result_value").
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Augmenting Existing Types](custom_types.html#types-typedecorator)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dialect` – Dialect instance in use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`coltype` – DBAPI coltype argument received in cursor.description.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: A type for large binary byte data.
  prefs: []
  type: TYPE_NORMAL
- en: The [`LargeBinary`](#sqlalchemy.types.LargeBinary "sqlalchemy.types.LargeBinary")
    type corresponds to a large and/or unlengthed binary type for the target platform,
    such as BLOB on MySQL and BYTEA for PostgreSQL. It also handles the necessary
    conversions for the DBAPI.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.types.LargeBinary.__init__)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.types.LargeBinary`](#sqlalchemy.types.LargeBinary "sqlalchemy.types.LargeBinary")
    (`sqlalchemy.types._Binary`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Construct a LargeBinary type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**length** – optional, a length for the column for use in DDL statements, for
    those binary types that accept a length, such as the MySQL BLOB type.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Refers to the return type of the MATCH operator.
  prefs: []
  type: TYPE_NORMAL
- en: As the [`ColumnOperators.match()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.match
    "sqlalchemy.sql.expression.ColumnOperators.match") is probably the most open-ended
    operator in generic SQLAlchemy Core, we can’t assume the return type at SQL evaluation
    time, as MySQL returns a floating point, not a boolean, and other backends might
    do something different. So this type acts as a placeholder, currently subclassing
    [`Boolean`](#sqlalchemy.types.Boolean "sqlalchemy.types.Boolean"). The type allows
    dialects to inject result-processing functionality if needed, and on MySQL will
    return floating-point values.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.types.MatchType`](#sqlalchemy.types.MatchType "sqlalchemy.types.MatchType")
    ([`sqlalchemy.types.Boolean`](#sqlalchemy.types.Boolean "sqlalchemy.types.Boolean"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Base for non-integer numeric types, such as `NUMERIC`, `FLOAT`, `DECIMAL`, and
    other variants.
  prefs: []
  type: TYPE_NORMAL
- en: The [`Numeric`](#sqlalchemy.types.Numeric "sqlalchemy.types.Numeric") datatype
    when used directly will render DDL corresponding to precision numerics if available,
    such as `NUMERIC(precision, scale)`. The [`Float`](#sqlalchemy.types.Float "sqlalchemy.types.Float")
    subclass will attempt to render a floating-point datatype such as `FLOAT(precision)`.
  prefs: []
  type: TYPE_NORMAL
- en: '[`Numeric`](#sqlalchemy.types.Numeric "sqlalchemy.types.Numeric") returns Python
    `decimal.Decimal` objects by default, based on the default value of `True` for
    the [`Numeric.asdecimal`](#sqlalchemy.types.Numeric.params.asdecimal "sqlalchemy.types.Numeric")
    parameter. If this parameter is set to False, returned values are coerced to Python
    `float` objects.'
  prefs: []
  type: TYPE_NORMAL
- en: The [`Float`](#sqlalchemy.types.Float "sqlalchemy.types.Float") subtype, being
    more specific to floating point, defaults the [`Float.asdecimal`](#sqlalchemy.types.Float.params.asdecimal
    "sqlalchemy.types.Float") flag to False so that the default Python datatype is
    `float`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: When using a [`Numeric`](#sqlalchemy.types.Numeric "sqlalchemy.types.Numeric")
    datatype against a database type that returns Python floating point values to
    the driver, the accuracy of the decimal conversion indicated by [`Numeric.asdecimal`](#sqlalchemy.types.Numeric.params.asdecimal
    "sqlalchemy.types.Numeric") may be limited. The behavior of specific numeric/floating
    point datatypes is a product of the SQL datatype in use, the Python [DBAPI](../glossary.html#term-DBAPI)
    in use, as well as strategies that may be present within the SQLAlchemy dialect
    in use. Users requiring specific precision/ scale are encouraged to experiment
    with the available datatypes in order to determine the best results.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.types.Numeric.__init__), [bind_processor()](#sqlalchemy.types.Numeric.bind_processor),
    [get_dbapi_type()](#sqlalchemy.types.Numeric.get_dbapi_type), [literal_processor()](#sqlalchemy.types.Numeric.literal_processor),
    [python_type](#sqlalchemy.types.Numeric.python_type), [result_processor()](#sqlalchemy.types.Numeric.result_processor)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.types.Numeric`](#sqlalchemy.types.Numeric "sqlalchemy.types.Numeric")
    (`sqlalchemy.types.HasExpressionLookup`, [`sqlalchemy.types.TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Construct a Numeric.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`precision` – the numeric precision for use in DDL `CREATE TABLE`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scale` – the numeric scale for use in DDL `CREATE TABLE`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`asdecimal` – default True. Return whether or not values should be sent as
    Python Decimal objects, or as floats. Different DBAPIs send one or the other based
    on datatypes - the Numeric type will ensure that return values are one or the
    other across DBAPIs consistently.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`decimal_return_scale` – Default scale to use when converting from floats to
    Python decimals. Floating point values will typically be much longer due to decimal
    inaccuracy, and most floating point database types don’t have a notion of “scale”,
    so by default the float type looks for the first ten decimal places when converting.
    Specifying this value will override that length. Types which do include an explicit
    “.scale” value, such as the base [`Numeric`](#sqlalchemy.types.Numeric "sqlalchemy.types.Numeric")
    as well as the MySQL float types, will use the value of “.scale” as the default
    for decimal_return_scale, if not otherwise specified.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When using the `Numeric` type, care should be taken to ensure that the asdecimal
    setting is appropriate for the DBAPI in use - when Numeric applies a conversion
    from Decimal->float or float-> Decimal, this conversion incurs an additional performance
    overhead for all result columns received.
  prefs: []
  type: TYPE_NORMAL
- en: DBAPIs that return Decimal natively (e.g. psycopg2) will have better accuracy
    and higher performance with a setting of `True`, as the native translation to
    Decimal reduces the amount of floating- point issues at play, and the Numeric
    type itself doesn’t need to apply any further conversions. However, another DBAPI
    which returns floats natively *will* incur an additional conversion overhead,
    and is still subject to floating point data loss - in which case `asdecimal=False`
    will at least remove the extra conversion overhead.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Return a conversion function for processing bind values.
  prefs: []
  type: TYPE_NORMAL
- en: Returns a callable which will receive a bind parameter value as the sole positional
    argument and will return a value to send to the DB-API.
  prefs: []
  type: TYPE_NORMAL
- en: If processing is not necessary, the method should return `None`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This method is only called relative to a **dialect specific type object**, which
    is often **private to a dialect in use** and is not the same type object as the
    public facing one, which means it’s not feasible to subclass a [`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") class in order to provide an alternate [`TypeEngine.bind_processor()`](type_api.html#sqlalchemy.types.TypeEngine.bind_processor
    "sqlalchemy.types.TypeEngine.bind_processor") method, unless subclassing the [`UserDefinedType`](custom_types.html#sqlalchemy.types.UserDefinedType
    "sqlalchemy.types.UserDefinedType") class explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: To provide alternate behavior for [`TypeEngine.bind_processor()`](type_api.html#sqlalchemy.types.TypeEngine.bind_processor
    "sqlalchemy.types.TypeEngine.bind_processor"), implement a [`TypeDecorator`](custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") class and provide an implementation of [`TypeDecorator.process_bind_param()`](custom_types.html#sqlalchemy.types.TypeDecorator.process_bind_param
    "sqlalchemy.types.TypeDecorator.process_bind_param").
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Augmenting Existing Types](custom_types.html#types-typedecorator)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**dialect** – Dialect instance in use.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Return the corresponding type object from the underlying DB-API, if any.
  prefs: []
  type: TYPE_NORMAL
- en: This can be useful for calling `setinputsizes()`, for example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Return a conversion function for processing literal values that are to be rendered
    directly without using binds.
  prefs: []
  type: TYPE_NORMAL
- en: This function is used when the compiler makes use of the “literal_binds” flag,
    typically used in DDL generation as well as in certain scenarios where backends
    don’t accept bound parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Returns a callable which will receive a literal Python value as the sole positional
    argument and will return a string representation to be rendered in a SQL statement.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This method is only called relative to a **dialect specific type object**, which
    is often **private to a dialect in use** and is not the same type object as the
    public facing one, which means it’s not feasible to subclass a [`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") class in order to provide an alternate [`TypeEngine.literal_processor()`](type_api.html#sqlalchemy.types.TypeEngine.literal_processor
    "sqlalchemy.types.TypeEngine.literal_processor") method, unless subclassing the
    [`UserDefinedType`](custom_types.html#sqlalchemy.types.UserDefinedType "sqlalchemy.types.UserDefinedType")
    class explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: To provide alternate behavior for [`TypeEngine.literal_processor()`](type_api.html#sqlalchemy.types.TypeEngine.literal_processor
    "sqlalchemy.types.TypeEngine.literal_processor"), implement a [`TypeDecorator`](custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") class and provide an implementation of [`TypeDecorator.process_literal_param()`](custom_types.html#sqlalchemy.types.TypeDecorator.process_literal_param
    "sqlalchemy.types.TypeDecorator.process_literal_param").
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Augmenting Existing Types](custom_types.html#types-typedecorator)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Return a conversion function for processing result row values.
  prefs: []
  type: TYPE_NORMAL
- en: Returns a callable which will receive a result row column value as the sole
    positional argument and will return a value to return to the user.
  prefs: []
  type: TYPE_NORMAL
- en: If processing is not necessary, the method should return `None`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This method is only called relative to a **dialect specific type object**, which
    is often **private to a dialect in use** and is not the same type object as the
    public facing one, which means it’s not feasible to subclass a [`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") class in order to provide an alternate [`TypeEngine.result_processor()`](type_api.html#sqlalchemy.types.TypeEngine.result_processor
    "sqlalchemy.types.TypeEngine.result_processor") method, unless subclassing the
    [`UserDefinedType`](custom_types.html#sqlalchemy.types.UserDefinedType "sqlalchemy.types.UserDefinedType")
    class explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: To provide alternate behavior for [`TypeEngine.result_processor()`](type_api.html#sqlalchemy.types.TypeEngine.result_processor
    "sqlalchemy.types.TypeEngine.result_processor"), implement a [`TypeDecorator`](custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") class and provide an implementation of [`TypeDecorator.process_result_value()`](custom_types.html#sqlalchemy.types.TypeDecorator.process_result_value
    "sqlalchemy.types.TypeDecorator.process_result_value").
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Augmenting Existing Types](custom_types.html#types-typedecorator)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dialect` – Dialect instance in use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`coltype` – DBAPI coltype argument received in cursor.description.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Holds Python objects, which are serialized using pickle.
  prefs: []
  type: TYPE_NORMAL
- en: PickleType builds upon the Binary type to apply Python’s `pickle.dumps()` to
    incoming objects, and `pickle.loads()` on the way out, allowing any pickleable
    Python object to be stored as a serialized binary field.
  prefs: []
  type: TYPE_NORMAL
- en: To allow ORM change events to propagate for elements associated with [`PickleType`](#sqlalchemy.types.PickleType
    "sqlalchemy.types.PickleType"), see [Mutation Tracking](../orm/extensions/mutable.html).
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.types.PickleType.__init__), [bind_processor()](#sqlalchemy.types.PickleType.bind_processor),
    [cache_ok](#sqlalchemy.types.PickleType.cache_ok), [compare_values()](#sqlalchemy.types.PickleType.compare_values),
    [impl](#sqlalchemy.types.PickleType.impl), [result_processor()](#sqlalchemy.types.PickleType.result_processor)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.types.PickleType`](#sqlalchemy.types.PickleType "sqlalchemy.types.PickleType")
    ([`sqlalchemy.types.TypeDecorator`](custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Construct a PickleType.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`protocol` – defaults to `pickle.HIGHEST_PROTOCOL`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pickler` – defaults to pickle. May be any object with pickle-compatible `dumps`
    and `loads` methods.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`comparator` – a 2-arg callable predicate used to compare values of this type.
    If left as `None`, the Python “equals” operator is used to compare values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`impl` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A binary-storing [`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine "sqlalchemy.types.TypeEngine")
    class or instance to use in place of the default [`LargeBinary`](#sqlalchemy.types.LargeBinary
    "sqlalchemy.types.LargeBinary"). For example the :class: _mysql.LONGBLOB class
    may be more effective when using MySQL.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: New in version 1.4.20.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Provide a bound value processing function for the given [`Dialect`](internals.html#sqlalchemy.engine.Dialect
    "sqlalchemy.engine.Dialect").
  prefs: []
  type: TYPE_NORMAL
- en: This is the method that fulfills the [`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") contract for bound value conversion which normally
    occurs via the [`TypeEngine.bind_processor()`](type_api.html#sqlalchemy.types.TypeEngine.bind_processor
    "sqlalchemy.types.TypeEngine.bind_processor") method.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: User-defined subclasses of [`TypeDecorator`](custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") should **not** implement this method, and should
    instead implement [`TypeDecorator.process_bind_param()`](custom_types.html#sqlalchemy.types.TypeDecorator.process_bind_param
    "sqlalchemy.types.TypeDecorator.process_bind_param") so that the “inner” processing
    provided by the implementing type is maintained.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**dialect** – Dialect instance in use.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Indicate if statements using this [`ExternalType`](type_api.html#sqlalchemy.types.ExternalType
    "sqlalchemy.types.ExternalType") are “safe to cache”.
  prefs: []
  type: TYPE_NORMAL
- en: 'The default value `None` will emit a warning and then not allow caching of
    a statement which includes this type. Set to `False` to disable statements using
    this type from being cached at all without a warning. When set to `True`, the
    object’s class and selected elements from its state will be used as part of the
    cache key. For example, using a [`TypeDecorator`](custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The cache key for the above type would be equivalent to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: The caching scheme will extract attributes from the type that correspond to
    the names of parameters in the `__init__()` method. Above, the “choices” attribute
    becomes part of the cache key but “internal_only” does not, because there is no
    parameter named “internal_only”.
  prefs: []
  type: TYPE_NORMAL
- en: The requirements for cacheable elements is that they are hashable and also that
    they indicate the same SQL rendered for expressions using this type every time
    for a given cache value.
  prefs: []
  type: TYPE_NORMAL
- en: 'To accommodate for datatypes that refer to unhashable structures such as dictionaries,
    sets and lists, these objects can be made “cacheable” by assigning hashable structures
    to the attributes whose names correspond with the names of the arguments. For
    example, a datatype which accepts a dictionary of lookup values may publish this
    as a sorted series of tuples. Given a previously un-cacheable type as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Where “lookup” is a dictionary. The type will not be able to generate a cache
    key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'If we **did** set up such a cache key, it wouldn’t be usable. We would get
    a tuple structure that contains a dictionary inside of it, which cannot itself
    be used as a key in a “cache dictionary” such as SQLAlchemy’s statement cache,
    since Python dictionaries aren’t hashable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'The type may be made cacheable by assigning a sorted tuple of tuples to the
    “.lookup” attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Where above, the cache key for `LookupType({"a": 10, "b": 20})` will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'New in version 1.4.14: - added the `cache_ok` flag to allow some configurability
    of caching for [`TypeDecorator`](custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") classes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 1.4.28: - added the [`ExternalType`](type_api.html#sqlalchemy.types.ExternalType
    "sqlalchemy.types.ExternalType") mixin which generalizes the `cache_ok` flag to
    both the [`TypeDecorator`](custom_types.html#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")
    and [`UserDefinedType`](custom_types.html#sqlalchemy.types.UserDefinedType "sqlalchemy.types.UserDefinedType")
    classes.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[SQL Compilation Caching](connections.html#sql-caching)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Given two values, compare them for equality.
  prefs: []
  type: TYPE_NORMAL
- en: By default this calls upon [`TypeEngine.compare_values()`](type_api.html#sqlalchemy.types.TypeEngine.compare_values
    "sqlalchemy.types.TypeEngine.compare_values") of the underlying “impl”, which
    in turn usually uses the Python equals operator `==`.
  prefs: []
  type: TYPE_NORMAL
- en: This function is used by the ORM to compare an original-loaded value with an
    intercepted “changed” value, to determine if a net change has occurred.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: alias of [`LargeBinary`](#sqlalchemy.types.LargeBinary "sqlalchemy.sql.sqltypes.LargeBinary")
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Provide a result value processing function for the given [`Dialect`](internals.html#sqlalchemy.engine.Dialect
    "sqlalchemy.engine.Dialect").
  prefs: []
  type: TYPE_NORMAL
- en: This is the method that fulfills the [`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") contract for bound value conversion which normally
    occurs via the [`TypeEngine.result_processor()`](type_api.html#sqlalchemy.types.TypeEngine.result_processor
    "sqlalchemy.types.TypeEngine.result_processor") method.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: User-defined subclasses of [`TypeDecorator`](custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") should **not** implement this method, and should
    instead implement [`TypeDecorator.process_result_value()`](custom_types.html#sqlalchemy.types.TypeDecorator.process_result_value
    "sqlalchemy.types.TypeDecorator.process_result_value") so that the “inner” processing
    provided by the implementing type is maintained.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dialect` – Dialect instance in use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`coltype` – A SQLAlchemy data type'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Add capabilities to a type which allow for schema-level DDL to be associated
    with a type.
  prefs: []
  type: TYPE_NORMAL
- en: Supports types that must be explicitly created/dropped (i.e. PG ENUM type) as
    well as types that are complimented by table or schema level constraints, triggers,
    and other rules.
  prefs: []
  type: TYPE_NORMAL
- en: '[`SchemaType`](#sqlalchemy.types.SchemaType "sqlalchemy.types.SchemaType")
    classes can also be targets for the [`DDLEvents.before_parent_attach()`](events.html#sqlalchemy.events.DDLEvents.before_parent_attach
    "sqlalchemy.events.DDLEvents.before_parent_attach") and [`DDLEvents.after_parent_attach()`](events.html#sqlalchemy.events.DDLEvents.after_parent_attach
    "sqlalchemy.events.DDLEvents.after_parent_attach") events, where the events fire
    off surrounding the association of the type object with a parent [`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column").'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Enum`](#sqlalchemy.types.Enum "sqlalchemy.types.Enum")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Boolean`](#sqlalchemy.types.Boolean "sqlalchemy.types.Boolean")'
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[adapt()](#sqlalchemy.types.SchemaType.adapt), [copy()](#sqlalchemy.types.SchemaType.copy),
    [create()](#sqlalchemy.types.SchemaType.create), [drop()](#sqlalchemy.types.SchemaType.drop),
    [name](#sqlalchemy.types.SchemaType.name)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.types.SchemaType`](#sqlalchemy.types.SchemaType "sqlalchemy.types.SchemaType")
    (`sqlalchemy.sql.expression.SchemaEventTarget`, `sqlalchemy.types.TypeEngineMixin`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Issue CREATE DDL for this type, if applicable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Issue DROP DDL for this type, if applicable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: A type for smaller `int` integers.
  prefs: []
  type: TYPE_NORMAL
- en: Typically generates a `SMALLINT` in DDL, and otherwise acts like a normal [`Integer`](#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer") on the Python side.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.types.SmallInteger`](#sqlalchemy.types.SmallInteger "sqlalchemy.types.SmallInteger")
    ([`sqlalchemy.types.Integer`](#sqlalchemy.types.Integer "sqlalchemy.types.Integer"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: The base for all string and character types.
  prefs: []
  type: TYPE_NORMAL
- en: In SQL, corresponds to VARCHAR.
  prefs: []
  type: TYPE_NORMAL
- en: The length field is usually required when the String type is used within a CREATE
    TABLE statement, as VARCHAR requires a length on most databases.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.types.String.__init__), [bind_processor()](#sqlalchemy.types.String.bind_processor),
    [get_dbapi_type()](#sqlalchemy.types.String.get_dbapi_type), [literal_processor()](#sqlalchemy.types.String.literal_processor),
    [python_type](#sqlalchemy.types.String.python_type), [result_processor()](#sqlalchemy.types.String.result_processor)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.types.String`](#sqlalchemy.types.String "sqlalchemy.types.String")
    ([`sqlalchemy.types.Concatenable`](type_api.html#sqlalchemy.types.Concatenable
    "sqlalchemy.types.Concatenable"), [`sqlalchemy.types.TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Create a string-holding type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`length` – optional, a length for the column for use in DDL and CAST expressions.
    May be safely omitted if no `CREATE TABLE` will be issued. Certain databases may
    require a `length` for use in DDL, and will raise an exception when the `CREATE
    TABLE` DDL is issued if a `VARCHAR` with no length is included. Whether the value
    is interpreted as bytes or characters is database specific.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`collation` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Optional, a column-level collation for use in DDL and CAST expressions. Renders
    using the COLLATE keyword supported by SQLite, MySQL, and PostgreSQL. E.g.:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In most cases, the [`Unicode`](#sqlalchemy.types.Unicode "sqlalchemy.types.Unicode")
    or [`UnicodeText`](#sqlalchemy.types.UnicodeText "sqlalchemy.types.UnicodeText")
    datatypes should be used for a [`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") that expects to store non-ascii data. These datatypes
    will ensure that the correct types are used on the database.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Return a conversion function for processing bind values.
  prefs: []
  type: TYPE_NORMAL
- en: Returns a callable which will receive a bind parameter value as the sole positional
    argument and will return a value to send to the DB-API.
  prefs: []
  type: TYPE_NORMAL
- en: If processing is not necessary, the method should return `None`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This method is only called relative to a **dialect specific type object**, which
    is often **private to a dialect in use** and is not the same type object as the
    public facing one, which means it’s not feasible to subclass a [`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") class in order to provide an alternate [`TypeEngine.bind_processor()`](type_api.html#sqlalchemy.types.TypeEngine.bind_processor
    "sqlalchemy.types.TypeEngine.bind_processor") method, unless subclassing the [`UserDefinedType`](custom_types.html#sqlalchemy.types.UserDefinedType
    "sqlalchemy.types.UserDefinedType") class explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: To provide alternate behavior for [`TypeEngine.bind_processor()`](type_api.html#sqlalchemy.types.TypeEngine.bind_processor
    "sqlalchemy.types.TypeEngine.bind_processor"), implement a [`TypeDecorator`](custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") class and provide an implementation of [`TypeDecorator.process_bind_param()`](custom_types.html#sqlalchemy.types.TypeDecorator.process_bind_param
    "sqlalchemy.types.TypeDecorator.process_bind_param").
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Augmenting Existing Types](custom_types.html#types-typedecorator)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**dialect** – Dialect instance in use.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Return the corresponding type object from the underlying DB-API, if any.
  prefs: []
  type: TYPE_NORMAL
- en: This can be useful for calling `setinputsizes()`, for example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Return a conversion function for processing literal values that are to be rendered
    directly without using binds.
  prefs: []
  type: TYPE_NORMAL
- en: This function is used when the compiler makes use of the “literal_binds” flag,
    typically used in DDL generation as well as in certain scenarios where backends
    don’t accept bound parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Returns a callable which will receive a literal Python value as the sole positional
    argument and will return a string representation to be rendered in a SQL statement.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This method is only called relative to a **dialect specific type object**, which
    is often **private to a dialect in use** and is not the same type object as the
    public facing one, which means it’s not feasible to subclass a [`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") class in order to provide an alternate [`TypeEngine.literal_processor()`](type_api.html#sqlalchemy.types.TypeEngine.literal_processor
    "sqlalchemy.types.TypeEngine.literal_processor") method, unless subclassing the
    [`UserDefinedType`](custom_types.html#sqlalchemy.types.UserDefinedType "sqlalchemy.types.UserDefinedType")
    class explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: To provide alternate behavior for [`TypeEngine.literal_processor()`](type_api.html#sqlalchemy.types.TypeEngine.literal_processor
    "sqlalchemy.types.TypeEngine.literal_processor"), implement a [`TypeDecorator`](custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") class and provide an implementation of [`TypeDecorator.process_literal_param()`](custom_types.html#sqlalchemy.types.TypeDecorator.process_literal_param
    "sqlalchemy.types.TypeDecorator.process_literal_param").
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Augmenting Existing Types](custom_types.html#types-typedecorator)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: Return a conversion function for processing result row values.
  prefs: []
  type: TYPE_NORMAL
- en: Returns a callable which will receive a result row column value as the sole
    positional argument and will return a value to return to the user.
  prefs: []
  type: TYPE_NORMAL
- en: If processing is not necessary, the method should return `None`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This method is only called relative to a **dialect specific type object**, which
    is often **private to a dialect in use** and is not the same type object as the
    public facing one, which means it’s not feasible to subclass a [`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") class in order to provide an alternate [`TypeEngine.result_processor()`](type_api.html#sqlalchemy.types.TypeEngine.result_processor
    "sqlalchemy.types.TypeEngine.result_processor") method, unless subclassing the
    [`UserDefinedType`](custom_types.html#sqlalchemy.types.UserDefinedType "sqlalchemy.types.UserDefinedType")
    class explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: To provide alternate behavior for [`TypeEngine.result_processor()`](type_api.html#sqlalchemy.types.TypeEngine.result_processor
    "sqlalchemy.types.TypeEngine.result_processor"), implement a [`TypeDecorator`](custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") class and provide an implementation of [`TypeDecorator.process_result_value()`](custom_types.html#sqlalchemy.types.TypeDecorator.process_result_value
    "sqlalchemy.types.TypeDecorator.process_result_value").
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Augmenting Existing Types](custom_types.html#types-typedecorator)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dialect` – Dialect instance in use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`coltype` – DBAPI coltype argument received in cursor.description.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: A variably sized string type.
  prefs: []
  type: TYPE_NORMAL
- en: In SQL, usually corresponds to CLOB or TEXT. In general, TEXT objects do not
    have a length; while some databases will accept a length argument here, it will
    be rejected by others.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.types.Text`](#sqlalchemy.types.Text "sqlalchemy.types.Text")
    ([`sqlalchemy.types.String`](#sqlalchemy.types.String "sqlalchemy.types.String"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: A type for `datetime.time()` objects.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[get_dbapi_type()](#sqlalchemy.types.Time.get_dbapi_type), [literal_processor()](#sqlalchemy.types.Time.literal_processor),
    [python_type](#sqlalchemy.types.Time.python_type)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.types.Time`](#sqlalchemy.types.Time "sqlalchemy.types.Time")
    (`sqlalchemy.types._RenderISO8601NoT`, `sqlalchemy.types.HasExpressionLookup`,
    [`sqlalchemy.types.TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine "sqlalchemy.types.TypeEngine"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: Return the corresponding type object from the underlying DB-API, if any.
  prefs: []
  type: TYPE_NORMAL
- en: This can be useful for calling `setinputsizes()`, for example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: Return a conversion function for processing literal values that are to be rendered
    directly without using binds.
  prefs: []
  type: TYPE_NORMAL
- en: This function is used when the compiler makes use of the “literal_binds” flag,
    typically used in DDL generation as well as in certain scenarios where backends
    don’t accept bound parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Returns a callable which will receive a literal Python value as the sole positional
    argument and will return a string representation to be rendered in a SQL statement.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This method is only called relative to a **dialect specific type object**, which
    is often **private to a dialect in use** and is not the same type object as the
    public facing one, which means it’s not feasible to subclass a [`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") class in order to provide an alternate [`TypeEngine.literal_processor()`](type_api.html#sqlalchemy.types.TypeEngine.literal_processor
    "sqlalchemy.types.TypeEngine.literal_processor") method, unless subclassing the
    [`UserDefinedType`](custom_types.html#sqlalchemy.types.UserDefinedType "sqlalchemy.types.UserDefinedType")
    class explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: To provide alternate behavior for [`TypeEngine.literal_processor()`](type_api.html#sqlalchemy.types.TypeEngine.literal_processor
    "sqlalchemy.types.TypeEngine.literal_processor"), implement a [`TypeDecorator`](custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") class and provide an implementation of [`TypeDecorator.process_literal_param()`](custom_types.html#sqlalchemy.types.TypeDecorator.process_literal_param
    "sqlalchemy.types.TypeDecorator.process_literal_param").
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Augmenting Existing Types](custom_types.html#types-typedecorator)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: A variable length Unicode string type.
  prefs: []
  type: TYPE_NORMAL
- en: The [`Unicode`](#sqlalchemy.types.Unicode "sqlalchemy.types.Unicode") type is
    a [`String`](#sqlalchemy.types.String "sqlalchemy.types.String") subclass that
    assumes input and output strings that may contain non-ASCII characters, and for
    some backends implies an underlying column type that is explicitly supporting
    of non-ASCII data, such as `NVARCHAR` on Oracle and SQL Server. This will impact
    the output of `CREATE TABLE` statements and `CAST` functions at the dialect level.
  prefs: []
  type: TYPE_NORMAL
- en: The character encoding used by the [`Unicode`](#sqlalchemy.types.Unicode "sqlalchemy.types.Unicode")
    type that is used to transmit and receive data to the database is usually determined
    by the DBAPI itself. All modern DBAPIs accommodate non-ASCII strings but may have
    different methods of managing database encodings; if necessary, this encoding
    should be configured as detailed in the notes for the target DBAPI in the [Dialects](../dialects/index.html)
    section.
  prefs: []
  type: TYPE_NORMAL
- en: In modern SQLAlchemy, use of the [`Unicode`](#sqlalchemy.types.Unicode "sqlalchemy.types.Unicode")
    datatype does not imply any encoding/decoding behavior within SQLAlchemy itself.
    In Python 3, all string objects are inherently Unicode capable, and SQLAlchemy
    does not produce bytestring objects nor does it accommodate a DBAPI that does
    not return Python Unicode objects in result sets for string values.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: Some database backends, particularly SQL Server with pyodbc, are known to have
    undesirable behaviors regarding data that is noted as being of `NVARCHAR` type
    as opposed to `VARCHAR`, including datatype mismatch errors and non-use of indexes.
    See the section on [`DialectEvents.do_setinputsizes()`](events.html#sqlalchemy.events.DialectEvents.do_setinputsizes
    "sqlalchemy.events.DialectEvents.do_setinputsizes") for background on working
    around unicode character issues for backends like SQL Server with pyodbc as well
    as cx_Oracle.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`UnicodeText`](#sqlalchemy.types.UnicodeText "sqlalchemy.types.UnicodeText")
    - unlengthed textual counterpart to [`Unicode`](#sqlalchemy.types.Unicode "sqlalchemy.types.Unicode").'
  prefs: []
  type: TYPE_NORMAL
- en: '[`DialectEvents.do_setinputsizes()`](events.html#sqlalchemy.events.DialectEvents.do_setinputsizes
    "sqlalchemy.events.DialectEvents.do_setinputsizes")'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.types.Unicode`](#sqlalchemy.types.Unicode "sqlalchemy.types.Unicode")
    ([`sqlalchemy.types.String`](#sqlalchemy.types.String "sqlalchemy.types.String"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: An unbounded-length Unicode string type.
  prefs: []
  type: TYPE_NORMAL
- en: See [`Unicode`](#sqlalchemy.types.Unicode "sqlalchemy.types.Unicode") for details
    on the unicode behavior of this object.
  prefs: []
  type: TYPE_NORMAL
- en: Like [`Unicode`](#sqlalchemy.types.Unicode "sqlalchemy.types.Unicode"), usage
    the [`UnicodeText`](#sqlalchemy.types.UnicodeText "sqlalchemy.types.UnicodeText")
    type implies a unicode-capable type being used on the backend, such as `NCLOB`,
    `NTEXT`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.types.UnicodeText`](#sqlalchemy.types.UnicodeText "sqlalchemy.types.UnicodeText")
    ([`sqlalchemy.types.Text`](#sqlalchemy.types.Text "sqlalchemy.types.Text"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: Represent a database agnostic UUID datatype.
  prefs: []
  type: TYPE_NORMAL
- en: For backends that have no “native” UUID datatype, the value will make use of
    `CHAR(32)` and store the UUID as a 32-character alphanumeric hex string.
  prefs: []
  type: TYPE_NORMAL
- en: For backends which are known to support `UUID` directly or a similar uuid-storing
    datatype such as SQL Server’s `UNIQUEIDENTIFIER`, a “native” mode enabled by default
    allows these types will be used on those backends.
  prefs: []
  type: TYPE_NORMAL
- en: 'In its default mode of use, the [`Uuid`](#sqlalchemy.types.Uuid "sqlalchemy.types.Uuid")
    datatype expects **Python uuid objects**, from the Python [uuid](https://docs.python.org/3/library/uuid.html)
    module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: To have the [`Uuid`](#sqlalchemy.types.Uuid "sqlalchemy.types.Uuid") datatype
    work with string-based Uuids (e.g. 32 character hexadecimal strings), pass the
    [`Uuid.as_uuid`](#sqlalchemy.types.Uuid.params.as_uuid "sqlalchemy.types.Uuid")
    parameter with the value `False`.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`UUID`](#sqlalchemy.types.UUID "sqlalchemy.types.UUID") - represents exactly
    the `UUID` datatype without any backend-agnostic behaviors.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.types.Uuid.__init__), [bind_processor()](#sqlalchemy.types.Uuid.bind_processor),
    [coerce_compared_value()](#sqlalchemy.types.Uuid.coerce_compared_value), [literal_processor()](#sqlalchemy.types.Uuid.literal_processor),
    [python_type](#sqlalchemy.types.Uuid.python_type), [result_processor()](#sqlalchemy.types.Uuid.result_processor)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.types.Uuid`](#sqlalchemy.types.Uuid "sqlalchemy.types.Uuid")
    (`sqlalchemy.types.Emulated`, [`sqlalchemy.types.TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: Construct a [`Uuid`](#sqlalchemy.types.Uuid "sqlalchemy.types.Uuid") type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`as_uuid=True` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: if True, values will be interpreted as Python uuid objects, converting to/from
    string via the DBAPI.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`native_uuid=True` – if True, backends that support either the `UUID` datatype
    directly, or a UUID-storing value (such as SQL Server’s `UNIQUEIDENTIFIER` will
    be used by those backends. If False, a `CHAR(32)` datatype will be used for all
    backends regardless of native support.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: Return a conversion function for processing bind values.
  prefs: []
  type: TYPE_NORMAL
- en: Returns a callable which will receive a bind parameter value as the sole positional
    argument and will return a value to send to the DB-API.
  prefs: []
  type: TYPE_NORMAL
- en: If processing is not necessary, the method should return `None`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This method is only called relative to a **dialect specific type object**, which
    is often **private to a dialect in use** and is not the same type object as the
    public facing one, which means it’s not feasible to subclass a [`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") class in order to provide an alternate [`TypeEngine.bind_processor()`](type_api.html#sqlalchemy.types.TypeEngine.bind_processor
    "sqlalchemy.types.TypeEngine.bind_processor") method, unless subclassing the [`UserDefinedType`](custom_types.html#sqlalchemy.types.UserDefinedType
    "sqlalchemy.types.UserDefinedType") class explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: To provide alternate behavior for [`TypeEngine.bind_processor()`](type_api.html#sqlalchemy.types.TypeEngine.bind_processor
    "sqlalchemy.types.TypeEngine.bind_processor"), implement a [`TypeDecorator`](custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") class and provide an implementation of [`TypeDecorator.process_bind_param()`](custom_types.html#sqlalchemy.types.TypeDecorator.process_bind_param
    "sqlalchemy.types.TypeDecorator.process_bind_param").
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Augmenting Existing Types](custom_types.html#types-typedecorator)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**dialect** – Dialect instance in use.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: See [`TypeEngine.coerce_compared_value()`](type_api.html#sqlalchemy.types.TypeEngine.coerce_compared_value
    "sqlalchemy.types.TypeEngine.coerce_compared_value") for a description.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: Return a conversion function for processing literal values that are to be rendered
    directly without using binds.
  prefs: []
  type: TYPE_NORMAL
- en: This function is used when the compiler makes use of the “literal_binds” flag,
    typically used in DDL generation as well as in certain scenarios where backends
    don’t accept bound parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Returns a callable which will receive a literal Python value as the sole positional
    argument and will return a string representation to be rendered in a SQL statement.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This method is only called relative to a **dialect specific type object**, which
    is often **private to a dialect in use** and is not the same type object as the
    public facing one, which means it’s not feasible to subclass a [`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") class in order to provide an alternate [`TypeEngine.literal_processor()`](type_api.html#sqlalchemy.types.TypeEngine.literal_processor
    "sqlalchemy.types.TypeEngine.literal_processor") method, unless subclassing the
    [`UserDefinedType`](custom_types.html#sqlalchemy.types.UserDefinedType "sqlalchemy.types.UserDefinedType")
    class explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: To provide alternate behavior for [`TypeEngine.literal_processor()`](type_api.html#sqlalchemy.types.TypeEngine.literal_processor
    "sqlalchemy.types.TypeEngine.literal_processor"), implement a [`TypeDecorator`](custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") class and provide an implementation of [`TypeDecorator.process_literal_param()`](custom_types.html#sqlalchemy.types.TypeDecorator.process_literal_param
    "sqlalchemy.types.TypeDecorator.process_literal_param").
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Augmenting Existing Types](custom_types.html#types-typedecorator)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: Return a conversion function for processing result row values.
  prefs: []
  type: TYPE_NORMAL
- en: Returns a callable which will receive a result row column value as the sole
    positional argument and will return a value to return to the user.
  prefs: []
  type: TYPE_NORMAL
- en: If processing is not necessary, the method should return `None`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This method is only called relative to a **dialect specific type object**, which
    is often **private to a dialect in use** and is not the same type object as the
    public facing one, which means it’s not feasible to subclass a [`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") class in order to provide an alternate [`TypeEngine.result_processor()`](type_api.html#sqlalchemy.types.TypeEngine.result_processor
    "sqlalchemy.types.TypeEngine.result_processor") method, unless subclassing the
    [`UserDefinedType`](custom_types.html#sqlalchemy.types.UserDefinedType "sqlalchemy.types.UserDefinedType")
    class explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: To provide alternate behavior for [`TypeEngine.result_processor()`](type_api.html#sqlalchemy.types.TypeEngine.result_processor
    "sqlalchemy.types.TypeEngine.result_processor"), implement a [`TypeDecorator`](custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") class and provide an implementation of [`TypeDecorator.process_result_value()`](custom_types.html#sqlalchemy.types.TypeDecorator.process_result_value
    "sqlalchemy.types.TypeDecorator.process_result_value").
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Augmenting Existing Types](custom_types.html#types-typedecorator)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dialect` – Dialect instance in use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`coltype` – DBAPI coltype argument received in cursor.description.  ## SQL
    Standard and Multiple Vendor “UPPERCASE” Types'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This category of types refers to types that are either part of the SQL standard,
    or are potentially found within a subset of database backends. Unlike the “generic”
    types, the SQL standard/multi-vendor types have **no** guarantee of working on
    all backends, and will only work on those backends that explicitly support them
    by name. That is, the type will always emit its exact name in DDL with `CREATE
    TABLE` is issued.
  prefs: []
  type: TYPE_NORMAL
- en: '| Object Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| [ARRAY](#sqlalchemy.types.ARRAY) | Represent a SQL Array type. |'
  prefs: []
  type: TYPE_TB
- en: '| [BIGINT](#sqlalchemy.types.BIGINT) | The SQL BIGINT type. |'
  prefs: []
  type: TYPE_TB
- en: '| [BINARY](#sqlalchemy.types.BINARY) | The SQL BINARY type. |'
  prefs: []
  type: TYPE_TB
- en: '| [BLOB](#sqlalchemy.types.BLOB) | The SQL BLOB type. |'
  prefs: []
  type: TYPE_TB
- en: '| [BOOLEAN](#sqlalchemy.types.BOOLEAN) | The SQL BOOLEAN type. |'
  prefs: []
  type: TYPE_TB
- en: '| [CHAR](#sqlalchemy.types.CHAR) | The SQL CHAR type. |'
  prefs: []
  type: TYPE_TB
- en: '| [CLOB](#sqlalchemy.types.CLOB) | The CLOB type. |'
  prefs: []
  type: TYPE_TB
- en: '| [DATE](#sqlalchemy.types.DATE) | The SQL DATE type. |'
  prefs: []
  type: TYPE_TB
- en: '| [DATETIME](#sqlalchemy.types.DATETIME) | The SQL DATETIME type. |'
  prefs: []
  type: TYPE_TB
- en: '| [DECIMAL](#sqlalchemy.types.DECIMAL) | The SQL DECIMAL type. |'
  prefs: []
  type: TYPE_TB
- en: '| [DOUBLE](#sqlalchemy.types.DOUBLE) | The SQL DOUBLE type. |'
  prefs: []
  type: TYPE_TB
- en: '| [DOUBLE_PRECISION](#sqlalchemy.types.DOUBLE_PRECISION) | The SQL DOUBLE PRECISION
    type. |'
  prefs: []
  type: TYPE_TB
- en: '| [FLOAT](#sqlalchemy.types.FLOAT) | The SQL FLOAT type. |'
  prefs: []
  type: TYPE_TB
- en: '| [INT](#sqlalchemy.types.INT) | alias of [`INTEGER`](#sqlalchemy.types.INTEGER
    "sqlalchemy.sql.sqltypes.INTEGER") |'
  prefs: []
  type: TYPE_TB
- en: '| [INTEGER](#sqlalchemy.types.INTEGER) | The SQL INT or INTEGER type. |'
  prefs: []
  type: TYPE_TB
- en: '| [JSON](#sqlalchemy.types.JSON) | Represent a SQL JSON type. |'
  prefs: []
  type: TYPE_TB
- en: '| [NCHAR](#sqlalchemy.types.NCHAR) | The SQL NCHAR type. |'
  prefs: []
  type: TYPE_TB
- en: '| [NUMERIC](#sqlalchemy.types.NUMERIC) | The SQL NUMERIC type. |'
  prefs: []
  type: TYPE_TB
- en: '| [NVARCHAR](#sqlalchemy.types.NVARCHAR) | The SQL NVARCHAR type. |'
  prefs: []
  type: TYPE_TB
- en: '| [REAL](#sqlalchemy.types.REAL) | The SQL REAL type. |'
  prefs: []
  type: TYPE_TB
- en: '| [SMALLINT](#sqlalchemy.types.SMALLINT) | The SQL SMALLINT type. |'
  prefs: []
  type: TYPE_TB
- en: '| [TEXT](#sqlalchemy.types.TEXT) | The SQL TEXT type. |'
  prefs: []
  type: TYPE_TB
- en: '| [TIME](#sqlalchemy.types.TIME) | The SQL TIME type. |'
  prefs: []
  type: TYPE_TB
- en: '| [TIMESTAMP](#sqlalchemy.types.TIMESTAMP) | The SQL TIMESTAMP type. |'
  prefs: []
  type: TYPE_TB
- en: '| [UUID](#sqlalchemy.types.UUID) | Represent the SQL UUID type. |'
  prefs: []
  type: TYPE_TB
- en: '| [VARBINARY](#sqlalchemy.types.VARBINARY) | The SQL VARBINARY type. |'
  prefs: []
  type: TYPE_TB
- en: '| [VARCHAR](#sqlalchemy.types.VARCHAR) | The SQL VARCHAR type. |'
  prefs: []
  type: TYPE_TB
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: Represent a SQL Array type.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This type serves as the basis for all ARRAY operations. However, currently **only
    the PostgreSQL backend has support for SQL arrays in SQLAlchemy**. It is recommended
    to use the PostgreSQL-specific [`sqlalchemy.dialects.postgresql.ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY") type directly when using ARRAY types with
    PostgreSQL, as it provides additional operators specific to that backend.
  prefs: []
  type: TYPE_NORMAL
- en: '[`ARRAY`](#sqlalchemy.types.ARRAY "sqlalchemy.types.ARRAY") is part of the
    Core in support of various SQL standard functions such as [`array_agg`](functions.html#sqlalchemy.sql.functions.array_agg
    "sqlalchemy.sql.functions.array_agg") which explicitly involve arrays; however,
    with the exception of the PostgreSQL backend and possibly some third-party dialects,
    no other SQLAlchemy built-in dialect has support for this type.'
  prefs: []
  type: TYPE_NORMAL
- en: 'An [`ARRAY`](#sqlalchemy.types.ARRAY "sqlalchemy.types.ARRAY") type is constructed
    given the “type” of element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'The above type represents an N-dimensional array, meaning a supporting backend
    such as PostgreSQL will interpret values with any number of dimensions automatically.
    To produce an INSERT construct that passes in a 1-dimensional array of integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'The [`ARRAY`](#sqlalchemy.types.ARRAY "sqlalchemy.types.ARRAY") type can be
    constructed given a fixed number of dimensions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'Sending a number of dimensions is optional, but recommended if the datatype
    is to represent arrays of more than one dimension. This number is used:'
  prefs: []
  type: TYPE_NORMAL
- en: When emitting the type declaration itself to the database, e.g. `INTEGER[][]`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When translating Python values to database values, and vice versa, e.g. an ARRAY
    of [`Unicode`](#sqlalchemy.types.Unicode "sqlalchemy.types.Unicode") objects uses
    this number to efficiently access the string values inside of array structures
    without resorting to per-row type inspection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When used with the Python `getitem` accessor, the number of dimensions serves
    to define the kind of type that the `[]` operator should return, e.g. for an ARRAY
    of INTEGER with two dimensions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: For 1-dimensional arrays, an [`ARRAY`](#sqlalchemy.types.ARRAY "sqlalchemy.types.ARRAY")
    instance with no dimension parameter will generally assume single-dimensional
    behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: 'SQL expressions of type [`ARRAY`](#sqlalchemy.types.ARRAY "sqlalchemy.types.ARRAY")
    have support for “index” and “slice” behavior. The `[]` operator produces expression
    constructs which will produce the appropriate SQL, both for SELECT statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'as well as UPDATE statements when the [`Update.values()`](dml.html#sqlalchemy.sql.expression.Update.values
    "sqlalchemy.sql.expression.Update.values") method is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: Indexed access is one-based by default; for zero-based index conversion, set
    [`ARRAY.zero_indexes`](#sqlalchemy.types.ARRAY.params.zero_indexes "sqlalchemy.types.ARRAY").
  prefs: []
  type: TYPE_NORMAL
- en: The [`ARRAY`](#sqlalchemy.types.ARRAY "sqlalchemy.types.ARRAY") type also provides
    for the operators [`Comparator.any()`](#sqlalchemy.types.ARRAY.Comparator.any
    "sqlalchemy.types.ARRAY.Comparator.any") and [`Comparator.all()`](#sqlalchemy.types.ARRAY.Comparator.all
    "sqlalchemy.types.ARRAY.Comparator.all"). The PostgreSQL-specific version of [`ARRAY`](#sqlalchemy.types.ARRAY
    "sqlalchemy.types.ARRAY") also provides additional operators.
  prefs: []
  type: TYPE_NORMAL
- en: '**Detecting Changes in ARRAY columns when using the ORM**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`ARRAY`](#sqlalchemy.types.ARRAY "sqlalchemy.types.ARRAY") type, when
    used with the SQLAlchemy ORM, does not detect in-place mutations to the array.
    In order to detect these, the [`sqlalchemy.ext.mutable`](../orm/extensions/mutable.html#module-sqlalchemy.ext.mutable
    "sqlalchemy.ext.mutable") extension must be used, using the [`MutableList`](../orm/extensions/mutable.html#sqlalchemy.ext.mutable.MutableList
    "sqlalchemy.ext.mutable.MutableList") class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: This extension will allow “in-place” changes such to the array such as `.append()`
    to produce events which will be detected by the unit of work. Note that changes
    to elements **inside** the array, including subarrays that are mutated in place,
    are **not** detected.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, assigning a new array value to an ORM element that replaces the
    old one will always trigger a change event.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sqlalchemy.dialects.postgresql.ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY")'
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.types.ARRAY.__init__), [contains()](#sqlalchemy.types.ARRAY.Comparator.contains),
    [any()](#sqlalchemy.types.ARRAY.Comparator.any), [all()](#sqlalchemy.types.ARRAY.Comparator.all)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.types.ARRAY`](#sqlalchemy.types.ARRAY "sqlalchemy.types.ARRAY")
    (`sqlalchemy.sql.expression.SchemaEventTarget`, [`sqlalchemy.types.Indexable`](type_api.html#sqlalchemy.types.Indexable
    "sqlalchemy.types.Indexable"), [`sqlalchemy.types.Concatenable`](type_api.html#sqlalchemy.types.Concatenable
    "sqlalchemy.types.Concatenable"), [`sqlalchemy.types.TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: Construct an [`ARRAY`](#sqlalchemy.types.ARRAY "sqlalchemy.types.ARRAY").
  prefs: []
  type: TYPE_NORMAL
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'Arguments are:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`item_type` – The data type of items of this array. Note that dimensionality
    is irrelevant here, so multi-dimensional arrays like `INTEGER[][]`, are constructed
    as `ARRAY(Integer)`, not as `ARRAY(ARRAY(Integer))` or such.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`as_tuple=False` – Specify whether return results should be converted to tuples
    from lists. This parameter is not generally needed as a Python list corresponds
    well to a SQL array.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dimensions` – if non-None, the ARRAY will assume a fixed number of dimensions.
    This impacts how the array is declared on the database, how it goes about interpreting
    Python and result values, as well as how expression behavior in conjunction with
    the “getitem” operator works. See the description at [`ARRAY`](#sqlalchemy.types.ARRAY
    "sqlalchemy.types.ARRAY") for additional detail.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`zero_indexes=False` – when True, index values will be converted between Python
    zero-based and SQL one-based indexes, e.g. a value of one will be added to all
    index values before passing to the database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: Define comparison operations for [`ARRAY`](#sqlalchemy.types.ARRAY "sqlalchemy.types.ARRAY").
  prefs: []
  type: TYPE_NORMAL
- en: More operators are available on the dialect-specific form of this type. See
    [`Comparator`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY.Comparator
    "sqlalchemy.dialects.postgresql.ARRAY.Comparator").
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.types.ARRAY.Comparator`](#sqlalchemy.types.ARRAY.Comparator
    "sqlalchemy.types.ARRAY.Comparator") (`sqlalchemy.types.Comparator`, `sqlalchemy.types.Comparator`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: '`ARRAY.contains()` not implemented for the base ARRAY type. Use the dialect-specific
    ARRAY type.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY") - PostgreSQL specific version.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: Return `other operator ANY (array)` clause.
  prefs: []
  type: TYPE_NORMAL
- en: Legacy Feature
  prefs: []
  type: TYPE_NORMAL
- en: This method is an [`ARRAY`](#sqlalchemy.types.ARRAY "sqlalchemy.types.ARRAY")
    - specific construct that is now superseded by the [`any_()`](sqlelement.html#sqlalchemy.sql.expression.any_
    "sqlalchemy.sql.expression.any_") function, which features a different calling
    style. The [`any_()`](sqlelement.html#sqlalchemy.sql.expression.any_ "sqlalchemy.sql.expression.any_")
    function is also mirrored at the method level via the [`ColumnOperators.any_()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.any_
    "sqlalchemy.sql.expression.ColumnOperators.any_") method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Usage of array-specific [`Comparator.any()`](#sqlalchemy.types.ARRAY.Comparator.any
    "sqlalchemy.types.ARRAY.Comparator.any") is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`other` – expression to be compared'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`operator` – an operator object from the `sqlalchemy.sql.operators` package,
    defaults to `eq()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`any_()`](sqlelement.html#sqlalchemy.sql.expression.any_ "sqlalchemy.sql.expression.any_")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Comparator.all()`](#sqlalchemy.types.ARRAY.Comparator.all "sqlalchemy.types.ARRAY.Comparator.all")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: Return `other operator ALL (array)` clause.
  prefs: []
  type: TYPE_NORMAL
- en: Legacy Feature
  prefs: []
  type: TYPE_NORMAL
- en: This method is an [`ARRAY`](#sqlalchemy.types.ARRAY "sqlalchemy.types.ARRAY")
    - specific construct that is now superseded by the [`all_()`](sqlelement.html#sqlalchemy.sql.expression.all_
    "sqlalchemy.sql.expression.all_") function, which features a different calling
    style. The [`all_()`](sqlelement.html#sqlalchemy.sql.expression.all_ "sqlalchemy.sql.expression.all_")
    function is also mirrored at the method level via the [`ColumnOperators.all_()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.all_
    "sqlalchemy.sql.expression.ColumnOperators.all_") method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Usage of array-specific [`Comparator.all()`](#sqlalchemy.types.ARRAY.Comparator.all
    "sqlalchemy.types.ARRAY.Comparator.all") is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`other` – expression to be compared'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`operator` – an operator object from the `sqlalchemy.sql.operators` package,
    defaults to `eq()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`all_()`](sqlelement.html#sqlalchemy.sql.expression.all_ "sqlalchemy.sql.expression.all_")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Comparator.any()`](#sqlalchemy.types.ARRAY.Comparator.any "sqlalchemy.types.ARRAY.Comparator.any")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: The SQL BIGINT type.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`BigInteger`](#sqlalchemy.types.BigInteger "sqlalchemy.types.BigInteger")
    - documentation for the base type.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.types.BIGINT`](#sqlalchemy.types.BIGINT "sqlalchemy.types.BIGINT")
    ([`sqlalchemy.types.BigInteger`](#sqlalchemy.types.BigInteger "sqlalchemy.types.BigInteger"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: The SQL BINARY type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.types.BINARY`](#sqlalchemy.types.BINARY "sqlalchemy.types.BINARY")
    (`sqlalchemy.types._Binary`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: The SQL BLOB type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.types.BLOB.__init__)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.types.BLOB`](#sqlalchemy.types.BLOB "sqlalchemy.types.BLOB")
    ([`sqlalchemy.types.LargeBinary`](#sqlalchemy.types.LargeBinary "sqlalchemy.types.LargeBinary"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `sqlalchemy.types.LargeBinary.__init__` *method of* [`LargeBinary`](#sqlalchemy.types.LargeBinary
    "sqlalchemy.types.LargeBinary")'
  prefs: []
  type: TYPE_NORMAL
- en: Construct a LargeBinary type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**length** – optional, a length for the column for use in DDL statements, for
    those binary types that accept a length, such as the MySQL BLOB type.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: The SQL BOOLEAN type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.types.BOOLEAN.__init__)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.types.BOOLEAN`](#sqlalchemy.types.BOOLEAN "sqlalchemy.types.BOOLEAN")
    ([`sqlalchemy.types.Boolean`](#sqlalchemy.types.Boolean "sqlalchemy.types.Boolean"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `sqlalchemy.types.Boolean.__init__` *method of* [`Boolean`](#sqlalchemy.types.Boolean
    "sqlalchemy.types.Boolean")'
  prefs: []
  type: TYPE_NORMAL
- en: Construct a Boolean.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`create_constraint` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: defaults to False. If the boolean is generated as an int/smallint, also create
    a CHECK constraint on the table that ensures 1 or 0 as a value.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: it is strongly recommended that the CHECK constraint have an explicit name in
    order to support schema-management concerns. This can be established either by
    setting the [`Boolean.name`](#sqlalchemy.types.Boolean.params.name "sqlalchemy.types.Boolean")
    parameter or by setting up an appropriate naming convention; see [Configuring
    Constraint Naming Conventions](constraints.html#constraint-naming-conventions)
    for background.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Changed in version 1.4: - this flag now defaults to False, meaning no CHECK
    constraint is generated for a non-native enumerated type.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`name` – if a CHECK constraint is generated, specify the name of the constraint.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: The SQL CHAR type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.types.CHAR.__init__)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.types.CHAR`](#sqlalchemy.types.CHAR "sqlalchemy.types.CHAR")
    ([`sqlalchemy.types.String`](#sqlalchemy.types.String "sqlalchemy.types.String"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `sqlalchemy.types.String.__init__` *method of* [`String`](#sqlalchemy.types.String
    "sqlalchemy.types.String")'
  prefs: []
  type: TYPE_NORMAL
- en: Create a string-holding type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`length` – optional, a length for the column for use in DDL and CAST expressions.
    May be safely omitted if no `CREATE TABLE` will be issued. Certain databases may
    require a `length` for use in DDL, and will raise an exception when the `CREATE
    TABLE` DDL is issued if a `VARCHAR` with no length is included. Whether the value
    is interpreted as bytes or characters is database specific.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`collation` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Optional, a column-level collation for use in DDL and CAST expressions. Renders
    using the COLLATE keyword supported by SQLite, MySQL, and PostgreSQL. E.g.:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In most cases, the [`Unicode`](#sqlalchemy.types.Unicode "sqlalchemy.types.Unicode")
    or [`UnicodeText`](#sqlalchemy.types.UnicodeText "sqlalchemy.types.UnicodeText")
    datatypes should be used for a [`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") that expects to store non-ascii data. These datatypes
    will ensure that the correct types are used on the database.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: The CLOB type.
  prefs: []
  type: TYPE_NORMAL
- en: This type is found in Oracle and Informix.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.types.CLOB.__init__)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.types.CLOB`](#sqlalchemy.types.CLOB "sqlalchemy.types.CLOB")
    ([`sqlalchemy.types.Text`](#sqlalchemy.types.Text "sqlalchemy.types.Text"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `sqlalchemy.types.String.__init__` *method of* [`String`](#sqlalchemy.types.String
    "sqlalchemy.types.String")'
  prefs: []
  type: TYPE_NORMAL
- en: Create a string-holding type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`length` – optional, a length for the column for use in DDL and CAST expressions.
    May be safely omitted if no `CREATE TABLE` will be issued. Certain databases may
    require a `length` for use in DDL, and will raise an exception when the `CREATE
    TABLE` DDL is issued if a `VARCHAR` with no length is included. Whether the value
    is interpreted as bytes or characters is database specific.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`collation` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Optional, a column-level collation for use in DDL and CAST expressions. Renders
    using the COLLATE keyword supported by SQLite, MySQL, and PostgreSQL. E.g.:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In most cases, the [`Unicode`](#sqlalchemy.types.Unicode "sqlalchemy.types.Unicode")
    or [`UnicodeText`](#sqlalchemy.types.UnicodeText "sqlalchemy.types.UnicodeText")
    datatypes should be used for a [`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") that expects to store non-ascii data. These datatypes
    will ensure that the correct types are used on the database.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: The SQL DATE type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.types.DATE`](#sqlalchemy.types.DATE "sqlalchemy.types.DATE")
    ([`sqlalchemy.types.Date`](#sqlalchemy.types.Date "sqlalchemy.types.Date"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: The SQL DATETIME type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.types.DATETIME.__init__)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.types.DATETIME`](#sqlalchemy.types.DATETIME "sqlalchemy.types.DATETIME")
    ([`sqlalchemy.types.DateTime`](#sqlalchemy.types.DateTime "sqlalchemy.types.DateTime"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `sqlalchemy.types.DateTime.__init__` *method of* [`DateTime`](#sqlalchemy.types.DateTime
    "sqlalchemy.types.DateTime")'
  prefs: []
  type: TYPE_NORMAL
- en: Construct a new [`DateTime`](#sqlalchemy.types.DateTime "sqlalchemy.types.DateTime").
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**timezone** – boolean. Indicates that the datetime type should enable timezone
    support, if available on the **base date/time-holding type only**. It is recommended
    to make use of the [`TIMESTAMP`](#sqlalchemy.types.TIMESTAMP "sqlalchemy.types.TIMESTAMP")
    datatype directly when using this flag, as some databases include separate generic
    date/time-holding types distinct from the timezone-capable TIMESTAMP datatype,
    such as Oracle.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: The SQL DECIMAL type.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Numeric`](#sqlalchemy.types.Numeric "sqlalchemy.types.Numeric") - documentation
    for the base type.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.types.DECIMAL.__init__)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.types.DECIMAL`](#sqlalchemy.types.DECIMAL "sqlalchemy.types.DECIMAL")
    ([`sqlalchemy.types.Numeric`](#sqlalchemy.types.Numeric "sqlalchemy.types.Numeric"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `sqlalchemy.types.Numeric.__init__` *method of* [`Numeric`](#sqlalchemy.types.Numeric
    "sqlalchemy.types.Numeric")'
  prefs: []
  type: TYPE_NORMAL
- en: Construct a Numeric.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`precision` – the numeric precision for use in DDL `CREATE TABLE`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scale` – the numeric scale for use in DDL `CREATE TABLE`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`asdecimal` – default True. Return whether or not values should be sent as
    Python Decimal objects, or as floats. Different DBAPIs send one or the other based
    on datatypes - the Numeric type will ensure that return values are one or the
    other across DBAPIs consistently.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`decimal_return_scale` – Default scale to use when converting from floats to
    Python decimals. Floating point values will typically be much longer due to decimal
    inaccuracy, and most floating point database types don’t have a notion of “scale”,
    so by default the float type looks for the first ten decimal places when converting.
    Specifying this value will override that length. Types which do include an explicit
    “.scale” value, such as the base [`Numeric`](#sqlalchemy.types.Numeric "sqlalchemy.types.Numeric")
    as well as the MySQL float types, will use the value of “.scale” as the default
    for decimal_return_scale, if not otherwise specified.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When using the `Numeric` type, care should be taken to ensure that the asdecimal
    setting is appropriate for the DBAPI in use - when Numeric applies a conversion
    from Decimal->float or float-> Decimal, this conversion incurs an additional performance
    overhead for all result columns received.
  prefs: []
  type: TYPE_NORMAL
- en: DBAPIs that return Decimal natively (e.g. psycopg2) will have better accuracy
    and higher performance with a setting of `True`, as the native translation to
    Decimal reduces the amount of floating- point issues at play, and the Numeric
    type itself doesn’t need to apply any further conversions. However, another DBAPI
    which returns floats natively *will* incur an additional conversion overhead,
    and is still subject to floating point data loss - in which case `asdecimal=False`
    will at least remove the extra conversion overhead.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: The SQL DOUBLE type.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Double`](#sqlalchemy.types.Double "sqlalchemy.types.Double") - documentation
    for the base type.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.types.DOUBLE.__init__)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.types.DOUBLE`](#sqlalchemy.types.DOUBLE "sqlalchemy.types.DOUBLE")
    ([`sqlalchemy.types.Double`](#sqlalchemy.types.Double "sqlalchemy.types.Double"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `sqlalchemy.types.Float.__init__` *method of* [`Float`](#sqlalchemy.types.Float
    "sqlalchemy.types.Float")'
  prefs: []
  type: TYPE_NORMAL
- en: Construct a Float.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`precision` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the numeric precision for use in DDL `CREATE TABLE`. Backends **should** attempt
    to ensure this precision indicates a number of digits for the generic [`Float`](#sqlalchemy.types.Float
    "sqlalchemy.types.Float") datatype.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For the Oracle backend, the [`Float.precision`](#sqlalchemy.types.Float.params.precision
    "sqlalchemy.types.Float") parameter is not accepted when rendering DDL, as Oracle
    does not support float precision specified as a number of decimal places. Instead,
    use the Oracle-specific [`FLOAT`](../dialects/oracle.html#sqlalchemy.dialects.oracle.FLOAT
    "sqlalchemy.dialects.oracle.FLOAT") datatype and specify the [`FLOAT.binary_precision`](../dialects/oracle.html#sqlalchemy.dialects.oracle.FLOAT.params.binary_precision
    "sqlalchemy.dialects.oracle.FLOAT") parameter. This is new in version 2.0 of SQLAlchemy.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To create a database agnostic [`Float`](#sqlalchemy.types.Float "sqlalchemy.types.Float")
    that separately specifies binary precision for Oracle, use [`TypeEngine.with_variant()`](type_api.html#sqlalchemy.types.TypeEngine.with_variant
    "sqlalchemy.types.TypeEngine.with_variant") as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`asdecimal` – the same flag as that of [`Numeric`](#sqlalchemy.types.Numeric
    "sqlalchemy.types.Numeric"), but defaults to `False`. Note that setting this flag
    to `True` results in floating point conversion.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`decimal_return_scale` – Default scale to use when converting from floats to
    Python decimals. Floating point values will typically be much longer due to decimal
    inaccuracy, and most floating point database types don’t have a notion of “scale”,
    so by default the float type looks for the first ten decimal places when converting.
    Specifying this value will override that length. Note that the MySQL float types,
    which do include “scale”, will use “scale” as the default for decimal_return_scale,
    if not otherwise specified.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: The SQL DOUBLE PRECISION type.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Double`](#sqlalchemy.types.Double "sqlalchemy.types.Double") - documentation
    for the base type.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.types.DOUBLE_PRECISION.__init__)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.types.DOUBLE_PRECISION`](#sqlalchemy.types.DOUBLE_PRECISION
    "sqlalchemy.types.DOUBLE_PRECISION") ([`sqlalchemy.types.Double`](#sqlalchemy.types.Double
    "sqlalchemy.types.Double"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `sqlalchemy.types.Float.__init__` *method of* [`Float`](#sqlalchemy.types.Float
    "sqlalchemy.types.Float")'
  prefs: []
  type: TYPE_NORMAL
- en: Construct a Float.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`precision` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the numeric precision for use in DDL `CREATE TABLE`. Backends **should** attempt
    to ensure this precision indicates a number of digits for the generic [`Float`](#sqlalchemy.types.Float
    "sqlalchemy.types.Float") datatype.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For the Oracle backend, the [`Float.precision`](#sqlalchemy.types.Float.params.precision
    "sqlalchemy.types.Float") parameter is not accepted when rendering DDL, as Oracle
    does not support float precision specified as a number of decimal places. Instead,
    use the Oracle-specific [`FLOAT`](../dialects/oracle.html#sqlalchemy.dialects.oracle.FLOAT
    "sqlalchemy.dialects.oracle.FLOAT") datatype and specify the [`FLOAT.binary_precision`](../dialects/oracle.html#sqlalchemy.dialects.oracle.FLOAT.params.binary_precision
    "sqlalchemy.dialects.oracle.FLOAT") parameter. This is new in version 2.0 of SQLAlchemy.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To create a database agnostic [`Float`](#sqlalchemy.types.Float "sqlalchemy.types.Float")
    that separately specifies binary precision for Oracle, use [`TypeEngine.with_variant()`](type_api.html#sqlalchemy.types.TypeEngine.with_variant
    "sqlalchemy.types.TypeEngine.with_variant") as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`asdecimal` – the same flag as that of [`Numeric`](#sqlalchemy.types.Numeric
    "sqlalchemy.types.Numeric"), but defaults to `False`. Note that setting this flag
    to `True` results in floating point conversion.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`decimal_return_scale` – Default scale to use when converting from floats to
    Python decimals. Floating point values will typically be much longer due to decimal
    inaccuracy, and most floating point database types don’t have a notion of “scale”,
    so by default the float type looks for the first ten decimal places when converting.
    Specifying this value will override that length. Note that the MySQL float types,
    which do include “scale”, will use “scale” as the default for decimal_return_scale,
    if not otherwise specified.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: The SQL FLOAT type.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Float`](#sqlalchemy.types.Float "sqlalchemy.types.Float") - documentation
    for the base type.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.types.FLOAT.__init__)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.types.FLOAT`](#sqlalchemy.types.FLOAT "sqlalchemy.types.FLOAT")
    ([`sqlalchemy.types.Float`](#sqlalchemy.types.Float "sqlalchemy.types.Float"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `sqlalchemy.types.Float.__init__` *method of* [`Float`](#sqlalchemy.types.Float
    "sqlalchemy.types.Float")'
  prefs: []
  type: TYPE_NORMAL
- en: Construct a Float.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`precision` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the numeric precision for use in DDL `CREATE TABLE`. Backends **should** attempt
    to ensure this precision indicates a number of digits for the generic [`Float`](#sqlalchemy.types.Float
    "sqlalchemy.types.Float") datatype.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For the Oracle backend, the [`Float.precision`](#sqlalchemy.types.Float.params.precision
    "sqlalchemy.types.Float") parameter is not accepted when rendering DDL, as Oracle
    does not support float precision specified as a number of decimal places. Instead,
    use the Oracle-specific [`FLOAT`](../dialects/oracle.html#sqlalchemy.dialects.oracle.FLOAT
    "sqlalchemy.dialects.oracle.FLOAT") datatype and specify the [`FLOAT.binary_precision`](../dialects/oracle.html#sqlalchemy.dialects.oracle.FLOAT.params.binary_precision
    "sqlalchemy.dialects.oracle.FLOAT") parameter. This is new in version 2.0 of SQLAlchemy.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To create a database agnostic [`Float`](#sqlalchemy.types.Float "sqlalchemy.types.Float")
    that separately specifies binary precision for Oracle, use [`TypeEngine.with_variant()`](type_api.html#sqlalchemy.types.TypeEngine.with_variant
    "sqlalchemy.types.TypeEngine.with_variant") as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`asdecimal` – the same flag as that of [`Numeric`](#sqlalchemy.types.Numeric
    "sqlalchemy.types.Numeric"), but defaults to `False`. Note that setting this flag
    to `True` results in floating point conversion.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`decimal_return_scale` – Default scale to use when converting from floats to
    Python decimals. Floating point values will typically be much longer due to decimal
    inaccuracy, and most floating point database types don’t have a notion of “scale”,
    so by default the float type looks for the first ten decimal places when converting.
    Specifying this value will override that length. Note that the MySQL float types,
    which do include “scale”, will use “scale” as the default for decimal_return_scale,
    if not otherwise specified.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: alias of [`INTEGER`](#sqlalchemy.types.INTEGER "sqlalchemy.sql.sqltypes.INTEGER")
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: Represent a SQL JSON type.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '[`JSON`](#sqlalchemy.types.JSON "sqlalchemy.types.JSON") is provided as a facade
    for vendor-specific JSON types. Since it supports JSON SQL operations, it only
    works on backends that have an actual JSON type, currently:'
  prefs: []
  type: TYPE_NORMAL
- en: PostgreSQL - see [`sqlalchemy.dialects.postgresql.JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON
    "sqlalchemy.dialects.postgresql.JSON") and [`sqlalchemy.dialects.postgresql.JSONB`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSONB
    "sqlalchemy.dialects.postgresql.JSONB") for backend-specific notes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MySQL - see [`sqlalchemy.dialects.mysql.JSON`](../dialects/mysql.html#sqlalchemy.dialects.mysql.JSON
    "sqlalchemy.dialects.mysql.JSON") for backend-specific notes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SQLite as of version 3.9 - see [`sqlalchemy.dialects.sqlite.JSON`](../dialects/sqlite.html#sqlalchemy.dialects.sqlite.JSON
    "sqlalchemy.dialects.sqlite.JSON") for backend-specific notes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microsoft SQL Server 2016 and later - see [`sqlalchemy.dialects.mssql.JSON`](../dialects/mssql.html#sqlalchemy.dialects.mssql.JSON
    "sqlalchemy.dialects.mssql.JSON") for backend-specific notes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`JSON`](#sqlalchemy.types.JSON "sqlalchemy.types.JSON") is part of the Core
    in support of the growing popularity of native JSON datatypes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`JSON`](#sqlalchemy.types.JSON "sqlalchemy.types.JSON") type stores arbitrary
    JSON format data, e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: '**JSON-Specific Expression Operators**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`JSON`](#sqlalchemy.types.JSON "sqlalchemy.types.JSON") datatype provides
    these additional SQL operations:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Keyed index operations:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Integer index operations:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Path index operations:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Data casters for specific JSON element types, subsequent to an index or path
    operation being invoked:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: New in version 1.3.11.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Additional operations may be available from the dialect-specific versions of
    [`JSON`](#sqlalchemy.types.JSON "sqlalchemy.types.JSON"), such as [`sqlalchemy.dialects.postgresql.JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON
    "sqlalchemy.dialects.postgresql.JSON") and [`sqlalchemy.dialects.postgresql.JSONB`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSONB
    "sqlalchemy.dialects.postgresql.JSONB") which both offer additional PostgreSQL-specific
    operations.
  prefs: []
  type: TYPE_NORMAL
- en: '**Casting JSON Elements to Other Types**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Index operations, i.e. those invoked by calling upon the expression using the
    Python bracket operator as in `some_column[''some key'']`, return an expression
    object whose type defaults to [`JSON`](#sqlalchemy.types.JSON "sqlalchemy.types.JSON")
    by default, so that further JSON-oriented instructions may be called upon the
    result type. However, it is likely more common that an index operation is expected
    to return a specific scalar element, such as a string or integer. In order to
    provide access to these elements in a backend-agnostic way, a series of data casters
    are provided:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Comparator.as_string()`](#sqlalchemy.types.JSON.Comparator.as_string "sqlalchemy.types.JSON.Comparator.as_string")
    - return the element as a string'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`Comparator.as_boolean()`](#sqlalchemy.types.JSON.Comparator.as_boolean "sqlalchemy.types.JSON.Comparator.as_boolean")
    - return the element as a boolean'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`Comparator.as_float()`](#sqlalchemy.types.JSON.Comparator.as_float "sqlalchemy.types.JSON.Comparator.as_float")
    - return the element as a float'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`Comparator.as_integer()`](#sqlalchemy.types.JSON.Comparator.as_integer "sqlalchemy.types.JSON.Comparator.as_integer")
    - return the element as an integer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These data casters are implemented by supporting dialects in order to assure
    that comparisons to the above types will work as expected, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: 'New in version 1.3.11: Added type-specific casters for the basic JSON data
    element types.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The data caster functions are new in version 1.3.11, and supersede the previous
    documented approaches of using CAST; for reference, this looked like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: 'The above case now works directly as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: For details on the previous comparison approach within the 1.3.x series, see
    the documentation for SQLAlchemy 1.2 or the included HTML files in the doc/ directory
    of the version’s distribution.
  prefs: []
  type: TYPE_NORMAL
- en: '**Detecting Changes in JSON columns when using the ORM**'
  prefs: []
  type: TYPE_NORMAL
- en: The [`JSON`](#sqlalchemy.types.JSON "sqlalchemy.types.JSON") type, when used
    with the SQLAlchemy ORM, does not detect in-place mutations to the structure.
    In order to detect these, the [`sqlalchemy.ext.mutable`](../orm/extensions/mutable.html#module-sqlalchemy.ext.mutable
    "sqlalchemy.ext.mutable") extension must be used, most typically using the [`MutableDict`](../orm/extensions/mutable.html#sqlalchemy.ext.mutable.MutableDict
    "sqlalchemy.ext.mutable.MutableDict") class. This extension will allow “in-place”
    changes to the datastructure to produce events which will be detected by the unit
    of work. See the example at [`HSTORE`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.HSTORE
    "sqlalchemy.dialects.postgresql.HSTORE") for a simple example involving a dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, assigning a JSON structure to an ORM element that replaces the
    old one will always trigger a change event.
  prefs: []
  type: TYPE_NORMAL
- en: '**Support for JSON null vs. SQL NULL**'
  prefs: []
  type: TYPE_NORMAL
- en: 'When working with NULL values, the [`JSON`](#sqlalchemy.types.JSON "sqlalchemy.types.JSON")
    type recommends the use of two specific constants in order to differentiate between
    a column that evaluates to SQL NULL, e.g. no value, vs. the JSON-encoded string
    of `"null"`. To insert or select against a value that is SQL NULL, use the constant
    [`null()`](sqlelement.html#sqlalchemy.sql.expression.null "sqlalchemy.sql.expression.null").
    This symbol may be passed as a parameter value specifically when using the [`JSON`](#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON") datatype, which contains special logic that interprets
    this symbol to mean that the column value should be SQL NULL as opposed to JSON
    `"null"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: 'To insert or select against a value that is JSON `"null"`, use the constant
    [`JSON.NULL`](#sqlalchemy.types.JSON.NULL "sqlalchemy.types.JSON.NULL"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: The [`JSON`](#sqlalchemy.types.JSON "sqlalchemy.types.JSON") type supports a
    flag [`JSON.none_as_null`](#sqlalchemy.types.JSON.params.none_as_null "sqlalchemy.types.JSON")
    which when set to True will result in the Python constant `None` evaluating to
    the value of SQL NULL, and when set to False results in the Python constant `None`
    evaluating to the value of JSON `"null"`. The Python value `None` may be used
    in conjunction with either [`JSON.NULL`](#sqlalchemy.types.JSON.NULL "sqlalchemy.types.JSON.NULL")
    and [`null()`](sqlelement.html#sqlalchemy.sql.expression.null "sqlalchemy.sql.expression.null")
    in order to indicate NULL values, but care must be taken as to the value of the
    [`JSON.none_as_null`](#sqlalchemy.types.JSON.params.none_as_null "sqlalchemy.types.JSON")
    in these cases.
  prefs: []
  type: TYPE_NORMAL
- en: '**Customizing the JSON Serializer**'
  prefs: []
  type: TYPE_NORMAL
- en: The JSON serializer and deserializer used by [`JSON`](#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON") defaults to Python’s `json.dumps` and `json.loads` functions;
    in the case of the psycopg2 dialect, psycopg2 may be using its own custom loader
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to affect the serializer / deserializer, they are currently configurable
    at the [`create_engine()`](engines.html#sqlalchemy.create_engine "sqlalchemy.create_engine")
    level via the [`create_engine.json_serializer`](engines.html#sqlalchemy.create_engine.params.json_serializer
    "sqlalchemy.create_engine") and [`create_engine.json_deserializer`](engines.html#sqlalchemy.create_engine.params.json_deserializer
    "sqlalchemy.create_engine") parameters. For example, to turn off `ensure_ascii`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: 'Changed in version 1.3.7: SQLite dialect’s `json_serializer` and `json_deserializer`
    parameters renamed from `_json_serializer` and `_json_deserializer`.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sqlalchemy.dialects.postgresql.JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON
    "sqlalchemy.dialects.postgresql.JSON")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`sqlalchemy.dialects.postgresql.JSONB`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSONB
    "sqlalchemy.dialects.postgresql.JSONB")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`sqlalchemy.dialects.mysql.JSON`](../dialects/mysql.html#sqlalchemy.dialects.mysql.JSON
    "sqlalchemy.dialects.mysql.JSON")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`sqlalchemy.dialects.sqlite.JSON`](../dialects/sqlite.html#sqlalchemy.dialects.sqlite.JSON
    "sqlalchemy.dialects.sqlite.JSON")'
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[as_boolean()](#sqlalchemy.types.JSON.Comparator.as_boolean), [as_float()](#sqlalchemy.types.JSON.Comparator.as_float),
    [as_integer()](#sqlalchemy.types.JSON.Comparator.as_integer), [as_json()](#sqlalchemy.types.JSON.Comparator.as_json),
    [as_numeric()](#sqlalchemy.types.JSON.Comparator.as_numeric), [as_string()](#sqlalchemy.types.JSON.Comparator.as_string),
    [bind_processor()](#sqlalchemy.types.JSON.JSONElementType.bind_processor), [literal_processor()](#sqlalchemy.types.JSON.JSONElementType.literal_processor),
    [NULL](#sqlalchemy.types.JSON.NULL), [__init__()](#sqlalchemy.types.JSON.__init__),
    [bind_processor()](#sqlalchemy.types.JSON.bind_processor), [comparator_factory](#sqlalchemy.types.JSON.comparator_factory),
    [hashable](#sqlalchemy.types.JSON.hashable), [python_type](#sqlalchemy.types.JSON.python_type),
    [result_processor()](#sqlalchemy.types.JSON.result_processor), [should_evaluate_none](#sqlalchemy.types.JSON.should_evaluate_none)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.types.JSON`](#sqlalchemy.types.JSON "sqlalchemy.types.JSON")
    ([`sqlalchemy.types.Indexable`](type_api.html#sqlalchemy.types.Indexable "sqlalchemy.types.Indexable"),
    [`sqlalchemy.types.TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine "sqlalchemy.types.TypeEngine"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: Define comparison operations for [`JSON`](#sqlalchemy.types.JSON "sqlalchemy.types.JSON").
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.types.JSON.Comparator`](#sqlalchemy.types.JSON.Comparator
    "sqlalchemy.types.JSON.Comparator") (`sqlalchemy.types.Comparator`, `sqlalchemy.types.Comparator`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: Cast an indexed value as boolean.
  prefs: []
  type: TYPE_NORMAL
- en: 'e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: New in version 1.3.11.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: Cast an indexed value as float.
  prefs: []
  type: TYPE_NORMAL
- en: 'e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: New in version 1.3.11.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: Cast an indexed value as integer.
  prefs: []
  type: TYPE_NORMAL
- en: 'e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: New in version 1.3.11.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: Cast an indexed value as JSON.
  prefs: []
  type: TYPE_NORMAL
- en: 'e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: This is typically the default behavior of indexed elements in any case.
  prefs: []
  type: TYPE_NORMAL
- en: Note that comparison of full JSON structures may not be supported by all backends.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.3.11.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: Cast an indexed value as numeric/decimal.
  prefs: []
  type: TYPE_NORMAL
- en: 'e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: New in version 1.4.0b2.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: Cast an indexed value as string.
  prefs: []
  type: TYPE_NORMAL
- en: 'e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: New in version 1.3.11.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: Common function for index / path elements in a JSON expression.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.types.JSON.JSONElementType`](#sqlalchemy.types.JSON.JSONElementType
    "sqlalchemy.types.JSON.JSONElementType") ([`sqlalchemy.types.TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: Return a conversion function for processing bind values.
  prefs: []
  type: TYPE_NORMAL
- en: Returns a callable which will receive a bind parameter value as the sole positional
    argument and will return a value to send to the DB-API.
  prefs: []
  type: TYPE_NORMAL
- en: If processing is not necessary, the method should return `None`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This method is only called relative to a **dialect specific type object**, which
    is often **private to a dialect in use** and is not the same type object as the
    public facing one, which means it’s not feasible to subclass a [`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") class in order to provide an alternate [`TypeEngine.bind_processor()`](type_api.html#sqlalchemy.types.TypeEngine.bind_processor
    "sqlalchemy.types.TypeEngine.bind_processor") method, unless subclassing the [`UserDefinedType`](custom_types.html#sqlalchemy.types.UserDefinedType
    "sqlalchemy.types.UserDefinedType") class explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: To provide alternate behavior for [`TypeEngine.bind_processor()`](type_api.html#sqlalchemy.types.TypeEngine.bind_processor
    "sqlalchemy.types.TypeEngine.bind_processor"), implement a [`TypeDecorator`](custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") class and provide an implementation of [`TypeDecorator.process_bind_param()`](custom_types.html#sqlalchemy.types.TypeDecorator.process_bind_param
    "sqlalchemy.types.TypeDecorator.process_bind_param").
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Augmenting Existing Types](custom_types.html#types-typedecorator)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**dialect** – Dialect instance in use.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: Return a conversion function for processing literal values that are to be rendered
    directly without using binds.
  prefs: []
  type: TYPE_NORMAL
- en: This function is used when the compiler makes use of the “literal_binds” flag,
    typically used in DDL generation as well as in certain scenarios where backends
    don’t accept bound parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Returns a callable which will receive a literal Python value as the sole positional
    argument and will return a string representation to be rendered in a SQL statement.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This method is only called relative to a **dialect specific type object**, which
    is often **private to a dialect in use** and is not the same type object as the
    public facing one, which means it’s not feasible to subclass a [`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") class in order to provide an alternate [`TypeEngine.literal_processor()`](type_api.html#sqlalchemy.types.TypeEngine.literal_processor
    "sqlalchemy.types.TypeEngine.literal_processor") method, unless subclassing the
    [`UserDefinedType`](custom_types.html#sqlalchemy.types.UserDefinedType "sqlalchemy.types.UserDefinedType")
    class explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: To provide alternate behavior for [`TypeEngine.literal_processor()`](type_api.html#sqlalchemy.types.TypeEngine.literal_processor
    "sqlalchemy.types.TypeEngine.literal_processor"), implement a [`TypeDecorator`](custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") class and provide an implementation of [`TypeDecorator.process_literal_param()`](custom_types.html#sqlalchemy.types.TypeDecorator.process_literal_param
    "sqlalchemy.types.TypeDecorator.process_literal_param").
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Augmenting Existing Types](custom_types.html#types-typedecorator)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: Placeholder for the datatype of a JSON index value.
  prefs: []
  type: TYPE_NORMAL
- en: This allows execution-time processing of JSON index values for special syntaxes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.types.JSON.JSONIndexType`](#sqlalchemy.types.JSON.JSONIndexType
    "sqlalchemy.types.JSON.JSONIndexType") (`sqlalchemy.types.JSONElementType`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: Placeholder for the datatype of a JSON index value.
  prefs: []
  type: TYPE_NORMAL
- en: This allows execution-time processing of JSON index values for special syntaxes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.types.JSON.JSONIntIndexType`](#sqlalchemy.types.JSON.JSONIntIndexType
    "sqlalchemy.types.JSON.JSONIntIndexType") (`sqlalchemy.types.JSONIndexType`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: Placeholder type for JSON path operations.
  prefs: []
  type: TYPE_NORMAL
- en: This allows execution-time processing of a path-based index value into a specific
    SQL syntax.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.types.JSON.JSONPathType`](#sqlalchemy.types.JSON.JSONPathType
    "sqlalchemy.types.JSON.JSONPathType") (`sqlalchemy.types.JSONElementType`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: Placeholder for the datatype of a JSON index value.
  prefs: []
  type: TYPE_NORMAL
- en: This allows execution-time processing of JSON index values for special syntaxes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.types.JSON.JSONStrIndexType`](#sqlalchemy.types.JSON.JSONStrIndexType
    "sqlalchemy.types.JSON.JSONStrIndexType") (`sqlalchemy.types.JSONIndexType`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: Describe the json value of NULL.
  prefs: []
  type: TYPE_NORMAL
- en: 'This value is used to force the JSON value of `"null"` to be used as the value.
    A value of Python `None` will be recognized either as SQL NULL or JSON `"null"`,
    based on the setting of the [`JSON.none_as_null`](#sqlalchemy.types.JSON.params.none_as_null
    "sqlalchemy.types.JSON") flag; the [`JSON.NULL`](#sqlalchemy.types.JSON.NULL "sqlalchemy.types.JSON.NULL")
    constant can be used to always resolve to JSON `"null"` regardless of this setting.
    This is in contrast to the [`null()`](sqlelement.html#sqlalchemy.sql.expression.null
    "sqlalchemy.sql.expression.null") construct, which always resolves to SQL NULL.
    E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to set JSON NULL as a default value for a column, the most transparent
    method is to use [`text()`](sqlelement.html#sqlalchemy.sql.expression.text "sqlalchemy.sql.expression.text"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: While it is possible to use [`JSON.NULL`](#sqlalchemy.types.JSON.NULL "sqlalchemy.types.JSON.NULL")
    in this context, the [`JSON.NULL`](#sqlalchemy.types.JSON.NULL "sqlalchemy.types.JSON.NULL")
    value will be returned as the value of the column, which in the context of the
    ORM or other repurposing of the default value, may not be desirable. Using a SQL
    expression means the value will be re-fetched from the database within the context
    of retrieving generated defaults.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: Construct a [`JSON`](#sqlalchemy.types.JSON "sqlalchemy.types.JSON") type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**none_as_null=False** –'
  prefs: []
  type: TYPE_NORMAL
- en: 'if True, persist the value `None` as a SQL NULL value, not the JSON encoding
    of `null`. Note that when this flag is False, the [`null()`](sqlelement.html#sqlalchemy.sql.expression.null
    "sqlalchemy.sql.expression.null") construct can still be used to persist a NULL
    value, which may be passed directly as a parameter value that is specially interpreted
    by the [`JSON`](#sqlalchemy.types.JSON "sqlalchemy.types.JSON") type as SQL NULL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '[`JSON.none_as_null`](#sqlalchemy.types.JSON.params.none_as_null "sqlalchemy.types.JSON")
    does **not** apply to the values passed to [`Column.default`](metadata.html#sqlalchemy.schema.Column.params.default
    "sqlalchemy.schema.Column") and [`Column.server_default`](metadata.html#sqlalchemy.schema.Column.params.server_default
    "sqlalchemy.schema.Column"); a value of `None` passed for these parameters means
    “no default present”.'
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, when used in SQL comparison expressions, the Python value `None`
    continues to refer to SQL null, and not JSON NULL. The [`JSON.none_as_null`](#sqlalchemy.types.JSON.params.none_as_null
    "sqlalchemy.types.JSON") flag refers explicitly to the **persistence** of the
    value within an INSERT or UPDATE statement. The [`JSON.NULL`](#sqlalchemy.types.JSON.NULL
    "sqlalchemy.types.JSON.NULL") value should be used for SQL expressions that wish
    to compare to JSON null.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`JSON.NULL`](#sqlalchemy.types.JSON.NULL "sqlalchemy.types.JSON.NULL")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: Return a conversion function for processing bind values.
  prefs: []
  type: TYPE_NORMAL
- en: Returns a callable which will receive a bind parameter value as the sole positional
    argument and will return a value to send to the DB-API.
  prefs: []
  type: TYPE_NORMAL
- en: If processing is not necessary, the method should return `None`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This method is only called relative to a **dialect specific type object**, which
    is often **private to a dialect in use** and is not the same type object as the
    public facing one, which means it’s not feasible to subclass a [`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") class in order to provide an alternate [`TypeEngine.bind_processor()`](type_api.html#sqlalchemy.types.TypeEngine.bind_processor
    "sqlalchemy.types.TypeEngine.bind_processor") method, unless subclassing the [`UserDefinedType`](custom_types.html#sqlalchemy.types.UserDefinedType
    "sqlalchemy.types.UserDefinedType") class explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: To provide alternate behavior for [`TypeEngine.bind_processor()`](type_api.html#sqlalchemy.types.TypeEngine.bind_processor
    "sqlalchemy.types.TypeEngine.bind_processor"), implement a [`TypeDecorator`](custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") class and provide an implementation of [`TypeDecorator.process_bind_param()`](custom_types.html#sqlalchemy.types.TypeDecorator.process_bind_param
    "sqlalchemy.types.TypeDecorator.process_bind_param").
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Augmenting Existing Types](custom_types.html#types-typedecorator)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**dialect** – Dialect instance in use.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: alias of [`Comparator`](#sqlalchemy.types.JSON.Comparator "sqlalchemy.sql.sqltypes.JSON.Comparator")
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: Flag, if False, means values from this type aren’t hashable.
  prefs: []
  type: TYPE_NORMAL
- en: Used by the ORM when uniquing result lists.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: Return a conversion function for processing result row values.
  prefs: []
  type: TYPE_NORMAL
- en: Returns a callable which will receive a result row column value as the sole
    positional argument and will return a value to return to the user.
  prefs: []
  type: TYPE_NORMAL
- en: If processing is not necessary, the method should return `None`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This method is only called relative to a **dialect specific type object**, which
    is often **private to a dialect in use** and is not the same type object as the
    public facing one, which means it’s not feasible to subclass a [`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") class in order to provide an alternate [`TypeEngine.result_processor()`](type_api.html#sqlalchemy.types.TypeEngine.result_processor
    "sqlalchemy.types.TypeEngine.result_processor") method, unless subclassing the
    [`UserDefinedType`](custom_types.html#sqlalchemy.types.UserDefinedType "sqlalchemy.types.UserDefinedType")
    class explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: To provide alternate behavior for [`TypeEngine.result_processor()`](type_api.html#sqlalchemy.types.TypeEngine.result_processor
    "sqlalchemy.types.TypeEngine.result_processor"), implement a [`TypeDecorator`](custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") class and provide an implementation of [`TypeDecorator.process_result_value()`](custom_types.html#sqlalchemy.types.TypeDecorator.process_result_value
    "sqlalchemy.types.TypeDecorator.process_result_value").
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Augmenting Existing Types](custom_types.html#types-typedecorator)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dialect` – Dialect instance in use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`coltype` – DBAPI coltype argument received in cursor.description.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: If True, the Python constant `None` is considered to be handled explicitly by
    this type.
  prefs: []
  type: TYPE_NORMAL
- en: The ORM uses this flag to indicate that a positive value of `None` is passed
    to the column in an INSERT statement, rather than omitting the column from the
    INSERT statement which has the effect of firing off column-level defaults. It
    also allows types which have special behavior for Python None, such as a JSON
    type, to indicate that they’d like to handle the None value explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: To set this flag on an existing type, use the [`TypeEngine.evaluates_none()`](type_api.html#sqlalchemy.types.TypeEngine.evaluates_none
    "sqlalchemy.types.TypeEngine.evaluates_none") method.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`TypeEngine.evaluates_none()`](type_api.html#sqlalchemy.types.TypeEngine.evaluates_none
    "sqlalchemy.types.TypeEngine.evaluates_none")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: The SQL INT or INTEGER type.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Integer`](#sqlalchemy.types.Integer "sqlalchemy.types.Integer") - documentation
    for the base type.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.types.INTEGER`](#sqlalchemy.types.INTEGER "sqlalchemy.types.INTEGER")
    ([`sqlalchemy.types.Integer`](#sqlalchemy.types.Integer "sqlalchemy.types.Integer"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: The SQL NCHAR type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.types.NCHAR.__init__)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.types.NCHAR`](#sqlalchemy.types.NCHAR "sqlalchemy.types.NCHAR")
    ([`sqlalchemy.types.Unicode`](#sqlalchemy.types.Unicode "sqlalchemy.types.Unicode"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `sqlalchemy.types.String.__init__` *method of* [`String`](#sqlalchemy.types.String
    "sqlalchemy.types.String")'
  prefs: []
  type: TYPE_NORMAL
- en: Create a string-holding type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`length` – optional, a length for the column for use in DDL and CAST expressions.
    May be safely omitted if no `CREATE TABLE` will be issued. Certain databases may
    require a `length` for use in DDL, and will raise an exception when the `CREATE
    TABLE` DDL is issued if a `VARCHAR` with no length is included. Whether the value
    is interpreted as bytes or characters is database specific.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`collation` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Optional, a column-level collation for use in DDL and CAST expressions. Renders
    using the COLLATE keyword supported by SQLite, MySQL, and PostgreSQL. E.g.:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE193]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In most cases, the [`Unicode`](#sqlalchemy.types.Unicode "sqlalchemy.types.Unicode")
    or [`UnicodeText`](#sqlalchemy.types.UnicodeText "sqlalchemy.types.UnicodeText")
    datatypes should be used for a [`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") that expects to store non-ascii data. These datatypes
    will ensure that the correct types are used on the database.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: The SQL NVARCHAR type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.types.NVARCHAR.__init__)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.types.NVARCHAR`](#sqlalchemy.types.NVARCHAR "sqlalchemy.types.NVARCHAR")
    ([`sqlalchemy.types.Unicode`](#sqlalchemy.types.Unicode "sqlalchemy.types.Unicode"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `sqlalchemy.types.String.__init__` *method of* [`String`](#sqlalchemy.types.String
    "sqlalchemy.types.String")'
  prefs: []
  type: TYPE_NORMAL
- en: Create a string-holding type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`length` – optional, a length for the column for use in DDL and CAST expressions.
    May be safely omitted if no `CREATE TABLE` will be issued. Certain databases may
    require a `length` for use in DDL, and will raise an exception when the `CREATE
    TABLE` DDL is issued if a `VARCHAR` with no length is included. Whether the value
    is interpreted as bytes or characters is database specific.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`collation` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Optional, a column-level collation for use in DDL and CAST expressions. Renders
    using the COLLATE keyword supported by SQLite, MySQL, and PostgreSQL. E.g.:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE196]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In most cases, the [`Unicode`](#sqlalchemy.types.Unicode "sqlalchemy.types.Unicode")
    or [`UnicodeText`](#sqlalchemy.types.UnicodeText "sqlalchemy.types.UnicodeText")
    datatypes should be used for a [`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") that expects to store non-ascii data. These datatypes
    will ensure that the correct types are used on the database.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: The SQL NUMERIC type.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Numeric`](#sqlalchemy.types.Numeric "sqlalchemy.types.Numeric") - documentation
    for the base type.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.types.NUMERIC.__init__)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.types.NUMERIC`](#sqlalchemy.types.NUMERIC "sqlalchemy.types.NUMERIC")
    ([`sqlalchemy.types.Numeric`](#sqlalchemy.types.Numeric "sqlalchemy.types.Numeric"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `sqlalchemy.types.Numeric.__init__` *method of* [`Numeric`](#sqlalchemy.types.Numeric
    "sqlalchemy.types.Numeric")'
  prefs: []
  type: TYPE_NORMAL
- en: Construct a Numeric.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`precision` – the numeric precision for use in DDL `CREATE TABLE`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scale` – the numeric scale for use in DDL `CREATE TABLE`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`asdecimal` – default True. Return whether or not values should be sent as
    Python Decimal objects, or as floats. Different DBAPIs send one or the other based
    on datatypes - the Numeric type will ensure that return values are one or the
    other across DBAPIs consistently.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`decimal_return_scale` – Default scale to use when converting from floats to
    Python decimals. Floating point values will typically be much longer due to decimal
    inaccuracy, and most floating point database types don’t have a notion of “scale”,
    so by default the float type looks for the first ten decimal places when converting.
    Specifying this value will override that length. Types which do include an explicit
    “.scale” value, such as the base [`Numeric`](#sqlalchemy.types.Numeric "sqlalchemy.types.Numeric")
    as well as the MySQL float types, will use the value of “.scale” as the default
    for decimal_return_scale, if not otherwise specified.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When using the `Numeric` type, care should be taken to ensure that the asdecimal
    setting is appropriate for the DBAPI in use - when Numeric applies a conversion
    from Decimal->float or float-> Decimal, this conversion incurs an additional performance
    overhead for all result columns received.
  prefs: []
  type: TYPE_NORMAL
- en: DBAPIs that return Decimal natively (e.g. psycopg2) will have better accuracy
    and higher performance with a setting of `True`, as the native translation to
    Decimal reduces the amount of floating- point issues at play, and the Numeric
    type itself doesn’t need to apply any further conversions. However, another DBAPI
    which returns floats natively *will* incur an additional conversion overhead,
    and is still subject to floating point data loss - in which case `asdecimal=False`
    will at least remove the extra conversion overhead.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: The SQL REAL type.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Float`](#sqlalchemy.types.Float "sqlalchemy.types.Float") - documentation
    for the base type.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.types.REAL.__init__)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.types.REAL`](#sqlalchemy.types.REAL "sqlalchemy.types.REAL")
    ([`sqlalchemy.types.Float`](#sqlalchemy.types.Float "sqlalchemy.types.Float"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `sqlalchemy.types.Float.__init__` *method of* [`Float`](#sqlalchemy.types.Float
    "sqlalchemy.types.Float")'
  prefs: []
  type: TYPE_NORMAL
- en: Construct a Float.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`precision` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the numeric precision for use in DDL `CREATE TABLE`. Backends **should** attempt
    to ensure this precision indicates a number of digits for the generic [`Float`](#sqlalchemy.types.Float
    "sqlalchemy.types.Float") datatype.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For the Oracle backend, the [`Float.precision`](#sqlalchemy.types.Float.params.precision
    "sqlalchemy.types.Float") parameter is not accepted when rendering DDL, as Oracle
    does not support float precision specified as a number of decimal places. Instead,
    use the Oracle-specific [`FLOAT`](../dialects/oracle.html#sqlalchemy.dialects.oracle.FLOAT
    "sqlalchemy.dialects.oracle.FLOAT") datatype and specify the [`FLOAT.binary_precision`](../dialects/oracle.html#sqlalchemy.dialects.oracle.FLOAT.params.binary_precision
    "sqlalchemy.dialects.oracle.FLOAT") parameter. This is new in version 2.0 of SQLAlchemy.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To create a database agnostic [`Float`](#sqlalchemy.types.Float "sqlalchemy.types.Float")
    that separately specifies binary precision for Oracle, use [`TypeEngine.with_variant()`](type_api.html#sqlalchemy.types.TypeEngine.with_variant
    "sqlalchemy.types.TypeEngine.with_variant") as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE201]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`asdecimal` – the same flag as that of [`Numeric`](#sqlalchemy.types.Numeric
    "sqlalchemy.types.Numeric"), but defaults to `False`. Note that setting this flag
    to `True` results in floating point conversion.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`decimal_return_scale` – Default scale to use when converting from floats to
    Python decimals. Floating point values will typically be much longer due to decimal
    inaccuracy, and most floating point database types don’t have a notion of “scale”,
    so by default the float type looks for the first ten decimal places when converting.
    Specifying this value will override that length. Note that the MySQL float types,
    which do include “scale”, will use “scale” as the default for decimal_return_scale,
    if not otherwise specified.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: The SQL SMALLINT type.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`SmallInteger`](#sqlalchemy.types.SmallInteger "sqlalchemy.types.SmallInteger")
    - documentation for the base type.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.types.SMALLINT`](#sqlalchemy.types.SMALLINT "sqlalchemy.types.SMALLINT")
    ([`sqlalchemy.types.SmallInteger`](#sqlalchemy.types.SmallInteger "sqlalchemy.types.SmallInteger"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: The SQL TEXT type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.types.TEXT.__init__)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.types.TEXT`](#sqlalchemy.types.TEXT "sqlalchemy.types.TEXT")
    ([`sqlalchemy.types.Text`](#sqlalchemy.types.Text "sqlalchemy.types.Text"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `sqlalchemy.types.String.__init__` *method of* [`String`](#sqlalchemy.types.String
    "sqlalchemy.types.String")'
  prefs: []
  type: TYPE_NORMAL
- en: Create a string-holding type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`length` – optional, a length for the column for use in DDL and CAST expressions.
    May be safely omitted if no `CREATE TABLE` will be issued. Certain databases may
    require a `length` for use in DDL, and will raise an exception when the `CREATE
    TABLE` DDL is issued if a `VARCHAR` with no length is included. Whether the value
    is interpreted as bytes or characters is database specific.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`collation` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Optional, a column-level collation for use in DDL and CAST expressions. Renders
    using the COLLATE keyword supported by SQLite, MySQL, and PostgreSQL. E.g.:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE205]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In most cases, the [`Unicode`](#sqlalchemy.types.Unicode "sqlalchemy.types.Unicode")
    or [`UnicodeText`](#sqlalchemy.types.UnicodeText "sqlalchemy.types.UnicodeText")
    datatypes should be used for a [`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") that expects to store non-ascii data. These datatypes
    will ensure that the correct types are used on the database.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: The SQL TIME type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.types.TIME`](#sqlalchemy.types.TIME "sqlalchemy.types.TIME")
    ([`sqlalchemy.types.Time`](#sqlalchemy.types.Time "sqlalchemy.types.Time"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: The SQL TIMESTAMP type.
  prefs: []
  type: TYPE_NORMAL
- en: '[`TIMESTAMP`](#sqlalchemy.types.TIMESTAMP "sqlalchemy.types.TIMESTAMP") datatypes
    have support for timezone storage on some backends, such as PostgreSQL and Oracle.
    Use the `TIMESTAMP.timezone` argument in order to enable “TIMESTAMP WITH TIMEZONE”
    for these backends.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.types.TIMESTAMP.__init__), [get_dbapi_type()](#sqlalchemy.types.TIMESTAMP.get_dbapi_type)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.types.TIMESTAMP`](#sqlalchemy.types.TIMESTAMP "sqlalchemy.types.TIMESTAMP")
    ([`sqlalchemy.types.DateTime`](#sqlalchemy.types.DateTime "sqlalchemy.types.DateTime"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: Construct a new [`TIMESTAMP`](#sqlalchemy.types.TIMESTAMP "sqlalchemy.types.TIMESTAMP").
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**timezone** – boolean. Indicates that the TIMESTAMP type should enable timezone
    support, if available on the target database. On a per-dialect basis is similar
    to “TIMESTAMP WITH TIMEZONE”. If the target database does not support timezones,
    this flag is ignored.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: Return the corresponding type object from the underlying DB-API, if any.
  prefs: []
  type: TYPE_NORMAL
- en: This can be useful for calling `setinputsizes()`, for example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: Represent the SQL UUID type.
  prefs: []
  type: TYPE_NORMAL
- en: This is the SQL-native form of the [`Uuid`](#sqlalchemy.types.Uuid "sqlalchemy.types.Uuid")
    database agnostic datatype, and is backwards compatible with the previous PostgreSQL-only
    version of `UUID`.
  prefs: []
  type: TYPE_NORMAL
- en: The [`UUID`](#sqlalchemy.types.UUID "sqlalchemy.types.UUID") datatype only works
    on databases that have a SQL datatype named `UUID`. It will not function for backends
    which don’t have this exact-named type, including SQL Server. For backend-agnostic
    UUID values with native support, including for SQL Server’s `UNIQUEIDENTIFIER`
    datatype, use the [`Uuid`](#sqlalchemy.types.Uuid "sqlalchemy.types.Uuid") datatype.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Uuid`](#sqlalchemy.types.Uuid "sqlalchemy.types.Uuid")'
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.types.UUID.__init__)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.types.UUID`](#sqlalchemy.types.UUID "sqlalchemy.types.UUID")
    ([`sqlalchemy.types.Uuid`](#sqlalchemy.types.Uuid "sqlalchemy.types.Uuid"), `sqlalchemy.types.NativeForEmulated`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: Construct a [`UUID`](#sqlalchemy.types.UUID "sqlalchemy.types.UUID") type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**as_uuid=True** –'
  prefs: []
  type: TYPE_NORMAL
- en: if True, values will be interpreted as Python uuid objects, converting to/from
    string via the DBAPI.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: The SQL VARBINARY type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.types.VARBINARY`](#sqlalchemy.types.VARBINARY "sqlalchemy.types.VARBINARY")
    (`sqlalchemy.types._Binary`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: The SQL VARCHAR type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.types.VARCHAR.__init__)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.types.VARCHAR`](#sqlalchemy.types.VARCHAR "sqlalchemy.types.VARCHAR")
    ([`sqlalchemy.types.String`](#sqlalchemy.types.String "sqlalchemy.types.String"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `sqlalchemy.types.String.__init__` *method of* [`String`](#sqlalchemy.types.String
    "sqlalchemy.types.String")'
  prefs: []
  type: TYPE_NORMAL
- en: Create a string-holding type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`length` – optional, a length for the column for use in DDL and CAST expressions.
    May be safely omitted if no `CREATE TABLE` will be issued. Certain databases may
    require a `length` for use in DDL, and will raise an exception when the `CREATE
    TABLE` DDL is issued if a `VARCHAR` with no length is included. Whether the value
    is interpreted as bytes or characters is database specific.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`collation` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Optional, a column-level collation for use in DDL and CAST expressions. Renders
    using the COLLATE keyword supported by SQLite, MySQL, and PostgreSQL. E.g.:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE215]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In most cases, the [`Unicode`](#sqlalchemy.types.Unicode "sqlalchemy.types.Unicode")
    or [`UnicodeText`](#sqlalchemy.types.UnicodeText "sqlalchemy.types.UnicodeText")
    datatypes should be used for a [`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") that expects to store non-ascii data. These datatypes
    will ensure that the correct types are used on the database.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The “CamelCase” datatypes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The rudimental types have “CamelCase” names such as [`String`](#sqlalchemy.types.String
    "sqlalchemy.types.String"), [`Numeric`](#sqlalchemy.types.Numeric "sqlalchemy.types.Numeric"),
    [`Integer`](#sqlalchemy.types.Integer "sqlalchemy.types.Integer"), and [`DateTime`](#sqlalchemy.types.DateTime
    "sqlalchemy.types.DateTime"). All of the immediate subclasses of [`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") are “CamelCase” types. The “CamelCase” types are
    to the greatest degree possible **database agnostic**, meaning they can all be
    used on any database backend where they will behave in such a way as appropriate
    to that backend in order to produce the desired behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of a straightforward “CamelCase” datatype is [`String`](#sqlalchemy.types.String
    "sqlalchemy.types.String"). On most backends, using this datatype in a [table
    specification](metadata.html#metadata-describing) will correspond to the `VARCHAR`
    database type being used on the target backend, delivering string values to and
    from the database, as in the example below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: When using a particular [`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") class in a [`Table`](metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") definition or in any SQL expression overall, if no
    arguments are required it may be passed as the class itself, that is, without
    instantiating it with `()`. If arguments are needed, such as the length argument
    of 60 in the `"email_address"` column above, the type may be instantiated.
  prefs: []
  type: TYPE_NORMAL
- en: Another “CamelCase” datatype that expresses more backend-specific behavior is
    the [`Boolean`](#sqlalchemy.types.Boolean "sqlalchemy.types.Boolean") datatype.
    Unlike [`String`](#sqlalchemy.types.String "sqlalchemy.types.String"), which represents
    a string datatype that all databases have, not every backend has a real “boolean”
    datatype; some make use of integers or BIT values 0 and 1, some have boolean literal
    constants `true` and `false` while others dont. For this datatype, [`Boolean`](#sqlalchemy.types.Boolean
    "sqlalchemy.types.Boolean") may render `BOOLEAN` on a backend such as PostgreSQL,
    `BIT` on the MySQL backend and `SMALLINT` on Oracle. As data is sent and received
    from the database using this type, based on the dialect in use it may be interpreting
    Python numeric or boolean values.
  prefs: []
  type: TYPE_NORMAL
- en: The typical SQLAlchemy application will likely wish to use primarily “CamelCase”
    types in the general case, as they will generally provide the best basic behavior
    and be automatically portable to all backends.
  prefs: []
  type: TYPE_NORMAL
- en: Reference for the general set of “CamelCase” datatypes is below at [Generic
    “CamelCase” Types](#types-generic).
  prefs: []
  type: TYPE_NORMAL
- en: The “UPPERCASE” datatypes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In contrast to the “CamelCase” types are the “UPPERCASE” datatypes. These datatypes
    are always inherited from a particular “CamelCase” datatype, and always represent
    an **exact** datatype. When using an “UPPERCASE” datatype, the name of the type
    is always rendered exactly as given, without regard for whether or not the current
    backend supports it. Therefore the use of “UPPERCASE” types in a SQLAlchemy application
    indicates that specific datatypes are required, which then implies that the application
    would normally, without additional steps taken, be limited to those backends which
    use the type exactly as given. Examples of UPPERCASE types include [`VARCHAR`](#sqlalchemy.types.VARCHAR
    "sqlalchemy.types.VARCHAR"), [`NUMERIC`](#sqlalchemy.types.NUMERIC "sqlalchemy.types.NUMERIC"),
    [`INTEGER`](#sqlalchemy.types.INTEGER "sqlalchemy.types.INTEGER"), and [`TIMESTAMP`](#sqlalchemy.types.TIMESTAMP
    "sqlalchemy.types.TIMESTAMP"), which inherit directly from the previously mentioned
    “CamelCase” types [`String`](#sqlalchemy.types.String "sqlalchemy.types.String"),
    [`Numeric`](#sqlalchemy.types.Numeric "sqlalchemy.types.Numeric"), [`Integer`](#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer"), and [`DateTime`](#sqlalchemy.types.DateTime "sqlalchemy.types.DateTime"),
    respectively.
  prefs: []
  type: TYPE_NORMAL
- en: The “UPPERCASE” datatypes that are part of `sqlalchemy.types` are common SQL
    types that typically expect to be available on at least two backends if not more.
  prefs: []
  type: TYPE_NORMAL
- en: Reference for the general set of “UPPERCASE” datatypes is below at [SQL Standard
    and Multiple Vendor “UPPERCASE” Types](#types-sqlstandard).
  prefs: []
  type: TYPE_NORMAL
- en: '## Backend-specific “UPPERCASE” datatypes'
  prefs: []
  type: TYPE_NORMAL
- en: Most databases also have their own datatypes that are either fully specific
    to those databases, or add additional arguments that are specific to those databases.
    For these datatypes, specific SQLAlchemy dialects provide **backend-specific**
    “UPPERCASE” datatypes, for a SQL type that has no analogue on other backends.
    Examples of backend-specific uppercase datatypes include PostgreSQL’s [`JSONB`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSONB
    "sqlalchemy.dialects.postgresql.JSONB"), SQL Server’s [`IMAGE`](../dialects/mssql.html#sqlalchemy.dialects.mssql.IMAGE
    "sqlalchemy.dialects.mssql.IMAGE") and MySQL’s [`TINYTEXT`](../dialects/mysql.html#sqlalchemy.dialects.mysql.TINYTEXT
    "sqlalchemy.dialects.mysql.TINYTEXT").
  prefs: []
  type: TYPE_NORMAL
- en: Specific backends may also include “UPPERCASE” datatypes that extend the arguments
    available from that same “UPPERCASE” datatype as found in the `sqlalchemy.types`
    module. An example is when creating a MySQL string datatype, one might want to
    specify MySQL-specific arguments such as `charset` or `national`, which are available
    from the MySQL version of [`VARCHAR`](../dialects/mysql.html#sqlalchemy.dialects.mysql.VARCHAR
    "sqlalchemy.dialects.mysql.VARCHAR") as the MySQL-only parameters [`VARCHAR.charset`](../dialects/mysql.html#sqlalchemy.dialects.mysql.VARCHAR.params.charset
    "sqlalchemy.dialects.mysql.VARCHAR") and [`VARCHAR.national`](../dialects/mysql.html#sqlalchemy.dialects.mysql.VARCHAR.params.national
    "sqlalchemy.dialects.mysql.VARCHAR").
  prefs: []
  type: TYPE_NORMAL
- en: API documentation for backend-specific types are in the dialect-specific documentation,
    listed at [Dialects](../dialects/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: '## Using “UPPERCASE” and Backend-specific types for multiple backends'
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing the presence of “UPPERCASE” and “CamelCase” types leads to the natural
    use case of how to make use of “UPPERCASE” datatypes for backend-specific options,
    but only when that backend is in use. To tie together the database-agnostic “CamelCase”
    and backend-specific “UPPERCASE” systems, one makes use of the [`TypeEngine.with_variant()`](type_api.html#sqlalchemy.types.TypeEngine.with_variant
    "sqlalchemy.types.TypeEngine.with_variant") method in order to **compose** types
    together to work with specific behaviors on specific backends.
  prefs: []
  type: TYPE_NORMAL
- en: 'Such as, to use the [`String`](#sqlalchemy.types.String "sqlalchemy.types.String")
    datatype, but when running on MySQL to make use of the [`VARCHAR.charset`](../dialects/mysql.html#sqlalchemy.dialects.mysql.VARCHAR.params.charset
    "sqlalchemy.dialects.mysql.VARCHAR") parameter of [`VARCHAR`](../dialects/mysql.html#sqlalchemy.dialects.mysql.VARCHAR
    "sqlalchemy.dialects.mysql.VARCHAR") when the table is created on MySQL or MariaDB,
    [`TypeEngine.with_variant()`](type_api.html#sqlalchemy.types.TypeEngine.with_variant
    "sqlalchemy.types.TypeEngine.with_variant") may be used as below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: In the above table definition, the `"bio"` column will have string-behaviors
    on all backends. On most backends it will render in DDL as `VARCHAR`. However
    on MySQL and MariaDB (indicated by database URLs that start with `mysql` or `mariadb`),
    it will render as `VARCHAR(255) CHARACTER SET utf8`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`TypeEngine.with_variant()`](type_api.html#sqlalchemy.types.TypeEngine.with_variant
    "sqlalchemy.types.TypeEngine.with_variant") - additional usage examples and notes'
  prefs: []
  type: TYPE_NORMAL
- en: '## Generic “CamelCase” Types'
  prefs: []
  type: TYPE_NORMAL
- en: Generic types specify a column that can read, write and store a particular type
    of Python data. SQLAlchemy will choose the best database column type available
    on the target database when issuing a `CREATE TABLE` statement. For complete control
    over which column type is emitted in `CREATE TABLE`, such as `VARCHAR` see [SQL
    Standard and Multiple Vendor “UPPERCASE” Types](#types-sqlstandard) and the other
    sections of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '| Object Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| [BigInteger](#sqlalchemy.types.BigInteger) | A type for bigger `int` integers.
    |'
  prefs: []
  type: TYPE_TB
- en: '| [Boolean](#sqlalchemy.types.Boolean) | A bool datatype. |'
  prefs: []
  type: TYPE_TB
- en: '| [Date](#sqlalchemy.types.Date) | A type for `datetime.date()` objects. |'
  prefs: []
  type: TYPE_TB
- en: '| [DateTime](#sqlalchemy.types.DateTime) | A type for `datetime.datetime()`
    objects. |'
  prefs: []
  type: TYPE_TB
- en: '| [Double](#sqlalchemy.types.Double) | A type for double `FLOAT` floating point
    types. |'
  prefs: []
  type: TYPE_TB
- en: '| [Enum](#sqlalchemy.types.Enum) | Generic Enum Type. |'
  prefs: []
  type: TYPE_TB
- en: '| [Float](#sqlalchemy.types.Float) | Type representing floating point types,
    such as `FLOAT` or `REAL`. |'
  prefs: []
  type: TYPE_TB
- en: '| [Integer](#sqlalchemy.types.Integer) | A type for `int` integers. |'
  prefs: []
  type: TYPE_TB
- en: '| [Interval](#sqlalchemy.types.Interval) | A type for `datetime.timedelta()`
    objects. |'
  prefs: []
  type: TYPE_TB
- en: '| [LargeBinary](#sqlalchemy.types.LargeBinary) | A type for large binary byte
    data. |'
  prefs: []
  type: TYPE_TB
- en: '| [MatchType](#sqlalchemy.types.MatchType) | Refers to the return type of the
    MATCH operator. |'
  prefs: []
  type: TYPE_TB
- en: '| [Numeric](#sqlalchemy.types.Numeric) | Base for non-integer numeric types,
    such as `NUMERIC`, `FLOAT`, `DECIMAL`, and other variants. |'
  prefs: []
  type: TYPE_TB
- en: '| [PickleType](#sqlalchemy.types.PickleType) | Holds Python objects, which
    are serialized using pickle. |'
  prefs: []
  type: TYPE_TB
- en: '| [SchemaType](#sqlalchemy.types.SchemaType) | Add capabilities to a type which
    allow for schema-level DDL to be associated with a type. |'
  prefs: []
  type: TYPE_TB
- en: '| [SmallInteger](#sqlalchemy.types.SmallInteger) | A type for smaller `int`
    integers. |'
  prefs: []
  type: TYPE_TB
- en: '| [String](#sqlalchemy.types.String) | The base for all string and character
    types. |'
  prefs: []
  type: TYPE_TB
- en: '| [Text](#sqlalchemy.types.Text) | A variably sized string type. |'
  prefs: []
  type: TYPE_TB
- en: '| [Time](#sqlalchemy.types.Time) | A type for `datetime.time()` objects. |'
  prefs: []
  type: TYPE_TB
- en: '| [Unicode](#sqlalchemy.types.Unicode) | A variable length Unicode string type.
    |'
  prefs: []
  type: TYPE_TB
- en: '| [UnicodeText](#sqlalchemy.types.UnicodeText) | An unbounded-length Unicode
    string type. |'
  prefs: []
  type: TYPE_TB
- en: '| [Uuid](#sqlalchemy.types.Uuid) | Represent a database agnostic UUID datatype.
    |'
  prefs: []
  type: TYPE_TB
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: A type for bigger `int` integers.
  prefs: []
  type: TYPE_NORMAL
- en: Typically generates a `BIGINT` in DDL, and otherwise acts like a normal [`Integer`](#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer") on the Python side.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.types.BigInteger`](#sqlalchemy.types.BigInteger "sqlalchemy.types.BigInteger")
    ([`sqlalchemy.types.Integer`](#sqlalchemy.types.Integer "sqlalchemy.types.Integer"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: A bool datatype.
  prefs: []
  type: TYPE_NORMAL
- en: '[`Boolean`](#sqlalchemy.types.Boolean "sqlalchemy.types.Boolean") typically
    uses BOOLEAN or SMALLINT on the DDL side, and on the Python side deals in `True`
    or `False`.'
  prefs: []
  type: TYPE_NORMAL
- en: The [`Boolean`](#sqlalchemy.types.Boolean "sqlalchemy.types.Boolean") datatype
    currently has two levels of assertion that the values persisted are simple true/false
    values. For all backends, only the Python values `None`, `True`, `False`, `1`
    or `0` are accepted as parameter values. For those backends that don’t support
    a “native boolean” datatype, an option exists to also create a CHECK constraint
    on the target column
  prefs: []
  type: TYPE_NORMAL
- en: 'Changed in version 1.2: the [`Boolean`](#sqlalchemy.types.Boolean "sqlalchemy.types.Boolean")
    datatype now asserts that incoming Python values are already in pure boolean form.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.types.Boolean.__init__), [bind_processor()](#sqlalchemy.types.Boolean.bind_processor),
    [literal_processor()](#sqlalchemy.types.Boolean.literal_processor), [python_type](#sqlalchemy.types.Boolean.python_type),
    [result_processor()](#sqlalchemy.types.Boolean.result_processor)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.types.Boolean`](#sqlalchemy.types.Boolean "sqlalchemy.types.Boolean")
    ([`sqlalchemy.types.SchemaType`](#sqlalchemy.types.SchemaType "sqlalchemy.types.SchemaType"),
    `sqlalchemy.types.Emulated`, [`sqlalchemy.types.TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: Construct a Boolean.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`create_constraint` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: defaults to False. If the boolean is generated as an int/smallint, also create
    a CHECK constraint on the table that ensures 1 or 0 as a value.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: it is strongly recommended that the CHECK constraint have an explicit name in
    order to support schema-management concerns. This can be established either by
    setting the [`Boolean.name`](#sqlalchemy.types.Boolean.params.name "sqlalchemy.types.Boolean")
    parameter or by setting up an appropriate naming convention; see [Configuring
    Constraint Naming Conventions](constraints.html#constraint-naming-conventions)
    for background.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Changed in version 1.4: - this flag now defaults to False, meaning no CHECK
    constraint is generated for a non-native enumerated type.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`name` – if a CHECK constraint is generated, specify the name of the constraint.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: Return a conversion function for processing bind values.
  prefs: []
  type: TYPE_NORMAL
- en: Returns a callable which will receive a bind parameter value as the sole positional
    argument and will return a value to send to the DB-API.
  prefs: []
  type: TYPE_NORMAL
- en: If processing is not necessary, the method should return `None`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This method is only called relative to a **dialect specific type object**, which
    is often **private to a dialect in use** and is not the same type object as the
    public facing one, which means it’s not feasible to subclass a [`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") class in order to provide an alternate [`TypeEngine.bind_processor()`](type_api.html#sqlalchemy.types.TypeEngine.bind_processor
    "sqlalchemy.types.TypeEngine.bind_processor") method, unless subclassing the [`UserDefinedType`](custom_types.html#sqlalchemy.types.UserDefinedType
    "sqlalchemy.types.UserDefinedType") class explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: To provide alternate behavior for [`TypeEngine.bind_processor()`](type_api.html#sqlalchemy.types.TypeEngine.bind_processor
    "sqlalchemy.types.TypeEngine.bind_processor"), implement a [`TypeDecorator`](custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") class and provide an implementation of [`TypeDecorator.process_bind_param()`](custom_types.html#sqlalchemy.types.TypeDecorator.process_bind_param
    "sqlalchemy.types.TypeDecorator.process_bind_param").
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Augmenting Existing Types](custom_types.html#types-typedecorator)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**dialect** – Dialect instance in use.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: Return a conversion function for processing literal values that are to be rendered
    directly without using binds.
  prefs: []
  type: TYPE_NORMAL
- en: This function is used when the compiler makes use of the “literal_binds” flag,
    typically used in DDL generation as well as in certain scenarios where backends
    don’t accept bound parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Returns a callable which will receive a literal Python value as the sole positional
    argument and will return a string representation to be rendered in a SQL statement.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This method is only called relative to a **dialect specific type object**, which
    is often **private to a dialect in use** and is not the same type object as the
    public facing one, which means it’s not feasible to subclass a [`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") class in order to provide an alternate [`TypeEngine.literal_processor()`](type_api.html#sqlalchemy.types.TypeEngine.literal_processor
    "sqlalchemy.types.TypeEngine.literal_processor") method, unless subclassing the
    [`UserDefinedType`](custom_types.html#sqlalchemy.types.UserDefinedType "sqlalchemy.types.UserDefinedType")
    class explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: To provide alternate behavior for [`TypeEngine.literal_processor()`](type_api.html#sqlalchemy.types.TypeEngine.literal_processor
    "sqlalchemy.types.TypeEngine.literal_processor"), implement a [`TypeDecorator`](custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") class and provide an implementation of [`TypeDecorator.process_literal_param()`](custom_types.html#sqlalchemy.types.TypeDecorator.process_literal_param
    "sqlalchemy.types.TypeDecorator.process_literal_param").
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Augmenting Existing Types](custom_types.html#types-typedecorator)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: Return a conversion function for processing result row values.
  prefs: []
  type: TYPE_NORMAL
- en: Returns a callable which will receive a result row column value as the sole
    positional argument and will return a value to return to the user.
  prefs: []
  type: TYPE_NORMAL
- en: If processing is not necessary, the method should return `None`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This method is only called relative to a **dialect specific type object**, which
    is often **private to a dialect in use** and is not the same type object as the
    public facing one, which means it’s not feasible to subclass a [`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") class in order to provide an alternate [`TypeEngine.result_processor()`](type_api.html#sqlalchemy.types.TypeEngine.result_processor
    "sqlalchemy.types.TypeEngine.result_processor") method, unless subclassing the
    [`UserDefinedType`](custom_types.html#sqlalchemy.types.UserDefinedType "sqlalchemy.types.UserDefinedType")
    class explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: To provide alternate behavior for [`TypeEngine.result_processor()`](type_api.html#sqlalchemy.types.TypeEngine.result_processor
    "sqlalchemy.types.TypeEngine.result_processor"), implement a [`TypeDecorator`](custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") class and provide an implementation of [`TypeDecorator.process_result_value()`](custom_types.html#sqlalchemy.types.TypeDecorator.process_result_value
    "sqlalchemy.types.TypeDecorator.process_result_value").
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Augmenting Existing Types](custom_types.html#types-typedecorator)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dialect` – Dialect instance in use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`coltype` – DBAPI coltype argument received in cursor.description.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE225]'
  prefs: []
  type: TYPE_PRE
- en: A type for `datetime.date()` objects.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[get_dbapi_type()](#sqlalchemy.types.Date.get_dbapi_type), [literal_processor()](#sqlalchemy.types.Date.literal_processor),
    [python_type](#sqlalchemy.types.Date.python_type)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.types.Date`](#sqlalchemy.types.Date "sqlalchemy.types.Date")
    (`sqlalchemy.types._RenderISO8601NoT`, `sqlalchemy.types.HasExpressionLookup`,
    [`sqlalchemy.types.TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine "sqlalchemy.types.TypeEngine"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: Return the corresponding type object from the underlying DB-API, if any.
  prefs: []
  type: TYPE_NORMAL
- en: This can be useful for calling `setinputsizes()`, for example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE227]'
  prefs: []
  type: TYPE_PRE
- en: Return a conversion function for processing literal values that are to be rendered
    directly without using binds.
  prefs: []
  type: TYPE_NORMAL
- en: This function is used when the compiler makes use of the “literal_binds” flag,
    typically used in DDL generation as well as in certain scenarios where backends
    don’t accept bound parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Returns a callable which will receive a literal Python value as the sole positional
    argument and will return a string representation to be rendered in a SQL statement.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This method is only called relative to a **dialect specific type object**, which
    is often **private to a dialect in use** and is not the same type object as the
    public facing one, which means it’s not feasible to subclass a [`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") class in order to provide an alternate [`TypeEngine.literal_processor()`](type_api.html#sqlalchemy.types.TypeEngine.literal_processor
    "sqlalchemy.types.TypeEngine.literal_processor") method, unless subclassing the
    [`UserDefinedType`](custom_types.html#sqlalchemy.types.UserDefinedType "sqlalchemy.types.UserDefinedType")
    class explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: To provide alternate behavior for [`TypeEngine.literal_processor()`](type_api.html#sqlalchemy.types.TypeEngine.literal_processor
    "sqlalchemy.types.TypeEngine.literal_processor"), implement a [`TypeDecorator`](custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") class and provide an implementation of [`TypeDecorator.process_literal_param()`](custom_types.html#sqlalchemy.types.TypeDecorator.process_literal_param
    "sqlalchemy.types.TypeDecorator.process_literal_param").
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Augmenting Existing Types](custom_types.html#types-typedecorator)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE228]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE229]'
  prefs: []
  type: TYPE_PRE
- en: A type for `datetime.datetime()` objects.
  prefs: []
  type: TYPE_NORMAL
- en: Date and time types return objects from the Python `datetime` module. Most DBAPIs
    have built in support for the datetime module, with the noted exception of SQLite.
    In the case of SQLite, date and time types are stored as strings which are then
    converted back to datetime objects when rows are returned.
  prefs: []
  type: TYPE_NORMAL
- en: For the time representation within the datetime type, some backends include
    additional options, such as timezone support and fractional seconds support. For
    fractional seconds, use the dialect-specific datatype, such as [`TIME`](../dialects/mysql.html#sqlalchemy.dialects.mysql.TIME
    "sqlalchemy.dialects.mysql.TIME"). For timezone support, use at least the [`TIMESTAMP`](#sqlalchemy.types.TIMESTAMP
    "sqlalchemy.types.TIMESTAMP") datatype, if not the dialect-specific datatype object.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.types.DateTime.__init__), [get_dbapi_type()](#sqlalchemy.types.DateTime.get_dbapi_type),
    [literal_processor()](#sqlalchemy.types.DateTime.literal_processor), [python_type](#sqlalchemy.types.DateTime.python_type)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.types.DateTime`](#sqlalchemy.types.DateTime "sqlalchemy.types.DateTime")
    (`sqlalchemy.types._RenderISO8601NoT`, `sqlalchemy.types.HasExpressionLookup`,
    [`sqlalchemy.types.TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine "sqlalchemy.types.TypeEngine"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE230]'
  prefs: []
  type: TYPE_PRE
- en: Construct a new [`DateTime`](#sqlalchemy.types.DateTime "sqlalchemy.types.DateTime").
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**timezone** – boolean. Indicates that the datetime type should enable timezone
    support, if available on the **base date/time-holding type only**. It is recommended
    to make use of the [`TIMESTAMP`](#sqlalchemy.types.TIMESTAMP "sqlalchemy.types.TIMESTAMP")
    datatype directly when using this flag, as some databases include separate generic
    date/time-holding types distinct from the timezone-capable TIMESTAMP datatype,
    such as Oracle.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE231]'
  prefs: []
  type: TYPE_PRE
- en: Return the corresponding type object from the underlying DB-API, if any.
  prefs: []
  type: TYPE_NORMAL
- en: This can be useful for calling `setinputsizes()`, for example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE232]'
  prefs: []
  type: TYPE_PRE
- en: Return a conversion function for processing literal values that are to be rendered
    directly without using binds.
  prefs: []
  type: TYPE_NORMAL
- en: This function is used when the compiler makes use of the “literal_binds” flag,
    typically used in DDL generation as well as in certain scenarios where backends
    don’t accept bound parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Returns a callable which will receive a literal Python value as the sole positional
    argument and will return a string representation to be rendered in a SQL statement.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This method is only called relative to a **dialect specific type object**, which
    is often **private to a dialect in use** and is not the same type object as the
    public facing one, which means it’s not feasible to subclass a [`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") class in order to provide an alternate [`TypeEngine.literal_processor()`](type_api.html#sqlalchemy.types.TypeEngine.literal_processor
    "sqlalchemy.types.TypeEngine.literal_processor") method, unless subclassing the
    [`UserDefinedType`](custom_types.html#sqlalchemy.types.UserDefinedType "sqlalchemy.types.UserDefinedType")
    class explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: To provide alternate behavior for [`TypeEngine.literal_processor()`](type_api.html#sqlalchemy.types.TypeEngine.literal_processor
    "sqlalchemy.types.TypeEngine.literal_processor"), implement a [`TypeDecorator`](custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") class and provide an implementation of [`TypeDecorator.process_literal_param()`](custom_types.html#sqlalchemy.types.TypeDecorator.process_literal_param
    "sqlalchemy.types.TypeDecorator.process_literal_param").
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Augmenting Existing Types](custom_types.html#types-typedecorator)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE233]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE234]'
  prefs: []
  type: TYPE_PRE
- en: Generic Enum Type.
  prefs: []
  type: TYPE_NORMAL
- en: The [`Enum`](#sqlalchemy.types.Enum "sqlalchemy.types.Enum") type provides a
    set of possible string values which the column is constrained towards.
  prefs: []
  type: TYPE_NORMAL
- en: The [`Enum`](#sqlalchemy.types.Enum "sqlalchemy.types.Enum") type will make
    use of the backend’s native “ENUM” type if one is available; otherwise, it uses
    a VARCHAR datatype. An option also exists to automatically produce a CHECK constraint
    when the VARCHAR (so called “non-native”) variant is produced; see the [`Enum.create_constraint`](#sqlalchemy.types.Enum.params.create_constraint
    "sqlalchemy.types.Enum") flag.
  prefs: []
  type: TYPE_NORMAL
- en: The [`Enum`](#sqlalchemy.types.Enum "sqlalchemy.types.Enum") type also provides
    in-Python validation of string values during both read and write operations. When
    reading a value from the database in a result set, the string value is always
    checked against the list of possible values and a `LookupError` is raised if no
    match is found. When passing a value to the database as a plain string within
    a SQL statement, if the [`Enum.validate_strings`](#sqlalchemy.types.Enum.params.validate_strings
    "sqlalchemy.types.Enum") parameter is set to True, a `LookupError` is raised for
    any string value that’s not located in the given list of possible values; note
    that this impacts usage of LIKE expressions with enumerated values (an unusual
    use case).
  prefs: []
  type: TYPE_NORMAL
- en: The source of enumerated values may be a list of string values, or alternatively
    a PEP-435-compliant enumerated class. For the purposes of the [`Enum`](#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum") datatype, this class need only provide a `__members__`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using an enumerated class, the enumerated objects are used both for input
    and output, rather than strings as is the case with a plain-string enumerated
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE235]'
  prefs: []
  type: TYPE_PRE
- en: Above, the string names of each element, e.g. “one”, “two”, “three”, are persisted
    to the database; the values of the Python Enum, here indicated as integers, are
    **not** used; the value of each enum can therefore be any kind of Python object
    whether or not it is persistable.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to persist the values and not the names, the [`Enum.values_callable`](#sqlalchemy.types.Enum.params.values_callable
    "sqlalchemy.types.Enum") parameter may be used. The value of this parameter is
    a user-supplied callable, which is intended to be used with a PEP-435-compliant
    enumerated class and returns a list of string values to be persisted. For a simple
    enumeration that uses string values, a callable such as `lambda x: [e.value for
    e in x]` is sufficient.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Using Python Enum or pep-586 Literal types in the type map](../orm/declarative_tables.html#orm-declarative-mapped-column-enums)
    - background on using the [`Enum`](#sqlalchemy.types.Enum "sqlalchemy.types.Enum")
    datatype with the ORM’s [ORM Annotated Declarative](../orm/declarative_tables.html#orm-declarative-mapped-column)
    feature.'
  prefs: []
  type: TYPE_NORMAL
- en: '[`ENUM`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ENUM "sqlalchemy.dialects.postgresql.ENUM")
    - PostgreSQL-specific type, which has additional functionality.'
  prefs: []
  type: TYPE_NORMAL
- en: '[`ENUM`](../dialects/mysql.html#sqlalchemy.dialects.mysql.ENUM "sqlalchemy.dialects.mysql.ENUM")
    - MySQL-specific type'
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.types.Enum.__init__), [create()](#sqlalchemy.types.Enum.create),
    [drop()](#sqlalchemy.types.Enum.drop)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.types.Enum`](#sqlalchemy.types.Enum "sqlalchemy.types.Enum")
    ([`sqlalchemy.types.String`](#sqlalchemy.types.String "sqlalchemy.types.String"),
    [`sqlalchemy.types.SchemaType`](#sqlalchemy.types.SchemaType "sqlalchemy.types.SchemaType"),
    `sqlalchemy.types.Emulated`, [`sqlalchemy.types.TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE236]'
  prefs: []
  type: TYPE_PRE
- en: Construct an enum.
  prefs: []
  type: TYPE_NORMAL
- en: Keyword arguments which don’t apply to a specific backend are ignored by that
    backend.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`*enums` – either exactly one PEP-435 compliant enumerated type or one or more
    string labels.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`create_constraint` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: defaults to False. When creating a non-native enumerated type, also build a
    CHECK constraint on the database against the valid values.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: it is strongly recommended that the CHECK constraint have an explicit name in
    order to support schema-management concerns. This can be established either by
    setting the [`Enum.name`](#sqlalchemy.types.Enum.params.name "sqlalchemy.types.Enum")
    parameter or by setting up an appropriate naming convention; see [Configuring
    Constraint Naming Conventions](constraints.html#constraint-naming-conventions)
    for background.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Changed in version 1.4: - this flag now defaults to False, meaning no CHECK
    constraint is generated for a non-native enumerated type.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`metadata` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Associate this type directly with a `MetaData` object. For types that exist
    on the target database as an independent schema construct (PostgreSQL), this type
    will be created and dropped within `create_all()` and `drop_all()` operations.
    If the type is not associated with any `MetaData` object, it will associate itself
    with each `Table` in which it is used, and will be created when any of those individual
    tables are created, after a check is performed for its existence. The type is
    only dropped when `drop_all()` is called for that `Table` object’s metadata, however.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The value of the [`MetaData.schema`](metadata.html#sqlalchemy.schema.MetaData.params.schema
    "sqlalchemy.schema.MetaData") parameter of the [`MetaData`](metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") object, if set, will be used as the default value
    of the [`Enum.schema`](#sqlalchemy.types.Enum.params.schema "sqlalchemy.types.Enum")
    on this object if an explicit value is not otherwise supplied.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Changed in version 1.4.12: [`Enum`](#sqlalchemy.types.Enum "sqlalchemy.types.Enum")
    inherits the [`MetaData.schema`](metadata.html#sqlalchemy.schema.MetaData.params.schema
    "sqlalchemy.schema.MetaData") parameter of the [`MetaData`](metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") object if present, when passed using the [`Enum.metadata`](#sqlalchemy.types.Enum.params.metadata
    "sqlalchemy.types.Enum") parameter.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`name` – The name of this type. This is required for PostgreSQL and any future
    supported database which requires an explicitly named type, or an explicitly named
    constraint in order to generate the type and/or a table that uses it. If a PEP-435
    enumerated class was used, its name (converted to lower case) is used by default.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`native_enum` – Use the database’s native ENUM type when available. Defaults
    to True. When False, uses VARCHAR + check constraint for all backends. When False,
    the VARCHAR length can be controlled with [`Enum.length`](#sqlalchemy.types.Enum.params.length
    "sqlalchemy.types.Enum"); currently “length” is ignored if native_enum=True.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`length` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allows specifying a custom length for the VARCHAR when a non-native enumeration
    datatype is used. By default it uses the length of the longest value.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Changed in version 2.0.0: The [`Enum.length`](#sqlalchemy.types.Enum.params.length
    "sqlalchemy.types.Enum") parameter is used unconditionally for `VARCHAR` rendering
    regardless of the [`Enum.native_enum`](#sqlalchemy.types.Enum.params.native_enum
    "sqlalchemy.types.Enum") parameter, for those backends where `VARCHAR` is used
    for enumerated datatypes.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`schema` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Schema name of this type. For types that exist on the target database as an
    independent schema construct (PostgreSQL), this parameter specifies the named
    schema in which the type is present.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If not present, the schema name will be taken from the [`MetaData`](metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") collection if passed as [`Enum.metadata`](#sqlalchemy.types.Enum.params.metadata
    "sqlalchemy.types.Enum"), for a [`MetaData`](metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") that includes the [`MetaData.schema`](metadata.html#sqlalchemy.schema.MetaData.params.schema
    "sqlalchemy.schema.MetaData") parameter.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Changed in version 1.4.12: [`Enum`](#sqlalchemy.types.Enum "sqlalchemy.types.Enum")
    inherits the [`MetaData.schema`](metadata.html#sqlalchemy.schema.MetaData.params.schema
    "sqlalchemy.schema.MetaData") parameter of the [`MetaData`](metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") object if present, when passed using the [`Enum.metadata`](#sqlalchemy.types.Enum.params.metadata
    "sqlalchemy.types.Enum") parameter.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Otherwise, if the [`Enum.inherit_schema`](#sqlalchemy.types.Enum.params.inherit_schema
    "sqlalchemy.types.Enum") flag is set to `True`, the schema will be inherited from
    the associated [`Table`](metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    object if any; when [`Enum.inherit_schema`](#sqlalchemy.types.Enum.params.inherit_schema
    "sqlalchemy.types.Enum") is at its default of `False`, the owning table’s schema
    is **not** used.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`quote` – Set explicit quoting preferences for the type’s name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`inherit_schema` – When `True`, the “schema” from the owning [`Table`](metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") will be copied to the “schema” attribute of this [`Enum`](#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum"), replacing whatever value was passed for the `schema`
    attribute. This also takes effect when using the [`Table.to_metadata()`](metadata.html#sqlalchemy.schema.Table.to_metadata
    "sqlalchemy.schema.Table.to_metadata") operation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`validate_strings` – when True, string values that are being passed to the
    database in a SQL statement will be checked for validity against the list of enumerated
    values. Unrecognized values will result in a `LookupError` being raised.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`values_callable` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A callable which will be passed the PEP-435 compliant enumerated type, which
    should then return a list of string values to be persisted. This allows for alternate
    usages such as using the string value of an enum to be persisted to the database
    instead of its name. The callable must return the values to be persisted in the
    same order as iterating through the Enum’s `__member__` attribute. For example
    `lambda x: [i.value for i in x]`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: New in version 1.2.3.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`sort_key_function` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a Python callable which may be used as the “key” argument in the Python `sorted()`
    built-in. The SQLAlchemy ORM requires that primary key columns which are mapped
    must be sortable in some way. When using an unsortable enumeration object such
    as a Python 3 `Enum` object, this parameter may be used to set a default sort
    key function for the objects. By default, the database value of the enumeration
    is used as the sorting function.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: New in version 1.3.8.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`omit_aliases` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A boolean that when true will remove aliases from pep 435 enums. defaults to
    `True`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Changed in version 2.0: This parameter now defaults to True.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE237]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`SchemaType.create()`](#sqlalchemy.types.SchemaType.create
    "sqlalchemy.types.SchemaType.create") *method of* [`SchemaType`](#sqlalchemy.types.SchemaType
    "sqlalchemy.types.SchemaType")'
  prefs: []
  type: TYPE_NORMAL
- en: Issue CREATE DDL for this type, if applicable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE238]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* [`SchemaType.drop()`](#sqlalchemy.types.SchemaType.drop
    "sqlalchemy.types.SchemaType.drop") *method of* [`SchemaType`](#sqlalchemy.types.SchemaType
    "sqlalchemy.types.SchemaType")'
  prefs: []
  type: TYPE_NORMAL
- en: Issue DROP DDL for this type, if applicable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE239]'
  prefs: []
  type: TYPE_PRE
- en: A type for double `FLOAT` floating point types.
  prefs: []
  type: TYPE_NORMAL
- en: Typically generates a `DOUBLE` or `DOUBLE_PRECISION` in DDL, and otherwise acts
    like a normal [`Float`](#sqlalchemy.types.Float "sqlalchemy.types.Float") on the
    Python side.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.types.Double`](#sqlalchemy.types.Double "sqlalchemy.types.Double")
    ([`sqlalchemy.types.Float`](#sqlalchemy.types.Float "sqlalchemy.types.Float"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE240]'
  prefs: []
  type: TYPE_PRE
- en: Type representing floating point types, such as `FLOAT` or `REAL`.
  prefs: []
  type: TYPE_NORMAL
- en: This type returns Python `float` objects by default, unless the [`Float.asdecimal`](#sqlalchemy.types.Float.params.asdecimal
    "sqlalchemy.types.Float") flag is set to `True`, in which case they are coerced
    to `decimal.Decimal` objects.
  prefs: []
  type: TYPE_NORMAL
- en: When a [`Float.precision`](#sqlalchemy.types.Float.params.precision "sqlalchemy.types.Float")
    is not provided in a [`Float`](#sqlalchemy.types.Float "sqlalchemy.types.Float")
    type some backend may compile this type as an 8 bytes / 64 bit float datatype.
    To use a 4 bytes / 32 bit float datatype a precision <= 24 can usually be provided
    or the [`REAL`](#sqlalchemy.types.REAL "sqlalchemy.types.REAL") type can be used.
    This is known to be the case in the PostgreSQL and MSSQL dialects that render
    the type as `FLOAT` that’s in both an alias of `DOUBLE PRECISION`. Other third
    party dialects may have similar behavior.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.types.Float.__init__), [result_processor()](#sqlalchemy.types.Float.result_processor)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.types.Float`](#sqlalchemy.types.Float "sqlalchemy.types.Float")
    ([`sqlalchemy.types.Numeric`](#sqlalchemy.types.Numeric "sqlalchemy.types.Numeric"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE241]'
  prefs: []
  type: TYPE_PRE
- en: Construct a Float.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`precision` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the numeric precision for use in DDL `CREATE TABLE`. Backends **should** attempt
    to ensure this precision indicates a number of digits for the generic [`Float`](#sqlalchemy.types.Float
    "sqlalchemy.types.Float") datatype.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For the Oracle backend, the [`Float.precision`](#sqlalchemy.types.Float.params.precision
    "sqlalchemy.types.Float") parameter is not accepted when rendering DDL, as Oracle
    does not support float precision specified as a number of decimal places. Instead,
    use the Oracle-specific [`FLOAT`](../dialects/oracle.html#sqlalchemy.dialects.oracle.FLOAT
    "sqlalchemy.dialects.oracle.FLOAT") datatype and specify the [`FLOAT.binary_precision`](../dialects/oracle.html#sqlalchemy.dialects.oracle.FLOAT.params.binary_precision
    "sqlalchemy.dialects.oracle.FLOAT") parameter. This is new in version 2.0 of SQLAlchemy.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To create a database agnostic [`Float`](#sqlalchemy.types.Float "sqlalchemy.types.Float")
    that separately specifies binary precision for Oracle, use [`TypeEngine.with_variant()`](type_api.html#sqlalchemy.types.TypeEngine.with_variant
    "sqlalchemy.types.TypeEngine.with_variant") as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE242]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`asdecimal` – the same flag as that of [`Numeric`](#sqlalchemy.types.Numeric
    "sqlalchemy.types.Numeric"), but defaults to `False`. Note that setting this flag
    to `True` results in floating point conversion.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`decimal_return_scale` – Default scale to use when converting from floats to
    Python decimals. Floating point values will typically be much longer due to decimal
    inaccuracy, and most floating point database types don’t have a notion of “scale”,
    so by default the float type looks for the first ten decimal places when converting.
    Specifying this value will override that length. Note that the MySQL float types,
    which do include “scale”, will use “scale” as the default for decimal_return_scale,
    if not otherwise specified.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE243]'
  prefs: []
  type: TYPE_PRE
- en: Return a conversion function for processing result row values.
  prefs: []
  type: TYPE_NORMAL
- en: Returns a callable which will receive a result row column value as the sole
    positional argument and will return a value to return to the user.
  prefs: []
  type: TYPE_NORMAL
- en: If processing is not necessary, the method should return `None`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This method is only called relative to a **dialect specific type object**, which
    is often **private to a dialect in use** and is not the same type object as the
    public facing one, which means it’s not feasible to subclass a [`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") class in order to provide an alternate [`TypeEngine.result_processor()`](type_api.html#sqlalchemy.types.TypeEngine.result_processor
    "sqlalchemy.types.TypeEngine.result_processor") method, unless subclassing the
    [`UserDefinedType`](custom_types.html#sqlalchemy.types.UserDefinedType "sqlalchemy.types.UserDefinedType")
    class explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: To provide alternate behavior for [`TypeEngine.result_processor()`](type_api.html#sqlalchemy.types.TypeEngine.result_processor
    "sqlalchemy.types.TypeEngine.result_processor"), implement a [`TypeDecorator`](custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") class and provide an implementation of [`TypeDecorator.process_result_value()`](custom_types.html#sqlalchemy.types.TypeDecorator.process_result_value
    "sqlalchemy.types.TypeDecorator.process_result_value").
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Augmenting Existing Types](custom_types.html#types-typedecorator)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dialect` – Dialect instance in use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`coltype` – DBAPI coltype argument received in cursor.description.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE244]'
  prefs: []
  type: TYPE_PRE
- en: A type for `int` integers.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[get_dbapi_type()](#sqlalchemy.types.Integer.get_dbapi_type), [literal_processor()](#sqlalchemy.types.Integer.literal_processor),
    [python_type](#sqlalchemy.types.Integer.python_type)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.types.Integer`](#sqlalchemy.types.Integer "sqlalchemy.types.Integer")
    (`sqlalchemy.types.HasExpressionLookup`, [`sqlalchemy.types.TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE245]'
  prefs: []
  type: TYPE_PRE
- en: Return the corresponding type object from the underlying DB-API, if any.
  prefs: []
  type: TYPE_NORMAL
- en: This can be useful for calling `setinputsizes()`, for example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE246]'
  prefs: []
  type: TYPE_PRE
- en: Return a conversion function for processing literal values that are to be rendered
    directly without using binds.
  prefs: []
  type: TYPE_NORMAL
- en: This function is used when the compiler makes use of the “literal_binds” flag,
    typically used in DDL generation as well as in certain scenarios where backends
    don’t accept bound parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Returns a callable which will receive a literal Python value as the sole positional
    argument and will return a string representation to be rendered in a SQL statement.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This method is only called relative to a **dialect specific type object**, which
    is often **private to a dialect in use** and is not the same type object as the
    public facing one, which means it’s not feasible to subclass a [`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") class in order to provide an alternate [`TypeEngine.literal_processor()`](type_api.html#sqlalchemy.types.TypeEngine.literal_processor
    "sqlalchemy.types.TypeEngine.literal_processor") method, unless subclassing the
    [`UserDefinedType`](custom_types.html#sqlalchemy.types.UserDefinedType "sqlalchemy.types.UserDefinedType")
    class explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: To provide alternate behavior for [`TypeEngine.literal_processor()`](type_api.html#sqlalchemy.types.TypeEngine.literal_processor
    "sqlalchemy.types.TypeEngine.literal_processor"), implement a [`TypeDecorator`](custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") class and provide an implementation of [`TypeDecorator.process_literal_param()`](custom_types.html#sqlalchemy.types.TypeDecorator.process_literal_param
    "sqlalchemy.types.TypeDecorator.process_literal_param").
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Augmenting Existing Types](custom_types.html#types-typedecorator)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE247]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE248]'
  prefs: []
  type: TYPE_PRE
- en: A type for `datetime.timedelta()` objects.
  prefs: []
  type: TYPE_NORMAL
- en: The Interval type deals with `datetime.timedelta` objects. In PostgreSQL and
    Oracle, the native `INTERVAL` type is used; for others, the value is stored as
    a date which is relative to the “epoch” (Jan. 1, 1970).
  prefs: []
  type: TYPE_NORMAL
- en: Note that the `Interval` type does not currently provide date arithmetic operations
    on platforms which do not support interval types natively. Such operations usually
    require transformation of both sides of the expression (such as, conversion of
    both sides into integer epoch values first) which currently is a manual procedure
    (such as via [`expression.func`](sqlelement.html#sqlalchemy.sql.expression.func
    "sqlalchemy.sql.expression.func")).
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.types.Interval.__init__), [adapt_to_emulated()](#sqlalchemy.types.Interval.adapt_to_emulated),
    [bind_processor()](#sqlalchemy.types.Interval.bind_processor), [cache_ok](#sqlalchemy.types.Interval.cache_ok),
    [coerce_compared_value()](#sqlalchemy.types.Interval.coerce_compared_value), [comparator_factory](#sqlalchemy.types.Interval.comparator_factory),
    [impl](#sqlalchemy.types.Interval.impl), [python_type](#sqlalchemy.types.Interval.python_type),
    [result_processor()](#sqlalchemy.types.Interval.result_processor)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.types.Interval`](#sqlalchemy.types.Interval "sqlalchemy.types.Interval")
    (`sqlalchemy.types.Emulated`, `sqlalchemy.types._AbstractInterval`, [`sqlalchemy.types.TypeDecorator`](custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE249]'
  prefs: []
  type: TYPE_PRE
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.types.Interval.Comparator`](#sqlalchemy.types.Interval.Comparator
    "sqlalchemy.types.Interval.Comparator") (`sqlalchemy.types.Comparator`, `sqlalchemy.types.Comparator`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE250]'
  prefs: []
  type: TYPE_PRE
- en: Construct an Interval object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`native` – when True, use the actual INTERVAL type provided by the database,
    if supported (currently PostgreSQL, Oracle). Otherwise, represent the interval
    data as an epoch value regardless.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`second_precision` – For native interval types which support a “fractional
    seconds precision” parameter, i.e. Oracle and PostgreSQL'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`day_precision` – for native interval types which support a “day precision”
    parameter, i.e. Oracle.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE251]'
  prefs: []
  type: TYPE_PRE
- en: Given an impl class, adapt this type to the impl assuming “emulated”.
  prefs: []
  type: TYPE_NORMAL
- en: The impl should also be an “emulated” version of this type, most likely the
    same class as this type itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'e.g.: sqltypes.Enum adapts to the Enum class.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE252]'
  prefs: []
  type: TYPE_PRE
- en: Return a conversion function for processing bind values.
  prefs: []
  type: TYPE_NORMAL
- en: Returns a callable which will receive a bind parameter value as the sole positional
    argument and will return a value to send to the DB-API.
  prefs: []
  type: TYPE_NORMAL
- en: If processing is not necessary, the method should return `None`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This method is only called relative to a **dialect specific type object**, which
    is often **private to a dialect in use** and is not the same type object as the
    public facing one, which means it’s not feasible to subclass a [`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") class in order to provide an alternate [`TypeEngine.bind_processor()`](type_api.html#sqlalchemy.types.TypeEngine.bind_processor
    "sqlalchemy.types.TypeEngine.bind_processor") method, unless subclassing the [`UserDefinedType`](custom_types.html#sqlalchemy.types.UserDefinedType
    "sqlalchemy.types.UserDefinedType") class explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: To provide alternate behavior for [`TypeEngine.bind_processor()`](type_api.html#sqlalchemy.types.TypeEngine.bind_processor
    "sqlalchemy.types.TypeEngine.bind_processor"), implement a [`TypeDecorator`](custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") class and provide an implementation of [`TypeDecorator.process_bind_param()`](custom_types.html#sqlalchemy.types.TypeDecorator.process_bind_param
    "sqlalchemy.types.TypeDecorator.process_bind_param").
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Augmenting Existing Types](custom_types.html#types-typedecorator)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**dialect** – Dialect instance in use.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE253]'
  prefs: []
  type: TYPE_PRE
- en: Indicate if statements using this [`ExternalType`](type_api.html#sqlalchemy.types.ExternalType
    "sqlalchemy.types.ExternalType") are “safe to cache”.
  prefs: []
  type: TYPE_NORMAL
- en: 'The default value `None` will emit a warning and then not allow caching of
    a statement which includes this type. Set to `False` to disable statements using
    this type from being cached at all without a warning. When set to `True`, the
    object’s class and selected elements from its state will be used as part of the
    cache key. For example, using a [`TypeDecorator`](custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE254]'
  prefs: []
  type: TYPE_PRE
- en: 'The cache key for the above type would be equivalent to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE255]'
  prefs: []
  type: TYPE_PRE
- en: The caching scheme will extract attributes from the type that correspond to
    the names of parameters in the `__init__()` method. Above, the “choices” attribute
    becomes part of the cache key but “internal_only” does not, because there is no
    parameter named “internal_only”.
  prefs: []
  type: TYPE_NORMAL
- en: The requirements for cacheable elements is that they are hashable and also that
    they indicate the same SQL rendered for expressions using this type every time
    for a given cache value.
  prefs: []
  type: TYPE_NORMAL
- en: 'To accommodate for datatypes that refer to unhashable structures such as dictionaries,
    sets and lists, these objects can be made “cacheable” by assigning hashable structures
    to the attributes whose names correspond with the names of the arguments. For
    example, a datatype which accepts a dictionary of lookup values may publish this
    as a sorted series of tuples. Given a previously un-cacheable type as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE256]'
  prefs: []
  type: TYPE_PRE
- en: 'Where “lookup” is a dictionary. The type will not be able to generate a cache
    key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE257]'
  prefs: []
  type: TYPE_PRE
- en: 'If we **did** set up such a cache key, it wouldn’t be usable. We would get
    a tuple structure that contains a dictionary inside of it, which cannot itself
    be used as a key in a “cache dictionary” such as SQLAlchemy’s statement cache,
    since Python dictionaries aren’t hashable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE258]'
  prefs: []
  type: TYPE_PRE
- en: 'The type may be made cacheable by assigning a sorted tuple of tuples to the
    “.lookup” attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE259]'
  prefs: []
  type: TYPE_PRE
- en: 'Where above, the cache key for `LookupType({"a": 10, "b": 20})` will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE260]'
  prefs: []
  type: TYPE_PRE
- en: 'New in version 1.4.14: - added the `cache_ok` flag to allow some configurability
    of caching for [`TypeDecorator`](custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") classes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 1.4.28: - added the [`ExternalType`](type_api.html#sqlalchemy.types.ExternalType
    "sqlalchemy.types.ExternalType") mixin which generalizes the `cache_ok` flag to
    both the [`TypeDecorator`](custom_types.html#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")
    and [`UserDefinedType`](custom_types.html#sqlalchemy.types.UserDefinedType "sqlalchemy.types.UserDefinedType")
    classes.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[SQL Compilation Caching](connections.html#sql-caching)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE261]'
  prefs: []
  type: TYPE_PRE
- en: Suggest a type for a ‘coerced’ Python value in an expression.
  prefs: []
  type: TYPE_NORMAL
- en: Given an operator and value, gives the type a chance to return a type which
    the value should be coerced into.
  prefs: []
  type: TYPE_NORMAL
- en: The default behavior here is conservative; if the right-hand side is already
    coerced into a SQL type based on its Python type, it is usually left alone.
  prefs: []
  type: TYPE_NORMAL
- en: End-user functionality extension here should generally be via [`TypeDecorator`](custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator"), which provides more liberal behavior in that
    it defaults to coercing the other side of the expression into this type, thus
    applying special Python conversions above and beyond those needed by the DBAPI
    to both ides. It also provides the public method [`TypeDecorator.coerce_compared_value()`](custom_types.html#sqlalchemy.types.TypeDecorator.coerce_compared_value
    "sqlalchemy.types.TypeDecorator.coerce_compared_value") which is intended for
    end-user customization of this behavior.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE262]'
  prefs: []
  type: TYPE_PRE
- en: alias of [`Comparator`](#sqlalchemy.types.Interval.Comparator "sqlalchemy.sql.sqltypes.Interval.Comparator")
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE263]'
  prefs: []
  type: TYPE_PRE
- en: alias of [`DateTime`](#sqlalchemy.types.DateTime "sqlalchemy.sql.sqltypes.DateTime")
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE264]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE265]'
  prefs: []
  type: TYPE_PRE
- en: Return a conversion function for processing result row values.
  prefs: []
  type: TYPE_NORMAL
- en: Returns a callable which will receive a result row column value as the sole
    positional argument and will return a value to return to the user.
  prefs: []
  type: TYPE_NORMAL
- en: If processing is not necessary, the method should return `None`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This method is only called relative to a **dialect specific type object**, which
    is often **private to a dialect in use** and is not the same type object as the
    public facing one, which means it’s not feasible to subclass a [`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") class in order to provide an alternate [`TypeEngine.result_processor()`](type_api.html#sqlalchemy.types.TypeEngine.result_processor
    "sqlalchemy.types.TypeEngine.result_processor") method, unless subclassing the
    [`UserDefinedType`](custom_types.html#sqlalchemy.types.UserDefinedType "sqlalchemy.types.UserDefinedType")
    class explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: To provide alternate behavior for [`TypeEngine.result_processor()`](type_api.html#sqlalchemy.types.TypeEngine.result_processor
    "sqlalchemy.types.TypeEngine.result_processor"), implement a [`TypeDecorator`](custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") class and provide an implementation of [`TypeDecorator.process_result_value()`](custom_types.html#sqlalchemy.types.TypeDecorator.process_result_value
    "sqlalchemy.types.TypeDecorator.process_result_value").
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Augmenting Existing Types](custom_types.html#types-typedecorator)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dialect` – Dialect instance in use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`coltype` – DBAPI coltype argument received in cursor.description.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE266]'
  prefs: []
  type: TYPE_PRE
- en: A type for large binary byte data.
  prefs: []
  type: TYPE_NORMAL
- en: The [`LargeBinary`](#sqlalchemy.types.LargeBinary "sqlalchemy.types.LargeBinary")
    type corresponds to a large and/or unlengthed binary type for the target platform,
    such as BLOB on MySQL and BYTEA for PostgreSQL. It also handles the necessary
    conversions for the DBAPI.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.types.LargeBinary.__init__)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.types.LargeBinary`](#sqlalchemy.types.LargeBinary "sqlalchemy.types.LargeBinary")
    (`sqlalchemy.types._Binary`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE267]'
  prefs: []
  type: TYPE_PRE
- en: Construct a LargeBinary type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**length** – optional, a length for the column for use in DDL statements, for
    those binary types that accept a length, such as the MySQL BLOB type.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE268]'
  prefs: []
  type: TYPE_PRE
- en: Refers to the return type of the MATCH operator.
  prefs: []
  type: TYPE_NORMAL
- en: As the [`ColumnOperators.match()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.match
    "sqlalchemy.sql.expression.ColumnOperators.match") is probably the most open-ended
    operator in generic SQLAlchemy Core, we can’t assume the return type at SQL evaluation
    time, as MySQL returns a floating point, not a boolean, and other backends might
    do something different. So this type acts as a placeholder, currently subclassing
    [`Boolean`](#sqlalchemy.types.Boolean "sqlalchemy.types.Boolean"). The type allows
    dialects to inject result-processing functionality if needed, and on MySQL will
    return floating-point values.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.types.MatchType`](#sqlalchemy.types.MatchType "sqlalchemy.types.MatchType")
    ([`sqlalchemy.types.Boolean`](#sqlalchemy.types.Boolean "sqlalchemy.types.Boolean"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE269]'
  prefs: []
  type: TYPE_PRE
- en: Base for non-integer numeric types, such as `NUMERIC`, `FLOAT`, `DECIMAL`, and
    other variants.
  prefs: []
  type: TYPE_NORMAL
- en: The [`Numeric`](#sqlalchemy.types.Numeric "sqlalchemy.types.Numeric") datatype
    when used directly will render DDL corresponding to precision numerics if available,
    such as `NUMERIC(precision, scale)`. The [`Float`](#sqlalchemy.types.Float "sqlalchemy.types.Float")
    subclass will attempt to render a floating-point datatype such as `FLOAT(precision)`.
  prefs: []
  type: TYPE_NORMAL
- en: '[`Numeric`](#sqlalchemy.types.Numeric "sqlalchemy.types.Numeric") returns Python
    `decimal.Decimal` objects by default, based on the default value of `True` for
    the [`Numeric.asdecimal`](#sqlalchemy.types.Numeric.params.asdecimal "sqlalchemy.types.Numeric")
    parameter. If this parameter is set to False, returned values are coerced to Python
    `float` objects.'
  prefs: []
  type: TYPE_NORMAL
- en: The [`Float`](#sqlalchemy.types.Float "sqlalchemy.types.Float") subtype, being
    more specific to floating point, defaults the [`Float.asdecimal`](#sqlalchemy.types.Float.params.asdecimal
    "sqlalchemy.types.Float") flag to False so that the default Python datatype is
    `float`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: When using a [`Numeric`](#sqlalchemy.types.Numeric "sqlalchemy.types.Numeric")
    datatype against a database type that returns Python floating point values to
    the driver, the accuracy of the decimal conversion indicated by [`Numeric.asdecimal`](#sqlalchemy.types.Numeric.params.asdecimal
    "sqlalchemy.types.Numeric") may be limited. The behavior of specific numeric/floating
    point datatypes is a product of the SQL datatype in use, the Python [DBAPI](../glossary.html#term-DBAPI)
    in use, as well as strategies that may be present within the SQLAlchemy dialect
    in use. Users requiring specific precision/ scale are encouraged to experiment
    with the available datatypes in order to determine the best results.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.types.Numeric.__init__), [bind_processor()](#sqlalchemy.types.Numeric.bind_processor),
    [get_dbapi_type()](#sqlalchemy.types.Numeric.get_dbapi_type), [literal_processor()](#sqlalchemy.types.Numeric.literal_processor),
    [python_type](#sqlalchemy.types.Numeric.python_type), [result_processor()](#sqlalchemy.types.Numeric.result_processor)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.types.Numeric`](#sqlalchemy.types.Numeric "sqlalchemy.types.Numeric")
    (`sqlalchemy.types.HasExpressionLookup`, [`sqlalchemy.types.TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE270]'
  prefs: []
  type: TYPE_PRE
- en: Construct a Numeric.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`precision` – the numeric precision for use in DDL `CREATE TABLE`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scale` – the numeric scale for use in DDL `CREATE TABLE`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`asdecimal` – default True. Return whether or not values should be sent as
    Python Decimal objects, or as floats. Different DBAPIs send one or the other based
    on datatypes - the Numeric type will ensure that return values are one or the
    other across DBAPIs consistently.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`decimal_return_scale` – Default scale to use when converting from floats to
    Python decimals. Floating point values will typically be much longer due to decimal
    inaccuracy, and most floating point database types don’t have a notion of “scale”,
    so by default the float type looks for the first ten decimal places when converting.
    Specifying this value will override that length. Types which do include an explicit
    “.scale” value, such as the base [`Numeric`](#sqlalchemy.types.Numeric "sqlalchemy.types.Numeric")
    as well as the MySQL float types, will use the value of “.scale” as the default
    for decimal_return_scale, if not otherwise specified.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When using the `Numeric` type, care should be taken to ensure that the asdecimal
    setting is appropriate for the DBAPI in use - when Numeric applies a conversion
    from Decimal->float or float-> Decimal, this conversion incurs an additional performance
    overhead for all result columns received.
  prefs: []
  type: TYPE_NORMAL
- en: DBAPIs that return Decimal natively (e.g. psycopg2) will have better accuracy
    and higher performance with a setting of `True`, as the native translation to
    Decimal reduces the amount of floating- point issues at play, and the Numeric
    type itself doesn’t need to apply any further conversions. However, another DBAPI
    which returns floats natively *will* incur an additional conversion overhead,
    and is still subject to floating point data loss - in which case `asdecimal=False`
    will at least remove the extra conversion overhead.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE271]'
  prefs: []
  type: TYPE_PRE
- en: Return a conversion function for processing bind values.
  prefs: []
  type: TYPE_NORMAL
- en: Returns a callable which will receive a bind parameter value as the sole positional
    argument and will return a value to send to the DB-API.
  prefs: []
  type: TYPE_NORMAL
- en: If processing is not necessary, the method should return `None`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This method is only called relative to a **dialect specific type object**, which
    is often **private to a dialect in use** and is not the same type object as the
    public facing one, which means it’s not feasible to subclass a [`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") class in order to provide an alternate [`TypeEngine.bind_processor()`](type_api.html#sqlalchemy.types.TypeEngine.bind_processor
    "sqlalchemy.types.TypeEngine.bind_processor") method, unless subclassing the [`UserDefinedType`](custom_types.html#sqlalchemy.types.UserDefinedType
    "sqlalchemy.types.UserDefinedType") class explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: To provide alternate behavior for [`TypeEngine.bind_processor()`](type_api.html#sqlalchemy.types.TypeEngine.bind_processor
    "sqlalchemy.types.TypeEngine.bind_processor"), implement a [`TypeDecorator`](custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") class and provide an implementation of [`TypeDecorator.process_bind_param()`](custom_types.html#sqlalchemy.types.TypeDecorator.process_bind_param
    "sqlalchemy.types.TypeDecorator.process_bind_param").
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Augmenting Existing Types](custom_types.html#types-typedecorator)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**dialect** – Dialect instance in use.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE272]'
  prefs: []
  type: TYPE_PRE
- en: Return the corresponding type object from the underlying DB-API, if any.
  prefs: []
  type: TYPE_NORMAL
- en: This can be useful for calling `setinputsizes()`, for example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE273]'
  prefs: []
  type: TYPE_PRE
- en: Return a conversion function for processing literal values that are to be rendered
    directly without using binds.
  prefs: []
  type: TYPE_NORMAL
- en: This function is used when the compiler makes use of the “literal_binds” flag,
    typically used in DDL generation as well as in certain scenarios where backends
    don’t accept bound parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Returns a callable which will receive a literal Python value as the sole positional
    argument and will return a string representation to be rendered in a SQL statement.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This method is only called relative to a **dialect specific type object**, which
    is often **private to a dialect in use** and is not the same type object as the
    public facing one, which means it’s not feasible to subclass a [`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") class in order to provide an alternate [`TypeEngine.literal_processor()`](type_api.html#sqlalchemy.types.TypeEngine.literal_processor
    "sqlalchemy.types.TypeEngine.literal_processor") method, unless subclassing the
    [`UserDefinedType`](custom_types.html#sqlalchemy.types.UserDefinedType "sqlalchemy.types.UserDefinedType")
    class explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: To provide alternate behavior for [`TypeEngine.literal_processor()`](type_api.html#sqlalchemy.types.TypeEngine.literal_processor
    "sqlalchemy.types.TypeEngine.literal_processor"), implement a [`TypeDecorator`](custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") class and provide an implementation of [`TypeDecorator.process_literal_param()`](custom_types.html#sqlalchemy.types.TypeDecorator.process_literal_param
    "sqlalchemy.types.TypeDecorator.process_literal_param").
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Augmenting Existing Types](custom_types.html#types-typedecorator)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE274]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE275]'
  prefs: []
  type: TYPE_PRE
- en: Return a conversion function for processing result row values.
  prefs: []
  type: TYPE_NORMAL
- en: Returns a callable which will receive a result row column value as the sole
    positional argument and will return a value to return to the user.
  prefs: []
  type: TYPE_NORMAL
- en: If processing is not necessary, the method should return `None`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This method is only called relative to a **dialect specific type object**, which
    is often **private to a dialect in use** and is not the same type object as the
    public facing one, which means it’s not feasible to subclass a [`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") class in order to provide an alternate [`TypeEngine.result_processor()`](type_api.html#sqlalchemy.types.TypeEngine.result_processor
    "sqlalchemy.types.TypeEngine.result_processor") method, unless subclassing the
    [`UserDefinedType`](custom_types.html#sqlalchemy.types.UserDefinedType "sqlalchemy.types.UserDefinedType")
    class explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: To provide alternate behavior for [`TypeEngine.result_processor()`](type_api.html#sqlalchemy.types.TypeEngine.result_processor
    "sqlalchemy.types.TypeEngine.result_processor"), implement a [`TypeDecorator`](custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") class and provide an implementation of [`TypeDecorator.process_result_value()`](custom_types.html#sqlalchemy.types.TypeDecorator.process_result_value
    "sqlalchemy.types.TypeDecorator.process_result_value").
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Augmenting Existing Types](custom_types.html#types-typedecorator)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dialect` – Dialect instance in use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`coltype` – DBAPI coltype argument received in cursor.description.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE276]'
  prefs: []
  type: TYPE_PRE
- en: Holds Python objects, which are serialized using pickle.
  prefs: []
  type: TYPE_NORMAL
- en: PickleType builds upon the Binary type to apply Python’s `pickle.dumps()` to
    incoming objects, and `pickle.loads()` on the way out, allowing any pickleable
    Python object to be stored as a serialized binary field.
  prefs: []
  type: TYPE_NORMAL
- en: To allow ORM change events to propagate for elements associated with [`PickleType`](#sqlalchemy.types.PickleType
    "sqlalchemy.types.PickleType"), see [Mutation Tracking](../orm/extensions/mutable.html).
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.types.PickleType.__init__), [bind_processor()](#sqlalchemy.types.PickleType.bind_processor),
    [cache_ok](#sqlalchemy.types.PickleType.cache_ok), [compare_values()](#sqlalchemy.types.PickleType.compare_values),
    [impl](#sqlalchemy.types.PickleType.impl), [result_processor()](#sqlalchemy.types.PickleType.result_processor)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.types.PickleType`](#sqlalchemy.types.PickleType "sqlalchemy.types.PickleType")
    ([`sqlalchemy.types.TypeDecorator`](custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE277]'
  prefs: []
  type: TYPE_PRE
- en: Construct a PickleType.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`protocol` – defaults to `pickle.HIGHEST_PROTOCOL`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pickler` – defaults to pickle. May be any object with pickle-compatible `dumps`
    and `loads` methods.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`comparator` – a 2-arg callable predicate used to compare values of this type.
    If left as `None`, the Python “equals” operator is used to compare values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`impl` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A binary-storing [`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine "sqlalchemy.types.TypeEngine")
    class or instance to use in place of the default [`LargeBinary`](#sqlalchemy.types.LargeBinary
    "sqlalchemy.types.LargeBinary"). For example the :class: _mysql.LONGBLOB class
    may be more effective when using MySQL.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: New in version 1.4.20.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE278]'
  prefs: []
  type: TYPE_PRE
- en: Provide a bound value processing function for the given [`Dialect`](internals.html#sqlalchemy.engine.Dialect
    "sqlalchemy.engine.Dialect").
  prefs: []
  type: TYPE_NORMAL
- en: This is the method that fulfills the [`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") contract for bound value conversion which normally
    occurs via the [`TypeEngine.bind_processor()`](type_api.html#sqlalchemy.types.TypeEngine.bind_processor
    "sqlalchemy.types.TypeEngine.bind_processor") method.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: User-defined subclasses of [`TypeDecorator`](custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") should **not** implement this method, and should
    instead implement [`TypeDecorator.process_bind_param()`](custom_types.html#sqlalchemy.types.TypeDecorator.process_bind_param
    "sqlalchemy.types.TypeDecorator.process_bind_param") so that the “inner” processing
    provided by the implementing type is maintained.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**dialect** – Dialect instance in use.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE279]'
  prefs: []
  type: TYPE_PRE
- en: Indicate if statements using this [`ExternalType`](type_api.html#sqlalchemy.types.ExternalType
    "sqlalchemy.types.ExternalType") are “safe to cache”.
  prefs: []
  type: TYPE_NORMAL
- en: 'The default value `None` will emit a warning and then not allow caching of
    a statement which includes this type. Set to `False` to disable statements using
    this type from being cached at all without a warning. When set to `True`, the
    object’s class and selected elements from its state will be used as part of the
    cache key. For example, using a [`TypeDecorator`](custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE280]'
  prefs: []
  type: TYPE_PRE
- en: 'The cache key for the above type would be equivalent to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE281]'
  prefs: []
  type: TYPE_PRE
- en: The caching scheme will extract attributes from the type that correspond to
    the names of parameters in the `__init__()` method. Above, the “choices” attribute
    becomes part of the cache key but “internal_only” does not, because there is no
    parameter named “internal_only”.
  prefs: []
  type: TYPE_NORMAL
- en: The requirements for cacheable elements is that they are hashable and also that
    they indicate the same SQL rendered for expressions using this type every time
    for a given cache value.
  prefs: []
  type: TYPE_NORMAL
- en: 'To accommodate for datatypes that refer to unhashable structures such as dictionaries,
    sets and lists, these objects can be made “cacheable” by assigning hashable structures
    to the attributes whose names correspond with the names of the arguments. For
    example, a datatype which accepts a dictionary of lookup values may publish this
    as a sorted series of tuples. Given a previously un-cacheable type as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE282]'
  prefs: []
  type: TYPE_PRE
- en: 'Where “lookup” is a dictionary. The type will not be able to generate a cache
    key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE283]'
  prefs: []
  type: TYPE_PRE
- en: 'If we **did** set up such a cache key, it wouldn’t be usable. We would get
    a tuple structure that contains a dictionary inside of it, which cannot itself
    be used as a key in a “cache dictionary” such as SQLAlchemy’s statement cache,
    since Python dictionaries aren’t hashable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE284]'
  prefs: []
  type: TYPE_PRE
- en: 'The type may be made cacheable by assigning a sorted tuple of tuples to the
    “.lookup” attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE285]'
  prefs: []
  type: TYPE_PRE
- en: 'Where above, the cache key for `LookupType({"a": 10, "b": 20})` will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE286]'
  prefs: []
  type: TYPE_PRE
- en: 'New in version 1.4.14: - added the `cache_ok` flag to allow some configurability
    of caching for [`TypeDecorator`](custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") classes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'New in version 1.4.28: - added the [`ExternalType`](type_api.html#sqlalchemy.types.ExternalType
    "sqlalchemy.types.ExternalType") mixin which generalizes the `cache_ok` flag to
    both the [`TypeDecorator`](custom_types.html#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")
    and [`UserDefinedType`](custom_types.html#sqlalchemy.types.UserDefinedType "sqlalchemy.types.UserDefinedType")
    classes.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[SQL Compilation Caching](connections.html#sql-caching)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE287]'
  prefs: []
  type: TYPE_PRE
- en: Given two values, compare them for equality.
  prefs: []
  type: TYPE_NORMAL
- en: By default this calls upon [`TypeEngine.compare_values()`](type_api.html#sqlalchemy.types.TypeEngine.compare_values
    "sqlalchemy.types.TypeEngine.compare_values") of the underlying “impl”, which
    in turn usually uses the Python equals operator `==`.
  prefs: []
  type: TYPE_NORMAL
- en: This function is used by the ORM to compare an original-loaded value with an
    intercepted “changed” value, to determine if a net change has occurred.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE288]'
  prefs: []
  type: TYPE_PRE
- en: alias of [`LargeBinary`](#sqlalchemy.types.LargeBinary "sqlalchemy.sql.sqltypes.LargeBinary")
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE289]'
  prefs: []
  type: TYPE_PRE
- en: Provide a result value processing function for the given [`Dialect`](internals.html#sqlalchemy.engine.Dialect
    "sqlalchemy.engine.Dialect").
  prefs: []
  type: TYPE_NORMAL
- en: This is the method that fulfills the [`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") contract for bound value conversion which normally
    occurs via the [`TypeEngine.result_processor()`](type_api.html#sqlalchemy.types.TypeEngine.result_processor
    "sqlalchemy.types.TypeEngine.result_processor") method.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: User-defined subclasses of [`TypeDecorator`](custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") should **not** implement this method, and should
    instead implement [`TypeDecorator.process_result_value()`](custom_types.html#sqlalchemy.types.TypeDecorator.process_result_value
    "sqlalchemy.types.TypeDecorator.process_result_value") so that the “inner” processing
    provided by the implementing type is maintained.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dialect` – Dialect instance in use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`coltype` – A SQLAlchemy data type'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE290]'
  prefs: []
  type: TYPE_PRE
- en: Add capabilities to a type which allow for schema-level DDL to be associated
    with a type.
  prefs: []
  type: TYPE_NORMAL
- en: Supports types that must be explicitly created/dropped (i.e. PG ENUM type) as
    well as types that are complimented by table or schema level constraints, triggers,
    and other rules.
  prefs: []
  type: TYPE_NORMAL
- en: '[`SchemaType`](#sqlalchemy.types.SchemaType "sqlalchemy.types.SchemaType")
    classes can also be targets for the [`DDLEvents.before_parent_attach()`](events.html#sqlalchemy.events.DDLEvents.before_parent_attach
    "sqlalchemy.events.DDLEvents.before_parent_attach") and [`DDLEvents.after_parent_attach()`](events.html#sqlalchemy.events.DDLEvents.after_parent_attach
    "sqlalchemy.events.DDLEvents.after_parent_attach") events, where the events fire
    off surrounding the association of the type object with a parent [`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column").'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Enum`](#sqlalchemy.types.Enum "sqlalchemy.types.Enum")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Boolean`](#sqlalchemy.types.Boolean "sqlalchemy.types.Boolean")'
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[adapt()](#sqlalchemy.types.SchemaType.adapt), [copy()](#sqlalchemy.types.SchemaType.copy),
    [create()](#sqlalchemy.types.SchemaType.create), [drop()](#sqlalchemy.types.SchemaType.drop),
    [name](#sqlalchemy.types.SchemaType.name)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.types.SchemaType`](#sqlalchemy.types.SchemaType "sqlalchemy.types.SchemaType")
    (`sqlalchemy.sql.expression.SchemaEventTarget`, `sqlalchemy.types.TypeEngineMixin`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE291]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE292]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE293]'
  prefs: []
  type: TYPE_PRE
- en: Issue CREATE DDL for this type, if applicable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE294]'
  prefs: []
  type: TYPE_PRE
- en: Issue DROP DDL for this type, if applicable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE295]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE296]'
  prefs: []
  type: TYPE_PRE
- en: A type for smaller `int` integers.
  prefs: []
  type: TYPE_NORMAL
- en: Typically generates a `SMALLINT` in DDL, and otherwise acts like a normal [`Integer`](#sqlalchemy.types.Integer
    "sqlalchemy.types.Integer") on the Python side.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.types.SmallInteger`](#sqlalchemy.types.SmallInteger "sqlalchemy.types.SmallInteger")
    ([`sqlalchemy.types.Integer`](#sqlalchemy.types.Integer "sqlalchemy.types.Integer"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE297]'
  prefs: []
  type: TYPE_PRE
- en: The base for all string and character types.
  prefs: []
  type: TYPE_NORMAL
- en: In SQL, corresponds to VARCHAR.
  prefs: []
  type: TYPE_NORMAL
- en: The length field is usually required when the String type is used within a CREATE
    TABLE statement, as VARCHAR requires a length on most databases.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.types.String.__init__), [bind_processor()](#sqlalchemy.types.String.bind_processor),
    [get_dbapi_type()](#sqlalchemy.types.String.get_dbapi_type), [literal_processor()](#sqlalchemy.types.String.literal_processor),
    [python_type](#sqlalchemy.types.String.python_type), [result_processor()](#sqlalchemy.types.String.result_processor)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.types.String`](#sqlalchemy.types.String "sqlalchemy.types.String")
    ([`sqlalchemy.types.Concatenable`](type_api.html#sqlalchemy.types.Concatenable
    "sqlalchemy.types.Concatenable"), [`sqlalchemy.types.TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE298]'
  prefs: []
  type: TYPE_PRE
- en: Create a string-holding type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`length` – optional, a length for the column for use in DDL and CAST expressions.
    May be safely omitted if no `CREATE TABLE` will be issued. Certain databases may
    require a `length` for use in DDL, and will raise an exception when the `CREATE
    TABLE` DDL is issued if a `VARCHAR` with no length is included. Whether the value
    is interpreted as bytes or characters is database specific.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`collation` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Optional, a column-level collation for use in DDL and CAST expressions. Renders
    using the COLLATE keyword supported by SQLite, MySQL, and PostgreSQL. E.g.:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE299]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In most cases, the [`Unicode`](#sqlalchemy.types.Unicode "sqlalchemy.types.Unicode")
    or [`UnicodeText`](#sqlalchemy.types.UnicodeText "sqlalchemy.types.UnicodeText")
    datatypes should be used for a [`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") that expects to store non-ascii data. These datatypes
    will ensure that the correct types are used on the database.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE300]'
  prefs: []
  type: TYPE_PRE
- en: Return a conversion function for processing bind values.
  prefs: []
  type: TYPE_NORMAL
- en: Returns a callable which will receive a bind parameter value as the sole positional
    argument and will return a value to send to the DB-API.
  prefs: []
  type: TYPE_NORMAL
- en: If processing is not necessary, the method should return `None`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This method is only called relative to a **dialect specific type object**, which
    is often **private to a dialect in use** and is not the same type object as the
    public facing one, which means it’s not feasible to subclass a [`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") class in order to provide an alternate [`TypeEngine.bind_processor()`](type_api.html#sqlalchemy.types.TypeEngine.bind_processor
    "sqlalchemy.types.TypeEngine.bind_processor") method, unless subclassing the [`UserDefinedType`](custom_types.html#sqlalchemy.types.UserDefinedType
    "sqlalchemy.types.UserDefinedType") class explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: To provide alternate behavior for [`TypeEngine.bind_processor()`](type_api.html#sqlalchemy.types.TypeEngine.bind_processor
    "sqlalchemy.types.TypeEngine.bind_processor"), implement a [`TypeDecorator`](custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") class and provide an implementation of [`TypeDecorator.process_bind_param()`](custom_types.html#sqlalchemy.types.TypeDecorator.process_bind_param
    "sqlalchemy.types.TypeDecorator.process_bind_param").
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Augmenting Existing Types](custom_types.html#types-typedecorator)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**dialect** – Dialect instance in use.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE301]'
  prefs: []
  type: TYPE_PRE
- en: Return the corresponding type object from the underlying DB-API, if any.
  prefs: []
  type: TYPE_NORMAL
- en: This can be useful for calling `setinputsizes()`, for example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE302]'
  prefs: []
  type: TYPE_PRE
- en: Return a conversion function for processing literal values that are to be rendered
    directly without using binds.
  prefs: []
  type: TYPE_NORMAL
- en: This function is used when the compiler makes use of the “literal_binds” flag,
    typically used in DDL generation as well as in certain scenarios where backends
    don’t accept bound parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Returns a callable which will receive a literal Python value as the sole positional
    argument and will return a string representation to be rendered in a SQL statement.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This method is only called relative to a **dialect specific type object**, which
    is often **private to a dialect in use** and is not the same type object as the
    public facing one, which means it’s not feasible to subclass a [`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") class in order to provide an alternate [`TypeEngine.literal_processor()`](type_api.html#sqlalchemy.types.TypeEngine.literal_processor
    "sqlalchemy.types.TypeEngine.literal_processor") method, unless subclassing the
    [`UserDefinedType`](custom_types.html#sqlalchemy.types.UserDefinedType "sqlalchemy.types.UserDefinedType")
    class explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: To provide alternate behavior for [`TypeEngine.literal_processor()`](type_api.html#sqlalchemy.types.TypeEngine.literal_processor
    "sqlalchemy.types.TypeEngine.literal_processor"), implement a [`TypeDecorator`](custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") class and provide an implementation of [`TypeDecorator.process_literal_param()`](custom_types.html#sqlalchemy.types.TypeDecorator.process_literal_param
    "sqlalchemy.types.TypeDecorator.process_literal_param").
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Augmenting Existing Types](custom_types.html#types-typedecorator)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE303]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE304]'
  prefs: []
  type: TYPE_PRE
- en: Return a conversion function for processing result row values.
  prefs: []
  type: TYPE_NORMAL
- en: Returns a callable which will receive a result row column value as the sole
    positional argument and will return a value to return to the user.
  prefs: []
  type: TYPE_NORMAL
- en: If processing is not necessary, the method should return `None`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This method is only called relative to a **dialect specific type object**, which
    is often **private to a dialect in use** and is not the same type object as the
    public facing one, which means it’s not feasible to subclass a [`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") class in order to provide an alternate [`TypeEngine.result_processor()`](type_api.html#sqlalchemy.types.TypeEngine.result_processor
    "sqlalchemy.types.TypeEngine.result_processor") method, unless subclassing the
    [`UserDefinedType`](custom_types.html#sqlalchemy.types.UserDefinedType "sqlalchemy.types.UserDefinedType")
    class explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: To provide alternate behavior for [`TypeEngine.result_processor()`](type_api.html#sqlalchemy.types.TypeEngine.result_processor
    "sqlalchemy.types.TypeEngine.result_processor"), implement a [`TypeDecorator`](custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") class and provide an implementation of [`TypeDecorator.process_result_value()`](custom_types.html#sqlalchemy.types.TypeDecorator.process_result_value
    "sqlalchemy.types.TypeDecorator.process_result_value").
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Augmenting Existing Types](custom_types.html#types-typedecorator)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dialect` – Dialect instance in use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`coltype` – DBAPI coltype argument received in cursor.description.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE305]'
  prefs: []
  type: TYPE_PRE
- en: A variably sized string type.
  prefs: []
  type: TYPE_NORMAL
- en: In SQL, usually corresponds to CLOB or TEXT. In general, TEXT objects do not
    have a length; while some databases will accept a length argument here, it will
    be rejected by others.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.types.Text`](#sqlalchemy.types.Text "sqlalchemy.types.Text")
    ([`sqlalchemy.types.String`](#sqlalchemy.types.String "sqlalchemy.types.String"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE306]'
  prefs: []
  type: TYPE_PRE
- en: A type for `datetime.time()` objects.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[get_dbapi_type()](#sqlalchemy.types.Time.get_dbapi_type), [literal_processor()](#sqlalchemy.types.Time.literal_processor),
    [python_type](#sqlalchemy.types.Time.python_type)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.types.Time`](#sqlalchemy.types.Time "sqlalchemy.types.Time")
    (`sqlalchemy.types._RenderISO8601NoT`, `sqlalchemy.types.HasExpressionLookup`,
    [`sqlalchemy.types.TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine "sqlalchemy.types.TypeEngine"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE307]'
  prefs: []
  type: TYPE_PRE
- en: Return the corresponding type object from the underlying DB-API, if any.
  prefs: []
  type: TYPE_NORMAL
- en: This can be useful for calling `setinputsizes()`, for example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE308]'
  prefs: []
  type: TYPE_PRE
- en: Return a conversion function for processing literal values that are to be rendered
    directly without using binds.
  prefs: []
  type: TYPE_NORMAL
- en: This function is used when the compiler makes use of the “literal_binds” flag,
    typically used in DDL generation as well as in certain scenarios where backends
    don’t accept bound parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Returns a callable which will receive a literal Python value as the sole positional
    argument and will return a string representation to be rendered in a SQL statement.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This method is only called relative to a **dialect specific type object**, which
    is often **private to a dialect in use** and is not the same type object as the
    public facing one, which means it’s not feasible to subclass a [`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") class in order to provide an alternate [`TypeEngine.literal_processor()`](type_api.html#sqlalchemy.types.TypeEngine.literal_processor
    "sqlalchemy.types.TypeEngine.literal_processor") method, unless subclassing the
    [`UserDefinedType`](custom_types.html#sqlalchemy.types.UserDefinedType "sqlalchemy.types.UserDefinedType")
    class explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: To provide alternate behavior for [`TypeEngine.literal_processor()`](type_api.html#sqlalchemy.types.TypeEngine.literal_processor
    "sqlalchemy.types.TypeEngine.literal_processor"), implement a [`TypeDecorator`](custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") class and provide an implementation of [`TypeDecorator.process_literal_param()`](custom_types.html#sqlalchemy.types.TypeDecorator.process_literal_param
    "sqlalchemy.types.TypeDecorator.process_literal_param").
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Augmenting Existing Types](custom_types.html#types-typedecorator)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE309]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE310]'
  prefs: []
  type: TYPE_PRE
- en: A variable length Unicode string type.
  prefs: []
  type: TYPE_NORMAL
- en: The [`Unicode`](#sqlalchemy.types.Unicode "sqlalchemy.types.Unicode") type is
    a [`String`](#sqlalchemy.types.String "sqlalchemy.types.String") subclass that
    assumes input and output strings that may contain non-ASCII characters, and for
    some backends implies an underlying column type that is explicitly supporting
    of non-ASCII data, such as `NVARCHAR` on Oracle and SQL Server. This will impact
    the output of `CREATE TABLE` statements and `CAST` functions at the dialect level.
  prefs: []
  type: TYPE_NORMAL
- en: The character encoding used by the [`Unicode`](#sqlalchemy.types.Unicode "sqlalchemy.types.Unicode")
    type that is used to transmit and receive data to the database is usually determined
    by the DBAPI itself. All modern DBAPIs accommodate non-ASCII strings but may have
    different methods of managing database encodings; if necessary, this encoding
    should be configured as detailed in the notes for the target DBAPI in the [Dialects](../dialects/index.html)
    section.
  prefs: []
  type: TYPE_NORMAL
- en: In modern SQLAlchemy, use of the [`Unicode`](#sqlalchemy.types.Unicode "sqlalchemy.types.Unicode")
    datatype does not imply any encoding/decoding behavior within SQLAlchemy itself.
    In Python 3, all string objects are inherently Unicode capable, and SQLAlchemy
    does not produce bytestring objects nor does it accommodate a DBAPI that does
    not return Python Unicode objects in result sets for string values.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs: []
  type: TYPE_NORMAL
- en: Some database backends, particularly SQL Server with pyodbc, are known to have
    undesirable behaviors regarding data that is noted as being of `NVARCHAR` type
    as opposed to `VARCHAR`, including datatype mismatch errors and non-use of indexes.
    See the section on [`DialectEvents.do_setinputsizes()`](events.html#sqlalchemy.events.DialectEvents.do_setinputsizes
    "sqlalchemy.events.DialectEvents.do_setinputsizes") for background on working
    around unicode character issues for backends like SQL Server with pyodbc as well
    as cx_Oracle.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`UnicodeText`](#sqlalchemy.types.UnicodeText "sqlalchemy.types.UnicodeText")
    - unlengthed textual counterpart to [`Unicode`](#sqlalchemy.types.Unicode "sqlalchemy.types.Unicode").'
  prefs: []
  type: TYPE_NORMAL
- en: '[`DialectEvents.do_setinputsizes()`](events.html#sqlalchemy.events.DialectEvents.do_setinputsizes
    "sqlalchemy.events.DialectEvents.do_setinputsizes")'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.types.Unicode`](#sqlalchemy.types.Unicode "sqlalchemy.types.Unicode")
    ([`sqlalchemy.types.String`](#sqlalchemy.types.String "sqlalchemy.types.String"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE311]'
  prefs: []
  type: TYPE_PRE
- en: An unbounded-length Unicode string type.
  prefs: []
  type: TYPE_NORMAL
- en: See [`Unicode`](#sqlalchemy.types.Unicode "sqlalchemy.types.Unicode") for details
    on the unicode behavior of this object.
  prefs: []
  type: TYPE_NORMAL
- en: Like [`Unicode`](#sqlalchemy.types.Unicode "sqlalchemy.types.Unicode"), usage
    the [`UnicodeText`](#sqlalchemy.types.UnicodeText "sqlalchemy.types.UnicodeText")
    type implies a unicode-capable type being used on the backend, such as `NCLOB`,
    `NTEXT`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.types.UnicodeText`](#sqlalchemy.types.UnicodeText "sqlalchemy.types.UnicodeText")
    ([`sqlalchemy.types.Text`](#sqlalchemy.types.Text "sqlalchemy.types.Text"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE312]'
  prefs: []
  type: TYPE_PRE
- en: Represent a database agnostic UUID datatype.
  prefs: []
  type: TYPE_NORMAL
- en: For backends that have no “native” UUID datatype, the value will make use of
    `CHAR(32)` and store the UUID as a 32-character alphanumeric hex string.
  prefs: []
  type: TYPE_NORMAL
- en: For backends which are known to support `UUID` directly or a similar uuid-storing
    datatype such as SQL Server’s `UNIQUEIDENTIFIER`, a “native” mode enabled by default
    allows these types will be used on those backends.
  prefs: []
  type: TYPE_NORMAL
- en: 'In its default mode of use, the [`Uuid`](#sqlalchemy.types.Uuid "sqlalchemy.types.Uuid")
    datatype expects **Python uuid objects**, from the Python [uuid](https://docs.python.org/3/library/uuid.html)
    module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE313]'
  prefs: []
  type: TYPE_PRE
- en: To have the [`Uuid`](#sqlalchemy.types.Uuid "sqlalchemy.types.Uuid") datatype
    work with string-based Uuids (e.g. 32 character hexadecimal strings), pass the
    [`Uuid.as_uuid`](#sqlalchemy.types.Uuid.params.as_uuid "sqlalchemy.types.Uuid")
    parameter with the value `False`.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`UUID`](#sqlalchemy.types.UUID "sqlalchemy.types.UUID") - represents exactly
    the `UUID` datatype without any backend-agnostic behaviors.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.types.Uuid.__init__), [bind_processor()](#sqlalchemy.types.Uuid.bind_processor),
    [coerce_compared_value()](#sqlalchemy.types.Uuid.coerce_compared_value), [literal_processor()](#sqlalchemy.types.Uuid.literal_processor),
    [python_type](#sqlalchemy.types.Uuid.python_type), [result_processor()](#sqlalchemy.types.Uuid.result_processor)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.types.Uuid`](#sqlalchemy.types.Uuid "sqlalchemy.types.Uuid")
    (`sqlalchemy.types.Emulated`, [`sqlalchemy.types.TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE314]'
  prefs: []
  type: TYPE_PRE
- en: Construct a [`Uuid`](#sqlalchemy.types.Uuid "sqlalchemy.types.Uuid") type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`as_uuid=True` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: if True, values will be interpreted as Python uuid objects, converting to/from
    string via the DBAPI.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`native_uuid=True` – if True, backends that support either the `UUID` datatype
    directly, or a UUID-storing value (such as SQL Server’s `UNIQUEIDENTIFIER` will
    be used by those backends. If False, a `CHAR(32)` datatype will be used for all
    backends regardless of native support.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE315]'
  prefs: []
  type: TYPE_PRE
- en: Return a conversion function for processing bind values.
  prefs: []
  type: TYPE_NORMAL
- en: Returns a callable which will receive a bind parameter value as the sole positional
    argument and will return a value to send to the DB-API.
  prefs: []
  type: TYPE_NORMAL
- en: If processing is not necessary, the method should return `None`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This method is only called relative to a **dialect specific type object**, which
    is often **private to a dialect in use** and is not the same type object as the
    public facing one, which means it’s not feasible to subclass a [`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") class in order to provide an alternate [`TypeEngine.bind_processor()`](type_api.html#sqlalchemy.types.TypeEngine.bind_processor
    "sqlalchemy.types.TypeEngine.bind_processor") method, unless subclassing the [`UserDefinedType`](custom_types.html#sqlalchemy.types.UserDefinedType
    "sqlalchemy.types.UserDefinedType") class explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: To provide alternate behavior for [`TypeEngine.bind_processor()`](type_api.html#sqlalchemy.types.TypeEngine.bind_processor
    "sqlalchemy.types.TypeEngine.bind_processor"), implement a [`TypeDecorator`](custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") class and provide an implementation of [`TypeDecorator.process_bind_param()`](custom_types.html#sqlalchemy.types.TypeDecorator.process_bind_param
    "sqlalchemy.types.TypeDecorator.process_bind_param").
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Augmenting Existing Types](custom_types.html#types-typedecorator)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**dialect** – Dialect instance in use.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE316]'
  prefs: []
  type: TYPE_PRE
- en: See [`TypeEngine.coerce_compared_value()`](type_api.html#sqlalchemy.types.TypeEngine.coerce_compared_value
    "sqlalchemy.types.TypeEngine.coerce_compared_value") for a description.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE317]'
  prefs: []
  type: TYPE_PRE
- en: Return a conversion function for processing literal values that are to be rendered
    directly without using binds.
  prefs: []
  type: TYPE_NORMAL
- en: This function is used when the compiler makes use of the “literal_binds” flag,
    typically used in DDL generation as well as in certain scenarios where backends
    don’t accept bound parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Returns a callable which will receive a literal Python value as the sole positional
    argument and will return a string representation to be rendered in a SQL statement.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This method is only called relative to a **dialect specific type object**, which
    is often **private to a dialect in use** and is not the same type object as the
    public facing one, which means it’s not feasible to subclass a [`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") class in order to provide an alternate [`TypeEngine.literal_processor()`](type_api.html#sqlalchemy.types.TypeEngine.literal_processor
    "sqlalchemy.types.TypeEngine.literal_processor") method, unless subclassing the
    [`UserDefinedType`](custom_types.html#sqlalchemy.types.UserDefinedType "sqlalchemy.types.UserDefinedType")
    class explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: To provide alternate behavior for [`TypeEngine.literal_processor()`](type_api.html#sqlalchemy.types.TypeEngine.literal_processor
    "sqlalchemy.types.TypeEngine.literal_processor"), implement a [`TypeDecorator`](custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") class and provide an implementation of [`TypeDecorator.process_literal_param()`](custom_types.html#sqlalchemy.types.TypeDecorator.process_literal_param
    "sqlalchemy.types.TypeDecorator.process_literal_param").
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Augmenting Existing Types](custom_types.html#types-typedecorator)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE318]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE319]'
  prefs: []
  type: TYPE_PRE
- en: Return a conversion function for processing result row values.
  prefs: []
  type: TYPE_NORMAL
- en: Returns a callable which will receive a result row column value as the sole
    positional argument and will return a value to return to the user.
  prefs: []
  type: TYPE_NORMAL
- en: If processing is not necessary, the method should return `None`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This method is only called relative to a **dialect specific type object**, which
    is often **private to a dialect in use** and is not the same type object as the
    public facing one, which means it’s not feasible to subclass a [`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") class in order to provide an alternate [`TypeEngine.result_processor()`](type_api.html#sqlalchemy.types.TypeEngine.result_processor
    "sqlalchemy.types.TypeEngine.result_processor") method, unless subclassing the
    [`UserDefinedType`](custom_types.html#sqlalchemy.types.UserDefinedType "sqlalchemy.types.UserDefinedType")
    class explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: To provide alternate behavior for [`TypeEngine.result_processor()`](type_api.html#sqlalchemy.types.TypeEngine.result_processor
    "sqlalchemy.types.TypeEngine.result_processor"), implement a [`TypeDecorator`](custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") class and provide an implementation of [`TypeDecorator.process_result_value()`](custom_types.html#sqlalchemy.types.TypeDecorator.process_result_value
    "sqlalchemy.types.TypeDecorator.process_result_value").
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Augmenting Existing Types](custom_types.html#types-typedecorator)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dialect` – Dialect instance in use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`coltype` – DBAPI coltype argument received in cursor.description.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '## SQL Standard and Multiple Vendor “UPPERCASE” Types'
  prefs: []
  type: TYPE_NORMAL
- en: This category of types refers to types that are either part of the SQL standard,
    or are potentially found within a subset of database backends. Unlike the “generic”
    types, the SQL standard/multi-vendor types have **no** guarantee of working on
    all backends, and will only work on those backends that explicitly support them
    by name. That is, the type will always emit its exact name in DDL with `CREATE
    TABLE` is issued.
  prefs: []
  type: TYPE_NORMAL
- en: '| Object Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| [ARRAY](#sqlalchemy.types.ARRAY) | Represent a SQL Array type. |'
  prefs: []
  type: TYPE_TB
- en: '| [BIGINT](#sqlalchemy.types.BIGINT) | The SQL BIGINT type. |'
  prefs: []
  type: TYPE_TB
- en: '| [BINARY](#sqlalchemy.types.BINARY) | The SQL BINARY type. |'
  prefs: []
  type: TYPE_TB
- en: '| [BLOB](#sqlalchemy.types.BLOB) | The SQL BLOB type. |'
  prefs: []
  type: TYPE_TB
- en: '| [BOOLEAN](#sqlalchemy.types.BOOLEAN) | The SQL BOOLEAN type. |'
  prefs: []
  type: TYPE_TB
- en: '| [CHAR](#sqlalchemy.types.CHAR) | The SQL CHAR type. |'
  prefs: []
  type: TYPE_TB
- en: '| [CLOB](#sqlalchemy.types.CLOB) | The CLOB type. |'
  prefs: []
  type: TYPE_TB
- en: '| [DATE](#sqlalchemy.types.DATE) | The SQL DATE type. |'
  prefs: []
  type: TYPE_TB
- en: '| [DATETIME](#sqlalchemy.types.DATETIME) | The SQL DATETIME type. |'
  prefs: []
  type: TYPE_TB
- en: '| [DECIMAL](#sqlalchemy.types.DECIMAL) | The SQL DECIMAL type. |'
  prefs: []
  type: TYPE_TB
- en: '| [DOUBLE](#sqlalchemy.types.DOUBLE) | The SQL DOUBLE type. |'
  prefs: []
  type: TYPE_TB
- en: '| [DOUBLE_PRECISION](#sqlalchemy.types.DOUBLE_PRECISION) | The SQL DOUBLE PRECISION
    type. |'
  prefs: []
  type: TYPE_TB
- en: '| [FLOAT](#sqlalchemy.types.FLOAT) | The SQL FLOAT type. |'
  prefs: []
  type: TYPE_TB
- en: '| [INT](#sqlalchemy.types.INT) | alias of [`INTEGER`](#sqlalchemy.types.INTEGER
    "sqlalchemy.sql.sqltypes.INTEGER") |'
  prefs: []
  type: TYPE_TB
- en: '| [INTEGER](#sqlalchemy.types.INTEGER) | The SQL INT or INTEGER type. |'
  prefs: []
  type: TYPE_TB
- en: '| [JSON](#sqlalchemy.types.JSON) | Represent a SQL JSON type. |'
  prefs: []
  type: TYPE_TB
- en: '| [NCHAR](#sqlalchemy.types.NCHAR) | The SQL NCHAR type. |'
  prefs: []
  type: TYPE_TB
- en: '| [NUMERIC](#sqlalchemy.types.NUMERIC) | The SQL NUMERIC type. |'
  prefs: []
  type: TYPE_TB
- en: '| [NVARCHAR](#sqlalchemy.types.NVARCHAR) | The SQL NVARCHAR type. |'
  prefs: []
  type: TYPE_TB
- en: '| [REAL](#sqlalchemy.types.REAL) | The SQL REAL type. |'
  prefs: []
  type: TYPE_TB
- en: '| [SMALLINT](#sqlalchemy.types.SMALLINT) | The SQL SMALLINT type. |'
  prefs: []
  type: TYPE_TB
- en: '| [TEXT](#sqlalchemy.types.TEXT) | The SQL TEXT type. |'
  prefs: []
  type: TYPE_TB
- en: '| [TIME](#sqlalchemy.types.TIME) | The SQL TIME type. |'
  prefs: []
  type: TYPE_TB
- en: '| [TIMESTAMP](#sqlalchemy.types.TIMESTAMP) | The SQL TIMESTAMP type. |'
  prefs: []
  type: TYPE_TB
- en: '| [UUID](#sqlalchemy.types.UUID) | Represent the SQL UUID type. |'
  prefs: []
  type: TYPE_TB
- en: '| [VARBINARY](#sqlalchemy.types.VARBINARY) | The SQL VARBINARY type. |'
  prefs: []
  type: TYPE_TB
- en: '| [VARCHAR](#sqlalchemy.types.VARCHAR) | The SQL VARCHAR type. |'
  prefs: []
  type: TYPE_TB
- en: '[PRE320]'
  prefs: []
  type: TYPE_PRE
- en: Represent a SQL Array type.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This type serves as the basis for all ARRAY operations. However, currently **only
    the PostgreSQL backend has support for SQL arrays in SQLAlchemy**. It is recommended
    to use the PostgreSQL-specific [`sqlalchemy.dialects.postgresql.ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY") type directly when using ARRAY types with
    PostgreSQL, as it provides additional operators specific to that backend.
  prefs: []
  type: TYPE_NORMAL
- en: '[`ARRAY`](#sqlalchemy.types.ARRAY "sqlalchemy.types.ARRAY") is part of the
    Core in support of various SQL standard functions such as [`array_agg`](functions.html#sqlalchemy.sql.functions.array_agg
    "sqlalchemy.sql.functions.array_agg") which explicitly involve arrays; however,
    with the exception of the PostgreSQL backend and possibly some third-party dialects,
    no other SQLAlchemy built-in dialect has support for this type.'
  prefs: []
  type: TYPE_NORMAL
- en: 'An [`ARRAY`](#sqlalchemy.types.ARRAY "sqlalchemy.types.ARRAY") type is constructed
    given the “type” of element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE321]'
  prefs: []
  type: TYPE_PRE
- en: 'The above type represents an N-dimensional array, meaning a supporting backend
    such as PostgreSQL will interpret values with any number of dimensions automatically.
    To produce an INSERT construct that passes in a 1-dimensional array of integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE322]'
  prefs: []
  type: TYPE_PRE
- en: 'The [`ARRAY`](#sqlalchemy.types.ARRAY "sqlalchemy.types.ARRAY") type can be
    constructed given a fixed number of dimensions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE323]'
  prefs: []
  type: TYPE_PRE
- en: 'Sending a number of dimensions is optional, but recommended if the datatype
    is to represent arrays of more than one dimension. This number is used:'
  prefs: []
  type: TYPE_NORMAL
- en: When emitting the type declaration itself to the database, e.g. `INTEGER[][]`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When translating Python values to database values, and vice versa, e.g. an ARRAY
    of [`Unicode`](#sqlalchemy.types.Unicode "sqlalchemy.types.Unicode") objects uses
    this number to efficiently access the string values inside of array structures
    without resorting to per-row type inspection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When used with the Python `getitem` accessor, the number of dimensions serves
    to define the kind of type that the `[]` operator should return, e.g. for an ARRAY
    of INTEGER with two dimensions:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE324]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: For 1-dimensional arrays, an [`ARRAY`](#sqlalchemy.types.ARRAY "sqlalchemy.types.ARRAY")
    instance with no dimension parameter will generally assume single-dimensional
    behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: 'SQL expressions of type [`ARRAY`](#sqlalchemy.types.ARRAY "sqlalchemy.types.ARRAY")
    have support for “index” and “slice” behavior. The `[]` operator produces expression
    constructs which will produce the appropriate SQL, both for SELECT statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE325]'
  prefs: []
  type: TYPE_PRE
- en: 'as well as UPDATE statements when the [`Update.values()`](dml.html#sqlalchemy.sql.expression.Update.values
    "sqlalchemy.sql.expression.Update.values") method is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE326]'
  prefs: []
  type: TYPE_PRE
- en: Indexed access is one-based by default; for zero-based index conversion, set
    [`ARRAY.zero_indexes`](#sqlalchemy.types.ARRAY.params.zero_indexes "sqlalchemy.types.ARRAY").
  prefs: []
  type: TYPE_NORMAL
- en: The [`ARRAY`](#sqlalchemy.types.ARRAY "sqlalchemy.types.ARRAY") type also provides
    for the operators [`Comparator.any()`](#sqlalchemy.types.ARRAY.Comparator.any
    "sqlalchemy.types.ARRAY.Comparator.any") and [`Comparator.all()`](#sqlalchemy.types.ARRAY.Comparator.all
    "sqlalchemy.types.ARRAY.Comparator.all"). The PostgreSQL-specific version of [`ARRAY`](#sqlalchemy.types.ARRAY
    "sqlalchemy.types.ARRAY") also provides additional operators.
  prefs: []
  type: TYPE_NORMAL
- en: '**Detecting Changes in ARRAY columns when using the ORM**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`ARRAY`](#sqlalchemy.types.ARRAY "sqlalchemy.types.ARRAY") type, when
    used with the SQLAlchemy ORM, does not detect in-place mutations to the array.
    In order to detect these, the [`sqlalchemy.ext.mutable`](../orm/extensions/mutable.html#module-sqlalchemy.ext.mutable
    "sqlalchemy.ext.mutable") extension must be used, using the [`MutableList`](../orm/extensions/mutable.html#sqlalchemy.ext.mutable.MutableList
    "sqlalchemy.ext.mutable.MutableList") class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE327]'
  prefs: []
  type: TYPE_PRE
- en: This extension will allow “in-place” changes such to the array such as `.append()`
    to produce events which will be detected by the unit of work. Note that changes
    to elements **inside** the array, including subarrays that are mutated in place,
    are **not** detected.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, assigning a new array value to an ORM element that replaces the
    old one will always trigger a change event.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sqlalchemy.dialects.postgresql.ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY")'
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.types.ARRAY.__init__), [contains()](#sqlalchemy.types.ARRAY.Comparator.contains),
    [any()](#sqlalchemy.types.ARRAY.Comparator.any), [all()](#sqlalchemy.types.ARRAY.Comparator.all)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.types.ARRAY`](#sqlalchemy.types.ARRAY "sqlalchemy.types.ARRAY")
    (`sqlalchemy.sql.expression.SchemaEventTarget`, [`sqlalchemy.types.Indexable`](type_api.html#sqlalchemy.types.Indexable
    "sqlalchemy.types.Indexable"), [`sqlalchemy.types.Concatenable`](type_api.html#sqlalchemy.types.Concatenable
    "sqlalchemy.types.Concatenable"), [`sqlalchemy.types.TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE328]'
  prefs: []
  type: TYPE_PRE
- en: Construct an [`ARRAY`](#sqlalchemy.types.ARRAY "sqlalchemy.types.ARRAY").
  prefs: []
  type: TYPE_NORMAL
- en: 'E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE329]'
  prefs: []
  type: TYPE_PRE
- en: 'Arguments are:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`item_type` – The data type of items of this array. Note that dimensionality
    is irrelevant here, so multi-dimensional arrays like `INTEGER[][]`, are constructed
    as `ARRAY(Integer)`, not as `ARRAY(ARRAY(Integer))` or such.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`as_tuple=False` – Specify whether return results should be converted to tuples
    from lists. This parameter is not generally needed as a Python list corresponds
    well to a SQL array.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dimensions` – if non-None, the ARRAY will assume a fixed number of dimensions.
    This impacts how the array is declared on the database, how it goes about interpreting
    Python and result values, as well as how expression behavior in conjunction with
    the “getitem” operator works. See the description at [`ARRAY`](#sqlalchemy.types.ARRAY
    "sqlalchemy.types.ARRAY") for additional detail.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`zero_indexes=False` – when True, index values will be converted between Python
    zero-based and SQL one-based indexes, e.g. a value of one will be added to all
    index values before passing to the database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE330]'
  prefs: []
  type: TYPE_PRE
- en: Define comparison operations for [`ARRAY`](#sqlalchemy.types.ARRAY "sqlalchemy.types.ARRAY").
  prefs: []
  type: TYPE_NORMAL
- en: More operators are available on the dialect-specific form of this type. See
    [`Comparator`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY.Comparator
    "sqlalchemy.dialects.postgresql.ARRAY.Comparator").
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.types.ARRAY.Comparator`](#sqlalchemy.types.ARRAY.Comparator
    "sqlalchemy.types.ARRAY.Comparator") (`sqlalchemy.types.Comparator`, `sqlalchemy.types.Comparator`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE331]'
  prefs: []
  type: TYPE_PRE
- en: '`ARRAY.contains()` not implemented for the base ARRAY type. Use the dialect-specific
    ARRAY type.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY") - PostgreSQL specific version.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE332]'
  prefs: []
  type: TYPE_PRE
- en: Return `other operator ANY (array)` clause.
  prefs: []
  type: TYPE_NORMAL
- en: Legacy Feature
  prefs: []
  type: TYPE_NORMAL
- en: This method is an [`ARRAY`](#sqlalchemy.types.ARRAY "sqlalchemy.types.ARRAY")
    - specific construct that is now superseded by the [`any_()`](sqlelement.html#sqlalchemy.sql.expression.any_
    "sqlalchemy.sql.expression.any_") function, which features a different calling
    style. The [`any_()`](sqlelement.html#sqlalchemy.sql.expression.any_ "sqlalchemy.sql.expression.any_")
    function is also mirrored at the method level via the [`ColumnOperators.any_()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.any_
    "sqlalchemy.sql.expression.ColumnOperators.any_") method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Usage of array-specific [`Comparator.any()`](#sqlalchemy.types.ARRAY.Comparator.any
    "sqlalchemy.types.ARRAY.Comparator.any") is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE333]'
  prefs: []
  type: TYPE_PRE
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`other` – expression to be compared'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`operator` – an operator object from the `sqlalchemy.sql.operators` package,
    defaults to `eq()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`any_()`](sqlelement.html#sqlalchemy.sql.expression.any_ "sqlalchemy.sql.expression.any_")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Comparator.all()`](#sqlalchemy.types.ARRAY.Comparator.all "sqlalchemy.types.ARRAY.Comparator.all")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE334]'
  prefs: []
  type: TYPE_PRE
- en: Return `other operator ALL (array)` clause.
  prefs: []
  type: TYPE_NORMAL
- en: Legacy Feature
  prefs: []
  type: TYPE_NORMAL
- en: This method is an [`ARRAY`](#sqlalchemy.types.ARRAY "sqlalchemy.types.ARRAY")
    - specific construct that is now superseded by the [`all_()`](sqlelement.html#sqlalchemy.sql.expression.all_
    "sqlalchemy.sql.expression.all_") function, which features a different calling
    style. The [`all_()`](sqlelement.html#sqlalchemy.sql.expression.all_ "sqlalchemy.sql.expression.all_")
    function is also mirrored at the method level via the [`ColumnOperators.all_()`](sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.all_
    "sqlalchemy.sql.expression.ColumnOperators.all_") method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Usage of array-specific [`Comparator.all()`](#sqlalchemy.types.ARRAY.Comparator.all
    "sqlalchemy.types.ARRAY.Comparator.all") is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE335]'
  prefs: []
  type: TYPE_PRE
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`other` – expression to be compared'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`operator` – an operator object from the `sqlalchemy.sql.operators` package,
    defaults to `eq()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`all_()`](sqlelement.html#sqlalchemy.sql.expression.all_ "sqlalchemy.sql.expression.all_")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Comparator.any()`](#sqlalchemy.types.ARRAY.Comparator.any "sqlalchemy.types.ARRAY.Comparator.any")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE336]'
  prefs: []
  type: TYPE_PRE
- en: The SQL BIGINT type.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`BigInteger`](#sqlalchemy.types.BigInteger "sqlalchemy.types.BigInteger")
    - documentation for the base type.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.types.BIGINT`](#sqlalchemy.types.BIGINT "sqlalchemy.types.BIGINT")
    ([`sqlalchemy.types.BigInteger`](#sqlalchemy.types.BigInteger "sqlalchemy.types.BigInteger"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE337]'
  prefs: []
  type: TYPE_PRE
- en: The SQL BINARY type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.types.BINARY`](#sqlalchemy.types.BINARY "sqlalchemy.types.BINARY")
    (`sqlalchemy.types._Binary`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE338]'
  prefs: []
  type: TYPE_PRE
- en: The SQL BLOB type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.types.BLOB.__init__)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.types.BLOB`](#sqlalchemy.types.BLOB "sqlalchemy.types.BLOB")
    ([`sqlalchemy.types.LargeBinary`](#sqlalchemy.types.LargeBinary "sqlalchemy.types.LargeBinary"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE339]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `sqlalchemy.types.LargeBinary.__init__` *method of* [`LargeBinary`](#sqlalchemy.types.LargeBinary
    "sqlalchemy.types.LargeBinary")'
  prefs: []
  type: TYPE_NORMAL
- en: Construct a LargeBinary type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**length** – optional, a length for the column for use in DDL statements, for
    those binary types that accept a length, such as the MySQL BLOB type.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE340]'
  prefs: []
  type: TYPE_PRE
- en: The SQL BOOLEAN type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.types.BOOLEAN.__init__)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.types.BOOLEAN`](#sqlalchemy.types.BOOLEAN "sqlalchemy.types.BOOLEAN")
    ([`sqlalchemy.types.Boolean`](#sqlalchemy.types.Boolean "sqlalchemy.types.Boolean"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE341]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `sqlalchemy.types.Boolean.__init__` *method of* [`Boolean`](#sqlalchemy.types.Boolean
    "sqlalchemy.types.Boolean")'
  prefs: []
  type: TYPE_NORMAL
- en: Construct a Boolean.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`create_constraint` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: defaults to False. If the boolean is generated as an int/smallint, also create
    a CHECK constraint on the table that ensures 1 or 0 as a value.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: it is strongly recommended that the CHECK constraint have an explicit name in
    order to support schema-management concerns. This can be established either by
    setting the [`Boolean.name`](#sqlalchemy.types.Boolean.params.name "sqlalchemy.types.Boolean")
    parameter or by setting up an appropriate naming convention; see [Configuring
    Constraint Naming Conventions](constraints.html#constraint-naming-conventions)
    for background.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Changed in version 1.4: - this flag now defaults to False, meaning no CHECK
    constraint is generated for a non-native enumerated type.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`name` – if a CHECK constraint is generated, specify the name of the constraint.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE342]'
  prefs: []
  type: TYPE_PRE
- en: The SQL CHAR type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.types.CHAR.__init__)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.types.CHAR`](#sqlalchemy.types.CHAR "sqlalchemy.types.CHAR")
    ([`sqlalchemy.types.String`](#sqlalchemy.types.String "sqlalchemy.types.String"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE343]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `sqlalchemy.types.String.__init__` *method of* [`String`](#sqlalchemy.types.String
    "sqlalchemy.types.String")'
  prefs: []
  type: TYPE_NORMAL
- en: Create a string-holding type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`length` – optional, a length for the column for use in DDL and CAST expressions.
    May be safely omitted if no `CREATE TABLE` will be issued. Certain databases may
    require a `length` for use in DDL, and will raise an exception when the `CREATE
    TABLE` DDL is issued if a `VARCHAR` with no length is included. Whether the value
    is interpreted as bytes or characters is database specific.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`collation` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Optional, a column-level collation for use in DDL and CAST expressions. Renders
    using the COLLATE keyword supported by SQLite, MySQL, and PostgreSQL. E.g.:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE344]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In most cases, the [`Unicode`](#sqlalchemy.types.Unicode "sqlalchemy.types.Unicode")
    or [`UnicodeText`](#sqlalchemy.types.UnicodeText "sqlalchemy.types.UnicodeText")
    datatypes should be used for a [`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") that expects to store non-ascii data. These datatypes
    will ensure that the correct types are used on the database.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE345]'
  prefs: []
  type: TYPE_PRE
- en: The CLOB type.
  prefs: []
  type: TYPE_NORMAL
- en: This type is found in Oracle and Informix.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.types.CLOB.__init__)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.types.CLOB`](#sqlalchemy.types.CLOB "sqlalchemy.types.CLOB")
    ([`sqlalchemy.types.Text`](#sqlalchemy.types.Text "sqlalchemy.types.Text"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE346]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `sqlalchemy.types.String.__init__` *method of* [`String`](#sqlalchemy.types.String
    "sqlalchemy.types.String")'
  prefs: []
  type: TYPE_NORMAL
- en: Create a string-holding type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`length` – optional, a length for the column for use in DDL and CAST expressions.
    May be safely omitted if no `CREATE TABLE` will be issued. Certain databases may
    require a `length` for use in DDL, and will raise an exception when the `CREATE
    TABLE` DDL is issued if a `VARCHAR` with no length is included. Whether the value
    is interpreted as bytes or characters is database specific.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`collation` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Optional, a column-level collation for use in DDL and CAST expressions. Renders
    using the COLLATE keyword supported by SQLite, MySQL, and PostgreSQL. E.g.:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE347]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In most cases, the [`Unicode`](#sqlalchemy.types.Unicode "sqlalchemy.types.Unicode")
    or [`UnicodeText`](#sqlalchemy.types.UnicodeText "sqlalchemy.types.UnicodeText")
    datatypes should be used for a [`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") that expects to store non-ascii data. These datatypes
    will ensure that the correct types are used on the database.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE348]'
  prefs: []
  type: TYPE_PRE
- en: The SQL DATE type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.types.DATE`](#sqlalchemy.types.DATE "sqlalchemy.types.DATE")
    ([`sqlalchemy.types.Date`](#sqlalchemy.types.Date "sqlalchemy.types.Date"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE349]'
  prefs: []
  type: TYPE_PRE
- en: The SQL DATETIME type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.types.DATETIME.__init__)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.types.DATETIME`](#sqlalchemy.types.DATETIME "sqlalchemy.types.DATETIME")
    ([`sqlalchemy.types.DateTime`](#sqlalchemy.types.DateTime "sqlalchemy.types.DateTime"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE350]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `sqlalchemy.types.DateTime.__init__` *method of* [`DateTime`](#sqlalchemy.types.DateTime
    "sqlalchemy.types.DateTime")'
  prefs: []
  type: TYPE_NORMAL
- en: Construct a new [`DateTime`](#sqlalchemy.types.DateTime "sqlalchemy.types.DateTime").
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**timezone** – boolean. Indicates that the datetime type should enable timezone
    support, if available on the **base date/time-holding type only**. It is recommended
    to make use of the [`TIMESTAMP`](#sqlalchemy.types.TIMESTAMP "sqlalchemy.types.TIMESTAMP")
    datatype directly when using this flag, as some databases include separate generic
    date/time-holding types distinct from the timezone-capable TIMESTAMP datatype,
    such as Oracle.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE351]'
  prefs: []
  type: TYPE_PRE
- en: The SQL DECIMAL type.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Numeric`](#sqlalchemy.types.Numeric "sqlalchemy.types.Numeric") - documentation
    for the base type.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.types.DECIMAL.__init__)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.types.DECIMAL`](#sqlalchemy.types.DECIMAL "sqlalchemy.types.DECIMAL")
    ([`sqlalchemy.types.Numeric`](#sqlalchemy.types.Numeric "sqlalchemy.types.Numeric"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE352]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `sqlalchemy.types.Numeric.__init__` *method of* [`Numeric`](#sqlalchemy.types.Numeric
    "sqlalchemy.types.Numeric")'
  prefs: []
  type: TYPE_NORMAL
- en: Construct a Numeric.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`precision` – the numeric precision for use in DDL `CREATE TABLE`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scale` – the numeric scale for use in DDL `CREATE TABLE`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`asdecimal` – default True. Return whether or not values should be sent as
    Python Decimal objects, or as floats. Different DBAPIs send one or the other based
    on datatypes - the Numeric type will ensure that return values are one or the
    other across DBAPIs consistently.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`decimal_return_scale` – Default scale to use when converting from floats to
    Python decimals. Floating point values will typically be much longer due to decimal
    inaccuracy, and most floating point database types don’t have a notion of “scale”,
    so by default the float type looks for the first ten decimal places when converting.
    Specifying this value will override that length. Types which do include an explicit
    “.scale” value, such as the base [`Numeric`](#sqlalchemy.types.Numeric "sqlalchemy.types.Numeric")
    as well as the MySQL float types, will use the value of “.scale” as the default
    for decimal_return_scale, if not otherwise specified.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When using the `Numeric` type, care should be taken to ensure that the asdecimal
    setting is appropriate for the DBAPI in use - when Numeric applies a conversion
    from Decimal->float or float-> Decimal, this conversion incurs an additional performance
    overhead for all result columns received.
  prefs: []
  type: TYPE_NORMAL
- en: DBAPIs that return Decimal natively (e.g. psycopg2) will have better accuracy
    and higher performance with a setting of `True`, as the native translation to
    Decimal reduces the amount of floating- point issues at play, and the Numeric
    type itself doesn’t need to apply any further conversions. However, another DBAPI
    which returns floats natively *will* incur an additional conversion overhead,
    and is still subject to floating point data loss - in which case `asdecimal=False`
    will at least remove the extra conversion overhead.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE353]'
  prefs: []
  type: TYPE_PRE
- en: The SQL DOUBLE type.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Double`](#sqlalchemy.types.Double "sqlalchemy.types.Double") - documentation
    for the base type.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.types.DOUBLE.__init__)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.types.DOUBLE`](#sqlalchemy.types.DOUBLE "sqlalchemy.types.DOUBLE")
    ([`sqlalchemy.types.Double`](#sqlalchemy.types.Double "sqlalchemy.types.Double"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE354]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `sqlalchemy.types.Float.__init__` *method of* [`Float`](#sqlalchemy.types.Float
    "sqlalchemy.types.Float")'
  prefs: []
  type: TYPE_NORMAL
- en: Construct a Float.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`precision` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the numeric precision for use in DDL `CREATE TABLE`. Backends **should** attempt
    to ensure this precision indicates a number of digits for the generic [`Float`](#sqlalchemy.types.Float
    "sqlalchemy.types.Float") datatype.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For the Oracle backend, the [`Float.precision`](#sqlalchemy.types.Float.params.precision
    "sqlalchemy.types.Float") parameter is not accepted when rendering DDL, as Oracle
    does not support float precision specified as a number of decimal places. Instead,
    use the Oracle-specific [`FLOAT`](../dialects/oracle.html#sqlalchemy.dialects.oracle.FLOAT
    "sqlalchemy.dialects.oracle.FLOAT") datatype and specify the [`FLOAT.binary_precision`](../dialects/oracle.html#sqlalchemy.dialects.oracle.FLOAT.params.binary_precision
    "sqlalchemy.dialects.oracle.FLOAT") parameter. This is new in version 2.0 of SQLAlchemy.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To create a database agnostic [`Float`](#sqlalchemy.types.Float "sqlalchemy.types.Float")
    that separately specifies binary precision for Oracle, use [`TypeEngine.with_variant()`](type_api.html#sqlalchemy.types.TypeEngine.with_variant
    "sqlalchemy.types.TypeEngine.with_variant") as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE355]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`asdecimal` – the same flag as that of [`Numeric`](#sqlalchemy.types.Numeric
    "sqlalchemy.types.Numeric"), but defaults to `False`. Note that setting this flag
    to `True` results in floating point conversion.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`decimal_return_scale` – Default scale to use when converting from floats to
    Python decimals. Floating point values will typically be much longer due to decimal
    inaccuracy, and most floating point database types don’t have a notion of “scale”,
    so by default the float type looks for the first ten decimal places when converting.
    Specifying this value will override that length. Note that the MySQL float types,
    which do include “scale”, will use “scale” as the default for decimal_return_scale,
    if not otherwise specified.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE356]'
  prefs: []
  type: TYPE_PRE
- en: The SQL DOUBLE PRECISION type.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Double`](#sqlalchemy.types.Double "sqlalchemy.types.Double") - documentation
    for the base type.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.types.DOUBLE_PRECISION.__init__)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.types.DOUBLE_PRECISION`](#sqlalchemy.types.DOUBLE_PRECISION
    "sqlalchemy.types.DOUBLE_PRECISION") ([`sqlalchemy.types.Double`](#sqlalchemy.types.Double
    "sqlalchemy.types.Double"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE357]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `sqlalchemy.types.Float.__init__` *method of* [`Float`](#sqlalchemy.types.Float
    "sqlalchemy.types.Float")'
  prefs: []
  type: TYPE_NORMAL
- en: Construct a Float.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`precision` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the numeric precision for use in DDL `CREATE TABLE`. Backends **should** attempt
    to ensure this precision indicates a number of digits for the generic [`Float`](#sqlalchemy.types.Float
    "sqlalchemy.types.Float") datatype.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For the Oracle backend, the [`Float.precision`](#sqlalchemy.types.Float.params.precision
    "sqlalchemy.types.Float") parameter is not accepted when rendering DDL, as Oracle
    does not support float precision specified as a number of decimal places. Instead,
    use the Oracle-specific [`FLOAT`](../dialects/oracle.html#sqlalchemy.dialects.oracle.FLOAT
    "sqlalchemy.dialects.oracle.FLOAT") datatype and specify the [`FLOAT.binary_precision`](../dialects/oracle.html#sqlalchemy.dialects.oracle.FLOAT.params.binary_precision
    "sqlalchemy.dialects.oracle.FLOAT") parameter. This is new in version 2.0 of SQLAlchemy.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To create a database agnostic [`Float`](#sqlalchemy.types.Float "sqlalchemy.types.Float")
    that separately specifies binary precision for Oracle, use [`TypeEngine.with_variant()`](type_api.html#sqlalchemy.types.TypeEngine.with_variant
    "sqlalchemy.types.TypeEngine.with_variant") as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE358]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`asdecimal` – the same flag as that of [`Numeric`](#sqlalchemy.types.Numeric
    "sqlalchemy.types.Numeric"), but defaults to `False`. Note that setting this flag
    to `True` results in floating point conversion.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`decimal_return_scale` – Default scale to use when converting from floats to
    Python decimals. Floating point values will typically be much longer due to decimal
    inaccuracy, and most floating point database types don’t have a notion of “scale”,
    so by default the float type looks for the first ten decimal places when converting.
    Specifying this value will override that length. Note that the MySQL float types,
    which do include “scale”, will use “scale” as the default for decimal_return_scale,
    if not otherwise specified.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE359]'
  prefs: []
  type: TYPE_PRE
- en: The SQL FLOAT type.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Float`](#sqlalchemy.types.Float "sqlalchemy.types.Float") - documentation
    for the base type.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.types.FLOAT.__init__)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.types.FLOAT`](#sqlalchemy.types.FLOAT "sqlalchemy.types.FLOAT")
    ([`sqlalchemy.types.Float`](#sqlalchemy.types.Float "sqlalchemy.types.Float"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE360]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `sqlalchemy.types.Float.__init__` *method of* [`Float`](#sqlalchemy.types.Float
    "sqlalchemy.types.Float")'
  prefs: []
  type: TYPE_NORMAL
- en: Construct a Float.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`precision` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the numeric precision for use in DDL `CREATE TABLE`. Backends **should** attempt
    to ensure this precision indicates a number of digits for the generic [`Float`](#sqlalchemy.types.Float
    "sqlalchemy.types.Float") datatype.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For the Oracle backend, the [`Float.precision`](#sqlalchemy.types.Float.params.precision
    "sqlalchemy.types.Float") parameter is not accepted when rendering DDL, as Oracle
    does not support float precision specified as a number of decimal places. Instead,
    use the Oracle-specific [`FLOAT`](../dialects/oracle.html#sqlalchemy.dialects.oracle.FLOAT
    "sqlalchemy.dialects.oracle.FLOAT") datatype and specify the [`FLOAT.binary_precision`](../dialects/oracle.html#sqlalchemy.dialects.oracle.FLOAT.params.binary_precision
    "sqlalchemy.dialects.oracle.FLOAT") parameter. This is new in version 2.0 of SQLAlchemy.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To create a database agnostic [`Float`](#sqlalchemy.types.Float "sqlalchemy.types.Float")
    that separately specifies binary precision for Oracle, use [`TypeEngine.with_variant()`](type_api.html#sqlalchemy.types.TypeEngine.with_variant
    "sqlalchemy.types.TypeEngine.with_variant") as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE361]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`asdecimal` – the same flag as that of [`Numeric`](#sqlalchemy.types.Numeric
    "sqlalchemy.types.Numeric"), but defaults to `False`. Note that setting this flag
    to `True` results in floating point conversion.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`decimal_return_scale` – Default scale to use when converting from floats to
    Python decimals. Floating point values will typically be much longer due to decimal
    inaccuracy, and most floating point database types don’t have a notion of “scale”,
    so by default the float type looks for the first ten decimal places when converting.
    Specifying this value will override that length. Note that the MySQL float types,
    which do include “scale”, will use “scale” as the default for decimal_return_scale,
    if not otherwise specified.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE362]'
  prefs: []
  type: TYPE_PRE
- en: alias of [`INTEGER`](#sqlalchemy.types.INTEGER "sqlalchemy.sql.sqltypes.INTEGER")
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE363]'
  prefs: []
  type: TYPE_PRE
- en: Represent a SQL JSON type.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '[`JSON`](#sqlalchemy.types.JSON "sqlalchemy.types.JSON") is provided as a facade
    for vendor-specific JSON types. Since it supports JSON SQL operations, it only
    works on backends that have an actual JSON type, currently:'
  prefs: []
  type: TYPE_NORMAL
- en: PostgreSQL - see [`sqlalchemy.dialects.postgresql.JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON
    "sqlalchemy.dialects.postgresql.JSON") and [`sqlalchemy.dialects.postgresql.JSONB`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSONB
    "sqlalchemy.dialects.postgresql.JSONB") for backend-specific notes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MySQL - see [`sqlalchemy.dialects.mysql.JSON`](../dialects/mysql.html#sqlalchemy.dialects.mysql.JSON
    "sqlalchemy.dialects.mysql.JSON") for backend-specific notes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SQLite as of version 3.9 - see [`sqlalchemy.dialects.sqlite.JSON`](../dialects/sqlite.html#sqlalchemy.dialects.sqlite.JSON
    "sqlalchemy.dialects.sqlite.JSON") for backend-specific notes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microsoft SQL Server 2016 and later - see [`sqlalchemy.dialects.mssql.JSON`](../dialects/mssql.html#sqlalchemy.dialects.mssql.JSON
    "sqlalchemy.dialects.mssql.JSON") for backend-specific notes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`JSON`](#sqlalchemy.types.JSON "sqlalchemy.types.JSON") is part of the Core
    in support of the growing popularity of native JSON datatypes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`JSON`](#sqlalchemy.types.JSON "sqlalchemy.types.JSON") type stores arbitrary
    JSON format data, e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE364]'
  prefs: []
  type: TYPE_PRE
- en: '**JSON-Specific Expression Operators**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`JSON`](#sqlalchemy.types.JSON "sqlalchemy.types.JSON") datatype provides
    these additional SQL operations:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Keyed index operations:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE365]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Integer index operations:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE366]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Path index operations:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE367]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Data casters for specific JSON element types, subsequent to an index or path
    operation being invoked:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE368]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: New in version 1.3.11.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Additional operations may be available from the dialect-specific versions of
    [`JSON`](#sqlalchemy.types.JSON "sqlalchemy.types.JSON"), such as [`sqlalchemy.dialects.postgresql.JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON
    "sqlalchemy.dialects.postgresql.JSON") and [`sqlalchemy.dialects.postgresql.JSONB`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSONB
    "sqlalchemy.dialects.postgresql.JSONB") which both offer additional PostgreSQL-specific
    operations.
  prefs: []
  type: TYPE_NORMAL
- en: '**Casting JSON Elements to Other Types**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Index operations, i.e. those invoked by calling upon the expression using the
    Python bracket operator as in `some_column[''some key'']`, return an expression
    object whose type defaults to [`JSON`](#sqlalchemy.types.JSON "sqlalchemy.types.JSON")
    by default, so that further JSON-oriented instructions may be called upon the
    result type. However, it is likely more common that an index operation is expected
    to return a specific scalar element, such as a string or integer. In order to
    provide access to these elements in a backend-agnostic way, a series of data casters
    are provided:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`Comparator.as_string()`](#sqlalchemy.types.JSON.Comparator.as_string "sqlalchemy.types.JSON.Comparator.as_string")
    - return the element as a string'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`Comparator.as_boolean()`](#sqlalchemy.types.JSON.Comparator.as_boolean "sqlalchemy.types.JSON.Comparator.as_boolean")
    - return the element as a boolean'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`Comparator.as_float()`](#sqlalchemy.types.JSON.Comparator.as_float "sqlalchemy.types.JSON.Comparator.as_float")
    - return the element as a float'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`Comparator.as_integer()`](#sqlalchemy.types.JSON.Comparator.as_integer "sqlalchemy.types.JSON.Comparator.as_integer")
    - return the element as an integer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These data casters are implemented by supporting dialects in order to assure
    that comparisons to the above types will work as expected, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE369]'
  prefs: []
  type: TYPE_PRE
- en: 'New in version 1.3.11: Added type-specific casters for the basic JSON data
    element types.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The data caster functions are new in version 1.3.11, and supersede the previous
    documented approaches of using CAST; for reference, this looked like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE370]'
  prefs: []
  type: TYPE_PRE
- en: 'The above case now works directly as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE371]'
  prefs: []
  type: TYPE_PRE
- en: For details on the previous comparison approach within the 1.3.x series, see
    the documentation for SQLAlchemy 1.2 or the included HTML files in the doc/ directory
    of the version’s distribution.
  prefs: []
  type: TYPE_NORMAL
- en: '**Detecting Changes in JSON columns when using the ORM**'
  prefs: []
  type: TYPE_NORMAL
- en: The [`JSON`](#sqlalchemy.types.JSON "sqlalchemy.types.JSON") type, when used
    with the SQLAlchemy ORM, does not detect in-place mutations to the structure.
    In order to detect these, the [`sqlalchemy.ext.mutable`](../orm/extensions/mutable.html#module-sqlalchemy.ext.mutable
    "sqlalchemy.ext.mutable") extension must be used, most typically using the [`MutableDict`](../orm/extensions/mutable.html#sqlalchemy.ext.mutable.MutableDict
    "sqlalchemy.ext.mutable.MutableDict") class. This extension will allow “in-place”
    changes to the datastructure to produce events which will be detected by the unit
    of work. See the example at [`HSTORE`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.HSTORE
    "sqlalchemy.dialects.postgresql.HSTORE") for a simple example involving a dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, assigning a JSON structure to an ORM element that replaces the
    old one will always trigger a change event.
  prefs: []
  type: TYPE_NORMAL
- en: '**Support for JSON null vs. SQL NULL**'
  prefs: []
  type: TYPE_NORMAL
- en: 'When working with NULL values, the [`JSON`](#sqlalchemy.types.JSON "sqlalchemy.types.JSON")
    type recommends the use of two specific constants in order to differentiate between
    a column that evaluates to SQL NULL, e.g. no value, vs. the JSON-encoded string
    of `"null"`. To insert or select against a value that is SQL NULL, use the constant
    [`null()`](sqlelement.html#sqlalchemy.sql.expression.null "sqlalchemy.sql.expression.null").
    This symbol may be passed as a parameter value specifically when using the [`JSON`](#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON") datatype, which contains special logic that interprets
    this symbol to mean that the column value should be SQL NULL as opposed to JSON
    `"null"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE372]'
  prefs: []
  type: TYPE_PRE
- en: 'To insert or select against a value that is JSON `"null"`, use the constant
    [`JSON.NULL`](#sqlalchemy.types.JSON.NULL "sqlalchemy.types.JSON.NULL"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE373]'
  prefs: []
  type: TYPE_PRE
- en: The [`JSON`](#sqlalchemy.types.JSON "sqlalchemy.types.JSON") type supports a
    flag [`JSON.none_as_null`](#sqlalchemy.types.JSON.params.none_as_null "sqlalchemy.types.JSON")
    which when set to True will result in the Python constant `None` evaluating to
    the value of SQL NULL, and when set to False results in the Python constant `None`
    evaluating to the value of JSON `"null"`. The Python value `None` may be used
    in conjunction with either [`JSON.NULL`](#sqlalchemy.types.JSON.NULL "sqlalchemy.types.JSON.NULL")
    and [`null()`](sqlelement.html#sqlalchemy.sql.expression.null "sqlalchemy.sql.expression.null")
    in order to indicate NULL values, but care must be taken as to the value of the
    [`JSON.none_as_null`](#sqlalchemy.types.JSON.params.none_as_null "sqlalchemy.types.JSON")
    in these cases.
  prefs: []
  type: TYPE_NORMAL
- en: '**Customizing the JSON Serializer**'
  prefs: []
  type: TYPE_NORMAL
- en: The JSON serializer and deserializer used by [`JSON`](#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON") defaults to Python’s `json.dumps` and `json.loads` functions;
    in the case of the psycopg2 dialect, psycopg2 may be using its own custom loader
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to affect the serializer / deserializer, they are currently configurable
    at the [`create_engine()`](engines.html#sqlalchemy.create_engine "sqlalchemy.create_engine")
    level via the [`create_engine.json_serializer`](engines.html#sqlalchemy.create_engine.params.json_serializer
    "sqlalchemy.create_engine") and [`create_engine.json_deserializer`](engines.html#sqlalchemy.create_engine.params.json_deserializer
    "sqlalchemy.create_engine") parameters. For example, to turn off `ensure_ascii`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE374]'
  prefs: []
  type: TYPE_PRE
- en: 'Changed in version 1.3.7: SQLite dialect’s `json_serializer` and `json_deserializer`
    parameters renamed from `_json_serializer` and `_json_deserializer`.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`sqlalchemy.dialects.postgresql.JSON`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSON
    "sqlalchemy.dialects.postgresql.JSON")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`sqlalchemy.dialects.postgresql.JSONB`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.JSONB
    "sqlalchemy.dialects.postgresql.JSONB")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`sqlalchemy.dialects.mysql.JSON`](../dialects/mysql.html#sqlalchemy.dialects.mysql.JSON
    "sqlalchemy.dialects.mysql.JSON")'
  prefs: []
  type: TYPE_NORMAL
- en: '[`sqlalchemy.dialects.sqlite.JSON`](../dialects/sqlite.html#sqlalchemy.dialects.sqlite.JSON
    "sqlalchemy.dialects.sqlite.JSON")'
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[as_boolean()](#sqlalchemy.types.JSON.Comparator.as_boolean), [as_float()](#sqlalchemy.types.JSON.Comparator.as_float),
    [as_integer()](#sqlalchemy.types.JSON.Comparator.as_integer), [as_json()](#sqlalchemy.types.JSON.Comparator.as_json),
    [as_numeric()](#sqlalchemy.types.JSON.Comparator.as_numeric), [as_string()](#sqlalchemy.types.JSON.Comparator.as_string),
    [bind_processor()](#sqlalchemy.types.JSON.JSONElementType.bind_processor), [literal_processor()](#sqlalchemy.types.JSON.JSONElementType.literal_processor),
    [NULL](#sqlalchemy.types.JSON.NULL), [__init__()](#sqlalchemy.types.JSON.__init__),
    [bind_processor()](#sqlalchemy.types.JSON.bind_processor), [comparator_factory](#sqlalchemy.types.JSON.comparator_factory),
    [hashable](#sqlalchemy.types.JSON.hashable), [python_type](#sqlalchemy.types.JSON.python_type),
    [result_processor()](#sqlalchemy.types.JSON.result_processor), [should_evaluate_none](#sqlalchemy.types.JSON.should_evaluate_none)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.types.JSON`](#sqlalchemy.types.JSON "sqlalchemy.types.JSON")
    ([`sqlalchemy.types.Indexable`](type_api.html#sqlalchemy.types.Indexable "sqlalchemy.types.Indexable"),
    [`sqlalchemy.types.TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine "sqlalchemy.types.TypeEngine"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE375]'
  prefs: []
  type: TYPE_PRE
- en: Define comparison operations for [`JSON`](#sqlalchemy.types.JSON "sqlalchemy.types.JSON").
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.types.JSON.Comparator`](#sqlalchemy.types.JSON.Comparator
    "sqlalchemy.types.JSON.Comparator") (`sqlalchemy.types.Comparator`, `sqlalchemy.types.Comparator`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE376]'
  prefs: []
  type: TYPE_PRE
- en: Cast an indexed value as boolean.
  prefs: []
  type: TYPE_NORMAL
- en: 'e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE377]'
  prefs: []
  type: TYPE_PRE
- en: New in version 1.3.11.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE378]'
  prefs: []
  type: TYPE_PRE
- en: Cast an indexed value as float.
  prefs: []
  type: TYPE_NORMAL
- en: 'e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE379]'
  prefs: []
  type: TYPE_PRE
- en: New in version 1.3.11.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE380]'
  prefs: []
  type: TYPE_PRE
- en: Cast an indexed value as integer.
  prefs: []
  type: TYPE_NORMAL
- en: 'e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE381]'
  prefs: []
  type: TYPE_PRE
- en: New in version 1.3.11.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE382]'
  prefs: []
  type: TYPE_PRE
- en: Cast an indexed value as JSON.
  prefs: []
  type: TYPE_NORMAL
- en: 'e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE383]'
  prefs: []
  type: TYPE_PRE
- en: This is typically the default behavior of indexed elements in any case.
  prefs: []
  type: TYPE_NORMAL
- en: Note that comparison of full JSON structures may not be supported by all backends.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 1.3.11.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE384]'
  prefs: []
  type: TYPE_PRE
- en: Cast an indexed value as numeric/decimal.
  prefs: []
  type: TYPE_NORMAL
- en: 'e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE385]'
  prefs: []
  type: TYPE_PRE
- en: New in version 1.4.0b2.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE386]'
  prefs: []
  type: TYPE_PRE
- en: Cast an indexed value as string.
  prefs: []
  type: TYPE_NORMAL
- en: 'e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE387]'
  prefs: []
  type: TYPE_PRE
- en: New in version 1.3.11.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE388]'
  prefs: []
  type: TYPE_PRE
- en: Common function for index / path elements in a JSON expression.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.types.JSON.JSONElementType`](#sqlalchemy.types.JSON.JSONElementType
    "sqlalchemy.types.JSON.JSONElementType") ([`sqlalchemy.types.TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE389]'
  prefs: []
  type: TYPE_PRE
- en: Return a conversion function for processing bind values.
  prefs: []
  type: TYPE_NORMAL
- en: Returns a callable which will receive a bind parameter value as the sole positional
    argument and will return a value to send to the DB-API.
  prefs: []
  type: TYPE_NORMAL
- en: If processing is not necessary, the method should return `None`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This method is only called relative to a **dialect specific type object**, which
    is often **private to a dialect in use** and is not the same type object as the
    public facing one, which means it’s not feasible to subclass a [`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") class in order to provide an alternate [`TypeEngine.bind_processor()`](type_api.html#sqlalchemy.types.TypeEngine.bind_processor
    "sqlalchemy.types.TypeEngine.bind_processor") method, unless subclassing the [`UserDefinedType`](custom_types.html#sqlalchemy.types.UserDefinedType
    "sqlalchemy.types.UserDefinedType") class explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: To provide alternate behavior for [`TypeEngine.bind_processor()`](type_api.html#sqlalchemy.types.TypeEngine.bind_processor
    "sqlalchemy.types.TypeEngine.bind_processor"), implement a [`TypeDecorator`](custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") class and provide an implementation of [`TypeDecorator.process_bind_param()`](custom_types.html#sqlalchemy.types.TypeDecorator.process_bind_param
    "sqlalchemy.types.TypeDecorator.process_bind_param").
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Augmenting Existing Types](custom_types.html#types-typedecorator)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**dialect** – Dialect instance in use.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE390]'
  prefs: []
  type: TYPE_PRE
- en: Return a conversion function for processing literal values that are to be rendered
    directly without using binds.
  prefs: []
  type: TYPE_NORMAL
- en: This function is used when the compiler makes use of the “literal_binds” flag,
    typically used in DDL generation as well as in certain scenarios where backends
    don’t accept bound parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Returns a callable which will receive a literal Python value as the sole positional
    argument and will return a string representation to be rendered in a SQL statement.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This method is only called relative to a **dialect specific type object**, which
    is often **private to a dialect in use** and is not the same type object as the
    public facing one, which means it’s not feasible to subclass a [`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") class in order to provide an alternate [`TypeEngine.literal_processor()`](type_api.html#sqlalchemy.types.TypeEngine.literal_processor
    "sqlalchemy.types.TypeEngine.literal_processor") method, unless subclassing the
    [`UserDefinedType`](custom_types.html#sqlalchemy.types.UserDefinedType "sqlalchemy.types.UserDefinedType")
    class explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: To provide alternate behavior for [`TypeEngine.literal_processor()`](type_api.html#sqlalchemy.types.TypeEngine.literal_processor
    "sqlalchemy.types.TypeEngine.literal_processor"), implement a [`TypeDecorator`](custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") class and provide an implementation of [`TypeDecorator.process_literal_param()`](custom_types.html#sqlalchemy.types.TypeDecorator.process_literal_param
    "sqlalchemy.types.TypeDecorator.process_literal_param").
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Augmenting Existing Types](custom_types.html#types-typedecorator)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE391]'
  prefs: []
  type: TYPE_PRE
- en: Placeholder for the datatype of a JSON index value.
  prefs: []
  type: TYPE_NORMAL
- en: This allows execution-time processing of JSON index values for special syntaxes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.types.JSON.JSONIndexType`](#sqlalchemy.types.JSON.JSONIndexType
    "sqlalchemy.types.JSON.JSONIndexType") (`sqlalchemy.types.JSONElementType`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE392]'
  prefs: []
  type: TYPE_PRE
- en: Placeholder for the datatype of a JSON index value.
  prefs: []
  type: TYPE_NORMAL
- en: This allows execution-time processing of JSON index values for special syntaxes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.types.JSON.JSONIntIndexType`](#sqlalchemy.types.JSON.JSONIntIndexType
    "sqlalchemy.types.JSON.JSONIntIndexType") (`sqlalchemy.types.JSONIndexType`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE393]'
  prefs: []
  type: TYPE_PRE
- en: Placeholder type for JSON path operations.
  prefs: []
  type: TYPE_NORMAL
- en: This allows execution-time processing of a path-based index value into a specific
    SQL syntax.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.types.JSON.JSONPathType`](#sqlalchemy.types.JSON.JSONPathType
    "sqlalchemy.types.JSON.JSONPathType") (`sqlalchemy.types.JSONElementType`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE394]'
  prefs: []
  type: TYPE_PRE
- en: Placeholder for the datatype of a JSON index value.
  prefs: []
  type: TYPE_NORMAL
- en: This allows execution-time processing of JSON index values for special syntaxes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.types.JSON.JSONStrIndexType`](#sqlalchemy.types.JSON.JSONStrIndexType
    "sqlalchemy.types.JSON.JSONStrIndexType") (`sqlalchemy.types.JSONIndexType`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE395]'
  prefs: []
  type: TYPE_PRE
- en: Describe the json value of NULL.
  prefs: []
  type: TYPE_NORMAL
- en: 'This value is used to force the JSON value of `"null"` to be used as the value.
    A value of Python `None` will be recognized either as SQL NULL or JSON `"null"`,
    based on the setting of the [`JSON.none_as_null`](#sqlalchemy.types.JSON.params.none_as_null
    "sqlalchemy.types.JSON") flag; the [`JSON.NULL`](#sqlalchemy.types.JSON.NULL "sqlalchemy.types.JSON.NULL")
    constant can be used to always resolve to JSON `"null"` regardless of this setting.
    This is in contrast to the [`null()`](sqlelement.html#sqlalchemy.sql.expression.null
    "sqlalchemy.sql.expression.null") construct, which always resolves to SQL NULL.
    E.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE396]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to set JSON NULL as a default value for a column, the most transparent
    method is to use [`text()`](sqlelement.html#sqlalchemy.sql.expression.text "sqlalchemy.sql.expression.text"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE397]'
  prefs: []
  type: TYPE_PRE
- en: While it is possible to use [`JSON.NULL`](#sqlalchemy.types.JSON.NULL "sqlalchemy.types.JSON.NULL")
    in this context, the [`JSON.NULL`](#sqlalchemy.types.JSON.NULL "sqlalchemy.types.JSON.NULL")
    value will be returned as the value of the column, which in the context of the
    ORM or other repurposing of the default value, may not be desirable. Using a SQL
    expression means the value will be re-fetched from the database within the context
    of retrieving generated defaults.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE398]'
  prefs: []
  type: TYPE_PRE
- en: Construct a [`JSON`](#sqlalchemy.types.JSON "sqlalchemy.types.JSON") type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**none_as_null=False** –'
  prefs: []
  type: TYPE_NORMAL
- en: 'if True, persist the value `None` as a SQL NULL value, not the JSON encoding
    of `null`. Note that when this flag is False, the [`null()`](sqlelement.html#sqlalchemy.sql.expression.null
    "sqlalchemy.sql.expression.null") construct can still be used to persist a NULL
    value, which may be passed directly as a parameter value that is specially interpreted
    by the [`JSON`](#sqlalchemy.types.JSON "sqlalchemy.types.JSON") type as SQL NULL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE399]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '[`JSON.none_as_null`](#sqlalchemy.types.JSON.params.none_as_null "sqlalchemy.types.JSON")
    does **not** apply to the values passed to [`Column.default`](metadata.html#sqlalchemy.schema.Column.params.default
    "sqlalchemy.schema.Column") and [`Column.server_default`](metadata.html#sqlalchemy.schema.Column.params.server_default
    "sqlalchemy.schema.Column"); a value of `None` passed for these parameters means
    “no default present”.'
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, when used in SQL comparison expressions, the Python value `None`
    continues to refer to SQL null, and not JSON NULL. The [`JSON.none_as_null`](#sqlalchemy.types.JSON.params.none_as_null
    "sqlalchemy.types.JSON") flag refers explicitly to the **persistence** of the
    value within an INSERT or UPDATE statement. The [`JSON.NULL`](#sqlalchemy.types.JSON.NULL
    "sqlalchemy.types.JSON.NULL") value should be used for SQL expressions that wish
    to compare to JSON null.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`JSON.NULL`](#sqlalchemy.types.JSON.NULL "sqlalchemy.types.JSON.NULL")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE400]'
  prefs: []
  type: TYPE_PRE
- en: Return a conversion function for processing bind values.
  prefs: []
  type: TYPE_NORMAL
- en: Returns a callable which will receive a bind parameter value as the sole positional
    argument and will return a value to send to the DB-API.
  prefs: []
  type: TYPE_NORMAL
- en: If processing is not necessary, the method should return `None`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This method is only called relative to a **dialect specific type object**, which
    is often **private to a dialect in use** and is not the same type object as the
    public facing one, which means it’s not feasible to subclass a [`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") class in order to provide an alternate [`TypeEngine.bind_processor()`](type_api.html#sqlalchemy.types.TypeEngine.bind_processor
    "sqlalchemy.types.TypeEngine.bind_processor") method, unless subclassing the [`UserDefinedType`](custom_types.html#sqlalchemy.types.UserDefinedType
    "sqlalchemy.types.UserDefinedType") class explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: To provide alternate behavior for [`TypeEngine.bind_processor()`](type_api.html#sqlalchemy.types.TypeEngine.bind_processor
    "sqlalchemy.types.TypeEngine.bind_processor"), implement a [`TypeDecorator`](custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") class and provide an implementation of [`TypeDecorator.process_bind_param()`](custom_types.html#sqlalchemy.types.TypeDecorator.process_bind_param
    "sqlalchemy.types.TypeDecorator.process_bind_param").
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Augmenting Existing Types](custom_types.html#types-typedecorator)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**dialect** – Dialect instance in use.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE401]'
  prefs: []
  type: TYPE_PRE
- en: alias of [`Comparator`](#sqlalchemy.types.JSON.Comparator "sqlalchemy.sql.sqltypes.JSON.Comparator")
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE402]'
  prefs: []
  type: TYPE_PRE
- en: Flag, if False, means values from this type aren’t hashable.
  prefs: []
  type: TYPE_NORMAL
- en: Used by the ORM when uniquing result lists.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE403]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE404]'
  prefs: []
  type: TYPE_PRE
- en: Return a conversion function for processing result row values.
  prefs: []
  type: TYPE_NORMAL
- en: Returns a callable which will receive a result row column value as the sole
    positional argument and will return a value to return to the user.
  prefs: []
  type: TYPE_NORMAL
- en: If processing is not necessary, the method should return `None`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This method is only called relative to a **dialect specific type object**, which
    is often **private to a dialect in use** and is not the same type object as the
    public facing one, which means it’s not feasible to subclass a [`TypeEngine`](type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") class in order to provide an alternate [`TypeEngine.result_processor()`](type_api.html#sqlalchemy.types.TypeEngine.result_processor
    "sqlalchemy.types.TypeEngine.result_processor") method, unless subclassing the
    [`UserDefinedType`](custom_types.html#sqlalchemy.types.UserDefinedType "sqlalchemy.types.UserDefinedType")
    class explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: To provide alternate behavior for [`TypeEngine.result_processor()`](type_api.html#sqlalchemy.types.TypeEngine.result_processor
    "sqlalchemy.types.TypeEngine.result_processor"), implement a [`TypeDecorator`](custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") class and provide an implementation of [`TypeDecorator.process_result_value()`](custom_types.html#sqlalchemy.types.TypeDecorator.process_result_value
    "sqlalchemy.types.TypeDecorator.process_result_value").
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Augmenting Existing Types](custom_types.html#types-typedecorator)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dialect` – Dialect instance in use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`coltype` – DBAPI coltype argument received in cursor.description.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE405]'
  prefs: []
  type: TYPE_PRE
- en: If True, the Python constant `None` is considered to be handled explicitly by
    this type.
  prefs: []
  type: TYPE_NORMAL
- en: The ORM uses this flag to indicate that a positive value of `None` is passed
    to the column in an INSERT statement, rather than omitting the column from the
    INSERT statement which has the effect of firing off column-level defaults. It
    also allows types which have special behavior for Python None, such as a JSON
    type, to indicate that they’d like to handle the None value explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: To set this flag on an existing type, use the [`TypeEngine.evaluates_none()`](type_api.html#sqlalchemy.types.TypeEngine.evaluates_none
    "sqlalchemy.types.TypeEngine.evaluates_none") method.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`TypeEngine.evaluates_none()`](type_api.html#sqlalchemy.types.TypeEngine.evaluates_none
    "sqlalchemy.types.TypeEngine.evaluates_none")'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE406]'
  prefs: []
  type: TYPE_PRE
- en: The SQL INT or INTEGER type.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Integer`](#sqlalchemy.types.Integer "sqlalchemy.types.Integer") - documentation
    for the base type.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.types.INTEGER`](#sqlalchemy.types.INTEGER "sqlalchemy.types.INTEGER")
    ([`sqlalchemy.types.Integer`](#sqlalchemy.types.Integer "sqlalchemy.types.Integer"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE407]'
  prefs: []
  type: TYPE_PRE
- en: The SQL NCHAR type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.types.NCHAR.__init__)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.types.NCHAR`](#sqlalchemy.types.NCHAR "sqlalchemy.types.NCHAR")
    ([`sqlalchemy.types.Unicode`](#sqlalchemy.types.Unicode "sqlalchemy.types.Unicode"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE408]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `sqlalchemy.types.String.__init__` *method of* [`String`](#sqlalchemy.types.String
    "sqlalchemy.types.String")'
  prefs: []
  type: TYPE_NORMAL
- en: Create a string-holding type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`length` – optional, a length for the column for use in DDL and CAST expressions.
    May be safely omitted if no `CREATE TABLE` will be issued. Certain databases may
    require a `length` for use in DDL, and will raise an exception when the `CREATE
    TABLE` DDL is issued if a `VARCHAR` with no length is included. Whether the value
    is interpreted as bytes or characters is database specific.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`collation` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Optional, a column-level collation for use in DDL and CAST expressions. Renders
    using the COLLATE keyword supported by SQLite, MySQL, and PostgreSQL. E.g.:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE409]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In most cases, the [`Unicode`](#sqlalchemy.types.Unicode "sqlalchemy.types.Unicode")
    or [`UnicodeText`](#sqlalchemy.types.UnicodeText "sqlalchemy.types.UnicodeText")
    datatypes should be used for a [`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") that expects to store non-ascii data. These datatypes
    will ensure that the correct types are used on the database.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE410]'
  prefs: []
  type: TYPE_PRE
- en: The SQL NVARCHAR type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.types.NVARCHAR.__init__)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.types.NVARCHAR`](#sqlalchemy.types.NVARCHAR "sqlalchemy.types.NVARCHAR")
    ([`sqlalchemy.types.Unicode`](#sqlalchemy.types.Unicode "sqlalchemy.types.Unicode"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE411]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `sqlalchemy.types.String.__init__` *method of* [`String`](#sqlalchemy.types.String
    "sqlalchemy.types.String")'
  prefs: []
  type: TYPE_NORMAL
- en: Create a string-holding type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`length` – optional, a length for the column for use in DDL and CAST expressions.
    May be safely omitted if no `CREATE TABLE` will be issued. Certain databases may
    require a `length` for use in DDL, and will raise an exception when the `CREATE
    TABLE` DDL is issued if a `VARCHAR` with no length is included. Whether the value
    is interpreted as bytes or characters is database specific.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`collation` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Optional, a column-level collation for use in DDL and CAST expressions. Renders
    using the COLLATE keyword supported by SQLite, MySQL, and PostgreSQL. E.g.:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE412]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In most cases, the [`Unicode`](#sqlalchemy.types.Unicode "sqlalchemy.types.Unicode")
    or [`UnicodeText`](#sqlalchemy.types.UnicodeText "sqlalchemy.types.UnicodeText")
    datatypes should be used for a [`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") that expects to store non-ascii data. These datatypes
    will ensure that the correct types are used on the database.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE413]'
  prefs: []
  type: TYPE_PRE
- en: The SQL NUMERIC type.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Numeric`](#sqlalchemy.types.Numeric "sqlalchemy.types.Numeric") - documentation
    for the base type.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.types.NUMERIC.__init__)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.types.NUMERIC`](#sqlalchemy.types.NUMERIC "sqlalchemy.types.NUMERIC")
    ([`sqlalchemy.types.Numeric`](#sqlalchemy.types.Numeric "sqlalchemy.types.Numeric"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE414]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `sqlalchemy.types.Numeric.__init__` *method of* [`Numeric`](#sqlalchemy.types.Numeric
    "sqlalchemy.types.Numeric")'
  prefs: []
  type: TYPE_NORMAL
- en: Construct a Numeric.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`precision` – the numeric precision for use in DDL `CREATE TABLE`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scale` – the numeric scale for use in DDL `CREATE TABLE`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`asdecimal` – default True. Return whether or not values should be sent as
    Python Decimal objects, or as floats. Different DBAPIs send one or the other based
    on datatypes - the Numeric type will ensure that return values are one or the
    other across DBAPIs consistently.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`decimal_return_scale` – Default scale to use when converting from floats to
    Python decimals. Floating point values will typically be much longer due to decimal
    inaccuracy, and most floating point database types don’t have a notion of “scale”,
    so by default the float type looks for the first ten decimal places when converting.
    Specifying this value will override that length. Types which do include an explicit
    “.scale” value, such as the base [`Numeric`](#sqlalchemy.types.Numeric "sqlalchemy.types.Numeric")
    as well as the MySQL float types, will use the value of “.scale” as the default
    for decimal_return_scale, if not otherwise specified.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When using the `Numeric` type, care should be taken to ensure that the asdecimal
    setting is appropriate for the DBAPI in use - when Numeric applies a conversion
    from Decimal->float or float-> Decimal, this conversion incurs an additional performance
    overhead for all result columns received.
  prefs: []
  type: TYPE_NORMAL
- en: DBAPIs that return Decimal natively (e.g. psycopg2) will have better accuracy
    and higher performance with a setting of `True`, as the native translation to
    Decimal reduces the amount of floating- point issues at play, and the Numeric
    type itself doesn’t need to apply any further conversions. However, another DBAPI
    which returns floats natively *will* incur an additional conversion overhead,
    and is still subject to floating point data loss - in which case `asdecimal=False`
    will at least remove the extra conversion overhead.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE415]'
  prefs: []
  type: TYPE_PRE
- en: The SQL REAL type.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Float`](#sqlalchemy.types.Float "sqlalchemy.types.Float") - documentation
    for the base type.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.types.REAL.__init__)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.types.REAL`](#sqlalchemy.types.REAL "sqlalchemy.types.REAL")
    ([`sqlalchemy.types.Float`](#sqlalchemy.types.Float "sqlalchemy.types.Float"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE416]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `sqlalchemy.types.Float.__init__` *method of* [`Float`](#sqlalchemy.types.Float
    "sqlalchemy.types.Float")'
  prefs: []
  type: TYPE_NORMAL
- en: Construct a Float.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`precision` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: the numeric precision for use in DDL `CREATE TABLE`. Backends **should** attempt
    to ensure this precision indicates a number of digits for the generic [`Float`](#sqlalchemy.types.Float
    "sqlalchemy.types.Float") datatype.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For the Oracle backend, the [`Float.precision`](#sqlalchemy.types.Float.params.precision
    "sqlalchemy.types.Float") parameter is not accepted when rendering DDL, as Oracle
    does not support float precision specified as a number of decimal places. Instead,
    use the Oracle-specific [`FLOAT`](../dialects/oracle.html#sqlalchemy.dialects.oracle.FLOAT
    "sqlalchemy.dialects.oracle.FLOAT") datatype and specify the [`FLOAT.binary_precision`](../dialects/oracle.html#sqlalchemy.dialects.oracle.FLOAT.params.binary_precision
    "sqlalchemy.dialects.oracle.FLOAT") parameter. This is new in version 2.0 of SQLAlchemy.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To create a database agnostic [`Float`](#sqlalchemy.types.Float "sqlalchemy.types.Float")
    that separately specifies binary precision for Oracle, use [`TypeEngine.with_variant()`](type_api.html#sqlalchemy.types.TypeEngine.with_variant
    "sqlalchemy.types.TypeEngine.with_variant") as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE417]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`asdecimal` – the same flag as that of [`Numeric`](#sqlalchemy.types.Numeric
    "sqlalchemy.types.Numeric"), but defaults to `False`. Note that setting this flag
    to `True` results in floating point conversion.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`decimal_return_scale` – Default scale to use when converting from floats to
    Python decimals. Floating point values will typically be much longer due to decimal
    inaccuracy, and most floating point database types don’t have a notion of “scale”,
    so by default the float type looks for the first ten decimal places when converting.
    Specifying this value will override that length. Note that the MySQL float types,
    which do include “scale”, will use “scale” as the default for decimal_return_scale,
    if not otherwise specified.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE418]'
  prefs: []
  type: TYPE_PRE
- en: The SQL SMALLINT type.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`SmallInteger`](#sqlalchemy.types.SmallInteger "sqlalchemy.types.SmallInteger")
    - documentation for the base type.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.types.SMALLINT`](#sqlalchemy.types.SMALLINT "sqlalchemy.types.SMALLINT")
    ([`sqlalchemy.types.SmallInteger`](#sqlalchemy.types.SmallInteger "sqlalchemy.types.SmallInteger"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE419]'
  prefs: []
  type: TYPE_PRE
- en: The SQL TEXT type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.types.TEXT.__init__)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.types.TEXT`](#sqlalchemy.types.TEXT "sqlalchemy.types.TEXT")
    ([`sqlalchemy.types.Text`](#sqlalchemy.types.Text "sqlalchemy.types.Text"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE420]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `sqlalchemy.types.String.__init__` *method of* [`String`](#sqlalchemy.types.String
    "sqlalchemy.types.String")'
  prefs: []
  type: TYPE_NORMAL
- en: Create a string-holding type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`length` – optional, a length for the column for use in DDL and CAST expressions.
    May be safely omitted if no `CREATE TABLE` will be issued. Certain databases may
    require a `length` for use in DDL, and will raise an exception when the `CREATE
    TABLE` DDL is issued if a `VARCHAR` with no length is included. Whether the value
    is interpreted as bytes or characters is database specific.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`collation` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Optional, a column-level collation for use in DDL and CAST expressions. Renders
    using the COLLATE keyword supported by SQLite, MySQL, and PostgreSQL. E.g.:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE421]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In most cases, the [`Unicode`](#sqlalchemy.types.Unicode "sqlalchemy.types.Unicode")
    or [`UnicodeText`](#sqlalchemy.types.UnicodeText "sqlalchemy.types.UnicodeText")
    datatypes should be used for a [`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") that expects to store non-ascii data. These datatypes
    will ensure that the correct types are used on the database.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE422]'
  prefs: []
  type: TYPE_PRE
- en: The SQL TIME type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.types.TIME`](#sqlalchemy.types.TIME "sqlalchemy.types.TIME")
    ([`sqlalchemy.types.Time`](#sqlalchemy.types.Time "sqlalchemy.types.Time"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE423]'
  prefs: []
  type: TYPE_PRE
- en: The SQL TIMESTAMP type.
  prefs: []
  type: TYPE_NORMAL
- en: '[`TIMESTAMP`](#sqlalchemy.types.TIMESTAMP "sqlalchemy.types.TIMESTAMP") datatypes
    have support for timezone storage on some backends, such as PostgreSQL and Oracle.
    Use the `TIMESTAMP.timezone` argument in order to enable “TIMESTAMP WITH TIMEZONE”
    for these backends.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.types.TIMESTAMP.__init__), [get_dbapi_type()](#sqlalchemy.types.TIMESTAMP.get_dbapi_type)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.types.TIMESTAMP`](#sqlalchemy.types.TIMESTAMP "sqlalchemy.types.TIMESTAMP")
    ([`sqlalchemy.types.DateTime`](#sqlalchemy.types.DateTime "sqlalchemy.types.DateTime"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE424]'
  prefs: []
  type: TYPE_PRE
- en: Construct a new [`TIMESTAMP`](#sqlalchemy.types.TIMESTAMP "sqlalchemy.types.TIMESTAMP").
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**timezone** – boolean. Indicates that the TIMESTAMP type should enable timezone
    support, if available on the target database. On a per-dialect basis is similar
    to “TIMESTAMP WITH TIMEZONE”. If the target database does not support timezones,
    this flag is ignored.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE425]'
  prefs: []
  type: TYPE_PRE
- en: Return the corresponding type object from the underlying DB-API, if any.
  prefs: []
  type: TYPE_NORMAL
- en: This can be useful for calling `setinputsizes()`, for example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE426]'
  prefs: []
  type: TYPE_PRE
- en: Represent the SQL UUID type.
  prefs: []
  type: TYPE_NORMAL
- en: This is the SQL-native form of the [`Uuid`](#sqlalchemy.types.Uuid "sqlalchemy.types.Uuid")
    database agnostic datatype, and is backwards compatible with the previous PostgreSQL-only
    version of `UUID`.
  prefs: []
  type: TYPE_NORMAL
- en: The [`UUID`](#sqlalchemy.types.UUID "sqlalchemy.types.UUID") datatype only works
    on databases that have a SQL datatype named `UUID`. It will not function for backends
    which don’t have this exact-named type, including SQL Server. For backend-agnostic
    UUID values with native support, including for SQL Server’s `UNIQUEIDENTIFIER`
    datatype, use the [`Uuid`](#sqlalchemy.types.Uuid "sqlalchemy.types.Uuid") datatype.
  prefs: []
  type: TYPE_NORMAL
- en: New in version 2.0.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[`Uuid`](#sqlalchemy.types.Uuid "sqlalchemy.types.Uuid")'
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.types.UUID.__init__)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.types.UUID`](#sqlalchemy.types.UUID "sqlalchemy.types.UUID")
    ([`sqlalchemy.types.Uuid`](#sqlalchemy.types.Uuid "sqlalchemy.types.Uuid"), `sqlalchemy.types.NativeForEmulated`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE427]'
  prefs: []
  type: TYPE_PRE
- en: Construct a [`UUID`](#sqlalchemy.types.UUID "sqlalchemy.types.UUID") type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**as_uuid=True** –'
  prefs: []
  type: TYPE_NORMAL
- en: if True, values will be interpreted as Python uuid objects, converting to/from
    string via the DBAPI.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE428]'
  prefs: []
  type: TYPE_PRE
- en: The SQL VARBINARY type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.types.VARBINARY`](#sqlalchemy.types.VARBINARY "sqlalchemy.types.VARBINARY")
    (`sqlalchemy.types._Binary`)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE429]'
  prefs: []
  type: TYPE_PRE
- en: The SQL VARCHAR type.
  prefs: []
  type: TYPE_NORMAL
- en: '**Members**'
  prefs: []
  type: TYPE_NORMAL
- en: '[__init__()](#sqlalchemy.types.VARCHAR.__init__)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Class signature**'
  prefs: []
  type: TYPE_NORMAL
- en: class [`sqlalchemy.types.VARCHAR`](#sqlalchemy.types.VARCHAR "sqlalchemy.types.VARCHAR")
    ([`sqlalchemy.types.String`](#sqlalchemy.types.String "sqlalchemy.types.String"))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE430]'
  prefs: []
  type: TYPE_PRE
- en: '*inherited from the* `sqlalchemy.types.String.__init__` *method of* [`String`](#sqlalchemy.types.String
    "sqlalchemy.types.String")'
  prefs: []
  type: TYPE_NORMAL
- en: Create a string-holding type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '`length` – optional, a length for the column for use in DDL and CAST expressions.
    May be safely omitted if no `CREATE TABLE` will be issued. Certain databases may
    require a `length` for use in DDL, and will raise an exception when the `CREATE
    TABLE` DDL is issued if a `VARCHAR` with no length is included. Whether the value
    is interpreted as bytes or characters is database specific.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`collation` –'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Optional, a column-level collation for use in DDL and CAST expressions. Renders
    using the COLLATE keyword supported by SQLite, MySQL, and PostgreSQL. E.g.:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE431]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In most cases, the [`Unicode`](#sqlalchemy.types.Unicode "sqlalchemy.types.Unicode")
    or [`UnicodeText`](#sqlalchemy.types.UnicodeText "sqlalchemy.types.UnicodeText")
    datatypes should be used for a [`Column`](metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") that expects to store non-ascii data. These datatypes
    will ensure that the correct types are used on the database.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
