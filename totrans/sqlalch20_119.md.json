["```py\nsqlalchemy.ext.SAWarning: MyType will not produce a cache key because the\n``cache_ok`` attribute is not set to True. This can have significant\nperformance implications including some performance degradations in\ncomparison to prior SQLAlchemy versions. Set this attribute to True if this\ntype object's state is safe to use in a cache key, or False to disable this\nwarning.\n```", "```py\nsqlalchemy.exc.SAWarning: Class MyClass will not make use of SQL\ncompilation caching as it does not set the 'inherit_cache' attribute to\n``True``. This can have significant performance implications including some\nperformance degradations in comparison to prior SQLAlchemy versions. Set\nthis attribute to True if this object can make use of the cache key\ngenerated by the superclass. Alternatively, this attribute may be set to\nFalse which will disable this warning.\n```", "```py\nsqlalchemy.exc.SAWarning: Dialect database:driver will not make use of SQL\ncompilation caching as it does not set the 'supports_statement_cache'\nattribute to ``True``. This can have significant performance implications\nincluding some performance degradations in comparison to prior SQLAlchemy\nversions. Dialect maintainers should seek to set this attribute to True\nafter appropriate development and testing for SQLAlchemy 1.4 caching\nsupport. Alternatively, this attribute may be set to False which will\ndisable this warning.\n```", "```py\n    class MyCustomType(TypeDecorator):\n        cache_ok = True\n        impl = String\n    ```", "```py\n17:37:48,325 INFO  [sqlalchemy.engine.base.Engine.0x...048c] SELECT ...\n17:37:48,326 INFO  [sqlalchemy.engine.base.Engine.0x...048c] {<params>}\n17:37:48,660 DEBUG [myapp.somemessage]\n```", "```py\nfrom sqlalchemy import event\nfrom sqlalchemy.engine import Engine\nimport time\nimport logging\n\nlogging.basicConfig()\nlogger = logging.getLogger(\"myapp.sqltime\")\nlogger.setLevel(logging.DEBUG)\n\n@event.listens_for(Engine, \"before_cursor_execute\")\ndef before_cursor_execute(conn, cursor, statement, parameters, context, executemany):\n    conn.info.setdefault(\"query_start_time\", []).append(time.time())\n    logger.debug(\"Start Query: %s\", statement)\n\n@event.listens_for(Engine, \"after_cursor_execute\")\ndef after_cursor_execute(conn, cursor, statement, parameters, context, executemany):\n    total = time.time() - conn.info[\"query_start_time\"].pop(-1)\n    logger.debug(\"Query Complete!\")\n    logger.debug(\"Total Time: %f\", total)\n```", "```py\nimport cProfile\nimport io\nimport pstats\nimport contextlib\n\n@contextlib.contextmanager\ndef profiled():\n    pr = cProfile.Profile()\n    pr.enable()\n    yield\n    pr.disable()\n    s = io.StringIO()\n    ps = pstats.Stats(pr, stream=s).sort_stats(\"cumulative\")\n    ps.print_stats()\n    # uncomment this to see who's calling what\n    # ps.print_callers()\n    print(s.getvalue())\n```", "```py\nwith profiled():\n    session.scalars(select(FooClass).where(FooClass.somevalue == 8)).all()\n```", "```py\n13726 function calls (13042 primitive calls) in 0.014 seconds\n\nOrdered by: cumulative time\n\nncalls  tottime  percall  cumtime  percall filename:lineno(function)\n222/21    0.001    0.000    0.011    0.001 lib/sqlalchemy/orm/loading.py:26(instances)\n220/20    0.002    0.000    0.010    0.001 lib/sqlalchemy/orm/loading.py:327(_instance)\n220/20    0.000    0.000    0.010    0.000 lib/sqlalchemy/orm/loading.py:284(populate_state)\n   20    0.000    0.000    0.010    0.000 lib/sqlalchemy/orm/strategies.py:987(load_collection_from_subq)\n   20    0.000    0.000    0.009    0.000 lib/sqlalchemy/orm/strategies.py:935(get)\n    1    0.000    0.000    0.009    0.009 lib/sqlalchemy/orm/strategies.py:940(_load)\n   21    0.000    0.000    0.008    0.000 lib/sqlalchemy/orm/strategies.py:942(<genexpr>)\n    2    0.000    0.000    0.004    0.002 lib/sqlalchemy/orm/query.py:2400(__iter__)\n    2    0.000    0.000    0.002    0.001 lib/sqlalchemy/orm/query.py:2414(_execute_and_instances)\n    2    0.000    0.000    0.002    0.001 lib/sqlalchemy/engine/base.py:659(execute)\n    2    0.000    0.000    0.002    0.001 lib/sqlalchemy/sql/elements.py:321(_execute_on_connection)\n    2    0.000    0.000    0.002    0.001 lib/sqlalchemy/engine/base.py:788(_execute_clauseelement)\n\n...\n```", "```py\n2    0.102    0.102    0.204    0.102 {method 'execute' of 'sqlite3.Cursor' objects}\n```", "```py\n2    0.300    0.600    0.300    0.600 {method 'fetchall' of 'sqlite3.Cursor' objects}\n```", "```py\n# the DBAPI cursor is fast...\n2    0.020    0.040    0.020    0.040 {method 'fetchall' of 'sqlite3.Cursor' objects}\n\n...\n\n# but SQLAlchemy's result proxy is slow, this is type-level processing\n2    0.100    0.200    0.100    0.200 lib/sqlalchemy/engine/result.py:778(fetchall)\n```", "```py\nfrom sqlalchemy import TypeDecorator\nimport time\n\nclass Foo(TypeDecorator):\n    impl = String\n\n    def process_result_value(self, value, thing):\n        # intentionally add slowness for illustration purposes\n        time.sleep(0.001)\n        return value\n```", "```py\n200    0.001    0.000    0.237    0.001 lib/sqlalchemy/sql/type_api.py:911(process)\n200    0.001    0.000    0.236    0.001 test.py:28(process_result_value)\n200    0.235    0.001    0.235    0.001 {time.sleep}\n```", "```py\n# the ORM calls _instance for each ORM-loaded row it sees, and\n# populate_state for each ORM-loaded row that results in the population\n# of an object's attributes\n220/20    0.001    0.000    0.010    0.000 lib/sqlalchemy/orm/loading.py:327(_instance)\n220/20    0.000    0.000    0.009    0.000 lib/sqlalchemy/orm/loading.py:284(populate_state)\n```", "```py\n    select(User.id, User.name)\n    ```", "```py\n    select(User)\n    ```", "```py\n    u_b = Bundle(\"user\", User.id, User.name)\n    a_b = Bundle(\"address\", Address.id, Address.email)\n\n    for user, address in session.execute(select(u_b, a_b).join(User.addresses)):\n        ...\n    ```", "```py\nsqlalchemy.ext.SAWarning: MyType will not produce a cache key because the\n``cache_ok`` attribute is not set to True. This can have significant\nperformance implications including some performance degradations in\ncomparison to prior SQLAlchemy versions. Set this attribute to True if this\ntype object's state is safe to use in a cache key, or False to disable this\nwarning.\n```", "```py\nsqlalchemy.exc.SAWarning: Class MyClass will not make use of SQL\ncompilation caching as it does not set the 'inherit_cache' attribute to\n``True``. This can have significant performance implications including some\nperformance degradations in comparison to prior SQLAlchemy versions. Set\nthis attribute to True if this object can make use of the cache key\ngenerated by the superclass. Alternatively, this attribute may be set to\nFalse which will disable this warning.\n```", "```py\nsqlalchemy.exc.SAWarning: Dialect database:driver will not make use of SQL\ncompilation caching as it does not set the 'supports_statement_cache'\nattribute to ``True``. This can have significant performance implications\nincluding some performance degradations in comparison to prior SQLAlchemy\nversions. Dialect maintainers should seek to set this attribute to True\nafter appropriate development and testing for SQLAlchemy 1.4 caching\nsupport. Alternatively, this attribute may be set to False which will\ndisable this warning.\n```", "```py\n    class MyCustomType(TypeDecorator):\n        cache_ok = True\n        impl = String\n    ```", "```py\nsqlalchemy.ext.SAWarning: MyType will not produce a cache key because the\n``cache_ok`` attribute is not set to True. This can have significant\nperformance implications including some performance degradations in\ncomparison to prior SQLAlchemy versions. Set this attribute to True if this\ntype object's state is safe to use in a cache key, or False to disable this\nwarning.\n```", "```py\nsqlalchemy.exc.SAWarning: Class MyClass will not make use of SQL\ncompilation caching as it does not set the 'inherit_cache' attribute to\n``True``. This can have significant performance implications including some\nperformance degradations in comparison to prior SQLAlchemy versions. Set\nthis attribute to True if this object can make use of the cache key\ngenerated by the superclass. Alternatively, this attribute may be set to\nFalse which will disable this warning.\n```", "```py\nsqlalchemy.exc.SAWarning: Dialect database:driver will not make use of SQL\ncompilation caching as it does not set the 'supports_statement_cache'\nattribute to ``True``. This can have significant performance implications\nincluding some performance degradations in comparison to prior SQLAlchemy\nversions. Dialect maintainers should seek to set this attribute to True\nafter appropriate development and testing for SQLAlchemy 1.4 caching\nsupport. Alternatively, this attribute may be set to False which will\ndisable this warning.\n```", "```py\n    class MyCustomType(TypeDecorator):\n        cache_ok = True\n        impl = String\n    ```", "```py\n17:37:48,325 INFO  [sqlalchemy.engine.base.Engine.0x...048c] SELECT ...\n17:37:48,326 INFO  [sqlalchemy.engine.base.Engine.0x...048c] {<params>}\n17:37:48,660 DEBUG [myapp.somemessage]\n```", "```py\nfrom sqlalchemy import event\nfrom sqlalchemy.engine import Engine\nimport time\nimport logging\n\nlogging.basicConfig()\nlogger = logging.getLogger(\"myapp.sqltime\")\nlogger.setLevel(logging.DEBUG)\n\n@event.listens_for(Engine, \"before_cursor_execute\")\ndef before_cursor_execute(conn, cursor, statement, parameters, context, executemany):\n    conn.info.setdefault(\"query_start_time\", []).append(time.time())\n    logger.debug(\"Start Query: %s\", statement)\n\n@event.listens_for(Engine, \"after_cursor_execute\")\ndef after_cursor_execute(conn, cursor, statement, parameters, context, executemany):\n    total = time.time() - conn.info[\"query_start_time\"].pop(-1)\n    logger.debug(\"Query Complete!\")\n    logger.debug(\"Total Time: %f\", total)\n```", "```py\nimport cProfile\nimport io\nimport pstats\nimport contextlib\n\n@contextlib.contextmanager\ndef profiled():\n    pr = cProfile.Profile()\n    pr.enable()\n    yield\n    pr.disable()\n    s = io.StringIO()\n    ps = pstats.Stats(pr, stream=s).sort_stats(\"cumulative\")\n    ps.print_stats()\n    # uncomment this to see who's calling what\n    # ps.print_callers()\n    print(s.getvalue())\n```", "```py\nwith profiled():\n    session.scalars(select(FooClass).where(FooClass.somevalue == 8)).all()\n```", "```py\n13726 function calls (13042 primitive calls) in 0.014 seconds\n\nOrdered by: cumulative time\n\nncalls  tottime  percall  cumtime  percall filename:lineno(function)\n222/21    0.001    0.000    0.011    0.001 lib/sqlalchemy/orm/loading.py:26(instances)\n220/20    0.002    0.000    0.010    0.001 lib/sqlalchemy/orm/loading.py:327(_instance)\n220/20    0.000    0.000    0.010    0.000 lib/sqlalchemy/orm/loading.py:284(populate_state)\n   20    0.000    0.000    0.010    0.000 lib/sqlalchemy/orm/strategies.py:987(load_collection_from_subq)\n   20    0.000    0.000    0.009    0.000 lib/sqlalchemy/orm/strategies.py:935(get)\n    1    0.000    0.000    0.009    0.009 lib/sqlalchemy/orm/strategies.py:940(_load)\n   21    0.000    0.000    0.008    0.000 lib/sqlalchemy/orm/strategies.py:942(<genexpr>)\n    2    0.000    0.000    0.004    0.002 lib/sqlalchemy/orm/query.py:2400(__iter__)\n    2    0.000    0.000    0.002    0.001 lib/sqlalchemy/orm/query.py:2414(_execute_and_instances)\n    2    0.000    0.000    0.002    0.001 lib/sqlalchemy/engine/base.py:659(execute)\n    2    0.000    0.000    0.002    0.001 lib/sqlalchemy/sql/elements.py:321(_execute_on_connection)\n    2    0.000    0.000    0.002    0.001 lib/sqlalchemy/engine/base.py:788(_execute_clauseelement)\n\n...\n```", "```py\n2    0.102    0.102    0.204    0.102 {method 'execute' of 'sqlite3.Cursor' objects}\n```", "```py\n2    0.300    0.600    0.300    0.600 {method 'fetchall' of 'sqlite3.Cursor' objects}\n```", "```py\n# the DBAPI cursor is fast...\n2    0.020    0.040    0.020    0.040 {method 'fetchall' of 'sqlite3.Cursor' objects}\n\n...\n\n# but SQLAlchemy's result proxy is slow, this is type-level processing\n2    0.100    0.200    0.100    0.200 lib/sqlalchemy/engine/result.py:778(fetchall)\n```", "```py\nfrom sqlalchemy import TypeDecorator\nimport time\n\nclass Foo(TypeDecorator):\n    impl = String\n\n    def process_result_value(self, value, thing):\n        # intentionally add slowness for illustration purposes\n        time.sleep(0.001)\n        return value\n```", "```py\n200    0.001    0.000    0.237    0.001 lib/sqlalchemy/sql/type_api.py:911(process)\n200    0.001    0.000    0.236    0.001 test.py:28(process_result_value)\n200    0.235    0.001    0.235    0.001 {time.sleep}\n```", "```py\n# the ORM calls _instance for each ORM-loaded row it sees, and\n# populate_state for each ORM-loaded row that results in the population\n# of an object's attributes\n220/20    0.001    0.000    0.010    0.000 lib/sqlalchemy/orm/loading.py:327(_instance)\n220/20    0.000    0.000    0.009    0.000 lib/sqlalchemy/orm/loading.py:284(populate_state)\n```", "```py\n    select(User.id, User.name)\n    ```", "```py\n    select(User)\n    ```", "```py\n    u_b = Bundle(\"user\", User.id, User.name)\n    a_b = Bundle(\"address\", Address.id, Address.email)\n\n    for user, address in session.execute(select(u_b, a_b).join(User.addresses)):\n        ...\n    ```", "```py\n17:37:48,325 INFO  [sqlalchemy.engine.base.Engine.0x...048c] SELECT ...\n17:37:48,326 INFO  [sqlalchemy.engine.base.Engine.0x...048c] {<params>}\n17:37:48,660 DEBUG [myapp.somemessage]\n```", "```py\nfrom sqlalchemy import event\nfrom sqlalchemy.engine import Engine\nimport time\nimport logging\n\nlogging.basicConfig()\nlogger = logging.getLogger(\"myapp.sqltime\")\nlogger.setLevel(logging.DEBUG)\n\n@event.listens_for(Engine, \"before_cursor_execute\")\ndef before_cursor_execute(conn, cursor, statement, parameters, context, executemany):\n    conn.info.setdefault(\"query_start_time\", []).append(time.time())\n    logger.debug(\"Start Query: %s\", statement)\n\n@event.listens_for(Engine, \"after_cursor_execute\")\ndef after_cursor_execute(conn, cursor, statement, parameters, context, executemany):\n    total = time.time() - conn.info[\"query_start_time\"].pop(-1)\n    logger.debug(\"Query Complete!\")\n    logger.debug(\"Total Time: %f\", total)\n```", "```py\nimport cProfile\nimport io\nimport pstats\nimport contextlib\n\n@contextlib.contextmanager\ndef profiled():\n    pr = cProfile.Profile()\n    pr.enable()\n    yield\n    pr.disable()\n    s = io.StringIO()\n    ps = pstats.Stats(pr, stream=s).sort_stats(\"cumulative\")\n    ps.print_stats()\n    # uncomment this to see who's calling what\n    # ps.print_callers()\n    print(s.getvalue())\n```", "```py\nwith profiled():\n    session.scalars(select(FooClass).where(FooClass.somevalue == 8)).all()\n```", "```py\n13726 function calls (13042 primitive calls) in 0.014 seconds\n\nOrdered by: cumulative time\n\nncalls  tottime  percall  cumtime  percall filename:lineno(function)\n222/21    0.001    0.000    0.011    0.001 lib/sqlalchemy/orm/loading.py:26(instances)\n220/20    0.002    0.000    0.010    0.001 lib/sqlalchemy/orm/loading.py:327(_instance)\n220/20    0.000    0.000    0.010    0.000 lib/sqlalchemy/orm/loading.py:284(populate_state)\n   20    0.000    0.000    0.010    0.000 lib/sqlalchemy/orm/strategies.py:987(load_collection_from_subq)\n   20    0.000    0.000    0.009    0.000 lib/sqlalchemy/orm/strategies.py:935(get)\n    1    0.000    0.000    0.009    0.009 lib/sqlalchemy/orm/strategies.py:940(_load)\n   21    0.000    0.000    0.008    0.000 lib/sqlalchemy/orm/strategies.py:942(<genexpr>)\n    2    0.000    0.000    0.004    0.002 lib/sqlalchemy/orm/query.py:2400(__iter__)\n    2    0.000    0.000    0.002    0.001 lib/sqlalchemy/orm/query.py:2414(_execute_and_instances)\n    2    0.000    0.000    0.002    0.001 lib/sqlalchemy/engine/base.py:659(execute)\n    2    0.000    0.000    0.002    0.001 lib/sqlalchemy/sql/elements.py:321(_execute_on_connection)\n    2    0.000    0.000    0.002    0.001 lib/sqlalchemy/engine/base.py:788(_execute_clauseelement)\n\n...\n```", "```py\n2    0.102    0.102    0.204    0.102 {method 'execute' of 'sqlite3.Cursor' objects}\n```", "```py\n2    0.300    0.600    0.300    0.600 {method 'fetchall' of 'sqlite3.Cursor' objects}\n```", "```py\n# the DBAPI cursor is fast...\n2    0.020    0.040    0.020    0.040 {method 'fetchall' of 'sqlite3.Cursor' objects}\n\n...\n\n# but SQLAlchemy's result proxy is slow, this is type-level processing\n2    0.100    0.200    0.100    0.200 lib/sqlalchemy/engine/result.py:778(fetchall)\n```", "```py\nfrom sqlalchemy import TypeDecorator\nimport time\n\nclass Foo(TypeDecorator):\n    impl = String\n\n    def process_result_value(self, value, thing):\n        # intentionally add slowness for illustration purposes\n        time.sleep(0.001)\n        return value\n```", "```py\n200    0.001    0.000    0.237    0.001 lib/sqlalchemy/sql/type_api.py:911(process)\n200    0.001    0.000    0.236    0.001 test.py:28(process_result_value)\n200    0.235    0.001    0.235    0.001 {time.sleep}\n```", "```py\n# the ORM calls _instance for each ORM-loaded row it sees, and\n# populate_state for each ORM-loaded row that results in the population\n# of an object's attributes\n220/20    0.001    0.000    0.010    0.000 lib/sqlalchemy/orm/loading.py:327(_instance)\n220/20    0.000    0.000    0.009    0.000 lib/sqlalchemy/orm/loading.py:284(populate_state)\n```", "```py\n    select(User.id, User.name)\n    ```", "```py\n    select(User)\n    ```", "```py\n    u_b = Bundle(\"user\", User.id, User.name)\n    a_b = Bundle(\"address\", Address.id, Address.email)\n\n    for user, address in session.execute(select(u_b, a_b).join(User.addresses)):\n        ...\n    ```"]