- en: Working with ORM Related Objects
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理 ORM 相关对象
- en: 原文：[https://docs.sqlalchemy.org/en/20/tutorial/orm_related_objects.html](https://docs.sqlalchemy.org/en/20/tutorial/orm_related_objects.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://docs.sqlalchemy.org/en/20/tutorial/orm_related_objects.html](https://docs.sqlalchemy.org/en/20/tutorial/orm_related_objects.html)
- en: In this section, we will cover one more essential ORM concept, which is how
    the ORM interacts with mapped classes that refer to other objects. In the section
    [Declaring Mapped Classes](metadata.html#tutorial-declaring-mapped-classes), the
    mapped class examples made use of a construct called [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship"). This construct defines a linkage between two different
    mapped classes, or from a mapped class to itself, the latter of which is called
    a **self-referential** relationship.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将涵盖另一个重要的 ORM 概念，即 ORM 如何与引用其他对象的映射类交互。在 [声明映射类](metadata.html#tutorial-declaring-mapped-classes)
    部分，映射类示例使用了一种称为 [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") 的构造。此构造定义了两个不同映射类之间的链接，或者从一个映射类到它自身，后者称为**自引用**关系。
- en: 'To describe the basic idea of [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship"), first we’ll review the mapping in short form,
    omitting the [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") mappings and other directives:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 要描述 [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") 的基本思想，首先我们将以简短形式回顾映射，省略 [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") 映射和其他指令。
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Above, the `User` class now has an attribute `User.addresses` and the `Address`
    class has an attribute `Address.user`. The [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") construct, in conjunction with the [`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") construct to indicate typing behavior, will be used to
    inspect the table relationships between the [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects that are mapped to the `User` and `Address`
    classes. As the [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    object representing the `address` table has a [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") which refers to the `user_account` table,
    the [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") can determine unambiguously that there is a [one
    to many](../glossary.html#term-one-to-many) relationship from the `User` class
    to the `Address` class, along the `User.addresses` relationship; one particular
    row in the `user_account` table may be referenced by many rows in the `address`
    table.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 如上，`User` 类现在有一个属性 `User.addresses`，而 `Address` 类有一个属性 `Address.user`。 [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") 构造与 [`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") 构造一起指示类型行为，将用于检查与 `User` 和 `Address` 类映射到的 [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") 对象之间的表关系。由于代表 `address` 表的 [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") 对象具有指向 `user_account` 表的 [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint")，[`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") 可以明确确定从 `User` 类到 `Address` 类的 [一对多](../glossary.html#term-one-to-many)
    关系，沿着 `User.addresses` 关系；`user_account` 表中的一个特定行可能被 `address` 表中的多行引用。
- en: All one-to-many relationships naturally correspond to a [many to one](../glossary.html#term-many-to-one)
    relationship in the other direction, in this case the one noted by `Address.user`.
    The [`relationship.back_populates`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.back_populates
    "sqlalchemy.orm.relationship") parameter, seen above configured on both [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") objects referring to the other name, establishes
    that each of these two [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") constructs should be considered to be complimentary
    to each other; we will see how this plays out in the next section.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 所有一对多关系自然对应于另一个方向的[多对一](../glossary.html#term-many-to-one)关系，在本例中由`Address.user`指出。如上所示在两个[`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")对象上配置的[`relationship.back_populates`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.back_populates
    "sqlalchemy.orm.relationship")参数，建立了这两个[`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")构造应被视为彼此补充；我们将在下一节中看到这是如何运作的。
- en: Persisting and Loading Relationships
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 持久化和加载关系
- en: 'We can start by illustrating what [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") does to instances of objects. If we make a new
    `User` object, we can note that there is a Python list when we access the `.addresses`
    element:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以首先说明[`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")对对象实例做了什么。如果我们创建一个新的`User`对象，我们可以注意到当我们访问`.addresses`元素时有一个Python列表：
- en: '[PRE1]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This object is a SQLAlchemy-specific version of Python `list` which has the
    ability to track and respond to changes made to it. The collection also appeared
    automatically when we accessed the attribute, even though we never assigned it
    to the object. This is similar to the behavior noted at [Inserting Rows using
    the ORM Unit of Work pattern](orm_data_manipulation.html#tutorial-inserting-orm)
    where it was observed that column-based attributes to which we don’t explicitly
    assign a value also display as `None` automatically, rather than raising an `AttributeError`
    as would be Python’s usual behavior.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 此对象是Python `list`的SQLAlchemy特定版本，具有跟踪和响应对其进行的更改的能力。即使我们从未将其分配给对象，当我们访问属性时，集合也会自动出现。这类似于在[使用ORM工作单元模式插入行](orm_data_manipulation.html#tutorial-inserting-orm)中观察到的行为，在那里我们观察到，我们没有明确为其分配值的基于列的属性也会自动显示为`None`，而不是像Python通常行为一样引发`AttributeError`。
- en: As the `u1` object is still [transient](../glossary.html#term-transient) and
    the `list` that we got from `u1.addresses` has not been mutated (i.e. appended
    or extended), it’s not actually associated with the object yet, but as we make
    changes to it, it will become part of the state of the `User` object.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`u1`对象仍然是[瞬态](../glossary.html#term-transient)，我们从`u1.addresses`获取的`list`尚未发生变异（即未被追加或扩展），因此它实际上还没有与对象关联，但随着我们对其进行更改，它将成为`User`对象状态的一部分。
- en: 'The collection is specific to the `Address` class which is the only type of
    Python object that may be persisted within it. Using the `list.append()` method
    we may add an `Address` object:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 该集合专用于`Address`类，这是唯一可以在其中持久化的Python对象类型。我们可以使用`list.append()`方法添加一个`Address`对象：
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'At this point, the `u1.addresses` collection as expected contains the new `Address`
    object:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，`u1.addresses`集合如预期中包含新的`Address`对象：
- en: '[PRE3]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As we associated the `Address` object with the `User.addresses` collection
    of the `u1` instance, another behavior also occurred, which is that the `User.addresses`
    relationship synchronized itself with the `Address.user` relationship, such that
    we can navigate not only from the `User` object to the `Address` object, we can
    also navigate from the `Address` object back to the “parent” `User` object:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将`Address`对象与`u1`实例的`User.addresses`集合关联时，还发生了另一个行为，即`User.addresses`关系将自动与`Address.user`关系同步，这样我们不仅可以从`User`对象导航到`Address`对象，还可以从`Address`对象导航回“父”`User`对象：
- en: '[PRE4]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This synchronization occurred as a result of our use of the [`relationship.back_populates`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.back_populates
    "sqlalchemy.orm.relationship") parameter between the two [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") objects. This parameter names another [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") for which complementary attribute assignment /
    list mutation should occur. It will work equally well in the other direction,
    which is that if we create another `Address` object and assign to its `Address.user`
    attribute, that `Address` becomes part of the `User.addresses` collection on that
    `User` object:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 此同步是由我们在两个 [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") 对象之间使用的 [`relationship.back_populates`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.back_populates
    "sqlalchemy.orm.relationship") 参数导致的。此参数命名了另一个应该发生补充属性赋值/列表变异的 [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") 。在另一个方向上同样有效，即如果我们创建另一个 `Address` 对象并将其分配给其 `Address.user`
    属性，那么该 `Address` 将成为该 `User` 对象上的 `User.addresses` 集合的一部分：
- en: '[PRE5]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We actually made use of the `user` parameter as a keyword argument in the `Address`
    constructor, which is accepted just like any other mapped attribute that was declared
    on the `Address` class. It is equivalent to assignment of the `Address.user` attribute
    after the fact:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上在 `Address` 构造函数中使用了 `user` 参数作为关键字参数，它像在 `Address` 类上声明的任何其他映射属性一样被接受。这相当于在事后分配了
    `Address.user` 属性：
- en: '[PRE6]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '### Cascading Objects into the Session'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '### 将对象级联到会话中'
- en: We now have a `User` and two `Address` objects that are associated in a bidirectional
    structure in memory, but as noted previously in [Inserting Rows using the ORM
    Unit of Work pattern](orm_data_manipulation.html#tutorial-inserting-orm) , these
    objects are said to be in the [transient](../glossary.html#term-transient) state
    until they are associated with a [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") object.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个 `User` 和两个 `Address` 对象，它们在内存中以双向结构关联，但正如之前在 [使用 ORM 单元工作模式插入行](orm_data_manipulation.html#tutorial-inserting-orm)
    中所指出的，这些对象被认为处于 [瞬时态](../glossary.html#term-transient) ，直到它们与一个 [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 对象关联。
- en: 'We make use of the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") that’s still ongoing, and note that when we apply the
    [`Session.add()`](../orm/session_api.html#sqlalchemy.orm.Session.add "sqlalchemy.orm.Session.add")
    method to the lead `User` object, the related `Address` object also gets added
    to that same [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session"):'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续使用正在进行中的 [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    ，注意当我们对主要的 `User` 对象应用 [`Session.add()`](../orm/session_api.html#sqlalchemy.orm.Session.add
    "sqlalchemy.orm.Session.add") 方法时，相关的 `Address` 对象也被添加到同一个 [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 中：
- en: '[PRE7]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The above behavior, where the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") received a `User` object, and followed along the `User.addresses`
    relationship to locate a related `Address` object, is known as the **save-update
    cascade** and is discussed in detail in the ORM reference documentation at [Cascades](../orm/cascades.html#unitofwork-cascades).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 上述行为，[`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    接收了一个 `User` 对象，并沿着 `User.addresses` 关系找到了相关的 `Address` 对象，被称为 **保存-更新级联**，在 ORM
    参考文档的 [级联](../orm/cascades.html#unitofwork-cascades) 中详细讨论。
- en: 'The three objects are now in the [pending](../glossary.html#term-pending) state;
    this means they are ready to be the subject of an INSERT operation but this has
    not yet proceeded; all three objects have no primary key assigned yet, and in
    addition, the `a1` and `a2` objects have an attribute called `user_id` which refers
    to the [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    that has a [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") referring to the `user_account.id` column;
    these are also `None` as the objects are not yet associated with a real database
    row:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个对象现在处于[pending](../glossary.html#term-pending)状态；这意味着它们准备好被用于INSERT操作，但这还没有进行；所有三个对象都还没有分配主键，并且`a1`和`a2`对象还有一个名为`user_id`的属性，它指向具有引用`user_account.id`列的[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")，这些也都是`None`，因为这些对象还没有与真实的数据库行关联：
- en: '[PRE8]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: It’s at this stage that we can see the very great utility that the unit of work
    process provides; recall in the section [INSERT usually generates the “values”
    clause automatically](data_insert.html#tutorial-core-insert-values-clause), rows
    were inserted into the `user_account` and `address` tables using some elaborate
    syntaxes in order to automatically associate the `address.user_id` columns with
    those of the `user_account` rows. Additionally, it was necessary that we emit
    INSERT for `user_account` rows first, before those of `address`, since rows in
    `address` are **dependent** on their parent row in `user_account` for a value
    in their `user_id` column.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 正是在这个阶段，我们可以看到工作单元过程提供的非常大的实用性；回想在[INSERT通常会自动生成“values”子句](data_insert.html#tutorial-core-insert-values-clause)一节中，使用一些复杂的语法将行插入到`user_account`和`address`表中，以便自动将`address.user_id`列与`user_account`行的列关联起来。此外，我们需要先为`user_account`行发出INSERT，然后再为`address`行发出INSERT，因为`address`行依赖于其父行`user_account`中`user_id`列的值。
- en: 'When using the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session"),
    all this tedium is handled for us and even the most die-hard SQL purist can benefit
    from automation of INSERT, UPDATE and DELETE statements. When we [`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") the transaction all steps invoke in the correct
    order, and furthermore the newly generated primary key of the `user_account` row
    is applied to the `address.user_id` column appropriately:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用[`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")时，所有这些繁琐的工作都会为我们处理，即使是最顽固的SQL纯粹主义者也可以从INSERT、UPDATE和DELETE语句的自动化中受益。当我们调用[`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit")提交事务时，所有步骤按正确顺序调用，而且`user_account`行的新生成主键也会适当地应用到`address.user_id`列上：
- en: '[PRE9]  ## Loading Relationships'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE9]  ## 加载关系'
- en: In the last step, we called [`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") which emitted a COMMIT for the transaction, and
    then per [`Session.commit.expire_on_commit`](../orm/session_api.html#sqlalchemy.orm.Session.commit.params.expire_on_commit
    "sqlalchemy.orm.Session.commit") expired all objects so that they refresh for
    the next transaction.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一步中，我们调用了[`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit")，这会为事务发出一个 COMMIT，然后根据[`Session.commit.expire_on_commit`](../orm/session_api.html#sqlalchemy.orm.Session.commit.params.expire_on_commit
    "sqlalchemy.orm.Session.commit")使所有对象过期，以便它们在下一个事务中刷新。
- en: 'When we next access an attribute on these objects, we’ll see the SELECT emitted
    for the primary attributes of the row, such as when we view the newly generated
    primary key for the `u1` object:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们下次访问这些对象的属性时，我们会看到为行的主要属性发出的SELECT，比如当我们查看`u1`对象的新生成的主键时：
- en: '[PRE10]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `u1` `User` object now has a persistent collection `User.addresses` that
    we may also access. As this collection consists of an additional set of rows from
    the `address` table, when we access this collection as well we again see a [lazy
    load](../glossary.html#term-lazy-load) emitted in order to retrieve the objects:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`u1` `User`对象现在有一个持久化集合`User.addresses`，我们也可以访问它。由于这个集合包含了`address`表中的一组额外行，当我们再次访问这个集合时，我们会再次看到一个[延迟加载](../glossary.html#term-lazy-load)以检索对象：'
- en: '[PRE11]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Collections and related attributes in the SQLAlchemy ORM are persistent in
    memory; once the collection or attribute is populated, SQL is no longer emitted
    until that collection or attribute is [expired](../glossary.html#term-expired).
    We may access `u1.addresses` again as well as add or remove items and this will
    not incur any new SQL calls:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy ORM 中的集合和相关属性在内存中是持久的；一旦集合或属性被填充，SQL 就不再发出，直到该集合或属性被[过期](../glossary.html#term-expired)。我们可以再次访问`u1.addresses`，以及添加或删除项目，并且这不会产生任何新的
    SQL 调用：
- en: '[PRE12]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'While the loading emitted by lazy loading can quickly become expensive if we
    don’t take explicit steps to optimize it, the network of lazy loading at least
    is fairly well optimized to not perform redundant work; as the `u1.addresses`
    collection was refreshed, per the [identity map](../glossary.html#term-identity-map)
    these are in fact the same `Address` instances as the `a1` and `a2` objects we’ve
    been dealing with already, so we’re done loading all attributes in this particular
    object graph:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然懒加载所发出的加载请求如果我们不采取明确的优化步骤就很容易变得昂贵，但至少懒加载的网络相当优化，不会执行冗余的工作；由于[u1.addresses](../glossary.html#term-identity-map)集合被刷新，根据身份映射，这些实际上是我们已经处理过的`a1`和`a2`对象中的相同的`Address`实例，因此我们已经完成了加载这个特定对象图中的所有属性：
- en: '[PRE13]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The issue of how relationships load, or not, is an entire subject onto itself.
    Some additional introduction to these concepts is later in this section at [Loader
    Strategies](#tutorial-orm-loader-strategies).  ## Using Relationships in Queries'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '关系如何加载或不加载的问题是一个独立的主题。稍后在本节的[加载策略](#tutorial-orm-loader-strategies)中对这些概念进行了一些补充介绍。
    ## 在查询中使用关系'
- en: The previous section introduced the behavior of the [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") construct when working with **instances of a mapped
    class**, above, the `u1`, `a1` and `a2` instances of the `User` and `Address`
    classes. In this section, we introduce the behavior of [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") as it applies to **class level behavior of a mapped
    class**, where it serves in several ways to help automate the construction of
    SQL queries.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 前一节介绍了当使用**映射类的实例**时[`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")构造的行为，上文介绍了`User`和`Address`类的`u1`、`a1`和`a2`实例。在本节中，我们介绍了当应用于映射类的**类级行为**时，[`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")的行为，它在多个方面帮助自动构建 SQL 查询。
- en: '### Using Relationships to Join'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '### 使用关系进行连接'
- en: The sections [Explicit FROM clauses and JOINs](data_select.html#tutorial-select-join)
    and [Setting the ON Clause](data_select.html#tutorial-select-join-onclause) introduced
    the usage of the [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") and [`Select.join_from()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join_from
    "sqlalchemy.sql.expression.Select.join_from") methods to compose SQL JOIN clauses.
    In order to describe how to join between tables, these methods either **infer**
    the ON clause based on the presence of a single unambiguous [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") object within the table metadata structure
    that links the two tables, or otherwise we may provide an explicit SQL Expression
    construct that indicates a specific ON clause.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '[显式 FROM 子句和 JOINs](data_select.html#tutorial-select-join)和[设置 ON 子句](data_select.html#tutorial-select-join-onclause)章节介绍了使用[`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join")和[`Select.join_from()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join_from
    "sqlalchemy.sql.expression.Select.join_from")方法来组合 SQL JOIN 子句。为了描述如何在表之间进行连接，这些方法要么根据表元数据结构中存在的单个明确的[`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint")对象推断出 ON 子句，该对象链接了这两个表，要么我们可以提供一个明确的
    SQL 表达式构造，指示特定的 ON 子句。'
- en: 'When using ORM entities, an additional mechanism is available to help us set
    up the ON clause of a join, which is to make use of the [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") objects that we set up in our user mapping, as
    was demonstrated at [Declaring Mapped Classes](metadata.html#tutorial-declaring-mapped-classes).
    The class-bound attribute corresponding to the [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") may be passed as the **single argument** to [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join"), where it serves to indicate both the
    right side of the join as well as the ON clause at once:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 ORM 实体时，还有一种额外的机制可用于帮助我们设置连接的 ON 子句，这就是利用我们在用户映射中设置的 [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") 对象，就像在 [声明映射类](metadata.html#tutorial-declaring-mapped-classes)
    中演示的那样。相应于 [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") 的类绑定属性可以作为 **单个参数** 传递给 [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join")，它既用于指示连接的右侧，又一次性指示 ON 子句：
- en: '[PRE14]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The presence of an ORM [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") on a mapping is not used by [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") or [`Select.join_from()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join_from
    "sqlalchemy.sql.expression.Select.join_from") to infer the ON clause if we don’t
    specify it. This means, if we join from `User` to `Address` without an ON clause,
    it works because of the [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") between the two mapped [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects, not because of the [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") objects on the `User` and `Address` classes:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 映射上的 ORM [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") 的存在，如果我们没有指定 ON 子句，将不会被 [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") 或 [`Select.join_from()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join_from
    "sqlalchemy.sql.expression.Select.join_from") 用于推断 ON 子句。这意味着，如果我们从 `User` 连接到
    `Address` 而没有 ON 子句，它会工作是因为两个映射的 [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") 对象之间的 [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint")，而不是 `User` 和 `Address` 类上的 [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") 对象：
- en: '[PRE15]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: See the section [Joins](../orm/queryguide/select.html#orm-queryguide-joins)
    in the [ORM Querying Guide](../orm/queryguide/index.html) for many more examples
    of how to use [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") and [`Select.join_from()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join_from
    "sqlalchemy.sql.expression.Select.join_from") with [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") constructs.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅 [连接](../orm/queryguide/select.html#orm-queryguide-joins) 在 [ORM 查询指南](../orm/queryguide/index.html)
    中，了解如何使用 [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") 和 [`Select.join_from()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join_from
    "sqlalchemy.sql.expression.Select.join_from") 与 [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") 构造的更多示例。
- en: See also
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 请参见
- en: '[Joins](../orm/queryguide/select.html#orm-queryguide-joins) in the [ORM Querying
    Guide](../orm/queryguide/index.html)  ### Relationship WHERE Operators'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '[连接](../orm/queryguide/select.html#orm-queryguide-joins) 在 [ORM 查询指南](../orm/queryguide/index.html)
    ### 关系 WHERE 运算符'
- en: There are some additional varieties of SQL generation helpers that come with
    [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")
    which are typically useful when building up the WHERE clause of a statement. See
    the section [Relationship WHERE Operators](../orm/queryguide/select.html#orm-queryguide-relationship-operators)
    in the [ORM Querying Guide](../orm/queryguide/index.html).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '[`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") 还配备了一些额外的 SQL 生成辅助工具，当构建语句的 WHERE 子句时通常很有用。请参阅
    [关系 WHERE 运算符](../orm/queryguide/select.html#orm-queryguide-relationship-operators)
    在 [ORM 查询指南](../orm/queryguide/index.html) 中的部分。'
- en: See also
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 请参见
- en: '[Relationship WHERE Operators](../orm/queryguide/select.html#orm-queryguide-relationship-operators)
    in the [ORM Querying Guide](../orm/queryguide/index.html)  ## Loader Strategies'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '[关系WHERE运算符](../orm/queryguide/select.html#orm-queryguide-relationship-operators)在[ORM查询指南](../orm/queryguide/index.html)中  ##
    加载策略'
- en: In the section [Loading Relationships](#tutorial-loading-relationships) we introduced
    the concept that when we work with instances of mapped objects, accessing the
    attributes that are mapped using [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") in the default case will emit a [lazy load](../glossary.html#term-lazy-load)
    when the collection is not populated in order to load the objects that should
    be present in this collection.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在[加载关系](#tutorial-loading-relationships)部分，我们介绍了这样一个概念，当我们使用映射对象的实例时，访问使用[`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")映射的属性时，在默认情况下，如果集合未填充，则会发出[延迟加载](../glossary.html#term-lazy-load)以加载应该存在于此集合中的对象。
- en: Lazy loading is one of the most famous ORM patterns, and is also the one that
    is most controversial. When several dozen ORM objects in memory each refer to
    a handful of unloaded attributes, routine manipulation of these objects can spin
    off many additional queries that can add up (otherwise known as the [N plus one
    problem](../glossary.html#term-N-plus-one-problem)), and to make matters worse
    they are emitted implicitly. These implicit queries may not be noticed, may cause
    errors when they are attempted after there’s no longer a database transaction
    available, or when using alternative concurrency patterns such as [asyncio](../orm/extensions/asyncio.html),
    they actually won’t work at all.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 延迟加载是最著名的ORM模式之一，也是最具争议的模式之一。当内存中有几十个ORM对象分别引用少量未加载的属性时，对这些对象的常规操作可能会产生许多额外的查询，这些查询可能会累积（也称为[N加一问题](../glossary.html#term-N-plus-one-problem)），更糟糕的是它们是隐式发出的。这些隐式查询可能不会被注意到，在数据库事务不再可用时尝试执行它们时可能会导致错误，或者在使用诸如[asyncio](../orm/extensions/asyncio.html)之类的替代并发模式时，它们实际上根本不起作用。
- en: At the same time, lazy loading is a vastly popular and useful pattern when it
    is compatible with the concurrency approach in use and isn’t otherwise causing
    problems. For these reasons, SQLAlchemy’s ORM places a lot of emphasis on being
    able to control and optimize this loading behavior.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 与此同时，当与正在使用的并发方法兼容且没有引起问题时，延迟加载是一种非常流行和有用的模式。出于这些原因，SQLAlchemy的ORM非常重视能够控制和优化这种加载行为。
- en: Above all, the first step in using ORM lazy loading effectively is to **test
    the application, turn on SQL echoing, and watch the SQL that is emitted**. If
    there seem to be lots of redundant SELECT statements that look very much like
    they could be rolled into one much more efficiently, if there are loads occurring
    inappropriately for objects that have been [detached](../glossary.html#term-detached)
    from their [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session"),
    that’s when to look into using **loader strategies**.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，有效使用ORM延迟加载的第一步是**测试应用程序，打开SQL回显，并观察生成的SQL语句**。如果看起来有很多冗余的SELECT语句，看起来它们可以更有效地合并为一个，如果对象在已经[分离](../glossary.html#term-detached)的[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")中不适当地发生加载，那就是使用**加载策略**的时候。
- en: 'Loader strategies are represented as objects that may be associated with a
    SELECT statement using the [`Select.options()`](../core/selectable.html#sqlalchemy.sql.expression.Select.options
    "sqlalchemy.sql.expression.Select.options") method, e.g.:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 加载策略表示为可以使用[`Select.options()`](../core/selectable.html#sqlalchemy.sql.expression.Select.options
    "sqlalchemy.sql.expression.Select.options")方法与SELECT语句关联的对象，例如：
- en: '[PRE16]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'They may be also configured as defaults for a [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") using the [`relationship.lazy`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.lazy
    "sqlalchemy.orm.relationship") option, e.g.:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 它们也可以被配置为[`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")的默认值，使用[`relationship.lazy`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.lazy
    "sqlalchemy.orm.relationship")选项，例如：
- en: '[PRE17]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Each loader strategy object adds some kind of information to the statement that
    will be used later by the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") when it is deciding how various attributes should be
    loaded and/or behave when they are accessed.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 每个加载器策略对象都会向语句中添加某种信息，该信息将在以后由[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")在决定各种属性在访问时应如何加载和/或行为时使用。
- en: The sections below will introduce a few of the most prominently used loader
    strategies.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的部分将介绍一些最常用的加载器策略。
- en: See also
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 参见
- en: 'Two sections in [Relationship Loading Techniques](../orm/queryguide/relationships.html):'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '[关系加载技术](../orm/queryguide/relationships.html)中的两个部分：'
- en: '[Configuring Loader Strategies at Mapping Time](../orm/queryguide/relationships.html#relationship-lazy-option)
    - details on configuring the strategy on [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[在映射时配置加载器策略](../orm/queryguide/relationships.html#relationship-lazy-option)
    - 配置在[`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")上的策略的详细信息'
- en: '[Relationship Loading with Loader Options](../orm/queryguide/relationships.html#relationship-loader-options)
    - details on using query-time loader strategies'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用加载器选项进行关系加载](../orm/queryguide/relationships.html#relationship-loader-options)
    - 使用查询时加载策略的详细信息'
- en: Selectin Load
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Selectin Load
- en: 'The most useful loader in modern SQLAlchemy is the [`selectinload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.selectinload
    "sqlalchemy.orm.selectinload") loader option. This option solves the most common
    form of the “N plus one” problem which is that of a set of objects that refer
    to related collections. [`selectinload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.selectinload
    "sqlalchemy.orm.selectinload") will ensure that a particular collection for a
    full series of objects are loaded up front using a single query. It does this
    using a SELECT form that in most cases can be emitted against the related table
    alone, without the introduction of JOINs or subqueries, and only queries for those
    parent objects for which the collection isn’t already loaded. Below we illustrate
    [`selectinload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.selectinload
    "sqlalchemy.orm.selectinload") by loading all of the `User` objects and all of
    their related `Address` objects; while we invoke [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") only once, given a [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") construct, when the database is accessed,
    there are in fact two SELECT statements emitted, the second one being to fetch
    the related `Address` objects:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代SQLAlchemy中最有用的加载器是[`selectinload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.selectinload
    "sqlalchemy.orm.selectinload")加载器选项。该选项解决了最常见形式的“N加一”问题，即一组对象引用相关集合。[`selectinload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.selectinload
    "sqlalchemy.orm.selectinload")将确保立即使用单个查询加载整个系列对象的特定集合。它使用一种SELECT形式，在大多数情况下可以针对相关表单独发出，而不需要引入JOIN或子查询，并且仅查询那些集合尚未加载的父对象。下面我们通过加载所有`User`对象及其所有相关的`Address`对象来说明[`selectinload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.selectinload
    "sqlalchemy.orm.selectinload")；虽然我们只调用了一次[`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute")，给定一个[`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select")构造，但在访问数据库时，实际上发出了两个SELECT语句，第二个语句是用于获取相关的`Address`对象：
- en: '[PRE18]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: See also
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 参见
- en: '[Select IN loading](../orm/queryguide/relationships.html#selectin-eager-loading)
    - in [Relationship Loading Techniques](../orm/queryguide/relationships.html)'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '[选择 IN 加载](../orm/queryguide/relationships.html#selectin-eager-loading) - 在[关系加载技术](../orm/queryguide/relationships.html)中'
- en: Joined Load
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Joined Load
- en: The [`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload") eager load strategy is the oldest eager loader in
    SQLAlchemy, which augments the SELECT statement that’s being passed to the database
    with a JOIN (which may be an outer or an inner join depending on options), which
    can then load in related objects.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '[`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload")预加载策略是SQLAlchemy中最古老的预加载器，它通过在传递给数据库的SELECT语句中添加一个JOIN（根据选项可能是外连接或内连接）来增强，然后可以加载相关对象。'
- en: 'The [`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload") strategy is best suited towards loading related many-to-one
    objects, as this only requires that additional columns are added to a primary
    entity row that would be fetched in any case. For greater efficiency, it also
    accepts an option [`joinedload.innerjoin`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload.params.innerjoin
    "sqlalchemy.orm.joinedload") so that an inner join instead of an outer join may
    be used for a case such as below where we know that all `Address` objects have
    an associated `User`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '[`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload")策略最适合加载相关的多对一对象，因为这只需要向主实体行添加额外的列，在任何情况下都会获取这些列。为了提高效率，它还接受一个选项[`joinedload.innerjoin`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload.params.innerjoin
    "sqlalchemy.orm.joinedload")，这样在下面这种情况下可以使用内连接而不是外连接，我们知道所有的`Address`对象都有一个关联的`User`：'
- en: '[PRE19]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload") also works for collections, meaning one-to-many relationships,
    however it has the effect of multiplying out primary rows per related item in
    a recursive way that grows the amount of data sent for a result set by orders
    of magnitude for nested collections and/or larger collections, so its use vs.
    another option such as [`selectinload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.selectinload
    "sqlalchemy.orm.selectinload") should be evaluated on a per-case basis.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '[`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload")也适用于集合，意味着一对多关系，但它会以递归方式将每个相关项乘以主行，从而增加通过结果集发送的数据量，对于嵌套集合和/或较大集合，这会使数据量成倍增长，因此应该根据具体情况评估其与其他选项（例如[`selectinload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.selectinload
    "sqlalchemy.orm.selectinload")）的使用。'
- en: It’s important to note that the WHERE and ORDER BY criteria of the enclosing
    [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select "sqlalchemy.sql.expression.Select")
    statement **do not target the table rendered by joinedload()**. Above, it can
    be seen in the SQL that an **anonymous alias** is applied to the `user_account`
    table such that is not directly addressable in the query. This concept is discussed
    in more detail in the section [The Zen of Joined Eager Loading](../orm/queryguide/relationships.html#zen-of-eager-loading).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，封闭[`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select")语句的WHERE和ORDER BY条件**不会针对joinedload()生成的表**。上面的例子中，可以看到SQL中对`user_account`表应用了一个**匿名别名**，以便在查询中无法直接寻址。这个概念在[加入式预加载的禅意](../orm/queryguide/relationships.html#zen-of-eager-loading)一节中有更详细的讨论。
- en: Tip
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: It’s important to note that many-to-one eager loads are often not necessary,
    as the “N plus one” problem is much less prevalent in the common case. When many
    objects all refer to the same related object, such as many `Address` objects that
    each refer to the same `User`, SQL will be emitted only once for that `User` object
    using normal lazy loading. The lazy load routine will look up the related object
    by primary key in the current [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") without emitting any SQL when possible.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，多对一的预加载通常是不必要的，因为“N加一”问题在常见情况下要少得多。当许多对象都引用相同的相关对象时，例如每个都引用相同`User`的许多`Address`对象时，SQL将仅对该`User`对象发出一次，使用普通的惰性加载。惰性加载例程将在当前[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")中尽可能地通过主键查找相关对象，而不在可能时发出任何SQL。
- en: See also
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Joined Eager Loading](../orm/queryguide/relationships.html#joined-eager-loading)
    - in [Relationship Loading Techniques](../orm/queryguide/relationships.html)'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '[加入式预加载](../orm/queryguide/relationships.html#joined-eager-loading) - 在[关系加载技术](../orm/queryguide/relationships.html)中'
- en: '### Explicit Join + Eager load'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '### 明确的连接 + 预加载'
- en: 'If we were to load `Address` rows while joining to the `user_account` table
    using a method such as [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") to render the JOIN, we could also leverage
    that JOIN in order to eagerly load the contents of the `Address.user` attribute
    on each `Address` object returned. This is essentially that we are using “joined
    eager loading” but rendering the JOIN ourselves. This common use case is achieved
    by using the [`contains_eager()`](../orm/queryguide/relationships.html#sqlalchemy.orm.contains_eager
    "sqlalchemy.orm.contains_eager") option. This option is very similar to [`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload"), except that it assumes we have set up the JOIN ourselves,
    and it instead only indicates that additional columns in the COLUMNS clause should
    be loaded into related attributes on each returned object, for example:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在连接到 `user_account` 表时加载 `Address` 行，使用诸如 [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join)
    之类的方法来渲染 JOIN，我们也可以利用该 JOIN 来急切地加载每个返回的 `Address` 对象的 `Address.user` 属性的内容。这本质上就是我们正在使用“连接的急切加载”，但是自己渲染
    JOIN。这个常见的用例是通过使用 [`contains_eager()`](../orm/queryguide/relationships.html#sqlalchemy.orm.contains_eager)
    选项实现的。该选项与 [`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload)
    非常相似，只是它假设我们已经自己设置了 JOIN，并且它仅指示应该将 COLUMNS 子句中的附加列加载到每个返回对象的相关属性中，例如：
- en: '[PRE20]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Above, we both filtered the rows on `user_account.name` and also loaded rows
    from `user_account` into the `Address.user` attribute of the returned rows. If
    we had applied [`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload") separately, we would get a SQL query that unnecessarily
    joins twice:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 上面，我们同时对 `user_account.name` 进行了筛选，并且将 `user_account` 中的行加载到返回的行的 `Address.user`
    属性中。如果我们分别应用了 [`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload)
    ，我们将会得到一个不必要两次连接的 SQL 查询：
- en: '[PRE21]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: See also
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'Two sections in [Relationship Loading Techniques](../orm/queryguide/relationships.html):'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '[关系加载技术](../orm/queryguide/relationships.html)中的两个部分：'
- en: '[The Zen of Joined Eager Loading](../orm/queryguide/relationships.html#zen-of-eager-loading)
    - describes the above problem in detail'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[连接急切加载的禅意](../orm/queryguide/relationships.html#zen-of-eager-loading) - 详细描述了上述问题'
- en: '[Routing Explicit Joins/Statements into Eagerly Loaded Collections](../orm/queryguide/relationships.html#contains-eager)
    - using [`contains_eager()`](../orm/queryguide/relationships.html#sqlalchemy.orm.contains_eager
    "sqlalchemy.orm.contains_eager")'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[将显式连接/语句路由到急切加载的集合](../orm/queryguide/relationships.html#contains-eager) -
    使用 [`contains_eager()`](../orm/queryguide/relationships.html#sqlalchemy.orm.contains_eager)'
- en: Raiseload
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Raiseload
- en: One additional loader strategy worth mentioning is [`raiseload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.raiseload
    "sqlalchemy.orm.raiseload"). This option is used to completely block an application
    from having the [N plus one](../glossary.html#term-N-plus-one) problem at all
    by causing what would normally be a lazy load to raise an error instead. It has
    two variants that are controlled via the [`raiseload.sql_only`](../orm/queryguide/relationships.html#sqlalchemy.orm.raiseload.params.sql_only
    "sqlalchemy.orm.raiseload") option to block either lazy loads that require SQL,
    versus all “load” operations including those which only need to consult the current
    [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session").
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的另一个加载器策略是 [`raiseload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.raiseload)
    。此选项用于通过导致通常将是延迟加载的操作引发错误来完全阻止应用程序遇到 [N 加一](../glossary.html#term-N-plus-one)
    问题。它有两个变体，通过 [`raiseload.sql_only`](../orm/queryguide/relationships.html#sqlalchemy.orm.raiseload.params.sql_only)
    选项进行控制，以阻止需要 SQL 的延迟加载，与所有“加载”操作，包括仅需要查询当前 [`Session`](../orm/session_api.html#sqlalchemy.orm.Session)
    的那些操作。
- en: 'One way to use [`raiseload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.raiseload
    "sqlalchemy.orm.raiseload") is to configure it on [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") itself, by setting [`relationship.lazy`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.lazy
    "sqlalchemy.orm.relationship") to the value `"raise_on_sql"`, so that for a particular
    mapping, a certain relationship will never try to emit SQL:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 [`raiseload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.raiseload
    "sqlalchemy.orm.raiseload") 的一种方法是在 [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") 上配置它，通过将 [`relationship.lazy`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.lazy
    "sqlalchemy.orm.relationship") 设置为值 `"raise_on_sql"`，这样对于特定映射，某个关系将永远不会尝试发出 SQL：
- en: '[PRE22]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Using such a mapping, the application is blocked from lazy loading, indicating
    that a particular query would need to specify a loader strategy:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这样的映射，应用程序被阻止了懒加载，表明特定查询需要指定一个加载策略：
- en: '[PRE23]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The exception would indicate that this collection should be loaded up front
    instead:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 异常将指示应该预先加载此集合：
- en: '[PRE24]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `lazy="raise_on_sql"` option tries to be smart about many-to-one relationships
    as well; above, if the `Address.user` attribute of an `Address` object were not
    loaded, but that `User` object were locally present in the same [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), the “raiseload” strategy would not raise an error.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`lazy="raise_on_sql"` 选项也会对多对一关系进行智能处理；上面，如果一个 `Address` 对象的 `Address.user`
    属性未加载，但是该 `User` 对象在同一个 [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 中本地存在，那么“raiseload”策略将不会引发错误。'
- en: See also
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Preventing unwanted lazy loads using raiseload](../orm/queryguide/relationships.html#prevent-lazy-with-raiseload)
    - in [Relationship Loading Techniques](../orm/queryguide/relationships.html)'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用 raiseload 阻止不必要的懒加载](../orm/queryguide/relationships.html#prevent-lazy-with-raiseload)
    - 在[关系加载技术](../orm/queryguide/relationships.html)中'
- en: Persisting and Loading Relationships
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 持久化和加载关系
- en: 'We can start by illustrating what [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") does to instances of objects. If we make a new
    `User` object, we can note that there is a Python list when we access the `.addresses`
    element:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以先说明 [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") 对象实例的作用。如果我们创建一个新的 `User` 对象，我们可以注意到当我们访问 `.addresses`
    元素时会有一个 Python 列表：
- en: '[PRE25]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This object is a SQLAlchemy-specific version of Python `list` which has the
    ability to track and respond to changes made to it. The collection also appeared
    automatically when we accessed the attribute, even though we never assigned it
    to the object. This is similar to the behavior noted at [Inserting Rows using
    the ORM Unit of Work pattern](orm_data_manipulation.html#tutorial-inserting-orm)
    where it was observed that column-based attributes to which we don’t explicitly
    assign a value also display as `None` automatically, rather than raising an `AttributeError`
    as would be Python’s usual behavior.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 此对象是 Python `list` 的 SQLAlchemy 特定版本，具有跟踪和响应对其进行的更改的能力。当我们访问属性时，集合也会自动出现，即使我们从未将其分配给对象。这类似于在
    [使用 ORM 工作单元模式插入行](orm_data_manipulation.html#tutorial-inserting-orm) 中注意到的行为，即我们没有明确为其分配值的基于列的属性也会自动显示为
    `None`，而不是像 Python 的通常行为那样引发 `AttributeError`。
- en: As the `u1` object is still [transient](../glossary.html#term-transient) and
    the `list` that we got from `u1.addresses` has not been mutated (i.e. appended
    or extended), it’s not actually associated with the object yet, but as we make
    changes to it, it will become part of the state of the `User` object.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `u1` 对象仍然是 [瞬态](../glossary.html#term-transient)，并且我们从 `u1.addresses` 得到的
    `list` 尚未被改变（即未被添加或扩展），因此实际上尚未与对象关联，但是当我们对其进行更改时，它将成为 `User` 对象状态的一部分。
- en: 'The collection is specific to the `Address` class which is the only type of
    Python object that may be persisted within it. Using the `list.append()` method
    we may add an `Address` object:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 该集合专用于 `Address` 类，这是唯一可以在其中持久化的 Python 对象类型。使用 `list.append()` 方法，我们可以添加一个
    `Address` 对象：
- en: '[PRE26]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'At this point, the `u1.addresses` collection as expected contains the new `Address`
    object:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，`u1.addresses` 集合按预期包含了新的 `Address` 对象：
- en: '[PRE27]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'As we associated the `Address` object with the `User.addresses` collection
    of the `u1` instance, another behavior also occurred, which is that the `User.addresses`
    relationship synchronized itself with the `Address.user` relationship, such that
    we can navigate not only from the `User` object to the `Address` object, we can
    also navigate from the `Address` object back to the “parent” `User` object:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将`Address`对象与`u1`实例的`User.addresses`集合关联起来时，还发生了另一个行为，即`User.addresses`关系与`Address.user`关系同步，这样我们不仅可以从`User`对象导航到`Address`对象，还可以从`Address`对象导航回“父”`User`对象：
- en: '[PRE28]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This synchronization occurred as a result of our use of the [`relationship.back_populates`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.back_populates
    "sqlalchemy.orm.relationship") parameter between the two [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") objects. This parameter names another [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") for which complementary attribute assignment /
    list mutation should occur. It will work equally well in the other direction,
    which is that if we create another `Address` object and assign to its `Address.user`
    attribute, that `Address` becomes part of the `User.addresses` collection on that
    `User` object:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这种同步发生是因为我们在两个[`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")对象之间使用了[`relationship.back_populates`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.back_populates
    "sqlalchemy.orm.relationship")参数。该参数命名了另一个应进行互补属性赋值/列表变异的[`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")。在另一个方向上同样有效，即如果我们创建另一个`Address`对象并将其分配给其`Address.user`属性，该`Address`将成为`User`对象上的`User.addresses`集合的一部分：
- en: '[PRE29]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We actually made use of the `user` parameter as a keyword argument in the `Address`
    constructor, which is accepted just like any other mapped attribute that was declared
    on the `Address` class. It is equivalent to assignment of the `Address.user` attribute
    after the fact:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上在`Address`构造函数中使用了`user`参数作为关键字参数，这与在`Address`类上声明的任何其他映射属性一样被接受。这相当于事后对`Address.user`属性进行赋值：
- en: '[PRE30]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '### Cascading Objects into the Session'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '### 将对象级联到会话中'
- en: We now have a `User` and two `Address` objects that are associated in a bidirectional
    structure in memory, but as noted previously in [Inserting Rows using the ORM
    Unit of Work pattern](orm_data_manipulation.html#tutorial-inserting-orm) , these
    objects are said to be in the [transient](../glossary.html#term-transient) state
    until they are associated with a [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") object.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个`User`和两个`Address`对象，在内存中以双向结构关联，但如前所述，在[使用ORM工作单元模式插入行](orm_data_manipulation.html#tutorial-inserting-orm)中，这些对象被称为处于[瞬态](../glossary.html#term-transient)状态，直到它们与一个[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")对象关联为止。
- en: 'We make use of the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") that’s still ongoing, and note that when we apply the
    [`Session.add()`](../orm/session_api.html#sqlalchemy.orm.Session.add "sqlalchemy.orm.Session.add")
    method to the lead `User` object, the related `Address` object also gets added
    to that same [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session"):'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们利用的是仍在进行中的[`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")，请注意，当我们对主`User`对象应用[`Session.add()`](../orm/session_api.html#sqlalchemy.orm.Session.add
    "sqlalchemy.orm.Session.add")方法时，相关的`Address`对象也会被添加到同一个[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")中：
- en: '[PRE31]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The above behavior, where the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") received a `User` object, and followed along the `User.addresses`
    relationship to locate a related `Address` object, is known as the **save-update
    cascade** and is discussed in detail in the ORM reference documentation at [Cascades](../orm/cascades.html#unitofwork-cascades).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 上述行为，即[`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")接收到一个`User`对象，并沿着`User.addresses`关系定位相关的`Address`对象的行为，被称为**保存更新级联**，并在ORM参考文档中详细讨论，链接地址为[Cascades](../orm/cascades.html#unitofwork-cascades)。
- en: 'The three objects are now in the [pending](../glossary.html#term-pending) state;
    this means they are ready to be the subject of an INSERT operation but this has
    not yet proceeded; all three objects have no primary key assigned yet, and in
    addition, the `a1` and `a2` objects have an attribute called `user_id` which refers
    to the [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    that has a [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") referring to the `user_account.id` column;
    these are also `None` as the objects are not yet associated with a real database
    row:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个对象现在处于 [挂起](../glossary.html#term-pending) 状态；这意味着它们已经准备好成为 INSERT 操作的对象，但这还没有进行；所有三个对象目前还没有分配主键，并且此外，`a1`
    和 `a2` 对象具有一个名为 `user_id` 的属性，该属性指向具有引用 `user_account.id` 列的 [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")，这些属性也是 `None`，因为这些对象尚未与真实的数据库行关联：
- en: '[PRE32]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: It’s at this stage that we can see the very great utility that the unit of work
    process provides; recall in the section [INSERT usually generates the “values”
    clause automatically](data_insert.html#tutorial-core-insert-values-clause), rows
    were inserted into the `user_account` and `address` tables using some elaborate
    syntaxes in order to automatically associate the `address.user_id` columns with
    those of the `user_account` rows. Additionally, it was necessary that we emit
    INSERT for `user_account` rows first, before those of `address`, since rows in
    `address` are **dependent** on their parent row in `user_account` for a value
    in their `user_id` column.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们可以看到工作单元流程提供的非常大的实用性；回想一下在 [INSERT 通常会自动生成“values”子句](data_insert.html#tutorial-core-insert-values-clause)
    中，行是如何插入到 `user_account` 和 `address` 表中的，使用一些复杂的语法来自动将 `address.user_id` 列与 `user_account`
    表中的列关联起来。此外，我们必须首先为 `user_account` 表中的行发出 INSERT，然后是 `address` 表中的行，因为 `address`
    中的行**依赖于**其在 `user_account` 表中的父行，以获取其 `user_id` 列中的值。
- en: 'When using the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session"),
    all this tedium is handled for us and even the most die-hard SQL purist can benefit
    from automation of INSERT, UPDATE and DELETE statements. When we [`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") the transaction all steps invoke in the correct
    order, and furthermore the newly generated primary key of the `user_account` row
    is applied to the `address.user_id` column appropriately:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    时，所有这些烦琐工作都由我们处理，即使是最铁杆的 SQL 纯粹主义者也可以从 INSERT、UPDATE 和 DELETE 语句的自动化中受益。当我们调用
    [`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit "sqlalchemy.orm.Session.commit")
    时，所有步骤都按正确的顺序执行，并且还会将 `user_account` 行的新生成的主键适当地应用到 `address.user_id` 列中：
- en: '[PRE33]  ### Cascading Objects into the Session'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE33]  ### 将对象级联到会话中'
- en: We now have a `User` and two `Address` objects that are associated in a bidirectional
    structure in memory, but as noted previously in [Inserting Rows using the ORM
    Unit of Work pattern](orm_data_manipulation.html#tutorial-inserting-orm) , these
    objects are said to be in the [transient](../glossary.html#term-transient) state
    until they are associated with a [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") object.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们在内存中有一个双向结构的 `User` 对象和两个 `Address` 对象，但正如之前在 [使用 ORM 工作单元模式插入行](orm_data_manipulation.html#tutorial-inserting-orm)
    中所述，这些对象被认为处于 [瞬时](../glossary.html#term-transient) 状态，直到它们与一个 [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 对象关联为止。
- en: 'We make use of the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") that’s still ongoing, and note that when we apply the
    [`Session.add()`](../orm/session_api.html#sqlalchemy.orm.Session.add "sqlalchemy.orm.Session.add")
    method to the lead `User` object, the related `Address` object also gets added
    to that same [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session"):'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们利用的是仍在进行中的 [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")，请注意，当我们将
    [`Session.add()`](../orm/session_api.html#sqlalchemy.orm.Session.add "sqlalchemy.orm.Session.add")
    方法应用于主 `User` 对象时，相关的 `Address` 对象也会被添加到同一个 [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 中：
- en: '[PRE34]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The above behavior, where the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") received a `User` object, and followed along the `User.addresses`
    relationship to locate a related `Address` object, is known as the **save-update
    cascade** and is discussed in detail in the ORM reference documentation at [Cascades](../orm/cascades.html#unitofwork-cascades).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 上述行为，其中[`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")接收到一个
    `User` 对象，并沿着 `User.addresses` 关系跟踪以找到相关的 `Address` 对象，被称为**save-update cascade**，并且在
    ORM 参考文档的[Cascades](../orm/cascades.html#unitofwork-cascades)中有详细讨论。
- en: 'The three objects are now in the [pending](../glossary.html#term-pending) state;
    this means they are ready to be the subject of an INSERT operation but this has
    not yet proceeded; all three objects have no primary key assigned yet, and in
    addition, the `a1` and `a2` objects have an attribute called `user_id` which refers
    to the [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    that has a [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") referring to the `user_account.id` column;
    these are also `None` as the objects are not yet associated with a real database
    row:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个对象现在处于[pending](../glossary.html#term-pending)状态；这意味着它们已准备好成为 INSERT 操作的主体，但还没有进行；这三个对象都还没有分配主键，并且此外，`a1`
    和 `a2` 对象具有一个名为 `user_id` 的属性，它指向具有引用 `user_account.id` 列的[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")；由于这些对象尚未与真实的数据库行关联，因此这些值也都是 `None`：
- en: '[PRE35]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: It’s at this stage that we can see the very great utility that the unit of work
    process provides; recall in the section [INSERT usually generates the “values”
    clause automatically](data_insert.html#tutorial-core-insert-values-clause), rows
    were inserted into the `user_account` and `address` tables using some elaborate
    syntaxes in order to automatically associate the `address.user_id` columns with
    those of the `user_account` rows. Additionally, it was necessary that we emit
    INSERT for `user_account` rows first, before those of `address`, since rows in
    `address` are **dependent** on their parent row in `user_account` for a value
    in their `user_id` column.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们可以看到工作单元流程提供的非常大的实用性；回想一下，在[INSERT 通常自动生成“values”子句](data_insert.html#tutorial-core-insert-values-clause)一节中，我们使用一些复杂的语法将行插入到
    `user_account` 和 `address` 表中，以便自动将 `address.user_id` 列与 `user_account` 行的列关联起来。此外，必须先为
    `user_account` 行发出 INSERT，然后才能为 `address` 的行发出 INSERT，因为 `address` 中的行依赖于其父行 `user_account`
    以在其 `user_id` 列中获得值。
- en: 'When using the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session"),
    all this tedium is handled for us and even the most die-hard SQL purist can benefit
    from automation of INSERT, UPDATE and DELETE statements. When we [`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") the transaction all steps invoke in the correct
    order, and furthermore the newly generated primary key of the `user_account` row
    is applied to the `address.user_id` column appropriately:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用[`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")时，所有这些繁琐的工作都由我们处理，即使是最铁杆的
    SQL 纯粹主义者也可以从 INSERT、UPDATE 和 DELETE 语句的自动化中受益。当我们调用[`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit")提交事务时，所有步骤都按正确的顺序执行，并且新生成的 `user_account` 行的主键还会适当地应用到
    `address.user_id` 列上：
- en: '[PRE36]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '## Loading Relationships'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '## 加载关系'
- en: In the last step, we called [`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") which emitted a COMMIT for the transaction, and
    then per [`Session.commit.expire_on_commit`](../orm/session_api.html#sqlalchemy.orm.Session.commit.params.expire_on_commit
    "sqlalchemy.orm.Session.commit") expired all objects so that they refresh for
    the next transaction.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一步中，我们调用了[`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit")，它发出了一个 COMMIT 以提交事务，然后根据[`Session.commit.expire_on_commit`](../orm/session_api.html#sqlalchemy.orm.Session.commit.params.expire_on_commit
    "sqlalchemy.orm.Session.commit")将所有对象过期，以便它们为下一个事务刷新。
- en: 'When we next access an attribute on these objects, we’ll see the SELECT emitted
    for the primary attributes of the row, such as when we view the newly generated
    primary key for the `u1` object:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们下次访问这些对象的属性时，我们将看到为行的主要属性发出的 SELECT，例如当我们查看 `u1` 对象的新生成的主键时：
- en: '[PRE37]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `u1` `User` object now has a persistent collection `User.addresses` that
    we may also access. As this collection consists of an additional set of rows from
    the `address` table, when we access this collection as well we again see a [lazy
    load](../glossary.html#term-lazy-load) emitted in order to retrieve the objects:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 `u1` `User` 对象具有一个持久集合 `User.addresses`，我们也可以访问它。由于此集合包含来自 `address` 表的一组额外行，因此当我们再次访问此集合时，我们会再次看到一个[懒加载](../glossary.html#term-lazy-load)以检索对象：
- en: '[PRE38]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Collections and related attributes in the SQLAlchemy ORM are persistent in
    memory; once the collection or attribute is populated, SQL is no longer emitted
    until that collection or attribute is [expired](../glossary.html#term-expired).
    We may access `u1.addresses` again as well as add or remove items and this will
    not incur any new SQL calls:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy ORM 中的集合和相关属性是在内存中持久存在的；一旦集合或属性被填充，SQL 就不再生成，直到该集合或属性被[过期](../glossary.html#term-expired)。我们可以再次访问
    `u1.addresses`，并添加或删除项目，这不会产生任何新的 SQL 调用：
- en: '[PRE39]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'While the loading emitted by lazy loading can quickly become expensive if we
    don’t take explicit steps to optimize it, the network of lazy loading at least
    is fairly well optimized to not perform redundant work; as the `u1.addresses`
    collection was refreshed, per the [identity map](../glossary.html#term-identity-map)
    these are in fact the same `Address` instances as the `a1` and `a2` objects we’ve
    been dealing with already, so we’re done loading all attributes in this particular
    object graph:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不采取显式步骤来优化懒加载，懒加载引发的加载可能会很快变得昂贵，但至少懒加载的网络相对来说已经相当优化，不会执行冗余工作；因为 `u1.addresses`
    集合已经刷新，根据[标识映射](../glossary.html#term-identity-map)，这些实际上是我们已经处理过的 `a1` 和 `a2`
    对象的同一 `Address` 实例，所以我们已经完成了加载此特定对象图中的所有属性：
- en: '[PRE40]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The issue of how relationships load, or not, is an entire subject onto itself.
    Some additional introduction to these concepts is later in this section at [Loader
    Strategies](#tutorial-orm-loader-strategies).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 关系如何加载或不加载是一个独立的主题。稍后在本节的 [加载器策略](#tutorial-orm-loader-strategies) 中会对这些概念进行一些额外的介绍。
- en: '## Using Relationships in Queries'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '## 在查询中使用关系'
- en: The previous section introduced the behavior of the [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") construct when working with **instances of a mapped
    class**, above, the `u1`, `a1` and `a2` instances of the `User` and `Address`
    classes. In this section, we introduce the behavior of [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") as it applies to **class level behavior of a mapped
    class**, where it serves in several ways to help automate the construction of
    SQL queries.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 前一节介绍了当与**映射类的实例**一起使用时 [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") 构造的行为，上面是 `User` 和 `Address` 类的 `u1`、`a1` 和 `a2`
    实例。在本节中，我们将介绍当应用于**映射类的类级行为**时 [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") 的行为，在这里，它以几种方式帮助自动构建 SQL 查询。
- en: '### Using Relationships to Join'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '### 使用关系进行连接'
- en: The sections [Explicit FROM clauses and JOINs](data_select.html#tutorial-select-join)
    and [Setting the ON Clause](data_select.html#tutorial-select-join-onclause) introduced
    the usage of the [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") and [`Select.join_from()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join_from
    "sqlalchemy.sql.expression.Select.join_from") methods to compose SQL JOIN clauses.
    In order to describe how to join between tables, these methods either **infer**
    the ON clause based on the presence of a single unambiguous [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") object within the table metadata structure
    that links the two tables, or otherwise we may provide an explicit SQL Expression
    construct that indicates a specific ON clause.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '[显式的 FROM 子句和 JOINs](data_select.html#tutorial-select-join) 和 [设置 ON 子句](data_select.html#tutorial-select-join-onclause)
    章节介绍了使用 [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") 和 [`Select.join_from()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join_from
    "sqlalchemy.sql.expression.Select.join_from") 方法来组合 SQL JOIN 子句。为了描述如何在表之间进行连接，这些方法要么**根据表元数据结构中链接两个表的单个明确的
    [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") 对象推断出 ON 子句，要么我们可以提供一个明确的 SQL 表达式构造，指示特定的
    ON 子句。'
- en: 'When using ORM entities, an additional mechanism is available to help us set
    up the ON clause of a join, which is to make use of the [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") objects that we set up in our user mapping, as
    was demonstrated at [Declaring Mapped Classes](metadata.html#tutorial-declaring-mapped-classes).
    The class-bound attribute corresponding to the [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") may be passed as the **single argument** to [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join"), where it serves to indicate both the
    right side of the join as well as the ON clause at once:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 ORM 实体时，有一种额外的机制可帮助我们设置连接的 ON 子句，那就是利用我们在用户映射中设置的[`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")对象，就像在[声明映射类](metadata.html#tutorial-declaring-mapped-classes)中所演示的那样。相应于[`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")的类绑定属性可以作为**单个参数**传递给[`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join")，在这里它同时用于指示连接的右侧以及 ON 子句：
- en: '[PRE41]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The presence of an ORM [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") on a mapping is not used by [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") or [`Select.join_from()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join_from
    "sqlalchemy.sql.expression.Select.join_from") to infer the ON clause if we don’t
    specify it. This means, if we join from `User` to `Address` without an ON clause,
    it works because of the [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") between the two mapped [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects, not because of the [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") objects on the `User` and `Address` classes:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有指定 ON 子句，则映射上的 ORM [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")对 [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") 或 [`Select.join_from()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join_from
    "sqlalchemy.sql.expression.Select.join_from") 的存在不会用于推断 ON 子句。这意味着，如果我们从 `User`
    连接到 `Address` 而没有 ON 子句，这是因为两个映射的 [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") 对象之间的 [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint")，而不是由于 `User` 和 `Address` 类上的 [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") 对象：
- en: '[PRE42]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: See the section [Joins](../orm/queryguide/select.html#orm-queryguide-joins)
    in the [ORM Querying Guide](../orm/queryguide/index.html) for many more examples
    of how to use [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") and [`Select.join_from()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join_from
    "sqlalchemy.sql.expression.Select.join_from") with [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") constructs.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[ORM 查询指南](../orm/queryguide/index.html)中的[连接](../orm/queryguide/select.html#orm-queryguide-joins)一节，了解如何使用
    [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") 和 [`Select.join_from()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join_from
    "sqlalchemy.sql.expression.Select.join_from") 以及 [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") 构造的更多示例。
- en: See also
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Joins](../orm/queryguide/select.html#orm-queryguide-joins) in the [ORM Querying
    Guide](../orm/queryguide/index.html)  ### Relationship WHERE Operators'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '[ORM 查询指南](../orm/queryguide/index.html)中的[连接](../orm/queryguide/select.html#orm-queryguide-joins)  ###
    Relationship WHERE 运算符'
- en: There are some additional varieties of SQL generation helpers that come with
    [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")
    which are typically useful when building up the WHERE clause of a statement. See
    the section [Relationship WHERE Operators](../orm/queryguide/select.html#orm-queryguide-relationship-operators)
    in the [ORM Querying Guide](../orm/queryguide/index.html).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些额外的 SQL 生成辅助程序，随着 [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") 一起提供，当构建语句的 WHERE 子句时通常很有用。请参阅[ORM 查询指南](../orm/queryguide/index.html)中的[Relationship
    WHERE 运算符](../orm/queryguide/select.html#orm-queryguide-relationship-operators)一节。
- en: See also
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Relationship WHERE Operators](../orm/queryguide/select.html#orm-queryguide-relationship-operators)
    in the [ORM Querying Guide](../orm/queryguide/index.html)  ### Using Relationships
    to Join'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '[ORM 查询指南中的关系 WHERE 运算符](../orm/queryguide/select.html#orm-queryguide-relationship-operators)
    ### 使用关系进行连接 在[ORM 查询指南](../orm/queryguide/index.html)'
- en: The sections [Explicit FROM clauses and JOINs](data_select.html#tutorial-select-join)
    and [Setting the ON Clause](data_select.html#tutorial-select-join-onclause) introduced
    the usage of the [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") and [`Select.join_from()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join_from
    "sqlalchemy.sql.expression.Select.join_from") methods to compose SQL JOIN clauses.
    In order to describe how to join between tables, these methods either **infer**
    the ON clause based on the presence of a single unambiguous [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") object within the table metadata structure
    that links the two tables, or otherwise we may provide an explicit SQL Expression
    construct that indicates a specific ON clause.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '[明确的 FROM 子句和 JOIN](data_select.html#tutorial-select-join)和[设置 ON 子句](data_select.html#tutorial-select-join-onclause)部分介绍了使用[`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join")和[`Select.join_from()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join_from
    "sqlalchemy.sql.expression.Select.join_from")方法组成 SQL JOIN 子句的用法。为了描述如何在表之间进行连接，这些方法根据表元数据结构中链接两个表的单一明确[`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint")对象的存在**推断** ON 子句，或者我们可以提供一个明确的 SQL 表达式构造来指示特定的
    ON 子句。'
- en: 'When using ORM entities, an additional mechanism is available to help us set
    up the ON clause of a join, which is to make use of the [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") objects that we set up in our user mapping, as
    was demonstrated at [Declaring Mapped Classes](metadata.html#tutorial-declaring-mapped-classes).
    The class-bound attribute corresponding to the [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") may be passed as the **single argument** to [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join"), where it serves to indicate both the
    right side of the join as well as the ON clause at once:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 ORM 实体时，有一种额外的机制可帮助我们设置连接的 ON 子句，即利用我们在用户映射中设置的[`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")对象，就像在[声明映射类](metadata.html#tutorial-declaring-mapped-classes)中所演示的那样。相应于[`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")的类绑定属性可以作为**单个参数**传递给[`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join")，在这里它既用于指示连接的右侧，又用于一次性指示 ON 子句：
- en: '[PRE43]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The presence of an ORM [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") on a mapping is not used by [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") or [`Select.join_from()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join_from
    "sqlalchemy.sql.expression.Select.join_from") to infer the ON clause if we don’t
    specify it. This means, if we join from `User` to `Address` without an ON clause,
    it works because of the [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") between the two mapped [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects, not because of the [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") objects on the `User` and `Address` classes:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不指定，映射中的 ORM [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")的存在不会被[`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join")或[`Select.join_from()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join_from
    "sqlalchemy.sql.expression.Select.join_from")用于推断 ON 子句。这意味着，如果我们从 `User` 到 `Address`
    进行连接而没有 ON 子句，这是因为两个映射的 [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") 对象之间的 [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint")，而不是 `User` 和 `Address` 类上的 [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") 对象：
- en: '[PRE44]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: See the section [Joins](../orm/queryguide/select.html#orm-queryguide-joins)
    in the [ORM Querying Guide](../orm/queryguide/index.html) for many more examples
    of how to use [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") and [`Select.join_from()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join_from
    "sqlalchemy.sql.expression.Select.join_from") with [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") constructs.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在[ORM查询指南](../orm/queryguide/index.html)中查看[连接（Joins）](../orm/queryguide/select.html#orm-queryguide-joins)部分，了解如何使用[`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join")和[`Select.join_from()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join_from
    "sqlalchemy.sql.expression.Select.join_from")以及[`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")构造的更多示例。
- en: See also
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Joins](../orm/queryguide/select.html#orm-queryguide-joins) in the [ORM Querying
    Guide](../orm/queryguide/index.html)'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '[ORM查询指南](../orm/queryguide/index.html)中的[连接（Joins）](../orm/queryguide/select.html#orm-queryguide-joins)'
- en: '### Relationship WHERE Operators'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '### 关系WHERE运算符'
- en: There are some additional varieties of SQL generation helpers that come with
    [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")
    which are typically useful when building up the WHERE clause of a statement. See
    the section [Relationship WHERE Operators](../orm/queryguide/select.html#orm-queryguide-relationship-operators)
    in the [ORM Querying Guide](../orm/queryguide/index.html).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建语句的WHERE子句时，[`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")还附带了一些其他类型的SQL生成助手，通常在构建过程中非常有用。请查看[ORM查询指南](../orm/queryguide/index.html)中的[关系WHERE运算符](../orm/queryguide/select.html#orm-queryguide-relationship-operators)部分。
- en: See also
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Relationship WHERE Operators](../orm/queryguide/select.html#orm-queryguide-relationship-operators)
    in the [ORM Querying Guide](../orm/queryguide/index.html)'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在[ORM查询指南](../orm/queryguide/index.html)中的[关系WHERE运算符](../orm/queryguide/select.html#orm-queryguide-relationship-operators)部分
- en: '## Loader Strategies'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '## 加载策略'
- en: In the section [Loading Relationships](#tutorial-loading-relationships) we introduced
    the concept that when we work with instances of mapped objects, accessing the
    attributes that are mapped using [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") in the default case will emit a [lazy load](../glossary.html#term-lazy-load)
    when the collection is not populated in order to load the objects that should
    be present in this collection.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在[加载关系](#tutorial-loading-relationships)部分，我们介绍了一个概念，即当我们处理映射对象的实例时，默认情况下访问使用[`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")映射的属性时，如果集合未填充，则会发出[惰性加载](../glossary.html#term-lazy-load)以加载应该存在于此集合中的对象。
- en: Lazy loading is one of the most famous ORM patterns, and is also the one that
    is most controversial. When several dozen ORM objects in memory each refer to
    a handful of unloaded attributes, routine manipulation of these objects can spin
    off many additional queries that can add up (otherwise known as the [N plus one
    problem](../glossary.html#term-N-plus-one-problem)), and to make matters worse
    they are emitted implicitly. These implicit queries may not be noticed, may cause
    errors when they are attempted after there’s no longer a database transaction
    available, or when using alternative concurrency patterns such as [asyncio](../orm/extensions/asyncio.html),
    they actually won’t work at all.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 懒加载是最著名的ORM模式之一，也是最具争议的模式之一。当内存中有几十个ORM对象各自引用了少量未加载的属性时，对这些对象的常规操作可能会产生许多额外的查询，这些查询可能会积累起来（也被称为[N加一问题](../glossary.html#term-N-plus-one-problem)），更糟糕的是它们是隐式生成的。这些隐式查询可能不会被注意到，在没有数据库事务可用时尝试使用它们时可能会导致错误，或者当使用诸如[asyncio](../orm/extensions/asyncio.html)等替代并发模式时，它们实际上根本不起作用。
- en: At the same time, lazy loading is a vastly popular and useful pattern when it
    is compatible with the concurrency approach in use and isn’t otherwise causing
    problems. For these reasons, SQLAlchemy’s ORM places a lot of emphasis on being
    able to control and optimize this loading behavior.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 与此同时，当它与正在使用的并发方法兼容并且没有引起问题时，懒加载是一种非常受欢迎和有用的模式。因此，SQLAlchemy的ORM非常强调能够控制和优化此加载行为。
- en: Above all, the first step in using ORM lazy loading effectively is to **test
    the application, turn on SQL echoing, and watch the SQL that is emitted**. If
    there seem to be lots of redundant SELECT statements that look very much like
    they could be rolled into one much more efficiently, if there are loads occurring
    inappropriately for objects that have been [detached](../glossary.html#term-detached)
    from their [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session"),
    that’s when to look into using **loader strategies**.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是，有效使用 ORM 懒加载的第一步是**测试应用程序，打开 SQL 回显，并观察发出的 SQL 语句**。如果看起来有大量的冗余的 SELECT
    语句，看起来很像它们可以更有效地合并为一个，如果发生了适用于已从其 [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 中分离的对象的不适当的加载，那么就要考虑使用**加载器策略**。
- en: 'Loader strategies are represented as objects that may be associated with a
    SELECT statement using the [`Select.options()`](../core/selectable.html#sqlalchemy.sql.expression.Select.options
    "sqlalchemy.sql.expression.Select.options") method, e.g.:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 加载器策略表示为对象，可以使用 [`Select.options()`](../core/selectable.html#sqlalchemy.sql.expression.Select.options
    "sqlalchemy.sql.expression.Select.options") 方法将其与 SELECT 语句关联，例如：
- en: '[PRE45]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'They may be also configured as defaults for a [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") using the [`relationship.lazy`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.lazy
    "sqlalchemy.orm.relationship") option, e.g.:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以将其配置为 [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") 的默认值，使用 [`relationship.lazy`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.lazy
    "sqlalchemy.orm.relationship") 选项，例如：
- en: '[PRE46]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Each loader strategy object adds some kind of information to the statement that
    will be used later by the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") when it is deciding how various attributes should be
    loaded and/or behave when they are accessed.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 每个加载器策略对象都会向语句添加某种信息，该信息稍后将由 [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 在决定在访问属性时应如何加载和/或行为时使用。
- en: The sections below will introduce a few of the most prominently used loader
    strategies.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的章节将介绍一些最常用的加载器策略。
- en: See also
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'Two sections in [Relationship Loading Techniques](../orm/queryguide/relationships.html):'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '[关系加载技术](../orm/queryguide/relationships.html) 中的两个部分：'
- en: '[Configuring Loader Strategies at Mapping Time](../orm/queryguide/relationships.html#relationship-lazy-option)
    - details on configuring the strategy on [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[在映射时配置加载器策略](../orm/queryguide/relationships.html#relationship-lazy-option)
    - 详细介绍了在 [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") 上配置策略的方法。'
- en: '[Relationship Loading with Loader Options](../orm/queryguide/relationships.html#relationship-loader-options)
    - details on using query-time loader strategies'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[使用加载器选项进行关系加载](../orm/queryguide/relationships.html#relationship-loader-options)
    - 详细介绍了使用查询时加载策略的方法。'
- en: Selectin Load
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Selectin Load
- en: 'The most useful loader in modern SQLAlchemy is the [`selectinload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.selectinload
    "sqlalchemy.orm.selectinload") loader option. This option solves the most common
    form of the “N plus one” problem which is that of a set of objects that refer
    to related collections. [`selectinload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.selectinload
    "sqlalchemy.orm.selectinload") will ensure that a particular collection for a
    full series of objects are loaded up front using a single query. It does this
    using a SELECT form that in most cases can be emitted against the related table
    alone, without the introduction of JOINs or subqueries, and only queries for those
    parent objects for which the collection isn’t already loaded. Below we illustrate
    [`selectinload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.selectinload
    "sqlalchemy.orm.selectinload") by loading all of the `User` objects and all of
    their related `Address` objects; while we invoke [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") only once, given a [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") construct, when the database is accessed,
    there are in fact two SELECT statements emitted, the second one being to fetch
    the related `Address` objects:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代 SQLAlchemy 中最有用的加载器是 [`selectinload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.selectinload
    "sqlalchemy.orm.selectinload") 加载器选项。该选项解决了“N plus one”问题的最常见形式，即一组对象引用相关集合。[`selectinload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.selectinload
    "sqlalchemy.orm.selectinload") 将确保通过单个查询一次性加载一系列对象的特定集合。它使用的 SELECT 形式在大多数情况下可以只针对相关表发出，而不需要引入
    JOIN 或子查询，并且仅查询那些尚未加载集合的父对象。下面我们通过加载所有 `User` 对象及其所有相关的 `Address` 对象来说明 [`selectinload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.selectinload
    "sqlalchemy.orm.selectinload")；虽然我们只调用一次 [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute")，但在访问数据库时实际上发出了两个 SELECT 语句，第二个语句用于获取相关的 `Address`
    对象：
- en: '[PRE47]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: See also
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Select IN loading](../orm/queryguide/relationships.html#selectin-eager-loading)
    - in [Relationship Loading Techniques](../orm/queryguide/relationships.html)'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '[选择 IN 加载](../orm/queryguide/relationships.html#selectin-eager-loading) - 在[关系加载技术](../orm/queryguide/relationships.html)中'
- en: Joined Load
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 联合加载
- en: The [`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload") eager load strategy is the oldest eager loader in
    SQLAlchemy, which augments the SELECT statement that’s being passed to the database
    with a JOIN (which may be an outer or an inner join depending on options), which
    can then load in related objects.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '[`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload") 立即加载策略是 SQLAlchemy 中最古老的立即加载器，它通过将传递给数据库的 SELECT
    语句与 JOIN（取决于选项可能是外连接或内连接）相结合，从而可以加载相关对象。'
- en: 'The [`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload") strategy is best suited towards loading related many-to-one
    objects, as this only requires that additional columns are added to a primary
    entity row that would be fetched in any case. For greater efficiency, it also
    accepts an option [`joinedload.innerjoin`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload.params.innerjoin
    "sqlalchemy.orm.joinedload") so that an inner join instead of an outer join may
    be used for a case such as below where we know that all `Address` objects have
    an associated `User`:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '[`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload") 策略最适合于加载相关的多对一对象，因为这仅需要将额外的列添加到主实体行中，而这些列无论如何都会被获取。为了提高效率，它还接受一个选项
    [`joinedload.innerjoin`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload.params.innerjoin
    "sqlalchemy.orm.joinedload")，以便在我们知道所有 `Address` 对象都有关联的 `User` 的情况下使用内连接而不是外连接：'
- en: '[PRE48]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload") also works for collections, meaning one-to-many relationships,
    however it has the effect of multiplying out primary rows per related item in
    a recursive way that grows the amount of data sent for a result set by orders
    of magnitude for nested collections and/or larger collections, so its use vs.
    another option such as [`selectinload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.selectinload
    "sqlalchemy.orm.selectinload") should be evaluated on a per-case basis.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '[`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload") 也适用于集合，即一对多关系，但它会以递归方式将主要行乘以相关项目，从而使结果集发送的数据量呈数量级增长，对于嵌套集合和/或较大集合，因此应该根据具体情况评估其与其他选项（如[`selectinload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.selectinload
    "sqlalchemy.orm.selectinload")）的使用。'
- en: It’s important to note that the WHERE and ORDER BY criteria of the enclosing
    [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select "sqlalchemy.sql.expression.Select")
    statement **do not target the table rendered by joinedload()**. Above, it can
    be seen in the SQL that an **anonymous alias** is applied to the `user_account`
    table such that is not directly addressable in the query. This concept is discussed
    in more detail in the section [The Zen of Joined Eager Loading](../orm/queryguide/relationships.html#zen-of-eager-loading).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，封闭[`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select")语句的WHERE和ORDER BY条件**不针对joinedload()渲染的表**。在上面的SQL中可以看到，`user_account`表被应用了**匿名别名**，因此在查询中无法直接访问。这个概念在[连接急切加载的禅意](../orm/queryguide/relationships.html#zen-of-eager-loading)部分中有更详细的讨论。
- en: Tip
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: It’s important to note that many-to-one eager loads are often not necessary,
    as the “N plus one” problem is much less prevalent in the common case. When many
    objects all refer to the same related object, such as many `Address` objects that
    each refer to the same `User`, SQL will be emitted only once for that `User` object
    using normal lazy loading. The lazy load routine will look up the related object
    by primary key in the current [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") without emitting any SQL when possible.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，很多对一的急切加载通常是不必要的，因为“N加一”问题在常见情况下不太普遍。当许多对象都引用同一个相关对象时，比如许多`Address`对象都引用同一个`User`时，SQL只会针对该`User`对象正常使用延迟加载而发出一次。延迟加载程序将在当前[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")中通过主键查找相关对象，尽可能不发出任何SQL。
- en: See also
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Joined Eager Loading](../orm/queryguide/relationships.html#joined-eager-loading)
    - in [Relationship Loading Techniques](../orm/queryguide/relationships.html)'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '[连接急切加载](../orm/queryguide/relationships.html#joined-eager-loading) - 在[关系加载技术](../orm/queryguide/relationships.html)中'
- en: '### Explicit Join + Eager load'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '### 显式连接 + 急切加载'
- en: 'If we were to load `Address` rows while joining to the `user_account` table
    using a method such as [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") to render the JOIN, we could also leverage
    that JOIN in order to eagerly load the contents of the `Address.user` attribute
    on each `Address` object returned. This is essentially that we are using “joined
    eager loading” but rendering the JOIN ourselves. This common use case is achieved
    by using the [`contains_eager()`](../orm/queryguide/relationships.html#sqlalchemy.orm.contains_eager
    "sqlalchemy.orm.contains_eager") option. This option is very similar to [`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload"), except that it assumes we have set up the JOIN ourselves,
    and it instead only indicates that additional columns in the COLUMNS clause should
    be loaded into related attributes on each returned object, for example:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在连接到`user_account`表时加载`Address`行，使用诸如[`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join")之类的方法来渲染JOIN，我们还可以利用该JOIN来急切加载每个返回的`Address`对象上的`Address.user`属性的内容。这本质上是我们在使用“连接急切加载”，但自己渲染JOIN。通过使用[`contains_eager()`](../orm/queryguide/relationships.html#sqlalchemy.orm.contains_eager
    "sqlalchemy.orm.contains_eager")选项来实现这种常见用例。该选项与[`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload")非常相似，只是它假设我们自己设置了JOIN，并且它只表示应该将COLUMNS子句中的附加列加载到每个返回对象的相关属性中，例如：
- en: '[PRE49]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Above, we both filtered the rows on `user_account.name` and also loaded rows
    from `user_account` into the `Address.user` attribute of the returned rows. If
    we had applied [`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload") separately, we would get a SQL query that unnecessarily
    joins twice:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，我们既过滤了`user_account.name`的行，也将`user_account`的行加载到返回行的`Address.user`属性中。如果我们单独应用了[`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload")，我们将得到一个不必要两次连接的SQL查询：
- en: '[PRE50]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: See also
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅
- en: 'Two sections in [Relationship Loading Techniques](../orm/queryguide/relationships.html):'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '[关系加载技术](../orm/queryguide/relationships.html)中的两个部分：'
- en: '[The Zen of Joined Eager Loading](../orm/queryguide/relationships.html#zen-of-eager-loading)
    - describes the above problem in detail'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[连接式预加载的禅意](../orm/queryguide/relationships.html#zen-of-eager-loading) - 详细描述了上述问题'
- en: '[Routing Explicit Joins/Statements into Eagerly Loaded Collections](../orm/queryguide/relationships.html#contains-eager)
    - using [`contains_eager()`](../orm/queryguide/relationships.html#sqlalchemy.orm.contains_eager
    "sqlalchemy.orm.contains_eager")'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[将显式连接/语句路由到已预加载的集合](../orm/queryguide/relationships.html#contains-eager) -
    使用[`contains_eager()`](../orm/queryguide/relationships.html#sqlalchemy.orm.contains_eager
    "sqlalchemy.orm.contains_eager")'
- en: Raiseload
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Raiseload
- en: One additional loader strategy worth mentioning is [`raiseload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.raiseload
    "sqlalchemy.orm.raiseload"). This option is used to completely block an application
    from having the [N plus one](../glossary.html#term-N-plus-one) problem at all
    by causing what would normally be a lazy load to raise an error instead. It has
    two variants that are controlled via the [`raiseload.sql_only`](../orm/queryguide/relationships.html#sqlalchemy.orm.raiseload.params.sql_only
    "sqlalchemy.orm.raiseload") option to block either lazy loads that require SQL,
    versus all “load” operations including those which only need to consult the current
    [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session").
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的一个额外的加载器策略是[`raiseload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.raiseload
    "sqlalchemy.orm.raiseload")。此选项用于通过导致通常是惰性加载的操作引发错误，从而完全阻止应用程序遇到[N加1](../glossary.html#term-N-plus-one)问题。它有两个变体，通过[`raiseload.sql_only`](../orm/queryguide/relationships.html#sqlalchemy.orm.raiseload.params.sql_only
    "sqlalchemy.orm.raiseload")选项进行控制，以阻止仅需要SQL的惰性加载，以及所有“加载”操作，包括仅需要查询当前[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")的操作。
- en: 'One way to use [`raiseload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.raiseload
    "sqlalchemy.orm.raiseload") is to configure it on [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") itself, by setting [`relationship.lazy`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.lazy
    "sqlalchemy.orm.relationship") to the value `"raise_on_sql"`, so that for a particular
    mapping, a certain relationship will never try to emit SQL:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[`raiseload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.raiseload
    "sqlalchemy.orm.raiseload")的一种方法是在[`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")本身上进行配置，通过将[`relationship.lazy`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.lazy
    "sqlalchemy.orm.relationship")设置为值`"raise_on_sql"`，以便对于特定映射，某个关系永远不会尝试发出SQL：
- en: '[PRE51]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Using such a mapping, the application is blocked from lazy loading, indicating
    that a particular query would need to specify a loader strategy:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这样的映射，应用程序被阻止了惰性加载，表示特定查询需要指定加载器策略：
- en: '[PRE52]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The exception would indicate that this collection should be loaded up front
    instead:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 异常会指示应该预先加载此集合：
- en: '[PRE53]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The `lazy="raise_on_sql"` option tries to be smart about many-to-one relationships
    as well; above, if the `Address.user` attribute of an `Address` object were not
    loaded, but that `User` object were locally present in the same [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), the “raiseload” strategy would not raise an error.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`lazy="raise_on_sql"`选项也试图对多对一关系变得更加智能；在上面的例子中，如果`Address`对象的`Address.user`属性未加载，但是`User`对象在同一个[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")中是本地存在的，那么“raiseload”策略就不会引发错误。'
- en: See also
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅
- en: '[Preventing unwanted lazy loads using raiseload](../orm/queryguide/relationships.html#prevent-lazy-with-raiseload)
    - in [Relationship Loading Techniques](../orm/queryguide/relationships.html)'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用raiseload防止不必要的惰性加载](../orm/queryguide/relationships.html#prevent-lazy-with-raiseload)
    - 在[关系加载技术](../orm/queryguide/relationships.html)中'
- en: Selectin Load
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Selectin Load
- en: 'The most useful loader in modern SQLAlchemy is the [`selectinload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.selectinload
    "sqlalchemy.orm.selectinload") loader option. This option solves the most common
    form of the “N plus one” problem which is that of a set of objects that refer
    to related collections. [`selectinload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.selectinload
    "sqlalchemy.orm.selectinload") will ensure that a particular collection for a
    full series of objects are loaded up front using a single query. It does this
    using a SELECT form that in most cases can be emitted against the related table
    alone, without the introduction of JOINs or subqueries, and only queries for those
    parent objects for which the collection isn’t already loaded. Below we illustrate
    [`selectinload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.selectinload
    "sqlalchemy.orm.selectinload") by loading all of the `User` objects and all of
    their related `Address` objects; while we invoke [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") only once, given a [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") construct, when the database is accessed,
    there are in fact two SELECT statements emitted, the second one being to fetch
    the related `Address` objects:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代 SQLAlchemy 中最有用的加载器是 [`selectinload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.selectinload
    "sqlalchemy.orm.selectinload") 加载器选项。该选项解决了“N加一”问题的最常见形式，即一组对象引用相关集合的问题。[`selectinload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.selectinload
    "sqlalchemy.orm.selectinload") 将确保一系列对象的特定集合通过单个查询提前加载。它使用一个 SELECT 形式，在大多数情况下可以针对相关表单独发出，而无需引入
    JOIN 或子查询，并且仅查询那些集合尚未加载的父对象。下面我们通过加载所有的 `User` 对象及其所有相关的 `Address` 对象来说明 [`selectinload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.selectinload
    "sqlalchemy.orm.selectinload")；虽然我们只调用一次 [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute")，给定一个 [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") 构造，在访问数据库时，实际上会发出两个 SELECT 语句，第二个用于获取相关的 `Address`
    对象：
- en: '[PRE54]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: See also
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 另见
- en: '[Select IN loading](../orm/queryguide/relationships.html#selectin-eager-loading)
    - in [Relationship Loading Techniques](../orm/queryguide/relationships.html)'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '[选择 IN 加载](../orm/queryguide/relationships.html#selectin-eager-loading) - 在[关系加载技术](../orm/queryguide/relationships.html)中'
- en: Joined Load
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 加载连接
- en: The [`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload") eager load strategy is the oldest eager loader in
    SQLAlchemy, which augments the SELECT statement that’s being passed to the database
    with a JOIN (which may be an outer or an inner join depending on options), which
    can then load in related objects.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '[`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload") 预加载策略是 SQLAlchemy 中最古老的预加载器，它通过在传递给数据库的 SELECT 语句中添加
    JOIN（根据选项可能是外连接或内连接）来增强查询，然后可以加载相关联的对象。'
- en: 'The [`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload") strategy is best suited towards loading related many-to-one
    objects, as this only requires that additional columns are added to a primary
    entity row that would be fetched in any case. For greater efficiency, it also
    accepts an option [`joinedload.innerjoin`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload.params.innerjoin
    "sqlalchemy.orm.joinedload") so that an inner join instead of an outer join may
    be used for a case such as below where we know that all `Address` objects have
    an associated `User`:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '[`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload") 策略最适合加载相关的一对多对象，因为这只需要向主实体行添加额外的列，这些列无论如何都会被检索。为了提高效率，它还接受一个选项
    [`joinedload.innerjoin`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload.params.innerjoin
    "sqlalchemy.orm.joinedload")，以便在下面这种情况下使用内连接而不是外连接，我们知道所有 `Address` 对象都有一个关联的
    `User`：'
- en: '[PRE55]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload") also works for collections, meaning one-to-many relationships,
    however it has the effect of multiplying out primary rows per related item in
    a recursive way that grows the amount of data sent for a result set by orders
    of magnitude for nested collections and/or larger collections, so its use vs.
    another option such as [`selectinload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.selectinload
    "sqlalchemy.orm.selectinload") should be evaluated on a per-case basis.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '[`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload")也适用于集合，意味着一对多关系，但是它会以递归方式将主要行乘以相关项目，这样会使结果集发送的数据量呈数量级增长，用于嵌套集合和/或较大集合的情况下，应该根据情况评估其与其他选项（例如[`selectinload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.selectinload
    "sqlalchemy.orm.selectinload")）的使用情况。'
- en: It’s important to note that the WHERE and ORDER BY criteria of the enclosing
    [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select "sqlalchemy.sql.expression.Select")
    statement **do not target the table rendered by joinedload()**. Above, it can
    be seen in the SQL that an **anonymous alias** is applied to the `user_account`
    table such that is not directly addressable in the query. This concept is discussed
    in more detail in the section [The Zen of Joined Eager Loading](../orm/queryguide/relationships.html#zen-of-eager-loading).
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，封闭[`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select")语句的WHERE和ORDER BY条件**不会针对joinedload()渲染的表**。如上所述，在SQL中可以看到对`user_account`表应用了**匿名别名**，因此无法直接在查询中进行地址定位。这个概念在
    [联接式预加载之禅](../orm/queryguide/relationships.html#zen-of-eager-loading) 部分中有更详细的讨论。
- en: Tip
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: It’s important to note that many-to-one eager loads are often not necessary,
    as the “N plus one” problem is much less prevalent in the common case. When many
    objects all refer to the same related object, such as many `Address` objects that
    each refer to the same `User`, SQL will be emitted only once for that `User` object
    using normal lazy loading. The lazy load routine will look up the related object
    by primary key in the current [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") without emitting any SQL when possible.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，往往不必要进行多对一的急切加载，因为在常见情况下，“N加一”问题不太普遍。当许多对象都引用同一个相关对象时，例如每个引用同一个`User`的许多`Address`对象时，SQL将仅一次对该`User`对象使用正常的延迟加载。延迟加载程序将尽可能地在当前[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")中通过主键查找相关对象，而不会在可能时发出任何SQL。
- en: See also
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 请参见
- en: '[Joined Eager Loading](../orm/queryguide/relationships.html#joined-eager-loading)
    - in [Relationship Loading Techniques](../orm/queryguide/relationships.html)'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '[联接式预加载](../orm/queryguide/relationships.html#joined-eager-loading) - 在 [关系加载技术](../orm/queryguide/relationships.html)
    中'
- en: '### Explicit Join + Eager load'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '### 显式连接 + 急切加载'
- en: 'If we were to load `Address` rows while joining to the `user_account` table
    using a method such as [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") to render the JOIN, we could also leverage
    that JOIN in order to eagerly load the contents of the `Address.user` attribute
    on each `Address` object returned. This is essentially that we are using “joined
    eager loading” but rendering the JOIN ourselves. This common use case is achieved
    by using the [`contains_eager()`](../orm/queryguide/relationships.html#sqlalchemy.orm.contains_eager
    "sqlalchemy.orm.contains_eager") option. This option is very similar to [`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload"), except that it assumes we have set up the JOIN ourselves,
    and it instead only indicates that additional columns in the COLUMNS clause should
    be loaded into related attributes on each returned object, for example:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在连接到`user_account`表时加载`Address`行，使用诸如[`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join")之类的方法来渲染连接，我们还可以利用该连接以便在每个返回的`Address`对象上急切加载`Address.user`属性的内容。这本质上是我们正在使用“联接式预加载”，但是自己渲染连接。通过使用[`contains_eager()`](../orm/queryguide/relationships.html#sqlalchemy.orm.contains_eager
    "sqlalchemy.orm.contains_eager")选项实现了这种常见用例。该选项与[`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload")非常相似，只是它假设我们已经自己设置了连接，并且它仅指示应该将COLUMNS子句中的其他列加载到每个返回对象的相关属性中，例如：
- en: '[PRE56]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Above, we both filtered the rows on `user_account.name` and also loaded rows
    from `user_account` into the `Address.user` attribute of the returned rows. If
    we had applied [`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload") separately, we would get a SQL query that unnecessarily
    joins twice:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述示例中，我们同时对 `user_account.name` 进行了行过滤，并将 `user_account` 的行加载到返回行的 `Address.user`
    属性中。如果我们分别应用了 [`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload")，我们会得到一个不必要地两次连接的 SQL 查询：
- en: '[PRE57]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: See also
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: 'Two sections in [Relationship Loading Techniques](../orm/queryguide/relationships.html):'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '[关系加载技术](../orm/queryguide/relationships.html) 中的两个部分：'
- en: '[The Zen of Joined Eager Loading](../orm/queryguide/relationships.html#zen-of-eager-loading)
    - describes the above problem in detail'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[急切加载的禅意](../orm/queryguide/relationships.html#zen-of-eager-loading) - 详细描述了上述问题'
- en: '[Routing Explicit Joins/Statements into Eagerly Loaded Collections](../orm/queryguide/relationships.html#contains-eager)
    - using [`contains_eager()`](../orm/queryguide/relationships.html#sqlalchemy.orm.contains_eager
    "sqlalchemy.orm.contains_eager")'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[将显式连接/语句路由到急切加载的集合中](../orm/queryguide/relationships.html#contains-eager)
    - 使用 [`contains_eager()`](../orm/queryguide/relationships.html#sqlalchemy.orm.contains_eager
    "sqlalchemy.orm.contains_eager")'
- en: Raiseload
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Raiseload
- en: One additional loader strategy worth mentioning is [`raiseload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.raiseload
    "sqlalchemy.orm.raiseload"). This option is used to completely block an application
    from having the [N plus one](../glossary.html#term-N-plus-one) problem at all
    by causing what would normally be a lazy load to raise an error instead. It has
    two variants that are controlled via the [`raiseload.sql_only`](../orm/queryguide/relationships.html#sqlalchemy.orm.raiseload.params.sql_only
    "sqlalchemy.orm.raiseload") option to block either lazy loads that require SQL,
    versus all “load” operations including those which only need to consult the current
    [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session").
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 还值得一提的一种额外的加载策略是 [`raiseload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.raiseload
    "sqlalchemy.orm.raiseload")。该选项用于通过使通常会产生惰性加载的操作引发错误来完全阻止应用程序出现 [N 加一](../glossary.html#term-N-plus-one)
    问题。它有两种变体，通过 [`raiseload.sql_only`](../orm/queryguide/relationships.html#sqlalchemy.orm.raiseload.params.sql_only
    "sqlalchemy.orm.raiseload") 选项进行控制，以阻止需要 SQL 的惰性加载，或者包括那些只需查询当前 [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 的“加载”操作。
- en: 'One way to use [`raiseload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.raiseload
    "sqlalchemy.orm.raiseload") is to configure it on [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") itself, by setting [`relationship.lazy`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.lazy
    "sqlalchemy.orm.relationship") to the value `"raise_on_sql"`, so that for a particular
    mapping, a certain relationship will never try to emit SQL:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 [`raiseload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.raiseload
    "sqlalchemy.orm.raiseload") 的一种方法是在 [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") 上直接配置它，通过将 [`relationship.lazy`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.lazy
    "sqlalchemy.orm.relationship") 设置为值 `"raise_on_sql"`，这样对于特定映射，某个关系将永远不会尝试发出 SQL：
- en: '[PRE58]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Using such a mapping, the application is blocked from lazy loading, indicating
    that a particular query would need to specify a loader strategy:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这样的映射，应用程序被阻止惰性加载，指示特定查询需要指定加载策略：
- en: '[PRE59]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The exception would indicate that this collection should be loaded up front
    instead:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 异常会指示应该立即加载此集合：
- en: '[PRE60]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The `lazy="raise_on_sql"` option tries to be smart about many-to-one relationships
    as well; above, if the `Address.user` attribute of an `Address` object were not
    loaded, but that `User` object were locally present in the same [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), the “raiseload” strategy would not raise an error.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '`lazy="raise_on_sql"` 选项还尝试智能处理多对一关系；在上述示例中，如果 `Address` 对象的 `Address.user`
    属性没有加载，但是该 `User` 对象在同一个 [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 中本地存在，则“raiseload”策略不会引发错误。'
- en: See also
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Preventing unwanted lazy loads using raiseload](../orm/queryguide/relationships.html#prevent-lazy-with-raiseload)
    - in [Relationship Loading Techniques](../orm/queryguide/relationships.html)'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用 raiseload 防止不必要的惰性加载](../orm/queryguide/relationships.html#prevent-lazy-with-raiseload)
    - 在 [关系加载技术](../orm/queryguide/relationships.html) 中'
