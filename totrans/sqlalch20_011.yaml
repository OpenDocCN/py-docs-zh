- en: Working with ORM Related Objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.sqlalchemy.org/en/20/tutorial/orm_related_objects.html](https://docs.sqlalchemy.org/en/20/tutorial/orm_related_objects.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In this section, we will cover one more essential ORM concept, which is how
    the ORM interacts with mapped classes that refer to other objects. In the section
    [Declaring Mapped Classes](metadata.html#tutorial-declaring-mapped-classes), the
    mapped class examples made use of a construct called [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship"). This construct defines a linkage between two different
    mapped classes, or from a mapped class to itself, the latter of which is called
    a **self-referential** relationship.
  prefs: []
  type: TYPE_NORMAL
- en: 'To describe the basic idea of [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship"), first we’ll review the mapping in short form,
    omitting the [`mapped_column()`](../orm/mapping_api.html#sqlalchemy.orm.mapped_column
    "sqlalchemy.orm.mapped_column") mappings and other directives:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Above, the `User` class now has an attribute `User.addresses` and the `Address`
    class has an attribute `Address.user`. The [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") construct, in conjunction with the [`Mapped`](../orm/internals.html#sqlalchemy.orm.Mapped
    "sqlalchemy.orm.Mapped") construct to indicate typing behavior, will be used to
    inspect the table relationships between the [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects that are mapped to the `User` and `Address`
    classes. As the [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    object representing the `address` table has a [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") which refers to the `user_account` table,
    the [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") can determine unambiguously that there is a [one
    to many](../glossary.html#term-one-to-many) relationship from the `User` class
    to the `Address` class, along the `User.addresses` relationship; one particular
    row in the `user_account` table may be referenced by many rows in the `address`
    table.
  prefs: []
  type: TYPE_NORMAL
- en: All one-to-many relationships naturally correspond to a [many to one](../glossary.html#term-many-to-one)
    relationship in the other direction, in this case the one noted by `Address.user`.
    The [`relationship.back_populates`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.back_populates
    "sqlalchemy.orm.relationship") parameter, seen above configured on both [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") objects referring to the other name, establishes
    that each of these two [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") constructs should be considered to be complimentary
    to each other; we will see how this plays out in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Persisting and Loading Relationships
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can start by illustrating what [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") does to instances of objects. If we make a new
    `User` object, we can note that there is a Python list when we access the `.addresses`
    element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This object is a SQLAlchemy-specific version of Python `list` which has the
    ability to track and respond to changes made to it. The collection also appeared
    automatically when we accessed the attribute, even though we never assigned it
    to the object. This is similar to the behavior noted at [Inserting Rows using
    the ORM Unit of Work pattern](orm_data_manipulation.html#tutorial-inserting-orm)
    where it was observed that column-based attributes to which we don’t explicitly
    assign a value also display as `None` automatically, rather than raising an `AttributeError`
    as would be Python’s usual behavior.
  prefs: []
  type: TYPE_NORMAL
- en: As the `u1` object is still [transient](../glossary.html#term-transient) and
    the `list` that we got from `u1.addresses` has not been mutated (i.e. appended
    or extended), it’s not actually associated with the object yet, but as we make
    changes to it, it will become part of the state of the `User` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The collection is specific to the `Address` class which is the only type of
    Python object that may be persisted within it. Using the `list.append()` method
    we may add an `Address` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, the `u1.addresses` collection as expected contains the new `Address`
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'As we associated the `Address` object with the `User.addresses` collection
    of the `u1` instance, another behavior also occurred, which is that the `User.addresses`
    relationship synchronized itself with the `Address.user` relationship, such that
    we can navigate not only from the `User` object to the `Address` object, we can
    also navigate from the `Address` object back to the “parent” `User` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This synchronization occurred as a result of our use of the [`relationship.back_populates`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.back_populates
    "sqlalchemy.orm.relationship") parameter between the two [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") objects. This parameter names another [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") for which complementary attribute assignment /
    list mutation should occur. It will work equally well in the other direction,
    which is that if we create another `Address` object and assign to its `Address.user`
    attribute, that `Address` becomes part of the `User.addresses` collection on that
    `User` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We actually made use of the `user` parameter as a keyword argument in the `Address`
    constructor, which is accepted just like any other mapped attribute that was declared
    on the `Address` class. It is equivalent to assignment of the `Address.user` attribute
    after the fact:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '### Cascading Objects into the Session'
  prefs: []
  type: TYPE_NORMAL
- en: We now have a `User` and two `Address` objects that are associated in a bidirectional
    structure in memory, but as noted previously in [Inserting Rows using the ORM
    Unit of Work pattern](orm_data_manipulation.html#tutorial-inserting-orm) , these
    objects are said to be in the [transient](../glossary.html#term-transient) state
    until they are associated with a [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") object.
  prefs: []
  type: TYPE_NORMAL
- en: 'We make use of the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") that’s still ongoing, and note that when we apply the
    [`Session.add()`](../orm/session_api.html#sqlalchemy.orm.Session.add "sqlalchemy.orm.Session.add")
    method to the lead `User` object, the related `Address` object also gets added
    to that same [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The above behavior, where the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") received a `User` object, and followed along the `User.addresses`
    relationship to locate a related `Address` object, is known as the **save-update
    cascade** and is discussed in detail in the ORM reference documentation at [Cascades](../orm/cascades.html#unitofwork-cascades).
  prefs: []
  type: TYPE_NORMAL
- en: 'The three objects are now in the [pending](../glossary.html#term-pending) state;
    this means they are ready to be the subject of an INSERT operation but this has
    not yet proceeded; all three objects have no primary key assigned yet, and in
    addition, the `a1` and `a2` objects have an attribute called `user_id` which refers
    to the [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    that has a [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") referring to the `user_account.id` column;
    these are also `None` as the objects are not yet associated with a real database
    row:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: It’s at this stage that we can see the very great utility that the unit of work
    process provides; recall in the section [INSERT usually generates the “values”
    clause automatically](data_insert.html#tutorial-core-insert-values-clause), rows
    were inserted into the `user_account` and `address` tables using some elaborate
    syntaxes in order to automatically associate the `address.user_id` columns with
    those of the `user_account` rows. Additionally, it was necessary that we emit
    INSERT for `user_account` rows first, before those of `address`, since rows in
    `address` are **dependent** on their parent row in `user_account` for a value
    in their `user_id` column.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session"),
    all this tedium is handled for us and even the most die-hard SQL purist can benefit
    from automation of INSERT, UPDATE and DELETE statements. When we [`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") the transaction all steps invoke in the correct
    order, and furthermore the newly generated primary key of the `user_account` row
    is applied to the `address.user_id` column appropriately:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]  ## Loading Relationships'
  prefs: []
  type: TYPE_NORMAL
- en: In the last step, we called [`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") which emitted a COMMIT for the transaction, and
    then per [`Session.commit.expire_on_commit`](../orm/session_api.html#sqlalchemy.orm.Session.commit.params.expire_on_commit
    "sqlalchemy.orm.Session.commit") expired all objects so that they refresh for
    the next transaction.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we next access an attribute on these objects, we’ll see the SELECT emitted
    for the primary attributes of the row, such as when we view the newly generated
    primary key for the `u1` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `u1` `User` object now has a persistent collection `User.addresses` that
    we may also access. As this collection consists of an additional set of rows from
    the `address` table, when we access this collection as well we again see a [lazy
    load](../glossary.html#term-lazy-load) emitted in order to retrieve the objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Collections and related attributes in the SQLAlchemy ORM are persistent in
    memory; once the collection or attribute is populated, SQL is no longer emitted
    until that collection or attribute is [expired](../glossary.html#term-expired).
    We may access `u1.addresses` again as well as add or remove items and this will
    not incur any new SQL calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'While the loading emitted by lazy loading can quickly become expensive if we
    don’t take explicit steps to optimize it, the network of lazy loading at least
    is fairly well optimized to not perform redundant work; as the `u1.addresses`
    collection was refreshed, per the [identity map](../glossary.html#term-identity-map)
    these are in fact the same `Address` instances as the `a1` and `a2` objects we’ve
    been dealing with already, so we’re done loading all attributes in this particular
    object graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The issue of how relationships load, or not, is an entire subject onto itself.
    Some additional introduction to these concepts is later in this section at [Loader
    Strategies](#tutorial-orm-loader-strategies).  ## Using Relationships in Queries'
  prefs: []
  type: TYPE_NORMAL
- en: The previous section introduced the behavior of the [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") construct when working with **instances of a mapped
    class**, above, the `u1`, `a1` and `a2` instances of the `User` and `Address`
    classes. In this section, we introduce the behavior of [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") as it applies to **class level behavior of a mapped
    class**, where it serves in several ways to help automate the construction of
    SQL queries.
  prefs: []
  type: TYPE_NORMAL
- en: '### Using Relationships to Join'
  prefs: []
  type: TYPE_NORMAL
- en: The sections [Explicit FROM clauses and JOINs](data_select.html#tutorial-select-join)
    and [Setting the ON Clause](data_select.html#tutorial-select-join-onclause) introduced
    the usage of the [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") and [`Select.join_from()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join_from
    "sqlalchemy.sql.expression.Select.join_from") methods to compose SQL JOIN clauses.
    In order to describe how to join between tables, these methods either **infer**
    the ON clause based on the presence of a single unambiguous [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") object within the table metadata structure
    that links the two tables, or otherwise we may provide an explicit SQL Expression
    construct that indicates a specific ON clause.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using ORM entities, an additional mechanism is available to help us set
    up the ON clause of a join, which is to make use of the [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") objects that we set up in our user mapping, as
    was demonstrated at [Declaring Mapped Classes](metadata.html#tutorial-declaring-mapped-classes).
    The class-bound attribute corresponding to the [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") may be passed as the **single argument** to [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join"), where it serves to indicate both the
    right side of the join as well as the ON clause at once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The presence of an ORM [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") on a mapping is not used by [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") or [`Select.join_from()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join_from
    "sqlalchemy.sql.expression.Select.join_from") to infer the ON clause if we don’t
    specify it. This means, if we join from `User` to `Address` without an ON clause,
    it works because of the [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") between the two mapped [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects, not because of the [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") objects on the `User` and `Address` classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: See the section [Joins](../orm/queryguide/select.html#orm-queryguide-joins)
    in the [ORM Querying Guide](../orm/queryguide/index.html) for many more examples
    of how to use [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") and [`Select.join_from()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join_from
    "sqlalchemy.sql.expression.Select.join_from") with [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") constructs.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Joins](../orm/queryguide/select.html#orm-queryguide-joins) in the [ORM Querying
    Guide](../orm/queryguide/index.html)  ### Relationship WHERE Operators'
  prefs: []
  type: TYPE_NORMAL
- en: There are some additional varieties of SQL generation helpers that come with
    [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")
    which are typically useful when building up the WHERE clause of a statement. See
    the section [Relationship WHERE Operators](../orm/queryguide/select.html#orm-queryguide-relationship-operators)
    in the [ORM Querying Guide](../orm/queryguide/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Relationship WHERE Operators](../orm/queryguide/select.html#orm-queryguide-relationship-operators)
    in the [ORM Querying Guide](../orm/queryguide/index.html)  ## Loader Strategies'
  prefs: []
  type: TYPE_NORMAL
- en: In the section [Loading Relationships](#tutorial-loading-relationships) we introduced
    the concept that when we work with instances of mapped objects, accessing the
    attributes that are mapped using [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") in the default case will emit a [lazy load](../glossary.html#term-lazy-load)
    when the collection is not populated in order to load the objects that should
    be present in this collection.
  prefs: []
  type: TYPE_NORMAL
- en: Lazy loading is one of the most famous ORM patterns, and is also the one that
    is most controversial. When several dozen ORM objects in memory each refer to
    a handful of unloaded attributes, routine manipulation of these objects can spin
    off many additional queries that can add up (otherwise known as the [N plus one
    problem](../glossary.html#term-N-plus-one-problem)), and to make matters worse
    they are emitted implicitly. These implicit queries may not be noticed, may cause
    errors when they are attempted after there’s no longer a database transaction
    available, or when using alternative concurrency patterns such as [asyncio](../orm/extensions/asyncio.html),
    they actually won’t work at all.
  prefs: []
  type: TYPE_NORMAL
- en: At the same time, lazy loading is a vastly popular and useful pattern when it
    is compatible with the concurrency approach in use and isn’t otherwise causing
    problems. For these reasons, SQLAlchemy’s ORM places a lot of emphasis on being
    able to control and optimize this loading behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Above all, the first step in using ORM lazy loading effectively is to **test
    the application, turn on SQL echoing, and watch the SQL that is emitted**. If
    there seem to be lots of redundant SELECT statements that look very much like
    they could be rolled into one much more efficiently, if there are loads occurring
    inappropriately for objects that have been [detached](../glossary.html#term-detached)
    from their [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session"),
    that’s when to look into using **loader strategies**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Loader strategies are represented as objects that may be associated with a
    SELECT statement using the [`Select.options()`](../core/selectable.html#sqlalchemy.sql.expression.Select.options
    "sqlalchemy.sql.expression.Select.options") method, e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'They may be also configured as defaults for a [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") using the [`relationship.lazy`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.lazy
    "sqlalchemy.orm.relationship") option, e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Each loader strategy object adds some kind of information to the statement that
    will be used later by the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") when it is deciding how various attributes should be
    loaded and/or behave when they are accessed.
  prefs: []
  type: TYPE_NORMAL
- en: The sections below will introduce a few of the most prominently used loader
    strategies.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: 'Two sections in [Relationship Loading Techniques](../orm/queryguide/relationships.html):'
  prefs: []
  type: TYPE_NORMAL
- en: '[Configuring Loader Strategies at Mapping Time](../orm/queryguide/relationships.html#relationship-lazy-option)
    - details on configuring the strategy on [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Relationship Loading with Loader Options](../orm/queryguide/relationships.html#relationship-loader-options)
    - details on using query-time loader strategies'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selectin Load
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The most useful loader in modern SQLAlchemy is the [`selectinload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.selectinload
    "sqlalchemy.orm.selectinload") loader option. This option solves the most common
    form of the “N plus one” problem which is that of a set of objects that refer
    to related collections. [`selectinload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.selectinload
    "sqlalchemy.orm.selectinload") will ensure that a particular collection for a
    full series of objects are loaded up front using a single query. It does this
    using a SELECT form that in most cases can be emitted against the related table
    alone, without the introduction of JOINs or subqueries, and only queries for those
    parent objects for which the collection isn’t already loaded. Below we illustrate
    [`selectinload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.selectinload
    "sqlalchemy.orm.selectinload") by loading all of the `User` objects and all of
    their related `Address` objects; while we invoke [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") only once, given a [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") construct, when the database is accessed,
    there are in fact two SELECT statements emitted, the second one being to fetch
    the related `Address` objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Select IN loading](../orm/queryguide/relationships.html#selectin-eager-loading)
    - in [Relationship Loading Techniques](../orm/queryguide/relationships.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Joined Load
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The [`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload") eager load strategy is the oldest eager loader in
    SQLAlchemy, which augments the SELECT statement that’s being passed to the database
    with a JOIN (which may be an outer or an inner join depending on options), which
    can then load in related objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload") strategy is best suited towards loading related many-to-one
    objects, as this only requires that additional columns are added to a primary
    entity row that would be fetched in any case. For greater efficiency, it also
    accepts an option [`joinedload.innerjoin`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload.params.innerjoin
    "sqlalchemy.orm.joinedload") so that an inner join instead of an outer join may
    be used for a case such as below where we know that all `Address` objects have
    an associated `User`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload") also works for collections, meaning one-to-many relationships,
    however it has the effect of multiplying out primary rows per related item in
    a recursive way that grows the amount of data sent for a result set by orders
    of magnitude for nested collections and/or larger collections, so its use vs.
    another option such as [`selectinload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.selectinload
    "sqlalchemy.orm.selectinload") should be evaluated on a per-case basis.'
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note that the WHERE and ORDER BY criteria of the enclosing
    [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select "sqlalchemy.sql.expression.Select")
    statement **do not target the table rendered by joinedload()**. Above, it can
    be seen in the SQL that an **anonymous alias** is applied to the `user_account`
    table such that is not directly addressable in the query. This concept is discussed
    in more detail in the section [The Zen of Joined Eager Loading](../orm/queryguide/relationships.html#zen-of-eager-loading).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note that many-to-one eager loads are often not necessary,
    as the “N plus one” problem is much less prevalent in the common case. When many
    objects all refer to the same related object, such as many `Address` objects that
    each refer to the same `User`, SQL will be emitted only once for that `User` object
    using normal lazy loading. The lazy load routine will look up the related object
    by primary key in the current [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") without emitting any SQL when possible.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Joined Eager Loading](../orm/queryguide/relationships.html#joined-eager-loading)
    - in [Relationship Loading Techniques](../orm/queryguide/relationships.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Explicit Join + Eager load'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we were to load `Address` rows while joining to the `user_account` table
    using a method such as [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") to render the JOIN, we could also leverage
    that JOIN in order to eagerly load the contents of the `Address.user` attribute
    on each `Address` object returned. This is essentially that we are using “joined
    eager loading” but rendering the JOIN ourselves. This common use case is achieved
    by using the [`contains_eager()`](../orm/queryguide/relationships.html#sqlalchemy.orm.contains_eager
    "sqlalchemy.orm.contains_eager") option. This option is very similar to [`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload"), except that it assumes we have set up the JOIN ourselves,
    and it instead only indicates that additional columns in the COLUMNS clause should
    be loaded into related attributes on each returned object, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Above, we both filtered the rows on `user_account.name` and also loaded rows
    from `user_account` into the `Address.user` attribute of the returned rows. If
    we had applied [`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload") separately, we would get a SQL query that unnecessarily
    joins twice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: 'Two sections in [Relationship Loading Techniques](../orm/queryguide/relationships.html):'
  prefs: []
  type: TYPE_NORMAL
- en: '[The Zen of Joined Eager Loading](../orm/queryguide/relationships.html#zen-of-eager-loading)
    - describes the above problem in detail'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Routing Explicit Joins/Statements into Eagerly Loaded Collections](../orm/queryguide/relationships.html#contains-eager)
    - using [`contains_eager()`](../orm/queryguide/relationships.html#sqlalchemy.orm.contains_eager
    "sqlalchemy.orm.contains_eager")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Raiseload
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One additional loader strategy worth mentioning is [`raiseload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.raiseload
    "sqlalchemy.orm.raiseload"). This option is used to completely block an application
    from having the [N plus one](../glossary.html#term-N-plus-one) problem at all
    by causing what would normally be a lazy load to raise an error instead. It has
    two variants that are controlled via the [`raiseload.sql_only`](../orm/queryguide/relationships.html#sqlalchemy.orm.raiseload.params.sql_only
    "sqlalchemy.orm.raiseload") option to block either lazy loads that require SQL,
    versus all “load” operations including those which only need to consult the current
    [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session").
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to use [`raiseload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.raiseload
    "sqlalchemy.orm.raiseload") is to configure it on [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") itself, by setting [`relationship.lazy`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.lazy
    "sqlalchemy.orm.relationship") to the value `"raise_on_sql"`, so that for a particular
    mapping, a certain relationship will never try to emit SQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Using such a mapping, the application is blocked from lazy loading, indicating
    that a particular query would need to specify a loader strategy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The exception would indicate that this collection should be loaded up front
    instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The `lazy="raise_on_sql"` option tries to be smart about many-to-one relationships
    as well; above, if the `Address.user` attribute of an `Address` object were not
    loaded, but that `User` object were locally present in the same [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), the “raiseload” strategy would not raise an error.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Preventing unwanted lazy loads using raiseload](../orm/queryguide/relationships.html#prevent-lazy-with-raiseload)
    - in [Relationship Loading Techniques](../orm/queryguide/relationships.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Persisting and Loading Relationships
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can start by illustrating what [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") does to instances of objects. If we make a new
    `User` object, we can note that there is a Python list when we access the `.addresses`
    element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This object is a SQLAlchemy-specific version of Python `list` which has the
    ability to track and respond to changes made to it. The collection also appeared
    automatically when we accessed the attribute, even though we never assigned it
    to the object. This is similar to the behavior noted at [Inserting Rows using
    the ORM Unit of Work pattern](orm_data_manipulation.html#tutorial-inserting-orm)
    where it was observed that column-based attributes to which we don’t explicitly
    assign a value also display as `None` automatically, rather than raising an `AttributeError`
    as would be Python’s usual behavior.
  prefs: []
  type: TYPE_NORMAL
- en: As the `u1` object is still [transient](../glossary.html#term-transient) and
    the `list` that we got from `u1.addresses` has not been mutated (i.e. appended
    or extended), it’s not actually associated with the object yet, but as we make
    changes to it, it will become part of the state of the `User` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The collection is specific to the `Address` class which is the only type of
    Python object that may be persisted within it. Using the `list.append()` method
    we may add an `Address` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, the `u1.addresses` collection as expected contains the new `Address`
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'As we associated the `Address` object with the `User.addresses` collection
    of the `u1` instance, another behavior also occurred, which is that the `User.addresses`
    relationship synchronized itself with the `Address.user` relationship, such that
    we can navigate not only from the `User` object to the `Address` object, we can
    also navigate from the `Address` object back to the “parent” `User` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This synchronization occurred as a result of our use of the [`relationship.back_populates`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.back_populates
    "sqlalchemy.orm.relationship") parameter between the two [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") objects. This parameter names another [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") for which complementary attribute assignment /
    list mutation should occur. It will work equally well in the other direction,
    which is that if we create another `Address` object and assign to its `Address.user`
    attribute, that `Address` becomes part of the `User.addresses` collection on that
    `User` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We actually made use of the `user` parameter as a keyword argument in the `Address`
    constructor, which is accepted just like any other mapped attribute that was declared
    on the `Address` class. It is equivalent to assignment of the `Address.user` attribute
    after the fact:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '### Cascading Objects into the Session'
  prefs: []
  type: TYPE_NORMAL
- en: We now have a `User` and two `Address` objects that are associated in a bidirectional
    structure in memory, but as noted previously in [Inserting Rows using the ORM
    Unit of Work pattern](orm_data_manipulation.html#tutorial-inserting-orm) , these
    objects are said to be in the [transient](../glossary.html#term-transient) state
    until they are associated with a [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") object.
  prefs: []
  type: TYPE_NORMAL
- en: 'We make use of the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") that’s still ongoing, and note that when we apply the
    [`Session.add()`](../orm/session_api.html#sqlalchemy.orm.Session.add "sqlalchemy.orm.Session.add")
    method to the lead `User` object, the related `Address` object also gets added
    to that same [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The above behavior, where the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") received a `User` object, and followed along the `User.addresses`
    relationship to locate a related `Address` object, is known as the **save-update
    cascade** and is discussed in detail in the ORM reference documentation at [Cascades](../orm/cascades.html#unitofwork-cascades).
  prefs: []
  type: TYPE_NORMAL
- en: 'The three objects are now in the [pending](../glossary.html#term-pending) state;
    this means they are ready to be the subject of an INSERT operation but this has
    not yet proceeded; all three objects have no primary key assigned yet, and in
    addition, the `a1` and `a2` objects have an attribute called `user_id` which refers
    to the [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    that has a [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") referring to the `user_account.id` column;
    these are also `None` as the objects are not yet associated with a real database
    row:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: It’s at this stage that we can see the very great utility that the unit of work
    process provides; recall in the section [INSERT usually generates the “values”
    clause automatically](data_insert.html#tutorial-core-insert-values-clause), rows
    were inserted into the `user_account` and `address` tables using some elaborate
    syntaxes in order to automatically associate the `address.user_id` columns with
    those of the `user_account` rows. Additionally, it was necessary that we emit
    INSERT for `user_account` rows first, before those of `address`, since rows in
    `address` are **dependent** on their parent row in `user_account` for a value
    in their `user_id` column.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session"),
    all this tedium is handled for us and even the most die-hard SQL purist can benefit
    from automation of INSERT, UPDATE and DELETE statements. When we [`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") the transaction all steps invoke in the correct
    order, and furthermore the newly generated primary key of the `user_account` row
    is applied to the `address.user_id` column appropriately:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]  ### Cascading Objects into the Session'
  prefs: []
  type: TYPE_NORMAL
- en: We now have a `User` and two `Address` objects that are associated in a bidirectional
    structure in memory, but as noted previously in [Inserting Rows using the ORM
    Unit of Work pattern](orm_data_manipulation.html#tutorial-inserting-orm) , these
    objects are said to be in the [transient](../glossary.html#term-transient) state
    until they are associated with a [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") object.
  prefs: []
  type: TYPE_NORMAL
- en: 'We make use of the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") that’s still ongoing, and note that when we apply the
    [`Session.add()`](../orm/session_api.html#sqlalchemy.orm.Session.add "sqlalchemy.orm.Session.add")
    method to the lead `User` object, the related `Address` object also gets added
    to that same [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The above behavior, where the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") received a `User` object, and followed along the `User.addresses`
    relationship to locate a related `Address` object, is known as the **save-update
    cascade** and is discussed in detail in the ORM reference documentation at [Cascades](../orm/cascades.html#unitofwork-cascades).
  prefs: []
  type: TYPE_NORMAL
- en: 'The three objects are now in the [pending](../glossary.html#term-pending) state;
    this means they are ready to be the subject of an INSERT operation but this has
    not yet proceeded; all three objects have no primary key assigned yet, and in
    addition, the `a1` and `a2` objects have an attribute called `user_id` which refers
    to the [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    that has a [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") referring to the `user_account.id` column;
    these are also `None` as the objects are not yet associated with a real database
    row:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: It’s at this stage that we can see the very great utility that the unit of work
    process provides; recall in the section [INSERT usually generates the “values”
    clause automatically](data_insert.html#tutorial-core-insert-values-clause), rows
    were inserted into the `user_account` and `address` tables using some elaborate
    syntaxes in order to automatically associate the `address.user_id` columns with
    those of the `user_account` rows. Additionally, it was necessary that we emit
    INSERT for `user_account` rows first, before those of `address`, since rows in
    `address` are **dependent** on their parent row in `user_account` for a value
    in their `user_id` column.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session"),
    all this tedium is handled for us and even the most die-hard SQL purist can benefit
    from automation of INSERT, UPDATE and DELETE statements. When we [`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") the transaction all steps invoke in the correct
    order, and furthermore the newly generated primary key of the `user_account` row
    is applied to the `address.user_id` column appropriately:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '## Loading Relationships'
  prefs: []
  type: TYPE_NORMAL
- en: In the last step, we called [`Session.commit()`](../orm/session_api.html#sqlalchemy.orm.Session.commit
    "sqlalchemy.orm.Session.commit") which emitted a COMMIT for the transaction, and
    then per [`Session.commit.expire_on_commit`](../orm/session_api.html#sqlalchemy.orm.Session.commit.params.expire_on_commit
    "sqlalchemy.orm.Session.commit") expired all objects so that they refresh for
    the next transaction.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we next access an attribute on these objects, we’ll see the SELECT emitted
    for the primary attributes of the row, such as when we view the newly generated
    primary key for the `u1` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The `u1` `User` object now has a persistent collection `User.addresses` that
    we may also access. As this collection consists of an additional set of rows from
    the `address` table, when we access this collection as well we again see a [lazy
    load](../glossary.html#term-lazy-load) emitted in order to retrieve the objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Collections and related attributes in the SQLAlchemy ORM are persistent in
    memory; once the collection or attribute is populated, SQL is no longer emitted
    until that collection or attribute is [expired](../glossary.html#term-expired).
    We may access `u1.addresses` again as well as add or remove items and this will
    not incur any new SQL calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'While the loading emitted by lazy loading can quickly become expensive if we
    don’t take explicit steps to optimize it, the network of lazy loading at least
    is fairly well optimized to not perform redundant work; as the `u1.addresses`
    collection was refreshed, per the [identity map](../glossary.html#term-identity-map)
    these are in fact the same `Address` instances as the `a1` and `a2` objects we’ve
    been dealing with already, so we’re done loading all attributes in this particular
    object graph:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The issue of how relationships load, or not, is an entire subject onto itself.
    Some additional introduction to these concepts is later in this section at [Loader
    Strategies](#tutorial-orm-loader-strategies).
  prefs: []
  type: TYPE_NORMAL
- en: '## Using Relationships in Queries'
  prefs: []
  type: TYPE_NORMAL
- en: The previous section introduced the behavior of the [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") construct when working with **instances of a mapped
    class**, above, the `u1`, `a1` and `a2` instances of the `User` and `Address`
    classes. In this section, we introduce the behavior of [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") as it applies to **class level behavior of a mapped
    class**, where it serves in several ways to help automate the construction of
    SQL queries.
  prefs: []
  type: TYPE_NORMAL
- en: '### Using Relationships to Join'
  prefs: []
  type: TYPE_NORMAL
- en: The sections [Explicit FROM clauses and JOINs](data_select.html#tutorial-select-join)
    and [Setting the ON Clause](data_select.html#tutorial-select-join-onclause) introduced
    the usage of the [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") and [`Select.join_from()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join_from
    "sqlalchemy.sql.expression.Select.join_from") methods to compose SQL JOIN clauses.
    In order to describe how to join between tables, these methods either **infer**
    the ON clause based on the presence of a single unambiguous [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") object within the table metadata structure
    that links the two tables, or otherwise we may provide an explicit SQL Expression
    construct that indicates a specific ON clause.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using ORM entities, an additional mechanism is available to help us set
    up the ON clause of a join, which is to make use of the [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") objects that we set up in our user mapping, as
    was demonstrated at [Declaring Mapped Classes](metadata.html#tutorial-declaring-mapped-classes).
    The class-bound attribute corresponding to the [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") may be passed as the **single argument** to [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join"), where it serves to indicate both the
    right side of the join as well as the ON clause at once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The presence of an ORM [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") on a mapping is not used by [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") or [`Select.join_from()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join_from
    "sqlalchemy.sql.expression.Select.join_from") to infer the ON clause if we don’t
    specify it. This means, if we join from `User` to `Address` without an ON clause,
    it works because of the [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") between the two mapped [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects, not because of the [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") objects on the `User` and `Address` classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: See the section [Joins](../orm/queryguide/select.html#orm-queryguide-joins)
    in the [ORM Querying Guide](../orm/queryguide/index.html) for many more examples
    of how to use [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") and [`Select.join_from()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join_from
    "sqlalchemy.sql.expression.Select.join_from") with [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") constructs.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Joins](../orm/queryguide/select.html#orm-queryguide-joins) in the [ORM Querying
    Guide](../orm/queryguide/index.html)  ### Relationship WHERE Operators'
  prefs: []
  type: TYPE_NORMAL
- en: There are some additional varieties of SQL generation helpers that come with
    [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")
    which are typically useful when building up the WHERE clause of a statement. See
    the section [Relationship WHERE Operators](../orm/queryguide/select.html#orm-queryguide-relationship-operators)
    in the [ORM Querying Guide](../orm/queryguide/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Relationship WHERE Operators](../orm/queryguide/select.html#orm-queryguide-relationship-operators)
    in the [ORM Querying Guide](../orm/queryguide/index.html)  ### Using Relationships
    to Join'
  prefs: []
  type: TYPE_NORMAL
- en: The sections [Explicit FROM clauses and JOINs](data_select.html#tutorial-select-join)
    and [Setting the ON Clause](data_select.html#tutorial-select-join-onclause) introduced
    the usage of the [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") and [`Select.join_from()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join_from
    "sqlalchemy.sql.expression.Select.join_from") methods to compose SQL JOIN clauses.
    In order to describe how to join between tables, these methods either **infer**
    the ON clause based on the presence of a single unambiguous [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") object within the table metadata structure
    that links the two tables, or otherwise we may provide an explicit SQL Expression
    construct that indicates a specific ON clause.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using ORM entities, an additional mechanism is available to help us set
    up the ON clause of a join, which is to make use of the [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") objects that we set up in our user mapping, as
    was demonstrated at [Declaring Mapped Classes](metadata.html#tutorial-declaring-mapped-classes).
    The class-bound attribute corresponding to the [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") may be passed as the **single argument** to [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join"), where it serves to indicate both the
    right side of the join as well as the ON clause at once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The presence of an ORM [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") on a mapping is not used by [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") or [`Select.join_from()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join_from
    "sqlalchemy.sql.expression.Select.join_from") to infer the ON clause if we don’t
    specify it. This means, if we join from `User` to `Address` without an ON clause,
    it works because of the [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") between the two mapped [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects, not because of the [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") objects on the `User` and `Address` classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: See the section [Joins](../orm/queryguide/select.html#orm-queryguide-joins)
    in the [ORM Querying Guide](../orm/queryguide/index.html) for many more examples
    of how to use [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") and [`Select.join_from()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join_from
    "sqlalchemy.sql.expression.Select.join_from") with [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") constructs.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Joins](../orm/queryguide/select.html#orm-queryguide-joins) in the [ORM Querying
    Guide](../orm/queryguide/index.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Relationship WHERE Operators'
  prefs: []
  type: TYPE_NORMAL
- en: There are some additional varieties of SQL generation helpers that come with
    [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship "sqlalchemy.orm.relationship")
    which are typically useful when building up the WHERE clause of a statement. See
    the section [Relationship WHERE Operators](../orm/queryguide/select.html#orm-queryguide-relationship-operators)
    in the [ORM Querying Guide](../orm/queryguide/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Relationship WHERE Operators](../orm/queryguide/select.html#orm-queryguide-relationship-operators)
    in the [ORM Querying Guide](../orm/queryguide/index.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '## Loader Strategies'
  prefs: []
  type: TYPE_NORMAL
- en: In the section [Loading Relationships](#tutorial-loading-relationships) we introduced
    the concept that when we work with instances of mapped objects, accessing the
    attributes that are mapped using [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") in the default case will emit a [lazy load](../glossary.html#term-lazy-load)
    when the collection is not populated in order to load the objects that should
    be present in this collection.
  prefs: []
  type: TYPE_NORMAL
- en: Lazy loading is one of the most famous ORM patterns, and is also the one that
    is most controversial. When several dozen ORM objects in memory each refer to
    a handful of unloaded attributes, routine manipulation of these objects can spin
    off many additional queries that can add up (otherwise known as the [N plus one
    problem](../glossary.html#term-N-plus-one-problem)), and to make matters worse
    they are emitted implicitly. These implicit queries may not be noticed, may cause
    errors when they are attempted after there’s no longer a database transaction
    available, or when using alternative concurrency patterns such as [asyncio](../orm/extensions/asyncio.html),
    they actually won’t work at all.
  prefs: []
  type: TYPE_NORMAL
- en: At the same time, lazy loading is a vastly popular and useful pattern when it
    is compatible with the concurrency approach in use and isn’t otherwise causing
    problems. For these reasons, SQLAlchemy’s ORM places a lot of emphasis on being
    able to control and optimize this loading behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Above all, the first step in using ORM lazy loading effectively is to **test
    the application, turn on SQL echoing, and watch the SQL that is emitted**. If
    there seem to be lots of redundant SELECT statements that look very much like
    they could be rolled into one much more efficiently, if there are loads occurring
    inappropriately for objects that have been [detached](../glossary.html#term-detached)
    from their [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session"),
    that’s when to look into using **loader strategies**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Loader strategies are represented as objects that may be associated with a
    SELECT statement using the [`Select.options()`](../core/selectable.html#sqlalchemy.sql.expression.Select.options
    "sqlalchemy.sql.expression.Select.options") method, e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'They may be also configured as defaults for a [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") using the [`relationship.lazy`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.lazy
    "sqlalchemy.orm.relationship") option, e.g.:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Each loader strategy object adds some kind of information to the statement that
    will be used later by the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") when it is deciding how various attributes should be
    loaded and/or behave when they are accessed.
  prefs: []
  type: TYPE_NORMAL
- en: The sections below will introduce a few of the most prominently used loader
    strategies.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: 'Two sections in [Relationship Loading Techniques](../orm/queryguide/relationships.html):'
  prefs: []
  type: TYPE_NORMAL
- en: '[Configuring Loader Strategies at Mapping Time](../orm/queryguide/relationships.html#relationship-lazy-option)
    - details on configuring the strategy on [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Relationship Loading with Loader Options](../orm/queryguide/relationships.html#relationship-loader-options)
    - details on using query-time loader strategies'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selectin Load
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The most useful loader in modern SQLAlchemy is the [`selectinload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.selectinload
    "sqlalchemy.orm.selectinload") loader option. This option solves the most common
    form of the “N plus one” problem which is that of a set of objects that refer
    to related collections. [`selectinload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.selectinload
    "sqlalchemy.orm.selectinload") will ensure that a particular collection for a
    full series of objects are loaded up front using a single query. It does this
    using a SELECT form that in most cases can be emitted against the related table
    alone, without the introduction of JOINs or subqueries, and only queries for those
    parent objects for which the collection isn’t already loaded. Below we illustrate
    [`selectinload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.selectinload
    "sqlalchemy.orm.selectinload") by loading all of the `User` objects and all of
    their related `Address` objects; while we invoke [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") only once, given a [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") construct, when the database is accessed,
    there are in fact two SELECT statements emitted, the second one being to fetch
    the related `Address` objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Select IN loading](../orm/queryguide/relationships.html#selectin-eager-loading)
    - in [Relationship Loading Techniques](../orm/queryguide/relationships.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Joined Load
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The [`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload") eager load strategy is the oldest eager loader in
    SQLAlchemy, which augments the SELECT statement that’s being passed to the database
    with a JOIN (which may be an outer or an inner join depending on options), which
    can then load in related objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload") strategy is best suited towards loading related many-to-one
    objects, as this only requires that additional columns are added to a primary
    entity row that would be fetched in any case. For greater efficiency, it also
    accepts an option [`joinedload.innerjoin`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload.params.innerjoin
    "sqlalchemy.orm.joinedload") so that an inner join instead of an outer join may
    be used for a case such as below where we know that all `Address` objects have
    an associated `User`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload") also works for collections, meaning one-to-many relationships,
    however it has the effect of multiplying out primary rows per related item in
    a recursive way that grows the amount of data sent for a result set by orders
    of magnitude for nested collections and/or larger collections, so its use vs.
    another option such as [`selectinload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.selectinload
    "sqlalchemy.orm.selectinload") should be evaluated on a per-case basis.'
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note that the WHERE and ORDER BY criteria of the enclosing
    [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select "sqlalchemy.sql.expression.Select")
    statement **do not target the table rendered by joinedload()**. Above, it can
    be seen in the SQL that an **anonymous alias** is applied to the `user_account`
    table such that is not directly addressable in the query. This concept is discussed
    in more detail in the section [The Zen of Joined Eager Loading](../orm/queryguide/relationships.html#zen-of-eager-loading).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note that many-to-one eager loads are often not necessary,
    as the “N plus one” problem is much less prevalent in the common case. When many
    objects all refer to the same related object, such as many `Address` objects that
    each refer to the same `User`, SQL will be emitted only once for that `User` object
    using normal lazy loading. The lazy load routine will look up the related object
    by primary key in the current [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") without emitting any SQL when possible.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Joined Eager Loading](../orm/queryguide/relationships.html#joined-eager-loading)
    - in [Relationship Loading Techniques](../orm/queryguide/relationships.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Explicit Join + Eager load'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we were to load `Address` rows while joining to the `user_account` table
    using a method such as [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") to render the JOIN, we could also leverage
    that JOIN in order to eagerly load the contents of the `Address.user` attribute
    on each `Address` object returned. This is essentially that we are using “joined
    eager loading” but rendering the JOIN ourselves. This common use case is achieved
    by using the [`contains_eager()`](../orm/queryguide/relationships.html#sqlalchemy.orm.contains_eager
    "sqlalchemy.orm.contains_eager") option. This option is very similar to [`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload"), except that it assumes we have set up the JOIN ourselves,
    and it instead only indicates that additional columns in the COLUMNS clause should
    be loaded into related attributes on each returned object, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Above, we both filtered the rows on `user_account.name` and also loaded rows
    from `user_account` into the `Address.user` attribute of the returned rows. If
    we had applied [`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload") separately, we would get a SQL query that unnecessarily
    joins twice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: 'Two sections in [Relationship Loading Techniques](../orm/queryguide/relationships.html):'
  prefs: []
  type: TYPE_NORMAL
- en: '[The Zen of Joined Eager Loading](../orm/queryguide/relationships.html#zen-of-eager-loading)
    - describes the above problem in detail'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Routing Explicit Joins/Statements into Eagerly Loaded Collections](../orm/queryguide/relationships.html#contains-eager)
    - using [`contains_eager()`](../orm/queryguide/relationships.html#sqlalchemy.orm.contains_eager
    "sqlalchemy.orm.contains_eager")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Raiseload
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One additional loader strategy worth mentioning is [`raiseload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.raiseload
    "sqlalchemy.orm.raiseload"). This option is used to completely block an application
    from having the [N plus one](../glossary.html#term-N-plus-one) problem at all
    by causing what would normally be a lazy load to raise an error instead. It has
    two variants that are controlled via the [`raiseload.sql_only`](../orm/queryguide/relationships.html#sqlalchemy.orm.raiseload.params.sql_only
    "sqlalchemy.orm.raiseload") option to block either lazy loads that require SQL,
    versus all “load” operations including those which only need to consult the current
    [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session").
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to use [`raiseload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.raiseload
    "sqlalchemy.orm.raiseload") is to configure it on [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") itself, by setting [`relationship.lazy`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.lazy
    "sqlalchemy.orm.relationship") to the value `"raise_on_sql"`, so that for a particular
    mapping, a certain relationship will never try to emit SQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Using such a mapping, the application is blocked from lazy loading, indicating
    that a particular query would need to specify a loader strategy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The exception would indicate that this collection should be loaded up front
    instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The `lazy="raise_on_sql"` option tries to be smart about many-to-one relationships
    as well; above, if the `Address.user` attribute of an `Address` object were not
    loaded, but that `User` object were locally present in the same [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), the “raiseload” strategy would not raise an error.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Preventing unwanted lazy loads using raiseload](../orm/queryguide/relationships.html#prevent-lazy-with-raiseload)
    - in [Relationship Loading Techniques](../orm/queryguide/relationships.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Selectin Load
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The most useful loader in modern SQLAlchemy is the [`selectinload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.selectinload
    "sqlalchemy.orm.selectinload") loader option. This option solves the most common
    form of the “N plus one” problem which is that of a set of objects that refer
    to related collections. [`selectinload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.selectinload
    "sqlalchemy.orm.selectinload") will ensure that a particular collection for a
    full series of objects are loaded up front using a single query. It does this
    using a SELECT form that in most cases can be emitted against the related table
    alone, without the introduction of JOINs or subqueries, and only queries for those
    parent objects for which the collection isn’t already loaded. Below we illustrate
    [`selectinload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.selectinload
    "sqlalchemy.orm.selectinload") by loading all of the `User` objects and all of
    their related `Address` objects; while we invoke [`Session.execute()`](../orm/session_api.html#sqlalchemy.orm.Session.execute
    "sqlalchemy.orm.Session.execute") only once, given a [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") construct, when the database is accessed,
    there are in fact two SELECT statements emitted, the second one being to fetch
    the related `Address` objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Select IN loading](../orm/queryguide/relationships.html#selectin-eager-loading)
    - in [Relationship Loading Techniques](../orm/queryguide/relationships.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Joined Load
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The [`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload") eager load strategy is the oldest eager loader in
    SQLAlchemy, which augments the SELECT statement that’s being passed to the database
    with a JOIN (which may be an outer or an inner join depending on options), which
    can then load in related objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload") strategy is best suited towards loading related many-to-one
    objects, as this only requires that additional columns are added to a primary
    entity row that would be fetched in any case. For greater efficiency, it also
    accepts an option [`joinedload.innerjoin`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload.params.innerjoin
    "sqlalchemy.orm.joinedload") so that an inner join instead of an outer join may
    be used for a case such as below where we know that all `Address` objects have
    an associated `User`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload") also works for collections, meaning one-to-many relationships,
    however it has the effect of multiplying out primary rows per related item in
    a recursive way that grows the amount of data sent for a result set by orders
    of magnitude for nested collections and/or larger collections, so its use vs.
    another option such as [`selectinload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.selectinload
    "sqlalchemy.orm.selectinload") should be evaluated on a per-case basis.'
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note that the WHERE and ORDER BY criteria of the enclosing
    [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select "sqlalchemy.sql.expression.Select")
    statement **do not target the table rendered by joinedload()**. Above, it can
    be seen in the SQL that an **anonymous alias** is applied to the `user_account`
    table such that is not directly addressable in the query. This concept is discussed
    in more detail in the section [The Zen of Joined Eager Loading](../orm/queryguide/relationships.html#zen-of-eager-loading).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note that many-to-one eager loads are often not necessary,
    as the “N plus one” problem is much less prevalent in the common case. When many
    objects all refer to the same related object, such as many `Address` objects that
    each refer to the same `User`, SQL will be emitted only once for that `User` object
    using normal lazy loading. The lazy load routine will look up the related object
    by primary key in the current [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") without emitting any SQL when possible.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Joined Eager Loading](../orm/queryguide/relationships.html#joined-eager-loading)
    - in [Relationship Loading Techniques](../orm/queryguide/relationships.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Explicit Join + Eager load'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we were to load `Address` rows while joining to the `user_account` table
    using a method such as [`Select.join()`](../core/selectable.html#sqlalchemy.sql.expression.Select.join
    "sqlalchemy.sql.expression.Select.join") to render the JOIN, we could also leverage
    that JOIN in order to eagerly load the contents of the `Address.user` attribute
    on each `Address` object returned. This is essentially that we are using “joined
    eager loading” but rendering the JOIN ourselves. This common use case is achieved
    by using the [`contains_eager()`](../orm/queryguide/relationships.html#sqlalchemy.orm.contains_eager
    "sqlalchemy.orm.contains_eager") option. This option is very similar to [`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload"), except that it assumes we have set up the JOIN ourselves,
    and it instead only indicates that additional columns in the COLUMNS clause should
    be loaded into related attributes on each returned object, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Above, we both filtered the rows on `user_account.name` and also loaded rows
    from `user_account` into the `Address.user` attribute of the returned rows. If
    we had applied [`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload") separately, we would get a SQL query that unnecessarily
    joins twice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: 'Two sections in [Relationship Loading Techniques](../orm/queryguide/relationships.html):'
  prefs: []
  type: TYPE_NORMAL
- en: '[The Zen of Joined Eager Loading](../orm/queryguide/relationships.html#zen-of-eager-loading)
    - describes the above problem in detail'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Routing Explicit Joins/Statements into Eagerly Loaded Collections](../orm/queryguide/relationships.html#contains-eager)
    - using [`contains_eager()`](../orm/queryguide/relationships.html#sqlalchemy.orm.contains_eager
    "sqlalchemy.orm.contains_eager")'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Raiseload
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One additional loader strategy worth mentioning is [`raiseload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.raiseload
    "sqlalchemy.orm.raiseload"). This option is used to completely block an application
    from having the [N plus one](../glossary.html#term-N-plus-one) problem at all
    by causing what would normally be a lazy load to raise an error instead. It has
    two variants that are controlled via the [`raiseload.sql_only`](../orm/queryguide/relationships.html#sqlalchemy.orm.raiseload.params.sql_only
    "sqlalchemy.orm.raiseload") option to block either lazy loads that require SQL,
    versus all “load” operations including those which only need to consult the current
    [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session").
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to use [`raiseload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.raiseload
    "sqlalchemy.orm.raiseload") is to configure it on [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") itself, by setting [`relationship.lazy`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.lazy
    "sqlalchemy.orm.relationship") to the value `"raise_on_sql"`, so that for a particular
    mapping, a certain relationship will never try to emit SQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Using such a mapping, the application is blocked from lazy loading, indicating
    that a particular query would need to specify a loader strategy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The exception would indicate that this collection should be loaded up front
    instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: The `lazy="raise_on_sql"` option tries to be smart about many-to-one relationships
    as well; above, if the `Address.user` attribute of an `Address` object were not
    loaded, but that `User` object were locally present in the same [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), the “raiseload” strategy would not raise an error.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Preventing unwanted lazy loads using raiseload](../orm/queryguide/relationships.html#prevent-lazy-with-raiseload)
    - in [Relationship Loading Techniques](../orm/queryguide/relationships.html)'
  prefs: []
  type: TYPE_NORMAL
