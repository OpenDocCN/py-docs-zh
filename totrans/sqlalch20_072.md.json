["```py\nfrom __future__ import annotations\n\nfrom sqlalchemy.ext.hybrid import hybrid_method\nfrom sqlalchemy.ext.hybrid import hybrid_property\nfrom sqlalchemy.orm import DeclarativeBase\nfrom sqlalchemy.orm import Mapped\nfrom sqlalchemy.orm import mapped_column\n\nclass Base(DeclarativeBase):\n    pass\n\nclass Interval(Base):\n    __tablename__ = 'interval'\n\n    id: Mapped[int] = mapped_column(primary_key=True)\n    start: Mapped[int]\n    end: Mapped[int]\n\n    def __init__(self, start: int, end: int):\n        self.start = start\n        self.end = end\n\n    @hybrid_property\n    def length(self) -> int:\n        return self.end - self.start\n\n    @hybrid_method\n    def contains(self, point: int) -> bool:\n        return (self.start <= point) & (point <= self.end)\n\n    @hybrid_method\n    def intersects(self, other: Interval) -> bool:\n        return self.contains(other.start) | self.contains(other.end)\n```", "```py\n>>> i1 = Interval(5, 10)\n>>> i1.length\n5\n```", "```py\n>>> from sqlalchemy import select\n>>> print(select(Interval.length))\nSELECT  interval.\"end\"  -  interval.start  AS  length\nFROM  interval\n>>> print(select(Interval).filter(Interval.length > 10))\nSELECT  interval.id,  interval.start,  interval.\"end\"\nFROM  interval\nWHERE  interval.\"end\"  -  interval.start  >  :param_1 \n```", "```py\n>>> print(select(Interval).filter_by(length=5))\nSELECT  interval.id,  interval.start,  interval.\"end\"\nFROM  interval\nWHERE  interval.\"end\"  -  interval.start  =  :param_1 \n```", "```py\n>>> i1.contains(6)\nTrue\n>>> i1.contains(15)\nFalse\n>>> i1.intersects(Interval(7, 18))\nTrue\n>>> i1.intersects(Interval(25, 29))\nFalse\n\n>>> print(select(Interval).filter(Interval.contains(15)))\nSELECT  interval.id,  interval.start,  interval.\"end\"\nFROM  interval\nWHERE  interval.start  <=  :start_1  AND  interval.\"end\"  >  :end_1\n>>> ia = aliased(Interval)\n>>> print(select(Interval, ia).filter(Interval.intersects(ia)))\nSELECT  interval.id,  interval.start,\ninterval.\"end\",  interval_1.id  AS  interval_1_id,\ninterval_1.start  AS  interval_1_start,  interval_1.\"end\"  AS  interval_1_end\nFROM  interval,  interval  AS  interval_1\nWHERE  interval.start  <=  interval_1.start\n  AND  interval.\"end\"  >  interval_1.start\n  OR  interval.start  <=  interval_1.\"end\"\n  AND  interval.\"end\"  >  interval_1.\"end\" \n```", "```py\nfrom sqlalchemy import ColumnElement\nfrom sqlalchemy import Float\nfrom sqlalchemy import func\nfrom sqlalchemy import type_coerce\n\nclass Interval(Base):\n    # ...\n\n    @hybrid_property\n    def radius(self) -> float:\n        return abs(self.length) / 2\n\n    @radius.inplace.expression\n    @classmethod\n    def _radius_expression(cls) -> ColumnElement[float]:\n        return type_coerce(func.abs(cls.length) / 2, Float)\n```", "```py\n>>> from sqlalchemy import select\n>>> print(select(Interval).filter(Interval.radius > 5))\nSELECT  interval.id,  interval.start,  interval.\"end\"\nFROM  interval\nWHERE  abs(interval.\"end\"  -  interval.start)  /  :abs_1  >  :param_1 \n```", "```py\n# correct use, however is not accepted by pep-484 tooling\n\nclass Interval(Base):\n    # ...\n\n    @hybrid_property\n    def radius(self):\n        return abs(self.length) / 2\n\n    @radius.setter\n    def radius(self, value):\n        self.length = value * 2\n\n    @radius.expression\n    def radius(cls):\n        return type_coerce(func.abs(cls.length) / 2, Float)\n```", "```py\n# correct use which is also accepted by pep-484 tooling\n\nclass Interval(Base):\n    # ...\n\n    @hybrid_property\n    def radius(self) -> float:\n        return abs(self.length) / 2\n\n    @radius.inplace.setter\n    def _radius_setter(self, value: float) -> None:\n        # for example only\n        self.length = value * 2\n\n    @radius.inplace.expression\n    @classmethod\n    def _radius_expression(cls) -> ColumnElement[float]:\n        return type_coerce(func.abs(cls.length) / 2, Float)\n```", "```py\nclass Interval(Base):\n    # ...\n\n    @hybrid_property\n    def length(self) -> int:\n        return self.end - self.start\n\n    @length.inplace.setter\n    def _length_setter(self, value: int) -> None:\n        self.end = self.start + value\n```", "```py\n>>> i1 = Interval(5, 10)\n>>> i1.length\n5\n>>> i1.length = 12\n>>> i1.end\n17\n```", "```py\nfrom sqlalchemy import update\nstmt = update(Interval).values({Interval.start_point: 10})\n```", "```py\nfrom typing import List, Tuple, Any\n\nclass Interval(Base):\n    # ...\n\n    @hybrid_property\n    def length(self) -> int:\n        return self.end - self.start\n\n    @length.inplace.setter\n    def _length_setter(self, value: int) -> None:\n        self.end = self.start + value\n\n    @length.inplace.update_expression\n    def _length_update_expression(cls, value: Any) -> List[Tuple[Any, Any]]:\n        return [\n            (cls.end, cls.start + value)\n        ]\n```", "```py\n>>> from sqlalchemy import update\n>>> print(update(Interval).values({Interval.length: 25}))\nUPDATE  interval  SET  \"end\"=(interval.start  +  :start_1) \n```", "```py\nfrom __future__ import annotations\n\nfrom decimal import Decimal\nfrom typing import cast\nfrom typing import List\nfrom typing import Optional\n\nfrom sqlalchemy import ForeignKey\nfrom sqlalchemy import Numeric\nfrom sqlalchemy import String\nfrom sqlalchemy import SQLColumnExpression\nfrom sqlalchemy.ext.hybrid import hybrid_property\nfrom sqlalchemy.orm import DeclarativeBase\nfrom sqlalchemy.orm import Mapped\nfrom sqlalchemy.orm import mapped_column\nfrom sqlalchemy.orm import relationship\n\nclass Base(DeclarativeBase):\n    pass\n\nclass SavingsAccount(Base):\n    __tablename__ = 'account'\n    id: Mapped[int] = mapped_column(primary_key=True)\n    user_id: Mapped[int] = mapped_column(ForeignKey('user.id'))\n    balance: Mapped[Decimal] = mapped_column(Numeric(15, 5))\n\n    owner: Mapped[User] = relationship(back_populates=\"accounts\")\n\nclass User(Base):\n    __tablename__ = 'user'\n    id: Mapped[int] = mapped_column(primary_key=True)\n    name: Mapped[str] = mapped_column(String(100))\n\n    accounts: Mapped[List[SavingsAccount]] = relationship(\n        back_populates=\"owner\", lazy=\"selectin\"\n    )\n\n    @hybrid_property\n    def balance(self) -> Optional[Decimal]:\n        if self.accounts:\n            return self.accounts[0].balance\n        else:\n            return None\n\n    @balance.inplace.setter\n    def _balance_setter(self, value: Optional[Decimal]) -> None:\n        assert value is not None\n\n        if not self.accounts:\n            account = SavingsAccount(owner=self)\n        else:\n            account = self.accounts[0]\n        account.balance = value\n\n    @balance.inplace.expression\n    @classmethod\n    def _balance_expression(cls) -> SQLColumnExpression[Optional[Decimal]]:\n        return cast(\"SQLColumnExpression[Optional[Decimal]]\", SavingsAccount.balance)\n```", "```py\n>>> from sqlalchemy import select\n>>> print(select(User, User.balance).\n...       join(User.accounts).filter(User.balance > 5000))\nSELECT  \"user\".id  AS  user_id,  \"user\".name  AS  user_name,\naccount.balance  AS  account_balance\nFROM  \"user\"  JOIN  account  ON  \"user\".id  =  account.user_id\nWHERE  account.balance  >  :balance_1 \n```", "```py\n>>> from sqlalchemy import select\n>>> from sqlalchemy import or_\n>>> print (select(User, User.balance).outerjoin(User.accounts).\n...         filter(or_(User.balance < 5000, User.balance == None)))\nSELECT  \"user\".id  AS  user_id,  \"user\".name  AS  user_name,\naccount.balance  AS  account_balance\nFROM  \"user\"  LEFT  OUTER  JOIN  account  ON  \"user\".id  =  account.user_id\nWHERE  account.balance  <  :balance_1  OR  account.balance  IS  NULL \n```", "```py\nfrom __future__ import annotations\n\nfrom decimal import Decimal\nfrom typing import List\n\nfrom sqlalchemy import ForeignKey\nfrom sqlalchemy import func\nfrom sqlalchemy import Numeric\nfrom sqlalchemy import select\nfrom sqlalchemy import SQLColumnExpression\nfrom sqlalchemy import String\nfrom sqlalchemy.ext.hybrid import hybrid_property\nfrom sqlalchemy.orm import DeclarativeBase\nfrom sqlalchemy.orm import Mapped\nfrom sqlalchemy.orm import mapped_column\nfrom sqlalchemy.orm import relationship\n\nclass Base(DeclarativeBase):\n    pass\n\nclass SavingsAccount(Base):\n    __tablename__ = 'account'\n    id: Mapped[int] = mapped_column(primary_key=True)\n    user_id: Mapped[int] = mapped_column(ForeignKey('user.id'))\n    balance: Mapped[Decimal] = mapped_column(Numeric(15, 5))\n\n    owner: Mapped[User] = relationship(back_populates=\"accounts\")\n\nclass User(Base):\n    __tablename__ = 'user'\n    id: Mapped[int] = mapped_column(primary_key=True)\n    name: Mapped[str] = mapped_column(String(100))\n\n    accounts: Mapped[List[SavingsAccount]] = relationship(\n        back_populates=\"owner\", lazy=\"selectin\"\n    )\n\n    @hybrid_property\n    def balance(self) -> Decimal:\n        return sum((acc.balance for acc in self.accounts), start=Decimal(\"0\"))\n\n    @balance.inplace.expression\n    @classmethod\n    def _balance_expression(cls) -> SQLColumnExpression[Decimal]:\n        return (\n            select(func.sum(SavingsAccount.balance))\n            .where(SavingsAccount.user_id == cls.id)\n            .label(\"total_balance\")\n        )\n```", "```py\n>>> from sqlalchemy import select\n>>> print(select(User).filter(User.balance > 400))\nSELECT  \"user\".id,  \"user\".name\nFROM  \"user\"\nWHERE  (\n  SELECT  sum(account.balance)  AS  sum_1  FROM  account\n  WHERE  account.user_id  =  \"user\".id\n)  >  :param_1 \n```", "```py\nfrom __future__ import annotations\n\nfrom typing import Any\n\nfrom sqlalchemy import ColumnElement\nfrom sqlalchemy import func\nfrom sqlalchemy.ext.hybrid import Comparator\nfrom sqlalchemy.ext.hybrid import hybrid_property\nfrom sqlalchemy.orm import DeclarativeBase\nfrom sqlalchemy.orm import Mapped\nfrom sqlalchemy.orm import mapped_column\n\nclass Base(DeclarativeBase):\n    pass\n\nclass CaseInsensitiveComparator(Comparator[str]):\n    def __eq__(self, other: Any) -> ColumnElement[bool]:  # type: ignore[override]  # noqa: E501\n        return func.lower(self.__clause_element__()) == func.lower(other)\n\nclass SearchWord(Base):\n    __tablename__ = 'searchword'\n\n    id: Mapped[int] = mapped_column(primary_key=True)\n    word: Mapped[str]\n\n    @hybrid_property\n    def word_insensitive(self) -> str:\n        return self.word.lower()\n\n    @word_insensitive.inplace.comparator\n    @classmethod\n    def _word_insensitive_comparator(cls) -> CaseInsensitiveComparator:\n        return CaseInsensitiveComparator(cls.word)\n```", "```py\n>>> from sqlalchemy import select\n>>> print(select(SearchWord).filter_by(word_insensitive=\"Trucks\"))\nSELECT  searchword.id,  searchword.word\nFROM  searchword\nWHERE  lower(searchword.word)  =  lower(:lower_1) \n```", "```py\nclass CaseInsensitiveComparator(Comparator):\n    def operate(self, op, other, **kwargs):\n        return op(\n            func.lower(self.__clause_element__()),\n            func.lower(other),\n            **kwargs,\n        )\n```", "```py\nclass FirstNameOnly(Base):\n    # ...\n\n    first_name: Mapped[str]\n\n    @hybrid_property\n    def name(self) -> str:\n        return self.first_name\n\n    @name.inplace.setter\n    def _name_setter(self, value: str) -> None:\n        self.first_name = value\n\nclass FirstNameLastName(FirstNameOnly):\n    # ...\n\n    last_name: Mapped[str]\n\n    # 'inplace' is not used here; calling getter creates a copy\n    # of FirstNameOnly.name that is local to FirstNameLastName\n    @FirstNameOnly.name.getter\n    def name(self) -> str:\n        return self.first_name + ' ' + self.last_name\n\n    @name.inplace.setter\n    def _name_setter(self, value: str) -> None:\n        self.first_name, self.last_name = value.split(' ', 1)\n```", "```py\nclass FirstNameLastName(FirstNameOnly):\n    # ...\n\n    last_name: Mapped[str]\n\n    @FirstNameOnly.name.overrides.expression\n    @classmethod\n    def name(cls):\n        return func.concat(cls.first_name, ' ', cls.last_name)\n```", "```py\nclass CaseInsensitiveWord(Comparator):\n    \"Hybrid value representing a lower case representation of a word.\"\n\n    def __init__(self, word):\n        if isinstance(word, basestring):\n            self.word = word.lower()\n        elif isinstance(word, CaseInsensitiveWord):\n            self.word = word.word\n        else:\n            self.word = func.lower(word)\n\n    def operate(self, op, other, **kwargs):\n        if not isinstance(other, CaseInsensitiveWord):\n            other = CaseInsensitiveWord(other)\n        return op(self.word, other.word, **kwargs)\n\n    def __clause_element__(self):\n        return self.word\n\n    def __str__(self):\n        return self.word\n\n    key = 'word'\n    \"Label to apply to Query tuple results\"\n```", "```py\nclass SearchWord(Base):\n    __tablename__ = 'searchword'\n    id: Mapped[int] = mapped_column(primary_key=True)\n    word: Mapped[str]\n\n    @hybrid_property\n    def word_insensitive(self) -> CaseInsensitiveWord:\n        return CaseInsensitiveWord(self.word)\n```", "```py\n>>> print(select(SearchWord).filter_by(word_insensitive=\"Trucks\"))\nSELECT  searchword.id  AS  searchword_id,  searchword.word  AS  searchword_word\nFROM  searchword\nWHERE  lower(searchword.word)  =  :lower_1 \n```", "```py\n>>> from sqlalchemy.orm import aliased\n>>> sw1 = aliased(SearchWord)\n>>> sw2 = aliased(SearchWord)\n>>> print(\n...     select(sw1.word_insensitive, sw2.word_insensitive).filter(\n...         sw1.word_insensitive > sw2.word_insensitive\n...     )\n... )\nSELECT  lower(searchword_1.word)  AS  lower_1,\nlower(searchword_2.word)  AS  lower_2\nFROM  searchword  AS  searchword_1,  searchword  AS  searchword_2\nWHERE  lower(searchword_1.word)  >  lower(searchword_2.word) \n```", "```py\n>>> ws1 = SearchWord(word=\"SomeWord\")\n>>> ws1.word_insensitive == \"sOmEwOrD\"\nTrue\n>>> ws1.word_insensitive == \"XOmEwOrX\"\nFalse\n>>> print(ws1.word_insensitive)\nsomeword\n```", "```py\nclass sqlalchemy.ext.hybrid.hybrid_method\n```", "```py\nmethod __init__(func: Callable[[Concatenate[Any, _P]], _R], expr: Callable[[Concatenate[Any, _P]], SQLCoreOperations[_R]] | None = None)\n```", "```py\nfrom sqlalchemy.ext.hybrid import hybrid_method\n\nclass SomeClass:\n    @hybrid_method\n    def value(self, x, y):\n        return self._value + x + y\n\n    @value.expression\n    @classmethod\n    def value(cls, x, y):\n        return func.some_function(cls._value, x, y)\n```", "```py\nmethod expression(expr: Callable[[Concatenate[Any, _P]], SQLCoreOperations[_R]]) \u2192 hybrid_method[_P, _R]\n```", "```py\nattribute extension_type: InspectionAttrExtensionType = 'HYBRID_METHOD'\n```", "```py\nattribute inplace\n```", "```py\nattribute is_attribute = True\n```", "```py\nclass sqlalchemy.ext.hybrid.hybrid_property\n```", "```py\nmethod __init__(fget: _HybridGetterType[_T], fset: _HybridSetterType[_T] | None = None, fdel: _HybridDeleterType[_T] | None = None, expr: _HybridExprCallableType[_T] | None = None, custom_comparator: Comparator[_T] | None = None, update_expr: _HybridUpdaterType[_T] | None = None)\n```", "```py\nfrom sqlalchemy.ext.hybrid import hybrid_property\n\nclass SomeClass:\n    @hybrid_property\n    def value(self):\n        return self._value\n\n    @value.setter\n    def value(self, value):\n        self._value = value\n```", "```py\nmethod comparator(comparator: _HybridComparatorCallableType[_T]) \u2192 hybrid_property[_T]\n```", "```py\nmethod deleter(fdel: _HybridDeleterType[_T]) \u2192 hybrid_property[_T]\n```", "```py\nmethod expression(expr: _HybridExprCallableType[_T]) \u2192 hybrid_property[_T]\n```", "```py\nattribute extension_type: InspectionAttrExtensionType = 'HYBRID_PROPERTY'\n```", "```py\nmethod getter(fget: _HybridGetterType[_T]) \u2192 hybrid_property[_T]\n```", "```py\nattribute inplace\n```", "```py\nclass Interval(Base):\n    # ...\n\n    @hybrid_property\n    def radius(self) -> float:\n        return abs(self.length) / 2\n\n    @radius.inplace.setter\n    def _radius_setter(self, value: float) -> None:\n        self.length = value * 2\n\n    @radius.inplace.expression\n    def _radius_expression(cls) -> ColumnElement[float]:\n        return type_coerce(func.abs(cls.length) / 2, Float)\n```", "```py\nattribute is_attribute = True\n```", "```py\nattribute overrides\n```", "```py\nclass SuperClass:\n    # ...\n\n    @hybrid_property\n    def foobar(self):\n        return self._foobar\n\nclass SubClass(SuperClass):\n    # ...\n\n    @SuperClass.foobar.overrides.expression\n    def foobar(cls):\n        return func.subfoobar(self._foobar)\n```", "```py\nmethod setter(fset: _HybridSetterType[_T]) \u2192 hybrid_property[_T]\n```", "```py\nmethod update_expression(meth: _HybridUpdaterType[_T]) \u2192 hybrid_property[_T]\n```", "```py\nclass Person(Base):\n    # ...\n\n    first_name = Column(String)\n    last_name = Column(String)\n\n    @hybrid_property\n    def fullname(self):\n        return first_name + \" \" + last_name\n\n    @fullname.update_expression\n    def fullname(cls, value):\n        fname, lname = value.split(\" \", 1)\n        return [\n            (cls.first_name, fname),\n            (cls.last_name, lname)\n        ]\n```", "```py\nclass sqlalchemy.ext.hybrid.Comparator\n```", "```py\nclass sqlalchemy.ext.hybrid.HybridExtensionType\n```", "```py\nattribute HYBRID_METHOD = 'HYBRID_METHOD'\n```", "```py\nattribute HYBRID_PROPERTY = 'HYBRID_PROPERTY'\n```", "```py\nfrom sqlalchemy import ColumnElement\nfrom sqlalchemy import Float\nfrom sqlalchemy import func\nfrom sqlalchemy import type_coerce\n\nclass Interval(Base):\n    # ...\n\n    @hybrid_property\n    def radius(self) -> float:\n        return abs(self.length) / 2\n\n    @radius.inplace.expression\n    @classmethod\n    def _radius_expression(cls) -> ColumnElement[float]:\n        return type_coerce(func.abs(cls.length) / 2, Float)\n```", "```py\n>>> from sqlalchemy import select\n>>> print(select(Interval).filter(Interval.radius > 5))\nSELECT  interval.id,  interval.start,  interval.\"end\"\nFROM  interval\nWHERE  abs(interval.\"end\"  -  interval.start)  /  :abs_1  >  :param_1 \n```", "```py\n# correct use, however is not accepted by pep-484 tooling\n\nclass Interval(Base):\n    # ...\n\n    @hybrid_property\n    def radius(self):\n        return abs(self.length) / 2\n\n    @radius.setter\n    def radius(self, value):\n        self.length = value * 2\n\n    @radius.expression\n    def radius(cls):\n        return type_coerce(func.abs(cls.length) / 2, Float)\n```", "```py\n# correct use which is also accepted by pep-484 tooling\n\nclass Interval(Base):\n    # ...\n\n    @hybrid_property\n    def radius(self) -> float:\n        return abs(self.length) / 2\n\n    @radius.inplace.setter\n    def _radius_setter(self, value: float) -> None:\n        # for example only\n        self.length = value * 2\n\n    @radius.inplace.expression\n    @classmethod\n    def _radius_expression(cls) -> ColumnElement[float]:\n        return type_coerce(func.abs(cls.length) / 2, Float)\n```", "```py\nclass Interval(Base):\n    # ...\n\n    @hybrid_property\n    def length(self) -> int:\n        return self.end - self.start\n\n    @length.inplace.setter\n    def _length_setter(self, value: int) -> None:\n        self.end = self.start + value\n```", "```py\n>>> i1 = Interval(5, 10)\n>>> i1.length\n5\n>>> i1.length = 12\n>>> i1.end\n17\n```", "```py\nfrom sqlalchemy import update\nstmt = update(Interval).values({Interval.start_point: 10})\n```", "```py\nfrom typing import List, Tuple, Any\n\nclass Interval(Base):\n    # ...\n\n    @hybrid_property\n    def length(self) -> int:\n        return self.end - self.start\n\n    @length.inplace.setter\n    def _length_setter(self, value: int) -> None:\n        self.end = self.start + value\n\n    @length.inplace.update_expression\n    def _length_update_expression(cls, value: Any) -> List[Tuple[Any, Any]]:\n        return [\n            (cls.end, cls.start + value)\n        ]\n```", "```py\n>>> from sqlalchemy import update\n>>> print(update(Interval).values({Interval.length: 25}))\nUPDATE  interval  SET  \"end\"=(interval.start  +  :start_1) \n```", "```py\nfrom __future__ import annotations\n\nfrom decimal import Decimal\nfrom typing import cast\nfrom typing import List\nfrom typing import Optional\n\nfrom sqlalchemy import ForeignKey\nfrom sqlalchemy import Numeric\nfrom sqlalchemy import String\nfrom sqlalchemy import SQLColumnExpression\nfrom sqlalchemy.ext.hybrid import hybrid_property\nfrom sqlalchemy.orm import DeclarativeBase\nfrom sqlalchemy.orm import Mapped\nfrom sqlalchemy.orm import mapped_column\nfrom sqlalchemy.orm import relationship\n\nclass Base(DeclarativeBase):\n    pass\n\nclass SavingsAccount(Base):\n    __tablename__ = 'account'\n    id: Mapped[int] = mapped_column(primary_key=True)\n    user_id: Mapped[int] = mapped_column(ForeignKey('user.id'))\n    balance: Mapped[Decimal] = mapped_column(Numeric(15, 5))\n\n    owner: Mapped[User] = relationship(back_populates=\"accounts\")\n\nclass User(Base):\n    __tablename__ = 'user'\n    id: Mapped[int] = mapped_column(primary_key=True)\n    name: Mapped[str] = mapped_column(String(100))\n\n    accounts: Mapped[List[SavingsAccount]] = relationship(\n        back_populates=\"owner\", lazy=\"selectin\"\n    )\n\n    @hybrid_property\n    def balance(self) -> Optional[Decimal]:\n        if self.accounts:\n            return self.accounts[0].balance\n        else:\n            return None\n\n    @balance.inplace.setter\n    def _balance_setter(self, value: Optional[Decimal]) -> None:\n        assert value is not None\n\n        if not self.accounts:\n            account = SavingsAccount(owner=self)\n        else:\n            account = self.accounts[0]\n        account.balance = value\n\n    @balance.inplace.expression\n    @classmethod\n    def _balance_expression(cls) -> SQLColumnExpression[Optional[Decimal]]:\n        return cast(\"SQLColumnExpression[Optional[Decimal]]\", SavingsAccount.balance)\n```", "```py\n>>> from sqlalchemy import select\n>>> print(select(User, User.balance).\n...       join(User.accounts).filter(User.balance > 5000))\nSELECT  \"user\".id  AS  user_id,  \"user\".name  AS  user_name,\naccount.balance  AS  account_balance\nFROM  \"user\"  JOIN  account  ON  \"user\".id  =  account.user_id\nWHERE  account.balance  >  :balance_1 \n```", "```py\n>>> from sqlalchemy import select\n>>> from sqlalchemy import or_\n>>> print (select(User, User.balance).outerjoin(User.accounts).\n...         filter(or_(User.balance < 5000, User.balance == None)))\nSELECT  \"user\".id  AS  user_id,  \"user\".name  AS  user_name,\naccount.balance  AS  account_balance\nFROM  \"user\"  LEFT  OUTER  JOIN  account  ON  \"user\".id  =  account.user_id\nWHERE  account.balance  <  :balance_1  OR  account.balance  IS  NULL \n```", "```py\nfrom __future__ import annotations\n\nfrom decimal import Decimal\nfrom typing import List\n\nfrom sqlalchemy import ForeignKey\nfrom sqlalchemy import func\nfrom sqlalchemy import Numeric\nfrom sqlalchemy import select\nfrom sqlalchemy import SQLColumnExpression\nfrom sqlalchemy import String\nfrom sqlalchemy.ext.hybrid import hybrid_property\nfrom sqlalchemy.orm import DeclarativeBase\nfrom sqlalchemy.orm import Mapped\nfrom sqlalchemy.orm import mapped_column\nfrom sqlalchemy.orm import relationship\n\nclass Base(DeclarativeBase):\n    pass\n\nclass SavingsAccount(Base):\n    __tablename__ = 'account'\n    id: Mapped[int] = mapped_column(primary_key=True)\n    user_id: Mapped[int] = mapped_column(ForeignKey('user.id'))\n    balance: Mapped[Decimal] = mapped_column(Numeric(15, 5))\n\n    owner: Mapped[User] = relationship(back_populates=\"accounts\")\n\nclass User(Base):\n    __tablename__ = 'user'\n    id: Mapped[int] = mapped_column(primary_key=True)\n    name: Mapped[str] = mapped_column(String(100))\n\n    accounts: Mapped[List[SavingsAccount]] = relationship(\n        back_populates=\"owner\", lazy=\"selectin\"\n    )\n\n    @hybrid_property\n    def balance(self) -> Decimal:\n        return sum((acc.balance for acc in self.accounts), start=Decimal(\"0\"))\n\n    @balance.inplace.expression\n    @classmethod\n    def _balance_expression(cls) -> SQLColumnExpression[Decimal]:\n        return (\n            select(func.sum(SavingsAccount.balance))\n            .where(SavingsAccount.user_id == cls.id)\n            .label(\"total_balance\")\n        )\n```", "```py\n>>> from sqlalchemy import select\n>>> print(select(User).filter(User.balance > 400))\nSELECT  \"user\".id,  \"user\".name\nFROM  \"user\"\nWHERE  (\n  SELECT  sum(account.balance)  AS  sum_1  FROM  account\n  WHERE  account.user_id  =  \"user\".id\n)  >  :param_1 \n```", "```py\nfrom __future__ import annotations\n\nfrom decimal import Decimal\nfrom typing import cast\nfrom typing import List\nfrom typing import Optional\n\nfrom sqlalchemy import ForeignKey\nfrom sqlalchemy import Numeric\nfrom sqlalchemy import String\nfrom sqlalchemy import SQLColumnExpression\nfrom sqlalchemy.ext.hybrid import hybrid_property\nfrom sqlalchemy.orm import DeclarativeBase\nfrom sqlalchemy.orm import Mapped\nfrom sqlalchemy.orm import mapped_column\nfrom sqlalchemy.orm import relationship\n\nclass Base(DeclarativeBase):\n    pass\n\nclass SavingsAccount(Base):\n    __tablename__ = 'account'\n    id: Mapped[int] = mapped_column(primary_key=True)\n    user_id: Mapped[int] = mapped_column(ForeignKey('user.id'))\n    balance: Mapped[Decimal] = mapped_column(Numeric(15, 5))\n\n    owner: Mapped[User] = relationship(back_populates=\"accounts\")\n\nclass User(Base):\n    __tablename__ = 'user'\n    id: Mapped[int] = mapped_column(primary_key=True)\n    name: Mapped[str] = mapped_column(String(100))\n\n    accounts: Mapped[List[SavingsAccount]] = relationship(\n        back_populates=\"owner\", lazy=\"selectin\"\n    )\n\n    @hybrid_property\n    def balance(self) -> Optional[Decimal]:\n        if self.accounts:\n            return self.accounts[0].balance\n        else:\n            return None\n\n    @balance.inplace.setter\n    def _balance_setter(self, value: Optional[Decimal]) -> None:\n        assert value is not None\n\n        if not self.accounts:\n            account = SavingsAccount(owner=self)\n        else:\n            account = self.accounts[0]\n        account.balance = value\n\n    @balance.inplace.expression\n    @classmethod\n    def _balance_expression(cls) -> SQLColumnExpression[Optional[Decimal]]:\n        return cast(\"SQLColumnExpression[Optional[Decimal]]\", SavingsAccount.balance)\n```", "```py\n>>> from sqlalchemy import select\n>>> print(select(User, User.balance).\n...       join(User.accounts).filter(User.balance > 5000))\nSELECT  \"user\".id  AS  user_id,  \"user\".name  AS  user_name,\naccount.balance  AS  account_balance\nFROM  \"user\"  JOIN  account  ON  \"user\".id  =  account.user_id\nWHERE  account.balance  >  :balance_1 \n```", "```py\n>>> from sqlalchemy import select\n>>> from sqlalchemy import or_\n>>> print (select(User, User.balance).outerjoin(User.accounts).\n...         filter(or_(User.balance < 5000, User.balance == None)))\nSELECT  \"user\".id  AS  user_id,  \"user\".name  AS  user_name,\naccount.balance  AS  account_balance\nFROM  \"user\"  LEFT  OUTER  JOIN  account  ON  \"user\".id  =  account.user_id\nWHERE  account.balance  <  :balance_1  OR  account.balance  IS  NULL \n```", "```py\nfrom __future__ import annotations\n\nfrom decimal import Decimal\nfrom typing import List\n\nfrom sqlalchemy import ForeignKey\nfrom sqlalchemy import func\nfrom sqlalchemy import Numeric\nfrom sqlalchemy import select\nfrom sqlalchemy import SQLColumnExpression\nfrom sqlalchemy import String\nfrom sqlalchemy.ext.hybrid import hybrid_property\nfrom sqlalchemy.orm import DeclarativeBase\nfrom sqlalchemy.orm import Mapped\nfrom sqlalchemy.orm import mapped_column\nfrom sqlalchemy.orm import relationship\n\nclass Base(DeclarativeBase):\n    pass\n\nclass SavingsAccount(Base):\n    __tablename__ = 'account'\n    id: Mapped[int] = mapped_column(primary_key=True)\n    user_id: Mapped[int] = mapped_column(ForeignKey('user.id'))\n    balance: Mapped[Decimal] = mapped_column(Numeric(15, 5))\n\n    owner: Mapped[User] = relationship(back_populates=\"accounts\")\n\nclass User(Base):\n    __tablename__ = 'user'\n    id: Mapped[int] = mapped_column(primary_key=True)\n    name: Mapped[str] = mapped_column(String(100))\n\n    accounts: Mapped[List[SavingsAccount]] = relationship(\n        back_populates=\"owner\", lazy=\"selectin\"\n    )\n\n    @hybrid_property\n    def balance(self) -> Decimal:\n        return sum((acc.balance for acc in self.accounts), start=Decimal(\"0\"))\n\n    @balance.inplace.expression\n    @classmethod\n    def _balance_expression(cls) -> SQLColumnExpression[Decimal]:\n        return (\n            select(func.sum(SavingsAccount.balance))\n            .where(SavingsAccount.user_id == cls.id)\n            .label(\"total_balance\")\n        )\n```", "```py\n>>> from sqlalchemy import select\n>>> print(select(User).filter(User.balance > 400))\nSELECT  \"user\".id,  \"user\".name\nFROM  \"user\"\nWHERE  (\n  SELECT  sum(account.balance)  AS  sum_1  FROM  account\n  WHERE  account.user_id  =  \"user\".id\n)  >  :param_1 \n```", "```py\nfrom __future__ import annotations\n\nfrom typing import Any\n\nfrom sqlalchemy import ColumnElement\nfrom sqlalchemy import func\nfrom sqlalchemy.ext.hybrid import Comparator\nfrom sqlalchemy.ext.hybrid import hybrid_property\nfrom sqlalchemy.orm import DeclarativeBase\nfrom sqlalchemy.orm import Mapped\nfrom sqlalchemy.orm import mapped_column\n\nclass Base(DeclarativeBase):\n    pass\n\nclass CaseInsensitiveComparator(Comparator[str]):\n    def __eq__(self, other: Any) -> ColumnElement[bool]:  # type: ignore[override]  # noqa: E501\n        return func.lower(self.__clause_element__()) == func.lower(other)\n\nclass SearchWord(Base):\n    __tablename__ = 'searchword'\n\n    id: Mapped[int] = mapped_column(primary_key=True)\n    word: Mapped[str]\n\n    @hybrid_property\n    def word_insensitive(self) -> str:\n        return self.word.lower()\n\n    @word_insensitive.inplace.comparator\n    @classmethod\n    def _word_insensitive_comparator(cls) -> CaseInsensitiveComparator:\n        return CaseInsensitiveComparator(cls.word)\n```", "```py\n>>> from sqlalchemy import select\n>>> print(select(SearchWord).filter_by(word_insensitive=\"Trucks\"))\nSELECT  searchword.id,  searchword.word\nFROM  searchword\nWHERE  lower(searchword.word)  =  lower(:lower_1) \n```", "```py\nclass CaseInsensitiveComparator(Comparator):\n    def operate(self, op, other, **kwargs):\n        return op(\n            func.lower(self.__clause_element__()),\n            func.lower(other),\n            **kwargs,\n        )\n```", "```py\nclass FirstNameOnly(Base):\n    # ...\n\n    first_name: Mapped[str]\n\n    @hybrid_property\n    def name(self) -> str:\n        return self.first_name\n\n    @name.inplace.setter\n    def _name_setter(self, value: str) -> None:\n        self.first_name = value\n\nclass FirstNameLastName(FirstNameOnly):\n    # ...\n\n    last_name: Mapped[str]\n\n    # 'inplace' is not used here; calling getter creates a copy\n    # of FirstNameOnly.name that is local to FirstNameLastName\n    @FirstNameOnly.name.getter\n    def name(self) -> str:\n        return self.first_name + ' ' + self.last_name\n\n    @name.inplace.setter\n    def _name_setter(self, value: str) -> None:\n        self.first_name, self.last_name = value.split(' ', 1)\n```", "```py\nclass FirstNameLastName(FirstNameOnly):\n    # ...\n\n    last_name: Mapped[str]\n\n    @FirstNameOnly.name.overrides.expression\n    @classmethod\n    def name(cls):\n        return func.concat(cls.first_name, ' ', cls.last_name)\n```", "```py\nclass CaseInsensitiveWord(Comparator):\n    \"Hybrid value representing a lower case representation of a word.\"\n\n    def __init__(self, word):\n        if isinstance(word, basestring):\n            self.word = word.lower()\n        elif isinstance(word, CaseInsensitiveWord):\n            self.word = word.word\n        else:\n            self.word = func.lower(word)\n\n    def operate(self, op, other, **kwargs):\n        if not isinstance(other, CaseInsensitiveWord):\n            other = CaseInsensitiveWord(other)\n        return op(self.word, other.word, **kwargs)\n\n    def __clause_element__(self):\n        return self.word\n\n    def __str__(self):\n        return self.word\n\n    key = 'word'\n    \"Label to apply to Query tuple results\"\n```", "```py\nclass SearchWord(Base):\n    __tablename__ = 'searchword'\n    id: Mapped[int] = mapped_column(primary_key=True)\n    word: Mapped[str]\n\n    @hybrid_property\n    def word_insensitive(self) -> CaseInsensitiveWord:\n        return CaseInsensitiveWord(self.word)\n```", "```py\n>>> print(select(SearchWord).filter_by(word_insensitive=\"Trucks\"))\nSELECT  searchword.id  AS  searchword_id,  searchword.word  AS  searchword_word\nFROM  searchword\nWHERE  lower(searchword.word)  =  :lower_1 \n```", "```py\n>>> from sqlalchemy.orm import aliased\n>>> sw1 = aliased(SearchWord)\n>>> sw2 = aliased(SearchWord)\n>>> print(\n...     select(sw1.word_insensitive, sw2.word_insensitive).filter(\n...         sw1.word_insensitive > sw2.word_insensitive\n...     )\n... )\nSELECT  lower(searchword_1.word)  AS  lower_1,\nlower(searchword_2.word)  AS  lower_2\nFROM  searchword  AS  searchword_1,  searchword  AS  searchword_2\nWHERE  lower(searchword_1.word)  >  lower(searchword_2.word) \n```", "```py\n>>> ws1 = SearchWord(word=\"SomeWord\")\n>>> ws1.word_insensitive == \"sOmEwOrD\"\nTrue\n>>> ws1.word_insensitive == \"XOmEwOrX\"\nFalse\n>>> print(ws1.word_insensitive)\nsomeword\n```", "```py\nclass sqlalchemy.ext.hybrid.hybrid_method\n```", "```py\nmethod __init__(func: Callable[[Concatenate[Any, _P]], _R], expr: Callable[[Concatenate[Any, _P]], SQLCoreOperations[_R]] | None = None)\n```", "```py\nfrom sqlalchemy.ext.hybrid import hybrid_method\n\nclass SomeClass:\n    @hybrid_method\n    def value(self, x, y):\n        return self._value + x + y\n\n    @value.expression\n    @classmethod\n    def value(cls, x, y):\n        return func.some_function(cls._value, x, y)\n```", "```py\nmethod expression(expr: Callable[[Concatenate[Any, _P]], SQLCoreOperations[_R]]) \u2192 hybrid_method[_P, _R]\n```", "```py\nattribute extension_type: InspectionAttrExtensionType = 'HYBRID_METHOD'\n```", "```py\nattribute inplace\n```", "```py\nattribute is_attribute = True\n```", "```py\nclass sqlalchemy.ext.hybrid.hybrid_property\n```", "```py\nmethod __init__(fget: _HybridGetterType[_T], fset: _HybridSetterType[_T] | None = None, fdel: _HybridDeleterType[_T] | None = None, expr: _HybridExprCallableType[_T] | None = None, custom_comparator: Comparator[_T] | None = None, update_expr: _HybridUpdaterType[_T] | None = None)\n```", "```py\nfrom sqlalchemy.ext.hybrid import hybrid_property\n\nclass SomeClass:\n    @hybrid_property\n    def value(self):\n        return self._value\n\n    @value.setter\n    def value(self, value):\n        self._value = value\n```", "```py\nmethod comparator(comparator: _HybridComparatorCallableType[_T]) \u2192 hybrid_property[_T]\n```", "```py\nmethod deleter(fdel: _HybridDeleterType[_T]) \u2192 hybrid_property[_T]\n```", "```py\nmethod expression(expr: _HybridExprCallableType[_T]) \u2192 hybrid_property[_T]\n```", "```py\nattribute extension_type: InspectionAttrExtensionType = 'HYBRID_PROPERTY'\n```", "```py\nmethod getter(fget: _HybridGetterType[_T]) \u2192 hybrid_property[_T]\n```", "```py\nattribute inplace\n```", "```py\nclass Interval(Base):\n    # ...\n\n    @hybrid_property\n    def radius(self) -> float:\n        return abs(self.length) / 2\n\n    @radius.inplace.setter\n    def _radius_setter(self, value: float) -> None:\n        self.length = value * 2\n\n    @radius.inplace.expression\n    def _radius_expression(cls) -> ColumnElement[float]:\n        return type_coerce(func.abs(cls.length) / 2, Float)\n```", "```py\nattribute is_attribute = True\n```", "```py\nattribute overrides\n```", "```py\nclass SuperClass:\n    # ...\n\n    @hybrid_property\n    def foobar(self):\n        return self._foobar\n\nclass SubClass(SuperClass):\n    # ...\n\n    @SuperClass.foobar.overrides.expression\n    def foobar(cls):\n        return func.subfoobar(self._foobar)\n```", "```py\nmethod setter(fset: _HybridSetterType[_T]) \u2192 hybrid_property[_T]\n```", "```py\nmethod update_expression(meth: _HybridUpdaterType[_T]) \u2192 hybrid_property[_T]\n```", "```py\nclass Person(Base):\n    # ...\n\n    first_name = Column(String)\n    last_name = Column(String)\n\n    @hybrid_property\n    def fullname(self):\n        return first_name + \" \" + last_name\n\n    @fullname.update_expression\n    def fullname(cls, value):\n        fname, lname = value.split(\" \", 1)\n        return [\n            (cls.first_name, fname),\n            (cls.last_name, lname)\n        ]\n```", "```py\nclass sqlalchemy.ext.hybrid.Comparator\n```", "```py\nclass sqlalchemy.ext.hybrid.HybridExtensionType\n```", "```py\nattribute HYBRID_METHOD = 'HYBRID_METHOD'\n```", "```py\nattribute HYBRID_PROPERTY = 'HYBRID_PROPERTY'\n```"]