- en: What’s New in SQLAlchemy 0.8?
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SQLAlchemy 0.8中的新功能是什么？
- en: 原文：[https://docs.sqlalchemy.org/en/20/changelog/migration_08.html](https://docs.sqlalchemy.org/en/20/changelog/migration_08.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://docs.sqlalchemy.org/en/20/changelog/migration_08.html](https://docs.sqlalchemy.org/en/20/changelog/migration_08.html)
- en: About this Document
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 关于本文档
- en: This document describes changes between SQLAlchemy version 0.7, undergoing maintenance
    releases as of October, 2012, and SQLAlchemy version 0.8, which is expected for
    release in early 2013.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本文档描述了SQLAlchemy版本0.7（截至2012年10月正在进行维护发布）和SQLAlchemy版本0.8（预计于2013年初发布）之间的更改。
- en: 'Document date: October 25, 2012 Updated: March 9, 2013'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 文档日期：2012年10月25日 更新日期：2013年3月9日
- en: Introduction
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍
- en: This guide introduces what’s new in SQLAlchemy version 0.8, and also documents
    changes which affect users migrating their applications from the 0.7 series of
    SQLAlchemy to 0.8.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本指南介绍了SQLAlchemy版本0.8中的新功能，并记录了影响用户将应用程序从SQLAlchemy 0.7系列迁移到0.8的更改。
- en: SQLAlchemy releases are closing in on 1.0, and each new version since 0.5 features
    fewer major usage changes. Most applications that are settled into modern 0.7
    patterns should be movable to 0.8 with no changes. Applications that use 0.6 and
    even 0.5 patterns should be directly migratable to 0.8 as well, though larger
    applications may want to test with each interim version.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy发布即将接近1.0，自0.5以来的每个新版本都减少了主要的使用更改。大多数已经适应现代0.7模式的应用程序应该可以无需更改地迁移到0.8。使用0.6甚至0.5模式的应用程序也应该可以直接迁移到0.8，尽管较大的应用程序可能希望在每个中间版本中进行测试。
- en: Platform Support
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 平台支持
- en: Targeting Python 2.5 and Up Now
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 现在面向Python 2.5及更高版本
- en: SQLAlchemy 0.8 will target Python 2.5 and forward; compatibility for Python
    2.4 is being dropped.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 0.8将面向Python 2.5及更高版本；对Python 2.4的兼容性将被删除。
- en: The internals will be able to make usage of Python ternaries (that is, `x if
    y else z`) which will improve things versus the usage of `y and x or z`, which
    naturally has been the source of some bugs, as well as context managers (that
    is, `with:`) and perhaps in some cases `try:/except:/else:` blocks which will
    help with code readability.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 内部将能够使用Python三元表达式（即，`x if y else z`），这将改善与使用`y and x or z`相比的情况，后者自然会导致一些错误，以及上下文管理器（即，`with:`）和在某些情况下可能会有助于代码可读性的`try:/except:/else:`块。
- en: SQLAlchemy will eventually drop 2.5 support as well - when 2.6 is reached as
    the baseline, SQLAlchemy will move to use 2.6/3.3 in-place compatibility, removing
    the usage of the `2to3` tool and maintaining a source base that works with Python
    2 and 3 at the same time.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy最终将放弃对2.5的支持 - 当达到2.6作为基线时，SQLAlchemy将转而使用2.6/3.3的就地兼容性，删除`2to3`工具的使用，并保持一个同时与Python
    2和3兼容的源代码库。
- en: New ORM Features
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 新的ORM功能
- en: '### Rewritten [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") mechanics'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '### 重写的[`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")机制'
- en: '0.8 features a much improved and capable system regarding how [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") determines how to join between two entities. The
    new system includes these features:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 0.8版本在[`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")如何确定两个实体之间如何连接方面具有更加改进和强大的系统。新系统包括以下功能：
- en: 'The `primaryjoin` argument is **no longer needed** when constructing a [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") against a class that has multiple foreign key paths
    to the target. Only the `foreign_keys` argument is needed to specify those columns
    which should be included:'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在构建针对具有多个外键路径指向目标的类的[`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")时，**不再需要**`primaryjoin`参数。只需要`foreign_keys`参数来指定应包括的列：
- en: '[PRE0]'
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'relationships against self-referential, composite foreign keys where **a column
    points to itself** are now supported. The canonical case is as follows:'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持自引用、复合外键的关系，其中**一列指向自身**。典型案例如下：
- en: '[PRE1]'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Above, the `Folder` refers to its parent `Folder` joining from `account_id`
    to itself, and `parent_id` to `folder_id`. When SQLAlchemy constructs an auto-
    join, no longer can it assume all columns on the “remote” side are aliased, and
    all columns on the “local” side are not - the `account_id` column is **on both
    sides**. So the internal relationship mechanics were totally rewritten to support
    an entirely different system whereby two copies of `account_id` are generated,
    each containing different *annotations* to determine their role within the statement.
    Note the join condition within a basic eager load:'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上面，`Folder`指的是从`account_id`到其自身的父`Folder`的连接，并且`parent_id`到`folder_id`的连接。当SQLAlchemy构造自动连接时，不能再假设“远程”侧的所有列都被别名化，而“本地”侧的所有列都没有被别名化
    - `account_id`列**在两侧都存在**。因此，内部关系机制完全重写，以支持一个完全不同的系统，其中生成了两个副本的`account_id`，每个副本包含不同的*注释*以确定它们在语句中的作用。注意基本急加载中的连接条件：
- en: '[PRE2]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Previously difficult custom join conditions, like those involving functions
    and/or CASTing of types, will now function as expected in most cases:'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以前的复杂自定义连接条件，比如涉及函数和/或类型转换（CASTing）的条件，现在在大多数情况下都将按预期运行：
- en: '[PRE3]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The new [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") mechanics make use of a SQLAlchemy concept known
    as [annotations](../glossary.html#term-annotations). These annotations are also
    available to application code explicitly via the [`foreign()`](../orm/relationship_api.html#sqlalchemy.orm.foreign
    "sqlalchemy.orm.foreign") and [`remote()`](../orm/relationship_api.html#sqlalchemy.orm.remote
    "sqlalchemy.orm.remote") functions, either as a means to improve readability for
    advanced configurations or to directly inject an exact configuration, bypassing
    the usual join-inspection heuristics:'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 新的[`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")机制利用了SQLAlchemy的一个概念，称为[注释](../glossary.html#term-annotations)。这些注释也可以通过[`foreign()`](../orm/relationship_api.html#sqlalchemy.orm.foreign
    "sqlalchemy.orm.foreign")和[`remote()`](../orm/relationship_api.html#sqlalchemy.orm.remote
    "sqlalchemy.orm.remote")函数明确提供给应用代码，无论是为了提高高级配置的可读性，还是直接注入一个精确的配置，绕过通常的连接检查启发式方法：
- en: '[PRE4]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: See also
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Configuring how Relationship Joins](../orm/join_conditions.html#relationship-configure-joins)
    - a newly revised section on [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") detailing the latest techniques for customizing
    related attributes and collection access.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '[配置关系连接方式](../orm/join_conditions.html#relationship-configure-joins) - 一个重新修订的关于[`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")的部分，详细说明了定制相关属性和集合访问的最新技术。'
- en: '[#1401](https://www.sqlalchemy.org/trac/ticket/1401) [#610](https://www.sqlalchemy.org/trac/ticket/610)  ###
    New Class/Object Inspection System'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '[#1401](https://www.sqlalchemy.org/trac/ticket/1401) [#610](https://www.sqlalchemy.org/trac/ticket/610)  ###
    新的类/对象检查系统'
- en: Lots of SQLAlchemy users are writing systems that require the ability to inspect
    the attributes of a mapped class, including being able to get at the primary key
    columns, object relationships, plain attributes, and so forth, typically for the
    purpose of building data-marshalling systems, like JSON/XML conversion schemes
    and of course form libraries galore.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 许多SQLAlchemy用户正在编写需要检查映射类属性的系统，包括能够获取主键列、对象关系、普通属性等等，通常是为了构建数据编组系统，比如JSON/XML转换方案以及各种表单库。
- en: Originally, the [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    and [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    model were the original inspection points, which have a well-documented system.
    While SQLAlchemy ORM models are also fully introspectable, this has never been
    a fully stable and supported feature, and users tended to not have a clear idea
    how to get at this information.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，[`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")和[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")模型是最初的检查点，具有完整的文档系统。虽然SQLAlchemy ORM模型也是完全可自省的，但这从来都不是一个完全稳定和受支持的功能，用户往往不清楚如何获取这些信息。
- en: 0.8 now provides a consistent, stable and fully documented API for this purpose,
    including an inspection system which works on mapped classes, instances, attributes,
    and other Core and ORM constructs. The entrypoint to this system is the core-level
    [`inspect()`](../core/inspection.html#sqlalchemy.inspect "sqlalchemy.inspect")
    function. In most cases, the object being inspected is one already part of SQLAlchemy’s
    system, such as [`Mapper`](../orm/mapping_api.html#sqlalchemy.orm.Mapper "sqlalchemy.orm.Mapper"),
    [`InstanceState`](../orm/internals.html#sqlalchemy.orm.InstanceState "sqlalchemy.orm.InstanceState"),
    [`Inspector`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector "sqlalchemy.engine.reflection.Inspector").
    In some cases, new objects have been added with the job of providing the inspection
    API in certain contexts, such as [`AliasedInsp`](../orm/queryguide/api.html#sqlalchemy.orm.util.AliasedInsp
    "sqlalchemy.orm.util.AliasedInsp") and [`AttributeState`](../orm/internals.html#sqlalchemy.orm.AttributeState
    "sqlalchemy.orm.AttributeState").
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 0.8 现在为此提供了一致、稳定且完全文档化的 API，包括一个检查系统，该系统适用于映射类、实例、属性以及其他核心和 ORM 构造。该系统的入口点是核心级的
    [`inspect()`](../core/inspection.html#sqlalchemy.inspect "sqlalchemy.inspect")
    函数。在大多数情况下，被检查的对象已经是 SQLAlchemy 系统的一部分，例如 [`Mapper`](../orm/mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper")、[`InstanceState`](../orm/internals.html#sqlalchemy.orm.InstanceState
    "sqlalchemy.orm.InstanceState")、[`Inspector`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector
    "sqlalchemy.engine.reflection.Inspector")。在某些情况下，已经添加了新对象，其工作是在某些上下文中提供检查 API，例如
    [`AliasedInsp`](../orm/queryguide/api.html#sqlalchemy.orm.util.AliasedInsp "sqlalchemy.orm.util.AliasedInsp")
    和 [`AttributeState`](../orm/internals.html#sqlalchemy.orm.AttributeState "sqlalchemy.orm.AttributeState")。
- en: 'A walkthrough of some key capabilities follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些关键功能的介绍：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: See also
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[Runtime Inspection API](../core/inspection.html)'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '[运行时检查 API](../core/inspection.html)'
- en: '[#2208](https://www.sqlalchemy.org/trac/ticket/2208)'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2208](https://www.sqlalchemy.org/trac/ticket/2208)'
- en: New with_polymorphic() feature, can be used anywhere
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 新的 with_polymorphic() 功能，可以在任何地方使用
- en: 'The `Query.with_polymorphic()` method allows the user to specify which tables
    should be present when querying against a joined-table entity. Unfortunately the
    method is awkward and only applies to the first entity in the list, and otherwise
    has awkward behaviors both in usage as well as within the internals. A new enhancement
    to the [`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased "sqlalchemy.orm.aliased")
    construct has been added called [`with_polymorphic()`](../orm/queryguide/inheritance.html#sqlalchemy.orm.with_polymorphic
    "sqlalchemy.orm.with_polymorphic") which allows any entity to be “aliased” into
    a “polymorphic” version of itself, freely usable anywhere:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`Query.with_polymorphic()` 方法允许用户指定在针对联接表实体进行查询时应该存在哪些表。不幸的是，该方法很笨拙，只适用于列表中的第一个实体，而且在使用和内部方面都有一些尴尬的行为。现在已经添加了一个新的增强功能到
    [`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased "sqlalchemy.orm.aliased")
    构造中，称为 [`with_polymorphic()`](../orm/queryguide/inheritance.html#sqlalchemy.orm.with_polymorphic
    "sqlalchemy.orm.with_polymorphic")，它允许任何实体被“别名”为其自身的“多态”版本，可以自由地在任何地方使用：'
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: See also
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[Using with_polymorphic()](../orm/queryguide/inheritance.html#with-polymorphic)
    - newly updated documentation for polymorphic loading control.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用 with_polymorphic()](../orm/queryguide/inheritance.html#with-polymorphic)
    - 用于多态加载控制的最新更新文档。'
- en: '[#2333](https://www.sqlalchemy.org/trac/ticket/2333)'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2333](https://www.sqlalchemy.org/trac/ticket/2333)'
- en: of_type() works with alias(), with_polymorphic(), any(), has(), joinedload(),
    subqueryload(), contains_eager()
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: of_type() 与 alias()、with_polymorphic()、any()、has()、joinedload()、subqueryload()、contains_eager()
    配合使用
- en: 'The [`PropComparator.of_type()`](../orm/internals.html#sqlalchemy.orm.PropComparator.of_type
    "sqlalchemy.orm.PropComparator.of_type") method is used to specify a specific
    subtype to use when constructing SQL expressions along a [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") that has a [polymorphic](../glossary.html#term-polymorphic)
    mapping as its target. This method can now be used to target *any number* of target
    subtypes, by combining it with the new [`with_polymorphic()`](../orm/queryguide/inheritance.html#sqlalchemy.orm.with_polymorphic
    "sqlalchemy.orm.with_polymorphic") function:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '[`PropComparator.of_type()`](../orm/internals.html#sqlalchemy.orm.PropComparator.of_type
    "sqlalchemy.orm.PropComparator.of_type") 方法用于在构建 SQL 表达式时指定要使用的特定子类型，该子类型作为其目标具有
    [多态](../glossary.html#term-polymorphic) 映射的 [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") 的目标。现在可以使用该方法来针对 *任意数量* 的目标子类型，通过与新的 [`with_polymorphic()`](../orm/queryguide/inheritance.html#sqlalchemy.orm.with_polymorphic
    "sqlalchemy.orm.with_polymorphic") 函数结合使用：'
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The method now works equally well in most places a regular relationship attribute
    is accepted, including with loader functions like [`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload"), [`subqueryload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.subqueryload
    "sqlalchemy.orm.subqueryload"), [`contains_eager()`](../orm/queryguide/relationships.html#sqlalchemy.orm.contains_eager
    "sqlalchemy.orm.contains_eager"), and comparison methods like [`PropComparator.any()`](../orm/internals.html#sqlalchemy.orm.PropComparator.any
    "sqlalchemy.orm.PropComparator.any") and [`PropComparator.has()`](../orm/internals.html#sqlalchemy.orm.PropComparator.has
    "sqlalchemy.orm.PropComparator.has"):'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法现在在大多数接受常规关系属性的地方同样有效，包括与[`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload")、[`subqueryload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.subqueryload
    "sqlalchemy.orm.subqueryload")、[`contains_eager()`](../orm/queryguide/relationships.html#sqlalchemy.orm.contains_eager
    "sqlalchemy.orm.contains_eager")等加载器函数以及与[`PropComparator.any()`](../orm/internals.html#sqlalchemy.orm.PropComparator.any
    "sqlalchemy.orm.PropComparator.any")和[`PropComparator.has()`](../orm/internals.html#sqlalchemy.orm.PropComparator.has
    "sqlalchemy.orm.PropComparator.has")等比较方法一起：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: See also
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[Joining to specific sub-types or with_polymorphic() entities](../orm/queryguide/inheritance.html#inheritance-of-type)'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '[加入特定子类型或with_polymorphic()实体](../orm/queryguide/inheritance.html#inheritance-of-type)'
- en: '[#2438](https://www.sqlalchemy.org/trac/ticket/2438) [#1106](https://www.sqlalchemy.org/trac/ticket/1106)'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2438](https://www.sqlalchemy.org/trac/ticket/2438) [#1106](https://www.sqlalchemy.org/trac/ticket/1106)'
- en: Events Can Be Applied to Unmapped Superclasses
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 事件可应用于未映射的超类
- en: 'Mapper and instance events can now be associated with an unmapped superclass,
    where those events will be propagated to subclasses as those subclasses are mapped.
    The `propagate=True` flag should be used. This feature allows events to be associated
    with a declarative base class:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以将映射器和实例事件与未映射的超类关联，这些事件将随着子类映射而传播。应使用`propagate=True`标志。此功能允许将事件与声明性基类关联：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[#2585](https://www.sqlalchemy.org/trac/ticket/2585)'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2585](https://www.sqlalchemy.org/trac/ticket/2585)'
- en: Declarative Distinguishes Between Modules/Packages
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Declarative区分模块/包
- en: 'A key feature of Declarative is the ability to refer to other mapped classes
    using their string name. The registry of class names is now sensitive to the owning
    module and package of a given class. The classes can be referred to via dotted
    name in expressions:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Declarative的一个关键特性是能够使用它们的字符串名称引用其他映射类。类名注册表现在对给定类的拥有模块和包敏感。这些类可以在表达式中通过点名引用：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The resolution allows that any full or partial disambiguating package name can
    be used. If the path to a particular class is still ambiguous, an error is raised.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 该解析允许使用任何完整或部分消歧义的包名称。如果到特定类的路径仍然模糊，将引发错误。
- en: '[#2338](https://www.sqlalchemy.org/trac/ticket/2338)'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2338](https://www.sqlalchemy.org/trac/ticket/2338)'
- en: New DeferredReflection Feature in Declarative
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Declarative中的新DeferredReflection功能
- en: 'The “deferred reflection” example has been moved to a supported feature within
    Declarative. This feature allows the construction of declarative mapped classes
    with only placeholder `Table` metadata, until a `prepare()` step is called, given
    an `Engine` with which to reflect fully all tables and establish actual mappings.
    The system supports overriding of columns, single and joined inheritance, as well
    as distinct bases-per-engine. A full declarative configuration can now be created
    against an existing table that is assembled upon engine creation time in one step:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: “延迟反射”示例已移至Declarative中的受支持功能。此功能允许仅使用占位符`Table`元数据构建声明性映射类，直到调用`prepare()`步骤，给定一个`Engine`，以完全反射所有表并建立实际映射。该系统支持列的覆盖、单一和联接继承，以及每个引擎的不同基础。现在可以在一个步骤中针对现有表创建完整的声明性配置：
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: See also
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[`DeferredReflection`](../orm/extensions/declarative/index.html#sqlalchemy.ext.declarative.DeferredReflection
    "sqlalchemy.ext.declarative.DeferredReflection")'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '[`DeferredReflection`](../orm/extensions/declarative/index.html#sqlalchemy.ext.declarative.DeferredReflection
    "sqlalchemy.ext.declarative.DeferredReflection")'
- en: '[#2485](https://www.sqlalchemy.org/trac/ticket/2485)'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2485](https://www.sqlalchemy.org/trac/ticket/2485)'
- en: ORM Classes Now Accepted by Core Constructs
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ORM类现在被核心构造所接受
- en: 'While the SQL expressions used with [`Query.filter()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.filter
    "sqlalchemy.orm.Query.filter"), such as `User.id == 5`, have always been compatible
    for use with core constructs such as [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select"), the mapped class itself would not be recognized
    when passed to [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select"), [`Select.select_from()`](../core/selectable.html#sqlalchemy.sql.expression.Select.select_from
    "sqlalchemy.sql.expression.Select.select_from"), or [`Select.correlate()`](../core/selectable.html#sqlalchemy.sql.expression.Select.correlate
    "sqlalchemy.sql.expression.Select.correlate"). A new SQL registration system allows
    a mapped class to be accepted as a FROM clause within the core:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然与[`Query.filter()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.filter
    "sqlalchemy.orm.Query.filter")一起使用的SQL表达式，如`User.id == 5`，一直与核心构造兼容，例如[`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select")，但当传递给[`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select")、[`Select.select_from()`](../core/selectable.html#sqlalchemy.sql.expression.Select.select_from
    "sqlalchemy.sql.expression.Select.select_from")或[`Select.correlate()`](../core/selectable.html#sqlalchemy.sql.expression.Select.correlate
    "sqlalchemy.sql.expression.Select.correlate")时，映射类本身将不被识别。一个新的SQL注册系统允许一个映射类作为核心中的FROM子句被接受：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Above, the mapped `User` class will expand into the [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") to which `User` is mapped.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 上面，映射的`User`类将扩展为[`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")，`User`被映射到其中的表。
- en: '[#2245](https://www.sqlalchemy.org/trac/ticket/2245)'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2245](https://www.sqlalchemy.org/trac/ticket/2245)'
- en: '### Query.update() supports UPDATE..FROM'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '### Query.update()支持UPDATE..FROM'
- en: 'The new UPDATE..FROM mechanics work in query.update(). Below, we emit an UPDATE
    against `SomeEntity`, adding a FROM clause (or equivalent, depending on backend)
    against `SomeOtherEntity`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 新的UPDATE..FROM机制适用于query.update()。下面，我们对`SomeEntity`执行UPDATE操作，添加一个FROM子句（或等效的，取决于后端）对`SomeOtherEntity`：
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In particular, updates to joined-inheritance entities are supported, provided
    the target of the UPDATE is local to the table being filtered on, or if the parent
    and child tables are mixed, they are joined explicitly in the query. Below, given
    `Engineer` as a joined subclass of `Person`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 特别地，支持对连接继承实体的更新，前提是UPDATE的目标是本地表上的表，或者如果父表和子表混合，它们在查询中被显式连接。下面，假设`Engineer`是`Person`的一个连接子类：
- en: '[PRE14]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'would produce:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 将产生：
- en: '[PRE15]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[#2365](https://www.sqlalchemy.org/trac/ticket/2365)'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2365](https://www.sqlalchemy.org/trac/ticket/2365)'
- en: rollback() will only roll back “dirty” objects from a begin_nested()
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: rollback()仅会回滚从begin_nested()开始的“脏”对象
- en: A behavioral change that should improve efficiency for those users using SAVEPOINT
    via `Session.begin_nested()` - upon `rollback()`, only those objects that were
    made dirty since the last flush will be expired, the rest of the `Session` remains
    intact. This because a ROLLBACK to a SAVEPOINT does not terminate the containing
    transaction’s isolation, so no expiry is needed except for those changes that
    were not flushed in the current transaction.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 一项行为变更应该提高那些通过`Session.begin_nested()`使用SAVEPOINT的用户的效率 - 在`rollback()`时，只有自上次刷新以来被标记为脏的对象将被过期，其余的`Session`保持不变。这是因为对SAVEPOINT的ROLLBACK不会终止包含事务的隔离，因此除了当前事务中未刷新的更改外，不需要过期。
- en: '[#2452](https://www.sqlalchemy.org/trac/ticket/2452)'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2452](https://www.sqlalchemy.org/trac/ticket/2452)'
- en: Caching Example now uses dogpile.cache
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 缓存示例现在使用dogpile.cache
- en: The caching example now uses [dogpile.cache](https://dogpilecache.readthedocs.io/).
    Dogpile.cache is a rewrite of the caching portion of Beaker, featuring vastly
    simpler and faster operation, as well as support for distributed locking.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存示例现在使用[dogpile.cache](https://dogpilecache.readthedocs.io/)。Dogpile.cache是Beaker缓存部分的重写，具有更简单和更快的操作，以及支持分布式锁定。
- en: 'Note that the SQLAlchemy APIs used by the Dogpile example as well as the previous
    Beaker example have changed slightly, in particular this change is needed as illustrated
    in the Beaker example:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Dogpile示例以及之前的Beaker示例中使用的SQLAlchemy API略有变化，特别是需要如Beaker示例中所示的这种变化：
- en: '[PRE16]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: See also
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[Dogpile Caching](../orm/examples.html#examples-caching)'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '[Dogpile缓存](../orm/examples.html#examples-caching)'
- en: '[#2589](https://www.sqlalchemy.org/trac/ticket/2589)'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2589](https://www.sqlalchemy.org/trac/ticket/2589)'
- en: New Core Features
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 新的核心功能
- en: Fully extensible, type-level operator support in Core
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 完全可扩展，核心中支持类型级别的操作符
- en: The Core has to date never had any system of adding support for new SQL operators
    to Column and other expression constructs, other than the [`ColumnOperators.op()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.op
    "sqlalchemy.sql.expression.ColumnOperators.op") method which is “just enough”
    to make things work. There has also never been any system in place for Core which
    allows the behavior of existing operators to be overridden. Up until now, the
    only way operators could be flexibly redefined was in the ORM layer, using [`column_property()`](../orm/mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property") given a `comparator_factory` argument. Third
    party libraries like GeoAlchemy therefore were forced to be ORM-centric and rely
    upon an array of hacks to apply new operations as well as to get them to propagate
    correctly.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，Core 从未有过任何系统来为 Column 和其他表达式构造添加对新 SQL 操作符的支持，除了[`ColumnOperators.op()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.op
    "sqlalchemy.sql.expression.ColumnOperators.op") 方法，这个方法“刚好”能使事情正常工作。此外，Core 中也从未存在过任何允许覆盖现有操作符行为的系统。直到现在，操作符能够灵活重新定义的唯一方式是在
    ORM 层，使用给定 `comparator_factory` 参数的 [`column_property()`](../orm/mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property")。因此，像 GeoAlchemy 这样的第三方库被迫以 ORM 为中心，并依赖于一系列的黑客技巧来应用新的操作以及正确地传播它们。
- en: The new operator system in Core adds the one hook that’s been missing all along,
    which is to associate new and overridden operators with *types*. Since after all,
    it’s not really a column, CAST operator, or SQL function that really drives what
    kinds of operations are present, it’s the *type* of the expression. The implementation
    details are minimal - only a few extra methods are added to the core [`ColumnElement`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement") type so that it consults its [`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") object for an optional set of operators. New or
    revised operations can be associated with any type, either via subclassing of
    an existing type, by using [`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator"), or “globally across-the-board” by attaching
    a new [`Comparator`](../core/type_api.html#sqlalchemy.types.TypeEngine.Comparator
    "sqlalchemy.types.TypeEngine.Comparator") object to an existing type class.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Core 中的新操作符系统增加了一直缺失的一个关键点，即将新的和被覆盖的操作符与 *类型* 关联起来。毕竟，真正驱动操作存在的不是列、CAST 操作符或
    SQL 函数，而是表达式的 *类型*。实现细节很少——只需向核心 [`ColumnElement`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement") 类型添加几个额外的方法，以便它向其 [`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") 对象咨询可选的一组操作符。新的或修订过的操作可以与任何类型关联，可以通过对现有类型进行子类化、使用
    [`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")，或者通过将新的
    [`Comparator`](../core/type_api.html#sqlalchemy.types.TypeEngine.Comparator "sqlalchemy.types.TypeEngine.Comparator")
    对象附加到现有类型类来“全面覆盖”地关联。
- en: 'For example, to add logarithm support to [`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric
    "sqlalchemy.types.Numeric") types:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要为 [`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric "sqlalchemy.types.Numeric")
    类型添加对数支持：
- en: '[PRE17]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The new type is usable like any other type:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 新类型可以像任何其他类型一样使用：
- en: '[PRE18]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: New features which have come from this immediately include support for PostgreSQL’s
    HSTORE type, as well as new operations associated with PostgreSQL’s ARRAY type.
    It also paves the way for existing types to acquire lots more operators that are
    specific to those types, such as more string, integer and date operators.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里产生的新功能包括对 PostgreSQL 的 HSTORE 类型的支持，以及与 PostgreSQL 的 ARRAY 类型相关的新操作。它还为现有类型铺平了道路，使其能够获取更多特定于这些类型的运算符，例如更多的字符串、整数和日期运算符。
- en: See also
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Redefining and Creating New Operators](../core/custom_types.html#types-operators)'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '[重新定义和创建新的操作符](../core/custom_types.html#types-operators)'
- en: '[`HSTORE`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.HSTORE
    "sqlalchemy.dialects.postgresql.HSTORE")'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '[`HSTORE`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.HSTORE
    "sqlalchemy.dialects.postgresql.HSTORE")'
- en: '[#2547](https://www.sqlalchemy.org/trac/ticket/2547)'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2547](https://www.sqlalchemy.org/trac/ticket/2547)'
- en: '### Multiple-VALUES support for Insert'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '### 对插入的多值支持'
- en: 'The [`Insert.values()`](../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") method now supports a list of dictionaries,
    which will render a multi-VALUES statement such as `VALUES (<row1>), (<row2>),
    ...`. This is only relevant to backends which support this syntax, including PostgreSQL,
    SQLite, and MySQL. It is not the same thing as the usual `executemany()` style
    of INSERT which remains unchanged:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Insert.values()`](../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") 方法现在支持字典列表，将呈现多VALUES语句，如 `VALUES (<row1>),
    (<row2>), ...`。这仅适用于支持此语法的后端，包括PostgreSQL、SQLite和MySQL。这与通常的 `executemany()` 样式的INSERT不同：'
- en: '[PRE19]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: See also
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`Insert.values()`](../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values")'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Insert.values()`](../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values")'
- en: '[#2623](https://www.sqlalchemy.org/trac/ticket/2623)'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2623](https://www.sqlalchemy.org/trac/ticket/2623)'
- en: Type Expressions
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类型表达式
- en: 'SQL expressions can now be associated with types. Historically, [`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") has always allowed Python-side functions which
    receive both bound parameters as well as result row values, passing them through
    a Python side conversion function on the way to/back from the database. The new
    feature allows similar functionality, except on the database side:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以将SQL表达式与类型关联起来。从历史上看，[`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") 一直允许Python端函数接收绑定参数和结果行值，通过Python端转换函数来回传递到/从数据库。新功能允许类似的功能，但在数据库端实现：
- en: '[PRE20]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Above, the `LowerString` type defines a SQL expression that will be emitted
    whenever the `test_table.c.data` column is rendered in the columns clause of a
    SELECT statement:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，`LowerString` 类型定义了一个SQL表达式，每当 `test_table.c.data` 列在SELECT语句的列子句中呈现时，该表达式将被发出：
- en: '[PRE21]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This feature is also used heavily by the new release of GeoAlchemy, to embed
    PostGIS expressions inline in SQL based on type rules.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这一功能也被新版的GeoAlchemy大量使用，可以根据类型规则在SQL中内联嵌入PostGIS表达式。
- en: See also
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Applying SQL-level Bind/Result Processing](../core/custom_types.html#types-sql-value-processing)'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '[应用SQL级别的绑定/结果处理](../core/custom_types.html#types-sql-value-processing)'
- en: '[#1534](https://www.sqlalchemy.org/trac/ticket/1534)'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '[#1534](https://www.sqlalchemy.org/trac/ticket/1534)'
- en: Core Inspection System
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 核心检查系统
- en: 'The [`inspect()`](../core/inspection.html#sqlalchemy.inspect "sqlalchemy.inspect")
    function introduced in [New Class/Object Inspection System](#feature-orminspection-08)
    also applies to the core. Applied to an [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") it produces an [`Inspector`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector
    "sqlalchemy.engine.reflection.Inspector") object:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '[New Class/Object Inspection System](#feature-orminspection-08) 中引入的 [`inspect()`](../core/inspection.html#sqlalchemy.inspect
    "sqlalchemy.inspect") 函数也适用于核心。应用于一个 [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") 会产生一个 [`Inspector`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector
    "sqlalchemy.engine.reflection.Inspector") 对象：'
- en: '[PRE22]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: It can also be applied to any [`ClauseElement`](../core/foundation.html#sqlalchemy.sql.expression.ClauseElement
    "sqlalchemy.sql.expression.ClauseElement"), which returns the [`ClauseElement`](../core/foundation.html#sqlalchemy.sql.expression.ClauseElement
    "sqlalchemy.sql.expression.ClauseElement") itself, such as [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table"), [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column"), [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select"), etc. This allows it to work fluently between
    Core and ORM constructs.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 它也可以应用于任何 [`ClauseElement`](../core/foundation.html#sqlalchemy.sql.expression.ClauseElement
    "sqlalchemy.sql.expression.ClauseElement")，它返回 [`ClauseElement`](../core/foundation.html#sqlalchemy.sql.expression.ClauseElement
    "sqlalchemy.sql.expression.ClauseElement") 本身，比如 [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")，[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")，[`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") 等。这使得它可以在核心和ORM构造之间流畅工作。
- en: New Method [`Select.correlate_except()`](../core/selectable.html#sqlalchemy.sql.expression.Select.correlate_except
    "sqlalchemy.sql.expression.Select.correlate_except")
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 新方法 [`Select.correlate_except()`](../core/selectable.html#sqlalchemy.sql.expression.Select.correlate_except
    "sqlalchemy.sql.expression.Select.correlate_except")
- en: '[`select()`](../core/selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select")
    now has a method [`Select.correlate_except()`](../core/selectable.html#sqlalchemy.sql.expression.Select.correlate_except
    "sqlalchemy.sql.expression.Select.correlate_except") which specifies “correlate
    on all FROM clauses except those specified”. It can be used for mapping scenarios
    where a related subquery should correlate normally, except against a particular
    target selectable:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '[`select()`](../core/selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select")
    现在有一个方法 [`Select.correlate_except()`](../core/selectable.html#sqlalchemy.sql.expression.Select.correlate_except
    "sqlalchemy.sql.expression.Select.correlate_except")，指定“除了指定的所有FROM子句之外的相关性”。它可用于映射场景，其中相关子查询应该正常关联，除了针对特定目标可选择的情况：'
- en: '[PRE23]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: See also
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`Select.correlate_except()`](../core/selectable.html#sqlalchemy.sql.expression.Select.correlate_except
    "sqlalchemy.sql.expression.Select.correlate_except")'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Select.correlate_except()`](../core/selectable.html#sqlalchemy.sql.expression.Select.correlate_except
    "sqlalchemy.sql.expression.Select.correlate_except")'
- en: PostgreSQL HSTORE type
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PostgreSQL HSTORE类型
- en: 'Support for PostgreSQL’s `HSTORE` type is now available as [`HSTORE`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.HSTORE
    "sqlalchemy.dialects.postgresql.HSTORE"). This type makes great usage of the new
    operator system to provide a full range of operators for HSTORE types, including
    index access, concatenation, and containment methods such as `comparator_factory.has_key()`,
    `comparator_factory.has_any()`, and `comparator_factory.matrix()`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: PostgreSQL的`HSTORE`类型的支持现在可用作为[`HSTORE`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.HSTORE
    "sqlalchemy.dialects.postgresql.HSTORE")。此类型充分利用了新的运算符系统，为HSTORE类型提供了一整套运算符，包括索引访问、连接和包含方法，如`comparator_factory.has_key()`、`comparator_factory.has_any()`和`comparator_factory.matrix()`：
- en: '[PRE24]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: See also
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`HSTORE`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.HSTORE
    "sqlalchemy.dialects.postgresql.HSTORE")'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '[`HSTORE`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.HSTORE
    "sqlalchemy.dialects.postgresql.HSTORE")'
- en: '[`hstore`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.hstore
    "sqlalchemy.dialects.postgresql.hstore")'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '[`hstore`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.hstore
    "sqlalchemy.dialects.postgresql.hstore")'
- en: '[#2606](https://www.sqlalchemy.org/trac/ticket/2606)'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2606](https://www.sqlalchemy.org/trac/ticket/2606)'
- en: Enhanced PostgreSQL ARRAY type
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 增强的PostgreSQL ARRAY类型
- en: 'The [`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY") type will accept an optional “dimension”
    argument, pinning it to a fixed number of dimensions and greatly improving efficiency
    when retrieving results:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '[`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY") 类型将接受一个可选的“维度”参数，将其固定到一个固定数量的维度，并在检索结果时大大提高效率：'
- en: '[PRE25]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The type also introduces new operators, using the new type-specific operator
    framework. New operations include indexed access:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 该类型还引入了新的运算符，使用新的类型特定运算符框架。新操作包括索引访问：
- en: '[PRE26]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'slice access in SELECT:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 切片访问在SELECT中：
- en: '[PRE27]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'slice updates in UPDATE:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 切片更新在UPDATE中：
- en: '[PRE28]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'freestanding array literals:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 独立的数组文字：
- en: '[PRE29]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'array concatenation, where below, the right side `[4, 5, 6]` is coerced into
    an array literal:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 数组连接，在下面，右侧的`[4, 5, 6]` 被强制转换为数组文字：
- en: '[PRE30]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: See also
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY")'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '[`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY")'
- en: '[`array`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.array
    "sqlalchemy.dialects.postgresql.array")'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '[`array`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.array
    "sqlalchemy.dialects.postgresql.array")'
- en: '[#2441](https://www.sqlalchemy.org/trac/ticket/2441)'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2441](https://www.sqlalchemy.org/trac/ticket/2441)'
- en: New, configurable DATE, TIME types for SQLite
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 新的、可配置的DATE、TIME类型用于SQLite
- en: SQLite has no built-in DATE, TIME, or DATETIME types, and instead provides some
    support for storage of date and time values either as strings or integers. The
    date and time types for SQLite are enhanced in 0.8 to be much more configurable
    as to the specific format, including that the “microseconds” portion is optional,
    as well as pretty much everything else.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite没有内置的DATE、TIME或DATETIME类型，而是提供了一些支持将日期和时间值存储为字符串或整数的方法。SQLite的日期和时间类型在0.8中得到了增强，可以更加灵活地配置特定格式，包括“微秒”部分是可选的，以及几乎所有其他内容。
- en: '[PRE31]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Huge thanks to Nate Dub for the sprinting on this at Pycon 2012.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 非常感谢Nate Dub在Pycon 2012上的努力。
- en: See also
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`DATETIME`](../dialects/sqlite.html#sqlalchemy.dialects.sqlite.DATETIME "sqlalchemy.dialects.sqlite.DATETIME")'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '[`DATETIME`](../dialects/sqlite.html#sqlalchemy.dialects.sqlite.DATETIME "sqlalchemy.dialects.sqlite.DATETIME")'
- en: '[`DATE`](../dialects/sqlite.html#sqlalchemy.dialects.sqlite.DATE "sqlalchemy.dialects.sqlite.DATE")'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '[`DATE`](../dialects/sqlite.html#sqlalchemy.dialects.sqlite.DATE "sqlalchemy.dialects.sqlite.DATE")'
- en: '[`TIME`](../dialects/sqlite.html#sqlalchemy.dialects.sqlite.TIME "sqlalchemy.dialects.sqlite.TIME")'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '[`TIME`](../dialects/sqlite.html#sqlalchemy.dialects.sqlite.TIME "sqlalchemy.dialects.sqlite.TIME")'
- en: '[#2363](https://www.sqlalchemy.org/trac/ticket/2363)'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2363](https://www.sqlalchemy.org/trac/ticket/2363)'
- en: “COLLATE” supported across all dialects; in particular MySQL, PostgreSQL, SQLite
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: “COLLATE”在所有方言中都受支持；特别是MySQL、PostgreSQL、SQLite
- en: 'The “collate” keyword, long accepted by the MySQL dialect, is now established
    on all [`String`](../core/type_basics.html#sqlalchemy.types.String "sqlalchemy.types.String")
    types and will render on any backend, including when features such as [`MetaData.create_all()`](../core/metadata.html#sqlalchemy.schema.MetaData.create_all
    "sqlalchemy.schema.MetaData.create_all") and [`cast()`](../core/sqlelement.html#sqlalchemy.sql.expression.cast
    "sqlalchemy.sql.expression.cast") is used:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: “collate”关键字，长期被MySQL方言接受，现在已经在所有[`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String")类型上建立，并且将在任何后端渲染，包括在使用[`MetaData.create_all()`](../core/metadata.html#sqlalchemy.schema.MetaData.create_all
    "sqlalchemy.schema.MetaData.create_all")和[`cast()`](../core/sqlelement.html#sqlalchemy.sql.expression.cast
    "sqlalchemy.sql.expression.cast")等功能时：
- en: '[PRE32]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: See also
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`String`](../core/type_basics.html#sqlalchemy.types.String "sqlalchemy.types.String")'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '[`String`](../core/type_basics.html#sqlalchemy.types.String "sqlalchemy.types.String")'
- en: '[#2276](https://www.sqlalchemy.org/trac/ticket/2276)'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2276](https://www.sqlalchemy.org/trac/ticket/2276)'
- en: “Prefixes” now supported for [`update()`](../core/dml.html#sqlalchemy.sql.expression.update
    "sqlalchemy.sql.expression.update"), [`delete()`](../core/dml.html#sqlalchemy.sql.expression.delete
    "sqlalchemy.sql.expression.delete")
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 现在支持“前缀”用于[`update()`](../core/dml.html#sqlalchemy.sql.expression.update "sqlalchemy.sql.expression.update")、[`delete()`](../core/dml.html#sqlalchemy.sql.expression.delete
    "sqlalchemy.sql.expression.delete")
- en: 'Geared towards MySQL, a “prefix” can be rendered within any of these constructs.
    E.g.:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 面向MySQL，一个“前缀”可以在任何这些结构中渲染。例如：
- en: '[PRE33]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The method is new in addition to those which already existed on [`insert()`](../core/dml.html#sqlalchemy.sql.expression.insert
    "sqlalchemy.sql.expression.insert"), [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") and [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query").
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法是新增的，除了已经存在于[`insert()`](../core/dml.html#sqlalchemy.sql.expression.insert
    "sqlalchemy.sql.expression.insert")、[`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select")和[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")上的方法之外。
- en: See also
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '`Update.prefix_with()`'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`Update.prefix_with()`'
- en: '`Delete.prefix_with()`'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`Delete.prefix_with()`'
- en: '`Insert.prefix_with()`'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`Insert.prefix_with()`'
- en: '[`Select.prefix_with()`](../core/selectable.html#sqlalchemy.sql.expression.Select.prefix_with
    "sqlalchemy.sql.expression.Select.prefix_with")'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Select.prefix_with()`](../core/selectable.html#sqlalchemy.sql.expression.Select.prefix_with
    "sqlalchemy.sql.expression.Select.prefix_with")'
- en: '[`Query.prefix_with()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.prefix_with
    "sqlalchemy.orm.Query.prefix_with")'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Query.prefix_with()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.prefix_with
    "sqlalchemy.orm.Query.prefix_with")'
- en: '[#2431](https://www.sqlalchemy.org/trac/ticket/2431)'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2431](https://www.sqlalchemy.org/trac/ticket/2431)'
- en: Behavioral Changes
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 行为变更
- en: '### The consideration of a “pending” object as an “orphan” has been made more
    aggressive'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '### 将“待定”对象视为“孤立”已经更加积极'
- en: This is a late add to the 0.8 series, however it is hoped that the new behavior
    is generally more consistent and intuitive in a wider variety of situations. The
    ORM has since at least version 0.4 included behavior such that an object that’s
    “pending”, meaning that it’s associated with a [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") but hasn’t been inserted into the database yet, is automatically
    expunged from the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    when it becomes an “orphan”, which means it has been de-associated with a parent
    object that refers to it with `delete-orphan` cascade on the configured [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship"). This behavior is intended to approximately mirror
    the behavior of a persistent (that is, already inserted) object, where the ORM
    will emit a DELETE for such objects that become orphans based on the interception
    of detachment events.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对0.8系列的一个晚期补充，但希望新行为在更广泛的情况下更一致和直观。ORM自至少版本0.4以来就包含了这样的行为，即一个“挂起”的对象，意味着它与[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")相关联，但尚未插入数据库，当它变成“孤儿”时，即已与引用它的父对象解除关联，并且在配置的[`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")上指定了`delete-orphan`级联时，将自动从[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")中清除。这种行为旨在大致模拟持久对象（即已插入）的行为，ORM将根据分离事件的拦截发出DELETE来删除成为孤儿的对象。
- en: The behavioral change comes into play for objects that are referred to by multiple
    kinds of parents that each specify `delete-orphan`; the typical example is an
    [association object](../orm/basic_relationships.html#association-pattern) that
    bridges two other kinds of objects in a many-to-many pattern. Previously, the
    behavior was such that the pending object would be expunged only when de-associated
    with *all* of its parents. With the behavioral change, the pending object is expunged
    as soon as it is de-associated from *any* of the parents that it was previously
    associated with. This behavior is intended to more closely match that of persistent
    objects, which are deleted as soon as they are de-associated from any parent.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 行为变更适用于被多种父对象引用并且每个父对象都指定了`delete-orphan`的对象；典型示例是在多对多模式中桥接两种其他对象的[关联对象](../orm/basic_relationships.html#association-pattern)。以前，行为是这样的，即挂起对象仅在与*所有*父对象解除关联时才会被清除。随着行为的变更，只要挂起对象与先前相关联的*任何*父对象解除关联，它就会被清除。这种行为旨在更接近持久对象的行为，即只要它们与任何父对象解除关联，它们就会被删除。
- en: The rationale for the older behavior dates back at least to version 0.4, and
    was basically a defensive decision to try to alleviate confusion when an object
    was still being constructed for INSERT. But the reality is that the object is
    re-associated with the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") as soon as it is attached to any new parent in any case.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 较旧行为的基本原因可以追溯至至少版本0.4，基本上是一种防御性决定，试图在对象仍在构建INSERT时减轻混淆。但事实是，无论如何，一旦对象附加到任何新父对象，它就会重新与[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")关联。
- en: It’s still possible to flush an object that is not associated with all of its
    required parents, if the object was either not associated with those parents in
    the first place, or if it was expunged, but then re-associated with a [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") via a subsequent attachment event but still not fully
    associated. In this situation, it is expected that the database would emit an
    integrity error, as there are likely NOT NULL foreign key columns that are unpopulated.
    The ORM makes the decision to let these INSERT attempts occur, based on the judgment
    that an object that is only partially associated with its required parents but
    has been actively associated with some of them, is more often than not a user
    error, rather than an intentional omission which should be silently skipped -
    silently skipping the INSERT here would make user errors of this nature very hard
    to debug.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然可以刷新一个对象，即使它没有与所有必需的父对象关联，如果该对象一开始就没有与这些父对象关联，或者如果它被清除，但随后通过后续的附加事件重新与[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")关联，但仍未完全关联。在这种情况下，预计数据库会发出完整性错误，因为可能存在未填充的NOT NULL外键列。ORM决定让这些INSERT尝试发生，基于这样的判断：一个只与其必需的父对象部分关联但已经积极地与其中一些关联的对象，更多的情况下是用户错误，而不是应该被默默跳过的有意遗漏
    - 在这里默默跳过INSERT会使这种用户错误非常难以调试。
- en: The old behavior, for applications that might have been relying upon it, can
    be re-enabled for any [`Mapper`](../orm/mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper") by specifying the flag `legacy_is_orphan` as a mapper
    option.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 对于可能依赖于旧行为的应用程序，可以通过将标志`legacy_is_orphan`作为映射器选项指定来重新启用旧行为。
- en: 'The new behavior allows the following test case to work:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 新行为允许以下测试用例正常工作：
- en: '[PRE34]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[#2655](https://www.sqlalchemy.org/trac/ticket/2655)'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2655](https://www.sqlalchemy.org/trac/ticket/2655)'
- en: The after_attach event fires after the item is associated with the Session instead
    of before; before_attach added
  id: totrans-186
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`after_attach` 事件在项目与会话关联之后触发，而不是之前；`before_attach` 添加'
- en: 'Event handlers which use after_attach can now assume the given instance is
    associated with the given session:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`after_attach`的事件处理程序现在可以假定给定实例与给定会话关联：
- en: '[PRE35]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Some use cases require that it work this way. However, other use cases require
    that the item is *not* yet part of the session, such as when a query, intended
    to load some state required for an instance, emits autoflush first and would otherwise
    prematurely flush the target object. Those use cases should use the new “before_attach”
    event:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 有些用例要求以这种方式工作。然而，其他用例要求项目尚未成为会话的一部分，比如当一个查询，旨在加载实例所需的某些状态，首先发出自动刷新，否则会过早刷新目标对象。这些用例应该使用新的“`before_attach`”事件：
- en: '[PRE36]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[#2464](https://www.sqlalchemy.org/trac/ticket/2464)'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2464](https://www.sqlalchemy.org/trac/ticket/2464)'
- en: Query now auto-correlates like a select() does
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查询现在像`select()`一样自动关联
- en: 'Previously it was necessary to call [`Query.correlate()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.correlate
    "sqlalchemy.orm.Query.correlate") in order to have a column- or WHERE-subquery
    correlate to the parent:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 以前需要调用[`Query.correlate()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.correlate
    "sqlalchemy.orm.Query.correlate")才能使列或WHERE子查询与父级关联：
- en: '[PRE37]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This was the opposite behavior of a plain `select()` construct which would
    assume auto-correlation by default. The above statement in 0.8 will correlate
    automatically:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这与普通的`select()`构造相反，后者默认情况下会假定自动关联。在0.8中，上述语句将自动关联：
- en: '[PRE38]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: like in `select()`, correlation can be disabled by calling `query.correlate(None)`
    or manually set by passing an entity, `query.correlate(someentity)`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在`select()`中一样，可以通过调用`query.correlate(None)`来禁用关联，或者通过传递一个实体来手动设置关联，`query.correlate(someentity)`。
- en: '[#2179](https://www.sqlalchemy.org/trac/ticket/2179)'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2179](https://www.sqlalchemy.org/trac/ticket/2179)'
- en: '### Correlation is now always context-specific'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '### 关联现在始终是上下文特定的'
- en: To allow a wider variety of correlation scenarios, the behavior of [`Select.correlate()`](../core/selectable.html#sqlalchemy.sql.expression.Select.correlate
    "sqlalchemy.sql.expression.Select.correlate") and [`Query.correlate()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.correlate
    "sqlalchemy.orm.Query.correlate") has changed slightly such that the SELECT statement
    will omit the “correlated” target from the FROM clause only if the statement is
    actually used in that context. Additionally, it’s no longer possible for a SELECT
    statement that’s placed as a FROM in an enclosing SELECT statement to “correlate”
    (i.e. omit) a FROM clause.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许更广泛的相关性场景，[`Select.correlate()`](../core/selectable.html#sqlalchemy.sql.expression.Select.correlate
    "sqlalchemy.sql.expression.Select.correlate") 和 [`Query.correlate()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.correlate
    "sqlalchemy.orm.Query.correlate") 的行为略有改变，以便 SELECT 语句仅在实际上下文中使用时才从 FROM 子句中省略“相关”的目标。此外，不再可能让作为外部
    SELECT 语句中的 FROM 的 SELECT 语句“相关”（即省略）FROM 子句。
- en: 'This change only makes things better as far as rendering SQL, in that it’s
    no longer possible to render illegal SQL where there are insufficient FROM objects
    relative to what’s being selected:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这个改变只会在渲染 SQL 方面变得更好，因为不再可能渲染出不合法的 SQL，其中所选内容相对于所选的 FROM 对象不足：
- en: '[PRE39]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Prior to this change, the above would return:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个改变之前，上述内容将返回：
- en: '[PRE40]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: which is invalid SQL as “t1” is not referred to in any FROM clause.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这是无效的 SQL，因为“t1”在任何 FROM 子句中都没有被引用。
- en: 'Now, in the absence of an enclosing SELECT, it returns:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在没有外部 SELECT 的情况下，它将返回：
- en: '[PRE41]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Within a SELECT, the correlation takes effect as expected:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SELECT 中，相关性会如预期地生效：
- en: '[PRE42]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This change is not expected to impact any existing applications, as the correlation
    behavior remains identical for properly constructed expressions. Only an application
    that relies, most likely within a testing scenario, on the invalid string output
    of a correlated SELECT used in a non-correlating context would see any change.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这个改变不会影响任何现有应用程序，因为对于正确构建的表达式，相关性行为保持不变。只有依赖于在非相关上下文中使用相关 SELECT 的无效字符串输出的应用程序（很可能是在测试场景中），才会看到任何变化。
- en: '[#2668](https://www.sqlalchemy.org/trac/ticket/2668)  ### create_all() and
    drop_all() will now honor an empty list as such'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2668](https://www.sqlalchemy.org/trac/ticket/2668)  ### create_all() 和 drop_all()
    现在将空列表视为如此'
- en: The methods [`MetaData.create_all()`](../core/metadata.html#sqlalchemy.schema.MetaData.create_all
    "sqlalchemy.schema.MetaData.create_all") and [`MetaData.drop_all()`](../core/metadata.html#sqlalchemy.schema.MetaData.drop_all
    "sqlalchemy.schema.MetaData.drop_all") will now accept a list of [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects that is empty, and will not emit any CREATE
    or DROP statements. Previously, an empty list was interpreted the same as passing
    `None` for a collection, and CREATE/DROP would be emitted for all items unconditionally.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 方法 [`MetaData.create_all()`](../core/metadata.html#sqlalchemy.schema.MetaData.create_all
    "sqlalchemy.schema.MetaData.create_all") 和 [`MetaData.drop_all()`](../core/metadata.html#sqlalchemy.schema.MetaData.drop_all
    "sqlalchemy.schema.MetaData.drop_all") 现在将接受一个空的 [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") 对象列表，并且不会发出任何 CREATE 或 DROP 语句。以前，空列表被解释为与传递 `None`
    相同，对所有项目都会无条件发出 CREATE/DROP。
- en: This is a bug fix but some applications may have been relying upon the previous
    behavior.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个错误修复，但一些应用程序可能一直依赖于先前的行为。
- en: '[#2664](https://www.sqlalchemy.org/trac/ticket/2664)'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2664](https://www.sqlalchemy.org/trac/ticket/2664)'
- en: Repaired the Event Targeting of [`InstrumentationEvents`](../orm/events.html#sqlalchemy.orm.InstrumentationEvents
    "sqlalchemy.orm.InstrumentationEvents")
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修复了 [`InstrumentationEvents`](../orm/events.html#sqlalchemy.orm.InstrumentationEvents
    "sqlalchemy.orm.InstrumentationEvents") 的事件目标定位
- en: The [`InstrumentationEvents`](../orm/events.html#sqlalchemy.orm.InstrumentationEvents
    "sqlalchemy.orm.InstrumentationEvents") series of event targets have documented
    that the events will only be fired off according to the actual class passed as
    a target. Through 0.7, this wasn’t the case, and any event listener applied to
    [`InstrumentationEvents`](../orm/events.html#sqlalchemy.orm.InstrumentationEvents
    "sqlalchemy.orm.InstrumentationEvents") would be invoked for all classes mapped.
    In 0.8, additional logic has been added so that the events will only invoke for
    those classes sent in. The `propagate` flag here is set to `True` by default as
    class instrumentation events are typically used to intercept classes that aren’t
    yet created.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '[`InstrumentationEvents`](../orm/events.html#sqlalchemy.orm.InstrumentationEvents
    "sqlalchemy.orm.InstrumentationEvents")系列事件目标已经记录，事件将仅根据传递的实际类别触发。直到0.7版本，这并不是这种情况，应用于[`InstrumentationEvents`](../orm/events.html#sqlalchemy.orm.InstrumentationEvents
    "sqlalchemy.orm.InstrumentationEvents")的任何事件监听器都将为所有映射的类调用。在0.8中，添加了额外的逻辑，使事件仅对发送的那些类调用。这里的`propagate`标志默认设置为`True`，因为类仪器事件通常用于拦截尚未创建的类。'
- en: '[#2590](https://www.sqlalchemy.org/trac/ticket/2590)'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2590](https://www.sqlalchemy.org/trac/ticket/2590)'
- en: No more magic coercion of “=” to IN when comparing to subquery in MS-SQL
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不再将“=”自动转换为IN，当与MS-SQL中的子查询进行比较时
- en: 'We found a very old behavior in the MSSQL dialect which would attempt to rescue
    users from themselves when doing something like this:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在MSSQL方言中发现了一个非常古老的行为，当用户尝试执行类似以下操作时，它会试图拯救用户：
- en: '[PRE44]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: SQL Server doesn’t allow an equality comparison to a scalar SELECT, that is,
    “x = (SELECT something)”. The MSSQL dialect would convert this to an IN. The same
    thing would happen however upon a comparison like “(SELECT something) = x”, and
    overall this level of guessing is outside of SQLAlchemy’s usual scope so the behavior
    is removed.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: SQL Server不允许将相等比较与标量SELECT进行比较，即，“x = (SELECT something)”。 MSSQL方言会将其转换为IN。然而，当进行类似“(SELECT
    something) = x”的比较时，也会发生同样的情况，总体上，这种猜测的水平超出了SQLAlchemy通常的范围，因此这种行为被移除。
- en: '[#2277](https://www.sqlalchemy.org/trac/ticket/2277)'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2277](https://www.sqlalchemy.org/trac/ticket/2277)'
- en: Fixed the behavior of [`Session.is_modified()`](../orm/session_api.html#sqlalchemy.orm.Session.is_modified
    "sqlalchemy.orm.Session.is_modified")
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修复了[`Session.is_modified()`](../orm/session_api.html#sqlalchemy.orm.Session.is_modified
    "sqlalchemy.orm.Session.is_modified")的行为
- en: The [`Session.is_modified()`](../orm/session_api.html#sqlalchemy.orm.Session.is_modified
    "sqlalchemy.orm.Session.is_modified") method accepts an argument `passive` which
    basically should not be necessary, the argument in all cases should be the value
    `True` - when left at its default of `False` it would have the effect of hitting
    the database, and often triggering autoflush which would itself change the results.
    In 0.8 the `passive` argument will have no effect, and unloaded attributes will
    never be checked for history since by definition there can be no pending state
    change on an unloaded attribute.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session.is_modified()`](../orm/session_api.html#sqlalchemy.orm.Session.is_modified
    "sqlalchemy.orm.Session.is_modified")方法接受一个参数`passive`，基本上不应该是必要的，所有情况下该参数的值应为`True`
    - 当保持默认值`False`时，它会导致命中数据库，并经常触发自动刷新，这将改变结果。在0.8中，`passive`参数将不起作用，并且未加载的属性永远不会被检查历史记录，因为根据定义，未加载的属性上不会有待处理的状态更改。'
- en: See also
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`Session.is_modified()`](../orm/session_api.html#sqlalchemy.orm.Session.is_modified
    "sqlalchemy.orm.Session.is_modified")'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session.is_modified()`](../orm/session_api.html#sqlalchemy.orm.Session.is_modified
    "sqlalchemy.orm.Session.is_modified")'
- en: '[#2320](https://www.sqlalchemy.org/trac/ticket/2320)'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2320](https://www.sqlalchemy.org/trac/ticket/2320)'
- en: '[`Column.key`](../core/metadata.html#sqlalchemy.schema.Column.key "sqlalchemy.schema.Column.key")
    is honored in the [`Select.c`](../core/selectable.html#sqlalchemy.sql.expression.Select.c
    "sqlalchemy.sql.expression.Select.c") attribute of [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") with `Select.apply_labels()`'
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[`Column.key`](../core/metadata.html#sqlalchemy.schema.Column.key "sqlalchemy.schema.Column.key")在[`Select.c`](../core/selectable.html#sqlalchemy.sql.expression.Select.c
    "sqlalchemy.sql.expression.Select.c")属性中受到`Select.apply_labels()`的尊重'
- en: 'Users of the expression system know that `Select.apply_labels()` prepends the
    table name to each column name, affecting the names that are available from [`Select.c`](../core/selectable.html#sqlalchemy.sql.expression.Select.c
    "sqlalchemy.sql.expression.Select.c"):'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式系统的用户知道`Select.apply_labels()`会在每个列名前面添加表名，影响从[`Select.c`](../core/selectable.html#sqlalchemy.sql.expression.Select.c
    "sqlalchemy.sql.expression.Select.c")中可用的名称：
- en: '[PRE45]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Before 0.8, if the [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") had a different [`Column.key`](../core/metadata.html#sqlalchemy.schema.Column.key
    "sqlalchemy.schema.Column.key"), this key would be ignored, inconsistently versus
    when `Select.apply_labels()` were not used:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在0.8版本之前，如果[`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")的[`Column.key`](../core/metadata.html#sqlalchemy.schema.Column.key
    "sqlalchemy.schema.Column.key")不同，这个键会被忽略，与未使用`Select.apply_labels()`时不一致：
- en: '[PRE46]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'In 0.8, [`Column.key`](../core/metadata.html#sqlalchemy.schema.Column.key "sqlalchemy.schema.Column.key")
    is honored in both cases:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在0.8版本中，[`Column.key`](../core/metadata.html#sqlalchemy.schema.Column.key "sqlalchemy.schema.Column.key")在两种情况下都受到尊重：
- en: '[PRE47]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: All other behavior regarding “name” and “key” are the same, including that the
    rendered SQL will still use the form `<tablename>_<colname>` - the emphasis here
    was on preventing the [`Column.key`](../core/metadata.html#sqlalchemy.schema.Column.key
    "sqlalchemy.schema.Column.key") contents from being rendered into the `SELECT`
    statement so that there are no issues with special/ non-ascii characters used
    in the [`Column.key`](../core/metadata.html#sqlalchemy.schema.Column.key "sqlalchemy.schema.Column.key").
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 关于“name”和“key”的所有其他行为都是相同的，包括渲染的SQL仍然使用形式`<tablename>_<colname>` - 这里的重点是防止[`Column.key`](../core/metadata.html#sqlalchemy.schema.Column.key
    "sqlalchemy.schema.Column.key")内容被渲染到`SELECT`语句中，以便在[`Column.key`](../core/metadata.html#sqlalchemy.schema.Column.key
    "sqlalchemy.schema.Column.key")中使用特殊/非ASCII字符时不会出现问题。
- en: '[#2397](https://www.sqlalchemy.org/trac/ticket/2397)'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2397](https://www.sqlalchemy.org/trac/ticket/2397)'
- en: single_parent warning is now an error
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`single_parent`警告现在变成了错误'
- en: A [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") that is many-to-one or many-to-many and specifies
    “cascade=’all, delete-orphan’”, which is an awkward but nonetheless supported
    use case (with restrictions) will now raise an error if the relationship does
    not specify the `single_parent=True` option. Previously it would only emit a warning,
    but a failure would follow almost immediately within the attribute system in any
    case.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 一个[`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")，它是多对一或多对多关系，并指定“cascade='all, delete-orphan'”，这是一个尴尬但仍然支持的用例（带有限制），如果关系没有指定`single_parent=True`选项，现在将引发错误。以前只会发出警告，但在任何情况下几乎立即会在属性系统中跟随失败。
- en: '[#2405](https://www.sqlalchemy.org/trac/ticket/2405)'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2405](https://www.sqlalchemy.org/trac/ticket/2405)'
- en: Adding the `inspector` argument to the `column_reflect` event
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加`inspector`参数到`column_reflect`事件
- en: '0.7 added a new event called `column_reflect`, provided so that the reflection
    of columns could be augmented as each one were reflected. We got this event slightly
    wrong in that the event gave no way to get at the current `Inspector` and `Connection`
    being used for the reflection, in the case that additional information from the
    database is needed. As this is a new event not widely used yet, we’ll be adding
    the `inspector` argument into it directly:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 0.7版本添加了一个名为`column_reflect`的新事件，提供了每个列反射时可以增强的机会。我们在这个事件上稍微出了点错，因为事件没有提供获取当前用于反射的`Inspector`和`Connection`的方法，以防需要来自数据库的额外信息。由于这是一个尚未广泛使用的新事件，我们将直接在其中添加`inspector`参数：
- en: '[PRE48]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[#2418](https://www.sqlalchemy.org/trac/ticket/2418)'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2418](https://www.sqlalchemy.org/trac/ticket/2418)'
- en: Disabling auto-detect of collations, casing for MySQL
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 禁用MySQL的自动检测排序规则和大小写敏感性
- en: The MySQL dialect does two calls, one very expensive, to load all possible collations
    from the database as well as information on casing, the first time an `Engine`
    connects. Neither of these collections are used for any SQLAlchemy functions,
    so these calls will be changed to no longer be emitted automatically. Applications
    that might have relied on these collections being present on `engine.dialect`
    will need to call upon `_detect_collations()` and `_detect_casing()` directly.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL方言进行两次调用，其中一次非常昂贵，从数据库加载所有可能的排序规则以及大小写信息，第一次`Engine`连接时。这两个集合都不会用于任何SQLAlchemy函数，因此这些调用将不再自动发出。可能依赖于这些集合存在于`engine.dialect`上的应用程序将需要直接调用`_detect_collations()`和`_detect_casing()`。
- en: '[#2404](https://www.sqlalchemy.org/trac/ticket/2404)'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2404](https://www.sqlalchemy.org/trac/ticket/2404)'
- en: “Unconsumed column names” warning becomes an exception
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: “未使用的列名”警告变成异常
- en: 'Referring to a non-existent column in an `insert()` or `update()` construct
    will raise an error instead of a warning:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在`insert()`或`update()`构造中引用不存在的列将引发错误而不是警告：
- en: '[PRE49]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[#2415](https://www.sqlalchemy.org/trac/ticket/2415)'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2415](https://www.sqlalchemy.org/trac/ticket/2415)'
- en: Inspector.get_primary_keys() is deprecated, use Inspector.get_pk_constraint
  id: totrans-252
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Inspector.get_primary_keys()已被弃用，请使用Inspector.get_pk_constraint
- en: 'These two methods on `Inspector` were redundant, where `get_primary_keys()`
    would return the same information as `get_pk_constraint()` minus the name of the
    constraint:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`Inspector`上的这两种方法是多余的，其中`get_primary_keys()`将返回与`get_pk_constraint()`相同的信息，减去约束的名称：'
- en: '[PRE50]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[#2422](https://www.sqlalchemy.org/trac/ticket/2422)'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2422](https://www.sqlalchemy.org/trac/ticket/2422)'
- en: Case-insensitive result row names will be disabled in most cases
  id: totrans-256
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在大多数情况下，不区分大小写的结果行名称将被禁用
- en: 'A very old behavior, the column names in `RowProxy` were always compared case-insensitively:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常古老的行为，在`RowProxy`中的列名始终是不区分大小写比较的：
- en: '[PRE51]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This was for the benefit of a few dialects which in the early days needed this,
    like Oracle and Firebird, but in modern usage we have more accurate ways of dealing
    with the case-insensitive behavior of these two platforms.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这是为了一些早期需要这样做的方言的好处，比如Oracle和Firebird，但在现代用法中，我们有更准确的方法来处理这两个平台的不区分大小写行为。
- en: Going forward, this behavior will be available only optionally, by passing the
    flag ``case_sensitive=False`` to ``create_engine()``, but otherwise column names
    requested from the row must match as far as casing.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 未来，这种行为将仅可选地通过将标志``case_sensitive=False``传递给``create_engine()``来使用，但否则从行中请求的列名必须匹配大小写。
- en: '[#2423](https://www.sqlalchemy.org/trac/ticket/2423)'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2423](https://www.sqlalchemy.org/trac/ticket/2423)'
- en: '`InstrumentationManager` and alternate class instrumentation is now an extension'
  id: totrans-262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`InstrumentationManager`和替代类仪器现在是一个扩展'
- en: The `sqlalchemy.orm.interfaces.InstrumentationManager` class is moved to `sqlalchemy.ext.instrumentation.InstrumentationManager`.
    The “alternate instrumentation” system was built for the benefit of a very small
    number of installations that needed to work with existing or unusual class instrumentation
    systems, and generally is very seldom used. The complexity of this system has
    been exported to an `ext.` module. It remains unused until once imported, typically
    when a third party library imports `InstrumentationManager`, at which point it
    is injected back into `sqlalchemy.orm` by replacing the default `InstrumentationFactory`
    with `ExtendedInstrumentationRegistry`.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '`sqlalchemy.orm.interfaces.InstrumentationManager`类已移动到`sqlalchemy.ext.instrumentation.InstrumentationManager`。
    “替代仪器”系统是为了极少数需要使用现有或不寻常的类仪器系统的安装而构建的，并且通常很少使用。这个系统的复杂性已经导出到一个`ext.`模块中。它保持未使用，直到被导入一次，通常是当第三方库导入`InstrumentationManager`时，此时它通过用`ExtendedInstrumentationRegistry`替换默认的`InstrumentationFactory`注入回`sqlalchemy.orm`。'
- en: Removed
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 已移除
- en: SQLSoup
  id: totrans-265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SQLSoup
- en: SQLSoup is a handy package that presents an alternative interface on top of
    the SQLAlchemy ORM. SQLSoup is now moved into its own project and documented/released
    separately; see [https://bitbucket.org/zzzeek/sqlsoup](https://bitbucket.org/zzzeek/sqlsoup).
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: SQLSoup是一个方便的包，它在SQLAlchemy ORM的基础上提供了一个替代接口。SQLSoup现在已经移动到自己的项目中，并且有单独的文档/发布；请参见[https://bitbucket.org/zzzeek/sqlsoup](https://bitbucket.org/zzzeek/sqlsoup)。
- en: SQLSoup is a very simple tool that could also benefit from contributors who
    are interested in its style of usage.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: SQLSoup是一个非常简单的工具，也可以受益于对其使用方式感兴趣的贡献者。
- en: '[#2262](https://www.sqlalchemy.org/trac/ticket/2262)'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2262](https://www.sqlalchemy.org/trac/ticket/2262)'
- en: MutableType
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: MutableType
- en: The older “mutable” system within the SQLAlchemy ORM has been removed. This
    refers to the `MutableType` interface which was applied to types such as `PickleType`
    and conditionally to `TypeDecorator`, and since very early SQLAlchemy versions
    has provided a way for the ORM to detect changes in so-called “mutable” data structures
    such as JSON structures and pickled objects. However, the implementation was never
    reasonable and forced a very inefficient mode of usage on the unit-of-work which
    caused an expensive scan of all objects to take place during flush. In 0.7, the
    [sqlalchemy.ext.mutable](https://docs.sqlalchemy.org/en/latest/orm/extensions/mutable.html)
    extension was introduced so that user-defined datatypes can appropriately send
    events to the unit of work as changes occur.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy ORM中的旧“可变”系统已被移除。这指的是应用于诸如`PickleType`的类型和有条件地应用于`TypeDecorator`的`MutableType`接口，并且自早期的SQLAlchemy版本以来一直提供了一种让ORM检测所谓的“可变”数据结构（如JSON结构和pickled对象）变化的方式。然而，实现从未合理，并迫使在单位操作期间发生昂贵的对象扫描的ORM使用方式。在0.7中，引入了[sqlalchemy.ext.mutable](https://docs.sqlalchemy.org/en/latest/orm/extensions/mutable.html)扩展，以便用户定义的数据类型可以在发生更改时适当地向单位操作发送事件。
- en: Today, usage of `MutableType` is expected to be low, as warnings have been in
    place for some years now regarding its inefficiency.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，`MutableType` 的使用预计会很少，因为多年来一直有关于其效率低下的警告。
- en: '[#2442](https://www.sqlalchemy.org/trac/ticket/2442)'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2442](https://www.sqlalchemy.org/trac/ticket/2442)'
- en: sqlalchemy.exceptions (has been sqlalchemy.exc for years)
  id: totrans-273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: sqlalchemy.exceptions（多年来一直是 sqlalchemy.exc）
- en: We had left in an alias `sqlalchemy.exceptions` to attempt to make it slightly
    easier for some very old libraries that hadn’t yet been upgraded to use `sqlalchemy.exc`.
    Some users are still being confused by it however so in 0.8 we’re taking it out
    entirely to eliminate any of that confusion.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们曾留下了一个别名 `sqlalchemy.exceptions`，以使一些尚未升级以使用 `sqlalchemy.exc` 的非常老的库稍微容易一些。然而，一些用户仍然感到困惑，因此在
    0.8 版本中我们将其完全删除，以消除任何困惑。
- en: '[#2433](https://www.sqlalchemy.org/trac/ticket/2433)'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2433](https://www.sqlalchemy.org/trac/ticket/2433)'
- en: Introduction
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍
- en: This guide introduces what’s new in SQLAlchemy version 0.8, and also documents
    changes which affect users migrating their applications from the 0.7 series of
    SQLAlchemy to 0.8.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 本指南介绍了 SQLAlchemy 0.8 版本的新功能，还记录了影响用户将其应用程序从 SQLAlchemy 0.7 系列迁移到 0.8 版本的更改。
- en: SQLAlchemy releases are closing in on 1.0, and each new version since 0.5 features
    fewer major usage changes. Most applications that are settled into modern 0.7
    patterns should be movable to 0.8 with no changes. Applications that use 0.6 and
    even 0.5 patterns should be directly migratable to 0.8 as well, though larger
    applications may want to test with each interim version.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 的发布版本即将接近 1.0，自 0.5 版本以来，每个新版本都减少了主要的使用变化。大多数已经适应现代 0.7 模式的应用程序应该可以无需更改地迁移到
    0.8 版本。使用 0.6 甚至 0.5 模式的应用程序也应该可以直接迁移到 0.8 版本，尽管较大的应用程序可能需要测试每个中间版本。
- en: Platform Support
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 平台支持
- en: Targeting Python 2.5 and Up Now
  id: totrans-280
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 现在的目标是 Python 2.5 及以上版本
- en: SQLAlchemy 0.8 will target Python 2.5 and forward; compatibility for Python
    2.4 is being dropped.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 0.8 将以 Python 2.5 为目标版本；不再兼容 Python 2.4。
- en: The internals will be able to make usage of Python ternaries (that is, `x if
    y else z`) which will improve things versus the usage of `y and x or z`, which
    naturally has been the source of some bugs, as well as context managers (that
    is, `with:`) and perhaps in some cases `try:/except:/else:` blocks which will
    help with code readability.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 内部将能够使用 Python 三元表达式（即，`x if y else z`），这将改善与使用 `y and x or z` 相比的情况，后者自然地导致了一些错误，以及上下文管理器（即，`with:`）和在某些情况下
    `try:/except:/else:` 块，这将有助于提高代码的可读性。
- en: SQLAlchemy will eventually drop 2.5 support as well - when 2.6 is reached as
    the baseline, SQLAlchemy will move to use 2.6/3.3 in-place compatibility, removing
    the usage of the `2to3` tool and maintaining a source base that works with Python
    2 and 3 at the same time.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 最终也会放弃对 2.5 版本的支持 - 当基线达到 2.6 时，SQLAlchemy 将转向使用 2.6/3.3 的就地兼容性，去除
    `2to3` 工具的使用，并保持一个同时适用于 Python 2 和 3 的源代码库。
- en: Targeting Python 2.5 and Up Now
  id: totrans-284
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 现在的目标是 Python 2.5 及以上版本
- en: SQLAlchemy 0.8 will target Python 2.5 and forward; compatibility for Python
    2.4 is being dropped.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 0.8 将以 Python 2.5 为目标版本；不再兼容 Python 2.4。
- en: The internals will be able to make usage of Python ternaries (that is, `x if
    y else z`) which will improve things versus the usage of `y and x or z`, which
    naturally has been the source of some bugs, as well as context managers (that
    is, `with:`) and perhaps in some cases `try:/except:/else:` blocks which will
    help with code readability.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 内部将能够使用 Python 三元表达式（即，`x if y else z`），这将改善与使用 `y and x or z` 相比的情况，后者自然地导致了一些错误，以及上下文管理器（即，`with:`）和在某些情况下
    `try:/except:/else:` 块，这将有助于提高代码的可读性。
- en: SQLAlchemy will eventually drop 2.5 support as well - when 2.6 is reached as
    the baseline, SQLAlchemy will move to use 2.6/3.3 in-place compatibility, removing
    the usage of the `2to3` tool and maintaining a source base that works with Python
    2 and 3 at the same time.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 最终也会放弃对 2.5 版本的支持 - 当基线达到 2.6 时，SQLAlchemy 将转向使用 2.6/3.3 的就地兼容性，去除
    `2to3` 工具的使用，并保持一个同时适用于 Python 2 和 3 的源代码库。
- en: New ORM Features
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 新的 ORM 特性
- en: '### Rewritten [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") mechanics'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '### 重写的 [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") 机制'
- en: '0.8 features a much improved and capable system regarding how [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") determines how to join between two entities. The
    new system includes these features:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 0.8 版本中关于 [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") 如何确定如何在两个实体之间连接的能力得到了大大改进和增强。新系统包括以下功能：
- en: 'The `primaryjoin` argument is **no longer needed** when constructing a [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") against a class that has multiple foreign key paths
    to the target. Only the `foreign_keys` argument is needed to specify those columns
    which should be included:'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当构建针对具有多个外键路径指向目标的类的 [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") 时，**不再需要** `primaryjoin` 参数。只需要使用 `foreign_keys`
    参数来指定应包含的列即可：
- en: '[PRE52]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'relationships against self-referential, composite foreign keys where **a column
    points to itself** are now supported. The canonical case is as follows:'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于自引用、复合外键的关系，在其中**一个列指向自身**的情况下，现在已经得到支持。典型案例如下：
- en: '[PRE53]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Above, the `Folder` refers to its parent `Folder` joining from `account_id`
    to itself, and `parent_id` to `folder_id`. When SQLAlchemy constructs an auto-
    join, no longer can it assume all columns on the “remote” side are aliased, and
    all columns on the “local” side are not - the `account_id` column is **on both
    sides**. So the internal relationship mechanics were totally rewritten to support
    an entirely different system whereby two copies of `account_id` are generated,
    each containing different *annotations* to determine their role within the statement.
    Note the join condition within a basic eager load:'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上面的示例中，`Folder` 引用了其父 `Folder`，从 `account_id` 到自身的连接，并从 `parent_id` 到 `folder_id`。当
    SQLAlchemy 构造自动连接时，不再假设“远程”一侧的所有列都被别名化，并且“本地”一侧的所有列都没有被别名化 - `account_id` 列在**两侧**都存在。因此，内部关系机制被完全重写，以支持一种完全不同的系统，其中生成了两个
    `account_id` 的副本，每个副本包含不同的*注释*以确定它们在语句中的角色。注意基本急加载中的连接条件：
- en: '[PRE54]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Previously difficult custom join conditions, like those involving functions
    and/or CASTing of types, will now function as expected in most cases:'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以前难以处理的自定义连接条件，比如涉及函数和/或类型转换的条件，现在在大多数情况下将按预期运行：
- en: '[PRE55]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The new [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") mechanics make use of a SQLAlchemy concept known
    as [annotations](../glossary.html#term-annotations). These annotations are also
    available to application code explicitly via the [`foreign()`](../orm/relationship_api.html#sqlalchemy.orm.foreign
    "sqlalchemy.orm.foreign") and [`remote()`](../orm/relationship_api.html#sqlalchemy.orm.remote
    "sqlalchemy.orm.remote") functions, either as a means to improve readability for
    advanced configurations or to directly inject an exact configuration, bypassing
    the usual join-inspection heuristics:'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 新的 [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") 机制利用了 SQLAlchemy 中称为 [annotations](../glossary.html#term-annotations)
    的概念。这些注释也可以通过 [`foreign()`](../orm/relationship_api.html#sqlalchemy.orm.foreign
    "sqlalchemy.orm.foreign") 和 [`remote()`](../orm/relationship_api.html#sqlalchemy.orm.remote
    "sqlalchemy.orm.remote") 函数显式地提供给应用程序代码，作为改善高级配置的可读性的手段，或者直接注入精确配置，绕过通常的连接检查启发式方法：
- en: '[PRE56]'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: See also
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Configuring how Relationship Joins](../orm/join_conditions.html#relationship-configure-joins)
    - a newly revised section on [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") detailing the latest techniques for customizing
    related attributes and collection access.'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '[配置关系连接方式](../orm/join_conditions.html#relationship-configure-joins) - 对于 [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") 的最新技术进行了全面修订，详细说明了自定义相关属性和集合访问的最新技术。'
- en: '[#1401](https://www.sqlalchemy.org/trac/ticket/1401) [#610](https://www.sqlalchemy.org/trac/ticket/610)  ###
    New Class/Object Inspection System'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '[#1401](https://www.sqlalchemy.org/trac/ticket/1401) [#610](https://www.sqlalchemy.org/trac/ticket/610)  ###
    新的类/对象检查系统'
- en: Lots of SQLAlchemy users are writing systems that require the ability to inspect
    the attributes of a mapped class, including being able to get at the primary key
    columns, object relationships, plain attributes, and so forth, typically for the
    purpose of building data-marshalling systems, like JSON/XML conversion schemes
    and of course form libraries galore.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 SQLAlchemy 用户正在编写需要检查映射类的属性的系统，包括能够访问主键列、对象关系、普通属性等，通常是为了构建数据编组系统，如 JSON/XML
    转换方案和各种表单库。
- en: Originally, the [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    and [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    model were the original inspection points, which have a well-documented system.
    While SQLAlchemy ORM models are also fully introspectable, this has never been
    a fully stable and supported feature, and users tended to not have a clear idea
    how to get at this information.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，[`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    和 [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    模型是最初的检查点，拥有一个完全文档化的系统。虽然 SQLAlchemy ORM 模型也是完全可内省的，但这从未是一个完全稳定和受支持的特性，用户往往不清楚如何获取这些信息。
- en: 0.8 now provides a consistent, stable and fully documented API for this purpose,
    including an inspection system which works on mapped classes, instances, attributes,
    and other Core and ORM constructs. The entrypoint to this system is the core-level
    [`inspect()`](../core/inspection.html#sqlalchemy.inspect "sqlalchemy.inspect")
    function. In most cases, the object being inspected is one already part of SQLAlchemy’s
    system, such as [`Mapper`](../orm/mapping_api.html#sqlalchemy.orm.Mapper "sqlalchemy.orm.Mapper"),
    [`InstanceState`](../orm/internals.html#sqlalchemy.orm.InstanceState "sqlalchemy.orm.InstanceState"),
    [`Inspector`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector "sqlalchemy.engine.reflection.Inspector").
    In some cases, new objects have been added with the job of providing the inspection
    API in certain contexts, such as [`AliasedInsp`](../orm/queryguide/api.html#sqlalchemy.orm.util.AliasedInsp
    "sqlalchemy.orm.util.AliasedInsp") and [`AttributeState`](../orm/internals.html#sqlalchemy.orm.AttributeState
    "sqlalchemy.orm.AttributeState").
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 0.8 现在为此提供了一致、稳定且完全文档化的 API，包括适用于映射类、实例、属性和其他核心和 ORM 结构的检查系统。此系统的入口是核心级别的 [`inspect()`](../core/inspection.html#sqlalchemy.inspect
    "sqlalchemy.inspect") 函数。在大多数情况下，被检查的对象已经是 SQLAlchemy 系统的一部分，比如 [`Mapper`](../orm/mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper")、[`InstanceState`](../orm/internals.html#sqlalchemy.orm.InstanceState
    "sqlalchemy.orm.InstanceState")、[`Inspector`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector
    "sqlalchemy.engine.reflection.Inspector") 等。在某些情况下，已经添加了新对象，用于在某些情境中提供检查 API，比如
    [`AliasedInsp`](../orm/queryguide/api.html#sqlalchemy.orm.util.AliasedInsp "sqlalchemy.orm.util.AliasedInsp")
    和 [`AttributeState`](../orm/internals.html#sqlalchemy.orm.AttributeState "sqlalchemy.orm.AttributeState")。
- en: 'A walkthrough of some key capabilities follows:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些关键功能的介绍：
- en: '[PRE57]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: See also
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Runtime Inspection API](../core/inspection.html)'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '[运行时检查 API](../core/inspection.html)'
- en: '[#2208](https://www.sqlalchemy.org/trac/ticket/2208)'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2208](https://www.sqlalchemy.org/trac/ticket/2208)'
- en: New with_polymorphic() feature, can be used anywhere
  id: totrans-312
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 新的 with_polymorphic() 功能，可在任何地方使用
- en: 'The `Query.with_polymorphic()` method allows the user to specify which tables
    should be present when querying against a joined-table entity. Unfortunately the
    method is awkward and only applies to the first entity in the list, and otherwise
    has awkward behaviors both in usage as well as within the internals. A new enhancement
    to the [`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased "sqlalchemy.orm.aliased")
    construct has been added called [`with_polymorphic()`](../orm/queryguide/inheritance.html#sqlalchemy.orm.with_polymorphic
    "sqlalchemy.orm.with_polymorphic") which allows any entity to be “aliased” into
    a “polymorphic” version of itself, freely usable anywhere:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '`Query.with_polymorphic()` 方法允许用户指定在针对连接表实体进行查询时应该存在哪些表。不幸的是，该方法很笨拙，仅适用于列表中的第一个实体，并且在使用和内部方面都有令人困扰的行为。已添加了一个名为
    [`with_polymorphic()`](../orm/queryguide/inheritance.html#sqlalchemy.orm.with_polymorphic
    "sqlalchemy.orm.with_polymorphic") 的新增强功能，可以将任何实体“别名化”为其自身的“多态”版本，可在任何地方自由使用：'
- en: '[PRE58]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: See also
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Using with_polymorphic()](../orm/queryguide/inheritance.html#with-polymorphic)
    - newly updated documentation for polymorphic loading control.'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用 with_polymorphic()](../orm/queryguide/inheritance.html#with-polymorphic)
    - 用于多态加载控制的新更新文档。'
- en: '[#2333](https://www.sqlalchemy.org/trac/ticket/2333)'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2333](https://www.sqlalchemy.org/trac/ticket/2333)'
- en: of_type() works with alias(), with_polymorphic(), any(), has(), joinedload(),
    subqueryload(), contains_eager()
  id: totrans-318
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: of_type() 与 alias()、with_polymorphic()、any()、has()、joinedload()、subqueryload()、contains_eager()
    一起使用
- en: 'The [`PropComparator.of_type()`](../orm/internals.html#sqlalchemy.orm.PropComparator.of_type
    "sqlalchemy.orm.PropComparator.of_type") method is used to specify a specific
    subtype to use when constructing SQL expressions along a [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") that has a [polymorphic](../glossary.html#term-polymorphic)
    mapping as its target. This method can now be used to target *any number* of target
    subtypes, by combining it with the new [`with_polymorphic()`](../orm/queryguide/inheritance.html#sqlalchemy.orm.with_polymorphic
    "sqlalchemy.orm.with_polymorphic") function:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '[`PropComparator.of_type()`](../orm/internals.html#sqlalchemy.orm.PropComparator.of_type
    "sqlalchemy.orm.PropComparator.of_type")方法用于在构建SQL表达式时指定要使用的特定子类型，该子类型作为[`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")的目标具有多态映射。现在可以通过与新的[`with_polymorphic()`](../orm/queryguide/inheritance.html#sqlalchemy.orm.with_polymorphic
    "sqlalchemy.orm.with_polymorphic")函数结合使用该方法来定位*任意数量*的目标子类型：'
- en: '[PRE59]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The method now works equally well in most places a regular relationship attribute
    is accepted, including with loader functions like [`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload"), [`subqueryload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.subqueryload
    "sqlalchemy.orm.subqueryload"), [`contains_eager()`](../orm/queryguide/relationships.html#sqlalchemy.orm.contains_eager
    "sqlalchemy.orm.contains_eager"), and comparison methods like [`PropComparator.any()`](../orm/internals.html#sqlalchemy.orm.PropComparator.any
    "sqlalchemy.orm.PropComparator.any") and [`PropComparator.has()`](../orm/internals.html#sqlalchemy.orm.PropComparator.has
    "sqlalchemy.orm.PropComparator.has"):'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法现在在大多数接受常规关系属性的地方同样有效，包括与加载器函数一起使用，如[`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload")、[`subqueryload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.subqueryload
    "sqlalchemy.orm.subqueryload")、[`contains_eager()`](../orm/queryguide/relationships.html#sqlalchemy.orm.contains_eager
    "sqlalchemy.orm.contains_eager")以及比较方法，如[`PropComparator.any()`](../orm/internals.html#sqlalchemy.orm.PropComparator.any
    "sqlalchemy.orm.PropComparator.any")和[`PropComparator.has()`](../orm/internals.html#sqlalchemy.orm.PropComparator.has
    "sqlalchemy.orm.PropComparator.has")：
- en: '[PRE60]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: See also
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Joining to specific sub-types or with_polymorphic() entities](../orm/queryguide/inheritance.html#inheritance-of-type)'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '[连接到特定子类型或with_polymorphic()实体](../orm/queryguide/inheritance.html#inheritance-of-type)'
- en: '[#2438](https://www.sqlalchemy.org/trac/ticket/2438) [#1106](https://www.sqlalchemy.org/trac/ticket/1106)'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2438](https://www.sqlalchemy.org/trac/ticket/2438) [#1106](https://www.sqlalchemy.org/trac/ticket/1106)'
- en: Events Can Be Applied to Unmapped Superclasses
  id: totrans-326
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 事件可以应用于未映射的超类
- en: 'Mapper and instance events can now be associated with an unmapped superclass,
    where those events will be propagated to subclasses as those subclasses are mapped.
    The `propagate=True` flag should be used. This feature allows events to be associated
    with a declarative base class:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: Mapper和实例事件现在可以与未映射的超类关联，这些事件将随着子类被映射而传播。应该使用`propagate=True`标志。此功能允许将事件与声明基类关联：
- en: '[PRE61]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[#2585](https://www.sqlalchemy.org/trac/ticket/2585)'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2585](https://www.sqlalchemy.org/trac/ticket/2585)'
- en: Declarative Distinguishes Between Modules/Packages
  id: totrans-330
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Declarative区分模块/包
- en: 'A key feature of Declarative is the ability to refer to other mapped classes
    using their string name. The registry of class names is now sensitive to the owning
    module and package of a given class. The classes can be referred to via dotted
    name in expressions:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: Declarative的一个关键特性是能够通过它们的字符串名称引用其他映射类。类名注册表现在对给定类的所属模块和包敏感。可以通过点名在表达式中引用这些类：
- en: '[PRE62]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The resolution allows that any full or partial disambiguating package name can
    be used. If the path to a particular class is still ambiguous, an error is raised.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 解析允许使用任何完整或部分消歧义的包名称。如果到特定类的路径仍然模糊不清，则会引发错误。
- en: '[#2338](https://www.sqlalchemy.org/trac/ticket/2338)'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2338](https://www.sqlalchemy.org/trac/ticket/2338)'
- en: New DeferredReflection Feature in Declarative
  id: totrans-335
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Declarative中的新DeferredReflection功能
- en: 'The “deferred reflection” example has been moved to a supported feature within
    Declarative. This feature allows the construction of declarative mapped classes
    with only placeholder `Table` metadata, until a `prepare()` step is called, given
    an `Engine` with which to reflect fully all tables and establish actual mappings.
    The system supports overriding of columns, single and joined inheritance, as well
    as distinct bases-per-engine. A full declarative configuration can now be created
    against an existing table that is assembled upon engine creation time in one step:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: “延迟反射”示例已移至Declarative中的一个支持功能。该功能允许仅使用占位符`Table`元数据构建声明性映射类，直到调用`prepare()`步骤，给定一个`Engine`以完全反映所有表并建立实际映射。该系统支持列的覆盖，单一和联合继承，以及每个引擎的不同基础。现在可以在一个步骤中在引擎创建时针对现有表创建完整的声明性配置：
- en: '[PRE63]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: See also
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[`DeferredReflection`](../orm/extensions/declarative/index.html#sqlalchemy.ext.declarative.DeferredReflection
    "sqlalchemy.ext.declarative.DeferredReflection")'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '[`DeferredReflection`](../orm/extensions/declarative/index.html#sqlalchemy.ext.declarative.DeferredReflection
    "sqlalchemy.ext.declarative.DeferredReflection")'
- en: '[#2485](https://www.sqlalchemy.org/trac/ticket/2485)'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2485](https://www.sqlalchemy.org/trac/ticket/2485)'
- en: ORM Classes Now Accepted by Core Constructs
  id: totrans-341
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ORM类现在被核心构造所接受
- en: 'While the SQL expressions used with [`Query.filter()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.filter
    "sqlalchemy.orm.Query.filter"), such as `User.id == 5`, have always been compatible
    for use with core constructs such as [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select"), the mapped class itself would not be recognized
    when passed to [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select"), [`Select.select_from()`](../core/selectable.html#sqlalchemy.sql.expression.Select.select_from
    "sqlalchemy.sql.expression.Select.select_from"), or [`Select.correlate()`](../core/selectable.html#sqlalchemy.sql.expression.Select.correlate
    "sqlalchemy.sql.expression.Select.correlate"). A new SQL registration system allows
    a mapped class to be accepted as a FROM clause within the core:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然与[`Query.filter()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.filter
    "sqlalchemy.orm.Query.filter")一起使用的SQL表达式，例如`User.id == 5`，一直与核心构造（如[`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select")）兼容，但传递给[`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select")、[`Select.select_from()`](../core/selectable.html#sqlalchemy.sql.expression.Select.select_from
    "sqlalchemy.sql.expression.Select.select_from")或[`Select.correlate()`](../core/selectable.html#sqlalchemy.sql.expression.Select.correlate
    "sqlalchemy.sql.expression.Select.correlate")时，映射类本身将不被识别。一个新的SQL注册系统允许一个映射类作为核心中的FROM子句被接受：
- en: '[PRE64]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Above, the mapped `User` class will expand into the [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") to which `User` is mapped.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 上面，映射的`User`类将扩展为`User`映射到的[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")。
- en: '[#2245](https://www.sqlalchemy.org/trac/ticket/2245)'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2245](https://www.sqlalchemy.org/trac/ticket/2245)'
- en: '### Query.update() supports UPDATE..FROM'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '### Query.update()支持UPDATE..FROM'
- en: 'The new UPDATE..FROM mechanics work in query.update(). Below, we emit an UPDATE
    against `SomeEntity`, adding a FROM clause (or equivalent, depending on backend)
    against `SomeOtherEntity`:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 新的UPDATE..FROM机制在query.update()中起作用。下面，我们对`SomeEntity`发出一个UPDATE，添加一个FROM子句（或等效的，取决于后端）对`SomeOtherEntity`：
- en: '[PRE65]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'In particular, updates to joined-inheritance entities are supported, provided
    the target of the UPDATE is local to the table being filtered on, or if the parent
    and child tables are mixed, they are joined explicitly in the query. Below, given
    `Engineer` as a joined subclass of `Person`:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是，支持对联合继承实体的更新，前提是UPDATE的目标是本地表上的，或者如果父表和子表混合，则它们在查询中明确连接。下面，以`Engineer`作为`Person`的联合子类：
- en: '[PRE66]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'would produce:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 会产生：
- en: '[PRE67]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[#2365](https://www.sqlalchemy.org/trac/ticket/2365)'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2365](https://www.sqlalchemy.org/trac/ticket/2365)'
- en: rollback() will only roll back “dirty” objects from a begin_nested()
  id: totrans-354
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: rollback()仅会回滚从begin_nested()开始的“脏”对象
- en: A behavioral change that should improve efficiency for those users using SAVEPOINT
    via `Session.begin_nested()` - upon `rollback()`, only those objects that were
    made dirty since the last flush will be expired, the rest of the `Session` remains
    intact. This because a ROLLBACK to a SAVEPOINT does not terminate the containing
    transaction’s isolation, so no expiry is needed except for those changes that
    were not flushed in the current transaction.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`Session.begin_nested()`使用SAVEPOINT的用户，应该改变行为以提高效率 - 在`rollback()`时，只有自上次刷新以来被标记为脏的对象将会过期，其余的`Session`保持不变。这是因为对SAVEPOINT的ROLLBACK不会终止包含事务的隔离，因此除了当前事务中未刷新的更改外，不需要过期。
- en: '[#2452](https://www.sqlalchemy.org/trac/ticket/2452)'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2452](https://www.sqlalchemy.org/trac/ticket/2452)'
- en: Caching Example now uses dogpile.cache
  id: totrans-357
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 缓存示例现在使用dogpile.cache
- en: The caching example now uses [dogpile.cache](https://dogpilecache.readthedocs.io/).
    Dogpile.cache is a rewrite of the caching portion of Beaker, featuring vastly
    simpler and faster operation, as well as support for distributed locking.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存示例现在使用[dogpile.cache](https://dogpilecache.readthedocs.io/)。Dogpile.cache是Beaker缓存部分的重写，具有更简单和更快的操作，以及对分布式锁定的支持。
- en: 'Note that the SQLAlchemy APIs used by the Dogpile example as well as the previous
    Beaker example have changed slightly, in particular this change is needed as illustrated
    in the Beaker example:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Dogpile示例以及之前的Beaker示例中使用的SQLAlchemy API略有变化，特别是在Beaker示例中所示的这种变化是必要的：
- en: '[PRE68]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: See also
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Dogpile Caching](../orm/examples.html#examples-caching)'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '[Dogpile缓存](../orm/examples.html#examples-caching)'
- en: '[#2589](https://www.sqlalchemy.org/trac/ticket/2589)'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2589](https://www.sqlalchemy.org/trac/ticket/2589)'
- en: '### Rewritten [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") mechanics'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '### 重写的[`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")机制'
- en: '0.8 features a much improved and capable system regarding how [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") determines how to join between two entities. The
    new system includes these features:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 0.8版本在[`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")确定如何在两个实体之间连接方面具有更加改进和强大的系统。新系统包括以下功能：
- en: 'The `primaryjoin` argument is **no longer needed** when constructing a [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") against a class that has multiple foreign key paths
    to the target. Only the `foreign_keys` argument is needed to specify those columns
    which should be included:'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当针对具有多个到目标的外键路径的类构建[`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")时，**不再需要**`primaryjoin`参数。只需要使用`foreign_keys`参数来指定应包含的列：
- en: '[PRE69]'
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'relationships against self-referential, composite foreign keys where **a column
    points to itself** are now supported. The canonical case is as follows:'
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持自引用、复合外键的关系，其中**一列指向自身**。典型案例如下：
- en: '[PRE70]'
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Above, the `Folder` refers to its parent `Folder` joining from `account_id`
    to itself, and `parent_id` to `folder_id`. When SQLAlchemy constructs an auto-
    join, no longer can it assume all columns on the “remote” side are aliased, and
    all columns on the “local” side are not - the `account_id` column is **on both
    sides**. So the internal relationship mechanics were totally rewritten to support
    an entirely different system whereby two copies of `account_id` are generated,
    each containing different *annotations* to determine their role within the statement.
    Note the join condition within a basic eager load:'
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在上面的示例中，`Folder`指向其父`Folder`，从`account_id`连接到自身，并且从`parent_id`连接到`folder_id`。当SQLAlchemy构建自动连接时，不能再假定“远程”一侧的所有列都被别名化，而“本地”一侧的所有列都没有被别名化
    - `account_id`列**在两侧**都存在。因此，内部关系机制被完全重写以支持一个完全不同的系统，其中生成了两个`account_id`的副本，每个包含不同的*注释*以确定它们在语句中的角色。请注意基本贪婪加载中的连接条件：
- en: '[PRE71]'
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Previously difficult custom join conditions, like those involving functions
    and/or CASTing of types, will now function as expected in most cases:'
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以前难以处理的自定义连接条件，例如涉及函数和/或类型转换的情况，现在在大多数情况下将按预期运行：
- en: '[PRE72]'
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The new [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") mechanics make use of a SQLAlchemy concept known
    as [annotations](../glossary.html#term-annotations). These annotations are also
    available to application code explicitly via the [`foreign()`](../orm/relationship_api.html#sqlalchemy.orm.foreign
    "sqlalchemy.orm.foreign") and [`remote()`](../orm/relationship_api.html#sqlalchemy.orm.remote
    "sqlalchemy.orm.remote") functions, either as a means to improve readability for
    advanced configurations or to directly inject an exact configuration, bypassing
    the usual join-inspection heuristics:'
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 新的[`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")机制利用了SQLAlchemy中称为[annotations](../glossary.html#term-annotations)的概念。这些注释也可以通过[`foreign()`](../orm/relationship_api.html#sqlalchemy.orm.foreign
    "sqlalchemy.orm.foreign")和[`remote()`](../orm/relationship_api.html#sqlalchemy.orm.remote
    "sqlalchemy.orm.remote")函数显式地提供给应用程序代码，作为改进高级配置的手段或直接注入精确配置的方式，绕过通常的联接检查启发式算法：
- en: '[PRE73]'
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: See also
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Configuring how Relationship Joins](../orm/join_conditions.html#relationship-configure-joins)
    - a newly revised section on [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") detailing the latest techniques for customizing
    related attributes and collection access.'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '[配置关系连接方式](../orm/join_conditions.html#relationship-configure-joins) - 一个新修订的关于[`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")的部分，详细介绍了定制相关属性和集合访问的最新技术。'
- en: '[#1401](https://www.sqlalchemy.org/trac/ticket/1401) [#610](https://www.sqlalchemy.org/trac/ticket/610)'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '[#1401](https://www.sqlalchemy.org/trac/ticket/1401) [#610](https://www.sqlalchemy.org/trac/ticket/610)'
- en: '### New Class/Object Inspection System'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '### 新的类/对象检查系统'
- en: Lots of SQLAlchemy users are writing systems that require the ability to inspect
    the attributes of a mapped class, including being able to get at the primary key
    columns, object relationships, plain attributes, and so forth, typically for the
    purpose of building data-marshalling systems, like JSON/XML conversion schemes
    and of course form libraries galore.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 许多SQLAlchemy用户正在编写需要检查映射类属性的系统，包括能够访问主键列、对象关系、普通属性等，通常用于构建数据编组系统，如JSON/XML转换方案和各种表单库。
- en: Originally, the [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    and [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    model were the original inspection points, which have a well-documented system.
    While SQLAlchemy ORM models are also fully introspectable, this has never been
    a fully stable and supported feature, and users tended to not have a clear idea
    how to get at this information.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，[`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")和[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")模型是最初的检查点，具有良好记录的系统。虽然SQLAlchemy ORM模型也是完全可自省的，但这从未是一个完全稳定和受支持的功能，用户往往不清楚如何获取这些信息。
- en: 0.8 now provides a consistent, stable and fully documented API for this purpose,
    including an inspection system which works on mapped classes, instances, attributes,
    and other Core and ORM constructs. The entrypoint to this system is the core-level
    [`inspect()`](../core/inspection.html#sqlalchemy.inspect "sqlalchemy.inspect")
    function. In most cases, the object being inspected is one already part of SQLAlchemy’s
    system, such as [`Mapper`](../orm/mapping_api.html#sqlalchemy.orm.Mapper "sqlalchemy.orm.Mapper"),
    [`InstanceState`](../orm/internals.html#sqlalchemy.orm.InstanceState "sqlalchemy.orm.InstanceState"),
    [`Inspector`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector "sqlalchemy.engine.reflection.Inspector").
    In some cases, new objects have been added with the job of providing the inspection
    API in certain contexts, such as [`AliasedInsp`](../orm/queryguide/api.html#sqlalchemy.orm.util.AliasedInsp
    "sqlalchemy.orm.util.AliasedInsp") and [`AttributeState`](../orm/internals.html#sqlalchemy.orm.AttributeState
    "sqlalchemy.orm.AttributeState").
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，0.8版本为此提供了一致、稳定且完全文档化的API，包括一个检查系统，可用于映射类、实例、属性和其他核心和ORM构造。 这个系统的入口是核心级别的[`inspect()`](../core/inspection.html#sqlalchemy.inspect
    "sqlalchemy.inspect")函数。 在大多数情况下，被检查的对象已经是SQLAlchemy系统的一部分，比如[`Mapper`](../orm/mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper")、[`InstanceState`](../orm/internals.html#sqlalchemy.orm.InstanceState
    "sqlalchemy.orm.InstanceState")、[`Inspector`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector
    "sqlalchemy.engine.reflection.Inspector")等。 在某些情况下，已添加了新对象，用于在某些上下文中提供检查API，比如[`AliasedInsp`](../orm/queryguide/api.html#sqlalchemy.orm.util.AliasedInsp
    "sqlalchemy.orm.util.AliasedInsp")和[`AttributeState`](../orm/internals.html#sqlalchemy.orm.AttributeState
    "sqlalchemy.orm.AttributeState")。
- en: 'A walkthrough of some key capabilities follows:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些关键功能的演示：
- en: '[PRE74]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: See also
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Runtime Inspection API](../core/inspection.html)'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '[运行时检查API](../core/inspection.html)'
- en: '[#2208](https://www.sqlalchemy.org/trac/ticket/2208)'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2208](https://www.sqlalchemy.org/trac/ticket/2208)'
- en: New with_polymorphic() feature, can be used anywhere
  id: totrans-388
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 新的with_polymorphic()功能，可在任何地方使用
- en: 'The `Query.with_polymorphic()` method allows the user to specify which tables
    should be present when querying against a joined-table entity. Unfortunately the
    method is awkward and only applies to the first entity in the list, and otherwise
    has awkward behaviors both in usage as well as within the internals. A new enhancement
    to the [`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased "sqlalchemy.orm.aliased")
    construct has been added called [`with_polymorphic()`](../orm/queryguide/inheritance.html#sqlalchemy.orm.with_polymorphic
    "sqlalchemy.orm.with_polymorphic") which allows any entity to be “aliased” into
    a “polymorphic” version of itself, freely usable anywhere:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '`Query.with_polymorphic()`方法允许用户指定在针对联接表实体进行查询时应该存在哪些表。 不幸的是，该方法很笨拙，只适用于列表中的第一个实体，否则在使用和内部方面都有一些尴尬的行为。
    已添加了一个名为[`with_polymorphic()`](../orm/queryguide/inheritance.html#sqlalchemy.orm.with_polymorphic
    "sqlalchemy.orm.with_polymorphic")的新增强功能，它允许任何实体“别名”为其自身的“多态”版本，可自由在任何地方使用：'
- en: '[PRE75]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: See also
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Using with_polymorphic()](../orm/queryguide/inheritance.html#with-polymorphic)
    - newly updated documentation for polymorphic loading control.'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用with_polymorphic()](../orm/queryguide/inheritance.html#with-polymorphic)
    - 用于多态加载控制的新更新文档。'
- en: '[#2333](https://www.sqlalchemy.org/trac/ticket/2333)'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2333](https://www.sqlalchemy.org/trac/ticket/2333)'
- en: of_type() works with alias(), with_polymorphic(), any(), has(), joinedload(),
    subqueryload(), contains_eager()
  id: totrans-394
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: of_type() 与 alias()、with_polymorphic()、any()、has()、joinedload()、subqueryload()、contains_eager()一起使用
- en: 'The [`PropComparator.of_type()`](../orm/internals.html#sqlalchemy.orm.PropComparator.of_type
    "sqlalchemy.orm.PropComparator.of_type") method is used to specify a specific
    subtype to use when constructing SQL expressions along a [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") that has a [polymorphic](../glossary.html#term-polymorphic)
    mapping as its target. This method can now be used to target *any number* of target
    subtypes, by combining it with the new [`with_polymorphic()`](../orm/queryguide/inheritance.html#sqlalchemy.orm.with_polymorphic
    "sqlalchemy.orm.with_polymorphic") function:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '[`PropComparator.of_type()`](../orm/internals.html#sqlalchemy.orm.PropComparator.of_type
    "sqlalchemy.orm.PropComparator.of_type")方法用于在构建SQL表达式时指定要使用的特定子类型，该表达式沿着具有[多态](../glossary.html#term-polymorphic)映射作为目标的[`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")。 现在，可以通过与新的[`with_polymorphic()`](../orm/queryguide/inheritance.html#sqlalchemy.orm.with_polymorphic
    "sqlalchemy.orm.with_polymorphic")函数结合使用，来指定*任意数量*的目标子类型：'
- en: '[PRE76]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The method now works equally well in most places a regular relationship attribute
    is accepted, including with loader functions like [`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload"), [`subqueryload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.subqueryload
    "sqlalchemy.orm.subqueryload"), [`contains_eager()`](../orm/queryguide/relationships.html#sqlalchemy.orm.contains_eager
    "sqlalchemy.orm.contains_eager"), and comparison methods like [`PropComparator.any()`](../orm/internals.html#sqlalchemy.orm.PropComparator.any
    "sqlalchemy.orm.PropComparator.any") and [`PropComparator.has()`](../orm/internals.html#sqlalchemy.orm.PropComparator.has
    "sqlalchemy.orm.PropComparator.has"):'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法现在在大多数常规关系属性接受的地方同样有效，包括与加载器函数一起使用，如[`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload")、[`subqueryload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.subqueryload
    "sqlalchemy.orm.subqueryload")、[`contains_eager()`](../orm/queryguide/relationships.html#sqlalchemy.orm.contains_eager
    "sqlalchemy.orm.contains_eager")，以及比较方法如[`PropComparator.any()`](../orm/internals.html#sqlalchemy.orm.PropComparator.any
    "sqlalchemy.orm.PropComparator.any") 和 [`PropComparator.has()`](../orm/internals.html#sqlalchemy.orm.PropComparator.has
    "sqlalchemy.orm.PropComparator.has")：
- en: '[PRE77]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: See also
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Joining to specific sub-types or with_polymorphic() entities](../orm/queryguide/inheritance.html#inheritance-of-type)'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: '[连接到特定子类型或 with_polymorphic() 实体](../orm/queryguide/inheritance.html#inheritance-of-type)'
- en: '[#2438](https://www.sqlalchemy.org/trac/ticket/2438) [#1106](https://www.sqlalchemy.org/trac/ticket/1106)'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2438](https://www.sqlalchemy.org/trac/ticket/2438) [#1106](https://www.sqlalchemy.org/trac/ticket/1106)'
- en: Events Can Be Applied to Unmapped Superclasses
  id: totrans-402
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 事件可以应用于未映射的超类
- en: 'Mapper and instance events can now be associated with an unmapped superclass,
    where those events will be propagated to subclasses as those subclasses are mapped.
    The `propagate=True` flag should be used. This feature allows events to be associated
    with a declarative base class:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以将 Mapper 和实例事件与未映射的超类关联，这些事件将传播到子类中，当这些子类被映射时。应该使用`propagate=True`标志。此功能允许将事件与声明式基类关联起来：
- en: '[PRE78]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[#2585](https://www.sqlalchemy.org/trac/ticket/2585)'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2585](https://www.sqlalchemy.org/trac/ticket/2585)'
- en: Declarative Distinguishes Between Modules/Packages
  id: totrans-406
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 声明式区分模块/包
- en: 'A key feature of Declarative is the ability to refer to other mapped classes
    using their string name. The registry of class names is now sensitive to the owning
    module and package of a given class. The classes can be referred to via dotted
    name in expressions:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 声明式的一个关键特性是能够使用其字符串名称引用其他映射类。现在，类名的注册表对给定类的拥有模块和包是敏感的。可以通过表达式中的点名引用这些类：
- en: '[PRE79]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: The resolution allows that any full or partial disambiguating package name can
    be used. If the path to a particular class is still ambiguous, an error is raised.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 解析允许使用任何全名或部分消除歧义的包名称。如果对特定类的路径仍然不明确，将会引发错误。
- en: '[#2338](https://www.sqlalchemy.org/trac/ticket/2338)'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2338](https://www.sqlalchemy.org/trac/ticket/2338)'
- en: New DeferredReflection Feature in Declarative
  id: totrans-411
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 声明式中的新延迟反射功能
- en: 'The “deferred reflection” example has been moved to a supported feature within
    Declarative. This feature allows the construction of declarative mapped classes
    with only placeholder `Table` metadata, until a `prepare()` step is called, given
    an `Engine` with which to reflect fully all tables and establish actual mappings.
    The system supports overriding of columns, single and joined inheritance, as well
    as distinct bases-per-engine. A full declarative configuration can now be created
    against an existing table that is assembled upon engine creation time in one step:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: “延迟反射”示例已移至声明式中的支持功能。此功能允许仅使用占位符`Table`元数据构建声明式映射类，直到调用`prepare()`步骤，并提供一个`Engine`以完全反射所有表并建立实际映射为止。该系统支持列的重写、单一和连接继承，以及每个引擎的不同基类。现在可以一次性在引擎创建时针对现有表创建完整的声明式配置：
- en: '[PRE80]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: See also
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`DeferredReflection`](../orm/extensions/declarative/index.html#sqlalchemy.ext.declarative.DeferredReflection
    "sqlalchemy.ext.declarative.DeferredReflection")'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '[`DeferredReflection`](../orm/extensions/declarative/index.html#sqlalchemy.ext.declarative.DeferredReflection
    "sqlalchemy.ext.declarative.DeferredReflection")'
- en: '[#2485](https://www.sqlalchemy.org/trac/ticket/2485)'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2485](https://www.sqlalchemy.org/trac/ticket/2485)'
- en: ORM Classes Now Accepted by Core Constructs
  id: totrans-417
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ORM 类现在被核心构造所接受
- en: 'While the SQL expressions used with [`Query.filter()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.filter
    "sqlalchemy.orm.Query.filter"), such as `User.id == 5`, have always been compatible
    for use with core constructs such as [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select"), the mapped class itself would not be recognized
    when passed to [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select"), [`Select.select_from()`](../core/selectable.html#sqlalchemy.sql.expression.Select.select_from
    "sqlalchemy.sql.expression.Select.select_from"), or [`Select.correlate()`](../core/selectable.html#sqlalchemy.sql.expression.Select.correlate
    "sqlalchemy.sql.expression.Select.correlate"). A new SQL registration system allows
    a mapped class to be accepted as a FROM clause within the core:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然与[`Query.filter()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.filter
    "sqlalchemy.orm.Query.filter")一起使用的SQL表达式，例如`User.id == 5`，一直与核心构造兼容，例如[`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select")，但当传递给[`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select")，[`Select.select_from()`](../core/selectable.html#sqlalchemy.sql.expression.Select.select_from
    "sqlalchemy.sql.expression.Select.select_from")或[`Select.correlate()`](../core/selectable.html#sqlalchemy.sql.expression.Select.correlate
    "sqlalchemy.sql.expression.Select.correlate")时，映射类本身将不被识别。一个新的SQL注册系统允许映射类作为核心中的FROM子句被接受：
- en: '[PRE81]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Above, the mapped `User` class will expand into the [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") to which `User` is mapped.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 上面，映射的`User`类将扩展为[`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")，`User`映射到其中的表。
- en: '[#2245](https://www.sqlalchemy.org/trac/ticket/2245)'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2245](https://www.sqlalchemy.org/trac/ticket/2245)'
- en: '### Query.update() supports UPDATE..FROM'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '### Query.update()支持UPDATE..FROM'
- en: 'The new UPDATE..FROM mechanics work in query.update(). Below, we emit an UPDATE
    against `SomeEntity`, adding a FROM clause (or equivalent, depending on backend)
    against `SomeOtherEntity`:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 新的UPDATE..FROM机制适用于query.update()。下面，我们对`SomeEntity`发出一个带有FROM子句（或等效的，取决于后端）的UPDATE：
- en: '[PRE82]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'In particular, updates to joined-inheritance entities are supported, provided
    the target of the UPDATE is local to the table being filtered on, or if the parent
    and child tables are mixed, they are joined explicitly in the query. Below, given
    `Engineer` as a joined subclass of `Person`:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '特别是，支持对连接继承实体的更新，前提是UPDATE的目标是过滤表上的本地表，或者如果父表和子表混合，它们在查询中明确连接。下面，给定`Engineer`作为`Person`的连接子类： '
- en: '[PRE83]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'would produce:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 会产生：
- en: '[PRE84]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[#2365](https://www.sqlalchemy.org/trac/ticket/2365)'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2365](https://www.sqlalchemy.org/trac/ticket/2365)'
- en: rollback() will only roll back “dirty” objects from a begin_nested()
  id: totrans-430
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: rollback()将仅回滚从begin_nested()开始的“脏”对象
- en: A behavioral change that should improve efficiency for those users using SAVEPOINT
    via `Session.begin_nested()` - upon `rollback()`, only those objects that were
    made dirty since the last flush will be expired, the rest of the `Session` remains
    intact. This because a ROLLBACK to a SAVEPOINT does not terminate the containing
    transaction’s isolation, so no expiry is needed except for those changes that
    were not flushed in the current transaction.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 一项行为变更应该提高那些通过`Session.begin_nested()`使用SAVEPOINT的用户的效率 - 在`rollback()`时，只有自上次刷新以来被标记为脏的对象将被过期，其余的`Session`保持不变。这是因为对SAVEPOINT的ROLLBACK不会终止包含事务的隔离，因此除了当前事务中未刷新的更改外，不需要过期。
- en: '[#2452](https://www.sqlalchemy.org/trac/ticket/2452)'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2452](https://www.sqlalchemy.org/trac/ticket/2452)'
- en: Caching Example now uses dogpile.cache
  id: totrans-433
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 缓存示例现在使用dogpile.cache
- en: The caching example now uses [dogpile.cache](https://dogpilecache.readthedocs.io/).
    Dogpile.cache is a rewrite of the caching portion of Beaker, featuring vastly
    simpler and faster operation, as well as support for distributed locking.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存示例现在使用[dogpile.cache](https://dogpilecache.readthedocs.io/)。Dogpile.cache是Beaker缓存部分的重写，具有更简单和更快的操作，以及对分布式锁定的支持。
- en: 'Note that the SQLAlchemy APIs used by the Dogpile example as well as the previous
    Beaker example have changed slightly, in particular this change is needed as illustrated
    in the Beaker example:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Dogpile示例以及之前的Beaker示例中使用的SQLAlchemy API略有变化，特别是正如Beaker示例中所示，这种变化是必要的：
- en: '[PRE85]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: See also
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[Dogpile Caching](../orm/examples.html#examples-caching)'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: '[Dogpile Caching](../orm/examples.html#examples-caching)'
- en: '[#2589](https://www.sqlalchemy.org/trac/ticket/2589)'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2589](https://www.sqlalchemy.org/trac/ticket/2589)'
- en: New Core Features
  id: totrans-440
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 新的核心功能
- en: Fully extensible, type-level operator support in Core
  id: totrans-441
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 完全可扩展，类型级别的核心操作符支持
- en: The Core has to date never had any system of adding support for new SQL operators
    to Column and other expression constructs, other than the [`ColumnOperators.op()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.op
    "sqlalchemy.sql.expression.ColumnOperators.op") method which is “just enough”
    to make things work. There has also never been any system in place for Core which
    allows the behavior of existing operators to be overridden. Up until now, the
    only way operators could be flexibly redefined was in the ORM layer, using [`column_property()`](../orm/mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property") given a `comparator_factory` argument. Third
    party libraries like GeoAlchemy therefore were forced to be ORM-centric and rely
    upon an array of hacks to apply new operations as well as to get them to propagate
    correctly.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，核心从未有过任何系统来为列和其他表达式构造添加对新SQL运算符的支持，除了[`ColumnOperators.op()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.op
    "sqlalchemy.sql.expression.ColumnOperators.op")方法，这个方法“刚好”能让事情正常运行。此外，核心从未有过任何系统允许覆盖现有运算符的行为。直到现在，唯一灵活重新定义运算符的方式是在ORM层中，使用[`column_property()`](../orm/mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property")并提供一个`comparator_factory`参数。因此，像GeoAlchemy这样的第三方库被迫以ORM为中心，并依赖各种技巧来应用新操作以及使其正确传播。
- en: The new operator system in Core adds the one hook that’s been missing all along,
    which is to associate new and overridden operators with *types*. Since after all,
    it’s not really a column, CAST operator, or SQL function that really drives what
    kinds of operations are present, it’s the *type* of the expression. The implementation
    details are minimal - only a few extra methods are added to the core [`ColumnElement`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement") type so that it consults its [`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") object for an optional set of operators. New or
    revised operations can be associated with any type, either via subclassing of
    an existing type, by using [`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator"), or “globally across-the-board” by attaching
    a new [`Comparator`](../core/type_api.html#sqlalchemy.types.TypeEngine.Comparator
    "sqlalchemy.types.TypeEngine.Comparator") object to an existing type class.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 核心中的新运算符系统添加了一直缺失的关键点，即将新的和覆盖的运算符与*类型*关联起来。毕竟，真正驱动操作类型的不是列、CAST运算符或SQL函数，而是表达式的*类型*。实现细节很少
    - 只需向核心[`ColumnElement`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement")类型添加几个额外方法，以便它向其[`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine")对象查询可选的一组运算符。新的或修订的操作可以与任何类型关联，可以通过对现有类型进行子类化，使用[`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator")，或者通过将新的[`Comparator`](../core/type_api.html#sqlalchemy.types.TypeEngine.Comparator
    "sqlalchemy.types.TypeEngine.Comparator")对象附加到现有类型类来“全面推广”。
- en: 'For example, to add logarithm support to [`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric
    "sqlalchemy.types.Numeric") types:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要为[`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric "sqlalchemy.types.Numeric")类型添加对数支持：
- en: '[PRE86]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'The new type is usable like any other type:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 这种新类型可以像任何其他类型一样使用：
- en: '[PRE87]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: New features which have come from this immediately include support for PostgreSQL’s
    HSTORE type, as well as new operations associated with PostgreSQL’s ARRAY type.
    It also paves the way for existing types to acquire lots more operators that are
    specific to those types, such as more string, integer and date operators.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 由此带来的新功能包括立即支持PostgreSQL的HSTORE类型，以及与PostgreSQL的ARRAY类型相关的新操作。它还为现有类型开辟了更多特定于这些类型的运算符的道路，例如更多的字符串、整数和日期运算符。
- en: See also
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Redefining and Creating New Operators](../core/custom_types.html#types-operators)'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: '[重新定义和创建新运算符](../core/custom_types.html#types-operators)'
- en: '[`HSTORE`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.HSTORE
    "sqlalchemy.dialects.postgresql.HSTORE")'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: '[`HSTORE`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.HSTORE
    "sqlalchemy.dialects.postgresql.HSTORE")'
- en: '[#2547](https://www.sqlalchemy.org/trac/ticket/2547)'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2547](https://www.sqlalchemy.org/trac/ticket/2547)'
- en: '### Multiple-VALUES support for Insert'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: '### 插入的多值支持'
- en: 'The [`Insert.values()`](../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") method now supports a list of dictionaries,
    which will render a multi-VALUES statement such as `VALUES (<row1>), (<row2>),
    ...`. This is only relevant to backends which support this syntax, including PostgreSQL,
    SQLite, and MySQL. It is not the same thing as the usual `executemany()` style
    of INSERT which remains unchanged:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Insert.values()`](../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values")方法现在支持字典列表，将生成多VALUES语句，如`VALUES (<row1>),
    (<row2>), ...`。这仅适用于支持此语法的后端，包括PostgreSQL、SQLite和MySQL。这与通常的`executemany()`风格的INSERT不同：'
- en: '[PRE88]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: See also
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`Insert.values()`](../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values")'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Insert.values()`](../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values")'
- en: '[#2623](https://www.sqlalchemy.org/trac/ticket/2623)'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2623](https://www.sqlalchemy.org/trac/ticket/2623)'
- en: Type Expressions
  id: totrans-459
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类型表达式
- en: 'SQL expressions can now be associated with types. Historically, [`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") has always allowed Python-side functions which
    receive both bound parameters as well as result row values, passing them through
    a Python side conversion function on the way to/back from the database. The new
    feature allows similar functionality, except on the database side:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以将SQL表达式与类型关联起来。从历史上看，[`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine")一直允许Python端函数接收绑定参数和结果行值，通过Python端转换函数在到达/返回数据库时进行转换。新功能允许类似的功能，但在数据库端进行：
- en: '[PRE89]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Above, the `LowerString` type defines a SQL expression that will be emitted
    whenever the `test_table.c.data` column is rendered in the columns clause of a
    SELECT statement:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 上面，`LowerString`类型定义了一个SQL表达式，每当`test_table.c.data`列在SELECT语句的列子句中呈现时，该表达式将被发出：
- en: '[PRE90]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: This feature is also used heavily by the new release of GeoAlchemy, to embed
    PostGIS expressions inline in SQL based on type rules.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 这个功能也被新版GeoAlchemy大量使用，以根据类型规则在SQL中内联嵌入PostGIS表达式。
- en: See also
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Applying SQL-level Bind/Result Processing](../core/custom_types.html#types-sql-value-processing)'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: '[应用SQL级别的绑定/结果处理](../core/custom_types.html#types-sql-value-processing)'
- en: '[#1534](https://www.sqlalchemy.org/trac/ticket/1534)'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: '[#1534](https://www.sqlalchemy.org/trac/ticket/1534)'
- en: Core Inspection System
  id: totrans-468
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 核心检查系统
- en: 'The [`inspect()`](../core/inspection.html#sqlalchemy.inspect "sqlalchemy.inspect")
    function introduced in [New Class/Object Inspection System](#feature-orminspection-08)
    also applies to the core. Applied to an [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") it produces an [`Inspector`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector
    "sqlalchemy.engine.reflection.Inspector") object:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: '[`inspect()`](../core/inspection.html#sqlalchemy.inspect "sqlalchemy.inspect")函数引入了[新的类/对象检查系统](#feature-orminspection-08)，也适用于核心。应用于[`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine")会产生一个[`Inspector`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector
    "sqlalchemy.engine.reflection.Inspector")对象：'
- en: '[PRE91]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: It can also be applied to any [`ClauseElement`](../core/foundation.html#sqlalchemy.sql.expression.ClauseElement
    "sqlalchemy.sql.expression.ClauseElement"), which returns the [`ClauseElement`](../core/foundation.html#sqlalchemy.sql.expression.ClauseElement
    "sqlalchemy.sql.expression.ClauseElement") itself, such as [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table"), [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column"), [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select"), etc. This allows it to work fluently between
    Core and ORM constructs.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 它也可以应用于任何[`ClauseElement`](../core/foundation.html#sqlalchemy.sql.expression.ClauseElement
    "sqlalchemy.sql.expression.ClauseElement")，它返回[`ClauseElement`](../core/foundation.html#sqlalchemy.sql.expression.ClauseElement
    "sqlalchemy.sql.expression.ClauseElement")本身，比如[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")、[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")、[`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select")等。这使得它可以在核心和ORM构造之间流畅地工作。
- en: New Method [`Select.correlate_except()`](../core/selectable.html#sqlalchemy.sql.expression.Select.correlate_except
    "sqlalchemy.sql.expression.Select.correlate_except")
  id: totrans-472
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 新方法[`Select.correlate_except()`](../core/selectable.html#sqlalchemy.sql.expression.Select.correlate_except
    "sqlalchemy.sql.expression.Select.correlate_except")
- en: '[`select()`](../core/selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select")
    now has a method [`Select.correlate_except()`](../core/selectable.html#sqlalchemy.sql.expression.Select.correlate_except
    "sqlalchemy.sql.expression.Select.correlate_except") which specifies “correlate
    on all FROM clauses except those specified”. It can be used for mapping scenarios
    where a related subquery should correlate normally, except against a particular
    target selectable:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: '[`select()`](../core/selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select")
    现在有一个方法[`Select.correlate_except()`](../core/selectable.html#sqlalchemy.sql.expression.Select.correlate_except
    "sqlalchemy.sql.expression.Select.correlate_except")，指定“除了指定的所有FROM子句之外的所有FROM子句”。它可用于映射场景，其中相关子查询应该正常关联，除了针对特定目标可选择的情况：'
- en: '[PRE92]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: See also
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`Select.correlate_except()`](../core/selectable.html#sqlalchemy.sql.expression.Select.correlate_except
    "sqlalchemy.sql.expression.Select.correlate_except")'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Select.correlate_except()`](../core/selectable.html#sqlalchemy.sql.expression.Select.correlate_except
    "sqlalchemy.sql.expression.Select.correlate_except")'
- en: PostgreSQL HSTORE type
  id: totrans-477
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PostgreSQL HSTORE类型
- en: 'Support for PostgreSQL’s `HSTORE` type is now available as [`HSTORE`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.HSTORE
    "sqlalchemy.dialects.postgresql.HSTORE"). This type makes great usage of the new
    operator system to provide a full range of operators for HSTORE types, including
    index access, concatenation, and containment methods such as `comparator_factory.has_key()`,
    `comparator_factory.has_any()`, and `comparator_factory.matrix()`:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: PostgreSQL的`HSTORE`类型现在可以作为[`HSTORE`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.HSTORE
    "sqlalchemy.dialects.postgresql.HSTORE")使用。该类型充分利用了新的操作符系统，为HSTORE类型提供了一整套操作符，包括索引访问、连接和包含方法，如`comparator_factory.has_key()`、`comparator_factory.has_any()`和`comparator_factory.matrix()`：
- en: '[PRE93]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: See also
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`HSTORE`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.HSTORE
    "sqlalchemy.dialects.postgresql.HSTORE")'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: '[`HSTORE`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.HSTORE
    "sqlalchemy.dialects.postgresql.HSTORE")'
- en: '[`hstore`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.hstore
    "sqlalchemy.dialects.postgresql.hstore")'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: '[`hstore`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.hstore
    "sqlalchemy.dialects.postgresql.hstore")'
- en: '[#2606](https://www.sqlalchemy.org/trac/ticket/2606)'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2606](https://www.sqlalchemy.org/trac/ticket/2606)'
- en: Enhanced PostgreSQL ARRAY type
  id: totrans-484
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 增强的PostgreSQL ARRAY类型
- en: 'The [`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY") type will accept an optional “dimension”
    argument, pinning it to a fixed number of dimensions and greatly improving efficiency
    when retrieving results:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: '[`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY") 类型将接受一个可选的“维度”参数，将其固定到一个固定数量的维度，大大提高检索结果的效率：'
- en: '[PRE94]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'The type also introduces new operators, using the new type-specific operator
    framework. New operations include indexed access:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 该类型还引入了新的操作符，使用新的类型特定的操作符框架。新操作包括索引访问：
- en: '[PRE95]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'slice access in SELECT:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 在SELECT中的切片访问：
- en: '[PRE96]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'slice updates in UPDATE:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 在UPDATE中的切片更新：
- en: '[PRE97]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'freestanding array literals:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 独立的数组文字：
- en: '[PRE98]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'array concatenation, where below, the right side `[4, 5, 6]` is coerced into
    an array literal:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 数组连接，在下面，右侧的`[4, 5, 6]`被强制转换为数组文字：
- en: '[PRE99]'
  id: totrans-496
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: See also
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY")'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: '[`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY")'
- en: '[`array`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.array
    "sqlalchemy.dialects.postgresql.array")'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: '[`array`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.array
    "sqlalchemy.dialects.postgresql.array")'
- en: '[#2441](https://www.sqlalchemy.org/trac/ticket/2441)'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2441](https://www.sqlalchemy.org/trac/ticket/2441)'
- en: New, configurable DATE, TIME types for SQLite
  id: totrans-501
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 新的可配置的SQLite日期、时间类型
- en: SQLite has no built-in DATE, TIME, or DATETIME types, and instead provides some
    support for storage of date and time values either as strings or integers. The
    date and time types for SQLite are enhanced in 0.8 to be much more configurable
    as to the specific format, including that the “microseconds” portion is optional,
    as well as pretty much everything else.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite没有内置的DATE、TIME或DATETIME类型，而是提供了一些支持将日期和时间值存储为字符串或整数的方法。0.8版本中增强了SQLite的日期和时间类型，使其更加可配置，包括“微秒”部分是可选的，以及几乎所有其他内容。
- en: '[PRE100]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: Huge thanks to Nate Dub for the sprinting on this at Pycon 2012.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 非常感谢Nate Dub在Pycon 2012上的努力。
- en: See also
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`DATETIME`](../dialects/sqlite.html#sqlalchemy.dialects.sqlite.DATETIME "sqlalchemy.dialects.sqlite.DATETIME")'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: '[`DATETIME`](../dialects/sqlite.html#sqlalchemy.dialects.sqlite.DATETIME "sqlalchemy.dialects.sqlite.DATETIME")'
- en: '[`DATE`](../dialects/sqlite.html#sqlalchemy.dialects.sqlite.DATE "sqlalchemy.dialects.sqlite.DATE")'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: '[`DATE`](../dialects/sqlite.html#sqlalchemy.dialects.sqlite.DATE "sqlalchemy.dialects.sqlite.DATE")'
- en: '[`TIME`](../dialects/sqlite.html#sqlalchemy.dialects.sqlite.TIME "sqlalchemy.dialects.sqlite.TIME")'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: '[`TIME`](../dialects/sqlite.html#sqlalchemy.dialects.sqlite.TIME "sqlalchemy.dialects.sqlite.TIME")'
- en: '[#2363](https://www.sqlalchemy.org/trac/ticket/2363)'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2363](https://www.sqlalchemy.org/trac/ticket/2363)'
- en: “COLLATE” supported across all dialects; in particular MySQL, PostgreSQL, SQLite
  id: totrans-510
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: “COLLATE”在所有方言中都受支持；特别是 MySQL、PostgreSQL、SQLite
- en: 'The “collate” keyword, long accepted by the MySQL dialect, is now established
    on all [`String`](../core/type_basics.html#sqlalchemy.types.String "sqlalchemy.types.String")
    types and will render on any backend, including when features such as [`MetaData.create_all()`](../core/metadata.html#sqlalchemy.schema.MetaData.create_all
    "sqlalchemy.schema.MetaData.create_all") and [`cast()`](../core/sqlelement.html#sqlalchemy.sql.expression.cast
    "sqlalchemy.sql.expression.cast") is used:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: “collate”关键字，长期以来被 MySQL 方言接受，现在已经在所有 [`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String") 类型上建立，并且将在任何后端呈现，包括在使用 [`MetaData.create_all()`](../core/metadata.html#sqlalchemy.schema.MetaData.create_all
    "sqlalchemy.schema.MetaData.create_all") 和 [`cast()`](../core/sqlelement.html#sqlalchemy.sql.expression.cast
    "sqlalchemy.sql.expression.cast") 等特性时：
- en: '[PRE101]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: See also
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 另见
- en: '[`String`](../core/type_basics.html#sqlalchemy.types.String "sqlalchemy.types.String")'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: '[`String`](../core/type_basics.html#sqlalchemy.types.String "sqlalchemy.types.String")'
- en: '[#2276](https://www.sqlalchemy.org/trac/ticket/2276)'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2276](https://www.sqlalchemy.org/trac/ticket/2276)'
- en: “Prefixes” now supported for [`update()`](../core/dml.html#sqlalchemy.sql.expression.update
    "sqlalchemy.sql.expression.update"), [`delete()`](../core/dml.html#sqlalchemy.sql.expression.delete
    "sqlalchemy.sql.expression.delete")
  id: totrans-516
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: “Prefixes”现在支持于 [`update()`](../core/dml.html#sqlalchemy.sql.expression.update
    "sqlalchemy.sql.expression.update"), [`delete()`](../core/dml.html#sqlalchemy.sql.expression.delete
    "sqlalchemy.sql.expression.delete")
- en: 'Geared towards MySQL, a “prefix” can be rendered within any of these constructs.
    E.g.:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 面向 MySQL，一个“前缀”可以在这些结构中的任何一个中呈现。例如：
- en: '[PRE102]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: The method is new in addition to those which already existed on [`insert()`](../core/dml.html#sqlalchemy.sql.expression.insert
    "sqlalchemy.sql.expression.insert"), [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") and [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query").
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法是新增的，除了已经存在于 [`insert()`](../core/dml.html#sqlalchemy.sql.expression.insert
    "sqlalchemy.sql.expression.insert"), [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") 和 [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") 上的方法。
- en: See also
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 另见
- en: '`Update.prefix_with()`'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: '`Update.prefix_with()`'
- en: '`Delete.prefix_with()`'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: '`Delete.prefix_with()`'
- en: '`Insert.prefix_with()`'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: '`Insert.prefix_with()`'
- en: '[`Select.prefix_with()`](../core/selectable.html#sqlalchemy.sql.expression.Select.prefix_with
    "sqlalchemy.sql.expression.Select.prefix_with")'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Select.prefix_with()`](../core/selectable.html#sqlalchemy.sql.expression.Select.prefix_with
    "sqlalchemy.sql.expression.Select.prefix_with")'
- en: '[`Query.prefix_with()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.prefix_with
    "sqlalchemy.orm.Query.prefix_with")'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Query.prefix_with()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.prefix_with
    "sqlalchemy.orm.Query.prefix_with")'
- en: '[#2431](https://www.sqlalchemy.org/trac/ticket/2431)'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2431](https://www.sqlalchemy.org/trac/ticket/2431)'
- en: Fully extensible, type-level operator support in Core
  id: totrans-527
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 完全可扩展的核心级别操作符支持
- en: The Core has to date never had any system of adding support for new SQL operators
    to Column and other expression constructs, other than the [`ColumnOperators.op()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.op
    "sqlalchemy.sql.expression.ColumnOperators.op") method which is “just enough”
    to make things work. There has also never been any system in place for Core which
    allows the behavior of existing operators to be overridden. Up until now, the
    only way operators could be flexibly redefined was in the ORM layer, using [`column_property()`](../orm/mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property") given a `comparator_factory` argument. Third
    party libraries like GeoAlchemy therefore were forced to be ORM-centric and rely
    upon an array of hacks to apply new operations as well as to get them to propagate
    correctly.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 迄今为止，核心从未有过为 Column 和其他表达式构造添加新 SQL 运算符的系统，除了 [`ColumnOperators.op()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.op
    "sqlalchemy.sql.expression.ColumnOperators.op") 方法，它“刚好足够”使事情正常工作。此外，核心中也从未建立过任何系统，允许覆盖现有运算符的行为。直到现在，灵活重新定义运算符的唯一方法是在
    ORM 层中，使用 [`column_property()`](../orm/mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property") 给定一个 `comparator_factory` 参数。因此，像 GeoAlchemy
    这样的第三方库被迫是 ORM 中心的，并且依赖于一系列的黑客来应用新的操作以及使其正确传播。
- en: The new operator system in Core adds the one hook that’s been missing all along,
    which is to associate new and overridden operators with *types*. Since after all,
    it’s not really a column, CAST operator, or SQL function that really drives what
    kinds of operations are present, it’s the *type* of the expression. The implementation
    details are minimal - only a few extra methods are added to the core [`ColumnElement`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement") type so that it consults its [`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") object for an optional set of operators. New or
    revised operations can be associated with any type, either via subclassing of
    an existing type, by using [`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator"), or “globally across-the-board” by attaching
    a new [`Comparator`](../core/type_api.html#sqlalchemy.types.TypeEngine.Comparator
    "sqlalchemy.types.TypeEngine.Comparator") object to an existing type class.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 核心中的新运算符系统添加了一直缺失的一个钩子，即将新的和重写的运算符与*类型*关联起来。毕竟，真正驱动存在哪些操作的不是列、CAST 运算符或 SQL
    函数，而是表达式的*类型*。实现细节很少——只需向核心 [`ColumnElement`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnElement
    "sqlalchemy.sql.expression.ColumnElement") 类型添加几个额外的方法，以便它向其 [`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") 对象查询一组可选的运算符。新的或修改后的操作可以与任何类型关联，可以通过对现有类型的子类化、使用
    [`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator "sqlalchemy.types.TypeDecorator")
    或通过将新的 [`Comparator`](../core/type_api.html#sqlalchemy.types.TypeEngine.Comparator
    "sqlalchemy.types.TypeEngine.Comparator") 对象附加到现有类型类来进行“全面的跨越边界”的关联。
- en: 'For example, to add logarithm support to [`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric
    "sqlalchemy.types.Numeric") types:'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要向 [`Numeric`](../core/type_basics.html#sqlalchemy.types.Numeric "sqlalchemy.types.Numeric")
    类型添加对数支持：
- en: '[PRE103]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'The new type is usable like any other type:'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 新类型可像其他类型一样使用：
- en: '[PRE104]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: New features which have come from this immediately include support for PostgreSQL’s
    HSTORE type, as well as new operations associated with PostgreSQL’s ARRAY type.
    It also paves the way for existing types to acquire lots more operators that are
    specific to those types, such as more string, integer and date operators.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 此举带来的新功能包括对 PostgreSQL 的 HSTORE 类型的支持，以及与 PostgreSQL 的 ARRAY 类型相关的新操作。它还为现有类型提供了更多专门针对这些类型的操作符的可能性，如更多字符串、整数和日期操作符。
- en: See also
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Redefining and Creating New Operators](../core/custom_types.html#types-operators)'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: '[重新定义和创建新运算符](../core/custom_types.html#types-operators)'
- en: '[`HSTORE`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.HSTORE
    "sqlalchemy.dialects.postgresql.HSTORE")'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: '[`HSTORE`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.HSTORE
    "sqlalchemy.dialects.postgresql.HSTORE")'
- en: '[#2547](https://www.sqlalchemy.org/trac/ticket/2547)'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2547](https://www.sqlalchemy.org/trac/ticket/2547)'
- en: '### Multiple-VALUES support for Insert'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: '### 插入的多值支持'
- en: 'The [`Insert.values()`](../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") method now supports a list of dictionaries,
    which will render a multi-VALUES statement such as `VALUES (<row1>), (<row2>),
    ...`. This is only relevant to backends which support this syntax, including PostgreSQL,
    SQLite, and MySQL. It is not the same thing as the usual `executemany()` style
    of INSERT which remains unchanged:'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Insert.values()`](../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") 方法现在支持字典列表，这将呈现出多值语句，如 `VALUES (<row1>),
    (<row2>), ...`。这仅与支持此语法的后端相关，包括 PostgreSQL、SQLite 和 MySQL。这与通常的 `executemany()`
    样式的 INSERT 不同：'
- en: '[PRE105]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: See also
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`Insert.values()`](../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values")'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Insert.values()`](../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values")'
- en: '[#2623](https://www.sqlalchemy.org/trac/ticket/2623)'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2623](https://www.sqlalchemy.org/trac/ticket/2623)'
- en: Type Expressions
  id: totrans-545
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类型表达式
- en: 'SQL expressions can now be associated with types. Historically, [`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") has always allowed Python-side functions which
    receive both bound parameters as well as result row values, passing them through
    a Python side conversion function on the way to/back from the database. The new
    feature allows similar functionality, except on the database side:'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: SQL 表达式现在可以与类型关联。在历史上，[`TypeEngine`](../core/type_api.html#sqlalchemy.types.TypeEngine
    "sqlalchemy.types.TypeEngine") 一直允许 Python 端函数接收绑定参数和结果行值，并在传递到/从数据库的途中通过 Python
    端转换函数进行转换。新功能允许类似的功能，但在数据库端执行：
- en: '[PRE106]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Above, the `LowerString` type defines a SQL expression that will be emitted
    whenever the `test_table.c.data` column is rendered in the columns clause of a
    SELECT statement:'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 上述中，`LowerString`类型定义了一个SQL表达式，每当`test_table.c.data`列在SELECT语句的列子句中被呈现时，该表达式就会被发出：
- en: '[PRE107]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: This feature is also used heavily by the new release of GeoAlchemy, to embed
    PostGIS expressions inline in SQL based on type rules.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特性也被新版的GeoAlchemy大量使用，以根据类型规则在SQL中内联嵌入PostGIS表达式。
- en: See also
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Applying SQL-level Bind/Result Processing](../core/custom_types.html#types-sql-value-processing)'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: '[应用SQL级绑定/结果处理](../core/custom_types.html#types-sql-value-processing)'
- en: '[#1534](https://www.sqlalchemy.org/trac/ticket/1534)'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: '[#1534](https://www.sqlalchemy.org/trac/ticket/1534)'
- en: Core Inspection System
  id: totrans-554
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 核心检查系统
- en: 'The [`inspect()`](../core/inspection.html#sqlalchemy.inspect "sqlalchemy.inspect")
    function introduced in [New Class/Object Inspection System](#feature-orminspection-08)
    also applies to the core. Applied to an [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") it produces an [`Inspector`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector
    "sqlalchemy.engine.reflection.Inspector") object:'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 引入的[`inspect()`](../core/inspection.html#sqlalchemy.inspect "sqlalchemy.inspect")函数[新的类/对象检查系统](#feature-orminspection-08)也适用于核心。应用到一个[`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine")上会产生一个[`Inspector`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector
    "sqlalchemy.engine.reflection.Inspector")对象：
- en: '[PRE108]'
  id: totrans-556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: It can also be applied to any [`ClauseElement`](../core/foundation.html#sqlalchemy.sql.expression.ClauseElement
    "sqlalchemy.sql.expression.ClauseElement"), which returns the [`ClauseElement`](../core/foundation.html#sqlalchemy.sql.expression.ClauseElement
    "sqlalchemy.sql.expression.ClauseElement") itself, such as [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table"), [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column"), [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select"), etc. This allows it to work fluently between
    Core and ORM constructs.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 它也可以应用于任何返回自身的[`ClauseElement`](../core/foundation.html#sqlalchemy.sql.expression.ClauseElement
    "sqlalchemy.sql.expression.ClauseElement")，例如[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")、[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")、[`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select")等。这使它可以在核心和ORM构造之间流畅工作。
- en: New Method [`Select.correlate_except()`](../core/selectable.html#sqlalchemy.sql.expression.Select.correlate_except
    "sqlalchemy.sql.expression.Select.correlate_except")
  id: totrans-558
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 新方法[`Select.correlate_except()`](../core/selectable.html#sqlalchemy.sql.expression.Select.correlate_except
    "sqlalchemy.sql.expression.Select.correlate_except")
- en: '[`select()`](../core/selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select")
    now has a method [`Select.correlate_except()`](../core/selectable.html#sqlalchemy.sql.expression.Select.correlate_except
    "sqlalchemy.sql.expression.Select.correlate_except") which specifies “correlate
    on all FROM clauses except those specified”. It can be used for mapping scenarios
    where a related subquery should correlate normally, except against a particular
    target selectable:'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: '[`select()`](../core/selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select")现在有一个方法[`Select.correlate_except()`](../core/selectable.html#sqlalchemy.sql.expression.Select.correlate_except
    "sqlalchemy.sql.expression.Select.correlate_except")，它指定“在除了指定的FROM子句之外的所有FROM子句上关联”。它可用于映射方案，其中相关子查询应该正常关联，除了针对特定目标可选择的情况：'
- en: '[PRE109]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: See also
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`Select.correlate_except()`](../core/selectable.html#sqlalchemy.sql.expression.Select.correlate_except
    "sqlalchemy.sql.expression.Select.correlate_except")'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Select.correlate_except()`](../core/selectable.html#sqlalchemy.sql.expression.Select.correlate_except
    "sqlalchemy.sql.expression.Select.correlate_except")'
- en: PostgreSQL HSTORE type
  id: totrans-563
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PostgreSQL HSTORE类型
- en: 'Support for PostgreSQL’s `HSTORE` type is now available as [`HSTORE`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.HSTORE
    "sqlalchemy.dialects.postgresql.HSTORE"). This type makes great usage of the new
    operator system to provide a full range of operators for HSTORE types, including
    index access, concatenation, and containment methods such as `comparator_factory.has_key()`,
    `comparator_factory.has_any()`, and `comparator_factory.matrix()`:'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 对PostgreSQL的`HSTORE`类型的支持现在可用作[`HSTORE`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.HSTORE
    "sqlalchemy.dialects.postgresql.HSTORE")。这种类型充分利用了新的运算符系统，为HSTORE类型提供了一整套运算符，包括索引访问、连接和包含方法，如`comparator_factory.has_key()`、`comparator_factory.has_any()`和`comparator_factory.matrix()`：
- en: '[PRE110]'
  id: totrans-565
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: See also
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`HSTORE`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.HSTORE
    "sqlalchemy.dialects.postgresql.HSTORE")'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: '[`HSTORE`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.HSTORE
    "sqlalchemy.dialects.postgresql.HSTORE")'
- en: '[`hstore`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.hstore
    "sqlalchemy.dialects.postgresql.hstore")'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: '[`hstore`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.hstore
    "sqlalchemy.dialects.postgresql.hstore")'
- en: '[#2606](https://www.sqlalchemy.org/trac/ticket/2606)'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2606](https://www.sqlalchemy.org/trac/ticket/2606)'
- en: Enhanced PostgreSQL ARRAY type
  id: totrans-570
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 增强的PostgreSQL ARRAY类型
- en: 'The [`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY") type will accept an optional “dimension”
    argument, pinning it to a fixed number of dimensions and greatly improving efficiency
    when retrieving results:'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: '[`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY") 类型将接受一个可选的“维度”参数，将其固定到一个固定数量的维度，大大提高检索结果的效率：'
- en: '[PRE111]'
  id: totrans-572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'The type also introduces new operators, using the new type-specific operator
    framework. New operations include indexed access:'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 该类型还引入了新的操作符，使用新的类型特定的操作符框架。新操作包括索引访问：
- en: '[PRE112]'
  id: totrans-574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'slice access in SELECT:'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 在SELECT中的切片访问：
- en: '[PRE113]'
  id: totrans-576
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'slice updates in UPDATE:'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 在UPDATE中的切片更新：
- en: '[PRE114]'
  id: totrans-578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'freestanding array literals:'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 独立的数组文字：
- en: '[PRE115]'
  id: totrans-580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'array concatenation, where below, the right side `[4, 5, 6]` is coerced into
    an array literal:'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 数组连接，下面的右侧`[4, 5, 6]`被强制转换为数组文字：
- en: '[PRE116]'
  id: totrans-582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: See also
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY")'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: '[`ARRAY`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ARRAY
    "sqlalchemy.dialects.postgresql.ARRAY")'
- en: '[`array`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.array
    "sqlalchemy.dialects.postgresql.array")'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: '[`array`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.array
    "sqlalchemy.dialects.postgresql.array")'
- en: '[#2441](https://www.sqlalchemy.org/trac/ticket/2441)'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2441](https://www.sqlalchemy.org/trac/ticket/2441)'
- en: New, configurable DATE, TIME types for SQLite
  id: totrans-587
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 新的、可配置的SQLite日期、时间类型
- en: SQLite has no built-in DATE, TIME, or DATETIME types, and instead provides some
    support for storage of date and time values either as strings or integers. The
    date and time types for SQLite are enhanced in 0.8 to be much more configurable
    as to the specific format, including that the “microseconds” portion is optional,
    as well as pretty much everything else.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite没有内置的DATE，TIME或DATETIME类型，而是提供了一些支持，用于将日期和时间值存储为字符串或整数。SQLite中的日期和时间类型在0.8中得到了增强，可以更具体地配置特定格式，包括“微秒”部分是可选的，以及几乎所有其他内容。
- en: '[PRE117]'
  id: totrans-589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: Huge thanks to Nate Dub for the sprinting on this at Pycon 2012.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 非常感谢Nate Dub在Pycon 2012上的努力。
- en: See also
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[`DATETIME`](../dialects/sqlite.html#sqlalchemy.dialects.sqlite.DATETIME "sqlalchemy.dialects.sqlite.DATETIME")'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: '[`DATETIME`](../dialects/sqlite.html#sqlalchemy.dialects.sqlite.DATETIME "sqlalchemy.dialects.sqlite.DATETIME")'
- en: '[`DATE`](../dialects/sqlite.html#sqlalchemy.dialects.sqlite.DATE "sqlalchemy.dialects.sqlite.DATE")'
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: '[`DATE`](../dialects/sqlite.html#sqlalchemy.dialects.sqlite.DATE "sqlalchemy.dialects.sqlite.DATE")'
- en: '[`TIME`](../dialects/sqlite.html#sqlalchemy.dialects.sqlite.TIME "sqlalchemy.dialects.sqlite.TIME")'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: '[`TIME`](../dialects/sqlite.html#sqlalchemy.dialects.sqlite.TIME "sqlalchemy.dialects.sqlite.TIME")'
- en: '[#2363](https://www.sqlalchemy.org/trac/ticket/2363)'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2363](https://www.sqlalchemy.org/trac/ticket/2363)'
- en: “COLLATE” supported across all dialects; in particular MySQL, PostgreSQL, SQLite
  id: totrans-596
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: “COLLATE”在所有方言中都受支持；特别是MySQL，PostgreSQL，SQLite
- en: 'The “collate” keyword, long accepted by the MySQL dialect, is now established
    on all [`String`](../core/type_basics.html#sqlalchemy.types.String "sqlalchemy.types.String")
    types and will render on any backend, including when features such as [`MetaData.create_all()`](../core/metadata.html#sqlalchemy.schema.MetaData.create_all
    "sqlalchemy.schema.MetaData.create_all") and [`cast()`](../core/sqlelement.html#sqlalchemy.sql.expression.cast
    "sqlalchemy.sql.expression.cast") is used:'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: “collate”关键字，长期以来被MySQL方言接受，现在已在所有[`String`](../core/type_basics.html#sqlalchemy.types.String
    "sqlalchemy.types.String") 类型上建立，并将在任何后端上呈现，包括在使用[`MetaData.create_all()`](../core/metadata.html#sqlalchemy.schema.MetaData.create_all
    "sqlalchemy.schema.MetaData.create_all")和[`cast()`](../core/sqlelement.html#sqlalchemy.sql.expression.cast
    "sqlalchemy.sql.expression.cast")等功能时：
- en: '[PRE118]'
  id: totrans-598
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: See also
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[`String`](../core/type_basics.html#sqlalchemy.types.String "sqlalchemy.types.String")'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: '[`String`](../core/type_basics.html#sqlalchemy.types.String "sqlalchemy.types.String")'
- en: '[#2276](https://www.sqlalchemy.org/trac/ticket/2276)'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2276](https://www.sqlalchemy.org/trac/ticket/2276)'
- en: “Prefixes” now supported for [`update()`](../core/dml.html#sqlalchemy.sql.expression.update
    "sqlalchemy.sql.expression.update"), [`delete()`](../core/dml.html#sqlalchemy.sql.expression.delete
    "sqlalchemy.sql.expression.delete")
  id: totrans-602
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 现在支持“前缀”用于[`update()`](../core/dml.html#sqlalchemy.sql.expression.update "sqlalchemy.sql.expression.update"),
    [`delete()`](../core/dml.html#sqlalchemy.sql.expression.delete "sqlalchemy.sql.expression.delete")
- en: 'Geared towards MySQL, a “prefix” can be rendered within any of these constructs.
    E.g.:'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 面向MySQL，可以在任何这些结构中呈现“前缀”。例如：
- en: '[PRE119]'
  id: totrans-604
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: The method is new in addition to those which already existed on [`insert()`](../core/dml.html#sqlalchemy.sql.expression.insert
    "sqlalchemy.sql.expression.insert"), [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") and [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query").
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法是新增的，除了已存在于[`insert()`](../core/dml.html#sqlalchemy.sql.expression.insert
    "sqlalchemy.sql.expression.insert")、[`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select")和[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")上的方法之外。
- en: See also
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '`Update.prefix_with()`'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: '`Update.prefix_with()`'
- en: '`Delete.prefix_with()`'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: '`Delete.prefix_with()`'
- en: '`Insert.prefix_with()`'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: '`Insert.prefix_with()`'
- en: '[`Select.prefix_with()`](../core/selectable.html#sqlalchemy.sql.expression.Select.prefix_with
    "sqlalchemy.sql.expression.Select.prefix_with")'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Select.prefix_with()`](../core/selectable.html#sqlalchemy.sql.expression.Select.prefix_with
    "sqlalchemy.sql.expression.Select.prefix_with")'
- en: '[`Query.prefix_with()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.prefix_with
    "sqlalchemy.orm.Query.prefix_with")'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Query.prefix_with()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.prefix_with
    "sqlalchemy.orm.Query.prefix_with")'
- en: '[#2431](https://www.sqlalchemy.org/trac/ticket/2431)'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2431](https://www.sqlalchemy.org/trac/ticket/2431)'
- en: Behavioral Changes
  id: totrans-613
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 行为变化
- en: '### The consideration of a “pending” object as an “orphan” has been made more
    aggressive'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: '### 将“待定”对象视为“孤儿”的考虑变得更加积极'
- en: This is a late add to the 0.8 series, however it is hoped that the new behavior
    is generally more consistent and intuitive in a wider variety of situations. The
    ORM has since at least version 0.4 included behavior such that an object that’s
    “pending”, meaning that it’s associated with a [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") but hasn’t been inserted into the database yet, is automatically
    expunged from the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    when it becomes an “orphan”, which means it has been de-associated with a parent
    object that refers to it with `delete-orphan` cascade on the configured [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship"). This behavior is intended to approximately mirror
    the behavior of a persistent (that is, already inserted) object, where the ORM
    will emit a DELETE for such objects that become orphans based on the interception
    of detachment events.
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 这是0.8系列的一个后期添加，但希望新行为在更广泛的情况下更一致和直观。ORM自至少0.4版本以来一直包括这样的行为，即一个“待定”对象，意味着它与[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")关联但尚未插入数据库，当它成为“孤儿”时，即已与使用`delete-orphan`级联的父对象解除关联时，将自动从[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")中清除。此行为旨在大致模拟持久对象的行为，其中ORM将根据分离事件的拦截发出DELETE以删除这些成为孤儿的对象。
- en: The behavioral change comes into play for objects that are referred to by multiple
    kinds of parents that each specify `delete-orphan`; the typical example is an
    [association object](../orm/basic_relationships.html#association-pattern) that
    bridges two other kinds of objects in a many-to-many pattern. Previously, the
    behavior was such that the pending object would be expunged only when de-associated
    with *all* of its parents. With the behavioral change, the pending object is expunged
    as soon as it is de-associated from *any* of the parents that it was previously
    associated with. This behavior is intended to more closely match that of persistent
    objects, which are deleted as soon as they are de-associated from any parent.
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 行为变化适用于被多种父对象引用并且每个父对象都指定`delete-orphan`的对象；典型示例是在多对多模式中连接两种其他对象的[关联对象](../orm/basic_relationships.html#association-pattern)。以前，行为是这样的，即当待定对象与*所有*父对象解除关联时才会被清除。随着行为变化，一旦待定对象与*任何*先前关联的父对象解除关联，该待定对象就会被清除。此行为旨在更接近持久对象的行为，即一旦与任何父对象解除关联，它们就会被删除。
- en: The rationale for the older behavior dates back at least to version 0.4, and
    was basically a defensive decision to try to alleviate confusion when an object
    was still being constructed for INSERT. But the reality is that the object is
    re-associated with the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") as soon as it is attached to any new parent in any case.
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 较旧行为的基本原因可以追溯到至少版本0.4，基本上是一种防御性决定，试图在对象仍在为INSERT构造时减轻混淆。但现实情况是，无论如何，只要对象附加到任何新父级，它就会立即重新与[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")关联。
- en: It’s still possible to flush an object that is not associated with all of its
    required parents, if the object was either not associated with those parents in
    the first place, or if it was expunged, but then re-associated with a [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") via a subsequent attachment event but still not fully
    associated. In this situation, it is expected that the database would emit an
    integrity error, as there are likely NOT NULL foreign key columns that are unpopulated.
    The ORM makes the decision to let these INSERT attempts occur, based on the judgment
    that an object that is only partially associated with its required parents but
    has been actively associated with some of them, is more often than not a user
    error, rather than an intentional omission which should be silently skipped -
    silently skipping the INSERT here would make user errors of this nature very hard
    to debug.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然可以刷新一个对象，该对象尚未与其所有必需的父级关联，如果该对象一开始就未与这些父级关联，或者如果它被清除，但随后通过后续附加事件重新与[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")关联，但仍未完全关联。在这种情况下，预计数据库会发出完整性错误，因为很可能存在未填充的NOT NULL外键列。ORM做出决定让这些INSERT尝试发生，基于这样的判断：一个只与其必需的父级部分关联但已经与其中一些父级积极关联的对象，更多的情况下是用户错误，而不是应该被悄悄跳过的有意遗漏
    - 在这里悄悄跳过INSERT会使这种性质的用户错误非常难以调试。
- en: The old behavior, for applications that might have been relying upon it, can
    be re-enabled for any [`Mapper`](../orm/mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper") by specifying the flag `legacy_is_orphan` as a mapper
    option.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 对于可能依赖于旧行为的应用程序，可以通过将标志`legacy_is_orphan`指定为映射器选项来重新启用旧行为。
- en: 'The new behavior allows the following test case to work:'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 新行为允许以下测试用例正常工作：
- en: '[PRE120]'
  id: totrans-621
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[#2655](https://www.sqlalchemy.org/trac/ticket/2655)'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2655](https://www.sqlalchemy.org/trac/ticket/2655)'
- en: The after_attach event fires after the item is associated with the Session instead
    of before; before_attach added
  id: totrans-623
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在项目与会话关联之后而不是之前触发after_attach事件；before_attach添加
- en: 'Event handlers which use after_attach can now assume the given instance is
    associated with the given session:'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 使用after_attach的事件处理程序现在可以假定给定实例与给定会话关联：
- en: '[PRE121]'
  id: totrans-625
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'Some use cases require that it work this way. However, other use cases require
    that the item is *not* yet part of the session, such as when a query, intended
    to load some state required for an instance, emits autoflush first and would otherwise
    prematurely flush the target object. Those use cases should use the new “before_attach”
    event:'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 有些用例要求它按照这种方式工作。然而，其他用例要求该项*尚未*成为会话的一部分，例如，当一个查询旨在加载实例所需的某些状态时，首先会触发自动刷新并且否则会过早刷新目标对象。这些用例应该使用新的“before_attach”事件：
- en: '[PRE122]'
  id: totrans-627
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[#2464](https://www.sqlalchemy.org/trac/ticket/2464)'
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2464](https://www.sqlalchemy.org/trac/ticket/2464)'
- en: Query now auto-correlates like a select() does
  id: totrans-629
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查询现在像select()一样自动相关
- en: 'Previously it was necessary to call [`Query.correlate()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.correlate
    "sqlalchemy.orm.Query.correlate") in order to have a column- or WHERE-subquery
    correlate to the parent:'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 以前需要调用[`Query.correlate()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.correlate
    "sqlalchemy.orm.Query.correlate")才能使列或WHERE子查询与父级相关联：
- en: '[PRE123]'
  id: totrans-631
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'This was the opposite behavior of a plain `select()` construct which would
    assume auto-correlation by default. The above statement in 0.8 will correlate
    automatically:'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 这与普通的`select()`构造相反，后者默认情况下会自动相关。在0.8中，上述语句将自动相关：
- en: '[PRE124]'
  id: totrans-633
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: like in `select()`, correlation can be disabled by calling `query.correlate(None)`
    or manually set by passing an entity, `query.correlate(someentity)`.
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在`select()`中一样，通过调用`query.correlate(None)`来禁用相关性，或者通过传递一个实体来手动设置相关性，`query.correlate(someentity)`。
- en: '[#2179](https://www.sqlalchemy.org/trac/ticket/2179)'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2179](https://www.sqlalchemy.org/trac/ticket/2179)'
- en: '### Correlation is now always context-specific'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: '### 相关性现在始终是上下文特定的'
- en: To allow a wider variety of correlation scenarios, the behavior of [`Select.correlate()`](../core/selectable.html#sqlalchemy.sql.expression.Select.correlate
    "sqlalchemy.sql.expression.Select.correlate") and [`Query.correlate()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.correlate
    "sqlalchemy.orm.Query.correlate") has changed slightly such that the SELECT statement
    will omit the “correlated” target from the FROM clause only if the statement is
    actually used in that context. Additionally, it’s no longer possible for a SELECT
    statement that’s placed as a FROM in an enclosing SELECT statement to “correlate”
    (i.e. omit) a FROM clause.
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许更广泛的相关性场景，[`Select.correlate()`](../core/selectable.html#sqlalchemy.sql.expression.Select.correlate
    "sqlalchemy.sql.expression.Select.correlate") 和 [`Query.correlate()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.correlate
    "sqlalchemy.orm.Query.correlate") 的行为略有改变，即如果 SELECT 语句实际上在该上下文中使用，那么该语句将仅在 FROM
    子句中省略“相关”的目标。此外，不再可能将作为外部 SELECT 语句中的 FROM 的 SELECT 语句“相关”（即省略）FROM 子句。
- en: 'This change only makes things better as far as rendering SQL, in that it’s
    no longer possible to render illegal SQL where there are insufficient FROM objects
    relative to what’s being selected:'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 这个改变只会让 SQL 渲染变得更好，因为不再可能渲染出不合法的 SQL，即在选择的内容相对于 FROM 对象不足的情况下：
- en: '[PRE125]'
  id: totrans-639
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'Prior to this change, the above would return:'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 在此更改之前，上述将返回：
- en: '[PRE126]'
  id: totrans-641
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: which is invalid SQL as “t1” is not referred to in any FROM clause.
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 当“t1”在任何 FROM 子句中都没有被引用时，这是无效的 SQL。
- en: 'Now, in the absence of an enclosing SELECT, it returns:'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在没有外部 SELECT 的情况下，它返回：
- en: '[PRE127]'
  id: totrans-644
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'Within a SELECT, the correlation takes effect as expected:'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SELECT 中，相关性会如预期地生效：
- en: '[PRE128]'
  id: totrans-646
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-647
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: This change is not expected to impact any existing applications, as the correlation
    behavior remains identical for properly constructed expressions. Only an application
    that relies, most likely within a testing scenario, on the invalid string output
    of a correlated SELECT used in a non-correlating context would see any change.
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
  zh: 这个改变不会影响任何现有应用程序，因为对于正确构建的表达式，相关性行为保持不变。只有依赖于在非相关上下文中使用相关的 SELECT 的无效字符串输出的应用程序（很可能是在测试场景中），才会看到任何变化。
- en: '[#2668](https://www.sqlalchemy.org/trac/ticket/2668)  ### create_all() and
    drop_all() will now honor an empty list as such'
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2668](https://www.sqlalchemy.org/trac/ticket/2668)  ### create_all() 和 drop_all()
    现在将空列表视为如此'
- en: The methods [`MetaData.create_all()`](../core/metadata.html#sqlalchemy.schema.MetaData.create_all
    "sqlalchemy.schema.MetaData.create_all") and [`MetaData.drop_all()`](../core/metadata.html#sqlalchemy.schema.MetaData.drop_all
    "sqlalchemy.schema.MetaData.drop_all") will now accept a list of [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects that is empty, and will not emit any CREATE
    or DROP statements. Previously, an empty list was interpreted the same as passing
    `None` for a collection, and CREATE/DROP would be emitted for all items unconditionally.
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 方法 [`MetaData.create_all()`](../core/metadata.html#sqlalchemy.schema.MetaData.create_all
    "sqlalchemy.schema.MetaData.create_all") 和 [`MetaData.drop_all()`](../core/metadata.html#sqlalchemy.schema.MetaData.drop_all
    "sqlalchemy.schema.MetaData.drop_all") 现在将接受一个空列表的 [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") 对象，并且不会发出任何 CREATE 或 DROP 语句。以前，将空列表解释为对集合传递 `None`，并且将无条件地为所有项目发出
    CREATE/DROP。
- en: This is a bug fix but some applications may have been relying upon the previous
    behavior.
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个错误修复，但一些应用程序可能一直依赖于先前的行为。
- en: '[#2664](https://www.sqlalchemy.org/trac/ticket/2664)'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2664](https://www.sqlalchemy.org/trac/ticket/2664)'
- en: Repaired the Event Targeting of [`InstrumentationEvents`](../orm/events.html#sqlalchemy.orm.InstrumentationEvents
    "sqlalchemy.orm.InstrumentationEvents")
  id: totrans-653
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修复了 [`InstrumentationEvents`](../orm/events.html#sqlalchemy.orm.InstrumentationEvents
    "sqlalchemy.orm.InstrumentationEvents") 的事件定位。
- en: The [`InstrumentationEvents`](../orm/events.html#sqlalchemy.orm.InstrumentationEvents
    "sqlalchemy.orm.InstrumentationEvents") series of event targets have documented
    that the events will only be fired off according to the actual class passed as
    a target. Through 0.7, this wasn’t the case, and any event listener applied to
    [`InstrumentationEvents`](../orm/events.html#sqlalchemy.orm.InstrumentationEvents
    "sqlalchemy.orm.InstrumentationEvents") would be invoked for all classes mapped.
    In 0.8, additional logic has been added so that the events will only invoke for
    those classes sent in. The `propagate` flag here is set to `True` by default as
    class instrumentation events are typically used to intercept classes that aren’t
    yet created.
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: '[`InstrumentationEvents`](../orm/events.html#sqlalchemy.orm.InstrumentationEvents
    "sqlalchemy.orm.InstrumentationEvents")系列事件目标已经记录，事件只会根据实际传递的类来触发。在0.7版本中，情况并非如此，应用于[`InstrumentationEvents`](../orm/events.html#sqlalchemy.orm.InstrumentationEvents
    "sqlalchemy.orm.InstrumentationEvents")的任何事件监听器都会对所有映射的类调用。在0.8版本中，添加了额外的逻辑，使事件只会为那些发送的类调用。这里的`propagate`标志默认设置为`True`，因为类仪器事件通常用于拦截尚未创建的类。'
- en: '[#2590](https://www.sqlalchemy.org/trac/ticket/2590)'
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2590](https://www.sqlalchemy.org/trac/ticket/2590)'
- en: No more magic coercion of “=” to IN when comparing to subquery in MS-SQL
  id: totrans-656
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不再将“=”自动转换为IN，用于与MS-SQL中的子查询进行比较
- en: 'We found a very old behavior in the MSSQL dialect which would attempt to rescue
    users from themselves when doing something like this:'
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在MSSQL方言中发现了一个非常古老的行为，当用户执行类似以下操作时，它会试图拯救用户：
- en: '[PRE130]'
  id: totrans-658
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: SQL Server doesn’t allow an equality comparison to a scalar SELECT, that is,
    “x = (SELECT something)”. The MSSQL dialect would convert this to an IN. The same
    thing would happen however upon a comparison like “(SELECT something) = x”, and
    overall this level of guessing is outside of SQLAlchemy’s usual scope so the behavior
    is removed.
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: SQL Server不允许将相等比较与标量SELECT进行比较，即“x = (SELECT something)”。MSSQL方言会将其转换为IN。然而，当进行类似“(SELECT
    something) = x”的比较时，也会发生相同的情况，总体而言，这种猜测的水平超出了SQLAlchemy通常的范围，因此删除了这种行为。
- en: '[#2277](https://www.sqlalchemy.org/trac/ticket/2277)'
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2277](https://www.sqlalchemy.org/trac/ticket/2277)'
- en: Fixed the behavior of [`Session.is_modified()`](../orm/session_api.html#sqlalchemy.orm.Session.is_modified
    "sqlalchemy.orm.Session.is_modified")
  id: totrans-661
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修复了[`Session.is_modified()`](../orm/session_api.html#sqlalchemy.orm.Session.is_modified
    "sqlalchemy.orm.Session.is_modified")的行为
- en: The [`Session.is_modified()`](../orm/session_api.html#sqlalchemy.orm.Session.is_modified
    "sqlalchemy.orm.Session.is_modified") method accepts an argument `passive` which
    basically should not be necessary, the argument in all cases should be the value
    `True` - when left at its default of `False` it would have the effect of hitting
    the database, and often triggering autoflush which would itself change the results.
    In 0.8 the `passive` argument will have no effect, and unloaded attributes will
    never be checked for history since by definition there can be no pending state
    change on an unloaded attribute.
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session.is_modified()`](../orm/session_api.html#sqlalchemy.orm.Session.is_modified
    "sqlalchemy.orm.Session.is_modified")方法接受一个参数`passive`，基本上不应该是必要的，所有情况下参数应该是值`True`
    - 当保持默认值`False`时，会影响数据库，并经常触发自动刷新，这将改变结果。在0.8版本中，`passive`参数将不起作用，并且未加载的属性永远不会检查历史记录，因为根据定义，未加载的属性上不会有待处理的状态更改。'
- en: See also
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[`Session.is_modified()`](../orm/session_api.html#sqlalchemy.orm.Session.is_modified
    "sqlalchemy.orm.Session.is_modified")'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session.is_modified()`](../orm/session_api.html#sqlalchemy.orm.Session.is_modified
    "sqlalchemy.orm.Session.is_modified")'
- en: '[#2320](https://www.sqlalchemy.org/trac/ticket/2320)'
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2320](https://www.sqlalchemy.org/trac/ticket/2320)'
- en: '[`Column.key`](../core/metadata.html#sqlalchemy.schema.Column.key "sqlalchemy.schema.Column.key")
    is honored in the [`Select.c`](../core/selectable.html#sqlalchemy.sql.expression.Select.c
    "sqlalchemy.sql.expression.Select.c") attribute of [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") with `Select.apply_labels()`'
  id: totrans-666
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[`Column.key`](../core/metadata.html#sqlalchemy.schema.Column.key "sqlalchemy.schema.Column.key")在[`Select.c`](../core/selectable.html#sqlalchemy.sql.expression.Select.c
    "sqlalchemy.sql.expression.Select.c")属性中受到`Select.apply_labels()`的尊重'
- en: 'Users of the expression system know that `Select.apply_labels()` prepends the
    table name to each column name, affecting the names that are available from [`Select.c`](../core/selectable.html#sqlalchemy.sql.expression.Select.c
    "sqlalchemy.sql.expression.Select.c"):'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式系统的用户知道`Select.apply_labels()`会在每个列名前添加表名，影响从[`Select.c`](../core/selectable.html#sqlalchemy.sql.expression.Select.c
    "sqlalchemy.sql.expression.Select.c")中可用的名称：
- en: '[PRE131]'
  id: totrans-668
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'Before 0.8, if the [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") had a different [`Column.key`](../core/metadata.html#sqlalchemy.schema.Column.key
    "sqlalchemy.schema.Column.key"), this key would be ignored, inconsistently versus
    when `Select.apply_labels()` were not used:'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 在0.8之前，如果[`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")具有不同的[`Column.key`](../core/metadata.html#sqlalchemy.schema.Column.key
    "sqlalchemy.schema.Column.key")，则此键将被忽略，与未使用`Select.apply_labels()`时的不一致性：
- en: '[PRE132]'
  id: totrans-670
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'In 0.8, [`Column.key`](../core/metadata.html#sqlalchemy.schema.Column.key "sqlalchemy.schema.Column.key")
    is honored in both cases:'
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 在0.8中，[`Column.key`](../core/metadata.html#sqlalchemy.schema.Column.key "sqlalchemy.schema.Column.key")在两种情况下都受到尊重：
- en: '[PRE133]'
  id: totrans-672
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: All other behavior regarding “name” and “key” are the same, including that the
    rendered SQL will still use the form `<tablename>_<colname>` - the emphasis here
    was on preventing the [`Column.key`](../core/metadata.html#sqlalchemy.schema.Column.key
    "sqlalchemy.schema.Column.key") contents from being rendered into the `SELECT`
    statement so that there are no issues with special/ non-ascii characters used
    in the [`Column.key`](../core/metadata.html#sqlalchemy.schema.Column.key "sqlalchemy.schema.Column.key").
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: 关于“name”和“key”的所有其他行为都是相同的，包括渲染的SQL仍然使用形式`<tablename>_<colname>` - 这里的重点是防止[`Column.key`](../core/metadata.html#sqlalchemy.schema.Column.key
    "sqlalchemy.schema.Column.key")内容被渲染到`SELECT`语句中，以便在[`Column.key`](../core/metadata.html#sqlalchemy.schema.Column.key
    "sqlalchemy.schema.Column.key")中使用特殊/非ASCII字符时不会出现问题。
- en: '[#2397](https://www.sqlalchemy.org/trac/ticket/2397)'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2397](https://www.sqlalchemy.org/trac/ticket/2397)'
- en: single_parent warning is now an error
  id: totrans-675
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`single_parent`警告现在是错误'
- en: A [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") that is many-to-one or many-to-many and specifies
    “cascade=’all, delete-orphan’”, which is an awkward but nonetheless supported
    use case (with restrictions) will now raise an error if the relationship does
    not specify the `single_parent=True` option. Previously it would only emit a warning,
    but a failure would follow almost immediately within the attribute system in any
    case.
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 一个[`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")，它是多对一或多对多关系，并指定了“cascade=’all, delete-orphan’”，这是一个尴尬但仍然支持的用例（带有限制），如果关系没有指定`single_parent=True`选项，现在将引发错误。以前只会发出警告，但在任何情况下几乎立即会在属性系统中跟随失败。
- en: '[#2405](https://www.sqlalchemy.org/trac/ticket/2405)'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2405](https://www.sqlalchemy.org/trac/ticket/2405)'
- en: Adding the `inspector` argument to the `column_reflect` event
  id: totrans-678
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将`inspector`参数添加到`column_reflect`事件
- en: '0.7 added a new event called `column_reflect`, provided so that the reflection
    of columns could be augmented as each one were reflected. We got this event slightly
    wrong in that the event gave no way to get at the current `Inspector` and `Connection`
    being used for the reflection, in the case that additional information from the
    database is needed. As this is a new event not widely used yet, we’ll be adding
    the `inspector` argument into it directly:'
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 0.7添加了一个名为`column_reflect`的新事件，提供了每个列反射时可以增强的事件。我们在这个事件上稍微出了点错，因为事件没有提供获取当前用于反射的`Inspector`和`Connection`的方法，以防需要来自数据库的其他信息。由于这是一个尚未广泛使用的新事件，我们将直接在其中添加`inspector`参数：
- en: '[PRE134]'
  id: totrans-680
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[#2418](https://www.sqlalchemy.org/trac/ticket/2418)'
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2418](https://www.sqlalchemy.org/trac/ticket/2418)'
- en: Disabling auto-detect of collations, casing for MySQL
  id: totrans-682
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 禁用MySQL的自动检测排序规则和大小写
- en: The MySQL dialect does two calls, one very expensive, to load all possible collations
    from the database as well as information on casing, the first time an `Engine`
    connects. Neither of these collections are used for any SQLAlchemy functions,
    so these calls will be changed to no longer be emitted automatically. Applications
    that might have relied on these collections being present on `engine.dialect`
    will need to call upon `_detect_collations()` and `_detect_casing()` directly.
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL方言在`Engine`连接时第一次进行两次调用，其中一次非常昂贵，加载数据库中的所有可能排序规则以及大小写信息。这两个集合都不会用于任何SQLAlchemy函数，因此这些调用将被更改为不再自动发出。可能依赖于这些集合存在于`engine.dialect`上的应用程序将需要直接调用`_detect_collations()`和`_detect_casing()`。
- en: '[#2404](https://www.sqlalchemy.org/trac/ticket/2404)'
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2404](https://www.sqlalchemy.org/trac/ticket/2404)'
- en: “Unconsumed column names” warning becomes an exception
  id: totrans-685
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: “未使用的列名”警告变为异常
- en: 'Referring to a non-existent column in an `insert()` or `update()` construct
    will raise an error instead of a warning:'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 在`insert()`或`update()`构造中引用不存在的列将引发错误而不是警告：
- en: '[PRE135]'
  id: totrans-687
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[#2415](https://www.sqlalchemy.org/trac/ticket/2415)'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2415](https://www.sqlalchemy.org/trac/ticket/2415)'
- en: Inspector.get_primary_keys() is deprecated, use Inspector.get_pk_constraint
  id: totrans-689
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Inspector.get_primary_keys()已弃用，请使用Inspector.get_pk_constraint
- en: 'These two methods on `Inspector` were redundant, where `get_primary_keys()`
    would return the same information as `get_pk_constraint()` minus the name of the
    constraint:'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种`Inspector`上的方法是多余的，其中`get_primary_keys()`将返回与`get_pk_constraint()`相同的信息，只是不包括约束的名称：
- en: '[PRE136]'
  id: totrans-691
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[#2422](https://www.sqlalchemy.org/trac/ticket/2422)'
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2422](https://www.sqlalchemy.org/trac/ticket/2422)'
- en: Case-insensitive result row names will be disabled in most cases
  id: totrans-693
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 大多数情况下将禁用不区分大小写的结果行名称
- en: 'A very old behavior, the column names in `RowProxy` were always compared case-insensitively:'
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常古老的行为，`RowProxy`中的列名始终是不区分大小写比较的：
- en: '[PRE137]'
  id: totrans-695
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: This was for the benefit of a few dialects which in the early days needed this,
    like Oracle and Firebird, but in modern usage we have more accurate ways of dealing
    with the case-insensitive behavior of these two platforms.
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 这是为了一些在早期需要这样做的方言，如Oracle和Firebird，但在现代用法中，我们有更准确的方法来处理这两个平台的不区分大小写行为。
- en: Going forward, this behavior will be available only optionally, by passing the
    flag ``case_sensitive=False`` to ``create_engine()``, but otherwise column names
    requested from the row must match as far as casing.
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 未来，此行为将仅可选地可用，通过将标志``case_sensitive=False``传递给``create_engine()``，但否则从行中请求的列名必须匹配大小写。
- en: '[#2423](https://www.sqlalchemy.org/trac/ticket/2423)'
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2423](https://www.sqlalchemy.org/trac/ticket/2423)'
- en: '`InstrumentationManager` and alternate class instrumentation is now an extension'
  id: totrans-699
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`InstrumentationManager`和替代类仪器现在是一个扩展'
- en: The `sqlalchemy.orm.interfaces.InstrumentationManager` class is moved to `sqlalchemy.ext.instrumentation.InstrumentationManager`.
    The “alternate instrumentation” system was built for the benefit of a very small
    number of installations that needed to work with existing or unusual class instrumentation
    systems, and generally is very seldom used. The complexity of this system has
    been exported to an `ext.` module. It remains unused until once imported, typically
    when a third party library imports `InstrumentationManager`, at which point it
    is injected back into `sqlalchemy.orm` by replacing the default `InstrumentationFactory`
    with `ExtendedInstrumentationRegistry`.
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: '`sqlalchemy.orm.interfaces.InstrumentationManager`类已移至`sqlalchemy.ext.instrumentation.InstrumentationManager`。
    “替代仪器”系统是为了极少数需要使用现有或不寻常的类仪器系统的安装而构建的，并且通常很少使用。该系统的复杂性已导出到一个`ext.`模块中。直到被导入后才会使用，通常是当第三方库导入`InstrumentationManager`时，此时它将通过用`ExtendedInstrumentationRegistry`替换默认的`InstrumentationFactory`将其注入回`sqlalchemy.orm`中。'
- en: '### The consideration of a “pending” object as an “orphan” has been made more
    aggressive'
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: '### 将“待定”对象视为“孤儿”的考虑变得更加激进'
- en: This is a late add to the 0.8 series, however it is hoped that the new behavior
    is generally more consistent and intuitive in a wider variety of situations. The
    ORM has since at least version 0.4 included behavior such that an object that’s
    “pending”, meaning that it’s associated with a [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") but hasn’t been inserted into the database yet, is automatically
    expunged from the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    when it becomes an “orphan”, which means it has been de-associated with a parent
    object that refers to it with `delete-orphan` cascade on the configured [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship"). This behavior is intended to approximately mirror
    the behavior of a persistent (that is, already inserted) object, where the ORM
    will emit a DELETE for such objects that become orphans based on the interception
    of detachment events.
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 这是0.8系列的一个较晚添加，但希望新行为在更广泛的情况下通常更一致和直观。ORM自至少0.4版本以来已经包含了这样的行为，即一个“待定”对象，意味着它与[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")相关联，但尚未插入到数据库中，当它成为“孤儿”时，即已经与引用它的父对象解除关联，并且在配置的[`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")上使用`delete-orphan`级联时，将自动从[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")中删除。此行为旨在大致反映持久对象（即已插入）的行为，ORM将根据分离事件的拦截为这些成为孤儿的对象发出DELETE。
- en: The behavioral change comes into play for objects that are referred to by multiple
    kinds of parents that each specify `delete-orphan`; the typical example is an
    [association object](../orm/basic_relationships.html#association-pattern) that
    bridges two other kinds of objects in a many-to-many pattern. Previously, the
    behavior was such that the pending object would be expunged only when de-associated
    with *all* of its parents. With the behavioral change, the pending object is expunged
    as soon as it is de-associated from *any* of the parents that it was previously
    associated with. This behavior is intended to more closely match that of persistent
    objects, which are deleted as soon as they are de-associated from any parent.
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 行为变更适用于被多种类型父对象引用的对象，每种类型父对象都指定`delete-orphan`；典型示例是在多对多模式中桥接两种其他对象的[关联对象](../orm/basic_relationships.html#association-pattern)。以前的行为是，挂起的对象仅在与*所有*父对象解除关联时才会被清除。通过行为变更，只要挂起的对象与先前相关联的*任何*父对象解除关联，它就会被清除。这种行为旨在更接近持久对象的行为，即只要它们与任何父对象解除关联，它们就会被删除。
- en: The rationale for the older behavior dates back at least to version 0.4, and
    was basically a defensive decision to try to alleviate confusion when an object
    was still being constructed for INSERT. But the reality is that the object is
    re-associated with the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") as soon as it is attached to any new parent in any case.
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 较旧行为的基本理由可以追溯到至少版本0.4，基本上是一种防御性决定，试图在对象仍在为INSERT构造时减轻混淆。但事实是，无论如何，只要对象附加到任何新父对象，它就会立即重新与[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")相关联。
- en: It’s still possible to flush an object that is not associated with all of its
    required parents, if the object was either not associated with those parents in
    the first place, or if it was expunged, but then re-associated with a [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") via a subsequent attachment event but still not fully
    associated. In this situation, it is expected that the database would emit an
    integrity error, as there are likely NOT NULL foreign key columns that are unpopulated.
    The ORM makes the decision to let these INSERT attempts occur, based on the judgment
    that an object that is only partially associated with its required parents but
    has been actively associated with some of them, is more often than not a user
    error, rather than an intentional omission which should be silently skipped -
    silently skipping the INSERT here would make user errors of this nature very hard
    to debug.
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然可以刷新一个与所有必需父对象都不相关联的对象，如果该对象一开始就没有与这些父对象相关联，或者如果它被清除，但后来通过后续的附加事件重新与[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")相关联但仍未完全相关联。在这种情况下，预计数据库会发出完整性错误，因为可能存在未填充的NOT NULL外键列。ORM决定让这些INSERT尝试发生，基于这样的判断：一个只与其必需父对象部分相关联但已经积极与其中一些相关联的对象，往往更多是用户错误，而不是应该被悄悄跳过的有意遗漏
    - 在这里悄悄跳过INSERT会使这种用户错误非常难以调试。
- en: The old behavior, for applications that might have been relying upon it, can
    be re-enabled for any [`Mapper`](../orm/mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper") by specifying the flag `legacy_is_orphan` as a mapper
    option.
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: 对于可能依赖于旧行为的应用程序，可以通过将标志`legacy_is_orphan`作为映射器选项指定，重新启用任何[`Mapper`](../orm/mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper")的旧行为。
- en: 'The new behavior allows the following test case to work:'
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 新行为允许以下测试用例工作：
- en: '[PRE138]'
  id: totrans-708
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[#2655](https://www.sqlalchemy.org/trac/ticket/2655)'
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2655](https://www.sqlalchemy.org/trac/ticket/2655)'
- en: The after_attach event fires after the item is associated with the Session instead
    of before; before_attach added
  id: totrans-710
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: after_attach事件在项目与会话关联后而不是之前触发；添加了before_attach
- en: 'Event handlers which use after_attach can now assume the given instance is
    associated with the given session:'
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 使用after_attach的事件处理程序现在可以假定给定的实例与给定的会话相关联：
- en: '[PRE139]'
  id: totrans-712
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'Some use cases require that it work this way. However, other use cases require
    that the item is *not* yet part of the session, such as when a query, intended
    to load some state required for an instance, emits autoflush first and would otherwise
    prematurely flush the target object. Those use cases should use the new “before_attach”
    event:'
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 有些用例要求它按照这种方式工作。然而，其他用例要求该项*尚未*成为会话的一部分，比如当一个查询，旨在加载实例所需的某些状态时，首先发出自动刷新，否则会过早刷新目标对象。这些用例应该使用新的“before_attach”事件：
- en: '[PRE140]'
  id: totrans-714
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[#2464](https://www.sqlalchemy.org/trac/ticket/2464)'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2464](https://www.sqlalchemy.org/trac/ticket/2464)'
- en: Query now auto-correlates like a select() does
  id: totrans-716
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查询现在会像`select()`一样自动关联
- en: 'Previously it was necessary to call [`Query.correlate()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.correlate
    "sqlalchemy.orm.Query.correlate") in order to have a column- or WHERE-subquery
    correlate to the parent:'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 以前需要调用[`Query.correlate()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.correlate
    "sqlalchemy.orm.Query.correlate")才能使列或 WHERE 子查询与父级关联：
- en: '[PRE141]'
  id: totrans-718
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'This was the opposite behavior of a plain `select()` construct which would
    assume auto-correlation by default. The above statement in 0.8 will correlate
    automatically:'
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个普通 `select()` 构造的相反行为，默认情况下会假定自动关联。在 0.8 中，上述语句将自动关联：
- en: '[PRE142]'
  id: totrans-720
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: like in `select()`, correlation can be disabled by calling `query.correlate(None)`
    or manually set by passing an entity, `query.correlate(someentity)`.
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在 `select()` 中一样，可以通过调用 `query.correlate(None)` 来禁用关联，或者通过传递一个实体来手动设置，`query.correlate(someentity)`。
- en: '[#2179](https://www.sqlalchemy.org/trac/ticket/2179)'
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2179](https://www.sqlalchemy.org/trac/ticket/2179)'
- en: '### Correlation is now always context-specific'
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: '### 关联现在始终是上下文特定的'
- en: To allow a wider variety of correlation scenarios, the behavior of [`Select.correlate()`](../core/selectable.html#sqlalchemy.sql.expression.Select.correlate
    "sqlalchemy.sql.expression.Select.correlate") and [`Query.correlate()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.correlate
    "sqlalchemy.orm.Query.correlate") has changed slightly such that the SELECT statement
    will omit the “correlated” target from the FROM clause only if the statement is
    actually used in that context. Additionally, it’s no longer possible for a SELECT
    statement that’s placed as a FROM in an enclosing SELECT statement to “correlate”
    (i.e. omit) a FROM clause.
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许更广泛的关联情景，[`Select.correlate()`](../core/selectable.html#sqlalchemy.sql.expression.Select.correlate
    "sqlalchemy.sql.expression.Select.correlate") 和[`Query.correlate()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.correlate
    "sqlalchemy.orm.Query.correlate") 的行为略有变化，这样 SELECT 语句将仅在实际使用它在该上下文中时，从 FROM 子句中省略“相关”的目标。此外，不再可能在一个封闭的
    SELECT 语句中作为 FROM 放置一个 SELECT 语句来“关联”（即省略）一个 FROM 子句。
- en: 'This change only makes things better as far as rendering SQL, in that it’s
    no longer possible to render illegal SQL where there are insufficient FROM objects
    relative to what’s being selected:'
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: 这个变化只会使 SQL 渲染变得更好，因为不再可能渲染出非法的 SQL，其中选择的 FROM 对象不足：
- en: '[PRE143]'
  id: totrans-726
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'Prior to this change, the above would return:'
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个变化之前，上述内容会返回：
- en: '[PRE144]'
  id: totrans-728
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: which is invalid SQL as “t1” is not referred to in any FROM clause.
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 这是无效的 SQL，因为“t1”在任何 FROM 子句中都没有被引用。
- en: 'Now, in the absence of an enclosing SELECT, it returns:'
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在没有封闭 SELECT 的情况下，它返回：
- en: '[PRE145]'
  id: totrans-731
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'Within a SELECT, the correlation takes effect as expected:'
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SELECT 中，关联会按预期生效：
- en: '[PRE146]'
  id: totrans-733
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-734
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: This change is not expected to impact any existing applications, as the correlation
    behavior remains identical for properly constructed expressions. Only an application
    that relies, most likely within a testing scenario, on the invalid string output
    of a correlated SELECT used in a non-correlating context would see any change.
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 这个变化预计不会影响任何现有的应用程序，因为相关性行为对于正确构建的表达式保持不变。只有一个依赖于在非相关上下文中使用相关 SELECT 的无效字符串输出的应用程序，最有可能是在测试场景中，才会看到任何变化。
- en: '[#2668](https://www.sqlalchemy.org/trac/ticket/2668)'
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2668](https://www.sqlalchemy.org/trac/ticket/2668)'
- en: '### create_all() and drop_all() will now honor an empty list as such'
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: '### create_all() 和 drop_all() 现在将尊重一个空列表'
- en: The methods [`MetaData.create_all()`](../core/metadata.html#sqlalchemy.schema.MetaData.create_all
    "sqlalchemy.schema.MetaData.create_all") and [`MetaData.drop_all()`](../core/metadata.html#sqlalchemy.schema.MetaData.drop_all
    "sqlalchemy.schema.MetaData.drop_all") will now accept a list of [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") objects that is empty, and will not emit any CREATE
    or DROP statements. Previously, an empty list was interpreted the same as passing
    `None` for a collection, and CREATE/DROP would be emitted for all items unconditionally.
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: 方法[`MetaData.create_all()`](../core/metadata.html#sqlalchemy.schema.MetaData.create_all
    "sqlalchemy.schema.MetaData.create_all")和[`MetaData.drop_all()`](../core/metadata.html#sqlalchemy.schema.MetaData.drop_all
    "sqlalchemy.schema.MetaData.drop_all")现在将接受一个空的[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")对象列表，并且不会发出任何 CREATE 或 DROP 语句。以前，空列表被解释为传递`None`给一个集合，对于所有项目都会无条件发出
    CREATE/DROP。
- en: This is a bug fix but some applications may have been relying upon the previous
    behavior.
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个 bug 修复，但某些应用可能一直依赖于以前的行为。
- en: '[#2664](https://www.sqlalchemy.org/trac/ticket/2664)'
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2664](https://www.sqlalchemy.org/trac/ticket/2664)'
- en: Repaired the Event Targeting of [`InstrumentationEvents`](../orm/events.html#sqlalchemy.orm.InstrumentationEvents
    "sqlalchemy.orm.InstrumentationEvents")
  id: totrans-741
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修复了 [`InstrumentationEvents`](../orm/events.html#sqlalchemy.orm.InstrumentationEvents
    "sqlalchemy.orm.InstrumentationEvents") 的事件定位
- en: The [`InstrumentationEvents`](../orm/events.html#sqlalchemy.orm.InstrumentationEvents
    "sqlalchemy.orm.InstrumentationEvents") series of event targets have documented
    that the events will only be fired off according to the actual class passed as
    a target. Through 0.7, this wasn’t the case, and any event listener applied to
    [`InstrumentationEvents`](../orm/events.html#sqlalchemy.orm.InstrumentationEvents
    "sqlalchemy.orm.InstrumentationEvents") would be invoked for all classes mapped.
    In 0.8, additional logic has been added so that the events will only invoke for
    those classes sent in. The `propagate` flag here is set to `True` by default as
    class instrumentation events are typically used to intercept classes that aren’t
    yet created.
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: '[`InstrumentationEvents`](../orm/events.html#sqlalchemy.orm.InstrumentationEvents
    "sqlalchemy.orm.InstrumentationEvents") 系列事件目标已经记录，事件将根据实际传递的类来触发。直到0.7版本，这并不是这样，任何应用于
    [`InstrumentationEvents`](../orm/events.html#sqlalchemy.orm.InstrumentationEvents
    "sqlalchemy.orm.InstrumentationEvents") 的事件监听器都会对所有映射的类调用。在0.8中，添加了额外的逻辑，使事件只会为那些传递的类调用。这里的
    `propagate` 标志默认设置为 `True`，因为类仪器事件通常用于拦截尚未创建的类。'
- en: '[#2590](https://www.sqlalchemy.org/trac/ticket/2590)'
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2590](https://www.sqlalchemy.org/trac/ticket/2590)'
- en: No more magic coercion of “=” to IN when comparing to subquery in MS-SQL
  id: totrans-744
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不再将“=”在MS-SQL中与子查询比较时自动转换为IN
- en: 'We found a very old behavior in the MSSQL dialect which would attempt to rescue
    users from themselves when doing something like this:'
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在MSSQL方言中发现了一个非常古老的行为，当用户尝试做类似这样的事情时，它会试图拯救用户：
- en: '[PRE148]'
  id: totrans-746
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: SQL Server doesn’t allow an equality comparison to a scalar SELECT, that is,
    “x = (SELECT something)”. The MSSQL dialect would convert this to an IN. The same
    thing would happen however upon a comparison like “(SELECT something) = x”, and
    overall this level of guessing is outside of SQLAlchemy’s usual scope so the behavior
    is removed.
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: SQL Server不允许将等号与标量SELECT进行比较，即，“x = (SELECT something)”。MSSQL方言会将其转换为IN。然而，当进行类似“(SELECT
    something) = x”的比较时，也会发生同样的情况，总体而言，这种猜测的水平超出了SQLAlchemy通常的范围，因此已移除该行为。
- en: '[#2277](https://www.sqlalchemy.org/trac/ticket/2277)'
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2277](https://www.sqlalchemy.org/trac/ticket/2277)'
- en: Fixed the behavior of [`Session.is_modified()`](../orm/session_api.html#sqlalchemy.orm.Session.is_modified
    "sqlalchemy.orm.Session.is_modified")
  id: totrans-749
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修复了 [`Session.is_modified()`](../orm/session_api.html#sqlalchemy.orm.Session.is_modified
    "sqlalchemy.orm.Session.is_modified") 的行为
- en: The [`Session.is_modified()`](../orm/session_api.html#sqlalchemy.orm.Session.is_modified
    "sqlalchemy.orm.Session.is_modified") method accepts an argument `passive` which
    basically should not be necessary, the argument in all cases should be the value
    `True` - when left at its default of `False` it would have the effect of hitting
    the database, and often triggering autoflush which would itself change the results.
    In 0.8 the `passive` argument will have no effect, and unloaded attributes will
    never be checked for history since by definition there can be no pending state
    change on an unloaded attribute.
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session.is_modified()`](../orm/session_api.html#sqlalchemy.orm.Session.is_modified
    "sqlalchemy.orm.Session.is_modified") 方法接受一个参数 `passive`，基本上不应该是必要的，所有情况下参数应该是值
    `True` - 当保持默认值 `False` 时，它会影响到数据库，并经常触发自动刷新，这将改变结果。在0.8中，`passive` 参数将不会产生任何影响，并且未加载的属性永远不会被检查历史，因为根据定义，未加载的属性不会有待处理的状态更改。'
- en: See also
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`Session.is_modified()`](../orm/session_api.html#sqlalchemy.orm.Session.is_modified
    "sqlalchemy.orm.Session.is_modified")'
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session.is_modified()`](../orm/session_api.html#sqlalchemy.orm.Session.is_modified
    "sqlalchemy.orm.Session.is_modified")'
- en: '[#2320](https://www.sqlalchemy.org/trac/ticket/2320)'
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2320](https://www.sqlalchemy.org/trac/ticket/2320)'
- en: '[`Column.key`](../core/metadata.html#sqlalchemy.schema.Column.key "sqlalchemy.schema.Column.key")
    is honored in the [`Select.c`](../core/selectable.html#sqlalchemy.sql.expression.Select.c
    "sqlalchemy.sql.expression.Select.c") attribute of [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") with `Select.apply_labels()`'
  id: totrans-754
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '[`Column.key`](../core/metadata.html#sqlalchemy.schema.Column.key "sqlalchemy.schema.Column.key")
    在 [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select "sqlalchemy.sql.expression.select")
    的 `Select.c` 属性中通过 `Select.apply_labels()` 得到尊重'
- en: 'Users of the expression system know that `Select.apply_labels()` prepends the
    table name to each column name, affecting the names that are available from [`Select.c`](../core/selectable.html#sqlalchemy.sql.expression.Select.c
    "sqlalchemy.sql.expression.Select.c"):'
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 表达式系统的用户知道`Select.apply_labels()`会在每个列名前面添加表名，影响从[`Select.c`](../core/selectable.html#sqlalchemy.sql.expression.Select.c
    "sqlalchemy.sql.expression.Select.c")中可用的名称：
- en: '[PRE149]'
  id: totrans-756
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'Before 0.8, if the [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") had a different [`Column.key`](../core/metadata.html#sqlalchemy.schema.Column.key
    "sqlalchemy.schema.Column.key"), this key would be ignored, inconsistently versus
    when `Select.apply_labels()` were not used:'
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 在0.8版本之前，如果[`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")的[`Column.key`](../core/metadata.html#sqlalchemy.schema.Column.key
    "sqlalchemy.schema.Column.key")不同，这个键会被忽略，与未使用`Select.apply_labels()`时不一致：
- en: '[PRE150]'
  id: totrans-758
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'In 0.8, [`Column.key`](../core/metadata.html#sqlalchemy.schema.Column.key "sqlalchemy.schema.Column.key")
    is honored in both cases:'
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: 在0.8版本中，[`Column.key`](../core/metadata.html#sqlalchemy.schema.Column.key "sqlalchemy.schema.Column.key")在两种情况下都受到尊重：
- en: '[PRE151]'
  id: totrans-760
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: All other behavior regarding “name” and “key” are the same, including that the
    rendered SQL will still use the form `<tablename>_<colname>` - the emphasis here
    was on preventing the [`Column.key`](../core/metadata.html#sqlalchemy.schema.Column.key
    "sqlalchemy.schema.Column.key") contents from being rendered into the `SELECT`
    statement so that there are no issues with special/ non-ascii characters used
    in the [`Column.key`](../core/metadata.html#sqlalchemy.schema.Column.key "sqlalchemy.schema.Column.key").
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: 关于“name”和“key”的所有其他行为都是相同的，包括渲染的SQL仍然会使用`<tablename>_<colname>`的形式 - 这里的重点是防止[`Column.key`](../core/metadata.html#sqlalchemy.schema.Column.key
    "sqlalchemy.schema.Column.key")的内容被渲染到`SELECT`语句中，以避免在[`Column.key`](../core/metadata.html#sqlalchemy.schema.Column.key
    "sqlalchemy.schema.Column.key")中使用特殊/非ASCII字符时出现问题。
- en: '[#2397](https://www.sqlalchemy.org/trac/ticket/2397)'
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2397](https://www.sqlalchemy.org/trac/ticket/2397)'
- en: single_parent warning is now an error
  id: totrans-763
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`single_parent`警告现在变成了错误'
- en: A [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") that is many-to-one or many-to-many and specifies
    “cascade=’all, delete-orphan’”, which is an awkward but nonetheless supported
    use case (with restrictions) will now raise an error if the relationship does
    not specify the `single_parent=True` option. Previously it would only emit a warning,
    but a failure would follow almost immediately within the attribute system in any
    case.
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: 一个[`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")，它是多对一或多对多关系，并指定“cascade='all, delete-orphan'”，这是一个尴尬但仍然支持的用例（受限制），如果关系没有指定`single_parent=True`选项，现在将引发错误。以前它只会发出警告，但在任何情况下几乎立即会在属性系统中跟随失败。
- en: '[#2405](https://www.sqlalchemy.org/trac/ticket/2405)'
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2405](https://www.sqlalchemy.org/trac/ticket/2405)'
- en: Adding the `inspector` argument to the `column_reflect` event
  id: totrans-766
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将`inspector`参数添加到`column_reflect`事件中
- en: '0.7 added a new event called `column_reflect`, provided so that the reflection
    of columns could be augmented as each one were reflected. We got this event slightly
    wrong in that the event gave no way to get at the current `Inspector` and `Connection`
    being used for the reflection, in the case that additional information from the
    database is needed. As this is a new event not widely used yet, we’ll be adding
    the `inspector` argument into it directly:'
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: 0.7版本添加了一个名为`column_reflect`的新事件，提供了对每个反射的列进行增强的方式。我们在这个事件中稍微出了点错，因为事件没有提供访问当前用于反射的`Inspector`和`Connection`的方法，以防需要来自数据库的附加信息。由于这是一个尚未广泛使用的新事件，我们将直接在其中添加`inspector`参数：
- en: '[PRE152]'
  id: totrans-768
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '[#2418](https://www.sqlalchemy.org/trac/ticket/2418)'
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2418](https://www.sqlalchemy.org/trac/ticket/2418)'
- en: Disabling auto-detect of collations, casing for MySQL
  id: totrans-770
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 禁用MySQL的自动检测排序规则和大小写敏感性
- en: The MySQL dialect does two calls, one very expensive, to load all possible collations
    from the database as well as information on casing, the first time an `Engine`
    connects. Neither of these collections are used for any SQLAlchemy functions,
    so these calls will be changed to no longer be emitted automatically. Applications
    that might have relied on these collections being present on `engine.dialect`
    will need to call upon `_detect_collations()` and `_detect_casing()` directly.
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL方言进行两次调用，其中一次非常昂贵，从数据库加载所有可能的排序规则以及大小写敏感性的信息，第一次引擎连接时。这两个集合都不会被任何SQLAlchemy函数使用，因此这些调用将被更改为不再自动发出。可能依赖于这些集合存在于`engine.dialect`上的应用程序将需要直接调用`_detect_collations()`和`_detect_casing()`。
- en: '[#2404](https://www.sqlalchemy.org/trac/ticket/2404)'
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2404](https://www.sqlalchemy.org/trac/ticket/2404)'
- en: “Unconsumed column names” warning becomes an exception
  id: totrans-773
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: “未消耗的列名” 警告变为异常
- en: 'Referring to a non-existent column in an `insert()` or `update()` construct
    will raise an error instead of a warning:'
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `insert()` 或 `update()` 构造中引用不存在的列将引发错误而不是警告：
- en: '[PRE153]'
  id: totrans-775
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: '[#2415](https://www.sqlalchemy.org/trac/ticket/2415)'
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2415](https://www.sqlalchemy.org/trac/ticket/2415)'
- en: Inspector.get_primary_keys() is deprecated, use Inspector.get_pk_constraint
  id: totrans-777
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Inspector.get_primary_keys() 已弃用，请使用 Inspector.get_pk_constraint
- en: 'These two methods on `Inspector` were redundant, where `get_primary_keys()`
    would return the same information as `get_pk_constraint()` minus the name of the
    constraint:'
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: '`Inspector` 上的这两种方法是多余的，`get_primary_keys()` 将返回与 `get_pk_constraint()` 相同的信息，但不包括约束的名称：'
- en: '[PRE154]'
  id: totrans-779
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '[#2422](https://www.sqlalchemy.org/trac/ticket/2422)'
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2422](https://www.sqlalchemy.org/trac/ticket/2422)'
- en: Case-insensitive result row names will be disabled in most cases
  id: totrans-781
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 大多数情况下将禁用不区分大小写的结果行名称
- en: 'A very old behavior, the column names in `RowProxy` were always compared case-insensitively:'
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常古老的行为，`RowProxy` 中的列名总是不区分大小写地进行比较：
- en: '[PRE155]'
  id: totrans-783
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: This was for the benefit of a few dialects which in the early days needed this,
    like Oracle and Firebird, but in modern usage we have more accurate ways of dealing
    with the case-insensitive behavior of these two platforms.
  id: totrans-784
  prefs: []
  type: TYPE_NORMAL
  zh: 这是为了一些在早期需要这样做的方言的利益，比如 Oracle 和 Firebird，但在现代用法中，我们有更准确的方法来处理这两个平台的不区分大小写行为。
- en: Going forward, this behavior will be available only optionally, by passing the
    flag ``case_sensitive=False`` to ``create_engine()``, but otherwise column names
    requested from the row must match as far as casing.
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 未来，此行为将仅可选地通过向 `create_engine()` 传递标志 ``case_sensitive=False`` 来使用，但否则从行中请求的列名必须匹配大小写。
- en: '[#2423](https://www.sqlalchemy.org/trac/ticket/2423)'
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2423](https://www.sqlalchemy.org/trac/ticket/2423)'
- en: '`InstrumentationManager` and alternate class instrumentation is now an extension'
  id: totrans-787
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`InstrumentationManager` 和替代类仪器现在是一个扩展'
- en: The `sqlalchemy.orm.interfaces.InstrumentationManager` class is moved to `sqlalchemy.ext.instrumentation.InstrumentationManager`.
    The “alternate instrumentation” system was built for the benefit of a very small
    number of installations that needed to work with existing or unusual class instrumentation
    systems, and generally is very seldom used. The complexity of this system has
    been exported to an `ext.` module. It remains unused until once imported, typically
    when a third party library imports `InstrumentationManager`, at which point it
    is injected back into `sqlalchemy.orm` by replacing the default `InstrumentationFactory`
    with `ExtendedInstrumentationRegistry`.
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: '`sqlalchemy.orm.interfaces.InstrumentationManager` 类已移动到 `sqlalchemy.ext.instrumentation.InstrumentationManager`。
    “替代仪器”系统是为了极少数需要使用现有或不寻常的类仪器系统的安装而构建的，并且通常很少使用。 这个系统的复杂性已导出到一个 `ext.` 模块中。 它在导入一次后保持未使用，通常是在第三方库导入
    `InstrumentationManager` 时，此时通过用 `ExtendedInstrumentationRegistry` 替换默认的 `InstrumentationFactory`
    将其注入回 `sqlalchemy.orm`。'
- en: Removed
  id: totrans-789
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 已移除
- en: SQLSoup
  id: totrans-790
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SQLSoup
- en: SQLSoup is a handy package that presents an alternative interface on top of
    the SQLAlchemy ORM. SQLSoup is now moved into its own project and documented/released
    separately; see [https://bitbucket.org/zzzeek/sqlsoup](https://bitbucket.org/zzzeek/sqlsoup).
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: SQLSoup 是一个方便的包，它在 SQLAlchemy ORM 之上提供了一个替代接口。 SQLSoup 现在已移至其自己的项目，并单独进行了文档化/发布；请参见
    [https://bitbucket.org/zzzeek/sqlsoup](https://bitbucket.org/zzzeek/sqlsoup)。
- en: SQLSoup is a very simple tool that could also benefit from contributors who
    are interested in its style of usage.
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: SQLSoup 是一个非常简单的工具，也可以受益于对其使用方式感兴趣的贡献者。
- en: '[#2262](https://www.sqlalchemy.org/trac/ticket/2262)'
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2262](https://www.sqlalchemy.org/trac/ticket/2262)'
- en: MutableType
  id: totrans-794
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可变类型
- en: The older “mutable” system within the SQLAlchemy ORM has been removed. This
    refers to the `MutableType` interface which was applied to types such as `PickleType`
    and conditionally to `TypeDecorator`, and since very early SQLAlchemy versions
    has provided a way for the ORM to detect changes in so-called “mutable” data structures
    such as JSON structures and pickled objects. However, the implementation was never
    reasonable and forced a very inefficient mode of usage on the unit-of-work which
    caused an expensive scan of all objects to take place during flush. In 0.7, the
    [sqlalchemy.ext.mutable](https://docs.sqlalchemy.org/en/latest/orm/extensions/mutable.html)
    extension was introduced so that user-defined datatypes can appropriately send
    events to the unit of work as changes occur.
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy ORM 中的旧的“可变”系统已经移除。这指的是应用于诸如`PickleType`的类型和有条件地应用于`TypeDecorator`的`MutableType`接口，自很早的
    SQLAlchemy 版本以来一直提供了一种让 ORM 检测所谓的“可变”数据结构（如 JSON 结构和 pickled 对象）变化的方式。然而，该实现从未合理，强制单元操作工作在非常低效的模式下运行，导致在
    flush 期间对所有对象进行昂贵的扫描。在 0.7 版本中，引入了[sqlalchemy.ext.mutable](https://docs.sqlalchemy.org/en/latest/orm/extensions/mutable.html)扩展，以便用户定义的数据类型可以在发生更改时适当地向单元操作发送事件。
- en: Today, usage of `MutableType` is expected to be low, as warnings have been in
    place for some years now regarding its inefficiency.
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，`MutableType`的使用预计会很少，因为多年来已经发出了有关其低效性的警告。
- en: '[#2442](https://www.sqlalchemy.org/trac/ticket/2442)'
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2442](https://www.sqlalchemy.org/trac/ticket/2442)'
- en: sqlalchemy.exceptions (has been sqlalchemy.exc for years)
  id: totrans-798
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: sqlalchemy.exceptions（多年来一直是 sqlalchemy.exc）
- en: We had left in an alias `sqlalchemy.exceptions` to attempt to make it slightly
    easier for some very old libraries that hadn’t yet been upgraded to use `sqlalchemy.exc`.
    Some users are still being confused by it however so in 0.8 we’re taking it out
    entirely to eliminate any of that confusion.
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: 我们保留了别名`sqlalchemy.exceptions`，以尝试使一些非常旧的库稍微容易些，这些库尚未升级以使用`sqlalchemy.exc`。然而，一些用户仍然被困惑，因此在
    0.8 版本中，我们将其完全删除，以消除任何困惑。
- en: '[#2433](https://www.sqlalchemy.org/trac/ticket/2433)'
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2433](https://www.sqlalchemy.org/trac/ticket/2433)'
- en: SQLSoup
  id: totrans-801
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SQLSoup
- en: SQLSoup is a handy package that presents an alternative interface on top of
    the SQLAlchemy ORM. SQLSoup is now moved into its own project and documented/released
    separately; see [https://bitbucket.org/zzzeek/sqlsoup](https://bitbucket.org/zzzeek/sqlsoup).
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: SQLSoup 是一个方便的包，它在 SQLAlchemy ORM 之上提供了一个替代接口。SQLSoup 现在已移动到自己的项目中，并且进行了单独的文档编写/发布；请参阅[https://bitbucket.org/zzzeek/sqlsoup](https://bitbucket.org/zzzeek/sqlsoup)。
- en: SQLSoup is a very simple tool that could also benefit from contributors who
    are interested in its style of usage.
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: SQLSoup 是一个非常简单的工具，也可以从对其使用风格感兴趣的贡献者中受益。
- en: '[#2262](https://www.sqlalchemy.org/trac/ticket/2262)'
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2262](https://www.sqlalchemy.org/trac/ticket/2262)'
- en: MutableType
  id: totrans-805
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: MutableType
- en: The older “mutable” system within the SQLAlchemy ORM has been removed. This
    refers to the `MutableType` interface which was applied to types such as `PickleType`
    and conditionally to `TypeDecorator`, and since very early SQLAlchemy versions
    has provided a way for the ORM to detect changes in so-called “mutable” data structures
    such as JSON structures and pickled objects. However, the implementation was never
    reasonable and forced a very inefficient mode of usage on the unit-of-work which
    caused an expensive scan of all objects to take place during flush. In 0.7, the
    [sqlalchemy.ext.mutable](https://docs.sqlalchemy.org/en/latest/orm/extensions/mutable.html)
    extension was introduced so that user-defined datatypes can appropriately send
    events to the unit of work as changes occur.
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy ORM 中的旧的“可变”系统已经移除。这指的是应用于诸如`PickleType`的类型和有条件地应用于`TypeDecorator`的`MutableType`接口，自很早的
    SQLAlchemy 版本以来一直提供了一种让 ORM 检测所谓的“可变”数据结构（如 JSON 结构和 pickled 对象）变化的方式。然而，该实现从未合理，强制单元操作工作在非常低效的模式下运行，导致在
    flush 期间对所有对象进行昂贵的扫描。在 0.7 版本中，引入了[sqlalchemy.ext.mutable](https://docs.sqlalchemy.org/en/latest/orm/extensions/mutable.html)扩展，以便用户定义的数据类型可以在发生更改时适当地向单元操作发送事件。
- en: Today, usage of `MutableType` is expected to be low, as warnings have been in
    place for some years now regarding its inefficiency.
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，`MutableType`的使用预计会很少，因为多年来已经发出了有关其低效性的警告。
- en: '[#2442](https://www.sqlalchemy.org/trac/ticket/2442)'
  id: totrans-808
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2442](https://www.sqlalchemy.org/trac/ticket/2442)'
- en: sqlalchemy.exceptions (has been sqlalchemy.exc for years)
  id: totrans-809
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: sqlalchemy.exceptions（多年来一直是 sqlalchemy.exc）
- en: We had left in an alias `sqlalchemy.exceptions` to attempt to make it slightly
    easier for some very old libraries that hadn’t yet been upgraded to use `sqlalchemy.exc`.
    Some users are still being confused by it however so in 0.8 we’re taking it out
    entirely to eliminate any of that confusion.
  id: totrans-810
  prefs: []
  type: TYPE_NORMAL
  zh: 我们曾经在别名`sqlalchemy.exceptions`中尝试让一些非常老旧的库更容易使用`sqlalchemy.exc`。然而，一些用户仍然感到困惑，因此在0.8版本中，我们将完全删除它，以消除任何困惑。
- en: '[#2433](https://www.sqlalchemy.org/trac/ticket/2433)'
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2433](https://www.sqlalchemy.org/trac/ticket/2433)'
