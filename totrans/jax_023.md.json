["```py\nfrom jax.experimental import checkify\nimport jax\nimport jax.numpy as jnp\n\ndef f(x, i):\n  checkify.check(i >= 0, \"index needs to be non-negative, got {i}\", i=i)\n  y = x[i]\n  z = jnp.sin(y)\n  return z\n\njittable_f = checkify.checkify(f)\n\nerr, z = jax.jit(jittable_f)(jnp.ones((5,)), -2)\nprint(err.get())\n# >> index needs to be non-negative, got -2! (check failed at <...>:6 (f)) \n```", "```py\nerrors = checkify.user_checks | checkify.index_checks | checkify.float_checks\nchecked_f = checkify.checkify(f, errors=errors)\n\nerr, z = checked_f(jnp.ones((5,)), 100)\nerr.throw()\n# ValueError: out-of-bounds indexing at <..>:7 (f)\n\nerr, z = checked_f(jnp.ones((5,)), -1)\nerr.throw()\n# ValueError: index needs to be non-negative! (check failed at <â€¦>:6 (f))\n\nerr, z = checked_f(jnp.array([jnp.inf, 1]), 0)\nerr.throw()\n# ValueError: nan generated by primitive sin at <...>:8 (f)\n\nerr, z = checked_f(jnp.array([5, 1]), 0)\nerr.throw()  # if no error occurred, throw does nothing! \n```", "```py\njax.jit(f)(jnp.ones((5,)), -1)  # checkify transformation not used\n# ValueError: Cannot abstractly evaluate a checkify.check which was not functionalized. \n```", "```py\nerr, z = jax.pmap(checked_f)(jnp.ones((3, 5)), jnp.array([-1, 2, 100]))\nerr.throw()\n\"\"\"\nValueError:\n..  at mapped index 0: index needs to be non-negative! (check failed at :6 (f))\n..  at mapped index 2: out-of-bounds indexing at <..>:7 (f)\n\"\"\" \n```", "```py\ndef f(x):\n  assert x > 0., \"must be positive!\"\n  return jnp.log(x)\n\njax.grad(f)(0.)\n# ValueError: \"must be positive!\" \n```", "```py\njax.jit(f)(0.)\n# ConcretizationTypeError: \"Abstract tracer value encountered ...\" \n```", "```py\ndef f_checked(x):\n  error = x <= 0.\n  result = jnp.log(x)\n  return error, result\n\nerr, y = jax.jit(f_checked)(0.)\nif err:\n  raise ValueError(\"must be positive!\")\n# ValueError: \"must be positive!\" \n```", "```py\ndef f(x):\n  checkify.check(x > 0., \"{} must be positive!\", x)  # convenient but effectful API\n  return jnp.log(x)\n\nf_checked = checkify(f)\n\nerr, x = jax.jit(f_checked)(-1.)\nerr.throw()\n# ValueError: -1\\. must be positive! (check failed at <...>:2 (f)) \n```", "```py\njnp.arange(3)[5]                # out of bounds\njnp.sin(jnp.inf)                # NaN generated\njnp.ones((5,)) / jnp.arange(5)  # division by zero \n```", "```py\ndef f(x, i):\n  y = x[i]        # i could be out of bounds.\n  z = jnp.sin(y)  # z could become NaN\n  return z\n\nerrors = checkify.user_checks | checkify.index_checks | checkify.float_checks\nchecked_f = checkify.checkify(f, errors=errors)\n\nerr, z = checked_f(jnp.ones((5,)), 100)\nerr.throw()\n# ValueError: out-of-bounds indexing at <..>:7 (f)\n\nerr, z = checked_f(jnp.array([jnp.inf, 1]), 0)\nerr.throw()\n# ValueError: nan generated by primitive sin at <...>:8 (f) \n```", "```py\ndef f(x, i):\n  return x[i]\n\ncheckify_of_jit = checkify.checkify(jax.jit(f))\njit_of_checkify = jax.jit(checkify.checkify(f))\nerr, _ =  checkify_of_jit(jnp.ones((5,)), 100)\nerr.get()\n# out-of-bounds indexing at <..>:2 (f)\nerr, _ = jit_of_checkify(jnp.ones((5,)), 100)\n# out-of-bounds indexing at <..>:2 (f) \n```", "```py\ndef f(x, i):\n  checkify.check(i >= 0, \"index needs to be non-negative!\")\n  return x[i]\n\nchecked_f = checkify.checkify(f, errors=checkify.all_checks)\nerrs, out = jax.vmap(checked_f)(jnp.ones((3, 5)), jnp.array([-1, 2, 100]))\nerrs.throw()\n\"\"\"\nValueError:\n at mapped index 0: index needs to be non-negative! (check failed at <...>:2 (f))\n at mapped index 2: out-of-bounds indexing at <...>:3 (f)\n\"\"\" \n```", "```py\n@jax.vmap\ndef f(x, i):\n  checkify.check(i >= 0, \"index needs to be non-negative!\")\n  return x[i]\n\nchecked_f = checkify.checkify(f, errors=checkify.all_checks)\nerr, out = checked_f(jnp.ones((3, 5)), jnp.array([-1, 2, 100]))\nerr.throw()\n# ValueError: index needs to be non-negative! (check failed at <...>:2 (f)) \n```", "```py\ndef f(x):\n  return x / x\n\nf = checkify.checkify(f, errors=checkify.float_checks)\nf = pjit(\n  f,\n  in_shardings=PartitionSpec('x', None),\n  out_shardings=(None, PartitionSpec('x', None)))\n\nwith jax.sharding.Mesh(mesh.devices, mesh.axis_names):\n err, data = f(input_data)\nerr.throw()\n# ValueError: divided by zero at <...>:4 (f) \n```", "```py\ndef f(x):\n return x / (1 + jnp.sqrt(x))\n\ngrad_f = jax.grad(f)\n\nerr, _ = checkify.checkify(grad_f, errors=checkify.nan_checks)(0.)\nprint(err.get())\n>> nan generated by primitive mul at <...>:3 (f) \n```", "```py\n@jax.custom_vjp\ndef assert_gradient_negative(x):\n return x\n\ndef fwd(x):\n return assert_gradient_negative(x), None\n\ndef bwd(_, grad):\n checkify.check(grad < 0, \"gradient needs to be negative!\")\n return (grad,)\n\nassert_gradient_negative.defvjp(fwd, bwd)\n\njax.grad(assert_gradient_negative)(-1.)\n# ValueError: gradient needs to be negative! \n```"]