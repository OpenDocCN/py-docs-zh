["```py\nfunction sqlalchemy.sql.expression.except_(*selects: _SelectStatementForCompoundArgument) \u2192 CompoundSelect\n```", "```py\nfunction sqlalchemy.sql.expression.except_all(*selects: _SelectStatementForCompoundArgument) \u2192 CompoundSelect\n```", "```py\nfunction sqlalchemy.sql.expression.exists(__argument: _ColumnsClauseArgument[Any] | SelectBase | ScalarSelect[Any] | None = None) \u2192 Exists\n```", "```py\nexists_criteria = exists().where(table1.c.col1 == table2.c.col2)\n```", "```py\nexists_criteria = (\n    select(table2.c.col2).\n    where(table1.c.col1 == table2.c.col2).\n    exists()\n)\n```", "```py\nstmt = select(table1.c.col1).where(exists_criteria)\n```", "```py\nSELECT col1 FROM table1 WHERE EXISTS\n(SELECT table2.col2 FROM table2 WHERE table2.col2 = table1.col1)\n```", "```py\nfunction sqlalchemy.sql.expression.intersect(*selects: _SelectStatementForCompoundArgument) \u2192 CompoundSelect\n```", "```py\nfunction sqlalchemy.sql.expression.intersect_all(*selects: _SelectStatementForCompoundArgument) \u2192 CompoundSelect\n```", "```py\nfunction sqlalchemy.sql.expression.select(*entities: _ColumnsClauseArgument[Any], **__kw: Any) \u2192 Select[Any]\n```", "```py\nfunction sqlalchemy.sql.expression.table(name: str, *columns: ColumnClause[Any], **kw: Any) \u2192 TableClause\n```", "```py\nfunction sqlalchemy.sql.expression.union(*selects: _SelectStatementForCompoundArgument) \u2192 CompoundSelect\n```", "```py\nfunction sqlalchemy.sql.expression.union_all(*selects: _SelectStatementForCompoundArgument) \u2192 CompoundSelect\n```", "```py\nfunction sqlalchemy.sql.expression.values(*columns: ColumnClause[Any], name: str | None = None, literal_binds: bool = False) \u2192 Values\n```", "```py\nfrom sqlalchemy import column\nfrom sqlalchemy import values\n\nvalue_expr = values(\n    column('id', Integer),\n    column('name', String),\n    name=\"my_values\"\n).data(\n    [(1, 'name1'), (2, 'name2'), (3, 'name3')]\n)\n```", "```py\nfunction sqlalchemy.sql.expression.alias(selectable: FromClause, name: str | None = None, flat: bool = False) \u2192 NamedFromClause\n```", "```py\nfunction sqlalchemy.sql.expression.cte(selectable: HasCTE, name: str | None = None, recursive: bool = False) \u2192 CTE\n```", "```py\nfunction sqlalchemy.sql.expression.join(left: _FromClauseArgument, right: _FromClauseArgument, onclause: _OnClauseArgument | None = None, isouter: bool = False, full: bool = False) \u2192 Join\n```", "```py\nj = join(user_table, address_table,\n         user_table.c.id == address_table.c.user_id)\nstmt = select(user_table).select_from(j)\n```", "```py\nSELECT user.id, user.name FROM user\nJOIN address ON user.id = address.user_id\n```", "```py\nfunction sqlalchemy.sql.expression.lateral(selectable: SelectBase | _FromClauseArgument, name: str | None = None) \u2192 LateralFromClause\n```", "```py\nfunction sqlalchemy.sql.expression.outerjoin(left: _FromClauseArgument, right: _FromClauseArgument, onclause: _OnClauseArgument | None = None, full: bool = False) \u2192 Join\n```", "```py\nfunction sqlalchemy.sql.expression.tablesample(selectable: _FromClauseArgument, sampling: float | Function[Any], name: str | None = None, seed: roles.ExpressionElementRole[Any] | None = None) \u2192 TableSample\n```", "```py\nfrom sqlalchemy import func\n\nselectable = people.tablesample(\n            func.bernoulli(1),\n            name='alias',\n            seed=func.random())\nstmt = select(selectable.c.people_id)\n```", "```py\nSELECT alias.people_id FROM\npeople AS alias TABLESAMPLE bernoulli(:bernoulli_1)\nREPEATABLE (random())\n```", "```py\nclass sqlalchemy.sql.expression.Alias\n```", "```py\nattribute inherit_cache: bool | None = True\n```", "```py\nclass sqlalchemy.sql.expression.AliasedReturnsRows\n```", "```py\nattribute description\n```", "```py\nmethod is_derived_from(fromclause: FromClause | None) \u2192 bool\n```", "```py\nattribute original\n```", "```py\nclass sqlalchemy.sql.expression.CompoundSelect\n```", "```py\nmethod add_cte(*ctes: CTE, nest_here: bool = False) \u2192 Self\n```", "```py\nfrom sqlalchemy import table, column, select\nt = table('t', column('c1'), column('c2'))\n\nins = t.insert().values({\"c1\": \"x\", \"c2\": \"y\"}).cte()\n\nstmt = select(t).add_cte(ins)\n```", "```py\nWITH anon_1 AS\n(INSERT INTO t (c1, c2) VALUES (:param_1, :param_2))\nSELECT t.c1, t.c2\nFROM t\n```", "```py\nfrom sqlalchemy import table, column\nfrom sqlalchemy.dialects.postgresql import insert\n\nt = table(\"t\", column(\"c1\"), column(\"c2\"))\n\ndelete_statement_cte = (\n    t.delete().where(t.c.c1 < 1).cte(\"deletions\")\n)\n\ninsert_stmt = insert(t).values({\"c1\": 1, \"c2\": 2})\nupdate_statement = insert_stmt.on_conflict_do_update(\n    index_elements=[t.c.c1],\n    set_={\n        \"c1\": insert_stmt.excluded.c1,\n        \"c2\": insert_stmt.excluded.c2,\n    },\n).add_cte(delete_statement_cte)\n\nprint(update_statement)\n```", "```py\nWITH deletions AS\n(DELETE FROM t WHERE t.c1 < %(c1_1)s)\nINSERT INTO t (c1, c2) VALUES (%(c1)s, %(c2)s)\nON CONFLICT (c1) DO UPDATE SET c1 = excluded.c1, c2 = excluded.c2\n```", "```py\nmethod alias(name: str | None = None, flat: bool = False) \u2192 Subquery\n```", "```py\nmethod as_scalar() \u2192 ScalarSelect[Any]\n```", "```py\nattribute c\n```", "```py\nmethod corresponding_column(column: KeyedColumnElement[Any], require_embedded: bool = False) \u2192 KeyedColumnElement[Any] | None\n```", "```py\nmethod cte(name: str | None = None, recursive: bool = False, nesting: bool = False) \u2192 CTE\n```", "```py\nfrom sqlalchemy import (Table, Column, String, Integer,\n                        MetaData, select, func)\n\nmetadata = MetaData()\n\norders = Table('orders', metadata,\n    Column('region', String),\n    Column('amount', Integer),\n    Column('product', String),\n    Column('quantity', Integer)\n)\n\nregional_sales = select(\n                    orders.c.region,\n                    func.sum(orders.c.amount).label('total_sales')\n                ).group_by(orders.c.region).cte(\"regional_sales\")\n\ntop_regions = select(regional_sales.c.region).\\\n        where(\n            regional_sales.c.total_sales >\n            select(\n                func.sum(regional_sales.c.total_sales) / 10\n            )\n        ).cte(\"top_regions\")\n\nstatement = select(\n            orders.c.region,\n            orders.c.product,\n            func.sum(orders.c.quantity).label(\"product_units\"),\n            func.sum(orders.c.amount).label(\"product_sales\")\n    ).where(orders.c.region.in_(\n        select(top_regions.c.region)\n    )).group_by(orders.c.region, orders.c.product)\n\nresult = conn.execute(statement).fetchall()\n```", "```py\nfrom sqlalchemy import (Table, Column, String, Integer,\n                        MetaData, select, func)\n\nmetadata = MetaData()\n\nparts = Table('parts', metadata,\n    Column('part', String),\n    Column('sub_part', String),\n    Column('quantity', Integer),\n)\n\nincluded_parts = select(\\\n    parts.c.sub_part, parts.c.part, parts.c.quantity\\\n    ).\\\n    where(parts.c.part=='our part').\\\n    cte(recursive=True)\n\nincl_alias = included_parts.alias()\nparts_alias = parts.alias()\nincluded_parts = included_parts.union_all(\n    select(\n        parts_alias.c.sub_part,\n        parts_alias.c.part,\n        parts_alias.c.quantity\n    ).\\\n    where(parts_alias.c.part==incl_alias.c.sub_part)\n)\n\nstatement = select(\n            included_parts.c.sub_part,\n            func.sum(included_parts.c.quantity).\n              label('total_quantity')\n        ).\\\n        group_by(included_parts.c.sub_part)\n\nresult = conn.execute(statement).fetchall()\n```", "```py\nfrom datetime import date\nfrom sqlalchemy import (MetaData, Table, Column, Integer,\n                        Date, select, literal, and_, exists)\n\nmetadata = MetaData()\n\nvisitors = Table('visitors', metadata,\n    Column('product_id', Integer, primary_key=True),\n    Column('date', Date, primary_key=True),\n    Column('count', Integer),\n)\n\n# add 5 visitors for the product_id == 1\nproduct_id = 1\nday = date.today()\ncount = 5\n\nupdate_cte = (\n    visitors.update()\n    .where(and_(visitors.c.product_id == product_id,\n                visitors.c.date == day))\n    .values(count=visitors.c.count + count)\n    .returning(literal(1))\n    .cte('update_cte')\n)\n\nupsert = visitors.insert().from_select(\n    [visitors.c.product_id, visitors.c.date, visitors.c.count],\n    select(literal(product_id), literal(day), literal(count))\n        .where(~exists(update_cte.select()))\n)\n\nconnection.execute(upsert)\n```", "```py\nvalue_a = select(\n    literal(\"root\").label(\"n\")\n).cte(\"value_a\")\n\n# A nested CTE with the same name as the root one\nvalue_a_nested = select(\n    literal(\"nesting\").label(\"n\")\n).cte(\"value_a\", nesting=True)\n\n# Nesting CTEs takes ascendency locally\n# over the CTEs at a higher level\nvalue_b = select(value_a_nested.c.n).cte(\"value_b\")\n\nvalue_ab = select(value_a.c.n.label(\"a\"), value_b.c.n.label(\"b\"))\n```", "```py\nWITH\n    value_a AS\n        (SELECT 'root' AS n),\n    value_b AS\n        (WITH value_a AS\n            (SELECT 'nesting' AS n)\n        SELECT value_a.n AS n FROM value_a)\nSELECT value_a.n AS a, value_b.n AS b\nFROM value_a, value_b\n```", "```py\nvalue_a = select(\n    literal(\"root\").label(\"n\")\n).cte(\"value_a\")\n\n# A nested CTE with the same name as the root one\nvalue_a_nested = select(\n    literal(\"nesting\").label(\"n\")\n).cte(\"value_a\")\n\n# Nesting CTEs takes ascendency locally\n# over the CTEs at a higher level\nvalue_b = (\n    select(value_a_nested.c.n).\n    add_cte(value_a_nested, nest_here=True).\n    cte(\"value_b\")\n)\n\nvalue_ab = select(value_a.c.n.label(\"a\"), value_b.c.n.label(\"b\"))\n```", "```py\nedge = Table(\n    \"edge\",\n    metadata,\n    Column(\"id\", Integer, primary_key=True),\n    Column(\"left\", Integer),\n    Column(\"right\", Integer),\n)\n\nroot_node = select(literal(1).label(\"node\")).cte(\n    \"nodes\", recursive=True\n)\n\nleft_edge = select(edge.c.left).join(\n    root_node, edge.c.right == root_node.c.node\n)\nright_edge = select(edge.c.right).join(\n    root_node, edge.c.left == root_node.c.node\n)\n\nsubgraph_cte = root_node.union(left_edge, right_edge)\n\nsubgraph = select(subgraph_cte)\n```", "```py\nWITH RECURSIVE nodes(node) AS (\n        SELECT 1 AS node\n    UNION\n        SELECT edge.\"left\" AS \"left\"\n        FROM edge JOIN nodes ON edge.\"right\" = nodes.node\n    UNION\n        SELECT edge.\"right\" AS \"right\"\n        FROM edge JOIN nodes ON edge.\"left\" = nodes.node\n)\nSELECT nodes.node FROM nodes\n```", "```py\nmethod execution_options(**kw: Any) \u2192 Self\n```", "```py\nstatement = select(table.c.x, table.c.y)\nnew_statement = statement.execution_options(my_option=True)\n```", "```py\nfrom sqlalchemy import event\n\n@event.listens_for(some_engine, \"before_execute\")\ndef _process_opt(conn, statement, multiparams, params, execution_options):\n    \"run a SQL function before invoking a statement\"\n\n    if execution_options.get(\"do_special_thing\", False):\n        conn.exec_driver_sql(\"run_special_function()\")\n```", "```py\nmethod exists() \u2192 Exists\n```", "```py\nattribute exported_columns\n```", "```py\nmethod fetch(count: _LimitOffsetType, with_ties: bool = False, percent: bool = False) \u2192 Self\n```", "```py\nmethod get_execution_options() \u2192 _ExecuteOptions\n```", "```py\nmethod get_label_style() \u2192 SelectLabelStyle\n```", "```py\nmethod group_by(_GenerativeSelect__first: Literal[None, _NoArg.NO_ARG] | _ColumnExpressionOrStrLabelArgument[Any] = _NoArg.NO_ARG, *clauses: _ColumnExpressionOrStrLabelArgument[Any]) \u2192 Self\n```", "```py\nstmt = select(table.c.name, func.max(table.c.stat)).\\\ngroup_by(table.c.name)\n```", "```py\nmethod is_derived_from(fromclause: FromClause | None) \u2192 bool\n```", "```py\nmethod label(name: str | None) \u2192 Label[Any]\n```", "```py\nmethod lateral(name: str | None = None) \u2192 LateralFromClause\n```", "```py\nmethod limit(limit: _LimitOffsetType) \u2192 Self\n```", "```py\nmethod offset(offset: _LimitOffsetType) \u2192 Self\n```", "```py\nmethod options(*options: ExecutableOption) \u2192 Self\n```", "```py\nmethod order_by(_GenerativeSelect__first: Literal[None, _NoArg.NO_ARG] | _ColumnExpressionOrStrLabelArgument[Any] = _NoArg.NO_ARG, *clauses: _ColumnExpressionOrStrLabelArgument[Any]) \u2192 Self\n```", "```py\nstmt = select(table).order_by(table.c.id, table.c.name)\n```", "```py\n# will erase all ORDER BY and ORDER BY new_col alone\nstmt = stmt.order_by(None).order_by(new_col)\n```", "```py\nmethod replace_selectable(old: FromClause, alias: Alias) \u2192 Self\n```", "```py\nmethod scalar_subquery() \u2192 ScalarSelect[Any]\n```", "```py\nmethod select(*arg: Any, **kw: Any) \u2192 Select\n```", "```py\nattribute selected_columns\n```", "```py\nmethod self_group(against: OperatorType | None = None) \u2192 GroupedElement\n```", "```py\nmethod set_label_style(style: SelectLabelStyle) \u2192 CompoundSelect\n```", "```py\nmethod slice(start: int, stop: int) \u2192 Self\n```", "```py\nstmt = select(User).order_by(User).id.slice(1, 3)\n```", "```py\nSELECT  users.id  AS  users_id,\n  users.name  AS  users_name\nFROM  users  ORDER  BY  users.id\nLIMIT  ?  OFFSET  ?\n(2,  1)\n```", "```py\nmethod subquery(name: str | None = None) \u2192 Subquery\n```", "```py\nstmt = select(table.c.id, table.c.name)\n```", "```py\nSELECT table.id, table.name FROM table\n```", "```py\nsubq = stmt.subquery()\nnew_stmt = select(subq)\n```", "```py\nSELECT anon_1.id, anon_1.name\nFROM (SELECT table.id, table.name FROM table) AS anon_1\n```", "```py\nmethod with_for_update(*, nowait: bool = False, read: bool = False, of: _ForUpdateOfArgument | None = None, skip_locked: bool = False, key_share: bool = False) \u2192 Self\n```", "```py\nstmt = select(table).with_for_update(nowait=True)\n```", "```py\nSELECT table.a, table.b FROM table FOR UPDATE NOWAIT\n```", "```py\nSELECT table.a, table.b FROM table FOR UPDATE\n```", "```py\nclass sqlalchemy.sql.expression.CTE\n```", "```py\nmethod alias(name: str | None = None, flat: bool = False) \u2192 CTE\n```", "```py\nmethod union(*other: _SelectStatementForCompoundArgument) \u2192 CTE\n```", "```py\nmethod union_all(*other: _SelectStatementForCompoundArgument) \u2192 CTE\n```", "```py\nclass sqlalchemy.sql.expression.Executable\n```", "```py\nmethod execution_options(**kw: Any) \u2192 Self\n```", "```py\nstatement = select(table.c.x, table.c.y)\nnew_statement = statement.execution_options(my_option=True)\n```", "```py\nfrom sqlalchemy import event\n\n@event.listens_for(some_engine, \"before_execute\")\ndef _process_opt(conn, statement, multiparams, params, execution_options):\n    \"run a SQL function before invoking a statement\"\n\n    if execution_options.get(\"do_special_thing\", False):\n        conn.exec_driver_sql(\"run_special_function()\")\n```", "```py\nmethod get_execution_options() \u2192 _ExecuteOptions\n```", "```py\nmethod options(*options: ExecutableOption) \u2192 Self\n```", "```py\nclass sqlalchemy.sql.expression.Exists\n```", "```py\nmethod correlate(*fromclauses: Literal[None, False] | _FromClauseArgument) \u2192 Self\n```", "```py\nmethod correlate_except(*fromclauses: Literal[None, False] | _FromClauseArgument) \u2192 Self\n```", "```py\nattribute inherit_cache: bool | None = True\n```", "```py\nmethod select() \u2192 Select\n```", "```py\nstmt = exists(some_table.c.id).where(some_table.c.id == 5).select()\n```", "```py\nSELECT EXISTS (SELECT id FROM some_table WHERE some_table = :param) AS anon_1\n```", "```py\nmethod select_from(*froms: _FromClauseArgument) \u2192 Self\n```", "```py\nmethod where(*clause: _ColumnExpressionArgument[bool]) \u2192 Self\n```", "```py\nclass sqlalchemy.sql.expression.FromClause\n```", "```py\nmethod alias(name: str | None = None, flat: bool = False) \u2192 NamedFromClause\n```", "```py\na2 = some_table.alias('a2')\n```", "```py\nattribute c\n```", "```py\nattribute columns\n```", "```py\nselect(mytable).where(mytable.c.somecolumn == 5)\n```", "```py\nattribute description\n```", "```py\nattribute entity_namespace\n```", "```py\nstmt.filter_by(address='some address')\n```", "```py\nattribute exported_columns\n```", "```py\nattribute foreign_keys\n```", "```py\nmethod is_derived_from(fromclause: FromClause | None) \u2192 bool\n```", "```py\nmethod join(right: _FromClauseArgument, onclause: _ColumnExpressionArgument[bool] | None = None, isouter: bool = False, full: bool = False) \u2192 Join\n```", "```py\nfrom sqlalchemy import join\n\nj = user_table.join(address_table,\n                user_table.c.id == address_table.c.user_id)\nstmt = select(user_table).select_from(j)\n```", "```py\nSELECT user.id, user.name FROM user\nJOIN address ON user.id = address.user_id\n```", "```py\nmethod outerjoin(right: _FromClauseArgument, onclause: _ColumnExpressionArgument[bool] | None = None, full: bool = False) \u2192 Join\n```", "```py\nfrom sqlalchemy import outerjoin\n\nj = user_table.outerjoin(address_table,\n                user_table.c.id == address_table.c.user_id)\n```", "```py\nj = user_table.join(\n    address_table,\n    user_table.c.id == address_table.c.user_id,\n    isouter=True)\n```", "```py\nattribute primary_key\n```", "```py\nattribute schema: str | None = None\n```", "```py\nmethod select() \u2192 Select\n```", "```py\nstmt = some_table.select().where(some_table.c.id == 5)\n```", "```py\nmethod tablesample(sampling: float | Function[Any], name: str | None = None, seed: roles.ExpressionElementRole[Any] | None = None) \u2192 TableSample\n```", "```py\nclass sqlalchemy.sql.expression.GenerativeSelect\n```", "```py\nmethod fetch(count: _LimitOffsetType, with_ties: bool = False, percent: bool = False) \u2192 Self\n```", "```py\nmethod get_label_style() \u2192 SelectLabelStyle\n```", "```py\nmethod group_by(_GenerativeSelect__first: Literal[None, _NoArg.NO_ARG] | _ColumnExpressionOrStrLabelArgument[Any] = _NoArg.NO_ARG, *clauses: _ColumnExpressionOrStrLabelArgument[Any]) \u2192 Self\n```", "```py\nstmt = select(table.c.name, func.max(table.c.stat)).\\\ngroup_by(table.c.name)\n```", "```py\nmethod limit(limit: _LimitOffsetType) \u2192 Self\n```", "```py\nmethod offset(offset: _LimitOffsetType) \u2192 Self\n```", "```py\nmethod order_by(_GenerativeSelect__first: Literal[None, _NoArg.NO_ARG] | _ColumnExpressionOrStrLabelArgument[Any] = _NoArg.NO_ARG, *clauses: _ColumnExpressionOrStrLabelArgument[Any]) \u2192 Self\n```", "```py\nstmt = select(table).order_by(table.c.id, table.c.name)\n```", "```py\n# will erase all ORDER BY and ORDER BY new_col alone\nstmt = stmt.order_by(None).order_by(new_col)\n```", "```py\nmethod set_label_style(style: SelectLabelStyle) \u2192 Self\n```", "```py\nmethod slice(start: int, stop: int) \u2192 Self\n```", "```py\nstmt = select(User).order_by(User).id.slice(1, 3)\n```", "```py\nSELECT  users.id  AS  users_id,\n  users.name  AS  users_name\nFROM  users  ORDER  BY  users.id\nLIMIT  ?  OFFSET  ?\n(2,  1)\n```", "```py\nmethod with_for_update(*, nowait: bool = False, read: bool = False, of: _ForUpdateOfArgument | None = None, skip_locked: bool = False, key_share: bool = False) \u2192 Self\n```", "```py\nstmt = select(table).with_for_update(nowait=True)\n```", "```py\nSELECT table.a, table.b FROM table FOR UPDATE NOWAIT\n```", "```py\nSELECT table.a, table.b FROM table FOR UPDATE\n```", "```py\nclass sqlalchemy.sql.expression.HasCTE\n```", "```py\nmethod add_cte(*ctes: CTE, nest_here: bool = False) \u2192 Self\n```", "```py\nfrom sqlalchemy import table, column, select\nt = table('t', column('c1'), column('c2'))\n\nins = t.insert().values({\"c1\": \"x\", \"c2\": \"y\"}).cte()\n\nstmt = select(t).add_cte(ins)\n```", "```py\nWITH anon_1 AS\n(INSERT INTO t (c1, c2) VALUES (:param_1, :param_2))\nSELECT t.c1, t.c2\nFROM t\n```", "```py\nfrom sqlalchemy import table, column\nfrom sqlalchemy.dialects.postgresql import insert\n\nt = table(\"t\", column(\"c1\"), column(\"c2\"))\n\ndelete_statement_cte = (\n    t.delete().where(t.c.c1 < 1).cte(\"deletions\")\n)\n\ninsert_stmt = insert(t).values({\"c1\": 1, \"c2\": 2})\nupdate_statement = insert_stmt.on_conflict_do_update(\n    index_elements=[t.c.c1],\n    set_={\n        \"c1\": insert_stmt.excluded.c1,\n        \"c2\": insert_stmt.excluded.c2,\n    },\n).add_cte(delete_statement_cte)\n\nprint(update_statement)\n```", "```py\nWITH deletions AS\n(DELETE FROM t WHERE t.c1 < %(c1_1)s)\nINSERT INTO t (c1, c2) VALUES (%(c1)s, %(c2)s)\nON CONFLICT (c1) DO UPDATE SET c1 = excluded.c1, c2 = excluded.c2\n```", "```py\nmethod cte(name: str | None = None, recursive: bool = False, nesting: bool = False) \u2192 CTE\n```", "```py\nfrom sqlalchemy import (Table, Column, String, Integer,\n                        MetaData, select, func)\n\nmetadata = MetaData()\n\norders = Table('orders', metadata,\n    Column('region', String),\n    Column('amount', Integer),\n    Column('product', String),\n    Column('quantity', Integer)\n)\n\nregional_sales = select(\n                    orders.c.region,\n                    func.sum(orders.c.amount).label('total_sales')\n                ).group_by(orders.c.region).cte(\"regional_sales\")\n\ntop_regions = select(regional_sales.c.region).\\\n        where(\n            regional_sales.c.total_sales >\n            select(\n                func.sum(regional_sales.c.total_sales) / 10\n            )\n        ).cte(\"top_regions\")\n\nstatement = select(\n            orders.c.region,\n            orders.c.product,\n            func.sum(orders.c.quantity).label(\"product_units\"),\n            func.sum(orders.c.amount).label(\"product_sales\")\n    ).where(orders.c.region.in_(\n        select(top_regions.c.region)\n    )).group_by(orders.c.region, orders.c.product)\n\nresult = conn.execute(statement).fetchall()\n```", "```py\nfrom sqlalchemy import (Table, Column, String, Integer,\n                        MetaData, select, func)\n\nmetadata = MetaData()\n\nparts = Table('parts', metadata,\n    Column('part', String),\n    Column('sub_part', String),\n    Column('quantity', Integer),\n)\n\nincluded_parts = select(\\\n    parts.c.sub_part, parts.c.part, parts.c.quantity\\\n    ).\\\n    where(parts.c.part=='our part').\\\n    cte(recursive=True)\n\nincl_alias = included_parts.alias()\nparts_alias = parts.alias()\nincluded_parts = included_parts.union_all(\n    select(\n        parts_alias.c.sub_part,\n        parts_alias.c.part,\n        parts_alias.c.quantity\n    ).\\\n    where(parts_alias.c.part==incl_alias.c.sub_part)\n)\n\nstatement = select(\n            included_parts.c.sub_part,\n            func.sum(included_parts.c.quantity).\n              label('total_quantity')\n        ).\\\n        group_by(included_parts.c.sub_part)\n\nresult = conn.execute(statement).fetchall()\n```", "```py\nfrom datetime import date\nfrom sqlalchemy import (MetaData, Table, Column, Integer,\n                        Date, select, literal, and_, exists)\n\nmetadata = MetaData()\n\nvisitors = Table('visitors', metadata,\n    Column('product_id', Integer, primary_key=True),\n    Column('date', Date, primary_key=True),\n    Column('count', Integer),\n)\n\n# add 5 visitors for the product_id == 1\nproduct_id = 1\nday = date.today()\ncount = 5\n\nupdate_cte = (\n    visitors.update()\n    .where(and_(visitors.c.product_id == product_id,\n                visitors.c.date == day))\n    .values(count=visitors.c.count + count)\n    .returning(literal(1))\n    .cte('update_cte')\n)\n\nupsert = visitors.insert().from_select(\n    [visitors.c.product_id, visitors.c.date, visitors.c.count],\n    select(literal(product_id), literal(day), literal(count))\n        .where(~exists(update_cte.select()))\n)\n\nconnection.execute(upsert)\n```", "```py\nvalue_a = select(\n    literal(\"root\").label(\"n\")\n).cte(\"value_a\")\n\n# A nested CTE with the same name as the root one\nvalue_a_nested = select(\n    literal(\"nesting\").label(\"n\")\n).cte(\"value_a\", nesting=True)\n\n# Nesting CTEs takes ascendency locally\n# over the CTEs at a higher level\nvalue_b = select(value_a_nested.c.n).cte(\"value_b\")\n\nvalue_ab = select(value_a.c.n.label(\"a\"), value_b.c.n.label(\"b\"))\n```", "```py\nWITH\n    value_a AS\n        (SELECT 'root' AS n),\n    value_b AS\n        (WITH value_a AS\n            (SELECT 'nesting' AS n)\n        SELECT value_a.n AS n FROM value_a)\nSELECT value_a.n AS a, value_b.n AS b\nFROM value_a, value_b\n```", "```py\nvalue_a = select(\n    literal(\"root\").label(\"n\")\n).cte(\"value_a\")\n\n# A nested CTE with the same name as the root one\nvalue_a_nested = select(\n    literal(\"nesting\").label(\"n\")\n).cte(\"value_a\")\n\n# Nesting CTEs takes ascendency locally\n# over the CTEs at a higher level\nvalue_b = (\n    select(value_a_nested.c.n).\n    add_cte(value_a_nested, nest_here=True).\n    cte(\"value_b\")\n)\n\nvalue_ab = select(value_a.c.n.label(\"a\"), value_b.c.n.label(\"b\"))\n```", "```py\nedge = Table(\n    \"edge\",\n    metadata,\n    Column(\"id\", Integer, primary_key=True),\n    Column(\"left\", Integer),\n    Column(\"right\", Integer),\n)\n\nroot_node = select(literal(1).label(\"node\")).cte(\n    \"nodes\", recursive=True\n)\n\nleft_edge = select(edge.c.left).join(\n    root_node, edge.c.right == root_node.c.node\n)\nright_edge = select(edge.c.right).join(\n    root_node, edge.c.left == root_node.c.node\n)\n\nsubgraph_cte = root_node.union(left_edge, right_edge)\n\nsubgraph = select(subgraph_cte)\n```", "```py\nWITH RECURSIVE nodes(node) AS (\n        SELECT 1 AS node\n    UNION\n        SELECT edge.\"left\" AS \"left\"\n        FROM edge JOIN nodes ON edge.\"right\" = nodes.node\n    UNION\n        SELECT edge.\"right\" AS \"right\"\n        FROM edge JOIN nodes ON edge.\"left\" = nodes.node\n)\nSELECT nodes.node FROM nodes\n```", "```py\nclass sqlalchemy.sql.expression.HasPrefixes\n```", "```py\nmethod prefix_with(*prefixes: _TextCoercedExpressionArgument[Any], dialect: str = '*') \u2192 Self\n```", "```py\nstmt = table.insert().prefix_with(\"LOW_PRIORITY\", dialect=\"mysql\")\n\n# MySQL 5.7 optimizer hints\nstmt = select(table).prefix_with(\n    \"/*+ BKA(t1) */\", dialect=\"mysql\")\n```", "```py\nclass sqlalchemy.sql.expression.HasSuffixes\n```", "```py\nmethod suffix_with(*suffixes: _TextCoercedExpressionArgument[Any], dialect: str = '*') \u2192 Self\n```", "```py\nstmt = select(col1, col2).cte().suffix_with(\n    \"cycle empno set y_cycle to 1 default 0\", dialect=\"oracle\")\n```", "```py\nclass sqlalchemy.sql.expression.Join\n```", "```py\nmethod __init__(left: _FromClauseArgument, right: _FromClauseArgument, onclause: _OnClauseArgument | None = None, isouter: bool = False, full: bool = False)\n```", "```py\nattribute description\n```", "```py\nmethod is_derived_from(fromclause: FromClause | None) \u2192 bool\n```", "```py\nmethod select() \u2192 Select\n```", "```py\nstmt = table_a.join(table_b, table_a.c.id == table_b.c.a_id)\n\nstmt = stmt.select()\n```", "```py\nSELECT table_a.id, table_a.col, table_b.id, table_b.a_id\nFROM table_a JOIN table_b ON table_a.id = table_b.a_id\n```", "```py\nmethod self_group(against: OperatorType | None = None) \u2192 FromGrouping\n```", "```py\nclass sqlalchemy.sql.expression.Lateral\n```", "```py\nattribute inherit_cache: bool | None = True\n```", "```py\nclass sqlalchemy.sql.expression.ReturnsRows\n```", "```py\nattribute exported_columns\n```", "```py\nmethod is_derived_from(fromclause: FromClause | None) \u2192 bool\n```", "```py\nclass sqlalchemy.sql.expression.ScalarSelect\n```", "```py\nmethod correlate(*fromclauses: Literal[None, False] | _FromClauseArgument) \u2192 Self\n```", "```py\nmethod correlate_except(*fromclauses: Literal[None, False] | _FromClauseArgument) \u2192 Self\n```", "```py\nattribute inherit_cache: bool | None = True\n```", "```py\nmethod self_group(against: OperatorType | None = None) \u2192 ColumnElement[Any]\n```", "```py\nmethod where(crit: _ColumnExpressionArgument[bool]) \u2192 Self\n```", "```py\nclass sqlalchemy.sql.expression.Select\n```", "```py\nmethod __init__(*entities: _ColumnsClauseArgument[Any])\n```", "```py\nmethod add_columns(*entities: _ColumnsClauseArgument[Any]) \u2192 Select[Any]\n```", "```py\nmy_select = my_select.add_columns(table.c.new_column)\n```", "```py\nmethod add_cte(*ctes: CTE, nest_here: bool = False) \u2192 Self\n```", "```py\nfrom sqlalchemy import table, column, select\nt = table('t', column('c1'), column('c2'))\n\nins = t.insert().values({\"c1\": \"x\", \"c2\": \"y\"}).cte()\n\nstmt = select(t).add_cte(ins)\n```", "```py\nWITH anon_1 AS\n(INSERT INTO t (c1, c2) VALUES (:param_1, :param_2))\nSELECT t.c1, t.c2\nFROM t\n```", "```py\nfrom sqlalchemy import table, column\nfrom sqlalchemy.dialects.postgresql import insert\n\nt = table(\"t\", column(\"c1\"), column(\"c2\"))\n\ndelete_statement_cte = (\n    t.delete().where(t.c.c1 < 1).cte(\"deletions\")\n)\n\ninsert_stmt = insert(t).values({\"c1\": 1, \"c2\": 2})\nupdate_statement = insert_stmt.on_conflict_do_update(\n    index_elements=[t.c.c1],\n    set_={\n        \"c1\": insert_stmt.excluded.c1,\n        \"c2\": insert_stmt.excluded.c2,\n    },\n).add_cte(delete_statement_cte)\n\nprint(update_statement)\n```", "```py\nWITH deletions AS\n(DELETE FROM t WHERE t.c1 < %(c1_1)s)\nINSERT INTO t (c1, c2) VALUES (%(c1)s, %(c2)s)\nON CONFLICT (c1) DO UPDATE SET c1 = excluded.c1, c2 = excluded.c2\n```", "```py\nmethod alias(name: str | None = None, flat: bool = False) \u2192 Subquery\n```", "```py\nmethod as_scalar() \u2192 ScalarSelect[Any]\n```", "```py\nattribute c\n```", "```py\nmethod column(column: _ColumnsClauseArgument[Any]) \u2192 Select[Any]\n```", "```py\nmy_select = my_select.column(table.c.new_column)\n```", "```py\nattribute column_descriptions\n```", "```py\n>>> stmt = select(user_table)\n>>> stmt.column_descriptions\n[\n {\n 'name': 'id',\n 'type': Integer(),\n 'expr': Column('id', Integer(), ...)},\n {\n 'name': 'name',\n 'type': String(length=30),\n 'expr': Column('name', String(length=30), ...)}\n]\n```", "```py\nattribute columns_clause_froms\n```", "```py\nmethod correlate(*fromclauses: Literal[None, False] | _FromClauseArgument) \u2192 Self\n```", "```py\nmethod correlate_except(*fromclauses: Literal[None, False] | _FromClauseArgument) \u2192 Self\n```", "```py\nmethod corresponding_column(column: KeyedColumnElement[Any], require_embedded: bool = False) \u2192 KeyedColumnElement[Any] | None\n```", "```py\nmethod cte(name: str | None = None, recursive: bool = False, nesting: bool = False) \u2192 CTE\n```", "```py\nfrom sqlalchemy import (Table, Column, String, Integer,\n                        MetaData, select, func)\n\nmetadata = MetaData()\n\norders = Table('orders', metadata,\n    Column('region', String),\n    Column('amount', Integer),\n    Column('product', String),\n    Column('quantity', Integer)\n)\n\nregional_sales = select(\n                    orders.c.region,\n                    func.sum(orders.c.amount).label('total_sales')\n                ).group_by(orders.c.region).cte(\"regional_sales\")\n\ntop_regions = select(regional_sales.c.region).\\\n        where(\n            regional_sales.c.total_sales >\n            select(\n                func.sum(regional_sales.c.total_sales) / 10\n            )\n        ).cte(\"top_regions\")\n\nstatement = select(\n            orders.c.region,\n            orders.c.product,\n            func.sum(orders.c.quantity).label(\"product_units\"),\n            func.sum(orders.c.amount).label(\"product_sales\")\n    ).where(orders.c.region.in_(\n        select(top_regions.c.region)\n    )).group_by(orders.c.region, orders.c.product)\n\nresult = conn.execute(statement).fetchall()\n```", "```py\nfrom sqlalchemy import (Table, Column, String, Integer,\n                        MetaData, select, func)\n\nmetadata = MetaData()\n\nparts = Table('parts', metadata,\n    Column('part', String),\n    Column('sub_part', String),\n    Column('quantity', Integer),\n)\n\nincluded_parts = select(\\\n    parts.c.sub_part, parts.c.part, parts.c.quantity\\\n    ).\\\n    where(parts.c.part=='our part').\\\n    cte(recursive=True)\n\nincl_alias = included_parts.alias()\nparts_alias = parts.alias()\nincluded_parts = included_parts.union_all(\n    select(\n        parts_alias.c.sub_part,\n        parts_alias.c.part,\n        parts_alias.c.quantity\n    ).\\\n    where(parts_alias.c.part==incl_alias.c.sub_part)\n)\n\nstatement = select(\n            included_parts.c.sub_part,\n            func.sum(included_parts.c.quantity).\n              label('total_quantity')\n        ).\\\n        group_by(included_parts.c.sub_part)\n\nresult = conn.execute(statement).fetchall()\n```", "```py\nfrom datetime import date\nfrom sqlalchemy import (MetaData, Table, Column, Integer,\n                        Date, select, literal, and_, exists)\n\nmetadata = MetaData()\n\nvisitors = Table('visitors', metadata,\n    Column('product_id', Integer, primary_key=True),\n    Column('date', Date, primary_key=True),\n    Column('count', Integer),\n)\n\n# add 5 visitors for the product_id == 1\nproduct_id = 1\nday = date.today()\ncount = 5\n\nupdate_cte = (\n    visitors.update()\n    .where(and_(visitors.c.product_id == product_id,\n                visitors.c.date == day))\n    .values(count=visitors.c.count + count)\n    .returning(literal(1))\n    .cte('update_cte')\n)\n\nupsert = visitors.insert().from_select(\n    [visitors.c.product_id, visitors.c.date, visitors.c.count],\n    select(literal(product_id), literal(day), literal(count))\n        .where(~exists(update_cte.select()))\n)\n\nconnection.execute(upsert)\n```", "```py\nvalue_a = select(\n    literal(\"root\").label(\"n\")\n).cte(\"value_a\")\n\n# A nested CTE with the same name as the root one\nvalue_a_nested = select(\n    literal(\"nesting\").label(\"n\")\n).cte(\"value_a\", nesting=True)\n\n# Nesting CTEs takes ascendency locally\n# over the CTEs at a higher level\nvalue_b = select(value_a_nested.c.n).cte(\"value_b\")\n\nvalue_ab = select(value_a.c.n.label(\"a\"), value_b.c.n.label(\"b\"))\n```", "```py\nWITH\n    value_a AS\n        (SELECT 'root' AS n),\n    value_b AS\n        (WITH value_a AS\n            (SELECT 'nesting' AS n)\n        SELECT value_a.n AS n FROM value_a)\nSELECT value_a.n AS a, value_b.n AS b\nFROM value_a, value_b\n```", "```py\nvalue_a = select(\n    literal(\"root\").label(\"n\")\n).cte(\"value_a\")\n\n# A nested CTE with the same name as the root one\nvalue_a_nested = select(\n    literal(\"nesting\").label(\"n\")\n).cte(\"value_a\")\n\n# Nesting CTEs takes ascendency locally\n# over the CTEs at a higher level\nvalue_b = (\n    select(value_a_nested.c.n).\n    add_cte(value_a_nested, nest_here=True).\n    cte(\"value_b\")\n)\n\nvalue_ab = select(value_a.c.n.label(\"a\"), value_b.c.n.label(\"b\"))\n```", "```py\nedge = Table(\n    \"edge\",\n    metadata,\n    Column(\"id\", Integer, primary_key=True),\n    Column(\"left\", Integer),\n    Column(\"right\", Integer),\n)\n\nroot_node = select(literal(1).label(\"node\")).cte(\n    \"nodes\", recursive=True\n)\n\nleft_edge = select(edge.c.left).join(\n    root_node, edge.c.right == root_node.c.node\n)\nright_edge = select(edge.c.right).join(\n    root_node, edge.c.left == root_node.c.node\n)\n\nsubgraph_cte = root_node.union(left_edge, right_edge)\n\nsubgraph = select(subgraph_cte)\n```", "```py\nWITH RECURSIVE nodes(node) AS (\n        SELECT 1 AS node\n    UNION\n        SELECT edge.\"left\" AS \"left\"\n        FROM edge JOIN nodes ON edge.\"right\" = nodes.node\n    UNION\n        SELECT edge.\"right\" AS \"right\"\n        FROM edge JOIN nodes ON edge.\"left\" = nodes.node\n)\nSELECT nodes.node FROM nodes\n```", "```py\nmethod distinct(*expr: _ColumnExpressionArgument[Any]) \u2192 Self\n```", "```py\nfrom sqlalchemy import select\nstmt = select(users_table.c.id, users_table.c.name).distinct()\n```", "```py\nSELECT DISTINCT user.id, user.name FROM user\n```", "```py\nmethod except_(*other: _SelectStatementForCompoundArgument) \u2192 CompoundSelect\n```", "```py\nmethod except_all(*other: _SelectStatementForCompoundArgument) \u2192 CompoundSelect\n```", "```py\nmethod execution_options(**kw: Any) \u2192 Self\n```", "```py\nstatement = select(table.c.x, table.c.y)\nnew_statement = statement.execution_options(my_option=True)\n```", "```py\nfrom sqlalchemy import event\n\n@event.listens_for(some_engine, \"before_execute\")\ndef _process_opt(conn, statement, multiparams, params, execution_options):\n    \"run a SQL function before invoking a statement\"\n\n    if execution_options.get(\"do_special_thing\", False):\n        conn.exec_driver_sql(\"run_special_function()\")\n```", "```py\nmethod exists() \u2192 Exists\n```", "```py\nattribute exported_columns\n```", "```py\nmethod fetch(count: _LimitOffsetType, with_ties: bool = False, percent: bool = False) \u2192 Self\n```", "```py\nmethod filter(*criteria: _ColumnExpressionArgument[bool]) \u2192 Self\n```", "```py\nmethod filter_by(**kwargs: Any) \u2192 Self\n```", "```py\nmethod from_statement(statement: ReturnsRowsRole) \u2192 ExecutableReturnsRows\n```", "```py\nattribute froms\n```", "```py\nmethod get_children(**kw: Any) \u2192 Iterable[ClauseElement]\n```", "```py\nmethod get_execution_options() \u2192 _ExecuteOptions\n```", "```py\nmethod get_final_froms() \u2192 Sequence[FromClause]\n```", "```py\nmethod get_label_style() \u2192 SelectLabelStyle\n```", "```py\nmethod group_by(_GenerativeSelect__first: Literal[None, _NoArg.NO_ARG] | _ColumnExpressionOrStrLabelArgument[Any] = _NoArg.NO_ARG, *clauses: _ColumnExpressionOrStrLabelArgument[Any]) \u2192 Self\n```", "```py\nstmt = select(table.c.name, func.max(table.c.stat)).\\\ngroup_by(table.c.name)\n```", "```py\nmethod having(*having: _ColumnExpressionArgument[bool]) \u2192 Self\n```", "```py\nattribute inherit_cache: bool | None = None\n```", "```py\nattribute inner_columns\n```", "```py\nmethod intersect(*other: _SelectStatementForCompoundArgument) \u2192 CompoundSelect\n```", "```py\nmethod intersect_all(*other: _SelectStatementForCompoundArgument) \u2192 CompoundSelect\n```", "```py\nmethod is_derived_from(fromclause: FromClause | None) \u2192 bool\n```", "```py\nmethod join(target: _JoinTargetArgument, onclause: _OnClauseArgument | None = None, *, isouter: bool = False, full: bool = False) \u2192 Self\n```", "```py\nstmt = select(user_table).join(address_table, user_table.c.id == address_table.c.user_id)\n```", "```py\nSELECT user.id, user.name FROM user JOIN address ON user.id = address.user_id\n```", "```py\nmethod join_from(from_: _FromClauseArgument, target: _JoinTargetArgument, onclause: _OnClauseArgument | None = None, *, isouter: bool = False, full: bool = False) \u2192 Self\n```", "```py\nstmt = select(user_table, address_table).join_from(\n    user_table, address_table, user_table.c.id == address_table.c.user_id\n)\n```", "```py\nSELECT user.id, user.name, address.id, address.email, address.user_id\nFROM user JOIN address ON user.id = address.user_id\n```", "```py\nmethod label(name: str | None) \u2192 Label[Any]\n```", "```py\nmethod lateral(name: str | None = None) \u2192 LateralFromClause\n```", "```py\nmethod limit(limit: _LimitOffsetType) \u2192 Self\n```", "```py\nmethod offset(offset: _LimitOffsetType) \u2192 Self\n```", "```py\nmethod options(*options: ExecutableOption) \u2192 Self\n```", "```py\nmethod order_by(_GenerativeSelect__first: Literal[None, _NoArg.NO_ARG] | _ColumnExpressionOrStrLabelArgument[Any] = _NoArg.NO_ARG, *clauses: _ColumnExpressionOrStrLabelArgument[Any]) \u2192 Self\n```", "```py\nstmt = select(table).order_by(table.c.id, table.c.name)\n```", "```py\n# will erase all ORDER BY and ORDER BY new_col alone\nstmt = stmt.order_by(None).order_by(new_col)\n```", "```py\nmethod outerjoin(target: _JoinTargetArgument, onclause: _OnClauseArgument | None = None, *, full: bool = False) \u2192 Self\n```", "```py\nmethod outerjoin_from(from_: _FromClauseArgument, target: _JoinTargetArgument, onclause: _OnClauseArgument | None = None, *, full: bool = False) \u2192 Self\n```", "```py\nmethod prefix_with(*prefixes: _TextCoercedExpressionArgument[Any], dialect: str = '*') \u2192 Self\n```", "```py\nstmt = table.insert().prefix_with(\"LOW_PRIORITY\", dialect=\"mysql\")\n\n# MySQL 5.7 optimizer hints\nstmt = select(table).prefix_with(\n    \"/*+ BKA(t1) */\", dialect=\"mysql\")\n```", "```py\nmethod reduce_columns(only_synonyms: bool = True) \u2192 Select\n```", "```py\nmethod replace_selectable(old: FromClause, alias: Alias) \u2192 Self\n```", "```py\nmethod scalar_subquery() \u2192 ScalarSelect[Any]\n```", "```py\nmethod select(*arg: Any, **kw: Any) \u2192 Select\n```", "```py\nmethod select_from(*froms: _FromClauseArgument) \u2192 Self\n```", "```py\ntable1 = table('t1', column('a'))\ntable2 = table('t2', column('b'))\ns = select(table1.c.a).\\\n    select_from(\n        table1.join(table2, table1.c.a==table2.c.b)\n    )\n```", "```py\nselect(func.count('*')).select_from(table1)\n```", "```py\nattribute selected_columns\n```", "```py\ncol1 = column('q', Integer)\ncol2 = column('p', Integer)\nstmt = select(col1, col2)\n```", "```py\ndef filter_on_id(my_select, id):\n    return my_select.where(my_select.selected_columns['id'] == id)\n\nstmt = select(MyModel)\n\n# adds \"WHERE id=:param\" to the statement\nstmt = filter_on_id(stmt, 42)\n```", "```py\nmethod self_group(against: OperatorType | None = None) \u2192 SelectStatementGrouping | Self\n```", "```py\nmethod set_label_style(style: SelectLabelStyle) \u2192 Self\n```", "```py\nmethod slice(start: int, stop: int) \u2192 Self\n```", "```py\nstmt = select(User).order_by(User).id.slice(1, 3)\n```", "```py\nSELECT  users.id  AS  users_id,\n  users.name  AS  users_name\nFROM  users  ORDER  BY  users.id\nLIMIT  ?  OFFSET  ?\n(2,  1)\n```", "```py\nmethod subquery(name: str | None = None) \u2192 Subquery\n```", "```py\nstmt = select(table.c.id, table.c.name)\n```", "```py\nSELECT table.id, table.name FROM table\n```", "```py\nsubq = stmt.subquery()\nnew_stmt = select(subq)\n```", "```py\nSELECT anon_1.id, anon_1.name\nFROM (SELECT table.id, table.name FROM table) AS anon_1\n```", "```py\nmethod suffix_with(*suffixes: _TextCoercedExpressionArgument[Any], dialect: str = '*') \u2192 Self\n```", "```py\nstmt = select(col1, col2).cte().suffix_with(\n    \"cycle empno set y_cycle to 1 default 0\", dialect=\"oracle\")\n```", "```py\nmethod union(*other: _SelectStatementForCompoundArgument) \u2192 CompoundSelect\n```", "```py\nmethod union_all(*other: _SelectStatementForCompoundArgument) \u2192 CompoundSelect\n```", "```py\nmethod where(*whereclause: _ColumnExpressionArgument[bool]) \u2192 Self\n```", "```py\nattribute whereclause\n```", "```py\nmethod with_for_update(*, nowait: bool = False, read: bool = False, of: _ForUpdateOfArgument | None = None, skip_locked: bool = False, key_share: bool = False) \u2192 Self\n```", "```py\nstmt = select(table).with_for_update(nowait=True)\n```", "```py\nSELECT table.a, table.b FROM table FOR UPDATE NOWAIT\n```", "```py\nSELECT table.a, table.b FROM table FOR UPDATE\n```", "```py\nmethod with_hint(selectable: _FromClauseArgument, text: str, dialect_name: str = '*') \u2192 Self\n```", "```py\nselect(mytable).\\\n    with_hint(mytable, \"index(%(name)s ix_mytable)\")\n```", "```py\nselect /*+ index(mytable ix_mytable) */ ... from mytable\n```", "```py\nselect(mytable).\\\n    with_hint(mytable, \"index(%(name)s ix_mytable)\", 'oracle').\\\n    with_hint(mytable, \"WITH INDEX ix_mytable\", 'mssql')\n```", "```py\nmethod with_only_columns(*entities: _ColumnsClauseArgument[Any], maintain_column_froms: bool = False, **_Select__kw: Any) \u2192 Select[Any]\n```", "```py\ns = select(table1.c.a, table1.c.b)\ns = s.with_only_columns(table1.c.b)\n```", "```py\ns = select(table1.c.b)\n```", "```py\ns = select(table1.c.a, table2.c.b)\ns = s.with_only_columns(table1.c.a, maintain_column_froms=True)\n```", "```py\ns = select(table1.c.a, table2.c.b)\ns = s.select_from(table1, table2).with_only_columns(table1.c.a)\n```", "```py\ns = select(table1.c.a, table2.c.b)\ns = s.select_from(*s.columns_clause_froms).with_only_columns(table1.c.a)\n```", "```py\nmethod with_statement_hint(text: str, dialect_name: str = '*') \u2192 Self\n```", "```py\nclass sqlalchemy.sql.expression.Selectable\n```", "```py\nmethod corresponding_column(column: KeyedColumnElement[Any], require_embedded: bool = False) \u2192 KeyedColumnElement[Any] | None\n```", "```py\nattribute exported_columns\n```", "```py\nattribute inherit_cache: bool | None = None\n```", "```py\nmethod is_derived_from(fromclause: FromClause | None) \u2192 bool\n```", "```py\nmethod lateral(name: str | None = None) \u2192 LateralFromClause\n```", "```py\nmethod replace_selectable(old: FromClause, alias: Alias) \u2192 Self\n```", "```py\nclass sqlalchemy.sql.expression.SelectBase\n```", "```py\nmethod add_cte(*ctes: CTE, nest_here: bool = False) \u2192 Self\n```", "```py\nfrom sqlalchemy import table, column, select\nt = table('t', column('c1'), column('c2'))\n\nins = t.insert().values({\"c1\": \"x\", \"c2\": \"y\"}).cte()\n\nstmt = select(t).add_cte(ins)\n```", "```py\nWITH anon_1 AS\n(INSERT INTO t (c1, c2) VALUES (:param_1, :param_2))\nSELECT t.c1, t.c2\nFROM t\n```", "```py\nfrom sqlalchemy import table, column\nfrom sqlalchemy.dialects.postgresql import insert\n\nt = table(\"t\", column(\"c1\"), column(\"c2\"))\n\ndelete_statement_cte = (\n    t.delete().where(t.c.c1 < 1).cte(\"deletions\")\n)\n\ninsert_stmt = insert(t).values({\"c1\": 1, \"c2\": 2})\nupdate_statement = insert_stmt.on_conflict_do_update(\n    index_elements=[t.c.c1],\n    set_={\n        \"c1\": insert_stmt.excluded.c1,\n        \"c2\": insert_stmt.excluded.c2,\n    },\n).add_cte(delete_statement_cte)\n\nprint(update_statement)\n```", "```py\nWITH deletions AS\n(DELETE FROM t WHERE t.c1 < %(c1_1)s)\nINSERT INTO t (c1, c2) VALUES (%(c1)s, %(c2)s)\nON CONFLICT (c1) DO UPDATE SET c1 = excluded.c1, c2 = excluded.c2\n```", "```py\nmethod alias(name: str | None = None, flat: bool = False) \u2192 Subquery\n```", "```py\nmethod as_scalar() \u2192 ScalarSelect[Any]\n```", "```py\nattribute c\n```", "```py\nmethod corresponding_column(column: KeyedColumnElement[Any], require_embedded: bool = False) \u2192 KeyedColumnElement[Any] | None\n```", "```py\nmethod cte(name: str | None = None, recursive: bool = False, nesting: bool = False) \u2192 CTE\n```", "```py\nfrom sqlalchemy import (Table, Column, String, Integer,\n                        MetaData, select, func)\n\nmetadata = MetaData()\n\norders = Table('orders', metadata,\n    Column('region', String),\n    Column('amount', Integer),\n    Column('product', String),\n    Column('quantity', Integer)\n)\n\nregional_sales = select(\n                    orders.c.region,\n                    func.sum(orders.c.amount).label('total_sales')\n                ).group_by(orders.c.region).cte(\"regional_sales\")\n\ntop_regions = select(regional_sales.c.region).\\\n        where(\n            regional_sales.c.total_sales >\n            select(\n                func.sum(regional_sales.c.total_sales) / 10\n            )\n        ).cte(\"top_regions\")\n\nstatement = select(\n            orders.c.region,\n            orders.c.product,\n            func.sum(orders.c.quantity).label(\"product_units\"),\n            func.sum(orders.c.amount).label(\"product_sales\")\n    ).where(orders.c.region.in_(\n        select(top_regions.c.region)\n    )).group_by(orders.c.region, orders.c.product)\n\nresult = conn.execute(statement).fetchall()\n```", "```py\nfrom sqlalchemy import (Table, Column, String, Integer,\n                        MetaData, select, func)\n\nmetadata = MetaData()\n\nparts = Table('parts', metadata,\n    Column('part', String),\n    Column('sub_part', String),\n    Column('quantity', Integer),\n)\n\nincluded_parts = select(\\\n    parts.c.sub_part, parts.c.part, parts.c.quantity\\\n    ).\\\n    where(parts.c.part=='our part').\\\n    cte(recursive=True)\n\nincl_alias = included_parts.alias()\nparts_alias = parts.alias()\nincluded_parts = included_parts.union_all(\n    select(\n        parts_alias.c.sub_part,\n        parts_alias.c.part,\n        parts_alias.c.quantity\n    ).\\\n    where(parts_alias.c.part==incl_alias.c.sub_part)\n)\n\nstatement = select(\n            included_parts.c.sub_part,\n            func.sum(included_parts.c.quantity).\n              label('total_quantity')\n        ).\\\n        group_by(included_parts.c.sub_part)\n\nresult = conn.execute(statement).fetchall()\n```", "```py\nfrom datetime import date\nfrom sqlalchemy import (MetaData, Table, Column, Integer,\n                        Date, select, literal, and_, exists)\n\nmetadata = MetaData()\n\nvisitors = Table('visitors', metadata,\n    Column('product_id', Integer, primary_key=True),\n    Column('date', Date, primary_key=True),\n    Column('count', Integer),\n)\n\n# add 5 visitors for the product_id == 1\nproduct_id = 1\nday = date.today()\ncount = 5\n\nupdate_cte = (\n    visitors.update()\n    .where(and_(visitors.c.product_id == product_id,\n                visitors.c.date == day))\n    .values(count=visitors.c.count + count)\n    .returning(literal(1))\n    .cte('update_cte')\n)\n\nupsert = visitors.insert().from_select(\n    [visitors.c.product_id, visitors.c.date, visitors.c.count],\n    select(literal(product_id), literal(day), literal(count))\n        .where(~exists(update_cte.select()))\n)\n\nconnection.execute(upsert)\n```", "```py\nvalue_a = select(\n    literal(\"root\").label(\"n\")\n).cte(\"value_a\")\n\n# A nested CTE with the same name as the root one\nvalue_a_nested = select(\n    literal(\"nesting\").label(\"n\")\n).cte(\"value_a\", nesting=True)\n\n# Nesting CTEs takes ascendency locally\n# over the CTEs at a higher level\nvalue_b = select(value_a_nested.c.n).cte(\"value_b\")\n\nvalue_ab = select(value_a.c.n.label(\"a\"), value_b.c.n.label(\"b\"))\n```", "```py\nWITH\n    value_a AS\n        (SELECT 'root' AS n),\n    value_b AS\n        (WITH value_a AS\n            (SELECT 'nesting' AS n)\n        SELECT value_a.n AS n FROM value_a)\nSELECT value_a.n AS a, value_b.n AS b\nFROM value_a, value_b\n```", "```py\nvalue_a = select(\n    literal(\"root\").label(\"n\")\n).cte(\"value_a\")\n\n# A nested CTE with the same name as the root one\nvalue_a_nested = select(\n    literal(\"nesting\").label(\"n\")\n).cte(\"value_a\")\n\n# Nesting CTEs takes ascendency locally\n# over the CTEs at a higher level\nvalue_b = (\n    select(value_a_nested.c.n).\n    add_cte(value_a_nested, nest_here=True).\n    cte(\"value_b\")\n)\n\nvalue_ab = select(value_a.c.n.label(\"a\"), value_b.c.n.label(\"b\"))\n```", "```py\nedge = Table(\n    \"edge\",\n    metadata,\n    Column(\"id\", Integer, primary_key=True),\n    Column(\"left\", Integer),\n    Column(\"right\", Integer),\n)\n\nroot_node = select(literal(1).label(\"node\")).cte(\n    \"nodes\", recursive=True\n)\n\nleft_edge = select(edge.c.left).join(\n    root_node, edge.c.right == root_node.c.node\n)\nright_edge = select(edge.c.right).join(\n    root_node, edge.c.left == root_node.c.node\n)\n\nsubgraph_cte = root_node.union(left_edge, right_edge)\n\nsubgraph = select(subgraph_cte)\n```", "```py\nWITH RECURSIVE nodes(node) AS (\n        SELECT 1 AS node\n    UNION\n        SELECT edge.\"left\" AS \"left\"\n        FROM edge JOIN nodes ON edge.\"right\" = nodes.node\n    UNION\n        SELECT edge.\"right\" AS \"right\"\n        FROM edge JOIN nodes ON edge.\"left\" = nodes.node\n)\nSELECT nodes.node FROM nodes\n```", "```py\nmethod exists() \u2192 Exists\n```", "```py\nattribute exported_columns\n```", "```py\nmethod get_label_style() \u2192 SelectLabelStyle\n```", "```py\nattribute inherit_cache: bool | None = None\n```", "```py\nmethod is_derived_from(fromclause: FromClause | None) \u2192 bool\n```", "```py\nmethod label(name: str | None) \u2192 Label[Any]\n```", "```py\nmethod lateral(name: str | None = None) \u2192 LateralFromClause\n```", "```py\nmethod replace_selectable(old: FromClause, alias: Alias) \u2192 Self\n```", "```py\nmethod scalar_subquery() \u2192 ScalarSelect[Any]\n```", "```py\nmethod select(*arg: Any, **kw: Any) \u2192 Select\n```", "```py\nattribute selected_columns\n```", "```py\nmethod set_label_style(style: SelectLabelStyle) \u2192 Self\n```", "```py\nmethod subquery(name: str | None = None) \u2192 Subquery\n```", "```py\nstmt = select(table.c.id, table.c.name)\n```", "```py\nSELECT table.id, table.name FROM table\n```", "```py\nsubq = stmt.subquery()\nnew_stmt = select(subq)\n```", "```py\nSELECT anon_1.id, anon_1.name\nFROM (SELECT table.id, table.name FROM table) AS anon_1\n```", "```py\nclass sqlalchemy.sql.expression.Subquery\n```", "```py\nmethod as_scalar() \u2192 ScalarSelect[Any]\n```", "```py\nattribute inherit_cache: bool | None = True\n```", "```py\nclass sqlalchemy.sql.expression.TableClause\n```", "```py\nfrom sqlalchemy import table, column\n\nuser = table(\"user\",\n        column(\"id\"),\n        column(\"name\"),\n        column(\"description\"),\n)\n```", "```py\nmethod alias(name: str | None = None, flat: bool = False) \u2192 NamedFromClause\n```", "```py\na2 = some_table.alias('a2')\n```", "```py\nattribute c\n```", "```py\nattribute columns\n```", "```py\nselect(mytable).where(mytable.c.somecolumn == 5)\n```", "```py\nmethod compare(other: ClauseElement, **kw: Any) \u2192 bool\n```", "```py\nmethod compile(bind: _HasDialect | None = None, dialect: Dialect | None = None, **kw: Any) \u2192 Compiled\n```", "```py\n    from sqlalchemy.sql import table, column, select\n\n    t = table('t', column('x'))\n\n    s = select(t).where(t.c.x == 5)\n\n    print(s.compile(compile_kwargs={\"literal_binds\": True}))\n    ```", "```py\nmethod corresponding_column(column: KeyedColumnElement[Any], require_embedded: bool = False) \u2192 KeyedColumnElement[Any] | None\n```", "```py\nmethod delete() \u2192 Delete\n```", "```py\ntable.delete().where(table.c.id==7)\n```", "```py\nattribute description\n```", "```py\nattribute entity_namespace\n```", "```py\nstmt.filter_by(address='some address')\n```", "```py\nattribute exported_columns\n```", "```py\nattribute foreign_keys\n```", "```py\nmethod get_children(*, omit_attrs: Tuple[str, ...] = (), **kw: Any) \u2192 Iterable[HasTraverseInternals]\n```", "```py\nattribute implicit_returning = False\n```", "```py\nattribute inherit_cache: bool | None = None\n```", "```py\nmethod insert() \u2192 Insert\n```", "```py\ntable.insert().values(name='foo')\n```", "```py\nmethod is_derived_from(fromclause: FromClause | None) \u2192 bool\n```", "```py\nmethod join(right: _FromClauseArgument, onclause: _ColumnExpressionArgument[bool] | None = None, isouter: bool = False, full: bool = False) \u2192 Join\n```", "```py\nfrom sqlalchemy import join\n\nj = user_table.join(address_table,\n                user_table.c.id == address_table.c.user_id)\nstmt = select(user_table).select_from(j)\n```", "```py\nSELECT user.id, user.name FROM user\nJOIN address ON user.id = address.user_id\n```", "```py\nmethod lateral(name: str | None = None) \u2192 LateralFromClause\n```", "```py\nmethod outerjoin(right: _FromClauseArgument, onclause: _ColumnExpressionArgument[bool] | None = None, full: bool = False) \u2192 Join\n```", "```py\nfrom sqlalchemy import outerjoin\n\nj = user_table.outerjoin(address_table,\n                user_table.c.id == address_table.c.user_id)\n```", "```py\nj = user_table.join(\n    address_table,\n    user_table.c.id == address_table.c.user_id,\n    isouter=True)\n```", "```py\nmethod params(*optionaldict, **kwargs)\n```", "```py\n>>> clause = column('x') + bindparam('foo')\n>>> print(clause.compile().params)\n{'foo':None}\n>>> print(clause.params({'foo':7}).compile().params)\n{'foo':7}\n```", "```py\nattribute primary_key\n```", "```py\nmethod replace_selectable(old: FromClause, alias: Alias) \u2192 Self\n```", "```py\nattribute schema: str | None = None\n```", "```py\nmethod select() \u2192 Select\n```", "```py\nstmt = some_table.select().where(some_table.c.id == 5)\n```", "```py\nmethod self_group(against: OperatorType | None = None) \u2192 ClauseElement\n```", "```py\nmethod table_valued() \u2192 TableValuedColumn[Any]\n```", "```py\n>>> from sqlalchemy import select, column, func, table\n>>> a = table(\"a\", column(\"id\"), column(\"x\"), column(\"y\"))\n>>> stmt = select(func.row_to_json(a.table_valued()))\n>>> print(stmt)\nSELECT  row_to_json(a)  AS  row_to_json_1\nFROM  a \n```", "```py\nmethod tablesample(sampling: float | Function[Any], name: str | None = None, seed: roles.ExpressionElementRole[Any] | None = None) \u2192 TableSample\n```", "```py\nmethod unique_params(*optionaldict, **kwargs)\n```", "```py\nmethod update() \u2192 Update\n```", "```py\ntable.update().where(table.c.id==7).values(name='foo')\n```", "```py\nclass sqlalchemy.sql.expression.TableSample\n```", "```py\nclass sqlalchemy.sql.expression.TableValuedAlias\n```", "```py\n>>> from sqlalchemy import select, func\n>>> fn = func.json_array_elements_text('[\"one\", \"two\", \"three\"]').table_valued(\"value\")\n>>> print(select(fn.c.value))\nSELECT  anon_1.value\nFROM  json_array_elements_text(:json_array_elements_text_1)  AS  anon_1 \n```", "```py\nmethod alias(name: str | None = None, flat: bool = False) \u2192 TableValuedAlias\n```", "```py\nattribute column\n```", "```py\n>>> print(select(func.some_func().table_valued(\"value\").column))\nSELECT  anon_1  FROM  some_func()  AS  anon_1 \n```", "```py\nmethod lateral(name: str | None = None) \u2192 LateralFromClause\n```", "```py\nmethod render_derived(name: str | None = None, with_types: bool = False) \u2192 TableValuedAlias\n```", "```py\n>>> print(\n...     select(\n...         func.unnest(array([\"one\", \"two\", \"three\"])).\n table_valued(\"x\", with_ordinality=\"o\").render_derived()\n...     )\n... )\nSELECT  anon_1.x,  anon_1.o\nFROM  unnest(ARRAY[%(param_1)s,  %(param_2)s,  %(param_3)s])  WITH  ORDINALITY  AS  anon_1(x,  o) \n```", "```py\n>>> print(\n...     select(\n...         func.json_to_recordset(\n...             '[{\"a\":1,\"b\":\"foo\"},{\"a\":\"2\",\"c\":\"bar\"}]'\n...         )\n...         .table_valued(column(\"a\", Integer), column(\"b\", String))\n...         .render_derived(with_types=True)\n...     )\n... )\nSELECT  anon_1.a,  anon_1.b  FROM  json_to_recordset(:json_to_recordset_1)\nAS  anon_1(a  INTEGER,  b  VARCHAR) \n```", "```py\nclass sqlalchemy.sql.expression.TextualSelect\n```", "```py\nmethod add_cte(*ctes: CTE, nest_here: bool = False) \u2192 Self\n```", "```py\nfrom sqlalchemy import table, column, select\nt = table('t', column('c1'), column('c2'))\n\nins = t.insert().values({\"c1\": \"x\", \"c2\": \"y\"}).cte()\n\nstmt = select(t).add_cte(ins)\n```", "```py\nWITH anon_1 AS\n(INSERT INTO t (c1, c2) VALUES (:param_1, :param_2))\nSELECT t.c1, t.c2\nFROM t\n```", "```py\nfrom sqlalchemy import table, column\nfrom sqlalchemy.dialects.postgresql import insert\n\nt = table(\"t\", column(\"c1\"), column(\"c2\"))\n\ndelete_statement_cte = (\n    t.delete().where(t.c.c1 < 1).cte(\"deletions\")\n)\n\ninsert_stmt = insert(t).values({\"c1\": 1, \"c2\": 2})\nupdate_statement = insert_stmt.on_conflict_do_update(\n    index_elements=[t.c.c1],\n    set_={\n        \"c1\": insert_stmt.excluded.c1,\n        \"c2\": insert_stmt.excluded.c2,\n    },\n).add_cte(delete_statement_cte)\n\nprint(update_statement)\n```", "```py\nWITH deletions AS\n(DELETE FROM t WHERE t.c1 < %(c1_1)s)\nINSERT INTO t (c1, c2) VALUES (%(c1)s, %(c2)s)\nON CONFLICT (c1) DO UPDATE SET c1 = excluded.c1, c2 = excluded.c2\n```", "```py\nmethod alias(name: str | None = None, flat: bool = False) \u2192 Subquery\n```", "```py\nmethod as_scalar() \u2192 ScalarSelect[Any]\n```", "```py\nattribute c\n```", "```py\nmethod compare(other: ClauseElement, **kw: Any) \u2192 bool\n```", "```py\nmethod compile(bind: _HasDialect | None = None, dialect: Dialect | None = None, **kw: Any) \u2192 Compiled\n```", "```py\n    from sqlalchemy.sql import table, column, select\n\n    t = table('t', column('x'))\n\n    s = select(t).where(t.c.x == 5)\n\n    print(s.compile(compile_kwargs={\"literal_binds\": True}))\n    ```", "```py\nmethod corresponding_column(column: KeyedColumnElement[Any], require_embedded: bool = False) \u2192 KeyedColumnElement[Any] | None\n```", "```py\nmethod cte(name: str | None = None, recursive: bool = False, nesting: bool = False) \u2192 CTE\n```", "```py\nfrom sqlalchemy import (Table, Column, String, Integer,\n                        MetaData, select, func)\n\nmetadata = MetaData()\n\norders = Table('orders', metadata,\n    Column('region', String),\n    Column('amount', Integer),\n    Column('product', String),\n    Column('quantity', Integer)\n)\n\nregional_sales = select(\n                    orders.c.region,\n                    func.sum(orders.c.amount).label('total_sales')\n                ).group_by(orders.c.region).cte(\"regional_sales\")\n\ntop_regions = select(regional_sales.c.region).\\\n        where(\n            regional_sales.c.total_sales >\n            select(\n                func.sum(regional_sales.c.total_sales) / 10\n            )\n        ).cte(\"top_regions\")\n\nstatement = select(\n            orders.c.region,\n            orders.c.product,\n            func.sum(orders.c.quantity).label(\"product_units\"),\n            func.sum(orders.c.amount).label(\"product_sales\")\n    ).where(orders.c.region.in_(\n        select(top_regions.c.region)\n    )).group_by(orders.c.region, orders.c.product)\n\nresult = conn.execute(statement).fetchall()\n```", "```py\nfrom sqlalchemy import (Table, Column, String, Integer,\n                        MetaData, select, func)\n\nmetadata = MetaData()\n\nparts = Table('parts', metadata,\n    Column('part', String),\n    Column('sub_part', String),\n    Column('quantity', Integer),\n)\n\nincluded_parts = select(\\\n    parts.c.sub_part, parts.c.part, parts.c.quantity\\\n    ).\\\n    where(parts.c.part=='our part').\\\n    cte(recursive=True)\n\nincl_alias = included_parts.alias()\nparts_alias = parts.alias()\nincluded_parts = included_parts.union_all(\n    select(\n        parts_alias.c.sub_part,\n        parts_alias.c.part,\n        parts_alias.c.quantity\n    ).\\\n    where(parts_alias.c.part==incl_alias.c.sub_part)\n)\n\nstatement = select(\n            included_parts.c.sub_part,\n            func.sum(included_parts.c.quantity).\n              label('total_quantity')\n        ).\\\n        group_by(included_parts.c.sub_part)\n\nresult = conn.execute(statement).fetchall()\n```", "```py\nfrom datetime import date\nfrom sqlalchemy import (MetaData, Table, Column, Integer,\n                        Date, select, literal, and_, exists)\n\nmetadata = MetaData()\n\nvisitors = Table('visitors', metadata,\n    Column('product_id', Integer, primary_key=True),\n    Column('date', Date, primary_key=True),\n    Column('count', Integer),\n)\n\n# add 5 visitors for the product_id == 1\nproduct_id = 1\nday = date.today()\ncount = 5\n\nupdate_cte = (\n    visitors.update()\n    .where(and_(visitors.c.product_id == product_id,\n                visitors.c.date == day))\n    .values(count=visitors.c.count + count)\n    .returning(literal(1))\n    .cte('update_cte')\n)\n\nupsert = visitors.insert().from_select(\n    [visitors.c.product_id, visitors.c.date, visitors.c.count],\n    select(literal(product_id), literal(day), literal(count))\n        .where(~exists(update_cte.select()))\n)\n\nconnection.execute(upsert)\n```", "```py\nvalue_a = select(\n    literal(\"root\").label(\"n\")\n).cte(\"value_a\")\n\n# A nested CTE with the same name as the root one\nvalue_a_nested = select(\n    literal(\"nesting\").label(\"n\")\n).cte(\"value_a\", nesting=True)\n\n# Nesting CTEs takes ascendency locally\n# over the CTEs at a higher level\nvalue_b = select(value_a_nested.c.n).cte(\"value_b\")\n\nvalue_ab = select(value_a.c.n.label(\"a\"), value_b.c.n.label(\"b\"))\n```", "```py\nWITH\n    value_a AS\n        (SELECT 'root' AS n),\n    value_b AS\n        (WITH value_a AS\n            (SELECT 'nesting' AS n)\n        SELECT value_a.n AS n FROM value_a)\nSELECT value_a.n AS a, value_b.n AS b\nFROM value_a, value_b\n```", "```py\nvalue_a = select(\n    literal(\"root\").label(\"n\")\n).cte(\"value_a\")\n\n# A nested CTE with the same name as the root one\nvalue_a_nested = select(\n    literal(\"nesting\").label(\"n\")\n).cte(\"value_a\")\n\n# Nesting CTEs takes ascendency locally\n# over the CTEs at a higher level\nvalue_b = (\n    select(value_a_nested.c.n).\n    add_cte(value_a_nested, nest_here=True).\n    cte(\"value_b\")\n)\n\nvalue_ab = select(value_a.c.n.label(\"a\"), value_b.c.n.label(\"b\"))\n```", "```py\nedge = Table(\n    \"edge\",\n    metadata,\n    Column(\"id\", Integer, primary_key=True),\n    Column(\"left\", Integer),\n    Column(\"right\", Integer),\n)\n\nroot_node = select(literal(1).label(\"node\")).cte(\n    \"nodes\", recursive=True\n)\n\nleft_edge = select(edge.c.left).join(\n    root_node, edge.c.right == root_node.c.node\n)\nright_edge = select(edge.c.right).join(\n    root_node, edge.c.left == root_node.c.node\n)\n\nsubgraph_cte = root_node.union(left_edge, right_edge)\n\nsubgraph = select(subgraph_cte)\n```", "```py\nWITH RECURSIVE nodes(node) AS (\n        SELECT 1 AS node\n    UNION\n        SELECT edge.\"left\" AS \"left\"\n        FROM edge JOIN nodes ON edge.\"right\" = nodes.node\n    UNION\n        SELECT edge.\"right\" AS \"right\"\n        FROM edge JOIN nodes ON edge.\"left\" = nodes.node\n)\nSELECT nodes.node FROM nodes\n```", "```py\nmethod execution_options(**kw: Any) \u2192 Self\n```", "```py\nstatement = select(table.c.x, table.c.y)\nnew_statement = statement.execution_options(my_option=True)\n```", "```py\nfrom sqlalchemy import event\n\n@event.listens_for(some_engine, \"before_execute\")\ndef _process_opt(conn, statement, multiparams, params, execution_options):\n    \"run a SQL function before invoking a statement\"\n\n    if execution_options.get(\"do_special_thing\", False):\n        conn.exec_driver_sql(\"run_special_function()\")\n```", "```py\nmethod exists() \u2192 Exists\n```", "```py\nattribute exported_columns\n```", "```py\nmethod get_children(*, omit_attrs: Tuple[str, ...] = (), **kw: Any) \u2192 Iterable[HasTraverseInternals]\n```", "```py\nmethod get_execution_options() \u2192 _ExecuteOptions\n```", "```py\nmethod get_label_style() \u2192 SelectLabelStyle\n```", "```py\nattribute inherit_cache: bool | None = None\n```", "```py\nmethod is_derived_from(fromclause: FromClause | None) \u2192 bool\n```", "```py\nmethod label(name: str | None) \u2192 Label[Any]\n```", "```py\nmethod lateral(name: str | None = None) \u2192 LateralFromClause\n```", "```py\nmethod options(*options: ExecutableOption) \u2192 Self\n```", "```py\nmethod params(_ClauseElement__optionaldict: Mapping[str, Any] | None = None, **kwargs: Any) \u2192 Self\n```", "```py\n>>> clause = column('x') + bindparam('foo')\n>>> print(clause.compile().params)\n{'foo':None}\n>>> print(clause.params({'foo':7}).compile().params)\n{'foo':7}\n```", "```py\nmethod replace_selectable(old: FromClause, alias: Alias) \u2192 Self\n```", "```py\nmethod scalar_subquery() \u2192 ScalarSelect[Any]\n```", "```py\nmethod select(*arg: Any, **kw: Any) \u2192 Select\n```", "```py\nattribute selected_columns\n```", "```py\nmethod self_group(against: OperatorType | None = None) \u2192 ClauseElement\n```", "```py\nmethod set_label_style(style: SelectLabelStyle) \u2192 TextualSelect\n```", "```py\nmethod subquery(name: str | None = None) \u2192 Subquery\n```", "```py\nstmt = select(table.c.id, table.c.name)\n```", "```py\nSELECT table.id, table.name FROM table\n```", "```py\nsubq = stmt.subquery()\nnew_stmt = select(subq)\n```", "```py\nSELECT anon_1.id, anon_1.name\nFROM (SELECT table.id, table.name FROM table) AS anon_1\n```", "```py\nmethod unique_params(_ClauseElement__optionaldict: Dict[str, Any] | None = None, **kwargs: Any) \u2192 Self\n```", "```py\nclass sqlalchemy.sql.expression.Values\n```", "```py\nmethod alias(name: str | None = None, flat: bool = False) \u2192 Self\n```", "```py\nmethod data(values: Sequence[Tuple[Any, ...]]) \u2192 Self\n```", "```py\nmy_values = my_values.data([(1, 'value 1'), (2, 'value2')])\n```", "```py\nmethod lateral(name: str | None = None) \u2192 LateralFromClause\n```", "```py\nmethod scalar_values() \u2192 ScalarValues\n```", "```py\nclass sqlalchemy.sql.expression.ScalarValues\n```", "```py\nclass sqlalchemy.sql.expression.SelectLabelStyle\n```", "```py\nattribute LABEL_STYLE_DEFAULT = 2\n```", "```py\nattribute LABEL_STYLE_DISAMBIGUATE_ONLY = 2\n```", "```py\n>>> from sqlalchemy import table, column, select, true, LABEL_STYLE_DISAMBIGUATE_ONLY\n>>> table1 = table(\"table1\", column(\"columna\"), column(\"columnb\"))\n>>> table2 = table(\"table2\", column(\"columna\"), column(\"columnc\"))\n>>> print(select(table1, table2).join(table2, true()).set_label_style(LABEL_STYLE_DISAMBIGUATE_ONLY))\nSELECT  table1.columna,  table1.columnb,  table2.columna  AS  columna_1,  table2.columnc\nFROM  table1  JOIN  table2  ON  true \n```", "```py\nattribute LABEL_STYLE_NONE = 0\n```", "```py\n>>> from sqlalchemy import table, column, select, true, LABEL_STYLE_NONE\n>>> table1 = table(\"table1\", column(\"columna\"), column(\"columnb\"))\n>>> table2 = table(\"table2\", column(\"columna\"), column(\"columnc\"))\n>>> print(select(table1, table2).join(table2, true()).set_label_style(LABEL_STYLE_NONE))\nSELECT  table1.columna,  table1.columnb,  table2.columna,  table2.columnc\nFROM  table1  JOIN  table2  ON  true \n```", "```py\nattribute LABEL_STYLE_TABLENAME_PLUS_COL = 1\n```", "```py\n>>> from sqlalchemy import table, column, select, true, LABEL_STYLE_TABLENAME_PLUS_COL\n>>> table1 = table(\"table1\", column(\"columna\"), column(\"columnb\"))\n>>> table2 = table(\"table2\", column(\"columna\"), column(\"columnc\"))\n>>> print(select(table1, table2).join(table2, true()).set_label_style(LABEL_STYLE_TABLENAME_PLUS_COL))\nSELECT  table1.columna  AS  table1_columna,  table1.columnb  AS  table1_columnb,  table2.columna  AS  table2_columna,  table2.columnc  AS  table2_columnc\nFROM  table1  JOIN  table2  ON  true \n```", "```py\nfunction sqlalchemy.sql.expression.except_(*selects: _SelectStatementForCompoundArgument) \u2192 CompoundSelect\n```", "```py\nfunction sqlalchemy.sql.expression.except_all(*selects: _SelectStatementForCompoundArgument) \u2192 CompoundSelect\n```", "```py\nfunction sqlalchemy.sql.expression.exists(__argument: _ColumnsClauseArgument[Any] | SelectBase | ScalarSelect[Any] | None = None) \u2192 Exists\n```", "```py\nexists_criteria = exists().where(table1.c.col1 == table2.c.col2)\n```", "```py\nexists_criteria = (\n    select(table2.c.col2).\n    where(table1.c.col1 == table2.c.col2).\n    exists()\n)\n```", "```py\nstmt = select(table1.c.col1).where(exists_criteria)\n```", "```py\nSELECT col1 FROM table1 WHERE EXISTS\n(SELECT table2.col2 FROM table2 WHERE table2.col2 = table1.col1)\n```", "```py\nfunction sqlalchemy.sql.expression.intersect(*selects: _SelectStatementForCompoundArgument) \u2192 CompoundSelect\n```", "```py\nfunction sqlalchemy.sql.expression.intersect_all(*selects: _SelectStatementForCompoundArgument) \u2192 CompoundSelect\n```", "```py\nfunction sqlalchemy.sql.expression.select(*entities: _ColumnsClauseArgument[Any], **__kw: Any) \u2192 Select[Any]\n```", "```py\nfunction sqlalchemy.sql.expression.table(name: str, *columns: ColumnClause[Any], **kw: Any) \u2192 TableClause\n```", "```py\nfunction sqlalchemy.sql.expression.union(*selects: _SelectStatementForCompoundArgument) \u2192 CompoundSelect\n```", "```py\nfunction sqlalchemy.sql.expression.union_all(*selects: _SelectStatementForCompoundArgument) \u2192 CompoundSelect\n```", "```py\nfunction sqlalchemy.sql.expression.values(*columns: ColumnClause[Any], name: str | None = None, literal_binds: bool = False) \u2192 Values\n```", "```py\nfrom sqlalchemy import column\nfrom sqlalchemy import values\n\nvalue_expr = values(\n    column('id', Integer),\n    column('name', String),\n    name=\"my_values\"\n).data(\n    [(1, 'name1'), (2, 'name2'), (3, 'name3')]\n)\n```", "```py\nfunction sqlalchemy.sql.expression.alias(selectable: FromClause, name: str | None = None, flat: bool = False) \u2192 NamedFromClause\n```", "```py\nfunction sqlalchemy.sql.expression.cte(selectable: HasCTE, name: str | None = None, recursive: bool = False) \u2192 CTE\n```", "```py\nfunction sqlalchemy.sql.expression.join(left: _FromClauseArgument, right: _FromClauseArgument, onclause: _OnClauseArgument | None = None, isouter: bool = False, full: bool = False) \u2192 Join\n```", "```py\nj = join(user_table, address_table,\n         user_table.c.id == address_table.c.user_id)\nstmt = select(user_table).select_from(j)\n```", "```py\nSELECT user.id, user.name FROM user\nJOIN address ON user.id = address.user_id\n```", "```py\nfunction sqlalchemy.sql.expression.lateral(selectable: SelectBase | _FromClauseArgument, name: str | None = None) \u2192 LateralFromClause\n```", "```py\nfunction sqlalchemy.sql.expression.outerjoin(left: _FromClauseArgument, right: _FromClauseArgument, onclause: _OnClauseArgument | None = None, full: bool = False) \u2192 Join\n```", "```py\nfunction sqlalchemy.sql.expression.tablesample(selectable: _FromClauseArgument, sampling: float | Function[Any], name: str | None = None, seed: roles.ExpressionElementRole[Any] | None = None) \u2192 TableSample\n```", "```py\nfrom sqlalchemy import func\n\nselectable = people.tablesample(\n            func.bernoulli(1),\n            name='alias',\n            seed=func.random())\nstmt = select(selectable.c.people_id)\n```", "```py\nSELECT alias.people_id FROM\npeople AS alias TABLESAMPLE bernoulli(:bernoulli_1)\nREPEATABLE (random())\n```", "```py\nclass sqlalchemy.sql.expression.Alias\n```", "```py\nattribute inherit_cache: bool | None = True\n```", "```py\nclass sqlalchemy.sql.expression.AliasedReturnsRows\n```", "```py\nattribute description\n```", "```py\nmethod is_derived_from(fromclause: FromClause | None) \u2192 bool\n```", "```py\nattribute original\n```", "```py\nclass sqlalchemy.sql.expression.CompoundSelect\n```", "```py\nmethod add_cte(*ctes: CTE, nest_here: bool = False) \u2192 Self\n```", "```py\nfrom sqlalchemy import table, column, select\nt = table('t', column('c1'), column('c2'))\n\nins = t.insert().values({\"c1\": \"x\", \"c2\": \"y\"}).cte()\n\nstmt = select(t).add_cte(ins)\n```", "```py\nWITH anon_1 AS\n(INSERT INTO t (c1, c2) VALUES (:param_1, :param_2))\nSELECT t.c1, t.c2\nFROM t\n```", "```py\nfrom sqlalchemy import table, column\nfrom sqlalchemy.dialects.postgresql import insert\n\nt = table(\"t\", column(\"c1\"), column(\"c2\"))\n\ndelete_statement_cte = (\n    t.delete().where(t.c.c1 < 1).cte(\"deletions\")\n)\n\ninsert_stmt = insert(t).values({\"c1\": 1, \"c2\": 2})\nupdate_statement = insert_stmt.on_conflict_do_update(\n    index_elements=[t.c.c1],\n    set_={\n        \"c1\": insert_stmt.excluded.c1,\n        \"c2\": insert_stmt.excluded.c2,\n    },\n).add_cte(delete_statement_cte)\n\nprint(update_statement)\n```", "```py\nWITH deletions AS\n(DELETE FROM t WHERE t.c1 < %(c1_1)s)\nINSERT INTO t (c1, c2) VALUES (%(c1)s, %(c2)s)\nON CONFLICT (c1) DO UPDATE SET c1 = excluded.c1, c2 = excluded.c2\n```", "```py\nmethod alias(name: str | None = None, flat: bool = False) \u2192 Subquery\n```", "```py\nmethod as_scalar() \u2192 ScalarSelect[Any]\n```", "```py\nattribute c\n```", "```py\nmethod corresponding_column(column: KeyedColumnElement[Any], require_embedded: bool = False) \u2192 KeyedColumnElement[Any] | None\n```", "```py\nmethod cte(name: str | None = None, recursive: bool = False, nesting: bool = False) \u2192 CTE\n```", "```py\nfrom sqlalchemy import (Table, Column, String, Integer,\n                        MetaData, select, func)\n\nmetadata = MetaData()\n\norders = Table('orders', metadata,\n    Column('region', String),\n    Column('amount', Integer),\n    Column('product', String),\n    Column('quantity', Integer)\n)\n\nregional_sales = select(\n                    orders.c.region,\n                    func.sum(orders.c.amount).label('total_sales')\n                ).group_by(orders.c.region).cte(\"regional_sales\")\n\ntop_regions = select(regional_sales.c.region).\\\n        where(\n            regional_sales.c.total_sales >\n            select(\n                func.sum(regional_sales.c.total_sales) / 10\n            )\n        ).cte(\"top_regions\")\n\nstatement = select(\n            orders.c.region,\n            orders.c.product,\n            func.sum(orders.c.quantity).label(\"product_units\"),\n            func.sum(orders.c.amount).label(\"product_sales\")\n    ).where(orders.c.region.in_(\n        select(top_regions.c.region)\n    )).group_by(orders.c.region, orders.c.product)\n\nresult = conn.execute(statement).fetchall()\n```", "```py\nfrom sqlalchemy import (Table, Column, String, Integer,\n                        MetaData, select, func)\n\nmetadata = MetaData()\n\nparts = Table('parts', metadata,\n    Column('part', String),\n    Column('sub_part', String),\n    Column('quantity', Integer),\n)\n\nincluded_parts = select(\\\n    parts.c.sub_part, parts.c.part, parts.c.quantity\\\n    ).\\\n    where(parts.c.part=='our part').\\\n    cte(recursive=True)\n\nincl_alias = included_parts.alias()\nparts_alias = parts.alias()\nincluded_parts = included_parts.union_all(\n    select(\n        parts_alias.c.sub_part,\n        parts_alias.c.part,\n        parts_alias.c.quantity\n    ).\\\n    where(parts_alias.c.part==incl_alias.c.sub_part)\n)\n\nstatement = select(\n            included_parts.c.sub_part,\n            func.sum(included_parts.c.quantity).\n              label('total_quantity')\n        ).\\\n        group_by(included_parts.c.sub_part)\n\nresult = conn.execute(statement).fetchall()\n```", "```py\nfrom datetime import date\nfrom sqlalchemy import (MetaData, Table, Column, Integer,\n                        Date, select, literal, and_, exists)\n\nmetadata = MetaData()\n\nvisitors = Table('visitors', metadata,\n    Column('product_id', Integer, primary_key=True),\n    Column('date', Date, primary_key=True),\n    Column('count', Integer),\n)\n\n# add 5 visitors for the product_id == 1\nproduct_id = 1\nday = date.today()\ncount = 5\n\nupdate_cte = (\n    visitors.update()\n    .where(and_(visitors.c.product_id == product_id,\n                visitors.c.date == day))\n    .values(count=visitors.c.count + count)\n    .returning(literal(1))\n    .cte('update_cte')\n)\n\nupsert = visitors.insert().from_select(\n    [visitors.c.product_id, visitors.c.date, visitors.c.count],\n    select(literal(product_id), literal(day), literal(count))\n        .where(~exists(update_cte.select()))\n)\n\nconnection.execute(upsert)\n```", "```py\nvalue_a = select(\n    literal(\"root\").label(\"n\")\n).cte(\"value_a\")\n\n# A nested CTE with the same name as the root one\nvalue_a_nested = select(\n    literal(\"nesting\").label(\"n\")\n).cte(\"value_a\", nesting=True)\n\n# Nesting CTEs takes ascendency locally\n# over the CTEs at a higher level\nvalue_b = select(value_a_nested.c.n).cte(\"value_b\")\n\nvalue_ab = select(value_a.c.n.label(\"a\"), value_b.c.n.label(\"b\"))\n```", "```py\nWITH\n    value_a AS\n        (SELECT 'root' AS n),\n    value_b AS\n        (WITH value_a AS\n            (SELECT 'nesting' AS n)\n        SELECT value_a.n AS n FROM value_a)\nSELECT value_a.n AS a, value_b.n AS b\nFROM value_a, value_b\n```", "```py\nvalue_a = select(\n    literal(\"root\").label(\"n\")\n).cte(\"value_a\")\n\n# A nested CTE with the same name as the root one\nvalue_a_nested = select(\n    literal(\"nesting\").label(\"n\")\n).cte(\"value_a\")\n\n# Nesting CTEs takes ascendency locally\n# over the CTEs at a higher level\nvalue_b = (\n    select(value_a_nested.c.n).\n    add_cte(value_a_nested, nest_here=True).\n    cte(\"value_b\")\n)\n\nvalue_ab = select(value_a.c.n.label(\"a\"), value_b.c.n.label(\"b\"))\n```", "```py\nedge = Table(\n    \"edge\",\n    metadata,\n    Column(\"id\", Integer, primary_key=True),\n    Column(\"left\", Integer),\n    Column(\"right\", Integer),\n)\n\nroot_node = select(literal(1).label(\"node\")).cte(\n    \"nodes\", recursive=True\n)\n\nleft_edge = select(edge.c.left).join(\n    root_node, edge.c.right == root_node.c.node\n)\nright_edge = select(edge.c.right).join(\n    root_node, edge.c.left == root_node.c.node\n)\n\nsubgraph_cte = root_node.union(left_edge, right_edge)\n\nsubgraph = select(subgraph_cte)\n```", "```py\nWITH RECURSIVE nodes(node) AS (\n        SELECT 1 AS node\n    UNION\n        SELECT edge.\"left\" AS \"left\"\n        FROM edge JOIN nodes ON edge.\"right\" = nodes.node\n    UNION\n        SELECT edge.\"right\" AS \"right\"\n        FROM edge JOIN nodes ON edge.\"left\" = nodes.node\n)\nSELECT nodes.node FROM nodes\n```", "```py\nmethod execution_options(**kw: Any) \u2192 Self\n```", "```py\nstatement = select(table.c.x, table.c.y)\nnew_statement = statement.execution_options(my_option=True)\n```", "```py\nfrom sqlalchemy import event\n\n@event.listens_for(some_engine, \"before_execute\")\ndef _process_opt(conn, statement, multiparams, params, execution_options):\n    \"run a SQL function before invoking a statement\"\n\n    if execution_options.get(\"do_special_thing\", False):\n        conn.exec_driver_sql(\"run_special_function()\")\n```", "```py\nmethod exists() \u2192 Exists\n```", "```py\nattribute exported_columns\n```", "```py\nmethod fetch(count: _LimitOffsetType, with_ties: bool = False, percent: bool = False) \u2192 Self\n```", "```py\nmethod get_execution_options() \u2192 _ExecuteOptions\n```", "```py\nmethod get_label_style() \u2192 SelectLabelStyle\n```", "```py\nmethod group_by(_GenerativeSelect__first: Literal[None, _NoArg.NO_ARG] | _ColumnExpressionOrStrLabelArgument[Any] = _NoArg.NO_ARG, *clauses: _ColumnExpressionOrStrLabelArgument[Any]) \u2192 Self\n```", "```py\nstmt = select(table.c.name, func.max(table.c.stat)).\\\ngroup_by(table.c.name)\n```", "```py\nmethod is_derived_from(fromclause: FromClause | None) \u2192 bool\n```", "```py\nmethod label(name: str | None) \u2192 Label[Any]\n```", "```py\nmethod lateral(name: str | None = None) \u2192 LateralFromClause\n```", "```py\nmethod limit(limit: _LimitOffsetType) \u2192 Self\n```", "```py\nmethod offset(offset: _LimitOffsetType) \u2192 Self\n```", "```py\nmethod options(*options: ExecutableOption) \u2192 Self\n```", "```py\nmethod order_by(_GenerativeSelect__first: Literal[None, _NoArg.NO_ARG] | _ColumnExpressionOrStrLabelArgument[Any] = _NoArg.NO_ARG, *clauses: _ColumnExpressionOrStrLabelArgument[Any]) \u2192 Self\n```", "```py\nstmt = select(table).order_by(table.c.id, table.c.name)\n```", "```py\n# will erase all ORDER BY and ORDER BY new_col alone\nstmt = stmt.order_by(None).order_by(new_col)\n```", "```py\nmethod replace_selectable(old: FromClause, alias: Alias) \u2192 Self\n```", "```py\nmethod scalar_subquery() \u2192 ScalarSelect[Any]\n```", "```py\nmethod select(*arg: Any, **kw: Any) \u2192 Select\n```", "```py\nattribute selected_columns\n```", "```py\nmethod self_group(against: OperatorType | None = None) \u2192 GroupedElement\n```", "```py\nmethod set_label_style(style: SelectLabelStyle) \u2192 CompoundSelect\n```", "```py\nmethod slice(start: int, stop: int) \u2192 Self\n```", "```py\nstmt = select(User).order_by(User).id.slice(1, 3)\n```", "```py\nSELECT  users.id  AS  users_id,\n  users.name  AS  users_name\nFROM  users  ORDER  BY  users.id\nLIMIT  ?  OFFSET  ?\n(2,  1)\n```", "```py\nmethod subquery(name: str | None = None) \u2192 Subquery\n```", "```py\nstmt = select(table.c.id, table.c.name)\n```", "```py\nSELECT table.id, table.name FROM table\n```", "```py\nsubq = stmt.subquery()\nnew_stmt = select(subq)\n```", "```py\nSELECT anon_1.id, anon_1.name\nFROM (SELECT table.id, table.name FROM table) AS anon_1\n```", "```py\nmethod with_for_update(*, nowait: bool = False, read: bool = False, of: _ForUpdateOfArgument | None = None, skip_locked: bool = False, key_share: bool = False) \u2192 Self\n```", "```py\nstmt = select(table).with_for_update(nowait=True)\n```", "```py\nSELECT table.a, table.b FROM table FOR UPDATE NOWAIT\n```", "```py\nSELECT table.a, table.b FROM table FOR UPDATE\n```", "```py\nclass sqlalchemy.sql.expression.CTE\n```", "```py\nmethod alias(name: str | None = None, flat: bool = False) \u2192 CTE\n```", "```py\nmethod union(*other: _SelectStatementForCompoundArgument) \u2192 CTE\n```", "```py\nmethod union_all(*other: _SelectStatementForCompoundArgument) \u2192 CTE\n```", "```py\nclass sqlalchemy.sql.expression.Executable\n```", "```py\nmethod execution_options(**kw: Any) \u2192 Self\n```", "```py\nstatement = select(table.c.x, table.c.y)\nnew_statement = statement.execution_options(my_option=True)\n```", "```py\nfrom sqlalchemy import event\n\n@event.listens_for(some_engine, \"before_execute\")\ndef _process_opt(conn, statement, multiparams, params, execution_options):\n    \"run a SQL function before invoking a statement\"\n\n    if execution_options.get(\"do_special_thing\", False):\n        conn.exec_driver_sql(\"run_special_function()\")\n```", "```py\nmethod get_execution_options() \u2192 _ExecuteOptions\n```", "```py\nmethod options(*options: ExecutableOption) \u2192 Self\n```", "```py\nclass sqlalchemy.sql.expression.Exists\n```", "```py\nmethod correlate(*fromclauses: Literal[None, False] | _FromClauseArgument) \u2192 Self\n```", "```py\nmethod correlate_except(*fromclauses: Literal[None, False] | _FromClauseArgument) \u2192 Self\n```", "```py\nattribute inherit_cache: bool | None = True\n```", "```py\nmethod select() \u2192 Select\n```", "```py\nstmt = exists(some_table.c.id).where(some_table.c.id == 5).select()\n```", "```py\nSELECT EXISTS (SELECT id FROM some_table WHERE some_table = :param) AS anon_1\n```", "```py\nmethod select_from(*froms: _FromClauseArgument) \u2192 Self\n```", "```py\nmethod where(*clause: _ColumnExpressionArgument[bool]) \u2192 Self\n```", "```py\nclass sqlalchemy.sql.expression.FromClause\n```", "```py\nmethod alias(name: str | None = None, flat: bool = False) \u2192 NamedFromClause\n```", "```py\na2 = some_table.alias('a2')\n```", "```py\nattribute c\n```", "```py\nattribute columns\n```", "```py\nselect(mytable).where(mytable.c.somecolumn == 5)\n```", "```py\nattribute description\n```", "```py\nattribute entity_namespace\n```", "```py\nstmt.filter_by(address='some address')\n```", "```py\nattribute exported_columns\n```", "```py\nattribute foreign_keys\n```", "```py\nmethod is_derived_from(fromclause: FromClause | None) \u2192 bool\n```", "```py\nmethod join(right: _FromClauseArgument, onclause: _ColumnExpressionArgument[bool] | None = None, isouter: bool = False, full: bool = False) \u2192 Join\n```", "```py\nfrom sqlalchemy import join\n\nj = user_table.join(address_table,\n                user_table.c.id == address_table.c.user_id)\nstmt = select(user_table).select_from(j)\n```", "```py\nSELECT user.id, user.name FROM user\nJOIN address ON user.id = address.user_id\n```", "```py\nmethod outerjoin(right: _FromClauseArgument, onclause: _ColumnExpressionArgument[bool] | None = None, full: bool = False) \u2192 Join\n```", "```py\nfrom sqlalchemy import outerjoin\n\nj = user_table.outerjoin(address_table,\n                user_table.c.id == address_table.c.user_id)\n```", "```py\nj = user_table.join(\n    address_table,\n    user_table.c.id == address_table.c.user_id,\n    isouter=True)\n```", "```py\nattribute primary_key\n```", "```py\nattribute schema: str | None = None\n```", "```py\nmethod select() \u2192 Select\n```", "```py\nstmt = some_table.select().where(some_table.c.id == 5)\n```", "```py\nmethod tablesample(sampling: float | Function[Any], name: str | None = None, seed: roles.ExpressionElementRole[Any] | None = None) \u2192 TableSample\n```", "```py\nclass sqlalchemy.sql.expression.GenerativeSelect\n```", "```py\nmethod fetch(count: _LimitOffsetType, with_ties: bool = False, percent: bool = False) \u2192 Self\n```", "```py\nmethod get_label_style() \u2192 SelectLabelStyle\n```", "```py\nmethod group_by(_GenerativeSelect__first: Literal[None, _NoArg.NO_ARG] | _ColumnExpressionOrStrLabelArgument[Any] = _NoArg.NO_ARG, *clauses: _ColumnExpressionOrStrLabelArgument[Any]) \u2192 Self\n```", "```py\nstmt = select(table.c.name, func.max(table.c.stat)).\\\ngroup_by(table.c.name)\n```", "```py\nmethod limit(limit: _LimitOffsetType) \u2192 Self\n```", "```py\nmethod offset(offset: _LimitOffsetType) \u2192 Self\n```", "```py\nmethod order_by(_GenerativeSelect__first: Literal[None, _NoArg.NO_ARG] | _ColumnExpressionOrStrLabelArgument[Any] = _NoArg.NO_ARG, *clauses: _ColumnExpressionOrStrLabelArgument[Any]) \u2192 Self\n```", "```py\nstmt = select(table).order_by(table.c.id, table.c.name)\n```", "```py\n# will erase all ORDER BY and ORDER BY new_col alone\nstmt = stmt.order_by(None).order_by(new_col)\n```", "```py\nmethod set_label_style(style: SelectLabelStyle) \u2192 Self\n```", "```py\nmethod slice(start: int, stop: int) \u2192 Self\n```", "```py\nstmt = select(User).order_by(User).id.slice(1, 3)\n```", "```py\nSELECT  users.id  AS  users_id,\n  users.name  AS  users_name\nFROM  users  ORDER  BY  users.id\nLIMIT  ?  OFFSET  ?\n(2,  1)\n```", "```py\nmethod with_for_update(*, nowait: bool = False, read: bool = False, of: _ForUpdateOfArgument | None = None, skip_locked: bool = False, key_share: bool = False) \u2192 Self\n```", "```py\nstmt = select(table).with_for_update(nowait=True)\n```", "```py\nSELECT table.a, table.b FROM table FOR UPDATE NOWAIT\n```", "```py\nSELECT table.a, table.b FROM table FOR UPDATE\n```", "```py\nclass sqlalchemy.sql.expression.HasCTE\n```", "```py\nmethod add_cte(*ctes: CTE, nest_here: bool = False) \u2192 Self\n```", "```py\nfrom sqlalchemy import table, column, select\nt = table('t', column('c1'), column('c2'))\n\nins = t.insert().values({\"c1\": \"x\", \"c2\": \"y\"}).cte()\n\nstmt = select(t).add_cte(ins)\n```", "```py\nWITH anon_1 AS\n(INSERT INTO t (c1, c2) VALUES (:param_1, :param_2))\nSELECT t.c1, t.c2\nFROM t\n```", "```py\nfrom sqlalchemy import table, column\nfrom sqlalchemy.dialects.postgresql import insert\n\nt = table(\"t\", column(\"c1\"), column(\"c2\"))\n\ndelete_statement_cte = (\n    t.delete().where(t.c.c1 < 1).cte(\"deletions\")\n)\n\ninsert_stmt = insert(t).values({\"c1\": 1, \"c2\": 2})\nupdate_statement = insert_stmt.on_conflict_do_update(\n    index_elements=[t.c.c1],\n    set_={\n        \"c1\": insert_stmt.excluded.c1,\n        \"c2\": insert_stmt.excluded.c2,\n    },\n).add_cte(delete_statement_cte)\n\nprint(update_statement)\n```", "```py\nWITH deletions AS\n(DELETE FROM t WHERE t.c1 < %(c1_1)s)\nINSERT INTO t (c1, c2) VALUES (%(c1)s, %(c2)s)\nON CONFLICT (c1) DO UPDATE SET c1 = excluded.c1, c2 = excluded.c2\n```", "```py\nmethod cte(name: str | None = None, recursive: bool = False, nesting: bool = False) \u2192 CTE\n```", "```py\nfrom sqlalchemy import (Table, Column, String, Integer,\n                        MetaData, select, func)\n\nmetadata = MetaData()\n\norders = Table('orders', metadata,\n    Column('region', String),\n    Column('amount', Integer),\n    Column('product', String),\n    Column('quantity', Integer)\n)\n\nregional_sales = select(\n                    orders.c.region,\n                    func.sum(orders.c.amount).label('total_sales')\n                ).group_by(orders.c.region).cte(\"regional_sales\")\n\ntop_regions = select(regional_sales.c.region).\\\n        where(\n            regional_sales.c.total_sales >\n            select(\n                func.sum(regional_sales.c.total_sales) / 10\n            )\n        ).cte(\"top_regions\")\n\nstatement = select(\n            orders.c.region,\n            orders.c.product,\n            func.sum(orders.c.quantity).label(\"product_units\"),\n            func.sum(orders.c.amount).label(\"product_sales\")\n    ).where(orders.c.region.in_(\n        select(top_regions.c.region)\n    )).group_by(orders.c.region, orders.c.product)\n\nresult = conn.execute(statement).fetchall()\n```", "```py\nfrom sqlalchemy import (Table, Column, String, Integer,\n                        MetaData, select, func)\n\nmetadata = MetaData()\n\nparts = Table('parts', metadata,\n    Column('part', String),\n    Column('sub_part', String),\n    Column('quantity', Integer),\n)\n\nincluded_parts = select(\\\n    parts.c.sub_part, parts.c.part, parts.c.quantity\\\n    ).\\\n    where(parts.c.part=='our part').\\\n    cte(recursive=True)\n\nincl_alias = included_parts.alias()\nparts_alias = parts.alias()\nincluded_parts = included_parts.union_all(\n    select(\n        parts_alias.c.sub_part,\n        parts_alias.c.part,\n        parts_alias.c.quantity\n    ).\\\n    where(parts_alias.c.part==incl_alias.c.sub_part)\n)\n\nstatement = select(\n            included_parts.c.sub_part,\n            func.sum(included_parts.c.quantity).\n              label('total_quantity')\n        ).\\\n        group_by(included_parts.c.sub_part)\n\nresult = conn.execute(statement).fetchall()\n```", "```py\nfrom datetime import date\nfrom sqlalchemy import (MetaData, Table, Column, Integer,\n                        Date, select, literal, and_, exists)\n\nmetadata = MetaData()\n\nvisitors = Table('visitors', metadata,\n    Column('product_id', Integer, primary_key=True),\n    Column('date', Date, primary_key=True),\n    Column('count', Integer),\n)\n\n# add 5 visitors for the product_id == 1\nproduct_id = 1\nday = date.today()\ncount = 5\n\nupdate_cte = (\n    visitors.update()\n    .where(and_(visitors.c.product_id == product_id,\n                visitors.c.date == day))\n    .values(count=visitors.c.count + count)\n    .returning(literal(1))\n    .cte('update_cte')\n)\n\nupsert = visitors.insert().from_select(\n    [visitors.c.product_id, visitors.c.date, visitors.c.count],\n    select(literal(product_id), literal(day), literal(count))\n        .where(~exists(update_cte.select()))\n)\n\nconnection.execute(upsert)\n```", "```py\nvalue_a = select(\n    literal(\"root\").label(\"n\")\n).cte(\"value_a\")\n\n# A nested CTE with the same name as the root one\nvalue_a_nested = select(\n    literal(\"nesting\").label(\"n\")\n).cte(\"value_a\", nesting=True)\n\n# Nesting CTEs takes ascendency locally\n# over the CTEs at a higher level\nvalue_b = select(value_a_nested.c.n).cte(\"value_b\")\n\nvalue_ab = select(value_a.c.n.label(\"a\"), value_b.c.n.label(\"b\"))\n```", "```py\nWITH\n    value_a AS\n        (SELECT 'root' AS n),\n    value_b AS\n        (WITH value_a AS\n            (SELECT 'nesting' AS n)\n        SELECT value_a.n AS n FROM value_a)\nSELECT value_a.n AS a, value_b.n AS b\nFROM value_a, value_b\n```", "```py\nvalue_a = select(\n    literal(\"root\").label(\"n\")\n).cte(\"value_a\")\n\n# A nested CTE with the same name as the root one\nvalue_a_nested = select(\n    literal(\"nesting\").label(\"n\")\n).cte(\"value_a\")\n\n# Nesting CTEs takes ascendency locally\n# over the CTEs at a higher level\nvalue_b = (\n    select(value_a_nested.c.n).\n    add_cte(value_a_nested, nest_here=True).\n    cte(\"value_b\")\n)\n\nvalue_ab = select(value_a.c.n.label(\"a\"), value_b.c.n.label(\"b\"))\n```", "```py\nedge = Table(\n    \"edge\",\n    metadata,\n    Column(\"id\", Integer, primary_key=True),\n    Column(\"left\", Integer),\n    Column(\"right\", Integer),\n)\n\nroot_node = select(literal(1).label(\"node\")).cte(\n    \"nodes\", recursive=True\n)\n\nleft_edge = select(edge.c.left).join(\n    root_node, edge.c.right == root_node.c.node\n)\nright_edge = select(edge.c.right).join(\n    root_node, edge.c.left == root_node.c.node\n)\n\nsubgraph_cte = root_node.union(left_edge, right_edge)\n\nsubgraph = select(subgraph_cte)\n```", "```py\nWITH RECURSIVE nodes(node) AS (\n        SELECT 1 AS node\n    UNION\n        SELECT edge.\"left\" AS \"left\"\n        FROM edge JOIN nodes ON edge.\"right\" = nodes.node\n    UNION\n        SELECT edge.\"right\" AS \"right\"\n        FROM edge JOIN nodes ON edge.\"left\" = nodes.node\n)\nSELECT nodes.node FROM nodes\n```", "```py\nclass sqlalchemy.sql.expression.HasPrefixes\n```", "```py\nmethod prefix_with(*prefixes: _TextCoercedExpressionArgument[Any], dialect: str = '*') \u2192 Self\n```", "```py\nstmt = table.insert().prefix_with(\"LOW_PRIORITY\", dialect=\"mysql\")\n\n# MySQL 5.7 optimizer hints\nstmt = select(table).prefix_with(\n    \"/*+ BKA(t1) */\", dialect=\"mysql\")\n```", "```py\nclass sqlalchemy.sql.expression.HasSuffixes\n```", "```py\nmethod suffix_with(*suffixes: _TextCoercedExpressionArgument[Any], dialect: str = '*') \u2192 Self\n```", "```py\nstmt = select(col1, col2).cte().suffix_with(\n    \"cycle empno set y_cycle to 1 default 0\", dialect=\"oracle\")\n```", "```py\nclass sqlalchemy.sql.expression.Join\n```", "```py\nmethod __init__(left: _FromClauseArgument, right: _FromClauseArgument, onclause: _OnClauseArgument | None = None, isouter: bool = False, full: bool = False)\n```", "```py\nattribute description\n```", "```py\nmethod is_derived_from(fromclause: FromClause | None) \u2192 bool\n```", "```py\nmethod select() \u2192 Select\n```", "```py\nstmt = table_a.join(table_b, table_a.c.id == table_b.c.a_id)\n\nstmt = stmt.select()\n```", "```py\nSELECT table_a.id, table_a.col, table_b.id, table_b.a_id\nFROM table_a JOIN table_b ON table_a.id = table_b.a_id\n```", "```py\nmethod self_group(against: OperatorType | None = None) \u2192 FromGrouping\n```", "```py\nclass sqlalchemy.sql.expression.Lateral\n```", "```py\nattribute inherit_cache: bool | None = True\n```", "```py\nclass sqlalchemy.sql.expression.ReturnsRows\n```", "```py\nattribute exported_columns\n```", "```py\nmethod is_derived_from(fromclause: FromClause | None) \u2192 bool\n```", "```py\nclass sqlalchemy.sql.expression.ScalarSelect\n```", "```py\nmethod correlate(*fromclauses: Literal[None, False] | _FromClauseArgument) \u2192 Self\n```", "```py\nmethod correlate_except(*fromclauses: Literal[None, False] | _FromClauseArgument) \u2192 Self\n```", "```py\nattribute inherit_cache: bool | None = True\n```", "```py\nmethod self_group(against: OperatorType | None = None) \u2192 ColumnElement[Any]\n```", "```py\nmethod where(crit: _ColumnExpressionArgument[bool]) \u2192 Self\n```", "```py\nclass sqlalchemy.sql.expression.Select\n```", "```py\nmethod __init__(*entities: _ColumnsClauseArgument[Any])\n```", "```py\nmethod add_columns(*entities: _ColumnsClauseArgument[Any]) \u2192 Select[Any]\n```", "```py\nmy_select = my_select.add_columns(table.c.new_column)\n```", "```py\nmethod add_cte(*ctes: CTE, nest_here: bool = False) \u2192 Self\n```", "```py\nfrom sqlalchemy import table, column, select\nt = table('t', column('c1'), column('c2'))\n\nins = t.insert().values({\"c1\": \"x\", \"c2\": \"y\"}).cte()\n\nstmt = select(t).add_cte(ins)\n```", "```py\nWITH anon_1 AS\n(INSERT INTO t (c1, c2) VALUES (:param_1, :param_2))\nSELECT t.c1, t.c2\nFROM t\n```", "```py\nfrom sqlalchemy import table, column\nfrom sqlalchemy.dialects.postgresql import insert\n\nt = table(\"t\", column(\"c1\"), column(\"c2\"))\n\ndelete_statement_cte = (\n    t.delete().where(t.c.c1 < 1).cte(\"deletions\")\n)\n\ninsert_stmt = insert(t).values({\"c1\": 1, \"c2\": 2})\nupdate_statement = insert_stmt.on_conflict_do_update(\n    index_elements=[t.c.c1],\n    set_={\n        \"c1\": insert_stmt.excluded.c1,\n        \"c2\": insert_stmt.excluded.c2,\n    },\n).add_cte(delete_statement_cte)\n\nprint(update_statement)\n```", "```py\nWITH deletions AS\n(DELETE FROM t WHERE t.c1 < %(c1_1)s)\nINSERT INTO t (c1, c2) VALUES (%(c1)s, %(c2)s)\nON CONFLICT (c1) DO UPDATE SET c1 = excluded.c1, c2 = excluded.c2\n```", "```py\nmethod alias(name: str | None = None, flat: bool = False) \u2192 Subquery\n```", "```py\nmethod as_scalar() \u2192 ScalarSelect[Any]\n```", "```py\nattribute c\n```", "```py\nmethod column(column: _ColumnsClauseArgument[Any]) \u2192 Select[Any]\n```", "```py\nmy_select = my_select.column(table.c.new_column)\n```", "```py\nattribute column_descriptions\n```", "```py\n>>> stmt = select(user_table)\n>>> stmt.column_descriptions\n[\n {\n 'name': 'id',\n 'type': Integer(),\n 'expr': Column('id', Integer(), ...)},\n {\n 'name': 'name',\n 'type': String(length=30),\n 'expr': Column('name', String(length=30), ...)}\n]\n```", "```py\nattribute columns_clause_froms\n```", "```py\nmethod correlate(*fromclauses: Literal[None, False] | _FromClauseArgument) \u2192 Self\n```", "```py\nmethod correlate_except(*fromclauses: Literal[None, False] | _FromClauseArgument) \u2192 Self\n```", "```py\nmethod corresponding_column(column: KeyedColumnElement[Any], require_embedded: bool = False) \u2192 KeyedColumnElement[Any] | None\n```", "```py\nmethod cte(name: str | None = None, recursive: bool = False, nesting: bool = False) \u2192 CTE\n```", "```py\nfrom sqlalchemy import (Table, Column, String, Integer,\n                        MetaData, select, func)\n\nmetadata = MetaData()\n\norders = Table('orders', metadata,\n    Column('region', String),\n    Column('amount', Integer),\n    Column('product', String),\n    Column('quantity', Integer)\n)\n\nregional_sales = select(\n                    orders.c.region,\n                    func.sum(orders.c.amount).label('total_sales')\n                ).group_by(orders.c.region).cte(\"regional_sales\")\n\ntop_regions = select(regional_sales.c.region).\\\n        where(\n            regional_sales.c.total_sales >\n            select(\n                func.sum(regional_sales.c.total_sales) / 10\n            )\n        ).cte(\"top_regions\")\n\nstatement = select(\n            orders.c.region,\n            orders.c.product,\n            func.sum(orders.c.quantity).label(\"product_units\"),\n            func.sum(orders.c.amount).label(\"product_sales\")\n    ).where(orders.c.region.in_(\n        select(top_regions.c.region)\n    )).group_by(orders.c.region, orders.c.product)\n\nresult = conn.execute(statement).fetchall()\n```", "```py\nfrom sqlalchemy import (Table, Column, String, Integer,\n                        MetaData, select, func)\n\nmetadata = MetaData()\n\nparts = Table('parts', metadata,\n    Column('part', String),\n    Column('sub_part', String),\n    Column('quantity', Integer),\n)\n\nincluded_parts = select(\\\n    parts.c.sub_part, parts.c.part, parts.c.quantity\\\n    ).\\\n    where(parts.c.part=='our part').\\\n    cte(recursive=True)\n\nincl_alias = included_parts.alias()\nparts_alias = parts.alias()\nincluded_parts = included_parts.union_all(\n    select(\n        parts_alias.c.sub_part,\n        parts_alias.c.part,\n        parts_alias.c.quantity\n    ).\\\n    where(parts_alias.c.part==incl_alias.c.sub_part)\n)\n\nstatement = select(\n            included_parts.c.sub_part,\n            func.sum(included_parts.c.quantity).\n              label('total_quantity')\n        ).\\\n        group_by(included_parts.c.sub_part)\n\nresult = conn.execute(statement).fetchall()\n```", "```py\nfrom datetime import date\nfrom sqlalchemy import (MetaData, Table, Column, Integer,\n                        Date, select, literal, and_, exists)\n\nmetadata = MetaData()\n\nvisitors = Table('visitors', metadata,\n    Column('product_id', Integer, primary_key=True),\n    Column('date', Date, primary_key=True),\n    Column('count', Integer),\n)\n\n# add 5 visitors for the product_id == 1\nproduct_id = 1\nday = date.today()\ncount = 5\n\nupdate_cte = (\n    visitors.update()\n    .where(and_(visitors.c.product_id == product_id,\n                visitors.c.date == day))\n    .values(count=visitors.c.count + count)\n    .returning(literal(1))\n    .cte('update_cte')\n)\n\nupsert = visitors.insert().from_select(\n    [visitors.c.product_id, visitors.c.date, visitors.c.count],\n    select(literal(product_id), literal(day), literal(count))\n        .where(~exists(update_cte.select()))\n)\n\nconnection.execute(upsert)\n```", "```py\nvalue_a = select(\n    literal(\"root\").label(\"n\")\n).cte(\"value_a\")\n\n# A nested CTE with the same name as the root one\nvalue_a_nested = select(\n    literal(\"nesting\").label(\"n\")\n).cte(\"value_a\", nesting=True)\n\n# Nesting CTEs takes ascendency locally\n# over the CTEs at a higher level\nvalue_b = select(value_a_nested.c.n).cte(\"value_b\")\n\nvalue_ab = select(value_a.c.n.label(\"a\"), value_b.c.n.label(\"b\"))\n```", "```py\nWITH\n    value_a AS\n        (SELECT 'root' AS n),\n    value_b AS\n        (WITH value_a AS\n            (SELECT 'nesting' AS n)\n        SELECT value_a.n AS n FROM value_a)\nSELECT value_a.n AS a, value_b.n AS b\nFROM value_a, value_b\n```", "```py\nvalue_a = select(\n    literal(\"root\").label(\"n\")\n).cte(\"value_a\")\n\n# A nested CTE with the same name as the root one\nvalue_a_nested = select(\n    literal(\"nesting\").label(\"n\")\n).cte(\"value_a\")\n\n# Nesting CTEs takes ascendency locally\n# over the CTEs at a higher level\nvalue_b = (\n    select(value_a_nested.c.n).\n    add_cte(value_a_nested, nest_here=True).\n    cte(\"value_b\")\n)\n\nvalue_ab = select(value_a.c.n.label(\"a\"), value_b.c.n.label(\"b\"))\n```", "```py\nedge = Table(\n    \"edge\",\n    metadata,\n    Column(\"id\", Integer, primary_key=True),\n    Column(\"left\", Integer),\n    Column(\"right\", Integer),\n)\n\nroot_node = select(literal(1).label(\"node\")).cte(\n    \"nodes\", recursive=True\n)\n\nleft_edge = select(edge.c.left).join(\n    root_node, edge.c.right == root_node.c.node\n)\nright_edge = select(edge.c.right).join(\n    root_node, edge.c.left == root_node.c.node\n)\n\nsubgraph_cte = root_node.union(left_edge, right_edge)\n\nsubgraph = select(subgraph_cte)\n```", "```py\nWITH RECURSIVE nodes(node) AS (\n        SELECT 1 AS node\n    UNION\n        SELECT edge.\"left\" AS \"left\"\n        FROM edge JOIN nodes ON edge.\"right\" = nodes.node\n    UNION\n        SELECT edge.\"right\" AS \"right\"\n        FROM edge JOIN nodes ON edge.\"left\" = nodes.node\n)\nSELECT nodes.node FROM nodes\n```", "```py\nmethod distinct(*expr: _ColumnExpressionArgument[Any]) \u2192 Self\n```", "```py\nfrom sqlalchemy import select\nstmt = select(users_table.c.id, users_table.c.name).distinct()\n```", "```py\nSELECT DISTINCT user.id, user.name FROM user\n```", "```py\nmethod except_(*other: _SelectStatementForCompoundArgument) \u2192 CompoundSelect\n```", "```py\nmethod except_all(*other: _SelectStatementForCompoundArgument) \u2192 CompoundSelect\n```", "```py\nmethod execution_options(**kw: Any) \u2192 Self\n```", "```py\nstatement = select(table.c.x, table.c.y)\nnew_statement = statement.execution_options(my_option=True)\n```", "```py\nfrom sqlalchemy import event\n\n@event.listens_for(some_engine, \"before_execute\")\ndef _process_opt(conn, statement, multiparams, params, execution_options):\n    \"run a SQL function before invoking a statement\"\n\n    if execution_options.get(\"do_special_thing\", False):\n        conn.exec_driver_sql(\"run_special_function()\")\n```", "```py\nmethod exists() \u2192 Exists\n```", "```py\nattribute exported_columns\n```", "```py\nmethod fetch(count: _LimitOffsetType, with_ties: bool = False, percent: bool = False) \u2192 Self\n```", "```py\nmethod filter(*criteria: _ColumnExpressionArgument[bool]) \u2192 Self\n```", "```py\nmethod filter_by(**kwargs: Any) \u2192 Self\n```", "```py\nmethod from_statement(statement: ReturnsRowsRole) \u2192 ExecutableReturnsRows\n```", "```py\nattribute froms\n```", "```py\nmethod get_children(**kw: Any) \u2192 Iterable[ClauseElement]\n```", "```py\nmethod get_execution_options() \u2192 _ExecuteOptions\n```", "```py\nmethod get_final_froms() \u2192 Sequence[FromClause]\n```", "```py\nmethod get_label_style() \u2192 SelectLabelStyle\n```", "```py\nmethod group_by(_GenerativeSelect__first: Literal[None, _NoArg.NO_ARG] | _ColumnExpressionOrStrLabelArgument[Any] = _NoArg.NO_ARG, *clauses: _ColumnExpressionOrStrLabelArgument[Any]) \u2192 Self\n```", "```py\nstmt = select(table.c.name, func.max(table.c.stat)).\\\ngroup_by(table.c.name)\n```", "```py\nmethod having(*having: _ColumnExpressionArgument[bool]) \u2192 Self\n```", "```py\nattribute inherit_cache: bool | None = None\n```", "```py\nattribute inner_columns\n```", "```py\nmethod intersect(*other: _SelectStatementForCompoundArgument) \u2192 CompoundSelect\n```", "```py\nmethod intersect_all(*other: _SelectStatementForCompoundArgument) \u2192 CompoundSelect\n```", "```py\nmethod is_derived_from(fromclause: FromClause | None) \u2192 bool\n```", "```py\nmethod join(target: _JoinTargetArgument, onclause: _OnClauseArgument | None = None, *, isouter: bool = False, full: bool = False) \u2192 Self\n```", "```py\nstmt = select(user_table).join(address_table, user_table.c.id == address_table.c.user_id)\n```", "```py\nSELECT user.id, user.name FROM user JOIN address ON user.id = address.user_id\n```", "```py\nmethod join_from(from_: _FromClauseArgument, target: _JoinTargetArgument, onclause: _OnClauseArgument | None = None, *, isouter: bool = False, full: bool = False) \u2192 Self\n```", "```py\nstmt = select(user_table, address_table).join_from(\n    user_table, address_table, user_table.c.id == address_table.c.user_id\n)\n```", "```py\nSELECT user.id, user.name, address.id, address.email, address.user_id\nFROM user JOIN address ON user.id = address.user_id\n```", "```py\nmethod label(name: str | None) \u2192 Label[Any]\n```", "```py\nmethod lateral(name: str | None = None) \u2192 LateralFromClause\n```", "```py\nmethod limit(limit: _LimitOffsetType) \u2192 Self\n```", "```py\nmethod offset(offset: _LimitOffsetType) \u2192 Self\n```", "```py\nmethod options(*options: ExecutableOption) \u2192 Self\n```", "```py\nmethod order_by(_GenerativeSelect__first: Literal[None, _NoArg.NO_ARG] | _ColumnExpressionOrStrLabelArgument[Any] = _NoArg.NO_ARG, *clauses: _ColumnExpressionOrStrLabelArgument[Any]) \u2192 Self\n```", "```py\nstmt = select(table).order_by(table.c.id, table.c.name)\n```", "```py\n# will erase all ORDER BY and ORDER BY new_col alone\nstmt = stmt.order_by(None).order_by(new_col)\n```", "```py\nmethod outerjoin(target: _JoinTargetArgument, onclause: _OnClauseArgument | None = None, *, full: bool = False) \u2192 Self\n```", "```py\nmethod outerjoin_from(from_: _FromClauseArgument, target: _JoinTargetArgument, onclause: _OnClauseArgument | None = None, *, full: bool = False) \u2192 Self\n```", "```py\nmethod prefix_with(*prefixes: _TextCoercedExpressionArgument[Any], dialect: str = '*') \u2192 Self\n```", "```py\nstmt = table.insert().prefix_with(\"LOW_PRIORITY\", dialect=\"mysql\")\n\n# MySQL 5.7 optimizer hints\nstmt = select(table).prefix_with(\n    \"/*+ BKA(t1) */\", dialect=\"mysql\")\n```", "```py\nmethod reduce_columns(only_synonyms: bool = True) \u2192 Select\n```", "```py\nmethod replace_selectable(old: FromClause, alias: Alias) \u2192 Self\n```", "```py\nmethod scalar_subquery() \u2192 ScalarSelect[Any]\n```", "```py\nmethod select(*arg: Any, **kw: Any) \u2192 Select\n```", "```py\nmethod select_from(*froms: _FromClauseArgument) \u2192 Self\n```", "```py\ntable1 = table('t1', column('a'))\ntable2 = table('t2', column('b'))\ns = select(table1.c.a).\\\n    select_from(\n        table1.join(table2, table1.c.a==table2.c.b)\n    )\n```", "```py\nselect(func.count('*')).select_from(table1)\n```", "```py\nattribute selected_columns\n```", "```py\ncol1 = column('q', Integer)\ncol2 = column('p', Integer)\nstmt = select(col1, col2)\n```", "```py\ndef filter_on_id(my_select, id):\n    return my_select.where(my_select.selected_columns['id'] == id)\n\nstmt = select(MyModel)\n\n# adds \"WHERE id=:param\" to the statement\nstmt = filter_on_id(stmt, 42)\n```", "```py\nmethod self_group(against: OperatorType | None = None) \u2192 SelectStatementGrouping | Self\n```", "```py\nmethod set_label_style(style: SelectLabelStyle) \u2192 Self\n```", "```py\nmethod slice(start: int, stop: int) \u2192 Self\n```", "```py\nstmt = select(User).order_by(User).id.slice(1, 3)\n```", "```py\nSELECT  users.id  AS  users_id,\n  users.name  AS  users_name\nFROM  users  ORDER  BY  users.id\nLIMIT  ?  OFFSET  ?\n(2,  1)\n```", "```py\nmethod subquery(name: str | None = None) \u2192 Subquery\n```", "```py\nstmt = select(table.c.id, table.c.name)\n```", "```py\nSELECT table.id, table.name FROM table\n```", "```py\nsubq = stmt.subquery()\nnew_stmt = select(subq)\n```", "```py\nSELECT anon_1.id, anon_1.name\nFROM (SELECT table.id, table.name FROM table) AS anon_1\n```", "```py\nmethod suffix_with(*suffixes: _TextCoercedExpressionArgument[Any], dialect: str = '*') \u2192 Self\n```", "```py\nstmt = select(col1, col2).cte().suffix_with(\n    \"cycle empno set y_cycle to 1 default 0\", dialect=\"oracle\")\n```", "```py\nmethod union(*other: _SelectStatementForCompoundArgument) \u2192 CompoundSelect\n```", "```py\nmethod union_all(*other: _SelectStatementForCompoundArgument) \u2192 CompoundSelect\n```", "```py\nmethod where(*whereclause: _ColumnExpressionArgument[bool]) \u2192 Self\n```", "```py\nattribute whereclause\n```", "```py\nmethod with_for_update(*, nowait: bool = False, read: bool = False, of: _ForUpdateOfArgument | None = None, skip_locked: bool = False, key_share: bool = False) \u2192 Self\n```", "```py\nstmt = select(table).with_for_update(nowait=True)\n```", "```py\nSELECT table.a, table.b FROM table FOR UPDATE NOWAIT\n```", "```py\nSELECT table.a, table.b FROM table FOR UPDATE\n```", "```py\nmethod with_hint(selectable: _FromClauseArgument, text: str, dialect_name: str = '*') \u2192 Self\n```", "```py\nselect(mytable).\\\n    with_hint(mytable, \"index(%(name)s ix_mytable)\")\n```", "```py\nselect /*+ index(mytable ix_mytable) */ ... from mytable\n```", "```py\nselect(mytable).\\\n    with_hint(mytable, \"index(%(name)s ix_mytable)\", 'oracle').\\\n    with_hint(mytable, \"WITH INDEX ix_mytable\", 'mssql')\n```", "```py\nmethod with_only_columns(*entities: _ColumnsClauseArgument[Any], maintain_column_froms: bool = False, **_Select__kw: Any) \u2192 Select[Any]\n```", "```py\ns = select(table1.c.a, table1.c.b)\ns = s.with_only_columns(table1.c.b)\n```", "```py\ns = select(table1.c.b)\n```", "```py\ns = select(table1.c.a, table2.c.b)\ns = s.with_only_columns(table1.c.a, maintain_column_froms=True)\n```", "```py\ns = select(table1.c.a, table2.c.b)\ns = s.select_from(table1, table2).with_only_columns(table1.c.a)\n```", "```py\ns = select(table1.c.a, table2.c.b)\ns = s.select_from(*s.columns_clause_froms).with_only_columns(table1.c.a)\n```", "```py\nmethod with_statement_hint(text: str, dialect_name: str = '*') \u2192 Self\n```", "```py\nclass sqlalchemy.sql.expression.Selectable\n```", "```py\nmethod corresponding_column(column: KeyedColumnElement[Any], require_embedded: bool = False) \u2192 KeyedColumnElement[Any] | None\n```", "```py\nattribute exported_columns\n```", "```py\nattribute inherit_cache: bool | None = None\n```", "```py\nmethod is_derived_from(fromclause: FromClause | None) \u2192 bool\n```", "```py\nmethod lateral(name: str | None = None) \u2192 LateralFromClause\n```", "```py\nmethod replace_selectable(old: FromClause, alias: Alias) \u2192 Self\n```", "```py\nclass sqlalchemy.sql.expression.SelectBase\n```", "```py\nmethod add_cte(*ctes: CTE, nest_here: bool = False) \u2192 Self\n```", "```py\nfrom sqlalchemy import table, column, select\nt = table('t', column('c1'), column('c2'))\n\nins = t.insert().values({\"c1\": \"x\", \"c2\": \"y\"}).cte()\n\nstmt = select(t).add_cte(ins)\n```", "```py\nWITH anon_1 AS\n(INSERT INTO t (c1, c2) VALUES (:param_1, :param_2))\nSELECT t.c1, t.c2\nFROM t\n```", "```py\nfrom sqlalchemy import table, column\nfrom sqlalchemy.dialects.postgresql import insert\n\nt = table(\"t\", column(\"c1\"), column(\"c2\"))\n\ndelete_statement_cte = (\n    t.delete().where(t.c.c1 < 1).cte(\"deletions\")\n)\n\ninsert_stmt = insert(t).values({\"c1\": 1, \"c2\": 2})\nupdate_statement = insert_stmt.on_conflict_do_update(\n    index_elements=[t.c.c1],\n    set_={\n        \"c1\": insert_stmt.excluded.c1,\n        \"c2\": insert_stmt.excluded.c2,\n    },\n).add_cte(delete_statement_cte)\n\nprint(update_statement)\n```", "```py\nWITH deletions AS\n(DELETE FROM t WHERE t.c1 < %(c1_1)s)\nINSERT INTO t (c1, c2) VALUES (%(c1)s, %(c2)s)\nON CONFLICT (c1) DO UPDATE SET c1 = excluded.c1, c2 = excluded.c2\n```", "```py\nmethod alias(name: str | None = None, flat: bool = False) \u2192 Subquery\n```", "```py\nmethod as_scalar() \u2192 ScalarSelect[Any]\n```", "```py\nattribute c\n```", "```py\nmethod corresponding_column(column: KeyedColumnElement[Any], require_embedded: bool = False) \u2192 KeyedColumnElement[Any] | None\n```", "```py\nmethod cte(name: str | None = None, recursive: bool = False, nesting: bool = False) \u2192 CTE\n```", "```py\nfrom sqlalchemy import (Table, Column, String, Integer,\n                        MetaData, select, func)\n\nmetadata = MetaData()\n\norders = Table('orders', metadata,\n    Column('region', String),\n    Column('amount', Integer),\n    Column('product', String),\n    Column('quantity', Integer)\n)\n\nregional_sales = select(\n                    orders.c.region,\n                    func.sum(orders.c.amount).label('total_sales')\n                ).group_by(orders.c.region).cte(\"regional_sales\")\n\ntop_regions = select(regional_sales.c.region).\\\n        where(\n            regional_sales.c.total_sales >\n            select(\n                func.sum(regional_sales.c.total_sales) / 10\n            )\n        ).cte(\"top_regions\")\n\nstatement = select(\n            orders.c.region,\n            orders.c.product,\n            func.sum(orders.c.quantity).label(\"product_units\"),\n            func.sum(orders.c.amount).label(\"product_sales\")\n    ).where(orders.c.region.in_(\n        select(top_regions.c.region)\n    )).group_by(orders.c.region, orders.c.product)\n\nresult = conn.execute(statement).fetchall()\n```", "```py\nfrom sqlalchemy import (Table, Column, String, Integer,\n                        MetaData, select, func)\n\nmetadata = MetaData()\n\nparts = Table('parts', metadata,\n    Column('part', String),\n    Column('sub_part', String),\n    Column('quantity', Integer),\n)\n\nincluded_parts = select(\\\n    parts.c.sub_part, parts.c.part, parts.c.quantity\\\n    ).\\\n    where(parts.c.part=='our part').\\\n    cte(recursive=True)\n\nincl_alias = included_parts.alias()\nparts_alias = parts.alias()\nincluded_parts = included_parts.union_all(\n    select(\n        parts_alias.c.sub_part,\n        parts_alias.c.part,\n        parts_alias.c.quantity\n    ).\\\n    where(parts_alias.c.part==incl_alias.c.sub_part)\n)\n\nstatement = select(\n            included_parts.c.sub_part,\n            func.sum(included_parts.c.quantity).\n              label('total_quantity')\n        ).\\\n        group_by(included_parts.c.sub_part)\n\nresult = conn.execute(statement).fetchall()\n```", "```py\nfrom datetime import date\nfrom sqlalchemy import (MetaData, Table, Column, Integer,\n                        Date, select, literal, and_, exists)\n\nmetadata = MetaData()\n\nvisitors = Table('visitors', metadata,\n    Column('product_id', Integer, primary_key=True),\n    Column('date', Date, primary_key=True),\n    Column('count', Integer),\n)\n\n# add 5 visitors for the product_id == 1\nproduct_id = 1\nday = date.today()\ncount = 5\n\nupdate_cte = (\n    visitors.update()\n    .where(and_(visitors.c.product_id == product_id,\n                visitors.c.date == day))\n    .values(count=visitors.c.count + count)\n    .returning(literal(1))\n    .cte('update_cte')\n)\n\nupsert = visitors.insert().from_select(\n    [visitors.c.product_id, visitors.c.date, visitors.c.count],\n    select(literal(product_id), literal(day), literal(count))\n        .where(~exists(update_cte.select()))\n)\n\nconnection.execute(upsert)\n```", "```py\nvalue_a = select(\n    literal(\"root\").label(\"n\")\n).cte(\"value_a\")\n\n# A nested CTE with the same name as the root one\nvalue_a_nested = select(\n    literal(\"nesting\").label(\"n\")\n).cte(\"value_a\", nesting=True)\n\n# Nesting CTEs takes ascendency locally\n# over the CTEs at a higher level\nvalue_b = select(value_a_nested.c.n).cte(\"value_b\")\n\nvalue_ab = select(value_a.c.n.label(\"a\"), value_b.c.n.label(\"b\"))\n```", "```py\nWITH\n    value_a AS\n        (SELECT 'root' AS n),\n    value_b AS\n        (WITH value_a AS\n            (SELECT 'nesting' AS n)\n        SELECT value_a.n AS n FROM value_a)\nSELECT value_a.n AS a, value_b.n AS b\nFROM value_a, value_b\n```", "```py\nvalue_a = select(\n    literal(\"root\").label(\"n\")\n).cte(\"value_a\")\n\n# A nested CTE with the same name as the root one\nvalue_a_nested = select(\n    literal(\"nesting\").label(\"n\")\n).cte(\"value_a\")\n\n# Nesting CTEs takes ascendency locally\n# over the CTEs at a higher level\nvalue_b = (\n    select(value_a_nested.c.n).\n    add_cte(value_a_nested, nest_here=True).\n    cte(\"value_b\")\n)\n\nvalue_ab = select(value_a.c.n.label(\"a\"), value_b.c.n.label(\"b\"))\n```", "```py\nedge = Table(\n    \"edge\",\n    metadata,\n    Column(\"id\", Integer, primary_key=True),\n    Column(\"left\", Integer),\n    Column(\"right\", Integer),\n)\n\nroot_node = select(literal(1).label(\"node\")).cte(\n    \"nodes\", recursive=True\n)\n\nleft_edge = select(edge.c.left).join(\n    root_node, edge.c.right == root_node.c.node\n)\nright_edge = select(edge.c.right).join(\n    root_node, edge.c.left == root_node.c.node\n)\n\nsubgraph_cte = root_node.union(left_edge, right_edge)\n\nsubgraph = select(subgraph_cte)\n```", "```py\nWITH RECURSIVE nodes(node) AS (\n        SELECT 1 AS node\n    UNION\n        SELECT edge.\"left\" AS \"left\"\n        FROM edge JOIN nodes ON edge.\"right\" = nodes.node\n    UNION\n        SELECT edge.\"right\" AS \"right\"\n        FROM edge JOIN nodes ON edge.\"left\" = nodes.node\n)\nSELECT nodes.node FROM nodes\n```", "```py\nmethod exists() \u2192 Exists\n```", "```py\nattribute exported_columns\n```", "```py\nmethod get_label_style() \u2192 SelectLabelStyle\n```", "```py\nattribute inherit_cache: bool | None = None\n```", "```py\nmethod is_derived_from(fromclause: FromClause | None) \u2192 bool\n```", "```py\nmethod label(name: str | None) \u2192 Label[Any]\n```", "```py\nmethod lateral(name: str | None = None) \u2192 LateralFromClause\n```", "```py\nmethod replace_selectable(old: FromClause, alias: Alias) \u2192 Self\n```", "```py\nmethod scalar_subquery() \u2192 ScalarSelect[Any]\n```", "```py\nmethod select(*arg: Any, **kw: Any) \u2192 Select\n```", "```py\nattribute selected_columns\n```", "```py\nmethod set_label_style(style: SelectLabelStyle) \u2192 Self\n```", "```py\nmethod subquery(name: str | None = None) \u2192 Subquery\n```", "```py\nstmt = select(table.c.id, table.c.name)\n```", "```py\nSELECT table.id, table.name FROM table\n```", "```py\nsubq = stmt.subquery()\nnew_stmt = select(subq)\n```", "```py\nSELECT anon_1.id, anon_1.name\nFROM (SELECT table.id, table.name FROM table) AS anon_1\n```", "```py\nclass sqlalchemy.sql.expression.Subquery\n```", "```py\nmethod as_scalar() \u2192 ScalarSelect[Any]\n```", "```py\nattribute inherit_cache: bool | None = True\n```", "```py\nclass sqlalchemy.sql.expression.TableClause\n```", "```py\nfrom sqlalchemy import table, column\n\nuser = table(\"user\",\n        column(\"id\"),\n        column(\"name\"),\n        column(\"description\"),\n)\n```", "```py\nmethod alias(name: str | None = None, flat: bool = False) \u2192 NamedFromClause\n```", "```py\na2 = some_table.alias('a2')\n```", "```py\nattribute c\n```", "```py\nattribute columns\n```", "```py\nselect(mytable).where(mytable.c.somecolumn == 5)\n```", "```py\nmethod compare(other: ClauseElement, **kw: Any) \u2192 bool\n```", "```py\nmethod compile(bind: _HasDialect | None = None, dialect: Dialect | None = None, **kw: Any) \u2192 Compiled\n```", "```py\n    from sqlalchemy.sql import table, column, select\n\n    t = table('t', column('x'))\n\n    s = select(t).where(t.c.x == 5)\n\n    print(s.compile(compile_kwargs={\"literal_binds\": True}))\n    ```", "```py\nmethod corresponding_column(column: KeyedColumnElement[Any], require_embedded: bool = False) \u2192 KeyedColumnElement[Any] | None\n```", "```py\nmethod delete() \u2192 Delete\n```", "```py\ntable.delete().where(table.c.id==7)\n```", "```py\nattribute description\n```", "```py\nattribute entity_namespace\n```", "```py\nstmt.filter_by(address='some address')\n```", "```py\nattribute exported_columns\n```", "```py\nattribute foreign_keys\n```", "```py\nmethod get_children(*, omit_attrs: Tuple[str, ...] = (), **kw: Any) \u2192 Iterable[HasTraverseInternals]\n```", "```py\nattribute implicit_returning = False\n```", "```py\nattribute inherit_cache: bool | None = None\n```", "```py\nmethod insert() \u2192 Insert\n```", "```py\ntable.insert().values(name='foo')\n```", "```py\nmethod is_derived_from(fromclause: FromClause | None) \u2192 bool\n```", "```py\nmethod join(right: _FromClauseArgument, onclause: _ColumnExpressionArgument[bool] | None = None, isouter: bool = False, full: bool = False) \u2192 Join\n```", "```py\nfrom sqlalchemy import join\n\nj = user_table.join(address_table,\n                user_table.c.id == address_table.c.user_id)\nstmt = select(user_table).select_from(j)\n```", "```py\nSELECT user.id, user.name FROM user\nJOIN address ON user.id = address.user_id\n```", "```py\nmethod lateral(name: str | None = None) \u2192 LateralFromClause\n```", "```py\nmethod outerjoin(right: _FromClauseArgument, onclause: _ColumnExpressionArgument[bool] | None = None, full: bool = False) \u2192 Join\n```", "```py\nfrom sqlalchemy import outerjoin\n\nj = user_table.outerjoin(address_table,\n                user_table.c.id == address_table.c.user_id)\n```", "```py\nj = user_table.join(\n    address_table,\n    user_table.c.id == address_table.c.user_id,\n    isouter=True)\n```", "```py\nmethod params(*optionaldict, **kwargs)\n```", "```py\n>>> clause = column('x') + bindparam('foo')\n>>> print(clause.compile().params)\n{'foo':None}\n>>> print(clause.params({'foo':7}).compile().params)\n{'foo':7}\n```", "```py\nattribute primary_key\n```", "```py\nmethod replace_selectable(old: FromClause, alias: Alias) \u2192 Self\n```", "```py\nattribute schema: str | None = None\n```", "```py\nmethod select() \u2192 Select\n```", "```py\nstmt = some_table.select().where(some_table.c.id == 5)\n```", "```py\nmethod self_group(against: OperatorType | None = None) \u2192 ClauseElement\n```", "```py\nmethod table_valued() \u2192 TableValuedColumn[Any]\n```", "```py\n>>> from sqlalchemy import select, column, func, table\n>>> a = table(\"a\", column(\"id\"), column(\"x\"), column(\"y\"))\n>>> stmt = select(func.row_to_json(a.table_valued()))\n>>> print(stmt)\nSELECT  row_to_json(a)  AS  row_to_json_1\nFROM  a \n```", "```py\nmethod tablesample(sampling: float | Function[Any], name: str | None = None, seed: roles.ExpressionElementRole[Any] | None = None) \u2192 TableSample\n```", "```py\nmethod unique_params(*optionaldict, **kwargs)\n```", "```py\nmethod update() \u2192 Update\n```", "```py\ntable.update().where(table.c.id==7).values(name='foo')\n```", "```py\nclass sqlalchemy.sql.expression.TableSample\n```", "```py\nclass sqlalchemy.sql.expression.TableValuedAlias\n```", "```py\n>>> from sqlalchemy import select, func\n>>> fn = func.json_array_elements_text('[\"one\", \"two\", \"three\"]').table_valued(\"value\")\n>>> print(select(fn.c.value))\nSELECT  anon_1.value\nFROM  json_array_elements_text(:json_array_elements_text_1)  AS  anon_1 \n```", "```py\nmethod alias(name: str | None = None, flat: bool = False) \u2192 TableValuedAlias\n```", "```py\nattribute column\n```", "```py\n>>> print(select(func.some_func().table_valued(\"value\").column))\nSELECT  anon_1  FROM  some_func()  AS  anon_1 \n```", "```py\nmethod lateral(name: str | None = None) \u2192 LateralFromClause\n```", "```py\nmethod render_derived(name: str | None = None, with_types: bool = False) \u2192 TableValuedAlias\n```", "```py\n>>> print(\n...     select(\n...         func.unnest(array([\"one\", \"two\", \"three\"])).\n table_valued(\"x\", with_ordinality=\"o\").render_derived()\n...     )\n... )\nSELECT  anon_1.x,  anon_1.o\nFROM  unnest(ARRAY[%(param_1)s,  %(param_2)s,  %(param_3)s])  WITH  ORDINALITY  AS  anon_1(x,  o) \n```", "```py\n>>> print(\n...     select(\n...         func.json_to_recordset(\n...             '[{\"a\":1,\"b\":\"foo\"},{\"a\":\"2\",\"c\":\"bar\"}]'\n...         )\n...         .table_valued(column(\"a\", Integer), column(\"b\", String))\n...         .render_derived(with_types=True)\n...     )\n... )\nSELECT  anon_1.a,  anon_1.b  FROM  json_to_recordset(:json_to_recordset_1)\nAS  anon_1(a  INTEGER,  b  VARCHAR) \n```", "```py\nclass sqlalchemy.sql.expression.TextualSelect\n```", "```py\nmethod add_cte(*ctes: CTE, nest_here: bool = False) \u2192 Self\n```", "```py\nfrom sqlalchemy import table, column, select\nt = table('t', column('c1'), column('c2'))\n\nins = t.insert().values({\"c1\": \"x\", \"c2\": \"y\"}).cte()\n\nstmt = select(t).add_cte(ins)\n```", "```py\nWITH anon_1 AS\n(INSERT INTO t (c1, c2) VALUES (:param_1, :param_2))\nSELECT t.c1, t.c2\nFROM t\n```", "```py\nfrom sqlalchemy import table, column\nfrom sqlalchemy.dialects.postgresql import insert\n\nt = table(\"t\", column(\"c1\"), column(\"c2\"))\n\ndelete_statement_cte = (\n    t.delete().where(t.c.c1 < 1).cte(\"deletions\")\n)\n\ninsert_stmt = insert(t).values({\"c1\": 1, \"c2\": 2})\nupdate_statement = insert_stmt.on_conflict_do_update(\n    index_elements=[t.c.c1],\n    set_={\n        \"c1\": insert_stmt.excluded.c1,\n        \"c2\": insert_stmt.excluded.c2,\n    },\n).add_cte(delete_statement_cte)\n\nprint(update_statement)\n```", "```py\nWITH deletions AS\n(DELETE FROM t WHERE t.c1 < %(c1_1)s)\nINSERT INTO t (c1, c2) VALUES (%(c1)s, %(c2)s)\nON CONFLICT (c1) DO UPDATE SET c1 = excluded.c1, c2 = excluded.c2\n```", "```py\nmethod alias(name: str | None = None, flat: bool = False) \u2192 Subquery\n```", "```py\nmethod as_scalar() \u2192 ScalarSelect[Any]\n```", "```py\nattribute c\n```", "```py\nmethod compare(other: ClauseElement, **kw: Any) \u2192 bool\n```", "```py\nmethod compile(bind: _HasDialect | None = None, dialect: Dialect | None = None, **kw: Any) \u2192 Compiled\n```", "```py\n    from sqlalchemy.sql import table, column, select\n\n    t = table('t', column('x'))\n\n    s = select(t).where(t.c.x == 5)\n\n    print(s.compile(compile_kwargs={\"literal_binds\": True}))\n    ```", "```py\nmethod corresponding_column(column: KeyedColumnElement[Any], require_embedded: bool = False) \u2192 KeyedColumnElement[Any] | None\n```", "```py\nmethod cte(name: str | None = None, recursive: bool = False, nesting: bool = False) \u2192 CTE\n```", "```py\nfrom sqlalchemy import (Table, Column, String, Integer,\n                        MetaData, select, func)\n\nmetadata = MetaData()\n\norders = Table('orders', metadata,\n    Column('region', String),\n    Column('amount', Integer),\n    Column('product', String),\n    Column('quantity', Integer)\n)\n\nregional_sales = select(\n                    orders.c.region,\n                    func.sum(orders.c.amount).label('total_sales')\n                ).group_by(orders.c.region).cte(\"regional_sales\")\n\ntop_regions = select(regional_sales.c.region).\\\n        where(\n            regional_sales.c.total_sales >\n            select(\n                func.sum(regional_sales.c.total_sales) / 10\n            )\n        ).cte(\"top_regions\")\n\nstatement = select(\n            orders.c.region,\n            orders.c.product,\n            func.sum(orders.c.quantity).label(\"product_units\"),\n            func.sum(orders.c.amount).label(\"product_sales\")\n    ).where(orders.c.region.in_(\n        select(top_regions.c.region)\n    )).group_by(orders.c.region, orders.c.product)\n\nresult = conn.execute(statement).fetchall()\n```", "```py\nfrom sqlalchemy import (Table, Column, String, Integer,\n                        MetaData, select, func)\n\nmetadata = MetaData()\n\nparts = Table('parts', metadata,\n    Column('part', String),\n    Column('sub_part', String),\n    Column('quantity', Integer),\n)\n\nincluded_parts = select(\\\n    parts.c.sub_part, parts.c.part, parts.c.quantity\\\n    ).\\\n    where(parts.c.part=='our part').\\\n    cte(recursive=True)\n\nincl_alias = included_parts.alias()\nparts_alias = parts.alias()\nincluded_parts = included_parts.union_all(\n    select(\n        parts_alias.c.sub_part,\n        parts_alias.c.part,\n        parts_alias.c.quantity\n    ).\\\n    where(parts_alias.c.part==incl_alias.c.sub_part)\n)\n\nstatement = select(\n            included_parts.c.sub_part,\n            func.sum(included_parts.c.quantity).\n              label('total_quantity')\n        ).\\\n        group_by(included_parts.c.sub_part)\n\nresult = conn.execute(statement).fetchall()\n```", "```py\nfrom datetime import date\nfrom sqlalchemy import (MetaData, Table, Column, Integer,\n                        Date, select, literal, and_, exists)\n\nmetadata = MetaData()\n\nvisitors = Table('visitors', metadata,\n    Column('product_id', Integer, primary_key=True),\n    Column('date', Date, primary_key=True),\n    Column('count', Integer),\n)\n\n# add 5 visitors for the product_id == 1\nproduct_id = 1\nday = date.today()\ncount = 5\n\nupdate_cte = (\n    visitors.update()\n    .where(and_(visitors.c.product_id == product_id,\n                visitors.c.date == day))\n    .values(count=visitors.c.count + count)\n    .returning(literal(1))\n    .cte('update_cte')\n)\n\nupsert = visitors.insert().from_select(\n    [visitors.c.product_id, visitors.c.date, visitors.c.count],\n    select(literal(product_id), literal(day), literal(count))\n        .where(~exists(update_cte.select()))\n)\n\nconnection.execute(upsert)\n```", "```py\nvalue_a = select(\n    literal(\"root\").label(\"n\")\n).cte(\"value_a\")\n\n# A nested CTE with the same name as the root one\nvalue_a_nested = select(\n    literal(\"nesting\").label(\"n\")\n).cte(\"value_a\", nesting=True)\n\n# Nesting CTEs takes ascendency locally\n# over the CTEs at a higher level\nvalue_b = select(value_a_nested.c.n).cte(\"value_b\")\n\nvalue_ab = select(value_a.c.n.label(\"a\"), value_b.c.n.label(\"b\"))\n```", "```py\nWITH\n    value_a AS\n        (SELECT 'root' AS n),\n    value_b AS\n        (WITH value_a AS\n            (SELECT 'nesting' AS n)\n        SELECT value_a.n AS n FROM value_a)\nSELECT value_a.n AS a, value_b.n AS b\nFROM value_a, value_b\n```", "```py\nvalue_a = select(\n    literal(\"root\").label(\"n\")\n).cte(\"value_a\")\n\n# A nested CTE with the same name as the root one\nvalue_a_nested = select(\n    literal(\"nesting\").label(\"n\")\n).cte(\"value_a\")\n\n# Nesting CTEs takes ascendency locally\n# over the CTEs at a higher level\nvalue_b = (\n    select(value_a_nested.c.n).\n    add_cte(value_a_nested, nest_here=True).\n    cte(\"value_b\")\n)\n\nvalue_ab = select(value_a.c.n.label(\"a\"), value_b.c.n.label(\"b\"))\n```", "```py\nedge = Table(\n    \"edge\",\n    metadata,\n    Column(\"id\", Integer, primary_key=True),\n    Column(\"left\", Integer),\n    Column(\"right\", Integer),\n)\n\nroot_node = select(literal(1).label(\"node\")).cte(\n    \"nodes\", recursive=True\n)\n\nleft_edge = select(edge.c.left).join(\n    root_node, edge.c.right == root_node.c.node\n)\nright_edge = select(edge.c.right).join(\n    root_node, edge.c.left == root_node.c.node\n)\n\nsubgraph_cte = root_node.union(left_edge, right_edge)\n\nsubgraph = select(subgraph_cte)\n```", "```py\nWITH RECURSIVE nodes(node) AS (\n        SELECT 1 AS node\n    UNION\n        SELECT edge.\"left\" AS \"left\"\n        FROM edge JOIN nodes ON edge.\"right\" = nodes.node\n    UNION\n        SELECT edge.\"right\" AS \"right\"\n        FROM edge JOIN nodes ON edge.\"left\" = nodes.node\n)\nSELECT nodes.node FROM nodes\n```", "```py\nmethod execution_options(**kw: Any) \u2192 Self\n```", "```py\nstatement = select(table.c.x, table.c.y)\nnew_statement = statement.execution_options(my_option=True)\n```", "```py\nfrom sqlalchemy import event\n\n@event.listens_for(some_engine, \"before_execute\")\ndef _process_opt(conn, statement, multiparams, params, execution_options):\n    \"run a SQL function before invoking a statement\"\n\n    if execution_options.get(\"do_special_thing\", False):\n        conn.exec_driver_sql(\"run_special_function()\")\n```", "```py\nmethod exists() \u2192 Exists\n```", "```py\nattribute exported_columns\n```", "```py\nmethod get_children(*, omit_attrs: Tuple[str, ...] = (), **kw: Any) \u2192 Iterable[HasTraverseInternals]\n```", "```py\nmethod get_execution_options() \u2192 _ExecuteOptions\n```", "```py\nmethod get_label_style() \u2192 SelectLabelStyle\n```", "```py\nattribute inherit_cache: bool | None = None\n```", "```py\nmethod is_derived_from(fromclause: FromClause | None) \u2192 bool\n```", "```py\nmethod label(name: str | None) \u2192 Label[Any]\n```", "```py\nmethod lateral(name: str | None = None) \u2192 LateralFromClause\n```", "```py\nmethod options(*options: ExecutableOption) \u2192 Self\n```", "```py\nmethod params(_ClauseElement__optionaldict: Mapping[str, Any] | None = None, **kwargs: Any) \u2192 Self\n```", "```py\n>>> clause = column('x') + bindparam('foo')\n>>> print(clause.compile().params)\n{'foo':None}\n>>> print(clause.params({'foo':7}).compile().params)\n{'foo':7}\n```", "```py\nmethod replace_selectable(old: FromClause, alias: Alias) \u2192 Self\n```", "```py\nmethod scalar_subquery() \u2192 ScalarSelect[Any]\n```", "```py\nmethod select(*arg: Any, **kw: Any) \u2192 Select\n```", "```py\nattribute selected_columns\n```", "```py\nmethod self_group(against: OperatorType | None = None) \u2192 ClauseElement\n```", "```py\nmethod set_label_style(style: SelectLabelStyle) \u2192 TextualSelect\n```", "```py\nmethod subquery(name: str | None = None) \u2192 Subquery\n```", "```py\nstmt = select(table.c.id, table.c.name)\n```", "```py\nSELECT table.id, table.name FROM table\n```", "```py\nsubq = stmt.subquery()\nnew_stmt = select(subq)\n```", "```py\nSELECT anon_1.id, anon_1.name\nFROM (SELECT table.id, table.name FROM table) AS anon_1\n```", "```py\nmethod unique_params(_ClauseElement__optionaldict: Dict[str, Any] | None = None, **kwargs: Any) \u2192 Self\n```", "```py\nclass sqlalchemy.sql.expression.Values\n```", "```py\nmethod alias(name: str | None = None, flat: bool = False) \u2192 Self\n```", "```py\nmethod data(values: Sequence[Tuple[Any, ...]]) \u2192 Self\n```", "```py\nmy_values = my_values.data([(1, 'value 1'), (2, 'value2')])\n```", "```py\nmethod lateral(name: str | None = None) \u2192 LateralFromClause\n```", "```py\nmethod scalar_values() \u2192 ScalarValues\n```", "```py\nclass sqlalchemy.sql.expression.ScalarValues\n```", "```py\nclass sqlalchemy.sql.expression.SelectLabelStyle\n```", "```py\nattribute LABEL_STYLE_DEFAULT = 2\n```", "```py\nattribute LABEL_STYLE_DISAMBIGUATE_ONLY = 2\n```", "```py\n>>> from sqlalchemy import table, column, select, true, LABEL_STYLE_DISAMBIGUATE_ONLY\n>>> table1 = table(\"table1\", column(\"columna\"), column(\"columnb\"))\n>>> table2 = table(\"table2\", column(\"columna\"), column(\"columnc\"))\n>>> print(select(table1, table2).join(table2, true()).set_label_style(LABEL_STYLE_DISAMBIGUATE_ONLY))\nSELECT  table1.columna,  table1.columnb,  table2.columna  AS  columna_1,  table2.columnc\nFROM  table1  JOIN  table2  ON  true \n```", "```py\nattribute LABEL_STYLE_NONE = 0\n```", "```py\n>>> from sqlalchemy import table, column, select, true, LABEL_STYLE_NONE\n>>> table1 = table(\"table1\", column(\"columna\"), column(\"columnb\"))\n>>> table2 = table(\"table2\", column(\"columna\"), column(\"columnc\"))\n>>> print(select(table1, table2).join(table2, true()).set_label_style(LABEL_STYLE_NONE))\nSELECT  table1.columna,  table1.columnb,  table2.columna,  table2.columnc\nFROM  table1  JOIN  table2  ON  true \n```", "```py\nattribute LABEL_STYLE_TABLENAME_PLUS_COL = 1\n```", "```py\n>>> from sqlalchemy import table, column, select, true, LABEL_STYLE_TABLENAME_PLUS_COL\n>>> table1 = table(\"table1\", column(\"columna\"), column(\"columnb\"))\n>>> table2 = table(\"table2\", column(\"columna\"), column(\"columnc\"))\n>>> print(select(table1, table2).join(table2, true()).set_label_style(LABEL_STYLE_TABLENAME_PLUS_COL))\nSELECT  table1.columna  AS  table1_columna,  table1.columnb  AS  table1_columnb,  table2.columna  AS  table2_columna,  table2.columnc  AS  table2_columnc\nFROM  table1  JOIN  table2  ON  true \n```"]