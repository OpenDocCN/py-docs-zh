- en: What’s New in SQLAlchemy 1.3?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 原文：[https://docs.sqlalchemy.org/en/20/changelog/migration_13.html](https://docs.sqlalchemy.org/en/20/changelog/migration_13.html)
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: About this Document
  prefs: []
  type: TYPE_NORMAL
- en: This document describes changes between SQLAlchemy version 1.2 and SQLAlchemy
    version 1.3.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This guide introduces what’s new in SQLAlchemy version 1.3 and also documents
    changes which affect users migrating their applications from the 1.2 series of
    SQLAlchemy to 1.3.
  prefs: []
  type: TYPE_NORMAL
- en: Please carefully review the sections on behavioral changes for potentially backwards-incompatible
    changes in behavior.
  prefs: []
  type: TYPE_NORMAL
- en: General
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '### Deprecation warnings are emitted for all deprecated elements; new deprecations
    added'
  prefs: []
  type: TYPE_NORMAL
- en: Release 1.3 ensures that all behaviors and APIs that are deprecated, including
    all those that have been long listed as “legacy” for years, are emitting `DeprecationWarning`
    warnings. This includes when making use of parameters such as [`Session.weak_identity_map`](../orm/session_api.html#sqlalchemy.orm.Session.params.weak_identity_map
    "sqlalchemy.orm.Session") and classes such as `MapperExtension`. While all deprecations
    have been noted in the documentation, often they did not use a proper restructured
    text directive, or include in what version they were deprecated. Whether or not
    a particular API feature actually emitted a deprecation warning was not consistent.
    The general attitude was that most or all of these deprecated features were treated
    as long-term legacy features with no plans to remove them.
  prefs: []
  type: TYPE_NORMAL
- en: The change includes that all documented deprecations now use a proper restructured
    text directive in the documentation with a version number, the verbiage that the
    feature or use case will be removed in a future release is made explicit (e.g.,
    no more legacy forever use cases), and that use of any such feature or use case
    will definitely emit a `DeprecationWarning`, which in Python 3 as well as when
    using modern testing tools like Pytest are now made more explicit in the standard
    error stream. The goal is that these long deprecated features, going back as far
    as version 0.7 or 0.6, should start being removed entirely, rather than keeping
    them around as “legacy” features. Additionally, some major new deprecations are
    being added as of version 1.3. As SQLAlchemy has 14 years of real world use by
    thousands of developers, it’s possible to point to a single stream of use cases
    that blend together well, and to trim away features and patterns that work against
    this single way of working.
  prefs: []
  type: TYPE_NORMAL
- en: The larger context is that SQLAlchemy seeks to adjust to the coming Python 3-only
    world, as well as a type-annotated world, and towards this goal there are **tentative**
    plans for a major rework of SQLAlchemy which would hopefully greatly reduce the
    cognitive load of the API as well as perform a major pass over the great many
    differences in implementation and use between Core and ORM. As these two systems
    evolved dramatically after SQLAlchemy’s first release, in particular the ORM still
    retains lots of “bolted on” behaviors that keep the wall of separation between
    Core and ORM too high. By focusing the API ahead of time on a single pattern for
    each supported use case, the eventual job of migrating to a significantly altered
    API becomes simpler.
  prefs: []
  type: TYPE_NORMAL
- en: For the most major deprecations being added in 1.3, see the linked sections
    below.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[“threadlocal” engine strategy deprecated](#change-4393-threadlocal)'
  prefs: []
  type: TYPE_NORMAL
- en: '[convert_unicode parameters deprecated](#change-4393-convertunicode)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Relationship to AliasedClass replaces the need for non primary mappers](#change-4423)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#4393](https://www.sqlalchemy.org/trac/ticket/4393)'
  prefs: []
  type: TYPE_NORMAL
- en: New Features and Improvements - ORM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '### Relationship to AliasedClass replaces the need for non primary mappers'
  prefs: []
  type: TYPE_NORMAL
- en: The “non primary mapper” is a [`Mapper`](../orm/mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper") created in the [Imperative Mapping](../orm/mapping_styles.html#orm-imperative-mapping)
    style, which acts as an additional mapper against an already mapped class against
    a different kind of selectable. The non primary mapper has its roots in the 0.1,
    0.2 series of SQLAlchemy where it was anticipated that the [`Mapper`](../orm/mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper") object was to be the primary query construction interface,
    before the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    object existed.
  prefs: []
  type: TYPE_NORMAL
- en: With the advent of [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") and later the [`AliasedClass`](../orm/queryguide/api.html#sqlalchemy.orm.util.AliasedClass
    "sqlalchemy.orm.util.AliasedClass") construct, most use cases for the non primary
    mapper went away. This was a good thing since SQLAlchemy also moved away from
    “classical” mappings altogether around the 0.5 series in favor of the declarative
    system.
  prefs: []
  type: TYPE_NORMAL
- en: One use case remained around for non primary mappers when it was realized that
    some very hard-to-define [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") configurations could be made possible when a non-primary
    mapper with an alternative selectable was made as the mapping target, rather than
    trying to construct a [`relationship.primaryjoin`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.primaryjoin
    "sqlalchemy.orm.relationship") that encompassed all the complexity of a particular
    inter-object relationship.
  prefs: []
  type: TYPE_NORMAL
- en: As this use case became more popular, its limitations became apparent, including
    that the non primary mapper is difficult to configure against a selectable that
    adds new columns, that the mapper does not inherit the relationships of the original
    mapping, that relationships which are configured explicitly on the non primary
    mapper do not function well with loader options, and that the non primary mapper
    also doesn’t provide a fully functional namespace of column-based attributes which
    can be used in queries (which again, in the old 0.1 - 0.4 days, one would use
    [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    objects directly with the ORM).
  prefs: []
  type: TYPE_NORMAL
- en: The missing piece was to allow the [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") to refer directly to the [`AliasedClass`](../orm/queryguide/api.html#sqlalchemy.orm.util.AliasedClass
    "sqlalchemy.orm.util.AliasedClass"). The [`AliasedClass`](../orm/queryguide/api.html#sqlalchemy.orm.util.AliasedClass
    "sqlalchemy.orm.util.AliasedClass") already does everything we want the non primary
    mapper to do; it allows an existing mapped class to be loaded from an alternative
    selectable, it inherits all the attributes and relationships of the existing mapper,
    it works extremely well with loader options, and it provides a class-like object
    that can be mixed into queries just like the class itself. With this change, the
    recipes that were formerly for non primary mappers at [Configuring how Relationship
    Joins](../orm/join_conditions.html#relationship-configure-joins) are changed to
    aliased class.
  prefs: []
  type: TYPE_NORMAL
- en: 'At [Relationship to Aliased Class](../orm/join_conditions.html#relationship-aliased-class),
    the original non primary mapper looked like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The properties were necessary in order to re-map the additional columns so that
    they did not conflict with the existing columns mapped to `B`, as well as it was
    necessary to define a new primary key.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the new approach, all of this verbosity goes away, and the additional
    columns are referenced directly when making the relationship:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The non primary mapper is now deprecated with the eventual goal to be that classical
    mappings as a feature go away entirely. The Declarative API would become the single
    means of mapping which hopefully will allow internal improvements and simplifications,
    as well as a clearer documentation story.
  prefs: []
  type: TYPE_NORMAL
- en: '[#4423](https://www.sqlalchemy.org/trac/ticket/4423)  ### selectin loading
    no longer uses JOIN for simple one-to-many'
  prefs: []
  type: TYPE_NORMAL
- en: The “selectin” loading feature added in 1.2 introduced an extremely performant
    new way to eagerly load collections, in many cases much faster than that of “subquery”
    eager loading, as it does not rely upon restating the original SELECT query and
    instead uses a simple IN clause. However, the “selectin” load still relied upon
    rendering a JOIN between the parent and related tables, since it needs the parent
    primary key values in the row in order to match rows up. In 1.3, a new optimization
    is added which will omit this JOIN in the most common case of a simple one-to-many
    load, where the related row already contains the primary key of the parent row
    expressed in its foreign key columns. This again provides for a dramatic performance
    improvement as the ORM now can load large numbers of collections all in one query
    without using JOIN or subqueries at all.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given a mapping:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In the 1.2 version of “selectin” loading, a load of A to B looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'With the new behavior, the load looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The behavior is being released as automatic, using a similar heuristic that
    lazy loading uses in order to determine if related entities can be fetched directly
    from the identity map. However, as with most querying features, the feature’s
    implementation became more complex as a result of advanced scenarios regarding
    polymorphic loading. If problems are encountered, users should report a bug, however
    the change also includes a flag [`relationship.omit_join`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.omit_join
    "sqlalchemy.orm.relationship") which can be set to `False` on the [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") to disable the optimization.
  prefs: []
  type: TYPE_NORMAL
- en: '[#4340](https://www.sqlalchemy.org/trac/ticket/4340)  ### Improvement to the
    behavior of many-to-one query expressions'
  prefs: []
  type: TYPE_NORMAL
- en: 'When building a query that compares a many-to-one relationship to an object
    value, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The above expression `Address.user == u1`, which ultimately compiles to a SQL
    expression normally based on the primary key columns of the `User` object like
    `"address.user_id = 5"`, uses a deferred callable in order to retrieve the value
    `5` within the bound expression until as late as possible. This is to suit both
    the use case where the `Address.user == u1` expression may be against a `User`
    object that isn’t flushed yet which relies upon a server- generated primary key
    value, as well as that the expression always returns the correct result even if
    the primary key value of `u1` has been changed since the expression was created.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, a side effect of this behavior is that if `u1` ends up being expired
    by the time the expression is evaluated, it results in an additional SELECT statement,
    and in the case that `u1` was also detached from the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), it would raise an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The expiration / expunging of the object can occur implicitly when the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is committed and the `u1` instance falls out of scope,
    as the `Address.user == u1` expression does not strongly reference the object
    itself, only its [`InstanceState`](../orm/internals.html#sqlalchemy.orm.InstanceState
    "sqlalchemy.orm.InstanceState").
  prefs: []
  type: TYPE_NORMAL
- en: The fix is to allow the `Address.user == u1` expression to evaluate the value
    `5` based on attempting to retrieve or load the value normally at expression compilation
    time as it does now, but if the object is detached and has been expired, it is
    retrieved from a new mechanism upon the [`InstanceState`](../orm/internals.html#sqlalchemy.orm.InstanceState
    "sqlalchemy.orm.InstanceState") which will memoize the last known value for a
    particular attribute on that state when that attribute is expired. This mechanism
    is only enabled for a specific attribute / [`InstanceState`](../orm/internals.html#sqlalchemy.orm.InstanceState
    "sqlalchemy.orm.InstanceState") when needed by the expression feature to conserve
    performance / memory overhead.
  prefs: []
  type: TYPE_NORMAL
- en: Originally, simpler approaches such as evaluating the expression immediately
    with various arrangements for trying to load the value later if not present were
    attempted, however the difficult edge case is that of the value of a column attribute
    (typically a natural primary key) that is being changed. In order to ensure that
    an expression like `Address.user == u1` always returns the correct answer for
    the current state of `u1`, it will return the current database-persisted value
    for a persistent object, unexpiring via SELECT query if necessary, and for a detached
    object it will return the most recent known value, regardless of when the object
    was expired using a new feature within the [`InstanceState`](../orm/internals.html#sqlalchemy.orm.InstanceState
    "sqlalchemy.orm.InstanceState") that tracks the last known value of a column attribute
    whenever the attribute is to be expired.
  prefs: []
  type: TYPE_NORMAL
- en: Modern attribute API features are used to indicate specific error messages when
    the value cannot be evaluated, the two cases of which are when the column attributes
    have never been set, and when the object was already expired when the first evaluation
    was made and is now detached. In all cases, [`DetachedInstanceError`](../orm/exceptions.html#sqlalchemy.orm.exc.DetachedInstanceError
    "sqlalchemy.orm.exc.DetachedInstanceError") is no longer raised.
  prefs: []
  type: TYPE_NORMAL
- en: '[#4359](https://www.sqlalchemy.org/trac/ticket/4359)  ### Many-to-one replacement
    won’t raise for “raiseload” or detached for “old” object'
  prefs: []
  type: TYPE_NORMAL
- en: 'Given the case where a lazy load would proceed on a many-to-one relationship
    in order to load the “old” value, if the relationship does not specify the [`relationship.active_history`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.active_history
    "sqlalchemy.orm.relationship") flag, an assertion will not be raised for a detached
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Above, when the `.user` attribute is replaced on the detached `a1` object, a
    [`DetachedInstanceError`](../orm/exceptions.html#sqlalchemy.orm.exc.DetachedInstanceError
    "sqlalchemy.orm.exc.DetachedInstanceError") would be raised as the attribute is
    attempting to retrieve the previous value of `.user` from the identity map. The
    change is that the operation now proceeds without the old value being loaded.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same change is also made to the `lazy="raise"` loader strategy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Previously, the association of `a1.user` would invoke the “raiseload” exception
    as a result of the attribute attempting to retrieve the previous value. This assertion
    is now skipped in the case of loading the “old” value.
  prefs: []
  type: TYPE_NORMAL
- en: '[#4353](https://www.sqlalchemy.org/trac/ticket/4353)  ### “del” implemented
    for ORM attributes'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Python `del` operation was not really usable for mapped attributes, either
    scalar columns or object references. Support has been added for this to work correctly,
    where the `del` operation is roughly equivalent to setting the attribute to the
    `None` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[#4354](https://www.sqlalchemy.org/trac/ticket/4354)  ### info dictionary added
    to InstanceState'
  prefs: []
  type: TYPE_NORMAL
- en: 'Added the `.info` dictionary to the [`InstanceState`](../orm/internals.html#sqlalchemy.orm.InstanceState
    "sqlalchemy.orm.InstanceState") class, the object that comes from calling [`inspect()`](../core/inspection.html#sqlalchemy.inspect
    "sqlalchemy.inspect") on a mapped object. This allows custom recipes to add additional
    information about an object that will be carried along with that object’s full
    lifecycle in memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[#4257](https://www.sqlalchemy.org/trac/ticket/4257)  ### Horizontal Sharding
    extension supports bulk update and delete methods'
  prefs: []
  type: TYPE_NORMAL
- en: The [`ShardedQuery`](../orm/extensions/horizontal_shard.html#sqlalchemy.ext.horizontal_shard.ShardedQuery
    "sqlalchemy.ext.horizontal_shard.ShardedQuery") extension object supports the
    [`Query.update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.update "sqlalchemy.orm.Query.update")
    and [`Query.delete()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.delete
    "sqlalchemy.orm.Query.delete") bulk update/delete methods. The `query_chooser`
    callable is consulted when they are called in order to run the update/delete across
    multiple shards based on given criteria.
  prefs: []
  type: TYPE_NORMAL
- en: '[#4196](https://www.sqlalchemy.org/trac/ticket/4196)'
  prefs: []
  type: TYPE_NORMAL
- en: Association Proxy Improvements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While not for any particular reason, the Association Proxy extension had many
    improvements this cycle.
  prefs: []
  type: TYPE_NORMAL
- en: '#### Association proxy has new cascade_scalar_deletes flag'
  prefs: []
  type: TYPE_NORMAL
- en: 'Given a mapping as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'An assignment to `A.b` will generate an `AB` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `A.b` association is scalar, and includes a new flag [`AssociationProxy.cascade_scalar_deletes`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy.params.cascade_scalar_deletes
    "sqlalchemy.ext.associationproxy.AssociationProxy"). When set, setting `A.b` to
    `None` will remove `A.ab` as well. The default behavior remains that it leaves
    `a.ab` in place:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: While it at first seemed intuitive that this logic should just look at the “cascade”
    attribute of the existing relationship, it’s not clear from that alone if the
    proxied object should be removed, hence the behavior is made available as an explicit
    option.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, `del` now works for scalars in a similar manner as setting to
    `None`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[#4308](https://www.sqlalchemy.org/trac/ticket/4308)  #### AssociationProxy
    stores class-specific state on a per-class basis'
  prefs: []
  type: TYPE_NORMAL
- en: The [`AssociationProxy`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy
    "sqlalchemy.ext.associationproxy.AssociationProxy") object makes lots of decisions
    based on the parent mapped class it is associated with. While the [`AssociationProxy`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy
    "sqlalchemy.ext.associationproxy.AssociationProxy") historically began as a relatively
    simple ‘getter,’ it became apparent early on that it also needed to make decisions
    regarding the kind of attribute to which it refers—such as scalar or collection,
    mapped object or simple value, and so on. To achieve this, it needs to inspect
    the mapped attribute or other referring descriptor or attribute, as referenced
    from its parent class. However in Python descriptor mechanics, a descriptor only
    learns about its “parent” class when it is accessed in the context of that class,
    such as calling `MyClass.some_descriptor`, which calls the `__get__()` method
    which passes in the class. The [`AssociationProxy`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy
    "sqlalchemy.ext.associationproxy.AssociationProxy") object would therefore store
    state that is specific to that class, but only once this method were called; trying
    to inspect this state ahead of time without first accessing the [`AssociationProxy`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy
    "sqlalchemy.ext.associationproxy.AssociationProxy") as a descriptor would raise
    an error. Additionally, it would assume that the first class to be seen by `__get__()`
    would be the only parent class it needed to know about. This is despite the fact
    that if a particular class has inheriting subclasses, the association proxy is
    really working on behalf of more than one parent class even though it was not
    explicitly re-used. While even with this shortcoming, the association proxy would
    still get pretty far with its current behavior, it still leaves shortcomings in
    some cases as well as the complex problem of determining the best “owner” class.
  prefs: []
  type: TYPE_NORMAL
- en: These problems are now solved in that [`AssociationProxy`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy
    "sqlalchemy.ext.associationproxy.AssociationProxy") no longer modifies its own
    internal state when `__get__()` is called; instead, a new object is generated
    per-class known as [`AssociationProxyInstance`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxyInstance
    "sqlalchemy.ext.associationproxy.AssociationProxyInstance") which handles all
    the state specific to a particular mapped parent class (when the parent class
    is not mapped, no [`AssociationProxyInstance`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxyInstance
    "sqlalchemy.ext.associationproxy.AssociationProxyInstance") is generated). The
    concept of a single “owning class” for the association proxy, which was nonetheless
    improved in 1.1, has essentially been replaced with an approach where the AP now
    can treat any number of “owning” classes equally.
  prefs: []
  type: TYPE_NORMAL
- en: 'To accommodate for applications that want to inspect this state for an [`AssociationProxy`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy
    "sqlalchemy.ext.associationproxy.AssociationProxy") without necessarily calling
    `__get__()`, a new method [`AssociationProxy.for_class()`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy.for_class
    "sqlalchemy.ext.associationproxy.AssociationProxy.for_class") is added that provides
    direct access to a class-specific [`AssociationProxyInstance`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxyInstance
    "sqlalchemy.ext.associationproxy.AssociationProxyInstance"), demonstrated as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have the [`AssociationProxyInstance`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxyInstance
    "sqlalchemy.ext.associationproxy.AssociationProxyInstance") object, in the above
    example stored in the `proxy_state` variable, we can look at attributes specific
    to the `User.keywords` proxy, such as `target_class`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[#3423](https://www.sqlalchemy.org/trac/ticket/3423)  #### AssociationProxy
    now provides standard column operators for a column-oriented target'
  prefs: []
  type: TYPE_NORMAL
- en: 'Given an [`AssociationProxy`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy
    "sqlalchemy.ext.associationproxy.AssociationProxy") where the target is a database
    column, and is **not** an object reference or another association proxy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `User.values` association proxy refers to the `Element.value` column. Standard
    column operations are now available, such as `like`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '`equals`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'When comparing to `None`, the `IS NULL` expression is augmented with a test
    that the related row does not exist at all; this is the same behavior as before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the [`ColumnOperators.contains()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.contains
    "sqlalchemy.sql.expression.ColumnOperators.contains") operator is in fact a string
    comparison operator; **this is a change in behavior** in that previously, the
    association proxy used `.contains` as a list containment operator only. With a
    column-oriented comparison, it now behaves like a “like”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In order to test the `User.values` collection for simple membership of the value
    `"foo"`, the equals operator (e.g. `User.values == 'foo'`) should be used; this
    works in previous versions as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using an object-based association proxy with a collection, the behavior
    is as before, that of testing for collection membership, e.g. given a mapping:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The `.contains()` method produces the same expression as before, testing the
    list of `User.elements` for the presence of an `Element` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Overall, the change is enabled based on the architectural change that is part
    of [AssociationProxy stores class-specific state on a per-class basis](#change-3423);
    as the proxy now spins off additional state when an expression is generated, there
    is both an object-target and a column-target version of the [`AssociationProxyInstance`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxyInstance
    "sqlalchemy.ext.associationproxy.AssociationProxyInstance") class.
  prefs: []
  type: TYPE_NORMAL
- en: '[#4351](https://www.sqlalchemy.org/trac/ticket/4351)'
  prefs: []
  type: TYPE_NORMAL
- en: Association Proxy now Strong References the Parent Object
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The long-standing behavior of the association proxy collection maintaining only
    a weak reference to the parent object is reverted; the proxy will now maintain
    a strong reference to the parent for as long as the proxy collection itself is
    also in memory, eliminating the “stale association proxy” error. This change is
    being made on an experimental basis to see if any use cases arise where it causes
    side effects.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, given a mapping with association proxy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Previously, if `a1` were deleted out of scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Trying to iterate the `b_data` collection after `a1` is deleted from scope
    would raise the error `"stale association proxy, parent object has gone out of
    scope"`. This is because the association proxy needs to access the actual `a1.bs`
    collection in order to produce a view, and prior to this change it maintained
    only a weak reference to `a1`. In particular, users would frequently encounter
    this error when performing an inline operation such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Above, because the `A` object would be garbage collected before the `b_data`
    collection were actually used.
  prefs: []
  type: TYPE_NORMAL
- en: 'The change is that the `b_data` collection is now maintaining a strong reference
    to the `a1` object, so that it remains present:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This change introduces the side effect that if an application is passing around
    the collection as above, **the parent object won’t be garbage collected** until
    the collection is also discarded. As always, if `a1` is persistent inside a particular
    [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session"),
    it will remain part of that session’s state until it is garbage collected.
  prefs: []
  type: TYPE_NORMAL
- en: Note that this change may be revised if it leads to problems.
  prefs: []
  type: TYPE_NORMAL
- en: '[#4268](https://www.sqlalchemy.org/trac/ticket/4268)'
  prefs: []
  type: TYPE_NORMAL
- en: '#### Implemented bulk replace for sets, dicts with AssociationProxy'
  prefs: []
  type: TYPE_NORMAL
- en: 'Assignment of a set or dictionary to an association proxy collection should
    now work correctly, whereas before it would re-create association proxy members
    for existing keys, leading to the issue of potential flush failures due to the
    delete+insert of the same object it now should only create new association objects
    where appropriate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[#2642](https://www.sqlalchemy.org/trac/ticket/2642)  ### Many-to-one backref
    checks for collection duplicates during remove operation'
  prefs: []
  type: TYPE_NORMAL
- en: 'When an ORM-mapped collection that existed as a Python sequence, typically
    a Python `list` as is the default for [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship"), contained duplicates, and the object were removed
    from one of its positions but not the other(s), a many-to-one backref would set
    its attribute to `None` even though the one-to-many side still represented the
    object as present. Even though one-to-many collections cannot have duplicates
    in the relational model, an ORM-mapped [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") that uses a sequence collection can have duplicates
    inside of it in memory, with the restriction that this duplicate state can neither
    be persisted nor retrieved from the database. In particular, having a duplicate
    temporarily present in the list is intrinsic to a Python “swap” operation. Given
    a standard one-to-many/many-to-one setup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'If we have an `A` object with two `B` members, and perform a swap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'During the above operation, interception of the standard Python `__setitem__`
    `__delitem__` methods delivers an interim state where the second `B()` object
    is present twice in the collection. When the `B()` object is removed from one
    of the positions, the `B.a` backref would set the reference to `None`, causing
    the link between the `A` and `B` object to be removed during the flush. The same
    issue can be demonstrated using plain duplicates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The fix ensures that when the backref fires off, which is before the collection
    is mutated, the collection is checked for exactly one or zero instances of the
    target item before unsetting the many-to-one side, using a linear search which
    at the moment makes use of `list.search` and `list.__contains__`.
  prefs: []
  type: TYPE_NORMAL
- en: Originally it was thought that an event-based reference counting scheme would
    need to be used within the collection internals so that all duplicate instances
    could be tracked throughout the lifecycle of the collection, which would have
    added a performance/memory/complexity impact to all collection operations, including
    the very frequent operations of loading and appending. The approach that is taken
    instead limits the additional expense to the less common operations of collection
    removal and bulk replacement, and the observed overhead of the linear scan is
    negligible; linear scans of relationship-bound collections are already used within
    the unit of work as well as when a collection is bulk replaced.
  prefs: []
  type: TYPE_NORMAL
- en: '[#1103](https://www.sqlalchemy.org/trac/ticket/1103)'
  prefs: []
  type: TYPE_NORMAL
- en: Key Behavioral Changes - ORM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '### Query.join() handles ambiguity in deciding the “left” side more explicitly'
  prefs: []
  type: TYPE_NORMAL
- en: 'Historically, given a query like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'given the standard tutorial mappings, the query would produce a FROM clause
    as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'That is, the JOIN would implicitly be against the first entity that matches.
    The new behavior is that an exception requests that this ambiguity be resolved:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The solution is to provide an ON clause, either as an expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Or to use the relationship attribute, if available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The change includes that a join can now correctly link to a FROM clause that
    is not the first element in the list if the join is otherwise non-ambiguous:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Prior to this enhancement, the above query would raise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the query works fine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Overall the change is directly towards Python’s “explicit is better than implicit”
    philosophy.
  prefs: []
  type: TYPE_NORMAL
- en: '[#4365](https://www.sqlalchemy.org/trac/ticket/4365)  ### FOR UPDATE clause
    is rendered within the joined eager load subquery as well as outside'
  prefs: []
  type: TYPE_NORMAL
- en: This change applies specifically to the use of the [`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload") loading strategy in conjunction with a row limited
    query, e.g. using [`Query.first()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.first
    "sqlalchemy.orm.Query.first") or [`Query.limit()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.limit
    "sqlalchemy.orm.Query.limit"), as well as with use of the [`Query.with_for_update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.with_for_update
    "sqlalchemy.orm.Query.with_for_update") method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given a query as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    object renders a SELECT of the following form when joined eager loading is combined
    with LIMIT:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'This is so that the limit of rows takes place for the primary entity without
    affecting the joined eager load of related items. When the above query is combined
    with “SELECT..FOR UPDATE”, the behavior has been this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'However, MySQL due to [https://bugs.mysql.com/bug.php?id=90693](https://bugs.mysql.com/bug.php?id=90693)
    does not lock the rows inside the subquery, unlike that of PostgreSQL and other
    databases. So the above query now renders as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: On the Oracle dialect, the inner “FOR UPDATE” is not rendered as Oracle does
    not support this syntax and the dialect skips any “FOR UPDATE” that is against
    a subquery; it isn’t necessary in any case since Oracle, like PostgreSQL, correctly
    locks all elements of the returned row.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using the [`Query.with_for_update.of`](../orm/queryguide/query.html#sqlalchemy.orm.Query.with_for_update.params.of
    "sqlalchemy.orm.Query.with_for_update") modifier, typically on PostgreSQL, the
    outer “FOR UPDATE” is omitted, and the OF is now rendered on the inside; previously,
    the OF target would not be converted to accommodate for the subquery correctly.
    So given:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The query would now render as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The above form should be helpful on PostgreSQL additionally since PostgreSQL
    will not allow the FOR UPDATE clause to be rendered after the LEFT OUTER JOIN
    target.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, FOR UPDATE remains highly specific to the target database in use and
    can’t easily be generalized for more complex queries.
  prefs: []
  type: TYPE_NORMAL
- en: '[#4246](https://www.sqlalchemy.org/trac/ticket/4246)  ### passive_deletes=’all’
    will leave FK unchanged for object removed from collection'
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`relationship.passive_deletes`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.passive_deletes
    "sqlalchemy.orm.relationship") option accepts the value `"all"` to indicate that
    no foreign key attributes should be modified when the object is flushed, even
    if the relationship’s collection / reference has been removed. Previously, this
    did not take place for one-to-many, or one-to-one relationships, in the following
    situation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The fix now includes that `address.user_id` is left unchanged as per `passive_deletes="all"`.
    This kind of thing is useful for building custom “version table” schemes and such
    where rows are archived instead of deleted.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3844](https://www.sqlalchemy.org/trac/ticket/3844)  ## New Features and Improvements
    - Core'
  prefs: []
  type: TYPE_NORMAL
- en: '### New multi-column naming convention tokens, long name truncation'
  prefs: []
  type: TYPE_NORMAL
- en: 'To suit the case where a [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") naming convention needs to disambiguate between
    multiple-column constraints and wishes to use all the columns within the generated
    constraint name, a new series of naming convention tokens are added, including
    `column_0N_name`, `column_0_N_name`, `column_0N_key`, `column_0_N_key`, `referred_column_0N_name`,
    `referred_column_0_N_name`, etc., which render the column name (or key or label)
    for all columns in the constraint, joined together either with no separator or
    with an underscore separator. Below we define a convention that will name [`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint") constraints with a name that joins together
    the names of all columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'The CREATE TABLE for the above table will render as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition, long-name truncation logic is now applied to the names generated
    by naming conventions, in particular to accommodate for multi-column labels that
    can produce very long names. This logic, which is the same as that used for truncating
    long label names in a SELECT statement, replaces excess characters that go over
    the identifier-length limit for the target database with a deterministically generated
    4-character hash. For example, on PostgreSQL where identifiers cannot be longer
    than 63 characters, a long constraint name would normally be generated from the
    table definition below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The truncation logic will ensure a too-long name isn’t generated for the UNIQUE
    constraint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The above suffix `a79e` is based on the md5 hash of the long name and will generate
    the same value every time to produce consistent names for a given schema.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the truncation logic also raises [`IdentifierError`](../core/exceptions.html#sqlalchemy.exc.IdentifierError
    "sqlalchemy.exc.IdentifierError") when a constraint name is explicitly too large
    for a given dialect. This has been the behavior for an [`Index`](../core/constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index") object for a long time, but is now applied to other
    kinds of constraints as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'will output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The exception raise prevents the production of non-deterministic constraint
    names truncated by the database backend which are then not compatible with database
    migrations later on.
  prefs: []
  type: TYPE_NORMAL
- en: 'To apply SQLAlchemy-side truncation rules to the above identifier, use the
    [`conv()`](../core/constraints.html#sqlalchemy.schema.conv "sqlalchemy.schema.conv")
    construct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'This will again output deterministically truncated SQL as in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: There is not at the moment an option to have the names pass through to allow
    database-side truncation. This has already been the case for [`Index`](../core/constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index") names for some time and issues have not been raised.
  prefs: []
  type: TYPE_NORMAL
- en: The change also repairs two other issues. One is that the `column_0_key` token
    wasn’t available even though this token was documented, the other was that the
    `referred_column_0_name` token would inadvertently render the `.key` and not the
    `.name` of the column if these two values were different.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Configuring Constraint Naming Conventions](../core/constraints.html#constraint-naming-conventions)'
  prefs: []
  type: TYPE_NORMAL
- en: '[`MetaData.naming_convention`](../core/metadata.html#sqlalchemy.schema.MetaData.params.naming_convention
    "sqlalchemy.schema.MetaData")'
  prefs: []
  type: TYPE_NORMAL
- en: '[#3989](https://www.sqlalchemy.org/trac/ticket/3989)  ### Binary comparison
    interpretation for SQL functions'
  prefs: []
  type: TYPE_NORMAL
- en: This enhancement is implemented at the Core level, however is applicable primarily
    to the ORM.
  prefs: []
  type: TYPE_NORMAL
- en: 'A SQL function that compares two elements can now be used as a “comparison”
    object, suitable for usage in an ORM [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship"), by first creating the function as usual using
    the [`func`](../core/sqlelement.html#sqlalchemy.sql.expression.func "sqlalchemy.sql.expression.func")
    factory, then when the function is complete calling upon the [`FunctionElement.as_comparison()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.as_comparison
    "sqlalchemy.sql.functions.FunctionElement.as_comparison") modifier to produce
    a [`BinaryExpression`](../core/sqlelement.html#sqlalchemy.sql.expression.BinaryExpression
    "sqlalchemy.sql.expression.BinaryExpression") that has a “left” and a “right”
    side:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Above, the [`relationship.primaryjoin`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.primaryjoin
    "sqlalchemy.orm.relationship") of the “descendants” relationship will produce
    a “left” and a “right” expression based on the first and second arguments passed
    to `instr()`. This allows features like the ORM lazyload to produce SQL like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'and a joinedload, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'to work as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: This feature is expected to help with situations such as making use of geometric
    functions in relationship join conditions, or any case where the ON clause of
    the SQL join is expressed in terms of a SQL function.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3831](https://www.sqlalchemy.org/trac/ticket/3831)  ### Expanding IN feature
    now supports empty lists'
  prefs: []
  type: TYPE_NORMAL
- en: 'The “expanding IN” feature introduced in version 1.2 at [Late-expanded IN parameter
    sets allow IN expressions with cached statements](migration_12.html#change-3953)
    now supports empty lists passed to the [`ColumnOperators.in_()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.in_
    "sqlalchemy.sql.expression.ColumnOperators.in_") operator. The implementation
    for an empty list will produce an “empty set” expression that is specific to a
    target backend, such as “SELECT CAST(NULL AS INTEGER) WHERE 1!=1” for PostgreSQL,
    “SELECT 1 FROM (SELECT 1) as _empty_set WHERE 1!=1” for MySQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The feature also works for tuple-oriented IN statements, where the “empty IN”
    expression will be expanded to support the elements given inside the tuple, such
    as on PostgreSQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[#4271](https://www.sqlalchemy.org/trac/ticket/4271)  ### TypeEngine methods
    bind_expression, column_expression work with Variant, type-specific types'
  prefs: []
  type: TYPE_NORMAL
- en: The [`TypeEngine.bind_expression()`](../core/type_api.html#sqlalchemy.types.TypeEngine.bind_expression
    "sqlalchemy.types.TypeEngine.bind_expression") and [`TypeEngine.column_expression()`](../core/type_api.html#sqlalchemy.types.TypeEngine.column_expression
    "sqlalchemy.types.TypeEngine.column_expression") methods now work when they are
    present on the “impl” of a particular datatype, allowing these methods to be used
    by dialects as well as for [`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") and [`Variant`](../core/type_api.html#sqlalchemy.types.Variant
    "sqlalchemy.types.Variant") use cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example illustrates a [`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") that applies SQL-time conversion functions to
    a [`LargeBinary`](../core/type_basics.html#sqlalchemy.types.LargeBinary "sqlalchemy.types.LargeBinary").
    In order for this type to work in the context of a [`Variant`](../core/type_api.html#sqlalchemy.types.Variant
    "sqlalchemy.types.Variant"), the compiler needs to drill into the “impl” of the
    variant expression in order to locate these methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The above expression will render a function within SQL when used on SQLite
    only:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'will render:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: The change also includes that dialects can implement [`TypeEngine.bind_expression()`](../core/type_api.html#sqlalchemy.types.TypeEngine.bind_expression
    "sqlalchemy.types.TypeEngine.bind_expression") and [`TypeEngine.column_expression()`](../core/type_api.html#sqlalchemy.types.TypeEngine.column_expression
    "sqlalchemy.types.TypeEngine.column_expression") on dialect-level implementation
    types where they will now be used; in particular this will be used for MySQL’s
    new “binary prefix” requirement as well as for casting decimal bind values for
    MySQL.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3981](https://www.sqlalchemy.org/trac/ticket/3981)  ### New last-in-first-out
    strategy for QueuePool'
  prefs: []
  type: TYPE_NORMAL
- en: The connection pool usually used by [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") is known as [`QueuePool`](../core/pooling.html#sqlalchemy.pool.QueuePool
    "sqlalchemy.pool.QueuePool"). This pool uses an object equivalent to Python’s
    built-in `Queue` class in order to store database connections waiting to be used.
    The `Queue` features first-in-first-out behavior, which is intended to provide
    a round-robin use of the database connections that are persistently in the pool.
    However, a potential downside of this is that when the utilization of the pool
    is low, the re-use of each connection in series means that a server-side timeout
    strategy that attempts to reduce unused connections is prevented from shutting
    down these connections. To suit this use case, a new flag [`create_engine.pool_use_lifo`](../core/engines.html#sqlalchemy.create_engine.params.pool_use_lifo
    "sqlalchemy.create_engine") is added which reverses the `.get()` method of the
    `Queue` to pull the connection from the beginning of the queue instead of the
    end, essentially turning the “queue” into a “stack” (adding a whole new pool called
    `StackPool` was considered, however this was too much verbosity).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Using FIFO vs. LIFO](../core/pooling.html#pool-use-lifo)'
  prefs: []
  type: TYPE_NORMAL
- en: Key Changes - Core
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '### Coercion of string SQL fragments to text() fully removed'
  prefs: []
  type: TYPE_NORMAL
- en: The warnings that were first added in version 1.0, described at [Warnings emitted
    when coercing full SQL fragments into text()](migration_10.html#migration-2992),
    have now been converted into exceptions. Continued concerns have been raised regarding
    the automatic coercion of string fragments passed to methods like [`Query.filter()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.filter
    "sqlalchemy.orm.Query.filter") and [`Select.order_by()`](../core/selectable.html#sqlalchemy.sql.expression.Select.order_by
    "sqlalchemy.sql.expression.Select.order_by") being converted to [`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text
    "sqlalchemy.sql.expression.text") constructs, even though this has emitted a warning.
    In the case of [`Select.order_by()`](../core/selectable.html#sqlalchemy.sql.expression.Select.order_by
    "sqlalchemy.sql.expression.Select.order_by"), [`Query.order_by()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.order_by
    "sqlalchemy.orm.Query.order_by"), [`Select.group_by()`](../core/selectable.html#sqlalchemy.sql.expression.Select.group_by
    "sqlalchemy.sql.expression.Select.group_by"), and [`Query.group_by()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.group_by
    "sqlalchemy.orm.Query.group_by"), a string label or column name is still resolved
    into the corresponding expression construct, however if the resolution fails,
    a [`CompileError`](../core/exceptions.html#sqlalchemy.exc.CompileError "sqlalchemy.exc.CompileError")
    is raised, thus preventing raw SQL text from being rendered directly.
  prefs: []
  type: TYPE_NORMAL
- en: '[#4481](https://www.sqlalchemy.org/trac/ticket/4481)  ### “threadlocal” engine
    strategy deprecated'
  prefs: []
  type: TYPE_NORMAL
- en: The “threadlocal engine strategy” was added around SQLAlchemy 0.2, as a solution
    to the problem that the standard way of operating in SQLAlchemy 0.1, which can
    be summed up as “threadlocal everything”, was found to be lacking. In retrospect,
    it seems fairly absurd that by SQLAlchemy’s first releases which were in every
    regard “alpha”, that there was concern that too many users had already settled
    on the existing API to simply change it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The original usage model for SQLAlchemy looked like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'After a few months of real world use, it was clear that trying to pretend a
    “connection” or a “transaction” was a hidden implementation detail was a bad idea,
    particularly the moment someone needed to deal with more than one database connection
    at a time. So the usage paradigm we see today was introduced, minus the context
    managers since they didn’t yet exist in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: The above paradigm was what people needed, but since it was still kind of verbose
    (because no context managers), the old way of working was kept around as well
    and it became the threadlocal engine strategy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Today, working with Core is much more succinct, and even more succinct than
    the original pattern, thanks to context managers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: At this point, any remaining code that is still relying upon the “threadlocal”
    style will be encouraged via this deprecation to modernize - the feature should
    be removed totally by the next major series of SQLAlchemy, e.g. 1.4\. The connection
    pool parameter [`Pool.use_threadlocal`](../core/pooling.html#sqlalchemy.pool.Pool.params.use_threadlocal
    "sqlalchemy.pool.Pool") is also deprecated as it does not actually have any effect
    in most cases, as is the `Engine.contextual_connect()` method, which is normally
    synonymous with the [`Engine.connect()`](../core/connections.html#sqlalchemy.engine.Engine.connect
    "sqlalchemy.engine.Engine.connect") method except in the case where the threadlocal
    engine is in use.
  prefs: []
  type: TYPE_NORMAL
- en: '[#4393](https://www.sqlalchemy.org/trac/ticket/4393)  ### convert_unicode parameters
    deprecated'
  prefs: []
  type: TYPE_NORMAL
- en: The parameters [`String.convert_unicode`](../core/type_basics.html#sqlalchemy.types.String.params.convert_unicode
    "sqlalchemy.types.String") and [`create_engine.convert_unicode`](../core/engines.html#sqlalchemy.create_engine.params.convert_unicode
    "sqlalchemy.create_engine") are deprecated. The purpose of these parameters was
    to instruct SQLAlchemy to ensure that incoming Python Unicode objects under Python
    2 were encoded to bytestrings before passing to the database, and to expect bytestrings
    from the database to be converted back to Python Unicode objects. In the pre-Python
    3 era, this was an enormous ordeal to get right, as virtually all Python DBAPIs
    had no Unicode support enabled by default, and most had major issues with the
    Unicode extensions that they did provide. Eventually, SQLAlchemy added C extensions,
    one of the primary purposes of these extensions was to speed up the Unicode decode
    process within result sets.
  prefs: []
  type: TYPE_NORMAL
- en: Once Python 3 was introduced, DBAPIs began to start supporting Unicode more
    fully, and more importantly, by default. However, the conditions under which a
    particular DBAPI would or would not return Unicode data from a result, as well
    as accept Python Unicode values as parameters, remained extremely complicated.
    This was the beginning of the obsolescence of the “convert_unicode” flags, because
    they were no longer sufficient as a means of ensuring that encode/decode was occurring
    only where needed and not where it wasn’t needed. Instead, “convert_unicode” started
    to be automatically detected by dialects. Part of this can be seen in the “SELECT
    ‘test plain returns’” and “SELECT ‘test_unicode_returns’” SQL emitted by an engine
    the first time it connects; the dialect is testing that the current DBAPI with
    its current settings and backend database connection is returning Unicode by default
    or not.
  prefs: []
  type: TYPE_NORMAL
- en: The end result is that end-user use of the “convert_unicode” flags should no
    longer be needed in any circumstances, and if they are, the SQLAlchemy project
    needs to know what those cases are and why. Currently, hundreds of Unicode round
    trip tests pass across all major databases without the use of this flag so there
    is a fairly high level of confidence that they are no longer needed except in
    arguable non use cases such as accessing mis-encoded data from a legacy database,
    which would be better suited using custom types.
  prefs: []
  type: TYPE_NORMAL
- en: '[#4393](https://www.sqlalchemy.org/trac/ticket/4393)'
  prefs: []
  type: TYPE_NORMAL
- en: Dialect Improvements and Changes - PostgreSQL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '### Added basic reflection support for PostgreSQL partitioned tables'
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy can render the “PARTITION BY” sequence within a PostgreSQL CREATE
    TABLE statement using the flag `postgresql_partition_by`, added in version 1.2.6\.
    However, the `'p'` type was not part of the reflection queries used until now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given a schema such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: The two table names `'data_values'` and `'data_values_4_10'` will come back
    from [`Inspector.get_table_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_table_names
    "sqlalchemy.engine.reflection.Inspector.get_table_names") and additionally the
    columns will come back from `Inspector.get_columns('data_values')` as well as
    `Inspector.get_columns('data_values_4_10')`. This also extends to the use of `Table(...,
    autoload=True)` with these tables.
  prefs: []
  type: TYPE_NORMAL
- en: '[#4237](https://www.sqlalchemy.org/trac/ticket/4237)'
  prefs: []
  type: TYPE_NORMAL
- en: Dialect Improvements and Changes - MySQL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '### Protocol-level ping now used for pre-ping'
  prefs: []
  type: TYPE_NORMAL
- en: 'The MySQL dialects including mysqlclient, python-mysql, PyMySQL and mysql-connector-python
    now use the `connection.ping()` method for the pool pre-ping feature, described
    at [Disconnect Handling - Pessimistic](../core/pooling.html#pool-disconnects-pessimistic).
    This is a much more lightweight ping than the previous method of emitting “SELECT
    1” on the connection.  ### Control of parameter ordering within ON DUPLICATE KEY
    UPDATE'
  prefs: []
  type: TYPE_NORMAL
- en: 'The order of UPDATE parameters in the `ON DUPLICATE KEY UPDATE` clause can
    now be explicitly ordered by passing a list of 2-tuples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[INSERT…ON DUPLICATE KEY UPDATE (Upsert)](../dialects/mysql.html#mysql-insert-on-duplicate-key-update)'
  prefs: []
  type: TYPE_NORMAL
- en: Dialect Improvements and Changes - SQLite
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '### Support for SQLite JSON Added'
  prefs: []
  type: TYPE_NORMAL
- en: A new datatype [`JSON`](../dialects/sqlite.html#sqlalchemy.dialects.sqlite.JSON
    "sqlalchemy.dialects.sqlite.JSON") is added which implements SQLite’s json member
    access functions on behalf of the [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON") base datatype. The SQLite `JSON_EXTRACT` and `JSON_QUOTE`
    functions are used by the implementation to provide basic JSON support.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the name of the datatype itself as rendered in the database is the
    name “JSON”. This will create a SQLite datatype with “numeric” affinity, which
    normally should not be an issue except in the case of a JSON value that consists
    of single integer value. Nevertheless, following an example in SQLite’s own documentation
    at [https://www.sqlite.org/json1.html](https://www.sqlite.org/json1.html) the
    name JSON is being used for its familiarity.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3850](https://www.sqlalchemy.org/trac/ticket/3850)  ### Support for SQLite
    ON CONFLICT in constraints added'
  prefs: []
  type: TYPE_NORMAL
- en: 'SQLite supports a non-standard ON CONFLICT clause that may be specified for
    standalone constraints as well as some column-inline constraints such as NOT NULL.
    Support has been added for these clauses via the `sqlite_on_conflict` keyword
    added to objects like [`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint") as well as several [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") -specific variants:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'The above table would render in a CREATE TABLE statement as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[ON CONFLICT support for constraints](../dialects/sqlite.html#sqlite-on-conflict-ddl)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#4360](https://www.sqlalchemy.org/trac/ticket/4360)'
  prefs: []
  type: TYPE_NORMAL
- en: Dialect Improvements and Changes - Oracle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '### National char datatypes de-emphasized for generic unicode, re-enabled with
    option'
  prefs: []
  type: TYPE_NORMAL
- en: The [`Unicode`](../core/type_basics.html#sqlalchemy.types.Unicode "sqlalchemy.types.Unicode")
    and [`UnicodeText`](../core/type_basics.html#sqlalchemy.types.UnicodeText "sqlalchemy.types.UnicodeText")
    datatypes by default now correspond to the `VARCHAR2` and `CLOB` datatypes on
    Oracle, rather than `NVARCHAR2` and `NCLOB` (otherwise known as “national” character
    set types). This will be seen in behaviors such as that of how they render in
    `CREATE TABLE` statements, as well as that no type object will be passed to `setinputsizes()`
    when bound parameters using [`Unicode`](../core/type_basics.html#sqlalchemy.types.Unicode
    "sqlalchemy.types.Unicode") or [`UnicodeText`](../core/type_basics.html#sqlalchemy.types.UnicodeText
    "sqlalchemy.types.UnicodeText") are used; cx_Oracle handles the string value natively.
    This change is based on advice from cx_Oracle’s maintainer that the “national”
    datatypes in Oracle are largely obsolete and are not performant. They also interfere
    in some situations such as when applied to the format specifier for functions
    like `trunc()`.
  prefs: []
  type: TYPE_NORMAL
- en: The one case where `NVARCHAR2` and related types may be needed is for a database
    that is not using a Unicode-compliant character set. In this case, the flag `use_nchar_for_unicode`
    can be passed to [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") to re-enable the old behavior.
  prefs: []
  type: TYPE_NORMAL
- en: As always, using the [`NVARCHAR2`](../dialects/oracle.html#sqlalchemy.dialects.oracle.NVARCHAR2
    "sqlalchemy.dialects.oracle.NVARCHAR2") and [`NCLOB`](../dialects/oracle.html#sqlalchemy.dialects.oracle.NCLOB
    "sqlalchemy.dialects.oracle.NCLOB") datatypes explicitly will continue to make
    use of `NVARCHAR2` and `NCLOB`, including within DDL as well as when handling
    bound parameters with cx_Oracle’s `setinputsizes()`.
  prefs: []
  type: TYPE_NORMAL
- en: On the read side, automatic Unicode conversion under Python 2 has been added
    to CHAR/VARCHAR/CLOB result rows, to match the behavior of cx_Oracle under Python
    3\. In order to mitigate the performance hit that the cx_Oracle dialect had previously
    with this behavior under Python 2, SQLAlchemy’s very performant (when C extensions
    are built) native Unicode handlers are used under Python 2. The automatic unicode
    coercion can be disabled by setting the `coerce_to_unicode` flag to False. This
    flag now defaults to True and applies to all string data returned in a result
    set that isn’t explicitly under [`Unicode`](../core/type_basics.html#sqlalchemy.types.Unicode
    "sqlalchemy.types.Unicode") or Oracle’s NVARCHAR2/NCHAR/NCLOB datatypes.
  prefs: []
  type: TYPE_NORMAL
- en: '[#4242](https://www.sqlalchemy.org/trac/ticket/4242)  ### cx_Oracle connect
    arguments modernized, deprecated parameters removed'
  prefs: []
  type: TYPE_NORMAL
- en: 'A series of modernizations to the parameters accepted by the cx_oracle dialect
    as well as the URL string:'
  prefs: []
  type: TYPE_NORMAL
- en: The deprecated parameters `auto_setinputsizes`, `allow_twophase`, `exclude_setinputsizes`
    are removed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The value of the `threaded` parameter, which has always been defaulted to True
    for the SQLAlchemy dialect, is no longer generated by default. The SQLAlchemy
    [`Connection`](../core/connections.html#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    object is not considered to be thread-safe itself so there’s no need for this
    flag to be passed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s deprecated to pass `threaded` to [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") itself. To set the value of `threaded` to `True`,
    pass it to either the [`create_engine.connect_args`](../core/engines.html#sqlalchemy.create_engine.params.connect_args
    "sqlalchemy.create_engine") dictionary or use the query string e.g. `oracle+cx_oracle://...?threaded=true`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All parameters passed on the URL query string that are not otherwise specially
    consumed are now passed to the cx_Oracle.connect() function. A selection of these
    are also coerced either into cx_Oracle constants or booleans including `mode`,
    `purity`, `events`, and `threaded`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As was the case earlier, all cx_Oracle `.connect()` arguments are accepted via
    the [`create_engine.connect_args`](../core/engines.html#sqlalchemy.create_engine.params.connect_args
    "sqlalchemy.create_engine") dictionary, the documentation was inaccurate regarding
    this.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[#4369](https://www.sqlalchemy.org/trac/ticket/4369)'
  prefs: []
  type: TYPE_NORMAL
- en: Dialect Improvements and Changes - SQL Server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '### Support for pyodbc fast_executemany'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pyodbc’s recently added “fast_executemany” mode, available when using the Microsoft
    ODBC driver, is now an option for the pyodbc / mssql dialect. Pass it via [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Fast Executemany Mode](../dialects/mssql.html#mssql-pyodbc-fastexecutemany)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#4158](https://www.sqlalchemy.org/trac/ticket/4158)  ### New parameters to
    affect IDENTITY start and increment, use of Sequence deprecated'
  prefs: []
  type: TYPE_NORMAL
- en: 'SQL Server as of SQL Server 2012 now supports sequences with real `CREATE SEQUENCE`
    syntax. In [#4235](https://www.sqlalchemy.org/trac/ticket/4235), SQLAlchemy will
    add support for these using [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence") in the same way as for any other dialect. However,
    the current situation is that [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence") has been repurposed on SQL Server specifically in
    order to affect the “start” and “increment” parameters for the `IDENTITY` specification
    on a primary key column. In order to make the transition towards normal sequences
    being available as well, using [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence") will emit a deprecation warning throughout the 1.3
    series. In order to affect “start” and “increment”, use the new `mssql_identity_start`
    and `mssql_identity_increment` parameters on [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to emit `IDENTITY` on a non-primary key column, which is a little-used
    but valid SQL Server use case, use the [`Column.autoincrement`](../core/metadata.html#sqlalchemy.schema.Column.params.autoincrement
    "sqlalchemy.schema.Column") flag, setting it to `True` on the target column, `False`
    on any integer primary key column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Auto Increment Behavior / IDENTITY Columns](../dialects/mssql.html#mssql-identity)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#4362](https://www.sqlalchemy.org/trac/ticket/4362)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#4235](https://www.sqlalchemy.org/trac/ticket/4235)  ## Changed StatementError
    formatting (newlines and %s)'
  prefs: []
  type: TYPE_NORMAL
- en: Two changes are introduced to the string representation for `StatementError`.
    The “detail” and “SQL” portions of the string representation are now separated
    by newlines, and newlines that are present in the original SQL statement are maintained.
    The goal is to improve readability while still keeping the original error message
    on one line for logging purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that an error message that previously looked like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Will now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: The primary impact of this change is that consumers can no longer assume that
    a complete exception message is on a single line, however the original “error”
    portion that is generated from the DBAPI driver or SQLAlchemy internals will still
    be on the first line.
  prefs: []
  type: TYPE_NORMAL
- en: '[#4500](https://www.sqlalchemy.org/trac/ticket/4500)'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This guide introduces what’s new in SQLAlchemy version 1.3 and also documents
    changes which affect users migrating their applications from the 1.2 series of
    SQLAlchemy to 1.3.
  prefs: []
  type: TYPE_NORMAL
- en: Please carefully review the sections on behavioral changes for potentially backwards-incompatible
    changes in behavior.
  prefs: []
  type: TYPE_NORMAL
- en: General
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '### Deprecation warnings are emitted for all deprecated elements; new deprecations
    added'
  prefs: []
  type: TYPE_NORMAL
- en: Release 1.3 ensures that all behaviors and APIs that are deprecated, including
    all those that have been long listed as “legacy” for years, are emitting `DeprecationWarning`
    warnings. This includes when making use of parameters such as [`Session.weak_identity_map`](../orm/session_api.html#sqlalchemy.orm.Session.params.weak_identity_map
    "sqlalchemy.orm.Session") and classes such as `MapperExtension`. While all deprecations
    have been noted in the documentation, often they did not use a proper restructured
    text directive, or include in what version they were deprecated. Whether or not
    a particular API feature actually emitted a deprecation warning was not consistent.
    The general attitude was that most or all of these deprecated features were treated
    as long-term legacy features with no plans to remove them.
  prefs: []
  type: TYPE_NORMAL
- en: The change includes that all documented deprecations now use a proper restructured
    text directive in the documentation with a version number, the verbiage that the
    feature or use case will be removed in a future release is made explicit (e.g.,
    no more legacy forever use cases), and that use of any such feature or use case
    will definitely emit a `DeprecationWarning`, which in Python 3 as well as when
    using modern testing tools like Pytest are now made more explicit in the standard
    error stream. The goal is that these long deprecated features, going back as far
    as version 0.7 or 0.6, should start being removed entirely, rather than keeping
    them around as “legacy” features. Additionally, some major new deprecations are
    being added as of version 1.3. As SQLAlchemy has 14 years of real world use by
    thousands of developers, it’s possible to point to a single stream of use cases
    that blend together well, and to trim away features and patterns that work against
    this single way of working.
  prefs: []
  type: TYPE_NORMAL
- en: The larger context is that SQLAlchemy seeks to adjust to the coming Python 3-only
    world, as well as a type-annotated world, and towards this goal there are **tentative**
    plans for a major rework of SQLAlchemy which would hopefully greatly reduce the
    cognitive load of the API as well as perform a major pass over the great many
    differences in implementation and use between Core and ORM. As these two systems
    evolved dramatically after SQLAlchemy’s first release, in particular the ORM still
    retains lots of “bolted on” behaviors that keep the wall of separation between
    Core and ORM too high. By focusing the API ahead of time on a single pattern for
    each supported use case, the eventual job of migrating to a significantly altered
    API becomes simpler.
  prefs: []
  type: TYPE_NORMAL
- en: For the most major deprecations being added in 1.3, see the linked sections
    below.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[“threadlocal” engine strategy deprecated](#change-4393-threadlocal)'
  prefs: []
  type: TYPE_NORMAL
- en: '[convert_unicode parameters deprecated](#change-4393-convertunicode)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Relationship to AliasedClass replaces the need for non primary mappers](#change-4423)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#4393](https://www.sqlalchemy.org/trac/ticket/4393)  ### Deprecation warnings
    are emitted for all deprecated elements; new deprecations added'
  prefs: []
  type: TYPE_NORMAL
- en: Release 1.3 ensures that all behaviors and APIs that are deprecated, including
    all those that have been long listed as “legacy” for years, are emitting `DeprecationWarning`
    warnings. This includes when making use of parameters such as [`Session.weak_identity_map`](../orm/session_api.html#sqlalchemy.orm.Session.params.weak_identity_map
    "sqlalchemy.orm.Session") and classes such as `MapperExtension`. While all deprecations
    have been noted in the documentation, often they did not use a proper restructured
    text directive, or include in what version they were deprecated. Whether or not
    a particular API feature actually emitted a deprecation warning was not consistent.
    The general attitude was that most or all of these deprecated features were treated
    as long-term legacy features with no plans to remove them.
  prefs: []
  type: TYPE_NORMAL
- en: The change includes that all documented deprecations now use a proper restructured
    text directive in the documentation with a version number, the verbiage that the
    feature or use case will be removed in a future release is made explicit (e.g.,
    no more legacy forever use cases), and that use of any such feature or use case
    will definitely emit a `DeprecationWarning`, which in Python 3 as well as when
    using modern testing tools like Pytest are now made more explicit in the standard
    error stream. The goal is that these long deprecated features, going back as far
    as version 0.7 or 0.6, should start being removed entirely, rather than keeping
    them around as “legacy” features. Additionally, some major new deprecations are
    being added as of version 1.3. As SQLAlchemy has 14 years of real world use by
    thousands of developers, it’s possible to point to a single stream of use cases
    that blend together well, and to trim away features and patterns that work against
    this single way of working.
  prefs: []
  type: TYPE_NORMAL
- en: The larger context is that SQLAlchemy seeks to adjust to the coming Python 3-only
    world, as well as a type-annotated world, and towards this goal there are **tentative**
    plans for a major rework of SQLAlchemy which would hopefully greatly reduce the
    cognitive load of the API as well as perform a major pass over the great many
    differences in implementation and use between Core and ORM. As these two systems
    evolved dramatically after SQLAlchemy’s first release, in particular the ORM still
    retains lots of “bolted on” behaviors that keep the wall of separation between
    Core and ORM too high. By focusing the API ahead of time on a single pattern for
    each supported use case, the eventual job of migrating to a significantly altered
    API becomes simpler.
  prefs: []
  type: TYPE_NORMAL
- en: For the most major deprecations being added in 1.3, see the linked sections
    below.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[“threadlocal” engine strategy deprecated](#change-4393-threadlocal)'
  prefs: []
  type: TYPE_NORMAL
- en: '[convert_unicode parameters deprecated](#change-4393-convertunicode)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Relationship to AliasedClass replaces the need for non primary mappers](#change-4423)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#4393](https://www.sqlalchemy.org/trac/ticket/4393)'
  prefs: []
  type: TYPE_NORMAL
- en: New Features and Improvements - ORM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '### Relationship to AliasedClass replaces the need for non primary mappers'
  prefs: []
  type: TYPE_NORMAL
- en: The “non primary mapper” is a [`Mapper`](../orm/mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper") created in the [Imperative Mapping](../orm/mapping_styles.html#orm-imperative-mapping)
    style, which acts as an additional mapper against an already mapped class against
    a different kind of selectable. The non primary mapper has its roots in the 0.1,
    0.2 series of SQLAlchemy where it was anticipated that the [`Mapper`](../orm/mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper") object was to be the primary query construction interface,
    before the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    object existed.
  prefs: []
  type: TYPE_NORMAL
- en: With the advent of [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") and later the [`AliasedClass`](../orm/queryguide/api.html#sqlalchemy.orm.util.AliasedClass
    "sqlalchemy.orm.util.AliasedClass") construct, most use cases for the non primary
    mapper went away. This was a good thing since SQLAlchemy also moved away from
    “classical” mappings altogether around the 0.5 series in favor of the declarative
    system.
  prefs: []
  type: TYPE_NORMAL
- en: One use case remained around for non primary mappers when it was realized that
    some very hard-to-define [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") configurations could be made possible when a non-primary
    mapper with an alternative selectable was made as the mapping target, rather than
    trying to construct a [`relationship.primaryjoin`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.primaryjoin
    "sqlalchemy.orm.relationship") that encompassed all the complexity of a particular
    inter-object relationship.
  prefs: []
  type: TYPE_NORMAL
- en: As this use case became more popular, its limitations became apparent, including
    that the non primary mapper is difficult to configure against a selectable that
    adds new columns, that the mapper does not inherit the relationships of the original
    mapping, that relationships which are configured explicitly on the non primary
    mapper do not function well with loader options, and that the non primary mapper
    also doesn’t provide a fully functional namespace of column-based attributes which
    can be used in queries (which again, in the old 0.1 - 0.4 days, one would use
    [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    objects directly with the ORM).
  prefs: []
  type: TYPE_NORMAL
- en: The missing piece was to allow the [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") to refer directly to the [`AliasedClass`](../orm/queryguide/api.html#sqlalchemy.orm.util.AliasedClass
    "sqlalchemy.orm.util.AliasedClass"). The [`AliasedClass`](../orm/queryguide/api.html#sqlalchemy.orm.util.AliasedClass
    "sqlalchemy.orm.util.AliasedClass") already does everything we want the non primary
    mapper to do; it allows an existing mapped class to be loaded from an alternative
    selectable, it inherits all the attributes and relationships of the existing mapper,
    it works extremely well with loader options, and it provides a class-like object
    that can be mixed into queries just like the class itself. With this change, the
    recipes that were formerly for non primary mappers at [Configuring how Relationship
    Joins](../orm/join_conditions.html#relationship-configure-joins) are changed to
    aliased class.
  prefs: []
  type: TYPE_NORMAL
- en: 'At [Relationship to Aliased Class](../orm/join_conditions.html#relationship-aliased-class),
    the original non primary mapper looked like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: The properties were necessary in order to re-map the additional columns so that
    they did not conflict with the existing columns mapped to `B`, as well as it was
    necessary to define a new primary key.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the new approach, all of this verbosity goes away, and the additional
    columns are referenced directly when making the relationship:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: The non primary mapper is now deprecated with the eventual goal to be that classical
    mappings as a feature go away entirely. The Declarative API would become the single
    means of mapping which hopefully will allow internal improvements and simplifications,
    as well as a clearer documentation story.
  prefs: []
  type: TYPE_NORMAL
- en: '[#4423](https://www.sqlalchemy.org/trac/ticket/4423)  ### selectin loading
    no longer uses JOIN for simple one-to-many'
  prefs: []
  type: TYPE_NORMAL
- en: The “selectin” loading feature added in 1.2 introduced an extremely performant
    new way to eagerly load collections, in many cases much faster than that of “subquery”
    eager loading, as it does not rely upon restating the original SELECT query and
    instead uses a simple IN clause. However, the “selectin” load still relied upon
    rendering a JOIN between the parent and related tables, since it needs the parent
    primary key values in the row in order to match rows up. In 1.3, a new optimization
    is added which will omit this JOIN in the most common case of a simple one-to-many
    load, where the related row already contains the primary key of the parent row
    expressed in its foreign key columns. This again provides for a dramatic performance
    improvement as the ORM now can load large numbers of collections all in one query
    without using JOIN or subqueries at all.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given a mapping:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'In the 1.2 version of “selectin” loading, a load of A to B looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'With the new behavior, the load looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: The behavior is being released as automatic, using a similar heuristic that
    lazy loading uses in order to determine if related entities can be fetched directly
    from the identity map. However, as with most querying features, the feature’s
    implementation became more complex as a result of advanced scenarios regarding
    polymorphic loading. If problems are encountered, users should report a bug, however
    the change also includes a flag [`relationship.omit_join`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.omit_join
    "sqlalchemy.orm.relationship") which can be set to `False` on the [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") to disable the optimization.
  prefs: []
  type: TYPE_NORMAL
- en: '[#4340](https://www.sqlalchemy.org/trac/ticket/4340)  ### Improvement to the
    behavior of many-to-one query expressions'
  prefs: []
  type: TYPE_NORMAL
- en: 'When building a query that compares a many-to-one relationship to an object
    value, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: The above expression `Address.user == u1`, which ultimately compiles to a SQL
    expression normally based on the primary key columns of the `User` object like
    `"address.user_id = 5"`, uses a deferred callable in order to retrieve the value
    `5` within the bound expression until as late as possible. This is to suit both
    the use case where the `Address.user == u1` expression may be against a `User`
    object that isn’t flushed yet which relies upon a server- generated primary key
    value, as well as that the expression always returns the correct result even if
    the primary key value of `u1` has been changed since the expression was created.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, a side effect of this behavior is that if `u1` ends up being expired
    by the time the expression is evaluated, it results in an additional SELECT statement,
    and in the case that `u1` was also detached from the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), it would raise an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: The expiration / expunging of the object can occur implicitly when the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is committed and the `u1` instance falls out of scope,
    as the `Address.user == u1` expression does not strongly reference the object
    itself, only its [`InstanceState`](../orm/internals.html#sqlalchemy.orm.InstanceState
    "sqlalchemy.orm.InstanceState").
  prefs: []
  type: TYPE_NORMAL
- en: The fix is to allow the `Address.user == u1` expression to evaluate the value
    `5` based on attempting to retrieve or load the value normally at expression compilation
    time as it does now, but if the object is detached and has been expired, it is
    retrieved from a new mechanism upon the [`InstanceState`](../orm/internals.html#sqlalchemy.orm.InstanceState
    "sqlalchemy.orm.InstanceState") which will memoize the last known value for a
    particular attribute on that state when that attribute is expired. This mechanism
    is only enabled for a specific attribute / [`InstanceState`](../orm/internals.html#sqlalchemy.orm.InstanceState
    "sqlalchemy.orm.InstanceState") when needed by the expression feature to conserve
    performance / memory overhead.
  prefs: []
  type: TYPE_NORMAL
- en: Originally, simpler approaches such as evaluating the expression immediately
    with various arrangements for trying to load the value later if not present were
    attempted, however the difficult edge case is that of the value of a column attribute
    (typically a natural primary key) that is being changed. In order to ensure that
    an expression like `Address.user == u1` always returns the correct answer for
    the current state of `u1`, it will return the current database-persisted value
    for a persistent object, unexpiring via SELECT query if necessary, and for a detached
    object it will return the most recent known value, regardless of when the object
    was expired using a new feature within the [`InstanceState`](../orm/internals.html#sqlalchemy.orm.InstanceState
    "sqlalchemy.orm.InstanceState") that tracks the last known value of a column attribute
    whenever the attribute is to be expired.
  prefs: []
  type: TYPE_NORMAL
- en: Modern attribute API features are used to indicate specific error messages when
    the value cannot be evaluated, the two cases of which are when the column attributes
    have never been set, and when the object was already expired when the first evaluation
    was made and is now detached. In all cases, [`DetachedInstanceError`](../orm/exceptions.html#sqlalchemy.orm.exc.DetachedInstanceError
    "sqlalchemy.orm.exc.DetachedInstanceError") is no longer raised.
  prefs: []
  type: TYPE_NORMAL
- en: '[#4359](https://www.sqlalchemy.org/trac/ticket/4359)  ### Many-to-one replacement
    won’t raise for “raiseload” or detached for “old” object'
  prefs: []
  type: TYPE_NORMAL
- en: 'Given the case where a lazy load would proceed on a many-to-one relationship
    in order to load the “old” value, if the relationship does not specify the [`relationship.active_history`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.active_history
    "sqlalchemy.orm.relationship") flag, an assertion will not be raised for a detached
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: Above, when the `.user` attribute is replaced on the detached `a1` object, a
    [`DetachedInstanceError`](../orm/exceptions.html#sqlalchemy.orm.exc.DetachedInstanceError
    "sqlalchemy.orm.exc.DetachedInstanceError") would be raised as the attribute is
    attempting to retrieve the previous value of `.user` from the identity map. The
    change is that the operation now proceeds without the old value being loaded.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same change is also made to the `lazy="raise"` loader strategy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: Previously, the association of `a1.user` would invoke the “raiseload” exception
    as a result of the attribute attempting to retrieve the previous value. This assertion
    is now skipped in the case of loading the “old” value.
  prefs: []
  type: TYPE_NORMAL
- en: '[#4353](https://www.sqlalchemy.org/trac/ticket/4353)  ### “del” implemented
    for ORM attributes'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Python `del` operation was not really usable for mapped attributes, either
    scalar columns or object references. Support has been added for this to work correctly,
    where the `del` operation is roughly equivalent to setting the attribute to the
    `None` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[#4354](https://www.sqlalchemy.org/trac/ticket/4354)  ### info dictionary added
    to InstanceState'
  prefs: []
  type: TYPE_NORMAL
- en: 'Added the `.info` dictionary to the [`InstanceState`](../orm/internals.html#sqlalchemy.orm.InstanceState
    "sqlalchemy.orm.InstanceState") class, the object that comes from calling [`inspect()`](../core/inspection.html#sqlalchemy.inspect
    "sqlalchemy.inspect") on a mapped object. This allows custom recipes to add additional
    information about an object that will be carried along with that object’s full
    lifecycle in memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[#4257](https://www.sqlalchemy.org/trac/ticket/4257)  ### Horizontal Sharding
    extension supports bulk update and delete methods'
  prefs: []
  type: TYPE_NORMAL
- en: The [`ShardedQuery`](../orm/extensions/horizontal_shard.html#sqlalchemy.ext.horizontal_shard.ShardedQuery
    "sqlalchemy.ext.horizontal_shard.ShardedQuery") extension object supports the
    [`Query.update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.update "sqlalchemy.orm.Query.update")
    and [`Query.delete()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.delete
    "sqlalchemy.orm.Query.delete") bulk update/delete methods. The `query_chooser`
    callable is consulted when they are called in order to run the update/delete across
    multiple shards based on given criteria.
  prefs: []
  type: TYPE_NORMAL
- en: '[#4196](https://www.sqlalchemy.org/trac/ticket/4196)'
  prefs: []
  type: TYPE_NORMAL
- en: Association Proxy Improvements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While not for any particular reason, the Association Proxy extension had many
    improvements this cycle.
  prefs: []
  type: TYPE_NORMAL
- en: '#### Association proxy has new cascade_scalar_deletes flag'
  prefs: []
  type: TYPE_NORMAL
- en: 'Given a mapping as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'An assignment to `A.b` will generate an `AB` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'The `A.b` association is scalar, and includes a new flag [`AssociationProxy.cascade_scalar_deletes`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy.params.cascade_scalar_deletes
    "sqlalchemy.ext.associationproxy.AssociationProxy"). When set, setting `A.b` to
    `None` will remove `A.ab` as well. The default behavior remains that it leaves
    `a.ab` in place:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: While it at first seemed intuitive that this logic should just look at the “cascade”
    attribute of the existing relationship, it’s not clear from that alone if the
    proxied object should be removed, hence the behavior is made available as an explicit
    option.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, `del` now works for scalars in a similar manner as setting to
    `None`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[#4308](https://www.sqlalchemy.org/trac/ticket/4308)  #### AssociationProxy
    stores class-specific state on a per-class basis'
  prefs: []
  type: TYPE_NORMAL
- en: The [`AssociationProxy`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy
    "sqlalchemy.ext.associationproxy.AssociationProxy") object makes lots of decisions
    based on the parent mapped class it is associated with. While the [`AssociationProxy`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy
    "sqlalchemy.ext.associationproxy.AssociationProxy") historically began as a relatively
    simple ‘getter,’ it became apparent early on that it also needed to make decisions
    regarding the kind of attribute to which it refers—such as scalar or collection,
    mapped object or simple value, and so on. To achieve this, it needs to inspect
    the mapped attribute or other referring descriptor or attribute, as referenced
    from its parent class. However in Python descriptor mechanics, a descriptor only
    learns about its “parent” class when it is accessed in the context of that class,
    such as calling `MyClass.some_descriptor`, which calls the `__get__()` method
    which passes in the class. The [`AssociationProxy`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy
    "sqlalchemy.ext.associationproxy.AssociationProxy") object would therefore store
    state that is specific to that class, but only once this method were called; trying
    to inspect this state ahead of time without first accessing the [`AssociationProxy`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy
    "sqlalchemy.ext.associationproxy.AssociationProxy") as a descriptor would raise
    an error. Additionally, it would assume that the first class to be seen by `__get__()`
    would be the only parent class it needed to know about. This is despite the fact
    that if a particular class has inheriting subclasses, the association proxy is
    really working on behalf of more than one parent class even though it was not
    explicitly re-used. While even with this shortcoming, the association proxy would
    still get pretty far with its current behavior, it still leaves shortcomings in
    some cases as well as the complex problem of determining the best “owner” class.
  prefs: []
  type: TYPE_NORMAL
- en: These problems are now solved in that [`AssociationProxy`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy
    "sqlalchemy.ext.associationproxy.AssociationProxy") no longer modifies its own
    internal state when `__get__()` is called; instead, a new object is generated
    per-class known as [`AssociationProxyInstance`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxyInstance
    "sqlalchemy.ext.associationproxy.AssociationProxyInstance") which handles all
    the state specific to a particular mapped parent class (when the parent class
    is not mapped, no [`AssociationProxyInstance`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxyInstance
    "sqlalchemy.ext.associationproxy.AssociationProxyInstance") is generated). The
    concept of a single “owning class” for the association proxy, which was nonetheless
    improved in 1.1, has essentially been replaced with an approach where the AP now
    can treat any number of “owning” classes equally.
  prefs: []
  type: TYPE_NORMAL
- en: 'To accommodate for applications that want to inspect this state for an [`AssociationProxy`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy
    "sqlalchemy.ext.associationproxy.AssociationProxy") without necessarily calling
    `__get__()`, a new method [`AssociationProxy.for_class()`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy.for_class
    "sqlalchemy.ext.associationproxy.AssociationProxy.for_class") is added that provides
    direct access to a class-specific [`AssociationProxyInstance`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxyInstance
    "sqlalchemy.ext.associationproxy.AssociationProxyInstance"), demonstrated as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have the [`AssociationProxyInstance`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxyInstance
    "sqlalchemy.ext.associationproxy.AssociationProxyInstance") object, in the above
    example stored in the `proxy_state` variable, we can look at attributes specific
    to the `User.keywords` proxy, such as `target_class`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '[#3423](https://www.sqlalchemy.org/trac/ticket/3423)  #### AssociationProxy
    now provides standard column operators for a column-oriented target'
  prefs: []
  type: TYPE_NORMAL
- en: 'Given an [`AssociationProxy`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy
    "sqlalchemy.ext.associationproxy.AssociationProxy") where the target is a database
    column, and is **not** an object reference or another association proxy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'The `User.values` association proxy refers to the `Element.value` column. Standard
    column operations are now available, such as `like`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '`equals`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'When comparing to `None`, the `IS NULL` expression is augmented with a test
    that the related row does not exist at all; this is the same behavior as before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the [`ColumnOperators.contains()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.contains
    "sqlalchemy.sql.expression.ColumnOperators.contains") operator is in fact a string
    comparison operator; **this is a change in behavior** in that previously, the
    association proxy used `.contains` as a list containment operator only. With a
    column-oriented comparison, it now behaves like a “like”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: In order to test the `User.values` collection for simple membership of the value
    `"foo"`, the equals operator (e.g. `User.values == 'foo'`) should be used; this
    works in previous versions as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using an object-based association proxy with a collection, the behavior
    is as before, that of testing for collection membership, e.g. given a mapping:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'The `.contains()` method produces the same expression as before, testing the
    list of `User.elements` for the presence of an `Element` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: Overall, the change is enabled based on the architectural change that is part
    of [AssociationProxy stores class-specific state on a per-class basis](#change-3423);
    as the proxy now spins off additional state when an expression is generated, there
    is both an object-target and a column-target version of the [`AssociationProxyInstance`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxyInstance
    "sqlalchemy.ext.associationproxy.AssociationProxyInstance") class.
  prefs: []
  type: TYPE_NORMAL
- en: '[#4351](https://www.sqlalchemy.org/trac/ticket/4351)'
  prefs: []
  type: TYPE_NORMAL
- en: Association Proxy now Strong References the Parent Object
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The long-standing behavior of the association proxy collection maintaining only
    a weak reference to the parent object is reverted; the proxy will now maintain
    a strong reference to the parent for as long as the proxy collection itself is
    also in memory, eliminating the “stale association proxy” error. This change is
    being made on an experimental basis to see if any use cases arise where it causes
    side effects.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, given a mapping with association proxy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'Previously, if `a1` were deleted out of scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'Trying to iterate the `b_data` collection after `a1` is deleted from scope
    would raise the error `"stale association proxy, parent object has gone out of
    scope"`. This is because the association proxy needs to access the actual `a1.bs`
    collection in order to produce a view, and prior to this change it maintained
    only a weak reference to `a1`. In particular, users would frequently encounter
    this error when performing an inline operation such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: Above, because the `A` object would be garbage collected before the `b_data`
    collection were actually used.
  prefs: []
  type: TYPE_NORMAL
- en: 'The change is that the `b_data` collection is now maintaining a strong reference
    to the `a1` object, so that it remains present:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: This change introduces the side effect that if an application is passing around
    the collection as above, **the parent object won’t be garbage collected** until
    the collection is also discarded. As always, if `a1` is persistent inside a particular
    [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session"),
    it will remain part of that session’s state until it is garbage collected.
  prefs: []
  type: TYPE_NORMAL
- en: Note that this change may be revised if it leads to problems.
  prefs: []
  type: TYPE_NORMAL
- en: '[#4268](https://www.sqlalchemy.org/trac/ticket/4268)'
  prefs: []
  type: TYPE_NORMAL
- en: '#### Implemented bulk replace for sets, dicts with AssociationProxy'
  prefs: []
  type: TYPE_NORMAL
- en: 'Assignment of a set or dictionary to an association proxy collection should
    now work correctly, whereas before it would re-create association proxy members
    for existing keys, leading to the issue of potential flush failures due to the
    delete+insert of the same object it now should only create new association objects
    where appropriate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '[#2642](https://www.sqlalchemy.org/trac/ticket/2642)  ### Many-to-one backref
    checks for collection duplicates during remove operation'
  prefs: []
  type: TYPE_NORMAL
- en: 'When an ORM-mapped collection that existed as a Python sequence, typically
    a Python `list` as is the default for [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship"), contained duplicates, and the object were removed
    from one of its positions but not the other(s), a many-to-one backref would set
    its attribute to `None` even though the one-to-many side still represented the
    object as present. Even though one-to-many collections cannot have duplicates
    in the relational model, an ORM-mapped [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") that uses a sequence collection can have duplicates
    inside of it in memory, with the restriction that this duplicate state can neither
    be persisted nor retrieved from the database. In particular, having a duplicate
    temporarily present in the list is intrinsic to a Python “swap” operation. Given
    a standard one-to-many/many-to-one setup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'If we have an `A` object with two `B` members, and perform a swap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'During the above operation, interception of the standard Python `__setitem__`
    `__delitem__` methods delivers an interim state where the second `B()` object
    is present twice in the collection. When the `B()` object is removed from one
    of the positions, the `B.a` backref would set the reference to `None`, causing
    the link between the `A` and `B` object to be removed during the flush. The same
    issue can be demonstrated using plain duplicates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: The fix ensures that when the backref fires off, which is before the collection
    is mutated, the collection is checked for exactly one or zero instances of the
    target item before unsetting the many-to-one side, using a linear search which
    at the moment makes use of `list.search` and `list.__contains__`.
  prefs: []
  type: TYPE_NORMAL
- en: Originally it was thought that an event-based reference counting scheme would
    need to be used within the collection internals so that all duplicate instances
    could be tracked throughout the lifecycle of the collection, which would have
    added a performance/memory/complexity impact to all collection operations, including
    the very frequent operations of loading and appending. The approach that is taken
    instead limits the additional expense to the less common operations of collection
    removal and bulk replacement, and the observed overhead of the linear scan is
    negligible; linear scans of relationship-bound collections are already used within
    the unit of work as well as when a collection is bulk replaced.
  prefs: []
  type: TYPE_NORMAL
- en: '[#1103](https://www.sqlalchemy.org/trac/ticket/1103)  ### Relationship to AliasedClass
    replaces the need for non primary mappers'
  prefs: []
  type: TYPE_NORMAL
- en: The “non primary mapper” is a [`Mapper`](../orm/mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper") created in the [Imperative Mapping](../orm/mapping_styles.html#orm-imperative-mapping)
    style, which acts as an additional mapper against an already mapped class against
    a different kind of selectable. The non primary mapper has its roots in the 0.1,
    0.2 series of SQLAlchemy where it was anticipated that the [`Mapper`](../orm/mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper") object was to be the primary query construction interface,
    before the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    object existed.
  prefs: []
  type: TYPE_NORMAL
- en: With the advent of [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") and later the [`AliasedClass`](../orm/queryguide/api.html#sqlalchemy.orm.util.AliasedClass
    "sqlalchemy.orm.util.AliasedClass") construct, most use cases for the non primary
    mapper went away. This was a good thing since SQLAlchemy also moved away from
    “classical” mappings altogether around the 0.5 series in favor of the declarative
    system.
  prefs: []
  type: TYPE_NORMAL
- en: One use case remained around for non primary mappers when it was realized that
    some very hard-to-define [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") configurations could be made possible when a non-primary
    mapper with an alternative selectable was made as the mapping target, rather than
    trying to construct a [`relationship.primaryjoin`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.primaryjoin
    "sqlalchemy.orm.relationship") that encompassed all the complexity of a particular
    inter-object relationship.
  prefs: []
  type: TYPE_NORMAL
- en: As this use case became more popular, its limitations became apparent, including
    that the non primary mapper is difficult to configure against a selectable that
    adds new columns, that the mapper does not inherit the relationships of the original
    mapping, that relationships which are configured explicitly on the non primary
    mapper do not function well with loader options, and that the non primary mapper
    also doesn’t provide a fully functional namespace of column-based attributes which
    can be used in queries (which again, in the old 0.1 - 0.4 days, one would use
    [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    objects directly with the ORM).
  prefs: []
  type: TYPE_NORMAL
- en: The missing piece was to allow the [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") to refer directly to the [`AliasedClass`](../orm/queryguide/api.html#sqlalchemy.orm.util.AliasedClass
    "sqlalchemy.orm.util.AliasedClass"). The [`AliasedClass`](../orm/queryguide/api.html#sqlalchemy.orm.util.AliasedClass
    "sqlalchemy.orm.util.AliasedClass") already does everything we want the non primary
    mapper to do; it allows an existing mapped class to be loaded from an alternative
    selectable, it inherits all the attributes and relationships of the existing mapper,
    it works extremely well with loader options, and it provides a class-like object
    that can be mixed into queries just like the class itself. With this change, the
    recipes that were formerly for non primary mappers at [Configuring how Relationship
    Joins](../orm/join_conditions.html#relationship-configure-joins) are changed to
    aliased class.
  prefs: []
  type: TYPE_NORMAL
- en: 'At [Relationship to Aliased Class](../orm/join_conditions.html#relationship-aliased-class),
    the original non primary mapper looked like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: The properties were necessary in order to re-map the additional columns so that
    they did not conflict with the existing columns mapped to `B`, as well as it was
    necessary to define a new primary key.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the new approach, all of this verbosity goes away, and the additional
    columns are referenced directly when making the relationship:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: The non primary mapper is now deprecated with the eventual goal to be that classical
    mappings as a feature go away entirely. The Declarative API would become the single
    means of mapping which hopefully will allow internal improvements and simplifications,
    as well as a clearer documentation story.
  prefs: []
  type: TYPE_NORMAL
- en: '[#4423](https://www.sqlalchemy.org/trac/ticket/4423)'
  prefs: []
  type: TYPE_NORMAL
- en: '### selectin loading no longer uses JOIN for simple one-to-many'
  prefs: []
  type: TYPE_NORMAL
- en: The “selectin” loading feature added in 1.2 introduced an extremely performant
    new way to eagerly load collections, in many cases much faster than that of “subquery”
    eager loading, as it does not rely upon restating the original SELECT query and
    instead uses a simple IN clause. However, the “selectin” load still relied upon
    rendering a JOIN between the parent and related tables, since it needs the parent
    primary key values in the row in order to match rows up. In 1.3, a new optimization
    is added which will omit this JOIN in the most common case of a simple one-to-many
    load, where the related row already contains the primary key of the parent row
    expressed in its foreign key columns. This again provides for a dramatic performance
    improvement as the ORM now can load large numbers of collections all in one query
    without using JOIN or subqueries at all.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given a mapping:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'In the 1.2 version of “selectin” loading, a load of A to B looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'With the new behavior, the load looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: The behavior is being released as automatic, using a similar heuristic that
    lazy loading uses in order to determine if related entities can be fetched directly
    from the identity map. However, as with most querying features, the feature’s
    implementation became more complex as a result of advanced scenarios regarding
    polymorphic loading. If problems are encountered, users should report a bug, however
    the change also includes a flag [`relationship.omit_join`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.omit_join
    "sqlalchemy.orm.relationship") which can be set to `False` on the [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") to disable the optimization.
  prefs: []
  type: TYPE_NORMAL
- en: '[#4340](https://www.sqlalchemy.org/trac/ticket/4340)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Improvement to the behavior of many-to-one query expressions'
  prefs: []
  type: TYPE_NORMAL
- en: 'When building a query that compares a many-to-one relationship to an object
    value, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: The above expression `Address.user == u1`, which ultimately compiles to a SQL
    expression normally based on the primary key columns of the `User` object like
    `"address.user_id = 5"`, uses a deferred callable in order to retrieve the value
    `5` within the bound expression until as late as possible. This is to suit both
    the use case where the `Address.user == u1` expression may be against a `User`
    object that isn’t flushed yet which relies upon a server- generated primary key
    value, as well as that the expression always returns the correct result even if
    the primary key value of `u1` has been changed since the expression was created.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, a side effect of this behavior is that if `u1` ends up being expired
    by the time the expression is evaluated, it results in an additional SELECT statement,
    and in the case that `u1` was also detached from the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), it would raise an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: The expiration / expunging of the object can occur implicitly when the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is committed and the `u1` instance falls out of scope,
    as the `Address.user == u1` expression does not strongly reference the object
    itself, only its [`InstanceState`](../orm/internals.html#sqlalchemy.orm.InstanceState
    "sqlalchemy.orm.InstanceState").
  prefs: []
  type: TYPE_NORMAL
- en: The fix is to allow the `Address.user == u1` expression to evaluate the value
    `5` based on attempting to retrieve or load the value normally at expression compilation
    time as it does now, but if the object is detached and has been expired, it is
    retrieved from a new mechanism upon the [`InstanceState`](../orm/internals.html#sqlalchemy.orm.InstanceState
    "sqlalchemy.orm.InstanceState") which will memoize the last known value for a
    particular attribute on that state when that attribute is expired. This mechanism
    is only enabled for a specific attribute / [`InstanceState`](../orm/internals.html#sqlalchemy.orm.InstanceState
    "sqlalchemy.orm.InstanceState") when needed by the expression feature to conserve
    performance / memory overhead.
  prefs: []
  type: TYPE_NORMAL
- en: Originally, simpler approaches such as evaluating the expression immediately
    with various arrangements for trying to load the value later if not present were
    attempted, however the difficult edge case is that of the value of a column attribute
    (typically a natural primary key) that is being changed. In order to ensure that
    an expression like `Address.user == u1` always returns the correct answer for
    the current state of `u1`, it will return the current database-persisted value
    for a persistent object, unexpiring via SELECT query if necessary, and for a detached
    object it will return the most recent known value, regardless of when the object
    was expired using a new feature within the [`InstanceState`](../orm/internals.html#sqlalchemy.orm.InstanceState
    "sqlalchemy.orm.InstanceState") that tracks the last known value of a column attribute
    whenever the attribute is to be expired.
  prefs: []
  type: TYPE_NORMAL
- en: Modern attribute API features are used to indicate specific error messages when
    the value cannot be evaluated, the two cases of which are when the column attributes
    have never been set, and when the object was already expired when the first evaluation
    was made and is now detached. In all cases, [`DetachedInstanceError`](../orm/exceptions.html#sqlalchemy.orm.exc.DetachedInstanceError
    "sqlalchemy.orm.exc.DetachedInstanceError") is no longer raised.
  prefs: []
  type: TYPE_NORMAL
- en: '[#4359](https://www.sqlalchemy.org/trac/ticket/4359)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Many-to-one replacement won’t raise for “raiseload” or detached for “old”
    object'
  prefs: []
  type: TYPE_NORMAL
- en: 'Given the case where a lazy load would proceed on a many-to-one relationship
    in order to load the “old” value, if the relationship does not specify the [`relationship.active_history`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.active_history
    "sqlalchemy.orm.relationship") flag, an assertion will not be raised for a detached
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: Above, when the `.user` attribute is replaced on the detached `a1` object, a
    [`DetachedInstanceError`](../orm/exceptions.html#sqlalchemy.orm.exc.DetachedInstanceError
    "sqlalchemy.orm.exc.DetachedInstanceError") would be raised as the attribute is
    attempting to retrieve the previous value of `.user` from the identity map. The
    change is that the operation now proceeds without the old value being loaded.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same change is also made to the `lazy="raise"` loader strategy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: Previously, the association of `a1.user` would invoke the “raiseload” exception
    as a result of the attribute attempting to retrieve the previous value. This assertion
    is now skipped in the case of loading the “old” value.
  prefs: []
  type: TYPE_NORMAL
- en: '[#4353](https://www.sqlalchemy.org/trac/ticket/4353)'
  prefs: []
  type: TYPE_NORMAL
- en: '### “del” implemented for ORM attributes'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Python `del` operation was not really usable for mapped attributes, either
    scalar columns or object references. Support has been added for this to work correctly,
    where the `del` operation is roughly equivalent to setting the attribute to the
    `None` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: '[#4354](https://www.sqlalchemy.org/trac/ticket/4354)'
  prefs: []
  type: TYPE_NORMAL
- en: '### info dictionary added to InstanceState'
  prefs: []
  type: TYPE_NORMAL
- en: 'Added the `.info` dictionary to the [`InstanceState`](../orm/internals.html#sqlalchemy.orm.InstanceState
    "sqlalchemy.orm.InstanceState") class, the object that comes from calling [`inspect()`](../core/inspection.html#sqlalchemy.inspect
    "sqlalchemy.inspect") on a mapped object. This allows custom recipes to add additional
    information about an object that will be carried along with that object’s full
    lifecycle in memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: '[#4257](https://www.sqlalchemy.org/trac/ticket/4257)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Horizontal Sharding extension supports bulk update and delete methods'
  prefs: []
  type: TYPE_NORMAL
- en: The [`ShardedQuery`](../orm/extensions/horizontal_shard.html#sqlalchemy.ext.horizontal_shard.ShardedQuery
    "sqlalchemy.ext.horizontal_shard.ShardedQuery") extension object supports the
    [`Query.update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.update "sqlalchemy.orm.Query.update")
    and [`Query.delete()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.delete
    "sqlalchemy.orm.Query.delete") bulk update/delete methods. The `query_chooser`
    callable is consulted when they are called in order to run the update/delete across
    multiple shards based on given criteria.
  prefs: []
  type: TYPE_NORMAL
- en: '[#4196](https://www.sqlalchemy.org/trac/ticket/4196)'
  prefs: []
  type: TYPE_NORMAL
- en: Association Proxy Improvements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While not for any particular reason, the Association Proxy extension had many
    improvements this cycle.
  prefs: []
  type: TYPE_NORMAL
- en: '#### Association proxy has new cascade_scalar_deletes flag'
  prefs: []
  type: TYPE_NORMAL
- en: 'Given a mapping as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'An assignment to `A.b` will generate an `AB` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: 'The `A.b` association is scalar, and includes a new flag [`AssociationProxy.cascade_scalar_deletes`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy.params.cascade_scalar_deletes
    "sqlalchemy.ext.associationproxy.AssociationProxy"). When set, setting `A.b` to
    `None` will remove `A.ab` as well. The default behavior remains that it leaves
    `a.ab` in place:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: While it at first seemed intuitive that this logic should just look at the “cascade”
    attribute of the existing relationship, it’s not clear from that alone if the
    proxied object should be removed, hence the behavior is made available as an explicit
    option.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, `del` now works for scalars in a similar manner as setting to
    `None`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: '[#4308](https://www.sqlalchemy.org/trac/ticket/4308)  #### AssociationProxy
    stores class-specific state on a per-class basis'
  prefs: []
  type: TYPE_NORMAL
- en: The [`AssociationProxy`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy
    "sqlalchemy.ext.associationproxy.AssociationProxy") object makes lots of decisions
    based on the parent mapped class it is associated with. While the [`AssociationProxy`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy
    "sqlalchemy.ext.associationproxy.AssociationProxy") historically began as a relatively
    simple ‘getter,’ it became apparent early on that it also needed to make decisions
    regarding the kind of attribute to which it refers—such as scalar or collection,
    mapped object or simple value, and so on. To achieve this, it needs to inspect
    the mapped attribute or other referring descriptor or attribute, as referenced
    from its parent class. However in Python descriptor mechanics, a descriptor only
    learns about its “parent” class when it is accessed in the context of that class,
    such as calling `MyClass.some_descriptor`, which calls the `__get__()` method
    which passes in the class. The [`AssociationProxy`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy
    "sqlalchemy.ext.associationproxy.AssociationProxy") object would therefore store
    state that is specific to that class, but only once this method were called; trying
    to inspect this state ahead of time without first accessing the [`AssociationProxy`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy
    "sqlalchemy.ext.associationproxy.AssociationProxy") as a descriptor would raise
    an error. Additionally, it would assume that the first class to be seen by `__get__()`
    would be the only parent class it needed to know about. This is despite the fact
    that if a particular class has inheriting subclasses, the association proxy is
    really working on behalf of more than one parent class even though it was not
    explicitly re-used. While even with this shortcoming, the association proxy would
    still get pretty far with its current behavior, it still leaves shortcomings in
    some cases as well as the complex problem of determining the best “owner” class.
  prefs: []
  type: TYPE_NORMAL
- en: These problems are now solved in that [`AssociationProxy`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy
    "sqlalchemy.ext.associationproxy.AssociationProxy") no longer modifies its own
    internal state when `__get__()` is called; instead, a new object is generated
    per-class known as [`AssociationProxyInstance`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxyInstance
    "sqlalchemy.ext.associationproxy.AssociationProxyInstance") which handles all
    the state specific to a particular mapped parent class (when the parent class
    is not mapped, no [`AssociationProxyInstance`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxyInstance
    "sqlalchemy.ext.associationproxy.AssociationProxyInstance") is generated). The
    concept of a single “owning class” for the association proxy, which was nonetheless
    improved in 1.1, has essentially been replaced with an approach where the AP now
    can treat any number of “owning” classes equally.
  prefs: []
  type: TYPE_NORMAL
- en: 'To accommodate for applications that want to inspect this state for an [`AssociationProxy`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy
    "sqlalchemy.ext.associationproxy.AssociationProxy") without necessarily calling
    `__get__()`, a new method [`AssociationProxy.for_class()`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy.for_class
    "sqlalchemy.ext.associationproxy.AssociationProxy.for_class") is added that provides
    direct access to a class-specific [`AssociationProxyInstance`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxyInstance
    "sqlalchemy.ext.associationproxy.AssociationProxyInstance"), demonstrated as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have the [`AssociationProxyInstance`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxyInstance
    "sqlalchemy.ext.associationproxy.AssociationProxyInstance") object, in the above
    example stored in the `proxy_state` variable, we can look at attributes specific
    to the `User.keywords` proxy, such as `target_class`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: '[#3423](https://www.sqlalchemy.org/trac/ticket/3423)  #### AssociationProxy
    now provides standard column operators for a column-oriented target'
  prefs: []
  type: TYPE_NORMAL
- en: 'Given an [`AssociationProxy`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy
    "sqlalchemy.ext.associationproxy.AssociationProxy") where the target is a database
    column, and is **not** an object reference or another association proxy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'The `User.values` association proxy refers to the `Element.value` column. Standard
    column operations are now available, such as `like`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: '`equals`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'When comparing to `None`, the `IS NULL` expression is augmented with a test
    that the related row does not exist at all; this is the same behavior as before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the [`ColumnOperators.contains()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.contains
    "sqlalchemy.sql.expression.ColumnOperators.contains") operator is in fact a string
    comparison operator; **this is a change in behavior** in that previously, the
    association proxy used `.contains` as a list containment operator only. With a
    column-oriented comparison, it now behaves like a “like”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: In order to test the `User.values` collection for simple membership of the value
    `"foo"`, the equals operator (e.g. `User.values == 'foo'`) should be used; this
    works in previous versions as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using an object-based association proxy with a collection, the behavior
    is as before, that of testing for collection membership, e.g. given a mapping:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'The `.contains()` method produces the same expression as before, testing the
    list of `User.elements` for the presence of an `Element` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: Overall, the change is enabled based on the architectural change that is part
    of [AssociationProxy stores class-specific state on a per-class basis](#change-3423);
    as the proxy now spins off additional state when an expression is generated, there
    is both an object-target and a column-target version of the [`AssociationProxyInstance`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxyInstance
    "sqlalchemy.ext.associationproxy.AssociationProxyInstance") class.
  prefs: []
  type: TYPE_NORMAL
- en: '[#4351](https://www.sqlalchemy.org/trac/ticket/4351)'
  prefs: []
  type: TYPE_NORMAL
- en: Association Proxy now Strong References the Parent Object
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The long-standing behavior of the association proxy collection maintaining only
    a weak reference to the parent object is reverted; the proxy will now maintain
    a strong reference to the parent for as long as the proxy collection itself is
    also in memory, eliminating the “stale association proxy” error. This change is
    being made on an experimental basis to see if any use cases arise where it causes
    side effects.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, given a mapping with association proxy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: 'Previously, if `a1` were deleted out of scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: 'Trying to iterate the `b_data` collection after `a1` is deleted from scope
    would raise the error `"stale association proxy, parent object has gone out of
    scope"`. This is because the association proxy needs to access the actual `a1.bs`
    collection in order to produce a view, and prior to this change it maintained
    only a weak reference to `a1`. In particular, users would frequently encounter
    this error when performing an inline operation such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: Above, because the `A` object would be garbage collected before the `b_data`
    collection were actually used.
  prefs: []
  type: TYPE_NORMAL
- en: 'The change is that the `b_data` collection is now maintaining a strong reference
    to the `a1` object, so that it remains present:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: This change introduces the side effect that if an application is passing around
    the collection as above, **the parent object won’t be garbage collected** until
    the collection is also discarded. As always, if `a1` is persistent inside a particular
    [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session"),
    it will remain part of that session’s state until it is garbage collected.
  prefs: []
  type: TYPE_NORMAL
- en: Note that this change may be revised if it leads to problems.
  prefs: []
  type: TYPE_NORMAL
- en: '[#4268](https://www.sqlalchemy.org/trac/ticket/4268)'
  prefs: []
  type: TYPE_NORMAL
- en: '#### Implemented bulk replace for sets, dicts with AssociationProxy'
  prefs: []
  type: TYPE_NORMAL
- en: 'Assignment of a set or dictionary to an association proxy collection should
    now work correctly, whereas before it would re-create association proxy members
    for existing keys, leading to the issue of potential flush failures due to the
    delete+insert of the same object it now should only create new association objects
    where appropriate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: '[#2642](https://www.sqlalchemy.org/trac/ticket/2642)  #### Association proxy
    has new cascade_scalar_deletes flag'
  prefs: []
  type: TYPE_NORMAL
- en: 'Given a mapping as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: 'An assignment to `A.b` will generate an `AB` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: 'The `A.b` association is scalar, and includes a new flag [`AssociationProxy.cascade_scalar_deletes`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy.params.cascade_scalar_deletes
    "sqlalchemy.ext.associationproxy.AssociationProxy"). When set, setting `A.b` to
    `None` will remove `A.ab` as well. The default behavior remains that it leaves
    `a.ab` in place:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: While it at first seemed intuitive that this logic should just look at the “cascade”
    attribute of the existing relationship, it’s not clear from that alone if the
    proxied object should be removed, hence the behavior is made available as an explicit
    option.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, `del` now works for scalars in a similar manner as setting to
    `None`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: '[#4308](https://www.sqlalchemy.org/trac/ticket/4308)'
  prefs: []
  type: TYPE_NORMAL
- en: '#### AssociationProxy stores class-specific state on a per-class basis'
  prefs: []
  type: TYPE_NORMAL
- en: The [`AssociationProxy`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy
    "sqlalchemy.ext.associationproxy.AssociationProxy") object makes lots of decisions
    based on the parent mapped class it is associated with. While the [`AssociationProxy`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy
    "sqlalchemy.ext.associationproxy.AssociationProxy") historically began as a relatively
    simple ‘getter,’ it became apparent early on that it also needed to make decisions
    regarding the kind of attribute to which it refers—such as scalar or collection,
    mapped object or simple value, and so on. To achieve this, it needs to inspect
    the mapped attribute or other referring descriptor or attribute, as referenced
    from its parent class. However in Python descriptor mechanics, a descriptor only
    learns about its “parent” class when it is accessed in the context of that class,
    such as calling `MyClass.some_descriptor`, which calls the `__get__()` method
    which passes in the class. The [`AssociationProxy`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy
    "sqlalchemy.ext.associationproxy.AssociationProxy") object would therefore store
    state that is specific to that class, but only once this method were called; trying
    to inspect this state ahead of time without first accessing the [`AssociationProxy`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy
    "sqlalchemy.ext.associationproxy.AssociationProxy") as a descriptor would raise
    an error. Additionally, it would assume that the first class to be seen by `__get__()`
    would be the only parent class it needed to know about. This is despite the fact
    that if a particular class has inheriting subclasses, the association proxy is
    really working on behalf of more than one parent class even though it was not
    explicitly re-used. While even with this shortcoming, the association proxy would
    still get pretty far with its current behavior, it still leaves shortcomings in
    some cases as well as the complex problem of determining the best “owner” class.
  prefs: []
  type: TYPE_NORMAL
- en: These problems are now solved in that [`AssociationProxy`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy
    "sqlalchemy.ext.associationproxy.AssociationProxy") no longer modifies its own
    internal state when `__get__()` is called; instead, a new object is generated
    per-class known as [`AssociationProxyInstance`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxyInstance
    "sqlalchemy.ext.associationproxy.AssociationProxyInstance") which handles all
    the state specific to a particular mapped parent class (when the parent class
    is not mapped, no [`AssociationProxyInstance`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxyInstance
    "sqlalchemy.ext.associationproxy.AssociationProxyInstance") is generated). The
    concept of a single “owning class” for the association proxy, which was nonetheless
    improved in 1.1, has essentially been replaced with an approach where the AP now
    can treat any number of “owning” classes equally.
  prefs: []
  type: TYPE_NORMAL
- en: 'To accommodate for applications that want to inspect this state for an [`AssociationProxy`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy
    "sqlalchemy.ext.associationproxy.AssociationProxy") without necessarily calling
    `__get__()`, a new method [`AssociationProxy.for_class()`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy.for_class
    "sqlalchemy.ext.associationproxy.AssociationProxy.for_class") is added that provides
    direct access to a class-specific [`AssociationProxyInstance`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxyInstance
    "sqlalchemy.ext.associationproxy.AssociationProxyInstance"), demonstrated as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have the [`AssociationProxyInstance`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxyInstance
    "sqlalchemy.ext.associationproxy.AssociationProxyInstance") object, in the above
    example stored in the `proxy_state` variable, we can look at attributes specific
    to the `User.keywords` proxy, such as `target_class`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: '[#3423](https://www.sqlalchemy.org/trac/ticket/3423)'
  prefs: []
  type: TYPE_NORMAL
- en: '#### AssociationProxy now provides standard column operators for a column-oriented
    target'
  prefs: []
  type: TYPE_NORMAL
- en: 'Given an [`AssociationProxy`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy
    "sqlalchemy.ext.associationproxy.AssociationProxy") where the target is a database
    column, and is **not** an object reference or another association proxy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: 'The `User.values` association proxy refers to the `Element.value` column. Standard
    column operations are now available, such as `like`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: '`equals`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: 'When comparing to `None`, the `IS NULL` expression is augmented with a test
    that the related row does not exist at all; this is the same behavior as before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the [`ColumnOperators.contains()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.contains
    "sqlalchemy.sql.expression.ColumnOperators.contains") operator is in fact a string
    comparison operator; **this is a change in behavior** in that previously, the
    association proxy used `.contains` as a list containment operator only. With a
    column-oriented comparison, it now behaves like a “like”:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: In order to test the `User.values` collection for simple membership of the value
    `"foo"`, the equals operator (e.g. `User.values == 'foo'`) should be used; this
    works in previous versions as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using an object-based association proxy with a collection, the behavior
    is as before, that of testing for collection membership, e.g. given a mapping:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: 'The `.contains()` method produces the same expression as before, testing the
    list of `User.elements` for the presence of an `Element` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: Overall, the change is enabled based on the architectural change that is part
    of [AssociationProxy stores class-specific state on a per-class basis](#change-3423);
    as the proxy now spins off additional state when an expression is generated, there
    is both an object-target and a column-target version of the [`AssociationProxyInstance`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxyInstance
    "sqlalchemy.ext.associationproxy.AssociationProxyInstance") class.
  prefs: []
  type: TYPE_NORMAL
- en: '[#4351](https://www.sqlalchemy.org/trac/ticket/4351)'
  prefs: []
  type: TYPE_NORMAL
- en: Association Proxy now Strong References the Parent Object
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The long-standing behavior of the association proxy collection maintaining only
    a weak reference to the parent object is reverted; the proxy will now maintain
    a strong reference to the parent for as long as the proxy collection itself is
    also in memory, eliminating the “stale association proxy” error. This change is
    being made on an experimental basis to see if any use cases arise where it causes
    side effects.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, given a mapping with association proxy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: 'Previously, if `a1` were deleted out of scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: 'Trying to iterate the `b_data` collection after `a1` is deleted from scope
    would raise the error `"stale association proxy, parent object has gone out of
    scope"`. This is because the association proxy needs to access the actual `a1.bs`
    collection in order to produce a view, and prior to this change it maintained
    only a weak reference to `a1`. In particular, users would frequently encounter
    this error when performing an inline operation such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: Above, because the `A` object would be garbage collected before the `b_data`
    collection were actually used.
  prefs: []
  type: TYPE_NORMAL
- en: 'The change is that the `b_data` collection is now maintaining a strong reference
    to the `a1` object, so that it remains present:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: This change introduces the side effect that if an application is passing around
    the collection as above, **the parent object won’t be garbage collected** until
    the collection is also discarded. As always, if `a1` is persistent inside a particular
    [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session"),
    it will remain part of that session’s state until it is garbage collected.
  prefs: []
  type: TYPE_NORMAL
- en: Note that this change may be revised if it leads to problems.
  prefs: []
  type: TYPE_NORMAL
- en: '[#4268](https://www.sqlalchemy.org/trac/ticket/4268)'
  prefs: []
  type: TYPE_NORMAL
- en: '#### Implemented bulk replace for sets, dicts with AssociationProxy'
  prefs: []
  type: TYPE_NORMAL
- en: 'Assignment of a set or dictionary to an association proxy collection should
    now work correctly, whereas before it would re-create association proxy members
    for existing keys, leading to the issue of potential flush failures due to the
    delete+insert of the same object it now should only create new association objects
    where appropriate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: '[#2642](https://www.sqlalchemy.org/trac/ticket/2642)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Many-to-one backref checks for collection duplicates during remove operation'
  prefs: []
  type: TYPE_NORMAL
- en: 'When an ORM-mapped collection that existed as a Python sequence, typically
    a Python `list` as is the default for [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship"), contained duplicates, and the object were removed
    from one of its positions but not the other(s), a many-to-one backref would set
    its attribute to `None` even though the one-to-many side still represented the
    object as present. Even though one-to-many collections cannot have duplicates
    in the relational model, an ORM-mapped [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") that uses a sequence collection can have duplicates
    inside of it in memory, with the restriction that this duplicate state can neither
    be persisted nor retrieved from the database. In particular, having a duplicate
    temporarily present in the list is intrinsic to a Python “swap” operation. Given
    a standard one-to-many/many-to-one setup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: 'If we have an `A` object with two `B` members, and perform a swap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: 'During the above operation, interception of the standard Python `__setitem__`
    `__delitem__` methods delivers an interim state where the second `B()` object
    is present twice in the collection. When the `B()` object is removed from one
    of the positions, the `B.a` backref would set the reference to `None`, causing
    the link between the `A` and `B` object to be removed during the flush. The same
    issue can be demonstrated using plain duplicates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: The fix ensures that when the backref fires off, which is before the collection
    is mutated, the collection is checked for exactly one or zero instances of the
    target item before unsetting the many-to-one side, using a linear search which
    at the moment makes use of `list.search` and `list.__contains__`.
  prefs: []
  type: TYPE_NORMAL
- en: Originally it was thought that an event-based reference counting scheme would
    need to be used within the collection internals so that all duplicate instances
    could be tracked throughout the lifecycle of the collection, which would have
    added a performance/memory/complexity impact to all collection operations, including
    the very frequent operations of loading and appending. The approach that is taken
    instead limits the additional expense to the less common operations of collection
    removal and bulk replacement, and the observed overhead of the linear scan is
    negligible; linear scans of relationship-bound collections are already used within
    the unit of work as well as when a collection is bulk replaced.
  prefs: []
  type: TYPE_NORMAL
- en: '[#1103](https://www.sqlalchemy.org/trac/ticket/1103)'
  prefs: []
  type: TYPE_NORMAL
- en: Key Behavioral Changes - ORM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '### Query.join() handles ambiguity in deciding the “left” side more explicitly'
  prefs: []
  type: TYPE_NORMAL
- en: 'Historically, given a query like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: 'given the standard tutorial mappings, the query would produce a FROM clause
    as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: 'That is, the JOIN would implicitly be against the first entity that matches.
    The new behavior is that an exception requests that this ambiguity be resolved:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: 'The solution is to provide an ON clause, either as an expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: 'Or to use the relationship attribute, if available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: 'The change includes that a join can now correctly link to a FROM clause that
    is not the first element in the list if the join is otherwise non-ambiguous:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: 'Prior to this enhancement, the above query would raise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the query works fine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: Overall the change is directly towards Python’s “explicit is better than implicit”
    philosophy.
  prefs: []
  type: TYPE_NORMAL
- en: '[#4365](https://www.sqlalchemy.org/trac/ticket/4365)  ### FOR UPDATE clause
    is rendered within the joined eager load subquery as well as outside'
  prefs: []
  type: TYPE_NORMAL
- en: This change applies specifically to the use of the [`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload") loading strategy in conjunction with a row limited
    query, e.g. using [`Query.first()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.first
    "sqlalchemy.orm.Query.first") or [`Query.limit()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.limit
    "sqlalchemy.orm.Query.limit"), as well as with use of the [`Query.with_for_update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.with_for_update
    "sqlalchemy.orm.Query.with_for_update") method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given a query as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: 'The [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    object renders a SELECT of the following form when joined eager loading is combined
    with LIMIT:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: 'This is so that the limit of rows takes place for the primary entity without
    affecting the joined eager load of related items. When the above query is combined
    with “SELECT..FOR UPDATE”, the behavior has been this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: 'However, MySQL due to [https://bugs.mysql.com/bug.php?id=90693](https://bugs.mysql.com/bug.php?id=90693)
    does not lock the rows inside the subquery, unlike that of PostgreSQL and other
    databases. So the above query now renders as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: On the Oracle dialect, the inner “FOR UPDATE” is not rendered as Oracle does
    not support this syntax and the dialect skips any “FOR UPDATE” that is against
    a subquery; it isn’t necessary in any case since Oracle, like PostgreSQL, correctly
    locks all elements of the returned row.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using the [`Query.with_for_update.of`](../orm/queryguide/query.html#sqlalchemy.orm.Query.with_for_update.params.of
    "sqlalchemy.orm.Query.with_for_update") modifier, typically on PostgreSQL, the
    outer “FOR UPDATE” is omitted, and the OF is now rendered on the inside; previously,
    the OF target would not be converted to accommodate for the subquery correctly.
    So given:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: 'The query would now render as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: The above form should be helpful on PostgreSQL additionally since PostgreSQL
    will not allow the FOR UPDATE clause to be rendered after the LEFT OUTER JOIN
    target.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, FOR UPDATE remains highly specific to the target database in use and
    can’t easily be generalized for more complex queries.
  prefs: []
  type: TYPE_NORMAL
- en: '[#4246](https://www.sqlalchemy.org/trac/ticket/4246)  ### passive_deletes=’all’
    will leave FK unchanged for object removed from collection'
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`relationship.passive_deletes`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.passive_deletes
    "sqlalchemy.orm.relationship") option accepts the value `"all"` to indicate that
    no foreign key attributes should be modified when the object is flushed, even
    if the relationship’s collection / reference has been removed. Previously, this
    did not take place for one-to-many, or one-to-one relationships, in the following
    situation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: The fix now includes that `address.user_id` is left unchanged as per `passive_deletes="all"`.
    This kind of thing is useful for building custom “version table” schemes and such
    where rows are archived instead of deleted.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3844](https://www.sqlalchemy.org/trac/ticket/3844)  ### Query.join() handles
    ambiguity in deciding the “left” side more explicitly'
  prefs: []
  type: TYPE_NORMAL
- en: 'Historically, given a query like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: 'given the standard tutorial mappings, the query would produce a FROM clause
    as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: 'That is, the JOIN would implicitly be against the first entity that matches.
    The new behavior is that an exception requests that this ambiguity be resolved:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: 'The solution is to provide an ON clause, either as an expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: 'Or to use the relationship attribute, if available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: 'The change includes that a join can now correctly link to a FROM clause that
    is not the first element in the list if the join is otherwise non-ambiguous:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: 'Prior to this enhancement, the above query would raise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the query works fine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: Overall the change is directly towards Python’s “explicit is better than implicit”
    philosophy.
  prefs: []
  type: TYPE_NORMAL
- en: '[#4365](https://www.sqlalchemy.org/trac/ticket/4365)'
  prefs: []
  type: TYPE_NORMAL
- en: '### FOR UPDATE clause is rendered within the joined eager load subquery as
    well as outside'
  prefs: []
  type: TYPE_NORMAL
- en: This change applies specifically to the use of the [`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload") loading strategy in conjunction with a row limited
    query, e.g. using [`Query.first()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.first
    "sqlalchemy.orm.Query.first") or [`Query.limit()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.limit
    "sqlalchemy.orm.Query.limit"), as well as with use of the [`Query.with_for_update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.with_for_update
    "sqlalchemy.orm.Query.with_for_update") method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given a query as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: 'The [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    object renders a SELECT of the following form when joined eager loading is combined
    with LIMIT:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: 'This is so that the limit of rows takes place for the primary entity without
    affecting the joined eager load of related items. When the above query is combined
    with “SELECT..FOR UPDATE”, the behavior has been this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: 'However, MySQL due to [https://bugs.mysql.com/bug.php?id=90693](https://bugs.mysql.com/bug.php?id=90693)
    does not lock the rows inside the subquery, unlike that of PostgreSQL and other
    databases. So the above query now renders as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: On the Oracle dialect, the inner “FOR UPDATE” is not rendered as Oracle does
    not support this syntax and the dialect skips any “FOR UPDATE” that is against
    a subquery; it isn’t necessary in any case since Oracle, like PostgreSQL, correctly
    locks all elements of the returned row.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using the [`Query.with_for_update.of`](../orm/queryguide/query.html#sqlalchemy.orm.Query.with_for_update.params.of
    "sqlalchemy.orm.Query.with_for_update") modifier, typically on PostgreSQL, the
    outer “FOR UPDATE” is omitted, and the OF is now rendered on the inside; previously,
    the OF target would not be converted to accommodate for the subquery correctly.
    So given:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: 'The query would now render as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs: []
  type: TYPE_PRE
- en: The above form should be helpful on PostgreSQL additionally since PostgreSQL
    will not allow the FOR UPDATE clause to be rendered after the LEFT OUTER JOIN
    target.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, FOR UPDATE remains highly specific to the target database in use and
    can’t easily be generalized for more complex queries.
  prefs: []
  type: TYPE_NORMAL
- en: '[#4246](https://www.sqlalchemy.org/trac/ticket/4246)'
  prefs: []
  type: TYPE_NORMAL
- en: '### passive_deletes=’all’ will leave FK unchanged for object removed from collection'
  prefs: []
  type: TYPE_NORMAL
- en: 'The [`relationship.passive_deletes`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.passive_deletes
    "sqlalchemy.orm.relationship") option accepts the value `"all"` to indicate that
    no foreign key attributes should be modified when the object is flushed, even
    if the relationship’s collection / reference has been removed. Previously, this
    did not take place for one-to-many, or one-to-one relationships, in the following
    situation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: The fix now includes that `address.user_id` is left unchanged as per `passive_deletes="all"`.
    This kind of thing is useful for building custom “version table” schemes and such
    where rows are archived instead of deleted.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3844](https://www.sqlalchemy.org/trac/ticket/3844)'
  prefs: []
  type: TYPE_NORMAL
- en: '## New Features and Improvements - Core'
  prefs: []
  type: TYPE_NORMAL
- en: '### New multi-column naming convention tokens, long name truncation'
  prefs: []
  type: TYPE_NORMAL
- en: 'To suit the case where a [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") naming convention needs to disambiguate between
    multiple-column constraints and wishes to use all the columns within the generated
    constraint name, a new series of naming convention tokens are added, including
    `column_0N_name`, `column_0_N_name`, `column_0N_key`, `column_0_N_key`, `referred_column_0N_name`,
    `referred_column_0_N_name`, etc., which render the column name (or key or label)
    for all columns in the constraint, joined together either with no separator or
    with an underscore separator. Below we define a convention that will name [`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint") constraints with a name that joins together
    the names of all columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: 'The CREATE TABLE for the above table will render as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition, long-name truncation logic is now applied to the names generated
    by naming conventions, in particular to accommodate for multi-column labels that
    can produce very long names. This logic, which is the same as that used for truncating
    long label names in a SELECT statement, replaces excess characters that go over
    the identifier-length limit for the target database with a deterministically generated
    4-character hash. For example, on PostgreSQL where identifiers cannot be longer
    than 63 characters, a long constraint name would normally be generated from the
    table definition below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: 'The truncation logic will ensure a too-long name isn’t generated for the UNIQUE
    constraint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: The above suffix `a79e` is based on the md5 hash of the long name and will generate
    the same value every time to produce consistent names for a given schema.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the truncation logic also raises [`IdentifierError`](../core/exceptions.html#sqlalchemy.exc.IdentifierError
    "sqlalchemy.exc.IdentifierError") when a constraint name is explicitly too large
    for a given dialect. This has been the behavior for an [`Index`](../core/constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index") object for a long time, but is now applied to other
    kinds of constraints as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: 'will output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: The exception raise prevents the production of non-deterministic constraint
    names truncated by the database backend which are then not compatible with database
    migrations later on.
  prefs: []
  type: TYPE_NORMAL
- en: 'To apply SQLAlchemy-side truncation rules to the above identifier, use the
    [`conv()`](../core/constraints.html#sqlalchemy.schema.conv "sqlalchemy.schema.conv")
    construct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: 'This will again output deterministically truncated SQL as in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: There is not at the moment an option to have the names pass through to allow
    database-side truncation. This has already been the case for [`Index`](../core/constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index") names for some time and issues have not been raised.
  prefs: []
  type: TYPE_NORMAL
- en: The change also repairs two other issues. One is that the `column_0_key` token
    wasn’t available even though this token was documented, the other was that the
    `referred_column_0_name` token would inadvertently render the `.key` and not the
    `.name` of the column if these two values were different.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Configuring Constraint Naming Conventions](../core/constraints.html#constraint-naming-conventions)'
  prefs: []
  type: TYPE_NORMAL
- en: '[`MetaData.naming_convention`](../core/metadata.html#sqlalchemy.schema.MetaData.params.naming_convention
    "sqlalchemy.schema.MetaData")'
  prefs: []
  type: TYPE_NORMAL
- en: '[#3989](https://www.sqlalchemy.org/trac/ticket/3989)  ### Binary comparison
    interpretation for SQL functions'
  prefs: []
  type: TYPE_NORMAL
- en: This enhancement is implemented at the Core level, however is applicable primarily
    to the ORM.
  prefs: []
  type: TYPE_NORMAL
- en: 'A SQL function that compares two elements can now be used as a “comparison”
    object, suitable for usage in an ORM [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship"), by first creating the function as usual using
    the [`func`](../core/sqlelement.html#sqlalchemy.sql.expression.func "sqlalchemy.sql.expression.func")
    factory, then when the function is complete calling upon the [`FunctionElement.as_comparison()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.as_comparison
    "sqlalchemy.sql.functions.FunctionElement.as_comparison") modifier to produce
    a [`BinaryExpression`](../core/sqlelement.html#sqlalchemy.sql.expression.BinaryExpression
    "sqlalchemy.sql.expression.BinaryExpression") that has a “left” and a “right”
    side:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: 'Above, the [`relationship.primaryjoin`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.primaryjoin
    "sqlalchemy.orm.relationship") of the “descendants” relationship will produce
    a “left” and a “right” expression based on the first and second arguments passed
    to `instr()`. This allows features like the ORM lazyload to produce SQL like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: 'and a joinedload, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: 'to work as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: This feature is expected to help with situations such as making use of geometric
    functions in relationship join conditions, or any case where the ON clause of
    the SQL join is expressed in terms of a SQL function.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3831](https://www.sqlalchemy.org/trac/ticket/3831)  ### Expanding IN feature
    now supports empty lists'
  prefs: []
  type: TYPE_NORMAL
- en: 'The “expanding IN” feature introduced in version 1.2 at [Late-expanded IN parameter
    sets allow IN expressions with cached statements](migration_12.html#change-3953)
    now supports empty lists passed to the [`ColumnOperators.in_()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.in_
    "sqlalchemy.sql.expression.ColumnOperators.in_") operator. The implementation
    for an empty list will produce an “empty set” expression that is specific to a
    target backend, such as “SELECT CAST(NULL AS INTEGER) WHERE 1!=1” for PostgreSQL,
    “SELECT 1 FROM (SELECT 1) as _empty_set WHERE 1!=1” for MySQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: 'The feature also works for tuple-oriented IN statements, where the “empty IN”
    expression will be expanded to support the elements given inside the tuple, such
    as on PostgreSQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: '[#4271](https://www.sqlalchemy.org/trac/ticket/4271)  ### TypeEngine methods
    bind_expression, column_expression work with Variant, type-specific types'
  prefs: []
  type: TYPE_NORMAL
- en: The [`TypeEngine.bind_expression()`](../core/type_api.html#sqlalchemy.types.TypeEngine.bind_expression
    "sqlalchemy.types.TypeEngine.bind_expression") and [`TypeEngine.column_expression()`](../core/type_api.html#sqlalchemy.types.TypeEngine.column_expression
    "sqlalchemy.types.TypeEngine.column_expression") methods now work when they are
    present on the “impl” of a particular datatype, allowing these methods to be used
    by dialects as well as for [`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") and [`Variant`](../core/type_api.html#sqlalchemy.types.Variant
    "sqlalchemy.types.Variant") use cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example illustrates a [`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") that applies SQL-time conversion functions to
    a [`LargeBinary`](../core/type_basics.html#sqlalchemy.types.LargeBinary "sqlalchemy.types.LargeBinary").
    In order for this type to work in the context of a [`Variant`](../core/type_api.html#sqlalchemy.types.Variant
    "sqlalchemy.types.Variant"), the compiler needs to drill into the “impl” of the
    variant expression in order to locate these methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: 'The above expression will render a function within SQL when used on SQLite
    only:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: 'will render:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: The change also includes that dialects can implement [`TypeEngine.bind_expression()`](../core/type_api.html#sqlalchemy.types.TypeEngine.bind_expression
    "sqlalchemy.types.TypeEngine.bind_expression") and [`TypeEngine.column_expression()`](../core/type_api.html#sqlalchemy.types.TypeEngine.column_expression
    "sqlalchemy.types.TypeEngine.column_expression") on dialect-level implementation
    types where they will now be used; in particular this will be used for MySQL’s
    new “binary prefix” requirement as well as for casting decimal bind values for
    MySQL.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3981](https://www.sqlalchemy.org/trac/ticket/3981)  ### New last-in-first-out
    strategy for QueuePool'
  prefs: []
  type: TYPE_NORMAL
- en: The connection pool usually used by [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") is known as [`QueuePool`](../core/pooling.html#sqlalchemy.pool.QueuePool
    "sqlalchemy.pool.QueuePool"). This pool uses an object equivalent to Python’s
    built-in `Queue` class in order to store database connections waiting to be used.
    The `Queue` features first-in-first-out behavior, which is intended to provide
    a round-robin use of the database connections that are persistently in the pool.
    However, a potential downside of this is that when the utilization of the pool
    is low, the re-use of each connection in series means that a server-side timeout
    strategy that attempts to reduce unused connections is prevented from shutting
    down these connections. To suit this use case, a new flag [`create_engine.pool_use_lifo`](../core/engines.html#sqlalchemy.create_engine.params.pool_use_lifo
    "sqlalchemy.create_engine") is added which reverses the `.get()` method of the
    `Queue` to pull the connection from the beginning of the queue instead of the
    end, essentially turning the “queue” into a “stack” (adding a whole new pool called
    `StackPool` was considered, however this was too much verbosity).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Using FIFO vs. LIFO](../core/pooling.html#pool-use-lifo)  ### New multi-column
    naming convention tokens, long name truncation'
  prefs: []
  type: TYPE_NORMAL
- en: 'To suit the case where a [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") naming convention needs to disambiguate between
    multiple-column constraints and wishes to use all the columns within the generated
    constraint name, a new series of naming convention tokens are added, including
    `column_0N_name`, `column_0_N_name`, `column_0N_key`, `column_0_N_key`, `referred_column_0N_name`,
    `referred_column_0_N_name`, etc., which render the column name (or key or label)
    for all columns in the constraint, joined together either with no separator or
    with an underscore separator. Below we define a convention that will name [`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint") constraints with a name that joins together
    the names of all columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: 'The CREATE TABLE for the above table will render as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition, long-name truncation logic is now applied to the names generated
    by naming conventions, in particular to accommodate for multi-column labels that
    can produce very long names. This logic, which is the same as that used for truncating
    long label names in a SELECT statement, replaces excess characters that go over
    the identifier-length limit for the target database with a deterministically generated
    4-character hash. For example, on PostgreSQL where identifiers cannot be longer
    than 63 characters, a long constraint name would normally be generated from the
    table definition below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: 'The truncation logic will ensure a too-long name isn’t generated for the UNIQUE
    constraint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: The above suffix `a79e` is based on the md5 hash of the long name and will generate
    the same value every time to produce consistent names for a given schema.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the truncation logic also raises [`IdentifierError`](../core/exceptions.html#sqlalchemy.exc.IdentifierError
    "sqlalchemy.exc.IdentifierError") when a constraint name is explicitly too large
    for a given dialect. This has been the behavior for an [`Index`](../core/constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index") object for a long time, but is now applied to other
    kinds of constraints as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: 'will output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: The exception raise prevents the production of non-deterministic constraint
    names truncated by the database backend which are then not compatible with database
    migrations later on.
  prefs: []
  type: TYPE_NORMAL
- en: 'To apply SQLAlchemy-side truncation rules to the above identifier, use the
    [`conv()`](../core/constraints.html#sqlalchemy.schema.conv "sqlalchemy.schema.conv")
    construct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: 'This will again output deterministically truncated SQL as in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: There is not at the moment an option to have the names pass through to allow
    database-side truncation. This has already been the case for [`Index`](../core/constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index") names for some time and issues have not been raised.
  prefs: []
  type: TYPE_NORMAL
- en: The change also repairs two other issues. One is that the `column_0_key` token
    wasn’t available even though this token was documented, the other was that the
    `referred_column_0_name` token would inadvertently render the `.key` and not the
    `.name` of the column if these two values were different.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Configuring Constraint Naming Conventions](../core/constraints.html#constraint-naming-conventions)'
  prefs: []
  type: TYPE_NORMAL
- en: '[`MetaData.naming_convention`](../core/metadata.html#sqlalchemy.schema.MetaData.params.naming_convention
    "sqlalchemy.schema.MetaData")'
  prefs: []
  type: TYPE_NORMAL
- en: '[#3989](https://www.sqlalchemy.org/trac/ticket/3989)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Binary comparison interpretation for SQL functions'
  prefs: []
  type: TYPE_NORMAL
- en: This enhancement is implemented at the Core level, however is applicable primarily
    to the ORM.
  prefs: []
  type: TYPE_NORMAL
- en: 'A SQL function that compares two elements can now be used as a “comparison”
    object, suitable for usage in an ORM [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship"), by first creating the function as usual using
    the [`func`](../core/sqlelement.html#sqlalchemy.sql.expression.func "sqlalchemy.sql.expression.func")
    factory, then when the function is complete calling upon the [`FunctionElement.as_comparison()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.as_comparison
    "sqlalchemy.sql.functions.FunctionElement.as_comparison") modifier to produce
    a [`BinaryExpression`](../core/sqlelement.html#sqlalchemy.sql.expression.BinaryExpression
    "sqlalchemy.sql.expression.BinaryExpression") that has a “left” and a “right”
    side:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: 'Above, the [`relationship.primaryjoin`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.primaryjoin
    "sqlalchemy.orm.relationship") of the “descendants” relationship will produce
    a “left” and a “right” expression based on the first and second arguments passed
    to `instr()`. This allows features like the ORM lazyload to produce SQL like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: 'and a joinedload, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: 'to work as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: This feature is expected to help with situations such as making use of geometric
    functions in relationship join conditions, or any case where the ON clause of
    the SQL join is expressed in terms of a SQL function.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3831](https://www.sqlalchemy.org/trac/ticket/3831)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Expanding IN feature now supports empty lists'
  prefs: []
  type: TYPE_NORMAL
- en: 'The “expanding IN” feature introduced in version 1.2 at [Late-expanded IN parameter
    sets allow IN expressions with cached statements](migration_12.html#change-3953)
    now supports empty lists passed to the [`ColumnOperators.in_()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.in_
    "sqlalchemy.sql.expression.ColumnOperators.in_") operator. The implementation
    for an empty list will produce an “empty set” expression that is specific to a
    target backend, such as “SELECT CAST(NULL AS INTEGER) WHERE 1!=1” for PostgreSQL,
    “SELECT 1 FROM (SELECT 1) as _empty_set WHERE 1!=1” for MySQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: 'The feature also works for tuple-oriented IN statements, where the “empty IN”
    expression will be expanded to support the elements given inside the tuple, such
    as on PostgreSQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: '[#4271](https://www.sqlalchemy.org/trac/ticket/4271)'
  prefs: []
  type: TYPE_NORMAL
- en: '### TypeEngine methods bind_expression, column_expression work with Variant,
    type-specific types'
  prefs: []
  type: TYPE_NORMAL
- en: The [`TypeEngine.bind_expression()`](../core/type_api.html#sqlalchemy.types.TypeEngine.bind_expression
    "sqlalchemy.types.TypeEngine.bind_expression") and [`TypeEngine.column_expression()`](../core/type_api.html#sqlalchemy.types.TypeEngine.column_expression
    "sqlalchemy.types.TypeEngine.column_expression") methods now work when they are
    present on the “impl” of a particular datatype, allowing these methods to be used
    by dialects as well as for [`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") and [`Variant`](../core/type_api.html#sqlalchemy.types.Variant
    "sqlalchemy.types.Variant") use cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example illustrates a [`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") that applies SQL-time conversion functions to
    a [`LargeBinary`](../core/type_basics.html#sqlalchemy.types.LargeBinary "sqlalchemy.types.LargeBinary").
    In order for this type to work in the context of a [`Variant`](../core/type_api.html#sqlalchemy.types.Variant
    "sqlalchemy.types.Variant"), the compiler needs to drill into the “impl” of the
    variant expression in order to locate these methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: 'The above expression will render a function within SQL when used on SQLite
    only:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: 'will render:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: The change also includes that dialects can implement [`TypeEngine.bind_expression()`](../core/type_api.html#sqlalchemy.types.TypeEngine.bind_expression
    "sqlalchemy.types.TypeEngine.bind_expression") and [`TypeEngine.column_expression()`](../core/type_api.html#sqlalchemy.types.TypeEngine.column_expression
    "sqlalchemy.types.TypeEngine.column_expression") on dialect-level implementation
    types where they will now be used; in particular this will be used for MySQL’s
    new “binary prefix” requirement as well as for casting decimal bind values for
    MySQL.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3981](https://www.sqlalchemy.org/trac/ticket/3981)'
  prefs: []
  type: TYPE_NORMAL
- en: '### New last-in-first-out strategy for QueuePool'
  prefs: []
  type: TYPE_NORMAL
- en: The connection pool usually used by [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") is known as [`QueuePool`](../core/pooling.html#sqlalchemy.pool.QueuePool
    "sqlalchemy.pool.QueuePool"). This pool uses an object equivalent to Python’s
    built-in `Queue` class in order to store database connections waiting to be used.
    The `Queue` features first-in-first-out behavior, which is intended to provide
    a round-robin use of the database connections that are persistently in the pool.
    However, a potential downside of this is that when the utilization of the pool
    is low, the re-use of each connection in series means that a server-side timeout
    strategy that attempts to reduce unused connections is prevented from shutting
    down these connections. To suit this use case, a new flag [`create_engine.pool_use_lifo`](../core/engines.html#sqlalchemy.create_engine.params.pool_use_lifo
    "sqlalchemy.create_engine") is added which reverses the `.get()` method of the
    `Queue` to pull the connection from the beginning of the queue instead of the
    end, essentially turning the “queue” into a “stack” (adding a whole new pool called
    `StackPool` was considered, however this was too much verbosity).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Using FIFO vs. LIFO](../core/pooling.html#pool-use-lifo)'
  prefs: []
  type: TYPE_NORMAL
- en: Key Changes - Core
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '### Coercion of string SQL fragments to text() fully removed'
  prefs: []
  type: TYPE_NORMAL
- en: The warnings that were first added in version 1.0, described at [Warnings emitted
    when coercing full SQL fragments into text()](migration_10.html#migration-2992),
    have now been converted into exceptions. Continued concerns have been raised regarding
    the automatic coercion of string fragments passed to methods like [`Query.filter()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.filter
    "sqlalchemy.orm.Query.filter") and [`Select.order_by()`](../core/selectable.html#sqlalchemy.sql.expression.Select.order_by
    "sqlalchemy.sql.expression.Select.order_by") being converted to [`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text
    "sqlalchemy.sql.expression.text") constructs, even though this has emitted a warning.
    In the case of [`Select.order_by()`](../core/selectable.html#sqlalchemy.sql.expression.Select.order_by
    "sqlalchemy.sql.expression.Select.order_by"), [`Query.order_by()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.order_by
    "sqlalchemy.orm.Query.order_by"), [`Select.group_by()`](../core/selectable.html#sqlalchemy.sql.expression.Select.group_by
    "sqlalchemy.sql.expression.Select.group_by"), and [`Query.group_by()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.group_by
    "sqlalchemy.orm.Query.group_by"), a string label or column name is still resolved
    into the corresponding expression construct, however if the resolution fails,
    a [`CompileError`](../core/exceptions.html#sqlalchemy.exc.CompileError "sqlalchemy.exc.CompileError")
    is raised, thus preventing raw SQL text from being rendered directly.
  prefs: []
  type: TYPE_NORMAL
- en: '[#4481](https://www.sqlalchemy.org/trac/ticket/4481)  ### “threadlocal” engine
    strategy deprecated'
  prefs: []
  type: TYPE_NORMAL
- en: The “threadlocal engine strategy” was added around SQLAlchemy 0.2, as a solution
    to the problem that the standard way of operating in SQLAlchemy 0.1, which can
    be summed up as “threadlocal everything”, was found to be lacking. In retrospect,
    it seems fairly absurd that by SQLAlchemy’s first releases which were in every
    regard “alpha”, that there was concern that too many users had already settled
    on the existing API to simply change it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The original usage model for SQLAlchemy looked like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: 'After a few months of real world use, it was clear that trying to pretend a
    “connection” or a “transaction” was a hidden implementation detail was a bad idea,
    particularly the moment someone needed to deal with more than one database connection
    at a time. So the usage paradigm we see today was introduced, minus the context
    managers since they didn’t yet exist in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: The above paradigm was what people needed, but since it was still kind of verbose
    (because no context managers), the old way of working was kept around as well
    and it became the threadlocal engine strategy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Today, working with Core is much more succinct, and even more succinct than
    the original pattern, thanks to context managers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: At this point, any remaining code that is still relying upon the “threadlocal”
    style will be encouraged via this deprecation to modernize - the feature should
    be removed totally by the next major series of SQLAlchemy, e.g. 1.4\. The connection
    pool parameter [`Pool.use_threadlocal`](../core/pooling.html#sqlalchemy.pool.Pool.params.use_threadlocal
    "sqlalchemy.pool.Pool") is also deprecated as it does not actually have any effect
    in most cases, as is the `Engine.contextual_connect()` method, which is normally
    synonymous with the [`Engine.connect()`](../core/connections.html#sqlalchemy.engine.Engine.connect
    "sqlalchemy.engine.Engine.connect") method except in the case where the threadlocal
    engine is in use.
  prefs: []
  type: TYPE_NORMAL
- en: '[#4393](https://www.sqlalchemy.org/trac/ticket/4393)  ### convert_unicode parameters
    deprecated'
  prefs: []
  type: TYPE_NORMAL
- en: The parameters [`String.convert_unicode`](../core/type_basics.html#sqlalchemy.types.String.params.convert_unicode
    "sqlalchemy.types.String") and [`create_engine.convert_unicode`](../core/engines.html#sqlalchemy.create_engine.params.convert_unicode
    "sqlalchemy.create_engine") are deprecated. The purpose of these parameters was
    to instruct SQLAlchemy to ensure that incoming Python Unicode objects under Python
    2 were encoded to bytestrings before passing to the database, and to expect bytestrings
    from the database to be converted back to Python Unicode objects. In the pre-Python
    3 era, this was an enormous ordeal to get right, as virtually all Python DBAPIs
    had no Unicode support enabled by default, and most had major issues with the
    Unicode extensions that they did provide. Eventually, SQLAlchemy added C extensions,
    one of the primary purposes of these extensions was to speed up the Unicode decode
    process within result sets.
  prefs: []
  type: TYPE_NORMAL
- en: Once Python 3 was introduced, DBAPIs began to start supporting Unicode more
    fully, and more importantly, by default. However, the conditions under which a
    particular DBAPI would or would not return Unicode data from a result, as well
    as accept Python Unicode values as parameters, remained extremely complicated.
    This was the beginning of the obsolescence of the “convert_unicode” flags, because
    they were no longer sufficient as a means of ensuring that encode/decode was occurring
    only where needed and not where it wasn’t needed. Instead, “convert_unicode” started
    to be automatically detected by dialects. Part of this can be seen in the “SELECT
    ‘test plain returns’” and “SELECT ‘test_unicode_returns’” SQL emitted by an engine
    the first time it connects; the dialect is testing that the current DBAPI with
    its current settings and backend database connection is returning Unicode by default
    or not.
  prefs: []
  type: TYPE_NORMAL
- en: The end result is that end-user use of the “convert_unicode” flags should no
    longer be needed in any circumstances, and if they are, the SQLAlchemy project
    needs to know what those cases are and why. Currently, hundreds of Unicode round
    trip tests pass across all major databases without the use of this flag so there
    is a fairly high level of confidence that they are no longer needed except in
    arguable non use cases such as accessing mis-encoded data from a legacy database,
    which would be better suited using custom types.
  prefs: []
  type: TYPE_NORMAL
- en: '[#4393](https://www.sqlalchemy.org/trac/ticket/4393)  ### Coercion of string
    SQL fragments to text() fully removed'
  prefs: []
  type: TYPE_NORMAL
- en: The warnings that were first added in version 1.0, described at [Warnings emitted
    when coercing full SQL fragments into text()](migration_10.html#migration-2992),
    have now been converted into exceptions. Continued concerns have been raised regarding
    the automatic coercion of string fragments passed to methods like [`Query.filter()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.filter
    "sqlalchemy.orm.Query.filter") and [`Select.order_by()`](../core/selectable.html#sqlalchemy.sql.expression.Select.order_by
    "sqlalchemy.sql.expression.Select.order_by") being converted to [`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text
    "sqlalchemy.sql.expression.text") constructs, even though this has emitted a warning.
    In the case of [`Select.order_by()`](../core/selectable.html#sqlalchemy.sql.expression.Select.order_by
    "sqlalchemy.sql.expression.Select.order_by"), [`Query.order_by()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.order_by
    "sqlalchemy.orm.Query.order_by"), [`Select.group_by()`](../core/selectable.html#sqlalchemy.sql.expression.Select.group_by
    "sqlalchemy.sql.expression.Select.group_by"), and [`Query.group_by()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.group_by
    "sqlalchemy.orm.Query.group_by"), a string label or column name is still resolved
    into the corresponding expression construct, however if the resolution fails,
    a [`CompileError`](../core/exceptions.html#sqlalchemy.exc.CompileError "sqlalchemy.exc.CompileError")
    is raised, thus preventing raw SQL text from being rendered directly.
  prefs: []
  type: TYPE_NORMAL
- en: '[#4481](https://www.sqlalchemy.org/trac/ticket/4481)'
  prefs: []
  type: TYPE_NORMAL
- en: '### “threadlocal” engine strategy deprecated'
  prefs: []
  type: TYPE_NORMAL
- en: The “threadlocal engine strategy” was added around SQLAlchemy 0.2, as a solution
    to the problem that the standard way of operating in SQLAlchemy 0.1, which can
    be summed up as “threadlocal everything”, was found to be lacking. In retrospect,
    it seems fairly absurd that by SQLAlchemy’s first releases which were in every
    regard “alpha”, that there was concern that too many users had already settled
    on the existing API to simply change it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The original usage model for SQLAlchemy looked like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE225]'
  prefs: []
  type: TYPE_PRE
- en: 'After a few months of real world use, it was clear that trying to pretend a
    “connection” or a “transaction” was a hidden implementation detail was a bad idea,
    particularly the moment someone needed to deal with more than one database connection
    at a time. So the usage paradigm we see today was introduced, minus the context
    managers since they didn’t yet exist in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: The above paradigm was what people needed, but since it was still kind of verbose
    (because no context managers), the old way of working was kept around as well
    and it became the threadlocal engine strategy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Today, working with Core is much more succinct, and even more succinct than
    the original pattern, thanks to context managers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE227]'
  prefs: []
  type: TYPE_PRE
- en: At this point, any remaining code that is still relying upon the “threadlocal”
    style will be encouraged via this deprecation to modernize - the feature should
    be removed totally by the next major series of SQLAlchemy, e.g. 1.4\. The connection
    pool parameter [`Pool.use_threadlocal`](../core/pooling.html#sqlalchemy.pool.Pool.params.use_threadlocal
    "sqlalchemy.pool.Pool") is also deprecated as it does not actually have any effect
    in most cases, as is the `Engine.contextual_connect()` method, which is normally
    synonymous with the [`Engine.connect()`](../core/connections.html#sqlalchemy.engine.Engine.connect
    "sqlalchemy.engine.Engine.connect") method except in the case where the threadlocal
    engine is in use.
  prefs: []
  type: TYPE_NORMAL
- en: '[#4393](https://www.sqlalchemy.org/trac/ticket/4393)'
  prefs: []
  type: TYPE_NORMAL
- en: '### convert_unicode parameters deprecated'
  prefs: []
  type: TYPE_NORMAL
- en: The parameters [`String.convert_unicode`](../core/type_basics.html#sqlalchemy.types.String.params.convert_unicode
    "sqlalchemy.types.String") and [`create_engine.convert_unicode`](../core/engines.html#sqlalchemy.create_engine.params.convert_unicode
    "sqlalchemy.create_engine") are deprecated. The purpose of these parameters was
    to instruct SQLAlchemy to ensure that incoming Python Unicode objects under Python
    2 were encoded to bytestrings before passing to the database, and to expect bytestrings
    from the database to be converted back to Python Unicode objects. In the pre-Python
    3 era, this was an enormous ordeal to get right, as virtually all Python DBAPIs
    had no Unicode support enabled by default, and most had major issues with the
    Unicode extensions that they did provide. Eventually, SQLAlchemy added C extensions,
    one of the primary purposes of these extensions was to speed up the Unicode decode
    process within result sets.
  prefs: []
  type: TYPE_NORMAL
- en: Once Python 3 was introduced, DBAPIs began to start supporting Unicode more
    fully, and more importantly, by default. However, the conditions under which a
    particular DBAPI would or would not return Unicode data from a result, as well
    as accept Python Unicode values as parameters, remained extremely complicated.
    This was the beginning of the obsolescence of the “convert_unicode” flags, because
    they were no longer sufficient as a means of ensuring that encode/decode was occurring
    only where needed and not where it wasn’t needed. Instead, “convert_unicode” started
    to be automatically detected by dialects. Part of this can be seen in the “SELECT
    ‘test plain returns’” and “SELECT ‘test_unicode_returns’” SQL emitted by an engine
    the first time it connects; the dialect is testing that the current DBAPI with
    its current settings and backend database connection is returning Unicode by default
    or not.
  prefs: []
  type: TYPE_NORMAL
- en: The end result is that end-user use of the “convert_unicode” flags should no
    longer be needed in any circumstances, and if they are, the SQLAlchemy project
    needs to know what those cases are and why. Currently, hundreds of Unicode round
    trip tests pass across all major databases without the use of this flag so there
    is a fairly high level of confidence that they are no longer needed except in
    arguable non use cases such as accessing mis-encoded data from a legacy database,
    which would be better suited using custom types.
  prefs: []
  type: TYPE_NORMAL
- en: '[#4393](https://www.sqlalchemy.org/trac/ticket/4393)'
  prefs: []
  type: TYPE_NORMAL
- en: Dialect Improvements and Changes - PostgreSQL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '### Added basic reflection support for PostgreSQL partitioned tables'
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy can render the “PARTITION BY” sequence within a PostgreSQL CREATE
    TABLE statement using the flag `postgresql_partition_by`, added in version 1.2.6\.
    However, the `'p'` type was not part of the reflection queries used until now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given a schema such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE228]'
  prefs: []
  type: TYPE_PRE
- en: The two table names `'data_values'` and `'data_values_4_10'` will come back
    from [`Inspector.get_table_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_table_names
    "sqlalchemy.engine.reflection.Inspector.get_table_names") and additionally the
    columns will come back from `Inspector.get_columns('data_values')` as well as
    `Inspector.get_columns('data_values_4_10')`. This also extends to the use of `Table(...,
    autoload=True)` with these tables.
  prefs: []
  type: TYPE_NORMAL
- en: '[#4237](https://www.sqlalchemy.org/trac/ticket/4237)  ### Added basic reflection
    support for PostgreSQL partitioned tables'
  prefs: []
  type: TYPE_NORMAL
- en: SQLAlchemy can render the “PARTITION BY” sequence within a PostgreSQL CREATE
    TABLE statement using the flag `postgresql_partition_by`, added in version 1.2.6\.
    However, the `'p'` type was not part of the reflection queries used until now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given a schema such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE229]'
  prefs: []
  type: TYPE_PRE
- en: The two table names `'data_values'` and `'data_values_4_10'` will come back
    from [`Inspector.get_table_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_table_names
    "sqlalchemy.engine.reflection.Inspector.get_table_names") and additionally the
    columns will come back from `Inspector.get_columns('data_values')` as well as
    `Inspector.get_columns('data_values_4_10')`. This also extends to the use of `Table(...,
    autoload=True)` with these tables.
  prefs: []
  type: TYPE_NORMAL
- en: '[#4237](https://www.sqlalchemy.org/trac/ticket/4237)'
  prefs: []
  type: TYPE_NORMAL
- en: Dialect Improvements and Changes - MySQL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '### Protocol-level ping now used for pre-ping'
  prefs: []
  type: TYPE_NORMAL
- en: 'The MySQL dialects including mysqlclient, python-mysql, PyMySQL and mysql-connector-python
    now use the `connection.ping()` method for the pool pre-ping feature, described
    at [Disconnect Handling - Pessimistic](../core/pooling.html#pool-disconnects-pessimistic).
    This is a much more lightweight ping than the previous method of emitting “SELECT
    1” on the connection.  ### Control of parameter ordering within ON DUPLICATE KEY
    UPDATE'
  prefs: []
  type: TYPE_NORMAL
- en: 'The order of UPDATE parameters in the `ON DUPLICATE KEY UPDATE` clause can
    now be explicitly ordered by passing a list of 2-tuples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE230]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[INSERT…ON DUPLICATE KEY UPDATE (Upsert)](../dialects/mysql.html#mysql-insert-on-duplicate-key-update)  ###
    Protocol-level ping now used for pre-ping'
  prefs: []
  type: TYPE_NORMAL
- en: The MySQL dialects including mysqlclient, python-mysql, PyMySQL and mysql-connector-python
    now use the `connection.ping()` method for the pool pre-ping feature, described
    at [Disconnect Handling - Pessimistic](../core/pooling.html#pool-disconnects-pessimistic).
    This is a much more lightweight ping than the previous method of emitting “SELECT
    1” on the connection.
  prefs: []
  type: TYPE_NORMAL
- en: '### Control of parameter ordering within ON DUPLICATE KEY UPDATE'
  prefs: []
  type: TYPE_NORMAL
- en: 'The order of UPDATE parameters in the `ON DUPLICATE KEY UPDATE` clause can
    now be explicitly ordered by passing a list of 2-tuples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE231]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[INSERT…ON DUPLICATE KEY UPDATE (Upsert)](../dialects/mysql.html#mysql-insert-on-duplicate-key-update)'
  prefs: []
  type: TYPE_NORMAL
- en: Dialect Improvements and Changes - SQLite
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '### Support for SQLite JSON Added'
  prefs: []
  type: TYPE_NORMAL
- en: A new datatype [`JSON`](../dialects/sqlite.html#sqlalchemy.dialects.sqlite.JSON
    "sqlalchemy.dialects.sqlite.JSON") is added which implements SQLite’s json member
    access functions on behalf of the [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON") base datatype. The SQLite `JSON_EXTRACT` and `JSON_QUOTE`
    functions are used by the implementation to provide basic JSON support.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the name of the datatype itself as rendered in the database is the
    name “JSON”. This will create a SQLite datatype with “numeric” affinity, which
    normally should not be an issue except in the case of a JSON value that consists
    of single integer value. Nevertheless, following an example in SQLite’s own documentation
    at [https://www.sqlite.org/json1.html](https://www.sqlite.org/json1.html) the
    name JSON is being used for its familiarity.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3850](https://www.sqlalchemy.org/trac/ticket/3850)  ### Support for SQLite
    ON CONFLICT in constraints added'
  prefs: []
  type: TYPE_NORMAL
- en: 'SQLite supports a non-standard ON CONFLICT clause that may be specified for
    standalone constraints as well as some column-inline constraints such as NOT NULL.
    Support has been added for these clauses via the `sqlite_on_conflict` keyword
    added to objects like [`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint") as well as several [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") -specific variants:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE232]'
  prefs: []
  type: TYPE_PRE
- en: 'The above table would render in a CREATE TABLE statement as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE233]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[ON CONFLICT support for constraints](../dialects/sqlite.html#sqlite-on-conflict-ddl)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#4360](https://www.sqlalchemy.org/trac/ticket/4360)  ### Support for SQLite
    JSON Added'
  prefs: []
  type: TYPE_NORMAL
- en: A new datatype [`JSON`](../dialects/sqlite.html#sqlalchemy.dialects.sqlite.JSON
    "sqlalchemy.dialects.sqlite.JSON") is added which implements SQLite’s json member
    access functions on behalf of the [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON") base datatype. The SQLite `JSON_EXTRACT` and `JSON_QUOTE`
    functions are used by the implementation to provide basic JSON support.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the name of the datatype itself as rendered in the database is the
    name “JSON”. This will create a SQLite datatype with “numeric” affinity, which
    normally should not be an issue except in the case of a JSON value that consists
    of single integer value. Nevertheless, following an example in SQLite’s own documentation
    at [https://www.sqlite.org/json1.html](https://www.sqlite.org/json1.html) the
    name JSON is being used for its familiarity.
  prefs: []
  type: TYPE_NORMAL
- en: '[#3850](https://www.sqlalchemy.org/trac/ticket/3850)'
  prefs: []
  type: TYPE_NORMAL
- en: '### Support for SQLite ON CONFLICT in constraints added'
  prefs: []
  type: TYPE_NORMAL
- en: 'SQLite supports a non-standard ON CONFLICT clause that may be specified for
    standalone constraints as well as some column-inline constraints such as NOT NULL.
    Support has been added for these clauses via the `sqlite_on_conflict` keyword
    added to objects like [`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint") as well as several [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") -specific variants:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE234]'
  prefs: []
  type: TYPE_PRE
- en: 'The above table would render in a CREATE TABLE statement as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE235]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[ON CONFLICT support for constraints](../dialects/sqlite.html#sqlite-on-conflict-ddl)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#4360](https://www.sqlalchemy.org/trac/ticket/4360)'
  prefs: []
  type: TYPE_NORMAL
- en: Dialect Improvements and Changes - Oracle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '### National char datatypes de-emphasized for generic unicode, re-enabled with
    option'
  prefs: []
  type: TYPE_NORMAL
- en: The [`Unicode`](../core/type_basics.html#sqlalchemy.types.Unicode "sqlalchemy.types.Unicode")
    and [`UnicodeText`](../core/type_basics.html#sqlalchemy.types.UnicodeText "sqlalchemy.types.UnicodeText")
    datatypes by default now correspond to the `VARCHAR2` and `CLOB` datatypes on
    Oracle, rather than `NVARCHAR2` and `NCLOB` (otherwise known as “national” character
    set types). This will be seen in behaviors such as that of how they render in
    `CREATE TABLE` statements, as well as that no type object will be passed to `setinputsizes()`
    when bound parameters using [`Unicode`](../core/type_basics.html#sqlalchemy.types.Unicode
    "sqlalchemy.types.Unicode") or [`UnicodeText`](../core/type_basics.html#sqlalchemy.types.UnicodeText
    "sqlalchemy.types.UnicodeText") are used; cx_Oracle handles the string value natively.
    This change is based on advice from cx_Oracle’s maintainer that the “national”
    datatypes in Oracle are largely obsolete and are not performant. They also interfere
    in some situations such as when applied to the format specifier for functions
    like `trunc()`.
  prefs: []
  type: TYPE_NORMAL
- en: The one case where `NVARCHAR2` and related types may be needed is for a database
    that is not using a Unicode-compliant character set. In this case, the flag `use_nchar_for_unicode`
    can be passed to [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") to re-enable the old behavior.
  prefs: []
  type: TYPE_NORMAL
- en: As always, using the [`NVARCHAR2`](../dialects/oracle.html#sqlalchemy.dialects.oracle.NVARCHAR2
    "sqlalchemy.dialects.oracle.NVARCHAR2") and [`NCLOB`](../dialects/oracle.html#sqlalchemy.dialects.oracle.NCLOB
    "sqlalchemy.dialects.oracle.NCLOB") datatypes explicitly will continue to make
    use of `NVARCHAR2` and `NCLOB`, including within DDL as well as when handling
    bound parameters with cx_Oracle’s `setinputsizes()`.
  prefs: []
  type: TYPE_NORMAL
- en: On the read side, automatic Unicode conversion under Python 2 has been added
    to CHAR/VARCHAR/CLOB result rows, to match the behavior of cx_Oracle under Python
    3\. In order to mitigate the performance hit that the cx_Oracle dialect had previously
    with this behavior under Python 2, SQLAlchemy’s very performant (when C extensions
    are built) native Unicode handlers are used under Python 2. The automatic unicode
    coercion can be disabled by setting the `coerce_to_unicode` flag to False. This
    flag now defaults to True and applies to all string data returned in a result
    set that isn’t explicitly under [`Unicode`](../core/type_basics.html#sqlalchemy.types.Unicode
    "sqlalchemy.types.Unicode") or Oracle’s NVARCHAR2/NCHAR/NCLOB datatypes.
  prefs: []
  type: TYPE_NORMAL
- en: '[#4242](https://www.sqlalchemy.org/trac/ticket/4242)  ### cx_Oracle connect
    arguments modernized, deprecated parameters removed'
  prefs: []
  type: TYPE_NORMAL
- en: 'A series of modernizations to the parameters accepted by the cx_oracle dialect
    as well as the URL string:'
  prefs: []
  type: TYPE_NORMAL
- en: The deprecated parameters `auto_setinputsizes`, `allow_twophase`, `exclude_setinputsizes`
    are removed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The value of the `threaded` parameter, which has always been defaulted to True
    for the SQLAlchemy dialect, is no longer generated by default. The SQLAlchemy
    [`Connection`](../core/connections.html#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    object is not considered to be thread-safe itself so there’s no need for this
    flag to be passed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s deprecated to pass `threaded` to [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") itself. To set the value of `threaded` to `True`,
    pass it to either the [`create_engine.connect_args`](../core/engines.html#sqlalchemy.create_engine.params.connect_args
    "sqlalchemy.create_engine") dictionary or use the query string e.g. `oracle+cx_oracle://...?threaded=true`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All parameters passed on the URL query string that are not otherwise specially
    consumed are now passed to the cx_Oracle.connect() function. A selection of these
    are also coerced either into cx_Oracle constants or booleans including `mode`,
    `purity`, `events`, and `threaded`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As was the case earlier, all cx_Oracle `.connect()` arguments are accepted via
    the [`create_engine.connect_args`](../core/engines.html#sqlalchemy.create_engine.params.connect_args
    "sqlalchemy.create_engine") dictionary, the documentation was inaccurate regarding
    this.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[#4369](https://www.sqlalchemy.org/trac/ticket/4369)  ### National char datatypes
    de-emphasized for generic unicode, re-enabled with option'
  prefs: []
  type: TYPE_NORMAL
- en: The [`Unicode`](../core/type_basics.html#sqlalchemy.types.Unicode "sqlalchemy.types.Unicode")
    and [`UnicodeText`](../core/type_basics.html#sqlalchemy.types.UnicodeText "sqlalchemy.types.UnicodeText")
    datatypes by default now correspond to the `VARCHAR2` and `CLOB` datatypes on
    Oracle, rather than `NVARCHAR2` and `NCLOB` (otherwise known as “national” character
    set types). This will be seen in behaviors such as that of how they render in
    `CREATE TABLE` statements, as well as that no type object will be passed to `setinputsizes()`
    when bound parameters using [`Unicode`](../core/type_basics.html#sqlalchemy.types.Unicode
    "sqlalchemy.types.Unicode") or [`UnicodeText`](../core/type_basics.html#sqlalchemy.types.UnicodeText
    "sqlalchemy.types.UnicodeText") are used; cx_Oracle handles the string value natively.
    This change is based on advice from cx_Oracle’s maintainer that the “national”
    datatypes in Oracle are largely obsolete and are not performant. They also interfere
    in some situations such as when applied to the format specifier for functions
    like `trunc()`.
  prefs: []
  type: TYPE_NORMAL
- en: The one case where `NVARCHAR2` and related types may be needed is for a database
    that is not using a Unicode-compliant character set. In this case, the flag `use_nchar_for_unicode`
    can be passed to [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") to re-enable the old behavior.
  prefs: []
  type: TYPE_NORMAL
- en: As always, using the [`NVARCHAR2`](../dialects/oracle.html#sqlalchemy.dialects.oracle.NVARCHAR2
    "sqlalchemy.dialects.oracle.NVARCHAR2") and [`NCLOB`](../dialects/oracle.html#sqlalchemy.dialects.oracle.NCLOB
    "sqlalchemy.dialects.oracle.NCLOB") datatypes explicitly will continue to make
    use of `NVARCHAR2` and `NCLOB`, including within DDL as well as when handling
    bound parameters with cx_Oracle’s `setinputsizes()`.
  prefs: []
  type: TYPE_NORMAL
- en: On the read side, automatic Unicode conversion under Python 2 has been added
    to CHAR/VARCHAR/CLOB result rows, to match the behavior of cx_Oracle under Python
    3\. In order to mitigate the performance hit that the cx_Oracle dialect had previously
    with this behavior under Python 2, SQLAlchemy’s very performant (when C extensions
    are built) native Unicode handlers are used under Python 2. The automatic unicode
    coercion can be disabled by setting the `coerce_to_unicode` flag to False. This
    flag now defaults to True and applies to all string data returned in a result
    set that isn’t explicitly under [`Unicode`](../core/type_basics.html#sqlalchemy.types.Unicode
    "sqlalchemy.types.Unicode") or Oracle’s NVARCHAR2/NCHAR/NCLOB datatypes.
  prefs: []
  type: TYPE_NORMAL
- en: '[#4242](https://www.sqlalchemy.org/trac/ticket/4242)'
  prefs: []
  type: TYPE_NORMAL
- en: '### cx_Oracle connect arguments modernized, deprecated parameters removed'
  prefs: []
  type: TYPE_NORMAL
- en: 'A series of modernizations to the parameters accepted by the cx_oracle dialect
    as well as the URL string:'
  prefs: []
  type: TYPE_NORMAL
- en: The deprecated parameters `auto_setinputsizes`, `allow_twophase`, `exclude_setinputsizes`
    are removed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The value of the `threaded` parameter, which has always been defaulted to True
    for the SQLAlchemy dialect, is no longer generated by default. The SQLAlchemy
    [`Connection`](../core/connections.html#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    object is not considered to be thread-safe itself so there’s no need for this
    flag to be passed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s deprecated to pass `threaded` to [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") itself. To set the value of `threaded` to `True`,
    pass it to either the [`create_engine.connect_args`](../core/engines.html#sqlalchemy.create_engine.params.connect_args
    "sqlalchemy.create_engine") dictionary or use the query string e.g. `oracle+cx_oracle://...?threaded=true`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All parameters passed on the URL query string that are not otherwise specially
    consumed are now passed to the cx_Oracle.connect() function. A selection of these
    are also coerced either into cx_Oracle constants or booleans including `mode`,
    `purity`, `events`, and `threaded`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As was the case earlier, all cx_Oracle `.connect()` arguments are accepted via
    the [`create_engine.connect_args`](../core/engines.html#sqlalchemy.create_engine.params.connect_args
    "sqlalchemy.create_engine") dictionary, the documentation was inaccurate regarding
    this.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[#4369](https://www.sqlalchemy.org/trac/ticket/4369)'
  prefs: []
  type: TYPE_NORMAL
- en: Dialect Improvements and Changes - SQL Server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '### Support for pyodbc fast_executemany'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pyodbc’s recently added “fast_executemany” mode, available when using the Microsoft
    ODBC driver, is now an option for the pyodbc / mssql dialect. Pass it via [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE236]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Fast Executemany Mode](../dialects/mssql.html#mssql-pyodbc-fastexecutemany)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#4158](https://www.sqlalchemy.org/trac/ticket/4158)  ### New parameters to
    affect IDENTITY start and increment, use of Sequence deprecated'
  prefs: []
  type: TYPE_NORMAL
- en: 'SQL Server as of SQL Server 2012 now supports sequences with real `CREATE SEQUENCE`
    syntax. In [#4235](https://www.sqlalchemy.org/trac/ticket/4235), SQLAlchemy will
    add support for these using [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence") in the same way as for any other dialect. However,
    the current situation is that [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence") has been repurposed on SQL Server specifically in
    order to affect the “start” and “increment” parameters for the `IDENTITY` specification
    on a primary key column. In order to make the transition towards normal sequences
    being available as well, using [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence") will emit a deprecation warning throughout the 1.3
    series. In order to affect “start” and “increment”, use the new `mssql_identity_start`
    and `mssql_identity_increment` parameters on [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE237]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to emit `IDENTITY` on a non-primary key column, which is a little-used
    but valid SQL Server use case, use the [`Column.autoincrement`](../core/metadata.html#sqlalchemy.schema.Column.params.autoincrement
    "sqlalchemy.schema.Column") flag, setting it to `True` on the target column, `False`
    on any integer primary key column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE238]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Auto Increment Behavior / IDENTITY Columns](../dialects/mssql.html#mssql-identity)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#4362](https://www.sqlalchemy.org/trac/ticket/4362)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#4235](https://www.sqlalchemy.org/trac/ticket/4235)  ### Support for pyodbc
    fast_executemany'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pyodbc’s recently added “fast_executemany” mode, available when using the Microsoft
    ODBC driver, is now an option for the pyodbc / mssql dialect. Pass it via [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE239]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Fast Executemany Mode](../dialects/mssql.html#mssql-pyodbc-fastexecutemany)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#4158](https://www.sqlalchemy.org/trac/ticket/4158)'
  prefs: []
  type: TYPE_NORMAL
- en: '### New parameters to affect IDENTITY start and increment, use of Sequence
    deprecated'
  prefs: []
  type: TYPE_NORMAL
- en: 'SQL Server as of SQL Server 2012 now supports sequences with real `CREATE SEQUENCE`
    syntax. In [#4235](https://www.sqlalchemy.org/trac/ticket/4235), SQLAlchemy will
    add support for these using [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence") in the same way as for any other dialect. However,
    the current situation is that [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence") has been repurposed on SQL Server specifically in
    order to affect the “start” and “increment” parameters for the `IDENTITY` specification
    on a primary key column. In order to make the transition towards normal sequences
    being available as well, using [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence") will emit a deprecation warning throughout the 1.3
    series. In order to affect “start” and “increment”, use the new `mssql_identity_start`
    and `mssql_identity_increment` parameters on [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column"):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE240]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to emit `IDENTITY` on a non-primary key column, which is a little-used
    but valid SQL Server use case, use the [`Column.autoincrement`](../core/metadata.html#sqlalchemy.schema.Column.params.autoincrement
    "sqlalchemy.schema.Column") flag, setting it to `True` on the target column, `False`
    on any integer primary key column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE241]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs: []
  type: TYPE_NORMAL
- en: '[Auto Increment Behavior / IDENTITY Columns](../dialects/mssql.html#mssql-identity)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#4362](https://www.sqlalchemy.org/trac/ticket/4362)'
  prefs: []
  type: TYPE_NORMAL
- en: '[#4235](https://www.sqlalchemy.org/trac/ticket/4235)'
  prefs: []
  type: TYPE_NORMAL
- en: '## Changed StatementError formatting (newlines and %s)'
  prefs: []
  type: TYPE_NORMAL
- en: Two changes are introduced to the string representation for `StatementError`.
    The “detail” and “SQL” portions of the string representation are now separated
    by newlines, and newlines that are present in the original SQL statement are maintained.
    The goal is to improve readability while still keeping the original error message
    on one line for logging purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that an error message that previously looked like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE242]'
  prefs: []
  type: TYPE_PRE
- en: 'Will now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE243]'
  prefs: []
  type: TYPE_PRE
- en: The primary impact of this change is that consumers can no longer assume that
    a complete exception message is on a single line, however the original “error”
    portion that is generated from the DBAPI driver or SQLAlchemy internals will still
    be on the first line.
  prefs: []
  type: TYPE_NORMAL
- en: '[#4500](https://www.sqlalchemy.org/trac/ticket/4500)'
  prefs: []
  type: TYPE_NORMAL
