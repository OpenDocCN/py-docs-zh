- en: What’s New in SQLAlchemy 1.3?
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SQLAlchemy 1.3有什么新功能？
- en: 原文：[https://docs.sqlalchemy.org/en/20/changelog/migration_13.html](https://docs.sqlalchemy.org/en/20/changelog/migration_13.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://docs.sqlalchemy.org/en/20/changelog/migration_13.html](https://docs.sqlalchemy.org/en/20/changelog/migration_13.html)
- en: About this Document
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 关于本文档
- en: This document describes changes between SQLAlchemy version 1.2 and SQLAlchemy
    version 1.3.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本文描述了SQLAlchemy版本1.2和SQLAlchemy版本1.3之间的更改。
- en: Introduction
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍
- en: This guide introduces what’s new in SQLAlchemy version 1.3 and also documents
    changes which affect users migrating their applications from the 1.2 series of
    SQLAlchemy to 1.3.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本指南介绍了SQLAlchemy版本1.3中的新功能，还记录了影响用户将其应用程序从SQLAlchemy 1.2系列迁移到1.3的更改。
- en: Please carefully review the sections on behavioral changes for potentially backwards-incompatible
    changes in behavior.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 请仔细查看行为变化部分，可能会有不兼容的行为变化。
- en: General
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通用
- en: '### Deprecation warnings are emitted for all deprecated elements; new deprecations
    added'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '### 对所有弃用元素发出弃用警告；新增弃用项'
- en: Release 1.3 ensures that all behaviors and APIs that are deprecated, including
    all those that have been long listed as “legacy” for years, are emitting `DeprecationWarning`
    warnings. This includes when making use of parameters such as [`Session.weak_identity_map`](../orm/session_api.html#sqlalchemy.orm.Session.params.weak_identity_map
    "sqlalchemy.orm.Session") and classes such as `MapperExtension`. While all deprecations
    have been noted in the documentation, often they did not use a proper restructured
    text directive, or include in what version they were deprecated. Whether or not
    a particular API feature actually emitted a deprecation warning was not consistent.
    The general attitude was that most or all of these deprecated features were treated
    as long-term legacy features with no plans to remove them.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 发行版1.3确保所有被弃用的行为和API，包括那些长期被列为“遗留”的，都会发出`DeprecationWarning`警告。这包括在使用参数时，比如[`Session.weak_identity_map`](../orm/session_api.html#sqlalchemy.orm.Session.params.weak_identity_map
    "sqlalchemy.orm.Session")和类似`MapperExtension`的情况。虽然所有弃用情况都已在文档中记录，但通常它们没有使用正确的重构文本指令，或者包含它们被弃用的版本。特定API功能是否实际发出弃用警告并不一致。一般的态度是，大多数或所有这些弃用功能都被视为长期遗留功能，没有计划删除它们。
- en: The change includes that all documented deprecations now use a proper restructured
    text directive in the documentation with a version number, the verbiage that the
    feature or use case will be removed in a future release is made explicit (e.g.,
    no more legacy forever use cases), and that use of any such feature or use case
    will definitely emit a `DeprecationWarning`, which in Python 3 as well as when
    using modern testing tools like Pytest are now made more explicit in the standard
    error stream. The goal is that these long deprecated features, going back as far
    as version 0.7 or 0.6, should start being removed entirely, rather than keeping
    them around as “legacy” features. Additionally, some major new deprecations are
    being added as of version 1.3. As SQLAlchemy has 14 years of real world use by
    thousands of developers, it’s possible to point to a single stream of use cases
    that blend together well, and to trim away features and patterns that work against
    this single way of working.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这一变化包括，所有记录的弃用现在在文档中使用了正确的重构文本指令，并附有版本号，明确说明该功能或用例将在将来的版本中被移除（例如，不再有永久遗留用例），并且使用任何此类功能或用例将明确发出`DeprecationWarning`，在Python
    3中以及使用现代测试工具如Pytest时，现在在标准错误流中更加明确。目标是，这些长期被弃用的功能，甚至可以追溯到版本0.7或0.6，应该开始被完全移除，而不是将它们保留为“遗留”功能。此外，从版本1.3开始，还添加了一些重大的新弃用项。由于SQLAlchemy已经被成千上万的开发人员实际使用了14年，可以指出一个混合得很好的用例流，以及修剪掉与这种单一工作方式相悖的功能和模式。
- en: The larger context is that SQLAlchemy seeks to adjust to the coming Python 3-only
    world, as well as a type-annotated world, and towards this goal there are **tentative**
    plans for a major rework of SQLAlchemy which would hopefully greatly reduce the
    cognitive load of the API as well as perform a major pass over the great many
    differences in implementation and use between Core and ORM. As these two systems
    evolved dramatically after SQLAlchemy’s first release, in particular the ORM still
    retains lots of “bolted on” behaviors that keep the wall of separation between
    Core and ORM too high. By focusing the API ahead of time on a single pattern for
    each supported use case, the eventual job of migrating to a significantly altered
    API becomes simpler.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 更大的背景是，SQLAlchemy致力于适应即将到来的仅支持Python 3的世界，以及类型注释的世界，为此，SQLAlchemy有**暂定**计划进行一项重大重构，希望大大减少API的认知负担，并对Core和ORM之间的许多实现和使用差异进行重大调整。由于这两个系统在SQLAlchemy首次发布后发生了巨大变化，特别是ORM仍然保留着许多“外挂”行为，使得Core和ORM之间的隔离墙过高。通过提前将API集中在每个支持的用例的单一模式上，将来迁移到显著改变的API的工作变得更简单。
- en: For the most major deprecations being added in 1.3, see the linked sections
    below.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 有关1.3版本中添加的最重要的弃用功能，请参见下面的链接部分。
- en: See also
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[“threadlocal” engine strategy deprecated](#change-4393-threadlocal)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '[“threadlocal”引擎策略已弃用](#change-4393-threadlocal)'
- en: '[convert_unicode parameters deprecated](#change-4393-convertunicode)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '[convert_unicode 参数已弃用](#change-4393-convertunicode)'
- en: '[Relationship to AliasedClass replaces the need for non primary mappers](#change-4423)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '[AliasedClass 与非主映射器的关系取代了](#change-4423) '
- en: '[#4393](https://www.sqlalchemy.org/trac/ticket/4393)'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4393](https://www.sqlalchemy.org/trac/ticket/4393)'
- en: New Features and Improvements - ORM
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 新功能和改进 - ORM
- en: '### Relationship to AliasedClass replaces the need for non primary mappers'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '### AliasedClass 与非主映射器的关系取代了'
- en: The “non primary mapper” is a [`Mapper`](../orm/mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper") created in the [Imperative Mapping](../orm/mapping_styles.html#orm-imperative-mapping)
    style, which acts as an additional mapper against an already mapped class against
    a different kind of selectable. The non primary mapper has its roots in the 0.1,
    0.2 series of SQLAlchemy where it was anticipated that the [`Mapper`](../orm/mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper") object was to be the primary query construction interface,
    before the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    object existed.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: “非主映射器”是以[Imperative Mapping](../orm/mapping_styles.html#orm-imperative-mapping)风格创建的[`Mapper`](../orm/mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper")，它充当已经映射的类的附加映射器，针对不同类型的可选择项。非主映射器起源于SQLAlchemy的0.1、0.2系列，当时预期[`Mapper`](../orm/mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper")对象将是主要的查询构造接口，而[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")对象尚不存在。
- en: With the advent of [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") and later the [`AliasedClass`](../orm/queryguide/api.html#sqlalchemy.orm.util.AliasedClass
    "sqlalchemy.orm.util.AliasedClass") construct, most use cases for the non primary
    mapper went away. This was a good thing since SQLAlchemy also moved away from
    “classical” mappings altogether around the 0.5 series in favor of the declarative
    system.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 随着[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")的出现，以及后来的[`AliasedClass`](../orm/queryguide/api.html#sqlalchemy.orm.util.AliasedClass
    "sqlalchemy.orm.util.AliasedClass")构造，大多数非主映射器的用例都消失了。这是一件好事，因为SQLAlchemy在0.5系列左右也完全摆脱了“经典”映射，转而采用了声明式系统。
- en: One use case remained around for non primary mappers when it was realized that
    some very hard-to-define [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") configurations could be made possible when a non-primary
    mapper with an alternative selectable was made as the mapping target, rather than
    trying to construct a [`relationship.primaryjoin`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.primaryjoin
    "sqlalchemy.orm.relationship") that encompassed all the complexity of a particular
    inter-object relationship.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当意识到一些非常难以定义的[`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")配置可能成为可能时，保留了一个非主映射器的用例，当一个具有替代可选择项的非主映射器被作为映射目标时，而不是尝试构建一个涵盖特定对象间关系所有复杂性的[`relationship.primaryjoin`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.primaryjoin
    "sqlalchemy.orm.relationship")。
- en: As this use case became more popular, its limitations became apparent, including
    that the non primary mapper is difficult to configure against a selectable that
    adds new columns, that the mapper does not inherit the relationships of the original
    mapping, that relationships which are configured explicitly on the non primary
    mapper do not function well with loader options, and that the non primary mapper
    also doesn’t provide a fully functional namespace of column-based attributes which
    can be used in queries (which again, in the old 0.1 - 0.4 days, one would use
    [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    objects directly with the ORM).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 随着这种用例变得更加流行，它的局限性变得明显，包括非主映射器难以配置到可选择添加新列的可选项上，映射器不继承原始映射的关系，显式配置在非主映射器上的关系与加载器选项不兼容，非主映射器也没有提供可用于查询的基于列的属性的完全功能命名空间（在旧的0.1
    - 0.4版本中，人们会直接使用[`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")对象与ORM一起使用）。
- en: The missing piece was to allow the [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") to refer directly to the [`AliasedClass`](../orm/queryguide/api.html#sqlalchemy.orm.util.AliasedClass
    "sqlalchemy.orm.util.AliasedClass"). The [`AliasedClass`](../orm/queryguide/api.html#sqlalchemy.orm.util.AliasedClass
    "sqlalchemy.orm.util.AliasedClass") already does everything we want the non primary
    mapper to do; it allows an existing mapped class to be loaded from an alternative
    selectable, it inherits all the attributes and relationships of the existing mapper,
    it works extremely well with loader options, and it provides a class-like object
    that can be mixed into queries just like the class itself. With this change, the
    recipes that were formerly for non primary mappers at [Configuring how Relationship
    Joins](../orm/join_conditions.html#relationship-configure-joins) are changed to
    aliased class.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 缺失的部分是允许[`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")直接引用[`AliasedClass`](../orm/queryguide/api.html#sqlalchemy.orm.util.AliasedClass
    "sqlalchemy.orm.util.AliasedClass")。[`AliasedClass`](../orm/queryguide/api.html#sqlalchemy.orm.util.AliasedClass
    "sqlalchemy.orm.util.AliasedClass")已经做了我们希望非主映射器做的一切；它允许从替代可选择项加载现有映射类，继承现有映射器的所有属性和关系，与加载器选项非常配合，提供一个类似类的对象，可以像类本身一样混入查询中。通过这种改变，以前针对非主映射器的配方在[配置关系连接方式](../orm/join_conditions.html#relationship-configure-joins)中被更改为别名类。
- en: 'At [Relationship to Aliased Class](../orm/join_conditions.html#relationship-aliased-class),
    the original non primary mapper looked like:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在[关系到别名类](../orm/join_conditions.html#relationship-aliased-class)时，原始的非主映射器看起来像：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The properties were necessary in order to re-map the additional columns so that
    they did not conflict with the existing columns mapped to `B`, as well as it was
    necessary to define a new primary key.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这些属性是必要的，以便重新映射额外的列，使其不与映射到`B`的现有列发生冲突，同时也需要定义一个新的主键。
- en: 'With the new approach, all of this verbosity goes away, and the additional
    columns are referenced directly when making the relationship:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 使用新方法，所有这些冗长的内容都消失了，并且在建立关系时直接引用了额外的列：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The non primary mapper is now deprecated with the eventual goal to be that classical
    mappings as a feature go away entirely. The Declarative API would become the single
    means of mapping which hopefully will allow internal improvements and simplifications,
    as well as a clearer documentation story.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 非主映射器现在已被弃用，最终目标是使经典映射作为一项功能完全消失。声明式API将成为映射的唯一手段，这希望能够实现内部改进和简化，以及更清晰的文档故事。
- en: '[#4423](https://www.sqlalchemy.org/trac/ticket/4423)  ### selectin loading
    no longer uses JOIN for simple one-to-many'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4423](https://www.sqlalchemy.org/trac/ticket/4423)  ### selectin加载不再对简单的一对多使用JOIN。'
- en: The “selectin” loading feature added in 1.2 introduced an extremely performant
    new way to eagerly load collections, in many cases much faster than that of “subquery”
    eager loading, as it does not rely upon restating the original SELECT query and
    instead uses a simple IN clause. However, the “selectin” load still relied upon
    rendering a JOIN between the parent and related tables, since it needs the parent
    primary key values in the row in order to match rows up. In 1.3, a new optimization
    is added which will omit this JOIN in the most common case of a simple one-to-many
    load, where the related row already contains the primary key of the parent row
    expressed in its foreign key columns. This again provides for a dramatic performance
    improvement as the ORM now can load large numbers of collections all in one query
    without using JOIN or subqueries at all.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在1.2版本中添加的“selectin”加载功能引入了一种极其高效的新方法来急切加载集合，在许多情况下比“subquery”急切加载要快得多，因为它不依赖于重新声明原始SELECT查询，而是使用一个简单的IN子句。然而，“selectin”加载仍然依赖于在父表和相关表之间渲染JOIN，因为它需要父表主键值在行中以匹配行。在1.3中，添加了一种新的优化，将在简单的一对多加载的最常见情况下省略此JOIN，其中相关行已经包含了父行的主键值，表达在其外键列中。这再次提供了显著的性能改进，因为ORM现在可以在一个查询中加载大量集合，而根本不使用JOIN或子查询。
- en: 'Given a mapping:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个映射：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the 1.2 version of “selectin” loading, a load of A to B looks like:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在“selectin”加载的1.2版本中，A到B的加载如下：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'With the new behavior, the load looks like:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 使用新行为，加载如下：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The behavior is being released as automatic, using a similar heuristic that
    lazy loading uses in order to determine if related entities can be fetched directly
    from the identity map. However, as with most querying features, the feature’s
    implementation became more complex as a result of advanced scenarios regarding
    polymorphic loading. If problems are encountered, users should report a bug, however
    the change also includes a flag [`relationship.omit_join`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.omit_join
    "sqlalchemy.orm.relationship") which can be set to `False` on the [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") to disable the optimization.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 该行为被释放为自动的，使用类似于延迟加载使用的启发式方法，以确定是否可以直接从标识映射中获取相关实体。然而，与大多数查询功能一样，由于涉及多态加载的高级场景，该功能的实现变得更加复杂。如果遇到问题，用户应该报告错误，但更改还包括一个标志[`relationship.omit_join`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.omit_join
    "sqlalchemy.orm.relationship")，可以在[`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")上设置为`False`以禁用优化。
- en: '[#4340](https://www.sqlalchemy.org/trac/ticket/4340)  ### Improvement to the
    behavior of many-to-one query expressions'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4340](https://www.sqlalchemy.org/trac/ticket/4340)  ### 改进多对一查询表达式的行为'
- en: 'When building a query that compares a many-to-one relationship to an object
    value, such as:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当构建一个将多对一关系与对象值进行比较的查询时，例如：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The above expression `Address.user == u1`, which ultimately compiles to a SQL
    expression normally based on the primary key columns of the `User` object like
    `"address.user_id = 5"`, uses a deferred callable in order to retrieve the value
    `5` within the bound expression until as late as possible. This is to suit both
    the use case where the `Address.user == u1` expression may be against a `User`
    object that isn’t flushed yet which relies upon a server- generated primary key
    value, as well as that the expression always returns the correct result even if
    the primary key value of `u1` has been changed since the expression was created.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 上述表达式`Address.user == u1`，最终编译为基于`User`对象的主键列的SQL表达式，如`"address.user_id = 5"`，使用延迟可调用以在绑定表达式中尽可能晚地检索值`5`。这是为了适应`Address.user
    == u1`表达式可能针对尚未刷新的`User`对象的用例，该对象依赖于服务器生成的主键值，以及该表达式始终返回正确结果的情况，即使自创建表达式以来`u1`的主键值已更改。
- en: 'However, a side effect of this behavior is that if `u1` ends up being expired
    by the time the expression is evaluated, it results in an additional SELECT statement,
    and in the case that `u1` was also detached from the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), it would raise an error:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种行为的一个副作用是，如果在评估表达式时`u1`最终过期，它将导致额外的SELECT语句，并且如果`u1`也从[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")中分离，它将引发错误：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The expiration / expunging of the object can occur implicitly when the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is committed and the `u1` instance falls out of scope,
    as the `Address.user == u1` expression does not strongly reference the object
    itself, only its [`InstanceState`](../orm/internals.html#sqlalchemy.orm.InstanceState
    "sqlalchemy.orm.InstanceState").
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 对象的过期/清除可以在[`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")提交时隐式发生，并且`u1`实例超出范围时，因为`Address.user
    == u1`表达式并不强烈引用对象本身，只引用其[`InstanceState`](../orm/internals.html#sqlalchemy.orm.InstanceState
    "sqlalchemy.orm.InstanceState")。
- en: The fix is to allow the `Address.user == u1` expression to evaluate the value
    `5` based on attempting to retrieve or load the value normally at expression compilation
    time as it does now, but if the object is detached and has been expired, it is
    retrieved from a new mechanism upon the [`InstanceState`](../orm/internals.html#sqlalchemy.orm.InstanceState
    "sqlalchemy.orm.InstanceState") which will memoize the last known value for a
    particular attribute on that state when that attribute is expired. This mechanism
    is only enabled for a specific attribute / [`InstanceState`](../orm/internals.html#sqlalchemy.orm.InstanceState
    "sqlalchemy.orm.InstanceState") when needed by the expression feature to conserve
    performance / memory overhead.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 修复的方法是允许`Address.user == u1`表达式根据尝试在表达式编译时正常检索或加载值来评估值`5`，就像现在一样，但如果对象已分离并已过期，则从[`InstanceState`](../orm/internals.html#sqlalchemy.orm.InstanceState
    "sqlalchemy.orm.InstanceState")上的新机制中检索，该机制将在属性过期时在该状态上记忆该属性的最后已知值。当表达式功能需要时，此机制仅为特定属性/
    [`InstanceState`](../orm/internals.html#sqlalchemy.orm.InstanceState "sqlalchemy.orm.InstanceState")启用，以节省性能/内存开销。
- en: Originally, simpler approaches such as evaluating the expression immediately
    with various arrangements for trying to load the value later if not present were
    attempted, however the difficult edge case is that of the value of a column attribute
    (typically a natural primary key) that is being changed. In order to ensure that
    an expression like `Address.user == u1` always returns the correct answer for
    the current state of `u1`, it will return the current database-persisted value
    for a persistent object, unexpiring via SELECT query if necessary, and for a detached
    object it will return the most recent known value, regardless of when the object
    was expired using a new feature within the [`InstanceState`](../orm/internals.html#sqlalchemy.orm.InstanceState
    "sqlalchemy.orm.InstanceState") that tracks the last known value of a column attribute
    whenever the attribute is to be expired.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，尝试了诸如立即评估表达式并尝试稍后加载值的各种简化方法，但困难的边缘情况是正在更改的列属性值（通常是自然主键）。为了确保像`Address.user
    == u1`这样的表达式始终返回`u1`当前状态的正确答案，它将返回持久对象的当前数据库持久化值，如果需要，通过SELECT查询取消过期，并且对于分离对象，它将返回最近已知的值，而不管对象何时使用[`InstanceState`](../orm/internals.html#sqlalchemy.orm.InstanceState
    "sqlalchemy.orm.InstanceState")中的新功能过期跟踪列属性的最后已知值。
- en: Modern attribute API features are used to indicate specific error messages when
    the value cannot be evaluated, the two cases of which are when the column attributes
    have never been set, and when the object was already expired when the first evaluation
    was made and is now detached. In all cases, [`DetachedInstanceError`](../orm/exceptions.html#sqlalchemy.orm.exc.DetachedInstanceError
    "sqlalchemy.orm.exc.DetachedInstanceError") is no longer raised.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当值无法评估时，现代属性API功能用于指示特定的错误消息，这两种情况是当列属性从未设置时，以及当对象在进行第一次评估时已过期并且现在已分离。在所有情况下，不再引发[`DetachedInstanceError`](../orm/exceptions.html#sqlalchemy.orm.exc.DetachedInstanceError
    "sqlalchemy.orm.exc.DetachedInstanceError")。
- en: '[#4359](https://www.sqlalchemy.org/trac/ticket/4359)  ### Many-to-one replacement
    won’t raise for “raiseload” or detached for “old” object'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4359](https://www.sqlalchemy.org/trac/ticket/4359)  ### 多对一替换不会对“raiseload”或“old”对象引发异常'
- en: 'Given the case where a lazy load would proceed on a many-to-one relationship
    in order to load the “old” value, if the relationship does not specify the [`relationship.active_history`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.active_history
    "sqlalchemy.orm.relationship") flag, an assertion will not be raised for a detached
    object:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多对一关系上进行延迟加载以加载“旧”值的情况下，如果关系未指定[`relationship.active_history`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.active_history
    "sqlalchemy.orm.relationship")标志，则不会为分离对象引发断言：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Above, when the `.user` attribute is replaced on the detached `a1` object, a
    [`DetachedInstanceError`](../orm/exceptions.html#sqlalchemy.orm.exc.DetachedInstanceError
    "sqlalchemy.orm.exc.DetachedInstanceError") would be raised as the attribute is
    attempting to retrieve the previous value of `.user` from the identity map. The
    change is that the operation now proceeds without the old value being loaded.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的情况下，当在分离的`a1`对象上替换`.user`属性时，将引发[`DetachedInstanceError`](../orm/exceptions.html#sqlalchemy.orm.exc.DetachedInstanceError
    "sqlalchemy.orm.exc.DetachedInstanceError")，因为属性试图从标识映射中检索`.user`的先前值。变化在于，操作现在继续进行而不加载旧值。
- en: 'The same change is also made to the `lazy="raise"` loader strategy:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的更改也适用于`lazy="raise"`加载策略：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Previously, the association of `a1.user` would invoke the “raiseload” exception
    as a result of the attribute attempting to retrieve the previous value. This assertion
    is now skipped in the case of loading the “old” value.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，`a1.user`的关联会触发“raiseload”异常，因为属性试图检索先前的值。在加载“旧”值的情况下，现在跳过此断言。
- en: '[#4353](https://www.sqlalchemy.org/trac/ticket/4353)  ### “del” implemented
    for ORM attributes'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4353](https://www.sqlalchemy.org/trac/ticket/4353)  ### 为ORM属性实现了“del”'
- en: 'The Python `del` operation was not really usable for mapped attributes, either
    scalar columns or object references. Support has been added for this to work correctly,
    where the `del` operation is roughly equivalent to setting the attribute to the
    `None` value:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Python的`del`操作实际上对于映射属性（标量列或对象引用）并不可用。已添加支持，使其能够正确工作，其中`del`操作大致相当于将属性设置为`None`值：
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[#4354](https://www.sqlalchemy.org/trac/ticket/4354)  ### info dictionary added
    to InstanceState'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4354](https://www.sqlalchemy.org/trac/ticket/4354)  ### 在InstanceState中添加了info字典'
- en: 'Added the `.info` dictionary to the [`InstanceState`](../orm/internals.html#sqlalchemy.orm.InstanceState
    "sqlalchemy.orm.InstanceState") class, the object that comes from calling [`inspect()`](../core/inspection.html#sqlalchemy.inspect
    "sqlalchemy.inspect") on a mapped object. This allows custom recipes to add additional
    information about an object that will be carried along with that object’s full
    lifecycle in memory:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 将`.info`字典添加到[`InstanceState`](../orm/internals.html#sqlalchemy.orm.InstanceState
    "sqlalchemy.orm.InstanceState")类中，该对象是通过调用映射对象上的[`inspect()`](../core/inspection.html#sqlalchemy.inspect
    "sqlalchemy.inspect")而来。这允许自定义方案添加有关对象的额外信息，这些信息将随着对象在内存中的整个生命周期而传递：
- en: '[PRE10]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[#4257](https://www.sqlalchemy.org/trac/ticket/4257)  ### Horizontal Sharding
    extension supports bulk update and delete methods'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4257](https://www.sqlalchemy.org/trac/ticket/4257)  ### 水平分片扩展支持批量更新和删除方法'
- en: The [`ShardedQuery`](../orm/extensions/horizontal_shard.html#sqlalchemy.ext.horizontal_shard.ShardedQuery
    "sqlalchemy.ext.horizontal_shard.ShardedQuery") extension object supports the
    [`Query.update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.update "sqlalchemy.orm.Query.update")
    and [`Query.delete()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.delete
    "sqlalchemy.orm.Query.delete") bulk update/delete methods. The `query_chooser`
    callable is consulted when they are called in order to run the update/delete across
    multiple shards based on given criteria.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '[`ShardedQuery`](../orm/extensions/horizontal_shard.html#sqlalchemy.ext.horizontal_shard.ShardedQuery
    "sqlalchemy.ext.horizontal_shard.ShardedQuery")扩展对象支持[`Query.update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.update
    "sqlalchemy.orm.Query.update")和[`Query.delete()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.delete
    "sqlalchemy.orm.Query.delete")批量更新/删除方法。在调用它们时，将咨询`query_chooser`可调用对象，以便根据给定的条件在多个分片上运行更新/删除操作。'
- en: '[#4196](https://www.sqlalchemy.org/trac/ticket/4196)'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4196](https://www.sqlalchemy.org/trac/ticket/4196)'
- en: Association Proxy Improvements
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Association Proxy改进
- en: While not for any particular reason, the Association Proxy extension had many
    improvements this cycle.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管没有特定原因，但是在本周期内，Association Proxy扩展进行了许多改进。
- en: '#### Association proxy has new cascade_scalar_deletes flag'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '#### Association proxy新增了cascade_scalar_deletes标志'
- en: 'Given a mapping as:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个映射如下：
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'An assignment to `A.b` will generate an `AB` object:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 对`A.b`的赋值将生成一个`AB`对象：
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `A.b` association is scalar, and includes a new flag [`AssociationProxy.cascade_scalar_deletes`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy.params.cascade_scalar_deletes
    "sqlalchemy.ext.associationproxy.AssociationProxy"). When set, setting `A.b` to
    `None` will remove `A.ab` as well. The default behavior remains that it leaves
    `a.ab` in place:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`A.b`关联是标量的，并包括一个新标志[`AssociationProxy.cascade_scalar_deletes`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy.params.cascade_scalar_deletes
    "sqlalchemy.ext.associationproxy.AssociationProxy")。设置时，��`A.b`设置为`None`也将删除`A.ab`。默认行为仍然是保留`a.ab`不变：'
- en: '[PRE13]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: While it at first seemed intuitive that this logic should just look at the “cascade”
    attribute of the existing relationship, it’s not clear from that alone if the
    proxied object should be removed, hence the behavior is made available as an explicit
    option.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 起初，这种逻辑看起来应该只查看现有关系的“级联”属性，这似乎很直观，但仅凭这一点就不清楚代理对象是否应该被移除，因此行为被作为一个明确的选项提供。
- en: 'Additionally, `del` now works for scalars in a similar manner as setting to
    `None`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`del` 现在对标量的操作方式与设置为 `None` 相似：
- en: '[PRE14]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[#4308](https://www.sqlalchemy.org/trac/ticket/4308)  #### AssociationProxy
    stores class-specific state on a per-class basis'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4308](https://www.sqlalchemy.org/trac/ticket/4308)  #### AssociationProxy
    在每个类上存储特定于类的状态'
- en: The [`AssociationProxy`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy
    "sqlalchemy.ext.associationproxy.AssociationProxy") object makes lots of decisions
    based on the parent mapped class it is associated with. While the [`AssociationProxy`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy
    "sqlalchemy.ext.associationproxy.AssociationProxy") historically began as a relatively
    simple ‘getter,’ it became apparent early on that it also needed to make decisions
    regarding the kind of attribute to which it refers—such as scalar or collection,
    mapped object or simple value, and so on. To achieve this, it needs to inspect
    the mapped attribute or other referring descriptor or attribute, as referenced
    from its parent class. However in Python descriptor mechanics, a descriptor only
    learns about its “parent” class when it is accessed in the context of that class,
    such as calling `MyClass.some_descriptor`, which calls the `__get__()` method
    which passes in the class. The [`AssociationProxy`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy
    "sqlalchemy.ext.associationproxy.AssociationProxy") object would therefore store
    state that is specific to that class, but only once this method were called; trying
    to inspect this state ahead of time without first accessing the [`AssociationProxy`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy
    "sqlalchemy.ext.associationproxy.AssociationProxy") as a descriptor would raise
    an error. Additionally, it would assume that the first class to be seen by `__get__()`
    would be the only parent class it needed to know about. This is despite the fact
    that if a particular class has inheriting subclasses, the association proxy is
    really working on behalf of more than one parent class even though it was not
    explicitly re-used. While even with this shortcoming, the association proxy would
    still get pretty far with its current behavior, it still leaves shortcomings in
    some cases as well as the complex problem of determining the best “owner” class.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '[`AssociationProxy`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy
    "sqlalchemy.ext.associationproxy.AssociationProxy") 对象基于其关联的父映射类做出许多决策。虽然 [`AssociationProxy`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy
    "sqlalchemy.ext.associationproxy.AssociationProxy") 最初只是一个相对简单的‘getter’，但很快就明显地需要做出关于其引用的属性类型的决策——比如标量或集合、映射对象或简单值等。为了实现这一点，它需要检查映射属性或其他引用描述符或属性，如从其父类引用的那样。然而，在
    Python 描述符机制中，描述符只有在在其“父”类的上下文中被访问时才会了解其“父”类，比如调用 `MyClass.some_descriptor`，这会调用
    `__get__()` 方法，该方法传递类。因此，[`AssociationProxy`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy
    "sqlalchemy.ext.associationproxy.AssociationProxy") 对象将存储特定于该类的状态，但只有在调用此方法后才会调用；在未首先将
    [`AssociationProxy`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy
    "sqlalchemy.ext.associationproxy.AssociationProxy") 作为描述符访问的情况下尝试检查此状态将引发错误。此外，它会假设
    `__get__()` 首次看到的类将是唯一需要了解的父类。尽管如果特定类具有继承子类，关联代理实际上是代表不止一个父类工作，即使没有明确重用。即使在存在这种缺陷的情况下，关联代理仍然可以通过其当前行为取得相当大的进展，但在某些情况下仍存在缺陷，以及确定最佳“所有者”类的复杂问题。'
- en: These problems are now solved in that [`AssociationProxy`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy
    "sqlalchemy.ext.associationproxy.AssociationProxy") no longer modifies its own
    internal state when `__get__()` is called; instead, a new object is generated
    per-class known as [`AssociationProxyInstance`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxyInstance
    "sqlalchemy.ext.associationproxy.AssociationProxyInstance") which handles all
    the state specific to a particular mapped parent class (when the parent class
    is not mapped, no [`AssociationProxyInstance`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxyInstance
    "sqlalchemy.ext.associationproxy.AssociationProxyInstance") is generated). The
    concept of a single “owning class” for the association proxy, which was nonetheless
    improved in 1.1, has essentially been replaced with an approach where the AP now
    can treat any number of “owning” classes equally.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这些问题已经得到解决，当调用 `__get__()` 时，[`AssociationProxy`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy
    "sqlalchemy.ext.associationproxy.AssociationProxy") 不再修改自己的内部状态；相反，每个类都生成了一个名为
    [`AssociationProxyInstance`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxyInstance
    "sqlalchemy.ext.associationproxy.AssociationProxyInstance") 的新对象，它处理了特定于特定映射父类的所有状态（当父类未映射时，不会生成
    [`AssociationProxyInstance`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxyInstance
    "sqlalchemy.ext.associationproxy.AssociationProxyInstance")）。关于关联代理的单一“拥有类”的概念，尽管在1.1中有所改进，但基本上已被一种方法所取代，即AP现在可以平等地处理任意数量的“拥有”类。
- en: 'To accommodate for applications that want to inspect this state for an [`AssociationProxy`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy
    "sqlalchemy.ext.associationproxy.AssociationProxy") without necessarily calling
    `__get__()`, a new method [`AssociationProxy.for_class()`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy.for_class
    "sqlalchemy.ext.associationproxy.AssociationProxy.for_class") is added that provides
    direct access to a class-specific [`AssociationProxyInstance`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxyInstance
    "sqlalchemy.ext.associationproxy.AssociationProxyInstance"), demonstrated as:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 为了适应那些想要检查这种状态的应用程序，而不一定要调用 `__get__()` 的 [`AssociationProxy`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy
    "sqlalchemy.ext.associationproxy.AssociationProxy")，添加了一个新方法 [`AssociationProxy.for_class()`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy.for_class
    "sqlalchemy.ext.associationproxy.AssociationProxy.for_class")，提供了直接访问特定于类的 [`AssociationProxyInstance`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxyInstance
    "sqlalchemy.ext.associationproxy.AssociationProxyInstance")，如下所示：
- en: '[PRE15]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Once we have the [`AssociationProxyInstance`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxyInstance
    "sqlalchemy.ext.associationproxy.AssociationProxyInstance") object, in the above
    example stored in the `proxy_state` variable, we can look at attributes specific
    to the `User.keywords` proxy, such as `target_class`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了 [`AssociationProxyInstance`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxyInstance
    "sqlalchemy.ext.associationproxy.AssociationProxyInstance") 对象，如上例中存储在 `proxy_state`
    变量中，我们可以查看特定于 `User.keywords` 代理的属性，例如 `target_class`：
- en: '[PRE16]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[#3423](https://www.sqlalchemy.org/trac/ticket/3423)  #### AssociationProxy
    now provides standard column operators for a column-oriented target'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3423](https://www.sqlalchemy.org/trac/ticket/3423)  #### `AssociationProxy`
    现在为基于列的目标提供了标准的列操作符'
- en: 'Given an [`AssociationProxy`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy
    "sqlalchemy.ext.associationproxy.AssociationProxy") where the target is a database
    column, and is **not** an object reference or another association proxy:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个 [`AssociationProxy`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy
    "sqlalchemy.ext.associationproxy.AssociationProxy")，其中目标是数据库列，并且**不是**对象引用或另一个关联代理：
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `User.values` association proxy refers to the `Element.value` column. Standard
    column operations are now available, such as `like`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`User.values` 关联代理指的是 `Element.value` 列。现在已经提供了标准的列操作，比如 `like`：'
- en: '[PRE18]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '`equals`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`equals`:'
- en: '[PRE19]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'When comparing to `None`, the `IS NULL` expression is augmented with a test
    that the related row does not exist at all; this is the same behavior as before:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当与 `None` 比较时，`IS NULL` 表达式被增强，以测试相关行根本不存在；这与以前的行为相同：
- en: '[PRE20]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Note that the [`ColumnOperators.contains()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.contains
    "sqlalchemy.sql.expression.ColumnOperators.contains") operator is in fact a string
    comparison operator; **this is a change in behavior** in that previously, the
    association proxy used `.contains` as a list containment operator only. With a
    column-oriented comparison, it now behaves like a “like”:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 [`ColumnOperators.contains()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.contains
    "sqlalchemy.sql.expression.ColumnOperators.contains") 操作符实际上是一个字符串比较操作符；**这是行为上的变化**，以前，关联代理仅将
    `.contains` 用作列表包含操作符。使用列导向的比较，它现在的行为类似于“like”：
- en: '[PRE21]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In order to test the `User.values` collection for simple membership of the value
    `"foo"`, the equals operator (e.g. `User.values == 'foo'`) should be used; this
    works in previous versions as well.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试 `User.values` 集合是否包含值 `"foo"`，应使用等号操作符（例如 `User.values == 'foo'`）；这在以前的版本中也适用。
- en: 'When using an object-based association proxy with a collection, the behavior
    is as before, that of testing for collection membership, e.g. given a mapping:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用基于对象的关联代理与集合时，行为与以前相同，即测试集合成员资格，例如，给定一个映射：
- en: '[PRE22]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `.contains()` method produces the same expression as before, testing the
    list of `User.elements` for the presence of an `Element` object:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`.contains()` 方法生成与以前相同的表达式，测试 `User.elements` 列表中是否存在 `Element` 对象：'
- en: '[PRE23]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Overall, the change is enabled based on the architectural change that is part
    of [AssociationProxy stores class-specific state on a per-class basis](#change-3423);
    as the proxy now spins off additional state when an expression is generated, there
    is both an object-target and a column-target version of the [`AssociationProxyInstance`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxyInstance
    "sqlalchemy.ext.associationproxy.AssociationProxyInstance") class.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，这个改变是基于[AssociationProxy stores class-specific state on a per-class basis](#change-3423)的结构性改变而启用的；因为代理现在在生成表达式时衍生了额外的状态，所以有一个对象目标版本和一个列目标版本的[`AssociationProxyInstance`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxyInstance
    "sqlalchemy.ext.associationproxy.AssociationProxyInstance") 类。
- en: '[#4351](https://www.sqlalchemy.org/trac/ticket/4351)'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4351](https://www.sqlalchemy.org/trac/ticket/4351)'
- en: Association Proxy now Strong References the Parent Object
  id: totrans-103
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 关联代理现在强引用父对象
- en: The long-standing behavior of the association proxy collection maintaining only
    a weak reference to the parent object is reverted; the proxy will now maintain
    a strong reference to the parent for as long as the proxy collection itself is
    also in memory, eliminating the “stale association proxy” error. This change is
    being made on an experimental basis to see if any use cases arise where it causes
    side effects.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 关联代理集合仅维护对父对象的弱引用的长期行为被还原；代理现在将在代理集合本身也在内存中的情况下维护对父对象的强引用，从而消除“stale association
    proxy”错误。此更改正在实验性地进行，以查看是否会引起任何副作用。
- en: 'As an example, given a mapping with association proxy:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，给定一个具有关联代理的映射：
- en: '[PRE24]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Previously, if `a1` were deleted out of scope:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，如果 `a1` 超出范围被删除：
- en: '[PRE25]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Trying to iterate the `b_data` collection after `a1` is deleted from scope
    would raise the error `"stale association proxy, parent object has gone out of
    scope"`. This is because the association proxy needs to access the actual `a1.bs`
    collection in order to produce a view, and prior to this change it maintained
    only a weak reference to `a1`. In particular, users would frequently encounter
    this error when performing an inline operation such as:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `a1` 在范围内被删除后尝试迭代 `b_data` 集合会引发错误 `"stale association proxy, parent object
    has gone out of scope"`。这是因为关联代理需要访问实际的 `a1.bs` 集合以生成视图，在这次更改之前，它仅维护对 `a1` 的弱引用。特别是，用户在执行内联操作时经常会遇到这个错误，例如：
- en: '[PRE26]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Above, because the `A` object would be garbage collected before the `b_data`
    collection were actually used.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 以上，因为在 `b_data` 集合实际使用之前，`A` 对象将被垃圾回收。
- en: 'The change is that the `b_data` collection is now maintaining a strong reference
    to the `a1` object, so that it remains present:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 更改是 `b_data` 集合现在维护对 `a1` 对象的强引用，以使其保持存在：
- en: '[PRE27]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This change introduces the side effect that if an application is passing around
    the collection as above, **the parent object won’t be garbage collected** until
    the collection is also discarded. As always, if `a1` is persistent inside a particular
    [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session"),
    it will remain part of that session’s state until it is garbage collected.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 此更改引入了一个副作用，即如果应用程序像上面那样传递集合，**父对象在集合被丢弃之前不会被垃圾回收**。一如既往，如果`a1`在特定的[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")中是持久的，它将保持在该会话的状态中，直到被垃圾回收。
- en: Note that this change may be revised if it leads to problems.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果此更改导致问题，可能会对其进行修订。
- en: '[#4268](https://www.sqlalchemy.org/trac/ticket/4268)'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4268](https://www.sqlalchemy.org/trac/ticket/4268)'
- en: '#### Implemented bulk replace for sets, dicts with AssociationProxy'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 为集合和关联代理实现了批量替换'
- en: 'Assignment of a set or dictionary to an association proxy collection should
    now work correctly, whereas before it would re-create association proxy members
    for existing keys, leading to the issue of potential flush failures due to the
    delete+insert of the same object it now should only create new association objects
    where appropriate:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 将集合或字典分配给关联代理集合现在应该能正常工作了，而以前会为现有键重新创建关联代理成员，导致由于相同对象的删除+插入而导致潜在刷新失败的问题，现在应该只在适当的情况下创建新的关联对象：
- en: '[PRE28]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[#2642](https://www.sqlalchemy.org/trac/ticket/2642)  ### Many-to-one backref
    checks for collection duplicates during remove operation'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2642](https://www.sqlalchemy.org/trac/ticket/2642)  ### 多对一反向引用在删除操作期间检查集合重复项'
- en: 'When an ORM-mapped collection that existed as a Python sequence, typically
    a Python `list` as is the default for [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship"), contained duplicates, and the object were removed
    from one of its positions but not the other(s), a many-to-one backref would set
    its attribute to `None` even though the one-to-many side still represented the
    object as present. Even though one-to-many collections cannot have duplicates
    in the relational model, an ORM-mapped [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") that uses a sequence collection can have duplicates
    inside of it in memory, with the restriction that this duplicate state can neither
    be persisted nor retrieved from the database. In particular, having a duplicate
    temporarily present in the list is intrinsic to a Python “swap” operation. Given
    a standard one-to-many/many-to-one setup:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当作为Python序列存在的ORM映射集合，通常是Python `list`（作为[`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")的默认值），包含重复项，并且对象从其中一个位置移除但未从其他位置移除时，多对一反向引用会将其属性设置为`None`，即使一对多侧仍然表示对象存在。即使一对多集合在关系模型中不能有重复项，但使用序列集合的ORM映射的[`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")在内存中可以有重复项，限制是此重复状态既不能持久化也不能从数据库中检索。特别是，在列表中临时存在重复项是Python“交换”操作的固有特性。给定标准的一对多/多对一设置：
- en: '[PRE29]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If we have an `A` object with two `B` members, and perform a swap:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个具有两个`B`成员的`A`对象，并执行交换：
- en: '[PRE30]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'During the above operation, interception of the standard Python `__setitem__`
    `__delitem__` methods delivers an interim state where the second `B()` object
    is present twice in the collection. When the `B()` object is removed from one
    of the positions, the `B.a` backref would set the reference to `None`, causing
    the link between the `A` and `B` object to be removed during the flush. The same
    issue can be demonstrated using plain duplicates:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述操作期间，拦截标准Python `__setitem__` `__delitem__`方法提供了第二个`B()`对象在集合中出现两次的临时状态。当`B()`对象从一个位置移除时，`B.a`反向引用将将引用设置为`None`，导致在刷新期间删除`A`和`B`对象之间的链接。相同的问题也可以使用普通重复项来演示：
- en: '[PRE31]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The fix ensures that when the backref fires off, which is before the collection
    is mutated, the collection is checked for exactly one or zero instances of the
    target item before unsetting the many-to-one side, using a linear search which
    at the moment makes use of `list.search` and `list.__contains__`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 此修复确保在触发反向引用之前（在集合被改变之前），会检查集合中是否恰好有一个或零个目标项的实例，然后在取消多对一侧时使用线性搜索，目前使用`list.search`和`list.__contains__`。
- en: Originally it was thought that an event-based reference counting scheme would
    need to be used within the collection internals so that all duplicate instances
    could be tracked throughout the lifecycle of the collection, which would have
    added a performance/memory/complexity impact to all collection operations, including
    the very frequent operations of loading and appending. The approach that is taken
    instead limits the additional expense to the less common operations of collection
    removal and bulk replacement, and the observed overhead of the linear scan is
    negligible; linear scans of relationship-bound collections are already used within
    the unit of work as well as when a collection is bulk replaced.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 最初认为需要在集合内部使用基于事件的引用计数方案，以便在整个集合的生命周期中跟踪所有重复的实例，这将对所有集合操作产生性能/内存/复杂性影响，包括非常频繁的加载和追加操作。相反采取的方法将额外的开销限制在集合移除和批量替换这些不太常见的操作上，并且线性扫描的观察开销是可以忽略的；在工作单元内以及在集合进行批量替换时，已经在关系绑定集合中使用了线性扫描。
- en: '[#1103](https://www.sqlalchemy.org/trac/ticket/1103)'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '[#1103](https://www.sqlalchemy.org/trac/ticket/1103)'
- en: Key Behavioral Changes - ORM
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关键行为变化 - ORM
- en: '### Query.join() handles ambiguity in deciding the “left” side more explicitly'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '### Query.join()更明确地处理决定“左”侧的模棱两可情况'
- en: 'Historically, given a query like the following:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 从历史上看，给定如下查询：
- en: '[PRE32]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'given the standard tutorial mappings, the query would produce a FROM clause
    as:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于标准教程映射，查询将产生一个FROM子句如下：
- en: '[PRE33]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'That is, the JOIN would implicitly be against the first entity that matches.
    The new behavior is that an exception requests that this ambiguity be resolved:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，JOIN将隐式地与第一个匹配的实体进行连接。新的行为是，异常请求解决这种模棱两可的情况：
- en: '[PRE34]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The solution is to provide an ON clause, either as an expression:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是提供一个ON子句，可以是一个表达式：
- en: '[PRE35]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Or to use the relationship attribute, if available:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 或者使用关系属性，如果可用的话：
- en: '[PRE36]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The change includes that a join can now correctly link to a FROM clause that
    is not the first element in the list if the join is otherwise non-ambiguous:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 更改包括现在JOIN可以正确地链接到不是列表中第一个元素的FROM子句，如果JOIN本身不是模棱两可的话：
- en: '[PRE37]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Prior to this enhancement, the above query would raise:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在此增强之前，上述查询将引发：
- en: '[PRE38]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now the query works fine:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在查询正常工作：
- en: '[PRE39]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Overall the change is directly towards Python’s “explicit is better than implicit”
    philosophy.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，这种变化直接符合Python的“显式优于隐式”的哲学。
- en: '[#4365](https://www.sqlalchemy.org/trac/ticket/4365)  ### FOR UPDATE clause
    is rendered within the joined eager load subquery as well as outside'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4365](https://www.sqlalchemy.org/trac/ticket/4365)  ### FOR UPDATE子句在联合加载子查询中以及外部呈现'
- en: This change applies specifically to the use of the [`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload") loading strategy in conjunction with a row limited
    query, e.g. using [`Query.first()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.first
    "sqlalchemy.orm.Query.first") or [`Query.limit()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.limit
    "sqlalchemy.orm.Query.limit"), as well as with use of the [`Query.with_for_update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.with_for_update
    "sqlalchemy.orm.Query.with_for_update") method.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 此更改特别适用于使用[`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload")加载策略与行限制查询结合使用时，例如使用[`Query.first()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.first
    "sqlalchemy.orm.Query.first")或[`Query.limit()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.limit
    "sqlalchemy.orm.Query.limit")，以及使用[`Query.with_for_update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.with_for_update
    "sqlalchemy.orm.Query.with_for_update")方法。
- en: 'Given a query as:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个查询如下：
- en: '[PRE40]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    object renders a SELECT of the following form when joined eager loading is combined
    with LIMIT:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当联合加载与LIMIT结合时，[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")对象呈现以下形式的SELECT：
- en: '[PRE41]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'This is so that the limit of rows takes place for the primary entity without
    affecting the joined eager load of related items. When the above query is combined
    with “SELECT..FOR UPDATE”, the behavior has been this:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做是为了使主实体的行限制不影响相关项目的联合加载。当上述查询与“SELECT..FOR UPDATE”结合时，行为是这样的：
- en: '[PRE42]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'However, MySQL due to [https://bugs.mysql.com/bug.php?id=90693](https://bugs.mysql.com/bug.php?id=90693)
    does not lock the rows inside the subquery, unlike that of PostgreSQL and other
    databases. So the above query now renders as:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于 MySQL [https://bugs.mysql.com/bug.php?id=90693](https://bugs.mysql.com/bug.php?id=90693)
    不锁定子查询中的行，不像 PostgreSQL 和其他数据库。因此，上述查询现在呈现为：
- en: '[PRE43]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: On the Oracle dialect, the inner “FOR UPDATE” is not rendered as Oracle does
    not support this syntax and the dialect skips any “FOR UPDATE” that is against
    a subquery; it isn’t necessary in any case since Oracle, like PostgreSQL, correctly
    locks all elements of the returned row.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Oracle 方言中，内部的“FOR UPDATE”不会呈现，因为 Oracle 不支持此语法，方言会跳过针对子查询的任何“FOR UPDATE”；在任何情况下都不是必要的，因为
    Oracle 像 PostgreSQL 一样正确锁定返回行的所有元素。
- en: 'When using the [`Query.with_for_update.of`](../orm/queryguide/query.html#sqlalchemy.orm.Query.with_for_update.params.of
    "sqlalchemy.orm.Query.with_for_update") modifier, typically on PostgreSQL, the
    outer “FOR UPDATE” is omitted, and the OF is now rendered on the inside; previously,
    the OF target would not be converted to accommodate for the subquery correctly.
    So given:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 [`Query.with_for_update.of`](../orm/queryguide/query.html#sqlalchemy.orm.Query.with_for_update)
    修饰符时，通常在 PostgreSQL 上，外部的“FOR UPDATE”被省略，OF 现在在内部呈现；以前，OF 目标不会被正确转换以适应子查询。所以给定：
- en: '[PRE44]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The query would now render as:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 查询现在会呈现为：
- en: '[PRE45]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The above form should be helpful on PostgreSQL additionally since PostgreSQL
    will not allow the FOR UPDATE clause to be rendered after the LEFT OUTER JOIN
    target.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 以上形式在 PostgreSQL 上应该有所帮助，此外，由于 PostgreSQL 不允许在 LEFT OUTER JOIN 目标之后呈现 FOR UPDATE
    子句。
- en: Overall, FOR UPDATE remains highly specific to the target database in use and
    can’t easily be generalized for more complex queries.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，FOR UPDATE 仍然高度特定于正在使用的目标数据库，并且不能轻易地推广到更复杂的查询。
- en: '[#4246](https://www.sqlalchemy.org/trac/ticket/4246)  ### passive_deletes=’all’
    will leave FK unchanged for object removed from collection'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4246](https://www.sqlalchemy.org/trac/ticket/4246)  ### passive_deletes=’all’
    将使 FK 在从集合中移除的对象中保持不变'
- en: 'The [`relationship.passive_deletes`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.passive_deletes
    "sqlalchemy.orm.relationship") option accepts the value `"all"` to indicate that
    no foreign key attributes should be modified when the object is flushed, even
    if the relationship’s collection / reference has been removed. Previously, this
    did not take place for one-to-many, or one-to-one relationships, in the following
    situation:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '[`relationship.passive_deletes`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.passive_deletes
    "sqlalchemy.orm.relationship") 选项接受值 `"all"`，表示当对象被刷新时，不应修改任何外键属性，即使关系的集合/引用已被移除。以前，在以下情况下不会发生这种情况：'
- en: '[PRE46]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The fix now includes that `address.user_id` is left unchanged as per `passive_deletes="all"`.
    This kind of thing is useful for building custom “version table” schemes and such
    where rows are archived instead of deleted.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 修复现在包括 `address.user_id` 保持不变，根据 `passive_deletes="all"`。这种情况对于构建自定义“版本表”方案等非常有用，其中行被归档而不是删除。
- en: '[#3844](https://www.sqlalchemy.org/trac/ticket/3844)  ## New Features and Improvements
    - Core'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3844](https://www.sqlalchemy.org/trac/ticket/3844)  ## 新功能和改进 - 核心'
- en: '### New multi-column naming convention tokens, long name truncation'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '### 新的多列命名约定标记，长名称截断'
- en: 'To suit the case where a [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") naming convention needs to disambiguate between
    multiple-column constraints and wishes to use all the columns within the generated
    constraint name, a new series of naming convention tokens are added, including
    `column_0N_name`, `column_0_N_name`, `column_0N_key`, `column_0_N_key`, `referred_column_0N_name`,
    `referred_column_0_N_name`, etc., which render the column name (or key or label)
    for all columns in the constraint, joined together either with no separator or
    with an underscore separator. Below we define a convention that will name [`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint") constraints with a name that joins together
    the names of all columns:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 为了适应一个[`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData "sqlalchemy.schema.MetaData")命名约定需要在多列约束之间消除歧义，并希望在生成的约束名中使用所有列的情况，添加了一系列新的命名约定标记，包括`column_0N_name`、`column_0_N_name`、`column_0N_key`、`column_0_N_key`、`referred_column_0N_name`、`referred_column_0_N_name`等，它们将约束中所有列的列名（或键或标签）连接在一起，要么没有分隔符，要么用下划线分隔符连接。下面我们定义一个约定，将[`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint")约束命名为所有列名称的组合：
- en: '[PRE47]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'The CREATE TABLE for the above table will render as:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 上述表的 CREATE TABLE 将呈现为：
- en: '[PRE48]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'In addition, long-name truncation logic is now applied to the names generated
    by naming conventions, in particular to accommodate for multi-column labels that
    can produce very long names. This logic, which is the same as that used for truncating
    long label names in a SELECT statement, replaces excess characters that go over
    the identifier-length limit for the target database with a deterministically generated
    4-character hash. For example, on PostgreSQL where identifiers cannot be longer
    than 63 characters, a long constraint name would normally be generated from the
    table definition below:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，现在将长名称截断逻辑应用于由命名约定生成的名称，特别是为了适应可能产生非常长名称的多列标签。这种逻辑与在SELECT语句中截断长标签名称所使用的逻辑相同，它会用一个确定性生成的4字符哈希替换超过目标数据库标识符长度限制的多余字符。例如，在
    PostgreSQL 中，标识符不能超过63个字符，一个长约束名通常会从下面的表定义中生成：
- en: '[PRE49]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The truncation logic will ensure a too-long name isn’t generated for the UNIQUE
    constraint:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 截断逻辑将确保不会为唯一约束生成过长的名称：
- en: '[PRE50]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The above suffix `a79e` is based on the md5 hash of the long name and will generate
    the same value every time to produce consistent names for a given schema.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 上述后缀`a79e`基于长名称的 md5 哈希，并且每次都会生成相同的值，以产生给定模式的一致名称。
- en: 'Note that the truncation logic also raises [`IdentifierError`](../core/exceptions.html#sqlalchemy.exc.IdentifierError
    "sqlalchemy.exc.IdentifierError") when a constraint name is explicitly too large
    for a given dialect. This has been the behavior for an [`Index`](../core/constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index") object for a long time, but is now applied to other
    kinds of constraints as well:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当约束名称对于给定方言明确过大时，截断逻辑还会引发[`IdentifierError`](../core/exceptions.html#sqlalchemy.exc.IdentifierError
    "sqlalchemy.exc.IdentifierError")。这已经是很长时间以来[`Index`](../core/constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index")对象的行为，但现在也适用于其他类型的约束：
- en: '[PRE51]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'will output:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 将输出：
- en: '[PRE52]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The exception raise prevents the production of non-deterministic constraint
    names truncated by the database backend which are then not compatible with database
    migrations later on.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 异常抛出阻止了由数据库后端截断的非确定性约束名称的生成，这些名称后来与数据库迁移不兼容。
- en: 'To apply SQLAlchemy-side truncation rules to the above identifier, use the
    [`conv()`](../core/constraints.html#sqlalchemy.schema.conv "sqlalchemy.schema.conv")
    construct:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 SQLAlchemy 端的截断规则应用于上述标识符，请使用[`conv()`](../core/constraints.html#sqlalchemy.schema.conv
    "sqlalchemy.schema.conv")构造：
- en: '[PRE53]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'This will again output deterministically truncated SQL as in:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这将再次输出确定性截断的 SQL，如下所示：
- en: '[PRE54]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: There is not at the moment an option to have the names pass through to allow
    database-side truncation. This has already been the case for [`Index`](../core/constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index") names for some time and issues have not been raised.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 目前还没有选项使名称通过以允许数据库端截断。这在[`Index`](../core/constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index")名称上已经有一段时间了，也没有引起问题。
- en: The change also repairs two other issues. One is that the `column_0_key` token
    wasn’t available even though this token was documented, the other was that the
    `referred_column_0_name` token would inadvertently render the `.key` and not the
    `.name` of the column if these two values were different.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 此更改还修复了另外两个问题。 其中一个是`column_0_key`令牌尽管已记录文档，但却不可用，另一个是`referred_column_0_name`令牌如果这两个值不同，则会无意中渲染`.key`而不是列的`.name`。
- en: See also
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Configuring Constraint Naming Conventions](../core/constraints.html#constraint-naming-conventions)'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '[配置约束命名约定](../core/constraints.html#constraint-naming-conventions)'
- en: '[`MetaData.naming_convention`](../core/metadata.html#sqlalchemy.schema.MetaData.params.naming_convention
    "sqlalchemy.schema.MetaData")'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '[`MetaData.naming_convention`](../core/metadata.html#sqlalchemy.schema.MetaData.params.naming_convention
    "sqlalchemy.schema.MetaData")'
- en: '[#3989](https://www.sqlalchemy.org/trac/ticket/3989)  ### Binary comparison
    interpretation for SQL functions'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3989](https://www.sqlalchemy.org/trac/ticket/3989)  ### SQL 函数的二进制比较解释'
- en: This enhancement is implemented at the Core level, however is applicable primarily
    to the ORM.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 此增强功能是在核心级别实现的，但主要适用于ORM。
- en: 'A SQL function that compares two elements can now be used as a “comparison”
    object, suitable for usage in an ORM [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship"), by first creating the function as usual using
    the [`func`](../core/sqlelement.html#sqlalchemy.sql.expression.func "sqlalchemy.sql.expression.func")
    factory, then when the function is complete calling upon the [`FunctionElement.as_comparison()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.as_comparison
    "sqlalchemy.sql.functions.FunctionElement.as_comparison") modifier to produce
    a [`BinaryExpression`](../core/sqlelement.html#sqlalchemy.sql.expression.BinaryExpression
    "sqlalchemy.sql.expression.BinaryExpression") that has a “left” and a “right”
    side:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，可以将比较两个元素的SQL函数用作“比较”对象，适用于ORM [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")的使用，首先像往常一样使用 [`func`](../core/sqlelement.html#sqlalchemy.sql.expression.func
    "sqlalchemy.sql.expression.func") 工厂创建函数，然后当函数完成时调用 [`FunctionElement.as_comparison()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.as_comparison
    "sqlalchemy.sql.functions.FunctionElement.as_comparison") 修改器以生成具有“左”和“右”侧的 [`BinaryExpression`](../core/sqlelement.html#sqlalchemy.sql.expression.BinaryExpression
    "sqlalchemy.sql.expression.BinaryExpression")：
- en: '[PRE55]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Above, the [`relationship.primaryjoin`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.primaryjoin
    "sqlalchemy.orm.relationship") of the “descendants” relationship will produce
    a “left” and a “right” expression based on the first and second arguments passed
    to `instr()`. This allows features like the ORM lazyload to produce SQL like:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 上述[`relationship.primaryjoin`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.primaryjoin
    "sqlalchemy.orm.relationship")中的“descendants”关系将基于传递给`instr()`的第一个和第二个参数生成“左”和“右”表达式。
    这允许ORM懒加载等功能生成类似以下的SQL：
- en: '[PRE56]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'and a joinedload, such as:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 和 joinedload，例如：
- en: '[PRE57]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'to work as:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 使其工作如下：
- en: '[PRE58]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This feature is expected to help with situations such as making use of geometric
    functions in relationship join conditions, or any case where the ON clause of
    the SQL join is expressed in terms of a SQL function.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 该功能预计将有助于处理诸如在关系连接条件中使用几何函数，或者任何在 SQL 连接的 ON 子句中以 SQL 函数的形式表达的情况等情况。
- en: '[#3831](https://www.sqlalchemy.org/trac/ticket/3831)  ### Expanding IN feature
    now supports empty lists'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3831](https://www.sqlalchemy.org/trac/ticket/3831)  ### 扩展 IN 功能现在支持空列表'
- en: 'The “expanding IN” feature introduced in version 1.2 at [Late-expanded IN parameter
    sets allow IN expressions with cached statements](migration_12.html#change-3953)
    now supports empty lists passed to the [`ColumnOperators.in_()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.in_
    "sqlalchemy.sql.expression.ColumnOperators.in_") operator. The implementation
    for an empty list will produce an “empty set” expression that is specific to a
    target backend, such as “SELECT CAST(NULL AS INTEGER) WHERE 1!=1” for PostgreSQL,
    “SELECT 1 FROM (SELECT 1) as _empty_set WHERE 1!=1” for MySQL:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在版本1.2中引入的“expanding IN”功能现在支持传递给[`ColumnOperators.in_()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.in_
    "sqlalchemy.sql.expression.ColumnOperators.in_")运算符的空列表。 对于空列表的实现将生成一个针对目标后端具体的“空集合”表达式，例如对于
    PostgreSQL，“SELECT CAST(NULL AS INTEGER) WHERE 1!=1”，对于 MySQL，“SELECT 1 FROM (SELECT
    1) as _empty_set WHERE 1!=1”：
- en: '[PRE59]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The feature also works for tuple-oriented IN statements, where the “empty IN”
    expression will be expanded to support the elements given inside the tuple, such
    as on PostgreSQL:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 该功能还适用于基于元组的 IN 语句，其中“空 IN”表达式将被扩展以支持元组中给定的元素，例如在 PostgreSQL 上：
- en: '[PRE60]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[#4271](https://www.sqlalchemy.org/trac/ticket/4271)  ### TypeEngine methods
    bind_expression, column_expression work with Variant, type-specific types'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4271](https://www.sqlalchemy.org/trac/ticket/4271)  ### TypeEngine 方法 bind_expression,
    column_expression 适用于 Variant、特定类型'
- en: The [`TypeEngine.bind_expression()`](../core/type_api.html#sqlalchemy.types.TypeEngine.bind_expression
    "sqlalchemy.types.TypeEngine.bind_expression") and [`TypeEngine.column_expression()`](../core/type_api.html#sqlalchemy.types.TypeEngine.column_expression
    "sqlalchemy.types.TypeEngine.column_expression") methods now work when they are
    present on the “impl” of a particular datatype, allowing these methods to be used
    by dialects as well as for [`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") and [`Variant`](../core/type_api.html#sqlalchemy.types.Variant
    "sqlalchemy.types.Variant") use cases.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 当这些方法存在于特定数据类型的“impl”上时，[`TypeEngine.bind_expression()`](../core/type_api.html#sqlalchemy.types.TypeEngine.bind_expression
    "sqlalchemy.types.TypeEngine.bind_expression") 和 [`TypeEngine.column_expression()`](../core/type_api.html#sqlalchemy.types.TypeEngine.column_expression
    "sqlalchemy.types.TypeEngine.column_expression") 方法现在可以工作，允许方言以及 [`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") 和 [`Variant`](../core/type_api.html#sqlalchemy.types.Variant
    "sqlalchemy.types.Variant") 使用这些方法。
- en: 'The following example illustrates a [`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") that applies SQL-time conversion functions to
    a [`LargeBinary`](../core/type_basics.html#sqlalchemy.types.LargeBinary "sqlalchemy.types.LargeBinary").
    In order for this type to work in the context of a [`Variant`](../core/type_api.html#sqlalchemy.types.Variant
    "sqlalchemy.types.Variant"), the compiler needs to drill into the “impl” of the
    variant expression in order to locate these methods:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例说明了一个将 SQL 时间转换函数应用于 [`LargeBinary`](../core/type_basics.html#sqlalchemy.types.LargeBinary
    "sqlalchemy.types.LargeBinary") 的 [`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator")。为了使此类型在 [`Variant`](../core/type_api.html#sqlalchemy.types.Variant
    "sqlalchemy.types.Variant") 的上下文中工作，编译器需要深入到变体表达式的“impl”中以定位这些方法：
- en: '[PRE61]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The above expression will render a function within SQL when used on SQLite
    only:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 上述表达式仅在 SQLite 上使用时会呈现为 SQL 中的函数：
- en: '[PRE62]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'will render:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 将呈现为：
- en: '[PRE63]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The change also includes that dialects can implement [`TypeEngine.bind_expression()`](../core/type_api.html#sqlalchemy.types.TypeEngine.bind_expression
    "sqlalchemy.types.TypeEngine.bind_expression") and [`TypeEngine.column_expression()`](../core/type_api.html#sqlalchemy.types.TypeEngine.column_expression
    "sqlalchemy.types.TypeEngine.column_expression") on dialect-level implementation
    types where they will now be used; in particular this will be used for MySQL’s
    new “binary prefix” requirement as well as for casting decimal bind values for
    MySQL.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 此更改还包括方言可以在方言级别的实现类型上实现[`TypeEngine.bind_expression()`](../core/type_api.html#sqlalchemy.types.TypeEngine.bind_expression
    "sqlalchemy.types.TypeEngine.bind_expression")和[`TypeEngine.column_expression()`](../core/type_api.html#sqlalchemy.types.TypeEngine.column_expression
    "sqlalchemy.types.TypeEngine.column_expression")，在那里它们现在将被使用；特别是这将用于 MySQL 的新“二进制前缀”要求以及用于将
    MySQL 的十进制绑定值转换为强制转换的情况。
- en: '[#3981](https://www.sqlalchemy.org/trac/ticket/3981)  ### New last-in-first-out
    strategy for QueuePool'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3981](https://www.sqlalchemy.org/trac/ticket/3981)  ### 新的后进先出策略适用于 QueuePool'
- en: The connection pool usually used by [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") is known as [`QueuePool`](../core/pooling.html#sqlalchemy.pool.QueuePool
    "sqlalchemy.pool.QueuePool"). This pool uses an object equivalent to Python’s
    built-in `Queue` class in order to store database connections waiting to be used.
    The `Queue` features first-in-first-out behavior, which is intended to provide
    a round-robin use of the database connections that are persistently in the pool.
    However, a potential downside of this is that when the utilization of the pool
    is low, the re-use of each connection in series means that a server-side timeout
    strategy that attempts to reduce unused connections is prevented from shutting
    down these connections. To suit this use case, a new flag [`create_engine.pool_use_lifo`](../core/engines.html#sqlalchemy.create_engine.params.pool_use_lifo
    "sqlalchemy.create_engine") is added which reverses the `.get()` method of the
    `Queue` to pull the connection from the beginning of the queue instead of the
    end, essentially turning the “queue” into a “stack” (adding a whole new pool called
    `StackPool` was considered, however this was too much verbosity).
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 通常由[`create_engine()`](../core/engines.html#sqlalchemy.create_engine "sqlalchemy.create_engine")使用的连接池被称为[`QueuePool`](../core/pooling.html#sqlalchemy.pool.QueuePool
    "sqlalchemy.pool.QueuePool")。 这个池使用一个类似于 Python 内置的`Queue`类的对象来存储等待使用的数据库连接。 `Queue`具有先进先出的行为，旨在提供对池中持久存在的数据库连接的循环使用。
    然而，这种方法的一个潜在缺点是，当池的利用率较低时，池中每个连接的串行重复使用意味着试图减少未使用连接的服务器端超时策略被阻止关闭这些连接。 为了适应这种用例，添加了一个新标志[`create_engine.pool_use_lifo`](../core/engines.html#sqlalchemy.create_engine.params.pool_use_lifo
    "sqlalchemy.create_engine")，它将`Queue`的`.get()`方法反转，从队列的开头而不是末尾获取连接，从本质上将“队列”变成“栈”（考虑到这太啰嗦，因此没有添加一个名为`StackPool`的全新池）。
- en: See also
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Using FIFO vs. LIFO](../core/pooling.html#pool-use-lifo)'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用 FIFO vs. LIFO](../core/pooling.html#pool-use-lifo)'
- en: Key Changes - Core
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 核心关键变化
- en: '### Coercion of string SQL fragments to text() fully removed'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '### 完全移除将字符串 SQL 片段强制转换为 text()'
- en: The warnings that were first added in version 1.0, described at [Warnings emitted
    when coercing full SQL fragments into text()](migration_10.html#migration-2992),
    have now been converted into exceptions. Continued concerns have been raised regarding
    the automatic coercion of string fragments passed to methods like [`Query.filter()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.filter
    "sqlalchemy.orm.Query.filter") and [`Select.order_by()`](../core/selectable.html#sqlalchemy.sql.expression.Select.order_by
    "sqlalchemy.sql.expression.Select.order_by") being converted to [`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text
    "sqlalchemy.sql.expression.text") constructs, even though this has emitted a warning.
    In the case of [`Select.order_by()`](../core/selectable.html#sqlalchemy.sql.expression.Select.order_by
    "sqlalchemy.sql.expression.Select.order_by"), [`Query.order_by()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.order_by
    "sqlalchemy.orm.Query.order_by"), [`Select.group_by()`](../core/selectable.html#sqlalchemy.sql.expression.Select.group_by
    "sqlalchemy.sql.expression.Select.group_by"), and [`Query.group_by()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.group_by
    "sqlalchemy.orm.Query.group_by"), a string label or column name is still resolved
    into the corresponding expression construct, however if the resolution fails,
    a [`CompileError`](../core/exceptions.html#sqlalchemy.exc.CompileError "sqlalchemy.exc.CompileError")
    is raised, thus preventing raw SQL text from being rendered directly.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 首次添加于版本 1.0 的警告，描述在[将完整 SQL 片段强制转换为 text() 时发出的警告](migration_10.html#migration-2992)，现已转换为异常。
    对于像[`Query.filter()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.filter
    "sqlalchemy.orm.Query.filter")和[`Select.order_by()`](../core/selectable.html#sqlalchemy.sql.expression.Select.order_by
    "sqlalchemy.sql.expression.Select.order_by")这样的方法传递的字符串片段自动转换为[`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text
    "sqlalchemy.sql.expression.text")构造的自动转换引发了持续的担忧，尽管这已发出警告。 在[`Select.order_by()`](../core/selectable.html#sqlalchemy.sql.expression.Select.order_by
    "sqlalchemy.sql.expression.Select.order_by")、[`Query.order_by()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.order_by
    "sqlalchemy.orm.Query.order_by")、[`Select.group_by()`](../core/selectable.html#sqlalchemy.sql.expression.Select.group_by
    "sqlalchemy.sql.expression.Select.group_by")和[`Query.group_by()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.group_by
    "sqlalchemy.orm.Query.group_by")的情况下，字符串标签或列名仍然会解析为相应的表达式构造，但如果解析失败，则会引发[`CompileError`](../core/exceptions.html#sqlalchemy.exc.CompileError
    "sqlalchemy.exc.CompileError")，从而防止直接呈现原始 SQL 文本。
- en: '[#4481](https://www.sqlalchemy.org/trac/ticket/4481)  ### “threadlocal” engine
    strategy deprecated'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4481](https://www.sqlalchemy.org/trac/ticket/4481)  ### “threadlocal”引擎策略已弃用'
- en: The “threadlocal engine strategy” was added around SQLAlchemy 0.2, as a solution
    to the problem that the standard way of operating in SQLAlchemy 0.1, which can
    be summed up as “threadlocal everything”, was found to be lacking. In retrospect,
    it seems fairly absurd that by SQLAlchemy’s first releases which were in every
    regard “alpha”, that there was concern that too many users had already settled
    on the existing API to simply change it.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: “线程本地引擎策略”是在SQLAlchemy 0.2左右添加的，作为解决在SQLAlchemy 0.1中操作的标准方式存在问题的解决方案，可以总结为“一切都是线程本地”。回顾来看，似乎相当荒谬，SQLAlchemy的首次发布在各方面都是“alpha”版本，已经担心太多用户已经定居在现有API上，无法简单地更改它。
- en: 'The original usage model for SQLAlchemy looked like this:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy的原始使用模型如下：
- en: '[PRE64]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'After a few months of real world use, it was clear that trying to pretend a
    “connection” or a “transaction” was a hidden implementation detail was a bad idea,
    particularly the moment someone needed to deal with more than one database connection
    at a time. So the usage paradigm we see today was introduced, minus the context
    managers since they didn’t yet exist in Python:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 经过几个月的实际使用，很明显，假装“连接”或“事务”是一个隐藏的实现细节是一个坏主意，特别是当有人需要同时处理多个数据库连接时。因此，我们今天看到的使用范式被引入，减去了上下文管理器，因为它们在Python中尚不存在：
- en: '[PRE65]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The above paradigm was what people needed, but since it was still kind of verbose
    (because no context managers), the old way of working was kept around as well
    and it became the threadlocal engine strategy.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 上述范式是人们所需要的，但由于仍然有点啰嗦（因为没有上下文管理器），旧的工作方式也被保留了下来，并成为了线程本地引擎策略。
- en: 'Today, working with Core is much more succinct, and even more succinct than
    the original pattern, thanks to context managers:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，与Core一起工作要简洁得多，甚至比原始模式更简洁，这要归功于上下文管理器：
- en: '[PRE66]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: At this point, any remaining code that is still relying upon the “threadlocal”
    style will be encouraged via this deprecation to modernize - the feature should
    be removed totally by the next major series of SQLAlchemy, e.g. 1.4\. The connection
    pool parameter [`Pool.use_threadlocal`](../core/pooling.html#sqlalchemy.pool.Pool.params.use_threadlocal
    "sqlalchemy.pool.Pool") is also deprecated as it does not actually have any effect
    in most cases, as is the `Engine.contextual_connect()` method, which is normally
    synonymous with the [`Engine.connect()`](../core/connections.html#sqlalchemy.engine.Engine.connect
    "sqlalchemy.engine.Engine.connect") method except in the case where the threadlocal
    engine is in use.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，任何仍然依赖“threadlocal”风格的代码都将通过此弃用被鼓励进行现代化改造 - 该功能应在下一个主要系列的SQLAlchemy中完全移除，例如1.4版。连接池参数[`Pool.use_threadlocal`](../core/pooling.html#sqlalchemy.pool.Pool.params.use_threadlocal
    "sqlalchemy.pool.Pool")也已弃用，因为在大多数情况下实际上没有任何效果，`Engine.contextual_connect()`方法也已弃用，该方法通常与[`Engine.connect()`](../core/connections.html#sqlalchemy.engine.Engine.connect
    "sqlalchemy.engine.Engine.connect")方法是同义的，除非使用了线程本地引擎。
- en: '[#4393](https://www.sqlalchemy.org/trac/ticket/4393)  ### convert_unicode parameters
    deprecated'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4393](https://www.sqlalchemy.org/trac/ticket/4393)  ### convert_unicode参数已弃用'
- en: The parameters [`String.convert_unicode`](../core/type_basics.html#sqlalchemy.types.String.params.convert_unicode
    "sqlalchemy.types.String") and [`create_engine.convert_unicode`](../core/engines.html#sqlalchemy.create_engine.params.convert_unicode
    "sqlalchemy.create_engine") are deprecated. The purpose of these parameters was
    to instruct SQLAlchemy to ensure that incoming Python Unicode objects under Python
    2 were encoded to bytestrings before passing to the database, and to expect bytestrings
    from the database to be converted back to Python Unicode objects. In the pre-Python
    3 era, this was an enormous ordeal to get right, as virtually all Python DBAPIs
    had no Unicode support enabled by default, and most had major issues with the
    Unicode extensions that they did provide. Eventually, SQLAlchemy added C extensions,
    one of the primary purposes of these extensions was to speed up the Unicode decode
    process within result sets.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 参数[`String.convert_unicode`](../core/type_basics.html#sqlalchemy.types.String.params.convert_unicode
    "sqlalchemy.types.String")和[`create_engine.convert_unicode`](../core/engines.html#sqlalchemy.create_engine.params.convert_unicode
    "sqlalchemy.create_engine")已被弃用。这些参数的目的是指示SQLAlchemy确保在Python 2中传递给数据库之前将传入的Python
    Unicode对象编码为字节字符串，并期望从数据库接收的字节字符串转换回Python Unicode对象。在Python 3之前的时代，这是一个巨大的挑战，因为几乎所有的Python
    DBAPI默认情况下都没有启用Unicode支持，并且大多数都存在与它们提供的Unicode扩展相关的主要问题。最终，SQLAlchemy添加了C扩展，其中一个主要目的是加快结果集中的Unicode解码过程。
- en: Once Python 3 was introduced, DBAPIs began to start supporting Unicode more
    fully, and more importantly, by default. However, the conditions under which a
    particular DBAPI would or would not return Unicode data from a result, as well
    as accept Python Unicode values as parameters, remained extremely complicated.
    This was the beginning of the obsolescence of the “convert_unicode” flags, because
    they were no longer sufficient as a means of ensuring that encode/decode was occurring
    only where needed and not where it wasn’t needed. Instead, “convert_unicode” started
    to be automatically detected by dialects. Part of this can be seen in the “SELECT
    ‘test plain returns’” and “SELECT ‘test_unicode_returns’” SQL emitted by an engine
    the first time it connects; the dialect is testing that the current DBAPI with
    its current settings and backend database connection is returning Unicode by default
    or not.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦引入了Python 3，DBAPI开始更全面地支持Unicode，并且更重要的是，默认情况下支持Unicode。然而，特定DBAPI在何种条件下返回Unicode数据以及接受Python
    Unicode值作为参数的条件仍然非常复杂。这标志着“convert_unicode”标志开始过时，因为它们不再足以确保编码/解码仅在需要时发生，而不是在不需要时发生。相反，“convert_unicode”开始被方言自动检测。这可以在引擎第一次连接时发出的“SELECT
    ‘test plain returns’”和“SELECT ‘test_unicode_returns’”SQL中看到；方言正在测试当前DBAPI及其当前设置和后端数据库连接是否默认返回Unicode。
- en: The end result is that end-user use of the “convert_unicode” flags should no
    longer be needed in any circumstances, and if they are, the SQLAlchemy project
    needs to know what those cases are and why. Currently, hundreds of Unicode round
    trip tests pass across all major databases without the use of this flag so there
    is a fairly high level of confidence that they are no longer needed except in
    arguable non use cases such as accessing mis-encoded data from a legacy database,
    which would be better suited using custom types.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果是，终端用户在任何情况下都不再需要使用“convert_unicode”标志，如果需要，SQLAlchemy项目需要知道这些情况及原因。目前，在所有主要数据库上，数百个Unicode往返测试通过，而不使用此标志，因此可以相当有信心地说它们不再需要，除非在争议的非使用情况下，例如访问来自传统数据库的错误编码数据，这种情况最好使用自定义类型。
- en: '[#4393](https://www.sqlalchemy.org/trac/ticket/4393)'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4393](https://www.sqlalchemy.org/trac/ticket/4393)'
- en: Dialect Improvements and Changes - PostgreSQL
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方言改进和更改 - PostgreSQL
- en: '### Added basic reflection support for PostgreSQL partitioned tables'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '### 为PostgreSQL分区表添加基本反射支持'
- en: SQLAlchemy can render the “PARTITION BY” sequence within a PostgreSQL CREATE
    TABLE statement using the flag `postgresql_partition_by`, added in version 1.2.6\.
    However, the `'p'` type was not part of the reflection queries used until now.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy可以使用版本1.2.6中添加的`postgresql_partition_by`标志，在PostgreSQL的CREATE TABLE语句中呈现“PARTITION
    BY”序列。然而，`'p'`类型直到现在都不是反射查询的一部分。
- en: 'Given a schema such as:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个类似于以下的模式：
- en: '[PRE67]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The two table names `'data_values'` and `'data_values_4_10'` will come back
    from [`Inspector.get_table_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_table_names
    "sqlalchemy.engine.reflection.Inspector.get_table_names") and additionally the
    columns will come back from `Inspector.get_columns('data_values')` as well as
    `Inspector.get_columns('data_values_4_10')`. This also extends to the use of `Table(...,
    autoload=True)` with these tables.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 两个表名 `'data_values'` 和 `'data_values_4_10'` 将从 [`Inspector.get_table_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_table_names
    "sqlalchemy.engine.reflection.Inspector.get_table_names") 中返回，此外，列也将从 `Inspector.get_columns('data_values')`
    以及 `Inspector.get_columns('data_values_4_10')` 中返回。这也适用于对这些表使用 `Table(..., autoload=True)`。
- en: '[#4237](https://www.sqlalchemy.org/trac/ticket/4237)'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4237](https://www.sqlalchemy.org/trac/ticket/4237)'
- en: Dialect Improvements and Changes - MySQL
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方言改进和变更 - MySQL
- en: '### Protocol-level ping now used for pre-ping'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '### 协议级别的 ping 现在用于预 ping'
- en: 'The MySQL dialects including mysqlclient, python-mysql, PyMySQL and mysql-connector-python
    now use the `connection.ping()` method for the pool pre-ping feature, described
    at [Disconnect Handling - Pessimistic](../core/pooling.html#pool-disconnects-pessimistic).
    This is a much more lightweight ping than the previous method of emitting “SELECT
    1” on the connection.  ### Control of parameter ordering within ON DUPLICATE KEY
    UPDATE'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 包括 mysqlclient、python-mysql、PyMySQL 和 mysql-connector-python 在内的 MySQL 方言现在使用
    `connection.ping()` 方法进行池预 ping 功能，详情请参阅 [Disconnect Handling - Pessimistic](../core/pooling.html#pool-disconnects-pessimistic)。这比以前在连接上发出
    “SELECT 1” 的方法更轻量级。### 控制 ON DUPLICATE KEY UPDATE 中参数的排序
- en: 'The order of UPDATE parameters in the `ON DUPLICATE KEY UPDATE` clause can
    now be explicitly ordered by passing a list of 2-tuples:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过传递一个 2 元组列表来显式地为 `ON DUPLICATE KEY UPDATE` 子句中的 UPDATE 参数进行排序：
- en: '[PRE68]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: See also
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[INSERT…ON DUPLICATE KEY UPDATE (Upsert)](../dialects/mysql.html#mysql-insert-on-duplicate-key-update)'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '[INSERT…ON DUPLICATE KEY UPDATE（Upsert）](../dialects/mysql.html#mysql-insert-on-duplicate-key-update)'
- en: Dialect Improvements and Changes - SQLite
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方言改进和变更 - SQLite
- en: '### Support for SQLite JSON Added'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '### 添加对 SQLite JSON 的支持'
- en: A new datatype [`JSON`](../dialects/sqlite.html#sqlalchemy.dialects.sqlite.JSON
    "sqlalchemy.dialects.sqlite.JSON") is added which implements SQLite’s json member
    access functions on behalf of the [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON") base datatype. The SQLite `JSON_EXTRACT` and `JSON_QUOTE`
    functions are used by the implementation to provide basic JSON support.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 添加了新的数据类型 [`JSON`](../dialects/sqlite.html#sqlalchemy.dialects.sqlite.JSON "sqlalchemy.dialects.sqlite.JSON")
    ，它代表了 [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON "sqlalchemy.types.JSON")
    基本数据类型的 SQLite 的 json 成员访问函数。实现使用 SQLite 的 `JSON_EXTRACT` 和 `JSON_QUOTE` 函数提供基本的
    JSON 支持。
- en: Note that the name of the datatype itself as rendered in the database is the
    name “JSON”. This will create a SQLite datatype with “numeric” affinity, which
    normally should not be an issue except in the case of a JSON value that consists
    of single integer value. Nevertheless, following an example in SQLite’s own documentation
    at [https://www.sqlite.org/json1.html](https://www.sqlite.org/json1.html) the
    name JSON is being used for its familiarity.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，数据库中呈现的数据类型本身的名称为“JSON”。这将创建一个具有“numeric”亲和性的 SQLite 数据类型，通常情况下不应该成为问题，除非是由单个整数值组成的
    JSON 值的情况。尽管如此，根据 SQLite 自己文档中的示例，JSON 的名称仍然被用于其熟悉性。参见 [https://www.sqlite.org/json1.html](https://www.sqlite.org/json1.html)
- en: '[#3850](https://www.sqlalchemy.org/trac/ticket/3850)  ### Support for SQLite
    ON CONFLICT in constraints added'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3850](https://www.sqlalchemy.org/trac/ticket/3850)  ### 添加对约束中 SQLite ON
    CONFLICT 的支持'
- en: 'SQLite supports a non-standard ON CONFLICT clause that may be specified for
    standalone constraints as well as some column-inline constraints such as NOT NULL.
    Support has been added for these clauses via the `sqlite_on_conflict` keyword
    added to objects like [`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint") as well as several [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") -specific variants:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 支持非标准的 ON CONFLICT 子句，可为独立约束以及一些列内约束（如 NOT NULL）指定。通过向 [`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint") 等对象添加 `sqlite_on_conflict` 关键字，已对这些子句进行了支持，以及几种
    [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    -特定变体：
- en: '[PRE69]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The above table would render in a CREATE TABLE statement as:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 上表将在 CREATE TABLE 语句中呈现为：
- en: '[PRE70]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: See also
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[ON CONFLICT support for constraints](../dialects/sqlite.html#sqlite-on-conflict-ddl)'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '[对约束的 ON CONFLICT 支持](../dialects/sqlite.html#sqlite-on-conflict-ddl)'
- en: '[#4360](https://www.sqlalchemy.org/trac/ticket/4360)'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4360](https://www.sqlalchemy.org/trac/ticket/4360)'
- en: Dialect Improvements and Changes - Oracle
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方言改进和变化 - Oracle
- en: '### National char datatypes de-emphasized for generic unicode, re-enabled with
    option'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '### 国家字符数据类型弱化以支持通用 Unicode，可通过选项重新启用'
- en: The [`Unicode`](../core/type_basics.html#sqlalchemy.types.Unicode "sqlalchemy.types.Unicode")
    and [`UnicodeText`](../core/type_basics.html#sqlalchemy.types.UnicodeText "sqlalchemy.types.UnicodeText")
    datatypes by default now correspond to the `VARCHAR2` and `CLOB` datatypes on
    Oracle, rather than `NVARCHAR2` and `NCLOB` (otherwise known as “national” character
    set types). This will be seen in behaviors such as that of how they render in
    `CREATE TABLE` statements, as well as that no type object will be passed to `setinputsizes()`
    when bound parameters using [`Unicode`](../core/type_basics.html#sqlalchemy.types.Unicode
    "sqlalchemy.types.Unicode") or [`UnicodeText`](../core/type_basics.html#sqlalchemy.types.UnicodeText
    "sqlalchemy.types.UnicodeText") are used; cx_Oracle handles the string value natively.
    This change is based on advice from cx_Oracle’s maintainer that the “national”
    datatypes in Oracle are largely obsolete and are not performant. They also interfere
    in some situations such as when applied to the format specifier for functions
    like `trunc()`.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，默认情况下，[`Unicode`](../core/type_basics.html#sqlalchemy.types.Unicode "sqlalchemy.types.Unicode")和[`UnicodeText`](../core/type_basics.html#sqlalchemy.types.UnicodeText
    "sqlalchemy.types.UnicodeText")数据类型现在对应于 Oracle 上的`VARCHAR2`和`CLOB`数据类型，而不是`NVARCHAR2`和`NCLOB`（也称为“国家”字符集类型）。这将在`CREATE
    TABLE`语句中的呈现行为中看到，以及当使用[`Unicode`](../core/type_basics.html#sqlalchemy.types.Unicode
    "sqlalchemy.types.Unicode")或[`UnicodeText`](../core/type_basics.html#sqlalchemy.types.UnicodeText
    "sqlalchemy.types.UnicodeText")的绑定参数时，不会传递类型对象给`setinputsizes()`；cx_Oracle会原生处理字符串值。这种变化基于
    cx_Oracle 维护者的建议，即 Oracle 中的“国家”数据类型在很大程度上已经过时且性能不佳。它们还会在某些情况下干扰，比如应用于`trunc()`等函数的格式说明符时。
- en: The one case where `NVARCHAR2` and related types may be needed is for a database
    that is not using a Unicode-compliant character set. In this case, the flag `use_nchar_for_unicode`
    can be passed to [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") to re-enable the old behavior.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据库不使用符合 Unicode 标准的字符集时，可能需要使用`NVARCHAR2`和相关类型的情况。在这种情况下，可以通过向[`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine")传递标志`use_nchar_for_unicode`来重新启用旧行为。
- en: As always, using the [`NVARCHAR2`](../dialects/oracle.html#sqlalchemy.dialects.oracle.NVARCHAR2
    "sqlalchemy.dialects.oracle.NVARCHAR2") and [`NCLOB`](../dialects/oracle.html#sqlalchemy.dialects.oracle.NCLOB
    "sqlalchemy.dialects.oracle.NCLOB") datatypes explicitly will continue to make
    use of `NVARCHAR2` and `NCLOB`, including within DDL as well as when handling
    bound parameters with cx_Oracle’s `setinputsizes()`.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 始终明确使用[`NVARCHAR2`](../dialects/oracle.html#sqlalchemy.dialects.oracle.NVARCHAR2
    "sqlalchemy.dialects.oracle.NVARCHAR2")和[`NCLOB`](../dialects/oracle.html#sqlalchemy.dialects.oracle.NCLOB
    "sqlalchemy.dialects.oracle.NCLOB")数据类型将继续使用`NVARCHAR2`和`NCLOB`，包括在 DDL 中以及在处理绑定参数时使用
    cx_Oracle 的`setinputsizes()`。
- en: On the read side, automatic Unicode conversion under Python 2 has been added
    to CHAR/VARCHAR/CLOB result rows, to match the behavior of cx_Oracle under Python
    3\. In order to mitigate the performance hit that the cx_Oracle dialect had previously
    with this behavior under Python 2, SQLAlchemy’s very performant (when C extensions
    are built) native Unicode handlers are used under Python 2. The automatic unicode
    coercion can be disabled by setting the `coerce_to_unicode` flag to False. This
    flag now defaults to True and applies to all string data returned in a result
    set that isn’t explicitly under [`Unicode`](../core/type_basics.html#sqlalchemy.types.Unicode
    "sqlalchemy.types.Unicode") or Oracle’s NVARCHAR2/NCHAR/NCLOB datatypes.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在读取方面，在 Python 2 下已添加了对 CHAR/VARCHAR/CLOB 结果行的自动 Unicode 转换，以匹配 Python 3 下 cx_Oracle
    的行为。为了减轻 cx_Oracle 方言在 Python 2 下先前具有的性能问题，SQLAlchemy 在 Python 2 下使用非常高效（当构建 C
    扩展时）的本机 Unicode 处理程序。可以通过将`coerce_to_unicode`标志设置为 False 来禁用自动 Unicode 强制转换。此标志现在默认为
    True，并适用于所有在结果集中返回的不明确为[`Unicode`](../core/type_basics.html#sqlalchemy.types.Unicode
    "sqlalchemy.types.Unicode")或 Oracle 的 NVARCHAR2/NCHAR/NCLOB 数据类型的字符串数据。
- en: '[#4242](https://www.sqlalchemy.org/trac/ticket/4242)  ### cx_Oracle connect
    arguments modernized, deprecated parameters removed'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4242](https://www.sqlalchemy.org/trac/ticket/4242)  ### cx_Oracle 连接参数现代化，已弃用的参数已移除'
- en: 'A series of modernizations to the parameters accepted by the cx_oracle dialect
    as well as the URL string:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: �� cx_oracle 方言接受的参数以及 URL 字符串进行了一系列现代化处理：
- en: The deprecated parameters `auto_setinputsizes`, `allow_twophase`, `exclude_setinputsizes`
    are removed.
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 弃用的参数`auto_setinputsizes`、`allow_twophase`、`exclude_setinputsizes`已被移除。
- en: The value of the `threaded` parameter, which has always been defaulted to True
    for the SQLAlchemy dialect, is no longer generated by default. The SQLAlchemy
    [`Connection`](../core/connections.html#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    object is not considered to be thread-safe itself so there’s no need for this
    flag to be passed.
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`threaded`参数的值，在SQLAlchemy方言中一直默认为True，现在不再默认生成。SQLAlchemy [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") 对象本身不被视为线程安全，因此不需要传递此标志。'
- en: It’s deprecated to pass `threaded` to [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") itself. To set the value of `threaded` to `True`,
    pass it to either the [`create_engine.connect_args`](../core/engines.html#sqlalchemy.create_engine.params.connect_args
    "sqlalchemy.create_engine") dictionary or use the query string e.g. `oracle+cx_oracle://...?threaded=true`.
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`threaded`传递给[`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine")本身已被弃用。要将`threaded`的值设置为`True`，请将其传递给[`create_engine.connect_args`](../core/engines.html#sqlalchemy.create_engine.params.connect_args
    "sqlalchemy.create_engine")字典或使用查询字符串，例如`oracle+cx_oracle://...?threaded=true`。
- en: All parameters passed on the URL query string that are not otherwise specially
    consumed are now passed to the cx_Oracle.connect() function. A selection of these
    are also coerced either into cx_Oracle constants or booleans including `mode`,
    `purity`, `events`, and `threaded`.
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有传递到URL查询字符串的参数，除非另有特殊处理，现在都传递给cx_Oracle.connect()函数。其中一些也被强制转换为cx_Oracle常量或布尔值，包括`mode`、`purity`、`events`和`threaded`。
- en: As was the case earlier, all cx_Oracle `.connect()` arguments are accepted via
    the [`create_engine.connect_args`](../core/engines.html#sqlalchemy.create_engine.params.connect_args
    "sqlalchemy.create_engine") dictionary, the documentation was inaccurate regarding
    this.
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与以往一样，所有cx_Oracle `.connect()` 参数都通过[`create_engine.connect_args`](../core/engines.html#sqlalchemy.create_engine.params.connect_args
    "sqlalchemy.create_engine") 字典接受，文档对此描述不准确。
- en: '[#4369](https://www.sqlalchemy.org/trac/ticket/4369)'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4369](https://www.sqlalchemy.org/trac/ticket/4369)'
- en: Dialect Improvements and Changes - SQL Server
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方言改进和变化 - SQL Server
- en: '### Support for pyodbc fast_executemany'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '### 支持pyodbc fast_executemany'
- en: 'Pyodbc’s recently added “fast_executemany” mode, available when using the Microsoft
    ODBC driver, is now an option for the pyodbc / mssql dialect. Pass it via [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine"):'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: Pyodbc最近添加的“fast_executemany”模式，在使用Microsoft ODBC驱动程序时可用，现在是pyodbc / mssql方言的选项。通过[`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine")传递：
- en: '[PRE71]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: See also
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Fast Executemany Mode](../dialects/mssql.html#mssql-pyodbc-fastexecutemany)'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '[快速Executemany模式](../dialects/mssql.html#mssql-pyodbc-fastexecutemany)'
- en: '[#4158](https://www.sqlalchemy.org/trac/ticket/4158)  ### New parameters to
    affect IDENTITY start and increment, use of Sequence deprecated'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4158](https://www.sqlalchemy.org/trac/ticket/4158)  ### 新参数影响IDENTITY的起始和增量，使用Sequence已被弃用'
- en: 'SQL Server as of SQL Server 2012 now supports sequences with real `CREATE SEQUENCE`
    syntax. In [#4235](https://www.sqlalchemy.org/trac/ticket/4235), SQLAlchemy will
    add support for these using [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence") in the same way as for any other dialect. However,
    the current situation is that [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence") has been repurposed on SQL Server specifically in
    order to affect the “start” and “increment” parameters for the `IDENTITY` specification
    on a primary key column. In order to make the transition towards normal sequences
    being available as well, using [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence") will emit a deprecation warning throughout the 1.3
    series. In order to affect “start” and “increment”, use the new `mssql_identity_start`
    and `mssql_identity_increment` parameters on [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column"):'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: SQL Server 自 SQL Server 2012 起现在支持具有真实 `CREATE SEQUENCE` 语法的序列。在 [#4235](https://www.sqlalchemy.org/trac/ticket/4235)
    中，SQLAlchemy 将添加对这些序列的支持，使用 [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence")，方式与其他任何方言一样。然而，目前的情况是 [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence") 已经在 SQL Server 上重新用途，以影响主键列的 `IDENTITY` 规范的 “start”
    和 “increment” 参数。为了向普通序列也可用过渡，使用 [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence") 将在 1.3 系列中的整个过渡期间发出弃用警告。为了影响 “start” 和 “increment”，请在
    [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    上使用新的 `mssql_identity_start` 和 `mssql_identity_increment` 参数：
- en: '[PRE72]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'In order to emit `IDENTITY` on a non-primary key column, which is a little-used
    but valid SQL Server use case, use the [`Column.autoincrement`](../core/metadata.html#sqlalchemy.schema.Column.params.autoincrement
    "sqlalchemy.schema.Column") flag, setting it to `True` on the target column, `False`
    on any integer primary key column:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 要在非主键列上发出 `IDENTITY`，这是一个很少使用但有效的 SQL Server 情况，请使用 [`Column.autoincrement`](../core/metadata.html#sqlalchemy.schema.Column.params.autoincrement
    "sqlalchemy.schema.Column") 标志，在目标列上将其设置为 `True`，在任何整数主键列上设置为 `False`：
- en: '[PRE73]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: See also
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Auto Increment Behavior / IDENTITY Columns](../dialects/mssql.html#mssql-identity)'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '[自动增量行为 / IDENTITY 列](../dialects/mssql.html#mssql-identity)'
- en: '[#4362](https://www.sqlalchemy.org/trac/ticket/4362)'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4362](https://www.sqlalchemy.org/trac/ticket/4362)'
- en: '[#4235](https://www.sqlalchemy.org/trac/ticket/4235)  ## Changed StatementError
    formatting (newlines and %s)'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4235](https://www.sqlalchemy.org/trac/ticket/4235)  ## 更改的 StatementError
    格式（换行符和 %s）'
- en: Two changes are introduced to the string representation for `StatementError`.
    The “detail” and “SQL” portions of the string representation are now separated
    by newlines, and newlines that are present in the original SQL statement are maintained.
    The goal is to improve readability while still keeping the original error message
    on one line for logging purposes.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `StatementError` 的字符串表示引入了两个更改。字符串表示的“详细信息”和“SQL”部分现在由换行符分隔，并且保留了原始 SQL 语句中存在的换行符。目标是在保持原始错误消息单行记录的同时提高可读性。
- en: 'This means that an error message that previously looked like this:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着以前看起来像这样的错误消息：
- en: '[PRE74]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Will now look like this:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将如下所示：
- en: '[PRE75]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: The primary impact of this change is that consumers can no longer assume that
    a complete exception message is on a single line, however the original “error”
    portion that is generated from the DBAPI driver or SQLAlchemy internals will still
    be on the first line.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 此更改的主要影响是消费者不再能假定完整的异常消息在单行上，但是来自 DBAPI 驱动程序或 SQLAlchemy 内部生成的原始 “错误” 部分仍将位于第一行。
- en: '[#4500](https://www.sqlalchemy.org/trac/ticket/4500)'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4500](https://www.sqlalchemy.org/trac/ticket/4500)'
- en: Introduction
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍
- en: This guide introduces what’s new in SQLAlchemy version 1.3 and also documents
    changes which affect users migrating their applications from the 1.2 series of
    SQLAlchemy to 1.3.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 本指南介绍了 SQLAlchemy 版本 1.3 中的新功能，并记录了对将应用程序从 SQLAlchemy 1.2 系列迁移到 1.3 系列的用户产生影响的更改。
- en: Please carefully review the sections on behavioral changes for potentially backwards-incompatible
    changes in behavior.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 请仔细查看行为更改部分，了解可能的向后不兼容的行为更改。
- en: General
  id: totrans-307
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一般
- en: '### Deprecation warnings are emitted for all deprecated elements; new deprecations
    added'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '### 为所有弃用元素发出弃用警告；添加新的弃用'
- en: Release 1.3 ensures that all behaviors and APIs that are deprecated, including
    all those that have been long listed as “legacy” for years, are emitting `DeprecationWarning`
    warnings. This includes when making use of parameters such as [`Session.weak_identity_map`](../orm/session_api.html#sqlalchemy.orm.Session.params.weak_identity_map
    "sqlalchemy.orm.Session") and classes such as `MapperExtension`. While all deprecations
    have been noted in the documentation, often they did not use a proper restructured
    text directive, or include in what version they were deprecated. Whether or not
    a particular API feature actually emitted a deprecation warning was not consistent.
    The general attitude was that most or all of these deprecated features were treated
    as long-term legacy features with no plans to remove them.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 发行版 1.3 确保所有被弃用的行为和 API，包括所有长期被列为“遗留”的行为和 API，都会发出 `DeprecationWarning` 警告。这包括在使用诸如
    [`Session.weak_identity_map`](../orm/session_api.html#sqlalchemy.orm.Session.params.weak_identity_map
    "sqlalchemy.orm.Session") 这样的参数和 `MapperExtension` 这样的类时。虽然所有弃用已在文档中注明，但通常它们没有使用正确的重新构造文本指令，或者包含它们被弃用的版本。一个特定的
    API 功能是否实际发出弃用警告并不一致。一般的态度是，大多数或所有这些弃用功能都被视为长期遗留功能，没有计划删除它们。
- en: The change includes that all documented deprecations now use a proper restructured
    text directive in the documentation with a version number, the verbiage that the
    feature or use case will be removed in a future release is made explicit (e.g.,
    no more legacy forever use cases), and that use of any such feature or use case
    will definitely emit a `DeprecationWarning`, which in Python 3 as well as when
    using modern testing tools like Pytest are now made more explicit in the standard
    error stream. The goal is that these long deprecated features, going back as far
    as version 0.7 or 0.6, should start being removed entirely, rather than keeping
    them around as “legacy” features. Additionally, some major new deprecations are
    being added as of version 1.3. As SQLAlchemy has 14 years of real world use by
    thousands of developers, it’s possible to point to a single stream of use cases
    that blend together well, and to trim away features and patterns that work against
    this single way of working.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 此次变更包括所有文档化的弃用现在都在文档中使用了正确的重新构造文本指令，并附有版本号，明确指出该功能或用例将在将来的版本中删除（例如，不再有永久使用的旧用例），以及使用任何此类功能或用例都将明确发出
    `DeprecationWarning` 警告，在 Python 3 中以及使用像 Pytest 这样的现代测试工具时，现在在标准错误流中更加明确。目标是，这些长时间弃用的功能，回溯到版本
    0.7 或 0.6，应该开始被完全删除，而不是保留它们作为“遗留”功能。此外，从版本 1.3 开始，一些重大的新弃用将被添加。由于 SQLAlchemy 在数千开发人员的实际使用中已有
    14 年，因此可以指出一种混合得很好的用例流，并且修剪掉与这种单一工作方式相违背的功能和模式。
- en: The larger context is that SQLAlchemy seeks to adjust to the coming Python 3-only
    world, as well as a type-annotated world, and towards this goal there are **tentative**
    plans for a major rework of SQLAlchemy which would hopefully greatly reduce the
    cognitive load of the API as well as perform a major pass over the great many
    differences in implementation and use between Core and ORM. As these two systems
    evolved dramatically after SQLAlchemy’s first release, in particular the ORM still
    retains lots of “bolted on” behaviors that keep the wall of separation between
    Core and ORM too high. By focusing the API ahead of time on a single pattern for
    each supported use case, the eventual job of migrating to a significantly altered
    API becomes simpler.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 更大的背景是 SQLAlchemy 试图适应即将到来的仅支持 Python 3 的世界，以及类型注解的世界，为此，**初步**计划对 SQLAlchemy
    进行重大改版，希望大大减少 API 的认知负担，以及对 Core 和 ORM 之间众多实现和使用差异的重大调整。由于这两个系统在 SQLAlchemy 首次发布后发生了巨大变化，特别是
    ORM 仍保留了许多“后期添加的”行为，这使得 Core 和 ORM 之间的隔离墙过高。通过提前将 API 集中在每个支持的用例的单一模式上，将来对显着改变的
    API 进行迁移的工作变得更加简单。
- en: For the most major deprecations being added in 1.3, see the linked sections
    below.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 对于在 1.3 中添加的最重大的弃用，请参见下面的链接部分。
- en: See also
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[“threadlocal” engine strategy deprecated](#change-4393-threadlocal)'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '[“threadlocal” 引擎策略已弃用](#change-4393-threadlocal)'
- en: '[convert_unicode parameters deprecated](#change-4393-convertunicode)'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '[convert_unicode 参数已弃用](#change-4393-convertunicode)'
- en: '[Relationship to AliasedClass replaces the need for non primary mappers](#change-4423)'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '[关于 AliasedClass 的关系取代了非主映射器的需要](#change-4423)'
- en: '[#4393](https://www.sqlalchemy.org/trac/ticket/4393)  ### Deprecation warnings
    are emitted for all deprecated elements; new deprecations added'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4393](https://www.sqlalchemy.org/trac/ticket/4393)  ### 所有弃用元素都会发出弃用警告；新增弃用'
- en: Release 1.3 ensures that all behaviors and APIs that are deprecated, including
    all those that have been long listed as “legacy” for years, are emitting `DeprecationWarning`
    warnings. This includes when making use of parameters such as [`Session.weak_identity_map`](../orm/session_api.html#sqlalchemy.orm.Session.params.weak_identity_map
    "sqlalchemy.orm.Session") and classes such as `MapperExtension`. While all deprecations
    have been noted in the documentation, often they did not use a proper restructured
    text directive, or include in what version they were deprecated. Whether or not
    a particular API feature actually emitted a deprecation warning was not consistent.
    The general attitude was that most or all of these deprecated features were treated
    as long-term legacy features with no plans to remove them.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 发布 1.3 确保所有被弃用的行为和 API，包括那些多年来一直被列为“遗留”的行为，都会发出`DeprecationWarning`警告。这包括当使用参数如[`Session.weak_identity_map`](../orm/session_api.html#sqlalchemy.orm.Session.params.weak_identity_map
    "sqlalchemy.orm.Session")和类似`MapperExtension`时。虽然所有弃用都已在文档中记录，但通常它们没有使用适当的重构文本指令，或者包含它们被弃用的版本。特定
    API 功能是否实际发出弃用警告并不一致。一般的态度是，大多数或所有这些弃用功能都被视为长期遗留功能，没有计划删除它们。
- en: The change includes that all documented deprecations now use a proper restructured
    text directive in the documentation with a version number, the verbiage that the
    feature or use case will be removed in a future release is made explicit (e.g.,
    no more legacy forever use cases), and that use of any such feature or use case
    will definitely emit a `DeprecationWarning`, which in Python 3 as well as when
    using modern testing tools like Pytest are now made more explicit in the standard
    error stream. The goal is that these long deprecated features, going back as far
    as version 0.7 or 0.6, should start being removed entirely, rather than keeping
    them around as “legacy” features. Additionally, some major new deprecations are
    being added as of version 1.3. As SQLAlchemy has 14 years of real world use by
    thousands of developers, it’s possible to point to a single stream of use cases
    that blend together well, and to trim away features and patterns that work against
    this single way of working.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 此更改包括，所有记录的弃用现在在文档中使用适当的重构文本指令，并附有版本号，明确说明该功能或用例将在将来的版本中被移除（例如，不再有永久的遗留用例），并且使用任何此类功能或用例肯定会发出`DeprecationWarning`，在
    Python 3 中以及使用现代测试工具如 Pytest 时，现在在标准错误流中更加明确。目标是，这些长期弃用的功能，可以追溯到版本 0.7 或 0.6，应该开始被完全移除，而不是将它们保留为“遗留”功能。此外，一些重大的新弃用功能正在版本
    1.3 中添加。由于 SQLAlchemy 在数千开发人员的实际使用中已经有了 14 年的历史，可以指出一个混合在一起的使用案例流，以及修剪掉与这种单一工作方式相悖的功能和模式。
- en: The larger context is that SQLAlchemy seeks to adjust to the coming Python 3-only
    world, as well as a type-annotated world, and towards this goal there are **tentative**
    plans for a major rework of SQLAlchemy which would hopefully greatly reduce the
    cognitive load of the API as well as perform a major pass over the great many
    differences in implementation and use between Core and ORM. As these two systems
    evolved dramatically after SQLAlchemy’s first release, in particular the ORM still
    retains lots of “bolted on” behaviors that keep the wall of separation between
    Core and ORM too high. By focusing the API ahead of time on a single pattern for
    each supported use case, the eventual job of migrating to a significantly altered
    API becomes simpler.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 的更大背景是，它试图适应即将到来的 Python 3-only 世界，以及一个类型注释的世界，为了实现这个目标，有**暂定**计划对
    SQLAlchemy 进行重大改造，希望能大大减少 API 的认知负荷，并对 Core 和 ORM 之间的实现和使用之间的许多差异进行重大调整。由于这两个系统在
    SQLAlchemy 首次发布后发生了巨大变化，特别是 ORM 仍然保留了许多“外挂”行为，使得 Core 和 ORM 之间的隔离墙过高。通过提前将 API
    集中在每个支持的用例的单一模式上，将来迁移到显著改变的 API 的工作变得更简单。
- en: For the most major deprecations being added in 1.3, see the linked sections
    below.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 1.3 中添加的最重要的弃用功能，请参见下面的链接部分。
- en: See also
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[“threadlocal” engine strategy deprecated](#change-4393-threadlocal)'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '[“threadlocal” engine strategy deprecated](#change-4393-threadlocal)'
- en: '[convert_unicode parameters deprecated](#change-4393-convertunicode)'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '[convert_unicode parameters deprecated](#change-4393-convertunicode)'
- en: '[Relationship to AliasedClass replaces the need for non primary mappers](#change-4423)'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '[与别名类的关系替代了非主要映射器的需求](#change-4423)'
- en: '[#4393](https://www.sqlalchemy.org/trac/ticket/4393)'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4393](https://www.sqlalchemy.org/trac/ticket/4393)'
- en: New Features and Improvements - ORM
  id: totrans-327
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 新功能和改进 - ORM
- en: '### Relationship to AliasedClass replaces the need for non primary mappers'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '### 与别名类的关系替代了非主要映射器的需求'
- en: The “non primary mapper” is a [`Mapper`](../orm/mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper") created in the [Imperative Mapping](../orm/mapping_styles.html#orm-imperative-mapping)
    style, which acts as an additional mapper against an already mapped class against
    a different kind of selectable. The non primary mapper has its roots in the 0.1,
    0.2 series of SQLAlchemy where it was anticipated that the [`Mapper`](../orm/mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper") object was to be the primary query construction interface,
    before the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    object existed.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: “非主要映射器”是以[命令式映射](../orm/mapping_styles.html#orm-imperative-mapping)风格创建的[`Mapper`](../orm/mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper")，它充当已经映射的类的额外映射器，针对不同类型的可选择对象。非主要映射器起源于 SQLAlchemy 的 0.1、0.2
    系列，那时预计[`Mapper`](../orm/mapping_api.html#sqlalchemy.orm.Mapper "sqlalchemy.orm.Mapper")对象将是主要的查询构建接口，之后才有[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")对象的存在。
- en: With the advent of [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") and later the [`AliasedClass`](../orm/queryguide/api.html#sqlalchemy.orm.util.AliasedClass
    "sqlalchemy.orm.util.AliasedClass") construct, most use cases for the non primary
    mapper went away. This was a good thing since SQLAlchemy also moved away from
    “classical” mappings altogether around the 0.5 series in favor of the declarative
    system.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 随着[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")的出现，以及后来的[`AliasedClass`](../orm/queryguide/api.html#sqlalchemy.orm.util.AliasedClass
    "sqlalchemy.orm.util.AliasedClass")构造，大多数非主要映射器的用例都消失了。这是一件好事，因为 SQLAlchemy 在
    0.5 系列左右也完全放弃了“经典”映射，转而采用了声明式系统。
- en: One use case remained around for non primary mappers when it was realized that
    some very hard-to-define [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") configurations could be made possible when a non-primary
    mapper with an alternative selectable was made as the mapping target, rather than
    trying to construct a [`relationship.primaryjoin`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.primaryjoin
    "sqlalchemy.orm.relationship") that encompassed all the complexity of a particular
    inter-object relationship.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 当意识到一些非常难以定义的[`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")配置可能会成为可能时，仍然保留了非主要映射器的一个用例。当使用非主要映射器作为映射目标时，可以使用替代可选择项，而不是尝试构建一个[`relationship.primaryjoin`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.primaryjoin
    "sqlalchemy.orm.relationship")，该关系涵盖了特定对象间关系的所有复杂性。
- en: As this use case became more popular, its limitations became apparent, including
    that the non primary mapper is difficult to configure against a selectable that
    adds new columns, that the mapper does not inherit the relationships of the original
    mapping, that relationships which are configured explicitly on the non primary
    mapper do not function well with loader options, and that the non primary mapper
    also doesn’t provide a fully functional namespace of column-based attributes which
    can be used in queries (which again, in the old 0.1 - 0.4 days, one would use
    [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    objects directly with the ORM).
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 随着这个用例变得越来越流行，它的局限性也变得明显，包括非主要映射器难以配置以适应添加新列的可选择项，映射器不继承原始映射的关系，明确配置在非主要映射器上的关系与加载器选项不兼容，非主要映射器还不能提供可在查询中使用的基于列的属性的完全功能命名空间（在旧的
    0.1 - 0.4 时代，人们会直接使用[`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")对象与
    ORM）。
- en: The missing piece was to allow the [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") to refer directly to the [`AliasedClass`](../orm/queryguide/api.html#sqlalchemy.orm.util.AliasedClass
    "sqlalchemy.orm.util.AliasedClass"). The [`AliasedClass`](../orm/queryguide/api.html#sqlalchemy.orm.util.AliasedClass
    "sqlalchemy.orm.util.AliasedClass") already does everything we want the non primary
    mapper to do; it allows an existing mapped class to be loaded from an alternative
    selectable, it inherits all the attributes and relationships of the existing mapper,
    it works extremely well with loader options, and it provides a class-like object
    that can be mixed into queries just like the class itself. With this change, the
    recipes that were formerly for non primary mappers at [Configuring how Relationship
    Joins](../orm/join_conditions.html#relationship-configure-joins) are changed to
    aliased class.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 缺失的部分是允许 [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") 直接引用 [`AliasedClass`](../orm/queryguide/api.html#sqlalchemy.orm.util.AliasedClass
    "sqlalchemy.orm.util.AliasedClass")。[`AliasedClass`](../orm/queryguide/api.html#sqlalchemy.orm.util.AliasedClass
    "sqlalchemy.orm.util.AliasedClass") 已经做了非主映射器所要做的一切；它允许从备用可选择中加载现有映射的类，它继承现有映射器的所有属性和关系，它与加载器选项非常配合，还提供了一个可以像类本身一样混入查询的类似对象。通过这个改变，原来针对非主映射器的[配置关系连接](../orm/join_conditions.html#relationship-configure-joins)的配方被更改为别名类。
- en: 'At [Relationship to Aliased Class](../orm/join_conditions.html#relationship-aliased-class),
    the original non primary mapper looked like:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在[关系到别名类](../orm/join_conditions.html#relationship-aliased-class)处，原始的非主映射器如下所示：
- en: '[PRE76]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: The properties were necessary in order to re-map the additional columns so that
    they did not conflict with the existing columns mapped to `B`, as well as it was
    necessary to define a new primary key.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 这些属性是必需的，以便重新映射额外的列，使其不与已映射到`B`的现有列发生冲突，同时还需要定义一个新的主键。
- en: 'With the new approach, all of this verbosity goes away, and the additional
    columns are referenced directly when making the relationship:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 使用新方法，所有这些冗长都会消失，并且在建立关系时可以直接引用额外的列：
- en: '[PRE77]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: The non primary mapper is now deprecated with the eventual goal to be that classical
    mappings as a feature go away entirely. The Declarative API would become the single
    means of mapping which hopefully will allow internal improvements and simplifications,
    as well as a clearer documentation story.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 非主映射器现已不推荐使用，最终目标是经典映射作为一种特性完全消失。声明性 API 将成为唯一的映射方式，这有望带来内部改进和简化，以及更清晰的文档说明。
- en: '[#4423](https://www.sqlalchemy.org/trac/ticket/4423)  ### selectin loading
    no longer uses JOIN for simple one-to-many'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4423](https://www.sqlalchemy.org/trac/ticket/4423)  ### selectin 加载不再使用 JOIN
    来进行简单的一对多加载'
- en: The “selectin” loading feature added in 1.2 introduced an extremely performant
    new way to eagerly load collections, in many cases much faster than that of “subquery”
    eager loading, as it does not rely upon restating the original SELECT query and
    instead uses a simple IN clause. However, the “selectin” load still relied upon
    rendering a JOIN between the parent and related tables, since it needs the parent
    primary key values in the row in order to match rows up. In 1.3, a new optimization
    is added which will omit this JOIN in the most common case of a simple one-to-many
    load, where the related row already contains the primary key of the parent row
    expressed in its foreign key columns. This again provides for a dramatic performance
    improvement as the ORM now can load large numbers of collections all in one query
    without using JOIN or subqueries at all.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 1.2 版中添加的“selectin”加载功能引入了一种极其高效的新方法来急切加载集合，在许多情况下比“subquery”急切加载要快得多，因为它不依赖于重复原始
    SELECT 查询，而是使用一个简单的 IN 子句。然而，“selectin”加载仍然依赖于在父表和相关表之间渲染 JOIN，因为它需要在行中使用父主键值来匹配行。在
    1.3 中，添加了一个新的优化，将在简单的一对多加载的最常见情况下省略这个 JOIN，其中相关的行已经包含了其外键列中表达的父行的主键。这再次提供了显着的性能改进，因为
    ORM 现在可以一次性加载大量集合，而完全不使用 JOIN 或子查询。
- en: 'Given a mapping:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个映射：
- en: '[PRE78]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'In the 1.2 version of “selectin” loading, a load of A to B looks like:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在 1.2 版本的“selectin”加载中，从 A 到 B 的加载如下所示：
- en: '[PRE79]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'With the new behavior, the load looks like:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 使用新行为，加载如下：
- en: '[PRE80]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: The behavior is being released as automatic, using a similar heuristic that
    lazy loading uses in order to determine if related entities can be fetched directly
    from the identity map. However, as with most querying features, the feature’s
    implementation became more complex as a result of advanced scenarios regarding
    polymorphic loading. If problems are encountered, users should report a bug, however
    the change also includes a flag [`relationship.omit_join`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.omit_join
    "sqlalchemy.orm.relationship") which can be set to `False` on the [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") to disable the optimization.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 该行为被自动释放，使用类似于延迟加载的启发式方法，以确定相关实体是否可以直接从标识映射中获取。然而，与大多数查询功能一样，由于关于多态加载的高级场景，该功能的实现变得更加复杂。如果遇到问题，用户应该报告错误，但是该更改还包括一个标志[`relationship.omit_join`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.omit_join
    "sqlalchemy.orm.relationship")，可以在[`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")上设置为`False`以禁用优化。
- en: '[#4340](https://www.sqlalchemy.org/trac/ticket/4340)  ### Improvement to the
    behavior of many-to-one query expressions'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4340](https://www.sqlalchemy.org/trac/ticket/4340)  ### 改进多对一查询表达式的行为'
- en: 'When building a query that compares a many-to-one relationship to an object
    value, such as:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 当构建一个查询，将一个多对一的关系与一个对象值进行比较时，比如：
- en: '[PRE81]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: The above expression `Address.user == u1`, which ultimately compiles to a SQL
    expression normally based on the primary key columns of the `User` object like
    `"address.user_id = 5"`, uses a deferred callable in order to retrieve the value
    `5` within the bound expression until as late as possible. This is to suit both
    the use case where the `Address.user == u1` expression may be against a `User`
    object that isn’t flushed yet which relies upon a server- generated primary key
    value, as well as that the expression always returns the correct result even if
    the primary key value of `u1` has been changed since the expression was created.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 上述表达式`Address.user == u1`最终编译成一个SQL表达式，通常基于`User`对象的主键列，如`"address.user_id =
    5"`，使用延迟可调用来在绑定表达式中尽可能晚地检索值`5`。这是为了适应两种情况：`Address.user == u1`表达式可能针对尚未刷新的`User`对象，依赖于服务器生成的主键值，以及即使自表达式创建以来`u1`的主键值已更改，表达式始终返回正确结果的情况。
- en: 'However, a side effect of this behavior is that if `u1` ends up being expired
    by the time the expression is evaluated, it results in an additional SELECT statement,
    and in the case that `u1` was also detached from the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), it would raise an error:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种行为的一个副作用是，如果`u1`在表达式被评估时已经过期，就会导致额外的SELECT语句，而且如果`u1`也已经从[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")中分离，就会引发错误：
- en: '[PRE82]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: The expiration / expunging of the object can occur implicitly when the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is committed and the `u1` instance falls out of scope,
    as the `Address.user == u1` expression does not strongly reference the object
    itself, only its [`InstanceState`](../orm/internals.html#sqlalchemy.orm.InstanceState
    "sqlalchemy.orm.InstanceState").
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 当[`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")提交并且`u1`实例超出范围时，对象的过期/清除可能会隐式发生，因为`Address.user
    == u1`表达式并不强烈引用对象本身，只引用其[`InstanceState`](../orm/internals.html#sqlalchemy.orm.InstanceState
    "sqlalchemy.orm.InstanceState")。
- en: The fix is to allow the `Address.user == u1` expression to evaluate the value
    `5` based on attempting to retrieve or load the value normally at expression compilation
    time as it does now, but if the object is detached and has been expired, it is
    retrieved from a new mechanism upon the [`InstanceState`](../orm/internals.html#sqlalchemy.orm.InstanceState
    "sqlalchemy.orm.InstanceState") which will memoize the last known value for a
    particular attribute on that state when that attribute is expired. This mechanism
    is only enabled for a specific attribute / [`InstanceState`](../orm/internals.html#sqlalchemy.orm.InstanceState
    "sqlalchemy.orm.InstanceState") when needed by the expression feature to conserve
    performance / memory overhead.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 修复方法是允许 `Address.user == u1` 表达式根据尝试在表达式编译时正常检索或加载值的结果来评估值 `5`，就像现在一样，但如果对象已分离并已过期，则从一个新的机制中检索它
    [`InstanceState`](../orm/internals.html#sqlalchemy.orm.InstanceState "sqlalchemy.orm.InstanceState")，该机制将在属性过期时对该状态上的特定属性的最后已知值进行备忘录。此机制仅在表达式功能需要时为特定属性/
    [`InstanceState`](../orm/internals.html#sqlalchemy.orm.InstanceState "sqlalchemy.orm.InstanceState")
    启用，以节省性能/内存开销。
- en: Originally, simpler approaches such as evaluating the expression immediately
    with various arrangements for trying to load the value later if not present were
    attempted, however the difficult edge case is that of the value of a column attribute
    (typically a natural primary key) that is being changed. In order to ensure that
    an expression like `Address.user == u1` always returns the correct answer for
    the current state of `u1`, it will return the current database-persisted value
    for a persistent object, unexpiring via SELECT query if necessary, and for a detached
    object it will return the most recent known value, regardless of when the object
    was expired using a new feature within the [`InstanceState`](../orm/internals.html#sqlalchemy.orm.InstanceState
    "sqlalchemy.orm.InstanceState") that tracks the last known value of a column attribute
    whenever the attribute is to be expired.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，尝试了诸如立即评估表达式并尝试稍后加载值的各种安排等更简单的方法，但困难的边缘情况是正在更改的列属性（通常是自然主键）的值。为了确保诸如 `Address.user
    == u1` 的表达式始终返回 `u1` 当前状态的正确答案，它将返回持久对象的当前数据库持久值，如果需要通过 SELECT 查询取消过期，并且对于已分离的对象，它将返回最近已知的值，而不管对象何时使用
    [`InstanceState`](../orm/internals.html#sqlalchemy.orm.InstanceState "sqlalchemy.orm.InstanceState")
    来跟踪列属性的最后已知值，无论何时属性将被过期。
- en: Modern attribute API features are used to indicate specific error messages when
    the value cannot be evaluated, the two cases of which are when the column attributes
    have never been set, and when the object was already expired when the first evaluation
    was made and is now detached. In all cases, [`DetachedInstanceError`](../orm/exceptions.html#sqlalchemy.orm.exc.DetachedInstanceError
    "sqlalchemy.orm.exc.DetachedInstanceError") is no longer raised.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 当无法评估值时，现代属性 API 功能用于指示特定的错误消息，这两种情况是当列属性从未设置时，以及当第一次进行评估时对象已过期时。在所有情况下，不再引发
    [`DetachedInstanceError`](../orm/exceptions.html#sqlalchemy.orm.exc.DetachedInstanceError
    "sqlalchemy.orm.exc.DetachedInstanceError")。
- en: '[#4359](https://www.sqlalchemy.org/trac/ticket/4359)  ### Many-to-one replacement
    won’t raise for “raiseload” or detached for “old” object'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4359](https://www.sqlalchemy.org/trac/ticket/4359)  ### 多对一替换不会对“raiseload”或“old”对象引发异常'
- en: 'Given the case where a lazy load would proceed on a many-to-one relationship
    in order to load the “old” value, if the relationship does not specify the [`relationship.active_history`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.active_history
    "sqlalchemy.orm.relationship") flag, an assertion will not be raised for a detached
    object:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到延迟加载将继续在多对一关系上进行，以加载“old”值，如果关系未指定 [`relationship.active_history`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.active_history
    "sqlalchemy.orm.relationship") 标志，则不会对分离的对象引发断言：
- en: '[PRE83]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Above, when the `.user` attribute is replaced on the detached `a1` object, a
    [`DetachedInstanceError`](../orm/exceptions.html#sqlalchemy.orm.exc.DetachedInstanceError
    "sqlalchemy.orm.exc.DetachedInstanceError") would be raised as the attribute is
    attempting to retrieve the previous value of `.user` from the identity map. The
    change is that the operation now proceeds without the old value being loaded.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 上面，在分离的 `a1` 对象上替换 `.user` 属性时，如果属性试图从标识映射中检索 `.user` 的先前值，则会引发 [`DetachedInstanceError`](../orm/exceptions.html#sqlalchemy.orm.exc.DetachedInstanceError
    "sqlalchemy.orm.exc.DetachedInstanceError")。变化在于该操作现在在不加载旧值的情况下继续进行。
- en: 'The same change is also made to the `lazy="raise"` loader strategy:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的改变也适用于`lazy="raise"`加载器策略：
- en: '[PRE84]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Previously, the association of `a1.user` would invoke the “raiseload” exception
    as a result of the attribute attempting to retrieve the previous value. This assertion
    is now skipped in the case of loading the “old” value.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，对`a1.user`的关联将引发“raiseload”异常，因为属性试图检索先前的值。在加载“旧”值的情况下，现在会跳过此断言。
- en: '[#4353](https://www.sqlalchemy.org/trac/ticket/4353)  ### “del” implemented
    for ORM attributes'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4353](https://www.sqlalchemy.org/trac/ticket/4353)  ### 为ORM属性实现了“del”'
- en: 'The Python `del` operation was not really usable for mapped attributes, either
    scalar columns or object references. Support has been added for this to work correctly,
    where the `del` operation is roughly equivalent to setting the attribute to the
    `None` value:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: Python `del`操作实际上对于映射属性（标量列或对象引用）并不可用。已添加支持，使其可以正常工作，其中`del`操作大致等同于将属性设置为`None`值：
- en: '[PRE85]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[#4354](https://www.sqlalchemy.org/trac/ticket/4354)  ### info dictionary added
    to InstanceState'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4354](https://www.sqlalchemy.org/trac/ticket/4354)  ### info字典添加到InstanceState'
- en: 'Added the `.info` dictionary to the [`InstanceState`](../orm/internals.html#sqlalchemy.orm.InstanceState
    "sqlalchemy.orm.InstanceState") class, the object that comes from calling [`inspect()`](../core/inspection.html#sqlalchemy.inspect
    "sqlalchemy.inspect") on a mapped object. This allows custom recipes to add additional
    information about an object that will be carried along with that object’s full
    lifecycle in memory:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 将`.info`字典添加到[`InstanceState`](../orm/internals.html#sqlalchemy.orm.InstanceState
    "sqlalchemy.orm.InstanceState")类，这个对象是调用一个映射对象上的[`inspect()`](../core/inspection.html#sqlalchemy.inspect
    "sqlalchemy.inspect")而来。这允许自定义配方添加有关对象的其他信息，这些信息将随着对象在内存中的完整生命周期一起传递：
- en: '[PRE86]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[#4257](https://www.sqlalchemy.org/trac/ticket/4257)  ### Horizontal Sharding
    extension supports bulk update and delete methods'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4257](https://www.sqlalchemy.org/trac/ticket/4257)  ### 水平分片扩展支持批量更新和删除方法'
- en: The [`ShardedQuery`](../orm/extensions/horizontal_shard.html#sqlalchemy.ext.horizontal_shard.ShardedQuery
    "sqlalchemy.ext.horizontal_shard.ShardedQuery") extension object supports the
    [`Query.update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.update "sqlalchemy.orm.Query.update")
    and [`Query.delete()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.delete
    "sqlalchemy.orm.Query.delete") bulk update/delete methods. The `query_chooser`
    callable is consulted when they are called in order to run the update/delete across
    multiple shards based on given criteria.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '[`ShardedQuery`](../orm/extensions/horizontal_shard.html#sqlalchemy.ext.horizontal_shard.ShardedQuery
    "sqlalchemy.ext.horizontal_shard.ShardedQuery")扩展对象支持[`Query.update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.update
    "sqlalchemy.orm.Query.update")和[`Query.delete()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.delete
    "sqlalchemy.orm.Query.delete")批量更新/删除方法。在调用它们时，将咨询`query_chooser`可调用对象，以便根据给定的条件跨多个分片运行更新/删除。'
- en: '[#4196](https://www.sqlalchemy.org/trac/ticket/4196)'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4196](https://www.sqlalchemy.org/trac/ticket/4196)'
- en: Association Proxy Improvements
  id: totrans-375
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关联代理改进
- en: While not for any particular reason, the Association Proxy extension had many
    improvements this cycle.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管没有任何特定的原因，但本周期的Association Proxy扩展有许多改进。
- en: '#### Association proxy has new cascade_scalar_deletes flag'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 关联代理有新的cascade_scalar_deletes标志'
- en: 'Given a mapping as:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个映射为：
- en: '[PRE87]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'An assignment to `A.b` will generate an `AB` object:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 对`A.b`的赋值将生成一个`AB`对象：
- en: '[PRE88]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'The `A.b` association is scalar, and includes a new flag [`AssociationProxy.cascade_scalar_deletes`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy.params.cascade_scalar_deletes
    "sqlalchemy.ext.associationproxy.AssociationProxy"). When set, setting `A.b` to
    `None` will remove `A.ab` as well. The default behavior remains that it leaves
    `a.ab` in place:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '`A.b`关联是标量的，并包含一个新标志[`AssociationProxy.cascade_scalar_deletes`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy.params.cascade_scalar_deletes
    "sqlalchemy.ext.associationproxy.AssociationProxy")。设置时，将`A.b`设置为`None`将同时删除`A.ab`。默认行为仍然是保留`a.ab`不变：'
- en: '[PRE89]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: While it at first seemed intuitive that this logic should just look at the “cascade”
    attribute of the existing relationship, it’s not clear from that alone if the
    proxied object should be removed, hence the behavior is made available as an explicit
    option.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然乍一看这个逻辑应该只看现有关系的“级联”属性，但仅从那个属性本身来看不清楚应该删除代理对象，因此行为被作为一个显式选项提供。
- en: 'Additionally, `del` now works for scalars in a similar manner as setting to
    `None`:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`del`现在对标量的工作方式类似于设置为`None`：
- en: '[PRE90]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[#4308](https://www.sqlalchemy.org/trac/ticket/4308)  #### AssociationProxy
    stores class-specific state on a per-class basis'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4308](https://www.sqlalchemy.org/trac/ticket/4308)  #### 关联代理在每个类上都存储特定于类的状态'
- en: The [`AssociationProxy`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy
    "sqlalchemy.ext.associationproxy.AssociationProxy") object makes lots of decisions
    based on the parent mapped class it is associated with. While the [`AssociationProxy`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy
    "sqlalchemy.ext.associationproxy.AssociationProxy") historically began as a relatively
    simple ‘getter,’ it became apparent early on that it also needed to make decisions
    regarding the kind of attribute to which it refers—such as scalar or collection,
    mapped object or simple value, and so on. To achieve this, it needs to inspect
    the mapped attribute or other referring descriptor or attribute, as referenced
    from its parent class. However in Python descriptor mechanics, a descriptor only
    learns about its “parent” class when it is accessed in the context of that class,
    such as calling `MyClass.some_descriptor`, which calls the `__get__()` method
    which passes in the class. The [`AssociationProxy`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy
    "sqlalchemy.ext.associationproxy.AssociationProxy") object would therefore store
    state that is specific to that class, but only once this method were called; trying
    to inspect this state ahead of time without first accessing the [`AssociationProxy`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy
    "sqlalchemy.ext.associationproxy.AssociationProxy") as a descriptor would raise
    an error. Additionally, it would assume that the first class to be seen by `__get__()`
    would be the only parent class it needed to know about. This is despite the fact
    that if a particular class has inheriting subclasses, the association proxy is
    really working on behalf of more than one parent class even though it was not
    explicitly re-used. While even with this shortcoming, the association proxy would
    still get pretty far with its current behavior, it still leaves shortcomings in
    some cases as well as the complex problem of determining the best “owner” class.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '[`AssociationProxy`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy
    "sqlalchemy.ext.associationproxy.AssociationProxy") 对象根据其关联的父映射类做出许多决策。虽然 [`AssociationProxy`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy
    "sqlalchemy.ext.associationproxy.AssociationProxy") 在历史上起初是一个相对简单的‘getter’，但很快就明显需要它也需要对其引用的属性类型做出决策——比如标量或集合、映射对象或简单值等等。为了实现这一点，它需要检查映射属性或其他引用的描述符或属性，如从其父类引用的那样。然而，在
    Python 的描述符机制中，描述符仅在其在该类的上下文中被访问时才了解其“父”类，例如调用 `MyClass.some_descriptor`，这会调用
    `__get__()` 方法并传入类。[`AssociationProxy`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy
    "sqlalchemy.ext.associationproxy.AssociationProxy") 对象因此会存储特定于该类的状态，但只有在调用此方法后才会这样做；尝试在首先将
    [`AssociationProxy`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy
    "sqlalchemy.ext.associationproxy.AssociationProxy") 作为描述符之前预先检查此状态将会引发错误。此外，它会假设由
    `__get__()` 首先看到的第一个类是它需要了解的唯一父类。尽管事实上，如果特定类具有继承的子类，那么关联代理实际上是代表不止一个父类工作的，尽管没有明确地重新使用它。尽管即使存在这样的缺点，关联代理仍然会通过其当前行为取得相当大的进展，但在某些情况下仍存在缺陷以及确定最佳“所有者”类的复杂问题。'
- en: These problems are now solved in that [`AssociationProxy`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy
    "sqlalchemy.ext.associationproxy.AssociationProxy") no longer modifies its own
    internal state when `__get__()` is called; instead, a new object is generated
    per-class known as [`AssociationProxyInstance`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxyInstance
    "sqlalchemy.ext.associationproxy.AssociationProxyInstance") which handles all
    the state specific to a particular mapped parent class (when the parent class
    is not mapped, no [`AssociationProxyInstance`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxyInstance
    "sqlalchemy.ext.associationproxy.AssociationProxyInstance") is generated). The
    concept of a single “owning class” for the association proxy, which was nonetheless
    improved in 1.1, has essentially been replaced with an approach where the AP now
    can treat any number of “owning” classes equally.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题现在已经在[`AssociationProxy`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy
    "sqlalchemy.ext.associationproxy.AssociationProxy")中得到解决，当调用`__get__()`时不再修改其自身的内部状态；相反，每个已知类别都会生成一个名为[`AssociationProxyInstance`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxyInstance
    "sqlalchemy.ext.associationproxy.AssociationProxyInstance")的新对象，该对象处理特定映射父类的所有状态（当父类未映射时，不会生成[`AssociationProxyInstance`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxyInstance
    "sqlalchemy.ext.associationproxy.AssociationProxyInstance")）。 单个“拥有类”的概念用于关联代理，尽管在1.1中有所改进，但基本上已被替换为现在的方法，其中AP现在可以平等地处理任意数量的“拥有”类。
- en: 'To accommodate for applications that want to inspect this state for an [`AssociationProxy`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy
    "sqlalchemy.ext.associationproxy.AssociationProxy") without necessarily calling
    `__get__()`, a new method [`AssociationProxy.for_class()`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy.for_class
    "sqlalchemy.ext.associationproxy.AssociationProxy.for_class") is added that provides
    direct access to a class-specific [`AssociationProxyInstance`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxyInstance
    "sqlalchemy.ext.associationproxy.AssociationProxyInstance"), demonstrated as:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 为了适应希望检查此状态的应用程序而不必调用`__get__()`的情况，添加了一个新方法[`AssociationProxy.for_class()`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy.for_class
    "sqlalchemy.ext.associationproxy.AssociationProxy.for_class")，它提供了直接访问特定类别[`AssociationProxyInstance`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxyInstance
    "sqlalchemy.ext.associationproxy.AssociationProxyInstance")的功能，如下所示：
- en: '[PRE91]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Once we have the [`AssociationProxyInstance`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxyInstance
    "sqlalchemy.ext.associationproxy.AssociationProxyInstance") object, in the above
    example stored in the `proxy_state` variable, we can look at attributes specific
    to the `User.keywords` proxy, such as `target_class`:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了[`AssociationProxyInstance`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxyInstance
    "sqlalchemy.ext.associationproxy.AssociationProxyInstance")对象，在上面的示例中存储在`proxy_state`变量中，我们可以查看特定于`User.keywords`代理的属性，例如`target_class`：
- en: '[PRE92]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[#3423](https://www.sqlalchemy.org/trac/ticket/3423)  #### AssociationProxy
    now provides standard column operators for a column-oriented target'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3423](https://www.sqlalchemy.org/trac/ticket/3423)  #### AssociationProxy现在为基于列的目标提供了标准列操作符'
- en: 'Given an [`AssociationProxy`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy
    "sqlalchemy.ext.associationproxy.AssociationProxy") where the target is a database
    column, and is **not** an object reference or another association proxy:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于[`AssociationProxy`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy
    "sqlalchemy.ext.associationproxy.AssociationProxy")的目标是数据库列，并且**不是**对象引用或另一个关联代理的情况：
- en: '[PRE93]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'The `User.values` association proxy refers to the `Element.value` column. Standard
    column operations are now available, such as `like`:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '`User.values`关联代理指的是`Element.value`列。现在可用标准列操作，例如`like`：'
- en: '[PRE94]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '`equals`:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '`equals`：'
- en: '[PRE95]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'When comparing to `None`, the `IS NULL` expression is augmented with a test
    that the related row does not exist at all; this is the same behavior as before:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 在与`None`比较时，`IS NULL`表达式增加了一个测试，即相关行根本不存在；这与以前的行为相同：
- en: '[PRE96]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Note that the [`ColumnOperators.contains()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.contains
    "sqlalchemy.sql.expression.ColumnOperators.contains") operator is in fact a string
    comparison operator; **this is a change in behavior** in that previously, the
    association proxy used `.contains` as a list containment operator only. With a
    column-oriented comparison, it now behaves like a “like”:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 注意[`ColumnOperators.contains()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.contains
    "sqlalchemy.sql.expression.ColumnOperators.contains")操作符实际上是一个字符串比较操作符；**这是一个行为上的改变**，之前，关联代理只将`.contains`作为列表包含操作符使用。现在，通过列比较，它现在的行为类似于“like”：
- en: '[PRE97]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: In order to test the `User.values` collection for simple membership of the value
    `"foo"`, the equals operator (e.g. `User.values == 'foo'`) should be used; this
    works in previous versions as well.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试`User.values`集合是否包含值`"foo"`，应该使用等于操作符（例如`User.values == 'foo'`）；这在之前的版本中也是有效的。
- en: 'When using an object-based association proxy with a collection, the behavior
    is as before, that of testing for collection membership, e.g. given a mapping:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用基于对象的关联代理与集合时，行为与以前相同，即测试集合成员资格，例如给定一个映射：
- en: '[PRE98]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'The `.contains()` method produces the same expression as before, testing the
    list of `User.elements` for the presence of an `Element` object:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: '`.contains()`方法产生与以前相同的表达式，测试`User.elements`列表中是否存在`Element`对象：'
- en: '[PRE99]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Overall, the change is enabled based on the architectural change that is part
    of [AssociationProxy stores class-specific state on a per-class basis](#change-3423);
    as the proxy now spins off additional state when an expression is generated, there
    is both an object-target and a column-target version of the [`AssociationProxyInstance`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxyInstance
    "sqlalchemy.ext.associationproxy.AssociationProxyInstance") class.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，这个改变是基于[AssociationProxy stores class-specific state on a per-class basis](#change-3423)的架构变化而启用的；因为代理现在在生成表达式时会衍生出额外的状态，所以[`AssociationProxyInstance`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxyInstance
    "sqlalchemy.ext.associationproxy.AssociationProxyInstance")类现在有对象目标和列目标版本。
- en: '[#4351](https://www.sqlalchemy.org/trac/ticket/4351)'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4351](https://www.sqlalchemy.org/trac/ticket/4351)'
- en: Association Proxy now Strong References the Parent Object
  id: totrans-412
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 关联代理现在强引用父对象
- en: The long-standing behavior of the association proxy collection maintaining only
    a weak reference to the parent object is reverted; the proxy will now maintain
    a strong reference to the parent for as long as the proxy collection itself is
    also in memory, eliminating the “stale association proxy” error. This change is
    being made on an experimental basis to see if any use cases arise where it causes
    side effects.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 长期以来，关联代理集合仅保持对父对象的弱引用的行为被恢复；代理现在将保持对父对象的强引用，只要代理集合本身也在内存中，消除了“过时的关联代理”错误。这个改变是基于实验性基础进行的，以查看是否会出现任何导致副作用的用例。
- en: 'As an example, given a mapping with association proxy:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 举例来说，给定一个带有关联代理的映射：
- en: '[PRE100]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Previously, if `a1` were deleted out of scope:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，如果`a1`超出范围被删除：
- en: '[PRE101]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Trying to iterate the `b_data` collection after `a1` is deleted from scope
    would raise the error `"stale association proxy, parent object has gone out of
    scope"`. This is because the association proxy needs to access the actual `a1.bs`
    collection in order to produce a view, and prior to this change it maintained
    only a weak reference to `a1`. In particular, users would frequently encounter
    this error when performing an inline operation such as:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 在`a1`超出范围被删除后尝试迭代`b_data`集合会引发错误“过时的关联代理，父对象已经超出范围”。这是因为关联代理需要访问实际的`a1.bs`集合以产生视图，在这个改变之前，它只保持对`a1`的弱引用。特别是，用户在执行内联操作时经常会遇到这个错误，比如：
- en: '[PRE102]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Above, because the `A` object would be garbage collected before the `b_data`
    collection were actually used.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的例子中，因为`A`对象在实际使用`b_data`集合之前已被垃圾回收。
- en: 'The change is that the `b_data` collection is now maintaining a strong reference
    to the `a1` object, so that it remains present:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 改变是`b_data`集合现在保持对`a1`对象的强引用，以便它保持存在：
- en: '[PRE103]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: This change introduces the side effect that if an application is passing around
    the collection as above, **the parent object won’t be garbage collected** until
    the collection is also discarded. As always, if `a1` is persistent inside a particular
    [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session"),
    it will remain part of that session’s state until it is garbage collected.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 此更改引入的副作用是，如果一个应用程序像上面一样传递集合，**父对象在集合被丢弃之前不会被垃圾回收**。正如以往一样，如果 `a1` 在特定的 [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") 内是持久化的，它将保持为该会话的状态直到被垃圾回收。
- en: Note that this change may be revised if it leads to problems.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果这种变化导致问题，可能会对此进行修订。
- en: '[#4268](https://www.sqlalchemy.org/trac/ticket/4268)'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4268](https://www.sqlalchemy.org/trac/ticket/4268)'
- en: '#### Implemented bulk replace for sets, dicts with AssociationProxy'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 为集合，具有 AssociationProxy 的字典实现批量替换'
- en: 'Assignment of a set or dictionary to an association proxy collection should
    now work correctly, whereas before it would re-create association proxy members
    for existing keys, leading to the issue of potential flush failures due to the
    delete+insert of the same object it now should only create new association objects
    where appropriate:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将集合代理分配给集合代理集合的集合应该正常工作，而以前会为现有键重新创建集合代理成员，导致潜在的刷新失败问题，因为删除+插入相同对象，现在应该只在适当的情况下创建新的关联对象：
- en: '[PRE104]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[#2642](https://www.sqlalchemy.org/trac/ticket/2642)  ### Many-to-one backref
    checks for collection duplicates during remove operation'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2642](https://www.sqlalchemy.org/trac/ticket/2642)  ### 多对一反向引用在删除操作期间检查集合重复项'
- en: 'When an ORM-mapped collection that existed as a Python sequence, typically
    a Python `list` as is the default for [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship"), contained duplicates, and the object were removed
    from one of its positions but not the other(s), a many-to-one backref would set
    its attribute to `None` even though the one-to-many side still represented the
    object as present. Even though one-to-many collections cannot have duplicates
    in the relational model, an ORM-mapped [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") that uses a sequence collection can have duplicates
    inside of it in memory, with the restriction that this duplicate state can neither
    be persisted nor retrieved from the database. In particular, having a duplicate
    temporarily present in the list is intrinsic to a Python “swap” operation. Given
    a standard one-to-many/many-to-one setup:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个ORM映射的集合存在作为Python序列时，通常是Python `list`，作为 [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") 的默认值，包含重复项，并且对象从其中一个位置被移除但其他位置没有移除时，一个多对一的反向引用会将其属性设置为
    `None`，即使一对多的一侧仍然表示对象存在。即使一对多的集合在关系模型中不能有重复项，在内存中使用序列集合的ORM映射的 [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") 可以包含其中的重复项，但限制是这种重复状态既不能持久化也不能从数据库中检索。特别是，在列表中临时存在重复项是
    Python “swap” 操作的固有特性。考虑到标准的一对多/多对一设置：
- en: '[PRE105]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'If we have an `A` object with two `B` members, and perform a swap:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个带有两个 `B` 成员的 `A` 对象，并执行交换：
- en: '[PRE106]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'During the above operation, interception of the standard Python `__setitem__`
    `__delitem__` methods delivers an interim state where the second `B()` object
    is present twice in the collection. When the `B()` object is removed from one
    of the positions, the `B.a` backref would set the reference to `None`, causing
    the link between the `A` and `B` object to be removed during the flush. The same
    issue can be demonstrated using plain duplicates:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述操作期间，拦截标准的 Python `__setitem__` `__delitem__` 方法提供了一个临时状态，其中第二个 `B()` 对象在集合中出现两次。当从一个位置移除
    `B()` 对象时，`B.a` 反向引用将引用设置为 `None`，导致刷新期间删除 `A` 和 `B` 对象之间的链接。同样的问题也可以使用普通重复项演示：
- en: '[PRE107]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: The fix ensures that when the backref fires off, which is before the collection
    is mutated, the collection is checked for exactly one or zero instances of the
    target item before unsetting the many-to-one side, using a linear search which
    at the moment makes use of `list.search` and `list.__contains__`.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 修复确保在触发反向引用之前，即在修改集合之前，对集合进行检查，确保目标项的实例数量为零或一，然后取消多对一的一侧，使用线性搜索，目前使用 `list.search`
    和 `list.__contains__`。
- en: Originally it was thought that an event-based reference counting scheme would
    need to be used within the collection internals so that all duplicate instances
    could be tracked throughout the lifecycle of the collection, which would have
    added a performance/memory/complexity impact to all collection operations, including
    the very frequent operations of loading and appending. The approach that is taken
    instead limits the additional expense to the less common operations of collection
    removal and bulk replacement, and the observed overhead of the linear scan is
    negligible; linear scans of relationship-bound collections are already used within
    the unit of work as well as when a collection is bulk replaced.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 最初认为在集合内部需要使用基于事件的引用计数方案，以便在整个集合的生命周期中跟踪所有重复实例，这将对所有集合操作产生性能/内存/复杂性影响，包括加载和追加这些非常频繁的操作。相反采取的方法将额外的开销限制在较少常见的集合移除和批量替换操作上，线性扫描的观察开销是可以忽略的；在工作单元中已经使用了与关系绑定集合的线性扫描，以及在集合进行批量替换时。
- en: '[#1103](https://www.sqlalchemy.org/trac/ticket/1103)  ### Relationship to AliasedClass
    replaces the need for non primary mappers'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: '[#1103](https://www.sqlalchemy.org/trac/ticket/1103)  ### 与AliasedClass的关系取代了非主映射器的需求'
- en: The “non primary mapper” is a [`Mapper`](../orm/mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper") created in the [Imperative Mapping](../orm/mapping_styles.html#orm-imperative-mapping)
    style, which acts as an additional mapper against an already mapped class against
    a different kind of selectable. The non primary mapper has its roots in the 0.1,
    0.2 series of SQLAlchemy where it was anticipated that the [`Mapper`](../orm/mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper") object was to be the primary query construction interface,
    before the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    object existed.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: “非主映射器”是以[Imperative Mapping](../orm/mapping_styles.html#orm-imperative-mapping)风格创建的[`Mapper`](../orm/mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper")，它充当已经映射类的另一种可选择的附加映射器。非主映射器起源于SQLAlchemy的0.1、0.2系列，当时预期[`Mapper`](../orm/mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper")对象将是主要的查询构造接口，而[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")对象还不存在。
- en: With the advent of [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") and later the [`AliasedClass`](../orm/queryguide/api.html#sqlalchemy.orm.util.AliasedClass
    "sqlalchemy.orm.util.AliasedClass") construct, most use cases for the non primary
    mapper went away. This was a good thing since SQLAlchemy also moved away from
    “classical” mappings altogether around the 0.5 series in favor of the declarative
    system.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 随着[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")的出现，以及后来的[`AliasedClass`](../orm/queryguide/api.html#sqlalchemy.orm.util.AliasedClass
    "sqlalchemy.orm.util.AliasedClass")构造，大多数非主映射器的用例都消失了。这是一件好事，因为SQLAlchemy在0.5系列左右也完全摆脱了“经典”映射，转而采用了声明式系统。
- en: One use case remained around for non primary mappers when it was realized that
    some very hard-to-define [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") configurations could be made possible when a non-primary
    mapper with an alternative selectable was made as the mapping target, rather than
    trying to construct a [`relationship.primaryjoin`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.primaryjoin
    "sqlalchemy.orm.relationship") that encompassed all the complexity of a particular
    inter-object relationship.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 当意识到一些非常难以定义的[`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")配置可能成为可能时，仍然存在一个非主映射器的用例，当一个具有替代可选择项的非主映射器被作为映射目标时，而不是尝试构建一个包含特定对象间关系所有复杂性的[`relationship.primaryjoin`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.primaryjoin
    "sqlalchemy.orm.relationship")。
- en: As this use case became more popular, its limitations became apparent, including
    that the non primary mapper is difficult to configure against a selectable that
    adds new columns, that the mapper does not inherit the relationships of the original
    mapping, that relationships which are configured explicitly on the non primary
    mapper do not function well with loader options, and that the non primary mapper
    also doesn’t provide a fully functional namespace of column-based attributes which
    can be used in queries (which again, in the old 0.1 - 0.4 days, one would use
    [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    objects directly with the ORM).
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: '随着这种使用情况越来越普遍，它的局限性变得明显，包括非主映射器难以配置到可选的添加新列的地方，映射器不继承原始映射的关系，非主映射器上明确配置的关系在加载器选项中表现不佳，非主映射器也不提供可以在查询中使用的基于列的属性的完整功能命名空间（在旧的0.1至0.4版本中，人们可以直接使用[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")对象与ORM）。  '
- en: The missing piece was to allow the [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") to refer directly to the [`AliasedClass`](../orm/queryguide/api.html#sqlalchemy.orm.util.AliasedClass
    "sqlalchemy.orm.util.AliasedClass"). The [`AliasedClass`](../orm/queryguide/api.html#sqlalchemy.orm.util.AliasedClass
    "sqlalchemy.orm.util.AliasedClass") already does everything we want the non primary
    mapper to do; it allows an existing mapped class to be loaded from an alternative
    selectable, it inherits all the attributes and relationships of the existing mapper,
    it works extremely well with loader options, and it provides a class-like object
    that can be mixed into queries just like the class itself. With this change, the
    recipes that were formerly for non primary mappers at [Configuring how Relationship
    Joins](../orm/join_conditions.html#relationship-configure-joins) are changed to
    aliased class.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: '缺失的部分是允许[`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")直接引用[`AliasedClass`](../orm/queryguide/api.html#sqlalchemy.orm.util.AliasedClass
    "sqlalchemy.orm.util.AliasedClass")。 [`AliasedClass`](../orm/queryguide/api.html#sqlalchemy.orm.util.AliasedClass
    "sqlalchemy.orm.util.AliasedClass")已经实现了我们希望非主映射器实现的所有功能；它允许从替代选择加载现有映射类，它继承了现有映射器的所有属性和关系，它与加载器选项非常配合，它提供了一个可以像类本身一样混入查询的类似类对象。通过这种改变，以前针对非主映射器的配方在[配置关联加入](../orm/join_conditions.html#relationship-configure-joins)处被改为别名类。  '
- en: 'At [Relationship to Aliased Class](../orm/join_conditions.html#relationship-aliased-class),
    the original non primary mapper looked like:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: '在[关联到别名类](../orm/join_conditions.html#relationship-aliased-class)，原始的非主映射器如下所示：  '
- en: '[PRE108]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: The properties were necessary in order to re-map the additional columns so that
    they did not conflict with the existing columns mapped to `B`, as well as it was
    necessary to define a new primary key.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: '这些属性是必需的，以便重新映射附加列，以便它们不与映射到`B`的现有列发生冲突，同时还需要定义一个新的主键。  '
- en: 'With the new approach, all of this verbosity goes away, and the additional
    columns are referenced directly when making the relationship:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: '采用新方法，所有这些冗长都消失了，并且在建立关系时直接引用附加列：  '
- en: '[PRE109]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: The non primary mapper is now deprecated with the eventual goal to be that classical
    mappings as a feature go away entirely. The Declarative API would become the single
    means of mapping which hopefully will allow internal improvements and simplifications,
    as well as a clearer documentation story.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: '非主映射器现在已经被弃用，最终目标是将经典映射作为一种功能完全取消。声明性API将成为映射的唯一手段，这希望能够实现内部改进和简化，以及更清晰的文档编写。  '
- en: '[#4423](https://www.sqlalchemy.org/trac/ticket/4423)'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4423](https://www.sqlalchemy.org/trac/ticket/4423)  '
- en: '### selectin loading no longer uses JOIN for simple one-to-many'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: '### selectin 加载不再对简单的一对多使用 JOIN  '
- en: The “selectin” loading feature added in 1.2 introduced an extremely performant
    new way to eagerly load collections, in many cases much faster than that of “subquery”
    eager loading, as it does not rely upon restating the original SELECT query and
    instead uses a simple IN clause. However, the “selectin” load still relied upon
    rendering a JOIN between the parent and related tables, since it needs the parent
    primary key values in the row in order to match rows up. In 1.3, a new optimization
    is added which will omit this JOIN in the most common case of a simple one-to-many
    load, where the related row already contains the primary key of the parent row
    expressed in its foreign key columns. This again provides for a dramatic performance
    improvement as the ORM now can load large numbers of collections all in one query
    without using JOIN or subqueries at all.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 在1.2中添加的“selectin”加载功能引入了一种极其高效的新方法来急切加载集合，在许多情况下比“subquery”急切加载要快得多，因为它不依赖于重新声明原始SELECT查询，而是使用一个简单的IN子句。然而，“selectin”加载仍然依赖于在父表和相关表之间渲染JOIN，因为它需要行中的父主键值以匹配行。在1.3中，添加了一种新的优化，将在简单的一对多加载的最常见情况下省略此JOIN，其中相关行已经包含了父行的主键值，表达为其外键列。这再次提供了显著的性能改进，因为ORM现在可以一次性加载大量集合，而无需使用JOIN或子查询。
- en: 'Given a mapping:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个映射：
- en: '[PRE110]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'In the 1.2 version of “selectin” loading, a load of A to B looks like:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 在“selectin”加载的1.2版本中，从A到B的加载看起来像：
- en: '[PRE111]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'With the new behavior, the load looks like:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 使用新行为后，负载看起来像：
- en: '[PRE112]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: The behavior is being released as automatic, using a similar heuristic that
    lazy loading uses in order to determine if related entities can be fetched directly
    from the identity map. However, as with most querying features, the feature’s
    implementation became more complex as a result of advanced scenarios regarding
    polymorphic loading. If problems are encountered, users should report a bug, however
    the change also includes a flag [`relationship.omit_join`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.omit_join
    "sqlalchemy.orm.relationship") which can be set to `False` on the [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") to disable the optimization.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 该行为被释放为自动的，使用了类似于延迟加载的启发式方法，以确定是否可以直接从标识映射中获取相关实体。然而，与大多数查询功能一样，由于涉及多态加载的高级场景，该功能的实现变得更加复杂。如果遇到问题，用户应该报告错误，但是该更改还包括一个标志[`relationship.omit_join`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.omit_join
    "sqlalchemy.orm.relationship")，可以在[`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")上设置为`False`，以禁用优化。
- en: '[#4340](https://www.sqlalchemy.org/trac/ticket/4340)'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4340](https://www.sqlalchemy.org/trac/ticket/4340)'
- en: '### Improvement to the behavior of many-to-one query expressions'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: '### 改进多对一查询表达式的行为'
- en: 'When building a query that compares a many-to-one relationship to an object
    value, such as:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 当构建一个将多对一关系与对象值进行比较的查询时，例如：
- en: '[PRE113]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: The above expression `Address.user == u1`, which ultimately compiles to a SQL
    expression normally based on the primary key columns of the `User` object like
    `"address.user_id = 5"`, uses a deferred callable in order to retrieve the value
    `5` within the bound expression until as late as possible. This is to suit both
    the use case where the `Address.user == u1` expression may be against a `User`
    object that isn’t flushed yet which relies upon a server- generated primary key
    value, as well as that the expression always returns the correct result even if
    the primary key value of `u1` has been changed since the expression was created.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 上述表达式`Address.user == u1`，最终编译成一个基于`User`对象的主键列的SQL表达式，如`"address.user_id =
    5"`，使用延迟可调用以在绑定表达式中尽可能晚地检索值`5`。这是为了适应这样一个用例，即`Address.user == u1`表达式可能针对尚未刷新的`User`对象，该对象依赖于服务器生成的主键值，以及该表达式始终返回正确的结果，即使自创建表达式以来`u1`的主键值已更改。
- en: 'However, a side effect of this behavior is that if `u1` ends up being expired
    by the time the expression is evaluated, it results in an additional SELECT statement,
    and in the case that `u1` was also detached from the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session"), it would raise an error:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种行为的一个副作用是，如果在评估表达式时`u1`最终过期，将导致额外的SELECT语句，并且在`u1`也从[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")中分离的情况下，将引发错误：
- en: '[PRE114]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: The expiration / expunging of the object can occur implicitly when the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session") is committed and the `u1` instance falls out of scope,
    as the `Address.user == u1` expression does not strongly reference the object
    itself, only its [`InstanceState`](../orm/internals.html#sqlalchemy.orm.InstanceState
    "sqlalchemy.orm.InstanceState").
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 当 [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    提交并且 `u1` 实例超出范围时，对象的过期 / 删除可能会隐式发生，因为 `Address.user == u1` 表达式不会强烈引用对象本身，而只会引用其[`InstanceState`](../orm/internals.html#sqlalchemy.orm.InstanceState
    "sqlalchemy.orm.InstanceState")。
- en: The fix is to allow the `Address.user == u1` expression to evaluate the value
    `5` based on attempting to retrieve or load the value normally at expression compilation
    time as it does now, but if the object is detached and has been expired, it is
    retrieved from a new mechanism upon the [`InstanceState`](../orm/internals.html#sqlalchemy.orm.InstanceState
    "sqlalchemy.orm.InstanceState") which will memoize the last known value for a
    particular attribute on that state when that attribute is expired. This mechanism
    is only enabled for a specific attribute / [`InstanceState`](../orm/internals.html#sqlalchemy.orm.InstanceState
    "sqlalchemy.orm.InstanceState") when needed by the expression feature to conserve
    performance / memory overhead.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 修复方法是允许 `Address.user == u1` 表达式根据在表达式编译时尝试正常检索或加载值的基础上评估值 `5`，就像现在一样，但如果对象是分离的并且已过期，则从
    [`InstanceState`](../orm/internals.html#sqlalchemy.orm.InstanceState "sqlalchemy.orm.InstanceState")上的新机制中检索，该机制将在该状态上的当属性过期时为该特定属性的最后已知值进行存储。仅当表达式功能需要时，此机制才会为特定属性
    / [`InstanceState`](../orm/internals.html#sqlalchemy.orm.InstanceState "sqlalchemy.orm.InstanceState")启用以节省性能
    / 内存开销。
- en: Originally, simpler approaches such as evaluating the expression immediately
    with various arrangements for trying to load the value later if not present were
    attempted, however the difficult edge case is that of the value of a column attribute
    (typically a natural primary key) that is being changed. In order to ensure that
    an expression like `Address.user == u1` always returns the correct answer for
    the current state of `u1`, it will return the current database-persisted value
    for a persistent object, unexpiring via SELECT query if necessary, and for a detached
    object it will return the most recent known value, regardless of when the object
    was expired using a new feature within the [`InstanceState`](../orm/internals.html#sqlalchemy.orm.InstanceState
    "sqlalchemy.orm.InstanceState") that tracks the last known value of a column attribute
    whenever the attribute is to be expired.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，尝试了诸如立即评估表达式并在以后尝试加载值时采取各种安排的简单方法，但困难的边缘案例是正在更改的列属性的值（通常是自然主键）的值。为了确保像 `Address.user
    == u1` 这样的表达式始终返回 `u1` 的当前状态的正确答案，如果需要，它将返回持久对象的当前数据库持久值，通过 SELECT 查询取消到期，并且对于分离的对象，它将返回最近已知的值，无论对象何时被使用新特性将其过期在[`InstanceState`](../orm/internals.html#sqlalchemy.orm.InstanceState
    "sqlalchemy.orm.InstanceState")中跟踪列属性的最后已知值时。
- en: Modern attribute API features are used to indicate specific error messages when
    the value cannot be evaluated, the two cases of which are when the column attributes
    have never been set, and when the object was already expired when the first evaluation
    was made and is now detached. In all cases, [`DetachedInstanceError`](../orm/exceptions.html#sqlalchemy.orm.exc.DetachedInstanceError
    "sqlalchemy.orm.exc.DetachedInstanceError") is no longer raised.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 当值无法评估时，现代属性API功能用于指示特定的错误消息，两种情况是当列属性从未设置过时，以及当对象在首次评估时已经过期且现在分离时。在所有情况下，[`DetachedInstanceError`](../orm/exceptions.html#sqlalchemy.orm.exc.DetachedInstanceError
    "sqlalchemy.orm.exc.DetachedInstanceError")不再被引发。
- en: '[#4359](https://www.sqlalchemy.org/trac/ticket/4359)'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4359](https://www.sqlalchemy.org/trac/ticket/4359)'
- en: '### Many-to-one replacement won’t raise for “raiseload” or detached for “old”
    object'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: '### 多对一替换不会对“raiseload”或“old”对象进行提升'
- en: 'Given the case where a lazy load would proceed on a many-to-one relationship
    in order to load the “old” value, if the relationship does not specify the [`relationship.active_history`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.active_history
    "sqlalchemy.orm.relationship") flag, an assertion will not be raised for a detached
    object:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到延迟加载将在多对一关系上进行以加载“old”值的情况，如果关系未指定[`relationship.active_history`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.active_history
    "sqlalchemy.orm.relationship")标志，则不会为分离的对象引发断言：
- en: '[PRE115]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: Above, when the `.user` attribute is replaced on the detached `a1` object, a
    [`DetachedInstanceError`](../orm/exceptions.html#sqlalchemy.orm.exc.DetachedInstanceError
    "sqlalchemy.orm.exc.DetachedInstanceError") would be raised as the attribute is
    attempting to retrieve the previous value of `.user` from the identity map. The
    change is that the operation now proceeds without the old value being loaded.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 上面，当在分离的 `a1` 对象上替换 `.user` 属性时，会引发 [`DetachedInstanceError`](../orm/exceptions.html#sqlalchemy.orm.exc.DetachedInstanceError
    "sqlalchemy.orm.exc.DetachedInstanceError")，因为属性试图从标识映射中检索 `.user` 的先前值。更改是现在操作会在不加载旧值的情况下继续进行。
- en: 'The same change is also made to the `lazy="raise"` loader strategy:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 对 `lazy="raise"` 加载器策略也进行了相同的更改：
- en: '[PRE116]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: Previously, the association of `a1.user` would invoke the “raiseload” exception
    as a result of the attribute attempting to retrieve the previous value. This assertion
    is now skipped in the case of loading the “old” value.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，`a1.user` 的关联会引发 “raiseload” 异常，因为属性试图检索先前的值。现在在加载 “旧” 值的情况下跳过了此断言。
- en: '[#4353](https://www.sqlalchemy.org/trac/ticket/4353)'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4353](https://www.sqlalchemy.org/trac/ticket/4353)'
- en: '### “del” implemented for ORM attributes'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: '### 为 ORM 属性实现了 “del”'
- en: 'The Python `del` operation was not really usable for mapped attributes, either
    scalar columns or object references. Support has been added for this to work correctly,
    where the `del` operation is roughly equivalent to setting the attribute to the
    `None` value:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: Python `del` 操作实际上不能用于映射属性，无论是标量列还是对象引用。已经添加了对此的支持，使其能够正常工作，其中 `del` 操作大致相当于将属性设置为
    `None` 值：
- en: '[PRE117]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[#4354](https://www.sqlalchemy.org/trac/ticket/4354)'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4354](https://www.sqlalchemy.org/trac/ticket/4354)'
- en: '### info dictionary added to InstanceState'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: '### 添加到 InstanceState 的 info 字典'
- en: 'Added the `.info` dictionary to the [`InstanceState`](../orm/internals.html#sqlalchemy.orm.InstanceState
    "sqlalchemy.orm.InstanceState") class, the object that comes from calling [`inspect()`](../core/inspection.html#sqlalchemy.inspect
    "sqlalchemy.inspect") on a mapped object. This allows custom recipes to add additional
    information about an object that will be carried along with that object’s full
    lifecycle in memory:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `.info` 字典添加到 [`InstanceState`](../orm/internals.html#sqlalchemy.orm.InstanceState
    "sqlalchemy.orm.InstanceState") 类，该类是通过在映射对象上调用 [`inspect()`](../core/inspection.html#sqlalchemy.inspect
    "sqlalchemy.inspect") 获得的。这允许自定义方案为对象添加关于对象的其他信息，该信息将随对象在内存中的完整生命周期一起传递：
- en: '[PRE118]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[#4257](https://www.sqlalchemy.org/trac/ticket/4257)'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4257](https://www.sqlalchemy.org/trac/ticket/4257)'
- en: '### Horizontal Sharding extension supports bulk update and delete methods'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: '### 水平分片扩展支持批量更新和删除方法'
- en: The [`ShardedQuery`](../orm/extensions/horizontal_shard.html#sqlalchemy.ext.horizontal_shard.ShardedQuery
    "sqlalchemy.ext.horizontal_shard.ShardedQuery") extension object supports the
    [`Query.update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.update "sqlalchemy.orm.Query.update")
    and [`Query.delete()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.delete
    "sqlalchemy.orm.Query.delete") bulk update/delete methods. The `query_chooser`
    callable is consulted when they are called in order to run the update/delete across
    multiple shards based on given criteria.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: '[`ShardedQuery`](../orm/extensions/horizontal_shard.html#sqlalchemy.ext.horizontal_shard.ShardedQuery
    "sqlalchemy.ext.horizontal_shard.ShardedQuery") 扩展对象支持 [`Query.update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.update
    "sqlalchemy.orm.Query.update") 和 [`Query.delete()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.delete
    "sqlalchemy.orm.Query.delete") 批量更新/删除方法。在调用它们时会咨询 `query_chooser` 可调用对象，以便根据给定的条件在多个分片上运行更新/删除操作。'
- en: '[#4196](https://www.sqlalchemy.org/trac/ticket/4196)'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4196](https://www.sqlalchemy.org/trac/ticket/4196)'
- en: Association Proxy Improvements
  id: totrans-491
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 协会代理改进
- en: While not for any particular reason, the Association Proxy extension had many
    improvements this cycle.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然没有特定的原因，但本次周期内协会代理扩展进行了许多改进。
- en: '#### Association proxy has new cascade_scalar_deletes flag'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 协会代理有新的 cascade_scalar_deletes 标志'
- en: 'Given a mapping as:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个映射如下：
- en: '[PRE119]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'An assignment to `A.b` will generate an `AB` object:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 对 `A.b` 的赋值将生成一个 `AB` 对象：
- en: '[PRE120]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: 'The `A.b` association is scalar, and includes a new flag [`AssociationProxy.cascade_scalar_deletes`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy.params.cascade_scalar_deletes
    "sqlalchemy.ext.associationproxy.AssociationProxy"). When set, setting `A.b` to
    `None` will remove `A.ab` as well. The default behavior remains that it leaves
    `a.ab` in place:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: '`A.b` 关联是标量的，并包括一个新标志 [`AssociationProxy.cascade_scalar_deletes`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy.params.cascade_scalar_deletes
    "sqlalchemy.ext.associationproxy.AssociationProxy")。设置了该标志后，将 `A.b` 设置为 `None`
    将同时移除 `A.ab`。默认行为仍然是保留 `a.ab` 不变：'
- en: '[PRE121]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: While it at first seemed intuitive that this logic should just look at the “cascade”
    attribute of the existing relationship, it’s not clear from that alone if the
    proxied object should be removed, hence the behavior is made available as an explicit
    option.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然最初看起来这个逻辑应该只需查看现有关系的“cascade”属性，但仅凭这一点并不清楚代理对象是否应该被移除，因此行为被作为显式选项提供。
- en: 'Additionally, `del` now works for scalars in a similar manner as setting to
    `None`:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，`del` 现在对标量的工作方式类似于设置为 `None`：
- en: '[PRE122]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[#4308](https://www.sqlalchemy.org/trac/ticket/4308)  #### AssociationProxy
    stores class-specific state on a per-class basis'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4308](https://www.sqlalchemy.org/trac/ticket/4308)  #### AssociationProxy
    在每个类的基础上存储类特定的状态'
- en: The [`AssociationProxy`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy
    "sqlalchemy.ext.associationproxy.AssociationProxy") object makes lots of decisions
    based on the parent mapped class it is associated with. While the [`AssociationProxy`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy
    "sqlalchemy.ext.associationproxy.AssociationProxy") historically began as a relatively
    simple ‘getter,’ it became apparent early on that it also needed to make decisions
    regarding the kind of attribute to which it refers—such as scalar or collection,
    mapped object or simple value, and so on. To achieve this, it needs to inspect
    the mapped attribute or other referring descriptor or attribute, as referenced
    from its parent class. However in Python descriptor mechanics, a descriptor only
    learns about its “parent” class when it is accessed in the context of that class,
    such as calling `MyClass.some_descriptor`, which calls the `__get__()` method
    which passes in the class. The [`AssociationProxy`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy
    "sqlalchemy.ext.associationproxy.AssociationProxy") object would therefore store
    state that is specific to that class, but only once this method were called; trying
    to inspect this state ahead of time without first accessing the [`AssociationProxy`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy
    "sqlalchemy.ext.associationproxy.AssociationProxy") as a descriptor would raise
    an error. Additionally, it would assume that the first class to be seen by `__get__()`
    would be the only parent class it needed to know about. This is despite the fact
    that if a particular class has inheriting subclasses, the association proxy is
    really working on behalf of more than one parent class even though it was not
    explicitly re-used. While even with this shortcoming, the association proxy would
    still get pretty far with its current behavior, it still leaves shortcomings in
    some cases as well as the complex problem of determining the best “owner” class.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: '[`AssociationProxy`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy
    "sqlalchemy.ext.associationproxy.AssociationProxy") 对象根据它关联的父映射类做出许多决策。虽然 [`AssociationProxy`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy
    "sqlalchemy.ext.associationproxy.AssociationProxy") 在历史上始作为相对简单的‘getter’，但很早就显而易见它还需要做出关于它所引用的属性类型的决策——例如标量或集合、映射对象或简单值等。为了实现这一点，它需要检查映射属性或其他引用描述符或属性，从其父类中引用。然而，在
    Python 描述符机制中，描述符仅在上下文中被访问时才了解其“父”类，例如调用 `MyClass.some_descriptor`，这将调用 `__get__()`
    方法，该方法传入类。因此，[`AssociationProxy`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy
    "sqlalchemy.ext.associationproxy.AssociationProxy") 对象将存储特定于该类的状态，但只有在首次调用此方法时才会;
    在首次访问 [`AssociationProxy`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy
    "sqlalchemy.ext.associationproxy.AssociationProxy") 作为描述符之前尝试检查此状态会引发错误。此外，它将假定`__get__()`看到的第一个类是它需要知道的唯一父类。尽管如果一个特定类有继承的子类，协会代理实际上是代表超过一个父类工作的，即使它没有明确地被重新使用。即使有这个缺陷，协会代理仍然可以通过其当前行为取得很大进展，但在某些情况下仍存在缺陷，以及确定最佳“所有者”类的复杂问题。'
- en: These problems are now solved in that [`AssociationProxy`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy
    "sqlalchemy.ext.associationproxy.AssociationProxy") no longer modifies its own
    internal state when `__get__()` is called; instead, a new object is generated
    per-class known as [`AssociationProxyInstance`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxyInstance
    "sqlalchemy.ext.associationproxy.AssociationProxyInstance") which handles all
    the state specific to a particular mapped parent class (when the parent class
    is not mapped, no [`AssociationProxyInstance`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxyInstance
    "sqlalchemy.ext.associationproxy.AssociationProxyInstance") is generated). The
    concept of a single “owning class” for the association proxy, which was nonetheless
    improved in 1.1, has essentially been replaced with an approach where the AP now
    can treat any number of “owning” classes equally.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 这些问题现在得到解决，因为当调用 `__get__()` 时，[`AssociationProxy`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy
    "sqlalchemy.ext.associationproxy.AssociationProxy") 不再修改自己的内部状态；相反，每个类都生成一个名为
    [`AssociationProxyInstance`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxyInstance
    "sqlalchemy.ext.associationproxy.AssociationProxyInstance") 的新对象，处理特定于特定映射父类的所有状态（当父类未映射时，不会生成
    [`AssociationProxyInstance`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxyInstance
    "sqlalchemy.ext.associationproxy.AssociationProxyInstance")）。关联代理的单一“拥有类”概念，尽管在
    1.1 中得到改进，但实质上已被一种方法取代，即 AP 现在可以平等对待任意数量的“拥有”类。
- en: 'To accommodate for applications that want to inspect this state for an [`AssociationProxy`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy
    "sqlalchemy.ext.associationproxy.AssociationProxy") without necessarily calling
    `__get__()`, a new method [`AssociationProxy.for_class()`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy.for_class
    "sqlalchemy.ext.associationproxy.AssociationProxy.for_class") is added that provides
    direct access to a class-specific [`AssociationProxyInstance`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxyInstance
    "sqlalchemy.ext.associationproxy.AssociationProxyInstance"), demonstrated as:'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 为了适应希望检查此状态的应用程序，而不一定调用 `__get__()` 的 [`AssociationProxy`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy
    "sqlalchemy.ext.associationproxy.AssociationProxy")，添加了一个新方法 [`AssociationProxy.for_class()`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy.for_class
    "sqlalchemy.ext.associationproxy.AssociationProxy.for_class")，提供对特定类的 [`AssociationProxyInstance`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxyInstance
    "sqlalchemy.ext.associationproxy.AssociationProxyInstance") 的直接访问，示例如下：
- en: '[PRE123]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'Once we have the [`AssociationProxyInstance`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxyInstance
    "sqlalchemy.ext.associationproxy.AssociationProxyInstance") object, in the above
    example stored in the `proxy_state` variable, we can look at attributes specific
    to the `User.keywords` proxy, such as `target_class`:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了 [`AssociationProxyInstance`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxyInstance
    "sqlalchemy.ext.associationproxy.AssociationProxyInstance") 对象，在上面的示例中存储在 `proxy_state`
    变量中，我们可以查看特定于 `User.keywords` 代理的��性，比如 `target_class`：
- en: '[PRE124]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[#3423](https://www.sqlalchemy.org/trac/ticket/3423)  #### AssociationProxy
    now provides standard column operators for a column-oriented target'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3423](https://www.sqlalchemy.org/trac/ticket/3423)  #### AssociationProxy
    现在为基于列的目标提供标准列运算符'
- en: 'Given an [`AssociationProxy`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy
    "sqlalchemy.ext.associationproxy.AssociationProxy") where the target is a database
    column, and is **not** an object reference or another association proxy:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个 [`AssociationProxy`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy
    "sqlalchemy.ext.associationproxy.AssociationProxy")，其中目标是数据库列，而**不是**对象引用或另一个关联代理：
- en: '[PRE125]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'The `User.values` association proxy refers to the `Element.value` column. Standard
    column operations are now available, such as `like`:'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: '`User.values` 关联代理指向 `Element.value` 列。现在可以进行标准列操作，比如 `like`：'
- en: '[PRE126]'
  id: totrans-514
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '`equals`:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: '`equals`：'
- en: '[PRE127]'
  id: totrans-516
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'When comparing to `None`, the `IS NULL` expression is augmented with a test
    that the related row does not exist at all; this is the same behavior as before:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 当与 `None` 进行比较时，`IS NULL` 表达式会增加一个测试，即相关行根本不存在；这与以前的行为相同：
- en: '[PRE128]'
  id: totrans-518
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'Note that the [`ColumnOperators.contains()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.contains
    "sqlalchemy.sql.expression.ColumnOperators.contains") operator is in fact a string
    comparison operator; **this is a change in behavior** in that previously, the
    association proxy used `.contains` as a list containment operator only. With a
    column-oriented comparison, it now behaves like a “like”:'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，[`ColumnOperators.contains()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.contains
    "sqlalchemy.sql.expression.ColumnOperators.contains")操作实际上是一个字符串比较操作符；**这是行为上的变化**，以前，关联代理仅使用`.contains`作为列表包含操作符。通过基于列的比较，它现在的行为类似于“like”：
- en: '[PRE129]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: In order to test the `User.values` collection for simple membership of the value
    `"foo"`, the equals operator (e.g. `User.values == 'foo'`) should be used; this
    works in previous versions as well.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试`User.values`集合是否包含值“foo”，应该使用等于操作符（例如`User.values == 'foo'`）；这在以前的版本中也适用。
- en: 'When using an object-based association proxy with a collection, the behavior
    is as before, that of testing for collection membership, e.g. given a mapping:'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用基于对象的关联代理与集合时，行为与以前相同，即测试集合成员资格，例如给定一个映射：
- en: '[PRE130]'
  id: totrans-523
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'The `.contains()` method produces the same expression as before, testing the
    list of `User.elements` for the presence of an `Element` object:'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: '`.contains()`方法产生与以前相同的表达式，测试`User.elements`列表中是否存在`Element`对象：'
- en: '[PRE131]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: Overall, the change is enabled based on the architectural change that is part
    of [AssociationProxy stores class-specific state on a per-class basis](#change-3423);
    as the proxy now spins off additional state when an expression is generated, there
    is both an object-target and a column-target version of the [`AssociationProxyInstance`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxyInstance
    "sqlalchemy.ext.associationproxy.AssociationProxyInstance") class.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，这种变化是基于[AssociationProxy stores class-specific state on a per-class basis](#change-3423)的架构变化实现的；因为代理现在在生成表达式时会产生额外的状态，所以[`AssociationProxyInstance`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxyInstance
    "sqlalchemy.ext.associationproxy.AssociationProxyInstance")类现在有对象目标和列目标版本。
- en: '[#4351](https://www.sqlalchemy.org/trac/ticket/4351)'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4351](https://www.sqlalchemy.org/trac/ticket/4351)'
- en: Association Proxy now Strong References the Parent Object
  id: totrans-528
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 关联代理现在强引用父对象
- en: The long-standing behavior of the association proxy collection maintaining only
    a weak reference to the parent object is reverted; the proxy will now maintain
    a strong reference to the parent for as long as the proxy collection itself is
    also in memory, eliminating the “stale association proxy” error. This change is
    being made on an experimental basis to see if any use cases arise where it causes
    side effects.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 关联代理集合长期以来只维护对父对象的弱引用的行为被还原；代理现在将在代理集合本身也在内存中的情况下维护对父对象的强引用，消除了“过时的关联代理”错误。这种变化是基于实验性的基础进行的，以查看是否会出现任何导致副作用的用例。
- en: 'As an example, given a mapping with association proxy:'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 举例来说，给定一个带有关联代理的映射：
- en: '[PRE132]'
  id: totrans-531
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'Previously, if `a1` were deleted out of scope:'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，如果`a1`在作用域外被删除：
- en: '[PRE133]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'Trying to iterate the `b_data` collection after `a1` is deleted from scope
    would raise the error `"stale association proxy, parent object has gone out of
    scope"`. This is because the association proxy needs to access the actual `a1.bs`
    collection in order to produce a view, and prior to this change it maintained
    only a weak reference to `a1`. In particular, users would frequently encounter
    this error when performing an inline operation such as:'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 在`a1`从作用域中删除后尝试迭代`b_data`集合会引发错误“过时的关联代理，父对象已经超出作用域”。这是因为关联代理需要访问实际的`a1.bs`集合以产生视图，在此更改之前，它只维护对`a1`的弱引用。特别是，用户在执行内联操作时经常会遇到此错误，例如：
- en: '[PRE134]'
  id: totrans-535
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: Above, because the `A` object would be garbage collected before the `b_data`
    collection were actually used.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`A`对象在`b_data`集合实际使用之前可能被垃圾回收。
- en: 'The change is that the `b_data` collection is now maintaining a strong reference
    to the `a1` object, so that it remains present:'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 变化在于`b_data`集合现在维护对`a1`对象的强引用，使其保持存在：
- en: '[PRE135]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: This change introduces the side effect that if an application is passing around
    the collection as above, **the parent object won’t be garbage collected** until
    the collection is also discarded. As always, if `a1` is persistent inside a particular
    [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session"),
    it will remain part of that session’s state until it is garbage collected.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 这个改变带来了一个副作用，即如果一个应用程序像上面那样传递集合，**父对象在集合被丢弃之前不会被垃圾回收**。一如既往，如果`a1`在特定的[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")中是持久的，它将一直保留在该会话的状态中，直到被垃圾回收。
- en: Note that this change may be revised if it leads to problems.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，如果这个改变导致问题，可能会进行修订。
- en: '[#4268](https://www.sqlalchemy.org/trac/ticket/4268)'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4268](https://www.sqlalchemy.org/trac/ticket/4268)'
- en: '#### Implemented bulk replace for sets, dicts with AssociationProxy'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 为集合、字典实现了批量替换与AssociationProxy'
- en: 'Assignment of a set or dictionary to an association proxy collection should
    now work correctly, whereas before it would re-create association proxy members
    for existing keys, leading to the issue of potential flush failures due to the
    delete+insert of the same object it now should only create new association objects
    where appropriate:'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 将集合或字典分配给关联代理集合现在应该能够正确工作，而以前会为现有键重新创建关联代理成员，导致由于相同对象的删除+插入而导致潜在的刷新失败问题，现在应该只在适当的情况下创建新的关联对象：
- en: '[PRE136]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[#2642](https://www.sqlalchemy.org/trac/ticket/2642)  #### Association proxy
    has new cascade_scalar_deletes flag'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2642](https://www.sqlalchemy.org/trac/ticket/2642)  #### 关联代理新增了新的cascade_scalar_deletes标志'
- en: 'Given a mapping as:'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个映射如下：
- en: '[PRE137]'
  id: totrans-547
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'An assignment to `A.b` will generate an `AB` object:'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 对`A.b`的赋值将生成一个`AB`对象：
- en: '[PRE138]'
  id: totrans-549
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'The `A.b` association is scalar, and includes a new flag [`AssociationProxy.cascade_scalar_deletes`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy.params.cascade_scalar_deletes
    "sqlalchemy.ext.associationproxy.AssociationProxy"). When set, setting `A.b` to
    `None` will remove `A.ab` as well. The default behavior remains that it leaves
    `a.ab` in place:'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: '`A.b`关联是标量的，并包括一个新标志[`AssociationProxy.cascade_scalar_deletes`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy.params.cascade_scalar_deletes
    "sqlalchemy.ext.associationproxy.AssociationProxy")。当设置时，将`A.b`设置为`None`将同时移除`A.ab`。默认行为仍然是保留`a.ab`在原地：'
- en: '[PRE139]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: While it at first seemed intuitive that this logic should just look at the “cascade”
    attribute of the existing relationship, it’s not clear from that alone if the
    proxied object should be removed, hence the behavior is made available as an explicit
    option.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 起初似乎很直观的是，这个逻辑应该只查看现有关系的“级联”属性，但仅仅从那个属性本身并不清楚代理对象是否应该被移除，因此行为被作为一个明确的选项提供。
- en: 'Additionally, `del` now works for scalars in a similar manner as setting to
    `None`:'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，`del`现在对标量的操作方式与设置为`None`类似：
- en: '[PRE140]'
  id: totrans-554
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[#4308](https://www.sqlalchemy.org/trac/ticket/4308)'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4308](https://www.sqlalchemy.org/trac/ticket/4308)'
- en: '#### AssociationProxy stores class-specific state on a per-class basis'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 关联代理在每个类上存储特定于类的状态'
- en: The [`AssociationProxy`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy
    "sqlalchemy.ext.associationproxy.AssociationProxy") object makes lots of decisions
    based on the parent mapped class it is associated with. While the [`AssociationProxy`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy
    "sqlalchemy.ext.associationproxy.AssociationProxy") historically began as a relatively
    simple ‘getter,’ it became apparent early on that it also needed to make decisions
    regarding the kind of attribute to which it refers—such as scalar or collection,
    mapped object or simple value, and so on. To achieve this, it needs to inspect
    the mapped attribute or other referring descriptor or attribute, as referenced
    from its parent class. However in Python descriptor mechanics, a descriptor only
    learns about its “parent” class when it is accessed in the context of that class,
    such as calling `MyClass.some_descriptor`, which calls the `__get__()` method
    which passes in the class. The [`AssociationProxy`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy
    "sqlalchemy.ext.associationproxy.AssociationProxy") object would therefore store
    state that is specific to that class, but only once this method were called; trying
    to inspect this state ahead of time without first accessing the [`AssociationProxy`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy
    "sqlalchemy.ext.associationproxy.AssociationProxy") as a descriptor would raise
    an error. Additionally, it would assume that the first class to be seen by `__get__()`
    would be the only parent class it needed to know about. This is despite the fact
    that if a particular class has inheriting subclasses, the association proxy is
    really working on behalf of more than one parent class even though it was not
    explicitly re-used. While even with this shortcoming, the association proxy would
    still get pretty far with its current behavior, it still leaves shortcomings in
    some cases as well as the complex problem of determining the best “owner” class.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: '[`AssociationProxy`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy
    "sqlalchemy.ext.associationproxy.AssociationProxy") 对象基于其关联的父映射类做出许多决策。虽然 [`AssociationProxy`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy
    "sqlalchemy.ext.associationproxy.AssociationProxy") 在历史上最初是一个相对简单的“getter”，但很快就明显地需要做出关于其引用的属性类型的决策——比如标量或集合、映射对象或简单值等。为了实现这一点，它需要检查映射属性或其他引用描述符或属性，这些都是从其父类引用的。然而，在
    Python 描述符机制中，描述符只有在在其“父”类的上下文中被访问时才会了解其“父”类，比如调用 `MyClass.some_descriptor`，这会调用
    `__get__()` 方法并传递类。因此，[`AssociationProxy`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy
    "sqlalchemy.ext.associationproxy.AssociationProxy") 对象将存储特定于该类的状态，但只有在调用此方法后才会这样；在未首先将
    [`AssociationProxy`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy
    "sqlalchemy.ext.associationproxy.AssociationProxy") 作为描述符访问的情况下尝试检查此状态将引发错误。此外，它会假定
    `__get__()` 看到的第一个类就是它需要了解的唯一父类。尽管如果一个特定类有继承的子类，关联代理实际上是代表不止一个父类工作，即使没有明确重用。尽管即使有这个缺点，关联代理仍然可以通过其当前行为取得相当大的进展，但在某些情况下仍存在缺陷，以及确定最佳“所有者”类的复杂问题。'
- en: These problems are now solved in that [`AssociationProxy`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy
    "sqlalchemy.ext.associationproxy.AssociationProxy") no longer modifies its own
    internal state when `__get__()` is called; instead, a new object is generated
    per-class known as [`AssociationProxyInstance`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxyInstance
    "sqlalchemy.ext.associationproxy.AssociationProxyInstance") which handles all
    the state specific to a particular mapped parent class (when the parent class
    is not mapped, no [`AssociationProxyInstance`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxyInstance
    "sqlalchemy.ext.associationproxy.AssociationProxyInstance") is generated). The
    concept of a single “owning class” for the association proxy, which was nonetheless
    improved in 1.1, has essentially been replaced with an approach where the AP now
    can treat any number of “owning” classes equally.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这些问题已经解决了，因为在调用 `__get__()` 时，[`AssociationProxy`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy
    "sqlalchemy.ext.associationproxy.AssociationProxy") 不再修改自己的内部状态；相反，针对每个类生成一个新对象，称为
    [`AssociationProxyInstance`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxyInstance
    "sqlalchemy.ext.associationproxy.AssociationProxyInstance")，该对象处理与特定映射的父类相关的所有状态（当父类未映射时，不会生成
    [`AssociationProxyInstance`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxyInstance
    "sqlalchemy.ext.associationproxy.AssociationProxyInstance")）。一个关联代理的单一“拥有类”的概念，尽管在
    1.1 中得到了改进，但基本上已被一种方法取代，即 AP 现在可以平等对待任意数量的“拥有”类。
- en: 'To accommodate for applications that want to inspect this state for an [`AssociationProxy`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy
    "sqlalchemy.ext.associationproxy.AssociationProxy") without necessarily calling
    `__get__()`, a new method [`AssociationProxy.for_class()`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy.for_class
    "sqlalchemy.ext.associationproxy.AssociationProxy.for_class") is added that provides
    direct access to a class-specific [`AssociationProxyInstance`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxyInstance
    "sqlalchemy.ext.associationproxy.AssociationProxyInstance"), demonstrated as:'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 为了适应那些想要检查此状态的应用，而不一定调用 `__get__()` 的应用程序，添加了一个新方法 [`AssociationProxy.for_class()`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy.for_class
    "sqlalchemy.ext.associationproxy.AssociationProxy.for_class")，它提供了对特定类的 [`AssociationProxyInstance`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxyInstance
    "sqlalchemy.ext.associationproxy.AssociationProxyInstance") 的直接访问，如下所示：
- en: '[PRE141]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'Once we have the [`AssociationProxyInstance`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxyInstance
    "sqlalchemy.ext.associationproxy.AssociationProxyInstance") object, in the above
    example stored in the `proxy_state` variable, we can look at attributes specific
    to the `User.keywords` proxy, such as `target_class`:'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们拥有 [`AssociationProxyInstance`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxyInstance
    "sqlalchemy.ext.associationproxy.AssociationProxyInstance") 对象，在上面的示例中存储在 `proxy_state`
    变量中，我们可以查看特定于 `User.keywords` 代理的属性，例如 `target_class`：
- en: '[PRE142]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[#3423](https://www.sqlalchemy.org/trac/ticket/3423)'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3423](https://www.sqlalchemy.org/trac/ticket/3423)'
- en: '#### AssociationProxy now provides standard column operators for a column-oriented
    target'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 关联代理现在为基于列的目标提供标准列操作符'
- en: 'Given an [`AssociationProxy`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy
    "sqlalchemy.ext.associationproxy.AssociationProxy") where the target is a database
    column, and is **not** an object reference or another association proxy:'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个 [`AssociationProxy`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxy
    "sqlalchemy.ext.associationproxy.AssociationProxy")，其中目标是数据库列，并且**不是**对象引用或另一个关联代理：
- en: '[PRE143]'
  id: totrans-566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'The `User.values` association proxy refers to the `Element.value` column. Standard
    column operations are now available, such as `like`:'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: '`User.values` 关联代理指的是 `Element.value` 列。现在可使用标准列操作，例如 `like`：'
- en: '[PRE144]'
  id: totrans-568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '`equals`:'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: '`equals`:'
- en: '[PRE145]'
  id: totrans-570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'When comparing to `None`, the `IS NULL` expression is augmented with a test
    that the related row does not exist at all; this is the same behavior as before:'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 当与 `None` 比较时，`IS NULL` 表达式会增加一个测试，即相关行根本不存在；这与以前的行为相同：
- en: '[PRE146]'
  id: totrans-572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'Note that the [`ColumnOperators.contains()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.contains
    "sqlalchemy.sql.expression.ColumnOperators.contains") operator is in fact a string
    comparison operator; **this is a change in behavior** in that previously, the
    association proxy used `.contains` as a list containment operator only. With a
    column-oriented comparison, it now behaves like a “like”:'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，[`ColumnOperators.contains()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.contains
    "sqlalchemy.sql.expression.ColumnOperators.contains") 操作符实际上是一个字符串比较操作符；**这是一个行为上的改变**，之前，关联代理仅将
    `.contains` 用作列表包含操作符。通过基于列的比较，它现在的行为类似于“like”：
- en: '[PRE147]'
  id: totrans-574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: In order to test the `User.values` collection for simple membership of the value
    `"foo"`, the equals operator (e.g. `User.values == 'foo'`) should be used; this
    works in previous versions as well.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试 `User.values` 集合是否包含值 `"foo"`，应该使用等于操作符（例如 `User.values == 'foo'`）；这在之前的版本中也适用。
- en: 'When using an object-based association proxy with a collection, the behavior
    is as before, that of testing for collection membership, e.g. given a mapping:'
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用基于对象的关联代理与集合时，行为与以前相同，即测试集合成员资格，例如给定一个映射：
- en: '[PRE148]'
  id: totrans-577
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'The `.contains()` method produces the same expression as before, testing the
    list of `User.elements` for the presence of an `Element` object:'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: '`.contains()` 方法产生与之前相同的表达式，测试 `User.elements` 列表中是否存在 `Element` 对象：'
- en: '[PRE149]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: Overall, the change is enabled based on the architectural change that is part
    of [AssociationProxy stores class-specific state on a per-class basis](#change-3423);
    as the proxy now spins off additional state when an expression is generated, there
    is both an object-target and a column-target version of the [`AssociationProxyInstance`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxyInstance
    "sqlalchemy.ext.associationproxy.AssociationProxyInstance") class.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，这个改变是基于[关联代理在每个类的基础上存储特定于类的状态](#change-3423)的架构变化而启用的；由于代理现在在生成表达式时会产生额外的状态，[`AssociationProxyInstance`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.AssociationProxyInstance
    "sqlalchemy.ext.associationproxy.AssociationProxyInstance") 类现在有对象目标和列目标版本。
- en: '[#4351](https://www.sqlalchemy.org/trac/ticket/4351)'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4351](https://www.sqlalchemy.org/trac/ticket/4351)'
- en: Association Proxy now Strong References the Parent Object
  id: totrans-582
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 关联代理现在强引用父对象
- en: The long-standing behavior of the association proxy collection maintaining only
    a weak reference to the parent object is reverted; the proxy will now maintain
    a strong reference to the parent for as long as the proxy collection itself is
    also in memory, eliminating the “stale association proxy” error. This change is
    being made on an experimental basis to see if any use cases arise where it causes
    side effects.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 关联代理集合长期维持对父对象的弱引用的行为被撤销；代理现在将在代理集合本身也在内存中的情况下维持对父对象的强引用，消除了“过时的关联代理”错误。这个改变是基于试验性基础进行的，以查看是否会出现任何导致副作用的用例。
- en: 'As an example, given a mapping with association proxy:'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 举例来说，给定一个带有关联代理的映射：
- en: '[PRE150]'
  id: totrans-585
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'Previously, if `a1` were deleted out of scope:'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，如果 `a1` 超出范围被删除：
- en: '[PRE151]'
  id: totrans-587
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'Trying to iterate the `b_data` collection after `a1` is deleted from scope
    would raise the error `"stale association proxy, parent object has gone out of
    scope"`. This is because the association proxy needs to access the actual `a1.bs`
    collection in order to produce a view, and prior to this change it maintained
    only a weak reference to `a1`. In particular, users would frequently encounter
    this error when performing an inline operation such as:'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `a1` 从范围中删除后尝试迭代 `b_data` 集合会引发错误 `"过时的关联代理，父对象已超出范围"`。这是因为关联代理需要访问实际的 `a1.bs`
    集合以生成视图，在此改变之前，它只维持对 `a1` 的弱引用。特别是，用户在执行内联操作时经常会遇到这个错误：
- en: '[PRE152]'
  id: totrans-589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: Above, because the `A` object would be garbage collected before the `b_data`
    collection were actually used.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的情况是因为 `A` 对象在 `b_data` 集合实际使用之前会被垃圾回收。
- en: 'The change is that the `b_data` collection is now maintaining a strong reference
    to the `a1` object, so that it remains present:'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 变化在于 `b_data` 集合现在维持对 `a1` 对象的强引用，使其保持存在：
- en: '[PRE153]'
  id: totrans-592
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: This change introduces the side effect that if an application is passing around
    the collection as above, **the parent object won’t be garbage collected** until
    the collection is also discarded. As always, if `a1` is persistent inside a particular
    [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session"),
    it will remain part of that session’s state until it is garbage collected.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 这种改变引入了一个副作用，即如果应用程序像上面那样传递集合，**父对象在集合被丢弃之前不会被垃圾回收**。一如既往，如果`a1`在特定的[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")内是持久的，它将一直保留在该会话的状态中，直到被垃圾回收。
- en: Note that this change may be revised if it leads to problems.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果这种改变导致问题，可能会进行修订。
- en: '[#4268](https://www.sqlalchemy.org/trac/ticket/4268)'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4268](https://www.sqlalchemy.org/trac/ticket/4268)'
- en: '#### Implemented bulk replace for sets, dicts with AssociationProxy'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: '#### 使用AssociationProxy为集合实现批量替换的功能'
- en: 'Assignment of a set or dictionary to an association proxy collection should
    now work correctly, whereas before it would re-create association proxy members
    for existing keys, leading to the issue of potential flush failures due to the
    delete+insert of the same object it now should only create new association objects
    where appropriate:'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将集合分配给关联代理集合应该可以正常工作，而以前会为现有键重新创建关联代理成员，导致由于删除+插入相同对象而导致潜在刷新失败的问题，现在应该只在适当的情况下创建新的关联对象：
- en: '[PRE154]'
  id: totrans-598
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '[#2642](https://www.sqlalchemy.org/trac/ticket/2642)'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2642](https://www.sqlalchemy.org/trac/ticket/2642)'
- en: '### Many-to-one backref checks for collection duplicates during remove operation'
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: '### 多对一反向引用在移除操作期间检查集合中的重复项'
- en: 'When an ORM-mapped collection that existed as a Python sequence, typically
    a Python `list` as is the default for [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship"), contained duplicates, and the object were removed
    from one of its positions but not the other(s), a many-to-one backref would set
    its attribute to `None` even though the one-to-many side still represented the
    object as present. Even though one-to-many collections cannot have duplicates
    in the relational model, an ORM-mapped [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship") that uses a sequence collection can have duplicates
    inside of it in memory, with the restriction that this duplicate state can neither
    be persisted nor retrieved from the database. In particular, having a duplicate
    temporarily present in the list is intrinsic to a Python “swap” operation. Given
    a standard one-to-many/many-to-one setup:'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 当ORM映射的集合作为Python序列存在时，通常是Python `list`，这是[`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")的默认值，包含重复项，并且对象从一个位置被移除但未从其他位置移除时，一个多对一的反向引用会将其属性设置为`None`，即使一对多方仍然表示对象存在。尽管一对多集合在关系模型中不能有重复项，但使用序列集合的ORM映射的[`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")在内存中可以有重复项，但这些重复状态既不能持久化也不能从数据库中检索。特别是，在列表中临时存在重复项是Python“交换”操作的固有特性。考虑一个标准的一对多/多对一设置：
- en: '[PRE155]'
  id: totrans-602
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: 'If we have an `A` object with two `B` members, and perform a swap:'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个具有两个`B`成员的`A`对象，并执行交换：
- en: '[PRE156]'
  id: totrans-604
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'During the above operation, interception of the standard Python `__setitem__`
    `__delitem__` methods delivers an interim state where the second `B()` object
    is present twice in the collection. When the `B()` object is removed from one
    of the positions, the `B.a` backref would set the reference to `None`, causing
    the link between the `A` and `B` object to be removed during the flush. The same
    issue can be demonstrated using plain duplicates:'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述操作期间，拦截标准Python `__setitem__` `__delitem__`方法会提供一个中间状态，其中第二个`B()`对象在集合中出现两次。当`B()`对象从一个位置移除时，`B.a`反向引用会将引用设置为`None`，导致在刷新期间删除`A`和`B`对象之间的链接。相同的问题也可以使用普通重复项来演示：
- en: '[PRE157]'
  id: totrans-606
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: The fix ensures that when the backref fires off, which is before the collection
    is mutated, the collection is checked for exactly one or zero instances of the
    target item before unsetting the many-to-one side, using a linear search which
    at the moment makes use of `list.search` and `list.__contains__`.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 修复确保在反向引用触发之前，在集合被改变之前，检查集合中是否恰好有一个或零个目标项的实例，然后在取消多对一方面时使用线性搜索，目前使用`list.search`和`list.__contains__`。
- en: Originally it was thought that an event-based reference counting scheme would
    need to be used within the collection internals so that all duplicate instances
    could be tracked throughout the lifecycle of the collection, which would have
    added a performance/memory/complexity impact to all collection operations, including
    the very frequent operations of loading and appending. The approach that is taken
    instead limits the additional expense to the less common operations of collection
    removal and bulk replacement, and the observed overhead of the linear scan is
    negligible; linear scans of relationship-bound collections are already used within
    the unit of work as well as when a collection is bulk replaced.
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 最初人们认为在集合内部需要使用基于事件的引用计数方案，以便在整个集合的生命周期内跟踪所有重复的实例，这将对所有集合操作产生性能/内存/复杂性影响，包括非常频繁的加载和追加操作。取而代之的方法是将额外的开销限制在较不常见的集合移除和批量替换操作上，并且观察到的线性扫描开销可以忽略不计；关系绑定集合的线性扫描已经在工作单元中使用，以及在集合被批量替换时已经被使用。
- en: '[#1103](https://www.sqlalchemy.org/trac/ticket/1103)'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: '[#1103](https://www.sqlalchemy.org/trac/ticket/1103)'
- en: Key Behavioral Changes - ORM
  id: totrans-610
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关键行为变化 - ORM
- en: '### Query.join() handles ambiguity in deciding the “left” side more explicitly'
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: '### Query.join() 更明确地处理决定“左”侧的歧义'
- en: 'Historically, given a query like the following:'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 从历史上看，给定以下查询：
- en: '[PRE158]'
  id: totrans-613
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: 'given the standard tutorial mappings, the query would produce a FROM clause
    as:'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于标准教程映射，查询将生成一个FROM子句，如下所示：
- en: '[PRE159]'
  id: totrans-615
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'That is, the JOIN would implicitly be against the first entity that matches.
    The new behavior is that an exception requests that this ambiguity be resolved:'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，JOIN会隐式地针对第一个匹配的实体。新的行为是要求解决这种模糊性的异常：
- en: '[PRE160]'
  id: totrans-617
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'The solution is to provide an ON clause, either as an expression:'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是提供一个ON子句，可以是一个表达式：
- en: '[PRE161]'
  id: totrans-619
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: 'Or to use the relationship attribute, if available:'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 或者使用关系属性，如果可用的话：
- en: '[PRE162]'
  id: totrans-621
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: 'The change includes that a join can now correctly link to a FROM clause that
    is not the first element in the list if the join is otherwise non-ambiguous:'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 这个变化包括，如果连接是非模糊的，那么现在连接可以正确地链接到不是列表中第一个元素的FROM子句：
- en: '[PRE163]'
  id: totrans-623
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: 'Prior to this enhancement, the above query would raise:'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 在这项增强之前，上述查询将引发：
- en: '[PRE164]'
  id: totrans-625
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: 'Now the query works fine:'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 现在查询可以正常工作了：
- en: '[PRE165]'
  id: totrans-627
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: Overall the change is directly towards Python’s “explicit is better than implicit”
    philosophy.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，这种变化直接符合Python的“显式优于隐式”的哲学。
- en: '[#4365](https://www.sqlalchemy.org/trac/ticket/4365)  ### FOR UPDATE clause
    is rendered within the joined eager load subquery as well as outside'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4365](https://www.sqlalchemy.org/trac/ticket/4365)  ### FOR UPDATE子句在联合贪婪加载子查询中以及外部呈现'
- en: This change applies specifically to the use of the [`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload") loading strategy in conjunction with a row limited
    query, e.g. using [`Query.first()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.first
    "sqlalchemy.orm.Query.first") or [`Query.limit()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.limit
    "sqlalchemy.orm.Query.limit"), as well as with use of the [`Query.with_for_update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.with_for_update
    "sqlalchemy.orm.Query.with_for_update") method.
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 此更改特别适用于使用[`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload")加载策略与行限制查询相结合，例如使用[`Query.first()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.first
    "sqlalchemy.orm.Query.first")或[`Query.limit()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.limit
    "sqlalchemy.orm.Query.limit")，以及使用[`Query.with_for_update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.with_for_update
    "sqlalchemy.orm.Query.with_for_update")方法。
- en: 'Given a query as:'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个查询：
- en: '[PRE166]'
  id: totrans-632
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: 'The [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    object renders a SELECT of the following form when joined eager loading is combined
    with LIMIT:'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 当联合贪婪加载与LIMIT结合时，[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")对象呈现如下形式的SELECT：
- en: '[PRE167]'
  id: totrans-634
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: 'This is so that the limit of rows takes place for the primary entity without
    affecting the joined eager load of related items. When the above query is combined
    with “SELECT..FOR UPDATE”, the behavior has been this:'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，对主要实体的行限制就会发生，而不会影响到关联项的贪婪加载。当上述查询与“SELECT..FOR UPDATE”结合时，行为是这样的：
- en: '[PRE168]'
  id: totrans-636
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: 'However, MySQL due to [https://bugs.mysql.com/bug.php?id=90693](https://bugs.mysql.com/bug.php?id=90693)
    does not lock the rows inside the subquery, unlike that of PostgreSQL and other
    databases. So the above query now renders as:'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于[https://bugs.mysql.com/bug.php?id=90693](https://bugs.mysql.com/bug.php?id=90693)，MySQL不会锁定子查询中的行，不像PostgreSQL和其他数据库。因此，上述查询现在呈现为：
- en: '[PRE169]'
  id: totrans-638
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: On the Oracle dialect, the inner “FOR UPDATE” is not rendered as Oracle does
    not support this syntax and the dialect skips any “FOR UPDATE” that is against
    a subquery; it isn’t necessary in any case since Oracle, like PostgreSQL, correctly
    locks all elements of the returned row.
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 在Oracle方言中，内部的“FOR UPDATE”不会呈现，因为Oracle不支持这种语法，方言会跳过针对子查询的任何“FOR UPDATE”；在任何情况下都不是必要的，因为Oracle像PostgreSQL一样正确锁定返回行的所有元素。
- en: 'When using the [`Query.with_for_update.of`](../orm/queryguide/query.html#sqlalchemy.orm.Query.with_for_update.params.of
    "sqlalchemy.orm.Query.with_for_update") modifier, typically on PostgreSQL, the
    outer “FOR UPDATE” is omitted, and the OF is now rendered on the inside; previously,
    the OF target would not be converted to accommodate for the subquery correctly.
    So given:'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 当在[`Query.with_for_update.of`](../orm/queryguide/query.html#sqlalchemy.orm.Query.with_for_update)修饰符上使用时，通常在PostgreSQL上，外部的“FOR
    UPDATE”被省略，OF现在在内部呈现；以前，OF目标不会被转换以正确适应子查询。因此，考虑到：
- en: '[PRE170]'
  id: totrans-641
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: 'The query would now render as:'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 现在查询将呈现为：
- en: '[PRE171]'
  id: totrans-643
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: The above form should be helpful on PostgreSQL additionally since PostgreSQL
    will not allow the FOR UPDATE clause to be rendered after the LEFT OUTER JOIN
    target.
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 上述形式应该对PostgreSQL有所帮助，因为PostgreSQL不允许在LEFT OUTER JOIN目标之后呈现FOR UPDATE子句。
- en: Overall, FOR UPDATE remains highly specific to the target database in use and
    can’t easily be generalized for more complex queries.
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，对于正在使用的目标数据库，FOR UPDATE仍然非常具体，不容易推广到更复杂的查询。
- en: '[#4246](https://www.sqlalchemy.org/trac/ticket/4246)  ### passive_deletes=’all’
    will leave FK unchanged for object removed from collection'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4246](https://www.sqlalchemy.org/trac/ticket/4246)  ### passive_deletes=’all’将使FK对于从集合中移除的对象保持不变'
- en: 'The [`relationship.passive_deletes`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.passive_deletes
    "sqlalchemy.orm.relationship") option accepts the value `"all"` to indicate that
    no foreign key attributes should be modified when the object is flushed, even
    if the relationship’s collection / reference has been removed. Previously, this
    did not take place for one-to-many, or one-to-one relationships, in the following
    situation:'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: '[`relationship.passive_deletes`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.passive_deletes
    "sqlalchemy.orm.relationship")选项接受值`"all"`，表示在刷新对象时不应修改任何外键属性，即使关系的集合/引用已被移除。以前，在以下情况下，这种情况并不适用于一对多或一对一关系：'
- en: '[PRE172]'
  id: totrans-648
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: The fix now includes that `address.user_id` is left unchanged as per `passive_deletes="all"`.
    This kind of thing is useful for building custom “version table” schemes and such
    where rows are archived instead of deleted.
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 修复现在包括`address.user_id`根据`passive_deletes="all"`保持不变。这种情况对于构建自定义“版本表”方案等非常有用，其中行被归档而不是被删除。
- en: '[#3844](https://www.sqlalchemy.org/trac/ticket/3844)  ### Query.join() handles
    ambiguity in deciding the “left” side more explicitly'
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3844](https://www.sqlalchemy.org/trac/ticket/3844)  ### Query.join()更明确地处理决定“左”侧的模棱两可性'
- en: 'Historically, given a query like the following:'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 历史上，给定如下查询：
- en: '[PRE173]'
  id: totrans-652
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: 'given the standard tutorial mappings, the query would produce a FROM clause
    as:'
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于标准教程映射，查询将生成一个FROM子句：
- en: '[PRE174]'
  id: totrans-654
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: 'That is, the JOIN would implicitly be against the first entity that matches.
    The new behavior is that an exception requests that this ambiguity be resolved:'
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着JOIN将隐式地针对第一个匹配的实体。新行为是，异常请求解决这种模棱两可的情况：
- en: '[PRE175]'
  id: totrans-656
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: 'The solution is to provide an ON clause, either as an expression:'
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是提供一个ON子句，可以是一个表达式：
- en: '[PRE176]'
  id: totrans-658
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: 'Or to use the relationship attribute, if available:'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 或者使用关系属性，如果可用的话：
- en: '[PRE177]'
  id: totrans-660
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: 'The change includes that a join can now correctly link to a FROM clause that
    is not the first element in the list if the join is otherwise non-ambiguous:'
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 更改包括现在JOIN可以正确地链接到不是列表中第一个元素的FROM子句，如果JOIN是非模棱两可的话：
- en: '[PRE178]'
  id: totrans-662
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: 'Prior to this enhancement, the above query would raise:'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 在此增强之前，上述查询将引发：
- en: '[PRE179]'
  id: totrans-664
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: 'Now the query works fine:'
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 现在查询正常工作：
- en: '[PRE180]'
  id: totrans-666
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: Overall the change is directly towards Python’s “explicit is better than implicit”
    philosophy.
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，这种变化直接符合Python的“显式优于隐式”的哲学。
- en: '[#4365](https://www.sqlalchemy.org/trac/ticket/4365)'
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4365](https://www.sqlalchemy.org/trac/ticket/4365)'
- en: '### FOR UPDATE clause is rendered within the joined eager load subquery as
    well as outside'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: '### FOR UPDATE子句在连接贪婪加载子查询内部以及外部都被渲染'
- en: This change applies specifically to the use of the [`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload") loading strategy in conjunction with a row limited
    query, e.g. using [`Query.first()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.first
    "sqlalchemy.orm.Query.first") or [`Query.limit()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.limit
    "sqlalchemy.orm.Query.limit"), as well as with use of the [`Query.with_for_update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.with_for_update
    "sqlalchemy.orm.Query.with_for_update") method.
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 此更改特别适用于使用[`joinedload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload
    "sqlalchemy.orm.joinedload")加载策略与行限制查询结合使用时，例如使用[`Query.first()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.first
    "sqlalchemy.orm.Query.first")或[`Query.limit()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.limit
    "sqlalchemy.orm.Query.limit")，以及使用[`Query.with_for_update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.with_for_update
    "sqlalchemy.orm.Query.with_for_update")方法。
- en: 'Given a query as:'
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个查询如下：
- en: '[PRE181]'
  id: totrans-672
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: 'The [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    object renders a SELECT of the following form when joined eager loading is combined
    with LIMIT:'
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: 当连接贪婪加载与LIMIT结合时，[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")对象会渲染以下形式的SELECT：
- en: '[PRE182]'
  id: totrans-674
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: 'This is so that the limit of rows takes place for the primary entity without
    affecting the joined eager load of related items. When the above query is combined
    with “SELECT..FOR UPDATE”, the behavior has been this:'
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做是为了使主实体的行限制生效，而不影响相关项目的连接贪婪加载。当上述查询与“SELECT..FOR UPDATE”结合时，行为如下：
- en: '[PRE183]'
  id: totrans-676
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: 'However, MySQL due to [https://bugs.mysql.com/bug.php?id=90693](https://bugs.mysql.com/bug.php?id=90693)
    does not lock the rows inside the subquery, unlike that of PostgreSQL and other
    databases. So the above query now renders as:'
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于[https://bugs.mysql.com/bug.php?id=90693](https://bugs.mysql.com/bug.php?id=90693)，MySQL不会锁定子查询内的行，不像PostgreSQL和其他数据库。因此，上述查询现在会渲染为：
- en: '[PRE184]'
  id: totrans-678
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: On the Oracle dialect, the inner “FOR UPDATE” is not rendered as Oracle does
    not support this syntax and the dialect skips any “FOR UPDATE” that is against
    a subquery; it isn’t necessary in any case since Oracle, like PostgreSQL, correctly
    locks all elements of the returned row.
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 在Oracle方言中，内部的“FOR UPDATE”不会被渲染，因为Oracle不支持这种语法，方言会跳过任何针对子查询的“FOR UPDATE”；在任何情况下都不是必要的，因为Oracle像PostgreSQL一样正确地锁定了返回行的所有元素。
- en: 'When using the [`Query.with_for_update.of`](../orm/queryguide/query.html#sqlalchemy.orm.Query.with_for_update.params.of
    "sqlalchemy.orm.Query.with_for_update") modifier, typically on PostgreSQL, the
    outer “FOR UPDATE” is omitted, and the OF is now rendered on the inside; previously,
    the OF target would not be converted to accommodate for the subquery correctly.
    So given:'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 当在[`Query.with_for_update.of`](../orm/queryguide/query.html#sqlalchemy.orm.Query.with_for_update
    "sqlalchemy.orm.Query.with_for_update")修饰符上使用时，通常在PostgreSQL上，外部的“FOR UPDATE”会被省略，OF现在会在内部被渲染；以前，OF目标不会被转换以适应子查询。所以给定：
- en: '[PRE185]'
  id: totrans-681
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: 'The query would now render as:'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 查询现在会渲染为：
- en: '[PRE186]'
  id: totrans-683
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: The above form should be helpful on PostgreSQL additionally since PostgreSQL
    will not allow the FOR UPDATE clause to be rendered after the LEFT OUTER JOIN
    target.
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 以上形式在PostgreSQL上也应该有所帮助，因为PostgreSQL不允许在LEFT OUTER JOIN目标之后渲染FOR UPDATE子句。
- en: Overall, FOR UPDATE remains highly specific to the target database in use and
    can’t easily be generalized for more complex queries.
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，FOR UPDATE对于正在使用的目标数据库非常具体，不能轻易地推广到更复杂的查询。
- en: '[#4246](https://www.sqlalchemy.org/trac/ticket/4246)'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4246](https://www.sqlalchemy.org/trac/ticket/4246)'
- en: '### passive_deletes=’all’ will leave FK unchanged for object removed from collection'
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: '### passive_deletes=''all''将使从集合中移除的对象的FK保持不变'
- en: 'The [`relationship.passive_deletes`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.passive_deletes
    "sqlalchemy.orm.relationship") option accepts the value `"all"` to indicate that
    no foreign key attributes should be modified when the object is flushed, even
    if the relationship’s collection / reference has been removed. Previously, this
    did not take place for one-to-many, or one-to-one relationships, in the following
    situation:'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: '[`relationship.passive_deletes`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.passive_deletes
    "sqlalchemy.orm.relationship")选项接受值`"all"`，表示在刷新对象时不应修改任何外键属性，即使关系的集合/引用已被移除。以前，在以下情况下，这不会发生在一对多或一对一关系中：'
- en: '[PRE187]'
  id: totrans-689
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: The fix now includes that `address.user_id` is left unchanged as per `passive_deletes="all"`.
    This kind of thing is useful for building custom “version table” schemes and such
    where rows are archived instead of deleted.
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: 修复现在包括`address.user_id`按照`passive_deletes="all"`不变。这种情况对于构建自定义“版本表”方案等非常有用，其中行被归档而不是删除。
- en: '[#3844](https://www.sqlalchemy.org/trac/ticket/3844)'
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3844](https://www.sqlalchemy.org/trac/ticket/3844)'
- en: '## New Features and Improvements - Core'
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: '## 新功能和改进 - 核心'
- en: '### New multi-column naming convention tokens, long name truncation'
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: '### 新的多列命名约定标记，长名称截断'
- en: 'To suit the case where a [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") naming convention needs to disambiguate between
    multiple-column constraints and wishes to use all the columns within the generated
    constraint name, a new series of naming convention tokens are added, including
    `column_0N_name`, `column_0_N_name`, `column_0N_key`, `column_0_N_key`, `referred_column_0N_name`,
    `referred_column_0_N_name`, etc., which render the column name (or key or label)
    for all columns in the constraint, joined together either with no separator or
    with an underscore separator. Below we define a convention that will name [`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint") constraints with a name that joins together
    the names of all columns:'
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 为了适应[`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData "sqlalchemy.schema.MetaData")命名约定需要区分多列约束并希望在生成的约束名称中使用所有列的情况，添加了一系列新的命名约定标记，包括`column_0N_name`、`column_0_N_name`、`column_0N_key`、`column_0_N_key`、`referred_column_0N_name`、`referred_column_0_N_name`等，它们将所有列的列名（或键或标签）连接在一起，没有分隔符或使用下划线分隔符。下面我们定义一个约定，将[`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint")约束命名为连接所有列名称的名称：
- en: '[PRE188]'
  id: totrans-695
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: 'The CREATE TABLE for the above table will render as:'
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 上述表的CREATE TABLE将呈现为：
- en: '[PRE189]'
  id: totrans-697
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: 'In addition, long-name truncation logic is now applied to the names generated
    by naming conventions, in particular to accommodate for multi-column labels that
    can produce very long names. This logic, which is the same as that used for truncating
    long label names in a SELECT statement, replaces excess characters that go over
    the identifier-length limit for the target database with a deterministically generated
    4-character hash. For example, on PostgreSQL where identifiers cannot be longer
    than 63 characters, a long constraint name would normally be generated from the
    table definition below:'
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，现在将长名称截断逻辑应用于命名约定生成的名称，特别是为了适应可能产生非常长名称的多列标签。这种逻辑与用于截断SELECT语句中的长标签名称的逻辑相同，用一个确定性生成的4字符哈希替换超过目标数据库标识符长度限制的多余字符。例如，在PostgreSQL上，标识符不能超过63个字符，长约束名称通常从下面的表定义中生成：
- en: '[PRE190]'
  id: totrans-699
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: 'The truncation logic will ensure a too-long name isn’t generated for the UNIQUE
    constraint:'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 截断逻辑将确保不会为UNIQUE约束生成过长的名称：
- en: '[PRE191]'
  id: totrans-701
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: The above suffix `a79e` is based on the md5 hash of the long name and will generate
    the same value every time to produce consistent names for a given schema.
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 上述后缀`a79e`基于长名称的md5哈希，并且每次生成相同的值，以产生给定模式的一致名称。
- en: 'Note that the truncation logic also raises [`IdentifierError`](../core/exceptions.html#sqlalchemy.exc.IdentifierError
    "sqlalchemy.exc.IdentifierError") when a constraint name is explicitly too large
    for a given dialect. This has been the behavior for an [`Index`](../core/constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index") object for a long time, but is now applied to other
    kinds of constraints as well:'
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当约束名在给定方言中显式过大时，截断逻辑也会引发[`IdentifierError`](../core/exceptions.html#sqlalchemy.exc.IdentifierError
    "sqlalchemy.exc.IdentifierError")。这已经是[`Index`](../core/constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index")对象的行为很长时间了，但现在也适用于其他类型的约束：
- en: '[PRE192]'
  id: totrans-704
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: 'will output:'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 将输出：
- en: '[PRE193]'
  id: totrans-706
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: The exception raise prevents the production of non-deterministic constraint
    names truncated by the database backend which are then not compatible with database
    migrations later on.
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 异常引发阻止了由数据库后端截断的非确定性约束名称的生成，这些名称后来与数据库迁移不兼容。
- en: 'To apply SQLAlchemy-side truncation rules to the above identifier, use the
    [`conv()`](../core/constraints.html#sqlalchemy.schema.conv "sqlalchemy.schema.conv")
    construct:'
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 要将SQLAlchemy端的截断规则应用于上述标识符，请使用[`conv()`](../core/constraints.html#sqlalchemy.schema.conv
    "sqlalchemy.schema.conv")构造：
- en: '[PRE194]'
  id: totrans-709
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: 'This will again output deterministically truncated SQL as in:'
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 这将再次输出确定性截断的SQL，如下所示：
- en: '[PRE195]'
  id: totrans-711
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: There is not at the moment an option to have the names pass through to allow
    database-side truncation. This has already been the case for [`Index`](../core/constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index") names for some time and issues have not been raised.
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 目前还没有选项可以使名称传递以允许数据库端截断。这对于[`Index`](../core/constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index")名称已经有一段时间了，而且并没有提出问题。
- en: The change also repairs two other issues. One is that the `column_0_key` token
    wasn’t available even though this token was documented, the other was that the
    `referred_column_0_name` token would inadvertently render the `.key` and not the
    `.name` of the column if these two values were different.
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 此更改还修复了另外两个问题。一个是`column_0_key`标记虽然被记录，但却无法使用，另一个是如果这两个值不同，`referred_column_0_name`标记会错误地呈现`.key`而不是`.name`列。
- en: See also
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Configuring Constraint Naming Conventions](../core/constraints.html#constraint-naming-conventions)'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: '[配置约束命名约定](../core/constraints.html#constraint-naming-conventions)'
- en: '[`MetaData.naming_convention`](../core/metadata.html#sqlalchemy.schema.MetaData.params.naming_convention
    "sqlalchemy.schema.MetaData")'
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: '[`MetaData.naming_convention`](../core/metadata.html#sqlalchemy.schema.MetaData.params.naming_convention
    "sqlalchemy.schema.MetaData")'
- en: '[#3989](https://www.sqlalchemy.org/trac/ticket/3989)  ### Binary comparison
    interpretation for SQL functions'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3989](https://www.sqlalchemy.org/trac/ticket/3989)  ### 用于SQL函数的二进制比较解释'
- en: This enhancement is implemented at the Core level, however is applicable primarily
    to the ORM.
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 这个增强功能是在核心层实现的，但主要适用于ORM。
- en: 'A SQL function that compares two elements can now be used as a “comparison”
    object, suitable for usage in an ORM [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship"), by first creating the function as usual using
    the [`func`](../core/sqlelement.html#sqlalchemy.sql.expression.func "sqlalchemy.sql.expression.func")
    factory, then when the function is complete calling upon the [`FunctionElement.as_comparison()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.as_comparison
    "sqlalchemy.sql.functions.FunctionElement.as_comparison") modifier to produce
    a [`BinaryExpression`](../core/sqlelement.html#sqlalchemy.sql.expression.BinaryExpression
    "sqlalchemy.sql.expression.BinaryExpression") that has a “left” and a “right”
    side:'
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以将比较两个元素的SQL函数用作“比较”对象，适用于ORM [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")的用法，首先像往常一样使用[`func`](../core/sqlelement.html#sqlalchemy.sql.expression.func
    "sqlalchemy.sql.expression.func")工厂创建函数，然后在函数完成时调用[`FunctionElement.as_comparison()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.as_comparison
    "sqlalchemy.sql.functions.FunctionElement.as_comparison")修饰符来生成一个具有“左”和“右”两侧的[`BinaryExpression`](../core/sqlelement.html#sqlalchemy.sql.expression.BinaryExpression
    "sqlalchemy.sql.expression.BinaryExpression")：
- en: '[PRE196]'
  id: totrans-720
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: 'Above, the [`relationship.primaryjoin`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.primaryjoin
    "sqlalchemy.orm.relationship") of the “descendants” relationship will produce
    a “left” and a “right” expression based on the first and second arguments passed
    to `instr()`. This allows features like the ORM lazyload to produce SQL like:'
  id: totrans-721
  prefs: []
  type: TYPE_NORMAL
  zh: 上面，“后代”关系的[`relationship.primaryjoin`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.primaryjoin
    "sqlalchemy.orm.relationship")将基于传递给`instr()`的第一个和第二个参数产生一个“左”和一个“右”表达式。这使得ORM懒加载等功能能够产生SQL，例如：
- en: '[PRE197]'
  id: totrans-722
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: 'and a joinedload, such as:'
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 以及一个joinedload，例如：
- en: '[PRE198]'
  id: totrans-724
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: 'to work as:'
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: 工作原理如下：
- en: '[PRE199]'
  id: totrans-726
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: This feature is expected to help with situations such as making use of geometric
    functions in relationship join conditions, or any case where the ON clause of
    the SQL join is expressed in terms of a SQL function.
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 该功能预期将有助于处理诸如在关系连接条件中使用几何函数或任何通过SQL函数来表达SQL连接的ON子句等情况。
- en: '[#3831](https://www.sqlalchemy.org/trac/ticket/3831)  ### Expanding IN feature
    now supports empty lists'
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3831](https://www.sqlalchemy.org/trac/ticket/3831)  ### 扩展IN特性现在支持空列表'
- en: 'The “expanding IN” feature introduced in version 1.2 at [Late-expanded IN parameter
    sets allow IN expressions with cached statements](migration_12.html#change-3953)
    now supports empty lists passed to the [`ColumnOperators.in_()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.in_
    "sqlalchemy.sql.expression.ColumnOperators.in_") operator. The implementation
    for an empty list will produce an “empty set” expression that is specific to a
    target backend, such as “SELECT CAST(NULL AS INTEGER) WHERE 1!=1” for PostgreSQL,
    “SELECT 1 FROM (SELECT 1) as _empty_set WHERE 1!=1” for MySQL:'
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 版本1.2中引入的“扩展IN”功能现在支持传递给[`ColumnOperators.in_()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.in_
    "sqlalchemy.sql.expression.ColumnOperators.in_")运算符的空列表。对于空列表的实现将产生一个特定于目标后端的“空集”表达式，例如对于PostgreSQL，“SELECT
    CAST(NULL AS INTEGER) WHERE 1!=1”，对于MySQL，“SELECT 1 FROM (SELECT 1) as _empty_set
    WHERE 1!=1”：
- en: '[PRE200]'
  id: totrans-730
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: 'The feature also works for tuple-oriented IN statements, where the “empty IN”
    expression will be expanded to support the elements given inside the tuple, such
    as on PostgreSQL:'
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: 该功能还适用于基于元组的IN语句，其中“空IN”表达式将被扩展以支持元组中给定的元素，例如在PostgreSQL上：
- en: '[PRE201]'
  id: totrans-732
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: '[#4271](https://www.sqlalchemy.org/trac/ticket/4271)  ### TypeEngine methods
    bind_expression, column_expression work with Variant, type-specific types'
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4271](https://www.sqlalchemy.org/trac/ticket/4271)  ### TypeEngine方法bind_expression、column_expression与Variant、特定类型一起工作'
- en: The [`TypeEngine.bind_expression()`](../core/type_api.html#sqlalchemy.types.TypeEngine.bind_expression
    "sqlalchemy.types.TypeEngine.bind_expression") and [`TypeEngine.column_expression()`](../core/type_api.html#sqlalchemy.types.TypeEngine.column_expression
    "sqlalchemy.types.TypeEngine.column_expression") methods now work when they are
    present on the “impl” of a particular datatype, allowing these methods to be used
    by dialects as well as for [`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") and [`Variant`](../core/type_api.html#sqlalchemy.types.Variant
    "sqlalchemy.types.Variant") use cases.
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: 当[`TypeEngine.bind_expression()`](../core/type_api.html#sqlalchemy.types.TypeEngine.bind_expression
    "sqlalchemy.types.TypeEngine.bind_expression")和[`TypeEngine.column_expression()`](../core/type_api.html#sqlalchemy.types.TypeEngine.column_expression
    "sqlalchemy.types.TypeEngine.column_expression")方法存在于特定数据类型的“impl”上时，这些方法现在可以被方言使用，也可以用于[`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator")和[`Variant`](../core/type_api.html#sqlalchemy.types.Variant
    "sqlalchemy.types.Variant")的用例。
- en: 'The following example illustrates a [`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") that applies SQL-time conversion functions to
    a [`LargeBinary`](../core/type_basics.html#sqlalchemy.types.LargeBinary "sqlalchemy.types.LargeBinary").
    In order for this type to work in the context of a [`Variant`](../core/type_api.html#sqlalchemy.types.Variant
    "sqlalchemy.types.Variant"), the compiler needs to drill into the “impl” of the
    variant expression in order to locate these methods:'
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例说明了一个[`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator")，它将SQL时间转换函数应用于[`LargeBinary`](../core/type_basics.html#sqlalchemy.types.LargeBinary
    "sqlalchemy.types.LargeBinary")。为了使此类型在[`Variant`](../core/type_api.html#sqlalchemy.types.Variant
    "sqlalchemy.types.Variant")的上下文中工作，编译器需要深入“impl”变体表达式以定位这些方法：
- en: '[PRE202]'
  id: totrans-736
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: 'The above expression will render a function within SQL when used on SQLite
    only:'
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 上述表达式仅在SQLite上使用时会呈现为SQL中的函数：
- en: '[PRE203]'
  id: totrans-738
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: 'will render:'
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 将呈现：
- en: '[PRE204]'
  id: totrans-740
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: The change also includes that dialects can implement [`TypeEngine.bind_expression()`](../core/type_api.html#sqlalchemy.types.TypeEngine.bind_expression
    "sqlalchemy.types.TypeEngine.bind_expression") and [`TypeEngine.column_expression()`](../core/type_api.html#sqlalchemy.types.TypeEngine.column_expression
    "sqlalchemy.types.TypeEngine.column_expression") on dialect-level implementation
    types where they will now be used; in particular this will be used for MySQL’s
    new “binary prefix” requirement as well as for casting decimal bind values for
    MySQL.
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: 此更改还包括方言可以在方言级别的实现类型上实现[`TypeEngine.bind_expression()`](../core/type_api.html#sqlalchemy.types.TypeEngine.bind_expression
    "sqlalchemy.types.TypeEngine.bind_expression")和[`TypeEngine.column_expression()`](../core/type_api.html#sqlalchemy.types.TypeEngine.column_expression
    "sqlalchemy.types.TypeEngine.column_expression")，它们现在将被使用；特别是这将用于MySQL的新“二进制前缀”要求以及用于将MySQL的十进制绑定值转换为浮点数。
- en: '[#3981](https://www.sqlalchemy.org/trac/ticket/3981)  ### New last-in-first-out
    strategy for QueuePool'
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3981](https://www.sqlalchemy.org/trac/ticket/3981)  ### QueuePool的新后进先出策略'
- en: The connection pool usually used by [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") is known as [`QueuePool`](../core/pooling.html#sqlalchemy.pool.QueuePool
    "sqlalchemy.pool.QueuePool"). This pool uses an object equivalent to Python’s
    built-in `Queue` class in order to store database connections waiting to be used.
    The `Queue` features first-in-first-out behavior, which is intended to provide
    a round-robin use of the database connections that are persistently in the pool.
    However, a potential downside of this is that when the utilization of the pool
    is low, the re-use of each connection in series means that a server-side timeout
    strategy that attempts to reduce unused connections is prevented from shutting
    down these connections. To suit this use case, a new flag [`create_engine.pool_use_lifo`](../core/engines.html#sqlalchemy.create_engine.params.pool_use_lifo
    "sqlalchemy.create_engine") is added which reverses the `.get()` method of the
    `Queue` to pull the connection from the beginning of the queue instead of the
    end, essentially turning the “queue” into a “stack” (adding a whole new pool called
    `StackPool` was considered, however this was too much verbosity).
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 通常由 [`create_engine()`](../core/engines.html#sqlalchemy.create_engine "sqlalchemy.create_engine")
    使用的连接池称为 [`QueuePool`](../core/pooling.html#sqlalchemy.pool.QueuePool "sqlalchemy.pool.QueuePool")。此连接池使用类似于
    Python 内置的 `Queue` 类的对象来存储等待使用的数据库连接。`Queue` 具有先进先出的行为，旨在提供对持续在池中的数据库连接的循环使用。然而，这样做的一个潜在缺点是，当池的利用率低时，池中的每个连接的串行重复使用意味着试图减少未使用连接的服务器端超时策略被阻止关闭这些连接。为了适应这种情况，添加了一个新的标志
    [`create_engine.pool_use_lifo`](../core/engines.html#sqlalchemy.create_engine.params.pool_use_lifo
    "sqlalchemy.create_engine") ，它将 `Queue` 的 `.get()` 方法反转，以从队列的开头而不是末尾获取连接，从而实质上将“队列”变为“栈”（考虑到这样做会增加一个称为
    `StackPool` 的全新连接池，但这太啰嗦了）。
- en: See also
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 另见
- en: '[Using FIFO vs. LIFO](../core/pooling.html#pool-use-lifo)  ### New multi-column
    naming convention tokens, long name truncation'
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用 FIFO vs. LIFO](../core/pooling.html#pool-use-lifo)  ### 新的多列命名约定标记，长名称截断'
- en: 'To suit the case where a [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") naming convention needs to disambiguate between
    multiple-column constraints and wishes to use all the columns within the generated
    constraint name, a new series of naming convention tokens are added, including
    `column_0N_name`, `column_0_N_name`, `column_0N_key`, `column_0_N_key`, `referred_column_0N_name`,
    `referred_column_0_N_name`, etc., which render the column name (or key or label)
    for all columns in the constraint, joined together either with no separator or
    with an underscore separator. Below we define a convention that will name [`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint") constraints with a name that joins together
    the names of all columns:'
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 为了适应需要通过 [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData "sqlalchemy.schema.MetaData")
    命名约定消除多列约束的歧义，并希望在生成的约束名称中使用所有列的情况，添加了一系列新的命名约定标记，包括 `column_0N_name`、`column_0_N_name`、`column_0N_key`、`column_0_N_key`、`referred_column_0N_name`、`referred_column_0_N_name`
    等，这些标记将约束中的所有列的列名（或键或标签）连接在一起，可以是没有分隔符或带有下划线分隔符。下面我们定义一个约定，将会以将所有列的名称连接在一起的方式命名
    [`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint") 约束：
- en: '[PRE205]'
  id: totrans-747
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: 'The CREATE TABLE for the above table will render as:'
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 上述表的 CREATE TABLE 将呈现为：
- en: '[PRE206]'
  id: totrans-749
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: 'In addition, long-name truncation logic is now applied to the names generated
    by naming conventions, in particular to accommodate for multi-column labels that
    can produce very long names. This logic, which is the same as that used for truncating
    long label names in a SELECT statement, replaces excess characters that go over
    the identifier-length limit for the target database with a deterministically generated
    4-character hash. For example, on PostgreSQL where identifiers cannot be longer
    than 63 characters, a long constraint name would normally be generated from the
    table definition below:'
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，现在对通过命名约定生成的名称应用长名称截断逻辑，特别是为了适应可能产生非常长名称的多列标签。这个逻辑与在 SELECT 语句中截断长标签名称所使用的逻辑相同，它用一个确定性生成的
    4 字符哈希替换了超过目标数据库标识符长度限制的多余字符。例如，在 PostgreSQL 中，标识符不能超过 63 个字符，长约束名通常是从下面的表定义生成的：
- en: '[PRE207]'
  id: totrans-751
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: 'The truncation logic will ensure a too-long name isn’t generated for the UNIQUE
    constraint:'
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 截断逻辑将确保不会为 UNIQUE 约束生成过长的名称：
- en: '[PRE208]'
  id: totrans-753
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: The above suffix `a79e` is based on the md5 hash of the long name and will generate
    the same value every time to produce consistent names for a given schema.
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: 上述后缀`a79e`基于长名称的md5哈希，并且每次生成相同的值，以为给定的模式生成一致的名称。
- en: 'Note that the truncation logic also raises [`IdentifierError`](../core/exceptions.html#sqlalchemy.exc.IdentifierError
    "sqlalchemy.exc.IdentifierError") when a constraint name is explicitly too large
    for a given dialect. This has been the behavior for an [`Index`](../core/constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index") object for a long time, but is now applied to other
    kinds of constraints as well:'
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，当约束名称显式过大时，截断逻辑还会引发[`IdentifierError`](../core/exceptions.html#sqlalchemy.exc.IdentifierError
    "sqlalchemy.exc.IdentifierError")。这已经是[`Index`](../core/constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index")对象的行为很长时间了，但现在也适用于其他类型的约束：
- en: '[PRE209]'
  id: totrans-756
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: 'will output:'
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将是：
- en: '[PRE210]'
  id: totrans-758
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: The exception raise prevents the production of non-deterministic constraint
    names truncated by the database backend which are then not compatible with database
    migrations later on.
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: 异常抛出可防止由数据库后端截断的不确定性约束名称的生成，这些名称随后与数据库迁移不兼容。
- en: 'To apply SQLAlchemy-side truncation rules to the above identifier, use the
    [`conv()`](../core/constraints.html#sqlalchemy.schema.conv "sqlalchemy.schema.conv")
    construct:'
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: 要将SQLAlchemy端的截断规则应用于上述标识符，请使用[`conv()`](../core/constraints.html#sqlalchemy.schema.conv
    "sqlalchemy.schema.conv")构造：
- en: '[PRE211]'
  id: totrans-761
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: 'This will again output deterministically truncated SQL as in:'
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 这将再次输出确定性截断的SQL，如下所示：
- en: '[PRE212]'
  id: totrans-763
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: There is not at the moment an option to have the names pass through to allow
    database-side truncation. This has already been the case for [`Index`](../core/constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index") names for some time and issues have not been raised.
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: 目前尚无选项可使名称通过以允许数据库端截断。这在一段时间内已经适用于[`Index`](../core/constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index")名称，并且并未引起问题。
- en: The change also repairs two other issues. One is that the `column_0_key` token
    wasn’t available even though this token was documented, the other was that the
    `referred_column_0_name` token would inadvertently render the `.key` and not the
    `.name` of the column if these two values were different.
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: 这一变更还修复了其他两个问题。其中一个是`column_0_key`令牌虽然已记录，但却不可用，另一个是如果这两个值不同，`referred_column_0_name`令牌会意外地呈现`.key`而不是`.name`。
- en: See also
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Configuring Constraint Naming Conventions](../core/constraints.html#constraint-naming-conventions)'
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: '[配置约束命名约定](../core/constraints.html#constraint-naming-conventions)'
- en: '[`MetaData.naming_convention`](../core/metadata.html#sqlalchemy.schema.MetaData.params.naming_convention
    "sqlalchemy.schema.MetaData")'
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: '[`MetaData.naming_convention`](../core/metadata.html#sqlalchemy.schema.MetaData.params.naming_convention
    "sqlalchemy.schema.MetaData")'
- en: '[#3989](https://www.sqlalchemy.org/trac/ticket/3989)'
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3989](https://www.sqlalchemy.org/trac/ticket/3989)'
- en: '### Binary comparison interpretation for SQL functions'
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: '### SQL函数的二进制比较解释'
- en: This enhancement is implemented at the Core level, however is applicable primarily
    to the ORM.
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: 此增强功能是在核心级别实现的，但主要适用于ORM。
- en: 'A SQL function that compares two elements can now be used as a “comparison”
    object, suitable for usage in an ORM [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship"), by first creating the function as usual using
    the [`func`](../core/sqlelement.html#sqlalchemy.sql.expression.func "sqlalchemy.sql.expression.func")
    factory, then when the function is complete calling upon the [`FunctionElement.as_comparison()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.as_comparison
    "sqlalchemy.sql.functions.FunctionElement.as_comparison") modifier to produce
    a [`BinaryExpression`](../core/sqlelement.html#sqlalchemy.sql.expression.BinaryExpression
    "sqlalchemy.sql.expression.BinaryExpression") that has a “left” and a “right”
    side:'
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以将比较两个元素的SQL函数用作适用于ORM [`relationship()`](../orm/relationship_api.html#sqlalchemy.orm.relationship
    "sqlalchemy.orm.relationship")中的“比较”对象，首先使用[`func`](../core/sqlelement.html#sqlalchemy.sql.expression.func
    "sqlalchemy.sql.expression.func")工厂通常创建该函数，然后当函数完成时调用[`FunctionElement.as_comparison()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.as_comparison
    "sqlalchemy.sql.functions.FunctionElement.as_comparison")修饰符，以生成具有“左”和“右”两侧的[`BinaryExpression`](../core/sqlelement.html#sqlalchemy.sql.expression.BinaryExpression
    "sqlalchemy.sql.expression.BinaryExpression")：
- en: '[PRE213]'
  id: totrans-773
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: 'Above, the [`relationship.primaryjoin`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.primaryjoin
    "sqlalchemy.orm.relationship") of the “descendants” relationship will produce
    a “left” and a “right” expression based on the first and second arguments passed
    to `instr()`. This allows features like the ORM lazyload to produce SQL like:'
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: 上面，“descendants”关系的[`relationship.primaryjoin`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.primaryjoin
    "sqlalchemy.orm.relationship")将基于传递给`instr()`的第一个和第二个参数产生一个“left”和一个“right”表达式。这允许ORM
    lazyload等功能生成类似以下的SQL：
- en: '[PRE214]'
  id: totrans-775
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: 'and a joinedload, such as:'
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: 以及一个joinedload，例如：
- en: '[PRE215]'
  id: totrans-777
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: 'to work as:'
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: 作为：
- en: '[PRE216]'
  id: totrans-779
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: This feature is expected to help with situations such as making use of geometric
    functions in relationship join conditions, or any case where the ON clause of
    the SQL join is expressed in terms of a SQL function.
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: 这个功能预计将有助于处理诸如在关系连接条件中使用几何函数或任何ON子句以SQL函数形式表达的情况。
- en: '[#3831](https://www.sqlalchemy.org/trac/ticket/3831)'
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3831](https://www.sqlalchemy.org/trac/ticket/3831)'
- en: '### Expanding IN feature now supports empty lists'
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: '### 扩展IN功能现在支持空列表'
- en: 'The “expanding IN” feature introduced in version 1.2 at [Late-expanded IN parameter
    sets allow IN expressions with cached statements](migration_12.html#change-3953)
    now supports empty lists passed to the [`ColumnOperators.in_()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.in_
    "sqlalchemy.sql.expression.ColumnOperators.in_") operator. The implementation
    for an empty list will produce an “empty set” expression that is specific to a
    target backend, such as “SELECT CAST(NULL AS INTEGER) WHERE 1!=1” for PostgreSQL,
    “SELECT 1 FROM (SELECT 1) as _empty_set WHERE 1!=1” for MySQL:'
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: 在版本1.2中引入的“扩展IN”功能现在支持传递给[`ColumnOperators.in_()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.in_
    "sqlalchemy.sql.expression.ColumnOperators.in_")运算符的空列表。对于空列表的实现将产生一个特定于目标后端的“空集合”表达式，例如对于PostgreSQL，“SELECT
    CAST(NULL AS INTEGER) WHERE 1!=1”，对于MySQL，“SELECT 1 FROM (SELECT 1) as _empty_set
    WHERE 1!=1”：
- en: '[PRE217]'
  id: totrans-784
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: 'The feature also works for tuple-oriented IN statements, where the “empty IN”
    expression will be expanded to support the elements given inside the tuple, such
    as on PostgreSQL:'
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 该功能还适用于基于元组的IN语句，其中“空IN”表达式将被扩展以支持元组中给定的元素，例如在PostgreSQL上：
- en: '[PRE218]'
  id: totrans-786
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: '[#4271](https://www.sqlalchemy.org/trac/ticket/4271)'
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4271](https://www.sqlalchemy.org/trac/ticket/4271)'
- en: '### TypeEngine methods bind_expression, column_expression work with Variant,
    type-specific types'
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: '### TypeEngine方法bind_expression、column_expression与Variant、特定类型一起工作'
- en: The [`TypeEngine.bind_expression()`](../core/type_api.html#sqlalchemy.types.TypeEngine.bind_expression
    "sqlalchemy.types.TypeEngine.bind_expression") and [`TypeEngine.column_expression()`](../core/type_api.html#sqlalchemy.types.TypeEngine.column_expression
    "sqlalchemy.types.TypeEngine.column_expression") methods now work when they are
    present on the “impl” of a particular datatype, allowing these methods to be used
    by dialects as well as for [`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") and [`Variant`](../core/type_api.html#sqlalchemy.types.Variant
    "sqlalchemy.types.Variant") use cases.
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: '[`TypeEngine.bind_expression()`](../core/type_api.html#sqlalchemy.types.TypeEngine.bind_expression
    "sqlalchemy.types.TypeEngine.bind_expression")和[`TypeEngine.column_expression()`](../core/type_api.html#sqlalchemy.types.TypeEngine.column_expression
    "sqlalchemy.types.TypeEngine.column_expression")方法现在在特定数据类型的“impl”上存在时也能工作，允许这些方法被方言以及[`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator")和[`Variant`](../core/type_api.html#sqlalchemy.types.Variant
    "sqlalchemy.types.Variant")用例使用。'
- en: 'The following example illustrates a [`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator") that applies SQL-time conversion functions to
    a [`LargeBinary`](../core/type_basics.html#sqlalchemy.types.LargeBinary "sqlalchemy.types.LargeBinary").
    In order for this type to work in the context of a [`Variant`](../core/type_api.html#sqlalchemy.types.Variant
    "sqlalchemy.types.Variant"), the compiler needs to drill into the “impl” of the
    variant expression in order to locate these methods:'
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例说明了一个[`TypeDecorator`](../core/custom_types.html#sqlalchemy.types.TypeDecorator
    "sqlalchemy.types.TypeDecorator")，它将SQL时间转换函数应用于[`LargeBinary`](../core/type_basics.html#sqlalchemy.types.LargeBinary
    "sqlalchemy.types.LargeBinary")。为了使这种类型在[`Variant`](../core/type_api.html#sqlalchemy.types.Variant
    "sqlalchemy.types.Variant")的上下文中工作，编译器需要深入“impl”变体表达式以定位这些方法：
- en: '[PRE219]'
  id: totrans-791
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: 'The above expression will render a function within SQL when used on SQLite
    only:'
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: 上述表达式仅在SQLite上使用时会在SQL中呈现一个函数：
- en: '[PRE220]'
  id: totrans-793
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: 'will render:'
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: 将呈现：
- en: '[PRE221]'
  id: totrans-795
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: The change also includes that dialects can implement [`TypeEngine.bind_expression()`](../core/type_api.html#sqlalchemy.types.TypeEngine.bind_expression
    "sqlalchemy.types.TypeEngine.bind_expression") and [`TypeEngine.column_expression()`](../core/type_api.html#sqlalchemy.types.TypeEngine.column_expression
    "sqlalchemy.types.TypeEngine.column_expression") on dialect-level implementation
    types where they will now be used; in particular this will be used for MySQL’s
    new “binary prefix” requirement as well as for casting decimal bind values for
    MySQL.
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: 此更改还包括方言可以在方言级别的实现类型上实现[`TypeEngine.bind_expression()`](../core/type_api.html#sqlalchemy.types.TypeEngine.bind_expression
    "sqlalchemy.types.TypeEngine.bind_expression")和[`TypeEngine.column_expression()`](../core/type_api.html#sqlalchemy.types.TypeEngine.column_expression
    "sqlalchemy.types.TypeEngine.column_expression")，在那里它们现在将被使用；特别是这将用于MySQL的新“二进制前缀”要求以及用于将MySQL的十进制绑定值转换的情况。
- en: '[#3981](https://www.sqlalchemy.org/trac/ticket/3981)'
  id: totrans-797
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3981](https://www.sqlalchemy.org/trac/ticket/3981)'
- en: '### New last-in-first-out strategy for QueuePool'
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: '### QueuePool 的新后进先出策略'
- en: The connection pool usually used by [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") is known as [`QueuePool`](../core/pooling.html#sqlalchemy.pool.QueuePool
    "sqlalchemy.pool.QueuePool"). This pool uses an object equivalent to Python’s
    built-in `Queue` class in order to store database connections waiting to be used.
    The `Queue` features first-in-first-out behavior, which is intended to provide
    a round-robin use of the database connections that are persistently in the pool.
    However, a potential downside of this is that when the utilization of the pool
    is low, the re-use of each connection in series means that a server-side timeout
    strategy that attempts to reduce unused connections is prevented from shutting
    down these connections. To suit this use case, a new flag [`create_engine.pool_use_lifo`](../core/engines.html#sqlalchemy.create_engine.params.pool_use_lifo
    "sqlalchemy.create_engine") is added which reverses the `.get()` method of the
    `Queue` to pull the connection from the beginning of the queue instead of the
    end, essentially turning the “queue” into a “stack” (adding a whole new pool called
    `StackPool` was considered, however this was too much verbosity).
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: 通常由[`create_engine()`](../core/engines.html#sqlalchemy.create_engine "sqlalchemy.create_engine")使用的连接池被称为[`QueuePool`](../core/pooling.html#sqlalchemy.pool.QueuePool
    "sqlalchemy.pool.QueuePool")。此池使用一个类似于Python内置的`Queue`类的对象来存储等待使用的数据库连接。`Queue`具有先进先出的行为，旨在提供对持久在池中的数据库连接的循环使用。然而，这种方法的一个潜在缺点是，当池的利用率较低时，池中每个连接的串行重复使用意味着试图减少未使用连接的服务器端超时策略被阻止关闭这些连接。为了适应这种用例，添加了一个新标志[`create_engine.pool_use_lifo`](../core/engines.html#sqlalchemy.create_engine.params.pool_use_lifo
    "sqlalchemy.create_engine")，它将`Queue`的`.get()`方法反转，从队列的开头而不是末尾获取连接，从本质上将“队列”变成“栈”（考虑到添加一个名为`StackPool`的全新池，但这太啰嗦了）。
- en: See also
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Using FIFO vs. LIFO](../core/pooling.html#pool-use-lifo)'
  id: totrans-801
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用 FIFO vs. LIFO](../core/pooling.html#pool-use-lifo)'
- en: Key Changes - Core
  id: totrans-802
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 核心关键变化
- en: '### Coercion of string SQL fragments to text() fully removed'
  id: totrans-803
  prefs: []
  type: TYPE_NORMAL
  zh: '### 完全删除将字符串 SQL 片段强制转换为 text() '
- en: The warnings that were first added in version 1.0, described at [Warnings emitted
    when coercing full SQL fragments into text()](migration_10.html#migration-2992),
    have now been converted into exceptions. Continued concerns have been raised regarding
    the automatic coercion of string fragments passed to methods like [`Query.filter()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.filter
    "sqlalchemy.orm.Query.filter") and [`Select.order_by()`](../core/selectable.html#sqlalchemy.sql.expression.Select.order_by
    "sqlalchemy.sql.expression.Select.order_by") being converted to [`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text
    "sqlalchemy.sql.expression.text") constructs, even though this has emitted a warning.
    In the case of [`Select.order_by()`](../core/selectable.html#sqlalchemy.sql.expression.Select.order_by
    "sqlalchemy.sql.expression.Select.order_by"), [`Query.order_by()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.order_by
    "sqlalchemy.orm.Query.order_by"), [`Select.group_by()`](../core/selectable.html#sqlalchemy.sql.expression.Select.group_by
    "sqlalchemy.sql.expression.Select.group_by"), and [`Query.group_by()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.group_by
    "sqlalchemy.orm.Query.group_by"), a string label or column name is still resolved
    into the corresponding expression construct, however if the resolution fails,
    a [`CompileError`](../core/exceptions.html#sqlalchemy.exc.CompileError "sqlalchemy.exc.CompileError")
    is raised, thus preventing raw SQL text from being rendered directly.
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: 首次在版本1.0中添加的警告，描述在[将完整SQL片段强制转换为text()时发出的警告](migration_10.html#migration-2992)，现在已转换为异常。对于像[`Query.filter()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.filter
    "sqlalchemy.orm.Query.filter")和[`Select.order_by()`](../core/selectable.html#sqlalchemy.sql.expression.Select.order_by
    "sqlalchemy.sql.expression.Select.order_by")等方法传递的字符串片段自动转换为[`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text
    "sqlalchemy.sql.expression.text")构造的持续关注，尽管这已发出警告。在[`Select.order_by()`](../core/selectable.html#sqlalchemy.sql.expression.Select.order_by
    "sqlalchemy.sql.expression.Select.order_by")、[`Query.order_by()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.order_by
    "sqlalchemy.orm.Query.order_by")、[`Select.group_by()`](../core/selectable.html#sqlalchemy.sql.expression.Select.group_by
    "sqlalchemy.sql.expression.Select.group_by")和[`Query.group_by()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.group_by
    "sqlalchemy.orm.Query.group_by")的情况下，字符串标签或列名仍然解析为相应的表达式构造，但如果解析失败，则会引发[`CompileError`](../core/exceptions.html#sqlalchemy.exc.CompileError
    "sqlalchemy.exc.CompileError")，从而防止直接呈现原始SQL文本。
- en: '[#4481](https://www.sqlalchemy.org/trac/ticket/4481)  ### “threadlocal” engine
    strategy deprecated'
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4481](https://www.sqlalchemy.org/trac/ticket/4481)  ### “线程本地”引擎策略已弃用'
- en: The “threadlocal engine strategy” was added around SQLAlchemy 0.2, as a solution
    to the problem that the standard way of operating in SQLAlchemy 0.1, which can
    be summed up as “threadlocal everything”, was found to be lacking. In retrospect,
    it seems fairly absurd that by SQLAlchemy’s first releases which were in every
    regard “alpha”, that there was concern that too many users had already settled
    on the existing API to simply change it.
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: “线程本地引擎策略”是在SQLAlchemy 0.2左右添加的，作为解决SQLAlchemy 0.1中操作的标准方式的问题的解决方案，可以总结为“线程本地一切”，发现存在不足。回顾起来，似乎相当荒谬，SQLAlchemy的首次发布在各个方面都是“alpha”，却担心太多用户已经定居在现有API上，无法简单地更改它。
- en: 'The original usage model for SQLAlchemy looked like this:'
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy的原始用法模型如下：
- en: '[PRE222]'
  id: totrans-808
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: 'After a few months of real world use, it was clear that trying to pretend a
    “connection” or a “transaction” was a hidden implementation detail was a bad idea,
    particularly the moment someone needed to deal with more than one database connection
    at a time. So the usage paradigm we see today was introduced, minus the context
    managers since they didn’t yet exist in Python:'
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: 在几个月的实际使用后，很明显，假装“连接”或“事务”是一个隐藏的实现细节是一个坏主意，特别是当有人需要同时处理多个数据库连接时。因此，我们今天看到的使用范式被引入，减去了上下文管理器，因为它们在Python中尚不存在：
- en: '[PRE223]'
  id: totrans-810
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: The above paradigm was what people needed, but since it was still kind of verbose
    (because no context managers), the old way of working was kept around as well
    and it became the threadlocal engine strategy.
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: 上述范式是人们所需要的，但由于它仍然有点冗长（因为没有上下文管理器），因此保留了旧的工作方式，并成为线程本地引擎策略。
- en: 'Today, working with Core is much more succinct, and even more succinct than
    the original pattern, thanks to context managers:'
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，使用Core更加简洁，甚至比原始模式更加简洁，这要归功于上下文管理器：
- en: '[PRE224]'
  id: totrans-813
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: At this point, any remaining code that is still relying upon the “threadlocal”
    style will be encouraged via this deprecation to modernize - the feature should
    be removed totally by the next major series of SQLAlchemy, e.g. 1.4\. The connection
    pool parameter [`Pool.use_threadlocal`](../core/pooling.html#sqlalchemy.pool.Pool.params.use_threadlocal
    "sqlalchemy.pool.Pool") is also deprecated as it does not actually have any effect
    in most cases, as is the `Engine.contextual_connect()` method, which is normally
    synonymous with the [`Engine.connect()`](../core/connections.html#sqlalchemy.engine.Engine.connect
    "sqlalchemy.engine.Engine.connect") method except in the case where the threadlocal
    engine is in use.
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，仍依赖“threadlocal”风格的任何剩余代码将通过此弃用来鼓励现代化 - 该功能应在下一个主要系列的SQLAlchemy中完全移除，例如1.4版。连接池参数[`Pool.use_threadlocal`](../core/pooling.html#sqlalchemy.pool.Pool.params.use_threadlocal
    "sqlalchemy.pool.Pool")也已弃用，因为在大多数情况下实际上没有任何效果，`Engine.contextual_connect()`方法也是如此，该方法通常与[`Engine.connect()`](../core/connections.html#sqlalchemy.engine.Engine.connect
    "sqlalchemy.engine.Engine.connect")方法是同义词，除非使用了threadlocal引擎。
- en: '[#4393](https://www.sqlalchemy.org/trac/ticket/4393)  ### convert_unicode parameters
    deprecated'
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4393](https://www.sqlalchemy.org/trac/ticket/4393)  ### convert_unicode参数已弃用'
- en: The parameters [`String.convert_unicode`](../core/type_basics.html#sqlalchemy.types.String.params.convert_unicode
    "sqlalchemy.types.String") and [`create_engine.convert_unicode`](../core/engines.html#sqlalchemy.create_engine.params.convert_unicode
    "sqlalchemy.create_engine") are deprecated. The purpose of these parameters was
    to instruct SQLAlchemy to ensure that incoming Python Unicode objects under Python
    2 were encoded to bytestrings before passing to the database, and to expect bytestrings
    from the database to be converted back to Python Unicode objects. In the pre-Python
    3 era, this was an enormous ordeal to get right, as virtually all Python DBAPIs
    had no Unicode support enabled by default, and most had major issues with the
    Unicode extensions that they did provide. Eventually, SQLAlchemy added C extensions,
    one of the primary purposes of these extensions was to speed up the Unicode decode
    process within result sets.
  id: totrans-816
  prefs: []
  type: TYPE_NORMAL
  zh: 参数[`String.convert_unicode`](../core/type_basics.html#sqlalchemy.types.String.params.convert_unicode
    "sqlalchemy.types.String")和[`create_engine.convert_unicode`](../core/engines.html#sqlalchemy.create_engine.params.convert_unicode
    "sqlalchemy.create_engine")已弃用。这些参数的目的是指示SQLAlchemy确保在Python 2下传递给数据库之前对传入的Python
    Unicode对象进行编码为字节字符串，并期望从数据库返回的字节字符串转换回Python Unicode对象。在Python 3之前的时代，要做到这一点是一件非常艰巨的事情，因为几乎所有Python
    DBAPI默认情况下都没有启用Unicode支持，并且大多数都存在与它们提供的Unicode扩展相关的主要问题。最终，SQLAlchemy添加了C扩展，这些扩展的主要目的之一是加快结果集中的Unicode解码过程。
- en: Once Python 3 was introduced, DBAPIs began to start supporting Unicode more
    fully, and more importantly, by default. However, the conditions under which a
    particular DBAPI would or would not return Unicode data from a result, as well
    as accept Python Unicode values as parameters, remained extremely complicated.
    This was the beginning of the obsolescence of the “convert_unicode” flags, because
    they were no longer sufficient as a means of ensuring that encode/decode was occurring
    only where needed and not where it wasn’t needed. Instead, “convert_unicode” started
    to be automatically detected by dialects. Part of this can be seen in the “SELECT
    ‘test plain returns’” and “SELECT ‘test_unicode_returns’” SQL emitted by an engine
    the first time it connects; the dialect is testing that the current DBAPI with
    its current settings and backend database connection is returning Unicode by default
    or not.
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦引入了Python 3，DBAPI开始更全面地支持Unicode，并且更重要的是，默认情况下支持Unicode。然而，特定DBAPI在何种条件下会或不会从结果返回Unicode数据，以及接受Python
    Unicode值作为参数的条件仍然非常复杂。这标志着“convert_unicode”标志开始过时，因为它们不再足以确保仅在需要时进行编码/解码，而不是在不需要时进行。相反，“convert_unicode”开始被dialects自动检测。这一部分可以在引擎第一次连接时发出的“SELECT
    ‘test plain returns’”和“SELECT ‘test_unicode_returns’”SQL中看到；方言正在测试当前DBAPI及其当前设置和后端数据库连接是否默认返回Unicode。
- en: The end result is that end-user use of the “convert_unicode” flags should no
    longer be needed in any circumstances, and if they are, the SQLAlchemy project
    needs to know what those cases are and why. Currently, hundreds of Unicode round
    trip tests pass across all major databases without the use of this flag so there
    is a fairly high level of confidence that they are no longer needed except in
    arguable non use cases such as accessing mis-encoded data from a legacy database,
    which would be better suited using custom types.
  id: totrans-818
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是，不再需要在任何情况下使用“convert_unicode”标志，如果需要，SQLAlchemy 项目需要知道这些情况及其原因。目前，在所有主要数据库上，使用该标志的
    Unicode 往返测试通过了数百次，因此相当有把握地认为它们不再需要，除非是在争议性的非使用情况，例如访问来自传统数据库的错误编码数据，最好使用自定义类型。
- en: '[#4393](https://www.sqlalchemy.org/trac/ticket/4393)  ### Coercion of string
    SQL fragments to text() fully removed'
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4393](https://www.sqlalchemy.org/trac/ticket/4393)  ### 完全移除将字符串 SQL 片段强制转换为
    text()'
- en: The warnings that were first added in version 1.0, described at [Warnings emitted
    when coercing full SQL fragments into text()](migration_10.html#migration-2992),
    have now been converted into exceptions. Continued concerns have been raised regarding
    the automatic coercion of string fragments passed to methods like [`Query.filter()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.filter
    "sqlalchemy.orm.Query.filter") and [`Select.order_by()`](../core/selectable.html#sqlalchemy.sql.expression.Select.order_by
    "sqlalchemy.sql.expression.Select.order_by") being converted to [`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text
    "sqlalchemy.sql.expression.text") constructs, even though this has emitted a warning.
    In the case of [`Select.order_by()`](../core/selectable.html#sqlalchemy.sql.expression.Select.order_by
    "sqlalchemy.sql.expression.Select.order_by"), [`Query.order_by()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.order_by
    "sqlalchemy.orm.Query.order_by"), [`Select.group_by()`](../core/selectable.html#sqlalchemy.sql.expression.Select.group_by
    "sqlalchemy.sql.expression.Select.group_by"), and [`Query.group_by()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.group_by
    "sqlalchemy.orm.Query.group_by"), a string label or column name is still resolved
    into the corresponding expression construct, however if the resolution fails,
    a [`CompileError`](../core/exceptions.html#sqlalchemy.exc.CompileError "sqlalchemy.exc.CompileError")
    is raised, thus preventing raw SQL text from being rendered directly.
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: 在 1.0 版本中首次添加的警告，描述在[将完整 SQL 片段强制转换为 text() 时发出的警告](migration_10.html#migration-2992)，现已转换为异常。对于将字符串片段传递给诸如[`Query.filter()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.filter
    "sqlalchemy.orm.Query.filter") 和 [`Select.order_by()`](../core/selectable.html#sqlalchemy.sql.expression.Select.order_by
    "sqlalchemy.sql.expression.Select.order_by")等方法的自动转换成[`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text
    "sqlalchemy.sql.expression.text") 构造的情况仍然存在持续的担忧，尽管已发出警告。对于[`Select.order_by()`](../core/selectable.html#sqlalchemy.sql.expression.Select.order_by
    "sqlalchemy.sql.expression.Select.order_by")、[`Query.order_by()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.order_by
    "sqlalchemy.orm.Query.order_by")、[`Select.group_by()`](../core/selectable.html#sqlalchemy.sql.expression.Select.group_by
    "sqlalchemy.sql.expression.Select.group_by") 和 [`Query.group_by()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.group_by
    "sqlalchemy.orm.Query.group_by")，字符串标签或列名仍然解析为相应的表达式构造，但如果解析失败，则引发[`CompileError`](../core/exceptions.html#sqlalchemy.exc.CompileError
    "sqlalchemy.exc.CompileError")，从而防止原始 SQL 文本直接呈现。
- en: '[#4481](https://www.sqlalchemy.org/trac/ticket/4481)'
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4481](https://www.sqlalchemy.org/trac/ticket/4481)'
- en: '### “threadlocal” engine strategy deprecated'
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: '### “threadlocal” 引擎策略已弃用'
- en: The “threadlocal engine strategy” was added around SQLAlchemy 0.2, as a solution
    to the problem that the standard way of operating in SQLAlchemy 0.1, which can
    be summed up as “threadlocal everything”, was found to be lacking. In retrospect,
    it seems fairly absurd that by SQLAlchemy’s first releases which were in every
    regard “alpha”, that there was concern that too many users had already settled
    on the existing API to simply change it.
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: “threadlocal 引擎策略” 是在 SQLAlchemy 0.2 左右添加的，作为 SQLAlchemy 0.1 中标准操作方式的解决方案，这种方式可以总结为“threadlocal
    everything”，但后来发现存在不足之处。回顾起来，很荒谬的是，即使 SQLAlchemy 的第一个版本在各个方面都是“alpha”版本，仍然担心已有太多用户已经习惯了现有的
    API 以至于不能轻易更改。
- en: 'The original usage model for SQLAlchemy looked like this:'
  id: totrans-824
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 的原始使用模型如下：
- en: '[PRE225]'
  id: totrans-825
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: 'After a few months of real world use, it was clear that trying to pretend a
    “connection” or a “transaction” was a hidden implementation detail was a bad idea,
    particularly the moment someone needed to deal with more than one database connection
    at a time. So the usage paradigm we see today was introduced, minus the context
    managers since they didn’t yet exist in Python:'
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: 经过几个月的实际使用，很明显，假装“连接”或“事务”是一个隐藏的实现细节是一个坏主意，特别是当有人需要同时处理多个数据库连接时。因此，我们今天看到的使用范式被引入，减去了上下文管理器，因为它们在
    Python 中尚不存在：
- en: '[PRE226]'
  id: totrans-827
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: The above paradigm was what people needed, but since it was still kind of verbose
    (because no context managers), the old way of working was kept around as well
    and it became the threadlocal engine strategy.
  id: totrans-828
  prefs: []
  type: TYPE_NORMAL
  zh: 上述范式是人们所需要的，但由于仍然有点啰嗦（因为没有上下文管理器），旧的工作方式也被保留下来，并成为线程本地引擎策略。
- en: 'Today, working with Core is much more succinct, and even more succinct than
    the original pattern, thanks to context managers:'
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，使用 Core 要简洁得多，甚至比原始模式更简洁，这要归功于上下文管理器：
- en: '[PRE227]'
  id: totrans-830
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: At this point, any remaining code that is still relying upon the “threadlocal”
    style will be encouraged via this deprecation to modernize - the feature should
    be removed totally by the next major series of SQLAlchemy, e.g. 1.4\. The connection
    pool parameter [`Pool.use_threadlocal`](../core/pooling.html#sqlalchemy.pool.Pool.params.use_threadlocal
    "sqlalchemy.pool.Pool") is also deprecated as it does not actually have any effect
    in most cases, as is the `Engine.contextual_connect()` method, which is normally
    synonymous with the [`Engine.connect()`](../core/connections.html#sqlalchemy.engine.Engine.connect
    "sqlalchemy.engine.Engine.connect") method except in the case where the threadlocal
    engine is in use.
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，任何仍然依赖“threadlocal”风格的代码都将通过此弃用被鼓励进行现代化 - 该功能应在下一个主要的 SQLAlchemy 系列（例如 1.4）中完全移除。连接池参数[`Pool.use_threadlocal`](../core/pooling.html#sqlalchemy.pool.Pool.params.use_threadlocal
    "sqlalchemy.pool.Pool")也被弃用，因为在大多数情况下实际上没有任何效果，`Engine.contextual_connect()`方法也是如此，该方法通常与[`Engine.connect()`](../core/connections.html#sqlalchemy.engine.Engine.connect
    "sqlalchemy.engine.Engine.connect")方法是同义的，除非使用线程本地引擎。
- en: '[#4393](https://www.sqlalchemy.org/trac/ticket/4393)'
  id: totrans-832
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4393](https://www.sqlalchemy.org/trac/ticket/4393)'
- en: '### convert_unicode parameters deprecated'
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: '### convert_unicode 参数已弃用'
- en: The parameters [`String.convert_unicode`](../core/type_basics.html#sqlalchemy.types.String.params.convert_unicode
    "sqlalchemy.types.String") and [`create_engine.convert_unicode`](../core/engines.html#sqlalchemy.create_engine.params.convert_unicode
    "sqlalchemy.create_engine") are deprecated. The purpose of these parameters was
    to instruct SQLAlchemy to ensure that incoming Python Unicode objects under Python
    2 were encoded to bytestrings before passing to the database, and to expect bytestrings
    from the database to be converted back to Python Unicode objects. In the pre-Python
    3 era, this was an enormous ordeal to get right, as virtually all Python DBAPIs
    had no Unicode support enabled by default, and most had major issues with the
    Unicode extensions that they did provide. Eventually, SQLAlchemy added C extensions,
    one of the primary purposes of these extensions was to speed up the Unicode decode
    process within result sets.
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: 参数[`String.convert_unicode`](../core/type_basics.html#sqlalchemy.types.String.params.convert_unicode
    "sqlalchemy.types.String")和[`create_engine.convert_unicode`](../core/engines.html#sqlalchemy.create_engine.params.convert_unicode
    "sqlalchemy.create_engine")已被弃用。这些参数的目的是指示 SQLAlchemy 在将 Python 2 中的传入 Unicode
    对象传递到数据库之前确保对其进行字节串编码，并期望从数据库接收字节串并将其转换回 Python Unicode 对象。在 Python 3 之前的时代，要做到这一点是一个巨大的挑战，因为几乎所有的
    Python DBAPI 默认情况下都没有启用 Unicode 支持，并且大多数都存在与其提供的 Unicode 扩展相关的主要问题。最终，SQLAlchemy
    添加了 C 扩展，其中这些扩展的主要目的之一是加速结果集中的 Unicode 解码过程。
- en: Once Python 3 was introduced, DBAPIs began to start supporting Unicode more
    fully, and more importantly, by default. However, the conditions under which a
    particular DBAPI would or would not return Unicode data from a result, as well
    as accept Python Unicode values as parameters, remained extremely complicated.
    This was the beginning of the obsolescence of the “convert_unicode” flags, because
    they were no longer sufficient as a means of ensuring that encode/decode was occurring
    only where needed and not where it wasn’t needed. Instead, “convert_unicode” started
    to be automatically detected by dialects. Part of this can be seen in the “SELECT
    ‘test plain returns’” and “SELECT ‘test_unicode_returns’” SQL emitted by an engine
    the first time it connects; the dialect is testing that the current DBAPI with
    its current settings and backend database connection is returning Unicode by default
    or not.
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦引入了 Python 3，DBAPI 开始更全面地支持 Unicode，更重要的是，默认情况下支持 Unicode。然而，特定 DBAPI 是否返回
    Unicode 数据以及接受 Python Unicode 值作为参数的条件仍然非常复杂。这标志着“convert_unicode”标志开始过时，因为它们不再足以确保仅在需要时进行编码/解码，而不是在不需要时进行。相反，“convert_unicode”开始由方言自动检测。可以从引擎第一次连接时发出的
    SQL “SELECT ‘test plain returns’” 和 “SELECT ‘test_unicode_returns’” 中看到其中一部分；方言正在测试当前
    DBAPI 与其当前设置和后端数据库连接是否默认返回 Unicode。
- en: The end result is that end-user use of the “convert_unicode” flags should no
    longer be needed in any circumstances, and if they are, the SQLAlchemy project
    needs to know what those cases are and why. Currently, hundreds of Unicode round
    trip tests pass across all major databases without the use of this flag so there
    is a fairly high level of confidence that they are no longer needed except in
    arguable non use cases such as accessing mis-encoded data from a legacy database,
    which would be better suited using custom types.
  id: totrans-836
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果是，在任何情况下，用户对“convert_unicode”标志的使用都不再需要，并且如果需要，SQLAlchemy 项目需要知道这些情况以及原因。当前，在所有主要数据库上，通过了数百个
    Unicode 往返测试，而不使用此标志，因此相当有信心不再需要它们，除非在可争议的非使用情况下，例如访问来自遗留数据库的错误编码数据，此时最好使用自定义类型。
- en: '[#4393](https://www.sqlalchemy.org/trac/ticket/4393)'
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4393](https://www.sqlalchemy.org/trac/ticket/4393)'
- en: Dialect Improvements and Changes - PostgreSQL
  id: totrans-838
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方言改进和更改 - PostgreSQL
- en: '### Added basic reflection support for PostgreSQL partitioned tables'
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: '### 为 PostgreSQL 分区表添加了基本的反射支持'
- en: SQLAlchemy can render the “PARTITION BY” sequence within a PostgreSQL CREATE
    TABLE statement using the flag `postgresql_partition_by`, added in version 1.2.6\.
    However, the `'p'` type was not part of the reflection queries used until now.
  id: totrans-840
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 可以在 PostgreSQL CREATE TABLE 语句中使用 `postgresql_partition_by` 标志渲染“PARTITION
    BY”序列，该标志在版本 1.2.6 中添加。然而，`'p'` 类型直到现在都不是反射查询的一部分。
- en: 'Given a schema such as:'
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: 给定这样一个模式：
- en: '[PRE228]'
  id: totrans-842
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: The two table names `'data_values'` and `'data_values_4_10'` will come back
    from [`Inspector.get_table_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_table_names
    "sqlalchemy.engine.reflection.Inspector.get_table_names") and additionally the
    columns will come back from `Inspector.get_columns('data_values')` as well as
    `Inspector.get_columns('data_values_4_10')`. This also extends to the use of `Table(...,
    autoload=True)` with these tables.
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: 两个表名 `'data_values'` 和 `'data_values_4_10'` 将通过 [`Inspector.get_table_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_table_names
    "sqlalchemy.engine.reflection.Inspector.get_table_names") 返回，并且列也将通过 `Inspector.get_columns('data_values')`
    和 `Inspector.get_columns('data_values_4_10')` 返回。这也适用于对这些表使用 `Table(..., autoload=True)`。
- en: '[#4237](https://www.sqlalchemy.org/trac/ticket/4237)  ### Added basic reflection
    support for PostgreSQL partitioned tables'
  id: totrans-844
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4237](https://www.sqlalchemy.org/trac/ticket/4237)  ### 为 PostgreSQL 分区表添加了基本的反射支持'
- en: SQLAlchemy can render the “PARTITION BY” sequence within a PostgreSQL CREATE
    TABLE statement using the flag `postgresql_partition_by`, added in version 1.2.6\.
    However, the `'p'` type was not part of the reflection queries used until now.
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 可以在 PostgreSQL CREATE TABLE 语句中使用 `postgresql_partition_by` 标志渲染“PARTITION
    BY”序列，该标志在版本 1.2.6 中添加。然而，`'p'` 类型直到现在都不是反射查询的一部分。
- en: 'Given a schema such as:'
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: 给定这样一个模式：
- en: '[PRE229]'
  id: totrans-847
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: The two table names `'data_values'` and `'data_values_4_10'` will come back
    from [`Inspector.get_table_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_table_names
    "sqlalchemy.engine.reflection.Inspector.get_table_names") and additionally the
    columns will come back from `Inspector.get_columns('data_values')` as well as
    `Inspector.get_columns('data_values_4_10')`. This also extends to the use of `Table(...,
    autoload=True)` with these tables.
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: 两个表名`'data_values'`和`'data_values_4_10'`将从[`Inspector.get_table_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_table_names
    "sqlalchemy.engine.reflection.Inspector.get_table_names")返回，并且还将从`Inspector.get_columns('data_values')`以及`Inspector.get_columns('data_values_4_10')`返回列。这也适用于使用这些表的`Table(...,
    autoload=True)`。
- en: '[#4237](https://www.sqlalchemy.org/trac/ticket/4237)'
  id: totrans-849
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4237](https://www.sqlalchemy.org/trac/ticket/4237)'
- en: Dialect Improvements and Changes - MySQL
  id: totrans-850
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方言改进和变化 - MySQL
- en: '### Protocol-level ping now used for pre-ping'
  id: totrans-851
  prefs: []
  type: TYPE_NORMAL
  zh: '### 协议级别的ping现在用于预先ping'
- en: 'The MySQL dialects including mysqlclient, python-mysql, PyMySQL and mysql-connector-python
    now use the `connection.ping()` method for the pool pre-ping feature, described
    at [Disconnect Handling - Pessimistic](../core/pooling.html#pool-disconnects-pessimistic).
    This is a much more lightweight ping than the previous method of emitting “SELECT
    1” on the connection.  ### Control of parameter ordering within ON DUPLICATE KEY
    UPDATE'
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: '包括mysqlclient、python-mysql、PyMySQL和mysql-connector-python在内的MySQL方言现在使用`connection.ping()`方法进行池预ping功能，详细信息请参见[断开处理
    - 悲观](../core/pooling.html#pool-disconnects-pessimistic)。这比以前在连接上发出“SELECT 1”的方法要轻量得多。  ###
    控制ON DUPLICATE KEY UPDATE中参数顺序'
- en: 'The order of UPDATE parameters in the `ON DUPLICATE KEY UPDATE` clause can
    now be explicitly ordered by passing a list of 2-tuples:'
  id: totrans-853
  prefs: []
  type: TYPE_NORMAL
  zh: '`ON DUPLICATE KEY UPDATE`子句中UPDATE参数的顺序现在可以通过传递一个2元组列表来明确排序：'
- en: '[PRE230]'
  id: totrans-854
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: See also
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: 参见
- en: '[INSERT…ON DUPLICATE KEY UPDATE (Upsert)](../dialects/mysql.html#mysql-insert-on-duplicate-key-update)  ###
    Protocol-level ping now used for pre-ping'
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: '[INSERT…ON DUPLICATE KEY UPDATE (Upsert)](../dialects/mysql.html#mysql-insert-on-duplicate-key-update)  ###
    协议级别的ping现在用于预先ping'
- en: The MySQL dialects including mysqlclient, python-mysql, PyMySQL and mysql-connector-python
    now use the `connection.ping()` method for the pool pre-ping feature, described
    at [Disconnect Handling - Pessimistic](../core/pooling.html#pool-disconnects-pessimistic).
    This is a much more lightweight ping than the previous method of emitting “SELECT
    1” on the connection.
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: 包括mysqlclient、python-mysql、PyMySQL和mysql-connector-python在内的MySQL方言现在使用`connection.ping()`方法进行池预ping功能，详细信息请参见[断开处理
    - 悲观](../core/pooling.html#pool-disconnects-pessimistic)。这比以前在连接上发出“SELECT 1”的方法要轻量得多。
- en: '### Control of parameter ordering within ON DUPLICATE KEY UPDATE'
  id: totrans-858
  prefs: []
  type: TYPE_NORMAL
  zh: '### 控制ON DUPLICATE KEY UPDATE中参数顺序'
- en: 'The order of UPDATE parameters in the `ON DUPLICATE KEY UPDATE` clause can
    now be explicitly ordered by passing a list of 2-tuples:'
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: '`ON DUPLICATE KEY UPDATE`子句中UPDATE参数的顺序现在可以通过传递一个2元组列表来明确排序：'
- en: '[PRE231]'
  id: totrans-860
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: See also
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
  zh: 参见
- en: '[INSERT…ON DUPLICATE KEY UPDATE (Upsert)](../dialects/mysql.html#mysql-insert-on-duplicate-key-update)'
  id: totrans-862
  prefs: []
  type: TYPE_NORMAL
  zh: '[INSERT…ON DUPLICATE KEY UPDATE (Upsert)](../dialects/mysql.html#mysql-insert-on-duplicate-key-update)'
- en: Dialect Improvements and Changes - SQLite
  id: totrans-863
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方言改进和变化 - SQLite
- en: '### Support for SQLite JSON Added'
  id: totrans-864
  prefs: []
  type: TYPE_NORMAL
  zh: '### 对SQLite JSON的支持已添加'
- en: A new datatype [`JSON`](../dialects/sqlite.html#sqlalchemy.dialects.sqlite.JSON
    "sqlalchemy.dialects.sqlite.JSON") is added which implements SQLite’s json member
    access functions on behalf of the [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON") base datatype. The SQLite `JSON_EXTRACT` and `JSON_QUOTE`
    functions are used by the implementation to provide basic JSON support.
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: 添加了一个新的数据类型[`JSON`](../dialects/sqlite.html#sqlalchemy.dialects.sqlite.JSON
    "sqlalchemy.dialects.sqlite.JSON")，它代表了[`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON")基础数据类型的SQLite的json成员访问函数。实现使用SQLite的`JSON_EXTRACT`和`JSON_QUOTE`函数来提供基本的JSON支持。
- en: Note that the name of the datatype itself as rendered in the database is the
    name “JSON”. This will create a SQLite datatype with “numeric” affinity, which
    normally should not be an issue except in the case of a JSON value that consists
    of single integer value. Nevertheless, following an example in SQLite’s own documentation
    at [https://www.sqlite.org/json1.html](https://www.sqlite.org/json1.html) the
    name JSON is being used for its familiarity.
  id: totrans-866
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，数据库中呈现的数据类型本身的名称是“JSON”。这将创建一个带有“numeric”亲和力的SQLite数据类型，通常情况下不应该成为问题，除非是由单个整数值组成的JSON值的情况。尽管如此，根据SQLite自己文档中的示例[https://www.sqlite.org/json1.html](https://www.sqlite.org/json1.html)，名称JSON正在被用于其熟悉性。
- en: '[#3850](https://www.sqlalchemy.org/trac/ticket/3850)  ### Support for SQLite
    ON CONFLICT in constraints added'
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3850](https://www.sqlalchemy.org/trac/ticket/3850)  ### 增加对SQLite约束中ON CONFLICT的支持'
- en: 'SQLite supports a non-standard ON CONFLICT clause that may be specified for
    standalone constraints as well as some column-inline constraints such as NOT NULL.
    Support has been added for these clauses via the `sqlite_on_conflict` keyword
    added to objects like [`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint") as well as several [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") -specific variants:'
  id: totrans-868
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite支持一个非标准的ON CONFLICT子句，可以为独立约束以及一些列内约束（如NOT NULL）指定。通过向诸如[`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint")之类的对象添加`sqlite_on_conflict`关键字以及几个[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") -特定的变体：
- en: '[PRE232]'
  id: totrans-869
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: 'The above table would render in a CREATE TABLE statement as:'
  id: totrans-870
  prefs: []
  type: TYPE_NORMAL
  zh: 上述表在CREATE TABLE语句中呈现为：
- en: '[PRE233]'
  id: totrans-871
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: See also
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[ON CONFLICT support for constraints](../dialects/sqlite.html#sqlite-on-conflict-ddl)'
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
  zh: '[ON CONFLICT支持约束](../dialects/sqlite.html#sqlite-on-conflict-ddl)'
- en: '[#4360](https://www.sqlalchemy.org/trac/ticket/4360)  ### Support for SQLite
    JSON Added'
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4360](https://www.sqlalchemy.org/trac/ticket/4360)  ### 增加对SQLite JSON的支持'
- en: A new datatype [`JSON`](../dialects/sqlite.html#sqlalchemy.dialects.sqlite.JSON
    "sqlalchemy.dialects.sqlite.JSON") is added which implements SQLite’s json member
    access functions on behalf of the [`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON") base datatype. The SQLite `JSON_EXTRACT` and `JSON_QUOTE`
    functions are used by the implementation to provide basic JSON support.
  id: totrans-875
  prefs: []
  type: TYPE_NORMAL
  zh: 添加了一个新的数据类型[`JSON`](../dialects/sqlite.html#sqlalchemy.dialects.sqlite.JSON
    "sqlalchemy.dialects.sqlite.JSON")，该数据类型代表[`JSON`](../core/type_basics.html#sqlalchemy.types.JSON
    "sqlalchemy.types.JSON")基本数据类型的SQLite的json成员访问函数。该实现使用SQLite的`JSON_EXTRACT`和`JSON_QUOTE`函数来提供基本的JSON支持。
- en: Note that the name of the datatype itself as rendered in the database is the
    name “JSON”. This will create a SQLite datatype with “numeric” affinity, which
    normally should not be an issue except in the case of a JSON value that consists
    of single integer value. Nevertheless, following an example in SQLite’s own documentation
    at [https://www.sqlite.org/json1.html](https://www.sqlite.org/json1.html) the
    name JSON is being used for its familiarity.
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，数据库中呈现的数据类型本身的名称是“JSON”。这将创建一个带有“数字”亲和力的SQLite数据类型，这通常不应该是问题，除非JSON值仅包含单个整数值。尽管如此，根据SQLite自己文档中的示例，[https://www.sqlite.org/json1.html](https://www.sqlite.org/json1.html)中使用了JSON这个名字以保持熟悉性。
- en: '[#3850](https://www.sqlalchemy.org/trac/ticket/3850)'
  id: totrans-877
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3850](https://www.sqlalchemy.org/trac/ticket/3850)'
- en: '### Support for SQLite ON CONFLICT in constraints added'
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
  zh: '### 增加对SQLite约束中ON CONFLICT的支持'
- en: 'SQLite supports a non-standard ON CONFLICT clause that may be specified for
    standalone constraints as well as some column-inline constraints such as NOT NULL.
    Support has been added for these clauses via the `sqlite_on_conflict` keyword
    added to objects like [`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint") as well as several [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") -specific variants:'
  id: totrans-879
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite支持一个非标准的ON CONFLICT子句，可以为独立约束以及一些列内约束（如NOT NULL）指定。通过向诸如[`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint")之类的对象添加`sqlite_on_conflict`关键字以及几个[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") -特定的变体，已为这些子句添加了支持：
- en: '[PRE234]'
  id: totrans-880
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: 'The above table would render in a CREATE TABLE statement as:'
  id: totrans-881
  prefs: []
  type: TYPE_NORMAL
  zh: 上述表在CREATE TABLE语句中呈现为：
- en: '[PRE235]'
  id: totrans-882
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: See also
  id: totrans-883
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[ON CONFLICT support for constraints](../dialects/sqlite.html#sqlite-on-conflict-ddl)'
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: '[ON CONFLICT支持约束](../dialects/sqlite.html#sqlite-on-conflict-ddl)'
- en: '[#4360](https://www.sqlalchemy.org/trac/ticket/4360)'
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4360](https://www.sqlalchemy.org/trac/ticket/4360)'
- en: Dialect Improvements and Changes - Oracle
  id: totrans-886
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方言改进和更改 - Oracle
- en: '### National char datatypes de-emphasized for generic unicode, re-enabled with
    option'
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: '### 对于通用unicode，国家字符数据类型被减弱，可通过选项重新启用'
- en: The [`Unicode`](../core/type_basics.html#sqlalchemy.types.Unicode "sqlalchemy.types.Unicode")
    and [`UnicodeText`](../core/type_basics.html#sqlalchemy.types.UnicodeText "sqlalchemy.types.UnicodeText")
    datatypes by default now correspond to the `VARCHAR2` and `CLOB` datatypes on
    Oracle, rather than `NVARCHAR2` and `NCLOB` (otherwise known as “national” character
    set types). This will be seen in behaviors such as that of how they render in
    `CREATE TABLE` statements, as well as that no type object will be passed to `setinputsizes()`
    when bound parameters using [`Unicode`](../core/type_basics.html#sqlalchemy.types.Unicode
    "sqlalchemy.types.Unicode") or [`UnicodeText`](../core/type_basics.html#sqlalchemy.types.UnicodeText
    "sqlalchemy.types.UnicodeText") are used; cx_Oracle handles the string value natively.
    This change is based on advice from cx_Oracle’s maintainer that the “national”
    datatypes in Oracle are largely obsolete and are not performant. They also interfere
    in some situations such as when applied to the format specifier for functions
    like `trunc()`.
  id: totrans-888
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，默认情况下，[`Unicode`](../core/type_basics.html#sqlalchemy.types.Unicode "sqlalchemy.types.Unicode")
    和 [`UnicodeText`](../core/type_basics.html#sqlalchemy.types.UnicodeText "sqlalchemy.types.UnicodeText")
    数据类型现在对应于 Oracle 上的 `VARCHAR2` 和 `CLOB` 数据类型，而不是 `NVARCHAR2` 和 `NCLOB`（也称为“国家”字符集类型）。这将在诸如它们在`CREATE
    TABLE`语句中的呈现方式等行为中看到，以及当使用[`Unicode`](../core/type_basics.html#sqlalchemy.types.Unicode
    "sqlalchemy.types.Unicode")或[`UnicodeText`](../core/type_basics.html#sqlalchemy.types.UnicodeText
    "sqlalchemy.types.UnicodeText")绑定参数时，不会传递任何类型对象给`setinputsizes()`；cx_Oracle 会原生处理字符串值。这种变化基于
    cx_Oracle 的维护者的建议，即 Oracle 中的“国家”数据类型在很大程度上已经过时且性能不佳。它们还会在某些情况下干扰，比如应用于像`trunc()`这样的函数的格式说明符时。
- en: The one case where `NVARCHAR2` and related types may be needed is for a database
    that is not using a Unicode-compliant character set. In this case, the flag `use_nchar_for_unicode`
    can be passed to [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") to re-enable the old behavior.
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据库不使用符合 Unicode 标准的字符集时，可能需要使用`NVARCHAR2`和相关类型的情况。在这种情况下，可以将标志`use_nchar_for_unicode`传递给[`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine")以重新启用旧行为。
- en: As always, using the [`NVARCHAR2`](../dialects/oracle.html#sqlalchemy.dialects.oracle.NVARCHAR2
    "sqlalchemy.dialects.oracle.NVARCHAR2") and [`NCLOB`](../dialects/oracle.html#sqlalchemy.dialects.oracle.NCLOB
    "sqlalchemy.dialects.oracle.NCLOB") datatypes explicitly will continue to make
    use of `NVARCHAR2` and `NCLOB`, including within DDL as well as when handling
    bound parameters with cx_Oracle’s `setinputsizes()`.
  id: totrans-890
  prefs: []
  type: TYPE_NORMAL
  zh: 如往常一样，明确使用[`NVARCHAR2`](../dialects/oracle.html#sqlalchemy.dialects.oracle.NVARCHAR2
    "sqlalchemy.dialects.oracle.NVARCHAR2")和[`NCLOB`](../dialects/oracle.html#sqlalchemy.dialects.oracle.NCLOB
    "sqlalchemy.dialects.oracle.NCLOB")数据类型将继续使用`NVARCHAR2`和`NCLOB`，包��在 DDL 中以及处理带有
    cx_Oracle 的`setinputsizes()`的绑定参数时。
- en: On the read side, automatic Unicode conversion under Python 2 has been added
    to CHAR/VARCHAR/CLOB result rows, to match the behavior of cx_Oracle under Python
    3\. In order to mitigate the performance hit that the cx_Oracle dialect had previously
    with this behavior under Python 2, SQLAlchemy’s very performant (when C extensions
    are built) native Unicode handlers are used under Python 2. The automatic unicode
    coercion can be disabled by setting the `coerce_to_unicode` flag to False. This
    flag now defaults to True and applies to all string data returned in a result
    set that isn’t explicitly under [`Unicode`](../core/type_basics.html#sqlalchemy.types.Unicode
    "sqlalchemy.types.Unicode") or Oracle’s NVARCHAR2/NCHAR/NCLOB datatypes.
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: 在读取方面，在 Python 2 下已经添加了对 CHAR/VARCHAR/CLOB 结果行的自动 Unicode 转换，以匹配 Python 3 下
    cx_Oracle 的行为。为了减轻 cx_Oracle 方言在 Python 2 下先前具有的性能损失，SQLAlchemy 在 Python 2 下使用非常高效（当构建
    C 扩展时）的本地 Unicode 处理程序。可以通过将`coerce_to_unicode`标志设置为 False 来禁用自动 Unicode 强制转换。此标志现在默认为
    True，并适用于所有在结果集中返回的字符串数据，这些数据不明确位于[`Unicode`](../core/type_basics.html#sqlalchemy.types.Unicode
    "sqlalchemy.types.Unicode")或 Oracle 的 NVARCHAR2/NCHAR/NCLOB 数据类型下。
- en: '[#4242](https://www.sqlalchemy.org/trac/ticket/4242)  ### cx_Oracle connect
    arguments modernized, deprecated parameters removed'
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4242](https://www.sqlalchemy.org/trac/ticket/4242)  ### cx_Oracle 连接参数现代化，废弃的参数已移除'
- en: 'A series of modernizations to the parameters accepted by the cx_oracle dialect
    as well as the URL string:'
  id: totrans-893
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 cx_oracle 方言接受的参数以及 URL 字符串进行了一系列现代化处理：
- en: The deprecated parameters `auto_setinputsizes`, `allow_twophase`, `exclude_setinputsizes`
    are removed.
  id: totrans-894
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 废弃的参数`auto_setinputsizes`、`allow_twophase`、`exclude_setinputsizes`已被移除。
- en: The value of the `threaded` parameter, which has always been defaulted to True
    for the SQLAlchemy dialect, is no longer generated by default. The SQLAlchemy
    [`Connection`](../core/connections.html#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    object is not considered to be thread-safe itself so there’s no need for this
    flag to be passed.
  id: totrans-895
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`threaded` 参数的值，对于 SQLAlchemy 方言一直默认为 True，现在不再默认生成。SQLAlchemy 的 [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") 对象本身不被视为线程安全，因此不需要传递此标志。'
- en: It’s deprecated to pass `threaded` to [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") itself. To set the value of `threaded` to `True`,
    pass it to either the [`create_engine.connect_args`](../core/engines.html#sqlalchemy.create_engine.params.connect_args
    "sqlalchemy.create_engine") dictionary or use the query string e.g. `oracle+cx_oracle://...?threaded=true`.
  id: totrans-896
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `threaded` 传递给 [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") 本身已被弃用。要将 `threaded` 的值设置为 `True`，请将其传递给 [`create_engine.connect_args`](../core/engines.html#sqlalchemy.create_engine.params.connect_args
    "sqlalchemy.create_engine") 字典或使用查询字符串，例如 `oracle+cx_oracle://...?threaded=true`。
- en: All parameters passed on the URL query string that are not otherwise specially
    consumed are now passed to the cx_Oracle.connect() function. A selection of these
    are also coerced either into cx_Oracle constants or booleans including `mode`,
    `purity`, `events`, and `threaded`.
  id: totrans-897
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，传递到 URL 查询字符串的所有参数，如果不被特别消耗，都会传递给 cx_Oracle.connect() 函数。其中一些也会被强制转换为 cx_Oracle
    常量或布尔值，包括 `mode`、`purity`、`events` 和 `threaded`。
- en: As was the case earlier, all cx_Oracle `.connect()` arguments are accepted via
    the [`create_engine.connect_args`](../core/engines.html#sqlalchemy.create_engine.params.connect_args
    "sqlalchemy.create_engine") dictionary, the documentation was inaccurate regarding
    this.
  id: totrans-898
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与之前一样，所有 cx_Oracle `.connect()` 参数都通过 [`create_engine.connect_args`](../core/engines.html#sqlalchemy.create_engine.params.connect_args
    "sqlalchemy.create_engine") 字典接受，文档在这方面是不准确的。
- en: '[#4369](https://www.sqlalchemy.org/trac/ticket/4369)  ### National char datatypes
    de-emphasized for generic unicode, re-enabled with option'
  id: totrans-899
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4369](https://www.sqlalchemy.org/trac/ticket/4369)  ### 国家字符数据类型被弱化以支持通用
    Unicode，可通过选项重新启用。'
- en: The [`Unicode`](../core/type_basics.html#sqlalchemy.types.Unicode "sqlalchemy.types.Unicode")
    and [`UnicodeText`](../core/type_basics.html#sqlalchemy.types.UnicodeText "sqlalchemy.types.UnicodeText")
    datatypes by default now correspond to the `VARCHAR2` and `CLOB` datatypes on
    Oracle, rather than `NVARCHAR2` and `NCLOB` (otherwise known as “national” character
    set types). This will be seen in behaviors such as that of how they render in
    `CREATE TABLE` statements, as well as that no type object will be passed to `setinputsizes()`
    when bound parameters using [`Unicode`](../core/type_basics.html#sqlalchemy.types.Unicode
    "sqlalchemy.types.Unicode") or [`UnicodeText`](../core/type_basics.html#sqlalchemy.types.UnicodeText
    "sqlalchemy.types.UnicodeText") are used; cx_Oracle handles the string value natively.
    This change is based on advice from cx_Oracle’s maintainer that the “national”
    datatypes in Oracle are largely obsolete and are not performant. They also interfere
    in some situations such as when applied to the format specifier for functions
    like `trunc()`.
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，[`Unicode`](../core/type_basics.html#sqlalchemy.types.Unicode "sqlalchemy.types.Unicode")
    和 [`UnicodeText`](../core/type_basics.html#sqlalchemy.types.UnicodeText "sqlalchemy.types.UnicodeText")
    数据类型现在对应于 Oracle 上的 `VARCHAR2` 和 `CLOB` 数据类型，而不是 `NVARCHAR2` 和 `NCLOB`（也称为“国家”字符集类型）。这将在诸如它们在
    `CREATE TABLE` 语句中的呈现方式等行为中看到，以及当使用 [`Unicode`](../core/type_basics.html#sqlalchemy.types.Unicode
    "sqlalchemy.types.Unicode") 或 [`UnicodeText`](../core/type_basics.html#sqlalchemy.types.UnicodeText
    "sqlalchemy.types.UnicodeText") 绑定参数时，不会传递任何类型对象给 `setinputsizes()`；cx_Oracle
    会原生处理字符串值。这一变化基于 cx_Oracle 的维护者的建议，即 Oracle 中的“国家”数据类型在很大程度上已经过时且性能不佳。它们还会在某些情况下干扰，比如应用于
    `trunc()` 等函数的格式说明符时。
- en: The one case where `NVARCHAR2` and related types may be needed is for a database
    that is not using a Unicode-compliant character set. In this case, the flag `use_nchar_for_unicode`
    can be passed to [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") to re-enable the old behavior.
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
  zh: 可能需要使用 `NVARCHAR2` 和相关类型的情况是数据库未使用符合 Unicode 标准的字符集。在这种情况下，可以通过将标志 `use_nchar_for_unicode`
    传递给 [`create_engine()`](../core/engines.html#sqlalchemy.create_engine "sqlalchemy.create_engine")
    来重新启用旧行为。
- en: As always, using the [`NVARCHAR2`](../dialects/oracle.html#sqlalchemy.dialects.oracle.NVARCHAR2
    "sqlalchemy.dialects.oracle.NVARCHAR2") and [`NCLOB`](../dialects/oracle.html#sqlalchemy.dialects.oracle.NCLOB
    "sqlalchemy.dialects.oracle.NCLOB") datatypes explicitly will continue to make
    use of `NVARCHAR2` and `NCLOB`, including within DDL as well as when handling
    bound parameters with cx_Oracle’s `setinputsizes()`.
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
  zh: 始终如此，在DDL中明确使用[`NVARCHAR2`](../dialects/oracle.html#sqlalchemy.dialects.oracle.NVARCHAR2
    "sqlalchemy.dialects.oracle.NVARCHAR2")和[`NCLOB`](../dialects/oracle.html#sqlalchemy.dialects.oracle.NCLOB
    "sqlalchemy.dialects.oracle.NCLOB")数据类型将继续使用`NVARCHAR2`和`NCLOB`，包括在处理绑定参数时使用cx_Oracle的`setinputsizes()`。
- en: On the read side, automatic Unicode conversion under Python 2 has been added
    to CHAR/VARCHAR/CLOB result rows, to match the behavior of cx_Oracle under Python
    3\. In order to mitigate the performance hit that the cx_Oracle dialect had previously
    with this behavior under Python 2, SQLAlchemy’s very performant (when C extensions
    are built) native Unicode handlers are used under Python 2. The automatic unicode
    coercion can be disabled by setting the `coerce_to_unicode` flag to False. This
    flag now defaults to True and applies to all string data returned in a result
    set that isn’t explicitly under [`Unicode`](../core/type_basics.html#sqlalchemy.types.Unicode
    "sqlalchemy.types.Unicode") or Oracle’s NVARCHAR2/NCHAR/NCLOB datatypes.
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
  zh: 在读取方面，在Python 2下已添加了CHAR/VARCHAR/CLOB结果行的自动Unicode转换，以匹配Python 3下cx_Oracle的行为。为了减轻以前在Python
    2下cx_Oracle方言在这种行为下的性能损失，SQLAlchemy在Python 2下使用了非常高效（当构建了C扩展时）的本地Unicode处理程序。自动Unicode强制转换可以通过将`coerce_to_unicode`标志设置为False来禁用。该标志现在默认为True，并适用于结果集中返回的所有不明确为[`Unicode`](../core/type_basics.html#sqlalchemy.types.Unicode
    "sqlalchemy.types.Unicode")或Oracle的NVARCHAR2/NCHAR/NCLOB数据类型的字符串数据。
- en: '[#4242](https://www.sqlalchemy.org/trac/ticket/4242)'
  id: totrans-904
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4242](https://www.sqlalchemy.org/trac/ticket/4242)'
- en: '### cx_Oracle connect arguments modernized, deprecated parameters removed'
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
  zh: '### cx_Oracle连接参数现代化，弃用的参数已移除'
- en: 'A series of modernizations to the parameters accepted by the cx_oracle dialect
    as well as the URL string:'
  id: totrans-906
  prefs: []
  type: TYPE_NORMAL
  zh: 对cx_oracle方言接受的参数以及URL字符串进行了一系列现代化改进：
- en: The deprecated parameters `auto_setinputsizes`, `allow_twophase`, `exclude_setinputsizes`
    are removed.
  id: totrans-907
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 弃用的参数`auto_setinputsizes`、`allow_twophase`、`exclude_setinputsizes`已被移除。
- en: The value of the `threaded` parameter, which has always been defaulted to True
    for the SQLAlchemy dialect, is no longer generated by default. The SQLAlchemy
    [`Connection`](../core/connections.html#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    object is not considered to be thread-safe itself so there’s no need for this
    flag to be passed.
  id: totrans-908
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`threaded`参数的值，对于SQLAlchemy方言始终默认为True，现在不再默认生成。SQLAlchemy的[`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")对象本身不被认为是线程安全的，因此不需要传递此标志。'
- en: It’s deprecated to pass `threaded` to [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") itself. To set the value of `threaded` to `True`,
    pass it to either the [`create_engine.connect_args`](../core/engines.html#sqlalchemy.create_engine.params.connect_args
    "sqlalchemy.create_engine") dictionary or use the query string e.g. `oracle+cx_oracle://...?threaded=true`.
  id: totrans-909
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`threaded`传递给[`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine")本身已被弃用。要将`threaded`的值设置为`True`，请将其传递给[`create_engine.connect_args`](../core/engines.html#sqlalchemy.create_engine.params.connect_args
    "sqlalchemy.create_engine")字典或使用查询字符串，例如`oracle+cx_oracle://...?threaded=true`。
- en: All parameters passed on the URL query string that are not otherwise specially
    consumed are now passed to the cx_Oracle.connect() function. A selection of these
    are also coerced either into cx_Oracle constants or booleans including `mode`,
    `purity`, `events`, and `threaded`.
  id: totrans-910
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，URL查询字符串中传递的所有参数，如果不被特殊消耗，都会传递给cx_Oracle.connect()函数。其中一些参数也会被强制转换为cx_Oracle常量或布尔值，包括`mode`、`purity`、`events`和`threaded`。
- en: As was the case earlier, all cx_Oracle `.connect()` arguments are accepted via
    the [`create_engine.connect_args`](../core/engines.html#sqlalchemy.create_engine.params.connect_args
    "sqlalchemy.create_engine") dictionary, the documentation was inaccurate regarding
    this.
  id: totrans-911
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与之前一样，所有cx_Oracle的`.connect()`参数都可以通过[`create_engine.connect_args`](../core/engines.html#sqlalchemy.create_engine.params.connect_args
    "sqlalchemy.create_engine")字典接受，文档在这方面描述不准确。
- en: '[#4369](https://www.sqlalchemy.org/trac/ticket/4369)'
  id: totrans-912
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4369](https://www.sqlalchemy.org/trac/ticket/4369)'
- en: Dialect Improvements and Changes - SQL Server
  id: totrans-913
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方言改进和变化 - SQL Server
- en: '### Support for pyodbc fast_executemany'
  id: totrans-914
  prefs: []
  type: TYPE_NORMAL
  zh: '### 支持pyodbc fast_executemany'
- en: 'Pyodbc’s recently added “fast_executemany” mode, available when using the Microsoft
    ODBC driver, is now an option for the pyodbc / mssql dialect. Pass it via [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine"):'
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
  zh: Pyodbc最近添加的“fast_executemany”模式，在使用Microsoft ODBC驱动程序时可用，现在是pyodbc / mssql方言的选项。通过[`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine")传递：
- en: '[PRE236]'
  id: totrans-916
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: See also
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Fast Executemany Mode](../dialects/mssql.html#mssql-pyodbc-fastexecutemany)'
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
  zh: '[快速执行多模式](../dialects/mssql.html#mssql-pyodbc-fastexecutemany)'
- en: '[#4158](https://www.sqlalchemy.org/trac/ticket/4158)  ### New parameters to
    affect IDENTITY start and increment, use of Sequence deprecated'
  id: totrans-919
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4158](https://www.sqlalchemy.org/trac/ticket/4158)  ### 新参数影响IDENTITY的起始和增量，使用Sequence已被弃用'
- en: 'SQL Server as of SQL Server 2012 now supports sequences with real `CREATE SEQUENCE`
    syntax. In [#4235](https://www.sqlalchemy.org/trac/ticket/4235), SQLAlchemy will
    add support for these using [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence") in the same way as for any other dialect. However,
    the current situation is that [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence") has been repurposed on SQL Server specifically in
    order to affect the “start” and “increment” parameters for the `IDENTITY` specification
    on a primary key column. In order to make the transition towards normal sequences
    being available as well, using [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence") will emit a deprecation warning throughout the 1.3
    series. In order to affect “start” and “increment”, use the new `mssql_identity_start`
    and `mssql_identity_increment` parameters on [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column"):'
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
  zh: 从SQL Server 2012开始，SQL Server现在支持具有真实`CREATE SEQUENCE`语法的序列。在[#4235](https://www.sqlalchemy.org/trac/ticket/4235)中，SQLAlchemy将添加对这些的支持，使用[`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence")方式与任何其他方言相同。然而，当前情况是，[`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence")已经在SQL Server上重新用途，以影响主键列上`IDENTITY`规范的“start”和“increment”参数。为了使过渡向正常序列也可用，使用[`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence")将在整个1.3系列中发出弃用警告。为了影响“start”和“increment”，在[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")上使用新的`mssql_identity_start`和`mssql_identity_increment`参数：
- en: '[PRE237]'
  id: totrans-921
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: 'In order to emit `IDENTITY` on a non-primary key column, which is a little-used
    but valid SQL Server use case, use the [`Column.autoincrement`](../core/metadata.html#sqlalchemy.schema.Column.params.autoincrement
    "sqlalchemy.schema.Column") flag, setting it to `True` on the target column, `False`
    on any integer primary key column:'
  id: totrans-922
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在非主键列上发出`IDENTITY`，这是一个很少使用但有效的SQL Server用例，使用[`Column.autoincrement`](../core/metadata.html#sqlalchemy.schema.Column.params.autoincrement
    "sqlalchemy.schema.Column")标志，将其设置为`True`在目标列上，`False`在任何整数主键列上：
- en: '[PRE238]'
  id: totrans-923
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: See also
  id: totrans-924
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Auto Increment Behavior / IDENTITY Columns](../dialects/mssql.html#mssql-identity)'
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
  zh: '[自增行为 / IDENTITY列](../dialects/mssql.html#mssql-identity)'
- en: '[#4362](https://www.sqlalchemy.org/trac/ticket/4362)'
  id: totrans-926
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4362](https://www.sqlalchemy.org/trac/ticket/4362)'
- en: '[#4235](https://www.sqlalchemy.org/trac/ticket/4235)  ### Support for pyodbc
    fast_executemany'
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4235](https://www.sqlalchemy.org/trac/ticket/4235)  ### 支持pyodbc fast_executemany'
- en: 'Pyodbc’s recently added “fast_executemany” mode, available when using the Microsoft
    ODBC driver, is now an option for the pyodbc / mssql dialect. Pass it via [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine"):'
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
  zh: Pyodbc最近添加的“fast_executemany”模式，在使用Microsoft ODBC驱动程序时可用，现在是pyodbc / mssql方言的选项。通过[`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine")传递：
- en: '[PRE239]'
  id: totrans-929
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: See also
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Fast Executemany Mode](../dialects/mssql.html#mssql-pyodbc-fastexecutemany)'
  id: totrans-931
  prefs: []
  type: TYPE_NORMAL
  zh: '[快速执行多模式](../dialects/mssql.html#mssql-pyodbc-fastexecutemany)'
- en: '[#4158](https://www.sqlalchemy.org/trac/ticket/4158)'
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4158](https://www.sqlalchemy.org/trac/ticket/4158)'
- en: '### New parameters to affect IDENTITY start and increment, use of Sequence
    deprecated'
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
  zh: '### 新参数影响IDENTITY的起始和增量，使用Sequence已被弃用'
- en: 'SQL Server as of SQL Server 2012 now supports sequences with real `CREATE SEQUENCE`
    syntax. In [#4235](https://www.sqlalchemy.org/trac/ticket/4235), SQLAlchemy will
    add support for these using [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence") in the same way as for any other dialect. However,
    the current situation is that [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence") has been repurposed on SQL Server specifically in
    order to affect the “start” and “increment” parameters for the `IDENTITY` specification
    on a primary key column. In order to make the transition towards normal sequences
    being available as well, using [`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence") will emit a deprecation warning throughout the 1.3
    series. In order to affect “start” and “increment”, use the new `mssql_identity_start`
    and `mssql_identity_increment` parameters on [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column"):'
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
  zh: 从 SQL Server 2012 开始，SQL Server 现在支持具有真实`CREATE SEQUENCE`语法的序列。在[#4235](https://www.sqlalchemy.org/trac/ticket/4235)中，SQLAlchemy
    将使用[`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence "sqlalchemy.schema.Sequence")来支持这些，方式与任何其他方言相同。然而，当前情况是，[`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence")已经在 SQL Server 上重新用途，以影响主键列上`IDENTITY`规范的“start”和“increment”参数。为了使过渡向正常序列也可用，使用[`Sequence`](../core/defaults.html#sqlalchemy.schema.Sequence
    "sqlalchemy.schema.Sequence")将在整个 1.3 系列中发出弃用警告。为了影响“start”和“increment”，请在[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")上使用新的`mssql_identity_start`和`mssql_identity_increment`参数：
- en: '[PRE240]'
  id: totrans-935
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: 'In order to emit `IDENTITY` on a non-primary key column, which is a little-used
    but valid SQL Server use case, use the [`Column.autoincrement`](../core/metadata.html#sqlalchemy.schema.Column.params.autoincrement
    "sqlalchemy.schema.Column") flag, setting it to `True` on the target column, `False`
    on any integer primary key column:'
  id: totrans-936
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在非主键列上发出`IDENTITY`，这是一个很少使用但有效的 SQL Server 用例，可以使用[`Column.autoincrement`](../core/metadata.html#sqlalchemy.schema.Column.params.autoincrement
    "sqlalchemy.schema.Column")标志，在目标列上将其设置为`True`，在任何整数主键列上将其设置为`False`：
- en: '[PRE241]'
  id: totrans-937
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: See also
  id: totrans-938
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Auto Increment Behavior / IDENTITY Columns](../dialects/mssql.html#mssql-identity)'
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
  zh: '[自动增量行为 / IDENTITY 列](../dialects/mssql.html#mssql-identity)'
- en: '[#4362](https://www.sqlalchemy.org/trac/ticket/4362)'
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4362](https://www.sqlalchemy.org/trac/ticket/4362)'
- en: '[#4235](https://www.sqlalchemy.org/trac/ticket/4235)'
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4235](https://www.sqlalchemy.org/trac/ticket/4235)'
- en: '## Changed StatementError formatting (newlines and %s)'
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
  zh: '## 更改了StatementError的格式（换行和%s）'
- en: Two changes are introduced to the string representation for `StatementError`.
    The “detail” and “SQL” portions of the string representation are now separated
    by newlines, and newlines that are present in the original SQL statement are maintained.
    The goal is to improve readability while still keeping the original error message
    on one line for logging purposes.
  id: totrans-943
  prefs: []
  type: TYPE_NORMAL
  zh: 对`StatementError`的字符串表示引入了两个更改。字符串表示的“detail”和“SQL”部分现在由换行符分隔，并保留了原始 SQL 语句中存在的换行符。目标是提高可读性，同时仍然保持原始错误消息在一行上以便于日志记录。
- en: 'This means that an error message that previously looked like this:'
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着以前看起来像这样的错误消息：
- en: '[PRE242]'
  id: totrans-945
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: 'Will now look like this:'
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看起来像这样：
- en: '[PRE243]'
  id: totrans-947
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: The primary impact of this change is that consumers can no longer assume that
    a complete exception message is on a single line, however the original “error”
    portion that is generated from the DBAPI driver or SQLAlchemy internals will still
    be on the first line.
  id: totrans-948
  prefs: []
  type: TYPE_NORMAL
  zh: 此更改的主要影响是消费者不能再假设完整的异常消息在单行上，但是从 DBAPI 驱动程序或 SQLAlchemy 内部生成的原始“error”部分仍将在第一行上。
- en: '[#4500](https://www.sqlalchemy.org/trac/ticket/4500)'
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
  zh: '[#4500](https://www.sqlalchemy.org/trac/ticket/4500)'
