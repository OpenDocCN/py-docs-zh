["```py\ncreate_engine(\"postgresql://scott:tiger@localhost/test\")\n```", "```py\ncreate_engine(\"postgresql+pg8000://scott:tiger@localhost/test\")\n```", "```py\nfrom sqlalchemy.dialects.postgresql import (\n    INTEGER,\n    BIGINT,\n    SMALLINT,\n    VARCHAR,\n    MACADDR,\n    DATE,\n    BYTEA,\n)\n```", "```py\n>>> from sqlalchemy.sql import column\n>>> column(\"foo\") == 5\n<sqlalchemy.sql.expression._BinaryExpression object at 0x1252490>\n```", "```py\n>>> str(column(\"foo\") == 5)\n'foo = :foo_1'\n```", "```py\n>>> if column(\"foo\") == 5:\n...     print(\"yes\")\n```", "```py\n>>> bool(column(\"foo\") == 5)\nFalse\n>>> bool(column(\"foo\") == column(\"foo\"))\nFalse\n>>> c = column(\"foo\")\n>>> bool(c == c)\nTrue\n>>>\n```", "```py\nif expression:\n    print(\"the expression is:\", expression)\n```", "```py\n>>> bool(c)\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\n  ...\n  raise TypeError(\"Boolean value of this clause is not defined\")\nTypeError: Boolean value of this clause is not defined\n```", "```py\nif expression is not None:\n    print(\"the expression is:\", expression)\n```", "```py\nconnection.execute(table.insert(), {\"data\": \"row1\"}, {\"data\": \"row2\"}, {\"data\": \"row3\"})\n```", "```py\nconnection.execute(\n    table.insert(),\n    {\"timestamp\": today, \"data\": \"row1\"},\n    {\"timestamp\": today, \"data\": \"row2\"},\n    {\"data\": \"row3\"},\n)\n```", "```py\nsqlite select/native: 0.260s\n\n0.6 / C extension\n\nsqlalchemy.sql select: 0.360s\nsqlalchemy.orm fetch: 2.500s\n\n0.6 / Pure Python\n\nsqlalchemy.sql select: 0.600s\nsqlalchemy.orm fetch: 3.000s\n\n0.5 / Pure Python\n\nsqlalchemy.sql select: 0.790s\nsqlalchemy.orm fetch: 4.030s\n```", "```py\nfrom sqlalchemy.schema import DDL\n\nDDL(\"CREATE TRIGGER users_trigger ...\").execute_at(\"after-create\", metadata)\n```", "```py\nfrom sqlalchemy.schema import Constraint, AddConstraint\n\nAddContraint(CheckConstraint(\"value > 5\")).execute_at(\"after-create\", mytable)\n```", "```py\nfrom sqlalchemy.schema import CreateTable\n\ncreate = CreateTable(mytable)\n\n# dumps the CREATE TABLE as a string\nprint(create)\n\n# executes the CREATE TABLE statement\nengine.execute(create)\n```", "```py\nfrom sqlalchemy.schema import DDLElement\nfrom sqlalchemy.ext.compiler import compiles\n\nclass AlterColumn(DDLElement):\n    def __init__(self, column, cmd):\n        self.column = column\n        self.cmd = cmd\n\n@compiles(AlterColumn)\ndef visit_alter_column(element, compiler, **kw):\n    return \"ALTER TABLE %s ALTER COLUMN %s  %s ...\" % (\n        element.column.table.name,\n        element.column.name,\n        element.cmd,\n    )\n\nengine.execute(AlterColumn(table.c.mycolumn, \"SET DEFAULT 'test'\"))\n```", "```py\nfrom sqlalchemy.engine.reflection import Inspector\n\ninsp = Inspector.from_engine(my_engine)\n\nprint(insp.get_schema_names())\n```", "```py\nmy_engine = create_engine(\"postgresql://...\")\npg_insp = Inspector.from_engine(my_engine)\n\nprint(pg_insp.get_table_oid(\"my_table\"))\n```", "```py\nresult = connection.execute(\n    table.insert().values(data=\"some data\").returning(table.c.id, table.c.timestamp)\n)\nrow = result.first()\nprint(\"ID:\", row[\"id\"], \"Timestamp:\", row[\"timestamp\"])\n```", "```py\nclass UTF8Encoded(TypeDecorator):\n  \"\"\"Unicode type which coerces to utf-8.\"\"\"\n\n    impl = sa.VARCHAR\n\n    def process_result_value(self, value, dialect):\n        if isinstance(value, unicode):\n            value = value.encode(\"utf-8\")\n        return value\n```", "```py\n>>> String(50)._compare_type_affinity(postgresql.VARCHAR(50))\nTrue\n>>> Integer()._compare_type_affinity(mysql.REAL)\nFalse\n```", "```py and ```", "```py options as well as the ```", "```py setting on ```", "```py, ```", "```py is now ```", "```py, ```", "```py/```", "```py options are now superseded by ```", "```py and ```", "```py. The old names will hang around for the foreseeable future just like ```", "```py now accepts ```", "```py option on ```", "```py are now ```", "```py for lazy loading (via a SELECT issued on attribute access), ```", "```py for joined-eager loading, ```", "```py for subquery-eager loading, ```", "```py for no loading should occur, and ```", "```py for a \u201cdynamic\u201d relationship. The old ```", "```py, ```", "```py, ```", "```py\nmapper(Child, child)\nmapper(\n    Parent,\n    parent,\n    properties={\"child\": relationship(Child, lazy=\"joined\", innerjoin=True)},\n)\n```", "```py\nsession.query(Parent).options(joinedload(Parent.child, innerjoin=True)).all()\n```", "```py\n    session.query(Address).options(eagerload(Address.user)).limit(10)\n    ```", "```py\n    SELECT  *  FROM\n      (SELECT  *  FROM  addresses  LIMIT  10)  AS  anon_1\n      LEFT  OUTER  JOIN  users  AS  users_1  ON  users_1.id  =  anon_1.addresses_user_id\n    ```", "```py\n    SELECT  *  FROM  addresses  LEFT  OUTER  JOIN  users  AS  users_1  ON  users_1.id  =  addresses.user_id  LIMIT  10\n    ```", "```py\ncreate_engine(\"postgresql://scott:tiger@localhost/test\")\n```", "```py\ncreate_engine(\"postgresql+pg8000://scott:tiger@localhost/test\")\n```", "```py\nfrom sqlalchemy.dialects.postgresql import (\n    INTEGER,\n    BIGINT,\n    SMALLINT,\n    VARCHAR,\n    MACADDR,\n    DATE,\n    BYTEA,\n)\n```", "```py\nfrom sqlalchemy.dialects.postgresql import (\n    INTEGER,\n    BIGINT,\n    SMALLINT,\n    VARCHAR,\n    MACADDR,\n    DATE,\n    BYTEA,\n)\n```", "```py\n>>> from sqlalchemy.sql import column\n>>> column(\"foo\") == 5\n<sqlalchemy.sql.expression._BinaryExpression object at 0x1252490>\n```", "```py\n>>> str(column(\"foo\") == 5)\n'foo = :foo_1'\n```", "```py\n>>> if column(\"foo\") == 5:\n...     print(\"yes\")\n```", "```py\n>>> bool(column(\"foo\") == 5)\nFalse\n>>> bool(column(\"foo\") == column(\"foo\"))\nFalse\n>>> c = column(\"foo\")\n>>> bool(c == c)\nTrue\n>>>\n```", "```py\nif expression:\n    print(\"the expression is:\", expression)\n```", "```py\n>>> bool(c)\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\n  ...\n  raise TypeError(\"Boolean value of this clause is not defined\")\nTypeError: Boolean value of this clause is not defined\n```", "```py\nif expression is not None:\n    print(\"the expression is:\", expression)\n```", "```py\nconnection.execute(table.insert(), {\"data\": \"row1\"}, {\"data\": \"row2\"}, {\"data\": \"row3\"})\n```", "```py\nconnection.execute(\n    table.insert(),\n    {\"timestamp\": today, \"data\": \"row1\"},\n    {\"timestamp\": today, \"data\": \"row2\"},\n    {\"data\": \"row3\"},\n)\n```", "```py\n>>> from sqlalchemy.sql import column\n>>> column(\"foo\") == 5\n<sqlalchemy.sql.expression._BinaryExpression object at 0x1252490>\n```", "```py\n>>> str(column(\"foo\") == 5)\n'foo = :foo_1'\n```", "```py\n>>> if column(\"foo\") == 5:\n...     print(\"yes\")\n```", "```py\n>>> bool(column(\"foo\") == 5)\nFalse\n>>> bool(column(\"foo\") == column(\"foo\"))\nFalse\n>>> c = column(\"foo\")\n>>> bool(c == c)\nTrue\n>>>\n```", "```py\nif expression:\n    print(\"the expression is:\", expression)\n```", "```py\n>>> bool(c)\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\n  ...\n  raise TypeError(\"Boolean value of this clause is not defined\")\nTypeError: Boolean value of this clause is not defined\n```", "```py\nif expression is not None:\n    print(\"the expression is:\", expression)\n```", "```py\nconnection.execute(table.insert(), {\"data\": \"row1\"}, {\"data\": \"row2\"}, {\"data\": \"row3\"})\n```", "```py\nconnection.execute(\n    table.insert(),\n    {\"timestamp\": today, \"data\": \"row1\"},\n    {\"timestamp\": today, \"data\": \"row2\"},\n    {\"data\": \"row3\"},\n)\n```", "```py\nsqlite select/native: 0.260s\n\n0.6 / C extension\n\nsqlalchemy.sql select: 0.360s\nsqlalchemy.orm fetch: 2.500s\n\n0.6 / Pure Python\n\nsqlalchemy.sql select: 0.600s\nsqlalchemy.orm fetch: 3.000s\n\n0.5 / Pure Python\n\nsqlalchemy.sql select: 0.790s\nsqlalchemy.orm fetch: 4.030s\n```", "```py\nfrom sqlalchemy.schema import DDL\n\nDDL(\"CREATE TRIGGER users_trigger ...\").execute_at(\"after-create\", metadata)\n```", "```py\nfrom sqlalchemy.schema import Constraint, AddConstraint\n\nAddContraint(CheckConstraint(\"value > 5\")).execute_at(\"after-create\", mytable)\n```", "```py\nfrom sqlalchemy.schema import CreateTable\n\ncreate = CreateTable(mytable)\n\n# dumps the CREATE TABLE as a string\nprint(create)\n\n# executes the CREATE TABLE statement\nengine.execute(create)\n```", "```py\nfrom sqlalchemy.schema import DDLElement\nfrom sqlalchemy.ext.compiler import compiles\n\nclass AlterColumn(DDLElement):\n    def __init__(self, column, cmd):\n        self.column = column\n        self.cmd = cmd\n\n@compiles(AlterColumn)\ndef visit_alter_column(element, compiler, **kw):\n    return \"ALTER TABLE %s ALTER COLUMN %s  %s ...\" % (\n        element.column.table.name,\n        element.column.name,\n        element.cmd,\n    )\n\nengine.execute(AlterColumn(table.c.mycolumn, \"SET DEFAULT 'test'\"))\n```", "```py\nfrom sqlalchemy.engine.reflection import Inspector\n\ninsp = Inspector.from_engine(my_engine)\n\nprint(insp.get_schema_names())\n```", "```py\nmy_engine = create_engine(\"postgresql://...\")\npg_insp = Inspector.from_engine(my_engine)\n\nprint(pg_insp.get_table_oid(\"my_table\"))\n```", "```py\nresult = connection.execute(\n    table.insert().values(data=\"some data\").returning(table.c.id, table.c.timestamp)\n)\nrow = result.first()\nprint(\"ID:\", row[\"id\"], \"Timestamp:\", row[\"timestamp\"])\n```", "```py\nclass UTF8Encoded(TypeDecorator):\n  \"\"\"Unicode type which coerces to utf-8.\"\"\"\n\n    impl = sa.VARCHAR\n\n    def process_result_value(self, value, dialect):\n        if isinstance(value, unicode):\n            value = value.encode(\"utf-8\")\n        return value\n```", "```py\n>>> String(50)._compare_type_affinity(postgresql.VARCHAR(50))\nTrue\n>>> Integer()._compare_type_affinity(mysql.REAL)\nFalse\n```", "```py\nclass UTF8Encoded(TypeDecorator):\n  \"\"\"Unicode type which coerces to utf-8.\"\"\"\n\n    impl = sa.VARCHAR\n\n    def process_result_value(self, value, dialect):\n        if isinstance(value, unicode):\n            value = value.encode(\"utf-8\")\n        return value\n```", "```py\n>>> String(50)._compare_type_affinity(postgresql.VARCHAR(50))\nTrue\n>>> Integer()._compare_type_affinity(mysql.REAL)\nFalse\n```", "```py and ```", "```py options as well as the ```", "```py setting on ```", "```py, ```", "```py is now ```", "```py, ```", "```py/```", "```py options are now superseded by ```", "```py and ```", "```py. The old names will hang around for the foreseeable future just like ```", "```py now accepts ```", "```py option on ```", "```py are now ```", "```py for lazy loading (via a SELECT issued on attribute access), ```", "```py for joined-eager loading, ```", "```py for subquery-eager loading, ```", "```py for no loading should occur, and ```", "```py for a \u201cdynamic\u201d relationship. The old ```", "```py, ```", "```py, ```", "```py\nmapper(Child, child)\nmapper(\n    Parent,\n    parent,\n    properties={\"child\": relationship(Child, lazy=\"joined\", innerjoin=True)},\n)\n```", "```py\nsession.query(Parent).options(joinedload(Parent.child, innerjoin=True)).all()\n```", "```py\n    session.query(Address).options(eagerload(Address.user)).limit(10)\n    ```", "```py\n    SELECT  *  FROM\n      (SELECT  *  FROM  addresses  LIMIT  10)  AS  anon_1\n      LEFT  OUTER  JOIN  users  AS  users_1  ON  users_1.id  =  anon_1.addresses_user_id\n    ```", "```py\n    SELECT  *  FROM  addresses  LEFT  OUTER  JOIN  users  AS  users_1  ON  users_1.id  =  addresses.user_id  LIMIT  10\n    ```", "```py and ```", "```py options as well as the ```", "```py setting on ```", "```py, ```", "```py is now ```", "```py, ```", "```py/```", "```py options are now superseded by ```", "```py and ```", "```py. The old names will hang around for the foreseeable future just like ```", "```py now accepts ```", "```py option on ```", "```py are now ```", "```py for lazy loading (via a SELECT issued on attribute access), ```", "```py for joined-eager loading, ```", "```py for subquery-eager loading, ```", "```py for no loading should occur, and ```", "```py for a \u201cdynamic\u201d relationship. The old ```", "```py, ```", "```py, ```", "```py\nmapper(Child, child)\nmapper(\n    Parent,\n    parent,\n    properties={\"child\": relationship(Child, lazy=\"joined\", innerjoin=True)},\n)\n```", "```py\nsession.query(Parent).options(joinedload(Parent.child, innerjoin=True)).all()\n```", "```py\n    session.query(Address).options(eagerload(Address.user)).limit(10)\n    ```", "```py\n    SELECT  *  FROM\n      (SELECT  *  FROM  addresses  LIMIT  10)  AS  anon_1\n      LEFT  OUTER  JOIN  users  AS  users_1  ON  users_1.id  =  anon_1.addresses_user_id\n    ```", "```py\n    SELECT  *  FROM  addresses  LEFT  OUTER  JOIN  users  AS  users_1  ON  users_1.id  =  addresses.user_id  LIMIT  10\n    ```"]