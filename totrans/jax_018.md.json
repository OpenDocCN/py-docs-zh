["```py\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nx_np = np.linspace(0, 10, 1000)\ny_np = 2 * np.sin(x_np) * np.cos(x_np)\nplt.plot(x_np, y_np); \n```", "```py\nimport jax.numpy as jnp\n\nx_jnp = jnp.linspace(0, 10, 1000)\ny_jnp = 2 * jnp.sin(x_jnp) * jnp.cos(x_jnp)\nplt.plot(x_jnp, y_jnp); \n```", "```py\ntype(x_np) \n```", "```py\nnumpy.ndarray \n```", "```py\ntype(x_jnp) \n```", "```py\njaxlib.xla_extension.ArrayImpl \n```", "```py\n# NumPy: mutable arrays\nx = np.arange(10)\nx[0] = 10\nprint(x) \n```", "```py\n[10  1  2  3  4  5  6  7  8  9] \n```", "```py\n%xmode minimal \n```", "```py\nException reporting mode: Minimal \n```", "```py\n# JAX: immutable arrays\nx = jnp.arange(10)\nx[0] = 10 \n```", "```py\nTypeError: '<class 'jaxlib.xla_extension.ArrayImpl'>' object does not support item assignment. JAX arrays are immutable. Instead of ``x[idx] = y``, use ``x = x.at[idx].set(y)`` or another .at[] method: https://jax.readthedocs.io/en/latest/_autosummary/jax.numpy.ndarray.at.html \n```", "```py\ny = x.at[0].set(10)\nprint(x)\nprint(y) \n```", "```py\n[0 1 2 3 4 5 6 7 8 9]\n[10  1  2  3  4  5  6  7  8  9] \n```", "```py\nimport jax.numpy as jnp\njnp.add(1, 1.0)  # jax.numpy API implicitly promotes mixed types. \n```", "```py\nArray(2., dtype=float32, weak_type=True) \n```", "```py\nfrom jax import lax\nlax.add(1, 1.0)  # jax.lax API requires explicit type promotion. \n```", "```py\nMLIRError: Verification failed:\nerror: \"jit(add)/jit(main)/add\"(callsite(\"<module>\"(\"/tmp/ipykernel_2814/3435837498.py\":2:0) at callsite(\"run_code\"(\"/home/docs/checkouts/readthedocs.org/user_builds/jax/envs/latest/lib/python3.10/site-packages/IPython/core/interactiveshell.py\":3577:0) at callsite(\"run_ast_nodes\"(\"/home/docs/checkouts/readthedocs.org/user_builds/jax/envs/latest/lib/python3.10/site-packages/IPython/core/interactiveshell.py\":3517:0) at callsite(\"run_cell_async\"(\"/home/docs/checkouts/readthedocs.org/user_builds/jax/envs/latest/lib/python3.10/site-packages/IPython/core/interactiveshell.py\":3334:0) at callsite(\"_pseudo_sync_runner\"(\"/home/docs/checkouts/readthedocs.org/user_builds/jax/envs/latest/lib/python3.10/site-packages/IPython/core/async_helpers.py\":129:0) at callsite(\"_run_cell\"(\"/home/docs/checkouts/readthedocs.org/user_builds/jax/envs/latest/lib/python3.10/site-packages/IPython/core/interactiveshell.py\":3130:0) at callsite(\"run_cell\"(\"/home/docs/checkouts/readthedocs.org/user_builds/jax/envs/latest/lib/python3.10/site-packages/IPython/core/interactiveshell.py\":3075:0) at callsite(\"run_cell\"(\"/home/docs/checkouts/readthedocs.org/user_builds/jax/envs/latest/lib/python3.10/site-packages/ipykernel/zmqshell.py\":549:0) at callsite(\"do_execute\"(\"/home/docs/checkouts/readthedocs.org/user_builds/jax/envs/latest/lib/python3.10/site-packages/ipykernel/ipkernel.py\":449:0) at \"execute_request\"(\"/home/docs/checkouts/readthedocs.org/user_builds/jax/envs/latest/lib/python3.10/site-packages/ipykernel/kernelbase.py\":778:0))))))))))): op requires the same element type for all operands and results\n\nThe above exception was the direct cause of the following exception:\n\nValueError: Cannot lower jaxpr with verifier errors:\n\top requires the same element type for all operands and results\n\t\tat loc(\"jit(add)/jit(main)/add\"(callsite(\"<module>\"(\"/tmp/ipykernel_2814/3435837498.py\":2:0) at callsite(\"run_code\"(\"/home/docs/checkouts/readthedocs.org/user_builds/jax/envs/latest/lib/python3.10/site-packages/IPython/core/interactiveshell.py\":3577:0) at callsite(\"run_ast_nodes\"(\"/home/docs/checkouts/readthedocs.org/user_builds/jax/envs/latest/lib/python3.10/site-packages/IPython/core/interactiveshell.py\":3517:0) at callsite(\"run_cell_async\"(\"/home/docs/checkouts/readthedocs.org/user_builds/jax/envs/latest/lib/python3.10/site-packages/IPython/core/interactiveshell.py\":3334:0) at callsite(\"_pseudo_sync_runner\"(\"/home/docs/checkouts/readthedocs.org/user_builds/jax/envs/latest/lib/python3.10/site-packages/IPython/core/async_helpers.py\":129:0) at callsite(\"_run_cell\"(\"/home/docs/checkouts/readthedocs.org/user_builds/jax/envs/latest/lib/python3.10/site-packages/IPython/core/interactiveshell.py\":3130:0) at callsite(\"run_cell\"(\"/home/docs/checkouts/readthedocs.org/user_builds/jax/envs/latest/lib/python3.10/site-packages/IPython/core/interactiveshell.py\":3075:0) at callsite(\"run_cell\"(\"/home/docs/checkouts/readthedocs.org/user_builds/jax/envs/latest/lib/python3.10/site-packages/ipykernel/zmqshell.py\":549:0) at callsite(\"do_execute\"(\"/home/docs/checkouts/readthedocs.org/user_builds/jax/envs/latest/lib/python3.10/site-packages/ipykernel/ipkernel.py\":449:0) at \"execute_request\"(\"/home/docs/checkouts/readthedocs.org/user_builds/jax/envs/latest/lib/python3.10/site-packages/ipykernel/kernelbase.py\":778:0))))))))))))\nDefine JAX_DUMP_IR_TO to dump the module. \n```", "```py\nlax.add(jnp.float32(1), 1.0) \n```", "```py\nArray(2., dtype=float32) \n```", "```py\nx = jnp.array([1, 2, 1])\ny = jnp.ones(10)\njnp.convolve(x, y) \n```", "```py\nArray([1., 3., 4., 4., 4., 4., 4., 4., 4., 4., 3., 1.], dtype=float32) \n```", "```py\nfrom jax import lax\nresult = lax.conv_general_dilated(\n    x.reshape(1, 1, 3).astype(float),  # note: explicit promotion\n    y.reshape(1, 1, 10),\n    window_strides=(1,),\n    padding=[(len(y) - 1, len(y) - 1)])  # equivalent of padding='full' in NumPy\nresult[0, 0] \n```", "```py\nArray([1., 3., 4., 4., 4., 4., 4., 4., 4., 4., 3., 1.], dtype=float32) \n```", "```py\nimport jax.numpy as jnp\n\ndef norm(X):\n  X = X - X.mean(0)\n  return X / X.std(0) \n```", "```py\nfrom jax import jit\nnorm_compiled = jit(norm) \n```", "```py\nnp.random.seed(1701)\nX = jnp.array(np.random.rand(10000, 10))\nnp.allclose(norm(X), norm_compiled(X), atol=1E-6) \n```", "```py\nTrue \n```", "```py\n%timeit norm(X).block_until_ready()\n%timeit norm_compiled(X).block_until_ready() \n```", "```py\n319 μs ± 1.98 μs per loop (mean ± std. dev. of 7 runs, 1,000 loops each)\n272 μs ± 849 ns per loop (mean ± std. dev. of 7 runs, 1,000 loops each) \n```", "```py\ndef get_negatives(x):\n  return x[x < 0]\n\nx = jnp.array(np.random.randn(10))\nget_negatives(x) \n```", "```py\nArray([-0.10570311, -0.59403396, -0.8680282 , -0.23489487], dtype=float32) \n```", "```py\njit(get_negatives)(x) \n```", "```py\nNonConcreteBooleanIndexError: Array boolean indices must be concrete; got ShapedArray(bool[10])\n\nSee https://jax.readthedocs.io/en/latest/errors.html#jax.errors.NonConcreteBooleanIndexError \n```", "```py\n@jit\ndef f(x, y):\n  print(\"Running f():\")\n  print(f\"  x = {x}\")\n  print(f\"  y = {y}\")\n  result = jnp.dot(x + 1, y + 1)\n  print(f\"  result = {result}\")\n  return result\n\nx = np.random.randn(3, 4)\ny = np.random.randn(4)\nf(x, y) \n```", "```py\nRunning f():\n  x = Traced<ShapedArray(float32[3,4])>with<DynamicJaxprTrace(level=1/0)>\n  y = Traced<ShapedArray(float32[4])>with<DynamicJaxprTrace(level=1/0)>\n  result = Traced<ShapedArray(float32[3])>with<DynamicJaxprTrace(level=1/0)> \n```", "```py\nArray([0.25773212, 5.3623195 , 5.403243  ], dtype=float32) \n```", "```py\nx2 = np.random.randn(3, 4)\ny2 = np.random.randn(4)\nf(x2, y2) \n```", "```py\nArray([1.4344584, 4.3004413, 7.9897013], dtype=float32) \n```", "```py\nfrom jax import make_jaxpr\n\ndef f(x, y):\n  return jnp.dot(x + 1, y + 1)\n\nmake_jaxpr(f)(x, y) \n```", "```py\n{ lambda ; a:f32[3,4] b:f32[4]. let\n    c:f32[3,4] = add a 1.0\n    d:f32[4] = add b 1.0\n    e:f32[3] = dot_general[\n      dimension_numbers=(([1], [0]), ([], []))\n      preferred_element_type=float32\n    ] c d\n  in (e,) } \n```", "```py\n@jit\ndef f(x, neg):\n  return -x if neg else x\n\nf(1, True) \n```", "```py\nTracerBoolConversionError: Attempted boolean conversion of traced array with shape bool[]..\nThe error occurred while tracing the function f at /tmp/ipykernel_2814/2422663986.py:1 for jit. This concrete value was not available in Python because it depends on the value of the argument neg.\nSee https://jax.readthedocs.io/en/latest/errors.html#jax.errors.TracerBoolConversionError \n```", "```py\nfrom functools import partial\n\n@partial(jit, static_argnums=(1,))\ndef f(x, neg):\n  return -x if neg else x\n\nf(1, True) \n```", "```py\nArray(-1, dtype=int32, weak_type=True) \n```", "```py\nf(1, False) \n```", "```py\nArray(1, dtype=int32, weak_type=True) \n```", "```py\nimport jax.numpy as jnp\nfrom jax import jit\n\n@jit\ndef f(x):\n  return x.reshape(jnp.array(x.shape).prod())\n\nx = jnp.ones((2, 3))\nf(x) \n```", "```py\nTypeError: Shapes must be 1D sequences of concrete values of integer type, got [Traced<ShapedArray(int32[])>with<DynamicJaxprTrace(level=1/0)>].\nIf using `jit`, try using `static_argnums` or applying `jit` to smaller subfunctions.\nThe error occurred while tracing the function f at /tmp/ipykernel_2814/1983583872.py:4 for jit. This value became a tracer due to JAX operations on these lines:\n\n  operation a:i32[2] = convert_element_type[new_dtype=int32 weak_type=False] b\n    from line /tmp/ipykernel_2814/1983583872.py:6 (f) \n```", "```py\n@jit\ndef f(x):\n  print(f\"x = {x}\")\n  print(f\"x.shape = {x.shape}\")\n  print(f\"jnp.array(x.shape).prod() = {jnp.array(x.shape).prod()}\")\n  # comment this out to avoid the error:\n  # return x.reshape(jnp.array(x.shape).prod())\n\nf(x) \n```", "```py\nx = Traced<ShapedArray(float32[2,3])>with<DynamicJaxprTrace(level=1/0)>\nx.shape = (2, 3)\njnp.array(x.shape).prod() = Traced<ShapedArray(int32[])>with<DynamicJaxprTrace(level=1/0)> \n```", "```py\nfrom jax import jit\nimport jax.numpy as jnp\nimport numpy as np\n\n@jit\ndef f(x):\n  return x.reshape((np.prod(x.shape),))\n\nf(x) \n```", "```py\nArray([1., 1., 1., 1., 1., 1.], dtype=float32) \n```"]