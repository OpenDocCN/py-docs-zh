["```py\nimport sys, pymupdf  # import the bindings\nfname = sys.argv[1]  # get filename from command line\ndoc = pymupdf.open(fname)  # open document\nfor page in doc:  # iterate through the pages\n    pix = page.get_pixmap()  # render page to an image\n    pix.save(\"page-%i.png\" % page.number)  # store image as a PNG \n```", "```py\nzoom_x = 2.0  # horizontal zoom\nzoom_y = 2.0  # vertical zoom\nmat = pymupdf.Matrix(zoom_x, zoom_y)  # zoom factor 2 in each dimension\npix = page.get_pixmap(matrix=mat)  # use 'mat' instead of the identity matrix \n```", "```py\nmat = pymupdf.Matrix(2, 2)  # zoom factor 2 in each direction\nrect = page.rect  # the page rectangle\nmp = (rect.tl + rect.br) / 2  # its middle point, becomes top-left of clip\nclip = pymupdf.Rect(mp, rect.br)  # the area we want\npix = page.get_pixmap(matrix=mat, clip=clip) \n```", "```py\n# WIDTH: width of the GUI window\n# HEIGHT: height of the GUI window\n# clip: a subrectangle of the document page\n# compare width/height ratios of image and window\n\nif clip.width / clip.height < WIDTH / HEIGHT:\n    # clip is narrower: zoom to window HEIGHT\n    zoom = HEIGHT / clip.height\nelse:  # clip is broader: zoom to window WIDTH\n    zoom = WIDTH / clip.width\nmat = pymupdf.Matrix(zoom, zoom)\npix = page.get_pixmap(matrix=mat, clip=clip) \n```", "```py\nwidth = WIDTH / zoom\nheight = HEIGHT / zoom\nclip = pymupdf.Rect(tl, tl.x + width, tl.y + height)\n# ensure we still are inside the page\nclip &= page.rect\nmat = pymupdf.Matrix(zoom, zoom)\npix = pymupdf.Pixmap(matrix=mat, clip=clip) \n```", "```py\n    >>> pdfbytes = doc.convert_to_pdf()  # this a bytes object\n    >>> pdf = pymupdf.open(\"pdf\", pdfbytes)  # open it as a PDF document\n    >>> # now use 'pdf' like any PDF document \n    ```", "```py\n    >>> d = page.get_text(\"dict\")\n    >>> blocks = d[\"blocks\"]  # the list of block dictionaries\n    >>> imgblocks = [b for b in blocks if b[\"type\"] == 1]\n    >>> pprint(imgblocks[0])\n    {'bbox': (100.0, 135.8769989013672, 300.0, 364.1230163574219),\n     'bpc': 8,\n     'colorspace': 3,\n     'ext': 'jpeg',\n     'height': 501,\n     'image': b'\\xff\\xd8\\xff\\xe0\\x00\\x10JFIF\\...',  # CAUTION: LARGE!\n     'size': 80518,\n     'transform': (200.0, 0.0, -0.0, 228.2460174560547, 100.0, 135.8769989013672),\n     'type': 1,\n     'width': 439,\n     'xres': 96,\n     'yres': 96} \n    ```", "```py\n>>> pix1 = pymupdf.Pixmap(doc.extract_image(xref)[\"image\"])    # (1) pixmap of image w/o alpha\n>>> mask = pymupdf.Pixmap(doc.extract_image(smask)[\"image\"])   # (2) mask pixmap\n>>> pix = pymupdf.Pixmap(pix1, mask)                           # (3) copy of pix1, image mask added \n```", "```py\nimport os, pymupdf\nimport PySimpleGUI as psg  # for showing a progress bar\ndoc = pymupdf.open()  # PDF with the pictures\nimgdir = \"D:/2012_10_05\"  # where the pics are\nimglist = os.listdir(imgdir)  # list of them\nimgcount = len(imglist)  # pic count\n\nfor i, f in enumerate(imglist):\n    img = pymupdf.open(os.path.join(imgdir, f))  # open pic as document\n    rect = img[0].rect  # pic dimension\n    pdfbytes = img.convert_to_pdf()  # make a PDF stream\n    img.close()  # no longer needed\n    imgPDF = pymupdf.open(\"pdf\", pdfbytes)  # open stream as PDF\n    page = doc.new_page(width = rect.width,  # new page with ...\n                       height = rect.height)  # pic dimension\n    page.show_pdf_page(rect, imgPDF, 0)  # image fills the page\n    psg.EasyProgressMeter(\"Import Images\",  # show our progress\n        i+1, imgcount)\n\ndoc.save(\"all-my-pics.pdf\") \n```", "```py\nimport os, pymupdf\nimport PySimpleGUI as psg  # for showing progress bar\ndoc = pymupdf.open()  # PDF with the pictures\nimgdir = \"D:/2012_10_05\"  # where my files are\n\nimglist = os.listdir(imgdir)  # list of pictures\nimgcount = len(imglist)  # pic count\nimglist.sort()  # nicely sort them\n\nfor i, f in enumerate(imglist):\n    img = open(os.path.join(imgdir,f), \"rb\").read()  # make pic stream\n    doc.embfile_add(img, f, filename=f,  # and embed it\n                        ufilename=f, desc=f)\n    psg.EasyProgressMeter(\"Embedding Files\",  # show our progress\n        i+1, imgcount)\n\npage = doc.new_page()  # at least 1 page is needed\n\ndoc.save(\"all-my-pics-embedded.pdf\") \n```", "```py\npix = pymupdf.Pixmap(\"input.xxx\")  # any supported input format\npix.save(\"output.yyy\")  # any supported output format \n```", "```py\npix = pymupdf.Pixmap(\"myfamily.jpg\")\npix.save(\"myfamily.psd\") \n```", "```py\nimport tkinter as tk\npix = pymupdf.Pixmap(\"input.jpg\")  # or any RGB / no-alpha image\ntkimg = tk.PhotoImage(data=pix.tobytes(\"ppm\")) \n```", "```py\nimport tkinter as tk\npix = pymupdf.Pixmap(\"input.png\")  # may have an alpha channel\nif pix.alpha:  # we have an alpha channel!\n    pix = pymupdf.Pixmap(pix, 0)  # remove it\ntkimg = tk.PhotoImage(data=pix.tobytes(\"ppm\")) \n```", "```py\nimport pymupdf\nsrc = pymupdf.Pixmap(\"img-7edges.png\")      # create pixmap from a picture\ncol = 3                                  # tiles per row\nlin = 4                                  # tiles per column\ntar_w = src.width * col                  # width of target\ntar_h = src.height * lin                 # height of target\n\n# create target pixmap\ntar_pix = pymupdf.Pixmap(src.colorspace, (0, 0, tar_w, tar_h), src.alpha)\n\n# now fill target with the tiles\nfor i in range(col):\n    for j in range(lin):\n        src.set_origin(src.width * i, src.height * j)\n        tar_pix.copy(src, src.irect) # copy input to new loc\n\ntar_pix.save(\"tar.png\") \n```", "```py\nimport pymupdf, time\nif not list(map(int, pymupdf.VersionBind.split(\".\"))) >= [1, 14, 8]:\n    raise SystemExit(\"need PyMuPDF v1.14.8 for this script\")\nn = 6                             # depth (precision)\nd = 3**n                          # edge length\n\nt0 = time.perf_counter()\nir = (0, 0, d, d)                 # the pixmap rectangle\n\npm = pymupdf.Pixmap(pymupdf.csRGB, ir, False)\npm.set_rect(pm.irect, (255,255,0)) # fill it with some background color\n\ncolor = (0, 0, 255)               # color to fill the punch holes\n\n# alternatively, define a 'fill' pixmap for the punch holes\n# this could be anything, e.g. some photo image ...\nfill = pymupdf.Pixmap(pymupdf.csRGB, ir, False) # same size as 'pm'\nfill.set_rect(fill.irect, (0, 255, 255))   # put some color in\n\ndef punch(x, y, step):\n  \"\"\"Recursively \"punch a hole\" in the central square of a pixmap.\n\n Arguments are top-left coords and the step width.\n\n Some alternative punching methods are commented out.\n \"\"\"\n    s = step // 3                 # the new step\n    # iterate through the 9 sub-squares\n    # the central one will be filled with the color\n    for i in range(3):\n        for j in range(3):\n            if i != j or i != 1:  # this is not the central cube\n                if s >= 3:        # recursing needed?\n                    punch(x+i*s, y+j*s, s)       # recurse\n            else:                 # punching alternatives are:\n                pm.set_rect((x+s, y+s, x+2*s, y+2*s), color)     # fill with a color\n                #pm.copy(fill, (x+s, y+s, x+2*s, y+2*s))  # copy from fill\n                #pm.invert_irect((x+s, y+s, x+2*s, y+2*s))       # invert colors\n\n    return\n\n#==============================================================================\n# main program\n#==============================================================================\n# now start punching holes into the pixmap\npunch(0, 0, d)\nt1 = time.perf_counter()\npm.save(\"sierpinski-punch.png\")\nt2 = time.perf_counter()\nprint (\"%g sec to create / fill the pixmap\" % round(t1-t0,3))\nprint (\"%g sec to save the image\" % round(t2-t1,3)) \n```", "```py\nimport numpy as np\nimport pymupdf\n#==============================================================================\n# create a fun-colored width * height PNG with pymupdf and numpy\n#==============================================================================\nheight = 150\nwidth  = 100\nbild = np.ndarray((height, width, 3), dtype=np.uint8)\n\nfor i in range(height):\n    for j in range(width):\n        # one pixel (some fun coloring)\n        bild[i, j] = [(i+j)%256, i%256, j%256]\n\nsamples = bytearray(bild.tostring())    # get plain pixel data from numpy array\npix = pymupdf.Pixmap(pymupdf.csRGB, width, height, samples, alpha=False)\npix.save(\"test.png\") \n```", "```py\npage.insert_image(\n    rect,                  # where to place the image (rect-like)\n    filename=None,         # image in a file\n    stream=None,           # image in memory (bytes)\n    pixmap=None,           # image from pixmap\n    mask=None,             # specify alpha channel separately\n    rotate=0,              # rotate (int, multiple of 90)\n    xref=0,                # re-use existing image\n    oc=0,                  # control visibility via OCG / OCMD\n    keep_proportion=True,  # keep aspect ratio\n    overlay=True,          # put in foreground\n) \n```", "```py\npage.show_pdf_page(\n    rect,                  # where to place the image (rect-like)\n    src,                   # source PDF\n    pno=0,                 # page number in source PDF\n    clip=None,             # only display this area (rect-like)\n    rotate=0,              # rotate (float, any value)\n    oc=0,                  # control visibility via OCG / OCMD\n    keep_proportion=True,  # keep aspect ratio\n    overlay=True,          # put in foreground\n) \n```", "```py\npix = page.get_pixmap(dpi=150)  # make page image with a decent resolution\n\n# the following matrix transforms page to pixmap coordinates\nmat = page.rect.torect(pix.irect)\n\n# search for some string \"needle\"\nrlist = page.search_for(\"needle\")\n# check the visibility for each hit rectangle\nfor rect in rlist:\n    if pix.color_topusage(clip=rect * mat)[0] > 0.95:\n        print(\"'needle' is invisible here:\", rect) \n```", "```py\nimport sys, pymupdf  # import the bindings\nfname = sys.argv[1]  # get filename from command line\ndoc = pymupdf.open(fname)  # open document\nfor page in doc:  # iterate through the pages\n    pix = page.get_pixmap()  # render page to an image\n    pix.save(\"page-%i.png\" % page.number)  # store image as a PNG \n```", "```py\nzoom_x = 2.0  # horizontal zoom\nzoom_y = 2.0  # vertical zoom\nmat = pymupdf.Matrix(zoom_x, zoom_y)  # zoom factor 2 in each dimension\npix = page.get_pixmap(matrix=mat)  # use 'mat' instead of the identity matrix \n```", "```py\nmat = pymupdf.Matrix(2, 2)  # zoom factor 2 in each direction\nrect = page.rect  # the page rectangle\nmp = (rect.tl + rect.br) / 2  # its middle point, becomes top-left of clip\nclip = pymupdf.Rect(mp, rect.br)  # the area we want\npix = page.get_pixmap(matrix=mat, clip=clip) \n```", "```py\n# WIDTH: width of the GUI window\n# HEIGHT: height of the GUI window\n# clip: a subrectangle of the document page\n# compare width/height ratios of image and window\n\nif clip.width / clip.height < WIDTH / HEIGHT:\n    # clip is narrower: zoom to window HEIGHT\n    zoom = HEIGHT / clip.height\nelse:  # clip is broader: zoom to window WIDTH\n    zoom = WIDTH / clip.width\nmat = pymupdf.Matrix(zoom, zoom)\npix = page.get_pixmap(matrix=mat, clip=clip) \n```", "```py\nwidth = WIDTH / zoom\nheight = HEIGHT / zoom\nclip = pymupdf.Rect(tl, tl.x + width, tl.y + height)\n# ensure we still are inside the page\nclip &= page.rect\nmat = pymupdf.Matrix(zoom, zoom)\npix = pymupdf.Pixmap(matrix=mat, clip=clip) \n```", "```py\n    >>> pdfbytes = doc.convert_to_pdf()  # this a bytes object\n    >>> pdf = pymupdf.open(\"pdf\", pdfbytes)  # open it as a PDF document\n    >>> # now use 'pdf' like any PDF document \n    ```", "```py\n    >>> d = page.get_text(\"dict\")\n    >>> blocks = d[\"blocks\"]  # the list of block dictionaries\n    >>> imgblocks = [b for b in blocks if b[\"type\"] == 1]\n    >>> pprint(imgblocks[0])\n    {'bbox': (100.0, 135.8769989013672, 300.0, 364.1230163574219),\n     'bpc': 8,\n     'colorspace': 3,\n     'ext': 'jpeg',\n     'height': 501,\n     'image': b'\\xff\\xd8\\xff\\xe0\\x00\\x10JFIF\\...',  # CAUTION: LARGE!\n     'size': 80518,\n     'transform': (200.0, 0.0, -0.0, 228.2460174560547, 100.0, 135.8769989013672),\n     'type': 1,\n     'width': 439,\n     'xres': 96,\n     'yres': 96} \n    ```", "```py\n>>> pix1 = pymupdf.Pixmap(doc.extract_image(xref)[\"image\"])    # (1) pixmap of image w/o alpha\n>>> mask = pymupdf.Pixmap(doc.extract_image(smask)[\"image\"])   # (2) mask pixmap\n>>> pix = pymupdf.Pixmap(pix1, mask)                           # (3) copy of pix1, image mask added \n```", "```py\nimport os, pymupdf\nimport PySimpleGUI as psg  # for showing a progress bar\ndoc = pymupdf.open()  # PDF with the pictures\nimgdir = \"D:/2012_10_05\"  # where the pics are\nimglist = os.listdir(imgdir)  # list of them\nimgcount = len(imglist)  # pic count\n\nfor i, f in enumerate(imglist):\n    img = pymupdf.open(os.path.join(imgdir, f))  # open pic as document\n    rect = img[0].rect  # pic dimension\n    pdfbytes = img.convert_to_pdf()  # make a PDF stream\n    img.close()  # no longer needed\n    imgPDF = pymupdf.open(\"pdf\", pdfbytes)  # open stream as PDF\n    page = doc.new_page(width = rect.width,  # new page with ...\n                       height = rect.height)  # pic dimension\n    page.show_pdf_page(rect, imgPDF, 0)  # image fills the page\n    psg.EasyProgressMeter(\"Import Images\",  # show our progress\n        i+1, imgcount)\n\ndoc.save(\"all-my-pics.pdf\") \n```", "```py\nimport os, pymupdf\nimport PySimpleGUI as psg  # for showing progress bar\ndoc = pymupdf.open()  # PDF with the pictures\nimgdir = \"D:/2012_10_05\"  # where my files are\n\nimglist = os.listdir(imgdir)  # list of pictures\nimgcount = len(imglist)  # pic count\nimglist.sort()  # nicely sort them\n\nfor i, f in enumerate(imglist):\n    img = open(os.path.join(imgdir,f), \"rb\").read()  # make pic stream\n    doc.embfile_add(img, f, filename=f,  # and embed it\n                        ufilename=f, desc=f)\n    psg.EasyProgressMeter(\"Embedding Files\",  # show our progress\n        i+1, imgcount)\n\npage = doc.new_page()  # at least 1 page is needed\n\ndoc.save(\"all-my-pics-embedded.pdf\") \n```", "```py\npix = pymupdf.Pixmap(\"input.xxx\")  # any supported input format\npix.save(\"output.yyy\")  # any supported output format \n```", "```py\npix = pymupdf.Pixmap(\"myfamily.jpg\")\npix.save(\"myfamily.psd\") \n```", "```py\nimport tkinter as tk\npix = pymupdf.Pixmap(\"input.jpg\")  # or any RGB / no-alpha image\ntkimg = tk.PhotoImage(data=pix.tobytes(\"ppm\")) \n```", "```py\nimport tkinter as tk\npix = pymupdf.Pixmap(\"input.png\")  # may have an alpha channel\nif pix.alpha:  # we have an alpha channel!\n    pix = pymupdf.Pixmap(pix, 0)  # remove it\ntkimg = tk.PhotoImage(data=pix.tobytes(\"ppm\")) \n```", "```py\nimport pymupdf\nsrc = pymupdf.Pixmap(\"img-7edges.png\")      # create pixmap from a picture\ncol = 3                                  # tiles per row\nlin = 4                                  # tiles per column\ntar_w = src.width * col                  # width of target\ntar_h = src.height * lin                 # height of target\n\n# create target pixmap\ntar_pix = pymupdf.Pixmap(src.colorspace, (0, 0, tar_w, tar_h), src.alpha)\n\n# now fill target with the tiles\nfor i in range(col):\n    for j in range(lin):\n        src.set_origin(src.width * i, src.height * j)\n        tar_pix.copy(src, src.irect) # copy input to new loc\n\ntar_pix.save(\"tar.png\") \n```", "```py\nimport pymupdf, time\nif not list(map(int, pymupdf.VersionBind.split(\".\"))) >= [1, 14, 8]:\n    raise SystemExit(\"need PyMuPDF v1.14.8 for this script\")\nn = 6                             # depth (precision)\nd = 3**n                          # edge length\n\nt0 = time.perf_counter()\nir = (0, 0, d, d)                 # the pixmap rectangle\n\npm = pymupdf.Pixmap(pymupdf.csRGB, ir, False)\npm.set_rect(pm.irect, (255,255,0)) # fill it with some background color\n\ncolor = (0, 0, 255)               # color to fill the punch holes\n\n# alternatively, define a 'fill' pixmap for the punch holes\n# this could be anything, e.g. some photo image ...\nfill = pymupdf.Pixmap(pymupdf.csRGB, ir, False) # same size as 'pm'\nfill.set_rect(fill.irect, (0, 255, 255))   # put some color in\n\ndef punch(x, y, step):\n  \"\"\"Recursively \"punch a hole\" in the central square of a pixmap.\n\n Arguments are top-left coords and the step width.\n\n Some alternative punching methods are commented out.\n \"\"\"\n    s = step // 3                 # the new step\n    # iterate through the 9 sub-squares\n    # the central one will be filled with the color\n    for i in range(3):\n        for j in range(3):\n            if i != j or i != 1:  # this is not the central cube\n                if s >= 3:        # recursing needed?\n                    punch(x+i*s, y+j*s, s)       # recurse\n            else:                 # punching alternatives are:\n                pm.set_rect((x+s, y+s, x+2*s, y+2*s), color)     # fill with a color\n                #pm.copy(fill, (x+s, y+s, x+2*s, y+2*s))  # copy from fill\n                #pm.invert_irect((x+s, y+s, x+2*s, y+2*s))       # invert colors\n\n    return\n\n#==============================================================================\n# main program\n#==============================================================================\n# now start punching holes into the pixmap\npunch(0, 0, d)\nt1 = time.perf_counter()\npm.save(\"sierpinski-punch.png\")\nt2 = time.perf_counter()\nprint (\"%g sec to create / fill the pixmap\" % round(t1-t0,3))\nprint (\"%g sec to save the image\" % round(t2-t1,3)) \n```", "```py\nimport numpy as np\nimport pymupdf\n#==============================================================================\n# create a fun-colored width * height PNG with pymupdf and numpy\n#==============================================================================\nheight = 150\nwidth  = 100\nbild = np.ndarray((height, width, 3), dtype=np.uint8)\n\nfor i in range(height):\n    for j in range(width):\n        # one pixel (some fun coloring)\n        bild[i, j] = [(i+j)%256, i%256, j%256]\n\nsamples = bytearray(bild.tostring())    # get plain pixel data from numpy array\npix = pymupdf.Pixmap(pymupdf.csRGB, width, height, samples, alpha=False)\npix.save(\"test.png\") \n```", "```py\npage.insert_image(\n    rect,                  # where to place the image (rect-like)\n    filename=None,         # image in a file\n    stream=None,           # image in memory (bytes)\n    pixmap=None,           # image from pixmap\n    mask=None,             # specify alpha channel separately\n    rotate=0,              # rotate (int, multiple of 90)\n    xref=0,                # re-use existing image\n    oc=0,                  # control visibility via OCG / OCMD\n    keep_proportion=True,  # keep aspect ratio\n    overlay=True,          # put in foreground\n) \n```", "```py\npage.show_pdf_page(\n    rect,                  # where to place the image (rect-like)\n    src,                   # source PDF\n    pno=0,                 # page number in source PDF\n    clip=None,             # only display this area (rect-like)\n    rotate=0,              # rotate (float, any value)\n    oc=0,                  # control visibility via OCG / OCMD\n    keep_proportion=True,  # keep aspect ratio\n    overlay=True,          # put in foreground\n) \n```", "```py\npix = page.get_pixmap(dpi=150)  # make page image with a decent resolution\n\n# the following matrix transforms page to pixmap coordinates\nmat = page.rect.torect(pix.irect)\n\n# search for some string \"needle\"\nrlist = page.search_for(\"needle\")\n# check the visibility for each hit rectangle\nfor rect in rlist:\n    if pix.color_topusage(clip=rect * mat)[0] > 0.95:\n        print(\"'needle' is invisible here:\", rect) \n```"]