- en: What’s New in SQLAlchemy 1.0?
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SQLAlchemy 1.0 中的新功能？
- en: 原文：[https://docs.sqlalchemy.org/en/20/changelog/migration_10.html](https://docs.sqlalchemy.org/en/20/changelog/migration_10.html)
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 原文：[https://docs.sqlalchemy.org/en/20/changelog/migration_10.html](https://docs.sqlalchemy.org/en/20/changelog/migration_10.html)
- en: About this Document
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 关于本文档
- en: This document describes changes between SQLAlchemy version 0.9, undergoing maintenance
    releases as of May, 2014, and SQLAlchemy version 1.0, released in April, 2015.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本文档描述了 SQLAlchemy 版本 0.9 与 2014 年 5 月维护发布的版本之间的更改，以及于 2015 年 4 月发布的版本 1.0 之间的更改。
- en: 'Document last updated: June 9, 2015'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 文档最后更新日期：2015 年 6 月 9 日
- en: Introduction
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍
- en: This guide introduces what’s new in SQLAlchemy version 1.0, and also documents
    changes which affect users migrating their applications from the 0.9 series of
    SQLAlchemy to 1.0.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本指南介绍了 SQLAlchemy 版本 1.0 中的新功能，并记录了影响用户将其应用程序从 SQLAlchemy 0.9 系列迁移到 1.0 的更改。
- en: Please carefully review the sections on behavioral changes for potentially backwards-incompatible
    changes in behavior.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 请仔细查看行为变化部分，可能会有不兼容的行为变化。
- en: New Features and Improvements - ORM
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 新功能和改进 - ORM
- en: New Session Bulk INSERT/UPDATE API
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 新会话批量插入/更新 API
- en: A new series of [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    methods which provide hooks directly into the unit of work’s facility for emitting
    INSERT and UPDATE statements has been created. When used correctly, this expert-oriented
    system can allow ORM-mappings to be used to generate bulk insert and update statements
    batched into executemany groups, allowing the statements to proceed at speeds
    that rival direct use of the Core.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了一系列新的 [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    方法，直接提供钩子进入工作单元的发出 INSERT 和 UPDATE 语句的功能。当正确使用时，这个面向专家的系统可以允许使用 ORM 映射生成批量插入和更新语句批量执行，使语句以与直接使用
    Core 相媲美的速度进行。
- en: See also
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Bulk Operations](../orm/persistence_techniques.html#bulk-operations) - introduction
    and full documentation'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[批量操作](../orm/persistence_techniques.html#bulk-operations) - 介绍和完整文档'
- en: '[#3100](https://www.sqlalchemy.org/trac/ticket/3100)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3100](https://www.sqlalchemy.org/trac/ticket/3100)'
- en: New Performance Example Suite
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 新性能示例套件
- en: Inspired by the benchmarking done for the [Bulk Operations](../orm/persistence_techniques.html#bulk-operations)
    feature as well as for the [How can I profile a SQLAlchemy powered application?](../faq/performance.html#faq-how-to-profile)
    section of the FAQ, a new example section has been added which features several
    scripts designed to illustrate the relative performance profile of various Core
    and ORM techniques. The scripts are organized into use cases, and are packaged
    under a single console interface such that any combination of demonstrations can
    be run, dumping out timings, Python profile results and/or RunSnake profile displays.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 受到[批量操作](../orm/persistence_techniques.html#bulk-operations)功能以及 FAQ 中的[如何对
    SQLAlchemy 驱动的应用程序进行性能分析？](../faq/performance.html#faq-how-to-profile)部分进行的基准测试的启发，添加了一个新的示例部分，其中包含几个旨在说明各种核心和
    ORM 技术的相对性能特征的脚本。这些脚本按用例组织，并打包在一个单一的控制台界面下，以便可以运行任何组合的演示，输出时间、Python 分析结果和/或 RunSnake
    分析显示。
- en: See also
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Performance](../orm/examples.html#examples-performance)'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '[性能](../orm/examples.html#examples-performance)'
- en: “Baked” Queries
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: “烘焙”查询
- en: 'The “baked” query feature is an unusual new approach which allows for straightforward
    construction an invocation of [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") objects using caching, which upon successive calls features
    vastly reduced Python function call overhead (over 75%). By specifying a [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object as a series of lambdas which are only invoked once,
    a query as a pre-compiled unit begins to be feasible:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: “烘焙”查询功能是一种不同寻常的新方法，允许使用缓存直接构建和调用 [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") 对象，通过连续调用大大减少了 Python 函数调用开销（超过 75%）。通过将一个 [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") 对象指定为一系列仅调用一次的 lambda，查询作为一个预编译单元开始变得可行：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: See also
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Baked Queries](../orm/extensions/baked.html)'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '[烘焙查询](../orm/extensions/baked.html)'
- en: '[#3054](https://www.sqlalchemy.org/trac/ticket/3054)'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3054](https://www.sqlalchemy.org/trac/ticket/3054)'
- en: '### Improvements to declarative mixins, `@declared_attr` and related features'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '### 改进声明性混合，`@declared_attr` 和相关功能'
- en: The declarative system in conjunction with [`declared_attr`](../orm/mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr") has been overhauled to support new capabilities.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 声明式系统与[`declared_attr`](../orm/mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr")结合进行了大幅改进，以支持新的功能。
- en: 'A function decorated with [`declared_attr`](../orm/mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr") is now called only **after** any mixin-based column
    copies are generated. This means the function can call upon mixin-established
    columns and will receive a reference to the correct [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") object:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 用[`declared_attr`](../orm/mapping_api.html#sqlalchemy.orm.declared_attr "sqlalchemy.orm.declared_attr")修饰的函数现在仅在生成基于混合的列副本之后才被调用。这意味着该函数可以调用混合建立的列，并将接收到正确的[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")对象的引用：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Above, `SomeClass.foobar_prop` will be invoked against `SomeClass`, and `SomeClass.foobar`
    will be the final [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    object that is to be mapped to `SomeClass`, as opposed to the non-copied object
    present directly on `HasFooBar`, even though the columns aren’t mapped yet.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述示例中，`SomeClass.foobar_prop`将针对`SomeClass`调用，并且`SomeClass.foobar`将是要映射到`SomeClass`的最终[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")对象，而不是直接出现在`HasFooBar`上的非副本对象，即使列尚未映射。
- en: 'The [`declared_attr`](../orm/mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr") function now **memoizes** the value that’s returned
    on a per-class basis, so that repeated calls to the same attribute will return
    the same value. We can alter the example to illustrate this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '[`declared_attr`](../orm/mapping_api.html#sqlalchemy.orm.declared_attr "sqlalchemy.orm.declared_attr")函数现在会根据每个类缓存返回的值，这样对同一属性的重复调用将返回相同的值。我们可以修改示例来说明这一点：'
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Previously, `SomeClass` would be mapped with one particular copy of the `foobar`
    column, but the `foobar_prop` by calling upon `foobar` a second time would produce
    a different column. The value of `SomeClass.foobar` is now memoized during declarative
    setup time, so that even before the attribute is mapped by the mapper, the interim
    column value will remain consistent no matter how many times the [`declared_attr`](../orm/mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr") is called upon.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，`SomeClass`将使用`foobar`列的特定副本进行映射，但通过第二次调用`foobar`来调用`foobar_prop`将会产生不同的列。在声明性设置时间内，`SomeClass.foobar`的值现在被记忆，因此即使在属性由映射器映射之前，每次调用[`declared_attr`](../orm/mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr")时，中间列值都将保持一致。
- en: The two behaviors above should help considerably with declarative definition
    of many types of mapper properties that derive from other attributes, where the
    [`declared_attr`](../orm/mapping_api.html#sqlalchemy.orm.declared_attr "sqlalchemy.orm.declared_attr")
    function is called upon from other [`declared_attr`](../orm/mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr") functions locally present before the class is
    actually mapped.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 上述两种行为应该极大地帮助声明式定义许多从其他属性派生的映射器属性类型，其中[`declared_attr`](../orm/mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr")函数是从其他本地[`declared_attr`](../orm/mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr")函数调用的，这些函数在类实际映射之前出现。
- en: 'For a pretty slim edge case where one wishes to build a declarative mixin that
    establishes distinct columns per subclass, a new modifier [`declared_attr.cascading`](../orm/mapping_api.html#sqlalchemy.orm.declared_attr.cascading
    "sqlalchemy.orm.declared_attr.cascading") is added. With this modifier, the decorated
    function will be invoked individually for each class in the mapped inheritance
    hierarchy. While this is already the behavior for special attributes such as `__table_args__`
    and `__mapper_args__`, for columns and other properties the behavior by default
    assumes that attribute is affixed to the base class only, and just inherited from
    subclasses. With [`declared_attr.cascading`](../orm/mapping_api.html#sqlalchemy.orm.declared_attr.cascading
    "sqlalchemy.orm.declared_attr.cascading"), individual behaviors can be applied:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个相当特殊的边缘情况，其中希望构建一个声明性混合类，为每个子类建立不同的列，添加了一个新的修饰符 [`declared_attr.cascading`](../orm/mapping_api.html#sqlalchemy.orm.declared_attr.cascading
    "sqlalchemy.orm.declared_attr.cascading")。使用此修饰符，装饰的函数将为映射继承层次结构中的每个类单独调用。虽然对于特殊属性如
    `__table_args__` 和 `__mapper_args__`，这已经是行为，但对于列和其他属性，默认情况下假定该属性仅附加到基类，并且仅从子类继承。使用
    [`declared_attr.cascading`](../orm/mapping_api.html#sqlalchemy.orm.declared_attr.cascading
    "sqlalchemy.orm.declared_attr.cascading")，可以应用个别行为：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: See also
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[Using _orm.declared_attr() to generate table-specific inheriting columns](../orm/declarative_mixins.html#mixin-inheritance-columns)'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用 _orm.declared_attr() 生成特定表继承列](../orm/declarative_mixins.html#mixin-inheritance-columns)'
- en: 'Finally, the [`AbstractConcreteBase`](../orm/extensions/declarative/index.html#sqlalchemy.ext.declarative.AbstractConcreteBase
    "sqlalchemy.ext.declarative.AbstractConcreteBase") class has been reworked so
    that a relationship or other mapper property can be set up inline on the abstract
    base:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，[`AbstractConcreteBase`](../orm/extensions/declarative/index.html#sqlalchemy.ext.declarative.AbstractConcreteBase
    "sqlalchemy.ext.declarative.AbstractConcreteBase") 类已经重新设计，以便在抽象基类上内联设置关系或其他映射器属性：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The above mapping will set up a table `cca` with both an `id` and a `something_id`
    column, and `Concrete` will also have a relationship `something`. The new feature
    is that `Abstract` will also have an independently configured relationship `something`
    that builds against the polymorphic union of the base.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 上述映射将设置一个带有 `id` 和 `something_id` 列的表 `cca`，并且 `Concrete` 还将具有一个名为 `something`
    的关系。新功能是 `Abstract` 也将具有一个独立配置的关系 `something`，该关系构建在基类的多态联合上。
- en: '[#3150](https://www.sqlalchemy.org/trac/ticket/3150) [#2670](https://www.sqlalchemy.org/trac/ticket/2670)
    [#3149](https://www.sqlalchemy.org/trac/ticket/3149) [#2952](https://www.sqlalchemy.org/trac/ticket/2952)
    [#3050](https://www.sqlalchemy.org/trac/ticket/3050)'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3150](https://www.sqlalchemy.org/trac/ticket/3150) [#2670](https://www.sqlalchemy.org/trac/ticket/2670)
    [#3149](https://www.sqlalchemy.org/trac/ticket/3149) [#2952](https://www.sqlalchemy.org/trac/ticket/2952)
    [#3050](https://www.sqlalchemy.org/trac/ticket/3050)'
- en: ORM full object fetches 25% faster
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ORM 完整对象获取速度提高 25%
- en: 'The mechanics of the `loading.py` module as well as the identity map have undergone
    several passes of inlining, refactoring, and pruning, so that a raw load of rows
    now populates ORM-based objects around 25% faster. Assuming a 1M row table, a
    script like the following illustrates the type of load that’s improved the most:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`loading.py` 模块的机制以及标识映射已经经历了几次内联、重构和修剪，因此现在原始行的加载速度大约快了 25%。假设有一个包含 100 万行的表，下面的脚本演示了改进最多的加载类型：'
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Local MacBookPro results bench from 19 seconds for 0.9 down to 14 seconds for
    1.0\. The [`Query.yield_per()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.yield_per
    "sqlalchemy.orm.Query.yield_per") call is always a good idea when batching huge
    numbers of rows, as it prevents the Python interpreter from having to allocate
    a huge amount of memory for all objects and their instrumentation at once. Without
    the [`Query.yield_per()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.yield_per
    "sqlalchemy.orm.Query.yield_per"), the above script on the MacBookPro is 31 seconds
    on 0.9 and 26 seconds on 1.0, the extra time spent setting up very large memory
    buffers.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 本地 MacBookPro 结果从 0.9 秒降至 1.0 秒的时间为 19 秒，降至 14 秒。在批量处理大量行时，[`Query.yield_per()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.yield_per
    "sqlalchemy.orm.Query.yield_per") 的调用总是一个好主意，因为它可以防止 Python 解释器一次性为所有对象及其仪器分配大量内存。没有
    [`Query.yield_per()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.yield_per
    "sqlalchemy.orm.Query.yield_per")，在 MacBookPro 上的上述脚本在 0.9 上需要 31 秒，在 1.0 上需要
    26 秒，额外的时间用于设置非常大的内存缓冲区。
- en: '### New KeyedTuple implementation dramatically faster'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '### 新的 KeyedTuple 实现速度显著提高'
- en: 'We took a look into the `KeyedTuple` implementation in the hopes of improving
    queries like this:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们研究了 `KeyedTuple` 实现，希望改进这样的查询：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `KeyedTuple` class is used rather than Python’s `collections.namedtuple()`,
    because the latter has a very complex type-creation routine that benchmarks much
    slower than `KeyedTuple`. However, when fetching hundreds of thousands of rows,
    `collections.namedtuple()` quickly overtakes `KeyedTuple` which becomes dramatically
    slower as instance invocation goes up. What to do? A new type that hedges between
    the approaches of both. Benching all three types for “size” (number of rows returned)
    and “num” (number of distinct queries), the new “lightweight keyed tuple” either
    outperforms both, or lags very slightly behind the faster object, based on which
    scenario. In the “sweet spot”, where we are both creating a good number of new
    types as well as fetching a good number of rows, the lightweight object totally
    smokes both namedtuple and KeyedTuple:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `KeyedTuple` 类而不是 Python 的 `collections.namedtuple()`，因为后者具有一个非常复杂的类型创建例程，比
    `KeyedTuple` 慢得多。然而，当获取数十万行时，`collections.namedtuple()` 很快超过 `KeyedTuple`，随着实例调用次数的增加，`KeyedTuple`
    的速度会急剧变慢。怎么办？一种新类型，介于两者之间的方法。对于“size”（返回的行数）和“num”（不同查询的数量）对所有三种类型进行测试，新的“轻量级键值元组”要么优于两者，要么略逊于更快的对象，具体取决于情况。在“甜蜜点”上，我们既创建了大量新类型，又获取了大量行，轻量级对象完全超过了
    namedtuple 和 KeyedTuple：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[#3176](https://www.sqlalchemy.org/trac/ticket/3176)  ### Significant Improvements
    in Structural Memory Use'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3176](https://www.sqlalchemy.org/trac/ticket/3176)### 结构化内存使用方面的显著改进'
- en: Structural memory use has been improved via much more significant use of `__slots__`
    for many internal objects. This optimization is particularly geared towards the
    base memory size of large applications that have lots of tables and columns, and
    reduces memory size for a variety of high-volume objects including event listening
    internals, comparator objects and parts of the ORM attribute and loader strategy
    system.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对许多内部对象更显著地使用 `__slots__`，改进了结构化内存使用。这种优化特别针对具有大量表和列的大型应用程序的基本内存大小，并减少了各种高容量对象的内存大小，包括事件监听内部、比较器对象以及
    ORM 属性和加载器策略系统的部分。
- en: 'A bench that makes use of heapy measure the startup size of Nova illustrates
    a difference of about 3.7 fewer megs, or 46%, taken up by SQLAlchemy’s objects,
    associated dictionaries, as well as weakrefs, within a basic import of “nova.db.sqlalchemy.models”:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 一个使用 heapy 测量 Nova 启动大小的工作台展示了 SQLAlchemy 对象、相关字典以及弱引用在“nova.db.sqlalchemy.models”基本导入中占用的空间减少了约
    3.7 兆字节，或者说减少了 46%：
- en: '[PRE8]  ### UPDATE statements are now batched with executemany() in a flush'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE8]### UPDATE 语句现在在刷新中与 executemany() 批处理'
- en: 'UPDATE statements can now be batched within an ORM flush into more performant
    executemany() call, similarly to how INSERT statements can be batched; this will
    be invoked within flush based on the following criteria:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以将 UPDATE 语句批处理到 ORM 刷新中，以更高效的 executemany() 调用执行，类似于 INSERT 语句可以批处理；这将根据以下标准在刷新中调用：
- en: two or more UPDATE statements in sequence involve the identical set of columns
    to be modified.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个或更多连续的 UPDATE 语句涉及相同的要修改的列集。
- en: The statement has no embedded SQL expressions in the SET clause.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语句在 SET 子句中没有嵌入的 SQL 表达式。
- en: 'The mapping does not use a `mapper.version_id_col`, or the backend dialect
    supports a “sane” rowcount for an executemany() operation; most DBAPIs support
    this correctly now.  ### Session.get_bind() handles a wider variety of inheritance
    scenarios'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 映射不使用 `mapper.version_id_col`，或者后端方言支持 executemany() 操作的“合理”行数；大多数 DBAPI 现在正确支持这一点。###
    Session.get_bind() 处理更广泛的继承场景
- en: 'The [`Session.get_bind()`](../orm/session_api.html#sqlalchemy.orm.Session.get_bind
    "sqlalchemy.orm.Session.get_bind") method is invoked whenever a query or unit
    of work flush process seeks to locate the database engine that corresponds to
    a particular class. The method has been improved to handle a variety of inheritance-oriented
    scenarios, including:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 每当查询或工作单元刷新过程寻找与特定类对应的数据库引擎时，都会调用 [`Session.get_bind()`](../orm/session_api.html#sqlalchemy.orm.Session.get_bind
    "sqlalchemy.orm.Session.get_bind") 方法。该方法已经改进，以处理各种继承导向的场景，包括：
- en: 'Binding to a Mixin or Abstract Class:'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绑定到一个 Mixin 或抽象类：
- en: '[PRE9]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Binding to inherited concrete subclasses individually based on table:'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于表格，分别绑定到继承的具体子类：
- en: '[PRE10]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[#3035](https://www.sqlalchemy.org/trac/ticket/3035)  ### Session.get_bind()
    will receive the Mapper in all relevant Query cases'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3035](https://www.sqlalchemy.org/trac/ticket/3035)  ### 在所有相关的查询情况下，Session.get_bind()将接收到Mapper'
- en: A series of issues were repaired where the [`Session.get_bind()`](../orm/session_api.html#sqlalchemy.orm.Session.get_bind
    "sqlalchemy.orm.Session.get_bind") would not receive the primary [`Mapper`](../orm/mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper") of the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query"), even though this mapper was readily available (the primary
    mapper is the single mapper, or alternatively the first mapper, that is associated
    with a [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    object).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 修复了一系列问题，其中[`Session.get_bind()`](../orm/session_api.html#sqlalchemy.orm.Session.get_bind
    "sqlalchemy.orm.Session.get_bind")未接收到[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")的主要[`Mapper`](../orm/mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper")，尽管此映射器是readily available的（主映射器是与[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")对象关联的单个映射器，或者替代是与查询关联的第一个映射器）。
- en: The [`Mapper`](../orm/mapping_api.html#sqlalchemy.orm.Mapper "sqlalchemy.orm.Mapper")
    object, when passed to [`Session.get_bind()`](../orm/session_api.html#sqlalchemy.orm.Session.get_bind
    "sqlalchemy.orm.Session.get_bind"), is typically used by sessions that make use
    of the [`Session.binds`](../orm/session_api.html#sqlalchemy.orm.Session.params.binds
    "sqlalchemy.orm.Session") parameter to associate mappers with a series of engines
    (although in this use case, things frequently “worked” in most cases anyway as
    the bind would be located via the mapped table object), or more specifically implement
    a user-defined [`Session.get_bind()`](../orm/session_api.html#sqlalchemy.orm.Session.get_bind
    "sqlalchemy.orm.Session.get_bind") method that provides some pattern of selecting
    engines based on mappers, such as horizontal sharding or a so-called “routing”
    session that routes queries to different backends.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当传递给[`Session.get_bind()`](../orm/session_api.html#sqlalchemy.orm.Session.get_bind
    "sqlalchemy.orm.Session.get_bind")的[`Mapper`](../orm/mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper")对象通常由使用[`Session.binds`](../orm/session_api.html#sqlalchemy.orm.Session.params.binds
    "sqlalchemy.orm.Session")参数的会话使用，以将映射器与一系列引擎关联（虽然在这种用例中，通常情况下“工作”，因为绑定通常会通过映射的表对象找到），或者更具体地实现一个用户定义的[`Session.get_bind()`](../orm/session_api.html#sqlalchemy.orm.Session.get_bind
    "sqlalchemy.orm.Session.get_bind")方法，该方法基于映射器提供一些选择引擎的模式，例如水平分片或所谓的“路由”会话，将查询路由到不同的后端。
- en: 'These scenarios include:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这些场景包括：
- en: '[`Query.count()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.count "sqlalchemy.orm.Query.count"):'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`Query.count()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.count "sqlalchemy.orm.Query.count"):'
- en: '[PRE11]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[`Query.update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.update
    "sqlalchemy.orm.Query.update") and [`Query.delete()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.delete
    "sqlalchemy.orm.Query.delete"), both for the UPDATE/DELETE statement as well as
    for the SELECT used by the “fetch” strategy:'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`Query.update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.update
    "sqlalchemy.orm.Query.update") 和 [`Query.delete()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.delete
    "sqlalchemy.orm.Query.delete")，用于UPDATE/DELETE语句以及“fetch”策略所使用的SELECT：'
- en: '[PRE12]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Queries against individual columns:'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对个别列的查询：
- en: '[PRE13]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'SQL functions and other expressions against indirect mappings such as [`column_property`](../orm/mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property"):'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对间接映射（例如[`column_property`](../orm/mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property")）的SQL函数和其他表达式：
- en: '[PRE14]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[#3227](https://www.sqlalchemy.org/trac/ticket/3227) [#3242](https://www.sqlalchemy.org/trac/ticket/3242)
    [#1326](https://www.sqlalchemy.org/trac/ticket/1326)  ### .info dictionary improvements'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3227](https://www.sqlalchemy.org/trac/ticket/3227) [#3242](https://www.sqlalchemy.org/trac/ticket/3242)
    [#1326](https://www.sqlalchemy.org/trac/ticket/1326)  ### .info 字典改进'
- en: 'The `InspectionAttr.info` collection is now available on every kind of object
    that one would retrieve from the [`Mapper.all_orm_descriptors`](../orm/mapping_api.html#sqlalchemy.orm.Mapper.all_orm_descriptors
    "sqlalchemy.orm.Mapper.all_orm_descriptors") collection. This includes [`hybrid_property`](../orm/extensions/hybrid.html#sqlalchemy.ext.hybrid.hybrid_property
    "sqlalchemy.ext.hybrid.hybrid_property") and [`association_proxy()`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.association_proxy
    "sqlalchemy.ext.associationproxy.association_proxy"). However, as these objects
    are class-bound descriptors, they must be accessed **separately** from the class
    to which they are attached in order to get at the attribute. Below this is illustrated
    using the [`Mapper.all_orm_descriptors`](../orm/mapping_api.html#sqlalchemy.orm.Mapper.all_orm_descriptors
    "sqlalchemy.orm.Mapper.all_orm_descriptors") namespace:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`InspectionAttr.info` 集合现在可用于从[`Mapper.all_orm_descriptors`](../orm/mapping_api.html#sqlalchemy.orm.Mapper.all_orm_descriptors
    "sqlalchemy.orm.Mapper.all_orm_descriptors")集合中检索到的每种对象。这包括[`hybrid_property`](../orm/extensions/hybrid.html#sqlalchemy.ext.hybrid.hybrid_property
    "sqlalchemy.ext.hybrid.hybrid_property")和[`association_proxy()`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.association_proxy
    "sqlalchemy.ext.associationproxy.association_proxy")。然而，由于这些对象是类绑定的描述符，必须**分开**从它们附加到的类中访问以获取属性。以下是使用[`Mapper.all_orm_descriptors`](../orm/mapping_api.html#sqlalchemy.orm.Mapper.all_orm_descriptors
    "sqlalchemy.orm.Mapper.all_orm_descriptors")命名空间进行说明：'
- en: '[PRE15]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: It is also available as a constructor argument for all [`SchemaItem`](../core/metadata.html#sqlalchemy.schema.SchemaItem
    "sqlalchemy.schema.SchemaItem") objects (e.g. [`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey"), [`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint") etc.) as well as remaining ORM constructs
    such as [`synonym()`](../orm/mapped_attributes.html#sqlalchemy.orm.synonym "sqlalchemy.orm.synonym").
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 它还可作为所有[`SchemaItem`](../core/metadata.html#sqlalchemy.schema.SchemaItem "sqlalchemy.schema.SchemaItem")对象（例如[`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey")，[`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint")等）的构造函数参数，以及剩余的 ORM 构造，如[`synonym()`](../orm/mapped_attributes.html#sqlalchemy.orm.synonym
    "sqlalchemy.orm.synonym")。
- en: '[#2971](https://www.sqlalchemy.org/trac/ticket/2971)'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2971](https://www.sqlalchemy.org/trac/ticket/2971)'
- en: '[#2963](https://www.sqlalchemy.org/trac/ticket/2963)  ### ColumnProperty constructs
    work a lot better with aliases, order_by'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2963](https://www.sqlalchemy.org/trac/ticket/2963)  ### ColumnProperty 构造与别名，order_by
    配合效果更好'
- en: A variety of issues regarding [`column_property()`](../orm/mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property") have been fixed, most specifically with regards
    to the [`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased "sqlalchemy.orm.aliased")
    construct as well as the “order by label” logic introduced in 0.9 (see [Label
    constructs can now render as their name alone in an ORDER BY](migration_09.html#migration-1068)).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 关于[`column_property()`](../orm/mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property")的各种问题已得到解决，特别是关于[`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased")构造以及在0.9版本中引入的“按标签排序”逻辑（参见[标签构造现在可以单独作为其名称在 ORDER BY
    中呈现](migration_09.html#migration-1068)）。
- en: 'Given a mapping like the following:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 给定如下映射：
- en: '[PRE16]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'A simple scenario that included “A.b” twice would fail to render correctly:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的场景中，包含两次“A.b”将无法正确渲染：
- en: '[PRE17]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This would order by the wrong column:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这会导致错误的列排序：
- en: '[PRE18]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'New output:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 新的输出：
- en: '[PRE19]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'There were also many scenarios where the “order by” logic would fail to order
    by label, for example if the mapping were “polymorphic”:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多情况下，“order by”逻辑会无法按标签排序，例如如果映射为“多态”：
- en: '[PRE20]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The order_by would fail to use the label, as it would be anonymized due to
    the polymorphic loading:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: order_by 将无法使用标签，因为由于多态加载，标签将被匿名化：
- en: '[PRE21]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now that the order by label tracks the anonymized label, this now works:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，由于按标签排序跟踪了匿名化标签，这现在有效：
- en: '[PRE22]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Included in these fixes are a variety of heisenbugs that could corrupt the state
    of an `aliased()` construct such that the labeling logic would again fail; these
    have also been fixed.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这些修复中还包括了一系列能够破坏`aliased()`构造状态的 heisenbugs，从而导致标签逻辑再次失败；这些问题也已得到解决。
- en: '[#3148](https://www.sqlalchemy.org/trac/ticket/3148) [#3188](https://www.sqlalchemy.org/trac/ticket/3188)'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3148](https://www.sqlalchemy.org/trac/ticket/3148) [#3188](https://www.sqlalchemy.org/trac/ticket/3188)'
- en: New Features and Improvements - Core
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 新功能和改进 - 核心
- en: '### Select/Query LIMIT / OFFSET may be specified as an arbitrary SQL expression'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '### 选择/查询 LIMIT / OFFSET 可以指定为任意 SQL 表达式'
- en: 'The [`Select.limit()`](../core/selectable.html#sqlalchemy.sql.expression.Select.limit
    "sqlalchemy.sql.expression.Select.limit") and [`Select.offset()`](../core/selectable.html#sqlalchemy.sql.expression.Select.offset
    "sqlalchemy.sql.expression.Select.offset") methods now accept any SQL expression,
    in addition to integer values, as arguments. The ORM [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object also passes through any expression to the underlying
    [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select "sqlalchemy.sql.expression.Select")
    object. Typically this is used to allow a bound parameter to be passed, which
    can be substituted with a value later:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Select.limit()`](../core/selectable.html#sqlalchemy.sql.expression.Select.limit
    "sqlalchemy.sql.expression.Select.limit") 和 [`Select.offset()`](../core/selectable.html#sqlalchemy.sql.expression.Select.offset
    "sqlalchemy.sql.expression.Select.offset") 方法现在接受任何 SQL 表达式作为参数，而不仅仅是整数值。ORM [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") 对象也会将任何表达式传递给底层的 [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") 对象。通常情况下，这用于允许传递绑定参数，稍后可以用值替换：'
- en: '[PRE23]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Dialects which don’t support non-integer LIMIT or OFFSET expressions may continue
    to not support this behavior; third party dialects may also need modification
    in order to take advantage of the new behavior. A dialect which currently uses
    the `._limit` or `._offset` attributes will continue to function for those cases
    where the limit/offset was specified as a simple integer value. However, when
    a SQL expression is specified, these two attributes will instead raise a [`CompileError`](../core/exceptions.html#sqlalchemy.exc.CompileError
    "sqlalchemy.exc.CompileError") on access. A third-party dialect which wishes to
    support the new feature should now call upon the `._limit_clause` and `._offset_clause`
    attributes to receive the full SQL expression, rather than the integer value.  ###
    The `use_alter` flag on `ForeignKeyConstraint` is (usually) no longer needed'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 不支持非整数 LIMIT 或 OFFSET 表达式的方言可能会继续不支持此行为；第三方方言可能还需要修改以利用新行为。当前使用 `._limit` 或
    `._offset` 属性的方言将继续对指定为简单整数值的限制/偏移的情况进行处理。但是，当指定 SQL 表达式时，这两个属性在访问时将引发 [`CompileError`](../core/exceptions.html#sqlalchemy.exc.CompileError
    "sqlalchemy.exc.CompileError")。希望支持新功能的第三方方言现在应调用 `._limit_clause` 和 `._offset_clause`
    属性以接收完整的 SQL 表达式，而不是整数值。### `ForeignKeyConstraint` 上的 `use_alter` 标志（通常）不再需要
- en: The [`MetaData.create_all()`](../core/metadata.html#sqlalchemy.schema.MetaData.create_all
    "sqlalchemy.schema.MetaData.create_all") and [`MetaData.drop_all()`](../core/metadata.html#sqlalchemy.schema.MetaData.drop_all
    "sqlalchemy.schema.MetaData.drop_all") methods will now make use of a system that
    automatically renders an ALTER statement for foreign key constraints that are
    involved in mutually-dependent cycles between tables, without the need to specify
    [`ForeignKeyConstraint.use_alter`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint.params.use_alter
    "sqlalchemy.schema.ForeignKeyConstraint"). Additionally, the foreign key constraints
    no longer need to have a name in order to be created via ALTER; only the DROP
    operation requires a name. In the case of a DROP, the feature will ensure that
    only constraints which have explicit names are actually included as ALTER statements.
    In the case of an unresolvable cycle within a DROP, the system emits a succinct
    and clear error message now if the DROP cannot proceed.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '[`MetaData.create_all()`](../core/metadata.html#sqlalchemy.schema.MetaData.create_all
    "sqlalchemy.schema.MetaData.create_all") 和 [`MetaData.drop_all()`](../core/metadata.html#sqlalchemy.schema.MetaData.drop_all
    "sqlalchemy.schema.MetaData.drop_all") 方法现在将使用一个系统，自动为涉及表之间相互依赖循环的外键约束生成 ALTER
    语句，无需指定 [`ForeignKeyConstraint.use_alter`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint.params.use_alter
    "sqlalchemy.schema.ForeignKeyConstraint")。此外，外键约束现在不再需要具有名称才能通过 ALTER 创建；只有 DROP
    操作需要名称。在 DROP 的情况下，该功能将确保只有具有显式名称的约束实际上包含在 ALTER 语句中。在 DROP 中存在无法解决的循环的情况下，如果无法继续执行
    DROP，系统现在会发出简洁明了的错误消息。'
- en: The [`ForeignKeyConstraint.use_alter`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint.params.use_alter
    "sqlalchemy.schema.ForeignKeyConstraint") and [`ForeignKey.use_alter`](../core/constraints.html#sqlalchemy.schema.ForeignKey.params.use_alter
    "sqlalchemy.schema.ForeignKey") flags remain in place, and continue to have the
    same effect of establishing those constraints for which ALTER is required during
    a CREATE/DROP scenario.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '[`ForeignKeyConstraint.use_alter`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint.params.use_alter
    "sqlalchemy.schema.ForeignKeyConstraint") 和 [`ForeignKey.use_alter`](../core/constraints.html#sqlalchemy.schema.ForeignKey.params.use_alter
    "sqlalchemy.schema.ForeignKey") 标志仍然存在，并且继续具有相同的效果，用于在 CREATE/DROP 场景中需要 ALTER
    的约束条件的建立。'
- en: As of version 1.0.1, special logic takes over in the case of SQLite, which does
    not support ALTER, in the case that during a DROP, the given tables have an unresolvable
    cycle; in this case a warning is emitted, and the tables are dropped with **no**
    ordering, which is usually fine on SQLite unless constraints are enabled. To resolve
    the warning and proceed with at least a partial ordering on a SQLite database,
    particularly one where constraints are enabled, re-apply “use_alter” flags to
    those [`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey "sqlalchemy.schema.ForeignKey")
    and [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") objects which should be explicitly omitted
    from the sort.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 从版本 1.0.1 开始，在 SQLite 的情况下，特殊逻辑接管，在 DROP 过程中，给定表存在无法解决的循环；在这种情况下会发出警告，并且表将以**无**顺序删除，这在
    SQLite 上通常是可以接受的，除非启用了约束。要解决警告并在 SQLite 数据库上至少进行部分排序，特别是在启用了约束的情况下，重新应用“use_alter”标志到那些应明确从排序中省略的
    [`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey "sqlalchemy.schema.ForeignKey")
    和 [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") 对象。
- en: See also
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[Creating/Dropping Foreign Key Constraints via ALTER](../core/constraints.html#use-alter)
    - full description of the new behavior.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '[通过 ALTER 创建/删除外键约束](../core/constraints.html#use-alter) - 新行为的完整描述。'
- en: '[#3282](https://www.sqlalchemy.org/trac/ticket/3282)  ### ResultProxy “auto
    close” is now a “soft” close'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3282](https://www.sqlalchemy.org/trac/ticket/3282)  ### ResultProxy “auto
    close” 现在是“soft” close'
- en: 'For many releases, the `ResultProxy` object has always been automatically closed
    out at the point at which all result rows have been fetched. This was to allow
    usage of the object without the need to call upon `ResultProxy.close()` explicitly;
    as all DBAPI resources had been freed, the object was safe to discard. However,
    the object maintained a strict “closed” behavior, which meant that any subsequent
    calls to `ResultProxy.fetchone()`, `ResultProxy.fetchmany()` or `ResultProxy.fetchall()`
    would now raise a [`ResourceClosedError`](../core/exceptions.html#sqlalchemy.exc.ResourceClosedError
    "sqlalchemy.exc.ResourceClosedError"):'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多版本中，`ResultProxy` 对象一直在获取所有结果行后自动关闭。这是为了允许在不需要显式调用 `ResultProxy.close()`
    的情况下使用对象；因为所有的 DBAPI 资源都已被释放，对象可以安全丢弃。然而，对象保持了严格的“closed”行为，这意味着任何后续对 `ResultProxy.fetchone()`、`ResultProxy.fetchmany()`
    或 `ResultProxy.fetchall()` 的调用现在会引发 [`ResourceClosedError`](../core/exceptions.html#sqlalchemy.exc.ResourceClosedError
    "sqlalchemy.exc.ResourceClosedError")：
- en: '[PRE24]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This behavior is inconsistent vs. what pep-249 states, which is that you can
    call upon the fetch methods repeatedly even after results are exhausted. It also
    interferes with behavior for some implementations of result proxy, such as the
    `BufferedColumnResultProxy` used by the cx_oracle dialect for certain datatypes.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为与 pep-249 所述的不一致，pep-249 表明，即使结果已经耗尽，也可以重复调用获取方法。它还干扰了某些结果代理的行为，例如 cx_oracle
    方言用于某些数据类型的 `BufferedColumnResultProxy`。
- en: 'To solve this, the “closed” state of the `ResultProxy` has been broken into
    two states; a “soft close” which does the majority of what “close” does, in that
    it releases the DBAPI cursor and in the case of a “close with result” object will
    also release the connection, and a “closed” state which is everything included
    by “soft close” as well as establishing the fetch methods as “closed”. The `ResultProxy.close()`
    method is now never called implicitly, only the `ResultProxy._soft_close()` method
    which is non-public:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，`ResultProxy` 的“closed”状态被分为两个状态；一个“soft close”执行了“close”大部分功能，释放了
    DBAPI 游标，并且在“close with result”对象的情况下还会释放连接，另一个“closed”状态包括了“soft close”的所有内容以及将获取方法设为“closed”。`ResultProxy.close()`
    方法现在不会隐式调用，只会调用非公开的 `ResultProxy._soft_close()` 方法：
- en: '[PRE25]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[#3330](https://www.sqlalchemy.org/trac/ticket/3330) [#3329](https://www.sqlalchemy.org/trac/ticket/3329)'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3330](https://www.sqlalchemy.org/trac/ticket/3330) [#3329](https://www.sqlalchemy.org/trac/ticket/3329)'
- en: CHECK Constraints now support the `%(column_0_name)s` token in naming conventions
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CHECK约束现在支持命名约定中的`%(column_0_name)s`标记
- en: 'The `%(column_0_name)s` will derive from the first column found in the expression
    of a [`CheckConstraint`](../core/constraints.html#sqlalchemy.schema.CheckConstraint
    "sqlalchemy.schema.CheckConstraint"):'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`%(column_0_name)s`将从[`CheckConstraint`](../core/constraints.html#sqlalchemy.schema.CheckConstraint
    "sqlalchemy.schema.CheckConstraint")表达式中找到的第一列派生：'
- en: '[PRE26]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Will render:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 将呈现：
- en: '[PRE27]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The combination of naming conventions with the constraint produced by a [`SchemaType`](../core/type_basics.html#sqlalchemy.types.SchemaType
    "sqlalchemy.types.SchemaType") such as [`Boolean`](../core/type_basics.html#sqlalchemy.types.Boolean
    "sqlalchemy.types.Boolean") or [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum") will also now make use of all CHECK constraint conventions.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 命名约束与由[`SchemaType`](../core/type_basics.html#sqlalchemy.types.SchemaType "sqlalchemy.types.SchemaType")生成的约束的组合，例如[`Boolean`](../core/type_basics.html#sqlalchemy.types.Boolean
    "sqlalchemy.types.Boolean")或[`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum")，现在也将使用所有CHECK约束约定。
- en: See also
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Naming CHECK Constraints](../core/constraints.html#naming-check-constraints)'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '[命名CHECK约束](../core/constraints.html#naming-check-constraints)'
- en: '[Configuring Naming for Boolean, Enum, and other schema types](../core/constraints.html#naming-schematypes)'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '[为布尔值、枚举和其他模式类型配置命名](../core/constraints.html#naming-schematypes)'
- en: '[#3299](https://www.sqlalchemy.org/trac/ticket/3299)'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3299](https://www.sqlalchemy.org/trac/ticket/3299)'
- en: '### Constraints referring to unattached Columns can auto-attach to the Table
    when their referred columns are attached'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '### 当引用的列未附加到表时，约束条件可以在其引用的列附加到表时自动附加'
- en: 'Since at least version 0.8, a [`Constraint`](../core/constraints.html#sqlalchemy.schema.Constraint
    "sqlalchemy.schema.Constraint") has had the ability to “auto-attach” itself to
    a [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    based on being passed table-attached columns:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 自至少版本0.8以来，[`Constraint`](../core/constraints.html#sqlalchemy.schema.Constraint
    "sqlalchemy.schema.Constraint")已经具有根据传递的与表关联的列“自动附加”到[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")的能力：
- en: '[PRE28]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'In order to assist with some cases that tend to come up with declarative, this
    same auto-attachment logic can now function even if the [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects are not yet associated with the [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table"); additional events are established such that when those
    [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    objects are associated, the [`Constraint`](../core/constraints.html#sqlalchemy.schema.Constraint
    "sqlalchemy.schema.Constraint") is also added:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助处理在声明性中经常出现的一些情况，即使[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")对象尚未与[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")关联，这种自动附加逻辑现在也可以运行；建立了额外的事件，以便当这些[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")对象关联时，[`Constraint`](../core/constraints.html#sqlalchemy.schema.Constraint
    "sqlalchemy.schema.Constraint")也被添加：
- en: '[PRE29]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The above feature was a late add as of version 1.0.0b3\. A fix as of version
    1.0.4 for [#3411](https://www.sqlalchemy.org/trac/ticket/3411) ensures that this
    logic does not occur if the [`Constraint`](../core/constraints.html#sqlalchemy.schema.Constraint
    "sqlalchemy.schema.Constraint") refers to a mixture of [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects and string column names; as we do not yet
    have tracking for the addition of names to a [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table"):'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 以上功能是在版本1.0.0b3中作为一个晚期添加的。截至版本1.0.4的修复[#3411](https://www.sqlalchemy.org/trac/ticket/3411)确保如果[`Constraint`](../core/constraints.html#sqlalchemy.schema.Constraint
    "sqlalchemy.schema.Constraint")引用了[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")对象和字符串列名的混合，则不会发生此逻辑；因为我们尚未跟踪将名称添加到[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")的操作：
- en: '[PRE30]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Above, the attachment event for column “a” to table “t” will fire off before
    column “b” is attached (as “a” is stated in the [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") constructor before “b”), and the constraint will fail
    to locate “b” if it were to attempt an attachment. For consistency, if the constraint
    refers to any string names, the autoattach-on-column-attach logic is skipped.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，将列“a”附加到表“t”的附件事件将在附加列“b”之前触发（因为在“b”之前在[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")构造函数中声明了“a”），如果尝试附加约束，则约束将无法找到“b”。为了保持一致性，如果约束引用任何字符串名称，则会跳过在列附加时自动附加的逻辑。
- en: 'The original auto-attach logic of course remains in place, if the [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") already contains all the target [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects at the time the [`Constraint`](../core/constraints.html#sqlalchemy.schema.Constraint
    "sqlalchemy.schema.Constraint") is constructed:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当[`Constraint`](../core/constraints.html#sqlalchemy.schema.Constraint "sqlalchemy.schema.Constraint")构造时，如果[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")已经包含所有目标[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")对象，则原始的自动附加逻辑仍然存在：
- en: '[PRE31]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[#3341](https://www.sqlalchemy.org/trac/ticket/3341) [#3411](https://www.sqlalchemy.org/trac/ticket/3411)  ###
    INSERT FROM SELECT now includes Python and SQL-expression defaults'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3341](https://www.sqlalchemy.org/trac/ticket/3341) [#3411](https://www.sqlalchemy.org/trac/ticket/3411)  ###
    INSERT FROM SELECT现在包括Python和SQL表达式默认值'
- en: '[`Insert.from_select()`](../core/dml.html#sqlalchemy.sql.expression.Insert.from_select
    "sqlalchemy.sql.expression.Insert.from_select") now includes Python and SQL-expression
    defaults if otherwise unspecified; the limitation where non-server column defaults
    aren’t included in an INSERT FROM SELECT is now lifted and these expressions are
    rendered as constants into the SELECT statement:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未指定，默认情况下，[`Insert.from_select()`](../core/dml.html#sqlalchemy.sql.expression.Insert.from_select
    "sqlalchemy.sql.expression.Insert.from_select")现在包括Python和SQL表达式默认值；现在解除了不包括非服务器列默认值在INSERT
    FROM SELECT中的限制，并将这些表达式呈现为常量插入SELECT语句中：
- en: '[PRE32]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Will render:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 将呈现为：
- en: '[PRE33]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The feature can be disabled using [`Insert.from_select.include_defaults`](../core/dml.html#sqlalchemy.sql.expression.Insert.from_select.params.include_defaults
    "sqlalchemy.sql.expression.Insert.from_select").  ### Column server defaults now
    render literal values'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用[`Insert.from_select.include_defaults`](../core/dml.html#sqlalchemy.sql.expression.Insert.from_select.params.include_defaults
    "sqlalchemy.sql.expression.Insert.from_select")来禁用该功能。### 现在列服务器默认值呈现为字面值
- en: 'The “literal binds” compiler flag is switched on when a [`DefaultClause`](../core/defaults.html#sqlalchemy.schema.DefaultClause
    "sqlalchemy.schema.DefaultClause"), set up by [`Column.server_default`](../core/metadata.html#sqlalchemy.schema.Column.params.server_default
    "sqlalchemy.schema.Column") is present as a SQL expression to be compiled. This
    allows literals embedded in SQL to render correctly, such as:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当由[`Column.server_default`](../core/metadata.html#sqlalchemy.schema.Column.params.server_default
    "sqlalchemy.schema.Column")设置为SQL表达式的[`DefaultClause`](../core/defaults.html#sqlalchemy.schema.DefaultClause
    "sqlalchemy.schema.DefaultClause")存在时，将打开“literal binds”编译器标志。这允许在SQL中嵌入的字面值正确呈现，例如：
- en: '[PRE34]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now renders:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在呈现为：
- en: '[PRE35]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Previously, the literal values `"foo", "bar", "baz"` would render as bound parameters,
    which are useless in DDL.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，字面值`"foo", "bar", "baz"`会呈现为绑定参数，在DDL中无用。
- en: '[#3087](https://www.sqlalchemy.org/trac/ticket/3087)  ### UniqueConstraint
    is now part of the Table reflection process'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3087](https://www.sqlalchemy.org/trac/ticket/3087)  ### UniqueConstraint现在是表反射过程的一部分'
- en: 'A [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    object populated using `autoload=True` will now include [`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint") constructs as well as [`Index`](../core/constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index") constructs. This logic has a few caveats for PostgreSQL
    and MySQL:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`autoload=True`填充的[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")对象现在将包括[`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint")构造以及[`Index`](../core/constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index")构造。对于PostgreSQL和MySQL，这种逻辑有一些注意事项：
- en: PostgreSQL
  id: totrans-148
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: PostgreSQL
- en: PostgreSQL has the behavior such that when a UNIQUE constraint is created, it
    implicitly creates a UNIQUE INDEX corresponding to that constraint as well. The
    [`Inspector.get_indexes()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_indexes
    "sqlalchemy.engine.reflection.Inspector.get_indexes") and the [`Inspector.get_unique_constraints()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_unique_constraints
    "sqlalchemy.engine.reflection.Inspector.get_unique_constraints") methods will
    continue to **both** return these entries distinctly, where [`Inspector.get_indexes()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_indexes
    "sqlalchemy.engine.reflection.Inspector.get_indexes") now features a token `duplicates_constraint`
    within the index entry indicating the corresponding constraint when detected.
    However, when performing full table reflection using `Table(..., autoload=True)`,
    the [`Index`](../core/constraints.html#sqlalchemy.schema.Index "sqlalchemy.schema.Index")
    construct is detected as being linked to the [`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint"), and is **not** present within the [`Table.indexes`](../core/metadata.html#sqlalchemy.schema.Table.indexes
    "sqlalchemy.schema.Table.indexes") collection; only the [`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint") will be present in the [`Table.constraints`](../core/metadata.html#sqlalchemy.schema.Table.constraints
    "sqlalchemy.schema.Table.constraints") collection. This deduplication logic works
    by joining to the `pg_constraint` table when querying `pg_index` to see if the
    two constructs are linked.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建唯一约束时，PostgreSQL 的行为是隐式地创建一个与该约束对应的唯一索引。[`Inspector.get_indexes()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_indexes
    "sqlalchemy.engine.reflection.Inspector.get_indexes") 和 [`Inspector.get_unique_constraints()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_unique_constraints
    "sqlalchemy.engine.reflection.Inspector.get_unique_constraints") 方法将继续**分别**返回这些条目，其中
    [`Inspector.get_indexes()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_indexes
    "sqlalchemy.engine.reflection.Inspector.get_indexes") 现在在索引条目中特征上带有一个标记 `duplicates_constraint`，指示检测到的相应约束。然而，当使用
    `Table(..., autoload=True)` 执行完整的表反射时，[`Index`](../core/constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index") 构造被检测为与 [`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint") 关联，并且**不会**出现在 [`Table.indexes`](../core/metadata.html#sqlalchemy.schema.Table.indexes
    "sqlalchemy.schema.Table.indexes") 集合中；只有 [`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint") 会出现在 [`Table.constraints`](../core/metadata.html#sqlalchemy.schema.Table.constraints
    "sqlalchemy.schema.Table.constraints") 集合中。这种去重逻辑通过在查询 `pg_index` 时连接到 `pg_constraint`
    表来实现，以查看这两个结构是否关联。
- en: MySQL
  id: totrans-150
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: MySQL
- en: MySQL does not have separate concepts for a UNIQUE INDEX and a UNIQUE constraint.
    While it supports both syntaxes when creating tables and indexes, it does not
    store them any differently. The [`Inspector.get_indexes()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_indexes
    "sqlalchemy.engine.reflection.Inspector.get_indexes") and the [`Inspector.get_unique_constraints()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_unique_constraints
    "sqlalchemy.engine.reflection.Inspector.get_unique_constraints") methods will
    continue to **both** return an entry for a UNIQUE index in MySQL, where [`Inspector.get_unique_constraints()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_unique_constraints
    "sqlalchemy.engine.reflection.Inspector.get_unique_constraints") features a new
    token `duplicates_index` within the constraint entry indicating that this is a
    dupe entry corresponding to that index. However, when performing full table reflection
    using `Table(..., autoload=True)`, the [`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint") construct is **not** part of the fully reflected
    [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    construct under any circumstances; this construct is always represented by a [`Index`](../core/constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index") with the `unique=True` setting present in the [`Table.indexes`](../core/metadata.html#sqlalchemy.schema.Table.indexes
    "sqlalchemy.schema.Table.indexes") collection.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL没有单独的UNIQUE INDEX和UNIQUE约束概念。虽然在创建表和索引时支持两种语法，但在存储时并没有任何不同。[`Inspector.get_indexes()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_indexes
    "sqlalchemy.engine.reflection.Inspector.get_indexes")和[`Inspector.get_unique_constraints()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_unique_constraints
    "sqlalchemy.engine.reflection.Inspector.get_unique_constraints")方法将继续**同时**返回MySQL中UNIQUE索引的条目，其中[`Inspector.get_unique_constraints()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_unique_constraints
    "sqlalchemy.engine.reflection.Inspector.get_unique_constraints")在约束条目中具有一个新的标记`duplicates_index`，指示这是与该索引对应的重复条目。然而，在使用`Table(...,
    autoload=True)`执行完整表反射时，[`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint")构造在任何情况下都**不**是完全反映的[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")构造的一部分；这个构造始终由在[`Table.indexes`](../core/metadata.html#sqlalchemy.schema.Table.indexes
    "sqlalchemy.schema.Table.indexes")集合中具有`unique=True`设置的[`Index`](../core/constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index")表示。
- en: See also
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[PostgreSQL Index Reflection](../dialects/postgresql.html#postgresql-index-reflection)'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '[PostgreSQL Index Reflection](../dialects/postgresql.html#postgresql-index-reflection)'
- en: '[MySQL / MariaDB Unique Constraints and Reflection](../dialects/mysql.html#mysql-unique-constraints)'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '[MySQL / MariaDB Unique Constraints and Reflection](../dialects/mysql.html#mysql-unique-constraints)'
- en: '[#3184](https://www.sqlalchemy.org/trac/ticket/3184)'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3184](https://www.sqlalchemy.org/trac/ticket/3184)'
- en: New systems to safely emit parameterized warnings
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安全地发出参数化警告的新系统
- en: For a long time, there has been a restriction that warning messages could not
    refer to data elements, such that a particular function might emit an infinite
    number of unique warnings. The key place this occurs is in the `Unicode type received
    non-unicode bind param value` warning. Placing the data value in this message
    would mean that the Python `__warningregistry__` for that module, or in some cases
    the Python-global `warnings.onceregistry`, would grow unbounded, as in most warning
    scenarios, one of these two collections is populated with every distinct warning
    message.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 长期以来，存在一个限制，即警告消息不能引用数据元素，这样一个特定函数可能会发出无限数量的唯一警告。这种情况最常见的地方是在`Unicode type received
    non-unicode bind param value`警告中。将数据值放入此消息中意味着该模块的Python `__warningregistry__`，或在某些情况下是Python全局的`warnings.onceregistry`，将无限增长，因为在大多数警告场景中，这两个集合中的一个会填充每个不同的警告消息。
- en: The change here is that by using a special `string` type that purposely changes
    how the string is hashed, we can control that a large number of parameterized
    messages are hashed only on a small set of possible hash values, such that a warning
    such as `Unicode type received non-unicode bind param value` can be tailored to
    be emitted only a specific number of times; beyond that, the Python warnings registry
    will begin recording them as duplicates.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用特殊的`string`类型，有意改变字符串的哈希方式，我们可以控制大量参数化消息仅在一小组可能的哈希值上进行哈希，这样一个警告，比如`Unicode
    type received non-unicode bind param value`，可以被定制为仅发出特定次数；此后，Python警告注册表将开始记录它们为重复项。
- en: 'To illustrate, the following test script will show only ten warnings being
    emitted for ten of the parameter sets, out of a total of 1000:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明，以下测试脚本将仅显示对于1000个参数集中的十个参数集发出的十个警告：
- en: '[PRE36]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The format of the warning here is:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的警告格式是：
- en: '[PRE37]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[#3178](https://www.sqlalchemy.org/trac/ticket/3178)'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3178](https://www.sqlalchemy.org/trac/ticket/3178)'
- en: Key Behavioral Changes - ORM
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关键行为变化 - ORM
- en: '### query.update() now resolves string names into mapped attribute names'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '### query.update()现在将字符串名称解析为映射的属性名称'
- en: The documentation for [`Query.update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.update
    "sqlalchemy.orm.Query.update") states that the given `values` dictionary is “a
    dictionary with attributes names as keys”, implying that these are mapped attribute
    names. Unfortunately, the function was designed more in mind to receive attributes
    and SQL expressions and not as much strings; when strings were passed, these strings
    would be passed through straight to the core update statement without any resolution
    as far as how these names are represented on the mapped class, meaning the name
    would have to match that of a table column exactly, not how an attribute of that
    name was mapped onto the class.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Query.update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.update
    "sqlalchemy.orm.Query.update")的文档说明给定的`values`字典是“以属性名称为键的字典”，这意味着这些是映射的属性名称。不幸的是，该函数更多地是设计为接收属性和SQL表达式，而不是字符串；当传递字符串时，这些字符串将直接传递到核心更新语句，而不解析这些名称在映射类上如何表示，这意味着名称必须与表列的名称完全匹配，而不是映射到类的属性的名称。'
- en: 'The string names are now resolved as attribute names in earnest:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在字符串名称被认真解析为属性名称：
- en: '[PRE38]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Above, the column `user_name` is mapped as `name`. Previously, a call to [`Query.update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.update
    "sqlalchemy.orm.Query.update") that was passed strings would have to have been
    called as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 上面，列`user_name`被映射为`name`。以前，传递字符串的[`Query.update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.update
    "sqlalchemy.orm.Query.update")调用必须如下调用：
- en: '[PRE39]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The given string is now resolved against the entity:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在给定的字符串将根据实体解析：
- en: '[PRE40]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'It is typically preferable to use the attribute directly, to avoid any ambiguity:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 通常最好直接使用属性，以避免任何歧义：
- en: '[PRE41]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The change also indicates that synonyms and hybrid attributes can be referred
    to by string name as well:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 此更改还表明，同义词和混合属性也可以通过字符串名称进行引用：
- en: '[PRE42]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[#3228](https://www.sqlalchemy.org/trac/ticket/3228)  ### Warnings emitted
    when comparing objects with None values to relationships'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3228](https://www.sqlalchemy.org/trac/ticket/3228)  ### 当将对象与None值比较到关系时发出警告'
- en: 'This change is new as of 1.0.1\. Some users are performing queries that are
    essentially of this form:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这个更改是从1.0.1版本开始的。一些用户正在执行基本上是这种形式的查询：
- en: '[PRE43]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This pattern is not currently supported in SQLAlchemy. For all versions, it
    emits SQL resembling:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 目前SQLAlchemy不支持这种模式。对于所有版本，它会生成类似的SQL：
- en: '[PRE44]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Note above, there is a comparison `WHERE ? = address.user_id` where the bound
    value `?` is receiving `None`, or `NULL` in SQL. **This will always return False
    in SQL**. The comparison here would in theory generate SQL as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意上面，有一个比较`WHERE ? = address.user_id`，其中绑定值`?`接收`None`，或在SQL中为`NULL`。**这在SQL中将始终返回False**。这里的比较理论上会生成以下SQL：
- en: '[PRE45]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'But right now, **it does not**. Applications which are relying upon the fact
    that “NULL = NULL” produces False in all cases run the risk that someday, SQLAlchemy
    might fix this issue to generate “IS NULL”, and the queries will then produce
    different results. Therefore with this kind of operation, you will see a warning:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，**目前还没有**。依赖于“NULL = NULL”在所有情况下产生False的应用程序存在风险，因为有一天，SQLAlchemy可能会修复此问题以生成“IS
    NULL”，然后查询将产生不同的结果。因此，在这种操作中，您将看到一个警告：
- en: '[PRE46]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Note that this pattern was broken in most cases for release 1.0.0 including
    all of the betas; a value like `SYMBOL('NEVER_SET')` would be generated. This
    issue has been fixed, but as a result of identifying this pattern, the warning
    is now there so that we can more safely repair this broken behavior (now captured
    in [#3373](https://www.sqlalchemy.org/trac/ticket/3373)) in a future release.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这种模式在1.0.0版本中的大多数情况下都被打破，包括所有的测试版；会生成类似`SYMBOL('NEVER_SET')`的值。这个问题已经修复，但由于识别了这种模式，现在有了警告，以便我们可以更安全地修复这种破损行为（现在在[#3373](https://www.sqlalchemy.org/trac/ticket/3373)中捕获）在未来的版本中。
- en: '[#3371](https://www.sqlalchemy.org/trac/ticket/3371)  ### A “negated contains
    or equals” relationship comparison will use the current value of attributes, not
    the database value'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3371](https://www.sqlalchemy.org/trac/ticket/3371)  ### “否定包含或等于”关系比较将使用属性的当前值，而不是数据库的值'
- en: This change is new as of 1.0.1; while we would have preferred for this to be
    in 1.0.0, it only became apparent as a result of [#3371](https://www.sqlalchemy.org/trac/ticket/3371).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这个改变是在1.0.1中新增的；虽然我们本来希望这个改变在1.0.0中，但这只是由于[#3371](https://www.sqlalchemy.org/trac/ticket/3371)才显现出来的。
- en: 'Given a mapping:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个映射：
- en: '[PRE47]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Given `A`, with primary key of 7, but which we changed to be 10 without flushing:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 给定`A`，主键为7，但我们将其更改为10而没有刷新：
- en: '[PRE48]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'A query against a many-to-one relationship with this object as the target will
    use the value 10 in the bound parameters:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 对于以这个对象为目标的多对一关系的查询，将在绑定参数中使用值10：
- en: '[PRE49]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Produces:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 生成：
- en: '[PRE50]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'However, before this change, the negation of this criteria would **not** use
    10, it would use 7, unless the object were flushed first:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在这个改变之前，这个条件的否定**不会**使用10，而是会使用7，除非对象首先被刷新：
- en: '[PRE51]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Produces (in 0.9 and all versions prior to 1.0.1):'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 生成（在0.9版本和1.0.1之前的所有版本中）：
- en: '[PRE52]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'For a transient object, it would produce a broken query:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个瞬态对象，它会产生一个错误的查询：
- en: '[PRE53]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This inconsistency has been repaired, and in all queries the current attribute
    value, in this example `10`, will now be used.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这种不一致性已经修复，在所有查询中，当前属性值，例如本例中的`10`，现在将被使用。
- en: '[#3374](https://www.sqlalchemy.org/trac/ticket/3374)  ### Changes to attribute
    events and other operations regarding attributes that have no pre-existing value'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3374](https://www.sqlalchemy.org/trac/ticket/3374)  ### 关于没有预先存在的值的属性事件和其他操作的更改'
- en: In this change, the default return value of `None` when accessing an object
    is now returned dynamically on each access, rather than implicitly setting the
    attribute’s state with a special “set” operation when it is first accessed. The
    visible result of this change is that `obj.__dict__` is not implicitly modified
    on get, and there are also some minor behavioral changes for [`get_history()`](../orm/session_api.html#sqlalchemy.orm.attributes.get_history
    "sqlalchemy.orm.attributes.get_history") and related functions.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个改变中，当访问一个对象时，默认的返回值`None`现在会在每次访问时动态返回，而不是在首次访问时通过特殊的“设置”操作隐式地设置属性的状态。这个改变的可见结果是，在获取时不会隐式修改`obj.__dict__`，并且对于[`get_history()`](../orm/session_api.html#sqlalchemy.orm.attributes.get_history
    "sqlalchemy.orm.attributes.get_history")和相关函数也有一些微小的行为变化。
- en: 'Given an object with no state:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个没有状态的对象：
- en: '[PRE54]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'It has always been SQLAlchemy’s behavior such that if we access a scalar or
    many-to-one attribute that was never set, it is returned as `None`:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy一直以来的行为是，如果我们访问一个从未设置过的标量或多对一属性，它会返回`None`：
- en: '[PRE55]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'This value of `None` is in fact now part of the state of `obj`, and is not
    unlike as though we had set the attribute explicitly, e.g. `obj.someattr = None`.
    However, the “set on get” here would behave differently as far as history and
    events. It would not emit any attribute event, and additionally if we view history,
    we see this:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`None`值实际上现在是`obj`状态的一部分，就像我们明确设置了属性一样，例如`obj.someattr = None`。然而，在这里“获取时设置”的行为会因为历史和事件而有所不同。它不会触发任何属性事件，并且另外如果我们查看历史，我们会看到这样：
- en: '[PRE56]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'That is, it’s as though the attribute were always `None` and were never changed.
    This is explicitly different from if we had set the attribute first instead:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，就好像属性始终是`None`，并且从未更改过一样。这与我们首先设置属性的情况明显不同：
- en: '[PRE57]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: The above means that the behavior of our “set” operation can be corrupted by
    the fact that the value was accessed via “get” earlier. In 1.0, this inconsistency
    has been resolved, by no longer actually setting anything when the default “getter”
    is used.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 以上意味着我们的“设置”操作的行为可以被访问到的值通过“获取”而访问的事实破坏。在1.0中，这种不一致性已经解决了，不再实际设置任何东西当使用默认的“getter”时。
- en: '[PRE58]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The reason the above behavior hasn’t had much impact is because the INSERT statement
    in relational databases considers a missing value to be the same as NULL in most
    cases. Whether SQLAlchemy received a history event for a particular attribute
    set to None or not would usually not matter; as the difference between sending
    None/NULL or not wouldn’t have an impact. However, as [#3060](https://www.sqlalchemy.org/trac/ticket/3060)
    (described here in [Priority of attribute changes on relationship-bound attributes
    vs. FK-bound may appear to change](#migration-3060)) illustrates, there are some
    seldom edge cases where we do in fact want to positively have `None` set. Also,
    allowing the attribute event here means it’s now possible to create “default value”
    functions for ORM mapped attributes.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 上述行为之所以没有产生太大影响，是因为在关系数据库中的插入语句在大多数情况下将缺失值视为 NULL。无论 SQLAlchemy 是否收到了针对特定属性设置为
    None 的历史事件，通常都不会有影响；因为发送 None/NULL 或不发送的区别不会产生影响。但是，正如 [#3060](https://www.sqlalchemy.org/trac/ticket/3060)（在[关系绑定属性与
    FK 绑定属性上的属性更改的优先级可能会发生变化](#migration-3060)中描述的那样）所示，有一些罕见的边缘情况，我们实际上确实希望明确设置为
    `None`。此外，在此处允许属性事件意味着现在可以为 ORM 映射属性创建“默认值”函数。
- en: As part of this change, the generation of the implicit “None” is now disabled
    for other situations where this used to occur; this includes when an attribute
    set operation on a many-to-one is received; previously, the “old” value would
    be “None” if it had been not set otherwise; it now will send the value `NEVER_SET`,
    which is a value that may be sent to an attribute listener now. This symbol may
    also be received when calling on mapper utility functions such as [`Mapper.primary_key_from_instance()`](../orm/mapping_api.html#sqlalchemy.orm.Mapper.primary_key_from_instance
    "sqlalchemy.orm.Mapper.primary_key_from_instance"); if the primary key attributes
    have no setting at all, whereas the value would be `None` before, it will now
    be the `NEVER_SET` symbol, and no change to the object’s state occurs.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 作为这一变化的一部分，现在已禁用了在其他情况下生成隐式“None”的功能；这包括在接收到对一对多的属性设置操作时；以前，如果“旧”值未设置，则“旧”值将为“None”；现在将发送值
    `NEVER_SET`，这是一个现在可以发送到属性监听器的值。当调用诸如 [`Mapper.primary_key_from_instance()`](../orm/mapping_api.html#sqlalchemy.orm.Mapper.primary_key_from_instance
    "sqlalchemy.orm.Mapper.primary_key_from_instance") 这样的映射器实用程序函数时，如果主键属性根本没有设置，而以前的值为
    `None`，那么现在将是 `NEVER_SET` 符号，并且不会更改对象的状态。
- en: '[#3061](https://www.sqlalchemy.org/trac/ticket/3061)  ### Priority of attribute
    changes on relationship-bound attributes vs. FK-bound may appear to change'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3061](https://www.sqlalchemy.org/trac/ticket/3061)  ### 关系绑定属性与 FK 绑定属性上的属性更改的优先级可能会发生变化'
- en: 'As a side effect of [#3060](https://www.sqlalchemy.org/trac/ticket/3060), setting
    a relationship-bound attribute to `None` is now a tracked history event which
    refers to the intention of persisting `None` to that attribute. As it has always
    been the case that setting a relationship-bound attribute will trump direct assignment
    to the foreign key attributes, a change in behavior can be seen here when assigning
    None. Given a mapping:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 [#3060](https://www.sqlalchemy.org/trac/ticket/3060) 的副作用，将关系绑定属性设置为 `None`
    现在是一个跟踪的历史事件，它指的是将 `None` 持久化到该属性的意图。由于一直都是设置关系绑定属性将优先于直接赋值给外键属性，因此在分配 None 时可以看到行为的变化。给定一个映射：
- en: '[PRE59]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'In 1.0, the relationship-bound attribute takes precedence over the FK-bound
    attribute in all cases, whether or not the value we assign is a reference to an
    `A` object or is `None`. In 0.9, the behavior is inconsistent and only takes effect
    if a value is assigned; the None is not considered:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在 1.0 版本中，无论我们分配的值是对 `A` 对象的引用还是 `None`，关系绑定属性都优先于 FK 绑定属性，这在所有情况下都是成立的。在 0.9
    版本中，行为不一致，并且只有在分配了一个值时才会生效；`None` 不会被考虑：
- en: '[PRE60]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[#3060](https://www.sqlalchemy.org/trac/ticket/3060)  ### session.expunge()
    will fully detach an object that’s been deleted'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3060](https://www.sqlalchemy.org/trac/ticket/3060)  ### session.expunge()
    将完全分离已删除的对象'
- en: 'The behavior of [`Session.expunge()`](../orm/session_api.html#sqlalchemy.orm.Session.expunge
    "sqlalchemy.orm.Session.expunge") had a bug that caused an inconsistency in behavior
    regarding deleted objects. The [`object_session()`](../orm/session_api.html#sqlalchemy.orm.object_session
    "sqlalchemy.orm.object_session") function as well as the [`InstanceState.session`](../orm/internals.html#sqlalchemy.orm.InstanceState.session
    "sqlalchemy.orm.InstanceState.session") attribute would still report object as
    belonging to the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    subsequent to the expunge:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session.expunge()`](../orm/session_api.html#sqlalchemy.orm.Session.expunge
    "sqlalchemy.orm.Session.expunge") 的行为存在一个 bug，导致关于已删除对象的行为存在不一致性。[`object_session()`](../orm/session_api.html#sqlalchemy.orm.object_session
    "sqlalchemy.orm.object_session") 函数以及 [`InstanceState.session`](../orm/internals.html#sqlalchemy.orm.InstanceState.session
    "sqlalchemy.orm.InstanceState.session") 属性仍然会报告对象属于 [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")，即使已经执行了 expunge 操作：'
- en: '[PRE61]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Note that it is normal for `u1 not in sess` to be True while `inspect(u1).session`
    still refers to the session, while the transaction is ongoing subsequent to the
    delete operation and [`Session.expunge()`](../orm/session_api.html#sqlalchemy.orm.Session.expunge
    "sqlalchemy.orm.Session.expunge") has not been called; the full detachment normally
    completes once the transaction is committed. This issue would also impact functions
    that rely on [`Session.expunge()`](../orm/session_api.html#sqlalchemy.orm.Session.expunge
    "sqlalchemy.orm.Session.expunge") such as [`make_transient()`](../orm/session_api.html#sqlalchemy.orm.make_transient
    "sqlalchemy.orm.make_transient").
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当事务正在进行中且尚未调用 [`Session.expunge()`](../orm/session_api.html#sqlalchemy.orm.Session.expunge
    "sqlalchemy.orm.Session.expunge") 时，`u1 not in sess` 为 True 是正常的，而 `inspect(u1).session`
    仍然引用会话；完全分离通常在事务提交后完成。此问题也会影响依赖于 [`Session.expunge()`](../orm/session_api.html#sqlalchemy.orm.Session.expunge
    "sqlalchemy.orm.Session.expunge") 的函数，如 [`make_transient()`](../orm/session_api.html#sqlalchemy.orm.make_transient
    "sqlalchemy.orm.make_transient")。
- en: '[#3139](https://www.sqlalchemy.org/trac/ticket/3139)  ### Joined/Subquery eager
    loading explicitly disallowed with yield_per'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3139](https://www.sqlalchemy.org/trac/ticket/3139)  ### 与 yield_per 明确不兼容的连接/子查询预加载'
- en: 'In order to make the [`Query.yield_per()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.yield_per
    "sqlalchemy.orm.Query.yield_per") method easier to use, an exception is raised
    if any subquery eager loaders, or joined eager loaders that would use collections,
    are to take effect when yield_per is used, as these are currently not compatible
    with yield-per (subquery loading could be in theory, however). When this error
    is raised, the [`lazyload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.lazyload
    "sqlalchemy.orm.lazyload") option can be sent with an asterisk:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使 [`Query.yield_per()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.yield_per
    "sqlalchemy.orm.Query.yield_per") 方法更容易使用，如果在使用 yield_per 时要生效任何子查询预加载程序，或者使用集合的连接预加载程序，则会引发异常，因为这些当前与
    yield-per 不兼容（理论上子查询加载可以兼容）。当引发此错误时，可以使用 [`lazyload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.lazyload
    "sqlalchemy.orm.lazyload") 选项发送一个星号：
- en: '[PRE62]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'or use [`Query.enable_eagerloads()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.enable_eagerloads
    "sqlalchemy.orm.Query.enable_eagerloads"):'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 或者使用 [`Query.enable_eagerloads()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.enable_eagerloads
    "sqlalchemy.orm.Query.enable_eagerloads")：
- en: '[PRE63]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The [`lazyload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.lazyload
    "sqlalchemy.orm.lazyload") option has the advantage that additional many-to-one
    joined loader options can still be used:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '[`lazyload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.lazyload
    "sqlalchemy.orm.lazyload") 选项的优点是仍然可以使用附加的一对多连接加载器选项：'
- en: '[PRE64]  ### Changes and fixes in handling of duplicate join targets'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE64]  ### 处理重复连接目标的更改和修复'
- en: Changes here encompass bugs where an unexpected and inconsistent behavior would
    occur in some scenarios when joining to an entity twice, or to multiple single-table
    entities against the same table, without using a relationship-based ON clause,
    as well as when joining multiple times to the same target relationship.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 此处的更改包括了一些 bug，当连接两次到一个实体时，或者连接到多个单表实体对同一张表时会出现意外和不一致的行为，而不使用基于关系的 ON 子句时，以及当多次连接到相同目标关系时。
- en: 'Starting with a mapping as:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 以以下映射开始：
- en: '[PRE65]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'A query that joins to `A.bs` twice:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 查询两次连接到 `A.bs` 的情况：
- en: '[PRE66]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Will render:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 将呈现为：
- en: '[PRE67]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The query deduplicates the redundant `A.bs` because it is attempting to support
    a case like the following:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 查询对冗余的 `A.bs` 进行了去重，因为它试图支持以下情况：
- en: '[PRE68]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'That is, the `A.bs` is part of a “path”. As part of [#3367](https://www.sqlalchemy.org/trac/ticket/3367),
    arriving at the same endpoint twice without it being part of a larger path will
    now emit a warning:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，`A.bs` 是“路径”的一部分。作为 [#3367](https://www.sqlalchemy.org/trac/ticket/3367)
    的一部分，两次到达相同的终点而不是作为更大路径的一部分将会发出警告：
- en: '[PRE69]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'The bigger change involves when joining to an entity without using a relationship-bound
    path. If we join to `B` twice:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 更大的变化涉及加入到一个实体而不使用关系绑定路径。如果我们两次加入到 `B`：
- en: '[PRE70]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'In 0.9, this would render as follows:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在 0.9 版本中，会呈现如下：
- en: '[PRE71]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: This is problematic since the aliasing is implicit and in the case of different
    ON clauses can lead to unpredictable results.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这是有问题的，因为别名是隐式的，在不同的 ON 子句的情况下可能导致不可预测的结果。
- en: 'In 1.0, no automatic aliasing is applied and we get:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在 1.0 版本中，不会自动应用别名，我们会得到：
- en: '[PRE72]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: This will raise an error from the database. While it might be nice if the “duplicate
    join target” acted identically if we joined both from redundant relationships
    vs. redundant non-relationship based targets, for now we are only changing the
    behavior in the more serious case where implicit aliasing would have occurred
    previously, and only emitting a warning in the relationship case. Ultimately,
    joining to the same thing twice without any aliasing to disambiguate should raise
    an error in all cases.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 这将从数据库中引发错误。虽然如果我们从冗余关系和冗余非关系目标中都加入时，“重复加入目标”表现相同可能更好，但目前我们只在以前会发生隐式别名的更严重情况下更改行为，并且在关系情况下只发出警告。最终，在所有情况下，两次加入相同的内容而没有任何别名以消除歧义应该引发错误。
- en: 'The change also has an impact on single-table inheritance targets. Using a
    mapping as follows:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这个变化也对单表继承目标产生影响。使用以下映射：
- en: '[PRE73]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The two queries at the bottom are equivalent, and should both render the identical
    SQL:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 底部的两个查询是等效的，应该都呈现相同的 SQL：
- en: '[PRE74]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The above SQL is invalid, as it renders “a” within the FROM list twice. However,
    the implicit aliasing bug would occur with the second query only and render this
    instead:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的 SQL 是无效的，因为在 FROM 列表中两次呈现了“a”。然而，隐式别名 bug 只会在第二个查询中发生，并呈现如下：
- en: '[PRE75]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Where above, the second join to “a” is aliased. While this seems convenient,
    it’s not how single-inheritance queries work in general and is misleading and
    inconsistent.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，第二次加入到“a”是有别名的。虽然这看起来很方便，但这不是单继承查询的一般工作方式，而且是误导性和不一致的。
- en: 'The net effect is that applications which were relying on this bug will now
    have an error raised by the database. The solution is to use the expected form.
    When referring to multiple subclasses of a single-inheritance entity in a query,
    you must manually use aliases to disambiguate the table, as all the subclasses
    normally refer to the same table:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序依赖于这个 bug 的应用程序现在会由数据库引发错误。解决方法是使用预期的形式。在查询中引用单继承实体的多个子类时，必须手动使用别名来消除表的歧义，因为所有子类通常指向同一张表：
- en: '[PRE76]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[#3233](https://www.sqlalchemy.org/trac/ticket/3233) [#3367](https://www.sqlalchemy.org/trac/ticket/3367)'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3233](https://www.sqlalchemy.org/trac/ticket/3233) [#3367](https://www.sqlalchemy.org/trac/ticket/3367)'
- en: Deferred Columns No Longer Implicitly Undefer
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 延迟列不再隐式取消延迟
- en: Mapped attributes marked as deferred without explicit undeferral will now remain
    “deferred” even if their column is otherwise present in the result set in some
    way. This is a performance enhancement in that an ORM load no longer spends time
    searching for each deferred column when the result set is obtained. However, for
    an application that has been relying upon this, an explicit [`undefer()`](../orm/queryguide/columns.html#sqlalchemy.orm.undefer
    "sqlalchemy.orm.undefer") or similar option should now be used, in order to prevent
    a SELECT from being emitted when the attribute is accessed.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 标记为延迟的映射属性，即使其列以某种方式出现在结果集中，现在也将保持“延迟”。这是一个性能增强，因为 ORM 加载不再花时间搜索每个延迟列，当结果集被获取时。然而，对于一直依赖于此的应用程序，现在应该使用显式的
    [`undefer()`](../orm/queryguide/columns.html#sqlalchemy.orm.undefer "sqlalchemy.orm.undefer")
    或类似选项，以防止在访问属性时发出 SELECT。
- en: '### Deprecated ORM Event Hooks Removed'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '### 废弃的 ORM 事件钩子已移除'
- en: 'The following ORM event hooks, some of which have been deprecated since 0.5,
    have been removed: `translate_row`, `populate_instance`, `append_result`, `create_instance`.
    The use cases for these hooks originated in the very early 0.1 / 0.2 series of
    SQLAlchemy and have long since been unnecessary. In particular, the hooks were
    largely unusable as the behavioral contracts within these events was strongly
    linked to the surrounding internals, such as how an instance needs to be created
    and initialized as well as how columns are located within an ORM-generated row.
    The removal of these hooks greatly simplifies the mechanics of ORM object loading.  ###
    API Change for new Bundle feature when custom row loaders are used'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '自0.5版本以来已被弃用的以下ORM事件钩子已被移除：`translate_row`、`populate_instance`、`append_result`、`create_instance`。这些钩子的用例起源于非常早期的0.1
    / 0.2系列的SQLAlchemy，并且早已不再需要。特别是，这些钩子在很大程度上无法使用，因为这些事件中的行为契约与周围内部紧密相关，例如实例如何需要被创建和初始化以及列如何在ORM生成的行中定位。移除这些钩子极大地简化了ORM对象加载的机制。  ###
    当使用自定义行加载器时，新Bundle功能的API更改'
- en: 'The new [`Bundle`](../orm/queryguide/api.html#sqlalchemy.orm.Bundle "sqlalchemy.orm.Bundle")
    object of 0.9 has a small change in API, when the `create_row_processor()` method
    is overridden on a custom class. Previously, the sample code looked like:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 0.9版本的新[`Bundle`](../orm/queryguide/api.html#sqlalchemy.orm.Bundle "sqlalchemy.orm.Bundle")对象在API上有一个小改变，当在自定义类上覆盖`create_row_processor()`方法时。之前，示例代码如下：
- en: '[PRE77]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The unused `result` member is now removed:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 未使用的`result`成员现已移除：
- en: '[PRE78]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: See also
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[Grouping Selected Attributes with Bundles](../orm/queryguide/select.html#bundles)  ###
    Right inner join nesting now the default for joinedload with innerjoin=True'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用捆绑组合选择属性](../orm/queryguide/select.html#bundles)  ### 现在默认为使用内连接加载时的右嵌套连接'
- en: The behavior of [`joinedload.innerjoin`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload.params.innerjoin
    "sqlalchemy.orm.joinedload") as well as [`relationship.innerjoin`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.innerjoin
    "sqlalchemy.orm.relationship") is now to use “nested” inner joins, that is, right-nested,
    as the default behavior when an inner join joined eager load is chained to an
    outer join eager load. In order to get the old behavior of chaining all joined
    eager loads as outer join when an outer join is present, use `innerjoin="unnested"`.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '[`joinedload.innerjoin`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload.params.innerjoin
    "sqlalchemy.orm.joinedload")以及[`relationship.innerjoin`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.innerjoin
    "sqlalchemy.orm.relationship")的行为现在是使用“nested”内连接，也就是右嵌套，作为内连接急加载链接到外连接急加载时的默认行为。为了获得当存在外连接时将所有连接急加载链接为外连接的旧行为，请使用`innerjoin="unnested"`。 '
- en: 'As introduced in [Right-nested inner joins available in joined eager loads](migration_09.html#feature-2976)
    from version 0.9, the behavior of `innerjoin="nested"` is that an inner join eager
    load chained to an outer join eager load will use a right-nested join. `"nested"`
    is now implied when using `innerjoin=True`:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 如从0.9版本中的[右嵌套内连接可用于连接的急加载](migration_09.html#feature-2976)中介绍的，`innerjoin="nested"`的行为是，内连接急加载链接到外连接急加载时将使用右嵌套连接。使用`innerjoin=True`时现在隐含了`"nested"`：
- en: '[PRE79]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'With the new default, this will render the FROM clause in the form:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 使用新的默认设置，这将使FROM子句呈现为：
- en: '[PRE80]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: That is, using a right-nested join for the INNER join so that the full result
    of `users` can be returned. The use of an INNER join is more efficient than using
    an OUTER join, and allows the [`joinedload.innerjoin`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload.params.innerjoin
    "sqlalchemy.orm.joinedload") optimization parameter to take effect in all cases.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，使用右嵌套连接进行内连接，以便返回`users`的完整结果。使用内连接比使用外连接更有效，并且允许[`joinedload.innerjoin`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload.params.innerjoin
    "sqlalchemy.orm.joinedload")优化参数在所有情况下生效。
- en: 'To get the older behavior, use `innerjoin="unnested"`:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 要获得旧的行为，请使用`innerjoin="unnested"`：
- en: '[PRE81]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'This will avoid right-nested joins and chain the joins together using all OUTER
    joins despite the innerjoin directive:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这将避免右嵌套连接，并使用所有外连接将连接链接在一起，尽管有内连接指令：
- en: '[PRE82]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: As noted in the 0.9 notes, the only database backend that has difficulty with
    right-nested joins is SQLite; SQLAlchemy as of 0.9 converts a right-nested join
    into a subquery as a join target on SQLite.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 如0.9版本说明中所述，唯一在右嵌套连接方面存在困难的数据库后端是SQLite；截至0.9版本，SQLAlchemy将右嵌套连接转换为SQLite上的子查询作为连接目标。
- en: See also
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[Right-nested inner joins available in joined eager loads](migration_09.html#feature-2976)
    - description of the feature as introduced in 0.9.4.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '[右嵌套内连接在联接急切加载中可用](migration_09.html#feature-2976) - 介绍了0.9.4中引入的功能。'
- en: '[#3008](https://www.sqlalchemy.org/trac/ticket/3008)  ### Subqueries no longer
    applied to uselist=False joined eager loads'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3008](https://www.sqlalchemy.org/trac/ticket/3008)  ### 子查询不再应用于uselist=False的联接急切加载'
- en: 'Given a joined eager load like the following:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 给定如下的联接急切加载：
- en: '[PRE83]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'SQLAlchemy considers the relationship `A.b` to be a “one to many, loaded as
    a single value”, which is essentially a “one to one” relationship. However, joined
    eager loading has always treated the above as a situation where the main query
    needs to be inside a subquery, as would normally be needed for a collection of
    B objects where the main query has a LIMIT applied:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy认为关系`A.b`是“一对多，加载为单个值”，本质上是“一对一”关系。然而，联接的急切加载一直将上述情况视为主查询需要在子查询中的情况，就像在主查询应用了LIMIT时通常需要的B对象集合一样：
- en: '[PRE84]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'However, since the relationship of the inner query to the outer one is that
    at most only one row is shared in the case of `uselist=False` (in the same way
    as a many-to-one), the “subquery” used with LIMIT + joined eager loading is now
    dropped in this case:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于内部查询与外部查询的关系在`uselist=False`的情况下最多只共享一行（就像一对多一样），因此在这种情况下现在会删除带有LIMIT +联接急切加载的“子查询”：
- en: '[PRE85]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: In the case that the LEFT OUTER JOIN returns more than one row, the ORM has
    always emitted a warning here and ignored additional results for `uselist=False`,
    so the results in that error situation should not change.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 如果LEFT OUTER JOIN返回多行，ORM一直会在这里发出警告并忽略`uselist=False`的额外结果，因此在这种错误情况下结果不应更改。
- en: '[#3249](https://www.sqlalchemy.org/trac/ticket/3249)'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3249](https://www.sqlalchemy.org/trac/ticket/3249)'
- en: query.update() / query.delete() raises if used with join(), select_from(), from_self()
  id: totrans-295
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: query.update() / query.delete()如果与join()，select_from()，from_self()一起使用会引发异常
- en: A warning is emitted in SQLAlchemy 0.9.10 (not yet released as of June 9, 2015)
    when the [`Query.update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.update
    "sqlalchemy.orm.Query.update") or [`Query.delete()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.delete
    "sqlalchemy.orm.Query.delete") methods are invoked against a query which has also
    called upon [`Query.join()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join"), [`Query.outerjoin()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.outerjoin
    "sqlalchemy.orm.Query.outerjoin"), [`Query.select_from()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.select_from
    "sqlalchemy.orm.Query.select_from") or `Query.from_self()`. These are unsupported
    use cases which silently fail in the 0.9 series up until 0.9.10 where it emits
    a warning. In 1.0, these cases raise an exception.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在SQLAlchemy 0.9.10中（截至2015年6月9日尚未发布），当调用[`Query.update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.update
    "sqlalchemy.orm.Query.update")或[`Query.delete()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.delete
    "sqlalchemy.orm.Query.delete")方法时，如果查询还调用了[`Query.join()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join")，[`Query.outerjoin()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.outerjoin
    "sqlalchemy.orm.Query.outerjoin")，[`Query.select_from()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.select_from
    "sqlalchemy.orm.Query.select_from")或`Query.from_self()`，则会发出警告。这些是不受支持的用例，在0.9系列中静默失败，直到0.9.10发出警告。在1.0中，这些情况会引发异常。
- en: '[#3349](https://www.sqlalchemy.org/trac/ticket/3349)'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3349](https://www.sqlalchemy.org/trac/ticket/3349)'
- en: query.update() with `synchronize_session='evaluate'` raises on multi-table update
  id: totrans-298
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用`synchronize_session='evaluate'`的query.update()在多表更新时会引发异常
- en: The “evaluator” for [`Query.update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.update
    "sqlalchemy.orm.Query.update") won’t work with multi-table updates, and needs
    to be set to `synchronize_session=False` or `synchronize_session='fetch'` when
    multiple tables are present. The new behavior is that an explicit exception is
    now raised, with a message to change the synchronize setting. This is upgraded
    from a warning emitted as of 0.9.7.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Query.update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.update
    "sqlalchemy.orm.Query.update")的“评估器”在多表更新时不起作用，当存在多个表时需要将其设置为`synchronize_session=False`或`synchronize_session=''fetch''`。新行为是现在会显式引发异常，并提醒更改同步设置。这是从0.9.7开始发出的警告升级而来。'
- en: '[#3117](https://www.sqlalchemy.org/trac/ticket/3117)'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3117](https://www.sqlalchemy.org/trac/ticket/3117)'
- en: Resurrect Event has been Removed
  id: totrans-301
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 复活的事件已被移除
- en: The “resurrect” ORM event has been removed entirely. This event ceased to have
    any function since version 0.8 removed the older “mutable” system from the unit
    of work.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: “复活”ORM事件已完全移除。自0.8版本移除工作单元中的旧“可变”系统以来，此事件已不再起作用。
- en: '### Change to single-table-inheritance criteria when using from_self(), count()'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '### 使用from_self()，count()时更改为单表继承条件'
- en: 'Given a single-table inheritance mapping, such as:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 给定单表继承映射，例如：
- en: '[PRE86]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Using `Query.from_self()` or [`Query.count()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.count
    "sqlalchemy.orm.Query.count") against a subclass would produce a subquery, but
    then add the “WHERE” criteria for subtypes to the outside:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 对子类使用`Query.from_self()`或[`Query.count()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.count
    "sqlalchemy.orm.Query.count")会产生一个子查询，然后将子类型的“WHERE”条件添加到外部：
- en: '[PRE87]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'rendering:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染：
- en: '[PRE88]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'The issue with this is that if the inner query does not specify all columns,
    then we can’t add the WHERE clause on the outside (it actually tries, and produces
    a bad query). This decision apparently goes way back to 0.6.5 with the note “may
    need to make more adjustments to this”. Well, those adjustments have arrived!
    So now the above query will render:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于，如果内部查询没有指定所有列，那么我们无法在外部添加WHERE子句（实际上会尝试，并生成错误的查询）。这个决定显然可以追溯到0.6.5版本，注释中写着“可能需要对此进行更多调整”。好吧，这些调整已经到位！因此，上述查询现在将渲染为：
- en: '[PRE89]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'So that queries that don’t include “type” will still work!:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，即使不包括“type”的查询也能正常工作！：
- en: '[PRE90]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Renders:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染：
- en: '[PRE91]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[#3177](https://www.sqlalchemy.org/trac/ticket/3177)  ### single-table-inheritance
    criteria added to all ON clauses unconditionally'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3177](https://www.sqlalchemy.org/trac/ticket/3177)  ### 单表继承条件无条件添加到所有ON子句'
- en: 'When joining to a single-table inheritance subclass target, the ORM always
    adds the “single table criteria” when joining on a relationship. Given a mapping
    as:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 当连接到单表继承子类目标时，ORM始终在连接关系时添加“单表条件”。给定映射如下：
- en: '[PRE92]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'It’s been the behavior for quite some time that a JOIN on the relationship
    will render a “single inheritance” clause for the type:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 长期以来，JOIN关系的行为是为类型渲染“单一继承”子句：
- en: '[PRE93]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'SQL output:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: SQL输出：
- en: '[PRE94]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Above, because we joined to a subclass `FooWidget`, [`Query.join()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join") knew to add the `AND widget.type IN ('foo')` criteria
    to the ON clause.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 上面，因为我们连接到子类`FooWidget`，[`Query.join()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join")知道要将`AND widget.type IN ('foo')`条件添加到ON子句中。
- en: 'The change here is that the `AND widget.type IN()` criteria is now appended
    to *any* ON clause, not just those generated from a relationship, including one
    that is explicitly stated:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 此处的更改是现在`AND widget.type IN()`条件现在附加到*任何*ON子句，而不仅仅是从关系生成的子句，包括明确声明的子句：
- en: '[PRE95]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'As well as the “implicit” join when no ON clause of any kind is stated:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 以及当没有任何ON子句时的“隐式”连接：
- en: '[PRE96]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Previously, the ON clause for these would not include the single-inheritance
    criteria. Applications that are already adding this criteria to work around this
    will want to remove its explicit use, though it should continue to work fine if
    the criteria happens to be rendered twice in the meantime.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，这些的ON子句不会包括单一继承条件。已经为了解决此问题而添加此条件的应用程序将希望删除其显式使用，尽管在此期间如果条件恰好被重复渲染，它应该继续正常工作。
- en: See also
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[Changes and fixes in handling of duplicate join targets](#bug-3233)'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '[处理重复连接目标的更改和修复](#bug-3233)'
- en: '[#3222](https://www.sqlalchemy.org/trac/ticket/3222)'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3222](https://www.sqlalchemy.org/trac/ticket/3222)'
- en: Key Behavioral Changes - Core
  id: totrans-332
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关键行为变化 - 核心
- en: '### Warnings emitted when coercing full SQL fragments into text()'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '### 在将完整SQL片段强制转换为text()时发出警告'
- en: Since SQLAlchemy’s inception, there has always been an emphasis on not getting
    in the way of the usage of plain text. The Core and ORM expression systems were
    intended to allow any number of points at which the user can just use plain text
    SQL expressions, not just in the sense that you can send a full SQL string to
    [`Connection.execute()`](../core/connections.html#sqlalchemy.engine.Connection.execute
    "sqlalchemy.engine.Connection.execute"), but that you can send strings with SQL
    expressions into many functions, such as [`Select.where()`](../core/selectable.html#sqlalchemy.sql.expression.Select.where
    "sqlalchemy.sql.expression.Select.where"), [`Query.filter()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.filter
    "sqlalchemy.orm.Query.filter"), and [`Select.order_by()`](../core/selectable.html#sqlalchemy.sql.expression.Select.order_by
    "sqlalchemy.sql.expression.Select.order_by").
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 自SQLAlchemy创建以来，一直强调不妨碍使用纯文本。Core和ORM表达式系统旨在允许用户在任何可以使用纯文本SQL表达式的地方使用纯文本，不仅仅是您可以将完整的SQL字符串发送到[`Connection.execute()`](../core/connections.html#sqlalchemy.engine.Connection.execute
    "sqlalchemy.engine.Connection.execute")，而且您可以将带有SQL表达式的字符串发送到许多函数中，例如[`Select.where()`](../core/selectable.html#sqlalchemy.sql.expression.Select.where
    "sqlalchemy.sql.expression.Select.where")，[`Query.filter()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.filter
    "sqlalchemy.orm.Query.filter")和[`Select.order_by()`](../core/selectable.html#sqlalchemy.sql.expression.Select.order_by
    "sqlalchemy.sql.expression.Select.order_by")。
- en: 'Note that by “SQL expressions” we mean a **full fragment of a SQL string**,
    such as:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这里所说的“SQL表达式”是指**完整的SQL字符串片段**，例如：
- en: '[PRE97]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'and we are **not talking about string arguments**, that is, the normal behavior
    of passing string values that become parameterized:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 我们**不是在讨论字符串参数**，即传递成为参数化的字符串值的正常行为：
- en: '[PRE98]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: The Core tutorial has long featured an example of the use of this technique,
    using a [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") construct where virtually all components of
    it are specified as straight strings. However, despite this long-standing behavior
    and example, users are apparently surprised that this behavior exists, and when
    asking around the community, I was unable to find any user that was in fact *not*
    surprised that you can send a full string into a method like [`Query.filter()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.filter
    "sqlalchemy.orm.Query.filter").
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: Core教程长期以来一直以使用这种技术的示例为特色，使用[`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select")构造，其中几乎所有组件都被指定为纯字符串。然而，尽管存在这种长期行为和示例，用户显然对这种行为感到惊讶，当在社区中询问时，我无法找到任何用户实际上*不*感到惊讶，即您可以将完整字符串发送到像[`Query.filter()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.filter
    "sqlalchemy.orm.Query.filter")这样的方法中。
- en: 'So the change here is to encourage the user to qualify textual strings when
    composing SQL that is partially or fully composed from textual fragments. When
    composing a select as below:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这里的更改是鼓励用户在部分或完全由文本片段组成的SQL中对文本字符串进行限定。在如下组合select时：
- en: '[PRE99]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'The statement is built up normally, with all the same coercions as before.
    However, one will see the following warnings emitted:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 语句正常构建，与以前的所有强制转换相同。然而，将会看到以下警告被发出：
- en: '[PRE100]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'These warnings attempt to show exactly where the issue is by displaying the
    parameters as well as where the string was received. The warnings make use of
    the [Session.get_bind() handles a wider variety of inheritance scenarios](#feature-3178)
    so that parameterized warnings can be emitted safely without running out of memory,
    and as always, if one wishes the warnings to be exceptions, the [Python Warnings
    Filter](https://docs.python.org/2/library/warnings.html) should be used:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 这些警告试图通过显示参数以及字符串接收位置来准确指出问题所在。这些警告利用[Session.get_bind()处理更广泛的继承场景](#feature-3178)，以便可以安全地发出参数化警告而不会耗尽内存，如果希望将警告作为异常处理，应使用[Python警告过滤器](https://docs.python.org/2/library/warnings.html)：
- en: '[PRE101]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Given the above warnings, our statement works just fine, but to get rid of
    the warnings we would rewrite our statement as follows:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于上述警告，我们的语句运行正常，但为了摆脱警告，我们将重写我们的语句如下：
- en: '[PRE102]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'and as the warnings suggest, we can give our statement more specificity about
    the text if we use [`column()`](../core/sqlelement.html#sqlalchemy.sql.expression.column
    "sqlalchemy.sql.expression.column") and [`table()`](../core/selectable.html#sqlalchemy.sql.expression.table
    "sqlalchemy.sql.expression.table"):'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 正如警告所建议的那样，如果我们使用[`column()`](../core/sqlelement.html#sqlalchemy.sql.expression.column
    "sqlalchemy.sql.expression.column")和[`table()`](../core/selectable.html#sqlalchemy.sql.expression.table
    "sqlalchemy.sql.expression.table")，我们可以使我们的语句对文本更具体：
- en: '[PRE103]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: Where note also that [`table()`](../core/selectable.html#sqlalchemy.sql.expression.table
    "sqlalchemy.sql.expression.table") and [`column()`](../core/sqlelement.html#sqlalchemy.sql.expression.column
    "sqlalchemy.sql.expression.column") can now be imported from “sqlalchemy” without
    the “sql” part.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 还请注意，现在可以从“sqlalchemy”导入 [`table()`](../core/selectable.html#sqlalchemy.sql.expression.table
    "sqlalchemy.sql.expression.table") 和 [`column()`](../core/sqlelement.html#sqlalchemy.sql.expression.column
    "sqlalchemy.sql.expression.column") 而不需要“sql”部分。
- en: The behavior here applies to [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") as well as to key methods on [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query"), including [`Query.filter()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.filter
    "sqlalchemy.orm.Query.filter"), [`Query.from_statement()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.from_statement
    "sqlalchemy.orm.Query.from_statement") and [`Query.having()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.having
    "sqlalchemy.orm.Query.having").
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 此处的行为适用于 [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") 以及 [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") 上的关键方法，包括 [`Query.filter()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.filter
    "sqlalchemy.orm.Query.filter")、[`Query.from_statement()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.from_statement
    "sqlalchemy.orm.Query.from_statement") 和 [`Query.having()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.having
    "sqlalchemy.orm.Query.having")。
- en: ORDER BY and GROUP BY are special cases
  id: totrans-352
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: ORDER BY 和 GROUP BY 是特殊情况。
- en: 'There is one case where usage of a string has special meaning, and as part
    of this change we have enhanced its functionality. When we have a [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") or [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") that refers to some column name or named label, we might
    want to GROUP BY and/or ORDER BY known columns or labels:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种情况下，使用字符串具有特殊含义，并且作为此更改的一部分，我们增强了其功能。当我们有一个引用某列名或命名标签的 [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") 或 [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") 时，我们可能想要对已知列或标签进行 GROUP BY 和/或 ORDER BY：
- en: '[PRE104]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'In the above statement we expect to see “ORDER BY id_count”, as opposed to
    a re-statement of the function. The string argument given is actively matched
    to an entry in the columns clause during compilation, so the above statement would
    produce as we expect, without warnings (though note that the `"name"` expression
    has been resolved to `users.name`!):'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述语句中，我们期望看到“ORDER BY id_count”，而不是函数的重新陈述。在编译期间，字符串参数会被主动与列子句中的条目匹配，因此上述语句将产生我们期望的结果，不会有警告（尽管请注意
    `"name"` 表达式已解析为 `users.name`！）：
- en: '[PRE105]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'However, if we refer to a name that cannot be located, then we get the warning
    again, as below:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果我们引用无法定位的名称，则会再次收到警告，如下所示：
- en: '[PRE106]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'The output does what we say, but again it warns us:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 输出确实按我们说的做了，但再次警告我们：
- en: '[PRE107]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: The above behavior applies to all those places where we might want to refer
    to a so-called “label reference”; ORDER BY and GROUP BY, but also within an OVER
    clause as well as a DISTINCT ON clause that refers to columns (e.g. the PostgreSQL
    syntax).
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 上述行为适用于我们可能想要引用所谓的“标签引用”的所有地方；ORDER BY 和 GROUP BY，以及 OVER 子句和 DISTINCT ON 子句内引用列的地方（例如
    PostgreSQL 语法）。
- en: 'We can still specify any arbitrary expression for ORDER BY or others using
    [`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text "sqlalchemy.sql.expression.text"):'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然可以使用 [`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text "sqlalchemy.sql.expression.text")
    指定任意表达式用于 ORDER BY 或其他地方：
- en: '[PRE109]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: The upshot of the whole change is that SQLAlchemy now would like us to tell
    it when a string is sent that this string is explicitly a [`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text
    "sqlalchemy.sql.expression.text") construct, or a column, table, etc., and if
    we use it as a label name in an order by, group by, or other expression, SQLAlchemy
    expects that the string resolves to something known, else it should again be qualified
    with [`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text "sqlalchemy.sql.expression.text")
    or similar.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 整个更改的结果是，SQLAlchemy 现在希望我们告诉它当发送一个字符串时，该字符串明确是一个 [`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text
    "sqlalchemy.sql.expression.text") 构造，或者是列、表等，如果我们将其用作 order by、group by 或其他表达式中的标签名称，则
    SQLAlchemy 期望该字符串解析为已知内容，否则它应该再次使用 [`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text
    "sqlalchemy.sql.expression.text") 或类似内容进行限定。
- en: '[#2992](https://www.sqlalchemy.org/trac/ticket/2992)  ### Python-side defaults
    invoked for each row individually when using a multivalued insert'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2992](https://www.sqlalchemy.org/trac/ticket/2992)  ### 使用多值插入时，为每一行单独调用
    Python 端默认值'
- en: Support for Python-side column defaults when using the multi-valued version
    of [`Insert.values()`](../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") were essentially not implemented, and
    would only work “by accident” in specific situations, when the dialect in use
    was using a non-positional (e.g. named) style of bound parameter, and when it
    was not necessary that a Python-side callable be invoked for each row.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用[`Insert.values()`](../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values")的多值版本时，对于 Python 端列默认值的支持基本上没有实现，并且只会在特定情况下“意外”工作，当使用的方言使用非位置（例如，命名）风格的绑定参数，并且不需要为每一行调用
    Python 端可调用时。
- en: 'The feature has been overhauled so that it works more similarly to that of
    an “executemany” style of invocation:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 该功能已进行了改进，使其更类似于“executemany”样式的调用：
- en: '[PRE110]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'The above example will invoke `next(counter)` for each row individually as
    would be expected:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例将为每一行单独调用`next(counter)`，这是预期的行为：
- en: '[PRE111]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Previously, a positional dialect would fail as a bind would not be generated
    for additional positions:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，位置方言会失败，因为不会为额外的位置生成绑定：
- en: '[PRE112]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'And with a “named” dialect, the same value for “id” would be re-used in each
    row (hence this change is backwards-incompatible with a system that relied on
    this):'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 并且使用“命名”方言时，“id”的相同值将在每一行中重新使用（因此，此更改与依赖于此的系统不兼容）：
- en: '[PRE113]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'The system will also refuse to invoke a “server side” default as inline-rendered
    SQL, since it cannot be guaranteed that a server side default is compatible with
    this. If the VALUES clause renders for a specific column, then a Python-side value
    is required; if an omitted value only refers to a server-side default, an exception
    is raised:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 系统还将拒绝将“服务器端”默认值作为内联渲染的 SQL 调用，因为无法保证服务器端默认值与此兼容。如果 VALUES 子句为特定列渲染，则需要 Python
    端值；如果省略的值仅引用服务器端默认值，则会引发异常：
- en: '[PRE114]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'will raise:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 将会引发：
- en: '[PRE115]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'Previously, the value “d1” would be copied into that of the third row (but
    again, only with named format!):'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，“d1”值将被复制到第三行的值中（但仅适用于命名格式！）：
- en: '[PRE116]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[#3288](https://www.sqlalchemy.org/trac/ticket/3288)  ### Event listeners can
    not be added or removed from within that event’s runner'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3288](https://www.sqlalchemy.org/trac/ticket/3288)  ### 无法在事件的运行器内添加或删除事件侦听器'
- en: Removal of an event listener from inside that same event itself would modify
    the elements of a list during iteration, which would cause still-attached event
    listeners to silently fail to fire. To prevent this while still maintaining performance,
    the lists have been replaced with `collections.deque()`, which does not allow
    any additions or removals during iteration, and instead raises `RuntimeError`.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 在事件内部从中删除事件侦听器将在迭代过程中修改列表的元素，这将导致仍附加的事件侦听器无声地失败。为了防止这种情况，同时保持性能，这些列表已被替换为`collections.deque()`，在迭代过程中不允许添加或删除，并且会引发`RuntimeError`。
- en: '[#3163](https://www.sqlalchemy.org/trac/ticket/3163)  ### The INSERT…FROM SELECT
    construct now implies `inline=True`'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3163](https://www.sqlalchemy.org/trac/ticket/3163)  ### INSERT…FROM SELECT
    构造现在意味着 `inline=True`'
- en: Using [`Insert.from_select()`](../core/dml.html#sqlalchemy.sql.expression.Insert.from_select
    "sqlalchemy.sql.expression.Insert.from_select") now implies `inline=True` on [`insert()`](../core/dml.html#sqlalchemy.sql.expression.insert
    "sqlalchemy.sql.expression.insert"). This helps to fix a bug where an INSERT…FROM
    SELECT construct would inadvertently be compiled as “implicit returning” on supporting
    backends, which would cause breakage in the case of an INSERT that inserts zero
    rows (as implicit returning expects a row), as well as arbitrary return data in
    the case of an INSERT that inserts multiple rows (e.g. only the first row of many).
    A similar change is also applied to an INSERT..VALUES with multiple parameter
    sets; implicit RETURNING will no longer emit for this statement either. As both
    of these constructs deal with variable numbers of rows, the `ResultProxy.inserted_primary_key`
    accessor does not apply. Previously, there was a documentation note that one may
    prefer `inline=True` with INSERT..FROM SELECT as some databases don’t support
    returning and therefore can’t do “implicit” returning, but there’s no reason an
    INSERT…FROM SELECT needs implicit returning in any case. Regular explicit [`Insert.returning()`](../core/dml.html#sqlalchemy.sql.expression.Insert.returning
    "sqlalchemy.sql.expression.Insert.returning") should be used to return variable
    numbers of result rows if inserted data is needed.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 现在使用[`Insert.from_select()`](../core/dml.html#sqlalchemy.sql.expression.Insert.from_select
    "sqlalchemy.sql.expression.Insert.from_select")会隐含在[`insert()`](../core/dml.html#sqlalchemy.sql.expression.insert
    "sqlalchemy.sql.expression.insert")上设置`inline=True`。这有助于修复一个错误，即INSERT…FROM SELECT结构会在支持的后端上不经意地编译为“implicit
    returning”，这会导致在插入零行的情况下（因为implicit returning需要一行）出现故障，以及在插入多行的情况下出现任意返回数据（例如，许多行中的第一行）。类似的更改也应用于具有多个参数集的INSERT..VALUES；这种语句也不会再发出implicit
    RETURNING。由于这两个结构都涉及可变数量的行，因此`ResultProxy.inserted_primary_key`访问器不适用。以前，有一个文档说明，即在一些数据库不支持返回的情况下，可能更喜欢`inline=True`与INSERT..FROM
    SELECT，因此无法执行“implicit”返回，但无论如何，INSERT…FROM SELECT都不需要implicit returning。如果需要插入的数据，应该使用常规的显式[`Insert.returning()`](../core/dml.html#sqlalchemy.sql.expression.Insert.returning
    "sqlalchemy.sql.expression.Insert.returning")来返回可变数量的结果行。
- en: '[#3169](https://www.sqlalchemy.org/trac/ticket/3169)  ### `autoload_with` now
    implies `autoload=True`'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3169](https://www.sqlalchemy.org/trac/ticket/3169)  ### `autoload_with` 现在隐含了
    `autoload=True`'
- en: 'A [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    can be set up for reflection by passing [`Table.autoload_with`](../core/metadata.html#sqlalchemy.schema.Table.params.autoload_with
    "sqlalchemy.schema.Table") alone:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 通过仅传递[`Table.autoload_with`](../core/metadata.html#sqlalchemy.schema.Table.params.autoload_with
    "sqlalchemy.schema.Table")，可以设置[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")以进行反射。
- en: '[PRE117]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[#3027](https://www.sqlalchemy.org/trac/ticket/3027)  ### DBAPI exception wrapping
    and handle_error() event improvements'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3027](https://www.sqlalchemy.org/trac/ticket/3027)  ### DBAPI异常包装和`handle_error()`事件改进'
- en: SQLAlchemy’s wrapping of DBAPI exceptions was not taking place in the case where
    a [`Connection`](../core/connections.html#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    object was invalidated, and then tried to reconnect and encountered an error;
    this has been resolved.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 在[`Connection`](../core/connections.html#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")对象失效后，尝试重新连接并遇到错误时，SQLAlchemy对DBAPI异常的包装没有发生；这个问题已经解决。
- en: Additionally, the recently added `ConnectionEvents.handle_error()` event is
    now invoked for errors that occur upon initial connect, upon reconnect, and when
    [`create_engine()`](../core/engines.html#sqlalchemy.create_engine "sqlalchemy.create_engine")
    is used given a custom connection function via [`create_engine.creator`](../core/engines.html#sqlalchemy.create_engine.params.creator
    "sqlalchemy.create_engine").
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，最近添加的`ConnectionEvents.handle_error()`事件现在在初始连接、重新连接时以及当通过[`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine")给定自定义连接函数时被调用。
- en: The [`ExceptionContext`](../core/connections.html#sqlalchemy.engine.ExceptionContext
    "sqlalchemy.engine.ExceptionContext") object has a new datamember [`ExceptionContext.engine`](../core/connections.html#sqlalchemy.engine.ExceptionContext.engine
    "sqlalchemy.engine.ExceptionContext.engine") that will always refer to the [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") in use, in those cases when the [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") object is not available (e.g. on initial connect).
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '[`ExceptionContext`](../core/connections.html#sqlalchemy.engine.ExceptionContext
    "sqlalchemy.engine.ExceptionContext") 对象有一个新的数据成员[`ExceptionContext.engine`](../core/connections.html#sqlalchemy.engine.ExceptionContext.engine
    "sqlalchemy.engine.ExceptionContext.engine")，它将始终指向正在使用的[`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine")，在那些[`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")对象不可用的情况下（例如在初始连接时）。'
- en: '[#3266](https://www.sqlalchemy.org/trac/ticket/3266)  ### ForeignKeyConstraint.columns
    is now a ColumnCollection'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3266](https://www.sqlalchemy.org/trac/ticket/3266)  ### ForeignKeyConstraint.columns
    现在是一个 ColumnCollection'
- en: '[`ForeignKeyConstraint.columns`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint.columns
    "sqlalchemy.schema.ForeignKeyConstraint.columns") was previously a plain list
    containing either strings or [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects, depending on how the [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") was constructed and whether it was associated
    with a table. The collection is now a [`ColumnCollection`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnCollection
    "sqlalchemy.sql.expression.ColumnCollection"), and is only initialized after the
    [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") is associated with a [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table"). A new accessor [`ForeignKeyConstraint.column_keys`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint.column_keys
    "sqlalchemy.schema.ForeignKeyConstraint.column_keys") is added to unconditionally
    return string keys for the local set of columns regardless of how the object was
    constructed or its current state.  ### MetaData.sorted_tables accessor is “deterministic”'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: '[`ForeignKeyConstraint.columns`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint.columns
    "sqlalchemy.schema.ForeignKeyConstraint.columns")以前是一个普通列表，其中包含字符串或[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")对象，具体取决于如何构建[`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint")以及它是否与表相关联。该集合现在是一个[`ColumnCollection`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnCollection
    "sqlalchemy.sql.expression.ColumnCollection")，并且仅在[`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint")与[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")相关联后才初始化。添加了一个新的访问器[`ForeignKeyConstraint.column_keys`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint.column_keys
    "sqlalchemy.schema.ForeignKeyConstraint.column_keys")，无论对象如何构建或其当前状态如何，都会无条件地返回本地列集的字符串键。  ###
    MetaData.sorted_tables 访问器是“确定性的”'
- en: The sorting of tables resulting from the [`MetaData.sorted_tables`](../core/metadata.html#sqlalchemy.schema.MetaData.sorted_tables
    "sqlalchemy.schema.MetaData.sorted_tables") accessor is “deterministic”; the ordering
    should be the same in all cases regardless of Python hashing. This is done by
    first sorting the tables by name before passing them to the topological algorithm,
    which maintains that ordering as it iterates.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 由[`MetaData.sorted_tables`](../core/metadata.html#sqlalchemy.schema.MetaData.sorted_tables
    "sqlalchemy.schema.MetaData.sorted_tables")访问器返回的表的排序是“确定性的”；无论Python哈希如何，排序在所有情况下都应该是相同的。这是通过首先按名称对表进行排序，然后将它们传递给拓扑算法来实现的，该算法在迭代时保持该顺序。
- en: Note that this change does **not** yet apply to the ordering applied when emitting
    [`MetaData.create_all()`](../core/metadata.html#sqlalchemy.schema.MetaData.create_all
    "sqlalchemy.schema.MetaData.create_all") or [`MetaData.drop_all()`](../core/metadata.html#sqlalchemy.schema.MetaData.drop_all
    "sqlalchemy.schema.MetaData.drop_all").
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，此更改**尚未**应用于发出[`MetaData.create_all()`](../core/metadata.html#sqlalchemy.schema.MetaData.create_all
    "sqlalchemy.schema.MetaData.create_all")或[`MetaData.drop_all()`](../core/metadata.html#sqlalchemy.schema.MetaData.drop_all
    "sqlalchemy.schema.MetaData.drop_all")时应用的排序。
- en: '[#3084](https://www.sqlalchemy.org/trac/ticket/3084)  ### null(), false() and
    true() constants are no longer singletons'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3084](https://www.sqlalchemy.org/trac/ticket/3084)  ### null()、false()和true()常量不再是单例'
- en: 'These three constants were changed to return a “singleton” value in 0.9; unfortunately,
    that would lead to a query like the following to not render as expected:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个常量在 0.9 中被更改为返回“单例”值；不幸的是，这将导致类似以下的查询无法按预期渲染：
- en: '[PRE118]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: rendering only `SELECT NULL AS anon_1`, because the two [`null()`](../core/sqlelement.html#sqlalchemy.sql.expression.null
    "sqlalchemy.sql.expression.null") constructs would come out as the same `NULL`
    object, and SQLAlchemy’s Core model is based on object identity in order to determine
    lexical significance. The change in 0.9 had no importance other than the desire
    to save on object overhead; in general, an unnamed construct needs to stay lexically
    unique so that it gets labeled uniquely.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 只渲染 `SELECT NULL AS anon_1`，因为两个 [`null()`](../core/sqlelement.html#sqlalchemy.sql.expression.null
    "sqlalchemy.sql.expression.null") 构造将输出相同的 `NULL` 对象，而 SQLAlchemy 的核心模型是基于对象标识来确定词法重要性的。0.9
    中的更改除了希望节省对象开销外并无重要性；通常，未命名的构造需要保持词法唯一，以便被唯一标记。
- en: '[#3170](https://www.sqlalchemy.org/trac/ticket/3170)  ### SQLite/Oracle have
    distinct methods for temporary table/view name reporting'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3170](https://www.sqlalchemy.org/trac/ticket/3170)  ### SQLite/Oracle 有不同的临时表/视图名称报告方法'
- en: The [`Inspector.get_table_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_table_names
    "sqlalchemy.engine.reflection.Inspector.get_table_names") and [`Inspector.get_view_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_view_names
    "sqlalchemy.engine.reflection.Inspector.get_view_names") methods in the case of
    SQLite/Oracle would also return the names of temporary tables and views, which
    is not provided by any other dialect (in the case of MySQL at least it is not
    even possible). This logic has been moved out to two new methods [`Inspector.get_temp_table_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_temp_table_names
    "sqlalchemy.engine.reflection.Inspector.get_temp_table_names") and [`Inspector.get_temp_view_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_temp_view_names
    "sqlalchemy.engine.reflection.Inspector.get_temp_view_names").
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SQLite/Oracle 的情况下，[`Inspector.get_table_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_table_names
    "sqlalchemy.engine.reflection.Inspector.get_table_names") 和 [`Inspector.get_view_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_view_names
    "sqlalchemy.engine.reflection.Inspector.get_view_names") 方法也会返回临时表和视图的名称，这是任何其他方言都不提供的（至少在
    MySQL 的情况下甚至不可能）。这一逻辑已经移出到两个新方法 [`Inspector.get_temp_table_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_temp_table_names
    "sqlalchemy.engine.reflection.Inspector.get_temp_table_names") 和 [`Inspector.get_temp_view_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_temp_view_names
    "sqlalchemy.engine.reflection.Inspector.get_temp_view_names")。
- en: Note that reflection of a specific named temporary table or temporary view,
    either by `Table('name', autoload=True)` or via methods like [`Inspector.get_columns()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_columns
    "sqlalchemy.engine.reflection.Inspector.get_columns") continues to function for
    most if not all dialects. For SQLite specifically, there is a bug fix for UNIQUE
    constraint reflection from temp tables as well, which is [#3203](https://www.sqlalchemy.org/trac/ticket/3203).
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，对于大多数（如果不是全部）方言，通过 `Table('name', autoload=True)` 或通过 [`Inspector.get_columns()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_columns
    "sqlalchemy.engine.reflection.Inspector.get_columns") 等方法反射特定命名的临时表或临时视图仍然有效。特别是对于
    SQLite，还修复了从临时表中反射 UNIQUE 约束的 bug，这是 [#3203](https://www.sqlalchemy.org/trac/ticket/3203)。
- en: '[#3204](https://www.sqlalchemy.org/trac/ticket/3204)'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3204](https://www.sqlalchemy.org/trac/ticket/3204)'
- en: Dialect Improvements and Changes - PostgreSQL
  id: totrans-405
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方言改进和变更 - PostgreSQL
- en: '### Overhaul of ENUM type create/drop rules'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '### ENUM 类型创建/删除规则的全面改进'
- en: The rules for PostgreSQL [`ENUM`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ENUM
    "sqlalchemy.dialects.postgresql.ENUM") have been made more strict with regards
    to creating and dropping of the TYPE.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 PostgreSQL 的 [`ENUM`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ENUM
    "sqlalchemy.dialects.postgresql.ENUM") 规则在创建和删除类型时变得更加严格。
- en: 'An [`ENUM`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ENUM
    "sqlalchemy.dialects.postgresql.ENUM") that is created **without** being explicitly
    associated with a [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") object will be created *and* dropped corresponding
    to [`Table.create()`](../core/metadata.html#sqlalchemy.schema.Table.create "sqlalchemy.schema.Table.create")
    and [`Table.drop()`](../core/metadata.html#sqlalchemy.schema.Table.drop "sqlalchemy.schema.Table.drop"):'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 创建的 [`ENUM`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ENUM
    "sqlalchemy.dialects.postgresql.ENUM") 如果没有明确与 [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") 对象关联，将会在 [`Table.create()`](../core/metadata.html#sqlalchemy.schema.Table.create
    "sqlalchemy.schema.Table.create") 和 [`Table.drop()`](../core/metadata.html#sqlalchemy.schema.Table.drop
    "sqlalchemy.schema.Table.drop") 时创建 *和* 删除：
- en: '[PRE119]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: This means that if a second table also has an enum named ‘myenum’, the above
    DROP operation will now fail. In order to accommodate the use case of a common
    shared enumerated type, the behavior of a metadata-associated enumeration has
    been enhanced.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着如果第二个表也有一个名为 'myenum' 的枚举，上述 DROP 操作现在将失败。为了适应共享枚举类型的常见用例，元数据关联的枚举行为已经得到增强。
- en: 'An [`ENUM`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ENUM
    "sqlalchemy.dialects.postgresql.ENUM") that is created **with** being explicitly
    associated with a [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") object will *not* be created *or* dropped corresponding
    to [`Table.create()`](../core/metadata.html#sqlalchemy.schema.Table.create "sqlalchemy.schema.Table.create")
    and [`Table.drop()`](../core/metadata.html#sqlalchemy.schema.Table.drop "sqlalchemy.schema.Table.drop"),
    with the exception of [`Table.create()`](../core/metadata.html#sqlalchemy.schema.Table.create
    "sqlalchemy.schema.Table.create") called with the `checkfirst=True` flag:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 创建的 [`ENUM`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ENUM
    "sqlalchemy.dialects.postgresql.ENUM") 如果明确与 [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") 对象关联，将不会在 [`Table.create()`](../core/metadata.html#sqlalchemy.schema.Table.create
    "sqlalchemy.schema.Table.create") 和 [`Table.drop()`](../core/metadata.html#sqlalchemy.schema.Table.drop
    "sqlalchemy.schema.Table.drop") 时创建 *或* 删除，除了在调用带有 `checkfirst=True` 标志的 [`Table.create()`](../core/metadata.html#sqlalchemy.schema.Table.create
    "sqlalchemy.schema.Table.create") 时：
- en: '[PRE120]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[#3319](https://www.sqlalchemy.org/trac/ticket/3319)'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3319](https://www.sqlalchemy.org/trac/ticket/3319)'
- en: New PostgreSQL Table options
  id: totrans-414
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 新的 PostgreSQL 表选项
- en: Added support for PG table options TABLESPACE, ON COMMIT, WITH(OUT) OIDS, and
    INHERITS, when rendering DDL via the [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") construct.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 在通过 [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    构造渲染 DDL 时，增加了对 PG 表选项 TABLESPACE、ON COMMIT、WITH(OUT) OIDS 和 INHERITS 的支持。
- en: See also
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[PostgreSQL Table Options](../dialects/postgresql.html#postgresql-table-options)'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '[PostgreSQL 表选项](../dialects/postgresql.html#postgresql-table-options)'
- en: '[#2051](https://www.sqlalchemy.org/trac/ticket/2051)'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2051](https://www.sqlalchemy.org/trac/ticket/2051)'
- en: '### New get_enums() method with PostgreSQL Dialect'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '### 具有 PostgreSQL 方言的新 get_enums() 方法'
- en: 'The [`inspect()`](../core/inspection.html#sqlalchemy.inspect "sqlalchemy.inspect")
    method returns a [`PGInspector`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.base.PGInspector
    "sqlalchemy.dialects.postgresql.base.PGInspector") object in the case of PostgreSQL,
    which includes a new [`PGInspector.get_enums()`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.base.PGInspector.get_enums
    "sqlalchemy.dialects.postgresql.base.PGInspector.get_enums") method that returns
    information on all available `ENUM` types:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '[`inspect()`](../core/inspection.html#sqlalchemy.inspect "sqlalchemy.inspect")
    方法在 PostgreSQL 的情况下返回一个 [`PGInspector`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.base.PGInspector
    "sqlalchemy.dialects.postgresql.base.PGInspector") 对象，其中包括一个新的 [`PGInspector.get_enums()`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.base.PGInspector.get_enums
    "sqlalchemy.dialects.postgresql.base.PGInspector.get_enums") 方法，返回所有可用 `ENUM`
    类型的信息：'
- en: '[PRE121]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: See also
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[`PGInspector.get_enums()`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.base.PGInspector.get_enums
    "sqlalchemy.dialects.postgresql.base.PGInspector.get_enums")  ### PostgreSQL Dialect
    reflects Materialized Views, Foreign Tables'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: '[`PGInspector.get_enums()`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.base.PGInspector.get_enums
    "sqlalchemy.dialects.postgresql.base.PGInspector.get_enums")  ### PostgreSQL 方言反映了物化视图、外部表'
- en: 'Changes are as follows:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 更改如下：
- en: the `Table` construct with `autoload=True` will now match a name that exists
    in the database as a materialized view or foreign table.
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 具有 `autoload=True` 的 `Table` 构造现在将匹配数据库中存在的物化视图或外部表的名称。
- en: '[`Inspector.get_view_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_view_names
    "sqlalchemy.engine.reflection.Inspector.get_view_names") will return plain and
    materialized view names.'
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`Inspector.get_view_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_view_names
    "sqlalchemy.engine.reflection.Inspector.get_view_names") 将返回普通和物化视图名称。'
- en: '[`Inspector.get_table_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_table_names
    "sqlalchemy.engine.reflection.Inspector.get_table_names") does **not** change
    for PostgreSQL, it continues to return only the names of plain tables.'
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`Inspector.get_table_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_table_names
    "sqlalchemy.engine.reflection.Inspector.get_table_names") 对于 PostgreSQL 不会发生变化，它继续只返回普通表的名称。'
- en: A new method [`PGInspector.get_foreign_table_names()`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.base.PGInspector.get_foreign_table_names
    "sqlalchemy.dialects.postgresql.base.PGInspector.get_foreign_table_names") is
    added which will return the names of tables that are specifically marked as “foreign”
    in the PostgreSQL schema tables.
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加了一个新方法 [`PGInspector.get_foreign_table_names()`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.base.PGInspector.get_foreign_table_names
    "sqlalchemy.dialects.postgresql.base.PGInspector.get_foreign_table_names") ，它将返回在
    PostgreSQL 模式表中明确标记为“外部”的表的名称。
- en: The change to reflection involves adding `'m'` and `'f'` to the list of qualifiers
    we use when querying `pg_class.relkind`, but this change is new in 1.0.0 to avoid
    any backwards-incompatible surprises for those running 0.9 in production.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 反射的变化涉及在查询 `pg_class.relkind` 时添加 `'m'` 和 `'f'` 到我们使用的修饰符列表，但这个变化是在 1.0.0 中新增的，以避免对那些在生产中运行
    0.9 版本的用户造成任何不兼容的惊喜。
- en: '[#2891](https://www.sqlalchemy.org/trac/ticket/2891)  ### PostgreSQL `has_table()`
    now works for temporary tables'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2891](https://www.sqlalchemy.org/trac/ticket/2891)  ### PostgreSQL `has_table()`
    现在适用于临时表'
- en: 'This is a simple fix such that “has table” for temporary tables now works,
    so that code like the following may proceed:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的修复，使得临时表的“有表”现在可以正常工作，因此像下面的代码可以继续执行：
- en: '[PRE122]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'The very unlikely case that this behavior will cause a non-failing application
    to behave differently, is because PostgreSQL allows a non-temporary table to silently
    overwrite a temporary table. So code like the following will now act completely
    differently, no longer creating the real table following the temporary table:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这种行为导致一个非失败的应用程序表现出不同的行为，那是因为 PostgreSQL 允许一个非临时表悄悄地覆盖一个临时表。因此，像下面的代码现在将完全不同，不再创建真实表来跟随临时表：
- en: '[PRE123]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[#3264](https://www.sqlalchemy.org/trac/ticket/3264)  ### PostgreSQL FILTER
    keyword'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3264](https://www.sqlalchemy.org/trac/ticket/3264)  ### PostgreSQL FILTER
    关键字'
- en: 'The SQL standard FILTER keyword for aggregate functions is now supported by
    PostgreSQL as of 9.4\. SQLAlchemy allows this using [`FunctionElement.filter()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.filter
    "sqlalchemy.sql.functions.FunctionElement.filter"):'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: PostgreSQL 现在支持聚合函数的 SQL 标准 FILTER 关键字，从 9.4 版开始。SQLAlchemy 允许使用 [`FunctionElement.filter()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.filter
    "sqlalchemy.sql.functions.FunctionElement.filter") 来实现这一点：
- en: '[PRE124]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: See also
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`FunctionElement.filter()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.filter
    "sqlalchemy.sql.functions.FunctionElement.filter")'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '[`FunctionElement.filter()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.filter
    "sqlalchemy.sql.functions.FunctionElement.filter")'
- en: '[`FunctionFilter`](../core/sqlelement.html#sqlalchemy.sql.expression.FunctionFilter
    "sqlalchemy.sql.expression.FunctionFilter")'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: '[`FunctionFilter`](../core/sqlelement.html#sqlalchemy.sql.expression.FunctionFilter
    "sqlalchemy.sql.expression.FunctionFilter")'
- en: PG8000 dialect supports client side encoding
  id: totrans-441
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PG8000 方言支持客户端端编码
- en: The [`create_engine.encoding`](../core/engines.html#sqlalchemy.create_engine.params.encoding
    "sqlalchemy.create_engine") parameter is now honored by the pg8000 dialect, using
    on connect handler which emits `SET CLIENT_ENCODING` matching the selected encoding.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，[`create_engine.encoding`](../core/engines.html#sqlalchemy.create_engine.params.encoding
    "sqlalchemy.create_engine") 参数已被 pg8000 方言所遵守，使用连接处理程序发出 `SET CLIENT_ENCODING`
    匹配所选编码。
- en: PG8000 native JSONB support
  id: totrans-443
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PG8000 原生 JSONB 支持
- en: Support for PG8000 versions greater than 1.10.1 has been added, where JSONB
    is supported natively.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 添加了对大于 1.10.1 版本的 PG8000 的支持，其中原生支持 JSONB。
- en: Support for psycopg2cffi Dialect on PyPy
  id: totrans-445
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对 PyPy 上的 psycopg2cffi 方言的支持
- en: Support for the pypy psycopg2cffi dialect is added.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 添加了对 pypy psycopg2cffi 方言的支持。
- en: See also
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`sqlalchemy.dialects.postgresql.psycopg2cffi`](../dialects/postgresql.html#module-sqlalchemy.dialects.postgresql.psycopg2cffi
    "sqlalchemy.dialects.postgresql.psycopg2cffi")'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: '[`sqlalchemy.dialects.postgresql.psycopg2cffi`](../dialects/postgresql.html#module-sqlalchemy.dialects.postgresql.psycopg2cffi
    "sqlalchemy.dialects.postgresql.psycopg2cffi")'
- en: Dialect Improvements and Changes - MySQL
  id: totrans-449
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方言改进和更改 - MySQL
- en: '### MySQL TIMESTAMP Type now renders NULL / NOT NULL in all cases'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: '### MySQL TIMESTAMP类型现在在所有情况下呈现NULL / NOT NULL'
- en: The MySQL dialect has always worked around MySQL’s implicit NOT NULL default
    associated with TIMESTAMP columns by emitting NULL for such a type, if the column
    is set up with `nullable=True`. However, MySQL 5.6.6 and above features a new
    flag [explicit_defaults_for_timestamp](https://dev.mysql.com/doc/refman/5.6/en/server-system-variables.html#sysvar_explicit_defaults_for_timestamp)
    which repairs MySQL’s non-standard behavior to make it behave like any other type;
    to accommodate this, SQLAlchemy now emits NULL/NOT NULL unconditionally for all
    TIMESTAMP columns.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL方言一直通过为具有`nullable=True`设置的TIMESTAMP列发出NULL来解决MySQL与TIMESTAMP列相关的隐式NOT
    NULL默认值的问题。然而，MySQL 5.6.6及以上版本具有一个新标志[explicit_defaults_for_timestamp](https://dev.mysql.com/doc/refman/5.6/en/server-system-variables.html#sysvar_explicit_defaults_for_timestamp)，它修复了MySQL的非标准行为，使其表现得像任何其他类型；为了适应这一点，SQLAlchemy现在无条件地为所有TIMESTAMP列发出NULL/NOT
    NULL。
- en: See also
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[TIMESTAMP Columns and NULL](../dialects/mysql.html#mysql-timestamp-null)'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: '[TIMESTAMP列和NULL](../dialects/mysql.html#mysql-timestamp-null)'
- en: '[#3155](https://www.sqlalchemy.org/trac/ticket/3155)  ### MySQL SET Type Overhauled
    to support empty sets, unicode, blank value handling'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3155](https://www.sqlalchemy.org/trac/ticket/3155)  ### MySQL SET类型进行了全面改进，以支持空集、unicode、空值处理'
- en: The [`SET`](../dialects/mysql.html#sqlalchemy.dialects.mysql.SET "sqlalchemy.dialects.mysql.SET")
    type historically not included a system of handling blank sets and empty values
    separately; as different drivers had different behaviors for treatment of empty
    strings and empty-string-set representations, the SET type tried only to hedge
    between these behaviors, opting to treat the empty set as `set([''])` as is still
    the current behavior for the MySQL-Connector-Python DBAPI. Part of the rationale
    here was that it was otherwise impossible to actually store a blank string within
    a MySQL SET, as the driver gives us back strings with no way to discern between
    `set([''])` and `set()`. It was left to the user to determine if `set([''])` actually
    meant “empty set” or not.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 历史上，[`SET`](../dialects/mysql.html#sqlalchemy.dialects.mysql.SET "sqlalchemy.dialects.mysql.SET")类型并未包含处理空集和空值的系统；由于不同的驱动程序对空字符串和空字符串集表示的处理方式不同，SET类型仅尝试在这些行为之间进行权衡，选择将空集视为`set([''])`，这仍然是MySQL-Connector-Python
    DBAPI的当前行为。这里的部分理由是，否则在MySQL SET中实际上无法存储空字符串，因为驱动程序返回没有办法区分`set([''])`和`set()`的字符串。用户需要确定`set([''])`是否实际上表示“空集”。
- en: 'The new behavior moves the use case for the blank string, which is an unusual
    case that isn’t even documented in MySQL’s documentation, into a special case,
    and the default behavior of [`SET`](../dialects/mysql.html#sqlalchemy.dialects.mysql.SET
    "sqlalchemy.dialects.mysql.SET") is now:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 新行为将空字符串的用例移动到一个特殊情况中，这是一个在MySQL文档中甚至没有记录的不寻常情况，并且[`SET`](../dialects/mysql.html#sqlalchemy.dialects.mysql.SET
    "sqlalchemy.dialects.mysql.SET")的默认行为现在是：
- en: to treat the empty string `''` as returned by MySQL-python into the empty set
    `set()`;
  id: totrans-457
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将由MySQL-python返回的空字符串`''`视为空集`set()`；
- en: to convert the single-blank value set `set([''])` returned by MySQL-Connector-Python
    into the empty set `set()`;
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将MySQL-Connector-Python返回的单空值集`set([''])`转换为空集`set()`；
- en: To handle the case of a set type that actually wishes includes the blank value
    `''` in its list of possible values, a new feature (required in this use case)
    is implemented whereby the set value is persisted and loaded as a bitwise integer
    value; the flag [`SET.retrieve_as_bitwise`](../dialects/mysql.html#sqlalchemy.dialects.mysql.SET.params.retrieve_as_bitwise
    "sqlalchemy.dialects.mysql.SET") is added in order to enable this.
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了处理实际希望在其可能值列表中包含空值`''`的集合类型的情况，实现了一个新功能（在这种用例中是必需的），其中集合值被持久化和加载为位整数值；添加了标志[`SET.retrieve_as_bitwise`](../dialects/mysql.html#sqlalchemy.dialects.mysql.SET.params.retrieve_as_bitwise
    "sqlalchemy.dialects.mysql.SET")以启用此功能。
- en: Using the [`SET.retrieve_as_bitwise`](../dialects/mysql.html#sqlalchemy.dialects.mysql.SET.params.retrieve_as_bitwise
    "sqlalchemy.dialects.mysql.SET") flag allows the set to be persisted and retrieved
    with no ambiguity of values. Theoretically this flag can be turned on in all cases,
    as long as the given list of values to the type matches the ordering exactly as
    declared in the database; it only makes the SQL echo output a bit more unusual.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[`SET.retrieve_as_bitwise`](../dialects/mysql.html#sqlalchemy.dialects.mysql.SET.params.retrieve_as_bitwise
    "sqlalchemy.dialects.mysql.SET")标志允许集合在没有值歧义的情况下持久化和检索。理论上，只要给定的值列表与数据库中声明的顺序完全匹配，就可以在所有情况下打开此标志；它只会使SQL回显输出有点不寻常。
- en: The default behavior of [`SET`](../dialects/mysql.html#sqlalchemy.dialects.mysql.SET
    "sqlalchemy.dialects.mysql.SET") otherwise remains the same, roundtripping values
    using strings. The string-based behavior now supports unicode fully including
    MySQL-python with use_unicode=0.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，[`SET`](../dialects/mysql.html#sqlalchemy.dialects.mysql.SET "sqlalchemy.dialects.mysql.SET")的默认行为保持不变，使用字符串来往复值。基于字符串的行为现在完全支持unicode，包括使用use_unicode=0的MySQL-python。
- en: '[#3283](https://www.sqlalchemy.org/trac/ticket/3283)'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3283](https://www.sqlalchemy.org/trac/ticket/3283)'
- en: MySQL internal “no such table” exceptions not passed to event handlers
  id: totrans-463
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: MySQL内部的“无此表”异常不会传递给事件处理程序
- en: The MySQL dialect will now disable `ConnectionEvents.handle_error()` events
    from firing for those statements which it uses internally to detect if a table
    exists or not. This is achieved using an execution option `skip_user_error_events`
    that disables the handle error event for the scope of that execution. In this
    way, user code that rewrites exceptions doesn’t need to worry about the MySQL
    dialect or other dialects that occasionally need to catch SQLAlchemy specific
    exceptions.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL方言现在将禁用`ConnectionEvents.handle_error()`事件，以防止这些语句触发内部用于检测表是否存在的事件处理程序。这是通过使用一个执行选项`skip_user_error_events`来实现的，该选项在该执行范围内禁用处理错误事件。通过这种方式，重写异常的用户代码不需要担心MySQL方言或其他偶尔需要捕获SQLAlchemy特定异常的方言。
- en: Changed the default value of `raise_on_warnings` for MySQL-Connector
  id: totrans-465
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更改了MySQL-Connector的`raise_on_warnings`默认值
- en: Changed the default value of “raise_on_warnings” to False for MySQL-Connector.
    This was set at True for some reason. The “buffered” flag unfortunately must stay
    at True as MySQLconnector does not allow a cursor to be closed unless all results
    are fully fetched.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 将“raise_on_warnings”的默认值更改为False，以用于MySQL-Connector。由于某种原因，此值设置为True。不幸的是，“buffered”标志必须保持为True，因为MySQL连接器不允许关闭游标，除非所有结果都完全获取。
- en: '[#2515](https://www.sqlalchemy.org/trac/ticket/2515)'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2515](https://www.sqlalchemy.org/trac/ticket/2515)'
- en: '### MySQL boolean symbols “true”, “false” work again'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: '### MySQL布尔符号“true”、“false”再次有效'
- en: 0.9’s overhaul of the IS/IS NOT operators as well as boolean types in [#2682](https://www.sqlalchemy.org/trac/ticket/2682)
    disallowed the MySQL dialect from making use of the “true” and “false” symbols
    in the context of “IS” / “IS NOT”. Apparently, even though MySQL has no “boolean”
    type, it supports IS / IS NOT when the special “true” and “false” symbols are
    used, even though these are otherwise synonymous with “1” and “0” (and IS/IS NOT
    don’t work with the numerics).
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 0.9版本对IS/IS NOT运算符以及[#2682](https://www.sqlalchemy.org/trac/ticket/2682)中的布尔类型进行了彻底改造，禁止MySQL方言在“IS”/“IS
    NOT”上下文中使用“true”和“false”符号。显然，即使MySQL没有“布尔”类型，但当使用特殊的“true”和“false”符号时，它支持IS/IS
    NOT，尽管这些符号在其他情况下与“1”和“0”是同义的（并且IS/IS NOT不能与数字一起使用）。
- en: So the change here is that the MySQL dialect remains “non native boolean”, but
    the [`true()`](../core/sqlelement.html#sqlalchemy.sql.expression.true "sqlalchemy.sql.expression.true")
    and [`false()`](../core/sqlelement.html#sqlalchemy.sql.expression.false "sqlalchemy.sql.expression.false")
    symbols again produce the keywords “true” and “false”, so that an expression like
    `column.is_(true())` again works on MySQL.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这里的变化是MySQL方言仍然保持“非本地布尔”，但[`true()`](../core/sqlelement.html#sqlalchemy.sql.expression.true
    "sqlalchemy.sql.expression.true")和[`false()`](../core/sqlelement.html#sqlalchemy.sql.expression.false
    "sqlalchemy.sql.expression.false")符号再次产生关键字“true”和“false”，因此像`column.is_(true())`这样的表达式在MySQL上再次有效。
- en: '[#3186](https://www.sqlalchemy.org/trac/ticket/3186)  ### The match() operator
    now returns an agnostic MatchType compatible with MySQL’s floating point return
    value'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3186](https://www.sqlalchemy.org/trac/ticket/3186)  ### match()运算符现在返回与MySQL浮点返回值兼容的MatchType'
- en: The return type of a [`ColumnOperators.match()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.match
    "sqlalchemy.sql.expression.ColumnOperators.match") expression is now a new type
    called [`MatchType`](../core/type_basics.html#sqlalchemy.types.MatchType "sqlalchemy.types.MatchType").
    This is a subclass of [`Boolean`](../core/type_basics.html#sqlalchemy.types.Boolean
    "sqlalchemy.types.Boolean"), that can be intercepted by the dialect in order to
    produce a different result type at SQL execution time.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: '[`ColumnOperators.match()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.match
    "sqlalchemy.sql.expression.ColumnOperators.match")表达式的返回类型现在是一个称为[`MatchType`](../core/type_basics.html#sqlalchemy.types.MatchType
    "sqlalchemy.types.MatchType")的新类型。这是[`Boolean`](../core/type_basics.html#sqlalchemy.types.Boolean
    "sqlalchemy.types.Boolean")的子类，可以被方言拦截以在SQL执行时产生不同的结果类型。'
- en: 'Code like the following will now function correctly and return floating points
    on MySQL:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 像下面这样的代码现在将正常运行并在MySQL上返回浮点数：
- en: '[PRE125]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[#3263](https://www.sqlalchemy.org/trac/ticket/3263)  ### Drizzle Dialect is
    now an External Dialect'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3263](https://www.sqlalchemy.org/trac/ticket/3263)  ### Drizzle方言现在是一个外部方言'
- en: The dialect for [Drizzle](https://www.drizzle.org/) is now an external dialect,
    available at [https://bitbucket.org/zzzeek/sqlalchemy-drizzle](https://bitbucket.org/zzzeek/sqlalchemy-drizzle).
    This dialect was added to SQLAlchemy right before SQLAlchemy was able to accommodate
    third party dialects well; going forward, all databases that aren’t within the
    “ubiquitous use” category are third party dialects. The dialect’s implementation
    hasn’t changed and is still based on the MySQL + MySQLdb dialects within SQLAlchemy.
    The dialect is as of yet unreleased and in “attic” status; however it passes the
    majority of tests and is generally in decent working order, if someone wants to
    pick up on polishing it.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: '[Drizzle](https://www.drizzle.org/)的方言现在是一个外部方言，可在[https://bitbucket.org/zzzeek/sqlalchemy-drizzle](https://bitbucket.org/zzzeek/sqlalchemy-drizzle)上找到。这个方言是在SQLAlchemy能够很好地适应第三方方言之前添加到SQLAlchemy的；未来，所有不属于“普遍使用”类别的数据库都是第三方方言。方言的实现没有改变，仍然基于SQLAlchemy中的MySQL
    + MySQLdb方言。该方言尚未发布，处于“attic”状态；但是它通过了大部分测试，通常工作正常，如果有人想要继续完善它。'
- en: Dialect Improvements and Changes - SQLite
  id: totrans-477
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方言改进和变化 - SQLite
- en: SQLite named and unnamed UNIQUE and FOREIGN KEY constraints will inspect and
    reflect
  id: totrans-478
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SQLite命名和未命名的唯一和外键约束将进行检查和反映
- en: UNIQUE and FOREIGN KEY constraints are now fully reflected on SQLite both with
    and without names. Previously, foreign key names were ignored and unnamed unique
    constraints were skipped. In particular this will help with Alembic’s new SQLite
    migration features.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite现在完全反映了有名称和无名称的唯一和外键约束。以前，外键名称被忽略，未命名的唯一约束被跳过。特别是这将有助于Alembic的新SQLite迁移功能。
- en: To achieve this, for both foreign keys and unique constraints, the result of
    PRAGMA foreign_keys, index_list, and index_info is combined with regular expression
    parsing of the CREATE TABLE statement overall to form a complete picture of the
    names of constraints, as well as differentiating UNIQUE constraints that were
    created as UNIQUE vs. unnamed INDEXes.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，对于外键和唯一约束，将PRAGMA foreign_keys、index_list和index_info的结果与对CREATE TABLE语句的正则表达式解析相结合，以形成对约束名称的完整描述，以及区分作为唯一约束创建的唯一约束与未命名INDEX的不同。
- en: '[#3244](https://www.sqlalchemy.org/trac/ticket/3244)'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3244](https://www.sqlalchemy.org/trac/ticket/3244)'
- en: '[#3261](https://www.sqlalchemy.org/trac/ticket/3261)'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3261](https://www.sqlalchemy.org/trac/ticket/3261)'
- en: Dialect Improvements and Changes - SQL Server
  id: totrans-483
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方言改进和变化 - SQL Server
- en: '### PyODBC driver name is required with hostname-based SQL Server connections'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: '### 使用基于主机名的SQL Server连接需要PyODBC驱动程序名称'
- en: 'Connecting to SQL Server with PyODBC using a DSN-less connection, e.g. with
    an explicit hostname, now requires a driver name - SQLAlchemy will no longer attempt
    to guess a default:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 使用无DSN连接的PyODBC连接到SQL Server，例如使用显式主机名，现在需要一个驱动程序名称 - SQLAlchemy将不再尝试猜测默认值：
- en: '[PRE126]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: SQLAlchemy’s previously hardcoded default of “SQL Server” is obsolete on Windows,
    and SQLAlchemy cannot be tasked with guessing the best driver based on operation
    system/driver detection. Using a DSN is always preferred when using ODBC to avoid
    this issue entirely.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy在Windows上以前硬编码的默认值“SQL Server”已经过时，SQLAlchemy不能根据操作系统/驱动程序检测来猜测最佳驱动程序。在使用ODBC时，始终首选使用DSN以避免这个问题。
- en: '[#3182](https://www.sqlalchemy.org/trac/ticket/3182)'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3182](https://www.sqlalchemy.org/trac/ticket/3182)'
- en: SQL Server 2012 large text / binary types render as VARCHAR, NVARCHAR, VARBINARY
  id: totrans-489
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SQL Server 2012大文本/二进制类型呈现为VARCHAR、NVARCHAR、VARBINARY
- en: The rendering of the [`TextClause`](../core/sqlelement.html#sqlalchemy.sql.expression.TextClause
    "sqlalchemy.sql.expression.TextClause"), [`UnicodeText`](../core/type_basics.html#sqlalchemy.types.UnicodeText
    "sqlalchemy.types.UnicodeText"), and [`LargeBinary`](../core/type_basics.html#sqlalchemy.types.LargeBinary
    "sqlalchemy.types.LargeBinary") types has been changed for SQL Server 2012 and
    greater, with options to control the behavior completely, based on deprecation
    guidelines from Microsoft. See [Large Text/Binary Type Deprecation](../dialects/mssql.html#mssql-large-type-deprecation)
    for details.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 SQL Server 2012 及更高版本，[`TextClause`](../core/sqlelement.html#sqlalchemy.sql.expression.TextClause
    "sqlalchemy.sql.expression.TextClause")、[`UnicodeText`](../core/type_basics.html#sqlalchemy.types.UnicodeText
    "sqlalchemy.types.UnicodeText") 和 [`LargeBinary`](../core/type_basics.html#sqlalchemy.types.LargeBinary
    "sqlalchemy.types.LargeBinary") 类型的呈现已经更改，可以完全控制行为，根据 Microsoft 的弃用指南。有关详细信息，请参阅[大文本/二进制类型弃用](../dialects/mssql.html#mssql-large-type-deprecation)。
- en: Dialect Improvements and Changes - Oracle
  id: totrans-491
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方言改进和更改 - Oracle
- en: '### Improved support for CTEs in Oracle'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: '### 改进的 Oracle CTE 支持'
- en: 'CTE support has been fixed up for Oracle, and there is also a new feature `CTE.with_suffixes()`
    that can assist with Oracle’s special directives:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: CTE 在 Oracle 中已经修复，还有一个新功能 `CTE.with_suffixes()` 可以帮助处理 Oracle 的特殊指令：
- en: '[PRE127]'
  id: totrans-494
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[#3220](https://www.sqlalchemy.org/trac/ticket/3220)'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3220](https://www.sqlalchemy.org/trac/ticket/3220)'
- en: New Oracle Keywords for DDL
  id: totrans-496
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: DDL 的新 Oracle 关键字
- en: 'Keywords such as COMPRESS, ON COMMIT, BITMAP:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: COMPRESS、ON COMMIT、BITMAP 等关键字：
- en: '[Oracle Table Options](../dialects/oracle.html#oracle-table-options)'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: '[Oracle 表选项](../dialects/oracle.html#oracle-table-options)'
- en: '[Oracle Specific Index Options](../dialects/oracle.html#oracle-index-options)'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: '[Oracle 特定索引选项](../dialects/oracle.html#oracle-index-options)'
- en: Introduction
  id: totrans-500
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍
- en: This guide introduces what’s new in SQLAlchemy version 1.0, and also documents
    changes which affect users migrating their applications from the 0.9 series of
    SQLAlchemy to 1.0.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 本指南介绍了 SQLAlchemy 版本 1.0 中的新功能，并记录了影响用户将其应用程序从 SQLAlchemy 0.9 系列迁移到 1.0 的更改。
- en: Please carefully review the sections on behavioral changes for potentially backwards-incompatible
    changes in behavior.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 请仔细查看行为变化部分，可能会有不兼容的行为变化。
- en: New Features and Improvements - ORM
  id: totrans-503
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 新功能和改进 - ORM
- en: New Session Bulk INSERT/UPDATE API
  id: totrans-504
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 新会话批量插入/更新 API
- en: A new series of [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    methods which provide hooks directly into the unit of work’s facility for emitting
    INSERT and UPDATE statements has been created. When used correctly, this expert-oriented
    system can allow ORM-mappings to be used to generate bulk insert and update statements
    batched into executemany groups, allowing the statements to proceed at speeds
    that rival direct use of the Core.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了一系列新的[`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")方法，直接提供钩子到工作单元的功能，用于生成批量插入和更新语句分组，使语句可以以与直接使用
    Core 相媲美的速度进行批量处理。
- en: See also
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Bulk Operations](../orm/persistence_techniques.html#bulk-operations) - introduction
    and full documentation'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: '[批量操作](../orm/persistence_techniques.html#bulk-operations) - 介绍和完整文档'
- en: '[#3100](https://www.sqlalchemy.org/trac/ticket/3100)'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3100](https://www.sqlalchemy.org/trac/ticket/3100)'
- en: New Performance Example Suite
  id: totrans-509
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 新性能示例套件
- en: Inspired by the benchmarking done for the [Bulk Operations](../orm/persistence_techniques.html#bulk-operations)
    feature as well as for the [How can I profile a SQLAlchemy powered application?](../faq/performance.html#faq-how-to-profile)
    section of the FAQ, a new example section has been added which features several
    scripts designed to illustrate the relative performance profile of various Core
    and ORM techniques. The scripts are organized into use cases, and are packaged
    under a single console interface such that any combination of demonstrations can
    be run, dumping out timings, Python profile results and/or RunSnake profile displays.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 受到为[批量操作](../orm/persistence_techniques.html#bulk-operations)功能以及[如何对 SQLAlchemy
    驱动的应用程序进行性能分析？](../faq/performance.html#faq-how-to-profile)FAQ部分进行的基准测试的启发，添加了一个新的示例部分，其中包含几个旨在说明各种核心和
    ORM 技术的相对性能特征的脚本。这些脚本按用例组织，并打包在一个单一的控制台界面下，以便可以运行任何组合的演示，输出时间、Python 分析结果和/或 RunSnake
    分析显示。
- en: See also
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Performance](../orm/examples.html#examples-performance)'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: '[性能](../orm/examples.html#examples-performance)'
- en: “Baked” Queries
  id: totrans-513
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: “烘焙”查询
- en: 'The “baked” query feature is an unusual new approach which allows for straightforward
    construction an invocation of [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") objects using caching, which upon successive calls features
    vastly reduced Python function call overhead (over 75%). By specifying a [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object as a series of lambdas which are only invoked once,
    a query as a pre-compiled unit begins to be feasible:'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: “烘焙”查询功能是一种不同寻常的新方法，允许直接构造和调用[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")对象，并使用缓存，在连续调用时大大减少了Python函数调用的开销（超过 75%）。通过将[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")对象指定为一系列仅调用一次的lambda表达式，可以开始将查询作为预编译单元来实现：
- en: '[PRE128]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: See also
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[Baked Queries](../orm/extensions/baked.html)'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: '[烘焙查询](../orm/extensions/baked.html)'
- en: '[#3054](https://www.sqlalchemy.org/trac/ticket/3054)'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3054](https://www.sqlalchemy.org/trac/ticket/3054)'
- en: '### Improvements to declarative mixins, `@declared_attr` and related features'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: '### 改进声明混合，`@declared_attr` 和相关功能'
- en: The declarative system in conjunction with [`declared_attr`](../orm/mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr") has been overhauled to support new capabilities.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[`declared_attr`](../orm/mapping_api.html#sqlalchemy.orm.declared_attr "sqlalchemy.orm.declared_attr")的声明系统已经进行了全面改进，以支持新的功能。
- en: 'A function decorated with [`declared_attr`](../orm/mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr") is now called only **after** any mixin-based column
    copies are generated. This means the function can call upon mixin-established
    columns and will receive a reference to the correct [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") object:'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 现在使用[`declared_attr`](../orm/mapping_api.html#sqlalchemy.orm.declared_attr "sqlalchemy.orm.declared_attr")装饰的函数仅在生成任何基于混合的列副本后才调用。这意味着函数可以调用混合建立的列，并将接收到正确的[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") 对象的引用：
- en: '[PRE129]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: Above, `SomeClass.foobar_prop` will be invoked against `SomeClass`, and `SomeClass.foobar`
    will be the final [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    object that is to be mapped to `SomeClass`, as opposed to the non-copied object
    present directly on `HasFooBar`, even though the columns aren’t mapped yet.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，`SomeClass.foobar_prop` 将针对 `SomeClass` 调用，并且 `SomeClass.foobar` 将是要映射到
    `SomeClass` 的最终 [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    对象，而不是直接存在于 `HasFooBar` 上的非复制对象，即使列还没有映射。
- en: 'The [`declared_attr`](../orm/mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr") function now **memoizes** the value that’s returned
    on a per-class basis, so that repeated calls to the same attribute will return
    the same value. We can alter the example to illustrate this:'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，[`declared_attr`](../orm/mapping_api.html#sqlalchemy.orm.declared_attr "sqlalchemy.orm.declared_attr")函数在每个类基础上**备忘**返回的值，因此对相同属性的重复调用将返回相同的值。我们可以修改示例来说明这一点：
- en: '[PRE130]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: Previously, `SomeClass` would be mapped with one particular copy of the `foobar`
    column, but the `foobar_prop` by calling upon `foobar` a second time would produce
    a different column. The value of `SomeClass.foobar` is now memoized during declarative
    setup time, so that even before the attribute is mapped by the mapper, the interim
    column value will remain consistent no matter how many times the [`declared_attr`](../orm/mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr") is called upon.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，`SomeClass` 将使用一个特定的 `foobar` 列进行映射，但通过第二次调用 `foobar` 来调用 `foobar_prop` 将产生一个不同的列。现在，在声明设置时间内对
    `SomeClass.foobar` 的值进行了备忘，因此即使在映射器将属性映射之前，[`declared_attr`](../orm/mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr") 被调用多少次，临时列值也将保持一致。
- en: The two behaviors above should help considerably with declarative definition
    of many types of mapper properties that derive from other attributes, where the
    [`declared_attr`](../orm/mapping_api.html#sqlalchemy.orm.declared_attr "sqlalchemy.orm.declared_attr")
    function is called upon from other [`declared_attr`](../orm/mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr") functions locally present before the class is
    actually mapped.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 上述两个行为应大大有助于声明定义许多类型的映射器属性，这些属性源自其他属性，其中[`declared_attr`](../orm/mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr")函数在实际映射类之前从其他[`declared_attr`](../orm/mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr")函数本地调用。
- en: 'For a pretty slim edge case where one wishes to build a declarative mixin that
    establishes distinct columns per subclass, a new modifier [`declared_attr.cascading`](../orm/mapping_api.html#sqlalchemy.orm.declared_attr.cascading
    "sqlalchemy.orm.declared_attr.cascading") is added. With this modifier, the decorated
    function will be invoked individually for each class in the mapped inheritance
    hierarchy. While this is already the behavior for special attributes such as `__table_args__`
    and `__mapper_args__`, for columns and other properties the behavior by default
    assumes that attribute is affixed to the base class only, and just inherited from
    subclasses. With [`declared_attr.cascading`](../orm/mapping_api.html#sqlalchemy.orm.declared_attr.cascading
    "sqlalchemy.orm.declared_attr.cascading"), individual behaviors can be applied:'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个相当特殊的边缘情况，其中希望构建一个声明性混合类，为每个子类建立不同的列，添加了一个新的修饰符 [`declared_attr.cascading`](../orm/mapping_api.html#sqlalchemy.orm.declared_attr.cascading
    "sqlalchemy.orm.declared_attr.cascading")。使用这个修饰符，装饰的函数将为映射继承层次结构中的每个类单独调用。虽然对于特殊属性如
    `__table_args__` 和 `__mapper_args__`，这已经是默认行为，但对于列和其他属性，默认行为假定该属性仅附加到基类，并从子类继承。使用
    [`declared_attr.cascading`](../orm/mapping_api.html#sqlalchemy.orm.declared_attr.cascading
    "sqlalchemy.orm.declared_attr.cascading")，可以应用个别行为：
- en: '[PRE131]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: See also
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[Using _orm.declared_attr() to generate table-specific inheriting columns](../orm/declarative_mixins.html#mixin-inheritance-columns)'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 _orm.declared_attr() 生成特定表继承列的[链接](../orm/declarative_mixins.html#mixin-inheritance-columns)
- en: 'Finally, the [`AbstractConcreteBase`](../orm/extensions/declarative/index.html#sqlalchemy.ext.declarative.AbstractConcreteBase
    "sqlalchemy.ext.declarative.AbstractConcreteBase") class has been reworked so
    that a relationship or other mapper property can be set up inline on the abstract
    base:'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，[`AbstractConcreteBase`](../orm/extensions/declarative/index.html#sqlalchemy.ext.declarative.AbstractConcreteBase
    "sqlalchemy.ext.declarative.AbstractConcreteBase") 类已经重新设计，以便在抽象基类上内联设置关系或其他映射属性：
- en: '[PRE132]'
  id: totrans-533
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: The above mapping will set up a table `cca` with both an `id` and a `something_id`
    column, and `Concrete` will also have a relationship `something`. The new feature
    is that `Abstract` will also have an independently configured relationship `something`
    that builds against the polymorphic union of the base.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 上述映射将建立一个名为 `cca` 的表，其中包含 `id` 和 `something_id` 列，而 `Concrete` 还将具有一个名为 `something`
    的关系。新功能是 `Abstract` 也将具有一个独立配置的关系 `something`，该关系针对基类的多态联合构建。
- en: '[#3150](https://www.sqlalchemy.org/trac/ticket/3150) [#2670](https://www.sqlalchemy.org/trac/ticket/2670)
    [#3149](https://www.sqlalchemy.org/trac/ticket/3149) [#2952](https://www.sqlalchemy.org/trac/ticket/2952)
    [#3050](https://www.sqlalchemy.org/trac/ticket/3050)'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3150](https://www.sqlalchemy.org/trac/ticket/3150) [#2670](https://www.sqlalchemy.org/trac/ticket/2670)
    [#3149](https://www.sqlalchemy.org/trac/ticket/3149) [#2952](https://www.sqlalchemy.org/trac/ticket/2952)
    [#3050](https://www.sqlalchemy.org/trac/ticket/3050)'
- en: ORM full object fetches 25% faster
  id: totrans-536
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ORM完整对象提取速度提高了25%
- en: 'The mechanics of the `loading.py` module as well as the identity map have undergone
    several passes of inlining, refactoring, and pruning, so that a raw load of rows
    now populates ORM-based objects around 25% faster. Assuming a 1M row table, a
    script like the following illustrates the type of load that’s improved the most:'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: '`loading.py` 模块的机制以及标识映射已经经历了几次内联、重构和修剪，因此现在原始行的加载速度比以前快了大约 25%。假设有一个包含 100
    万行的表，下面的脚本说明了哪种加载方式得到了最大的改进：'
- en: '[PRE133]'
  id: totrans-538
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: Local MacBookPro results bench from 19 seconds for 0.9 down to 14 seconds for
    1.0\. The [`Query.yield_per()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.yield_per
    "sqlalchemy.orm.Query.yield_per") call is always a good idea when batching huge
    numbers of rows, as it prevents the Python interpreter from having to allocate
    a huge amount of memory for all objects and their instrumentation at once. Without
    the [`Query.yield_per()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.yield_per
    "sqlalchemy.orm.Query.yield_per"), the above script on the MacBookPro is 31 seconds
    on 0.9 and 26 seconds on 1.0, the extra time spent setting up very large memory
    buffers.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 本地 MacBookPro 结果从 0.9 的 19 秒降至 1.0 的 14 秒。当批处理大量行时，[`Query.yield_per()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.yield_per
    "sqlalchemy.orm.Query.yield_per") 的调用总是一个好主意，因为它可以防止 Python 解释器一次性为所有对象及其仪器分配大量内存。没有
    [`Query.yield_per()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.yield_per
    "sqlalchemy.orm.Query.yield_per")，在 MacBookPro 上的上述脚本在 0.9 上为 31 秒，在 1.0 上为 26
    秒，额外的时间花费在设置非常大的内存缓冲区上。
- en: '### New KeyedTuple implementation dramatically faster'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: '### 新的 KeyedTuple 实现速度大幅提升'
- en: 'We took a look into the `KeyedTuple` implementation in the hopes of improving
    queries like this:'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 我们研究了 `KeyedTuple` 的实现，希望改进这样的查询：
- en: '[PRE134]'
  id: totrans-542
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'The `KeyedTuple` class is used rather than Python’s `collections.namedtuple()`,
    because the latter has a very complex type-creation routine that benchmarks much
    slower than `KeyedTuple`. However, when fetching hundreds of thousands of rows,
    `collections.namedtuple()` quickly overtakes `KeyedTuple` which becomes dramatically
    slower as instance invocation goes up. What to do? A new type that hedges between
    the approaches of both. Benching all three types for “size” (number of rows returned)
    and “num” (number of distinct queries), the new “lightweight keyed tuple” either
    outperforms both, or lags very slightly behind the faster object, based on which
    scenario. In the “sweet spot”, where we are both creating a good number of new
    types as well as fetching a good number of rows, the lightweight object totally
    smokes both namedtuple and KeyedTuple:'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `KeyedTuple` 类而不是 Python 的 `collections.namedtuple()`，因为后者具有一个非常复杂的类型创建程序，比
    `KeyedTuple` 的速度慢得多。然而，当获取数十万行时，`collections.namedtuple()` 很快就会超过 `KeyedTuple`，随着实例调用次数的增加，`KeyedTuple`
    的速度会急剧变慢。怎么办？一种新类型，介于两者之间的方法。对于“大小”（返回的行数）和“num”（不同查询的数量）对所有三种类型进行测试，新的“轻量级键值元组”要么优于两者，要么略逊于更快的对象，取决于情况。在“甜蜜点”，即我们既创建了大量新类型又获取了大量行时，轻量级对象完全超过了
    namedtuple 和 KeyedTuple：
- en: '[PRE135]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[#3176](https://www.sqlalchemy.org/trac/ticket/3176)  ### Significant Improvements
    in Structural Memory Use'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3176](https://www.sqlalchemy.org/trac/ticket/3176)  ### 结构内存使用显著改进'
- en: Structural memory use has been improved via much more significant use of `__slots__`
    for many internal objects. This optimization is particularly geared towards the
    base memory size of large applications that have lots of tables and columns, and
    reduces memory size for a variety of high-volume objects including event listening
    internals, comparator objects and parts of the ORM attribute and loader strategy
    system.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 通过更多内部对象更显著地使用 `__slots__`，改进了结构内存使用。这种优化特别针对具有大量表和列的大型应用程序的基本内存大小，减少了各种高容量对象的内存大小，包括事件监听内部、比较器对象以及
    ORM 属性和加载器策略系统的部分。
- en: 'A bench that makes use of heapy measure the startup size of Nova illustrates
    a difference of about 3.7 fewer megs, or 46%, taken up by SQLAlchemy’s objects,
    associated dictionaries, as well as weakrefs, within a basic import of “nova.db.sqlalchemy.models”:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 一张长椅利用堆积测量 Nova 的启动大小，显示出 SQLAlchemy 的对象、相关字典以及弱引用所占空间减少了约 3.7 兆字节，或者说减少了 46%，在基本导入“nova.db.sqlalchemy.models”时：
- en: '[PRE136]  ### UPDATE statements are now batched with executemany() in a flush'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE136]  ### UPDATE 语句现在使用 executemany() 进行批处理'
- en: 'UPDATE statements can now be batched within an ORM flush into more performant
    executemany() call, similarly to how INSERT statements can be batched; this will
    be invoked within flush based on the following criteria:'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以在 ORM 刷新中批处理 UPDATE 语句，以更高效的 executemany() 调用，类似于 INSERT 语句的批处理；这将根据以下标准在刷新中调用：
- en: two or more UPDATE statements in sequence involve the identical set of columns
    to be modified.
  id: totrans-550
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连续两个或更多个 UPDATE 语句涉及相同的要修改的列集。
- en: The statement has no embedded SQL expressions in the SET clause.
  id: totrans-551
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语句在 SET 子句中没有嵌入的 SQL 表达式。
- en: 'The mapping does not use a `mapper.version_id_col`, or the backend dialect
    supports a “sane” rowcount for an executemany() operation; most DBAPIs support
    this correctly now.  ### Session.get_bind() handles a wider variety of inheritance
    scenarios'
  id: totrans-552
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '映射不使用 `mapper.version_id_col`，或者后端方言支持 executemany() 操作的“合理”行数；大多数 DBAPI 现在都正确支持这一点。  ###
    Session.get_bind() 处理更广泛的继承场景'
- en: 'The [`Session.get_bind()`](../orm/session_api.html#sqlalchemy.orm.Session.get_bind
    "sqlalchemy.orm.Session.get_bind") method is invoked whenever a query or unit
    of work flush process seeks to locate the database engine that corresponds to
    a particular class. The method has been improved to handle a variety of inheritance-oriented
    scenarios, including:'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 每当查询或工作单元刷新过程寻找与特定类对应的数据库引擎时，都会调用 [`Session.get_bind()`](../orm/session_api.html#sqlalchemy.orm.Session.get_bind
    "sqlalchemy.orm.Session.get_bind") 方法。该方法已经改进，以处理各种继承导向的场景，包括：
- en: 'Binding to a Mixin or Abstract Class:'
  id: totrans-554
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绑定到 Mixin 或抽象类：
- en: '[PRE137]'
  id: totrans-555
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'Binding to inherited concrete subclasses individually based on table:'
  id: totrans-556
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据表单独绑定到继承的具体子类：
- en: '[PRE138]'
  id: totrans-557
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[#3035](https://www.sqlalchemy.org/trac/ticket/3035)  ### Session.get_bind()
    will receive the Mapper in all relevant Query cases'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3035](https://www.sqlalchemy.org/trac/ticket/3035)  ### 在所有相关的查询情况下，`Session.get_bind()`
    将接收到 Mapper'
- en: A series of issues were repaired where the [`Session.get_bind()`](../orm/session_api.html#sqlalchemy.orm.Session.get_bind
    "sqlalchemy.orm.Session.get_bind") would not receive the primary [`Mapper`](../orm/mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper") of the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query"), even though this mapper was readily available (the primary
    mapper is the single mapper, or alternatively the first mapper, that is associated
    with a [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    object).
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 修复了一系列问题，其中 [`Session.get_bind()`](../orm/session_api.html#sqlalchemy.orm.Session.get_bind
    "sqlalchemy.orm.Session.get_bind") 不会接收到 [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") 的主要 [`Mapper`](../orm/mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper")，尽管该映射器是readily available的（主要映射器是与 [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") 对象关联的单个映射器，或者是第一个映射器）。
- en: The [`Mapper`](../orm/mapping_api.html#sqlalchemy.orm.Mapper "sqlalchemy.orm.Mapper")
    object, when passed to [`Session.get_bind()`](../orm/session_api.html#sqlalchemy.orm.Session.get_bind
    "sqlalchemy.orm.Session.get_bind"), is typically used by sessions that make use
    of the [`Session.binds`](../orm/session_api.html#sqlalchemy.orm.Session.params.binds
    "sqlalchemy.orm.Session") parameter to associate mappers with a series of engines
    (although in this use case, things frequently “worked” in most cases anyway as
    the bind would be located via the mapped table object), or more specifically implement
    a user-defined [`Session.get_bind()`](../orm/session_api.html#sqlalchemy.orm.Session.get_bind
    "sqlalchemy.orm.Session.get_bind") method that provides some pattern of selecting
    engines based on mappers, such as horizontal sharding or a so-called “routing”
    session that routes queries to different backends.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 当传递给 [`Session.get_bind()`](../orm/session_api.html#sqlalchemy.orm.Session.get_bind
    "sqlalchemy.orm.Session.get_bind") 的 [`Mapper`](../orm/mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper") 对象通常由使用 [`Session.binds`](../orm/session_api.html#sqlalchemy.orm.Session.params.binds
    "sqlalchemy.orm.Session") 参数将映射与一系列引擎关联的会话使用（尽管在这种情况下，大多数情况下事情通常“工作”，因为绑定通常通过映射表对象找到），或更具体地实现一个用户定义的
    [`Session.get_bind()`](../orm/session_api.html#sqlalchemy.orm.Session.get_bind
    "sqlalchemy.orm.Session.get_bind") 方法，根据映射器选择引擎的某种模式，比如水平分片或所谓的“路由”会话，将查询路由到不同的后端。
- en: 'These scenarios include:'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 这些场景包括：
- en: '[`Query.count()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.count "sqlalchemy.orm.Query.count"):'
  id: totrans-562
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`Query.count()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.count "sqlalchemy.orm.Query.count"):'
- en: '[PRE139]'
  id: totrans-563
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[`Query.update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.update
    "sqlalchemy.orm.Query.update") and [`Query.delete()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.delete
    "sqlalchemy.orm.Query.delete"), both for the UPDATE/DELETE statement as well as
    for the SELECT used by the “fetch” strategy:'
  id: totrans-564
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`Query.update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.update
    "sqlalchemy.orm.Query.update") 和 [`Query.delete()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.delete
    "sqlalchemy.orm.Query.delete")，用于 UPDATE/DELETE 语句以及“fetch”策略所使用的 SELECT：'
- en: '[PRE140]'
  id: totrans-565
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE140]'
- en: 'Queries against individual columns:'
  id: totrans-566
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 针对单独列的查询：
- en: '[PRE141]'
  id: totrans-567
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE141]'
- en: 'SQL functions and other expressions against indirect mappings such as [`column_property`](../orm/mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property"):'
  id: totrans-568
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '针对间接映射的 SQL 函数和其他表达式，比如 [`column_property`](../orm/mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property"):'
- en: '[PRE142]'
  id: totrans-569
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[#3227](https://www.sqlalchemy.org/trac/ticket/3227) [#3242](https://www.sqlalchemy.org/trac/ticket/3242)
    [#1326](https://www.sqlalchemy.org/trac/ticket/1326)  ### .info dictionary improvements'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3227](https://www.sqlalchemy.org/trac/ticket/3227) [#3242](https://www.sqlalchemy.org/trac/ticket/3242)
    [#1326](https://www.sqlalchemy.org/trac/ticket/1326)  ### .info 字典改进'
- en: 'The `InspectionAttr.info` collection is now available on every kind of object
    that one would retrieve from the [`Mapper.all_orm_descriptors`](../orm/mapping_api.html#sqlalchemy.orm.Mapper.all_orm_descriptors
    "sqlalchemy.orm.Mapper.all_orm_descriptors") collection. This includes [`hybrid_property`](../orm/extensions/hybrid.html#sqlalchemy.ext.hybrid.hybrid_property
    "sqlalchemy.ext.hybrid.hybrid_property") and [`association_proxy()`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.association_proxy
    "sqlalchemy.ext.associationproxy.association_proxy"). However, as these objects
    are class-bound descriptors, they must be accessed **separately** from the class
    to which they are attached in order to get at the attribute. Below this is illustrated
    using the [`Mapper.all_orm_descriptors`](../orm/mapping_api.html#sqlalchemy.orm.Mapper.all_orm_descriptors
    "sqlalchemy.orm.Mapper.all_orm_descriptors") namespace:'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: '`InspectionAttr.info` 集合现在可以在从[`Mapper.all_orm_descriptors`](../orm/mapping_api.html#sqlalchemy.orm.Mapper.all_orm_descriptors
    "sqlalchemy.orm.Mapper.all_orm_descriptors") 集合中检索到的每种对象上使用。这包括[`hybrid_property`](../orm/extensions/hybrid.html#sqlalchemy.ext.hybrid.hybrid_property
    "sqlalchemy.ext.hybrid.hybrid_property") 和 [`association_proxy()`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.association_proxy
    "sqlalchemy.ext.associationproxy.association_proxy")。然而，由于这些对象是类绑定描述符，必须**单独**从它们所附加的类中访问以获取属性。以下是使用[`Mapper.all_orm_descriptors`](../orm/mapping_api.html#sqlalchemy.orm.Mapper.all_orm_descriptors
    "sqlalchemy.orm.Mapper.all_orm_descriptors") 命名空间进行说明：'
- en: '[PRE143]'
  id: totrans-572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: It is also available as a constructor argument for all [`SchemaItem`](../core/metadata.html#sqlalchemy.schema.SchemaItem
    "sqlalchemy.schema.SchemaItem") objects (e.g. [`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey"), [`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint") etc.) as well as remaining ORM constructs
    such as [`synonym()`](../orm/mapped_attributes.html#sqlalchemy.orm.synonym "sqlalchemy.orm.synonym").
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 它也作为所有[`SchemaItem`](../core/metadata.html#sqlalchemy.schema.SchemaItem "sqlalchemy.schema.SchemaItem")
    对象（例如[`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey "sqlalchemy.schema.ForeignKey")、[`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint")等）的构造函数参数，以及剩余的ORM构造，如[`synonym()`](../orm/mapped_attributes.html#sqlalchemy.orm.synonym
    "sqlalchemy.orm.synonym")。
- en: '[#2971](https://www.sqlalchemy.org/trac/ticket/2971)'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2971](https://www.sqlalchemy.org/trac/ticket/2971)'
- en: '[#2963](https://www.sqlalchemy.org/trac/ticket/2963)  ### ColumnProperty constructs
    work a lot better with aliases, order_by'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2963](https://www.sqlalchemy.org/trac/ticket/2963)  ### ColumnProperty 结构在使用别名、order_by
    时效果更好'
- en: A variety of issues regarding [`column_property()`](../orm/mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property") have been fixed, most specifically with regards
    to the [`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased "sqlalchemy.orm.aliased")
    construct as well as the “order by label” logic introduced in 0.9 (see [Label
    constructs can now render as their name alone in an ORDER BY](migration_09.html#migration-1068)).
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 已修复了关于[`column_property()`](../orm/mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property")的各种问题，特别是关于[`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased
    "sqlalchemy.orm.aliased")构造以及0.9版本中引入的“order by label”逻辑（参见[Label constructs can
    now render as their name alone in an ORDER BY](migration_09.html#migration-1068)）。
- en: 'Given a mapping like the following:'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 给定如下映射：
- en: '[PRE144]'
  id: totrans-578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'A simple scenario that included “A.b” twice would fail to render correctly:'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的包含两次“A.b”的场景将无法正确呈现：
- en: '[PRE145]'
  id: totrans-580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'This would order by the wrong column:'
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 这将按照错误的列排序：
- en: '[PRE146]'
  id: totrans-582
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: 'New output:'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 新输出：
- en: '[PRE147]'
  id: totrans-584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: 'There were also many scenarios where the “order by” logic would fail to order
    by label, for example if the mapping were “polymorphic”:'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多情况下，“order by”逻辑将无法按照标签排序，例如如果映射是“多态”的情况：
- en: '[PRE148]'
  id: totrans-586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: 'The order_by would fail to use the label, as it would be anonymized due to
    the polymorphic loading:'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: order_by 将无法使用标签，因为由于多态加载而被匿名化：
- en: '[PRE149]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'Now that the order by label tracks the anonymized label, this now works:'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 order by 标签跟踪匿名化标签，这现在可以工作：
- en: '[PRE150]'
  id: totrans-590
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: Included in these fixes are a variety of heisenbugs that could corrupt the state
    of an `aliased()` construct such that the labeling logic would again fail; these
    have also been fixed.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 这些修复中包括了各种可能破坏`aliased()`构造状态的 heisenbugs；这些问题也已经修复。
- en: '[#3148](https://www.sqlalchemy.org/trac/ticket/3148) [#3188](https://www.sqlalchemy.org/trac/ticket/3188)'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3148](https://www.sqlalchemy.org/trac/ticket/3148) [#3188](https://www.sqlalchemy.org/trac/ticket/3188)'
- en: New Session Bulk INSERT/UPDATE API
  id: totrans-593
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 新的会话批量插入/更新API
- en: A new series of [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    methods which provide hooks directly into the unit of work’s facility for emitting
    INSERT and UPDATE statements has been created. When used correctly, this expert-oriented
    system can allow ORM-mappings to be used to generate bulk insert and update statements
    batched into executemany groups, allowing the statements to proceed at speeds
    that rival direct use of the Core.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了一系列新的[`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")方法，直接提供钩子进入工作单元的功能，用于发出INSERT和UPDATE语句。当正确使用时，这个面向专家的系统可以允许ORM映射用于生成批量插入和更新语句，分批执行到executemany组，使语句以与直接使用Core相媲美的速度进行。
- en: See also
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Bulk Operations](../orm/persistence_techniques.html#bulk-operations) - introduction
    and full documentation'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: '[批量操作](../orm/persistence_techniques.html#bulk-operations) - 介绍和完整文档'
- en: '[#3100](https://www.sqlalchemy.org/trac/ticket/3100)'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3100](https://www.sqlalchemy.org/trac/ticket/3100)'
- en: New Performance Example Suite
  id: totrans-598
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 新的性能示例套件
- en: Inspired by the benchmarking done for the [Bulk Operations](../orm/persistence_techniques.html#bulk-operations)
    feature as well as for the [How can I profile a SQLAlchemy powered application?](../faq/performance.html#faq-how-to-profile)
    section of the FAQ, a new example section has been added which features several
    scripts designed to illustrate the relative performance profile of various Core
    and ORM techniques. The scripts are organized into use cases, and are packaged
    under a single console interface such that any combination of demonstrations can
    be run, dumping out timings, Python profile results and/or RunSnake profile displays.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 受到对[批量操作](../orm/persistence_techniques.html#bulk-operations)功能以及FAQ中的[如何对SQLAlchemy应用程序进行性能分析？](../faq/performance.html#faq-how-to-profile)部分进行的基准测试的启发，添加了一个新的示例部分，其中包含几个旨在说明各种Core和ORM技术的相对性能概况的脚本。这些脚本按用例组织，并打包在一个单一的控制台界面下，以便可以运行任意组合的演示，输出时间、Python性能分析结果和/或RunSnake性能显示。
- en: See also
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Performance](../orm/examples.html#examples-performance)'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: '[性能](../orm/examples.html#examples-performance)'
- en: “Baked” Queries
  id: totrans-602
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: “烘焙”查询
- en: 'The “baked” query feature is an unusual new approach which allows for straightforward
    construction an invocation of [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") objects using caching, which upon successive calls features
    vastly reduced Python function call overhead (over 75%). By specifying a [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object as a series of lambdas which are only invoked once,
    a query as a pre-compiled unit begins to be feasible:'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: “烘焙”查询功能是一种不同寻常的新方法，允许使用缓存直接构建和调用[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")对象，随着连续调用，Python函数调用开销大大降低（超过75%）。通过将[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")对象指定为一系列仅调用一次的lambda表达式，作为预编译单元的查询开始变得可行：
- en: '[PRE151]'
  id: totrans-604
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: See also
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Baked Queries](../orm/extensions/baked.html)'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: '[烘焙查询](../orm/extensions/baked.html)'
- en: '[#3054](https://www.sqlalchemy.org/trac/ticket/3054)'
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3054](https://www.sqlalchemy.org/trac/ticket/3054)'
- en: '### Improvements to declarative mixins, `@declared_attr` and related features'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: '### 改进声明性混合类，`@declared_attr`和相关功能'
- en: The declarative system in conjunction with [`declared_attr`](../orm/mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr") has been overhauled to support new capabilities.
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 与[`declared_attr`](../orm/mapping_api.html#sqlalchemy.orm.declared_attr "sqlalchemy.orm.declared_attr")结合使用的声明性系统已经进行了全面改进，以支持新的功能。
- en: 'A function decorated with [`declared_attr`](../orm/mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr") is now called only **after** any mixin-based column
    copies are generated. This means the function can call upon mixin-established
    columns and will receive a reference to the correct [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") object:'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用[`declared_attr`](../orm/mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr")装饰的函数仅在生成基于混合类的列副本之后才被调用。这意味着该函数可以调用基于混合类建立的列，并将接收到正确的[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")对象的引用：
- en: '[PRE152]'
  id: totrans-611
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: Above, `SomeClass.foobar_prop` will be invoked against `SomeClass`, and `SomeClass.foobar`
    will be the final [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    object that is to be mapped to `SomeClass`, as opposed to the non-copied object
    present directly on `HasFooBar`, even though the columns aren’t mapped yet.
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，`SomeClass.foobar_prop` 将针对 `SomeClass` 调用，而 `SomeClass.foobar` 将是最终要映射到
    `SomeClass` 的 [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    对象，而不是直接存在于 `HasFooBar` 上的非复制对象，即使列尚未映射。
- en: 'The [`declared_attr`](../orm/mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr") function now **memoizes** the value that’s returned
    on a per-class basis, so that repeated calls to the same attribute will return
    the same value. We can alter the example to illustrate this:'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: '[`declared_attr`](../orm/mapping_api.html#sqlalchemy.orm.declared_attr "sqlalchemy.orm.declared_attr")
    函数现在会基于每个类记忆返回的值，以便对相同属性的重复调用会返回相同的值。我们可以修改示例来说明这一点：'
- en: '[PRE153]'
  id: totrans-614
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: Previously, `SomeClass` would be mapped with one particular copy of the `foobar`
    column, but the `foobar_prop` by calling upon `foobar` a second time would produce
    a different column. The value of `SomeClass.foobar` is now memoized during declarative
    setup time, so that even before the attribute is mapped by the mapper, the interim
    column value will remain consistent no matter how many times the [`declared_attr`](../orm/mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr") is called upon.
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，`SomeClass` 将以一个特定的 `foobar` 列的副本进行映射，但通过第二次调用 `foobar` 来调用 `foobar_prop`
    将产生一个不同的列。在声明式设置期间，`SomeClass.foobar` 的值现在被记忆，因此即使在属性由映射器映射之前，临时列值也将保持一致，无论 [`declared_attr`](../orm/mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr") 被调用多少次。
- en: The two behaviors above should help considerably with declarative definition
    of many types of mapper properties that derive from other attributes, where the
    [`declared_attr`](../orm/mapping_api.html#sqlalchemy.orm.declared_attr "sqlalchemy.orm.declared_attr")
    function is called upon from other [`declared_attr`](../orm/mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr") functions locally present before the class is
    actually mapped.
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 上述两种行为应该极大地帮助声明性定义许多类型的映射器属性，这些属性派生自其他属性，在类实际映射之前从其他 [`declared_attr`](../orm/mapping_api.html#sqlalchemy.orm.declared_attr
    "sqlalchemy.orm.declared_attr") 函数中调用。
- en: 'For a pretty slim edge case where one wishes to build a declarative mixin that
    establishes distinct columns per subclass, a new modifier [`declared_attr.cascading`](../orm/mapping_api.html#sqlalchemy.orm.declared_attr.cascading
    "sqlalchemy.orm.declared_attr.cascading") is added. With this modifier, the decorated
    function will be invoked individually for each class in the mapped inheritance
    hierarchy. While this is already the behavior for special attributes such as `__table_args__`
    and `__mapper_args__`, for columns and other properties the behavior by default
    assumes that attribute is affixed to the base class only, and just inherited from
    subclasses. With [`declared_attr.cascading`](../orm/mapping_api.html#sqlalchemy.orm.declared_attr.cascading
    "sqlalchemy.orm.declared_attr.cascading"), individual behaviors can be applied:'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个非常罕见的边缘情况，其中希望建立一个在每个子类中建立不同列的声明性混合类，添加了一个新的修饰符 [`declared_attr.cascading`](../orm/mapping_api.html#sqlalchemy.orm.declared_attr.cascading
    "sqlalchemy.orm.declared_attr.cascading")。使用这个修饰符，装饰的函数将分别为映射的继承层次结构中的每个类调用。虽然这已经是诸如
    `__table_args__` 和 `__mapper_args__` 等特殊属性的行为，但是对于列和其他属性，默认情况下假定该属性仅附加到基类，并且仅从子类继承。使用
    [`declared_attr.cascading`](../orm/mapping_api.html#sqlalchemy.orm.declared_attr.cascading
    "sqlalchemy.orm.declared_attr.cascading")，可以应用单独的行为：
- en: '[PRE154]'
  id: totrans-618
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: See also
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 另见
- en: '[Using _orm.declared_attr() to generate table-specific inheriting columns](../orm/declarative_mixins.html#mixin-inheritance-columns)'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用 _orm.declared_attr() 生成特定于表的继承列](../orm/declarative_mixins.html#mixin-inheritance-columns)'
- en: 'Finally, the [`AbstractConcreteBase`](../orm/extensions/declarative/index.html#sqlalchemy.ext.declarative.AbstractConcreteBase
    "sqlalchemy.ext.declarative.AbstractConcreteBase") class has been reworked so
    that a relationship or other mapper property can be set up inline on the abstract
    base:'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，[`AbstractConcreteBase`](../orm/extensions/declarative/index.html#sqlalchemy.ext.declarative.AbstractConcreteBase
    "sqlalchemy.ext.declarative.AbstractConcreteBase") 类已经重新设计，以便在抽象基类上内联设置关系或其他映射器属性：
- en: '[PRE155]'
  id: totrans-622
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: The above mapping will set up a table `cca` with both an `id` and a `something_id`
    column, and `Concrete` will also have a relationship `something`. The new feature
    is that `Abstract` will also have an independently configured relationship `something`
    that builds against the polymorphic union of the base.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 上述映射将设置一个名为 `cca` 的表，其中包含 `id` 和 `something_id` 列，而 `Concrete` 还将具有一个名为 `something`
    的关系。新功能是 `Abstract` 也将有一个独立配置的关系 `something`，该关系构建在基类的多态联合上。
- en: '[#3150](https://www.sqlalchemy.org/trac/ticket/3150) [#2670](https://www.sqlalchemy.org/trac/ticket/2670)
    [#3149](https://www.sqlalchemy.org/trac/ticket/3149) [#2952](https://www.sqlalchemy.org/trac/ticket/2952)
    [#3050](https://www.sqlalchemy.org/trac/ticket/3050)'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3150](https://www.sqlalchemy.org/trac/ticket/3150) [#2670](https://www.sqlalchemy.org/trac/ticket/2670)
    [#3149](https://www.sqlalchemy.org/trac/ticket/3149) [#2952](https://www.sqlalchemy.org/trac/ticket/2952)
    [#3050](https://www.sqlalchemy.org/trac/ticket/3050)'
- en: ORM full object fetches 25% faster
  id: totrans-625
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ORM 完整对象的提取速度提高了 25%
- en: 'The mechanics of the `loading.py` module as well as the identity map have undergone
    several passes of inlining, refactoring, and pruning, so that a raw load of rows
    now populates ORM-based objects around 25% faster. Assuming a 1M row table, a
    script like the following illustrates the type of load that’s improved the most:'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: '`loading.py` 模块的机制以及标识映射经历了几次内联、重构和修剪，因此现在原始行的加载速度比基于 ORM 的对象快约 25%。假设有一个包含
    1 百万行的表，下面的脚本演示了最大程度改进的加载类型：'
- en: '[PRE156]'
  id: totrans-627
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: Local MacBookPro results bench from 19 seconds for 0.9 down to 14 seconds for
    1.0\. The [`Query.yield_per()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.yield_per
    "sqlalchemy.orm.Query.yield_per") call is always a good idea when batching huge
    numbers of rows, as it prevents the Python interpreter from having to allocate
    a huge amount of memory for all objects and their instrumentation at once. Without
    the [`Query.yield_per()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.yield_per
    "sqlalchemy.orm.Query.yield_per"), the above script on the MacBookPro is 31 seconds
    on 0.9 and 26 seconds on 1.0, the extra time spent setting up very large memory
    buffers.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 本地 MacBookPro 的结果从 0.9 秒降至 1.0 秒的时间为 19 秒降至 14 秒。在批量处理大量行时，[`Query.yield_per()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.yield_per
    "sqlalchemy.orm.Query.yield_per") 的调用总是一个好主意，因为它可以防止 Python 解释器一次性为所有对象及其仪器分配大量内存。没有
    [`Query.yield_per()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.yield_per
    "sqlalchemy.orm.Query.yield_per")，在 MacBookPro 上，0.9 版本上的上述脚本需要 31 秒，1.0 版本上需要
    26 秒，额外的时间用于设置非常大的内存缓冲区。
- en: '### New KeyedTuple implementation dramatically faster'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: '### 新的 KeyedTuple 实现速度显著提高'
- en: 'We took a look into the `KeyedTuple` implementation in the hopes of improving
    queries like this:'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 我们研究了 `KeyedTuple` 实现，希望改进这样的查询：
- en: '[PRE157]'
  id: totrans-631
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: 'The `KeyedTuple` class is used rather than Python’s `collections.namedtuple()`,
    because the latter has a very complex type-creation routine that benchmarks much
    slower than `KeyedTuple`. However, when fetching hundreds of thousands of rows,
    `collections.namedtuple()` quickly overtakes `KeyedTuple` which becomes dramatically
    slower as instance invocation goes up. What to do? A new type that hedges between
    the approaches of both. Benching all three types for “size” (number of rows returned)
    and “num” (number of distinct queries), the new “lightweight keyed tuple” either
    outperforms both, or lags very slightly behind the faster object, based on which
    scenario. In the “sweet spot”, where we are both creating a good number of new
    types as well as fetching a good number of rows, the lightweight object totally
    smokes both namedtuple and KeyedTuple:'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `KeyedTuple` 类而不是 Python 的 `collections.namedtuple()`，因为后者具有一个非常复杂的类型创建程序，其性能比
    `KeyedTuple` 慢得多。然而，当提取数十万行时，`collections.namedtuple()` 很快就会超过 `KeyedTuple`，随着实例调用次数的增加，`KeyedTuple`
    的性能会急剧下降。怎么办？一个新类型，介于两者之间的方法。对于“大小”（返回的行数）和“num”（不同查询的数量）对所有三种类型进行测试，新的“轻量级键值元组”要么优于两者，要么略逊于更快的对象，具体取决于情况。在“甜蜜点”，我们既创建了大量新类型，又提取了大量行时，轻量级对象完全超越了
    namedtuple 和 KeyedTuple：
- en: '[PRE158]'
  id: totrans-633
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '[#3176](https://www.sqlalchemy.org/trac/ticket/3176)'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3176](https://www.sqlalchemy.org/trac/ticket/3176)'
- en: '### Significant Improvements in Structural Memory Use'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: '### 结构内存使用方面的显著改进'
- en: Structural memory use has been improved via much more significant use of `__slots__`
    for many internal objects. This optimization is particularly geared towards the
    base memory size of large applications that have lots of tables and columns, and
    reduces memory size for a variety of high-volume objects including event listening
    internals, comparator objects and parts of the ORM attribute and loader strategy
    system.
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 通过更多内部对象的`__slots__`的更显著使用改进了结构性内存使用。这种优化特别针对具有大量表和列的大型应用程序的基本内存大小，并减少了各种高容量对象的内存大小，包括事件监听内部、比较器对象以及ORM属性和加载器策略系统的部分。
- en: 'A bench that makes use of heapy measure the startup size of Nova illustrates
    a difference of about 3.7 fewer megs, or 46%, taken up by SQLAlchemy’s objects,
    associated dictionaries, as well as weakrefs, within a basic import of “nova.db.sqlalchemy.models”:'
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 一个利用heapy测量Nova启动大小的工作台展示了SQLAlchemy对象、相关字典以及弱引用在“nova.db.sqlalchemy.models”基本导入中占用的空间约减少了3.7兆字节，或46%：
- en: '[PRE159]'
  id: totrans-638
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: '### UPDATE statements are now batched with executemany() in a flush'
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: '### UPDATE语句现在在flush中与executemany()批处理'
- en: 'UPDATE statements can now be batched within an ORM flush into more performant
    executemany() call, similarly to how INSERT statements can be batched; this will
    be invoked within flush based on the following criteria:'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以将UPDATE语句批量处理到ORM flush中，以更高效的executemany()调用，类似于INSERT语句可以批量处理；这将根据以下标准在flush中调用：
- en: two or more UPDATE statements in sequence involve the identical set of columns
    to be modified.
  id: totrans-641
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连续两个或更多的UPDATE语句涉及相同的要修改的列集。
- en: The statement has no embedded SQL expressions in the SET clause.
  id: totrans-642
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该语句在SET子句中没有嵌入SQL表达式。
- en: The mapping does not use a `mapper.version_id_col`, or the backend dialect supports
    a “sane” rowcount for an executemany() operation; most DBAPIs support this correctly
    now.
  id: totrans-643
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 映射不使用`mapper.version_id_col`，或者后端方言支持对executemany()操作的“合理”行数计数；现在大多数DBAPI都正确支持这一点。
- en: '### Session.get_bind() handles a wider variety of inheritance scenarios'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: '### Session.get_bind()处理更广泛的继承场景'
- en: 'The [`Session.get_bind()`](../orm/session_api.html#sqlalchemy.orm.Session.get_bind
    "sqlalchemy.orm.Session.get_bind") method is invoked whenever a query or unit
    of work flush process seeks to locate the database engine that corresponds to
    a particular class. The method has been improved to handle a variety of inheritance-oriented
    scenarios, including:'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 每当查询或工作单元flush过程试图定位与特定类对应的数据库引擎时，都会调用[`Session.get_bind()`](../orm/session_api.html#sqlalchemy.orm.Session.get_bind
    "sqlalchemy.orm.Session.get_bind")方法。该方法已经改进，以处理各种基于继承的场景，包括：
- en: 'Binding to a Mixin or Abstract Class:'
  id: totrans-646
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绑定到Mixin或抽象类：
- en: '[PRE160]'
  id: totrans-647
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'Binding to inherited concrete subclasses individually based on table:'
  id: totrans-648
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据表单独绑定到继承的具体子类：
- en: '[PRE161]'
  id: totrans-649
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '[#3035](https://www.sqlalchemy.org/trac/ticket/3035)'
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3035](https://www.sqlalchemy.org/trac/ticket/3035)'
- en: '### Session.get_bind() will receive the Mapper in all relevant Query cases'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: '### Session.get_bind()将在所有相关的Query情况下接收到Mapper'
- en: A series of issues were repaired where the [`Session.get_bind()`](../orm/session_api.html#sqlalchemy.orm.Session.get_bind
    "sqlalchemy.orm.Session.get_bind") would not receive the primary [`Mapper`](../orm/mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper") of the [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query"), even though this mapper was readily available (the primary
    mapper is the single mapper, or alternatively the first mapper, that is associated
    with a [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query "sqlalchemy.orm.Query")
    object).
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 修复了一系列问题，其中[`Session.get_bind()`](../orm/session_api.html#sqlalchemy.orm.Session.get_bind
    "sqlalchemy.orm.Session.get_bind")不会接收到[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")的主要[`Mapper`](../orm/mapping_api.html#sqlalchemy.orm.Mapper
    "sqlalchemy.orm.Mapper")，即使该映射器是readily available的（主要映射器是与[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")对象关联的单个映射器，或者是第一个映射器）。
- en: The [`Mapper`](../orm/mapping_api.html#sqlalchemy.orm.Mapper "sqlalchemy.orm.Mapper")
    object, when passed to [`Session.get_bind()`](../orm/session_api.html#sqlalchemy.orm.Session.get_bind
    "sqlalchemy.orm.Session.get_bind"), is typically used by sessions that make use
    of the [`Session.binds`](../orm/session_api.html#sqlalchemy.orm.Session.params.binds
    "sqlalchemy.orm.Session") parameter to associate mappers with a series of engines
    (although in this use case, things frequently “worked” in most cases anyway as
    the bind would be located via the mapped table object), or more specifically implement
    a user-defined [`Session.get_bind()`](../orm/session_api.html#sqlalchemy.orm.Session.get_bind
    "sqlalchemy.orm.Session.get_bind") method that provides some pattern of selecting
    engines based on mappers, such as horizontal sharding or a so-called “routing”
    session that routes queries to different backends.
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 当 [`Mapper`](../orm/mapping_api.html#sqlalchemy.orm.Mapper "sqlalchemy.orm.Mapper")
    对象传递给 [`Session.get_bind()`](../orm/session_api.html#sqlalchemy.orm.Session.get_bind
    "sqlalchemy.orm.Session.get_bind") 时，通常由使用 [`Session.binds`](../orm/session_api.html#sqlalchemy.orm.Session.params.binds
    "sqlalchemy.orm.Session") 参数关联映射器与一系列引擎的会话使用，或更具体地实现一个用户定义的 [`Session.get_bind()`](../orm/session_api.html#sqlalchemy.orm.Session.get_bind
    "sqlalchemy.orm.Session.get_bind") 方法，根据映射器提供一种基于模式选择引擎的方式，例如水平分片或所谓的“路由”会话，将查询路由到不同的后端。
- en: 'These scenarios include:'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 这些场景包括：
- en: '[`Query.count()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.count "sqlalchemy.orm.Query.count"):'
  id: totrans-655
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`Query.count()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.count "sqlalchemy.orm.Query.count"):'
- en: '[PRE162]'
  id: totrans-656
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE162]'
- en: '[`Query.update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.update
    "sqlalchemy.orm.Query.update") and [`Query.delete()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.delete
    "sqlalchemy.orm.Query.delete"), both for the UPDATE/DELETE statement as well as
    for the SELECT used by the “fetch” strategy:'
  id: totrans-657
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`Query.update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.update
    "sqlalchemy.orm.Query.update") 和 [`Query.delete()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.delete
    "sqlalchemy.orm.Query.delete")，都用于 UPDATE/DELETE 语句以及“fetch”策略中使用的 SELECT：'
- en: '[PRE163]'
  id: totrans-658
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE163]'
- en: 'Queries against individual columns:'
  id: totrans-659
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 针对单个列的查询：
- en: '[PRE164]'
  id: totrans-660
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE164]'
- en: 'SQL functions and other expressions against indirect mappings such as [`column_property`](../orm/mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property"):'
  id: totrans-661
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 针对间接映射的 SQL 函数和其他表达式，例如 [`column_property`](../orm/mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property")：
- en: '[PRE165]'
  id: totrans-662
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE165]'
- en: '[#3227](https://www.sqlalchemy.org/trac/ticket/3227) [#3242](https://www.sqlalchemy.org/trac/ticket/3242)
    [#1326](https://www.sqlalchemy.org/trac/ticket/1326)'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3227](https://www.sqlalchemy.org/trac/ticket/3227) [#3242](https://www.sqlalchemy.org/trac/ticket/3242)
    [#1326](https://www.sqlalchemy.org/trac/ticket/1326)'
- en: '### .info dictionary improvements'
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: '### .info 字典改进'
- en: 'The `InspectionAttr.info` collection is now available on every kind of object
    that one would retrieve from the [`Mapper.all_orm_descriptors`](../orm/mapping_api.html#sqlalchemy.orm.Mapper.all_orm_descriptors
    "sqlalchemy.orm.Mapper.all_orm_descriptors") collection. This includes [`hybrid_property`](../orm/extensions/hybrid.html#sqlalchemy.ext.hybrid.hybrid_property
    "sqlalchemy.ext.hybrid.hybrid_property") and [`association_proxy()`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.association_proxy
    "sqlalchemy.ext.associationproxy.association_proxy"). However, as these objects
    are class-bound descriptors, they must be accessed **separately** from the class
    to which they are attached in order to get at the attribute. Below this is illustrated
    using the [`Mapper.all_orm_descriptors`](../orm/mapping_api.html#sqlalchemy.orm.Mapper.all_orm_descriptors
    "sqlalchemy.orm.Mapper.all_orm_descriptors") namespace:'
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: '`InspectionAttr.info` 集合现在可以在从 [`Mapper.all_orm_descriptors`](../orm/mapping_api.html#sqlalchemy.orm.Mapper.all_orm_descriptors
    "sqlalchemy.orm.Mapper.all_orm_descriptors") 集合中检索的任何类型的对象上使用。这包括 [`hybrid_property`](../orm/extensions/hybrid.html#sqlalchemy.ext.hybrid.hybrid_property
    "sqlalchemy.ext.hybrid.hybrid_property") 和 [`association_proxy()`](../orm/extensions/associationproxy.html#sqlalchemy.ext.associationproxy.association_proxy
    "sqlalchemy.ext.associationproxy.association_proxy")。然而，由于这些对象是类绑定描述符，必须**单独**从附加到的类中访问它们，以便访问属性。下面使用
    [`Mapper.all_orm_descriptors`](../orm/mapping_api.html#sqlalchemy.orm.Mapper.all_orm_descriptors
    "sqlalchemy.orm.Mapper.all_orm_descriptors") 命名空间进行说明：'
- en: '[PRE166]'
  id: totrans-666
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: It is also available as a constructor argument for all [`SchemaItem`](../core/metadata.html#sqlalchemy.schema.SchemaItem
    "sqlalchemy.schema.SchemaItem") objects (e.g. [`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey"), [`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint") etc.) as well as remaining ORM constructs
    such as [`synonym()`](../orm/mapped_attributes.html#sqlalchemy.orm.synonym "sqlalchemy.orm.synonym").
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 它也作为所有[`SchemaItem`](../core/metadata.html#sqlalchemy.schema.SchemaItem "sqlalchemy.schema.SchemaItem")对象（例如[`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey")、[`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint")等）的构造函数参数可用，以及剩余的ORM构造，如[`synonym()`](../orm/mapped_attributes.html#sqlalchemy.orm.synonym
    "sqlalchemy.orm.synonym")。
- en: '[#2971](https://www.sqlalchemy.org/trac/ticket/2971)'
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2971](https://www.sqlalchemy.org/trac/ticket/2971)'
- en: '[#2963](https://www.sqlalchemy.org/trac/ticket/2963)'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2963](https://www.sqlalchemy.org/trac/ticket/2963)'
- en: '### ColumnProperty constructs work a lot better with aliases, order_by'
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: '### ColumnProperty构造与别名、order_by更好地配合'
- en: A variety of issues regarding [`column_property()`](../orm/mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property") have been fixed, most specifically with regards
    to the [`aliased()`](../orm/queryguide/api.html#sqlalchemy.orm.aliased "sqlalchemy.orm.aliased")
    construct as well as the “order by label” logic introduced in 0.9 (see [Label
    constructs can now render as their name alone in an ORDER BY](migration_09.html#migration-1068)).
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 解决了关于[`column_property()`](../orm/mapping_api.html#sqlalchemy.orm.column_property
    "sqlalchemy.orm.column_property")的各种问题，特别是关于0.9版本引入的关于“order by label”逻辑的问题（参见[Label
    constructs can now render as their name alone in an ORDER BY](migration_09.html#migration-1068)）。
- en: 'Given a mapping like the following:'
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 给定以下映射：
- en: '[PRE167]'
  id: totrans-673
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: 'A simple scenario that included “A.b” twice would fail to render correctly:'
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的场景，包含两次“A.b”将无法正确呈现：
- en: '[PRE168]'
  id: totrans-675
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: 'This would order by the wrong column:'
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 这将按错误的列排序：
- en: '[PRE169]'
  id: totrans-677
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: 'New output:'
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 新输出：
- en: '[PRE170]'
  id: totrans-679
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: 'There were also many scenarios where the “order by” logic would fail to order
    by label, for example if the mapping were “polymorphic”:'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，“order by”逻辑无法按标签排序，例如如果映射是“多态”的：
- en: '[PRE171]'
  id: totrans-681
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: 'The order_by would fail to use the label, as it would be anonymized due to
    the polymorphic loading:'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 由于多态加载，order_by将无法使用标签，因为它将被匿名化：
- en: '[PRE172]'
  id: totrans-683
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: 'Now that the order by label tracks the anonymized label, this now works:'
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，由于order by标签跟踪了匿名化标签，这现在可以工作：
- en: '[PRE173]'
  id: totrans-685
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: Included in these fixes are a variety of heisenbugs that could corrupt the state
    of an `aliased()` construct such that the labeling logic would again fail; these
    have also been fixed.
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 这些修复中包括了一系列可能会破坏`aliased()`构造状态的heisenbugs，使标签逻辑再次失败；这些问题也已经修复。
- en: '[#3148](https://www.sqlalchemy.org/trac/ticket/3148) [#3188](https://www.sqlalchemy.org/trac/ticket/3188)'
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3148](https://www.sqlalchemy.org/trac/ticket/3148) [#3188](https://www.sqlalchemy.org/trac/ticket/3188)'
- en: New Features and Improvements - Core
  id: totrans-688
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 新功能和改进 - 核心
- en: '### Select/Query LIMIT / OFFSET may be specified as an arbitrary SQL expression'
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: '### Select/Query LIMIT / OFFSET可以指定为任意SQL表达式'
- en: 'The [`Select.limit()`](../core/selectable.html#sqlalchemy.sql.expression.Select.limit
    "sqlalchemy.sql.expression.Select.limit") and [`Select.offset()`](../core/selectable.html#sqlalchemy.sql.expression.Select.offset
    "sqlalchemy.sql.expression.Select.offset") methods now accept any SQL expression,
    in addition to integer values, as arguments. The ORM [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object also passes through any expression to the underlying
    [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select "sqlalchemy.sql.expression.Select")
    object. Typically this is used to allow a bound parameter to be passed, which
    can be substituted with a value later:'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Select.limit()`](../core/selectable.html#sqlalchemy.sql.expression.Select.limit
    "sqlalchemy.sql.expression.Select.limit")和[`Select.offset()`](../core/selectable.html#sqlalchemy.sql.expression.Select.offset
    "sqlalchemy.sql.expression.Select.offset")方法现在接受任何SQL表达式作为参数，而不仅仅是整数值。ORM [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")对象也将任何表达式传递给底层的[`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select")对象。通常用于允许传递绑定参数，稍后可以用值替换：'
- en: '[PRE174]'
  id: totrans-691
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: 'Dialects which don’t support non-integer LIMIT or OFFSET expressions may continue
    to not support this behavior; third party dialects may also need modification
    in order to take advantage of the new behavior. A dialect which currently uses
    the `._limit` or `._offset` attributes will continue to function for those cases
    where the limit/offset was specified as a simple integer value. However, when
    a SQL expression is specified, these two attributes will instead raise a [`CompileError`](../core/exceptions.html#sqlalchemy.exc.CompileError
    "sqlalchemy.exc.CompileError") on access. A third-party dialect which wishes to
    support the new feature should now call upon the `._limit_clause` and `._offset_clause`
    attributes to receive the full SQL expression, rather than the integer value.  ###
    The `use_alter` flag on `ForeignKeyConstraint` is (usually) no longer needed'
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 不支持非整数 LIMIT 或 OFFSET 表达式的方言可能继续不支持此行为；第三方方言可能还需要修改以利用新行为。当前使用 `._limit` 或 `._offset`
    属性的方言将继续为那些限制/偏移指定为简单整数值的情况下运行。然而，当指定 SQL 表达式时，这两个属性将在访问时引发 [`CompileError`](../core/exceptions.html#sqlalchemy.exc.CompileError
    "sqlalchemy.exc.CompileError")。希望支持新功能的第三方方言现在应调用 `._limit_clause` 和 `._offset_clause`
    属性以接收完整的 SQL 表达式，而不是整数值。### `ForeignKeyConstraint` 上的 `use_alter` 标志（通常）不再需要。
- en: The [`MetaData.create_all()`](../core/metadata.html#sqlalchemy.schema.MetaData.create_all
    "sqlalchemy.schema.MetaData.create_all") and [`MetaData.drop_all()`](../core/metadata.html#sqlalchemy.schema.MetaData.drop_all
    "sqlalchemy.schema.MetaData.drop_all") methods will now make use of a system that
    automatically renders an ALTER statement for foreign key constraints that are
    involved in mutually-dependent cycles between tables, without the need to specify
    [`ForeignKeyConstraint.use_alter`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint.params.use_alter
    "sqlalchemy.schema.ForeignKeyConstraint"). Additionally, the foreign key constraints
    no longer need to have a name in order to be created via ALTER; only the DROP
    operation requires a name. In the case of a DROP, the feature will ensure that
    only constraints which have explicit names are actually included as ALTER statements.
    In the case of an unresolvable cycle within a DROP, the system emits a succinct
    and clear error message now if the DROP cannot proceed.
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: '[`MetaData.create_all()`](../core/metadata.html#sqlalchemy.schema.MetaData.create_all
    "sqlalchemy.schema.MetaData.create_all") 和 [`MetaData.drop_all()`](../core/metadata.html#sqlalchemy.schema.MetaData.drop_all
    "sqlalchemy.schema.MetaData.drop_all") 方法现在将使用一个系统，自动为涉及表之间相互依赖循环的外键约束渲染 ALTER
    语句，无需指定 [`ForeignKeyConstraint.use_alter`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint.params.use_alter
    "sqlalchemy.schema.ForeignKeyConstraint")。此外，外键约束现在不再需要名称即可通过 ALTER 创建；只有 DROP
    操作需要名称。在 DROP 的情况下，该功能将确保只有具有显式名称的约束实际上包含在 ALTER 语句中。在 DROP 中存在无法解决的循环的情况下，如果无法继续执行
    DROP，系统现在会发出简洁明了的错误消息。'
- en: The [`ForeignKeyConstraint.use_alter`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint.params.use_alter
    "sqlalchemy.schema.ForeignKeyConstraint") and [`ForeignKey.use_alter`](../core/constraints.html#sqlalchemy.schema.ForeignKey.params.use_alter
    "sqlalchemy.schema.ForeignKey") flags remain in place, and continue to have the
    same effect of establishing those constraints for which ALTER is required during
    a CREATE/DROP scenario.
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: '[`ForeignKeyConstraint.use_alter`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint.params.use_alter
    "sqlalchemy.schema.ForeignKeyConstraint") 和 [`ForeignKey.use_alter`](../core/constraints.html#sqlalchemy.schema.ForeignKey.params.use_alter
    "sqlalchemy.schema.ForeignKey") 标志仍然存在，并且继续具有相同的效果，在 CREATE/DROP 场景中建立需要 ALTER
    的约束。'
- en: As of version 1.0.1, special logic takes over in the case of SQLite, which does
    not support ALTER, in the case that during a DROP, the given tables have an unresolvable
    cycle; in this case a warning is emitted, and the tables are dropped with **no**
    ordering, which is usually fine on SQLite unless constraints are enabled. To resolve
    the warning and proceed with at least a partial ordering on a SQLite database,
    particularly one where constraints are enabled, re-apply “use_alter” flags to
    those [`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey "sqlalchemy.schema.ForeignKey")
    and [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") objects which should be explicitly omitted
    from the sort.
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 从版本 1.0.1 开始，针对 SQLite 的特殊逻辑接管了 ALTER 的情况，在 DROP 期间，如果给定的表存在不可解析的循环，将发出警告，并且这些表将以
    **无** 排序的方式删除，这在 SQLite 上通常是可以接受的，除非启用了约束。为了解决警告并在 SQLite 数据库上至少进行部分排序，特别是在启用了约束的数据库上，请重新将“use_alter”标志应用于那些应该明确排除的
    [`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey "sqlalchemy.schema.ForeignKey")
    和 [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") 对象。
- en: See also
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Creating/Dropping Foreign Key Constraints via ALTER](../core/constraints.html#use-alter)
    - full description of the new behavior.'
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: '[通过 ALTER 创建/删除外键约束](../core/constraints.html#use-alter) - 新行为的完整描述。'
- en: '[#3282](https://www.sqlalchemy.org/trac/ticket/3282)  ### ResultProxy “auto
    close” is now a “soft” close'
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3282](https://www.sqlalchemy.org/trac/ticket/3282)  ### ResultProxy “auto
    close” 现在是 “soft” close'
- en: 'For many releases, the `ResultProxy` object has always been automatically closed
    out at the point at which all result rows have been fetched. This was to allow
    usage of the object without the need to call upon `ResultProxy.close()` explicitly;
    as all DBAPI resources had been freed, the object was safe to discard. However,
    the object maintained a strict “closed” behavior, which meant that any subsequent
    calls to `ResultProxy.fetchone()`, `ResultProxy.fetchmany()` or `ResultProxy.fetchall()`
    would now raise a [`ResourceClosedError`](../core/exceptions.html#sqlalchemy.exc.ResourceClosedError
    "sqlalchemy.exc.ResourceClosedError"):'
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多版本中，`ResultProxy` 对象总是在获取所有结果行后自动关闭。这是为了允许在不需要显式调用 `ResultProxy.close()`
    的情况下使用该对象；由于所有的 DBAPI 资源都已被释放，因此可以安全地丢弃该对象。但是，该对象保持了严格的“关闭”行为，这意味着对 `ResultProxy.fetchone()`、`ResultProxy.fetchmany()`
    或 `ResultProxy.fetchall()` 的任何后续调用现在都将引发 [`ResourceClosedError`](../core/exceptions.html#sqlalchemy.exc.ResourceClosedError
    "sqlalchemy.exc.ResourceClosedError")：
- en: '[PRE175]'
  id: totrans-700
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: This behavior is inconsistent vs. what pep-249 states, which is that you can
    call upon the fetch methods repeatedly even after results are exhausted. It also
    interferes with behavior for some implementations of result proxy, such as the
    `BufferedColumnResultProxy` used by the cx_oracle dialect for certain datatypes.
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为与 pep-249 规定的不一致，即使结果耗尽后仍然可以重复调用 fetch 方法。这也会干扰某些实现结果代理的行为，例如某些数据类型的 cx_oracle
    方言所使用的 `BufferedColumnResultProxy`。
- en: 'To solve this, the “closed” state of the `ResultProxy` has been broken into
    two states; a “soft close” which does the majority of what “close” does, in that
    it releases the DBAPI cursor and in the case of a “close with result” object will
    also release the connection, and a “closed” state which is everything included
    by “soft close” as well as establishing the fetch methods as “closed”. The `ResultProxy.close()`
    method is now never called implicitly, only the `ResultProxy._soft_close()` method
    which is non-public:'
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，“ResultProxy”的“closed”状态被分解为两个状态；一个“软关闭”执行了“关闭”的大部分功能，释放了 DBAPI 游标，并且在“带有结果的关闭”对象的情况下还会释放连接，并且一个“关闭”状态包括“软关闭”所包含的一切以及将提取方法设为“关闭”。`ResultProxy.close()`
    方法现在不会被隐式调用，只会调用 `ResultProxy._soft_close()` 方法，该方法是非公开的：
- en: '[PRE176]'
  id: totrans-703
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: '[#3330](https://www.sqlalchemy.org/trac/ticket/3330) [#3329](https://www.sqlalchemy.org/trac/ticket/3329)'
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3330](https://www.sqlalchemy.org/trac/ticket/3330) [#3329](https://www.sqlalchemy.org/trac/ticket/3329)'
- en: CHECK Constraints now support the `%(column_0_name)s` token in naming conventions
  id: totrans-705
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CHECK 约束现在支持命名约定中的 `%(column_0_name)s` 占位符。
- en: 'The `%(column_0_name)s` will derive from the first column found in the expression
    of a [`CheckConstraint`](../core/constraints.html#sqlalchemy.schema.CheckConstraint
    "sqlalchemy.schema.CheckConstraint"):'
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: '`%(column_0_name)s` 将派生自 [`CheckConstraint`](../core/constraints.html#sqlalchemy.schema.CheckConstraint
    "sqlalchemy.schema.CheckConstraint") 表达式中找到的第一列：'
- en: '[PRE177]'
  id: totrans-707
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: 'Will render:'
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 将呈现：
- en: '[PRE178]'
  id: totrans-709
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: The combination of naming conventions with the constraint produced by a [`SchemaType`](../core/type_basics.html#sqlalchemy.types.SchemaType
    "sqlalchemy.types.SchemaType") such as [`Boolean`](../core/type_basics.html#sqlalchemy.types.Boolean
    "sqlalchemy.types.Boolean") or [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum") will also now make use of all CHECK constraint conventions.
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: 与由[`SchemaType`](../core/type_basics.html#sqlalchemy.types.SchemaType "sqlalchemy.types.SchemaType")生成的约束的命名约定的组合，例如[`Boolean`](../core/type_basics.html#sqlalchemy.types.Boolean
    "sqlalchemy.types.Boolean")或[`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum")现在也将使用所有CHECK约束约定。
- en: See also
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Naming CHECK Constraints](../core/constraints.html#naming-check-constraints)'
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: '[命名CHECK约束](../core/constraints.html#naming-check-constraints)'
- en: '[Configuring Naming for Boolean, Enum, and other schema types](../core/constraints.html#naming-schematypes)'
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: '[配置布尔值、枚举和其他模式类型的命名](../core/constraints.html#naming-schematypes)'
- en: '[#3299](https://www.sqlalchemy.org/trac/ticket/3299)'
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3299](https://www.sqlalchemy.org/trac/ticket/3299)'
- en: '### Constraints referring to unattached Columns can auto-attach to the Table
    when their referred columns are attached'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: '### 当约束引用未附加的列时，可以在其引用的列附加到表时自动附加约束'
- en: 'Since at least version 0.8, a [`Constraint`](../core/constraints.html#sqlalchemy.schema.Constraint
    "sqlalchemy.schema.Constraint") has had the ability to “auto-attach” itself to
    a [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    based on being passed table-attached columns:'
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 自版本0.8起，[`Constraint`](../core/constraints.html#sqlalchemy.schema.Constraint
    "sqlalchemy.schema.Constraint")至少具有根据传递的与表附加的列“自动附加”到[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")的能力：
- en: '[PRE179]'
  id: totrans-717
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: 'In order to assist with some cases that tend to come up with declarative, this
    same auto-attachment logic can now function even if the [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects are not yet associated with the [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table"); additional events are established such that when those
    [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    objects are associated, the [`Constraint`](../core/constraints.html#sqlalchemy.schema.Constraint
    "sqlalchemy.schema.Constraint") is also added:'
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: '为了帮助一些在声明时经常出现的情况，即使[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")对象尚未与[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")关联，此自动附加逻辑现在也可以起作用；建立了额外的事件，以便当这些[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")对象关联时，也会添加[`Constraint`](../core/constraints.html#sqlalchemy.schema.Constraint
    "sqlalchemy.schema.Constraint"):'
- en: '[PRE180]'
  id: totrans-719
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: 'The above feature was a late add as of version 1.0.0b3\. A fix as of version
    1.0.4 for [#3411](https://www.sqlalchemy.org/trac/ticket/3411) ensures that this
    logic does not occur if the [`Constraint`](../core/constraints.html#sqlalchemy.schema.Constraint
    "sqlalchemy.schema.Constraint") refers to a mixture of [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects and string column names; as we do not yet
    have tracking for the addition of names to a [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table"):'
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 以上功能是版本1.0.0b3之后的晚期添加的。从版本1.0.4开始修复了[#3411](https://www.sqlalchemy.org/trac/ticket/3411)，以确保如果[`Constraint`](../core/constraints.html#sqlalchemy.schema.Constraint
    "sqlalchemy.schema.Constraint")引用混合了[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")对象和字符串列名，则不会发生此逻辑；因为我们尚未跟踪将名称添加到[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")的情况：
- en: '[PRE181]'
  id: totrans-721
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: Above, the attachment event for column “a” to table “t” will fire off before
    column “b” is attached (as “a” is stated in the [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") constructor before “b”), and the constraint will fail
    to locate “b” if it were to attempt an attachment. For consistency, if the constraint
    refers to any string names, the autoattach-on-column-attach logic is skipped.
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面，对于列“a”到表“t”的附加事件将在列“b”被附加之前触发（因为“a”在[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")构造函数中在“b”之前声明），如果尝试进行附加，则约束将无法定位“b”。为了保持一致，如果约束涉及任何字符串名称，则会跳过自动在列附加时附加的逻辑。
- en: 'The original auto-attach logic of course remains in place, if the [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") already contains all the target [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects at the time the [`Constraint`](../core/constraints.html#sqlalchemy.schema.Constraint
    "sqlalchemy.schema.Constraint") is constructed:'
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 当 [`Constraint`](../core/constraints.html#sqlalchemy.schema.Constraint "sqlalchemy.schema.Constraint")
    构造时，如果 [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    已经包含所有目标 [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    对象，则原始的自动附加逻辑仍然存在：
- en: '[PRE182]'
  id: totrans-724
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: '[#3341](https://www.sqlalchemy.org/trac/ticket/3341) [#3411](https://www.sqlalchemy.org/trac/ticket/3411)  ###
    INSERT FROM SELECT now includes Python and SQL-expression defaults'
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3341](https://www.sqlalchemy.org/trac/ticket/3341) [#3411](https://www.sqlalchemy.org/trac/ticket/3411)  ###
    INSERT FROM SELECT 现在包括 Python 和 SQL 表达式默认值'
- en: '[`Insert.from_select()`](../core/dml.html#sqlalchemy.sql.expression.Insert.from_select
    "sqlalchemy.sql.expression.Insert.from_select") now includes Python and SQL-expression
    defaults if otherwise unspecified; the limitation where non-server column defaults
    aren’t included in an INSERT FROM SELECT is now lifted and these expressions are
    rendered as constants into the SELECT statement:'
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未另行指定，[`Insert.from_select()`](../core/dml.html#sqlalchemy.sql.expression.Insert.from_select
    "sqlalchemy.sql.expression.Insert.from_select") 现在包括 Python 和 SQL 表达式默认值；解除了非服务器列默认值不包括在
    INSERT FROM SELECT 中的限制，这些表达式被渲染为常量插入到 SELECT 语句中：
- en: '[PRE183]'
  id: totrans-727
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: 'Will render:'
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: 将呈现：
- en: '[PRE184]'
  id: totrans-729
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: 'The feature can be disabled using [`Insert.from_select.include_defaults`](../core/dml.html#sqlalchemy.sql.expression.Insert.from_select.params.include_defaults
    "sqlalchemy.sql.expression.Insert.from_select").  ### Column server defaults now
    render literal values'
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: '可以使用 [`Insert.from_select.include_defaults`](../core/dml.html#sqlalchemy.sql.expression.Insert.from_select.params.include_defaults
    "sqlalchemy.sql.expression.Insert.from_select") 来禁用此功能。  ### Column 服务器默认值现在呈现为字面值'
- en: 'The “literal binds” compiler flag is switched on when a [`DefaultClause`](../core/defaults.html#sqlalchemy.schema.DefaultClause
    "sqlalchemy.schema.DefaultClause"), set up by [`Column.server_default`](../core/metadata.html#sqlalchemy.schema.Column.params.server_default
    "sqlalchemy.schema.Column") is present as a SQL expression to be compiled. This
    allows literals embedded in SQL to render correctly, such as:'
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: 当由 [`Column.server_default`](../core/metadata.html#sqlalchemy.schema.Column.params.server_default
    "sqlalchemy.schema.Column") 设置的 [`DefaultClause`](../core/defaults.html#sqlalchemy.schema.DefaultClause
    "sqlalchemy.schema.DefaultClause") 存在作为要编译的 SQL 表达式时，“literal binds” 编译器标志会被打开。这允许嵌入在
    SQL 中的字面值正确渲染，例如：
- en: '[PRE185]'
  id: totrans-732
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: 'Now renders:'
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: 现在呈现为：
- en: '[PRE186]'
  id: totrans-734
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: Previously, the literal values `"foo", "bar", "baz"` would render as bound parameters,
    which are useless in DDL.
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，字面值 `"foo", "bar", "baz"` 会被渲染为绑定参数，在 DDL 中毫无用处。
- en: '[#3087](https://www.sqlalchemy.org/trac/ticket/3087)  ### UniqueConstraint
    is now part of the Table reflection process'
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3087](https://www.sqlalchemy.org/trac/ticket/3087)  ### UniqueConstraint
    现在是表反射过程的一部分'
- en: 'A [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    object populated using `autoload=True` will now include [`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint") constructs as well as [`Index`](../core/constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index") constructs. This logic has a few caveats for PostgreSQL
    and MySQL:'
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `autoload=True` 填充的 [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") 对象现在也会包括 [`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint") 构造以及 [`Index`](../core/constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index") 构造。这个逻辑在 PostgreSQL 和 MySQL 中有一些注意事项：
- en: PostgreSQL
  id: totrans-738
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: PostgreSQL
- en: PostgreSQL has the behavior such that when a UNIQUE constraint is created, it
    implicitly creates a UNIQUE INDEX corresponding to that constraint as well. The
    [`Inspector.get_indexes()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_indexes
    "sqlalchemy.engine.reflection.Inspector.get_indexes") and the [`Inspector.get_unique_constraints()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_unique_constraints
    "sqlalchemy.engine.reflection.Inspector.get_unique_constraints") methods will
    continue to **both** return these entries distinctly, where [`Inspector.get_indexes()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_indexes
    "sqlalchemy.engine.reflection.Inspector.get_indexes") now features a token `duplicates_constraint`
    within the index entry indicating the corresponding constraint when detected.
    However, when performing full table reflection using `Table(..., autoload=True)`,
    the [`Index`](../core/constraints.html#sqlalchemy.schema.Index "sqlalchemy.schema.Index")
    construct is detected as being linked to the [`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint"), and is **not** present within the [`Table.indexes`](../core/metadata.html#sqlalchemy.schema.Table.indexes
    "sqlalchemy.schema.Table.indexes") collection; only the [`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint") will be present in the [`Table.constraints`](../core/metadata.html#sqlalchemy.schema.Table.constraints
    "sqlalchemy.schema.Table.constraints") collection. This deduplication logic works
    by joining to the `pg_constraint` table when querying `pg_index` to see if the
    two constructs are linked.
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: PostgreSQL在创建唯一约束时会隐式创建对应的唯一索引。[`Inspector.get_indexes()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_indexes
    "sqlalchemy.engine.reflection.Inspector.get_indexes")和[`Inspector.get_unique_constraints()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_unique_constraints
    "sqlalchemy.engine.reflection.Inspector.get_unique_constraints")方法将继续**分别**返回这些条目，其中[`Inspector.get_indexes()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_indexes
    "sqlalchemy.engine.reflection.Inspector.get_indexes")现在在索引条目中包含一个`duplicates_constraint`标记，指示检测到的相应约束。然而，在使用`Table(...,
    autoload=True)`进行完整表反射时，检测到[`Index`](../core/constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index")构造与[`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint")相关联，并且**不**会出现在[`Table.indexes`](../core/metadata.html#sqlalchemy.schema.Table.indexes
    "sqlalchemy.schema.Table.indexes")集合中；只有[`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint")会出现在[`Table.constraints`](../core/metadata.html#sqlalchemy.schema.Table.constraints
    "sqlalchemy.schema.Table.constraints")集合中。这种去重逻辑通过在查询`pg_index`时连接到`pg_constraint`表来查看这两个构造是否相关联。
- en: MySQL
  id: totrans-740
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: MySQL
- en: MySQL does not have separate concepts for a UNIQUE INDEX and a UNIQUE constraint.
    While it supports both syntaxes when creating tables and indexes, it does not
    store them any differently. The [`Inspector.get_indexes()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_indexes
    "sqlalchemy.engine.reflection.Inspector.get_indexes") and the [`Inspector.get_unique_constraints()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_unique_constraints
    "sqlalchemy.engine.reflection.Inspector.get_unique_constraints") methods will
    continue to **both** return an entry for a UNIQUE index in MySQL, where [`Inspector.get_unique_constraints()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_unique_constraints
    "sqlalchemy.engine.reflection.Inspector.get_unique_constraints") features a new
    token `duplicates_index` within the constraint entry indicating that this is a
    dupe entry corresponding to that index. However, when performing full table reflection
    using `Table(..., autoload=True)`, the [`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint") construct is **not** part of the fully reflected
    [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    construct under any circumstances; this construct is always represented by a [`Index`](../core/constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index") with the `unique=True` setting present in the [`Table.indexes`](../core/metadata.html#sqlalchemy.schema.Table.indexes
    "sqlalchemy.schema.Table.indexes") collection.
  id: totrans-741
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL没有唯一索引和唯一约束的单独概念。虽然它在创建表和索引时都支持两种语法，但在存储时没有任何区别。[`Inspector.get_indexes()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_indexes
    "sqlalchemy.engine.reflection.Inspector.get_indexes")和[`Inspector.get_unique_constraints()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_unique_constraints
    "sqlalchemy.engine.reflection.Inspector.get_unique_constraints")方法将**同时**返回MySQL中唯一索引的条目，其中[`Inspector.get_unique_constraints()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_unique_constraints
    "sqlalchemy.engine.reflection.Inspector.get_unique_constraints")在约束条目中包含一个新的标记
    `duplicates_index`，表示这是与该索引对应的重复条目。但是，在使用`Table(..., autoload=True)`执行完整表反射时，[`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint")构造**不**会在任何情况下成为完全反射的[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")构造的一部分；该构造始终由[`Index`](../core/constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index")表示，并且在[`Table.indexes`](../core/metadata.html#sqlalchemy.schema.Table.indexes
    "sqlalchemy.schema.Table.indexes")集合中存在`unique=True`设置。
- en: See also
  id: totrans-742
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[PostgreSQL Index Reflection](../dialects/postgresql.html#postgresql-index-reflection)'
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: '[PostgreSQL 索引反射](../dialects/postgresql.html#postgresql-index-reflection)'
- en: '[MySQL / MariaDB Unique Constraints and Reflection](../dialects/mysql.html#mysql-unique-constraints)'
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: '[MySQL / MariaDB 唯一约束和反射](../dialects/mysql.html#mysql-unique-constraints)'
- en: '[#3184](https://www.sqlalchemy.org/trac/ticket/3184)'
  id: totrans-745
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3184](https://www.sqlalchemy.org/trac/ticket/3184)'
- en: New systems to safely emit parameterized warnings
  id: totrans-746
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 新的系统以安全方式发出参数化警告
- en: For a long time, there has been a restriction that warning messages could not
    refer to data elements, such that a particular function might emit an infinite
    number of unique warnings. The key place this occurs is in the `Unicode type received
    non-unicode bind param value` warning. Placing the data value in this message
    would mean that the Python `__warningregistry__` for that module, or in some cases
    the Python-global `warnings.onceregistry`, would grow unbounded, as in most warning
    scenarios, one of these two collections is populated with every distinct warning
    message.
  id: totrans-747
  prefs: []
  type: TYPE_NORMAL
  zh: 长期以来，存在着一个限制，即警告消息不能引用数据元素，因此特定函数可能会发出无限数量的唯一警告。这种情况最常见的地方是在`Unicode类型接收到非Unicode绑定参数值`警告中。将数据值放入此消息中意味着该模块的Python
    `__warningregistry__`，或在某些情况下是Python 全局的 `warnings.onceregistry`，会无限增长，因为在大多数警告情况下，这两个集合中的一个会填充每个不同的警告消息。
- en: The change here is that by using a special `string` type that purposely changes
    how the string is hashed, we can control that a large number of parameterized
    messages are hashed only on a small set of possible hash values, such that a warning
    such as `Unicode type received non-unicode bind param value` can be tailored to
    be emitted only a specific number of times; beyond that, the Python warnings registry
    will begin recording them as duplicates.
  id: totrans-748
  prefs: []
  type: TYPE_NORMAL
  zh: 此处的更改是通过使用一个特殊的`string`类型，故意更改字符串的哈希方式，我们可以控制大量参数化消息仅在一小组可能的哈希值上进行哈希，使得像`Unicode类型接收到非Unicode绑定参数值`这样的警告可以被定制为仅发出特定次数；超出此次数，Python
    警告注册表将开始记录它们作为重复项。
- en: 'To illustrate, the following test script will show only ten warnings being
    emitted for ten of the parameter sets, out of a total of 1000:'
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 举例来说，以下测试脚本将仅对一千个参数集中的十个发出警告：
- en: '[PRE187]'
  id: totrans-750
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: 'The format of the warning here is:'
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的警告格式为：
- en: '[PRE188]'
  id: totrans-752
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: '[#3178](https://www.sqlalchemy.org/trac/ticket/3178)'
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3178](https://www.sqlalchemy.org/trac/ticket/3178)'
- en: '### Select/Query LIMIT / OFFSET may be specified as an arbitrary SQL expression'
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: '### Select/Query LIMIT / OFFSET 可以指定为任意 SQL 表达式'
- en: 'The [`Select.limit()`](../core/selectable.html#sqlalchemy.sql.expression.Select.limit
    "sqlalchemy.sql.expression.Select.limit") and [`Select.offset()`](../core/selectable.html#sqlalchemy.sql.expression.Select.offset
    "sqlalchemy.sql.expression.Select.offset") methods now accept any SQL expression,
    in addition to integer values, as arguments. The ORM [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") object also passes through any expression to the underlying
    [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select "sqlalchemy.sql.expression.Select")
    object. Typically this is used to allow a bound parameter to be passed, which
    can be substituted with a value later:'
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Select.limit()`](../core/selectable.html#sqlalchemy.sql.expression.Select.limit
    "sqlalchemy.sql.expression.Select.limit") 和 [`Select.offset()`](../core/selectable.html#sqlalchemy.sql.expression.Select.offset
    "sqlalchemy.sql.expression.Select.offset") 方法现在接受任何 SQL 表达式作为参数，而不仅仅是整数值。ORM [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") 对象也会将任何表达式传递给底层的 [`Select`](../core/selectable.html#sqlalchemy.sql.expression.Select
    "sqlalchemy.sql.expression.Select") 对象。通常用于允许传递绑定参数，稍后可以用值替换：'
- en: '[PRE189]'
  id: totrans-756
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: Dialects which don’t support non-integer LIMIT or OFFSET expressions may continue
    to not support this behavior; third party dialects may also need modification
    in order to take advantage of the new behavior. A dialect which currently uses
    the `._limit` or `._offset` attributes will continue to function for those cases
    where the limit/offset was specified as a simple integer value. However, when
    a SQL expression is specified, these two attributes will instead raise a [`CompileError`](../core/exceptions.html#sqlalchemy.exc.CompileError
    "sqlalchemy.exc.CompileError") on access. A third-party dialect which wishes to
    support the new feature should now call upon the `._limit_clause` and `._offset_clause`
    attributes to receive the full SQL expression, rather than the integer value.
  id: totrans-757
  prefs: []
  type: TYPE_NORMAL
  zh: 不支持非整数 LIMIT 或 OFFSET 表达式的方言可能继续不支持此行为；第三方方言可能还需要修改以利用新行为。当前使用 `._limit` 或 `._offset`
    属性的方言将继续对指定为简单整数值的限制/偏移量的情况进行处理。但是，当指定 SQL 表达式时，这两个属性将在访问时引发 [`CompileError`](../core/exceptions.html#sqlalchemy.exc.CompileError
    "sqlalchemy.exc.CompileError")。希望支持新功能的第三方方言现在应调用 `._limit_clause` 和 `._offset_clause`
    属性以接收完整的 SQL 表达式，而不是整数值。
- en: '### The `use_alter` flag on `ForeignKeyConstraint` is (usually) no longer needed'
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: '### `ForeignKeyConstraint` 上的 `use_alter` 标志（通常）不再需要'
- en: The [`MetaData.create_all()`](../core/metadata.html#sqlalchemy.schema.MetaData.create_all
    "sqlalchemy.schema.MetaData.create_all") and [`MetaData.drop_all()`](../core/metadata.html#sqlalchemy.schema.MetaData.drop_all
    "sqlalchemy.schema.MetaData.drop_all") methods will now make use of a system that
    automatically renders an ALTER statement for foreign key constraints that are
    involved in mutually-dependent cycles between tables, without the need to specify
    [`ForeignKeyConstraint.use_alter`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint.params.use_alter
    "sqlalchemy.schema.ForeignKeyConstraint"). Additionally, the foreign key constraints
    no longer need to have a name in order to be created via ALTER; only the DROP
    operation requires a name. In the case of a DROP, the feature will ensure that
    only constraints which have explicit names are actually included as ALTER statements.
    In the case of an unresolvable cycle within a DROP, the system emits a succinct
    and clear error message now if the DROP cannot proceed.
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: '[`MetaData.create_all()`](../core/metadata.html#sqlalchemy.schema.MetaData.create_all
    "sqlalchemy.schema.MetaData.create_all") 和 [`MetaData.drop_all()`](../core/metadata.html#sqlalchemy.schema.MetaData.drop_all
    "sqlalchemy.schema.MetaData.drop_all") 方法现在将使用一个系统，自动为涉及表之间相互依赖循环的外键约束渲染 ALTER
    语句，无需指定 [`ForeignKeyConstraint.use_alter`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint.params.use_alter
    "sqlalchemy.schema.ForeignKeyConstraint")。此外，外键约束现在不再需要名称即可通过 ALTER 创建；仅在 DROP
    操作时需要名称。在 DROP 的情况下，该功能将确保只有具有显式名称的约束实际上包含在 ALTER 语句中。在 DROP 中存在无法解决的循环的情况下，如果无法继续进行
    DROP，系统现在会发出简洁明了的错误消息。'
- en: The [`ForeignKeyConstraint.use_alter`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint.params.use_alter
    "sqlalchemy.schema.ForeignKeyConstraint") and [`ForeignKey.use_alter`](../core/constraints.html#sqlalchemy.schema.ForeignKey.params.use_alter
    "sqlalchemy.schema.ForeignKey") flags remain in place, and continue to have the
    same effect of establishing those constraints for which ALTER is required during
    a CREATE/DROP scenario.
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: '[`ForeignKeyConstraint.use_alter`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint.params.use_alter
    "sqlalchemy.schema.ForeignKeyConstraint") 和 [`ForeignKey.use_alter`](../core/constraints.html#sqlalchemy.schema.ForeignKey.params.use_alter
    "sqlalchemy.schema.ForeignKey") 标志保持不变，并且继续具有相同的效果，即在 CREATE/DROP 情景中需要 ALTER
    来建立这些约束条件。'
- en: As of version 1.0.1, special logic takes over in the case of SQLite, which does
    not support ALTER, in the case that during a DROP, the given tables have an unresolvable
    cycle; in this case a warning is emitted, and the tables are dropped with **no**
    ordering, which is usually fine on SQLite unless constraints are enabled. To resolve
    the warning and proceed with at least a partial ordering on a SQLite database,
    particularly one where constraints are enabled, re-apply “use_alter” flags to
    those [`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey "sqlalchemy.schema.ForeignKey")
    and [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") objects which should be explicitly omitted
    from the sort.
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: 自版本 1.0.1 起，在 SQLite 的情况下，特殊逻辑会接管，SQLite 不支持 ALTER，在 DROP 过程中，如果给定的表存在无法解析的循环，则会发出警告，并且这些表将无序删除，这在
    SQLite 上通常没问题，除非启用了约束条件。要解决警告并在 SQLite 数据库上至少实现部分排序，特别是在启用约束条件的数据库中，重新将 “use_alter”
    标志应用于那些应该在排序中显式省略的 [`ForeignKey`](../core/constraints.html#sqlalchemy.schema.ForeignKey
    "sqlalchemy.schema.ForeignKey") 和 [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") 对象。
- en: See also
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 另见
- en: '[Creating/Dropping Foreign Key Constraints via ALTER](../core/constraints.html#use-alter)
    - full description of the new behavior.'
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: '[通过 ALTER 创建/删除外键约束](../core/constraints.html#use-alter) - 新行为的完整描述。'
- en: '[#3282](https://www.sqlalchemy.org/trac/ticket/3282)'
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3282](https://www.sqlalchemy.org/trac/ticket/3282)'
- en: '### ResultProxy “auto close” is now a “soft” close'
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: '### ResultProxy “auto close” 现在是 “soft” close'
- en: 'For many releases, the `ResultProxy` object has always been automatically closed
    out at the point at which all result rows have been fetched. This was to allow
    usage of the object without the need to call upon `ResultProxy.close()` explicitly;
    as all DBAPI resources had been freed, the object was safe to discard. However,
    the object maintained a strict “closed” behavior, which meant that any subsequent
    calls to `ResultProxy.fetchone()`, `ResultProxy.fetchmany()` or `ResultProxy.fetchall()`
    would now raise a [`ResourceClosedError`](../core/exceptions.html#sqlalchemy.exc.ResourceClosedError
    "sqlalchemy.exc.ResourceClosedError"):'
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: 在很多版本中，`ResultProxy` 对象一直会在获取所有结果行后自动关闭。这是为了允许在不需要显式调用 `ResultProxy.close()`
    的情况下使用该对象；由于所有的 DBAPI 资源都已被释放，因此可以安全地丢弃该对象。然而，该对象仍保持严格的“closed”行为，这意味着任何后续对 `ResultProxy.fetchone()`、`ResultProxy.fetchmany()`
    或 `ResultProxy.fetchall()` 的调用都会引发 [`ResourceClosedError`](../core/exceptions.html#sqlalchemy.exc.ResourceClosedError
    "sqlalchemy.exc.ResourceClosedError")：
- en: '[PRE190]'
  id: totrans-767
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: This behavior is inconsistent vs. what pep-249 states, which is that you can
    call upon the fetch methods repeatedly even after results are exhausted. It also
    interferes with behavior for some implementations of result proxy, such as the
    `BufferedColumnResultProxy` used by the cx_oracle dialect for certain datatypes.
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: 此行为与 pep-249 的规定不一致，pep-249 规定即使结果已经耗尽，仍然可以重复调用 fetch 方法。这也会影响到某些结果代理的实现行为，比如
    cx_oracle 方言中某些数据类型使用的 `BufferedColumnResultProxy`。
- en: 'To solve this, the “closed” state of the `ResultProxy` has been broken into
    two states; a “soft close” which does the majority of what “close” does, in that
    it releases the DBAPI cursor and in the case of a “close with result” object will
    also release the connection, and a “closed” state which is everything included
    by “soft close” as well as establishing the fetch methods as “closed”. The `ResultProxy.close()`
    method is now never called implicitly, only the `ResultProxy._soft_close()` method
    which is non-public:'
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，“ResultProxy”的“closed”状态已被分为两个状态；“软关闭”执行了“关闭”的大部分操作，即释放了 DBAPI 游标，并且在
    “close with result” 对象的情况下还会释放连接，并且“closed”状态包括了“soft close”中的所有内容，同时还将 fetch
    方法设为“closed”。现在永远不会隐式调用 `ResultProxy.close()` 方法，只会调用非公开的 `ResultProxy._soft_close()`
    方法：
- en: '[PRE191]'
  id: totrans-770
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: '[#3330](https://www.sqlalchemy.org/trac/ticket/3330) [#3329](https://www.sqlalchemy.org/trac/ticket/3329)'
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3330](https://www.sqlalchemy.org/trac/ticket/3330) [#3329](https://www.sqlalchemy.org/trac/ticket/3329)'
- en: CHECK Constraints now support the `%(column_0_name)s` token in naming conventions
  id: totrans-772
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CHECK Constraints现在支持命名约定中的`%(column_0_name)s`标记
- en: 'The `%(column_0_name)s` will derive from the first column found in the expression
    of a [`CheckConstraint`](../core/constraints.html#sqlalchemy.schema.CheckConstraint
    "sqlalchemy.schema.CheckConstraint"):'
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: '`%(column_0_name)s`将从[`CheckConstraint`](../core/constraints.html#sqlalchemy.schema.CheckConstraint
    "sqlalchemy.schema.CheckConstraint")的表达式中找到的第一列派生：'
- en: '[PRE192]'
  id: totrans-774
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: 'Will render:'
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: 将呈现为：
- en: '[PRE193]'
  id: totrans-776
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: The combination of naming conventions with the constraint produced by a [`SchemaType`](../core/type_basics.html#sqlalchemy.types.SchemaType
    "sqlalchemy.types.SchemaType") such as [`Boolean`](../core/type_basics.html#sqlalchemy.types.Boolean
    "sqlalchemy.types.Boolean") or [`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum") will also now make use of all CHECK constraint conventions.
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 命名约定与由[`SchemaType`](../core/type_basics.html#sqlalchemy.types.SchemaType "sqlalchemy.types.SchemaType")（如[`Boolean`](../core/type_basics.html#sqlalchemy.types.Boolean
    "sqlalchemy.types.Boolean")或[`Enum`](../core/type_basics.html#sqlalchemy.types.Enum
    "sqlalchemy.types.Enum")）产生的约束的组合现在也将使用所有CHECK约束约定。
- en: See also
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: 另见
- en: '[Naming CHECK Constraints](../core/constraints.html#naming-check-constraints)'
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: '[命名CHECK约束](../core/constraints.html#naming-check-constraints)'
- en: '[Configuring Naming for Boolean, Enum, and other schema types](../core/constraints.html#naming-schematypes)'
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: '[为布尔值、枚举和其他模式类型配置命名](../core/constraints.html#naming-schematypes)'
- en: '[#3299](https://www.sqlalchemy.org/trac/ticket/3299)'
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3299](https://www.sqlalchemy.org/trac/ticket/3299)'
- en: '### Constraints referring to unattached Columns can auto-attach to the Table
    when their referred columns are attached'
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: '### 当其引用的列附加时，引用未附加的列的约束可以自动附加到表上'
- en: 'Since at least version 0.8, a [`Constraint`](../core/constraints.html#sqlalchemy.schema.Constraint
    "sqlalchemy.schema.Constraint") has had the ability to “auto-attach” itself to
    a [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    based on being passed table-attached columns:'
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: 至少从版本0.8开始，[`Constraint`](../core/constraints.html#sqlalchemy.schema.Constraint
    "sqlalchemy.schema.Constraint")已经能够根据传递的表附加列自动“附加”到[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")上：
- en: '[PRE194]'
  id: totrans-784
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: 'In order to assist with some cases that tend to come up with declarative, this
    same auto-attachment logic can now function even if the [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects are not yet associated with the [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table"); additional events are established such that when those
    [`Column`](../core/metadata.html#sqlalchemy.schema.Column "sqlalchemy.schema.Column")
    objects are associated, the [`Constraint`](../core/constraints.html#sqlalchemy.schema.Constraint
    "sqlalchemy.schema.Constraint") is also added:'
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助处理一些在声明时经常出现的情况，即使[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")对象尚未与[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")关联，此相同的自动附加逻辑现在也可以起作用；额外的事件被建立，以便当这些[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")对象关联时，也添加了[`Constraint`](../core/constraints.html#sqlalchemy.schema.Constraint
    "sqlalchemy.schema.Constraint")：
- en: '[PRE195]'
  id: totrans-786
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: 'The above feature was a late add as of version 1.0.0b3\. A fix as of version
    1.0.4 for [#3411](https://www.sqlalchemy.org/trac/ticket/3411) ensures that this
    logic does not occur if the [`Constraint`](../core/constraints.html#sqlalchemy.schema.Constraint
    "sqlalchemy.schema.Constraint") refers to a mixture of [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects and string column names; as we do not yet
    have tracking for the addition of names to a [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table"):'
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: 上述功能是截至版本1.0.0b3的最后添加的。从版本1.0.4开始对[#3411](https://www.sqlalchemy.org/trac/ticket/3411)的修复确保如果[`Constraint`](../core/constraints.html#sqlalchemy.schema.Constraint
    "sqlalchemy.schema.Constraint")引用了[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")对象和字符串列名称的混合；因为我们尚未跟踪将名称添加到[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")中：
- en: '[PRE196]'
  id: totrans-788
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: Above, the attachment event for column “a” to table “t” will fire off before
    column “b” is attached (as “a” is stated in the [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") constructor before “b”), and the constraint will fail
    to locate “b” if it were to attempt an attachment. For consistency, if the constraint
    refers to any string names, the autoattach-on-column-attach logic is skipped.
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的示例中，将列“a”附加到表“t”的附加事件将在附加列“b”之前触发（因为“a”在构造[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")时在“b”之前声明），如果约束尝试附加时无法找到“b”，约束将失败。为了保持一致性，如果约束引用任何字符串名称，则跳过在列附加时自动附加的逻辑。
- en: 'The original auto-attach logic of course remains in place, if the [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") already contains all the target [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects at the time the [`Constraint`](../core/constraints.html#sqlalchemy.schema.Constraint
    "sqlalchemy.schema.Constraint") is constructed:'
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: 当[`Constraint`](../core/constraints.html#sqlalchemy.schema.Constraint "sqlalchemy.schema.Constraint")构造时，如果[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")已经包含所有目标[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")对象，则原始的自动附加逻辑当然仍然存在：
- en: '[PRE197]'
  id: totrans-791
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: '[#3341](https://www.sqlalchemy.org/trac/ticket/3341) [#3411](https://www.sqlalchemy.org/trac/ticket/3411)'
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3341](https://www.sqlalchemy.org/trac/ticket/3341) [#3411](https://www.sqlalchemy.org/trac/ticket/3411)'
- en: '### INSERT FROM SELECT now includes Python and SQL-expression defaults'
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: '### INSERT FROM SELECT 现在包括 Python 和 SQL 表达式默认值'
- en: '[`Insert.from_select()`](../core/dml.html#sqlalchemy.sql.expression.Insert.from_select
    "sqlalchemy.sql.expression.Insert.from_select") now includes Python and SQL-expression
    defaults if otherwise unspecified; the limitation where non-server column defaults
    aren’t included in an INSERT FROM SELECT is now lifted and these expressions are
    rendered as constants into the SELECT statement:'
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未另行指定，则[`Insert.from_select()`](../core/dml.html#sqlalchemy.sql.expression.Insert.from_select
    "sqlalchemy.sql.expression.Insert.from_select")现在将包括 Python 和 SQL 表达式默认值；现在解除了非服务器列默认值不包括在
    INSERT FROM SELECT 中的限制，并将这些表达式作为常量呈现到 SELECT 语句中：
- en: '[PRE198]'
  id: totrans-795
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: 'Will render:'
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: 将呈现：
- en: '[PRE199]'
  id: totrans-797
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: The feature can be disabled using [`Insert.from_select.include_defaults`](../core/dml.html#sqlalchemy.sql.expression.Insert.from_select.params.include_defaults
    "sqlalchemy.sql.expression.Insert.from_select").
  id: totrans-798
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用[`Insert.from_select.include_defaults`](../core/dml.html#sqlalchemy.sql.expression.Insert.from_select.params.include_defaults
    "sqlalchemy.sql.expression.Insert.from_select")来禁用此功能。
- en: '### Column server defaults now render literal values'
  id: totrans-799
  prefs: []
  type: TYPE_NORMAL
  zh: '### Column 服务器默认值现在呈现为字面值'
- en: 'The “literal binds” compiler flag is switched on when a [`DefaultClause`](../core/defaults.html#sqlalchemy.schema.DefaultClause
    "sqlalchemy.schema.DefaultClause"), set up by [`Column.server_default`](../core/metadata.html#sqlalchemy.schema.Column.params.server_default
    "sqlalchemy.schema.Column") is present as a SQL expression to be compiled. This
    allows literals embedded in SQL to render correctly, such as:'
  id: totrans-800
  prefs: []
  type: TYPE_NORMAL
  zh: 当由[`Column.server_default`](../core/metadata.html#sqlalchemy.schema.Column.params.server_default
    "sqlalchemy.schema.Column")设置的[`DefaultClause`](../core/defaults.html#sqlalchemy.schema.DefaultClause
    "sqlalchemy.schema.DefaultClause")作为要编译的 SQL 表达式存在时，“字面绑定”编译器标志将被打开。这允许嵌入在 SQL
    中的字面值正确呈现，例如：
- en: '[PRE200]'
  id: totrans-801
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: 'Now renders:'
  id: totrans-802
  prefs: []
  type: TYPE_NORMAL
  zh: 现在呈现：
- en: '[PRE201]'
  id: totrans-803
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: Previously, the literal values `"foo", "bar", "baz"` would render as bound parameters,
    which are useless in DDL.
  id: totrans-804
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，字面值`"foo", "bar", "baz"`会呈现为绑定参数，在 DDL 中毫无用处。
- en: '[#3087](https://www.sqlalchemy.org/trac/ticket/3087)'
  id: totrans-805
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3087](https://www.sqlalchemy.org/trac/ticket/3087)'
- en: '### UniqueConstraint is now part of the Table reflection process'
  id: totrans-806
  prefs: []
  type: TYPE_NORMAL
  zh: '### UniqueConstraint 现在是 Table 反射过程的一部分'
- en: 'A [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    object populated using `autoload=True` will now include [`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint") constructs as well as [`Index`](../core/constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index") constructs. This logic has a few caveats for PostgreSQL
    and MySQL:'
  id: totrans-807
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`autoload=True`填充的[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")对象现在将包括[`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint")构造以及[`Index`](../core/constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index")构造。对于 PostgreSQL 和 MySQL，这种逻辑有一些注意事项：
- en: PostgreSQL
  id: totrans-808
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: PostgreSQL
- en: PostgreSQL has the behavior such that when a UNIQUE constraint is created, it
    implicitly creates a UNIQUE INDEX corresponding to that constraint as well. The
    [`Inspector.get_indexes()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_indexes
    "sqlalchemy.engine.reflection.Inspector.get_indexes") and the [`Inspector.get_unique_constraints()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_unique_constraints
    "sqlalchemy.engine.reflection.Inspector.get_unique_constraints") methods will
    continue to **both** return these entries distinctly, where [`Inspector.get_indexes()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_indexes
    "sqlalchemy.engine.reflection.Inspector.get_indexes") now features a token `duplicates_constraint`
    within the index entry indicating the corresponding constraint when detected.
    However, when performing full table reflection using `Table(..., autoload=True)`,
    the [`Index`](../core/constraints.html#sqlalchemy.schema.Index "sqlalchemy.schema.Index")
    construct is detected as being linked to the [`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint"), and is **not** present within the [`Table.indexes`](../core/metadata.html#sqlalchemy.schema.Table.indexes
    "sqlalchemy.schema.Table.indexes") collection; only the [`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint") will be present in the [`Table.constraints`](../core/metadata.html#sqlalchemy.schema.Table.constraints
    "sqlalchemy.schema.Table.constraints") collection. This deduplication logic works
    by joining to the `pg_constraint` table when querying `pg_index` to see if the
    two constructs are linked.
  id: totrans-809
  prefs: []
  type: TYPE_NORMAL
  zh: PostgreSQL 的行为是，当创建一个唯一约束时，它会隐式地创建一个对应该约束的唯一索引。[`Inspector.get_indexes()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_indexes
    "sqlalchemy.engine.reflection.Inspector.get_indexes") 和 [`Inspector.get_unique_constraints()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_unique_constraints
    "sqlalchemy.engine.reflection.Inspector.get_unique_constraints") 方法将继续**分别**返回这些条目，其中
    [`Inspector.get_indexes()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_indexes
    "sqlalchemy.engine.reflection.Inspector.get_indexes") 现在在索引条目中包含一个 `duplicates_constraint`
    标记，指示检测到的相应约束。然而，在使用 `Table(..., autoload=True)` 进行完整表反射时，检测到 [`Index`](../core/constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index") 构造与 [`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint") 相关联，并且**不**出现在 [`Table.indexes`](../core/metadata.html#sqlalchemy.schema.Table.indexes
    "sqlalchemy.schema.Table.indexes") 集合中；只有 [`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint") 将出现在 [`Table.constraints`](../core/metadata.html#sqlalchemy.schema.Table.constraints
    "sqlalchemy.schema.Table.constraints") 集合中。这种去重逻辑通过在查询 `pg_index` 时连接到 `pg_constraint`
    表来查看这两个构造是否关联。
- en: MySQL
  id: totrans-810
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: MySQL
- en: MySQL does not have separate concepts for a UNIQUE INDEX and a UNIQUE constraint.
    While it supports both syntaxes when creating tables and indexes, it does not
    store them any differently. The [`Inspector.get_indexes()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_indexes
    "sqlalchemy.engine.reflection.Inspector.get_indexes") and the [`Inspector.get_unique_constraints()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_unique_constraints
    "sqlalchemy.engine.reflection.Inspector.get_unique_constraints") methods will
    continue to **both** return an entry for a UNIQUE index in MySQL, where [`Inspector.get_unique_constraints()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_unique_constraints
    "sqlalchemy.engine.reflection.Inspector.get_unique_constraints") features a new
    token `duplicates_index` within the constraint entry indicating that this is a
    dupe entry corresponding to that index. However, when performing full table reflection
    using `Table(..., autoload=True)`, the [`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint") construct is **not** part of the fully reflected
    [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    construct under any circumstances; this construct is always represented by a [`Index`](../core/constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index") with the `unique=True` setting present in the [`Table.indexes`](../core/metadata.html#sqlalchemy.schema.Table.indexes
    "sqlalchemy.schema.Table.indexes") collection.
  id: totrans-811
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL没有单独的概念来区分唯一索引和唯一约束。虽然在创建表和索引时都支持两种语法，但在存储时并没有任何区别。[`Inspector.get_indexes()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_indexes
    "sqlalchemy.engine.reflection.Inspector.get_indexes")和[`Inspector.get_unique_constraints()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_unique_constraints
    "sqlalchemy.engine.reflection.Inspector.get_unique_constraints")方法将继续**同时**返回MySQL中唯一索引的条目，其中[`Inspector.get_unique_constraints()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_unique_constraints
    "sqlalchemy.engine.reflection.Inspector.get_unique_constraints")在约束条目中使用新标记`duplicates_index`指示这是对应于该索引的重复条目。然而，在使用`Table(...,
    autoload=True)`执行完整表反射时，[`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint")构造在任何情况下都**不**是完全反映的[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")构造的一部分；这个构造始终由在[`Table.indexes`](../core/metadata.html#sqlalchemy.schema.Table.indexes
    "sqlalchemy.schema.Table.indexes")集合中存在`unique=True`设置的[`Index`](../core/constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index")表示。
- en: See also
  id: totrans-812
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[PostgreSQL Index Reflection](../dialects/postgresql.html#postgresql-index-reflection)'
  id: totrans-813
  prefs: []
  type: TYPE_NORMAL
  zh: '[PostgreSQL 索引反射](../dialects/postgresql.html#postgresql-index-reflection)'
- en: '[MySQL / MariaDB Unique Constraints and Reflection](../dialects/mysql.html#mysql-unique-constraints)'
  id: totrans-814
  prefs: []
  type: TYPE_NORMAL
  zh: '[MySQL / MariaDB 唯一约束和反射](../dialects/mysql.html#mysql-unique-constraints)'
- en: '[#3184](https://www.sqlalchemy.org/trac/ticket/3184)'
  id: totrans-815
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3184](https://www.sqlalchemy.org/trac/ticket/3184)'
- en: PostgreSQL
  id: totrans-816
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: PostgreSQL
- en: PostgreSQL has the behavior such that when a UNIQUE constraint is created, it
    implicitly creates a UNIQUE INDEX corresponding to that constraint as well. The
    [`Inspector.get_indexes()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_indexes
    "sqlalchemy.engine.reflection.Inspector.get_indexes") and the [`Inspector.get_unique_constraints()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_unique_constraints
    "sqlalchemy.engine.reflection.Inspector.get_unique_constraints") methods will
    continue to **both** return these entries distinctly, where [`Inspector.get_indexes()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_indexes
    "sqlalchemy.engine.reflection.Inspector.get_indexes") now features a token `duplicates_constraint`
    within the index entry indicating the corresponding constraint when detected.
    However, when performing full table reflection using `Table(..., autoload=True)`,
    the [`Index`](../core/constraints.html#sqlalchemy.schema.Index "sqlalchemy.schema.Index")
    construct is detected as being linked to the [`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint"), and is **not** present within the [`Table.indexes`](../core/metadata.html#sqlalchemy.schema.Table.indexes
    "sqlalchemy.schema.Table.indexes") collection; only the [`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint") will be present in the [`Table.constraints`](../core/metadata.html#sqlalchemy.schema.Table.constraints
    "sqlalchemy.schema.Table.constraints") collection. This deduplication logic works
    by joining to the `pg_constraint` table when querying `pg_index` to see if the
    two constructs are linked.
  id: totrans-817
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建唯一约束时，PostgreSQL 的行为是隐式创建与该约束对应的唯一索引。[`Inspector.get_indexes()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_indexes
    "sqlalchemy.engine.reflection.Inspector.get_indexes") 和 [`Inspector.get_unique_constraints()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_unique_constraints
    "sqlalchemy.engine.reflection.Inspector.get_unique_constraints") 方法将继续**分别**返回这些条目，其中
    [`Inspector.get_indexes()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_indexes
    "sqlalchemy.engine.reflection.Inspector.get_indexes") 现在在索引条目中特征化了一个 `duplicates_constraint`
    标记，表示当检测到相应约束时。然而，在使用 `Table(..., autoload=True)` 进行完整表反射时，[`Index`](../core/constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index") 结构被检测为与 [`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint") 相关联，并且**不**会出现在 [`Table.indexes`](../core/metadata.html#sqlalchemy.schema.Table.indexes
    "sqlalchemy.schema.Table.indexes") 集合中；只有 [`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint") 会出现在 [`Table.constraints`](../core/metadata.html#sqlalchemy.schema.Table.constraints
    "sqlalchemy.schema.Table.constraints") 集合中。这个去重逻辑通过在查询 `pg_index` 时连接到 `pg_constraint`
    表来查看这两个结构是否相关联。
- en: MySQL
  id: totrans-818
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: MySQL
- en: MySQL does not have separate concepts for a UNIQUE INDEX and a UNIQUE constraint.
    While it supports both syntaxes when creating tables and indexes, it does not
    store them any differently. The [`Inspector.get_indexes()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_indexes
    "sqlalchemy.engine.reflection.Inspector.get_indexes") and the [`Inspector.get_unique_constraints()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_unique_constraints
    "sqlalchemy.engine.reflection.Inspector.get_unique_constraints") methods will
    continue to **both** return an entry for a UNIQUE index in MySQL, where [`Inspector.get_unique_constraints()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_unique_constraints
    "sqlalchemy.engine.reflection.Inspector.get_unique_constraints") features a new
    token `duplicates_index` within the constraint entry indicating that this is a
    dupe entry corresponding to that index. However, when performing full table reflection
    using `Table(..., autoload=True)`, the [`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint") construct is **not** part of the fully reflected
    [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    construct under any circumstances; this construct is always represented by a [`Index`](../core/constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index") with the `unique=True` setting present in the [`Table.indexes`](../core/metadata.html#sqlalchemy.schema.Table.indexes
    "sqlalchemy.schema.Table.indexes") collection.
  id: totrans-819
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL没有单独的概念来区分**唯一索引**和**唯一约束**。虽然在创建表和索引时支持两种语法，但在存储时并没有任何区别。[`Inspector.get_indexes()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_indexes
    "sqlalchemy.engine.reflection.Inspector.get_indexes")和[`Inspector.get_unique_constraints()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_unique_constraints
    "sqlalchemy.engine.reflection.Inspector.get_unique_constraints")方法将继续**同时**返回MySQL中唯一索引的条目，其中[`Inspector.get_unique_constraints()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_unique_constraints
    "sqlalchemy.engine.reflection.Inspector.get_unique_constraints")在约束条目中具有一个新的标记`duplicates_index`，表示这是对应该索引的重复条目。然而，在使用`Table(...,
    autoload=True)`执行完整表反射时，[`UniqueConstraint`](../core/constraints.html#sqlalchemy.schema.UniqueConstraint
    "sqlalchemy.schema.UniqueConstraint")构造在任何情况下都**不**是完全反映的[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")构造的一部分；这个构造始终由在[`Table.indexes`](../core/metadata.html#sqlalchemy.schema.Table.indexes
    "sqlalchemy.schema.Table.indexes")集合中存在`unique=True`设置的[`Index`](../core/constraints.html#sqlalchemy.schema.Index
    "sqlalchemy.schema.Index")表示。
- en: See also
  id: totrans-820
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[PostgreSQL Index Reflection](../dialects/postgresql.html#postgresql-index-reflection)'
  id: totrans-821
  prefs: []
  type: TYPE_NORMAL
  zh: '[PostgreSQL索引反射](../dialects/postgresql.html#postgresql-index-reflection)'
- en: '[MySQL / MariaDB Unique Constraints and Reflection](../dialects/mysql.html#mysql-unique-constraints)'
  id: totrans-822
  prefs: []
  type: TYPE_NORMAL
  zh: '[MySQL / MariaDB唯一约束和反射](../dialects/mysql.html#mysql-unique-constraints)'
- en: '[#3184](https://www.sqlalchemy.org/trac/ticket/3184)'
  id: totrans-823
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3184](https://www.sqlalchemy.org/trac/ticket/3184)'
- en: New systems to safely emit parameterized warnings
  id: totrans-824
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安全发出参数化警告的新系统
- en: For a long time, there has been a restriction that warning messages could not
    refer to data elements, such that a particular function might emit an infinite
    number of unique warnings. The key place this occurs is in the `Unicode type received
    non-unicode bind param value` warning. Placing the data value in this message
    would mean that the Python `__warningregistry__` for that module, or in some cases
    the Python-global `warnings.onceregistry`, would grow unbounded, as in most warning
    scenarios, one of these two collections is populated with every distinct warning
    message.
  id: totrans-825
  prefs: []
  type: TYPE_NORMAL
  zh: 长期以来，存在一个限制，即警告消息不能引用数据元素，这样一个特定函数可能会发出无限数量的唯一警告。这种情况最常见的地方是在`Unicode type received
    non-unicode bind param value`警告中。将数据值放入此消息中意味着该模块的Python `__warningregistry__`，或在某些情况下是Python全局的`warnings.onceregistry`，将无限增长，因为在大多数警告场景中，这两个集合中的一个会填充每个不同的警告消息。
- en: The change here is that by using a special `string` type that purposely changes
    how the string is hashed, we can control that a large number of parameterized
    messages are hashed only on a small set of possible hash values, such that a warning
    such as `Unicode type received non-unicode bind param value` can be tailored to
    be emitted only a specific number of times; beyond that, the Python warnings registry
    will begin recording them as duplicates.
  id: totrans-826
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的变化是通过使用一种特殊的`string`类型，故意改变字符串的哈希方式，我们可以控制大量参数化消息仅在一小组可能的哈希值上进行哈希，这样一个警告，比如`Unicode
    type received non-unicode bind param value`，可以被定制为仅发出特定次数；在那之后，Python警告注册表将开始记录它们作为重复项。
- en: 'To illustrate, the following test script will show only ten warnings being
    emitted for ten of the parameter sets, out of a total of 1000:'
  id: totrans-827
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明，以下测试脚本将仅显示对于1000个参数集中的十个参数集发出的十个警告：
- en: '[PRE202]'
  id: totrans-828
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: 'The format of the warning here is:'
  id: totrans-829
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的警告格式是：
- en: '[PRE203]'
  id: totrans-830
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: '[#3178](https://www.sqlalchemy.org/trac/ticket/3178)'
  id: totrans-831
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3178](https://www.sqlalchemy.org/trac/ticket/3178)'
- en: Key Behavioral Changes - ORM
  id: totrans-832
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关键行为变化 - ORM
- en: '### query.update() now resolves string names into mapped attribute names'
  id: totrans-833
  prefs: []
  type: TYPE_NORMAL
  zh: '### query.update()现在将字符串名称解析为映射属性名称'
- en: The documentation for [`Query.update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.update
    "sqlalchemy.orm.Query.update") states that the given `values` dictionary is “a
    dictionary with attributes names as keys”, implying that these are mapped attribute
    names. Unfortunately, the function was designed more in mind to receive attributes
    and SQL expressions and not as much strings; when strings were passed, these strings
    would be passed through straight to the core update statement without any resolution
    as far as how these names are represented on the mapped class, meaning the name
    would have to match that of a table column exactly, not how an attribute of that
    name was mapped onto the class.
  id: totrans-834
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Query.update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.update
    "sqlalchemy.orm.Query.update")的文档说明给定的`values`字典是“以属性名称为键的字典”，这意味着这些是映射的属性名称。不幸的是，该函数更多地是设计为接收属性和SQL表达式，而不是字符串；当传递字符串时，这些字符串将直接传递到核心更新语句，而不解析这些名称在映射类上的表示方式，这意味着名称必须与表列的名称完全匹配，而不是该名称被映射到类的属性上的方式。'
- en: 'The string names are now resolved as attribute names in earnest:'
  id: totrans-835
  prefs: []
  type: TYPE_NORMAL
  zh: 现在字符串名称会认真解析为属性名称：
- en: '[PRE204]'
  id: totrans-836
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: 'Above, the column `user_name` is mapped as `name`. Previously, a call to [`Query.update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.update
    "sqlalchemy.orm.Query.update") that was passed strings would have to have been
    called as follows:'
  id: totrans-837
  prefs: []
  type: TYPE_NORMAL
  zh: 上面，列`user_name`被映射为`name`。以前，传递字符串的[`Query.update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.update
    "sqlalchemy.orm.Query.update")调用必须如下调用：
- en: '[PRE205]'
  id: totrans-838
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: 'The given string is now resolved against the entity:'
  id: totrans-839
  prefs: []
  type: TYPE_NORMAL
  zh: 现在给定的字符串将根据实体解析：
- en: '[PRE206]'
  id: totrans-840
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: 'It is typically preferable to use the attribute directly, to avoid any ambiguity:'
  id: totrans-841
  prefs: []
  type: TYPE_NORMAL
  zh: 通常最好直接使用属性，以避免任何歧义：
- en: '[PRE207]'
  id: totrans-842
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: 'The change also indicates that synonyms and hybrid attributes can be referred
    to by string name as well:'
  id: totrans-843
  prefs: []
  type: TYPE_NORMAL
  zh: 此更改还表明，同义词和混合属性也可以通过字符串名称引用：
- en: '[PRE208]'
  id: totrans-844
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: '[#3228](https://www.sqlalchemy.org/trac/ticket/3228)  ### Warnings emitted
    when comparing objects with None values to relationships'
  id: totrans-845
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3228](https://www.sqlalchemy.org/trac/ticket/3228)  ### 当将对象与None值比较时发出警告'
- en: 'This change is new as of 1.0.1\. Some users are performing queries that are
    essentially of this form:'
  id: totrans-846
  prefs: []
  type: TYPE_NORMAL
  zh: 这个更改是从1.0.1版本开始的。一些用户正在执行基本上是这种形式的查询：
- en: '[PRE209]'
  id: totrans-847
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: 'This pattern is not currently supported in SQLAlchemy. For all versions, it
    emits SQL resembling:'
  id: totrans-848
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy当前不支持这种模式。对于所有版本，它生成类似于以下的SQL：
- en: '[PRE210]'
  id: totrans-849
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: 'Note above, there is a comparison `WHERE ? = address.user_id` where the bound
    value `?` is receiving `None`, or `NULL` in SQL. **This will always return False
    in SQL**. The comparison here would in theory generate SQL as follows:'
  id: totrans-850
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意上面，有一个比较`WHERE ? = address.user_id`，其中绑定值`?`接收`None`，或者在SQL中是`NULL`。**这在SQL中总是返回False**。这里的比较理论上会生成以下SQL：
- en: '[PRE211]'
  id: totrans-851
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: 'But right now, **it does not**. Applications which are relying upon the fact
    that “NULL = NULL” produces False in all cases run the risk that someday, SQLAlchemy
    might fix this issue to generate “IS NULL”, and the queries will then produce
    different results. Therefore with this kind of operation, you will see a warning:'
  id: totrans-852
  prefs: []
  type: TYPE_NORMAL
  zh: 但是现在**并不是这样**。依赖于“NULL = NULL”在所有情况下产生False的应用程序存在风险，因为有一天，SQLAlchemy可能会修复这个问题以生成“IS
    NULL”，然后查询将产生不同的结果。因此，在这种操作中，你会看到一个警告：
- en: '[PRE212]'
  id: totrans-853
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: Note that this pattern was broken in most cases for release 1.0.0 including
    all of the betas; a value like `SYMBOL('NEVER_SET')` would be generated. This
    issue has been fixed, but as a result of identifying this pattern, the warning
    is now there so that we can more safely repair this broken behavior (now captured
    in [#3373](https://www.sqlalchemy.org/trac/ticket/3373)) in a future release.
  id: totrans-854
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这种模式在1.0.0版本中的大多数情况下都被破坏，包括所有的beta版本；像`SYMBOL('NEVER_SET')`这样的值将被生成。这个问题已经修复，但由于识别到这种模式，现在有了警告，以便我们可以更安全地修复这个破损的行为（现在在[#3373](https://www.sqlalchemy.org/trac/ticket/3373)中捕获）在未来的版本中。
- en: '[#3371](https://www.sqlalchemy.org/trac/ticket/3371)  ### A “negated contains
    or equals” relationship comparison will use the current value of attributes, not
    the database value'
  id: totrans-855
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3371](https://www.sqlalchemy.org/trac/ticket/3371)  ### “否定包含或等于”关系比较将使用属性的当前值，而不是数据库值'
- en: This change is new as of 1.0.1; while we would have preferred for this to be
    in 1.0.0, it only became apparent as a result of [#3371](https://www.sqlalchemy.org/trac/ticket/3371).
  id: totrans-856
  prefs: []
  type: TYPE_NORMAL
  zh: 此更改是 1.0.1 的新功能；虽然我们希望这个功能在 1.0.0 中就存在，但这只是作为 [#3371](https://www.sqlalchemy.org/trac/ticket/3371)
    的结果才变得明显。
- en: 'Given a mapping:'
  id: totrans-857
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个映射：
- en: '[PRE213]'
  id: totrans-858
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: 'Given `A`, with primary key of 7, but which we changed to be 10 without flushing:'
  id: totrans-859
  prefs: []
  type: TYPE_NORMAL
  zh: 给定 `A`，其主键为 7，但我们在不刷新的情况下将其更改为 10：
- en: '[PRE214]'
  id: totrans-860
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: 'A query against a many-to-one relationship with this object as the target will
    use the value 10 in the bound parameters:'
  id: totrans-861
  prefs: []
  type: TYPE_NORMAL
  zh: 针对此对象作为目标的多对一关系的查询将使用绑定参数中的值 10：
- en: '[PRE215]'
  id: totrans-862
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: 'Produces:'
  id: totrans-863
  prefs: []
  type: TYPE_NORMAL
  zh: 生成：
- en: '[PRE216]'
  id: totrans-864
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: 'However, before this change, the negation of this criteria would **not** use
    10, it would use 7, unless the object were flushed first:'
  id: totrans-865
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在此更改之前，这个条件的否定**不会**使用 10，而是使用 7，除非先刷新对象：
- en: '[PRE217]'
  id: totrans-866
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: 'Produces (in 0.9 and all versions prior to 1.0.1):'
  id: totrans-867
  prefs: []
  type: TYPE_NORMAL
  zh: 生成（在 0.9 版本和所有 1.0.1 版本之前的版本中）：
- en: '[PRE218]'
  id: totrans-868
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: 'For a transient object, it would produce a broken query:'
  id: totrans-869
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个临时对象，它会产生一个错误的查询：
- en: '[PRE219]'
  id: totrans-870
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: This inconsistency has been repaired, and in all queries the current attribute
    value, in this example `10`, will now be used.
  id: totrans-871
  prefs: []
  type: TYPE_NORMAL
  zh: 此不一致性已经修复，在所有查询中，当前属性值，例如此示例中的 `10`，现在将被使用。
- en: '[#3374](https://www.sqlalchemy.org/trac/ticket/3374)  ### Changes to attribute
    events and other operations regarding attributes that have no pre-existing value'
  id: totrans-872
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3374](https://www.sqlalchemy.org/trac/ticket/3374)  ### 关于没有预先存在值的属性的属性事件和其他操作的更改'
- en: In this change, the default return value of `None` when accessing an object
    is now returned dynamically on each access, rather than implicitly setting the
    attribute’s state with a special “set” operation when it is first accessed. The
    visible result of this change is that `obj.__dict__` is not implicitly modified
    on get, and there are also some minor behavioral changes for [`get_history()`](../orm/session_api.html#sqlalchemy.orm.attributes.get_history
    "sqlalchemy.orm.attributes.get_history") and related functions.
  id: totrans-873
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个更改中，当访问对象时，`None`的默认返回值现在会在每次访问时动态返回，而不是在首次访问时通过特殊的“设置”操作隐式地设置属性的状态。这个更改的可见结果是，`obj.__dict__`在获取时不会被隐式修改，并且对于
    [`get_history()`](../orm/session_api.html#sqlalchemy.orm.attributes.get_history
    "sqlalchemy.orm.attributes.get_history") 和相关函数也有一些轻微的行为变化。
- en: 'Given an object with no state:'
  id: totrans-874
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个没有状态的对象：
- en: '[PRE220]'
  id: totrans-875
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: 'It has always been SQLAlchemy’s behavior such that if we access a scalar or
    many-to-one attribute that was never set, it is returned as `None`:'
  id: totrans-876
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 的行为一直是这样的，如果我们访问一个从未设置过的标量或多对一属性，它会返回 `None`：
- en: '[PRE221]'
  id: totrans-877
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: 'This value of `None` is in fact now part of the state of `obj`, and is not
    unlike as though we had set the attribute explicitly, e.g. `obj.someattr = None`.
    However, the “set on get” here would behave differently as far as history and
    events. It would not emit any attribute event, and additionally if we view history,
    we see this:'
  id: totrans-878
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`None`值实际上现在是`obj`状态的一部分，并且与我们明确设置属性的情况类似，例如 `obj.someattr = None`。然而，这里的“获取时设置”在历史和事件方面会有不同的行为。它不会触发任何属性事件，此外，如果我们查看历史记录，我们会看到这样的情况：
- en: '[PRE222]'
  id: totrans-879
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: 'That is, it’s as though the attribute were always `None` and were never changed.
    This is explicitly different from if we had set the attribute first instead:'
  id: totrans-880
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，就好像属性始终是`None`，且从未更改过一样。这与我们首先设置属性的情况明显不同：
- en: '[PRE223]'
  id: totrans-881
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: The above means that the behavior of our “set” operation can be corrupted by
    the fact that the value was accessed via “get” earlier. In 1.0, this inconsistency
    has been resolved, by no longer actually setting anything when the default “getter”
    is used.
  id: totrans-882
  prefs: []
  type: TYPE_NORMAL
  zh: 上述意味着我们的“设置”操作的行为可能会被通过“获取”访问值的事实所破坏。在 1.0 中，这个不一致性已经得到了解决，不再在首次访问时实际设置任何东西。
- en: '[PRE224]'
  id: totrans-883
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: The reason the above behavior hasn’t had much impact is because the INSERT statement
    in relational databases considers a missing value to be the same as NULL in most
    cases. Whether SQLAlchemy received a history event for a particular attribute
    set to None or not would usually not matter; as the difference between sending
    None/NULL or not wouldn’t have an impact. However, as [#3060](https://www.sqlalchemy.org/trac/ticket/3060)
    (described here in [Priority of attribute changes on relationship-bound attributes
    vs. FK-bound may appear to change](#migration-3060)) illustrates, there are some
    seldom edge cases where we do in fact want to positively have `None` set. Also,
    allowing the attribute event here means it’s now possible to create “default value”
    functions for ORM mapped attributes.
  id: totrans-884
  prefs: []
  type: TYPE_NORMAL
  zh: 以上行为之所以没有产生太大影响，是因为在关系数据库中的INSERT语句在大多数情况下将缺失的值视为NULL。对于SQLAlchemy是否接收到了将特定属性设置为None的历史事件，通常并不重要；因为发送None/NULL或者不发送之间的区别通常不会产生影响。然而，正如[#3060](https://www.sqlalchemy.org/trac/ticket/3060)（在[属性变更的优先级：与关系绑定的属性相比，外键绑定的属性可能会出现变化](#migration-3060)中描述的那样）所示，有一些罕见的边缘情况，我们确实希望明确将`None`设置为属性。此外，允许在此处发生属性事件意味着现在可以为ORM映射的属性创建“默认值”函数。
- en: As part of this change, the generation of the implicit “None” is now disabled
    for other situations where this used to occur; this includes when an attribute
    set operation on a many-to-one is received; previously, the “old” value would
    be “None” if it had been not set otherwise; it now will send the value `NEVER_SET`,
    which is a value that may be sent to an attribute listener now. This symbol may
    also be received when calling on mapper utility functions such as [`Mapper.primary_key_from_instance()`](../orm/mapping_api.html#sqlalchemy.orm.Mapper.primary_key_from_instance
    "sqlalchemy.orm.Mapper.primary_key_from_instance"); if the primary key attributes
    have no setting at all, whereas the value would be `None` before, it will now
    be the `NEVER_SET` symbol, and no change to the object’s state occurs.
  id: totrans-885
  prefs: []
  type: TYPE_NORMAL
  zh: 作为这一变更的一部分，现在已禁用了在其他情况下生成隐式“None”的功能；这包括在收到对many-to-one进行属性设置操作时；以前，如果“旧”值没有被设置，那么“旧”值将是“None”；现在它将发送值`NEVER_SET`，这是一个现在可以发送到属性监听器的值。在调用诸如[`Mapper.primary_key_from_instance()`](../orm/mapping_api.html#sqlalchemy.orm.Mapper.primary_key_from_instance
    "sqlalchemy.orm.Mapper.primary_key_from_instance")之类的映射器实用程序函数时，也可能接收到此符号；如果主键属性根本没有设置，而以前值是`None`，那么现在将是`NEVER_SET`符号，并且对象的状态不会发生任何更改。
- en: '[#3061](https://www.sqlalchemy.org/trac/ticket/3061)  ### Priority of attribute
    changes on relationship-bound attributes vs. FK-bound may appear to change'
  id: totrans-886
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3061](https://www.sqlalchemy.org/trac/ticket/3061)  ### 属性变更的优先级：与关系绑定的属性相比，外键绑定的属性可能会出现变化'
- en: 'As a side effect of [#3060](https://www.sqlalchemy.org/trac/ticket/3060), setting
    a relationship-bound attribute to `None` is now a tracked history event which
    refers to the intention of persisting `None` to that attribute. As it has always
    been the case that setting a relationship-bound attribute will trump direct assignment
    to the foreign key attributes, a change in behavior can be seen here when assigning
    None. Given a mapping:'
  id: totrans-887
  prefs: []
  type: TYPE_NORMAL
  zh: 作为[#3060](https://www.sqlalchemy.org/trac/ticket/3060)的副作用，将关系绑定的属性设置为`None`现在是一个被追踪的历史事件，它指的是将`None`持久化到该属性的意图。由于一直以来，设置关系绑定的属性将优先于直接分配给外键属性，因此在分配None时可以看到行为的变化。给定一个映射：
- en: '[PRE225]'
  id: totrans-888
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: 'In 1.0, the relationship-bound attribute takes precedence over the FK-bound
    attribute in all cases, whether or not the value we assign is a reference to an
    `A` object or is `None`. In 0.9, the behavior is inconsistent and only takes effect
    if a value is assigned; the None is not considered:'
  id: totrans-889
  prefs: []
  type: TYPE_NORMAL
  zh: 在1.0中，无论我们分配的值是指向`A`对象的引用还是`None`，关系绑定的属性都优先于FK绑定的属性。在0.9中，行为是不一致的，只有在分配了值时才生效；None不被考虑：
- en: '[PRE226]'
  id: totrans-890
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: '[#3060](https://www.sqlalchemy.org/trac/ticket/3060)  ### session.expunge()
    will fully detach an object that’s been deleted'
  id: totrans-891
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3060](https://www.sqlalchemy.org/trac/ticket/3060)  ### session.expunge()
    将完全分离已被删除的对象'
- en: 'The behavior of [`Session.expunge()`](../orm/session_api.html#sqlalchemy.orm.Session.expunge
    "sqlalchemy.orm.Session.expunge") had a bug that caused an inconsistency in behavior
    regarding deleted objects. The [`object_session()`](../orm/session_api.html#sqlalchemy.orm.object_session
    "sqlalchemy.orm.object_session") function as well as the [`InstanceState.session`](../orm/internals.html#sqlalchemy.orm.InstanceState.session
    "sqlalchemy.orm.InstanceState.session") attribute would still report object as
    belonging to the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    subsequent to the expunge:'
  id: totrans-892
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session.expunge()`](../orm/session_api.html#sqlalchemy.orm.Session.expunge
    "sqlalchemy.orm.Session.expunge") 的行为存在一个错误，导致已删除对象的行为不一致。[`object_session()`](../orm/session_api.html#sqlalchemy.orm.object_session
    "sqlalchemy.orm.object_session") 函数以及 [`InstanceState.session`](../orm/internals.html#sqlalchemy.orm.InstanceState.session
    "sqlalchemy.orm.InstanceState.session") 属性会在 expunge 之后仍然报告对象属于 [`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")：'
- en: '[PRE227]'
  id: totrans-893
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: Note that it is normal for `u1 not in sess` to be True while `inspect(u1).session`
    still refers to the session, while the transaction is ongoing subsequent to the
    delete operation and [`Session.expunge()`](../orm/session_api.html#sqlalchemy.orm.Session.expunge
    "sqlalchemy.orm.Session.expunge") has not been called; the full detachment normally
    completes once the transaction is committed. This issue would also impact functions
    that rely on [`Session.expunge()`](../orm/session_api.html#sqlalchemy.orm.Session.expunge
    "sqlalchemy.orm.Session.expunge") such as [`make_transient()`](../orm/session_api.html#sqlalchemy.orm.make_transient
    "sqlalchemy.orm.make_transient").
  id: totrans-894
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`u1 not in sess` 为 True 而 `inspect(u1).session` 仍然指向会话，当事务正在进行删除操作之后，但尚未调用
    [`Session.expunge()`](../orm/session_api.html#sqlalchemy.orm.Session.expunge "sqlalchemy.orm.Session.expunge")
    时，完全分离通常会在事务提交后完成。这个问题也会影响到依赖于 [`Session.expunge()`](../orm/session_api.html#sqlalchemy.orm.Session.expunge
    "sqlalchemy.orm.Session.expunge") 的函数，比如 [`make_transient()`](../orm/session_api.html#sqlalchemy.orm.make_transient
    "sqlalchemy.orm.make_transient")。
- en: '[#3139](https://www.sqlalchemy.org/trac/ticket/3139)  ### Joined/Subquery eager
    loading explicitly disallowed with yield_per'
  id: totrans-895
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3139](https://www.sqlalchemy.org/trac/ticket/3139)  ### 使用 yield_per 明确禁止连接/子查询即时加载'
- en: 'In order to make the [`Query.yield_per()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.yield_per
    "sqlalchemy.orm.Query.yield_per") method easier to use, an exception is raised
    if any subquery eager loaders, or joined eager loaders that would use collections,
    are to take effect when yield_per is used, as these are currently not compatible
    with yield-per (subquery loading could be in theory, however). When this error
    is raised, the [`lazyload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.lazyload
    "sqlalchemy.orm.lazyload") option can be sent with an asterisk:'
  id: totrans-896
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使 [`Query.yield_per()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.yield_per
    "sqlalchemy.orm.Query.yield_per") 方法更容易使用，在使用 yield_per 时如果任何子查询即时加载器或将使用集合的连接即时加载器生效，则会引发异常，因为这些当前与
    yield_per 不兼容（理论上子查询加载可以，然而）。当引发此错误时，可以使用带有星号的 [`lazyload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.lazyload
    "sqlalchemy.orm.lazyload") 选项：
- en: '[PRE228]'
  id: totrans-897
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: 'or use [`Query.enable_eagerloads()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.enable_eagerloads
    "sqlalchemy.orm.Query.enable_eagerloads"):'
  id: totrans-898
  prefs: []
  type: TYPE_NORMAL
  zh: 或者使用 [`Query.enable_eagerloads()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.enable_eagerloads
    "sqlalchemy.orm.Query.enable_eagerloads")：
- en: '[PRE229]'
  id: totrans-899
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: 'The [`lazyload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.lazyload
    "sqlalchemy.orm.lazyload") option has the advantage that additional many-to-one
    joined loader options can still be used:'
  id: totrans-900
  prefs: []
  type: TYPE_NORMAL
  zh: '[`lazyload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.lazyload
    "sqlalchemy.orm.lazyload") 选项的优点是仍然可以使用额外的多对一连接加载器选项：'
- en: '[PRE230]  ### Changes and fixes in handling of duplicate join targets'
  id: totrans-901
  prefs: []
  type: TYPE_NORMAL
  zh: '[PRE230]  ### 对重复连接目标的处理中的更改和修复'
- en: Changes here encompass bugs where an unexpected and inconsistent behavior would
    occur in some scenarios when joining to an entity twice, or to multiple single-table
    entities against the same table, without using a relationship-based ON clause,
    as well as when joining multiple times to the same target relationship.
  id: totrans-902
  prefs: []
  type: TYPE_NORMAL
  zh: 对于在两次连接到同一实体或多次连接到同一张表的单表实体而不使用基于关系的 ON 子句时，某些情况下可能会出现意外和不一致行为的错误进行了更改，以及当多次连接到同一目标关系时。
- en: 'Starting with a mapping as:'
  id: totrans-903
  prefs: []
  type: TYPE_NORMAL
  zh: 从一个映射开始：
- en: '[PRE231]'
  id: totrans-904
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: 'A query that joins to `A.bs` twice:'
  id: totrans-905
  prefs: []
  type: TYPE_NORMAL
  zh: 一个连接到 `A.bs` 两次的查询：
- en: '[PRE232]'
  id: totrans-906
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: 'Will render:'
  id: totrans-907
  prefs: []
  type: TYPE_NORMAL
  zh: 将会渲染：
- en: '[PRE233]'
  id: totrans-908
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: 'The query deduplicates the redundant `A.bs` because it is attempting to support
    a case like the following:'
  id: totrans-909
  prefs: []
  type: TYPE_NORMAL
  zh: 查询对冗余的 `A.bs` 进行了去重，因为它试图支持以下情况：
- en: '[PRE234]'
  id: totrans-910
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: 'That is, the `A.bs` is part of a “path”. As part of [#3367](https://www.sqlalchemy.org/trac/ticket/3367),
    arriving at the same endpoint twice without it being part of a larger path will
    now emit a warning:'
  id: totrans-911
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，`A.bs` 是“路径”的一部分。作为 [#3367](https://www.sqlalchemy.org/trac/ticket/3367)
    的一部分，如果到达相同的终点两次而不是作为更大路径的一部分，现在会发出警告：
- en: '[PRE235]'
  id: totrans-912
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: 'The bigger change involves when joining to an entity without using a relationship-bound
    path. If we join to `B` twice:'
  id: totrans-913
  prefs: []
  type: TYPE_NORMAL
  zh: 更大的变化涉及加入到一个实体而不使用关系绑定路径。如果我们两次加入到 `B`：
- en: '[PRE236]'
  id: totrans-914
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: 'In 0.9, this would render as follows:'
  id: totrans-915
  prefs: []
  type: TYPE_NORMAL
  zh: 在 0.9 版本中，这将呈现如下：
- en: '[PRE237]'
  id: totrans-916
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: This is problematic since the aliasing is implicit and in the case of different
    ON clauses can lead to unpredictable results.
  id: totrans-917
  prefs: []
  type: TYPE_NORMAL
  zh: 这是有问题的，因为别名是隐式的，在不同的 ON 子句的情况下可能导致不可预测的结果。
- en: 'In 1.0, no automatic aliasing is applied and we get:'
  id: totrans-918
  prefs: []
  type: TYPE_NORMAL
  zh: 在 1.0 版本中，不会应用自动别名，我们会得到：
- en: '[PRE238]'
  id: totrans-919
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: This will raise an error from the database. While it might be nice if the “duplicate
    join target” acted identically if we joined both from redundant relationships
    vs. redundant non-relationship based targets, for now we are only changing the
    behavior in the more serious case where implicit aliasing would have occurred
    previously, and only emitting a warning in the relationship case. Ultimately,
    joining to the same thing twice without any aliasing to disambiguate should raise
    an error in all cases.
  id: totrans-920
  prefs: []
  type: TYPE_NORMAL
  zh: 这将从数据库中引发错误。虽然如果“重复加入目标”在我们从冗余关系 vs. 冗余非关系目标中都加入时表现相同可能会很好，但目前我们只在以前会发生隐式别名的更严重情况下更改行为，并且在关系情况下只发出警告。最终，在所有情况下，加入到相同的东西两次而没有任何别名以消除歧义应该引发错误。
- en: 'The change also has an impact on single-table inheritance targets. Using a
    mapping as follows:'
  id: totrans-921
  prefs: []
  type: TYPE_NORMAL
  zh: 此更改还影响单表继承目标。使用以下映射：
- en: '[PRE239]'
  id: totrans-922
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: 'The two queries at the bottom are equivalent, and should both render the identical
    SQL:'
  id: totrans-923
  prefs: []
  type: TYPE_NORMAL
  zh: 底部的两个查询是等效的，应该都呈现相同的 SQL：
- en: '[PRE240]'
  id: totrans-924
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: 'The above SQL is invalid, as it renders “a” within the FROM list twice. However,
    the implicit aliasing bug would occur with the second query only and render this
    instead:'
  id: totrans-925
  prefs: []
  type: TYPE_NORMAL
  zh: 上述 SQL 是无效的，因为在 FROM 列表中两次呈现了“a”。然而，隐式别名 bug 只会在第二个查询中发生，并呈现如下：
- en: '[PRE241]'
  id: totrans-926
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: Where above, the second join to “a” is aliased. While this seems convenient,
    it’s not how single-inheritance queries work in general and is misleading and
    inconsistent.
  id: totrans-927
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面，对“a”的第二次加入被别名。虽然这看起来很方便，但这不是单继承查询的一般工作方式，而且是误导性和不一致的。
- en: 'The net effect is that applications which were relying on this bug will now
    have an error raised by the database. The solution is to use the expected form.
    When referring to multiple subclasses of a single-inheritance entity in a query,
    you must manually use aliases to disambiguate the table, as all the subclasses
    normally refer to the same table:'
  id: totrans-928
  prefs: []
  type: TYPE_NORMAL
  zh: 其净效果是依赖于此 bug 的应用程序现在将由数据库引发错误。解决方案是使用预期的形式。在查询中引用单继承实体的多个子类时，必须手动使用别名来消除表的歧义，因为所有子类通常指向同一张表：
- en: '[PRE242]'
  id: totrans-929
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: '[#3233](https://www.sqlalchemy.org/trac/ticket/3233) [#3367](https://www.sqlalchemy.org/trac/ticket/3367)'
  id: totrans-930
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3233](https://www.sqlalchemy.org/trac/ticket/3233) [#3367](https://www.sqlalchemy.org/trac/ticket/3367)'
- en: Deferred Columns No Longer Implicitly Undefer
  id: totrans-931
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 延迟列不再隐式取消延迟
- en: Mapped attributes marked as deferred without explicit undeferral will now remain
    “deferred” even if their column is otherwise present in the result set in some
    way. This is a performance enhancement in that an ORM load no longer spends time
    searching for each deferred column when the result set is obtained. However, for
    an application that has been relying upon this, an explicit [`undefer()`](../orm/queryguide/columns.html#sqlalchemy.orm.undefer
    "sqlalchemy.orm.undefer") or similar option should now be used, in order to prevent
    a SELECT from being emitted when the attribute is accessed.
  id: totrans-932
  prefs: []
  type: TYPE_NORMAL
  zh: 标记为延迟的映射属性如果没有明确取消延迟，现在即使它们的列以某种方式存在于结果集中，也将保持“延迟”。这是一个性能增强，因为 ORM 加载在获得结果集时不再花时间搜索每个延迟列。然而，对于一直依赖于此的应用程序，现在应该使用显式的
    [`undefer()`](../orm/queryguide/columns.html#sqlalchemy.orm.undefer "sqlalchemy.orm.undefer")
    或类似选项，以防止在访问属性时发出 SELECT。
- en: '### Deprecated ORM Event Hooks Removed'
  id: totrans-933
  prefs: []
  type: TYPE_NORMAL
  zh: '### 废弃的 ORM 事件钩子已移除'
- en: 'The following ORM event hooks, some of which have been deprecated since 0.5,
    have been removed: `translate_row`, `populate_instance`, `append_result`, `create_instance`.
    The use cases for these hooks originated in the very early 0.1 / 0.2 series of
    SQLAlchemy and have long since been unnecessary. In particular, the hooks were
    largely unusable as the behavioral contracts within these events was strongly
    linked to the surrounding internals, such as how an instance needs to be created
    and initialized as well as how columns are located within an ORM-generated row.
    The removal of these hooks greatly simplifies the mechanics of ORM object loading.  ###
    API Change for new Bundle feature when custom row loaders are used'
  id: totrans-934
  prefs: []
  type: TYPE_NORMAL
  zh: '自0.5以来已被弃用的以下ORM事件钩子已被删除：`translate_row`、`populate_instance`、`append_result`、`create_instance`。这些钩子的用例起源于早期的0.1
    / 0.2系列SQLAlchemy，并且早已不再需要。特别是，这些钩子在很大程度上无法使用，因为这些事件中的行为契约与周围内部的强烈联系，例如需要如何创建和初始化实例以及如何在ORM生成的行中定位列。删除这些钩子极大地简化了ORM对象加载的机制。  ###
    当使用自定义行加载器时，新 Bundle 功能的 API 变更'
- en: 'The new [`Bundle`](../orm/queryguide/api.html#sqlalchemy.orm.Bundle "sqlalchemy.orm.Bundle")
    object of 0.9 has a small change in API, when the `create_row_processor()` method
    is overridden on a custom class. Previously, the sample code looked like:'
  id: totrans-935
  prefs: []
  type: TYPE_NORMAL
  zh: 0.9 版本的新 [`Bundle`](../orm/queryguide/api.html#sqlalchemy.orm.Bundle "sqlalchemy.orm.Bundle")
    对象在 API 上有一个小变化，当在自定义类上覆盖 `create_row_processor()` 方法时。以前的示例代码如下：
- en: '[PRE243]'
  id: totrans-936
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: 'The unused `result` member is now removed:'
  id: totrans-937
  prefs: []
  type: TYPE_NORMAL
  zh: 未使用的 `result` 成员现已被删除：
- en: '[PRE244]'
  id: totrans-938
  prefs: []
  type: TYPE_PRE
  zh: '[PRE244]'
- en: See also
  id: totrans-939
  prefs: []
  type: TYPE_NORMAL
  zh: 另见
- en: '[Grouping Selected Attributes with Bundles](../orm/queryguide/select.html#bundles)  ###
    Right inner join nesting now the default for joinedload with innerjoin=True'
  id: totrans-940
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用 Bundles 对选定属性进行分组](../orm/queryguide/select.html#bundles)  ### 内连接右嵌套现在是
    `joinedload` 的默认设置，`innerjoin=True`'
- en: The behavior of [`joinedload.innerjoin`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload.params.innerjoin
    "sqlalchemy.orm.joinedload") as well as [`relationship.innerjoin`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.innerjoin
    "sqlalchemy.orm.relationship") is now to use “nested” inner joins, that is, right-nested,
    as the default behavior when an inner join joined eager load is chained to an
    outer join eager load. In order to get the old behavior of chaining all joined
    eager loads as outer join when an outer join is present, use `innerjoin="unnested"`.
  id: totrans-941
  prefs: []
  type: TYPE_NORMAL
  zh: 当内连接贪婪加载链接到外连接贪婪加载时，[`joinedload.innerjoin`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload.params.innerjoin
    "sqlalchemy.orm.joinedload") 的行为以及 [`relationship.innerjoin`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.innerjoin
    "sqlalchemy.orm.relationship") 现在默认使用“嵌套”内连接，即右嵌套。为了获得当外连接存在时将所有贪婪加载链接为外连接的旧行为，请使用
    `innerjoin="unnested"`。
- en: 'As introduced in [Right-nested inner joins available in joined eager loads](migration_09.html#feature-2976)
    from version 0.9, the behavior of `innerjoin="nested"` is that an inner join eager
    load chained to an outer join eager load will use a right-nested join. `"nested"`
    is now implied when using `innerjoin=True`:'
  id: totrans-942
  prefs: []
  type: TYPE_NORMAL
  zh: 正如从0.9版本开始介绍的 [内连接右嵌套可用于连接贪婪加载](migration_09.html#feature-2976)，`innerjoin="nested"`
    的行为是将内连接贪婪加载链到外连接贪婪加载时使用右嵌套连接。当使用 `innerjoin=True` 时，现在隐含了 `"nested"`：
- en: '[PRE245]'
  id: totrans-943
  prefs: []
  type: TYPE_PRE
  zh: '[PRE245]'
- en: 'With the new default, this will render the FROM clause in the form:'
  id: totrans-944
  prefs: []
  type: TYPE_NORMAL
  zh: 使用新的默认设置，FROM 子句将以以下形式呈现：
- en: '[PRE246]'
  id: totrans-945
  prefs: []
  type: TYPE_PRE
  zh: '[PRE246]'
- en: That is, using a right-nested join for the INNER join so that the full result
    of `users` can be returned. The use of an INNER join is more efficient than using
    an OUTER join, and allows the [`joinedload.innerjoin`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload.params.innerjoin
    "sqlalchemy.orm.joinedload") optimization parameter to take effect in all cases.
  id: totrans-946
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，使用右嵌套连接进行 INNER 连接，以便能够返回 `users` 的完整结果。使用 INNER 连接比使用 OUTER 连接更高效，并且允许在所有情况下使用
    [`joinedload.innerjoin`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload.params.innerjoin
    "sqlalchemy.orm.joinedload") 优化参数。
- en: 'To get the older behavior, use `innerjoin="unnested"`:'
  id: totrans-947
  prefs: []
  type: TYPE_NORMAL
  zh: 要获得旧的行为，请使用 `innerjoin="unnested"`：
- en: '[PRE247]'
  id: totrans-948
  prefs: []
  type: TYPE_PRE
  zh: '[PRE247]'
- en: 'This will avoid right-nested joins and chain the joins together using all OUTER
    joins despite the innerjoin directive:'
  id: totrans-949
  prefs: []
  type: TYPE_NORMAL
  zh: 这将避免右嵌套连接，并使用所有 OUTER 连接将连接链在一起，尽管有内连接指令：
- en: '[PRE248]'
  id: totrans-950
  prefs: []
  type: TYPE_PRE
  zh: '[PRE248]'
- en: As noted in the 0.9 notes, the only database backend that has difficulty with
    right-nested joins is SQLite; SQLAlchemy as of 0.9 converts a right-nested join
    into a subquery as a join target on SQLite.
  id: totrans-951
  prefs: []
  type: TYPE_NORMAL
  zh: 如0.9备注中所述，唯一在右嵌套连接方面有困难的数据库后端是SQLite；从0.9开始，SQLAlchemy会将右嵌套连接转换为子查询作为SQLite上的连接目标。
- en: See also
  id: totrans-952
  prefs: []
  type: TYPE_NORMAL
  zh: 另见
- en: '[Right-nested inner joins available in joined eager loads](migration_09.html#feature-2976)
    - description of the feature as introduced in 0.9.4.'
  id: totrans-953
  prefs: []
  type: TYPE_NORMAL
  zh: '[连接式加载中可用的右嵌套内连接](migration_09.html#feature-2976) - 介绍了0.9.4版本中引入的功能。'
- en: '[#3008](https://www.sqlalchemy.org/trac/ticket/3008)  ### Subqueries no longer
    applied to uselist=False joined eager loads'
  id: totrans-954
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3008](https://www.sqlalchemy.org/trac/ticket/3008)  ### 不再将子查询应用于uselist=False的连接式加载'
- en: 'Given a joined eager load like the following:'
  id: totrans-955
  prefs: []
  type: TYPE_NORMAL
  zh: 给定如下的连接式加载：
- en: '[PRE249]'
  id: totrans-956
  prefs: []
  type: TYPE_PRE
  zh: '[PRE249]'
- en: 'SQLAlchemy considers the relationship `A.b` to be a “one to many, loaded as
    a single value”, which is essentially a “one to one” relationship. However, joined
    eager loading has always treated the above as a situation where the main query
    needs to be inside a subquery, as would normally be needed for a collection of
    B objects where the main query has a LIMIT applied:'
  id: totrans-957
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy认为关系`A.b`是“一对多，加载为单个值”，本质上是“一对一”关系。然而，连接式加载一直将上述情况视为主查询需要在子查询中的情况，就像对主查询应用LIMIT时通常需要的那样：
- en: '[PRE250]'
  id: totrans-958
  prefs: []
  type: TYPE_PRE
  zh: '[PRE250]'
- en: 'However, since the relationship of the inner query to the outer one is that
    at most only one row is shared in the case of `uselist=False` (in the same way
    as a many-to-one), the “subquery” used with LIMIT + joined eager loading is now
    dropped in this case:'
  id: totrans-959
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于内部查询与外部查询的关系在`uselist=False`的情况下最多只共享一行（与一对多的方式相同），因此在使用LIMIT +连接式加载时，“子查询”在这种情况下现在被取消：
- en: '[PRE251]'
  id: totrans-960
  prefs: []
  type: TYPE_PRE
  zh: '[PRE251]'
- en: In the case that the LEFT OUTER JOIN returns more than one row, the ORM has
    always emitted a warning here and ignored additional results for `uselist=False`,
    so the results in that error situation should not change.
  id: totrans-961
  prefs: []
  type: TYPE_NORMAL
  zh: 在左外连接返回多于一行的情况下，ORM一直在此处发出警告，并对于`uselist=False`忽略额外的结果，因此在该错误情况下结果不应更改。
- en: '[#3249](https://www.sqlalchemy.org/trac/ticket/3249)'
  id: totrans-962
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3249](https://www.sqlalchemy.org/trac/ticket/3249)'
- en: query.update() / query.delete() raises if used with join(), select_from(), from_self()
  id: totrans-963
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用join()，select_from()，from_self()时，query.update() / query.delete()会引发异常。
- en: A warning is emitted in SQLAlchemy 0.9.10 (not yet released as of June 9, 2015)
    when the [`Query.update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.update
    "sqlalchemy.orm.Query.update") or [`Query.delete()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.delete
    "sqlalchemy.orm.Query.delete") methods are invoked against a query which has also
    called upon [`Query.join()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join"), [`Query.outerjoin()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.outerjoin
    "sqlalchemy.orm.Query.outerjoin"), [`Query.select_from()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.select_from
    "sqlalchemy.orm.Query.select_from") or `Query.from_self()`. These are unsupported
    use cases which silently fail in the 0.9 series up until 0.9.10 where it emits
    a warning. In 1.0, these cases raise an exception.
  id: totrans-964
  prefs: []
  type: TYPE_NORMAL
  zh: 在SQLAlchemy 0.9.10版本（截至2015年6月9日尚未发布）中，当调用[`Query.update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.update)或[`Query.delete()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.delete)方法时，如果查询还调用了[`Query.join()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.join)，[`Query.outerjoin()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.outerjoin)，[`Query.select_from()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.select_from)或`Query.from_self()`，则会发出警告。这些是不受支持的用例，在0.9系列中静默失败，直到0.9.10版本发出警告。在1.0版本中，这些情况会引发异常。
- en: '[#3349](https://www.sqlalchemy.org/trac/ticket/3349)'
  id: totrans-965
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3349](https://www.sqlalchemy.org/trac/ticket/3349)'
- en: query.update() with `synchronize_session='evaluate'` raises on multi-table update
  id: totrans-966
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用`synchronize_session='evaluate'`时，query.update()在多表更新时会引发异常。
- en: The “evaluator” for [`Query.update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.update
    "sqlalchemy.orm.Query.update") won’t work with multi-table updates, and needs
    to be set to `synchronize_session=False` or `synchronize_session='fetch'` when
    multiple tables are present. The new behavior is that an explicit exception is
    now raised, with a message to change the synchronize setting. This is upgraded
    from a warning emitted as of 0.9.7.
  id: totrans-967
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Query.update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.update)的“评估器”在多表更新时不起作用，当存在多个表时，需要将其设置为`synchronize_session=False`或`synchronize_session=''fetch''`。新的行为是现在会显式引发异常，并提醒更改同步设置。这是从0.9.7版本开始升级的，之前只是发出警告。'
- en: '[#3117](https://www.sqlalchemy.org/trac/ticket/3117)'
  id: totrans-968
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3117](https://www.sqlalchemy.org/trac/ticket/3117)'
- en: Resurrect Event has been Removed
  id: totrans-969
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 复活事件已被移除
- en: The “resurrect” ORM event has been removed entirely. This event ceased to have
    any function since version 0.8 removed the older “mutable” system from the unit
    of work.
  id: totrans-970
  prefs: []
  type: TYPE_NORMAL
  zh: “复活”ORM 事件已完全删除。自版本 0.8 删除了工作单元中的旧“可变”系统以来，此事件已不再起作用。
- en: '### Change to single-table-inheritance criteria when using from_self(), count()'
  id: totrans-971
  prefs: []
  type: TYPE_NORMAL
  zh: '### 使用 from_self()，count() 时对单表继承条件的更改'
- en: 'Given a single-table inheritance mapping, such as:'
  id: totrans-972
  prefs: []
  type: TYPE_NORMAL
  zh: 给定单表继承映射，例如：
- en: '[PRE252]'
  id: totrans-973
  prefs: []
  type: TYPE_PRE
  zh: '[PRE252]'
- en: 'Using `Query.from_self()` or [`Query.count()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.count
    "sqlalchemy.orm.Query.count") against a subclass would produce a subquery, but
    then add the “WHERE” criteria for subtypes to the outside:'
  id: totrans-974
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Query.from_self()` 或 [`Query.count()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.count
    "sqlalchemy.orm.Query.count") 对子类进行操作将生成一个子查询，然后将子类型的“WHERE”条件添加到外部：
- en: '[PRE253]'
  id: totrans-975
  prefs: []
  type: TYPE_PRE
  zh: '[PRE253]'
- en: 'rendering:'
  id: totrans-976
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染：
- en: '[PRE254]'
  id: totrans-977
  prefs: []
  type: TYPE_PRE
  zh: '[PRE254]'
- en: 'The issue with this is that if the inner query does not specify all columns,
    then we can’t add the WHERE clause on the outside (it actually tries, and produces
    a bad query). This decision apparently goes way back to 0.6.5 with the note “may
    need to make more adjustments to this”. Well, those adjustments have arrived!
    So now the above query will render:'
  id: totrans-978
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题在于，如果内部查询没有指定所有列，那么我们就无法在外部添加 WHERE 子句（实际上会尝试，并生成一个糟糕的查询）。这个决定显然可以追溯到 0.6.5
    版本，带有注释“可能需要对此进行更多调整”。好吧，这些调整已经到位！因此，上述查询现在将渲染为：
- en: '[PRE255]'
  id: totrans-979
  prefs: []
  type: TYPE_PRE
  zh: '[PRE255]'
- en: 'So that queries that don’t include “type” will still work!:'
  id: totrans-980
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，不包括“type”的查询仍将有效！：
- en: '[PRE256]'
  id: totrans-981
  prefs: []
  type: TYPE_PRE
  zh: '[PRE256]'
- en: 'Renders:'
  id: totrans-982
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染：
- en: '[PRE257]'
  id: totrans-983
  prefs: []
  type: TYPE_PRE
  zh: '[PRE257]'
- en: '[#3177](https://www.sqlalchemy.org/trac/ticket/3177)  ### single-table-inheritance
    criteria added to all ON clauses unconditionally'
  id: totrans-984
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3177](https://www.sqlalchemy.org/trac/ticket/3177)  ### 单表继承条件无条件地添加到所有 ON
    子句中'
- en: 'When joining to a single-table inheritance subclass target, the ORM always
    adds the “single table criteria” when joining on a relationship. Given a mapping
    as:'
  id: totrans-985
  prefs: []
  type: TYPE_NORMAL
  zh: 当连接到单表继承子类目标时，ORM 在连接关系时始终添加“单表条件”。给定一个映射如下：
- en: '[PRE258]'
  id: totrans-986
  prefs: []
  type: TYPE_PRE
  zh: '[PRE258]'
- en: 'It’s been the behavior for quite some time that a JOIN on the relationship
    will render a “single inheritance” clause for the type:'
  id: totrans-987
  prefs: []
  type: TYPE_NORMAL
  zh: 长时间以来，JOIN 关系将为类型渲染“单继承”子句：
- en: '[PRE259]'
  id: totrans-988
  prefs: []
  type: TYPE_PRE
  zh: '[PRE259]'
- en: 'SQL output:'
  id: totrans-989
  prefs: []
  type: TYPE_NORMAL
  zh: 'SQL 输出： '
- en: '[PRE260]'
  id: totrans-990
  prefs: []
  type: TYPE_PRE
  zh: '[PRE260]'
- en: Above, because we joined to a subclass `FooWidget`, [`Query.join()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join") knew to add the `AND widget.type IN ('foo')` criteria
    to the ON clause.
  id: totrans-991
  prefs: []
  type: TYPE_NORMAL
  zh: 上面，因为我们连接到了子类 `FooWidget`，[`Query.join()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join") 知道要将 `AND widget.type IN ('foo')` 条件添加到 ON 子句中。
- en: 'The change here is that the `AND widget.type IN()` criteria is now appended
    to *any* ON clause, not just those generated from a relationship, including one
    that is explicitly stated:'
  id: totrans-992
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的变化是 `AND widget.type IN()` 条件现在附加到*任何* ON 子句，不仅仅是从关系生成的那些，包括明确声明的一个：
- en: '[PRE261]'
  id: totrans-993
  prefs: []
  type: TYPE_PRE
  zh: '[PRE261]'
- en: 'As well as the “implicit” join when no ON clause of any kind is stated:'
  id: totrans-994
  prefs: []
  type: TYPE_NORMAL
  zh: 以及当没有任何 ON 子句时的“隐式”连接：
- en: '[PRE262]'
  id: totrans-995
  prefs: []
  type: TYPE_PRE
  zh: '[PRE262]'
- en: Previously, the ON clause for these would not include the single-inheritance
    criteria. Applications that are already adding this criteria to work around this
    will want to remove its explicit use, though it should continue to work fine if
    the criteria happens to be rendered twice in the meantime.
  id: totrans-996
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，这些的 ON 子句不会包括单继承条件。已经在应用程序中添加此条件以解决此问题的应用程序将希望删除其显式使用，尽管如果在此期间该条件恰好被渲染两次，则应该继续正常工作。
- en: See also
  id: totrans-997
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Changes and fixes in handling of duplicate join targets](#bug-3233)'
  id: totrans-998
  prefs: []
  type: TYPE_NORMAL
  zh: '[处理重复连接目标的更改和修复](#bug-3233)'
- en: '[#3222](https://www.sqlalchemy.org/trac/ticket/3222)  ### query.update() now
    resolves string names into mapped attribute names'
  id: totrans-999
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3222](https://www.sqlalchemy.org/trac/ticket/3222)  ### query.update() 现在将字符串名称解析为映射属性名称'
- en: The documentation for [`Query.update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.update
    "sqlalchemy.orm.Query.update") states that the given `values` dictionary is “a
    dictionary with attributes names as keys”, implying that these are mapped attribute
    names. Unfortunately, the function was designed more in mind to receive attributes
    and SQL expressions and not as much strings; when strings were passed, these strings
    would be passed through straight to the core update statement without any resolution
    as far as how these names are represented on the mapped class, meaning the name
    would have to match that of a table column exactly, not how an attribute of that
    name was mapped onto the class.
  id: totrans-1000
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Query.update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.update
    "sqlalchemy.orm.Query.update")的文档说明给定的`values`字典是“以属性名称为键的字典”，暗示这些是映射的属性名称。不幸的是，该函数更多地设计为接收属性和SQL表达式，而不是字符串；当传递字符串时，这些字符串将直接传递到核心更新语句，而不解析这些名称在映射类上如何表示，这意味着名称必须与表列的名称完全匹配，而不是映射到类的属性的名称。'
- en: 'The string names are now resolved as attribute names in earnest:'
  id: totrans-1001
  prefs: []
  type: TYPE_NORMAL
  zh: 字符���名称现在认真解析为属性名称：
- en: '[PRE263]'
  id: totrans-1002
  prefs: []
  type: TYPE_PRE
  zh: '[PRE263]'
- en: 'Above, the column `user_name` is mapped as `name`. Previously, a call to [`Query.update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.update
    "sqlalchemy.orm.Query.update") that was passed strings would have to have been
    called as follows:'
  id: totrans-1003
  prefs: []
  type: TYPE_NORMAL
  zh: 上面，列`user_name`被映射为`name`。以前，传递字符串的[`Query.update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.update
    "sqlalchemy.orm.Query.update")调用必须按照以下方式调用：
- en: '[PRE264]'
  id: totrans-1004
  prefs: []
  type: TYPE_PRE
  zh: '[PRE264]'
- en: 'The given string is now resolved against the entity:'
  id: totrans-1005
  prefs: []
  type: TYPE_NORMAL
  zh: 现在给定的字符串已经解析为实体：
- en: '[PRE265]'
  id: totrans-1006
  prefs: []
  type: TYPE_PRE
  zh: '[PRE265]'
- en: 'It is typically preferable to use the attribute directly, to avoid any ambiguity:'
  id: totrans-1007
  prefs: []
  type: TYPE_NORMAL
  zh: 通常最好直接使用属性，以避免任何歧义：
- en: '[PRE266]'
  id: totrans-1008
  prefs: []
  type: TYPE_PRE
  zh: '[PRE266]'
- en: 'The change also indicates that synonyms and hybrid attributes can be referred
    to by string name as well:'
  id: totrans-1009
  prefs: []
  type: TYPE_NORMAL
  zh: 此更改还表明，同义词和混合属性也可以通过字符串名称进行引用：
- en: '[PRE267]'
  id: totrans-1010
  prefs: []
  type: TYPE_PRE
  zh: '[PRE267]'
- en: '[#3228](https://www.sqlalchemy.org/trac/ticket/3228)'
  id: totrans-1011
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3228](https://www.sqlalchemy.org/trac/ticket/3228)'
- en: '### Warnings emitted when comparing objects with None values to relationships'
  id: totrans-1012
  prefs: []
  type: TYPE_NORMAL
  zh: '### 当将具有None值的对象与关系进行比较时发出警告'
- en: 'This change is new as of 1.0.1\. Some users are performing queries that are
    essentially of this form:'
  id: totrans-1013
  prefs: []
  type: TYPE_NORMAL
  zh: 这个更改是从1.0.1版本开始的。一些用户正在执行基本上是这种形式的查询：
- en: '[PRE268]'
  id: totrans-1014
  prefs: []
  type: TYPE_PRE
  zh: '[PRE268]'
- en: 'This pattern is not currently supported in SQLAlchemy. For all versions, it
    emits SQL resembling:'
  id: totrans-1015
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy目前不支持这种模式。对于所有版本，它生成类似于以下的SQL：
- en: '[PRE269]'
  id: totrans-1016
  prefs: []
  type: TYPE_PRE
  zh: '[PRE269]'
- en: 'Note above, there is a comparison `WHERE ? = address.user_id` where the bound
    value `?` is receiving `None`, or `NULL` in SQL. **This will always return False
    in SQL**. The comparison here would in theory generate SQL as follows:'
  id: totrans-1017
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意上面，有一个比较`WHERE ? = address.user_id`，其中绑定值`?`接收到`None`，或者在SQL中是`NULL`。**这在SQL中总是返回False**。理论上，这里的比较会生成如下的SQL：
- en: '[PRE270]'
  id: totrans-1018
  prefs: []
  type: TYPE_PRE
  zh: '[PRE270]'
- en: 'But right now, **it does not**. Applications which are relying upon the fact
    that “NULL = NULL” produces False in all cases run the risk that someday, SQLAlchemy
    might fix this issue to generate “IS NULL”, and the queries will then produce
    different results. Therefore with this kind of operation, you will see a warning:'
  id: totrans-1019
  prefs: []
  type: TYPE_NORMAL
  zh: 但是现在，**它不会**。依赖于“NULL = NULL”在所有情况下产生False的应用程序可能会面临这样的风险，即有一天，SQLAlchemy可能会修复此问题以生成“IS
    NULL”，然后查询将产生不同的结果。因此，在进行这种操作时，您将看到一个警告：
- en: '[PRE271]'
  id: totrans-1020
  prefs: []
  type: TYPE_PRE
  zh: '[PRE271]'
- en: Note that this pattern was broken in most cases for release 1.0.0 including
    all of the betas; a value like `SYMBOL('NEVER_SET')` would be generated. This
    issue has been fixed, but as a result of identifying this pattern, the warning
    is now there so that we can more safely repair this broken behavior (now captured
    in [#3373](https://www.sqlalchemy.org/trac/ticket/3373)) in a future release.
  id: totrans-1021
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这种模式在1.0.0版本中的大多数情况下都被破坏，包括所有的beta版本；像`SYMBOL('NEVER_SET')`这样的值将被生成。这个问题已经修复，但由于识别到这种模式，现在有了警告，以便我们可以更安全地修复这个破损的行为（现在在[#3373](https://www.sqlalchemy.org/trac/ticket/3373)中捕获）在未来的版本中。
- en: '[#3371](https://www.sqlalchemy.org/trac/ticket/3371)'
  id: totrans-1022
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3371](https://www.sqlalchemy.org/trac/ticket/3371)'
- en: '### A “negated contains or equals” relationship comparison will use the current
    value of attributes, not the database value'
  id: totrans-1023
  prefs: []
  type: TYPE_NORMAL
  zh: '### “否定包含或等于”关系比较将使用属性的当前值，而不是数据库值'
- en: This change is new as of 1.0.1; while we would have preferred for this to be
    in 1.0.0, it only became apparent as a result of [#3371](https://www.sqlalchemy.org/trac/ticket/3371).
  id: totrans-1024
  prefs: []
  type: TYPE_NORMAL
  zh: 这个更改是从1.0.1版本开始的；虽然我们更希望这在1.0.0中实现，但只有通过[#3371](https://www.sqlalchemy.org/trac/ticket/3371)才变得明显。
- en: 'Given a mapping:'
  id: totrans-1025
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个映射：
- en: '[PRE272]'
  id: totrans-1026
  prefs: []
  type: TYPE_PRE
  zh: '[PRE272]'
- en: 'Given `A`, with primary key of 7, but which we changed to be 10 without flushing:'
  id: totrans-1027
  prefs: []
  type: TYPE_NORMAL
  zh: 给定`A`，主键为7，但我们将其更改为10而没有刷新：
- en: '[PRE273]'
  id: totrans-1028
  prefs: []
  type: TYPE_PRE
  zh: '[PRE273]'
- en: 'A query against a many-to-one relationship with this object as the target will
    use the value 10 in the bound parameters:'
  id: totrans-1029
  prefs: []
  type: TYPE_NORMAL
  zh: 对于以这个对象为目标的一对多关系的查询将使用绑定参数中的值10：
- en: '[PRE274]'
  id: totrans-1030
  prefs: []
  type: TYPE_PRE
  zh: '[PRE274]'
- en: 'Produces:'
  id: totrans-1031
  prefs: []
  type: TYPE_NORMAL
  zh: 产生的结果：
- en: '[PRE275]'
  id: totrans-1032
  prefs: []
  type: TYPE_PRE
  zh: '[PRE275]'
- en: 'However, before this change, the negation of this criteria would **not** use
    10, it would use 7, unless the object were flushed first:'
  id: totrans-1033
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在这个改变之前，对这个标准的否定将**不会**使用10，而是使用7，除非对象首先被刷新：
- en: '[PRE276]'
  id: totrans-1034
  prefs: []
  type: TYPE_PRE
  zh: '[PRE276]'
- en: 'Produces (in 0.9 and all versions prior to 1.0.1):'
  id: totrans-1035
  prefs: []
  type: TYPE_NORMAL
  zh: 产生的结果（在0.9版本和所有1.0.1版本之前的版本中）：
- en: '[PRE277]'
  id: totrans-1036
  prefs: []
  type: TYPE_PRE
  zh: '[PRE277]'
- en: 'For a transient object, it would produce a broken query:'
  id: totrans-1037
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个瞬态对象，它将产生一个错误的查询：
- en: '[PRE278]'
  id: totrans-1038
  prefs: []
  type: TYPE_PRE
  zh: '[PRE278]'
- en: This inconsistency has been repaired, and in all queries the current attribute
    value, in this example `10`, will now be used.
  id: totrans-1039
  prefs: []
  type: TYPE_NORMAL
  zh: 这种不一致性已经得到修复，在所有查询中，当前属性值，比如这个例子中的`10`，现在将被使用。
- en: '[#3374](https://www.sqlalchemy.org/trac/ticket/3374)'
  id: totrans-1040
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3374](https://www.sqlalchemy.org/trac/ticket/3374)'
- en: '### Changes to attribute events and other operations regarding attributes that
    have no pre-existing value'
  id: totrans-1041
  prefs: []
  type: TYPE_NORMAL
  zh: '### 关于没有预先存在值的属性事件和其他操作的更改'
- en: In this change, the default return value of `None` when accessing an object
    is now returned dynamically on each access, rather than implicitly setting the
    attribute’s state with a special “set” operation when it is first accessed. The
    visible result of this change is that `obj.__dict__` is not implicitly modified
    on get, and there are also some minor behavioral changes for [`get_history()`](../orm/session_api.html#sqlalchemy.orm.attributes.get_history
    "sqlalchemy.orm.attributes.get_history") and related functions.
  id: totrans-1042
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个改变中，当访问一个对象时，默认的返回值`None`现在会在每次访问时动态返回，而不是在第一次访问时隐式地使用特殊的“set”操作设置属性的状态。这个改变的可见结果是，`obj.__dict__`在获取时不会隐式修改，并且对于[`get_history()`](../orm/session_api.html#sqlalchemy.orm.attributes.get_history
    "sqlalchemy.orm.attributes.get_history")和相关函数也有一些轻微的行为变化。
- en: 'Given an object with no state:'
  id: totrans-1043
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于一个没有状态的对象：
- en: '[PRE279]'
  id: totrans-1044
  prefs: []
  type: TYPE_PRE
  zh: '[PRE279]'
- en: 'It has always been SQLAlchemy’s behavior such that if we access a scalar or
    many-to-one attribute that was never set, it is returned as `None`:'
  id: totrans-1045
  prefs: []
  type: TYPE_NORMAL
  zh: 一直以来，SQLAlchemy的行为是，如果我们访问一个从未设置过的标量或一对多属性，它会返回`None`：
- en: '[PRE280]'
  id: totrans-1046
  prefs: []
  type: TYPE_PRE
  zh: '[PRE280]'
- en: 'This value of `None` is in fact now part of the state of `obj`, and is not
    unlike as though we had set the attribute explicitly, e.g. `obj.someattr = None`.
    However, the “set on get” here would behave differently as far as history and
    events. It would not emit any attribute event, and additionally if we view history,
    we see this:'
  id: totrans-1047
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`None`值实际上现在是`obj`的状态的一部分，与我们明确设置属性的情况类似，比如`obj.someattr = None`。然而，在这里“获取时设置”会在历史和事件方面有所不同。它不会触发任何属性事件，而且如果我们查看历史记录，我们会看到这样：
- en: '[PRE281]'
  id: totrans-1048
  prefs: []
  type: TYPE_PRE
  zh: '[PRE281]'
- en: 'That is, it’s as though the attribute were always `None` and were never changed.
    This is explicitly different from if we had set the attribute first instead:'
  id: totrans-1049
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，就好像属性始终是`None`，并且从未更改过。这与我们首先设置属性的情况明显不同：
- en: '[PRE282]'
  id: totrans-1050
  prefs: []
  type: TYPE_PRE
  zh: '[PRE282]'
- en: The above means that the behavior of our “set” operation can be corrupted by
    the fact that the value was accessed via “get” earlier. In 1.0, this inconsistency
    has been resolved, by no longer actually setting anything when the default “getter”
    is used.
  id: totrans-1051
  prefs: []
  type: TYPE_NORMAL
  zh: 上述意味着我们的“set”操作的行为可能会受到早期通过“get”访问值的影响而被破坏。在1.0版本中，这种不一致性已经得到解决，不再在使用默认“getter”时实际设置任何内容。
- en: '[PRE283]'
  id: totrans-1052
  prefs: []
  type: TYPE_PRE
  zh: '[PRE283]'
- en: The reason the above behavior hasn’t had much impact is because the INSERT statement
    in relational databases considers a missing value to be the same as NULL in most
    cases. Whether SQLAlchemy received a history event for a particular attribute
    set to None or not would usually not matter; as the difference between sending
    None/NULL or not wouldn’t have an impact. However, as [#3060](https://www.sqlalchemy.org/trac/ticket/3060)
    (described here in [Priority of attribute changes on relationship-bound attributes
    vs. FK-bound may appear to change](#migration-3060)) illustrates, there are some
    seldom edge cases where we do in fact want to positively have `None` set. Also,
    allowing the attribute event here means it’s now possible to create “default value”
    functions for ORM mapped attributes.
  id: totrans-1053
  prefs: []
  type: TYPE_NORMAL
  zh: 上述行为之所以没有太大影响，是因为在关系数据库中的INSERT语句在大多数情况下将缺失值视为NULL。对于特定属性设置为None的情况，SQLAlchemy是否收到历史事件通常不重要；因为发送None/NULL或不发送的区别通常不会产生影响。然而，正如[#3060](https://www.sqlalchemy.org/trac/ticket/3060)（在[关于关系绑定属性与FK绑定属性的属性更改优先级可能会发生变化](#migration-3060)中描述）所示，有一些很少见的边缘情况，我们实际上确实希望明确设置`None`。此外，在这里允许属性事件意味着现在可以为ORM映射属性创建“默认值”函数。
- en: As part of this change, the generation of the implicit “None” is now disabled
    for other situations where this used to occur; this includes when an attribute
    set operation on a many-to-one is received; previously, the “old” value would
    be “None” if it had been not set otherwise; it now will send the value `NEVER_SET`,
    which is a value that may be sent to an attribute listener now. This symbol may
    also be received when calling on mapper utility functions such as [`Mapper.primary_key_from_instance()`](../orm/mapping_api.html#sqlalchemy.orm.Mapper.primary_key_from_instance
    "sqlalchemy.orm.Mapper.primary_key_from_instance"); if the primary key attributes
    have no setting at all, whereas the value would be `None` before, it will now
    be the `NEVER_SET` symbol, and no change to the object’s state occurs.
  id: totrans-1054
  prefs: []
  type: TYPE_NORMAL
  zh: 作为这一变化的一部分，现在已禁用了在其他情况下生成隐式“None”的操作；这包括当接收到对多对一属性的属性设置操作时；以前，如果“旧”值未设置，那么“旧”值将为“None”；现在将发送值`NEVER_SET`，这是一个现在可能发送给属性监听器的值。当调用映射器实用函数时，也可能收到此符号，例如[`Mapper.primary_key_from_instance()`](../orm/mapping_api.html#sqlalchemy.orm.Mapper.primary_key_from_instance
    "sqlalchemy.orm.Mapper.primary_key_from_instance")；如果主键属性根本没有设置，而以前的值为`None`，那么现在将是`NEVER_SET`符号，并且对象状态不会发生任何变化。
- en: '[#3061](https://www.sqlalchemy.org/trac/ticket/3061)'
  id: totrans-1055
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3061](https://www.sqlalchemy.org/trac/ticket/3061)'
- en: '### Priority of attribute changes on relationship-bound attributes vs. FK-bound
    may appear to change'
  id: totrans-1056
  prefs: []
  type: TYPE_NORMAL
  zh: '### 属性变化对关系绑定属性和外键绑定属性的优先级可能会发生变化'
- en: 'As a side effect of [#3060](https://www.sqlalchemy.org/trac/ticket/3060), setting
    a relationship-bound attribute to `None` is now a tracked history event which
    refers to the intention of persisting `None` to that attribute. As it has always
    been the case that setting a relationship-bound attribute will trump direct assignment
    to the foreign key attributes, a change in behavior can be seen here when assigning
    None. Given a mapping:'
  id: totrans-1057
  prefs: []
  type: TYPE_NORMAL
  zh: 作为[#3060](https://www.sqlalchemy.org/trac/ticket/3060)的一个副作用，将关系绑定属性设置为`None`现在是一个被跟踪的历史事件，指的是将`None`持久化到该属性的意图。由于一直以来设置关系绑定属性将优先于直接赋值给外键属性，因此在分配`None`时可以看到行为上的变化。给定一个映射：
- en: '[PRE284]'
  id: totrans-1058
  prefs: []
  type: TYPE_PRE
  zh: '[PRE284]'
- en: 'In 1.0, the relationship-bound attribute takes precedence over the FK-bound
    attribute in all cases, whether or not the value we assign is a reference to an
    `A` object or is `None`. In 0.9, the behavior is inconsistent and only takes effect
    if a value is assigned; the None is not considered:'
  id: totrans-1059
  prefs: []
  type: TYPE_NORMAL
  zh: 在1.0版本中，无论我们分配的值是对`A`对象的引用还是`None`，关系绑定属性在所有情况下都优先于外键绑定属性。在0.9版本中，行为是不一致的，只有在分配值时才会生效；`None`不被考虑：
- en: '[PRE285]'
  id: totrans-1060
  prefs: []
  type: TYPE_PRE
  zh: '[PRE285]'
- en: '[#3060](https://www.sqlalchemy.org/trac/ticket/3060)'
  id: totrans-1061
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3060](https://www.sqlalchemy.org/trac/ticket/3060)'
- en: '### session.expunge() will fully detach an object that’s been deleted'
  id: totrans-1062
  prefs: []
  type: TYPE_NORMAL
  zh: '### session.expunge()将完全分离已删除的对象'
- en: 'The behavior of [`Session.expunge()`](../orm/session_api.html#sqlalchemy.orm.Session.expunge
    "sqlalchemy.orm.Session.expunge") had a bug that caused an inconsistency in behavior
    regarding deleted objects. The [`object_session()`](../orm/session_api.html#sqlalchemy.orm.object_session
    "sqlalchemy.orm.object_session") function as well as the [`InstanceState.session`](../orm/internals.html#sqlalchemy.orm.InstanceState.session
    "sqlalchemy.orm.InstanceState.session") attribute would still report object as
    belonging to the [`Session`](../orm/session_api.html#sqlalchemy.orm.Session "sqlalchemy.orm.Session")
    subsequent to the expunge:'
  id: totrans-1063
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Session.expunge()`](../orm/session_api.html#sqlalchemy.orm.Session.expunge
    "sqlalchemy.orm.Session.expunge")的行为存在一个错误，导致关于已删除对象的行为不一致。[`object_session()`](../orm/session_api.html#sqlalchemy.orm.object_session
    "sqlalchemy.orm.object_session")函数以及[`InstanceState.session`](../orm/internals.html#sqlalchemy.orm.InstanceState.session
    "sqlalchemy.orm.InstanceState.session")属性仍会报告对象属于[`Session`](../orm/session_api.html#sqlalchemy.orm.Session
    "sqlalchemy.orm.Session")，即使在执行expunge之后：'
- en: '[PRE286]'
  id: totrans-1064
  prefs: []
  type: TYPE_PRE
  zh: '[PRE286]'
- en: Note that it is normal for `u1 not in sess` to be True while `inspect(u1).session`
    still refers to the session, while the transaction is ongoing subsequent to the
    delete operation and [`Session.expunge()`](../orm/session_api.html#sqlalchemy.orm.Session.expunge
    "sqlalchemy.orm.Session.expunge") has not been called; the full detachment normally
    completes once the transaction is committed. This issue would also impact functions
    that rely on [`Session.expunge()`](../orm/session_api.html#sqlalchemy.orm.Session.expunge
    "sqlalchemy.orm.Session.expunge") such as [`make_transient()`](../orm/session_api.html#sqlalchemy.orm.make_transient
    "sqlalchemy.orm.make_transient").
  id: totrans-1065
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`u1 not in sess`为True而`inspect(u1).session`仍然指向会话是正常的，而事务正在进行中，删除操作之后尚未调用[`Session.expunge()`](../orm/session_api.html#sqlalchemy.orm.Session.expunge
    "sqlalchemy.orm.Session.expunge")；完全分离通常在事务提交后完成。这个问题也会影响依赖于[`Session.expunge()`](../orm/session_api.html#sqlalchemy.orm.Session.expunge
    "sqlalchemy.orm.Session.expunge")的函数，比如[`make_transient()`](../orm/session_api.html#sqlalchemy.orm.make_transient
    "sqlalchemy.orm.make_transient")。
- en: '[#3139](https://www.sqlalchemy.org/trac/ticket/3139)'
  id: totrans-1066
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3139](https://www.sqlalchemy.org/trac/ticket/3139)'
- en: '### Joined/Subquery eager loading explicitly disallowed with yield_per'
  id: totrans-1067
  prefs: []
  type: TYPE_NORMAL
  zh: '### 使用yield_per明确禁止连接/子查询的急加载'
- en: 'In order to make the [`Query.yield_per()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.yield_per
    "sqlalchemy.orm.Query.yield_per") method easier to use, an exception is raised
    if any subquery eager loaders, or joined eager loaders that would use collections,
    are to take effect when yield_per is used, as these are currently not compatible
    with yield-per (subquery loading could be in theory, however). When this error
    is raised, the [`lazyload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.lazyload
    "sqlalchemy.orm.lazyload") option can be sent with an asterisk:'
  id: totrans-1068
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使[`Query.yield_per()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.yield_per
    "sqlalchemy.orm.Query.yield_per")方法更容易使用，如果在使用yield_per时要生效任何子查询急加载器或使用集合的连接急加载器，将引发异常，因为这些当前与yield-per不兼容（子查询加载理论上可能是兼容的）。当出现此错误时，可以使用带有星号的[`lazyload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.lazyload
    "sqlalchemy.orm.lazyload")选项：
- en: '[PRE287]'
  id: totrans-1069
  prefs: []
  type: TYPE_PRE
  zh: '[PRE287]'
- en: 'or use [`Query.enable_eagerloads()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.enable_eagerloads
    "sqlalchemy.orm.Query.enable_eagerloads"):'
  id: totrans-1070
  prefs: []
  type: TYPE_NORMAL
  zh: '或使用[`Query.enable_eagerloads()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.enable_eagerloads
    "sqlalchemy.orm.Query.enable_eagerloads"):'
- en: '[PRE288]'
  id: totrans-1071
  prefs: []
  type: TYPE_PRE
  zh: '[PRE288]'
- en: 'The [`lazyload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.lazyload
    "sqlalchemy.orm.lazyload") option has the advantage that additional many-to-one
    joined loader options can still be used:'
  id: totrans-1072
  prefs: []
  type: TYPE_NORMAL
  zh: '[`lazyload()`](../orm/queryguide/relationships.html#sqlalchemy.orm.lazyload
    "sqlalchemy.orm.lazyload")选项的优势在于仍然可以使用额外的多对一连接加载器选项：'
- en: '[PRE289]'
  id: totrans-1073
  prefs: []
  type: TYPE_PRE
  zh: '[PRE289]'
- en: '### Changes and fixes in handling of duplicate join targets'
  id: totrans-1074
  prefs: []
  type: TYPE_NORMAL
  zh: '### 处理重复连接目标的更改和修复'
- en: Changes here encompass bugs where an unexpected and inconsistent behavior would
    occur in some scenarios when joining to an entity twice, or to multiple single-table
    entities against the same table, without using a relationship-based ON clause,
    as well as when joining multiple times to the same target relationship.
  id: totrans-1075
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的更改涵盖了在某些情况下连接到实体两次或对同一表的多个单表实体进行多次连接时会发生意外和不一致行为的错误，而不使用基于关系的ON子句时，以及在多次连接到相同目标关系时。
- en: 'Starting with a mapping as:'
  id: totrans-1076
  prefs: []
  type: TYPE_NORMAL
  zh: 从一个映射开始：
- en: '[PRE290]'
  id: totrans-1077
  prefs: []
  type: TYPE_PRE
  zh: '[PRE290]'
- en: 'A query that joins to `A.bs` twice:'
  id: totrans-1078
  prefs: []
  type: TYPE_NORMAL
  zh: 一个查询两次连接到`A.bs`的问题：
- en: '[PRE291]'
  id: totrans-1079
  prefs: []
  type: TYPE_PRE
  zh: '[PRE291]'
- en: 'Will render:'
  id: totrans-1080
  prefs: []
  type: TYPE_NORMAL
  zh: 将呈现为：
- en: '[PRE292]'
  id: totrans-1081
  prefs: []
  type: TYPE_PRE
  zh: '[PRE292]'
- en: 'The query deduplicates the redundant `A.bs` because it is attempting to support
    a case like the following:'
  id: totrans-1082
  prefs: []
  type: TYPE_NORMAL
  zh: 查询去重了冗余的`A.bs`，因为它试图支持以下情况：
- en: '[PRE293]'
  id: totrans-1083
  prefs: []
  type: TYPE_PRE
  zh: '[PRE293]'
- en: 'That is, the `A.bs` is part of a “path”. As part of [#3367](https://www.sqlalchemy.org/trac/ticket/3367),
    arriving at the same endpoint twice without it being part of a larger path will
    now emit a warning:'
  id: totrans-1084
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，`A.bs`是“路径”的一部分。作为[#3367](https://www.sqlalchemy.org/trac/ticket/3367)的一部分，到达相同的终点两次而不是作为更大路径的一部分现在会发出警告：
- en: '[PRE294]'
  id: totrans-1085
  prefs: []
  type: TYPE_PRE
  zh: '[PRE294]'
- en: 'The bigger change involves when joining to an entity without using a relationship-bound
    path. If we join to `B` twice:'
  id: totrans-1086
  prefs: []
  type: TYPE_NORMAL
  zh: 更大的变化涉及在不使用基于关系的路径连接到实体时。如果我们两次连接到`B`：
- en: '[PRE295]'
  id: totrans-1087
  prefs: []
  type: TYPE_PRE
  zh: '[PRE295]'
- en: 'In 0.9, this would render as follows:'
  id: totrans-1088
  prefs: []
  type: TYPE_NORMAL
  zh: 在0.9版本中，这将呈现如下：
- en: '[PRE296]'
  id: totrans-1089
  prefs: []
  type: TYPE_PRE
  zh: '[PRE296]'
- en: This is problematic since the aliasing is implicit and in the case of different
    ON clauses can lead to unpredictable results.
  id: totrans-1090
  prefs: []
  type: TYPE_NORMAL
  zh: 这是有问题的，因为别名是隐式的，在不同的ON子句的情况下可能导致结果不可预测。
- en: 'In 1.0, no automatic aliasing is applied and we get:'
  id: totrans-1091
  prefs: []
  type: TYPE_NORMAL
  zh: 在1.0中，不会自动应用别名，我们得到：
- en: '[PRE297]'
  id: totrans-1092
  prefs: []
  type: TYPE_PRE
  zh: '[PRE297]'
- en: This will raise an error from the database. While it might be nice if the “duplicate
    join target” acted identically if we joined both from redundant relationships
    vs. redundant non-relationship based targets, for now we are only changing the
    behavior in the more serious case where implicit aliasing would have occurred
    previously, and only emitting a warning in the relationship case. Ultimately,
    joining to the same thing twice without any aliasing to disambiguate should raise
    an error in all cases.
  id: totrans-1093
  prefs: []
  type: TYPE_NORMAL
  zh: 这将从数据库中引发错误。虽然如果“重复连接目标”在我们从冗余关系 vs. 冗余非关系目标中都加入时表现相同的话会很好，但是目前我们只在以前会发生隐式别名时更改行为，在关系情况下只发出警告。最终，在所有情况下，未加别名以消除歧义地两次连接到相同内容都应该引发错误。
- en: 'The change also has an impact on single-table inheritance targets. Using a
    mapping as follows:'
  id: totrans-1094
  prefs: []
  type: TYPE_NORMAL
  zh: 此更改还对单表继承目标产生影响。使用以下映射：
- en: '[PRE298]'
  id: totrans-1095
  prefs: []
  type: TYPE_PRE
  zh: '[PRE298]'
- en: 'The two queries at the bottom are equivalent, and should both render the identical
    SQL:'
  id: totrans-1096
  prefs: []
  type: TYPE_NORMAL
  zh: 底部的两个查询是等价的，应该都会渲染相同的 SQL：
- en: '[PRE299]'
  id: totrans-1097
  prefs: []
  type: TYPE_PRE
  zh: '[PRE299]'
- en: 'The above SQL is invalid, as it renders “a” within the FROM list twice. However,
    the implicit aliasing bug would occur with the second query only and render this
    instead:'
  id: totrans-1098
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的 SQL 是无效的，因为它在 FROM 列表中两次呈现 “a”。然而，隐式别名错误只会在第二个查询中发生，而不是呈现以下结果：
- en: '[PRE300]'
  id: totrans-1099
  prefs: []
  type: TYPE_PRE
  zh: '[PRE300]'
- en: Where above, the second join to “a” is aliased. While this seems convenient,
    it’s not how single-inheritance queries work in general and is misleading and
    inconsistent.
  id: totrans-1100
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的情况下，第二次加入到 “a” 的连接已经被别名化。虽然这看起来很方便，但这并不是单继承查询通常的工作方式，这是误导性和不一致的。
- en: 'The net effect is that applications which were relying on this bug will now
    have an error raised by the database. The solution is to use the expected form.
    When referring to multiple subclasses of a single-inheritance entity in a query,
    you must manually use aliases to disambiguate the table, as all the subclasses
    normally refer to the same table:'
  id: totrans-1101
  prefs: []
  type: TYPE_NORMAL
  zh: 净影响是依赖于此错误的应用程序现在将由数据库引发错误。解决方案是使用期望的形式。在查询中引用单继承实体的多个子类时，必须手动使用别名来消除表的歧义，因为所有子类通常都指向相同的表：
- en: '[PRE301]'
  id: totrans-1102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE301]'
- en: '[#3233](https://www.sqlalchemy.org/trac/ticket/3233) [#3367](https://www.sqlalchemy.org/trac/ticket/3367)'
  id: totrans-1103
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3233](https://www.sqlalchemy.org/trac/ticket/3233) [#3367](https://www.sqlalchemy.org/trac/ticket/3367)'
- en: Deferred Columns No Longer Implicitly Undefer
  id: totrans-1104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不再隐式取消延迟列
- en: Mapped attributes marked as deferred without explicit undeferral will now remain
    “deferred” even if their column is otherwise present in the result set in some
    way. This is a performance enhancement in that an ORM load no longer spends time
    searching for each deferred column when the result set is obtained. However, for
    an application that has been relying upon this, an explicit [`undefer()`](../orm/queryguide/columns.html#sqlalchemy.orm.undefer
    "sqlalchemy.orm.undefer") or similar option should now be used, in order to prevent
    a SELECT from being emitted when the attribute is accessed.
  id: totrans-1105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未明确取消设置延迟的延迟列，现在标记为延迟的映射属性将始终保持“延迟”，即使它们的列以某种方式出现在结果集中。这是一种性能增强，因为 ORM 加载在获取结果集时不再花时间搜索每个延迟列。然而，对于依赖于此的应用程序，现在应该使用显式
    [`undefer()`](../orm/queryguide/columns.html#sqlalchemy.orm.undefer "sqlalchemy.orm.undefer")
    或类似选项，以防止在访问属性时发出 SELECT。
- en: '### Deprecated ORM Event Hooks Removed'
  id: totrans-1106
  prefs: []
  type: TYPE_NORMAL
  zh: '### 废弃的 ORM 事件钩子已移除'
- en: 'The following ORM event hooks, some of which have been deprecated since 0.5,
    have been removed: `translate_row`, `populate_instance`, `append_result`, `create_instance`.
    The use cases for these hooks originated in the very early 0.1 / 0.2 series of
    SQLAlchemy and have long since been unnecessary. In particular, the hooks were
    largely unusable as the behavioral contracts within these events was strongly
    linked to the surrounding internals, such as how an instance needs to be created
    and initialized as well as how columns are located within an ORM-generated row.
    The removal of these hooks greatly simplifies the mechanics of ORM object loading.'
  id: totrans-1107
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 ORM 事件钩子，其中一些从 0.5 版本开始已被弃用，已被移除：`translate_row`、`populate_instance`、`append_result`、`create_instance`。这些钩子的用例始于早期的
    0.1 / 0.2 版本的 SQLAlchemy，并且早已不再需要。特别是，这些钩子在很大程度上无法使用，因为这些事件内部的行为约定与周围内部的密切联系，比如实例需要如何创建和初始化以及如何在
    ORM 生成的行中定位列。移除这些钩子大大简化了 ORM 对象加载的机制。
- en: '### API Change for new Bundle feature when custom row loaders are used'
  id: totrans-1108
  prefs: []
  type: TYPE_NORMAL
  zh: '### 在使用自定义行加载器时对新 Bundle 功能的 API 更改'
- en: 'The new [`Bundle`](../orm/queryguide/api.html#sqlalchemy.orm.Bundle "sqlalchemy.orm.Bundle")
    object of 0.9 has a small change in API, when the `create_row_processor()` method
    is overridden on a custom class. Previously, the sample code looked like:'
  id: totrans-1109
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 [`Bundle`](../orm/queryguide/api.html#sqlalchemy.orm.Bundle "sqlalchemy.orm.Bundle")
    对象在自定义类上覆盖 `create_row_processor()` 方法时 API 有所变化。以前，示例代码如下所示：
- en: '[PRE302]'
  id: totrans-1110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE302]'
- en: 'The unused `result` member is now removed:'
  id: totrans-1111
  prefs: []
  type: TYPE_NORMAL
  zh: 未使用的 `result` 成员现已删除：
- en: '[PRE303]'
  id: totrans-1112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE303]'
- en: See also
  id: totrans-1113
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Grouping Selected Attributes with Bundles](../orm/queryguide/select.html#bundles)'
  id: totrans-1114
  prefs: []
  type: TYPE_NORMAL
  zh: '[使用 Bundles 分组选定属性](../orm/queryguide/select.html#bundles)'
- en: '### Right inner join nesting now the default for joinedload with innerjoin=True'
  id: totrans-1115
  prefs: []
  type: TYPE_NORMAL
  zh: '### 右嵌套内连接现在是 `joinedload` 的默认值，`innerjoin=True`'
- en: The behavior of [`joinedload.innerjoin`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload.params.innerjoin
    "sqlalchemy.orm.joinedload") as well as [`relationship.innerjoin`](../orm/relationship_api.html#sqlalchemy.orm.relationship.params.innerjoin
    "sqlalchemy.orm.relationship") is now to use “nested” inner joins, that is, right-nested,
    as the default behavior when an inner join joined eager load is chained to an
    outer join eager load. In order to get the old behavior of chaining all joined
    eager loads as outer join when an outer join is present, use `innerjoin="unnested"`.
  id: totrans-1116
  prefs: []
  type: TYPE_NORMAL
  zh: 当 INNER JOIN 连接式预加载链接到 OUTER JOIN 连接式预加载时，默认行为为使用“嵌套” INNER JOIN，也就是右嵌套。如果要获得当存在
    OUTER JOIN 时链接所有 INNER JOIN 连接式预加载的旧行为，请使用 `innerjoin="unnested"`。
- en: 'As introduced in [Right-nested inner joins available in joined eager loads](migration_09.html#feature-2976)
    from version 0.9, the behavior of `innerjoin="nested"` is that an inner join eager
    load chained to an outer join eager load will use a right-nested join. `"nested"`
    is now implied when using `innerjoin=True`:'
  id: totrans-1117
  prefs: []
  type: TYPE_NORMAL
  zh: 正如在 [右嵌套内连接可用于连接式预加载](migration_09.html#feature-2976) 中介绍的，`innerjoin="nested"`
    的行为是，当 INNER JOIN 连接式预加载链接到 OUTER JOIN 连接式预加载时，将使用右嵌套连接。当使用 `innerjoin=True` 时，现在会隐含
    `"nested"`：
- en: '[PRE304]'
  id: totrans-1118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE304]'
- en: 'With the new default, this will render the FROM clause in the form:'
  id: totrans-1119
  prefs: []
  type: TYPE_NORMAL
  zh: 使用新的默认值，FROM 子句将呈现为以下形式：
- en: '[PRE305]'
  id: totrans-1120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE305]'
- en: That is, using a right-nested join for the INNER join so that the full result
    of `users` can be returned. The use of an INNER join is more efficient than using
    an OUTER join, and allows the [`joinedload.innerjoin`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload.params.innerjoin
    "sqlalchemy.orm.joinedload") optimization parameter to take effect in all cases.
  id: totrans-1121
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，对于 INNER JOIN，使用右嵌套连接，以便返回`users`的完整结果集。使用 INNER JOIN 比使用 OUTER JOIN 更有效，并且允许在所有情况下生效
    [`joinedload.innerjoin`](../orm/queryguide/relationships.html#sqlalchemy.orm.joinedload.params.innerjoin
    "sqlalchemy.orm.joinedload") 优化参数。
- en: 'To get the older behavior, use `innerjoin="unnested"`:'
  id: totrans-1122
  prefs: []
  type: TYPE_NORMAL
  zh: 要获得旧行为，请使用 `innerjoin="unnested"`：
- en: '[PRE306]'
  id: totrans-1123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE306]'
- en: 'This will avoid right-nested joins and chain the joins together using all OUTER
    joins despite the innerjoin directive:'
  id: totrans-1124
  prefs: []
  type: TYPE_NORMAL
  zh: 这将避免右嵌套连接，并使用所有 OUTER JOIN 将连接链接在一起，尽管存在 innerjoin 指令：
- en: '[PRE307]'
  id: totrans-1125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE307]'
- en: As noted in the 0.9 notes, the only database backend that has difficulty with
    right-nested joins is SQLite; SQLAlchemy as of 0.9 converts a right-nested join
    into a subquery as a join target on SQLite.
  id: totrans-1126
  prefs: []
  type: TYPE_NORMAL
  zh: 如在 0.9 版本的说明中指出的，唯一有困难的数据库后端是 SQLite；从 0.9 版本开始，SQLAlchemy 会将右嵌套连接转换为 SQLite
    上的子查询作为连接目标。
- en: See also
  id: totrans-1127
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Right-nested inner joins available in joined eager loads](migration_09.html#feature-2976)
    - description of the feature as introduced in 0.9.4.'
  id: totrans-1128
  prefs: []
  type: TYPE_NORMAL
  zh: '[右嵌套内连接可用于连接式预加载](migration_09.html#feature-2976) - 在 0.9.4 版本中引入的功能的描述。'
- en: '[#3008](https://www.sqlalchemy.org/trac/ticket/3008)'
  id: totrans-1129
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3008](https://www.sqlalchemy.org/trac/ticket/3008)'
- en: '### Subqueries no longer applied to uselist=False joined eager loads'
  id: totrans-1130
  prefs: []
  type: TYPE_NORMAL
  zh: '### 不再将子查询应用于 uselist=False 的连接式预加载'
- en: 'Given a joined eager load like the following:'
  id: totrans-1131
  prefs: []
  type: TYPE_NORMAL
  zh: 给定如下连接式预加载：
- en: '[PRE308]'
  id: totrans-1132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE308]'
- en: 'SQLAlchemy considers the relationship `A.b` to be a “one to many, loaded as
    a single value”, which is essentially a “one to one” relationship. However, joined
    eager loading has always treated the above as a situation where the main query
    needs to be inside a subquery, as would normally be needed for a collection of
    B objects where the main query has a LIMIT applied:'
  id: totrans-1133
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 认为关系 `A.b` 是“加载为单个值的一对多”，实质上是“一对一”关系。然而，连接式预加载始终将以上情况视为需要主查询位于子查询内的情况，正如在应用
    LIMIT 于主查询时通常需要的情况下一样：
- en: '[PRE309]'
  id: totrans-1134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE309]'
- en: 'However, since the relationship of the inner query to the outer one is that
    at most only one row is shared in the case of `uselist=False` (in the same way
    as a many-to-one), the “subquery” used with LIMIT + joined eager loading is now
    dropped in this case:'
  id: totrans-1135
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于内部查询与外部查询的关系，在 `uselist=False` 的情况下最多只有一行是共享的（与多对一相同），因此在此情况下现已放弃使用带有 LIMIT
    + joined eager loading 的“子查询”：
- en: '[PRE310]'
  id: totrans-1136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE310]'
- en: In the case that the LEFT OUTER JOIN returns more than one row, the ORM has
    always emitted a warning here and ignored additional results for `uselist=False`,
    so the results in that error situation should not change.
  id: totrans-1137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 LEFT OUTER JOIN 返回多于一行的情况下，ORM 一直会在此处发出警告，并且对于 `uselist=False`，会忽略额外的结果，因此在这种错误情况下，结果不应更改。
- en: '[#3249](https://www.sqlalchemy.org/trac/ticket/3249)'
  id: totrans-1138
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3249](https://www.sqlalchemy.org/trac/ticket/3249)'
- en: query.update() / query.delete() raises if used with join(), select_from(), from_self()
  id: totrans-1139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 当与 join()、select_from()、from_self() 一起使用时，query.update() / query.delete() 会引发异常。
- en: A warning is emitted in SQLAlchemy 0.9.10 (not yet released as of June 9, 2015)
    when the [`Query.update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.update
    "sqlalchemy.orm.Query.update") or [`Query.delete()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.delete
    "sqlalchemy.orm.Query.delete") methods are invoked against a query which has also
    called upon [`Query.join()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join"), [`Query.outerjoin()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.outerjoin
    "sqlalchemy.orm.Query.outerjoin"), [`Query.select_from()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.select_from
    "sqlalchemy.orm.Query.select_from") or `Query.from_self()`. These are unsupported
    use cases which silently fail in the 0.9 series up until 0.9.10 where it emits
    a warning. In 1.0, these cases raise an exception.
  id: totrans-1140
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用 [`Query.update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.update
    "sqlalchemy.orm.Query.update") 或 [`Query.delete()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.delete
    "sqlalchemy.orm.Query.delete") 方法的查询还调用了 [`Query.join()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join")、[`Query.outerjoin()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.outerjoin
    "sqlalchemy.orm.Query.outerjoin")、[`Query.select_from()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.select_from
    "sqlalchemy.orm.Query.select_from") 或 `Query.from_self()` 时，SQLAlchemy 0.9.10
    发出警告（截至 2015 年 6 月 9 日尚未发布）。这些是不受支持的用例，直到 0.9.10 发出警告，但在 1.0 中，这些情况会引发异常。
- en: '[#3349](https://www.sqlalchemy.org/trac/ticket/3349)'
  id: totrans-1141
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3349](https://www.sqlalchemy.org/trac/ticket/3349)'
- en: query.update() with `synchronize_session='evaluate'` raises on multi-table update
  id: totrans-1142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 当使用 `synchronize_session='evaluate'` 进行多表更新时，query.update() 会引发异常。
- en: The “evaluator” for [`Query.update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.update
    "sqlalchemy.orm.Query.update") won’t work with multi-table updates, and needs
    to be set to `synchronize_session=False` or `synchronize_session='fetch'` when
    multiple tables are present. The new behavior is that an explicit exception is
    now raised, with a message to change the synchronize setting. This is upgraded
    from a warning emitted as of 0.9.7.
  id: totrans-1143
  prefs: []
  type: TYPE_NORMAL
  zh: 当进行多表更新时，[`Query.update()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.update
    "sqlalchemy.orm.Query.update") 的“评估器”不适用，并且在存在多个表时需要将其设置为 `synchronize_session=False`
    或 `synchronize_session='fetch'`。新的行为是现在会显式引发异常，并提供消息以更改同步设置。这是从 0.9.7 开始发出的警告升级而来。
- en: '[#3117](https://www.sqlalchemy.org/trac/ticket/3117)'
  id: totrans-1144
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3117](https://www.sqlalchemy.org/trac/ticket/3117)'
- en: Resurrect Event has been Removed
  id: totrans-1145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 已删除 Resurrect 事件
- en: The “resurrect” ORM event has been removed entirely. This event ceased to have
    any function since version 0.8 removed the older “mutable” system from the unit
    of work.
  id: totrans-1146
  prefs: []
  type: TYPE_NORMAL
  zh: 完全删除了“复活”ORM事件。自从版本 0.8 移除了工作单元中的旧“可变”系统以来，该事件已不再起作用。
- en: '### Change to single-table-inheritance criteria when using from_self(), count()'
  id: totrans-1147
  prefs: []
  type: TYPE_NORMAL
  zh: '### 使用 from_self()、count() 时的单表继承条件更改'
- en: 'Given a single-table inheritance mapping, such as:'
  id: totrans-1148
  prefs: []
  type: TYPE_NORMAL
  zh: 给定单表继承映射，例如：
- en: '[PRE311]'
  id: totrans-1149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE311]'
- en: 'Using `Query.from_self()` or [`Query.count()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.count
    "sqlalchemy.orm.Query.count") against a subclass would produce a subquery, but
    then add the “WHERE” criteria for subtypes to the outside:'
  id: totrans-1150
  prefs: []
  type: TYPE_NORMAL
  zh: 对子类使用 `Query.from_self()` 或 [`Query.count()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.count
    "sqlalchemy.orm.Query.count") 会生成子查询，但然后将子类型的“WHERE”条件添加到外部：
- en: '[PRE312]'
  id: totrans-1151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE312]'
- en: 'rendering:'
  id: totrans-1152
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染：
- en: '[PRE313]'
  id: totrans-1153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE313]'
- en: 'The issue with this is that if the inner query does not specify all columns,
    then we can’t add the WHERE clause on the outside (it actually tries, and produces
    a bad query). This decision apparently goes way back to 0.6.5 with the note “may
    need to make more adjustments to this”. Well, those adjustments have arrived!
    So now the above query will render:'
  id: totrans-1154
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的问题是，如果内部查询没有指定所有列，那么我们无法在外部添加 WHERE 子句（实际上尝试了，并生成了一个错误的查询）。这个决定显然可以追溯到 0.6.5，注明“可能需要对此进行更多调整”。好吧，这些调整已经到来了！因此，现在上述查询将呈现为：
- en: '[PRE314]'
  id: totrans-1155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE314]'
- en: 'So that queries that don’t include “type” will still work!:'
  id: totrans-1156
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，即使查询不包括“type”，也会工作！：
- en: '[PRE315]'
  id: totrans-1157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE315]'
- en: 'Renders:'
  id: totrans-1158
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染：
- en: '[PRE316]'
  id: totrans-1159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE316]'
- en: '[#3177](https://www.sqlalchemy.org/trac/ticket/3177)'
  id: totrans-1160
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3177](https://www.sqlalchemy.org/trac/ticket/3177)'
- en: '### single-table-inheritance criteria added to all ON clauses unconditionally'
  id: totrans-1161
  prefs: []
  type: TYPE_NORMAL
  zh: '### 单表继承条件无条件添加到所有 ON 子句'
- en: 'When joining to a single-table inheritance subclass target, the ORM always
    adds the “single table criteria” when joining on a relationship. Given a mapping
    as:'
  id: totrans-1162
  prefs: []
  type: TYPE_NORMAL
  zh: 当加入到单表继承子类目标时，ORM 总是在关系上加入“单表条件”。假设有一个映射如下：
- en: '[PRE317]'
  id: totrans-1163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE317]'
- en: 'It’s been the behavior for quite some time that a JOIN on the relationship
    will render a “single inheritance” clause for the type:'
  id: totrans-1164
  prefs: []
  type: TYPE_NORMAL
  zh: 很长一段时间以来，JOIN 关系都会为类型生成“单继承”子句：
- en: '[PRE318]'
  id: totrans-1165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE318]'
- en: 'SQL output:'
  id: totrans-1166
  prefs: []
  type: TYPE_NORMAL
  zh: SQL 输出：
- en: '[PRE319]'
  id: totrans-1167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE319]'
- en: Above, because we joined to a subclass `FooWidget`, [`Query.join()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join") knew to add the `AND widget.type IN ('foo')` criteria
    to the ON clause.
  id: totrans-1168
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的例子中，由于我们连接到了子类 `FooWidget`，[`Query.join()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.join
    "sqlalchemy.orm.Query.join") 知道要将 `AND widget.type IN ('foo')` 的条件添加到 ON 子句中。
- en: 'The change here is that the `AND widget.type IN()` criteria is now appended
    to *any* ON clause, not just those generated from a relationship, including one
    that is explicitly stated:'
  id: totrans-1169
  prefs: []
  type: TYPE_NORMAL
  zh: 此处的更改是现在 `AND widget.type IN()` 的条件现在附加到 *任何* ON 子句上，不仅仅是从关系生成的那些，包括明确声明的一个：
- en: '[PRE320]'
  id: totrans-1170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE320]'
- en: 'As well as the “implicit” join when no ON clause of any kind is stated:'
  id: totrans-1171
  prefs: []
  type: TYPE_NORMAL
  zh: 以及当没有任何类型的 ON 子句时的“隐式”连接：
- en: '[PRE321]'
  id: totrans-1172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE321]'
- en: Previously, the ON clause for these would not include the single-inheritance
    criteria. Applications that are already adding this criteria to work around this
    will want to remove its explicit use, though it should continue to work fine if
    the criteria happens to be rendered twice in the meantime.
  id: totrans-1173
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，这些 ON 子句不会包含单继承的条件。已经添加了此条件以解决此问题的应用程序将希望删除其显式使用，尽管在此期间如果条件恰好被重复呈现，则应该继续正常工作。
- en: See also
  id: totrans-1174
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Changes and fixes in handling of duplicate join targets](#bug-3233)'
  id: totrans-1175
  prefs: []
  type: TYPE_NORMAL
  zh: '[处理重复的联接目标中的更改和修复](#bug-3233)'
- en: '[#3222](https://www.sqlalchemy.org/trac/ticket/3222)'
  id: totrans-1176
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3222](https://www.sqlalchemy.org/trac/ticket/3222)'
- en: Key Behavioral Changes - Core
  id: totrans-1177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关键行为更改 - 核心
- en: '### Warnings emitted when coercing full SQL fragments into text()'
  id: totrans-1178
  prefs: []
  type: TYPE_NORMAL
  zh: '### 将完整的 SQL 片段强制转换为 text() 时发出警告'
- en: Since SQLAlchemy’s inception, there has always been an emphasis on not getting
    in the way of the usage of plain text. The Core and ORM expression systems were
    intended to allow any number of points at which the user can just use plain text
    SQL expressions, not just in the sense that you can send a full SQL string to
    [`Connection.execute()`](../core/connections.html#sqlalchemy.engine.Connection.execute
    "sqlalchemy.engine.Connection.execute"), but that you can send strings with SQL
    expressions into many functions, such as [`Select.where()`](../core/selectable.html#sqlalchemy.sql.expression.Select.where
    "sqlalchemy.sql.expression.Select.where"), [`Query.filter()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.filter
    "sqlalchemy.orm.Query.filter"), and [`Select.order_by()`](../core/selectable.html#sqlalchemy.sql.expression.Select.order_by
    "sqlalchemy.sql.expression.Select.order_by").
  id: totrans-1179
  prefs: []
  type: TYPE_NORMAL
  zh: 自 SQLAlchemy 成立以来，一直强调不妨碍纯文本的使用。核心和 ORM 表达系统旨在允许用户在许多地方使用纯文本 SQL 表达式，不仅仅是在你可以将完整的
    SQL 字符串发送到 [`Connection.execute()`](../core/connections.html#sqlalchemy.engine.Connection.execute
    "sqlalchemy.engine.Connection.execute")，而且还可以将带有 SQL 表达式的字符串发送到许多函数中，例如 [`Select.where()`](../core/selectable.html#sqlalchemy.sql.expression.Select.where
    "sqlalchemy.sql.expression.Select.where")，[`Query.filter()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.filter
    "sqlalchemy.orm.Query.filter") 和 [`Select.order_by()`](../core/selectable.html#sqlalchemy.sql.expression.Select.order_by
    "sqlalchemy.sql.expression.Select.order_by")。
- en: 'Note that by “SQL expressions” we mean a **full fragment of a SQL string**,
    such as:'
  id: totrans-1180
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，“SQL 表达式”指的是完整的 SQL 字符串片段，例如：
- en: '[PRE322]'
  id: totrans-1181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE322]'
- en: 'and we are **not talking about string arguments**, that is, the normal behavior
    of passing string values that become parameterized:'
  id: totrans-1182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们并不是在谈论字符串参数，也就是传递字符串值并成为参数化的正常行为：
- en: '[PRE323]'
  id: totrans-1183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE323]'
- en: The Core tutorial has long featured an example of the use of this technique,
    using a [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") construct where virtually all components of
    it are specified as straight strings. However, despite this long-standing behavior
    and example, users are apparently surprised that this behavior exists, and when
    asking around the community, I was unable to find any user that was in fact *not*
    surprised that you can send a full string into a method like [`Query.filter()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.filter
    "sqlalchemy.orm.Query.filter").
  id: totrans-1184
  prefs: []
  type: TYPE_NORMAL
  zh: 核心教程长期以来一直展示了使用这种技术的示例，使用了一个[`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select")构造，其中几乎所有组件都被指定为直接字符串。然而，尽管存在这种长期行为和示例，用户显然对这种行为感到惊讶，当在社区中询问时，我无法找到任何一个用户实际上*不*感到惊讶，即您可以将完整字符串发送到像[`Query.filter()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.filter
    "sqlalchemy.orm.Query.filter")这样的方法中。
- en: 'So the change here is to encourage the user to qualify textual strings when
    composing SQL that is partially or fully composed from textual fragments. When
    composing a select as below:'
  id: totrans-1185
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这里的更改是鼓励用户在部分或完全由文本片段组成的SQL中对文本字符串进行限定。在以下组成选择时：
- en: '[PRE324]'
  id: totrans-1186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE324]'
- en: 'The statement is built up normally, with all the same coercions as before.
    However, one will see the following warnings emitted:'
  id: totrans-1187
  prefs: []
  type: TYPE_NORMAL
  zh: 语句通常构建，具有与以前相同的强制转换。然而，将看到以下警告被发出：
- en: '[PRE325]'
  id: totrans-1188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE325]'
- en: 'These warnings attempt to show exactly where the issue is by displaying the
    parameters as well as where the string was received. The warnings make use of
    the [Session.get_bind() handles a wider variety of inheritance scenarios](#feature-3178)
    so that parameterized warnings can be emitted safely without running out of memory,
    and as always, if one wishes the warnings to be exceptions, the [Python Warnings
    Filter](https://docs.python.org/2/library/warnings.html) should be used:'
  id: totrans-1189
  prefs: []
  type: TYPE_NORMAL
  zh: 这些警告试图准确显示问题所在，显示参数以及字符串接收的位置。警告使用[Session.get_bind()处理更广泛的继承场景](#feature-3178)，以便可以安全地发出参数化警告而不会耗尽内存，如常，如果希望将警告作为异常处理，应使用[Python警告过滤器](https://docs.python.org/2/library/warnings.html)：
- en: '[PRE326]'
  id: totrans-1190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE326]'
- en: 'Given the above warnings, our statement works just fine, but to get rid of
    the warnings we would rewrite our statement as follows:'
  id: totrans-1191
  prefs: []
  type: TYPE_NORMAL
  zh: 给出上述警告后，我们的语句运行正常，但为了消除警告，我们将重写我们的语句如下：
- en: '[PRE327]'
  id: totrans-1192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE327]'
- en: 'and as the warnings suggest, we can give our statement more specificity about
    the text if we use [`column()`](../core/sqlelement.html#sqlalchemy.sql.expression.column
    "sqlalchemy.sql.expression.column") and [`table()`](../core/selectable.html#sqlalchemy.sql.expression.table
    "sqlalchemy.sql.expression.table"):'
  id: totrans-1193
  prefs: []
  type: TYPE_NORMAL
  zh: 正如警告所建议的，如果我们使用[`column()`](../core/sqlelement.html#sqlalchemy.sql.expression.column
    "sqlalchemy.sql.expression.column")和[`table()`](../core/selectable.html#sqlalchemy.sql.expression.table
    "sqlalchemy.sql.expression.table")，我们可以使我们的语句更具体：
- en: '[PRE328]'
  id: totrans-1194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE328]'
- en: Where note also that [`table()`](../core/selectable.html#sqlalchemy.sql.expression.table
    "sqlalchemy.sql.expression.table") and [`column()`](../core/sqlelement.html#sqlalchemy.sql.expression.column
    "sqlalchemy.sql.expression.column") can now be imported from “sqlalchemy” without
    the “sql” part.
  id: totrans-1195
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，[`table()`](../core/selectable.html#sqlalchemy.sql.expression.table "sqlalchemy.sql.expression.table")和[`column()`](../core/sqlelement.html#sqlalchemy.sql.expression.column
    "sqlalchemy.sql.expression.column")现在可以从“sqlalchemy”中导入，而不需要“sql”部分。
- en: The behavior here applies to [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") as well as to key methods on [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query"), including [`Query.filter()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.filter
    "sqlalchemy.orm.Query.filter"), [`Query.from_statement()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.from_statement
    "sqlalchemy.orm.Query.from_statement") and [`Query.having()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.having
    "sqlalchemy.orm.Query.having").
  id: totrans-1196
  prefs: []
  type: TYPE_NORMAL
  zh: 此行为也适用于[`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select")以及[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")上的关键方法，包括[`Query.filter()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.filter
    "sqlalchemy.orm.Query.filter")、[`Query.from_statement()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.from_statement
    "sqlalchemy.orm.Query.from_statement")和[`Query.having()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.having
    "sqlalchemy.orm.Query.having")。
- en: ORDER BY and GROUP BY are special cases
  id: totrans-1197
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: ORDER BY和GROUP BY是特殊情况
- en: 'There is one case where usage of a string has special meaning, and as part
    of this change we have enhanced its functionality. When we have a [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") or [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") that refers to some column name or named label, we might
    want to GROUP BY and/or ORDER BY known columns or labels:'
  id: totrans-1198
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种情况下，使用字符串具有特殊含义，并且作为这一变化的一部分，我们已增强了其功能。当我们有一个[`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select")或[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")引用某个列名或命名标签时，我们可能想要对已知列或标签进行GROUP BY和/或ORDER BY：
- en: '[PRE329]'
  id: totrans-1199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE329]'
- en: 'In the above statement we expect to see “ORDER BY id_count”, as opposed to
    a re-statement of the function. The string argument given is actively matched
    to an entry in the columns clause during compilation, so the above statement would
    produce as we expect, without warnings (though note that the `"name"` expression
    has been resolved to `users.name`!):'
  id: totrans-1200
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的语句中，我们期望看到“ORDER BY id_count”，而不是函数的重新声明。在编译过程中，给定的字符串参数会与列子句中的条目进行主动匹配，因此上述语句将按我们的期望产生，没有警告（尽管请注意，`"name"`表达式已解析为`users.name`！）：
- en: '[PRE330]'
  id: totrans-1201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE330]'
- en: 'However, if we refer to a name that cannot be located, then we get the warning
    again, as below:'
  id: totrans-1202
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们引用一个无法找到的名称，那么我们会再次收到警告，如下所示：
- en: '[PRE331]'
  id: totrans-1203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE331]'
- en: 'The output does what we say, but again it warns us:'
  id: totrans-1204
  prefs: []
  type: TYPE_NORMAL
  zh: 输出确实按我们说的做了，但再次警告我们：
- en: '[PRE332]'
  id: totrans-1205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE332]'
- en: '[PRE333]'
  id: totrans-1206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE333]'
- en: The above behavior applies to all those places where we might want to refer
    to a so-called “label reference”; ORDER BY and GROUP BY, but also within an OVER
    clause as well as a DISTINCT ON clause that refers to columns (e.g. the PostgreSQL
    syntax).
  id: totrans-1207
  prefs: []
  type: TYPE_NORMAL
  zh: 上述行为适用于所有那些我们可能想要引用所谓“标签引用”的地方；ORDER BY和GROUP BY，但也在OVER子句以及引用列的DISTINCT ON子句中（例如PostgreSQL语法）：
- en: 'We can still specify any arbitrary expression for ORDER BY or others using
    [`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text "sqlalchemy.sql.expression.text"):'
  id: totrans-1208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然可以使用[`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text "sqlalchemy.sql.expression.text")指定任意表达式用于ORDER
    BY或其他操作：
- en: '[PRE334]'
  id: totrans-1209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE334]'
- en: The upshot of the whole change is that SQLAlchemy now would like us to tell
    it when a string is sent that this string is explicitly a [`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text
    "sqlalchemy.sql.expression.text") construct, or a column, table, etc., and if
    we use it as a label name in an order by, group by, or other expression, SQLAlchemy
    expects that the string resolves to something known, else it should again be qualified
    with [`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text "sqlalchemy.sql.expression.text")
    or similar.
  id: totrans-1210
  prefs: []
  type: TYPE_NORMAL
  zh: 整个变化的结果是，SQLAlchemy现在希望我们告诉它，当发送一个字符串时，这个字符串明确是一个[`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text
    "sqlalchemy.sql.expression.text")构造，或者是一个列、表等，如果我们在order by、group by或其他表达式中使用它作为标签名称，SQLAlchemy期望该字符串解析为已知的内容，否则应再次用[`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text
    "sqlalchemy.sql.expression.text")或类似的方式进行限定。
- en: '[#2992](https://www.sqlalchemy.org/trac/ticket/2992)  ### Python-side defaults
    invoked for each row individually when using a multivalued insert'
  id: totrans-1211
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2992](https://www.sqlalchemy.org/trac/ticket/2992)  ### 使用多值插入时，每行都会单独调用Python端的默认值'
- en: Support for Python-side column defaults when using the multi-valued version
    of [`Insert.values()`](../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") were essentially not implemented, and
    would only work “by accident” in specific situations, when the dialect in use
    was using a non-positional (e.g. named) style of bound parameter, and when it
    was not necessary that a Python-side callable be invoked for each row.
  id: totrans-1212
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用[`Insert.values()`](../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values")的多值版本时，对于Python端列默认值的支持基本上没有实现，并且只会在特定情况下“偶然”工作，当使用的方言使用非位置（例如命名）风格的绑定参数时，并且不需要为每一行调用Python端可调用函���时。
- en: 'The feature has been overhauled so that it works more similarly to that of
    an “executemany” style of invocation:'
  id: totrans-1213
  prefs: []
  type: TYPE_NORMAL
  zh: 该功能已进行了全面改进，使其更类似于“executemany”样式的调用：
- en: '[PRE335]'
  id: totrans-1214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE335]'
- en: 'The above example will invoke `next(counter)` for each row individually as
    would be expected:'
  id: totrans-1215
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的示例将为每一行单独调用`next(counter)`，这是可以预期的：
- en: '[PRE336]'
  id: totrans-1216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE336]'
- en: 'Previously, a positional dialect would fail as a bind would not be generated
    for additional positions:'
  id: totrans-1217
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，位置方言会失败，因为不会为额外的位置生成绑定：
- en: '[PRE337]'
  id: totrans-1218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE337]'
- en: 'And with a “named” dialect, the same value for “id” would be re-used in each
    row (hence this change is backwards-incompatible with a system that relied on
    this):'
  id: totrans-1219
  prefs: []
  type: TYPE_NORMAL
  zh: 并且对于“命名”方言，相同的“id”值将在每一行中重新使用（因此这种更改与依赖于此的系统不兼容）：
- en: '[PRE338]'
  id: totrans-1220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE338]'
- en: 'The system will also refuse to invoke a “server side” default as inline-rendered
    SQL, since it cannot be guaranteed that a server side default is compatible with
    this. If the VALUES clause renders for a specific column, then a Python-side value
    is required; if an omitted value only refers to a server-side default, an exception
    is raised:'
  id: totrans-1221
  prefs: []
  type: TYPE_NORMAL
  zh: 系统还将拒绝将“服务器端”默认值作为内联渲染的SQL调用，因为无法保证服务器端默认值与此兼容。如果VALUES子句为特定列呈现，则需要Python端的值；如果省略的值仅指向服务器端默认值，则会引发异常：
- en: '[PRE339]'
  id: totrans-1222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE339]'
- en: 'will raise:'
  id: totrans-1223
  prefs: []
  type: TYPE_NORMAL
  zh: 将引发：
- en: '[PRE340]'
  id: totrans-1224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE340]'
- en: 'Previously, the value “d1” would be copied into that of the third row (but
    again, only with named format!):'
  id: totrans-1225
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，“d1”值将被复制到第三行的值中（但再次，仅适用于命名格式！）：
- en: '[PRE341]'
  id: totrans-1226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE341]'
- en: '[#3288](https://www.sqlalchemy.org/trac/ticket/3288)  ### Event listeners can
    not be added or removed from within that event’s runner'
  id: totrans-1227
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3288](https://www.sqlalchemy.org/trac/ticket/3288)  ### 事件监听器不能在该事件的运行程序内添加或删除'
- en: Removal of an event listener from inside that same event itself would modify
    the elements of a list during iteration, which would cause still-attached event
    listeners to silently fail to fire. To prevent this while still maintaining performance,
    the lists have been replaced with `collections.deque()`, which does not allow
    any additions or removals during iteration, and instead raises `RuntimeError`.
  id: totrans-1228
  prefs: []
  type: TYPE_NORMAL
  zh: 从同一事件中删除事件监听器将在迭代期间修改列表的元素，这将导致仍然附加的事件监听器无法静默触发。为了防止这种情况，同时保持性能，列表已被替换为`collections.deque()`，在迭代期间不允许任何添加或删除，并且会引发`RuntimeError`。
- en: '[#3163](https://www.sqlalchemy.org/trac/ticket/3163)  ### The INSERT…FROM SELECT
    construct now implies `inline=True`'
  id: totrans-1229
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3163](https://www.sqlalchemy.org/trac/ticket/3163)  ### INSERT…FROM SELECT结构现在意味着`inline=True`'
- en: Using [`Insert.from_select()`](../core/dml.html#sqlalchemy.sql.expression.Insert.from_select
    "sqlalchemy.sql.expression.Insert.from_select") now implies `inline=True` on [`insert()`](../core/dml.html#sqlalchemy.sql.expression.insert
    "sqlalchemy.sql.expression.insert"). This helps to fix a bug where an INSERT…FROM
    SELECT construct would inadvertently be compiled as “implicit returning” on supporting
    backends, which would cause breakage in the case of an INSERT that inserts zero
    rows (as implicit returning expects a row), as well as arbitrary return data in
    the case of an INSERT that inserts multiple rows (e.g. only the first row of many).
    A similar change is also applied to an INSERT..VALUES with multiple parameter
    sets; implicit RETURNING will no longer emit for this statement either. As both
    of these constructs deal with variable numbers of rows, the `ResultProxy.inserted_primary_key`
    accessor does not apply. Previously, there was a documentation note that one may
    prefer `inline=True` with INSERT..FROM SELECT as some databases don’t support
    returning and therefore can’t do “implicit” returning, but there’s no reason an
    INSERT…FROM SELECT needs implicit returning in any case. Regular explicit [`Insert.returning()`](../core/dml.html#sqlalchemy.sql.expression.Insert.returning
    "sqlalchemy.sql.expression.Insert.returning") should be used to return variable
    numbers of result rows if inserted data is needed.
  id: totrans-1230
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[`Insert.from_select()`](../core/dml.html#sqlalchemy.sql.expression.Insert.from_select
    "sqlalchemy.sql.expression.Insert.from_select")现在意味着在[`insert()`](../core/dml.html#sqlalchemy.sql.expression.insert
    "sqlalchemy.sql.expression.insert")上隐含`inline=True`。这有助于修复一个bug，即在支持的后端上，INSERT…FROM
    SELECT结构会被错误地编译为“隐式返回”，这会导致在插入零行的情况下出现故障（因为隐式返回期望一行），以及在插入多行的情况下出现任意返回数据（例如，只有许多行中的第一行）。类似的更改也适用于具有多个参数集的INSERT..VALUES；对于此语句，隐式RETURNING也不再发出。由于这两个结构处理可变数量的行，因此`ResultProxy.inserted_primary_key`访问器不适用。以前，有一个文档注释，即对于INSERT..FROM
    SELECT，可能更喜欢使用`inline=True`，因为一些数据库不支持返回，因此无法进行“隐式”返回，但无论如何，INSERT…FROM SELECT都不需要隐式返回。如果需要返回插入的数据的可变数量的结果行，则应使用常规的显式[`Insert.returning()`](../core/dml.html#sqlalchemy.sql.expression.Insert.returning
    "sqlalchemy.sql.expression.Insert.returning")。
- en: '[#3169](https://www.sqlalchemy.org/trac/ticket/3169)  ### `autoload_with` now
    implies `autoload=True`'
  id: totrans-1231
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3169](https://www.sqlalchemy.org/trac/ticket/3169)  ### `autoload_with`现在意味着`autoload=True`'
- en: 'A [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    can be set up for reflection by passing [`Table.autoload_with`](../core/metadata.html#sqlalchemy.schema.Table.params.autoload_with
    "sqlalchemy.schema.Table") alone:'
  id: totrans-1232
  prefs: []
  type: TYPE_NORMAL
  zh: 通过仅传递 [`Table.autoload_with`](../core/metadata.html#sqlalchemy.schema.Table.params.autoload_with
    "sqlalchemy.schema.Table") ，可以设置一个 [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") 进行反射：
- en: '[PRE342]'
  id: totrans-1233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE342]'
- en: '[#3027](https://www.sqlalchemy.org/trac/ticket/3027)  ### DBAPI exception wrapping
    and handle_error() event improvements'
  id: totrans-1234
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3027](https://www.sqlalchemy.org/trac/ticket/3027)  ### DBAPI 异常封装和 handle_error()
    事件改进'
- en: SQLAlchemy’s wrapping of DBAPI exceptions was not taking place in the case where
    a [`Connection`](../core/connections.html#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    object was invalidated, and then tried to reconnect and encountered an error;
    this has been resolved.
  id: totrans-1235
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 对 DBAPI 异常的封装在以下情况下未发生：当一个 [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") 对象被失效，然后尝试重新连接并遇到错误时；这个问题已经解决了。
- en: Additionally, the recently added `ConnectionEvents.handle_error()` event is
    now invoked for errors that occur upon initial connect, upon reconnect, and when
    [`create_engine()`](../core/engines.html#sqlalchemy.create_engine "sqlalchemy.create_engine")
    is used given a custom connection function via [`create_engine.creator`](../core/engines.html#sqlalchemy.create_engine.params.creator
    "sqlalchemy.create_engine").
  id: totrans-1236
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，最近添加的 `ConnectionEvents.handle_error()` 事件现在会在初始连接时、重新连接时以及通过 [`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine") 使用自定义连接函数时（通过 [`create_engine.creator`](../core/engines.html#sqlalchemy.create_engine.params.creator
    "sqlalchemy.create_engine") ）调用。
- en: The [`ExceptionContext`](../core/connections.html#sqlalchemy.engine.ExceptionContext
    "sqlalchemy.engine.ExceptionContext") object has a new datamember [`ExceptionContext.engine`](../core/connections.html#sqlalchemy.engine.ExceptionContext.engine
    "sqlalchemy.engine.ExceptionContext.engine") that will always refer to the [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") in use, in those cases when the [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") object is not available (e.g. on initial connect).
  id: totrans-1237
  prefs: []
  type: TYPE_NORMAL
  zh: '[`ExceptionContext`](../core/connections.html#sqlalchemy.engine.ExceptionContext
    "sqlalchemy.engine.ExceptionContext") 对象现在有一个新的数据成员 [`ExceptionContext.engine`](../core/connections.html#sqlalchemy.engine.ExceptionContext.engine
    "sqlalchemy.engine.ExceptionContext.engine") ，在那些 [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") 对象不可用的情况下（例如在初始连接时）将始终引用正在使用的 [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") 。'
- en: '[#3266](https://www.sqlalchemy.org/trac/ticket/3266)  ### ForeignKeyConstraint.columns
    is now a ColumnCollection'
  id: totrans-1238
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3266](https://www.sqlalchemy.org/trac/ticket/3266)  ### ForeignKeyConstraint.columns
    现在是 ColumnCollection'
- en: '[`ForeignKeyConstraint.columns`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint.columns
    "sqlalchemy.schema.ForeignKeyConstraint.columns") was previously a plain list
    containing either strings or [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects, depending on how the [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") was constructed and whether it was associated
    with a table. The collection is now a [`ColumnCollection`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnCollection
    "sqlalchemy.sql.expression.ColumnCollection"), and is only initialized after the
    [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") is associated with a [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table"). A new accessor [`ForeignKeyConstraint.column_keys`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint.column_keys
    "sqlalchemy.schema.ForeignKeyConstraint.column_keys") is added to unconditionally
    return string keys for the local set of columns regardless of how the object was
    constructed or its current state.  ### MetaData.sorted_tables accessor is “deterministic”'
  id: totrans-1239
  prefs: []
  type: TYPE_NORMAL
  zh: '[`ForeignKeyConstraint.columns`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint.columns
    "sqlalchemy.schema.ForeignKeyConstraint.columns")以前是一个普通列表，其中包含字符串或根据[`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint")如何构建以及是否与表关联而包含[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")对象。该集合现在是一个[`ColumnCollection`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnCollection
    "sqlalchemy.sql.expression.ColumnCollection")，并且仅在[`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint")与[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")关联后才初始化。添加了一个新的访问器[`ForeignKeyConstraint.column_keys`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint.column_keys
    "sqlalchemy.schema.ForeignKeyConstraint.column_keys")，无条件地返回本地列集的字符串键，而不管对象是如何构建的或其当前状态如何。###
    MetaData.sorted_tables 访问器是“确定性的”'
- en: The sorting of tables resulting from the [`MetaData.sorted_tables`](../core/metadata.html#sqlalchemy.schema.MetaData.sorted_tables
    "sqlalchemy.schema.MetaData.sorted_tables") accessor is “deterministic”; the ordering
    should be the same in all cases regardless of Python hashing. This is done by
    first sorting the tables by name before passing them to the topological algorithm,
    which maintains that ordering as it iterates.
  id: totrans-1240
  prefs: []
  type: TYPE_NORMAL
  zh: 由[`MetaData.sorted_tables`](../core/metadata.html#sqlalchemy.schema.MetaData.sorted_tables
    "sqlalchemy.schema.MetaData.sorted_tables")访问器导致的表的排序是“确定性的”；无论Python哈希如何，排序在所有情况下都应该相同。这是通过首先按名称对表进行排序，然后将它们传递给拓扑算法来实现的，该算法在迭代时保持该顺序。
- en: Note that this change does **not** yet apply to the ordering applied when emitting
    [`MetaData.create_all()`](../core/metadata.html#sqlalchemy.schema.MetaData.create_all
    "sqlalchemy.schema.MetaData.create_all") or [`MetaData.drop_all()`](../core/metadata.html#sqlalchemy.schema.MetaData.drop_all
    "sqlalchemy.schema.MetaData.drop_all").
  id: totrans-1241
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这种变化**尚未**应用于在发出[`MetaData.create_all()`](../core/metadata.html#sqlalchemy.schema.MetaData.create_all
    "sqlalchemy.schema.MetaData.create_all")或[`MetaData.drop_all()`](../core/metadata.html#sqlalchemy.schema.MetaData.drop_all
    "sqlalchemy.schema.MetaData.drop_all")时应用的顺序。
- en: '[#3084](https://www.sqlalchemy.org/trac/ticket/3084)  ### null(), false() and
    true() constants are no longer singletons'
  id: totrans-1242
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3084](https://www.sqlalchemy.org/trac/ticket/3084)### null()、false()和true()常量不再是单例'
- en: 'These three constants were changed to return a “singleton” value in 0.9; unfortunately,
    that would lead to a query like the following to not render as expected:'
  id: totrans-1243
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个常量在0.9中被更改为返回“单例”值；不幸的是，这会导致以下查询无法按预期渲染：
- en: '[PRE343]'
  id: totrans-1244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE343]'
- en: rendering only `SELECT NULL AS anon_1`, because the two [`null()`](../core/sqlelement.html#sqlalchemy.sql.expression.null
    "sqlalchemy.sql.expression.null") constructs would come out as the same `NULL`
    object, and SQLAlchemy’s Core model is based on object identity in order to determine
    lexical significance. The change in 0.9 had no importance other than the desire
    to save on object overhead; in general, an unnamed construct needs to stay lexically
    unique so that it gets labeled uniquely.
  id: totrans-1245
  prefs: []
  type: TYPE_NORMAL
  zh: 仅渲染`SELECT NULL AS anon_1`，因为两个[`null()`](../core/sqlelement.html#sqlalchemy.sql.expression.null
    "sqlalchemy.sql.expression.null")构造将输出相同的`NULL`对象，而SQLAlchemy的核心模型基于对象标识来确定词法重要性。0.9中的更改除了希望节省对象开销外并无重要性；通常，未命名的构造需要保持词法上的唯一性，以便被唯一标记。
- en: '[#3170](https://www.sqlalchemy.org/trac/ticket/3170)  ### SQLite/Oracle have
    distinct methods for temporary table/view name reporting'
  id: totrans-1246
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3170](https://www.sqlalchemy.org/trac/ticket/3170)### SQLite/Oracle有用于临时表/视图名称报告的不同方法'
- en: The [`Inspector.get_table_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_table_names
    "sqlalchemy.engine.reflection.Inspector.get_table_names") and [`Inspector.get_view_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_view_names
    "sqlalchemy.engine.reflection.Inspector.get_view_names") methods in the case of
    SQLite/Oracle would also return the names of temporary tables and views, which
    is not provided by any other dialect (in the case of MySQL at least it is not
    even possible). This logic has been moved out to two new methods [`Inspector.get_temp_table_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_temp_table_names
    "sqlalchemy.engine.reflection.Inspector.get_temp_table_names") and [`Inspector.get_temp_view_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_temp_view_names
    "sqlalchemy.engine.reflection.Inspector.get_temp_view_names").
  id: totrans-1247
  prefs: []
  type: TYPE_NORMAL
  zh: '[`Inspector.get_table_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_table_names
    "sqlalchemy.engine.reflection.Inspector.get_table_names") 和 [`Inspector.get_view_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_view_names
    "sqlalchemy.engine.reflection.Inspector.get_view_names") 方法在 SQLite/Oracle 的情况下也会返回临时表和视图的名称，这是任何其他方言都不提供的（至少在
    MySQL 的情况下甚至不可能）。这一逻辑已经移出到两个新方法 [`Inspector.get_temp_table_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_temp_table_names
    "sqlalchemy.engine.reflection.Inspector.get_temp_table_names") 和 [`Inspector.get_temp_view_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_temp_view_names
    "sqlalchemy.engine.reflection.Inspector.get_temp_view_names")。'
- en: Note that reflection of a specific named temporary table or temporary view,
    either by `Table('name', autoload=True)` or via methods like [`Inspector.get_columns()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_columns
    "sqlalchemy.engine.reflection.Inspector.get_columns") continues to function for
    most if not all dialects. For SQLite specifically, there is a bug fix for UNIQUE
    constraint reflection from temp tables as well, which is [#3203](https://www.sqlalchemy.org/trac/ticket/3203).
  id: totrans-1248
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，对于大多数方言，反射特定命名的临时表或临时视图，无论是通过 `Table('name', autoload=True)` 还是通过 [`Inspector.get_columns()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_columns
    "sqlalchemy.engine.reflection.Inspector.get_columns") 等方法，继续正常运行。特别是对于 SQLite，还修复了从临时表中反射
    UNIQUE 约束的 bug，即 [#3203](https://www.sqlalchemy.org/trac/ticket/3203)。
- en: '[#3204](https://www.sqlalchemy.org/trac/ticket/3204)  ### Warnings emitted
    when coercing full SQL fragments into text()'
  id: totrans-1249
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3204](https://www.sqlalchemy.org/trac/ticket/3204)  ### 当将完整的 SQL 片段强制转换为文本时发出警告'
- en: Since SQLAlchemy’s inception, there has always been an emphasis on not getting
    in the way of the usage of plain text. The Core and ORM expression systems were
    intended to allow any number of points at which the user can just use plain text
    SQL expressions, not just in the sense that you can send a full SQL string to
    [`Connection.execute()`](../core/connections.html#sqlalchemy.engine.Connection.execute
    "sqlalchemy.engine.Connection.execute"), but that you can send strings with SQL
    expressions into many functions, such as [`Select.where()`](../core/selectable.html#sqlalchemy.sql.expression.Select.where
    "sqlalchemy.sql.expression.Select.where"), [`Query.filter()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.filter
    "sqlalchemy.orm.Query.filter"), and [`Select.order_by()`](../core/selectable.html#sqlalchemy.sql.expression.Select.order_by
    "sqlalchemy.sql.expression.Select.order_by").
  id: totrans-1250
  prefs: []
  type: TYPE_NORMAL
  zh: 自 SQLAlchemy 创建以来，始终强调不妨碍使用纯文本的方式。核心和 ORM 表达系统旨在允许用户在任何时候使用纯文本 SQL 表达式，不仅仅是可以将完整的
    SQL 字符串发送给 [`Connection.execute()`](../core/connections.html#sqlalchemy.engine.Connection.execute
    "sqlalchemy.engine.Connection.execute")，还可以将带有 SQL 表达式的字符串发送到许多函数中，例如 [`Select.where()`](../core/selectable.html#sqlalchemy.sql.expression.Select.where
    "sqlalchemy.sql.expression.Select.where")，[`Query.filter()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.filter
    "sqlalchemy.orm.Query.filter") 和 [`Select.order_by()`](../core/selectable.html#sqlalchemy.sql.expression.Select.order_by
    "sqlalchemy.sql.expression.Select.order_by")。
- en: 'Note that by “SQL expressions” we mean a **full fragment of a SQL string**,
    such as:'
  id: totrans-1251
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，“SQL表达式”指的是**完整的 SQL 字符串片段**，例如：
- en: '[PRE344]'
  id: totrans-1252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE344]'
- en: 'and we are **not talking about string arguments**, that is, the normal behavior
    of passing string values that become parameterized:'
  id: totrans-1253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们并**不是在讨论字符串参数**，也就是传递字符串值并变成参数化的正常行为：
- en: '[PRE345]'
  id: totrans-1254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE345]'
- en: The Core tutorial has long featured an example of the use of this technique,
    using a [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") construct where virtually all components of
    it are specified as straight strings. However, despite this long-standing behavior
    and example, users are apparently surprised that this behavior exists, and when
    asking around the community, I was unable to find any user that was in fact *not*
    surprised that you can send a full string into a method like [`Query.filter()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.filter
    "sqlalchemy.orm.Query.filter").
  id: totrans-1255
  prefs: []
  type: TYPE_NORMAL
  zh: 核心教程长期以来一直展示了使用这种技术的示例，使用了[`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select")构造，其中几乎所有组件都被指定为直接字符串。然而，尽管有这种长期存在的行为和示例，用户显然对此行为感到惊讶，当在社区中询问时，我无法找到任何一个用户实际上*不*感到惊讶的，即您可以将完整的字符串发送到[`Query.filter()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.filter
    "sqlalchemy.orm.Query.filter")等方法中。
- en: 'So the change here is to encourage the user to qualify textual strings when
    composing SQL that is partially or fully composed from textual fragments. When
    composing a select as below:'
  id: totrans-1256
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这里的变化是鼓励用户在从文本片段部分或完全组成的SQL中组合文本字符串时进行限定。当如下组合选择时：
- en: '[PRE346]'
  id: totrans-1257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE346]'
- en: 'The statement is built up normally, with all the same coercions as before.
    However, one will see the following warnings emitted:'
  id: totrans-1258
  prefs: []
  type: TYPE_NORMAL
  zh: 语句按照通常的方式构建，具有与以前相同的强制转换。然而，你会看到以下警告被发出：
- en: '[PRE347]'
  id: totrans-1259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE347]'
- en: 'These warnings attempt to show exactly where the issue is by displaying the
    parameters as well as where the string was received. The warnings make use of
    the [Session.get_bind() handles a wider variety of inheritance scenarios](#feature-3178)
    so that parameterized warnings can be emitted safely without running out of memory,
    and as always, if one wishes the warnings to be exceptions, the [Python Warnings
    Filter](https://docs.python.org/2/library/warnings.html) should be used:'
  id: totrans-1260
  prefs: []
  type: TYPE_NORMAL
  zh: 这些警告试图通过显示参数以及字符串接收位置的方式准确指出问题所在。这些警告利用了[会话.get_bind()处理更广泛的继承场景](#feature-3178)，以便可以安全地发出参数化警告，而不会耗尽内存。如往常一样，如果希望将警告作为异常处理，应该使用[Python警告过滤器](https://docs.python.org/2/library/warnings.html)：
- en: '[PRE348]'
  id: totrans-1261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE348]'
- en: 'Given the above warnings, our statement works just fine, but to get rid of
    the warnings we would rewrite our statement as follows:'
  id: totrans-1262
  prefs: []
  type: TYPE_NORMAL
  zh: 给出上述警告，我们的语句运行良好，但要消除警告，我们需要重写我们的语句如下：
- en: '[PRE349]'
  id: totrans-1263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE349]'
- en: 'and as the warnings suggest, we can give our statement more specificity about
    the text if we use [`column()`](../core/sqlelement.html#sqlalchemy.sql.expression.column
    "sqlalchemy.sql.expression.column") and [`table()`](../core/selectable.html#sqlalchemy.sql.expression.table
    "sqlalchemy.sql.expression.table"):'
  id: totrans-1264
  prefs: []
  type: TYPE_NORMAL
  zh: 正如警告所建议的那样，如果我们使用[`column()`](../core/sqlelement.html#sqlalchemy.sql.expression.column
    "sqlalchemy.sql.expression.column")和[`table()`](../core/selectable.html#sqlalchemy.sql.expression.table
    "sqlalchemy.sql.expression.table")，我们可以对语句的文本给予更多的具体性：
- en: '[PRE350]'
  id: totrans-1265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE350]'
- en: Where note also that [`table()`](../core/selectable.html#sqlalchemy.sql.expression.table
    "sqlalchemy.sql.expression.table") and [`column()`](../core/sqlelement.html#sqlalchemy.sql.expression.column
    "sqlalchemy.sql.expression.column") can now be imported from “sqlalchemy” without
    the “sql” part.
  id: totrans-1266
  prefs: []
  type: TYPE_NORMAL
  zh: 还请注意，现在可以从“sqlalchemy”中导入[`table()`](../core/selectable.html#sqlalchemy.sql.expression.table
    "sqlalchemy.sql.expression.table")和[`column()`](../core/sqlelement.html#sqlalchemy.sql.expression.column
    "sqlalchemy.sql.expression.column")而不需要“sql”部分。
- en: The behavior here applies to [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") as well as to key methods on [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query"), including [`Query.filter()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.filter
    "sqlalchemy.orm.Query.filter"), [`Query.from_statement()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.from_statement
    "sqlalchemy.orm.Query.from_statement") and [`Query.having()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.having
    "sqlalchemy.orm.Query.having").
  id: totrans-1267
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的行为适用于[`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select")以及[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")的关键方法，包括[`Query.filter()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.filter
    "sqlalchemy.orm.Query.filter")、[`Query.from_statement()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.from_statement
    "sqlalchemy.orm.Query.from_statement")和[`Query.having()`](../orm/queryguide/query.html#sqlalchemy.orm.Query.having
    "sqlalchemy.orm.Query.having")。
- en: ORDER BY and GROUP BY are special cases
  id: totrans-1268
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: ORDER BY和GROUP BY是特例
- en: 'There is one case where usage of a string has special meaning, and as part
    of this change we have enhanced its functionality. When we have a [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") or [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") that refers to some column name or named label, we might
    want to GROUP BY and/or ORDER BY known columns or labels:'
  id: totrans-1269
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种情况下，使用字符串具有特殊含义，并且作为这种更改的一部分，我们已经增强了其功能。当我们有一个[`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select")或[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")引用某个列名或命名标签时，我们可能希望按已知列或标签进行分组和/或排序：
- en: '[PRE351]'
  id: totrans-1270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE351]'
- en: 'In the above statement we expect to see “ORDER BY id_count”, as opposed to
    a re-statement of the function. The string argument given is actively matched
    to an entry in the columns clause during compilation, so the above statement would
    produce as we expect, without warnings (though note that the `"name"` expression
    has been resolved to `users.name`!):'
  id: totrans-1271
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述语句中，我们期望看到“ORDER BY id_count”，而不是函数的重新声明。在编译过程中，给定的字符串参数会被主动匹配到列子句中的条目，因此上述语句会按我们的期望产生结果，没有警告（尽管请注意`"name"`表达式已解析为`users.name`！）：
- en: '[PRE352]'
  id: totrans-1272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE352]'
- en: 'However, if we refer to a name that cannot be located, then we get the warning
    again, as below:'
  id: totrans-1273
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们引用一个无法找到的名称，那么我们会再次收到警告，如下所示：
- en: '[PRE353]'
  id: totrans-1274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE353]'
- en: 'The output does what we say, but again it warns us:'
  id: totrans-1275
  prefs: []
  type: TYPE_NORMAL
  zh: 输出确实按我们说的做了，但再次警告我们：
- en: '[PRE354]'
  id: totrans-1276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE354]'
- en: '[PRE355]'
  id: totrans-1277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE355]'
- en: The above behavior applies to all those places where we might want to refer
    to a so-called “label reference”; ORDER BY and GROUP BY, but also within an OVER
    clause as well as a DISTINCT ON clause that refers to columns (e.g. the PostgreSQL
    syntax).
  id: totrans-1278
  prefs: []
  type: TYPE_NORMAL
  zh: 上述行为适用于所有那些我们可能想要引用所谓的“标签引用”的地方；ORDER BY和GROUP BY，还有在OVER子句中以及引用列的DISTINCT ON子句中（例如PostgreSQL语法）。
- en: 'We can still specify any arbitrary expression for ORDER BY or others using
    [`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text "sqlalchemy.sql.expression.text"):'
  id: totrans-1279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然可以使用[`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text "sqlalchemy.sql.expression.text")指定任意表达式用于ORDER
    BY或其他操作：
- en: '[PRE356]'
  id: totrans-1280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE356]'
- en: The upshot of the whole change is that SQLAlchemy now would like us to tell
    it when a string is sent that this string is explicitly a [`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text
    "sqlalchemy.sql.expression.text") construct, or a column, table, etc., and if
    we use it as a label name in an order by, group by, or other expression, SQLAlchemy
    expects that the string resolves to something known, else it should again be qualified
    with [`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text "sqlalchemy.sql.expression.text")
    or similar.
  id: totrans-1281
  prefs: []
  type: TYPE_NORMAL
  zh: 整个更改的要点是，现在SQLAlchemy希望我们告诉它，当发送一个字符串时，这个字符串明确是一个[`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text
    "sqlalchemy.sql.expression.text")构造，或者是一个列、表等，如果我们将其用作order by、group by或其他表达式中的标签名称，SQLAlchemy期望该字符串解析为已知内容，否则应再次使用[`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text
    "sqlalchemy.sql.expression.text")或类似内容进行限定。
- en: '[#2992](https://www.sqlalchemy.org/trac/ticket/2992)'
  id: totrans-1282
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2992](https://www.sqlalchemy.org/trac/ticket/2992)'
- en: ORDER BY and GROUP BY are special cases
  id: totrans-1283
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: ORDER BY和GROUP BY是特殊情况
- en: 'There is one case where usage of a string has special meaning, and as part
    of this change we have enhanced its functionality. When we have a [`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select") or [`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query") that refers to some column name or named label, we might
    want to GROUP BY and/or ORDER BY known columns or labels:'
  id: totrans-1284
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种情况下，使用字符串具有特殊含义，并且作为这种更改的一部分，我们已经增强了其功能。当我们有一个[`select()`](../core/selectable.html#sqlalchemy.sql.expression.select
    "sqlalchemy.sql.expression.select")或[`Query`](../orm/queryguide/query.html#sqlalchemy.orm.Query
    "sqlalchemy.orm.Query")引用某个列名或命名标签时，我们可能希望按已知列或标签进行分组和/或排序：
- en: '[PRE357]'
  id: totrans-1285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE357]'
- en: 'In the above statement we expect to see “ORDER BY id_count”, as opposed to
    a re-statement of the function. The string argument given is actively matched
    to an entry in the columns clause during compilation, so the above statement would
    produce as we expect, without warnings (though note that the `"name"` expression
    has been resolved to `users.name`!):'
  id: totrans-1286
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述语句中，我们期望看到“ORDER BY id_count”，而不是函数的重新声明。在编译过程中，给定的字符串参数会被主动匹配到列子句中的条目，因此上述语句会按我们的期望产生结果，���有警告（尽管请注意`"name"`表达式已解析为`users.name`！）：
- en: '[PRE358]'
  id: totrans-1287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE358]'
- en: 'However, if we refer to a name that cannot be located, then we get the warning
    again, as below:'
  id: totrans-1288
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们引用一个无法找到的名称，那么我们会再次收到警告，如下所示：
- en: '[PRE359]'
  id: totrans-1289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE359]'
- en: 'The output does what we say, but again it warns us:'
  id: totrans-1290
  prefs: []
  type: TYPE_NORMAL
  zh: 输出确实按我们说的做了，但再次警告我们：
- en: '[PRE360]'
  id: totrans-1291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE360]'
- en: '[PRE361]'
  id: totrans-1292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE361]'
- en: The above behavior applies to all those places where we might want to refer
    to a so-called “label reference”; ORDER BY and GROUP BY, but also within an OVER
    clause as well as a DISTINCT ON clause that refers to columns (e.g. the PostgreSQL
    syntax).
  id: totrans-1293
  prefs: []
  type: TYPE_NORMAL
  zh: 上述行为适用于所有那些我们可能想要引用所谓的“标签引用”的地方；ORDER BY 和 GROUP BY，还有在 OVER 子句以及引用列的 DISTINCT
    ON 子句中（例如 PostgreSQL 语法）。
- en: 'We can still specify any arbitrary expression for ORDER BY or others using
    [`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text "sqlalchemy.sql.expression.text"):'
  id: totrans-1294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然可以使用[`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text "sqlalchemy.sql.expression.text")指定任意表达式用于
    ORDER BY 或其他操作：
- en: '[PRE362]'
  id: totrans-1295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE362]'
- en: The upshot of the whole change is that SQLAlchemy now would like us to tell
    it when a string is sent that this string is explicitly a [`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text
    "sqlalchemy.sql.expression.text") construct, or a column, table, etc., and if
    we use it as a label name in an order by, group by, or other expression, SQLAlchemy
    expects that the string resolves to something known, else it should again be qualified
    with [`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text "sqlalchemy.sql.expression.text")
    or similar.
  id: totrans-1296
  prefs: []
  type: TYPE_NORMAL
  zh: 整个变化的结果是，SQLAlchemy 现在希望我们告诉它当发送一个字符串时，这个字符串明确是一个[`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text
    "sqlalchemy.sql.expression.text") 构造，或者一个列、表等，如果我们将其用作 ORDER BY、GROUP BY 或其他表达式中的标签名称，SQLAlchemy
    期望该字符串解析为已知的内容，否则应再次使用[`text()`](../core/sqlelement.html#sqlalchemy.sql.expression.text
    "sqlalchemy.sql.expression.text") 或类似的进行限定。
- en: '[#2992](https://www.sqlalchemy.org/trac/ticket/2992)'
  id: totrans-1297
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2992](https://www.sqlalchemy.org/trac/ticket/2992)'
- en: '### Python-side defaults invoked for each row individually when using a multivalued
    insert'
  id: totrans-1298
  prefs: []
  type: TYPE_NORMAL
  zh: '### 当使用多值插入时，为每一行分别调用 Python 端默认值'
- en: Support for Python-side column defaults when using the multi-valued version
    of [`Insert.values()`](../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values") were essentially not implemented, and
    would only work “by accident” in specific situations, when the dialect in use
    was using a non-positional (e.g. named) style of bound parameter, and when it
    was not necessary that a Python-side callable be invoked for each row.
  id: totrans-1299
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用多值版本的[`Insert.values()`](../core/dml.html#sqlalchemy.sql.expression.Insert.values
    "sqlalchemy.sql.expression.Insert.values")时，对于 Python 端列默认值的支持基本上没有实现，并且只会在特定情况下“偶然”起作用，当使用的方言采用非位置（例如命名）风格的绑定参数时，并且不需要为每一行调用
    Python 端可调用函数时。
- en: 'The feature has been overhauled so that it works more similarly to that of
    an “executemany” style of invocation:'
  id: totrans-1300
  prefs: []
  type: TYPE_NORMAL
  zh: 该功能已经进行了改进，使其更类似于“executemany”风格的调用：
- en: '[PRE363]'
  id: totrans-1301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE363]'
- en: 'The above example will invoke `next(counter)` for each row individually as
    would be expected:'
  id: totrans-1302
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的示例将为每一行分别调用`next(counter)`，正如预期的那样：
- en: '[PRE364]'
  id: totrans-1303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE364]'
- en: 'Previously, a positional dialect would fail as a bind would not be generated
    for additional positions:'
  id: totrans-1304
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，位置方言会失败，因为不会为额外的位置生成绑定：
- en: '[PRE365]'
  id: totrans-1305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE365]'
- en: 'And with a “named” dialect, the same value for “id” would be re-used in each
    row (hence this change is backwards-incompatible with a system that relied on
    this):'
  id: totrans-1306
  prefs: []
  type: TYPE_NORMAL
  zh: 并且使用“命名”方言时，“id” 的相同值将在每一行中重新使用（因此这个改变与依赖于此的系统不兼容）：
- en: '[PRE366]'
  id: totrans-1307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE366]'
- en: 'The system will also refuse to invoke a “server side” default as inline-rendered
    SQL, since it cannot be guaranteed that a server side default is compatible with
    this. If the VALUES clause renders for a specific column, then a Python-side value
    is required; if an omitted value only refers to a server-side default, an exception
    is raised:'
  id: totrans-1308
  prefs: []
  type: TYPE_NORMAL
  zh: 该系统还会拒绝将“服务器端”默认值作为内联渲染的 SQL 调用，因为无法保证服务器端默认值与此兼容。如果 VALUES 子句为特定列渲染，则需要一个 Python
    端值；如果省略的值只是引用服务器端默认值，则会引发异常：
- en: '[PRE367]'
  id: totrans-1309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE367]'
- en: 'will raise:'
  id: totrans-1310
  prefs: []
  type: TYPE_NORMAL
  zh: 将引发：
- en: '[PRE368]'
  id: totrans-1311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE368]'
- en: 'Previously, the value “d1” would be copied into that of the third row (but
    again, only with named format!):'
  id: totrans-1312
  prefs: []
  type: TYPE_NORMAL
  zh: 以前，“d1” 的值会被复制到第三行的值中（但仅适用于命名格式！）：
- en: '[PRE369]'
  id: totrans-1313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE369]'
- en: '[#3288](https://www.sqlalchemy.org/trac/ticket/3288)'
  id: totrans-1314
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3288](https://www.sqlalchemy.org/trac/ticket/3288)'
- en: '### Event listeners can not be added or removed from within that event’s runner'
  id: totrans-1315
  prefs: []
  type: TYPE_NORMAL
  zh: '### 事件监听器不能在该事件的运行程序内添加或移除'
- en: Removal of an event listener from inside that same event itself would modify
    the elements of a list during iteration, which would cause still-attached event
    listeners to silently fail to fire. To prevent this while still maintaining performance,
    the lists have been replaced with `collections.deque()`, which does not allow
    any additions or removals during iteration, and instead raises `RuntimeError`.
  id: totrans-1316
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一事件中从内部移除事件侦听器会在迭代过程中修改列表的元素，这将导致仍然附加的事件侦听器无法静默触发。为了防止这种情况，同时保持性能，列表已被替换为
    `collections.deque()`，在迭代过程中不允许添加或删除，并且会引发 `RuntimeError`。
- en: '[#3163](https://www.sqlalchemy.org/trac/ticket/3163)'
  id: totrans-1317
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3163](https://www.sqlalchemy.org/trac/ticket/3163)'
- en: '### The INSERT…FROM SELECT construct now implies `inline=True`'
  id: totrans-1318
  prefs: []
  type: TYPE_NORMAL
  zh: '### INSERT…FROM SELECT 结构现在意味着 `inline=True`'
- en: Using [`Insert.from_select()`](../core/dml.html#sqlalchemy.sql.expression.Insert.from_select
    "sqlalchemy.sql.expression.Insert.from_select") now implies `inline=True` on [`insert()`](../core/dml.html#sqlalchemy.sql.expression.insert
    "sqlalchemy.sql.expression.insert"). This helps to fix a bug where an INSERT…FROM
    SELECT construct would inadvertently be compiled as “implicit returning” on supporting
    backends, which would cause breakage in the case of an INSERT that inserts zero
    rows (as implicit returning expects a row), as well as arbitrary return data in
    the case of an INSERT that inserts multiple rows (e.g. only the first row of many).
    A similar change is also applied to an INSERT..VALUES with multiple parameter
    sets; implicit RETURNING will no longer emit for this statement either. As both
    of these constructs deal with variable numbers of rows, the `ResultProxy.inserted_primary_key`
    accessor does not apply. Previously, there was a documentation note that one may
    prefer `inline=True` with INSERT..FROM SELECT as some databases don’t support
    returning and therefore can’t do “implicit” returning, but there’s no reason an
    INSERT…FROM SELECT needs implicit returning in any case. Regular explicit [`Insert.returning()`](../core/dml.html#sqlalchemy.sql.expression.Insert.returning
    "sqlalchemy.sql.expression.Insert.returning") should be used to return variable
    numbers of result rows if inserted data is needed.
  id: totrans-1319
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 [`Insert.from_select()`](../core/dml.html#sqlalchemy.sql.expression.Insert.from_select
    "sqlalchemy.sql.expression.Insert.from_select") 时，现在会隐含 `inline=True` 在 [`insert()`](../core/dml.html#sqlalchemy.sql.expression.insert
    "sqlalchemy.sql.expression.insert") 上。这有助于修复一个 bug，即 INSERT…FROM SELECT 结构会在支持的后端意外地被编译为“implicit
    returning”，这会导致在插入零行的情况下出现故障（因为 implicit returning 需要一行），以及在插入多行的情况下出现任意返回数据（例如，多行中的第一行）。类似的更改也适用于具有多个参数集的
    INSERT..VALUES；此语句也不再发出 implicit RETURNING。由于这两个结构处理可变数量的行，因此 `ResultProxy.inserted_primary_key`
    访问器不适用。以前，有一个文档说明，即在某些数据库不支持返回并且因此无法执行“implicit”返回的情况下，可能更喜欢使用 `inline=True` 与
    INSERT..FROM SELECT，但无论如何，INSERT…FROM SELECT 都不需要 implicit returning。如果需要返回插入数据的可变数量的结果行，则应使用常规的显式
    [`Insert.returning()`](../core/dml.html#sqlalchemy.sql.expression.Insert.returning
    "sqlalchemy.sql.expression.Insert.returning")。
- en: '[#3169](https://www.sqlalchemy.org/trac/ticket/3169)'
  id: totrans-1320
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3169](https://www.sqlalchemy.org/trac/ticket/3169)'
- en: '### `autoload_with` now implies `autoload=True`'
  id: totrans-1321
  prefs: []
  type: TYPE_NORMAL
  zh: '### `autoload_with` 现在意味着 `autoload=True`'
- en: 'A [`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")
    can be set up for reflection by passing [`Table.autoload_with`](../core/metadata.html#sqlalchemy.schema.Table.params.autoload_with
    "sqlalchemy.schema.Table") alone:'
  id: totrans-1322
  prefs: []
  type: TYPE_NORMAL
  zh: 通过仅传递 [`Table.autoload_with`](../core/metadata.html#sqlalchemy.schema.Table.params.autoload_with
    "sqlalchemy.schema.Table")，可以为 [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") 设置反射：
- en: '[PRE370]'
  id: totrans-1323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE370]'
- en: '[#3027](https://www.sqlalchemy.org/trac/ticket/3027)'
  id: totrans-1324
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3027](https://www.sqlalchemy.org/trac/ticket/3027)'
- en: '### DBAPI exception wrapping and handle_error() event improvements'
  id: totrans-1325
  prefs: []
  type: TYPE_NORMAL
  zh: '### DBAPI 异常包装和 handle_error() 事件改进'
- en: SQLAlchemy’s wrapping of DBAPI exceptions was not taking place in the case where
    a [`Connection`](../core/connections.html#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    object was invalidated, and then tried to reconnect and encountered an error;
    this has been resolved.
  id: totrans-1326
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [`Connection`](../core/connections.html#sqlalchemy.engine.Connection "sqlalchemy.engine.Connection")
    对象失效并尝试重新连接并遇到错误的情况下，SQLAlchemy 对 DBAPI 异常的包装未发生，这个问题已经解决。
- en: Additionally, the recently added `ConnectionEvents.handle_error()` event is
    now invoked for errors that occur upon initial connect, upon reconnect, and when
    [`create_engine()`](../core/engines.html#sqlalchemy.create_engine "sqlalchemy.create_engine")
    is used given a custom connection function via [`create_engine.creator`](../core/engines.html#sqlalchemy.create_engine.params.creator
    "sqlalchemy.create_engine").
  id: totrans-1327
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，最近添加的`ConnectionEvents.handle_error()`事件现在在初始连接时、重新连接时以及通过[`create_engine()`](../core/engines.html#sqlalchemy.create_engine
    "sqlalchemy.create_engine")给定自定义连接函数时通过[`create_engine.creator`](../core/engines.html#sqlalchemy.create_engine.params.creator
    "sqlalchemy.create_engine")调用。
- en: The [`ExceptionContext`](../core/connections.html#sqlalchemy.engine.ExceptionContext
    "sqlalchemy.engine.ExceptionContext") object has a new datamember [`ExceptionContext.engine`](../core/connections.html#sqlalchemy.engine.ExceptionContext.engine
    "sqlalchemy.engine.ExceptionContext.engine") that will always refer to the [`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine") in use, in those cases when the [`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection") object is not available (e.g. on initial connect).
  id: totrans-1328
  prefs: []
  type: TYPE_NORMAL
  zh: '[`ExceptionContext`](../core/connections.html#sqlalchemy.engine.ExceptionContext
    "sqlalchemy.engine.ExceptionContext") 对象有一个新的数据成员[`ExceptionContext.engine`](../core/connections.html#sqlalchemy.engine.ExceptionContext.engine
    "sqlalchemy.engine.ExceptionContext.engine")，它将始终引用正在使用的[`Engine`](../core/connections.html#sqlalchemy.engine.Engine
    "sqlalchemy.engine.Engine")，在[`Connection`](../core/connections.html#sqlalchemy.engine.Connection
    "sqlalchemy.engine.Connection")对象不可用的情况下（例如在初始连接时）。'
- en: '[#3266](https://www.sqlalchemy.org/trac/ticket/3266)'
  id: totrans-1329
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3266](https://www.sqlalchemy.org/trac/ticket/3266)'
- en: '### ForeignKeyConstraint.columns is now a ColumnCollection'
  id: totrans-1330
  prefs: []
  type: TYPE_NORMAL
  zh: '### ForeignKeyConstraint.columns 现在是一个 ColumnCollection'
- en: '[`ForeignKeyConstraint.columns`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint.columns
    "sqlalchemy.schema.ForeignKeyConstraint.columns") was previously a plain list
    containing either strings or [`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column") objects, depending on how the [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") was constructed and whether it was associated
    with a table. The collection is now a [`ColumnCollection`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnCollection
    "sqlalchemy.sql.expression.ColumnCollection"), and is only initialized after the
    [`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint") is associated with a [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table"). A new accessor [`ForeignKeyConstraint.column_keys`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint.column_keys
    "sqlalchemy.schema.ForeignKeyConstraint.column_keys") is added to unconditionally
    return string keys for the local set of columns regardless of how the object was
    constructed or its current state.'
  id: totrans-1331
  prefs: []
  type: TYPE_NORMAL
  zh: '[`ForeignKeyConstraint.columns`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint.columns
    "sqlalchemy.schema.ForeignKeyConstraint.columns") 以前是一个普通列表，其中包含字符串或[`Column`](../core/metadata.html#sqlalchemy.schema.Column
    "sqlalchemy.schema.Column")对象，取决于[`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint")的构造方式以及是否与表相关联。该集合现在是一个[`ColumnCollection`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnCollection
    "sqlalchemy.sql.expression.ColumnCollection")，只有在[`ForeignKeyConstraint`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint
    "sqlalchemy.schema.ForeignKeyConstraint")与[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")相关联后才会初始化。新增了一个访问器[`ForeignKeyConstraint.column_keys`](../core/constraints.html#sqlalchemy.schema.ForeignKeyConstraint.column_keys
    "sqlalchemy.schema.ForeignKeyConstraint.column_keys")，无条件地返回本地列集的字符串键，而不管对象是如何构造的或其当前状态如何。'
- en: '### MetaData.sorted_tables accessor is “deterministic”'
  id: totrans-1332
  prefs: []
  type: TYPE_NORMAL
  zh: '### MetaData.sorted_tables 访问器是“确定性的”'
- en: The sorting of tables resulting from the [`MetaData.sorted_tables`](../core/metadata.html#sqlalchemy.schema.MetaData.sorted_tables
    "sqlalchemy.schema.MetaData.sorted_tables") accessor is “deterministic”; the ordering
    should be the same in all cases regardless of Python hashing. This is done by
    first sorting the tables by name before passing them to the topological algorithm,
    which maintains that ordering as it iterates.
  id: totrans-1333
  prefs: []
  type: TYPE_NORMAL
  zh: 由[`MetaData.sorted_tables`](../core/metadata.html#sqlalchemy.schema.MetaData.sorted_tables
    "sqlalchemy.schema.MetaData.sorted_tables")访问器导致的表的排序是“确定性的”；无论Python哈希如何，排序在所有情况下应该是相同的。这是通过首先按名称对表进行排序，然后将它们传递给拓扑算法来实现的，该算法在迭代时保持该顺序。
- en: Note that this change does **not** yet apply to the ordering applied when emitting
    [`MetaData.create_all()`](../core/metadata.html#sqlalchemy.schema.MetaData.create_all
    "sqlalchemy.schema.MetaData.create_all") or [`MetaData.drop_all()`](../core/metadata.html#sqlalchemy.schema.MetaData.drop_all
    "sqlalchemy.schema.MetaData.drop_all").
  id: totrans-1334
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，此更改**尚未**应用于在发出[`MetaData.create_all()`](../core/metadata.html#sqlalchemy.schema.MetaData.create_all
    "sqlalchemy.schema.MetaData.create_all")或[`MetaData.drop_all()`](../core/metadata.html#sqlalchemy.schema.MetaData.drop_all
    "sqlalchemy.schema.MetaData.drop_all")时应用的排序。
- en: '[#3084](https://www.sqlalchemy.org/trac/ticket/3084)'
  id: totrans-1335
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3084](https://www.sqlalchemy.org/trac/ticket/3084)'
- en: '### null(), false() and true() constants are no longer singletons'
  id: totrans-1336
  prefs: []
  type: TYPE_NORMAL
  zh: '### null()、false()和true()常量不再是单例'
- en: 'These three constants were changed to return a “singleton” value in 0.9; unfortunately,
    that would lead to a query like the following to not render as expected:'
  id: totrans-1337
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个常量在0.9中被更改为返回“单例”值；不幸的是，这将导致像以下查询一样的内容无法按预期渲染：
- en: '[PRE371]'
  id: totrans-1338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE371]'
- en: rendering only `SELECT NULL AS anon_1`, because the two [`null()`](../core/sqlelement.html#sqlalchemy.sql.expression.null
    "sqlalchemy.sql.expression.null") constructs would come out as the same `NULL`
    object, and SQLAlchemy’s Core model is based on object identity in order to determine
    lexical significance. The change in 0.9 had no importance other than the desire
    to save on object overhead; in general, an unnamed construct needs to stay lexically
    unique so that it gets labeled uniquely.
  id: totrans-1339
  prefs: []
  type: TYPE_NORMAL
  zh: 仅渲染`SELECT NULL AS anon_1`，因为两个[`null()`](../core/sqlelement.html#sqlalchemy.sql.expression.null
    "sqlalchemy.sql.expression.null")构造将产生相同的`NULL`对象，并且SQLAlchemy的Core模型是基于对象标识来确定词法重要性的。0.9中的变化除了希望节省对象开销外没有任何重要性；一般来说，一个未命名的构造需要保持词法上的唯一性，以便得到唯一的标记。
- en: '[#3170](https://www.sqlalchemy.org/trac/ticket/3170)'
  id: totrans-1340
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3170](https://www.sqlalchemy.org/trac/ticket/3170)'
- en: '### SQLite/Oracle have distinct methods for temporary table/view name reporting'
  id: totrans-1341
  prefs: []
  type: TYPE_NORMAL
  zh: '### SQLite/Oracle有用于临时表/视图名称报告的不同方法'
- en: The [`Inspector.get_table_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_table_names
    "sqlalchemy.engine.reflection.Inspector.get_table_names") and [`Inspector.get_view_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_view_names
    "sqlalchemy.engine.reflection.Inspector.get_view_names") methods in the case of
    SQLite/Oracle would also return the names of temporary tables and views, which
    is not provided by any other dialect (in the case of MySQL at least it is not
    even possible). This logic has been moved out to two new methods [`Inspector.get_temp_table_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_temp_table_names
    "sqlalchemy.engine.reflection.Inspector.get_temp_table_names") and [`Inspector.get_temp_view_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_temp_view_names
    "sqlalchemy.engine.reflection.Inspector.get_temp_view_names").
  id: totrans-1342
  prefs: []
  type: TYPE_NORMAL
  zh: 在SQLite/Oracle的情况下，[`Inspector.get_table_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_table_names
    "sqlalchemy.engine.reflection.Inspector.get_table_names")和[`Inspector.get_view_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_view_names
    "sqlalchemy.engine.reflection.Inspector.get_view_names")方法还将返回临时表和视图的名称，这是其他方言不提供的（至少在MySQL的情况下甚至不可能）。这种逻辑已移至两个新方法[`Inspector.get_temp_table_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_temp_table_names
    "sqlalchemy.engine.reflection.Inspector.get_temp_table_names")和[`Inspector.get_temp_view_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_temp_view_names
    "sqlalchemy.engine.reflection.Inspector.get_temp_view_names")。
- en: Note that reflection of a specific named temporary table or temporary view,
    either by `Table('name', autoload=True)` or via methods like [`Inspector.get_columns()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_columns
    "sqlalchemy.engine.reflection.Inspector.get_columns") continues to function for
    most if not all dialects. For SQLite specifically, there is a bug fix for UNIQUE
    constraint reflection from temp tables as well, which is [#3203](https://www.sqlalchemy.org/trac/ticket/3203).
  id: totrans-1343
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，特定命名的临时表或临时视图的反射，无论是通过`Table('name', autoload=True)`还是通过[`Inspector.get_columns()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_columns
    "sqlalchemy.engine.reflection.Inspector.get_columns")等方法，对大多数（如果不是全部）方言仍然有效。对于SQLite特别地，还修复了有关从临时表中反射UNIQUE约束的错误，这是[#3203](https://www.sqlalchemy.org/trac/ticket/3203)。
- en: '[#3204](https://www.sqlalchemy.org/trac/ticket/3204)'
  id: totrans-1344
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3204](https://www.sqlalchemy.org/trac/ticket/3204)'
- en: Dialect Improvements and Changes - PostgreSQL
  id: totrans-1345
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方言改进和变更 - PostgreSQL
- en: '### Overhaul of ENUM type create/drop rules'
  id: totrans-1346
  prefs: []
  type: TYPE_NORMAL
  zh: '### 枚举类型创建/删除规则的彻底改造'
- en: The rules for PostgreSQL [`ENUM`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ENUM
    "sqlalchemy.dialects.postgresql.ENUM") have been made more strict with regards
    to creating and dropping of the TYPE.
  id: totrans-1347
  prefs: []
  type: TYPE_NORMAL
  zh: 与创建和删除类型有关的PostgreSQL [`ENUM`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ENUM
    "sqlalchemy.dialects.postgresql.ENUM")规则已经更加严格。
- en: 'An [`ENUM`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ENUM
    "sqlalchemy.dialects.postgresql.ENUM") that is created **without** being explicitly
    associated with a [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") object will be created *and* dropped corresponding
    to [`Table.create()`](../core/metadata.html#sqlalchemy.schema.Table.create "sqlalchemy.schema.Table.create")
    and [`Table.drop()`](../core/metadata.html#sqlalchemy.schema.Table.drop "sqlalchemy.schema.Table.drop"):'
  id: totrans-1348
  prefs: []
  type: TYPE_NORMAL
  zh: 通过未明确与[`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData "sqlalchemy.schema.MetaData")对象关联创建的[`ENUM`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ENUM
    "sqlalchemy.dialects.postgresql.ENUM")将根据[`Table.create()`](../core/metadata.html#sqlalchemy.schema.Table.create
    "sqlalchemy.schema.Table.create")和[`Table.drop()`](../core/metadata.html#sqlalchemy.schema.Table.drop
    "sqlalchemy.schema.Table.drop")创建和删除：
- en: '[PRE372]'
  id: totrans-1349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE372]'
- en: This means that if a second table also has an enum named ‘myenum’, the above
    DROP operation will now fail. In order to accommodate the use case of a common
    shared enumerated type, the behavior of a metadata-associated enumeration has
    been enhanced.
  id: totrans-1350
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着如果第二个表也有一个名为‘myenum’的枚举，上述DROP操作现在将失败。为了适应共享枚举类型的用例，元数据关联的枚举行为已经得到增强。
- en: 'An [`ENUM`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ENUM
    "sqlalchemy.dialects.postgresql.ENUM") that is created **with** being explicitly
    associated with a [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") object will *not* be created *or* dropped corresponding
    to [`Table.create()`](../core/metadata.html#sqlalchemy.schema.Table.create "sqlalchemy.schema.Table.create")
    and [`Table.drop()`](../core/metadata.html#sqlalchemy.schema.Table.drop "sqlalchemy.schema.Table.drop"),
    with the exception of [`Table.create()`](../core/metadata.html#sqlalchemy.schema.Table.create
    "sqlalchemy.schema.Table.create") called with the `checkfirst=True` flag:'
  id: totrans-1351
  prefs: []
  type: TYPE_NORMAL
  zh: 通过与[`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData "sqlalchemy.schema.MetaData")对象明确关联创建的[`ENUM`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ENUM
    "sqlalchemy.dialects.postgresql.ENUM")将不会根据[`Table.create()`](../core/metadata.html#sqlalchemy.schema.Table.create
    "sqlalchemy.schema.Table.create")和[`Table.drop()`](../core/metadata.html#sqlalchemy.schema.Table.drop
    "sqlalchemy.schema.Table.drop")创建或删除，除了使用`checkfirst=True`标志调用的[`Table.create()`](../core/metadata.html#sqlalchemy.schema.Table.create
    "sqlalchemy.schema.Table.create")：
- en: '[PRE373]'
  id: totrans-1352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE373]'
- en: '[#3319](https://www.sqlalchemy.org/trac/ticket/3319)'
  id: totrans-1353
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3319](https://www.sqlalchemy.org/trac/ticket/3319)'
- en: New PostgreSQL Table options
  id: totrans-1354
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 新的PostgreSQL表选项
- en: Added support for PG table options TABLESPACE, ON COMMIT, WITH(OUT) OIDS, and
    INHERITS, when rendering DDL via the [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") construct.
  id: totrans-1355
  prefs: []
  type: TYPE_NORMAL
  zh: 在通过[`Table`](../core/metadata.html#sqlalchemy.schema.Table "sqlalchemy.schema.Table")构造渲染DDL时，添加了对PG表选项TABLESPACE、ON
    COMMIT、WITH(OUT) OIDS和INHERITS的支持。
- en: See also
  id: totrans-1356
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[PostgreSQL Table Options](../dialects/postgresql.html#postgresql-table-options)'
  id: totrans-1357
  prefs: []
  type: TYPE_NORMAL
  zh: '[PostgreSQL表选项](../dialects/postgresql.html#postgresql-table-options)'
- en: '[#2051](https://www.sqlalchemy.org/trac/ticket/2051)'
  id: totrans-1358
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2051](https://www.sqlalchemy.org/trac/ticket/2051)'
- en: '### New get_enums() method with PostgreSQL Dialect'
  id: totrans-1359
  prefs: []
  type: TYPE_NORMAL
  zh: '### 具有PostgreSQL方言的新get_enums()方法'
- en: 'The [`inspect()`](../core/inspection.html#sqlalchemy.inspect "sqlalchemy.inspect")
    method returns a [`PGInspector`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.base.PGInspector
    "sqlalchemy.dialects.postgresql.base.PGInspector") object in the case of PostgreSQL,
    which includes a new [`PGInspector.get_enums()`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.base.PGInspector.get_enums
    "sqlalchemy.dialects.postgresql.base.PGInspector.get_enums") method that returns
    information on all available `ENUM` types:'
  id: totrans-1360
  prefs: []
  type: TYPE_NORMAL
  zh: 在PostgreSQL的情况下，[`inspect()`](../core/inspection.html#sqlalchemy.inspect "sqlalchemy.inspect")方法返回一个[`PGInspector`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.base.PGInspector
    "sqlalchemy.dialects.postgresql.base.PGInspector")对象，其中包括一个新的[`PGInspector.get_enums()`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.base.PGInspector.get_enums
    "sqlalchemy.dialects.postgresql.base.PGInspector.get_enums")方法，返回所有可用的`ENUM`类型的信息：
- en: '[PRE374]'
  id: totrans-1361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE374]'
- en: See also
  id: totrans-1362
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[`PGInspector.get_enums()`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.base.PGInspector.get_enums
    "sqlalchemy.dialects.postgresql.base.PGInspector.get_enums")  ### PostgreSQL Dialect
    reflects Materialized Views, Foreign Tables'
  id: totrans-1363
  prefs: []
  type: TYPE_NORMAL
  zh: '[`PGInspector.get_enums()`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.base.PGInspector.get_enums
    "sqlalchemy.dialects.postgresql.base.PGInspector.get_enums")  ### PostgreSQL方言反映了物化视图、外部表'
- en: 'Changes are as follows:'
  id: totrans-1364
  prefs: []
  type: TYPE_NORMAL
  zh: 更改如下：
- en: the `Table` construct with `autoload=True` will now match a name that exists
    in the database as a materialized view or foreign table.
  id: totrans-1365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `autoload=True` 的 `Table` 构造现在将匹配数据库中存在的作为物化视图或外部表的名称。
- en: '[`Inspector.get_view_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_view_names
    "sqlalchemy.engine.reflection.Inspector.get_view_names") will return plain and
    materialized view names.'
  id: totrans-1366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`Inspector.get_view_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_view_names
    "sqlalchemy.engine.reflection.Inspector.get_view_names") 将返回普通和物化视图的名称。'
- en: '[`Inspector.get_table_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_table_names
    "sqlalchemy.engine.reflection.Inspector.get_table_names") does **not** change
    for PostgreSQL, it continues to return only the names of plain tables.'
  id: totrans-1367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`Inspector.get_table_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_table_names
    "sqlalchemy.engine.reflection.Inspector.get_table_names") 对于 PostgreSQL 不会发生变化，它继续只返回普通表的名称。'
- en: A new method [`PGInspector.get_foreign_table_names()`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.base.PGInspector.get_foreign_table_names
    "sqlalchemy.dialects.postgresql.base.PGInspector.get_foreign_table_names") is
    added which will return the names of tables that are specifically marked as “foreign”
    in the PostgreSQL schema tables.
  id: totrans-1368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加了一个新方法 [`PGInspector.get_foreign_table_names()`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.base.PGInspector.get_foreign_table_names
    "sqlalchemy.dialects.postgresql.base.PGInspector.get_foreign_table_names")，它将返回在
    PostgreSQL 模式表中明确标记为“外部”的表的名称。
- en: The change to reflection involves adding `'m'` and `'f'` to the list of qualifiers
    we use when querying `pg_class.relkind`, but this change is new in 1.0.0 to avoid
    any backwards-incompatible surprises for those running 0.9 in production.
  id: totrans-1369
  prefs: []
  type: TYPE_NORMAL
  zh: 反射的变化涉及在查询 `pg_class.relkind` 时添加 `'m'` 和 `'f'` 到我们使用的修饰符列表，但这个变化是在 1.0.0 中新增的，以避免对正在生产中运行
    0.9 的用户造成任何不兼容的惊喜。
- en: '[#2891](https://www.sqlalchemy.org/trac/ticket/2891)  ### PostgreSQL `has_table()`
    now works for temporary tables'
  id: totrans-1370
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2891](https://www.sqlalchemy.org/trac/ticket/2891)  ### PostgreSQL `has_table()`
    现在适用于临时表'
- en: 'This is a simple fix such that “has table” for temporary tables now works,
    so that code like the following may proceed:'
  id: totrans-1371
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的修复，使得临时表的“has table”现在可以正常工作，因此像下面这样的代码可以继续执行：
- en: '[PRE375]'
  id: totrans-1372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE375]'
- en: 'The very unlikely case that this behavior will cause a non-failing application
    to behave differently, is because PostgreSQL allows a non-temporary table to silently
    overwrite a temporary table. So code like the following will now act completely
    differently, no longer creating the real table following the temporary table:'
  id: totrans-1373
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为可能导致一个不会失败的应用程序表现不同的极不可能的情况，是因为 PostgreSQL 允许非临时表悄悄地覆盖临时表。因此，像下面这样的代码现在将完全不同，不再创建临时表后面的真实表：
- en: '[PRE376]'
  id: totrans-1374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE376]'
- en: '[#3264](https://www.sqlalchemy.org/trac/ticket/3264)  ### PostgreSQL FILTER
    keyword'
  id: totrans-1375
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3264](https://www.sqlalchemy.org/trac/ticket/3264)  ### PostgreSQL FILTER
    关键字'
- en: 'The SQL standard FILTER keyword for aggregate functions is now supported by
    PostgreSQL as of 9.4\. SQLAlchemy allows this using [`FunctionElement.filter()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.filter
    "sqlalchemy.sql.functions.FunctionElement.filter"):'
  id: totrans-1376
  prefs: []
  type: TYPE_NORMAL
  zh: SQL 标准的 FILTER 关键字现在由 PostgreSQL 支持，从 9.4 版开始。SQLAlchemy 允许使用 [`FunctionElement.filter()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.filter
    "sqlalchemy.sql.functions.FunctionElement.filter") 来实现：
- en: '[PRE377]'
  id: totrans-1377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE377]'
- en: See also
  id: totrans-1378
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`FunctionElement.filter()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.filter
    "sqlalchemy.sql.functions.FunctionElement.filter")'
  id: totrans-1379
  prefs: []
  type: TYPE_NORMAL
  zh: '[`FunctionElement.filter()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.filter
    "sqlalchemy.sql.functions.FunctionElement.filter")'
- en: '[`FunctionFilter`](../core/sqlelement.html#sqlalchemy.sql.expression.FunctionFilter
    "sqlalchemy.sql.expression.FunctionFilter")'
  id: totrans-1380
  prefs: []
  type: TYPE_NORMAL
  zh: '[`FunctionFilter`](../core/sqlelement.html#sqlalchemy.sql.expression.FunctionFilter
    "sqlalchemy.sql.expression.FunctionFilter")'
- en: PG8000 dialect supports client side encoding
  id: totrans-1381
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PG8000 方言支持客户端编码
- en: The [`create_engine.encoding`](../core/engines.html#sqlalchemy.create_engine.params.encoding
    "sqlalchemy.create_engine") parameter is now honored by the pg8000 dialect, using
    on connect handler which emits `SET CLIENT_ENCODING` matching the selected encoding.
  id: totrans-1382
  prefs: []
  type: TYPE_NORMAL
  zh: '[`create_engine.encoding`](../core/engines.html#sqlalchemy.create_engine.params.encoding
    "sqlalchemy.create_engine") 参数现在由 pg8000 方言遵守，使用连接处理程序发出 `SET CLIENT_ENCODING`
    匹配所选编码。'
- en: PG8000 native JSONB support
  id: totrans-1383
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PG8000 原生 JSONB 支持
- en: Support for PG8000 versions greater than 1.10.1 has been added, where JSONB
    is supported natively.
  id: totrans-1384
  prefs: []
  type: TYPE_NORMAL
  zh: 添加了对大于 1.10.1 版本的 PG8000 的支持，其中原生支持 JSONB。
- en: Support for psycopg2cffi Dialect on PyPy
  id: totrans-1385
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对 PyPy 上的 psycopg2cffi 方言的支持
- en: Support for the pypy psycopg2cffi dialect is added.
  id: totrans-1386
  prefs: []
  type: TYPE_NORMAL
  zh: 添加了对 pypy psycopg2cffi 方言的支持。
- en: See also
  id: totrans-1387
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`sqlalchemy.dialects.postgresql.psycopg2cffi`](../dialects/postgresql.html#module-sqlalchemy.dialects.postgresql.psycopg2cffi
    "sqlalchemy.dialects.postgresql.psycopg2cffi")'
  id: totrans-1388
  prefs: []
  type: TYPE_NORMAL
  zh: '[`sqlalchemy.dialects.postgresql.psycopg2cffi`](../dialects/postgresql.html#module-sqlalchemy.dialects.postgresql.psycopg2cffi
    "sqlalchemy.dialects.postgresql.psycopg2cffi")'
- en: '### Overhaul of ENUM type create/drop rules'
  id: totrans-1389
  prefs: []
  type: TYPE_NORMAL
  zh: '### ENUM类型创建/删除规则的全面改革'
- en: The rules for PostgreSQL [`ENUM`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ENUM
    "sqlalchemy.dialects.postgresql.ENUM") have been made more strict with regards
    to creating and dropping of the TYPE.
  id: totrans-1390
  prefs: []
  type: TYPE_NORMAL
  zh: 有关创建和删除TYPE的PostgreSQL [`ENUM`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ENUM
    "sqlalchemy.dialects.postgresql.ENUM")的规则已经更加严格。
- en: 'An [`ENUM`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ENUM
    "sqlalchemy.dialects.postgresql.ENUM") that is created **without** being explicitly
    associated with a [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") object will be created *and* dropped corresponding
    to [`Table.create()`](../core/metadata.html#sqlalchemy.schema.Table.create "sqlalchemy.schema.Table.create")
    and [`Table.drop()`](../core/metadata.html#sqlalchemy.schema.Table.drop "sqlalchemy.schema.Table.drop"):'
  id: totrans-1391
  prefs: []
  type: TYPE_NORMAL
  zh: 一个[`ENUM`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ENUM "sqlalchemy.dialects.postgresql.ENUM")如果没有明确与[`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData")对象关联，将根据[`Table.create()`](../core/metadata.html#sqlalchemy.schema.Table.create
    "sqlalchemy.schema.Table.create")和[`Table.drop()`](../core/metadata.html#sqlalchemy.schema.Table.drop
    "sqlalchemy.schema.Table.drop")创��和删除：
- en: '[PRE378]'
  id: totrans-1392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE378]'
- en: This means that if a second table also has an enum named ‘myenum’, the above
    DROP operation will now fail. In order to accommodate the use case of a common
    shared enumerated type, the behavior of a metadata-associated enumeration has
    been enhanced.
  id: totrans-1393
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着如果第二个表也有一个名为‘myenum’的枚举，上述DROP操作现在将失败。为了适应共享枚举类型的使用情况，元数据关联的枚举行为已经增强。
- en: 'An [`ENUM`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ENUM
    "sqlalchemy.dialects.postgresql.ENUM") that is created **with** being explicitly
    associated with a [`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData") object will *not* be created *or* dropped corresponding
    to [`Table.create()`](../core/metadata.html#sqlalchemy.schema.Table.create "sqlalchemy.schema.Table.create")
    and [`Table.drop()`](../core/metadata.html#sqlalchemy.schema.Table.drop "sqlalchemy.schema.Table.drop"),
    with the exception of [`Table.create()`](../core/metadata.html#sqlalchemy.schema.Table.create
    "sqlalchemy.schema.Table.create") called with the `checkfirst=True` flag:'
  id: totrans-1394
  prefs: []
  type: TYPE_NORMAL
  zh: 一个[`ENUM`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.ENUM "sqlalchemy.dialects.postgresql.ENUM")如果明确与[`MetaData`](../core/metadata.html#sqlalchemy.schema.MetaData
    "sqlalchemy.schema.MetaData")对象关联，将不会根据[`Table.create()`](../core/metadata.html#sqlalchemy.schema.Table.create
    "sqlalchemy.schema.Table.create")和[`Table.drop()`](../core/metadata.html#sqlalchemy.schema.Table.drop
    "sqlalchemy.schema.Table.drop")创建或删除，除非使用`checkfirst=True`标志调用[`Table.create()`](../core/metadata.html#sqlalchemy.schema.Table.create
    "sqlalchemy.schema.Table.create")：
- en: '[PRE379]'
  id: totrans-1395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE379]'
- en: '[#3319](https://www.sqlalchemy.org/trac/ticket/3319)'
  id: totrans-1396
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3319](https://www.sqlalchemy.org/trac/ticket/3319)'
- en: New PostgreSQL Table options
  id: totrans-1397
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 新的PostgreSQL表选项
- en: Added support for PG table options TABLESPACE, ON COMMIT, WITH(OUT) OIDS, and
    INHERITS, when rendering DDL via the [`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table") construct.
  id: totrans-1398
  prefs: []
  type: TYPE_NORMAL
  zh: 添加了对PG表选项TABLESPACE、ON COMMIT、WITH(OUT) OIDS和INHERITS的支持，通过[`Table`](../core/metadata.html#sqlalchemy.schema.Table
    "sqlalchemy.schema.Table")构造渲染DDL时。
- en: See also
  id: totrans-1399
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[PostgreSQL Table Options](../dialects/postgresql.html#postgresql-table-options)'
  id: totrans-1400
  prefs: []
  type: TYPE_NORMAL
  zh: '[PostgreSQL表选项](../dialects/postgresql.html#postgresql-table-options)'
- en: '[#2051](https://www.sqlalchemy.org/trac/ticket/2051)'
  id: totrans-1401
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2051](https://www.sqlalchemy.org/trac/ticket/2051)'
- en: '### New get_enums() method with PostgreSQL Dialect'
  id: totrans-1402
  prefs: []
  type: TYPE_NORMAL
  zh: '### 具有PostgreSQL方言的新get_enums()方法'
- en: 'The [`inspect()`](../core/inspection.html#sqlalchemy.inspect "sqlalchemy.inspect")
    method returns a [`PGInspector`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.base.PGInspector
    "sqlalchemy.dialects.postgresql.base.PGInspector") object in the case of PostgreSQL,
    which includes a new [`PGInspector.get_enums()`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.base.PGInspector.get_enums
    "sqlalchemy.dialects.postgresql.base.PGInspector.get_enums") method that returns
    information on all available `ENUM` types:'
  id: totrans-1403
  prefs: []
  type: TYPE_NORMAL
  zh: '[`inspect()`](../core/inspection.html#sqlalchemy.inspect "sqlalchemy.inspect")方法在PostgreSQL情况下返回一个[`PGInspector`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.base.PGInspector
    "sqlalchemy.dialects.postgresql.base.PGInspector")对象，其中包括一个新的[`PGInspector.get_enums()`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.base.PGInspector.get_enums
    "sqlalchemy.dialects.postgresql.base.PGInspector.get_enums")方法，返回所有可用`ENUM`类型的信息：'
- en: '[PRE380]'
  id: totrans-1404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE380]'
- en: See also
  id: totrans-1405
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`PGInspector.get_enums()`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.base.PGInspector.get_enums
    "sqlalchemy.dialects.postgresql.base.PGInspector.get_enums")'
  id: totrans-1406
  prefs: []
  type: TYPE_NORMAL
  zh: '[`PGInspector.get_enums()`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.base.PGInspector.get_enums
    "sqlalchemy.dialects.postgresql.base.PGInspector.get_enums")'
- en: '### PostgreSQL Dialect reflects Materialized Views, Foreign Tables'
  id: totrans-1407
  prefs: []
  type: TYPE_NORMAL
  zh: '### PostgreSQL 方言反映了物化视图、外部表'
- en: 'Changes are as follows:'
  id: totrans-1408
  prefs: []
  type: TYPE_NORMAL
  zh: 更改如下：
- en: the `Table` construct with `autoload=True` will now match a name that exists
    in the database as a materialized view or foreign table.
  id: totrans-1409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `autoload=True` 的 `Table` 构造现在将匹配数据库中存在的物化视图或外部表的名称。
- en: '[`Inspector.get_view_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_view_names
    "sqlalchemy.engine.reflection.Inspector.get_view_names") will return plain and
    materialized view names.'
  id: totrans-1410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`Inspector.get_view_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_view_names
    "sqlalchemy.engine.reflection.Inspector.get_view_names") 将返回普通视图和物化视图的名称。'
- en: '[`Inspector.get_table_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_table_names
    "sqlalchemy.engine.reflection.Inspector.get_table_names") does **not** change
    for PostgreSQL, it continues to return only the names of plain tables.'
  id: totrans-1411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[`Inspector.get_table_names()`](../core/reflection.html#sqlalchemy.engine.reflection.Inspector.get_table_names
    "sqlalchemy.engine.reflection.Inspector.get_table_names") 对于 PostgreSQL 不会发生变化，它仍然只返回普通表的名称。'
- en: A new method [`PGInspector.get_foreign_table_names()`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.base.PGInspector.get_foreign_table_names
    "sqlalchemy.dialects.postgresql.base.PGInspector.get_foreign_table_names") is
    added which will return the names of tables that are specifically marked as “foreign”
    in the PostgreSQL schema tables.
  id: totrans-1412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加了一个新方法 [`PGInspector.get_foreign_table_names()`](../dialects/postgresql.html#sqlalchemy.dialects.postgresql.base.PGInspector.get_foreign_table_names
    "sqlalchemy.dialects.postgresql.base.PGInspector.get_foreign_table_names")，它将返回在
    PostgreSQL 模式表中明确标记为“外部”的表的名称。
- en: The change to reflection involves adding `'m'` and `'f'` to the list of qualifiers
    we use when querying `pg_class.relkind`, but this change is new in 1.0.0 to avoid
    any backwards-incompatible surprises for those running 0.9 in production.
  id: totrans-1413
  prefs: []
  type: TYPE_NORMAL
  zh: 反射的变化涉及在查询`pg_class.relkind`时将`'m'`和`'f'`添加到我们使用的限定符列表中，但这个变化是在 1.0.0 版本中新增的，以避免对于在生产环境中运行
    0.9 版本的用户造成任何不兼容的惊喜。
- en: '[#2891](https://www.sqlalchemy.org/trac/ticket/2891)'
  id: totrans-1414
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2891](https://www.sqlalchemy.org/trac/ticket/2891)'
- en: '### PostgreSQL `has_table()` now works for temporary tables'
  id: totrans-1415
  prefs: []
  type: TYPE_NORMAL
  zh: '### PostgreSQL `has_table()` 现在适用于临时表'
- en: 'This is a simple fix such that “has table” for temporary tables now works,
    so that code like the following may proceed:'
  id: totrans-1416
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的修复，使得临时表的“有表”现在可以工作，因此像下面这样的代码可以继续进行：
- en: '[PRE381]'
  id: totrans-1417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE381]'
- en: 'The very unlikely case that this behavior will cause a non-failing application
    to behave differently, is because PostgreSQL allows a non-temporary table to silently
    overwrite a temporary table. So code like the following will now act completely
    differently, no longer creating the real table following the temporary table:'
  id: totrans-1418
  prefs: []
  type: TYPE_NORMAL
  zh: 这种行为可能导致一个不会失败的应用程序表现不同的极端情况，是因为 PostgreSQL 允许非临时表悄悄地覆盖临时表。因此，像下面这样的代码现在将完全不同，不再创建真实表来跟随临时表：
- en: '[PRE382]'
  id: totrans-1419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE382]'
- en: '[#3264](https://www.sqlalchemy.org/trac/ticket/3264)'
  id: totrans-1420
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3264](https://www.sqlalchemy.org/trac/ticket/3264)'
- en: '### PostgreSQL FILTER keyword'
  id: totrans-1421
  prefs: []
  type: TYPE_NORMAL
  zh: '### PostgreSQL FILTER 关键字'
- en: 'The SQL standard FILTER keyword for aggregate functions is now supported by
    PostgreSQL as of 9.4\. SQLAlchemy allows this using [`FunctionElement.filter()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.filter
    "sqlalchemy.sql.functions.FunctionElement.filter"):'
  id: totrans-1422
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 9.4 版本的 PostgreSQL 支持 SQL 标准的 FILTER 关键字。SQLAlchemy 允许使用 [`FunctionElement.filter()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.filter
    "sqlalchemy.sql.functions.FunctionElement.filter")：
- en: '[PRE383]'
  id: totrans-1423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE383]'
- en: See also
  id: totrans-1424
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`FunctionElement.filter()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.filter
    "sqlalchemy.sql.functions.FunctionElement.filter")'
  id: totrans-1425
  prefs: []
  type: TYPE_NORMAL
  zh: '[`FunctionElement.filter()`](../core/functions.html#sqlalchemy.sql.functions.FunctionElement.filter
    "sqlalchemy.sql.functions.FunctionElement.filter")'
- en: '[`FunctionFilter`](../core/sqlelement.html#sqlalchemy.sql.expression.FunctionFilter
    "sqlalchemy.sql.expression.FunctionFilter")'
  id: totrans-1426
  prefs: []
  type: TYPE_NORMAL
  zh: '[`FunctionFilter`](../core/sqlelement.html#sqlalchemy.sql.expression.FunctionFilter
    "sqlalchemy.sql.expression.FunctionFilter")'
- en: PG8000 dialect supports client side encoding
  id: totrans-1427
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PG8000 方言支持客户端编码
- en: The [`create_engine.encoding`](../core/engines.html#sqlalchemy.create_engine.params.encoding
    "sqlalchemy.create_engine") parameter is now honored by the pg8000 dialect, using
    on connect handler which emits `SET CLIENT_ENCODING` matching the selected encoding.
  id: totrans-1428
  prefs: []
  type: TYPE_NORMAL
  zh: '[`create_engine.encoding`](../core/engines.html#sqlalchemy.create_engine.params.encoding
    "sqlalchemy.create_engine") 参数现在受到 pg8000 方言的尊重，使用连接处理程序发出与所选编码匹配的 `SET CLIENT_ENCODING`。'
- en: PG8000 native JSONB support
  id: totrans-1429
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PG8000 原生 JSONB 支持
- en: Support for PG8000 versions greater than 1.10.1 has been added, where JSONB
    is supported natively.
  id: totrans-1430
  prefs: []
  type: TYPE_NORMAL
  zh: 添加了对大于 1.10.1 版本的 PG8000 的支持，其中原生支持 JSONB。
- en: Support for psycopg2cffi Dialect on PyPy
  id: totrans-1431
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 支持在 PyPy 上的 psycopg2cffi 方言
- en: Support for the pypy psycopg2cffi dialect is added.
  id: totrans-1432
  prefs: []
  type: TYPE_NORMAL
  zh: 添加了对 pypy psycopg2cffi 方言的支持。
- en: See also
  id: totrans-1433
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[`sqlalchemy.dialects.postgresql.psycopg2cffi`](../dialects/postgresql.html#module-sqlalchemy.dialects.postgresql.psycopg2cffi
    "sqlalchemy.dialects.postgresql.psycopg2cffi")'
  id: totrans-1434
  prefs: []
  type: TYPE_NORMAL
  zh: '[`sqlalchemy.dialects.postgresql.psycopg2cffi`](../dialects/postgresql.html#module-sqlalchemy.dialects.postgresql.psycopg2cffi
    "sqlalchemy.dialects.postgresql.psycopg2cffi")'
- en: Dialect Improvements and Changes - MySQL
  id: totrans-1435
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方言改进和更改 - MySQL
- en: '### MySQL TIMESTAMP Type now renders NULL / NOT NULL in all cases'
  id: totrans-1436
  prefs: []
  type: TYPE_NORMAL
  zh: '### MySQL TIMESTAMP 类型现在在所有情况下都渲染为 NULL / NOT NULL'
- en: The MySQL dialect has always worked around MySQL’s implicit NOT NULL default
    associated with TIMESTAMP columns by emitting NULL for such a type, if the column
    is set up with `nullable=True`. However, MySQL 5.6.6 and above features a new
    flag [explicit_defaults_for_timestamp](https://dev.mysql.com/doc/refman/5.6/en/server-system-variables.html#sysvar_explicit_defaults_for_timestamp)
    which repairs MySQL’s non-standard behavior to make it behave like any other type;
    to accommodate this, SQLAlchemy now emits NULL/NOT NULL unconditionally for all
    TIMESTAMP columns.
  id: totrans-1437
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL 方言始终通过为 `nullable=True` 设置的列发出 NULL 来解决与 TIMESTAMP 列关联的隐式 NOT NULL 默认值的问题。然而，MySQL
    5.6.6 及以上版本具有一个新标志[explicit_defaults_for_timestamp](https://dev.mysql.com/doc/refman/5.6/en/server-system-variables.html#sysvar_explicit_defaults_for_timestamp)，修复了
    MySQL 的非标准行为，使其像任何其他类型一样运行；为了适应这一点，SQLAlchemy 现在无条件地为所有 TIMESTAMP 列发出 NULL/NOT
    NULL。
- en: See also
  id: totrans-1438
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[TIMESTAMP Columns and NULL](../dialects/mysql.html#mysql-timestamp-null)'
  id: totrans-1439
  prefs: []
  type: TYPE_NORMAL
  zh: '[TIMESTAMP 列和 NULL](../dialects/mysql.html#mysql-timestamp-null)'
- en: '[#3155](https://www.sqlalchemy.org/trac/ticket/3155)  ### MySQL SET Type Overhauled
    to support empty sets, unicode, blank value handling'
  id: totrans-1440
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3155](https://www.sqlalchemy.org/trac/ticket/3155)  ### MySQL SET 类型进行了全面改进，以支持空集、unicode、空值处理'
- en: The [`SET`](../dialects/mysql.html#sqlalchemy.dialects.mysql.SET "sqlalchemy.dialects.mysql.SET")
    type historically not included a system of handling blank sets and empty values
    separately; as different drivers had different behaviors for treatment of empty
    strings and empty-string-set representations, the SET type tried only to hedge
    between these behaviors, opting to treat the empty set as `set([''])` as is still
    the current behavior for the MySQL-Connector-Python DBAPI. Part of the rationale
    here was that it was otherwise impossible to actually store a blank string within
    a MySQL SET, as the driver gives us back strings with no way to discern between
    `set([''])` and `set()`. It was left to the user to determine if `set([''])` actually
    meant “empty set” or not.
  id: totrans-1441
  prefs: []
  type: TYPE_NORMAL
  zh: '[`SET`](../dialects/mysql.html#sqlalchemy.dialects.mysql.SET "sqlalchemy.dialects.mysql.SET")
    类型历史上没有包括处理空集和空值的系统；由于不同的驱动程序对空字符串和空字符串集表示的处理方式不同，因此 SET 类型尝试只在这些行为之间进行权衡，选择将空集视为
    `set([''''])`，这仍然是 MySQL-Connector-Python DBAPI 的当前行为。其中部分理由是否则无法实际在 MySQL SET
    中存储空字符串，因为驱动程序返回没有办法区分 `set([''''])` 和 `set()` 的字符串。留给用户确定 `set([''''])` 实际上是否意味着“空集”或其他情况。'
- en: 'The new behavior moves the use case for the blank string, which is an unusual
    case that isn’t even documented in MySQL’s documentation, into a special case,
    and the default behavior of [`SET`](../dialects/mysql.html#sqlalchemy.dialects.mysql.SET
    "sqlalchemy.dialects.mysql.SET") is now:'
  id: totrans-1442
  prefs: []
  type: TYPE_NORMAL
  zh: 新行为将使用空字符串的用例（这是一个不寻常的情况，甚至在 MySQL 的文档中都没有记录），移入特殊情况中，而[`SET`](../dialects/mysql.html#sqlalchemy.dialects.mysql.SET
    "sqlalchemy.dialects.mysql.SET")的默认行为现在是：
- en: to treat the empty string `''` as returned by MySQL-python into the empty set
    `set()`;
  id: totrans-1443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将由 MySQL-python 返回的空字符串 `''` 视为空集 `set()`；
- en: to convert the single-blank value set `set([''])` returned by MySQL-Connector-Python
    into the empty set `set()`;
  id: totrans-1444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将由 MySQL-Connector-Python 返回的单空值集 `set([''])` 转换为空集 `set()`；
- en: To handle the case of a set type that actually wishes includes the blank value
    `''` in its list of possible values, a new feature (required in this use case)
    is implemented whereby the set value is persisted and loaded as a bitwise integer
    value; the flag [`SET.retrieve_as_bitwise`](../dialects/mysql.html#sqlalchemy.dialects.mysql.SET.params.retrieve_as_bitwise
    "sqlalchemy.dialects.mysql.SET") is added in order to enable this.
  id: totrans-1445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了处理实际希望包含空值 `''` 在其可能值列表中的集合类型的情况，实施了一个新功能（在这种情况下是必需的），即将集合值持久化和加载为位整数值；添加了标志
    [`SET.retrieve_as_bitwise`](../dialects/mysql.html#sqlalchemy.dialects.mysql.SET.params.retrieve_as_bitwise
    "sqlalchemy.dialects.mysql.SET") 以启用此功能。
- en: Using the [`SET.retrieve_as_bitwise`](../dialects/mysql.html#sqlalchemy.dialects.mysql.SET.params.retrieve_as_bitwise
    "sqlalchemy.dialects.mysql.SET") flag allows the set to be persisted and retrieved
    with no ambiguity of values. Theoretically this flag can be turned on in all cases,
    as long as the given list of values to the type matches the ordering exactly as
    declared in the database; it only makes the SQL echo output a bit more unusual.
  id: totrans-1446
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 [`SET.retrieve_as_bitwise`](../dialects/mysql.html#sqlalchemy.dialects.mysql.SET.params.retrieve_as_bitwise
    "sqlalchemy.dialects.mysql.SET") 标志允许集合以无歧义的值进行持久化和检索。理论上，只要给定的值列表与数据库中声明的顺序完全匹配，就可以在所有情况下打开此标志；它只是使
    SQL 回显输出有点不寻常。
- en: The default behavior of [`SET`](../dialects/mysql.html#sqlalchemy.dialects.mysql.SET
    "sqlalchemy.dialects.mysql.SET") otherwise remains the same, roundtripping values
    using strings. The string-based behavior now supports unicode fully including
    MySQL-python with use_unicode=0.
  id: totrans-1447
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，[`SET`](../dialects/mysql.html#sqlalchemy.dialects.mysql.SET "sqlalchemy.dialects.mysql.SET")
    的默认行为保持不变，使用字符串循环传递值。基于字符串的行为现在完全支持 Unicode，包括 MySQL-python 使用 `use_unicode=0`。
- en: '[#3283](https://www.sqlalchemy.org/trac/ticket/3283)'
  id: totrans-1448
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3283](https://www.sqlalchemy.org/trac/ticket/3283)'
- en: MySQL internal “no such table” exceptions not passed to event handlers
  id: totrans-1449
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: MySQL 内部的“无此表”异常不会传递给事件处理程序
- en: The MySQL dialect will now disable `ConnectionEvents.handle_error()` events
    from firing for those statements which it uses internally to detect if a table
    exists or not. This is achieved using an execution option `skip_user_error_events`
    that disables the handle error event for the scope of that execution. In this
    way, user code that rewrites exceptions doesn’t need to worry about the MySQL
    dialect or other dialects that occasionally need to catch SQLAlchemy specific
    exceptions.
  id: totrans-1450
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL 方言现在将禁用 `ConnectionEvents.handle_error()` 事件，以防止这些语句触发用于内部检测表是否存在的事件。这是通过使用一个执行选项
    `skip_user_error_events` 实现的，该选项在该执行范围内禁用了处理错误事件。这样，重写异常的用户代码不需要担心 MySQL 方言或其他偶尔需要捕获
    SQLAlchemy 特定异常的方言。
- en: Changed the default value of `raise_on_warnings` for MySQL-Connector
  id: totrans-1451
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更改了 MySQL-Connector 的 `raise_on_warnings` 的默认值
- en: Changed the default value of “raise_on_warnings” to False for MySQL-Connector.
    This was set at True for some reason. The “buffered” flag unfortunately must stay
    at True as MySQLconnector does not allow a cursor to be closed unless all results
    are fully fetched.
  id: totrans-1452
  prefs: []
  type: TYPE_NORMAL
  zh: 将 MySQL-Connector 的 “raise_on_warnings” 的默认值更改为 False。出于某种原因，它被设置为 True。不幸的是，“buffered”
    标志必须保持为 True，因为 MySQLconnector 不允许关闭游标，除非所有结果都被完全获取。
- en: '[#2515](https://www.sqlalchemy.org/trac/ticket/2515)'
  id: totrans-1453
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2515](https://www.sqlalchemy.org/trac/ticket/2515)'
- en: '### MySQL boolean symbols “true”, “false” work again'
  id: totrans-1454
  prefs: []
  type: TYPE_NORMAL
  zh: '### MySQL 布尔符号“true”、“false”再次有效'
- en: 0.9’s overhaul of the IS/IS NOT operators as well as boolean types in [#2682](https://www.sqlalchemy.org/trac/ticket/2682)
    disallowed the MySQL dialect from making use of the “true” and “false” symbols
    in the context of “IS” / “IS NOT”. Apparently, even though MySQL has no “boolean”
    type, it supports IS / IS NOT when the special “true” and “false” symbols are
    used, even though these are otherwise synonymous with “1” and “0” (and IS/IS NOT
    don’t work with the numerics).
  id: totrans-1455
  prefs: []
  type: TYPE_NORMAL
  zh: 0.9 版本对 IS/IS NOT 操作符以及 [#2682](https://www.sqlalchemy.org/trac/ticket/2682)
    中的布尔类型进行了彻底改造，禁止 MySQL 方言在“IS”/“IS NOT”的上下文中使用“true”和“false”符号。显然，即使 MySQL 没有“布尔”类型，但当使用特殊的“true”和“false”符号时，它支持
    IS/IS NOT，尽管这些符号在其他情况下与“1”和“0”是同义词（并且 IS/IS NOT 与数字不兼容）。
- en: So the change here is that the MySQL dialect remains “non native boolean”, but
    the [`true()`](../core/sqlelement.html#sqlalchemy.sql.expression.true "sqlalchemy.sql.expression.true")
    and [`false()`](../core/sqlelement.html#sqlalchemy.sql.expression.false "sqlalchemy.sql.expression.false")
    symbols again produce the keywords “true” and “false”, so that an expression like
    `column.is_(true())` again works on MySQL.
  id: totrans-1456
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这里的更改是 MySQL 方言仍然是“非本地布尔”，但 [`true()`](../core/sqlelement.html#sqlalchemy.sql.expression.true
    "sqlalchemy.sql.expression.true") 和 [`false()`](../core/sqlelement.html#sqlalchemy.sql.expression.false
    "sqlalchemy.sql.expression.false") 符号再次生成关键字“true”和“false”，因此像 `column.is_(true())`
    这样的表达式再次在 MySQL 上起作用。
- en: '[#3186](https://www.sqlalchemy.org/trac/ticket/3186)  ### The match() operator
    now returns an agnostic MatchType compatible with MySQL’s floating point return
    value'
  id: totrans-1457
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3186](https://www.sqlalchemy.org/trac/ticket/3186)  ### `match()` 操作符现在返回与
    MySQL 浮点返回值兼容的不可知 MatchType'
- en: The return type of a [`ColumnOperators.match()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.match
    "sqlalchemy.sql.expression.ColumnOperators.match") expression is now a new type
    called [`MatchType`](../core/type_basics.html#sqlalchemy.types.MatchType "sqlalchemy.types.MatchType").
    This is a subclass of [`Boolean`](../core/type_basics.html#sqlalchemy.types.Boolean
    "sqlalchemy.types.Boolean"), that can be intercepted by the dialect in order to
    produce a different result type at SQL execution time.
  id: totrans-1458
  prefs: []
  type: TYPE_NORMAL
  zh: '[`ColumnOperators.match()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.match
    "sqlalchemy.sql.expression.ColumnOperators.match")表达式的返回类型现在是一个称为[`MatchType`](../core/type_basics.html#sqlalchemy.types.MatchType
    "sqlalchemy.types.MatchType")的新类型。这是[`Boolean`](../core/type_basics.html#sqlalchemy.types.Boolean
    "sqlalchemy.types.Boolean")的子类，可以被方言拦截，以在SQL执行时产生不同的结果类型。'
- en: 'Code like the following will now function correctly and return floating points
    on MySQL:'
  id: totrans-1459
  prefs: []
  type: TYPE_NORMAL
  zh: 类似以下代码现在将在MySQL上正确运行并返回浮点数：
- en: '[PRE384]'
  id: totrans-1460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE384]'
- en: '[#3263](https://www.sqlalchemy.org/trac/ticket/3263)  ### Drizzle Dialect is
    now an External Dialect'
  id: totrans-1461
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3263](https://www.sqlalchemy.org/trac/ticket/3263)  ### Drizzle Dialect is
    now an External Dialect'
- en: 'The dialect for [Drizzle](https://www.drizzle.org/) is now an external dialect,
    available at [https://bitbucket.org/zzzeek/sqlalchemy-drizzle](https://bitbucket.org/zzzeek/sqlalchemy-drizzle).
    This dialect was added to SQLAlchemy right before SQLAlchemy was able to accommodate
    third party dialects well; going forward, all databases that aren’t within the
    “ubiquitous use” category are third party dialects. The dialect’s implementation
    hasn’t changed and is still based on the MySQL + MySQLdb dialects within SQLAlchemy.
    The dialect is as of yet unreleased and in “attic” status; however it passes the
    majority of tests and is generally in decent working order, if someone wants to
    pick up on polishing it.  ### MySQL TIMESTAMP Type now renders NULL / NOT NULL
    in all cases'
  id: totrans-1462
  prefs: []
  type: TYPE_NORMAL
  zh: '[Drizzle](https://www.drizzle.org/)的方言现在是一个外部方言，可在[https://bitbucket.org/zzzeek/sqlalchemy-drizzle](https://bitbucket.org/zzzeek/sqlalchemy-drizzle)上找到。这个方言是在SQLAlchemy能够很好地适应第三方方言之前添加到SQLAlchemy的；未来，所有不属于“普遍使用”类别的数据库都是第三方方言。该方言的实现没有改变，仍然基于SQLAlchemy中的MySQL
    + MySQLdb方言。该方言目前尚未发布，处于“attic”状态；但是它通过了大部分测试，一般工作正常，如果有人想要继续完善它的话。  ### MySQL
    TIMESTAMP Type now renders NULL / NOT NULL in all cases'
- en: The MySQL dialect has always worked around MySQL’s implicit NOT NULL default
    associated with TIMESTAMP columns by emitting NULL for such a type, if the column
    is set up with `nullable=True`. However, MySQL 5.6.6 and above features a new
    flag [explicit_defaults_for_timestamp](https://dev.mysql.com/doc/refman/5.6/en/server-system-variables.html#sysvar_explicit_defaults_for_timestamp)
    which repairs MySQL’s non-standard behavior to make it behave like any other type;
    to accommodate this, SQLAlchemy now emits NULL/NOT NULL unconditionally for all
    TIMESTAMP columns.
  id: totrans-1463
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL方言一直通过在`nullable=True`的情况下为TIMESTAMP列发出NULL来解决MySQL隐式NOT NULL默认值的问题。然而，MySQL
    5.6.6及以上版本引入了一个新标志[explicit_defaults_for_timestamp](https://dev.mysql.com/doc/refman/5.6/en/server-system-variables.html#sysvar_explicit_defaults_for_timestamp)，修复了MySQL的非标准行为，使其表现得像任何其他类型；为了适应这一点，SQLAlchemy现在无条件地为所有TIMESTAMP列发出NULL/NOT
    NULL。
- en: See also
  id: totrans-1464
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参见
- en: '[TIMESTAMP Columns and NULL](../dialects/mysql.html#mysql-timestamp-null)'
  id: totrans-1465
  prefs: []
  type: TYPE_NORMAL
  zh: '[TIMESTAMP Columns and NULL](../dialects/mysql.html#mysql-timestamp-null)'
- en: '[#3155](https://www.sqlalchemy.org/trac/ticket/3155)'
  id: totrans-1466
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3155](https://www.sqlalchemy.org/trac/ticket/3155)'
- en: '### MySQL SET Type Overhauled to support empty sets, unicode, blank value handling'
  id: totrans-1467
  prefs: []
  type: TYPE_NORMAL
  zh: '### MySQL SET Type Overhauled to support empty sets, unicode, blank value handling'
- en: The [`SET`](../dialects/mysql.html#sqlalchemy.dialects.mysql.SET "sqlalchemy.dialects.mysql.SET")
    type historically not included a system of handling blank sets and empty values
    separately; as different drivers had different behaviors for treatment of empty
    strings and empty-string-set representations, the SET type tried only to hedge
    between these behaviors, opting to treat the empty set as `set([''])` as is still
    the current behavior for the MySQL-Connector-Python DBAPI. Part of the rationale
    here was that it was otherwise impossible to actually store a blank string within
    a MySQL SET, as the driver gives us back strings with no way to discern between
    `set([''])` and `set()`. It was left to the user to determine if `set([''])` actually
    meant “empty set” or not.
  id: totrans-1468
  prefs: []
  type: TYPE_NORMAL
  zh: '[`SET`](../dialects/mysql.html#sqlalchemy.dialects.mysql.SET "sqlalchemy.dialects.mysql.SET")类型历史上不包括处理空集和空值的系统；由于不同的驱动程序对空字符串和空字符串集表示的处理方式不同，因此
    SET 类型仅尝试在这些行为之间做出取舍，选择将空集视为`set([''''])`，这仍然是 MySQL-Connector-Python DBAPI 的当前行为。这样做的部分原因是，否则无法实际在
    MySQL SET 中存储空字符串，因为驱动程序返回的字符串没有办法区分`set([''''])`和`set()`之间的区别。用户需要确定`set([''''])`是否实际上表示“空集”。'
- en: 'The new behavior moves the use case for the blank string, which is an unusual
    case that isn’t even documented in MySQL’s documentation, into a special case,
    and the default behavior of [`SET`](../dialects/mysql.html#sqlalchemy.dialects.mysql.SET
    "sqlalchemy.dialects.mysql.SET") is now:'
  id: totrans-1469
  prefs: []
  type: TYPE_NORMAL
  zh: 新行为将空字符串的使用情况移至一个特殊情况，这是一个不常见的情况，甚至在 MySQL 的文档中也没有记录，而[`SET`](../dialects/mysql.html#sqlalchemy.dialects.mysql.SET
    "sqlalchemy.dialects.mysql.SET")的默认行为现在是：
- en: to treat the empty string `''` as returned by MySQL-python into the empty set
    `set()`;
  id: totrans-1470
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将由 MySQL-python 返回的空字符串`''`视为空集`set()`；
- en: to convert the single-blank value set `set([''])` returned by MySQL-Connector-Python
    into the empty set `set()`;
  id: totrans-1471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 MySQL-Connector-Python 返回的单个空值集`set([''])`转换为空集`set()`。
- en: To handle the case of a set type that actually wishes includes the blank value
    `''` in its list of possible values, a new feature (required in this use case)
    is implemented whereby the set value is persisted and loaded as a bitwise integer
    value; the flag [`SET.retrieve_as_bitwise`](../dialects/mysql.html#sqlalchemy.dialects.mysql.SET.params.retrieve_as_bitwise
    "sqlalchemy.dialects.mysql.SET") is added in order to enable this.
  id: totrans-1472
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了处理实际希望在其可能值列表中包含空值`''`的集合类型的情况，实现了一个新特性（在此用例中需要），即集合值被持久化并作为位整数值加载；添加了标志[`SET.retrieve_as_bitwise`](../dialects/mysql.html#sqlalchemy.dialects.mysql.SET.params.retrieve_as_bitwise
    "sqlalchemy.dialects.mysql.SET")以启用此功能。
- en: Using the [`SET.retrieve_as_bitwise`](../dialects/mysql.html#sqlalchemy.dialects.mysql.SET.params.retrieve_as_bitwise
    "sqlalchemy.dialects.mysql.SET") flag allows the set to be persisted and retrieved
    with no ambiguity of values. Theoretically this flag can be turned on in all cases,
    as long as the given list of values to the type matches the ordering exactly as
    declared in the database; it only makes the SQL echo output a bit more unusual.
  id: totrans-1473
  prefs: []
  type: TYPE_NORMAL
  zh: 使用标志[`SET.retrieve_as_bitwise`](../dialects/mysql.html#sqlalchemy.dialects.mysql.SET.params.retrieve_as_bitwise
    "sqlalchemy.dialects.mysql.SET")允许集合被持久化和检索而没有值的歧义。从理论上讲，只要类型的给定值列表与数据库中声明的顺序完全匹配，就可以在所有情况下打开此标志；它只会使
    SQL 回显输出略显不同寻常。
- en: The default behavior of [`SET`](../dialects/mysql.html#sqlalchemy.dialects.mysql.SET
    "sqlalchemy.dialects.mysql.SET") otherwise remains the same, roundtripping values
    using strings. The string-based behavior now supports unicode fully including
    MySQL-python with use_unicode=0.
  id: totrans-1474
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，[`SET`](../dialects/mysql.html#sqlalchemy.dialects.mysql.SET "sqlalchemy.dialects.mysql.SET")的默认行为保持不变，使用字符串往返值。基于字符串的行为现在完全支持
    Unicode，包括 MySQL-python，并且使用`use_unicode=0`。
- en: '[#3283](https://www.sqlalchemy.org/trac/ticket/3283)'
  id: totrans-1475
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3283](https://www.sqlalchemy.org/trac/ticket/3283)'
- en: MySQL internal “no such table” exceptions not passed to event handlers
  id: totrans-1476
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: MySQL 内部的“无此表”异常不会传递给事件处理程序。
- en: The MySQL dialect will now disable `ConnectionEvents.handle_error()` events
    from firing for those statements which it uses internally to detect if a table
    exists or not. This is achieved using an execution option `skip_user_error_events`
    that disables the handle error event for the scope of that execution. In this
    way, user code that rewrites exceptions doesn’t need to worry about the MySQL
    dialect or other dialects that occasionally need to catch SQLAlchemy specific
    exceptions.
  id: totrans-1477
  prefs: []
  type: TYPE_NORMAL
  zh: MySQL 方言现在将禁用 `ConnectionEvents.handle_error()` 事件对内部用于检测表是否存在的语句触发。这是通过使用一个执行选项
    `skip_user_error_events` 来实现的，该选项在该执行范围内禁用了处理错误事件。这样，重写异常的用户代码不需要担心 MySQL 方言或其他偶尔需要捕获
    SQLAlchemy 特定异常的方言。
- en: Changed the default value of `raise_on_warnings` for MySQL-Connector
  id: totrans-1478
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更改了 MySQL-Connector 的 `raise_on_warnings` 默认值
- en: Changed the default value of “raise_on_warnings” to False for MySQL-Connector.
    This was set at True for some reason. The “buffered” flag unfortunately must stay
    at True as MySQLconnector does not allow a cursor to be closed unless all results
    are fully fetched.
  id: totrans-1479
  prefs: []
  type: TYPE_NORMAL
  zh: 将 MySQL-Connector 的“raise_on_warnings”默认值更改为 False。由于某种原因，这被设置为 True。不幸的是，“buffered”
    标志必须保持为 True，因为 MySQLconnector 不允许关闭游标，除非所有结果都被完全获取。
- en: '[#2515](https://www.sqlalchemy.org/trac/ticket/2515)'
  id: totrans-1480
  prefs: []
  type: TYPE_NORMAL
  zh: '[#2515](https://www.sqlalchemy.org/trac/ticket/2515)'
- en: '### MySQL boolean symbols “true”, “false” work again'
  id: totrans-1481
  prefs: []
  type: TYPE_NORMAL
  zh: '### MySQL 布尔符号“true”、“false”再次生效'
- en: 0.9’s overhaul of the IS/IS NOT operators as well as boolean types in [#2682](https://www.sqlalchemy.org/trac/ticket/2682)
    disallowed the MySQL dialect from making use of the “true” and “false” symbols
    in the context of “IS” / “IS NOT”. Apparently, even though MySQL has no “boolean”
    type, it supports IS / IS NOT when the special “true” and “false” symbols are
    used, even though these are otherwise synonymous with “1” and “0” (and IS/IS NOT
    don’t work with the numerics).
  id: totrans-1482
  prefs: []
  type: TYPE_NORMAL
  zh: 0.9 版本对 IS/IS NOT 操作符以及布尔类型的改进在 [#2682](https://www.sqlalchemy.org/trac/ticket/2682)
    中禁止了 MySQL 方言在“IS”/“IS NOT”上使用“true”和“false”符号。显然，即使 MySQL 没有“布尔”类型，但在使用特殊的“true”和“false”符号时，它支持
    IS/IS NOT，尽管这些符号在其他情况下与“1”和“0”是同义的（并且 IS/IS NOT 不能与数字一起使用）。
- en: So the change here is that the MySQL dialect remains “non native boolean”, but
    the [`true()`](../core/sqlelement.html#sqlalchemy.sql.expression.true "sqlalchemy.sql.expression.true")
    and [`false()`](../core/sqlelement.html#sqlalchemy.sql.expression.false "sqlalchemy.sql.expression.false")
    symbols again produce the keywords “true” and “false”, so that an expression like
    `column.is_(true())` again works on MySQL.
  id: totrans-1483
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的变化是 MySQL 方言仍然保持“非本地布尔”，但 [`true()`](../core/sqlelement.html#sqlalchemy.sql.expression.true
    "sqlalchemy.sql.expression.true") 和 [`false()`](../core/sqlelement.html#sqlalchemy.sql.expression.false
    "sqlalchemy.sql.expression.false") 符号再次产生关键字“true”和“false”，因此像 `column.is_(true())`
    这样的表达式在 MySQL 上再次生效。
- en: '[#3186](https://www.sqlalchemy.org/trac/ticket/3186)'
  id: totrans-1484
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3186](https://www.sqlalchemy.org/trac/ticket/3186)'
- en: '### The match() operator now returns an agnostic MatchType compatible with
    MySQL’s floating point return value'
  id: totrans-1485
  prefs: []
  type: TYPE_NORMAL
  zh: '### `match()` 操作符现在返回一个与 MySQL 浮点返回值兼容的不可知的 MatchType'
- en: The return type of a [`ColumnOperators.match()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.match
    "sqlalchemy.sql.expression.ColumnOperators.match") expression is now a new type
    called [`MatchType`](../core/type_basics.html#sqlalchemy.types.MatchType "sqlalchemy.types.MatchType").
    This is a subclass of [`Boolean`](../core/type_basics.html#sqlalchemy.types.Boolean
    "sqlalchemy.types.Boolean"), that can be intercepted by the dialect in order to
    produce a different result type at SQL execution time.
  id: totrans-1486
  prefs: []
  type: TYPE_NORMAL
  zh: '[`ColumnOperators.match()`](../core/sqlelement.html#sqlalchemy.sql.expression.ColumnOperators.match
    "sqlalchemy.sql.expression.ColumnOperators.match") 表达式的返回类型现在是一个称为 [`MatchType`](../core/type_basics.html#sqlalchemy.types.MatchType
    "sqlalchemy.types.MatchType") 的新类型。这是 [`Boolean`](../core/type_basics.html#sqlalchemy.types.Boolean
    "sqlalchemy.types.Boolean") 的子类，可以被方言拦截以在 SQL 执行时产生不同的结果类型。'
- en: 'Code like the following will now function correctly and return floating points
    on MySQL:'
  id: totrans-1487
  prefs: []
  type: TYPE_NORMAL
  zh: 类似以下代码现在将正确运行并在 MySQL 上返回浮点数：
- en: '[PRE385]'
  id: totrans-1488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE385]'
- en: '[#3263](https://www.sqlalchemy.org/trac/ticket/3263)'
  id: totrans-1489
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3263](https://www.sqlalchemy.org/trac/ticket/3263)'
- en: '### Drizzle Dialect is now an External Dialect'
  id: totrans-1490
  prefs: []
  type: TYPE_NORMAL
  zh: '### Drizzle 方言现在是外部方言'
- en: The dialect for [Drizzle](https://www.drizzle.org/) is now an external dialect,
    available at [https://bitbucket.org/zzzeek/sqlalchemy-drizzle](https://bitbucket.org/zzzeek/sqlalchemy-drizzle).
    This dialect was added to SQLAlchemy right before SQLAlchemy was able to accommodate
    third party dialects well; going forward, all databases that aren’t within the
    “ubiquitous use” category are third party dialects. The dialect’s implementation
    hasn’t changed and is still based on the MySQL + MySQLdb dialects within SQLAlchemy.
    The dialect is as of yet unreleased and in “attic” status; however it passes the
    majority of tests and is generally in decent working order, if someone wants to
    pick up on polishing it.
  id: totrans-1491
  prefs: []
  type: TYPE_NORMAL
  zh: '[Drizzle](https://www.drizzle.org/) 的方言现在是一个外部方言，可在 [https://bitbucket.org/zzzeek/sqlalchemy-drizzle](https://bitbucket.org/zzzeek/sqlalchemy-drizzle)
    上获得。这个方言是在 SQLAlchemy 能够很好地适应第三方方言之前添加到 SQLAlchemy 的；未来，所有不属于“普遍使用”类别的数据库都是第三方方言。方言的实现没有改变，仍然基于
    SQLAlchemy 中的 MySQL + MySQLdb 方言。该方言尚未发布，处于“attic”状态；但是它通过了大部分测试，通常工作正常，如果有人想要继续完善它。'
- en: Dialect Improvements and Changes - SQLite
  id: totrans-1492
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方言改进和更改 - SQLite
- en: SQLite named and unnamed UNIQUE and FOREIGN KEY constraints will inspect and
    reflect
  id: totrans-1493
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SQLite 命名和未命名的 UNIQUE 和 FOREIGN KEY 约束将进行检查和反映
- en: UNIQUE and FOREIGN KEY constraints are now fully reflected on SQLite both with
    and without names. Previously, foreign key names were ignored and unnamed unique
    constraints were skipped. In particular this will help with Alembic’s new SQLite
    migration features.
  id: totrans-1494
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SQLite 上，现在完全反映了具有和不具有名称的 UNIQUE 和 FOREIGN KEY 约束。以前，外键名称被忽略，未命名的唯一约束被跳过。特别是这将有助于
    Alembic 的新 SQLite 迁移功能。
- en: To achieve this, for both foreign keys and unique constraints, the result of
    PRAGMA foreign_keys, index_list, and index_info is combined with regular expression
    parsing of the CREATE TABLE statement overall to form a complete picture of the
    names of constraints, as well as differentiating UNIQUE constraints that were
    created as UNIQUE vs. unnamed INDEXes.
  id: totrans-1495
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，对于外键和唯一约束，PRAGMA foreign_keys、index_list 和 index_info 的结果与对 CREATE TABLE
    语句的正则表达式解析相结合，以形成对约束名称的完整了解，以及区分作为 UNIQUE 创建的 UNIQUE 约束与未命名的 INDEX。
- en: '[#3244](https://www.sqlalchemy.org/trac/ticket/3244)'
  id: totrans-1496
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3244](https://www.sqlalchemy.org/trac/ticket/3244)'
- en: '[#3261](https://www.sqlalchemy.org/trac/ticket/3261)'
  id: totrans-1497
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3261](https://www.sqlalchemy.org/trac/ticket/3261)'
- en: SQLite named and unnamed UNIQUE and FOREIGN KEY constraints will inspect and
    reflect
  id: totrans-1498
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SQLite 命名和未命名的 UNIQUE 和 FOREIGN KEY 约束将进行检查和反映
- en: UNIQUE and FOREIGN KEY constraints are now fully reflected on SQLite both with
    and without names. Previously, foreign key names were ignored and unnamed unique
    constraints were skipped. In particular this will help with Alembic’s new SQLite
    migration features.
  id: totrans-1499
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SQLite 上，现在完全反映了具有和不具有名称的 UNIQUE 和 FOREIGN KEY 约束。以前，外键名称被忽略，未命名的唯一约束被跳过。特别是这将有助于
    Alembic 的新 SQLite 迁移功能。
- en: To achieve this, for both foreign keys and unique constraints, the result of
    PRAGMA foreign_keys, index_list, and index_info is combined with regular expression
    parsing of the CREATE TABLE statement overall to form a complete picture of the
    names of constraints, as well as differentiating UNIQUE constraints that were
    created as UNIQUE vs. unnamed INDEXes.
  id: totrans-1500
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，对于外键和唯一约束，PRAGMA foreign_keys、index_list 和 index_info 的结果与对 CREATE TABLE
    语句的正则表达式解析相结合，以形成对约束名称的完整了解，以及区分作为 UNIQUE 创建的 UNIQUE 约束与未命名的 INDEX。
- en: '[#3244](https://www.sqlalchemy.org/trac/ticket/3244)'
  id: totrans-1501
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3244](https://www.sqlalchemy.org/trac/ticket/3244)'
- en: '[#3261](https://www.sqlalchemy.org/trac/ticket/3261)'
  id: totrans-1502
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3261](https://www.sqlalchemy.org/trac/ticket/3261)'
- en: Dialect Improvements and Changes - SQL Server
  id: totrans-1503
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方言改进和更改 - SQL Server
- en: '### PyODBC driver name is required with hostname-based SQL Server connections'
  id: totrans-1504
  prefs: []
  type: TYPE_NORMAL
  zh: '### 需要在基于主机名的 SQL Server 连接中提供 PyODBC 驱动程序名称'
- en: 'Connecting to SQL Server with PyODBC using a DSN-less connection, e.g. with
    an explicit hostname, now requires a driver name - SQLAlchemy will no longer attempt
    to guess a default:'
  id: totrans-1505
  prefs: []
  type: TYPE_NORMAL
  zh: 使用无 DSN 连接的 PyODBC 连接到 SQL Server，例如使用显式主机名，现在需要提供驱动程序名称 - SQLAlchemy 将不再尝试猜测默认值：
- en: '[PRE386]'
  id: totrans-1506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE386]'
- en: SQLAlchemy’s previously hardcoded default of “SQL Server” is obsolete on Windows,
    and SQLAlchemy cannot be tasked with guessing the best driver based on operation
    system/driver detection. Using a DSN is always preferred when using ODBC to avoid
    this issue entirely.
  id: totrans-1507
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 在 Windows 上以前硬编码的默认值“SQL Server”已经过时，SQLAlchemy 不能根据操作系统/驱动程序检测来猜测最佳驱动程序。在使用
    ODBC 时，始终首选使用 DSN 来避免这个问题。
- en: '[#3182](https://www.sqlalchemy.org/trac/ticket/3182)'
  id: totrans-1508
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3182](https://www.sqlalchemy.org/trac/ticket/3182)'
- en: SQL Server 2012 large text / binary types render as VARCHAR, NVARCHAR, VARBINARY
  id: totrans-1509
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SQL Server 2012 大型文本/二进制类型呈现为 VARCHAR、NVARCHAR、VARBINARY
- en: The rendering of the [`TextClause`](../core/sqlelement.html#sqlalchemy.sql.expression.TextClause
    "sqlalchemy.sql.expression.TextClause"), [`UnicodeText`](../core/type_basics.html#sqlalchemy.types.UnicodeText
    "sqlalchemy.types.UnicodeText"), and [`LargeBinary`](../core/type_basics.html#sqlalchemy.types.LargeBinary
    "sqlalchemy.types.LargeBinary") types has been changed for SQL Server 2012 and
    greater, with options to control the behavior completely, based on deprecation
    guidelines from Microsoft. See [Large Text/Binary Type Deprecation](../dialects/mssql.html#mssql-large-type-deprecation)
    for details.
  id: totrans-1510
  prefs: []
  type: TYPE_NORMAL
  zh: SQL Server 2012 及更高版本的 [`TextClause`](../core/sqlelement.html#sqlalchemy.sql.expression.TextClause
    "sqlalchemy.sql.expression.TextClause")、[`UnicodeText`](../core/type_basics.html#sqlalchemy.types.UnicodeText
    "sqlalchemy.types.UnicodeText") 和 [`LargeBinary`](../core/type_basics.html#sqlalchemy.types.LargeBinary
    "sqlalchemy.types.LargeBinary") 类型的呈现已更改，完全控制行为的选项，基于微软的弃用指南。详情请参阅 [大型文本/二进制类型弃用](../dialects/mssql.html#mssql-large-type-deprecation)。
- en: '### PyODBC driver name is required with hostname-based SQL Server connections'
  id: totrans-1511
  prefs: []
  type: TYPE_NORMAL
  zh: '### 在基于主机名的 SQL Server 连接中需要 PyODBC 驱动程序名称'
- en: 'Connecting to SQL Server with PyODBC using a DSN-less connection, e.g. with
    an explicit hostname, now requires a driver name - SQLAlchemy will no longer attempt
    to guess a default:'
  id: totrans-1512
  prefs: []
  type: TYPE_NORMAL
  zh: 使用无 DSN 连接的方式连接到 SQL Server，例如使用显式主机名，现在需要驱动程序名称 - SQLAlchemy 不再尝试猜测默认值：
- en: '[PRE387]'
  id: totrans-1513
  prefs: []
  type: TYPE_PRE
  zh: '[PRE387]'
- en: SQLAlchemy’s previously hardcoded default of “SQL Server” is obsolete on Windows,
    and SQLAlchemy cannot be tasked with guessing the best driver based on operation
    system/driver detection. Using a DSN is always preferred when using ODBC to avoid
    this issue entirely.
  id: totrans-1514
  prefs: []
  type: TYPE_NORMAL
  zh: SQLAlchemy 在 Windows 上先前固定的默认值“SQL Server”已经过时，不能根据操作系统/驱动程序检测猜测最佳驱动程序。使用 DSN
    总是首选，以避免此问题。
- en: '[#3182](https://www.sqlalchemy.org/trac/ticket/3182)'
  id: totrans-1515
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3182](https://www.sqlalchemy.org/trac/ticket/3182)'
- en: SQL Server 2012 large text / binary types render as VARCHAR, NVARCHAR, VARBINARY
  id: totrans-1516
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SQL Server 2012 大型文本/二进制类型呈现为 VARCHAR、NVARCHAR、VARBINARY
- en: The rendering of the [`TextClause`](../core/sqlelement.html#sqlalchemy.sql.expression.TextClause
    "sqlalchemy.sql.expression.TextClause"), [`UnicodeText`](../core/type_basics.html#sqlalchemy.types.UnicodeText
    "sqlalchemy.types.UnicodeText"), and [`LargeBinary`](../core/type_basics.html#sqlalchemy.types.LargeBinary
    "sqlalchemy.types.LargeBinary") types has been changed for SQL Server 2012 and
    greater, with options to control the behavior completely, based on deprecation
    guidelines from Microsoft. See [Large Text/Binary Type Deprecation](../dialects/mssql.html#mssql-large-type-deprecation)
    for details.
  id: totrans-1517
  prefs: []
  type: TYPE_NORMAL
  zh: SQL Server 2012 及更高版本的 [`TextClause`](../core/sqlelement.html#sqlalchemy.sql.expression.TextClause
    "sqlalchemy.sql.expression.TextClause")、[`UnicodeText`](../core/type_basics.html#sqlalchemy.types.UnicodeText
    "sqlalchemy.types.UnicodeText") 和 [`LargeBinary`](../core/type_basics.html#sqlalchemy.types.LargeBinary
    "sqlalchemy.types.LargeBinary") 类型的呈现已更改，完全控制行为的选项，基于微软的弃用指南。详情请参阅 [大型文本/二进制类型弃用](../dialects/mssql.html#mssql-large-type-deprecation)。
- en: Dialect Improvements and Changes - Oracle
  id: totrans-1518
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Oracle 方言的改进和变化 - Oracle
- en: '### Improved support for CTEs in Oracle'
  id: totrans-1519
  prefs: []
  type: TYPE_NORMAL
  zh: '### Oracle 中 CTE 的改进支持'
- en: 'CTE support has been fixed up for Oracle, and there is also a new feature `CTE.with_suffixes()`
    that can assist with Oracle’s special directives:'
  id: totrans-1520
  prefs: []
  type: TYPE_NORMAL
  zh: Oracle 的 CTE 支持已经修复，并且还有一个新功能 `CTE.with_suffixes()` 可以帮助处理 Oracle 的特殊指令：
- en: '[PRE388]'
  id: totrans-1521
  prefs: []
  type: TYPE_PRE
  zh: '[PRE388]'
- en: '[#3220](https://www.sqlalchemy.org/trac/ticket/3220)'
  id: totrans-1522
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3220](https://www.sqlalchemy.org/trac/ticket/3220)'
- en: New Oracle Keywords for DDL
  id: totrans-1523
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 新的 Oracle DDL 关键字
- en: 'Keywords such as COMPRESS, ON COMMIT, BITMAP:'
  id: totrans-1524
  prefs: []
  type: TYPE_NORMAL
  zh: 关键词如 COMPRESS、ON COMMIT、BITMAP：
- en: '[Oracle Table Options](../dialects/oracle.html#oracle-table-options)'
  id: totrans-1525
  prefs: []
  type: TYPE_NORMAL
  zh: '[Oracle 表选项](../dialects/oracle.html#oracle-table-options)'
- en: '[Oracle Specific Index Options](../dialects/oracle.html#oracle-index-options)'
  id: totrans-1526
  prefs: []
  type: TYPE_NORMAL
  zh: '[Oracle 特定索引选项](../dialects/oracle.html#oracle-index-options)'
- en: '### Improved support for CTEs in Oracle'
  id: totrans-1527
  prefs: []
  type: TYPE_NORMAL
  zh: '### Oracle 中 CTE 的改进支持'
- en: 'CTE support has been fixed up for Oracle, and there is also a new feature `CTE.with_suffixes()`
    that can assist with Oracle’s special directives:'
  id: totrans-1528
  prefs: []
  type: TYPE_NORMAL
  zh: Oracle 的 CTE 支持已经修复，并且还有一个新功能 `CTE.with_suffixes()` 可以帮助处理 Oracle 的特殊指令：
- en: '[PRE389]'
  id: totrans-1529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE389]'
- en: '[#3220](https://www.sqlalchemy.org/trac/ticket/3220)'
  id: totrans-1530
  prefs: []
  type: TYPE_NORMAL
  zh: '[#3220](https://www.sqlalchemy.org/trac/ticket/3220)'
- en: New Oracle Keywords for DDL
  id: totrans-1531
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 新的 Oracle DDL 关键字
- en: 'Keywords such as COMPRESS, ON COMMIT, BITMAP:'
  id: totrans-1532
  prefs: []
  type: TYPE_NORMAL
  zh: 关键词如 COMPRESS、ON COMMIT、BITMAP：
- en: '[Oracle Table Options](../dialects/oracle.html#oracle-table-options)'
  id: totrans-1533
  prefs: []
  type: TYPE_NORMAL
  zh: '[Oracle 表选项](../dialects/oracle.html#oracle-table-options)'
- en: '[Oracle Specific Index Options](../dialects/oracle.html#oracle-index-options)'
  id: totrans-1534
  prefs: []
  type: TYPE_NORMAL
  zh: '[Oracle 特定索引选项](../dialects/oracle.html#oracle-index-options)'
